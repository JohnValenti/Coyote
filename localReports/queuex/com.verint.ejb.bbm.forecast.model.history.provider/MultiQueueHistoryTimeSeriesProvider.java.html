<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MultiQueueHistoryTimeSeriesProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.model.history.provider</a> &gt; <span class="el_source">MultiQueueHistoryTimeSeriesProvider.java</span></div><h1>MultiQueueHistoryTimeSeriesProvider.java</h1><pre class="source lang-java linenums">package com.verint.ejb.bbm.forecast.model.history.provider;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.pulse.model.PulseNoteBO;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.verint.ejb.bbm.forecast.model.history.service.IHistoryDataService;
import com.verint.ejb.bbm.forecast.model.history.service.INotesDataService;

import java.util.*;

/**
 * Loads and caches history data for a set of queues.
 */
public class MultiQueueHistoryTimeSeriesProvider implements IHistoryProvider {

	private final Collection&lt;QueueHistoryTimeSeriesProvider&gt; constituentProviders;
	private final IHistoryDataService historyDataService;
	private final INotesDataService notesDataService;
	private final boolean useUnknownCallVolume;

<span class="nc" id="L26">	private Map&lt;TimeIntervalAtTime, TraceCube&gt; aggregatedHistoryByTimeIntervalAtTime = new HashMap&lt;TimeIntervalAtTime, TraceCube&gt;();</span>
<span class="nc" id="L27">	private Map&lt;DateRange, List&lt;Date&gt;&gt; cachedHistoryDays = new HashMap&lt;DateRange, List&lt;Date&gt;&gt;();</span>

	public MultiQueueHistoryTimeSeriesProvider(Collection&lt;QueueHistoryTimeSeriesProvider&gt; constituentProviders,
<span class="nc" id="L30">			IHistoryDataService historyDataService, INotesDataService notesDataService, boolean useUnknownCallVolume) {</span>
<span class="nc" id="L31">		this.constituentProviders = constituentProviders;</span>
<span class="nc" id="L32">		this.historyDataService = historyDataService;</span>
<span class="nc" id="L33">		this.notesDataService = notesDataService;</span>
<span class="nc" id="L34">		this.useUnknownCallVolume = useUnknownCallVolume;</span>
<span class="nc" id="L35">	}</span>

	@Override
	public TraceCube getHistory(TimeIntervalAtTime interval) throws BbmException {

<span class="nc bnc" id="L40" title="All 2 branches missed.">		if (aggregatedHistoryByTimeIntervalAtTime.get(interval) != null) {</span>
<span class="nc" id="L41">			return aggregatedHistoryByTimeIntervalAtTime.get(interval);</span>
		}

		//Find all constituent providers/queues that do NOT have history loaded for the given period
<span class="nc" id="L45">		Collection&lt;Queue&gt; queuesNeedingHistory = getQueuesThatNeedHistoryLoadedForPeriod(interval);</span>

<span class="nc bnc" id="L47" title="All 2 branches missed.">		if (!queuesNeedingHistory.isEmpty()) {</span>
			//Load bulk history for the queues that do NOT have it already loaded
<span class="nc" id="L49">			Map&lt;ID, ActualTraceCube&gt; historyForUnloadedQueues =</span>
<span class="nc" id="L50">					historyDataService.getHistory(queuesNeedingHistory, interval);</span>

			//Load bulk notes for the queues that do NOT have it already loaded
<span class="nc" id="L53">			Collection&lt;PulseNoteBO&gt; notesForUnloadedQueues = getNotesForUnloadedQueues(interval);</span>

			//Set individual notes/histories into constituent providers/mark as loaded
<span class="nc" id="L56">			cacheNotesForUnloadedQueues(notesForUnloadedQueues, interval);</span>
<span class="nc" id="L57">			cacheHistoryForUnloadedQueues(historyForUnloadedQueues, interval);</span>
		}

		//Aggregate history together, cache it
<span class="nc" id="L61">		ActualTraceCube aggregatedHistory = getAggregatedHistoryFromConstituentProviders(interval);</span>
<span class="nc" id="L62">		aggregatedHistoryByTimeIntervalAtTime.put(interval, aggregatedHistory);</span>
<span class="nc" id="L63">		return aggregatedHistory;</span>
	}

	@Override
	public Collection&lt;PulseNoteBO&gt; getNotes(TimeIntervalAtTime interval) throws BbmException {

<span class="nc" id="L69">		Collection&lt;PulseNoteBO&gt; notesForUnloadedQueues = getNotesForUnloadedQueues(interval);</span>
<span class="nc" id="L70">		cacheNotesForUnloadedQueues(notesForUnloadedQueues, interval);</span>
<span class="nc" id="L71">		return getNotesForAllQueues(interval);</span>
	}

	@Override
	public List&lt;Date&gt; getDaysWithHistory(Date start, Date end) throws BbmException {
<span class="nc" id="L76">		DateRange range = new DateRange(start, end);</span>

<span class="nc bnc" id="L78" title="All 2 branches missed.">		if (cachedHistoryDays.get(range) != null) {</span>
<span class="nc" id="L79">			return cachedHistoryDays.get(range);</span>
		}
		
<span class="nc" id="L82">		List&lt;Date&gt; daysWithHistory = historyDataService.getDaysWithHistory(getQueuesFromConstituentProviders(),</span>
				start, end);
<span class="nc" id="L84">		cachedHistoryDays.put(range, daysWithHistory);</span>
<span class="nc" id="L85">		return daysWithHistory;</span>
	}

	private Collection&lt;PulseNoteBO&gt; getNotesForUnloadedQueues(TimeIntervalAtTime interval) throws BbmException {

<span class="nc" id="L90">		return notesDataService.getNotes(getQueuesThatNeedNotesLoadedForPeriod(interval),</span>
<span class="nc" id="L91">				interval.getStartTime(), new Date(interval.getEndTime().getTime() - 1));</span>
	}

	private void cacheNotesForUnloadedQueues(Collection&lt;PulseNoteBO&gt; notesForUnloadedQueues, TimeIntervalAtTime interval) {

<span class="nc bnc" id="L96" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider constituentProvider : constituentProviders) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (!constituentProvider.isNotesLoadedForPeriod(interval)) {</span>
<span class="nc" id="L98">				Set&lt;PulseNoteBO&gt; notesForQueue = new HashSet&lt;PulseNoteBO&gt;();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">				for (PulseNoteBO noteToCache : notesForUnloadedQueues) {</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">					if (noteToCache.getQueues().containsKey(constituentProvider.getQueue().getID())) {</span>
<span class="nc" id="L101">						notesForQueue.add(noteToCache);</span>
					}
<span class="nc" id="L103">				}</span>
<span class="nc" id="L104">				constituentProvider.setNotesForPeriod(notesForQueue, interval);</span>
			}
<span class="nc" id="L106">		}</span>
<span class="nc" id="L107">	}</span>

	/**
	 * Loads the notes from all constituent providers for the given interval.
	 */
	private Collection&lt;PulseNoteBO&gt; getNotesForAllQueues(TimeIntervalAtTime interval) throws BbmException {

<span class="nc" id="L114">		Set&lt;PulseNoteBO&gt; notesFromAllQueues = new HashSet&lt;PulseNoteBO&gt;();</span>

<span class="nc bnc" id="L116" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider provider : constituentProviders) {</span>
<span class="nc" id="L117">			notesFromAllQueues.addAll(provider.getNotes(interval));</span>
<span class="nc" id="L118">		}</span>

<span class="nc" id="L120">		return notesFromAllQueues;</span>
	}

	private Collection&lt;Queue&gt; getQueuesThatNeedHistoryLoadedForPeriod(TimeIntervalAtTime interval) {
<span class="nc" id="L124">		Collection&lt;Queue&gt; queuesNeedingHistory = new ArrayList&lt;Queue&gt;();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider provider : constituentProviders) {</span>
<span class="nc bnc" id="L126" title="All 2 branches missed.">			if (!provider.isHistoryLoadedForPeriod(interval)) {</span>
<span class="nc" id="L127">				queuesNeedingHistory.add(provider.getQueue());</span>
			}
<span class="nc" id="L129">		}</span>

<span class="nc" id="L131">		return queuesNeedingHistory;</span>
	}

	private Collection&lt;ID&gt; getQueuesThatNeedNotesLoadedForPeriod(TimeIntervalAtTime interval) {
<span class="nc" id="L135">		Collection&lt;ID&gt; queuesNeedingNotes = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider provider : constituentProviders) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">			if (!provider.isNotesLoadedForPeriod(interval)) {</span>
<span class="nc" id="L138">				queuesNeedingNotes.add(provider.getQueue().getID());</span>
			}
<span class="nc" id="L140">		}</span>

<span class="nc" id="L142">		return queuesNeedingNotes;</span>
	}

	private void cacheHistoryForUnloadedQueues(Map&lt;ID, ActualTraceCube&gt; historyForUnloadedQueues,
			TimeIntervalAtTime interval) throws BbmException {

<span class="nc bnc" id="L148" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider constituentProvider : constituentProviders) {</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">			if (!constituentProvider.isHistoryLoadedForPeriod(interval)) {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">				for (ID queueId : historyForUnloadedQueues.keySet()) {</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">					if (queueId.equals(constituentProvider.getQueue().getID())) {</span>
<span class="nc" id="L152">						constituentProvider.setHistoryForPeriod(historyForUnloadedQueues.get(queueId), interval);</span>
					}
<span class="nc" id="L154">				}</span>
			}
<span class="nc" id="L156">		}</span>
<span class="nc" id="L157">	}</span>

	private ActualTraceCube getAggregatedHistoryFromConstituentProviders(TimeIntervalAtTime interval) throws BbmException {
<span class="nc" id="L160">		final Collection&lt;ActualTraceCube&gt; constituentHistory = new ArrayList&lt;ActualTraceCube&gt;(constituentProviders.size());</span>
<span class="nc" id="L161">		final Map&lt;ID, ID&gt; queueMediaMap = new HashMap&lt;ID, ID&gt;();</span>

<span class="nc bnc" id="L163" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider provider : constituentProviders) {</span>
<span class="nc" id="L164">			constituentHistory.add(provider.getHistory(interval));</span>
<span class="nc" id="L165">			queueMediaMap.put(provider.getQueue().getID(), provider.getQueue().getMediaID());</span>
<span class="nc" id="L166">		}</span>

<span class="nc" id="L168">		final ActualTraceCube aggregatedCube =</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				(ActualTraceCube)TraceOperator.combineQueue(constituentHistory.toArray(new ActualTraceCube[]{}),</span>
				!useUnknownCallVolume, queueMediaMap);
<span class="nc" id="L171">		return aggregatedCube;</span>
	}

	private Collection&lt;Queue&gt; getQueuesFromConstituentProviders() {
<span class="nc" id="L175">		Collection&lt;Queue&gt; constituentQueues = new ArrayList&lt;Queue&gt;();</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		for (QueueHistoryTimeSeriesProvider provider : constituentProviders) {</span>
<span class="nc" id="L177">			constituentQueues.add(provider.getQueue());</span>
<span class="nc" id="L178">		}</span>

<span class="nc" id="L180">		return constituentQueues;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>