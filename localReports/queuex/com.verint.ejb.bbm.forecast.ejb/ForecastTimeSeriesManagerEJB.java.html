<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ForecastTimeSeriesManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.ejb</a> &gt; <span class="el_source">ForecastTimeSeriesManagerEJB.java</span></div><h1>ForecastTimeSeriesManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * (c) 2009-2012 Verint Systems, Inc.
 */
package com.verint.ejb.bbm.forecast.ejb;

import com.bluepumpkin.common.datatypes.Duration;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.ejb.bbm.campaign.ejb.*;
import com.bluepumpkin.ejb.bbm.campaign.model.*;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.time.TimeContextFactory;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.*;
import com.bluepumpkin.ejb.bbm.timeseries.model.*;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.QueueDAO;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.MediaType;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueFieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.bbm.forecast.ForecastTraceCubeUtil;
import com.verint.ejb.bbm.forecast.ejb.calculator.ForecastCalculatorFactory;
import com.verint.ejb.bbm.forecast.ejb.calculator.IForecastCalculator;
import com.verint.ejb.bbm.forecast.model.*;
import com.verint.ejb.bbm.forecast.model.ProfileComponent.Type;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntry;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntryHistoryPeriod;
import com.verint.ejb.bbm.forecast.model.history.provider.HistoryProviderFactory;
import com.verint.ejb.bbm.forecast.model.history.provider.IHistoryProvider;
import com.verint.ejb.bbm.forecast.model.history.provider.OutboundHistoryProvider;
import com.verint.ejb.bbm.fterequirements.FteRequirementsUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.RemoteException;
import java.util.*;

/**
 * This session bean handles saving forecast data including active forecasts,
 * base forecasts, profiles, and instances, and loading and saving distributed
 * queue allocation data.
 * &lt;p&gt;
 * Most forecast data is loaded in {@link TimeSeriesManagerEJB}.
 */
@SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L67">public class ForecastTimeSeriesManagerEJB extends SessionEJBBase {</span>
	public static final int ALLOCATION_VALUES_PER_ROW = 96;
<span class="fc" id="L69">	private static Category m_cat = Log.initCategory(ForecastTimeSeriesManagerEJB.class.getName());</span>

	private TimeSeriesManager m_timeSeriesManager;
	private WorkloadManager m_workloadManager;
	private CampaignManager m_campaignManager;
	private ForecastTimeSeriesManager m_forecastTimeSeriesManager;
	private WorkloadManager workloadManager;
	private TimeSeriesManager timeSeriesManager;

<span class="fc" id="L78">	private boolean m_whatIfMode = false;</span>

	// Instance initializer.  Instance initializers are run after any superclass
	// constructors complete, and before any constructors in this class.
	{
<span class="fc" id="L83">		super.init(ForecastTimeSeriesManagerEJB.class.getName());</span>
	}

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L90">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L91">			Boolean WIF = (Boolean)initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">			if (WIF != null)</span>
<span class="fc" id="L93">				m_whatIfMode = WIF.booleanValue();</span>
<span class="fc" id="L94">			m_timeSeriesManager = WfmManagerFactory.getTimeSeriesManager(m_whatIfMode);</span>
<span class="fc" id="L95">			m_workloadManager = WfmManagerFactory.getWorkloadManager(m_whatIfMode);</span>
<span class="fc" id="L96">			m_campaignManager = WfmManagerFactory.getCampaignManager(m_whatIfMode);</span>
<span class="fc" id="L97">			m_forecastTimeSeriesManager = WfmManagerFactory.getForecastTimeSeriesManager(m_whatIfMode);</span>
<span class="fc" id="L98">			workloadManager = WfmManagerFactory.getWorkloadManager(m_whatIfMode);</span>
<span class="fc" id="L99">			timeSeriesManager = WfmManagerFactory.getTimeSeriesManager(m_whatIfMode);</span>
<span class="nc" id="L100">		} catch (Exception e) {</span>
<span class="nc" id="L101">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="fc" id="L102">		}</span>
<span class="fc" id="L103">	}</span>

	/**
	 * Returns a collection of forecast profile lists belonging to the given forecast profiles.  The map returned is
	 * keyed on the forecast profile ID, and the values in the map correspond to the forecast profile lists belonging
	 * to that profile.
	 */
	public Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; getForecastProfileListsByProfile(Collection&lt;ForecastProfile&gt; profiles)
			throws BbmFinderException {
<span class="fc" id="L112">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>
<span class="fc" id="L113">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; profileLists = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
		try {
<span class="fc bfc" id="L115" title="All 2 branches covered.">			for (ForecastProfile profile : profiles) {</span>
<span class="pc bpc" id="L116" title="1 of 2 branches missed.">				if (!profileLists.containsKey(profile.getID())) {</span>
<span class="fc" id="L117">					profileLists.put(profile.getID(), dao.getForecastProfileListsByForecastProfileID(profile.getStringID()));</span>
				} else {
<span class="nc" id="L119">					profileLists.get(profile.getID()).addAll(</span>
<span class="nc" id="L120">							dao.getForecastProfileListsByForecastProfileID(profile.getStringID()));</span>
				}
<span class="fc" id="L122">			}</span>
<span class="fc" id="L123">			return profileLists;</span>
		} finally {
<span class="pc" id="L125">			dao.cleanUp();</span>
		}
	}

	private ID getSPID(ID spQueueID) throws BbmFinderException {
<span class="fc" id="L130">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
		try {
<span class="fc" id="L132">			return spqDAO.getSPQueuesByIDs(Collections.singleton(spQueueID)).iterator().next().getSpID();</span>
		} finally {
<span class="pc" id="L134">			spqDAO.cleanUp();</span>
		}
	}

	// {{ ------------------- Start Forecast Profiles -------------------- //
	/**
	 * Saves a forecast profile object (including any profile components set on it) and the ProfileTimeSeries
	 * objects associated with this forecast profile.
	 *
	 * If the forecast profile already has an id, this method will do a db update. If not, it will do a create.
	 *
	 * If the forecast profile is named, this method will first remove any profiles with that name.
	 */
	public ID saveForecastProfile(ForecastProfile forecastProfile, Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection)
			throws BbmException {
<span class="fc" id="L149">		methodStart(&quot;saveForecastProfile&quot;, forecastProfile, timeSeriesCollection);</span>
<span class="fc" id="L150">		ProfileTimeSeriesDAO ptsDao = new ProfileTimeSeriesDAO();</span>

<span class="fc" id="L152">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L153">		ID retVal = null;</span>

		// Create ForecastProfile
<span class="fc" id="L156">		Collection&lt;ID&gt; fpIDs = saveForecastProfileRecords(Collections.singleton(forecastProfile));</span>
<span class="pc bpc" id="L157" title="2 of 4 branches missed.">		if (fpIDs != null &amp;&amp; fpIDs.isEmpty() == false) {</span>
<span class="fc" id="L158">			retVal = fpIDs.iterator().next();</span>
		}

		// Create ProfileTimeSeries
		try {
<span class="fc" id="L163">			Collection&lt;ProfileTimeSeries&gt; tsToCreate = new ArrayList&lt;ProfileTimeSeries&gt;();</span>
<span class="fc" id="L164">			Collection&lt;ProfileTimeSeries&gt; tsToUpdate = new ArrayList&lt;ProfileTimeSeries&gt;();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">			for (ProfileTimeSeries pts : timeSeriesCollection) {</span>
<span class="pc bpc" id="L166" title="3 of 4 branches missed.">				if (pts.getID() == null || pts.getID().equals(ValueObjectBase.m_nullObject)) {</span>
<span class="fc" id="L167">					tsToCreate.add(pts);</span>
<span class="fc" id="L168">					pts.setCreated(new Date());</span>
<span class="fc" id="L169">					pts.setCreatedBy(user);</span>
				} else {
<span class="nc" id="L171">					tsToUpdate.add(pts);</span>
<span class="nc" id="L172">					pts.setModified(new Date());</span>
<span class="nc" id="L173">					pts.setModifiedBy(user);</span>
				}
<span class="fc" id="L175">				pts.setForecastProfileID(forecastProfile.getID());</span>
<span class="fc" id="L176">			}</span>
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">			if (! tsToCreate.isEmpty()) ptsDao.createObjects(tsToCreate);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">			if (! tsToUpdate.isEmpty()) ptsDao.updateObjects(tsToUpdate);</span>
<span class="nc" id="L179">		} catch (Exception e) {</span>
<span class="nc" id="L180">			handleException(e);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L183">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L185">			ptsDao.cleanUp();</span>
<span class="pc" id="L186">			methodFinish();</span>
<span class="fc" id="L187">		}</span>
<span class="fc" id="L188">		return retVal;</span>
	}

	/**
	 * Saves a forecast profile for an outbound media queue, including the associated ProfileTimeSeries and
	 * ForecastProfileLists for the profile.
	 * @param forecastProfile - the ForecastProfile to persist in the database
	 * @param timeSeriesCollection -
	 * @param forecastProfileLists -
	 * @param type - ProfileComponent.Type, either Absolute or Relative
	 * @return the ID of the newly persisted ForecastProfile
	 */
	public ID saveOutboundForecastProfile(ForecastProfile forecastProfile,
			Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection, Collection&lt;ForecastProfileList&gt; forecastProfileLists,
			Date spWeekStartDate, Type type) throws BbmException {
<span class="nc" id="L203">		methodStart(&quot;saveOutboundForecastProfile&quot;, forecastProfile, timeSeriesCollection, forecastProfileLists);</span>

		ID newForecastProfileID;

		try {
<span class="nc" id="L208">			newForecastProfileID = saveForecastProfile(forecastProfile, timeSeriesCollection);</span>

			//If this is an absolute profile, then we need to adjust the start/end dates of the forecast
			//profile list so that they are adjusted relative to the start date of the current SP week.  Then,
			//when the profile is loaded into another SP week, the lists will be re-constituted with the same dates
			//relative to the start of the new SP week.
<span class="nc bnc" id="L214" title="All 6 branches missed.">			if (Type.Absolute.equals(type) &amp;&amp; forecastProfile.isModified() &amp;&amp;</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">					forecastProfileLists != null &amp;&amp; forecastProfileLists.size() &gt; 0) {</span>

<span class="nc bnc" id="L217" title="All 2 branches missed.">				for (ForecastProfileList fpl : forecastProfileLists) {</span>
<span class="nc" id="L218">					fpl.setProfileId(newForecastProfileID);</span>

<span class="nc" id="L220">					int daysBetweenFplAndSpWeek = TimeZoneUtil.numberOfDaysRound(spWeekStartDate, fpl.getStartTime());</span>
<span class="nc" id="L221">					int lengthOfFplInDays = TimeZoneUtil.numberOfDaysRound(fpl.getStartTime(), fpl.getEndTime());</span>

<span class="nc" id="L223">					Calendar fplStartDate = ForecastProfileList.getReferenceDateForManuallyModifiedProfiles();</span>
<span class="nc" id="L224">					fplStartDate.add(Calendar.DATE, daysBetweenFplAndSpWeek);</span>
<span class="nc" id="L225">					Calendar fplEndDate = (Calendar)fplStartDate.clone();</span>
<span class="nc" id="L226">					fplEndDate.add(Calendar.DATE, lengthOfFplInDays);</span>
<span class="nc" id="L227">					fpl.setStartTime(fplStartDate.getTime());</span>
<span class="nc" id="L228">					fpl.setEndTime(fplEndDate.getTime());</span>
<span class="nc" id="L229">				}</span>

<span class="nc" id="L231">				HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; profileListMap =</span>
						new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();
<span class="nc" id="L233">				profileListMap.put(newForecastProfileID, forecastProfileLists);</span>
<span class="nc" id="L234">				saveForecastProfileLists(profileListMap);</span>
			}
<span class="nc" id="L236">		} catch (BbmException e) {</span>
<span class="nc" id="L237">			handleException(e);</span>
<span class="nc" id="L238">			throw e;</span>
		} finally {
<span class="nc" id="L240">			methodFinish();</span>
<span class="nc" id="L241">		}</span>

<span class="nc" id="L243">		return newForecastProfileID;</span>
	}

	/**
	 * Saves the ForecastProfile record into the database. If the parameter already has an id set,
	 * it will do an update, if not, it will create.
	 * &lt;p&gt;
	 * This method will remove any existing Forecast Profile records from the database if they fill the
	 * same role and do not have the same id as the ForecastProfile object passed in. For more information
	 * about the different roles that a ForecastProfile object can be, see the &lt;code&gt;ForecastProfileDAO.getObjectsWithRole&lt;/code&gt;
	 * documentation.
	 * &lt;p&gt;
	 * This method automatically sets created and modified metadata.
	 *
	 * @param forecastProfile
	 * @return
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private Collection&lt;ID&gt; saveForecastProfileRecords(Collection&lt;ForecastProfile&gt; forecastProfiles)
			throws BbmException {
<span class="fc" id="L264">		methodStart(&quot;saveForecastProfileRecords&quot;, forecastProfiles);</span>
<span class="fc" id="L265">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>

<span class="fc" id="L267">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L268">		Collection&lt;ID&gt; retVal = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L269">        Collection&lt;ID&gt; profilesToDelete = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L270">		Collection&lt;ForecastProfile&gt; profilesToCreate = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="fc" id="L271">		Collection&lt;ForecastProfile&gt; profilesToUpdate= new ArrayList&lt;ForecastProfile&gt;();</span>
		try {
			// Delete any profile with the same role
<span class="fc bfc" id="L274" title="All 2 branches covered.">			for (ForecastProfile forecastProfile : forecastProfiles) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">				for (ForecastProfile fp : dao.getObjectsWithRole(forecastProfile.getSPQueueID(), forecastProfile.getName(),</span>
<span class="fc" id="L276">						forecastProfile.getForecastInstanceID(), forecastProfile.getStartDate())) {</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">					if (!fp.getID().equals(forecastProfile.getID())) {</span>
<span class="fc" id="L278">                        profilesToDelete.add(fp.getID());</span>
                    }
<span class="fc" id="L280">				}</span>

<span class="pc bpc" id="L282" title="1 of 2 branches missed.">				if (forecastProfile.getID() == null)  {</span>
<span class="fc" id="L283">					forecastProfile.setCreatedBy(user);</span>
<span class="fc" id="L284">					forecastProfile.setCreatedDate(new Date());</span>
<span class="fc" id="L285">					profilesToCreate.add(forecastProfile);</span>
				} else {
<span class="nc" id="L287">					forecastProfile.setModifiedBy(user);</span>
<span class="nc" id="L288">					forecastProfile.setModifiedDate(new Date());</span>
<span class="nc" id="L289">					profilesToUpdate.add(forecastProfile);</span>
				}
<span class="fc" id="L291">			}</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (profilesToDelete.isEmpty() == false) {</span>
<span class="fc" id="L293">                dao.deleteObjects(profilesToDelete);</span>
            }
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">			if (profilesToCreate.isEmpty() == false) {</span>
<span class="fc" id="L296">				retVal.addAll(dao.createObjects(profilesToCreate));</span>
			}
<span class="pc bpc" id="L298" title="1 of 2 branches missed.">			if (profilesToUpdate.isEmpty() == false) {</span>
<span class="nc" id="L299">				dao.updateObjects(profilesToUpdate);</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">				for (ForecastProfile fp : profilesToUpdate) {</span>
<span class="nc" id="L301">					retVal.add(fp.getID());</span>
<span class="nc" id="L302">				}</span>
			}
<span class="nc" id="L304">		} catch (BbmException e) {</span>
<span class="nc" id="L305">			logSaveForecastProfileRecordsException(forecastProfiles);</span>
<span class="nc" id="L306">			handleException(e);</span>
<span class="nc" id="L307">			throw e;</span>
<span class="nc" id="L308">		} catch (MultiUserException e) {</span>
<span class="nc" id="L309">			logSaveForecastProfileRecordsException(forecastProfiles);</span>
<span class="nc" id="L310">			handleException(e);</span>
<span class="nc" id="L311">			throw new BbmException(e);</span>
		} finally {
<span class="pc" id="L313">			dao.cleanUp();</span>
<span class="pc" id="L314">			methodFinish();</span>
<span class="fc" id="L315">		}</span>
<span class="fc" id="L316">		return retVal;</span>
	}

	private void logSaveForecastProfileRecordsException(Collection&lt;ForecastProfile&gt; forecastProfiles) {
<span class="nc" id="L320">		m_cat.error(&quot;Error in saveForecastProfileRecords:&quot;);</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">		for (ForecastProfile profile : forecastProfiles) {</span>
<span class="nc" id="L322">			m_cat.error(&quot;    ForecastProfile ID = &quot; + profile.getID() + &quot; SPQUEUEID = &quot; + profile.getSPQueueID() +</span>
<span class="nc" id="L323">					&quot; STARTDATE = &quot; + profile.getStartDate() + &quot; NAME = &quot; + profile.getName() + &quot; FINSTANCEID = &quot; +</span>
<span class="nc" id="L324">					profile.getForecastInstanceID() + &quot; FPROFILEID = &quot; + profile.getForecastProfileID());</span>
<span class="nc" id="L325">		}</span>
<span class="nc" id="L326">	}</span>

	private void persistForecastProfileLists(Collection&lt;ForecastProfileList&gt; onesToDelete,
			Collection&lt;ForecastProfileList&gt; onesToCreate) throws BbmCreateException, BbmUpdateException, BbmRemoveException {
<span class="fc" id="L330">		methodStart(&quot;persistForecastProfileLists&quot;);</span>
<span class="fc" id="L331">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>

<span class="pc bpc" id="L333" title="1 of 2 branches missed.">		for (ForecastProfileList oneToDelete : onesToDelete) {</span>
<span class="nc" id="L334">			dao.deleteObject(oneToDelete.getID());</span>
<span class="nc" id="L335">		}</span>
<span class="fc" id="L336">		insertForecastProfileLists(onesToCreate);</span>
<span class="fc" id="L337">	}</span>

	private void insertForecastProfileLists(Collection&lt;ForecastProfileList&gt; onesToCreate) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L340">		methodStart(&quot;insertForecastProfileLists&quot;);</span>
<span class="fc" id="L341">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>

<span class="fc" id="L343">		String user = m_sessionContext.getCallerPrincipal().getName();</span>

		try {
<span class="fc bfc" id="L346" title="All 2 branches covered.">			for (ForecastProfileList oneToCreate : onesToCreate) {</span>
<span class="fc" id="L347">				oneToCreate.setCreatedBy(user);</span>
<span class="fc" id="L348">				oneToCreate.setCreatedDate(new Date());</span>
<span class="fc" id="L349">				dao.createObject(oneToCreate);</span>
<span class="fc" id="L350">			}</span>
		} finally {
<span class="pc" id="L352">			dao.cleanUp();</span>
<span class="pc" id="L353">			methodFinish();</span>
<span class="fc" id="L354">		}</span>
<span class="fc" id="L355">	}</span>

	public void deleteForecastProfile(ID forecastProfileID) throws BbmRemoveException {
<span class="nc" id="L358">		methodStart(&quot;deleteForecastProfile&quot;, forecastProfileID);</span>
<span class="nc" id="L359">		ProfileTimeSeriesDAO ptsDAO = new ProfileTimeSeriesDAO();</span>
<span class="nc" id="L360">		ForecastProfileDAO dao = new ForecastProfileDAO(ptsDAO.getDMO());</span>
		try {
<span class="nc" id="L362">			ptsDAO.deleteObjectsWithParentID(forecastProfileID);</span>
<span class="nc" id="L363">			dao.deleteObjects(Collections.singleton(forecastProfileID));</span>
<span class="nc" id="L364">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L365">			handleException(e);</span>
<span class="nc" id="L366">			throw e;</span>
		} finally {
<span class="nc" id="L368">			dao.cleanUp();</span>
<span class="nc" id="L369">			methodFinish();</span>
<span class="nc" id="L370">		}</span>
<span class="nc" id="L371">	}</span>

	public Collection&lt;ForecastProfile&gt; getActiveForecastProfilesBySPQueueIDs(Collection&lt;ID&gt; spQueueIDs)
	throws BbmFinderException {
<span class="fc" id="L375">		methodStart(&quot;getActiveForecastProfilesBySPQueueIDs&quot;, spQueueIDs);</span>
<span class="fc" id="L376">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
<span class="fc" id="L378">			return dao.getActive(spQueueIDs);</span>
<span class="nc" id="L379">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L380">			handleException(e, false);</span>
<span class="nc" id="L381">			throw e;</span>
		} finally {
<span class="pc" id="L383">			dao.cleanUp();</span>
<span class="pc" id="L384">			methodFinish();</span>
		}
	}

	/**
	 * Returns all forecast profiles associated to the given forecast instance.
	 *
	 * FIXME: the spqueueIDs are never used!  This method returns all forecast profiles for the given
	 * instance regardless of which spqueue is associated to the profile.
	 */
	public Collection&lt;ForecastProfile&gt; getForecastProfilesByForecastInstanceIDAndSPQueueIDs(ID forecastInstanceID , Collection&lt;ID&gt; spQueueIDs)
	throws BbmFinderException {
<span class="nc" id="L396">		methodStart(&quot;getForecastProfilesByForecastInstanceIDAndSPQueueIDs&quot;, forecastInstanceID);</span>
<span class="nc" id="L397">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
			//QC-117409 (from QC-115976) ESR 4113828 Port to 11.2
			//Fixed so that ForecastProfiles could be got based on QueueIDs
<span class="nc" id="L401">			Collection&lt;ForecastProfile&gt; fps = new LinkedHashSet&lt;ForecastProfile&gt;(dao.getObjectsByForecastInstanceAndSPQueueID(forecastInstanceID, spQueueIDs));</span>
<span class="nc" id="L402">			fixReforecastProfiles(fps);</span>
<span class="nc" id="L403">			return fps;</span>
<span class="nc" id="L404">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L405">			handleException(e, false);</span>
<span class="nc" id="L406">			throw e;</span>
		} finally {
<span class="nc" id="L408">			dao.cleanUp();</span>
<span class="nc" id="L409">			methodFinish();</span>
		}
	}

	/**
 	 * Pulse's reforecast functionality saves a forecast instance with sloppy values in the ForecastProfile table.
	 * Things it does wrong are:
	 * &lt;ol&gt;
	 * &lt;li&gt;Has a duration of 7, even for multi-week SPs.
	 * &lt;li&gt;Has null startdate and enddate fields.
	 * &lt;li&gt;Does not save a record for each sp-queue-week. It saves one for each sp-queue.
	 * &lt;/ol&gt;
	 * This method will delete these records and create some with more appropriate values. It will only attempt
	 * to fix records that match all of the bad behavior listed above. If a record only has a subset of these
	 * problems, it will be left as is.
	 * @param fps
	 */
	private void fixReforecastProfiles(Collection&lt;ForecastProfile&gt; fps) throws BbmFinderException {

		// First, collect any profiles that need to be fixed.
<span class="nc" id="L429">		Map&lt;ID, ForecastProfile&gt; fpsToFixBySPQueueID = new HashMap&lt;ID, ForecastProfile&gt;();</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">		for (ForecastProfile fp : fps) {</span>
			// Check for null Start &amp; End Dates, as well as duration
<span class="nc bnc" id="L432" title="All 4 branches missed.">			if (fp.getStartDate() == null &amp;&amp; fp.getEndDate() == null) {</span>
				// Check for only one record for each sp-queue
<span class="nc bnc" id="L434" title="All 2 branches missed.">				if (fpsToFixBySPQueueID.remove(fp.getSPQueueID()) != null) continue;</span>

<span class="nc" id="L436">				fpsToFixBySPQueueID.put(fp.getSPQueueID(), fp);</span>
			}
<span class="nc" id="L438">		}</span>

<span class="nc bnc" id="L440" title="All 2 branches missed.">		if (!fpsToFixBySPQueueID.isEmpty()) {</span>
<span class="nc" id="L441">			SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="nc" id="L442">			SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="nc" id="L443">			CampaignDAO campaignDAO = new CampaignDAO();</span>
			try {
				// We need to create a forecast profile record for each spqueue week
<span class="nc" id="L446">				Collection&lt;ForecastProfile&gt; recordsToAdd = new LinkedList&lt;ForecastProfile&gt;();</span>

				// First get SP &amp; Campaign
<span class="nc" id="L449">				SPQueue spq = spqDAO.getSPQueue(fpsToFixBySPQueueID.keySet().iterator().next());</span>
<span class="nc" id="L450">				SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spq.getSpID());</span>
<span class="nc" id="L451">				Campaign campaign = campaignDAO.getObjectByID(sp.getCampaignID());</span>

				// Loop through all weeks in SP, creating a new object for each sp-queue-week
<span class="nc" id="L454">				Calendar spWeekStart = Calendar.getInstance(campaign.getTimeZone());</span>
<span class="nc" id="L455">				spWeekStart.setTime(sp.getStartTime());</span>
<span class="nc" id="L456">				Calendar nextWeekStart = Calendar.getInstance(campaign.getTimeZone());</span>
<span class="nc" id="L457">				nextWeekStart.setTime(sp.getStartTime());</span>
<span class="nc" id="L458">				nextWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc bnc" id="L459" title="All 2 branches missed.">				while (spWeekStart.getTime().getTime() &lt; sp.getEndTime().getTime()) {</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">					for (ForecastProfile fp : fpsToFixBySPQueueID.values()) {</span>
<span class="nc" id="L461">						ForecastProfile newProfile = fp.cloneForecastProfileValueFields();</span>
<span class="nc" id="L462">						newProfile.setStartDate(spWeekStart.getTime());</span>
<span class="nc" id="L463">						newProfile.setEndDate(nextWeekStart.getTime());</span>
<span class="nc" id="L464">						recordsToAdd.add(newProfile);</span>
<span class="nc" id="L465">					}</span>
<span class="nc" id="L466">					spWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc" id="L467">					nextWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
				}

<span class="nc" id="L470">				ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
<span class="nc" id="L471">				fps.removeAll(fpsToFixBySPQueueID.values());</span>
<span class="nc" id="L472">				fpDAO.deleteObjects(ValueObjectUtil.getIDFromObjects(fpsToFixBySPQueueID.values()));</span>
<span class="nc" id="L473">				fpDAO.createObjects(recordsToAdd);</span>
<span class="nc" id="L474">				fps.addAll(recordsToAdd);</span>
<span class="nc" id="L475">			} catch (Exception e) {</span>
<span class="nc bnc" id="L476" title="All 2 branches missed.">				if (e instanceof BbmFinderException) throw (BbmFinderException)e;</span>
<span class="nc" id="L477">				else throw new BbmFinderException(e);</span>
			} finally {
<span class="nc" id="L479">				spqDAO.cleanUp();</span>
<span class="nc" id="L480">				spDAO.cleanUp();</span>
<span class="nc" id="L481">				campaignDAO.cleanUp();</span>
<span class="nc" id="L482">			}</span>
		}
<span class="nc" id="L484">	}</span>

	public Collection&lt;ForecastProfile&gt; getManuallySavedForecastProfiles() throws BbmFinderException {
<span class="fc" id="L487">		methodStart(&quot;getForecastProfiles&quot;);</span>
<span class="fc" id="L488">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
<span class="fc" id="L490">			return dao.getObjects(&quot;spqueueid is null and forecastinstanceid is null&quot;);</span>
<span class="nc" id="L491">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L492">			handleException(e, false);</span>
<span class="nc" id="L493">			throw e;</span>
		} finally {
<span class="pc" id="L495">			dao.cleanUp();</span>
<span class="pc" id="L496">			methodFinish();</span>
		}
	}

	public Collection&lt;ProfileTimeSeries&gt; getProfileTimeSeriesByProfileID(ID profileID)
	throws BbmFinderException {
<span class="nc" id="L502">		methodStart(&quot;getProfileTimeSeriesByProfileID&quot;, profileID);</span>
<span class="nc" id="L503">		ForecastProfileDAO fpDao = new ForecastProfileDAO();</span>
<span class="nc" id="L504">		ProfileTimeSeriesDAO dao = new ProfileTimeSeriesDAO(fpDao.getDMO());</span>
		try {
<span class="nc" id="L506">			return dao.getObjectsByParentID(profileID);</span>
<span class="nc" id="L507">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L508">			handleException(e, false);</span>
<span class="nc" id="L509">			throw e;</span>
		} finally {
<span class="nc" id="L511">			fpDao.cleanUp();</span>
<span class="nc" id="L512">			dao.cleanUp();</span>
<span class="nc" id="L513">			methodFinish();</span>
		}
	}

	public void saveProfileTimeSeries(Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L518">		methodStart(&quot;saveProfileTimeSeries&quot;, timeSeriesCollection);</span>
<span class="nc" id="L519">		ProfileTimeSeriesDAO dao = new ProfileTimeSeriesDAO();</span>
		try {
<span class="nc" id="L521">			HashSet&lt;ProfileTimeSeries&gt; objectsToCreate = new HashSet&lt;ProfileTimeSeries&gt;();</span>
<span class="nc" id="L522">			HashSet&lt;ProfileTimeSeries&gt; objectsToUpdate = new HashSet&lt;ProfileTimeSeries&gt;();</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">			for ( ProfileTimeSeries pts : timeSeriesCollection) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">				if (pts.getID() == null) objectsToCreate.add(pts);</span>
<span class="nc" id="L525">				else objectsToUpdate.add(pts);</span>
<span class="nc" id="L526">			}</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">			if (objectsToCreate.size() &gt; 0) dao.createObjects(objectsToCreate);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">			if (objectsToUpdate.size() &gt; 0) dao.updateObjects(objectsToUpdate);</span>
<span class="nc" id="L529">		} catch (Exception e) {</span>
<span class="nc" id="L530">			handleException(e);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L533">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L535">			dao.cleanUp();</span>
<span class="nc" id="L536">			methodFinish();</span>
<span class="nc" id="L537">		}</span>
<span class="nc" id="L538">	}</span>

	// }} ------------------- End Forecast Profiles -------------------- //

	// {{ ------------------- Start Instances -------------------------- //

	public Collection&lt;ForecastInstance&gt; getForecastInstancesForSPQueue(ID spQueueID) throws BbmFinderException {
<span class="nc" id="L545">		methodStart(&quot;getForecastInstancesForSPQueue&quot;, spQueueID);</span>
<span class="nc" id="L546">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
<span class="nc" id="L547">		ForecastProfileDAO fpDao = new ForecastProfileDAO(dao.getDMO());</span>
		try {
<span class="nc" id="L549">			Set&lt;ID&gt; fiIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">			for (ForecastProfile fp : fpDao.getObjectsBySPQueueID(spQueueID)) {</span>
<span class="nc" id="L551">				ID fiID = fp.getForecastInstanceID();</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">				if (fiID != null) fiIDSet.add(fiID);</span>
<span class="nc" id="L553">			}</span>
<span class="nc" id="L554">			return dao.getObjectsByIDs(fiIDSet);</span>
<span class="nc" id="L555">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L556">			handleException(e, false);</span>
<span class="nc" id="L557">			throw e;</span>
		} finally {
<span class="nc" id="L559">			dao.cleanUp();</span>
<span class="nc" id="L560">			fpDao.cleanUp();</span>
<span class="nc" id="L561">			methodFinish();</span>
		}
	}

	public Collection&lt;ForecastInstance&gt; getForecastInstancesForSP(ID spID) throws BbmFinderException {
<span class="nc" id="L566">		methodStart(&quot;getForecastInstancesForSP&quot;, spID);</span>
<span class="nc" id="L567">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
		try {
<span class="nc" id="L569">			return dao.getObjectsByParentID(spID);</span>
<span class="nc" id="L570">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L571">			handleException(e, false);</span>
<span class="nc" id="L572">			throw e;</span>
		} finally {
<span class="nc" id="L574">			dao.cleanUp();</span>
<span class="nc" id="L575">			methodFinish();</span>
		}
	}

	/**
	 * Returns true if the given forecast instance id is linked to all of the given
	 * queues in the given sp with the given media.  Otherwise returns false.
	 */
	public boolean isForecastInstanceValidForMediaInSp(ID forecastInstanceId, ID spId, ID mediaId)
			throws BbmFinderException {
<span class="nc" id="L585">		methodStart(&quot;isForecastInstanceValidForMediaInSp&quot;, forecastInstanceId, spId, mediaId);</span>
<span class="nc" id="L586">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
<span class="nc" id="L587">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {

<span class="nc" id="L590">			Collection&lt;SPQueue&gt; singleSpQueuesInMedia = spqDao.getNonCombinedSPQueuesByMediaAndSP(spId, mediaId);</span>
<span class="nc" id="L591">			Collection&lt;ID&gt; queueIds = ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID,</span>
					singleSpQueuesInMedia);

<span class="nc" id="L594">			Collection&lt;ID&gt; forecastInstanceIds = dao.getForecastInstanceIdsForSpsAndQueues(spId, queueIds);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">			for (ID instanceId : forecastInstanceIds) {</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">				if (instanceId.equals(forecastInstanceId)) {</span>
<span class="nc" id="L597">					return true;</span>
				}
<span class="nc" id="L599">			}</span>
<span class="nc" id="L600">			return false;</span>
<span class="nc" id="L601">		} catch (JdmoException e) {</span>
<span class="nc" id="L602">			handleException(e);</span>
<span class="nc" id="L603">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L605">			dao.cleanUp();</span>
<span class="nc" id="L606">			spqDao.cleanUp();</span>
<span class="nc" id="L607">			methodFinish();</span>
		}
	}

	/**
	 * Returns true if the given forecast instance id is linked to both the given scheduling period and all of the given
	 * queues.  Otherwise returns false.
	 */
	public boolean isForecastInstanceValidForQueuesInSp(ID forecastInstanceId, ID spId, Collection&lt;ID&gt; queueIds)
			throws BbmFinderException {
<span class="nc" id="L617">		methodStart(&quot;isForecastInstanceValidForQueuesInSp&quot;, forecastInstanceId, spId, queueIds);</span>
<span class="nc" id="L618">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
		try {
<span class="nc" id="L620">			Collection&lt;ID&gt; forecastInstanceIds = dao.getForecastInstanceIdsForSpsAndQueues(spId, queueIds);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">			for (ID instanceId : forecastInstanceIds) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">				if (instanceId.equals(forecastInstanceId)) {</span>
<span class="nc" id="L623">					return true;</span>
				}
<span class="nc" id="L625">			}</span>
<span class="nc" id="L626">			return false;</span>
<span class="nc" id="L627">		} catch (JdmoException e) {</span>
<span class="nc" id="L628">			handleException(e);</span>
<span class="nc" id="L629">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L631">			dao.cleanUp();</span>
<span class="nc" id="L632">			methodFinish();</span>
		}
	}

	/**
	 * Saves the forecast instance for immediate media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveImmediateMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 *
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveImmediateMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveImmediateMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveImmediateMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L655">		methodStart(&quot;saveImmediateMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, isBase);</span>
		try {
<span class="fc" id="L657">			return saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="nc" id="L658">		} catch (Exception e) {</span>
<span class="nc" id="L659">			handleException(e);</span>
<span class="nc bnc" id="L660" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L662">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L664">			methodFinish();</span>
		}
	}

	/**
	 * Saves the forecast instance for deferred media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveImmediateMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 *
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param spQueues - Collection of associated SPQueue objects that will be updated as part of this operation.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveDeferredMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveDeferredMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveDeferredMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, Collection&lt;SPQueue&gt; spQueues, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L688">		methodStart(&quot;saveDeferredMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, spQueues, isBase);</span>
		try {
<span class="nc" id="L690">			ForecastInstance fi = saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="nc" id="L691">			saveAssociatedDataForDeferredMediaForecastInstance(spQueues, fi.getID());</span>
<span class="nc" id="L692">			return fi;</span>
<span class="nc" id="L693">		} catch (Exception e) {</span>
<span class="nc" id="L694">			handleException(e);</span>
<span class="nc bnc" id="L695" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L697">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L699">			methodFinish();</span>
		}
	}

	/**
	 * Saves the additional (non-time series) data associated with a forecast instance that contains
	 * deferred media queues.  This includes the forecasted interim backlog that is associated to each
	 * deferred queue.
	 */
	private void saveAssociatedDataForDeferredMediaForecastInstance(Collection&lt;SPQueue&gt; spQueues, ID forecastInstanceID)
	throws MultiUserException, BbmUpdateException, BbmFinderException, BbmCreateException, JdmoException {
<span class="nc" id="L710">		SPQueueDAO dao = new SPQueueDAO();</span>
<span class="nc" id="L711">		ForecastInterimBacklogDAO fibDAO = new ForecastInterimBacklogDAO();</span>
		try {
<span class="nc" id="L713">			fibDAO.updateInterimBacklogForForecastInstance(spQueues, forecastInstanceID);</span>
		} finally {
<span class="nc" id="L715">			dao.cleanUp();</span>
<span class="nc" id="L716">			fibDAO.cleanUp();</span>
<span class="nc" id="L717">		}</span>
<span class="nc" id="L718">	}</span>

	/**
	 * Saves the forecast instance for outbound media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveOutboundMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveOutboundMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveOutboundMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveOutboundMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L740">		methodStart(&quot;saveOutboundMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, listsByProfile, isBase);</span>

		try {
<span class="nc" id="L743">			ForecastInstance retVal = saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="nc" id="L744">			saveAssociatedDataForOutboundMediaForecastInstance(retVal.getId(), listsByProfile);</span>

<span class="nc" id="L746">			return retVal;</span>
<span class="nc" id="L747">		} catch (Exception e) {</span>
<span class="nc" id="L748">			handleException(e);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L751">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L753">			methodFinish();</span>
		}
	}

	/**
	 * Saves the additional (non-time series) data associated with a forecast instance that contains
	 * outbound media queues.  This includes the forecasted outbound call lists that are associated to
	 * each outbound queue.
	 */
	private void saveAssociatedDataForOutboundMediaForecastInstance(ID forecastInstanceID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmException {
<span class="fc" id="L764">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
			//Profiles may have been cloned in previous step, we need to retrieve the forecast profiles for the
			//given instance and then the forecast profile IDs on those profiles need to be set on the forecast profile lists
<span class="fc" id="L768">			Collection&lt;ForecastProfile&gt; profiles = fpDAO.getObjectsByForecastInstanceID(forecastInstanceID);</span>
<span class="fc" id="L769">			saveForecastProfileLists(getOutboundProfileListsByForecastProfileID(profiles, listsByProfile));</span>
		} finally {
<span class="pc" id="L771">			fpDAO.cleanUp();</span>
<span class="fc" id="L772">		}</span>
<span class="fc" id="L773">	}</span>

	/**
	 * Saves the forecast instance. Profiles must all be in the same SP.  Used internally by the save forecast instance methods for specific media types.
	 * The instance may be a named instance or the Base instance.
	 * This method supports incremental saves. If data exists for a SPQueue specified by the
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 */
	private ForecastInstance saveForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, boolean isBase) throws BbmFinderException, BbmException, CloneNotSupportedException {
<span class="pc bpc" id="L783" title="2 of 4 branches missed.">		if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>
<span class="pc bpc" id="L784" title="2 of 4 branches missed.">		if (profiles != null &amp;&amp; profiles.size() &gt; 0) {</span>
<span class="fc" id="L785">			boolean shouldCloneProfiles = false;</span>

			//Check to see if we have a previously saved instance with this name for the given SP.  If we do,
			// then we need to create a new set of profiles as we will be creating a new instance as well.
			//
			// [RWF, 2010-12-14] I'm not sure why we need this. I am guessing that it was needed to clear out old
			// data. However, the saveForecastProfileRecord already does some cleanup. There is no time
			// left in the dev cycle to investigate this further.
<span class="fc" id="L793">			ForecastInstance previouslySavedInstance = getSavedForecastInstance(getSPID(forecastsBySPQueueID.keySet().iterator().next()),</span>
					name, isBase);
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">			if (previouslySavedInstance != null) shouldCloneProfiles = true;</span>

			// If it is a base forecast, clone the profiles. This is done because, often, people will code the client such
			// that they pass in the active forecast profiles and want to set it as the base. If we don't clone the profiles, the
			// nature of the profile records would change from an active forecast to a base forecast. By cloning, we leave the
			// active forecast alone.
<span class="pc bpc" id="L801" title="1 of 2 branches missed.">			if (isBase) shouldCloneProfiles = true;</span>

<span class="pc bpc" id="L803" title="1 of 2 branches missed.">			if (shouldCloneProfiles) {</span>
<span class="fc" id="L804">				Collection&lt;ForecastProfile&gt; clonedProfiles = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">				for (ForecastProfile profile : profiles) {</span>
<span class="fc" id="L806">					clonedProfiles.add(profile.cloneForecastProfileValueFields());</span>
<span class="fc" id="L807">				}</span>
<span class="fc" id="L808">				profiles = clonedProfiles;</span>
			}
		}
<span class="fc" id="L811">		ForecastInstance fi = saveForecastInstanceRecord(name, getSPID(forecastsBySPQueueID.keySet().iterator().next()), isBase);</span>
<span class="pc bpc" id="L812" title="2 of 4 branches missed.">		if (profiles != null &amp;&amp; !profiles.isEmpty()) {</span>
<span class="fc" id="L813">			saveForecastProfiles(profiles, fi.getID());</span>
		}
<span class="fc" id="L815">		saveForecastTimeSeries(forecastsBySPQueueID, fi.getID());</span>
<span class="fc" id="L816">		return fi;</span>
	}

	/**
	 * Saves a record in the ForecastInstance table.
	 *
	 * @param name
	 * @param data
	 * @param timeZone
	 * @param isBase
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private ForecastInstance saveForecastInstanceRecord(String name, ID spID, boolean isBase) throws BbmException {
<span class="fc" id="L830">		methodStart(&quot;saveForecastInstance&quot;, name, spID, isBase);</span>
<span class="fc" id="L831">		ForecastInstanceDAO fiDAO = new ForecastInstanceDAO();</span>
<span class="fc" id="L832">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="fc" id="L833">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
<span class="fc" id="L834">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>
<span class="fc" id="L835">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
		try {
<span class="fc" id="L837">			ForecastInstance fi = getSavedForecastInstance(spID, name, isBase);</span>

			// If no FI exists, create new
<span class="pc bpc" id="L840" title="1 of 2 branches missed.">			if (fi == null) {</span>
<span class="fc" id="L841">				fi = new ForecastInstance();</span>
<span class="fc" id="L842">				fi.setCreated(new Date());</span>
<span class="fc" id="L843">				fi.setCreatedBy(user);</span>
<span class="fc" id="L844">				fi.setDescription(name);</span>
<span class="fc" id="L845">				fi.setIsBase(isBase);</span>
<span class="fc" id="L846">				fi.setSpId(spID);</span>
<span class="fc" id="L847">				fiDAO.createObject(fi);</span>
			} else  {
				// If FI already exists, modify
<span class="nc" id="L850">				fi.setModified(new Date());</span>
<span class="nc" id="L851">				fi.setModifiedBy(user);</span>
<span class="nc" id="L852">				fi.setDescription(name);</span>
<span class="nc" id="L853">				fi.setIsBase(isBase);</span>
<span class="nc" id="L854">				fi.setSpId(spID);</span>
<span class="nc" id="L855">				fiDAO.updateObject(fi);</span>
			}
<span class="fc" id="L857">			return fi;</span>
<span class="nc" id="L858">		} catch (MultiUserException e) {</span>
<span class="nc" id="L859">			throw new BbmCreateException(e);</span>
<span class="nc" id="L860">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L861">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L863">			spQueueDAO.cleanUp();</span>
<span class="pc" id="L864">			fpDAO.cleanUp();</span>
<span class="pc" id="L865">			ftsDAO.cleanUp();</span>
<span class="pc" id="L866">			fiDAO.cleanUp();</span>
<span class="pc" id="L867">			methodFinish();</span>
		}
	}

	/**
	 * Returns the forecast instance with the given name and Scheduling Period (or the base forecast of the scheduling
	 * period if isBase is true).  Returns null if a forecast instance does not exist for these parameters.
	 */
	private ForecastInstance getSavedForecastInstance(ID spID, String name, boolean isBase) throws BbmFinderException {
<span class="fc" id="L876">		methodStart(&quot;getSavedForecastInstance&quot;);</span>

<span class="fc" id="L878">		ForecastInstance fi = null;</span>
<span class="fc" id="L879">		ForecastInstanceDAO fiDAO = new ForecastInstanceDAO();</span>
		try
		{
<span class="pc bpc" id="L882" title="3 of 4 branches missed.">			if (! isBase &amp;&amp; ! StringUtil.isEmpty(name))fi = fiDAO.getObjectByNameAndSPID(name, spID);</span>
<span class="pc bpc" id="L883" title="1 of 2 branches missed.">			else if (isBase) fi = fiDAO.getBaseForecastInstance(spID);</span>
<span class="fc" id="L884">			return fi;</span>
<span class="nc" id="L885">		}catch(Exception e) {</span>
<span class="nc" id="L886">			handleException(e);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L888">			throw new BbmFinderException(e);</span>
		} finally{
<span class="pc" id="L890">			fiDAO.cleanUp();</span>
<span class="pc" id="L891">			methodFinish();</span>
		}

	}

	// }} ------------------- End Instances -------------------------- //

	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the spQueues are the keys in the forecastsBySPQueueID map).
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 */
	public void saveImmediateMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L907">		saveImmediateMediaForecastAsActive(profiles, forecastsBySPQueueID, ForecastUpdateOriginalSource.UnknownUpdate);</span>
<span class="fc" id="L908">	}</span>

	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the spQueues are the keys in the forecastsBySPQueueID map).
	 * NOTE: This is essentially an optimized version of saveImmediateMediaForecastAsActive.  It is only intended to be used for the RFS import
	 * as it skips some steps for the saving of forecast data that are normally required (mainly allocations).  In almost all cases, you want to
	 * use saveImmediateMediaForecastAsActive instead!
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 */
	public void saveImmediateMediaForecastAsActiveForRFS(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;ID, ? extends TraceCube&gt; forecastsBySPQueueID)
				throws BbmCreateException, BbmUpdateException {
		try {
			//Map&lt;ID, TraceCube&gt; forecastsBySPQueueID = new HashMap&lt;ID, TraceCube&gt;();
<span class="nc bnc" id="L924" title="All 4 branches missed.">			if (forecastsBySPQueueID != null &amp;&amp; forecastsBySPQueueID.isEmpty() == false) {</span>
				//Persist forecast time series
<span class="nc" id="L926">				saveDataForImmediateMediaActiveForecast(profiles, forecastsBySPQueueID);</span>
			}
<span class="nc" id="L928">		} catch (Exception e) {</span>
<span class="nc" id="L929">			handleException(e);</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L932">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L934">			methodFinish();</span>
<span class="nc" id="L935">		}</span>
<span class="nc" id="L936">	}</span>

	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the spQueues are the keys in the forecastsBySPQueueID map).
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param updateSource if &lt;code&gt;ForecastUpdateOriginalSource.ChildUpdate&lt;/code&gt; and the forecasted
	 * queues include distributed child queues, then the children's parent forecasts and
	 * allocation percentages will be updated as well.  Otherwise the updates will not occur.
	 * Normally this parameter would be &lt;code&gt;ForecastUpdateOriginalSource.ChildUpdate&lt;/code&gt;
	 * but if the child forecast is itself being updated as a result of an update to the parent
	 * forecast then the changes to the child should not loop back to the parent.
	 */
	private void saveImmediateMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			ForecastUpdateOriginalSource updateSource)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L954">		methodStart(&quot;saveImmediateMediaForecastAsActive&quot;);</span>

		try {
<span class="fc" id="L957">			Collection&lt;ID&gt; savedSPQueueIDs = m_forecastTimeSeriesManager.saveDataForImmediateMediaActiveForecast(profiles, forecastsBySPQueueID);</span>
			//After the transaction for saving forecast data has been committed, we now kick off the fte
			//requirements calculations for these spqueues
<span class="fc" id="L960">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(savedSPQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="fc" id="L961">			updateAllocations(savedSPQueueIDs, updateSource);</span>
<span class="nc" id="L962">		} catch (Exception e) {</span>
<span class="nc" id="L963">			handleException(e);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L966">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L968">			methodFinish();</span>
<span class="fc" id="L969">		}</span>
<span class="fc" id="L970">	}</span>

    /**
     * This method is used by saveDataForImmediateMediaActiveForecast to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active immediate media forecasts.  Use saveImmediateMediaForecastAsActive instead!
     */
	public Collection&lt;ID&gt; saveDataForImmediateMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L981">		methodStart(&quot;saveDataForImmediateMediaActiveForecast&quot;);</span>

		try {
<span class="fc" id="L984">			saveForecastProfiles(profiles, null);</span>
<span class="fc" id="L985">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>

<span class="fc" id="L987">			return ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="nc" id="L989">		} catch (Exception e) {</span>
<span class="nc" id="L990">			handleException(e);</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L993">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L995">			methodFinish();</span>
		}
	}

    /**
     * Saves an active project media forecast with forecast and project profiles for the given spQueues in forecastsBySPQueueID.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
     * @param projectProfiles
     * @param profiles
     * @param forecastsBySPQueueID
     * @throws BbmCreateException
     * @throws BbmUpdateException
     * @throws BbmRemoveException
     * @throws RemoteException
     */
	public void saveProjectMediaForecastAsActive(
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfile)
	throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1014">		methodStart(&quot;saveProjectMediaForecastAsActive&quot;);</span>
		try {
<span class="nc" id="L1016">			m_forecastTimeSeriesManager.saveDataForProjectMediaActiveForecast(projectsByForecastProfile);</span>
<span class="nc" id="L1017">			Collection&lt;ID&gt; spQueueIDs = ValueObjectUtil.getFieldObjectCol(</span>
<span class="nc" id="L1018">					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, projectsByForecastProfile.keySet());</span>
<span class="nc" id="L1019">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIDs, m_whatIfMode);</span>
<span class="nc" id="L1020">		} catch (Exception e) {</span>
<span class="nc" id="L1021">			handleException(e);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1024">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1026">			methodFinish();</span>
<span class="nc" id="L1027">		}</span>
<span class="nc" id="L1028">	}</span>

    /**
     * This method is used by saveProjectMediaForecastAsActive to save the necessary data for the project queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active project forecasts.  Use saveProjectMediaForecastAsActive instead!
     */
	public void saveDataForProjectMediaActiveForecast(
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfile)
	throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1041">		methodStart(&quot;saveDataForProjectMediaActiveForecast&quot;);</span>
<span class="nc" id="L1042">		ForecastProfileProjectDAO dao = new ForecastProfileProjectDAO();</span>

		try {
<span class="nc bnc" id="L1045" title="All 4 branches missed.">			if (projectsByForecastProfile != null &amp;&amp; !projectsByForecastProfile.isEmpty()) {</span>
<span class="nc" id="L1046">				Collection&lt;ID&gt; forecastProfilesToDelete = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1047">				Collection&lt;ForecastProfileProject&gt; projectsToSave = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1048">				saveForecastProfiles(projectsByForecastProfile.keySet(), null);</span>
                for (Map.Entry&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfileEntry :
<span class="nc bnc" id="L1050" title="All 2 branches missed.">            			projectsByForecastProfile.entrySet()) {</span>
<span class="nc" id="L1051">	                ForecastProfile forecastProfile = projectsByForecastProfileEntry.getKey();</span>
<span class="nc" id="L1052">					Collection&lt;ForecastProfileProject&gt; filterProjectProfiles = projectsByForecastProfileEntry.getValue();</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">                    if (forecastProfile.getForecastProfileID() != null) {</span>
<span class="nc" id="L1054">                        forecastProfilesToDelete.add(forecastProfile.getForecastProfileID());</span>
                    }
<span class="nc bnc" id="L1056" title="All 4 branches missed.">					if (filterProjectProfiles != null &amp;&amp; filterProjectProfiles.isEmpty() == false) {</span>
<span class="nc bnc" id="L1057" title="All 2 branches missed.">						for (ForecastProfileProject fpp : filterProjectProfiles) {</span>
							/**
							 * Fix for QC#88192
							 */
<span class="nc bnc" id="L1061" title="All 2 branches missed.">							if (fpp.getID() != null) {</span>
<span class="nc" id="L1062">								fpp.setID(null);</span>
							}
<span class="nc" id="L1064">							fpp.setForecastProfileID(forecastProfile.getForecastProfileID());</span>
<span class="nc" id="L1065">							projectsToSave.add(fpp);</span>
<span class="nc" id="L1066">						}</span>
					}
<span class="nc" id="L1068">				}</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">				if (forecastProfilesToDelete.isEmpty() == false) {</span>
<span class="nc" id="L1070">					dao.deleteByForecastProfileIDs(forecastProfilesToDelete);</span>
				}
<span class="nc bnc" id="L1072" title="All 2 branches missed.">				if (projectsToSave.isEmpty() == false) {</span>
<span class="nc" id="L1073">					saveForecastProjectRecords(projectsToSave);</span>
				}
			}
<span class="nc" id="L1076">		} catch (Exception e) {</span>
<span class="nc" id="L1077">			handleException(e);</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1080">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1082">			methodFinish();</span>
<span class="nc" id="L1083">			dao.cleanUp();</span>
<span class="nc" id="L1084">		}</span>
<span class="nc" id="L1085">	}</span>

	/**
     * Saves an active outbound media forecast with forecast profiles and forecasted outbound call lists for the given spQueues in forecastsBySPQueueID.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param listsByProfile - hashmap: key = forecast profile, value = list of forecasted outbound call lists for the forecast profile
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void saveOutboundMediaForecastAsActive(Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1101">		methodStart(&quot;saveOutboundMediaForecastAsActive&quot;);</span>
		try {
<span class="fc" id="L1103">			m_forecastTimeSeriesManager.saveDataForOutboundMediaActiveForecast(profiles, forecastsBySPQueueID, listsByProfile);</span>
<span class="fc" id="L1104">			Collection&lt;ID&gt; spQueueIDs = ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="fc" id="L1106">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1107">		} catch (Exception e) {</span>
<span class="nc" id="L1108">			handleException(e);</span>
<span class="nc bnc" id="L1109" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1111">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1113">			methodFinish();</span>
<span class="fc" id="L1114">		}</span>
<span class="fc" id="L1115">	}</span>

    /**
     * This method is used by saveOutboundMediaForecastAsActive to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active outbound forecasts.  Use saveOutboundMediaForecastAsActive instead!
     */
	public void saveDataForOutboundMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1128">		methodStart(&quot;saveDataForOutboundMediaActiveForecast&quot;);</span>
		try {
<span class="fc" id="L1130">			saveForecastProfiles(profiles, null);</span>

			//We know that when we make the call to saveForecastProfiles above, it is possible that the profiles
			//are actually deleted and new ones created rather than just updating.  What we need to do then is
			//update the forecast profile IDs on the forecast profile lists with the new IDs before we save the lists.
<span class="fc" id="L1135">			saveForecastProfileLists(getOutboundProfileListsByForecastProfileID(profiles, listsByProfile));</span>
<span class="fc" id="L1136">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>
<span class="nc" id="L1137">		} catch (Exception e) {</span>
<span class="nc" id="L1138">			handleException(e);</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1140" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1141">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1143">			methodFinish();</span>
<span class="fc" id="L1144">		}</span>
<span class="fc" id="L1145">	}</span>

	/**
	 * Saves an active deferred media forecast with forecast profiles for the given spQueues.
	 * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
	 * is stored on the SPQueue value object.
	 * It is only intended to be used for the RFS import as it does not recalculate the Required FTE after saving.
	 * In almost all cases, you want to use saveDeferredMediaForecastAsActive instead.
	 *
	 * @param profiles             - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues             - SPQueue value objects we are updating
	 */
	public void saveDeferredMediaForecastAsActiveForRFS(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L1162">		methodStart(&quot;saveDeferredMediaForecastAsActiveForRFS&quot;, profiles, forecastsBySPQueueID,  spQueues);</span>
		try {
<span class="nc" id="L1164">			m_forecastTimeSeriesManager.saveDataForDeferredMediaActiveForecast(profiles, forecastsBySPQueueID, spQueues);</span>
<span class="nc" id="L1165">		} catch (Exception e) {</span>
<span class="nc" id="L1166">			handleException(e);</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1168" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1169">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1171">			methodFinish();</span>
<span class="nc" id="L1172">		}</span>
<span class="nc" id="L1173">	}</span>

	/**
     * Saves an active deferred media forecast with forecast profiles for the given spQueues.
     * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
     * is stored on the SPQueue value object.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues - SPQueue value objects we are updating
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void saveDeferredMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues)
				throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1193">		saveDeferredMediaForecastAsActive(profiles, forecastsBySPQueueID, spQueues, ForecastUpdateOriginalSource.UnknownUpdate);</span>
<span class="nc" id="L1194">	}</span>
	/**
     * Saves an active deferred media forecast with forecast profiles for the given spQueues.
     * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
     * is stored on the SPQueue value object.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues - SPQueue value objects we are updating
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void saveDeferredMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues,
			ForecastUpdateOriginalSource updateSource)
				throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1214">		methodStart(&quot;saveDeferredMediaForecastAsActive&quot;);</span>
		try {
<span class="nc" id="L1216">			Collection&lt;ID&gt; savedSPQueueIDs = m_forecastTimeSeriesManager.saveDataForDeferredMediaActiveForecast(profiles, forecastsBySPQueueID, spQueues);</span>
			//After the transaction for saving forecast data has been committed, we now kick off the fte
			//requirements calculations for these spqueues
<span class="nc" id="L1219">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(savedSPQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1220">			updateAllocations(savedSPQueueIDs, updateSource);</span>
<span class="nc" id="L1221">		} catch (Exception e) {</span>
<span class="nc" id="L1222">    		handleException(e);</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1225">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1227">			methodFinish();</span>
<span class="nc" id="L1228">		}</span>
<span class="nc" id="L1229">	}</span>

    /**
     * This method is used by saveDeferredMediaForecastAsActive to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active deferred forecasts.  Use saveDeferredMediaForecastAsActive instead!
     */
	public Collection&lt;ID&gt; saveDataForDeferredMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1242">		methodStart(&quot;saveDataForDeferredMediaActiveForecast&quot;);</span>
<span class="nc" id="L1243">		SPQueueDAO dao = new SPQueueDAO();</span>
		try {
<span class="nc" id="L1245">			saveForecastProfiles(profiles, null);</span>
<span class="nc" id="L1246">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>
<span class="nc" id="L1247">        	dao.updateObjects(spQueues);</span>

<span class="nc" id="L1249">        	return ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="nc" id="L1251">		} catch (Exception e) {</span>
<span class="nc" id="L1252">    		handleException(e);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1254" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1255">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1257">        	dao.cleanUp();</span>
<span class="nc" id="L1258">			methodFinish();</span>
		}
	}

	/**
	 * Sets the forecast instance id on each Forecast Profile before saving
	 * @param profiles
	 * @param forecastInstanceID
	 * @throws BbmException
	 */
	private void saveForecastProfiles(Collection&lt;ForecastProfile&gt; profiles, ID forecastInstanceID) throws BbmException {
<span class="fc bfc" id="L1269" title="All 2 branches covered.">		for (ForecastProfile fp : profiles) {</span>
<span class="fc" id="L1270">			fp.setForecastInstanceID(forecastInstanceID);</span>
<span class="fc" id="L1271">		}</span>
<span class="fc" id="L1272">		saveForecastProfileRecords(profiles);</span>
<span class="fc" id="L1273">	}</span>

	/**
	 * Saves a collection of ForecastProfileLists (forecasted outbound call lists) associated to the given forecast profiles
	 * (specified by the ID of the ForecastProfile as the key of the hashmap of the parameter to this method).
	 */
	private void saveForecastProfileLists(Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsByProfileId) throws BbmException {
		//TODO: this seems to be getting called four times during save for a four week sp
<span class="fc" id="L1281">		ForecastProfileListDAO listDao = new ForecastProfileListDAO();</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">		for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; entry : listsByProfileId.entrySet()) {</span>
<span class="fc" id="L1283">			ID profileId = entry.getKey();</span>
			// Now for this profile, see how the persisted lists match with the input lists and decide which ones to delete,
			// which ones to update and which ones to create
<span class="fc" id="L1286">			Map&lt;ID, ForecastProfileList&gt; originalList = ValueObjectUtil.getIDObjectMap(listDao.getForecastProfileListsByForecastProfileID(profileId));</span>
<span class="fc" id="L1287">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listFromUI = createForecastProfileListMap(entry.getValue());</span>

<span class="fc" id="L1289">			Collection&lt;ForecastProfileList&gt; onesToDelete = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc" id="L1290">			Collection&lt;ForecastProfileList&gt; onesToUpdate = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc" id="L1291">			getForecastProfileListsToDeleteAndUpdate(originalList, listFromUI, onesToDelete, onesToUpdate);</span>
<span class="fc" id="L1292">			Collection&lt;ForecastProfileList&gt; onesToCreate = getForecastProfileListsToCreate(originalList, listFromUI);</span>

			//The forecast profiles that we want to update actually need to be re-created, because the profiles that
			//were saved in the previous operation were cloned from the old profile and the old ones were deleted.  During
			//that delete operation, that profile's set of profile lists were deleted as well.  Therefore, we will re-create
			//the profile's forecasted lists here.
<span class="pc bpc" id="L1298" title="1 of 2 branches missed.">			for (ForecastProfileList profileListToUpdate : onesToUpdate) {</span>
<span class="nc" id="L1299">				profileListToUpdate.setID(null);</span>
<span class="nc" id="L1300">				onesToCreate.add(profileListToUpdate);</span>
<span class="nc" id="L1301">			}</span>
<span class="fc" id="L1302">			persistForecastProfileLists(onesToDelete, onesToCreate);</span>
<span class="fc" id="L1303">		}</span>
<span class="fc" id="L1304">	}</span>

	/**
	 * Returns a map of forecast profile list collections, keyed on the forecast profile list's ID.  Most entries
	 * in the map will only have collections with one object in them, since most forecast profile lists have a unique
	 * ID.  The exception will be for brand new lists with null IDs, that collection will contain all newly created lists
	 * that have yet to be saved.
	 */
	private Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; createForecastProfileListMap(Collection&lt;ForecastProfileList&gt; lists) {
<span class="fc" id="L1313">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; map = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
<span class="fc bfc" id="L1314" title="All 2 branches covered.">		for (ForecastProfileList forecastProfileList : lists) {</span>
<span class="pc bpc" id="L1315" title="1 of 2 branches missed.">			if (map.containsKey(forecastProfileList.getID()) == false) {</span>
<span class="fc" id="L1316">				map.put(forecastProfileList.getID(), new HashSet&lt;ForecastProfileList&gt;());</span>
			}
<span class="fc" id="L1318">			map.get(forecastProfileList.getID()).add(forecastProfileList);</span>
<span class="fc" id="L1319">		}</span>
<span class="fc" id="L1320">		return map;</span>
	}

	/**
	 * Populates the forecast profile lists to delete and update.
	 *
	 * @param existingOnes the existing (currently persisted) forecast profile lists
	 * @param listsFromUI the lists coming from the UI that need to e persisted (synched) into the persistence store
	 * @param onesToDelete the ones to delete - this is like an output parameter, the method will populate this collection with lists that
	 * need to be deleted based on the existing and new forecast profile lists.
	 * @param onesToUpdate the ones to update - this is like an output parameter, the method will populate this collection with lists that
	 * need to be updated based on the existing and new forecast profile lists.
	 * @return the forecast profile lists to delete
	 */
	private void getForecastProfileListsToDeleteAndUpdate(
			Map&lt;ID, ForecastProfileList&gt; existingOnes,
			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsFromUI,
			Collection&lt;ForecastProfileList&gt; onesToDelete,
			Collection&lt;ForecastProfileList&gt; onesToUpdate) {
		// if an existing one is not among new ones - that needs to be deleted
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">		for (Map.Entry&lt;ID, ForecastProfileList&gt; existingOneEntry : existingOnes.entrySet()) {</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">			if (!listsFromUI.containsKey(existingOneEntry.getKey())) {</span>
<span class="nc" id="L1342">				onesToDelete.add(existingOneEntry.getValue());</span>
			} else {
<span class="nc" id="L1344">				Collection&lt;ForecastProfileList&gt; listColFromUI = listsFromUI.get(existingOneEntry.getKey());</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">				for (ForecastProfileList listFromUI : listColFromUI) {</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">					if (isForecastProfileListModified(existingOneEntry.getValue(), listFromUI)) {</span>
<span class="nc" id="L1347">						onesToUpdate.add(listFromUI);</span>
					}
<span class="nc" id="L1349">				}</span>
			}
<span class="nc" id="L1351">		}</span>
<span class="fc" id="L1352">	}</span>

	private boolean isForecastProfileListModified(ForecastProfileList original, ForecastProfileList oneToCheck) {
<span class="nc bnc" id="L1355" title="All 4 branches missed.">		return (original.getRetries() != oneToCheck.getRetries() || original.getLength() != oneToCheck.getLength());</span>
	}

	private Collection&lt;ForecastProfileList&gt; getForecastProfileListsToCreate(Map&lt;ID, ForecastProfileList&gt; existingOnes,
			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; newOnes) {
<span class="fc" id="L1360">		Collection&lt;ForecastProfileList&gt; onesToCreate = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc bfc" id="L1361" title="All 2 branches covered.">		for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; newOneEntry : newOnes.entrySet()) {</span>
<span class="pc bpc" id="L1362" title="1 of 2 branches missed.">			if (!existingOnes.containsKey(newOneEntry.getKey())) {</span>
<span class="fc" id="L1363">				onesToCreate.addAll(newOneEntry.getValue());</span>
			}
<span class="fc" id="L1365">		}</span>
<span class="fc" id="L1366">		return onesToCreate;</span>
	}

	private void saveForecastTimeSeries(Map&lt;? extends ID, ? extends TraceCube&gt; dataBySPQueueID, ID forecastInstanceID) throws BbmException {
<span class="pc bpc" id="L1370" title="2 of 4 branches missed.">		if (dataBySPQueueID == null || dataBySPQueueID.isEmpty()) return;</span>
<span class="fc" id="L1371">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="fc" id="L1372">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>
<span class="fc" id="L1373">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="fc" id="L1374">		CampaignDAO cDAO = new CampaignDAO();</span>
		try {
			// Get campaign time zone
<span class="fc" id="L1377">			SPQueue spQueue = spQueueDAO.getSPQueuesByIDs(Collections.singleton(dataBySPQueueID.keySet().iterator().next())).iterator().next();</span>
<span class="fc" id="L1378">			SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spQueue.getSpID());</span>
<span class="fc" id="L1379">			Campaign c = cDAO.getCampaign(Collections.singleton(sp.getCampaignID()), false).iterator().next();</span>
<span class="fc" id="L1380">			TimeContext timeContext = TimeContextFactory.getTimeContext(c);</span>

<span class="fc" id="L1382">			String user = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="fc" id="L1384">			Collection&lt;ForecastTimeSeries&gt; ftsToSave = new HashSet&lt;ForecastTimeSeries&gt;();</span>
<span class="fc bfc" id="L1385" title="All 2 branches covered.">			for (ID spQueueID : dataBySPQueueID.keySet()) {</span>
<span class="fc" id="L1386">				TraceCube tc = dataBySPQueueID.get(spQueueID);</span>
<span class="fc bfc" id="L1387" title="All 2 branches covered.">				for (ForecastTimeSeries fts : ForecastTimeSeriesUtil.getForecastTimeSeriesCol(tc, timeContext)) {</span>
<span class="fc" id="L1388">					fts.setCreated(new Date());</span>
<span class="fc" id="L1389">					fts.setCreatedBy(user);</span>
<span class="fc" id="L1390">					fts.setForecastInstanceId(forecastInstanceID);</span>
<span class="fc" id="L1391">					fts.setSpQueueId(spQueueID);</span>
<span class="fc" id="L1392">					ftsToSave.add(fts);</span>
<span class="fc" id="L1393">				}</span>
<span class="fc" id="L1394">			}</span>
			// Delete any old forecasts for the spqueues, then save
<span class="fc" id="L1396">			ftsDAO.deleteObjectsByInstanceAndSPQueueIDs(forecastInstanceID, dataBySPQueueID.keySet());</span>
<span class="fc" id="L1397">			ftsDAO.createObjects(ftsToSave);</span>
<span class="nc" id="L1398">		} catch(Exception ex) {</span>
<span class="nc" id="L1399">			handleException(ex);</span>
<span class="nc" id="L1400">			throw new BbmUpdateException(ex);</span>
		}
		finally {
<span class="pc" id="L1403">			spQueueDAO.cleanUp();</span>
<span class="pc" id="L1404">			spDAO.cleanUp();</span>
<span class="pc" id="L1405">			cDAO.cleanUp();</span>
<span class="pc" id="L1406">			ftsDAO.cleanUp();</span>
<span class="fc" id="L1407">		}</span>
<span class="fc" id="L1408">	}</span>

	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves. If data exists for a SPQueue specified by the
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records with the correct forecastInstanceID set.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveImmediateMediaForecastAsBase(
			String name,
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1429">		methodStart(&quot;saveImmediateMediaForecastAsBase&quot;);</span>

		try {
<span class="pc bpc" id="L1432" title="2 of 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>

			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="fc" id="L1436">			m_forecastTimeSeriesManager.saveImmediateMediaForecastInstance(name, profiles, forecastsBySPQueueID, true); // true means is base forecast</span>

			//recalculate FTE requirements for the given spqueues
<span class="fc" id="L1439">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L1440" title="All 2 branches covered.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="fc" id="L1441">				spqIDs.add(id);</span>
<span class="fc" id="L1442">			}</span>
<span class="fc" id="L1443">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1444">		} catch (Exception e) {</span>
<span class="nc" id="L1445">    		handleException(e);</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1447" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1448">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1450">			methodFinish();</span>
<span class="fc" id="L1451">		}</span>
<span class="fc" id="L1452">	}</span>

	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves. If data exists for a SPQueue specified by the
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records with the correct forecastInstanceID set.
	 * &lt;li&gt; Updates the SPQueue value objects as some data corresponding to the forecast is stored in those value objects.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveDeferredMediaForecastAsBase(
			String name,
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1475">		methodStart(&quot;saveDeferredMediaForecastAsBase&quot;);</span>
		try {
<span class="nc bnc" id="L1477" title="All 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>

			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="nc" id="L1481">			m_forecastTimeSeriesManager.saveDeferredMediaForecastInstance(name, profiles, forecastsBySPQueueID, spQueues, true); // true means is base forecast</span>

			//recalculate FTE requirements for the given spqueues
<span class="nc" id="L1484">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="nc" id="L1486">				spqIDs.add(id);</span>
<span class="nc" id="L1487">			}</span>
<span class="nc" id="L1488">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1489">		} catch (Exception e) {</span>
<span class="nc" id="L1490">			handleException(e);</span>
<span class="nc bnc" id="L1491" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1493">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1495">			methodFinish();</span>
<span class="nc" id="L1496">		}</span>
<span class="nc" id="L1497">	}</span>

	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves.
	 *   If data exists for a SPQueue specified by the passed in ForecastProfile, it will be replaced,
	 *   but existing forecast data for spqueues that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has
	 *   an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records
	 *   with the correct forecastInstanceID set.
	 * &lt;li&gt; Saves the forecasted outbound lists for the given forecast profiles.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveOutboundMediaForecastAsBase(String name, Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1520">		methodStart(&quot;saveOutboundMediaForecastAsBase&quot;);</span>
<span class="nc" id="L1521">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
<span class="nc bnc" id="L1523" title="All 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>

			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="nc" id="L1527">			m_forecastTimeSeriesManager.saveOutboundMediaForecastInstance(name, profiles, forecastsBySPQueueID, listsByProfile, true); // true means is base forecast</span>

			//recalculate FTE requirements for the given spqueues
<span class="nc" id="L1530">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1531" title="All 2 branches missed.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="nc" id="L1532">				spqIDs.add(id);</span>
<span class="nc" id="L1533">			}</span>
<span class="nc" id="L1534">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1535">		} catch (Exception e) {</span>
<span class="nc" id="L1536">    		handleException(e);</span>
<span class="nc bnc" id="L1537" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1539">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1541">			fpDAO.cleanUp();</span>
<span class="nc" id="L1542">			methodFinish();</span>
<span class="nc" id="L1543">		}</span>
<span class="nc" id="L1544">	}</span>

	/**
	 * Checks to see if a base forecast has been set for the given spQueueIDs
	 * @param spQueueIDs
	 * @returns Map&lt;ID, Boolean&gt; of booleans specifying if the base forecast for key SPQueue ID has been set
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Map&lt;ID, Boolean&gt; isBaseForecastSet(Collection&lt;? extends ID&gt; spQueueIDs) throws BbmFinderException {
<span class="pc bpc" id="L1554" title="2 of 4 branches missed.">		if (spQueueIDs == null || spQueueIDs.isEmpty()) return Collections.emptyMap();</span>

<span class="fc" id="L1556">		ForecastInstanceDAO fiDao = new ForecastInstanceDAO();</span>
<span class="fc" id="L1557">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="fc" id="L1558">		ForecastTimeSeriesDAO dao = new ForecastTimeSeriesDAO();</span>
		try {
<span class="fc" id="L1560">			Map&lt;ID, Boolean&gt; retVal = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc bfc" id="L1561" title="All 2 branches covered.">			for (ID id : spQueueIDs) retVal.put(id, Boolean.FALSE);</span>

<span class="fc" id="L1563">			ID spID = null;</span>
<span class="fc" id="L1564">			spID = spqDAO.getObjectByID(spQueueIDs.iterator().next()).getSpID();</span>

<span class="fc" id="L1566">			ForecastInstance baseForecast = fiDao.getBaseForecastInstance(spID);</span>
<span class="fc bfc" id="L1567" title="All 2 branches covered.">			if (baseForecast == null) return retVal;</span>

<span class="fc" id="L1569">			return dao.isForecastSet(baseForecast.getID(), spQueueIDs);</span>
<span class="nc" id="L1570">		} catch (Exception e) {</span>
<span class="nc" id="L1571">			handleException(e);</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L1573">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1575">			spqDAO.cleanUp();</span>
<span class="pc" id="L1576">			fiDao.cleanUp();</span>
<span class="pc" id="L1577">			dao.cleanUp();</span>
		}
	}

	/**
	 * Creates and saves a base forecast instance for the given SchedulingPeriod that includes a copy of the
	 * active forecasts of all of the given sp queues.
	 */
	public void saveActiveForecastAsBase(String name, Collection&lt;ID&gt; spQueueIDs, SchedulingPeriod sp) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1586">		methodStart(&quot;saveActiveForecastAsBase&quot;, name, spQueueIDs, sp);</span>
		try {
<span class="pc bpc" id="L1588" title="2 of 4 branches missed.">			if (spQueueIDs == null || spQueueIDs.isEmpty())</span>
<span class="nc" id="L1589">				return;</span>
			//get active forecast profiles and null out ids to insert as new record
<span class="fc" id="L1591">			Collection&lt;ForecastProfile&gt; profiles = this.getActiveForecastProfilesBySPQueueIDs(spQueueIDs);</span>
<span class="pc bpc" id="L1592" title="2 of 4 branches missed.">			if (profiles == null || profiles.isEmpty()) {</span>
<span class="nc" id="L1593">				return; //no active forecast, nothing to set as the base</span>
			}

			//Load forecast data for each sp queue
<span class="fc" id="L1597">			Map&lt;ID, ForecastTraceCube&gt; forecastsBySPQueueID = getForecastTraceCubesForSPQueues(spQueueIDs,</span>
<span class="fc" id="L1598">					sp.getCampaignID(), sp.getStartTime(), new Date(sp.getEndTime().getTime() - 1));</span>

			//Save the base forecast instance
<span class="fc" id="L1601">			ForecastInstance baseInstance = saveForecastInstance(name, profiles, forecastsBySPQueueID, true);</span>

<span class="fc" id="L1603">			Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesByIDs(spQueueIDs);</span>
<span class="fc" id="L1604">			Map&lt;MediaType, Collection&lt;SPQueue&gt;&gt; spQueueMediaMap = MediaType.getMediaTypeMapForSPQueues(spQueues);</span>

			//Save associated data for outbound forecast instances if there are outbound queues present
<span class="pc bpc" id="L1607" title="2 of 4 branches missed.">			if (spQueueMediaMap.containsKey(MediaType.OUTBOUND) &amp;&amp; spQueueMediaMap.get(MediaType.OUTBOUND).isEmpty() == false) {</span>
				//Load the forecast profile lists (outbound call lists) for the given spqueues.  These will be copied to the
				//base forecast instance.
<span class="fc" id="L1610">				Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsByProfileID = getForecastProfileListsByProfile(profiles);</span>
<span class="fc" id="L1611">				Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsByProfile =</span>
					new HashMap&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt;();
<span class="fc bfc" id="L1613" title="All 2 branches covered.">				for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; entry : forecastProfileListsByProfileID.entrySet()) {</span>
<span class="pc bpc" id="L1614" title="1 of 2 branches missed.">					if (entry.getValue() != null) {</span>
<span class="fc bfc" id="L1615" title="All 2 branches covered.">						for (ForecastProfile profile : profiles) {</span>
<span class="pc bpc" id="L1616" title="1 of 2 branches missed.">							if (entry.getKey().equals(profile.getID())) {</span>
<span class="fc" id="L1617">								forecastProfileListsByProfile.put(profile, entry.getValue());</span>
							}
<span class="fc" id="L1619">						}</span>
					}
<span class="fc" id="L1621">				}</span>
<span class="fc" id="L1622">				saveAssociatedDataForOutboundMediaForecastInstance(baseInstance.getId(), forecastProfileListsByProfile);</span>
			}

			//Save associated data for deferred forecast instances if there are deferred queues present
<span class="pc bpc" id="L1626" title="1 of 2 branches missed.">			if (spQueueMediaMap.containsKey(MediaType.DEFERRED)) {</span>
<span class="nc" id="L1627">				Collection&lt;SPQueue&gt; deferredSPQueues = spQueueMediaMap.get(MediaType.DEFERRED);</span>
<span class="nc" id="L1628">				saveAssociatedDataForDeferredMediaForecastInstance(deferredSPQueues, baseInstance.getID());</span>
			}
<span class="nc" id="L1630">		} catch (Exception e) {</span>
<span class="nc" id="L1631">    		handleException(e);</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1633" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1634">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1636">			methodFinish();</span>
<span class="fc" id="L1637">		}</span>
<span class="fc" id="L1638">	}</span>

	public void deleteForecastInstance(ID forecastInstanceID, Collection&lt;ID&gt; spQueueIDs)throws BbmFinderException
	{
<span class="nc" id="L1642">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="nc" id="L1643">		ForecastInstanceDAO fiDao = new ForecastInstanceDAO();</span>
<span class="nc" id="L1644">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
<span class="nc" id="L1646">			ftsDAO.deleteObjectsByInstanceAndSPQueueIDs(forecastInstanceID, spQueueIDs);</span>
<span class="nc" id="L1647">			fpDAO.deleteObjectsByInstanceAndSPQueues(forecastInstanceID, spQueueIDs);</span>
<span class="nc" id="L1648">			fiDao.deleteObject(forecastInstanceID);</span>
<span class="nc" id="L1649">		}catch (Exception e) {</span>
<span class="nc" id="L1650">			handleException(e);</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L1652">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1654">			ftsDAO.cleanUp();</span>
<span class="nc" id="L1655">			fpDAO.cleanUp();</span>
<span class="nc" id="L1656">			fiDao.cleanUp();</span>
<span class="nc" id="L1657">		}</span>

<span class="nc" id="L1659">	}</span>

	public Collection&lt;ForecastProfileProject&gt; getActiveProjects(Collection&lt;ID&gt; spQueueIDs) throws JdmoException, BbmFinderException
	{
<span class="nc" id="L1663">		Collection&lt;ForecastProfileProject&gt; projects = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1664">		methodStart(&quot;getActiveProjects&quot;, spQueueIDs);</span>
		try {
<span class="nc" id="L1666">			ForecastProfileProjectDAO fppDAO = new ForecastProfileProjectDAO();</span>
<span class="nc" id="L1667">			projects = fppDAO.getActiveForecastProfileProjects(spQueueIDs);</span>
<span class="nc" id="L1668">		} catch(BbmFinderException e){</span>
<span class="nc" id="L1669">			handleException(e,false);</span>
<span class="nc" id="L1670">			throw e;</span>
		} finally {
<span class="nc" id="L1672">			methodFinish();</span>
<span class="nc" id="L1673">		}</span>
<span class="nc" id="L1674">		return projects;</span>
	}

	/**
	 * @param forecastProfile
	 * @return
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private void saveForecastProjectRecords(Collection&lt;ForecastProfileProject&gt; forecastProfileProjects) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1684">		methodStart(&quot;saveForecastProjectRecords&quot;, forecastProfileProjects);</span>
<span class="nc" id="L1685">		ForecastProfileProjectDAO dao = new ForecastProfileProjectDAO();</span>

<span class="nc" id="L1687">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
		try {
<span class="nc" id="L1689">			Collection&lt;ForecastProfileProject&gt; projectsToCreate = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1690">			Collection&lt;ForecastProfileProject&gt; projectsToUpdate = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1691">            Collection&lt;ID&gt; queueSIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1692">            QueueFieldInfo queueFieldInfo = new QueueFieldInfo();</span>

<span class="nc bnc" id="L1694" title="All 2 branches missed.">			for (ForecastProfileProject project : forecastProfileProjects) {</span>
<span class="nc bnc" id="L1695" title="All 2 branches missed.">				if (project.getID() == null)  {</span>
<span class="nc" id="L1696">					project.setCreatedBy(user);</span>
<span class="nc" id="L1697">					project.setCreatedDate(new Date());</span>
<span class="nc" id="L1698">                    queueSIDs.add(project.getQueueID());</span>
<span class="nc" id="L1699">					projectsToCreate.add(project);</span>
				} else {
<span class="nc" id="L1701">					project.setModifiedBy(user);</span>
<span class="nc" id="L1702">					project.setModifiedDate(new Date());</span>
<span class="nc" id="L1703">					projectsToUpdate.add(project);</span>
				}
<span class="nc" id="L1705">			}</span>

<span class="nc bnc" id="L1707" title="All 2 branches missed.">			if (projectsToCreate.isEmpty() == false) {</span>
<span class="nc" id="L1708">                Map&lt;ID, ID&gt; mappedQueueIDs = DAOUtil.mapIDsToDEIDs(queueSIDs, queueFieldInfo);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">                for (ForecastProfileProject project : projectsToCreate) {</span>
<span class="nc" id="L1710">                    project.setQueueID(mappedQueueIDs.get(project.getQueueID()));</span>
<span class="nc" id="L1711">                }</span>
<span class="nc" id="L1712">				dao.createObjects(projectsToCreate);</span>
			}

<span class="nc bnc" id="L1715" title="All 2 branches missed.">			if (projectsToUpdate.isEmpty() == false) {</span>
<span class="nc" id="L1716">				dao.updateObjects(projectsToUpdate);</span>
			}
<span class="nc" id="L1718">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1719">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1720">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1721">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1722">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1723">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1725">			dao.cleanUp();</span>
<span class="nc" id="L1726">			methodFinish();</span>
<span class="nc" id="L1727">		}</span>
<span class="nc" id="L1728">	}</span>

	// {{ ------------------- Start Distributed Allocation -------------------- //

	/**
	 * Updates allocations and related parent or child forecasts to reflect the newly saved
	 * forecast data for the specified SPQueues.
	 * &lt;p/&gt;
	 * For every parent distributed queue in the list of SPQueueIDs, reallocates the
	 * newly saved forecast to its child queues.
	 * &lt;p/&gt;
	 * For every distributed child queue, updates the forecast allocations for its parent
	 * and the parent forecast itself.
	 *
	 * @param savedSPQueueIDs the IDs of the SPQueues for which forecast data has just been
	 * saved.
	 * @param updateSource whether the allocations are being updated as a result of an
	 * update to the parent forecast, or the child forecast, or it is not known which.
	 *
	 * @throws RemoteException
	 * @throws BbmFinderException
	 * @throws BbmUpdateException
	 * @throws BbmCreateException
	 */
	private void updateAllocations(
			Collection&lt;ID&gt; savedSPQueueIDs,
			ForecastUpdateOriginalSource updateSource)
				throws RemoteException, BbmFinderException, BbmUpdateException, BbmCreateException {
		// This call only does something if spQueueId is associated with a parent distributed queue.
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">		if (updateSource != ForecastUpdateOriginalSource.ChildUpdate) {</span>
<span class="fc bfc" id="L1758" title="All 2 branches covered.">			for (ID spQueueId : savedSPQueueIDs) {</span>
<span class="fc" id="L1759">				allocateForecastForSingleOrCombinedQueueIfAppropriate(spQueueId);</span>
<span class="fc" id="L1760">			}</span>
		}
		// If on the other hand this is a distributed child queue we update the parent's
		// allocations and total forecast.
<span class="pc bpc" id="L1764" title="1 of 2 branches missed.">		if (updateSource != ForecastUpdateOriginalSource.ParentUpdate) {</span>
<span class="fc" id="L1765">			Set&lt;SPQueue&gt; parentsToRecalculate = new HashSet&lt;SPQueue&gt;();</span>
<span class="fc bfc" id="L1766" title="All 2 branches covered.">			for (ID spQueueId : savedSPQueueIDs) {</span>
<span class="fc" id="L1767">				SPQueue parentSpQueue = m_campaignManager.getDistributedParentSpQueue(spQueueId);</span>
<span class="pc bpc" id="L1768" title="1 of 2 branches missed.">				if (parentSpQueue != null) {</span>
<span class="nc" id="L1769">					parentsToRecalculate.add(parentSpQueue);</span>
				}
<span class="fc" id="L1771">			}</span>
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">			for (SPQueue parentSpQueue : parentsToRecalculate) {</span>
<span class="nc" id="L1773">				updateChildAllocationsAndRecalculateParentForecast(parentSpQueue);</span>
<span class="nc" id="L1774">			}</span>
		}
<span class="fc" id="L1776">	}</span>

	/**
	 * Returns a map keyed by child SP queue ID of the forecast allocation percentages for
	 * each child SP queue of the specified parent SP queue.
	 *
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildForecastAllocationsForDistributedSpQueue(ID parentSpQueueID)
			throws BbmFinderException {
<span class="nc" id="L1787">		Map&lt;ID, double[]&gt; allocationMap = new HashMap&lt;ID, double[]&gt;();</span>
		try {
<span class="nc" id="L1789">			Collection&lt;ForecastAllocationTimeSeries&gt; allocationRawSeries = getRawChildForecastAllocations(parentSpQueueID);</span>
<span class="nc" id="L1790">			allocationMap = convertTraceSegmentsToDataMap(</span>
<span class="nc" id="L1791">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="nc" id="L1792">					getForecastAllocationTraceSegments(allocationRawSeries),</span>
					DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
		}
<span class="nc" id="L1795">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1796">			handleException(bfe);</span>
<span class="nc" id="L1797">			throw bfe;</span>
		}
<span class="nc" id="L1799">		catch (Exception e) {</span>
<span class="nc" id="L1800">			handleException(e);</span>
<span class="nc" id="L1801">			throw new BbmFinderException(e);</span>
<span class="nc" id="L1802">		}</span>
<span class="nc" id="L1803">		return allocationMap;</span>
	}

	/**
	 * Returns any existing child forecast allocations for the specified parent
	 * SPQueue ID.
	 *
	 * @param parentSpQueueID
	 * @return the child forecast allocations for {@code parentSpQueueID} or an
	 * empty collection if there are none defined
	 * @throws BbmFinderException
	 */
	private Collection&lt;ForecastAllocationTimeSeries&gt; getRawChildForecastAllocations(ID parentSpQueueID)
			throws BbmFinderException {
<span class="nc" id="L1817">		ForecastAllocationTimeSeriesDAO fatsDAO = new ForecastAllocationTimeSeriesDAO();</span>
		try {
<span class="nc" id="L1819">			return fatsDAO.getObjectsByParentID(parentSpQueueID);</span>
		}
		finally {
<span class="nc" id="L1822">			fatsDAO.cleanUp();</span>
		}
	}

	/**
	 * Converts the specified trace segments into a map from child SPQueue ID to data
	 * arrays.
	 * &lt;p/&gt;
	 * If the trace segment collection is empty, fills every data array with zeros.
	 * &lt;p/&gt;
	 * Converts from 96-interval days to DST aware data, filling any Fall-back DST
	 * transitions encountered with the values indicated by the specified fill type.
	 *
	 * @param parentSpQueue
	 * @param traceSegments
	 * @param fillType the strategy for filling in a DST transition interval of the
	 * fall-back variety
	 * @return
	 * @throws BbmFinderException
	 */
	private Map&lt;ID, double[]&gt; convertTraceSegmentsToDataMap(
			SPQueue parentSpQueue,
			Collection&lt;? extends AbstractTraceSegment&lt;? extends ValueObjectBase&gt;&gt; traceSegments,
			DSTTransitionFillType fillType)
				throws BbmFinderException, RemoteException {
<span class="nc" id="L1847">		Map&lt;ID, double[]&gt; dataMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1848">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
		try {
<span class="nc" id="L1850">			ID spId = parentSpQueue.getSpID();</span>
<span class="nc" id="L1851">			SchedulingPeriod sp = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(spId, spDAO.getDaoFieldInfo()));</span>
<span class="nc" id="L1852">			double valueToInsertIntoGaps = 0.0;</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">			if (traceSegments.isEmpty()) {</span>
<span class="nc" id="L1854">				dataMap = createDefaultAllocationMap(sp.getStartTime(), sp.getEndTime(), parentSpQueue.getID());</span>
			} else {
<span class="nc" id="L1856">				dataMap = collateTraceSegments(traceSegments, sp.getStartTime(), sp.getEndTime());</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">				switch (fillType) {</span>
				default:
				case FillWithZeros:
<span class="nc" id="L1860">					valueToInsertIntoGaps = 0;</span>
<span class="nc" id="L1861">					break;</span>
				case FillWithEvenAllocationAcrossQueues:
<span class="nc" id="L1863">					valueToInsertIntoGaps = 100.0 / dataMap.size();</span>
				}
			}
<span class="nc" id="L1866">			dataMap = convertDataMapFromIdealTimeToDSTAwareTime(dataMap, valueToInsertIntoGaps, sp.getStartTime(), m_campaignManager.getChildSPQueueTimeZonesByParentSPQueueID(parentSpQueue.getID()));</span>
		}
		finally {
<span class="nc" id="L1869">			spDAO.cleanUp();</span>
<span class="nc" id="L1870">		}</span>
<span class="nc" id="L1871">		return dataMap;</span>
	}
	/**
	 * Returns a map keyed by child SP queue ID of the predicted allocation percentages for
	 * each child SP queue of the specified parent SP queue.
	 *
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildPredictedAllocationsForDistributedSpQueue(ID parentSpQueueID)
			throws BbmFinderException {
<span class="nc" id="L1882">		Map&lt;ID, double[]&gt; predictedAllocationMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1883">		PredictedAllocationTimeSeriesDAO patsDAO = new PredictedAllocationTimeSeriesDAO();</span>
		try {
<span class="nc" id="L1885">			Collection&lt;PredictedAllocationTimeSeries&gt; predictedAllocationRawSeries = patsDAO.getObjectsByParentID(parentSpQueueID);</span>
<span class="nc" id="L1886">			predictedAllocationMap = convertTraceSegmentsToDataMap(</span>
<span class="nc" id="L1887">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="nc" id="L1888">					getPredictedAllocationTraceSegments(predictedAllocationRawSeries),</span>
					DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
		}
<span class="nc" id="L1891">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1892">			handleException(bfe);</span>
<span class="nc" id="L1893">			throw bfe;</span>
		}
<span class="nc" id="L1895">		catch (Exception e) {</span>
<span class="nc" id="L1896">			handleException(e);</span>
<span class="nc" id="L1897">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L1900">			patsDAO.cleanUp();</span>
<span class="nc" id="L1901">		}</span>
<span class="nc" id="L1902">		return predictedAllocationMap;</span>
	}

	/**
	 * Returns a map keyed by child SP queue ID of the predicted paid staffing levels for
	 * each child SP queue of the specified parent SP queue.
	 *
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildPredictedStaffingForDistributedSpQueue(ID parentSpQueueID)
			throws BbmFinderException {
<span class="nc" id="L1914">		Map&lt;ID, double[]&gt; predictedStaffingMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1915">		PredictedAllocationTimeSeriesDAO patsDAO = new PredictedAllocationTimeSeriesDAO();</span>
		try {
<span class="nc" id="L1917">			Collection&lt;PredictedAllocationTimeSeries&gt; predictedStaffingRawSeries = patsDAO.getObjectsByParentID(parentSpQueueID);</span>
<span class="nc" id="L1918">			predictedStaffingMap = convertTraceSegmentsToDataMap(</span>
<span class="nc" id="L1919">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="nc" id="L1920">					getPredictedStaffingTraceSegments(predictedStaffingRawSeries),</span>
					DSTTransitionFillType.FillWithZeros);
		}
<span class="nc" id="L1923">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1924">			handleException(bfe);</span>
<span class="nc" id="L1925">			throw bfe;</span>
		}
<span class="nc" id="L1927">		catch (Exception e) {</span>
<span class="nc" id="L1928">			handleException(e);</span>
<span class="nc" id="L1929">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L1932">			patsDAO.cleanUp();</span>
<span class="nc" id="L1933">		}</span>
<span class="nc" id="L1934">		return predictedStaffingMap;</span>
	}

	/**
	 * Creates a default forecast allocation map that contains all zeros for the
	 * child SpQueues of the specified parent SpQueue.  The returned time series
	 * are based on idealized 24-hour days and must be further converted to
	 * DST-aware series before being suitable for client use.
	 *
	 * @param startTime
	 * @param endTime
	 * @param distributedSpQueueId
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws JdmoException
	 */
	private Map&lt;ID, double[]&gt; createDefaultAllocationMap(
			Date startTime,
			Date endTime,
			ID distributedSpQueueId)
			throws BbmFinderException, RemoteException {
<span class="nc" id="L1956">		Map&lt;ID, double[]&gt; defaultMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1957">		int numPoints = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, endTime);</span>
<span class="nc bnc" id="L1958" title="All 2 branches missed.">		for (SPQueue spQueue : m_campaignManager.getChildSpQueuesOfDistributedSpQueue(distributedSpQueueId)) {</span>
<span class="nc" id="L1959">			defaultMap.put(spQueue.getID(), new double[numPoints]);</span>
<span class="nc" id="L1960">		}</span>
<span class="nc" id="L1961">		return defaultMap;</span>
	}

	/**
	 * Recalculates all child
	 * forecast allocations for the children of the parent queue based on the latest
	 * saved child forecast data, recalculates the parent forecast volume, and saves all
	 * the resulting data.
	 *
	 * @param parentSpQueue
	 * @param parentQueue
	 * @param parentSchedulingPeriod
	 * @throws BbmFinderException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void updateChildAllocationsAndRecalculateParentForecast(SPQueue parentSpQueue)
			throws BbmFinderException, BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L1980">		Queue parentQueue = new QueueDAO().getObjects(Collections.singleton(parentSpQueue.getQueueID())).iterator().next();</span>
<span class="nc" id="L1981">		ID parentSpId = parentSpQueue.getSpID();</span>
<span class="nc" id="L1982">		SchedulingPeriod parentSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(parentSpId, new SchedulingPeriodFieldInfo()));</span>
<span class="nc" id="L1983">		Collection&lt;ForecastAllocationTimeSeries&gt; rawAllocations = getRawChildForecastAllocations(parentSpQueue.getID());</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">		if ( ! rawAllocations.isEmpty() ) {</span>
<span class="nc" id="L1985">			CampaignDAO campaignDao = new CampaignDAO();</span>
			try {
<span class="nc" id="L1987">				Campaign parentCampaign = campaignDao.getObjectByID(parentSchedulingPeriod.getCampaignID());</span>
<span class="nc" id="L1988">				Collection&lt;ID&gt; queueIds = m_workloadManager.getSubQueues(Collections.singleton(parentQueue.getID()));</span>
<span class="nc" id="L1989">				ForecastTraceCube meta = new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
<span class="nc" id="L1990">				Collection&lt;TraceCube&gt; childForecasts = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
						// We don't have the child campaign ID and the method doesn't use it for
						// a ForecastTraceCube anyway.  If the method ever starts using it we'll
						// get NullPointerExceptions and know we have to fix this.
						null,
						queueIds,
<span class="nc" id="L1997">						parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L1998">						parentSchedulingPeriod.getEndTime());</span>
<span class="nc" id="L1999">				TraceCube parentForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
<span class="nc" id="L2001">						parentCampaign.getID(),</span>
<span class="nc" id="L2002">						Collections.singleton(parentQueue.getID()),</span>
<span class="nc" id="L2003">						parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L2004">						parentSchedulingPeriod.getEndTime()).iterator().next();</span>
<span class="nc bnc" id="L2005" title="All 2 branches missed.">				if ( ! childForecasts.isEmpty() ) {</span>
<span class="nc" id="L2006">					calculateAllocationsAndAdjustParentForecast(</span>
							parentForecast,
							childForecasts,
<span class="nc" id="L2009">							parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L2010">							parentSchedulingPeriod.getEndTime(),</span>
							parentSpQueue,
							parentSchedulingPeriod,
							parentQueue,
							rawAllocations);
				}
			}
			finally {
<span class="nc" id="L2018">				campaignDao.cleanUp();</span>
<span class="nc" id="L2019">			}</span>
		}
<span class="nc" id="L2021">	}</span>

	/**
	 * Recalculates all child
	 * forecast allocations for the children of the parent queue based on the latest
	 * saved child forecast data, recalculates the parent forecast volume, and saves all
	 * the resulting data.
	 *
	 * @param parentForecast
	 * @param childForecasts
	 * @param startTime
	 * @param endTime
	 * @param parentSpQueue
	 * @param parentSp
	 * @param parentQueue
	 * @param oldRawAllocations
	 * @throws BbmFinderException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void calculateAllocationsAndAdjustParentForecast(
			TraceCube parentForecast,
			Collection&lt;TraceCube&gt; childForecasts,
			Date startTime,
			Date endTime,
			SPQueue parentSpQueue,
			SchedulingPeriod parentSp,
			Queue parentQueue,
			Collection&lt;ForecastAllocationTimeSeries&gt; oldRawAllocations)
				throws BbmFinderException, BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L2052">		Map&lt;ID, double[]&gt; oldChildAllocations = convertTraceSegmentsToDataMap(</span>
				parentSpQueue,
<span class="nc" id="L2054">				getForecastAllocationTraceSegments(oldRawAllocations),</span>
				DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
<span class="nc" id="L2056">		Set&lt;ID&gt; childSpQueueIds = oldChildAllocations.keySet();</span>
<span class="nc" id="L2057">		Map&lt;ID, double[]&gt; childAllocations = new HashMap&lt;ID, double[]&gt;();</span>
		// Forecasts and allocation ignore DST
<span class="nc" id="L2059">		int numberOfTimeIntervals = TimeZoneUtil.numberOfDaysRound(startTime, endTime) * Trace.DAYPOINTS;</span>
<span class="nc" id="L2060">		Map&lt;ID, ID&gt; spQueueIdsByQueueIds = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc" id="L2061">		SPQueueDAO spqDao = new SPQueueDAO();</span>
<span class="nc" id="L2062">		CampaignDAO campaignDao = new CampaignDAO();</span>
		try {
<span class="nc bnc" id="L2064" title="All 2 branches missed.">			for (ID childSpQueueId : childSpQueueIds) {</span>
<span class="nc" id="L2065">				SPQueue childSpQueue = spqDao.getObjectByID(childSpQueueId);</span>
<span class="nc" id="L2066">				spQueueIdsByQueueIds.put(childSpQueue.getQueueID(), childSpQueueId);</span>
<span class="nc" id="L2067">				childAllocations.put(childSpQueueId, new double[numberOfTimeIntervals]);</span>
<span class="nc" id="L2068">			}</span>
<span class="nc" id="L2069">			Campaign parentCampaign = campaignDao.getObjectByID(parentSp.getCampaignID());</span>
<span class="nc" id="L2070">			int dayStartHours = parentCampaign.getDayBoundaryOffset() / 60;</span>
<span class="nc" id="L2071">			int dayStartMinutes = parentCampaign.getDayBoundaryOffset() % 60;</span>
<span class="nc" id="L2072">			Calendar currentDateCal = Calendar.getInstance(parentCampaign.getTimeZone());</span>
<span class="nc" id="L2073">			currentDateCal.setTime(startTime);</span>
<span class="nc" id="L2074">			int arrayIndex = 0;</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">			while (currentDateCal.getTime().before(endTime)) {</span>
				// Deliberately avoid taking DST into account when stepping through the
				// scheduling period.
				// We step through each day advancing wall clock in 15-minute increments.
				// This causes us to ignore DST transitions.  We also offset the current
				// hour and minute by the campaign's day start offset.
<span class="nc bnc" id="L2081" title="All 2 branches missed.">				for (int hour = 0; hour &lt; 24; ++hour) {</span>
<span class="nc" id="L2082">					int currentHour = (hour + dayStartHours) % 24;</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">					for (int minute = 0; minute &lt; 60; minute += 15) {</span>
<span class="nc" id="L2084">						int currentMinute = (minute + dayStartMinutes) % 60;</span>
<span class="nc" id="L2085">						Calendar currentTimeCal = Calendar.getInstance(parentCampaign.getTimeZone());</span>
<span class="nc" id="L2086">						currentTimeCal.setTime(currentDateCal.getTime());</span>
						// If the day start offset has pushed us into the next day...
<span class="nc bnc" id="L2088" title="All 6 branches missed.">						if (currentHour &lt; hour || (currentHour == hour &amp;&amp; currentMinute &lt; minute)) {</span>
							// ... then bump the cursor up by one day.
<span class="nc" id="L2090">							currentTimeCal.add(Calendar.DAY_OF_MONTH, 1);</span>
						}
						// TODO: This may run into problems because
						// if you call set(Calendar.MILLISECOND, 0), or seconds, or minutes on a Calendar
						// that's pointing to 1am PDT on an autumn DST transition you get 1am PST which is
						// an hour later.
<span class="nc" id="L2096">						currentTimeCal.set(Calendar.HOUR_OF_DAY, hour);</span>
<span class="nc" id="L2097">						currentTimeCal.set(Calendar.MINUTE, minute);</span>

<span class="nc" id="L2099">						int parentVolumeTotal = 0;</span>
<span class="nc" id="L2100">						double rawTotalWeightedAHT = 0;</span>
<span class="nc bnc" id="L2101" title="All 2 branches missed.">						for (TraceCube childForecast : childForecasts) {</span>
<span class="nc" id="L2102">							int currentVolume = Math.max(0, childForecast.getTraceValue(Trace.CV, currentTimeCal.getTime()));</span>
<span class="nc" id="L2103">							parentVolumeTotal += currentVolume;</span>
<span class="nc" id="L2104">							rawTotalWeightedAHT += currentVolume * Math.max(0, childForecast.getTraceValue(Trace.AHT, currentTimeCal.getTime()));</span>
<span class="nc" id="L2105">						}</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">						for (TraceCube childForecast : childForecasts) {</span>
<span class="nc" id="L2107">							ID childSpQueueID = spQueueIdsByQueueIds.get(childForecast.getQueueID());</span>
							// It's possible that one of the child queues has no forecast allocation percentages,
							// which would imply there is no entry for it in oldRawAllocations and eventually the
							// spQueueIdsByQueueIds map; in that case skip that child queues forecast adjustment
<span class="nc bnc" id="L2111" title="All 2 branches missed.">							if (childSpQueueID == null) {</span>
<span class="nc" id="L2112">								continue;</span>
							}
<span class="nc" id="L2114">							double[] allocationArray = childAllocations.get(childSpQueueID);</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">							if (parentVolumeTotal &gt; 0) {</span>
<span class="nc" id="L2116">								allocationArray[arrayIndex] =</span>
<span class="nc" id="L2117">									Math.max(childForecast.getTraceValue(Trace.CV, currentTimeCal.getTime()), 0.) / parentVolumeTotal * 100;</span>
							} else {
								// if the parent forecast is zero use the old allocation
<span class="nc" id="L2120">								allocationArray[arrayIndex] = oldChildAllocations.get(childSpQueueID)[arrayIndex];</span>
							}
<span class="nc" id="L2122">						}</span>
<span class="nc" id="L2123">						parentForecast.setTraceValue(Trace.CV, parentVolumeTotal, currentTimeCal.getTime(), true);</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">						if (parentVolumeTotal &gt; 0) {</span>
<span class="nc" id="L2125">							parentForecast.setTraceValue(Trace.AHT, TraceUtil.roundDouble(rawTotalWeightedAHT / parentVolumeTotal), currentTimeCal.getTime(), true);</span>
						} else {
<span class="nc" id="L2127">							parentForecast.setTraceValue(Trace.AHT, 0, currentTimeCal.getTime(), true);</span>
						}
<span class="nc" id="L2129">						arrayIndex++;</span>
					}
				}
<span class="nc" id="L2132">				currentDateCal.add(Calendar.DATE, 1);</span>
			}
<span class="nc" id="L2134">			Collection&lt;ForecastProfile&gt; parentProfiles = getOrCreateForecastProfiles(parentSpQueue.getID());</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">			for (ForecastProfile profile : parentProfiles) {</span>
				// Because this save operation is the result of a manual update to a child forecast,
				// the parent forecast is now implicitly manually defined.
<span class="nc" id="L2138">				profile.setIsModified(true);</span>
<span class="nc" id="L2139">			}</span>
<span class="nc" id="L2140">			Map&lt;ID, TraceCube&gt; forecastsBySpQueueId = new HashMap&lt;ID, TraceCube&gt;();</span>
<span class="nc" id="L2141">			forecastsBySpQueueId.put(parentSpQueue.getID(), parentForecast);</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">			if (Media.isMediaImmediate(parentQueue.getMediaID())) {</span>
<span class="nc" id="L2143">				saveImmediateMediaForecastAsActive(</span>
						parentProfiles,
						forecastsBySpQueueId,
						ForecastUpdateOriginalSource.ChildUpdate);
			} else {
<span class="nc" id="L2148">				saveDeferredMediaForecastAsActive(</span>
						parentProfiles,
						forecastsBySpQueueId,
<span class="nc" id="L2151">						Collections.singleton(parentSpQueue),</span>
						ForecastUpdateOriginalSource.ChildUpdate);
			}
<span class="nc" id="L2154">			saveChildForecastAllocationsForDistributedSpQueue(parentSpQueue.getID(), childAllocations);</span>
		}
		finally {
<span class="nc" id="L2157">			campaignDao.cleanUp();</span>
<span class="nc" id="L2158">			spqDao.cleanUp();</span>
<span class="nc" id="L2159">		}</span>
<span class="nc" id="L2160">	}</span>

	/**
	 * If the specified SpQueue is associated with an immediate or deferred media
	 * parent distributed queue (single or combined), and if child queue allocation
	 * percentages have been defined for that queue, this method allocates the currently
	 * saved forecast across the queue's children using the currently defined child allocation
	 * percentages.
	 * &lt;p/&gt;
	 * Otherwise, this method does nothing.
	 *
	 * @param parentSpQueue an immediate or deferred parent distributed SpQueue ID, which
	 * may be either a single parent queue or a single-media combined queue.
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private void allocateForecastForSingleOrCombinedQueueIfAppropriate(ID parentSpQueueID)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L2178">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
<span class="fc" id="L2180">			SPQueue parentSpQueue = spqDao.getObjectByID(parentSpQueueID);</span>
<span class="pc bpc" id="L2181" title="1 of 2 branches missed.">			if (parentSpQueue.getMediaID() == null) {</span>
				// We don't handle combined-combined, but neither does the forecast applet.
<span class="nc" id="L2183">				return;</span>
			}
<span class="pc bpc" id="L2185" title="1 of 2 branches missed.">			if (Media.isMediaImmediate(parentSpQueue.getMediaID()) ||</span>
<span class="nc bnc" id="L2186" title="All 2 branches missed.">				Media.isMediaDeferred(parentSpQueue.getMediaID())) {</span>
<span class="pc bpc" id="L2187" title="1 of 2 branches missed.">				if (parentSpQueue.getQueueID() == null) {</span>
					// We have a combined queue; have to check allocation for every
					// queue.
<span class="nc" id="L2190">					Collection&lt;Queue&gt; singleQueues = m_workloadManager.getNonCombinedQueuesByMediaAndSP(parentSpQueue.getMediaID(), parentSpQueue.getSpID());</span>
<span class="nc bnc" id="L2191" title="All 2 branches missed.">					for (Queue singleQueue : singleQueues) {</span>
<span class="nc" id="L2192">						SPQueue spQueue = m_campaignManager.getSPQueue(parentSpQueue.getSpID(), singleQueue.getID());</span>
<span class="nc" id="L2193">						allocateForecastForSingleQueueIfAppropriate(spQueue);</span>
<span class="nc" id="L2194">					}</span>
<span class="nc" id="L2195">				} else {</span>
<span class="fc" id="L2196">					allocateForecastForSingleQueueIfAppropriate(parentSpQueue);</span>
				}
			}
		}
		finally {
<span class="pc" id="L2201">			spqDao.cleanUp();</span>
<span class="fc" id="L2202">		}</span>
<span class="fc" id="L2203">	}</span>

	/**
	 * If the specified SpQueue is associated with a single immediate or deferred media
	 * parent distributed queue, and if child queue allocation percentages have been
	 * defined for that queue, this method allocates the currently saved forecast
	 * across the queue's children using the currently defined child allocation
	 * percentages.
	 * &lt;p&gt;
	 * Otherwise, this method does nothing.
	 *
	 * @param parentSpQueue an immediate or deferred parent distributed SpQueue ID, which
	 * must be a single parent queue, not combined.
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private void allocateForecastForSingleQueueIfAppropriate(SPQueue parentSpQueue)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L2221">		ID parentQueueId = parentSpQueue.getQueueID();</span>
<span class="pc bpc" id="L2222" title="1 of 2 branches missed.">		if (parentQueueId != null) {</span>
<span class="fc" id="L2223">			QueueDAO queueDao = new QueueDAO(); // Doesn't need cleanup call.</span>
<span class="fc" id="L2224">			Queue queue = queueDao.getObjects(Collections.singleton(parentQueueId)).iterator().next();</span>
<span class="pc bpc" id="L2225" title="1 of 2 branches missed.">			if (queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L2226">				Collection&lt;ForecastAllocationTimeSeries&gt; rawAllocations = getRawChildForecastAllocations(parentSpQueue.getID());</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">				if ( ! rawAllocations.isEmpty() ) {</span>
<span class="nc" id="L2228">					SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="nc" id="L2229">					CampaignDAO campaignDao = new CampaignDAO();</span>
					try {
<span class="nc" id="L2231">						Map&lt;ID, double[]&gt; childAllocations = convertTraceSegmentsToDataMap(</span>
								parentSpQueue,
<span class="nc" id="L2233">								getForecastAllocationTraceSegments(rawAllocations),</span>
								DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
<span class="nc" id="L2235">						ID spId = parentSpQueue.getSpID();</span>
<span class="nc" id="L2236">						SchedulingPeriod parentSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(spId, spDAO.getDaoFieldInfo()));</span>
<span class="nc" id="L2237">						Campaign parentCampaign = campaignDao.getObjectByID(parentSchedulingPeriod.getCampaignID());</span>
<span class="nc" id="L2238">						allocateParentForecastAmongChildren(parentSpQueue, parentSchedulingPeriod, parentCampaign, childAllocations);</span>
					}
					finally {

<span class="nc" id="L2242">						spDAO.cleanUp();</span>
<span class="nc" id="L2243">						campaignDao.cleanUp();</span>
<span class="nc" id="L2244">					}</span>
				}
			}
		}
<span class="fc" id="L2248">	}</span>

	private Collection&lt;ForecastAllocationTraceSegment&gt; getForecastAllocationTraceSegments(Collection&lt;ForecastAllocationTimeSeries&gt; sourceValueObjects) {
<span class="nc" id="L2251">		Collection&lt;ForecastAllocationTraceSegment&gt; destinationSegments = new ArrayList&lt;ForecastAllocationTraceSegment&gt;();</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">		for (ForecastAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2253">			destinationSegments.add(new ForecastAllocationTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2254">		}</span>
<span class="nc" id="L2255">		return destinationSegments;</span>
	}

	private Collection&lt;PredictedAllocationTraceSegment&gt; getPredictedAllocationTraceSegments(Collection&lt;PredictedAllocationTimeSeries&gt; sourceValueObjects) {
<span class="nc" id="L2259">		Collection&lt;PredictedAllocationTraceSegment&gt; destinationSegments = new ArrayList&lt;PredictedAllocationTraceSegment&gt;();</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">		for (PredictedAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2261">			destinationSegments.add(new PredictedAllocationTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2262">		}</span>
<span class="nc" id="L2263">		return destinationSegments;</span>
	}

	private Collection&lt;PredictedStaffingTraceSegment&gt; getPredictedStaffingTraceSegments(Collection&lt;PredictedAllocationTimeSeries&gt; sourceValueObjects) {
<span class="nc" id="L2267">		Collection&lt;PredictedStaffingTraceSegment&gt; destinationSegments = new ArrayList&lt;PredictedStaffingTraceSegment&gt;();</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">		for (PredictedAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2269">			destinationSegments.add(new PredictedStaffingTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2270">		}</span>
<span class="nc" id="L2271">		return destinationSegments;</span>
	}

	/**
	 * Saves distributed child forecast allocations for the specified SPQueue.
	 *
	 * @param parentSpQueueID the SPQueue ID of the parent
	 * @param childAllocations child forecast allocations, keyed by SPQueue ID.
	 * @throws BbmFinderException
	 */
	public void saveChildForecastAllocationsForDistributedSpQueue(
			ID parentSpQueueID,
			Map&lt;ID, double[]&gt; childAllocations)
			throws BbmFinderException {
<span class="nc" id="L2285">		ForecastAllocationTimeSeriesDAO fatsDAO = new ForecastAllocationTimeSeriesDAO();</span>
<span class="nc" id="L2286">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>

		try {
<span class="nc" id="L2289">			String user = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="nc" id="L2291">			Collection&lt;ForecastAllocationTimeSeries&gt; fatsToSave = new HashSet&lt;ForecastAllocationTimeSeries&gt;();</span>
<span class="nc bnc" id="L2292" title="All 2 branches missed.">			for (ID spQueueID : childAllocations.keySet()) {</span>
				// Get child organization time zone
<span class="nc" id="L2294">				SPQueue childSpQueue = spQueueDAO.getSPQueuesByIDs(Collections.singleton(spQueueID)).iterator().next();</span>
<span class="nc" id="L2295">				SchedulingPeriod sp = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(childSpQueue.getSpID(), spQueueDAO.getDaoFieldInfo()));</span>
<span class="nc" id="L2296">				TimeZone timeZone = m_campaignManager.getTimeZoneByCampaignID(sp.getCampaignID());</span>
<span class="nc" id="L2297">				double[] allocations = childAllocations.get(spQueueID);</span>
<span class="nc" id="L2298">				allocations = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(allocations, 0.0, sp.getStartTime(), Duration.fromMinutes(15), timeZone);</span>
<span class="nc" id="L2299">				double[] allocationsToSave = setNegativeValuesToZero(allocations);</span>
<span class="nc bnc" id="L2300" title="All 2 branches missed.">				for (ForecastAllocationTimeSeries fats : splitDataIntoTimeSeries(sp.getStartTime(), timeZone, allocationsToSave)) {</span>
<span class="nc" id="L2301">					fats.setSourceSpQueueId(parentSpQueueID);</span>
<span class="nc" id="L2302">					fats.setDestinationSpQueueId(spQueueID);</span>
<span class="nc" id="L2303">					fats.setCreateDate(new Date());</span>
<span class="nc" id="L2304">					fats.setCreatedBy(user);</span>
<span class="nc" id="L2305">					fatsToSave.add(fats);</span>
<span class="nc" id="L2306">				}</span>
<span class="nc" id="L2307">			}</span>
			// Delete any old forecast allocations for the spqueues, then save
<span class="nc" id="L2309">			fatsDAO.deleteObjectsWithParentID(parentSpQueueID);</span>
<span class="nc" id="L2310">			fatsDAO.createObjects(fatsToSave);</span>
		}
<span class="nc" id="L2312">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2313">			handleException(bfe);</span>
<span class="nc" id="L2314">			throw bfe;</span>
		}
<span class="nc" id="L2316">		catch (BbmRemoveException bre) {</span>
<span class="nc" id="L2317">			handleException(bre);</span>
<span class="nc" id="L2318">			throw new BbmFinderException(bre);</span>
		}
<span class="nc" id="L2320">		catch (BbmCreateException bce) {</span>
<span class="nc" id="L2321">			handleException(bce);</span>
<span class="nc" id="L2322">			throw new BbmFinderException(bce);</span>
		}
<span class="nc" id="L2324">		catch (Exception e) {</span>
<span class="nc" id="L2325">			handleException(e);</span>
<span class="nc" id="L2326">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L2329">			fatsDAO.cleanUp();</span>
<span class="nc" id="L2330">			spQueueDAO.cleanUp();</span>
<span class="nc" id="L2331">		}</span>
<span class="nc" id="L2332">	}</span>

	/**
	 * Obtains the predicted child queue allocations for each distributed parent queue
	 * with the specified media type, aggregates that data according to the specified
	 * granularity, and saves it as the queue's forecast allocation percentages.
	 */
	public void saveAndApplyPredictedAllocationsForCombinedQueueSkilled(
			Campaign campaign,
			SPQueue parentSpQueue,
			SchedulingPeriod schedulingPeriod,
			ID mediaId,
			Duration granularity)
		throws BbmFinderException {
		// For each constituent queue,
		//   * load the predicted allocations for that queue,
		//   * aggregate them to the selected granularity,
		//   * save them as forecast allocations,
		//   * and apply them to that forecast
		try {
<span class="nc" id="L2352">			Collection&lt;Queue&gt; constituentQueues = QueueDAO.getNonCombinedQueuesByMediaAndSP(mediaId, schedulingPeriod.getID());</span>
<span class="nc" id="L2353">			Collection&lt;ID&gt; distributedSpQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">			for (Queue candidate : constituentQueues) {</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">				if (candidate.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L2356">					distributedSpQueueIds.add(SPQueueDAO.getSPQueueID(schedulingPeriod.getID(), candidate.getID()));</span>
				}
<span class="nc" id="L2358">			}</span>
<span class="nc bnc" id="L2359" title="All 2 branches missed.">			for (ID constituentSpQueueId : distributedSpQueueIds) {</span>
<span class="nc" id="L2360">				Map&lt;ID, double[]&gt; childPredictedAllocations = getChildPredictedAllocationsForDistributedSpQueue(constituentSpQueueId);</span>
<span class="nc" id="L2361">				Map&lt;ID, double[]&gt; aggregatedAllocations = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">				for (ID childSpQueueId : childPredictedAllocations.keySet()) {</span>
<span class="nc" id="L2363">					aggregatedAllocations.put(childSpQueueId, TraceOperator.averageArrayWithGranularity(childPredictedAllocations.get(childSpQueueId), granularity));</span>
<span class="nc" id="L2364">				}</span>
<span class="nc" id="L2365">				saveChildForecastAllocationsForDistributedSpQueue(constituentSpQueueId, aggregatedAllocations);</span>
<span class="nc" id="L2366">				allocateParentForecastAmongChildren(parentSpQueue, schedulingPeriod, campaign, aggregatedAllocations);</span>
<span class="nc" id="L2367">			}</span>
		}
<span class="nc" id="L2369">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2370">			handleException(bfe);</span>
<span class="nc" id="L2371">			throw bfe;</span>
		}
<span class="nc" id="L2373">		catch (Exception e) {</span>
<span class="nc" id="L2374">			handleException(e);</span>
<span class="nc" id="L2375">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2376">		}</span>
<span class="nc" id="L2377">	}</span>

	/**
	 * Obtains the predicted child queue allocations for the combined parent queue
	 * with the specified media type, aggregates that data according to the specified
	 * granularity, and saves it to each constituent parent distributed queue for the
	 * specified media type as that queue's forecast allocation percentages.
	 * &lt;p&gt;
	 * Returns a collection of constituent parent queue names for parent queues that
	 * could not be updated because at least one child SpQueue in the combined predicted
	 * allocation data did not have any child queue of the failed parent queue linked to
	 * its scheduling period.
	 */
	public Collection&lt;String&gt; saveAndApplyPredictedAllocationsForCombinedQueueUnskilled(
			Campaign campaign,
			SPQueue parentSpQueue,
			SchedulingPeriod schedulingPeriod,
			ID mediaId,
			Duration granularity)
		throws BbmFinderException {
<span class="nc" id="L2397">		Collection&lt;String&gt; failedParentQueueNames = new ArrayList&lt;String&gt;();</span>
		// Load the predicted allocations for the parent queue,
		// aggregate them to the selected granularity,
		// then for each constituent queue,
		//   * do a sanity check to see if the constituent parent queue has linked subqueues
		//     corresponding to every child SP of the parent SpQueue;
		//       * if that fails, add the constituent parent queue's SpQueue ID to the list of
		//         failed SpQueue IDs,
		//       * otherwise
		//           * save the predicted allocations as forecast allocations,
		//           * and apply them to that forecast
<span class="nc" id="L2408">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
<span class="nc" id="L2410">			Map&lt;ID, double[]&gt; combinedPredictedAllocations = getChildPredictedAllocationsForDistributedSpQueue(parentSpQueue.getID());</span>
<span class="nc" id="L2411">			Map&lt;ID, double[]&gt; aggregatedCombinedAllocations = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc bnc" id="L2412" title="All 2 branches missed.">			for (ID childSpQueueId : combinedPredictedAllocations.keySet()) {</span>
<span class="nc" id="L2413">				aggregatedCombinedAllocations.put(childSpQueueId, TraceOperator.averageArrayWithGranularity(combinedPredictedAllocations.get(childSpQueueId), granularity));</span>
<span class="nc" id="L2414">			}</span>
<span class="nc" id="L2415">			Collection&lt;Queue&gt; constituentQueues = QueueDAO.getNonCombinedQueuesByMediaAndSP(mediaId, schedulingPeriod.getID());</span>
<span class="nc" id="L2416">			Collection&lt;ID&gt; distributedSpQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">			for (Queue candidate : constituentQueues) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">				if (candidate.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L2419">					distributedSpQueueIds.add(SPQueueDAO.getSPQueueID(schedulingPeriod.getID(), candidate.getID()));</span>
				}
<span class="nc" id="L2421">			}</span>
<span class="nc" id="L2422">			QueueDAO queueDao = new QueueDAO();</span>
<span class="nc" id="L2423">			Collection&lt;ID&gt; failedParentQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2424" title="All 2 branches missed.">			for (ID constituentSpQueueId : distributedSpQueueIds) {</span>
<span class="nc" id="L2425">				SPQueue constituentSpQueue = spqDao.getSPQueue(constituentSpQueueId);</span>
<span class="nc" id="L2426">				Map&lt;ID, double[]&gt; mappedAllocations = mapCombinedPredictedAllocationsToConstituentSpQueue(aggregatedCombinedAllocations, constituentSpQueue);</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">				if (mappedAllocations.isEmpty()) {</span>
<span class="nc" id="L2428">					failedParentQueueIds.add(constituentSpQueue.getQueueID());</span>
				} else {
<span class="nc" id="L2430">					saveChildForecastAllocationsForDistributedSpQueue(constituentSpQueueId, mappedAllocations);</span>
<span class="nc" id="L2431">					allocateParentForecastAmongChildren(constituentSpQueue, schedulingPeriod, campaign, mappedAllocations);</span>
				}
<span class="nc" id="L2433">			}</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">			for (Queue failedParentQueue : queueDao.getObjects(failedParentQueueIds)) {</span>
<span class="nc" id="L2435">				failedParentQueueNames.add(failedParentQueue.getName());</span>
<span class="nc" id="L2436">			}</span>
		}
<span class="nc" id="L2438">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2439">			handleException(bfe);</span>
<span class="nc" id="L2440">			throw bfe;</span>
		}
<span class="nc" id="L2442">		catch (Exception e) {</span>
<span class="nc" id="L2443">			handleException(e);</span>
<span class="nc" id="L2444">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L2447">			spqDao.cleanUp();</span>
<span class="nc" id="L2448">		}</span>
<span class="nc" id="L2449">		return failedParentQueueNames;</span>
	}

	/**
	 * For each child SpQueue represented in {@code sourceAllocations}, finds the child
	 * SpQueue of {@code targetSpQueue} with the same scheduling period, and maps
	 * the allocations in {@code sourceAllocations} to that SpQueue ID in the resulting
	 * map.  If no such target SpQueue exists the method stops processing and returns
	 * an empty map.
	 *
	 * @param aggregatedCombinedAllocations
	 * @param constituentSpQueueId
	 * @return
	 */
	private Map&lt;ID, double[]&gt; mapCombinedPredictedAllocationsToConstituentSpQueue(
			Map&lt;ID, double[]&gt; sourceAllocations,
			SPQueue targetSpQueue)
				throws JdmoException, BbmObjectNotFoundException, BbmFinderException, RemoteException {

<span class="nc" id="L2468">		Map&lt;ID, double[]&gt; mappedAllocations = new HashMap&lt;ID, double[]&gt;();</span>

<span class="nc" id="L2470">		Collection&lt;SPQueue&gt; targetChildSpQueues = m_campaignManager.getChildSpQueuesOfDistributedSpQueue(targetSpQueue.getID());</span>

		// If the target SpQueue has fewer children than there are entries in the allocation
		// map, then we already know we're missing a queue somewhere.
<span class="nc bnc" id="L2474" title="All 2 branches missed.">		if (targetChildSpQueues.size() &lt; sourceAllocations.size()) {</span>
<span class="nc" id="L2475">			return Collections.emptyMap();</span>
		}

<span class="nc" id="L2478">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
			// For each child combined spqueue, we try to find a child of the target parent
			// spqueue that has the same SP ID, and if we find it we map the source allocations
			// to the child spqueue that we found.  Otherwise we return null because there was
			// an spqueue in the allocations that had no corresponding child of the target
			// parent.
<span class="nc bnc" id="L2485" title="All 2 branches missed.">			for (ID childCombinedSpQueueId : sourceAllocations.keySet()) {</span>
<span class="nc" id="L2486">				SPQueue childCombinedSpQueue = spqDao.getSPQueue(childCombinedSpQueueId);</span>
<span class="nc" id="L2487">				SPQueue targetChildSpQueue = null;</span>
<span class="nc bnc" id="L2488" title="All 2 branches missed.">				for (SPQueue candidate : targetChildSpQueues) {</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">					if (candidate.getSpID().equals(childCombinedSpQueue.getSpID())) {</span>
<span class="nc" id="L2490">						targetChildSpQueue = candidate;</span>
<span class="nc" id="L2491">						break;</span>
					}
<span class="nc" id="L2493">				}</span>
<span class="nc bnc" id="L2494" title="All 2 branches missed.">				if (targetChildSpQueue == null) {</span>
<span class="nc" id="L2495">					return Collections.emptyMap();</span>
				} else {
<span class="nc" id="L2497">					mappedAllocations.put(targetChildSpQueue.getID(), sourceAllocations.get(childCombinedSpQueue.getID()));</span>
				}
<span class="nc" id="L2499">			}</span>
		}
		finally {
<span class="nc" id="L2502">			spqDao.cleanUp();</span>
<span class="nc" id="L2503">		}</span>

<span class="nc" id="L2505">		return mappedAllocations;</span>
	}

	/**
	 * Collates time series data from a collection of trace segments into a map from ID to
	 * array of data values.  The returned data arrays are based on idealized 24-hour
	 * days and must be further converted to DST-aware data before being suitable for
	 * client use.
	 *
	 * @param dataProviders
	 * @param startTime
	 * @param endTime
	 * @return
	 */
	private Map&lt;ID, double[]&gt; collateTraceSegments(
			Collection&lt;? extends AbstractTraceSegment&lt;? extends ValueObjectBase&gt;&gt; dataProviders,
			Date startTime,
			Date endTime) {

<span class="nc" id="L2524">		Map&lt;ID, double[]&gt; timeSeriesMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L2525">		int numPoints = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, endTime);</span>
<span class="nc bnc" id="L2526" title="All 2 branches missed.">		for (AbstractTraceSegment&lt;? extends ValueObjectBase&gt; dataProvider : dataProviders) {</span>
<span class="nc" id="L2527">			Date rowStart = dataProvider.getDate();</span>
<span class="nc" id="L2528">			int offset = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, rowStart);</span>
<span class="nc" id="L2529">			double[] timeSeries = timeSeriesMap.get(dataProvider.getID());</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">			if (timeSeries == null) {</span>
<span class="nc" id="L2531">				timeSeries = new double[numPoints];</span>
<span class="nc" id="L2532">				timeSeriesMap.put(dataProvider.getID(), timeSeries);</span>
			}
<span class="nc" id="L2534">			double[] sourceArray = dataProvider.getTraceData();</span>
<span class="nc" id="L2535">			System.arraycopy(sourceArray, 0, timeSeries, offset, sourceArray.length);</span>
<span class="nc" id="L2536">		}</span>
<span class="nc" id="L2537">		return timeSeriesMap;</span>
	}

	/**
	 * Converts the array of double values into a collection of {@link ForecastAllocationTimeSeries},
	 * one for each day of data in the original array.
	 *
	 * @param startDate the start date of the array of data
	 * @param timeZone the time zone within which the data are defined
	 * @param data double values, assumed to be specified at 15-minute intervals
	 * @return
	 */
	private Collection&lt;ForecastAllocationTimeSeries&gt; splitDataIntoTimeSeries(Date startDate, TimeZone timeZone, double[] data) {
<span class="nc" id="L2550">		Collection&lt;ForecastAllocationTimeSeries&gt; seriesCollection = new ArrayList&lt;ForecastAllocationTimeSeries&gt;();</span>
<span class="nc" id="L2551">		Calendar currentDateCal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L2552">		currentDateCal.setTime(startDate);</span>
<span class="nc" id="L2553">		int dayStartIndex = 0;</span>
<span class="nc bnc" id="L2554" title="All 2 branches missed.">		while (dayStartIndex &lt; data.length) {</span>
<span class="nc" id="L2555">			ForecastAllocationTimeSeries allocationTimeSeries = new ForecastAllocationTimeSeries();</span>
<span class="nc" id="L2556">			allocationTimeSeries.setDateTime(currentDateCal.getTime());</span>
<span class="nc" id="L2557">			allocationTimeSeries.setAllocationTimeSeries(Arrays.copyOfRange(data, dayStartIndex, dayStartIndex + ALLOCATION_VALUES_PER_ROW));</span>
<span class="nc" id="L2558">			currentDateCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L2559">			seriesCollection.add(allocationTimeSeries);</span>
<span class="nc" id="L2560">			dayStartIndex += ALLOCATION_VALUES_PER_ROW;</span>
<span class="nc" id="L2561">		}</span>
<span class="nc" id="L2562">		return seriesCollection;</span>
	}

	/**
	 * Converts each array in the source map from idealized 24-hour days to DST-aware time, where
	 * a day may be 23, 24, or 25 hours long.
	 *
	 * @param sourceMap
	 * @param valueToInsertIntoGaps
	 * @param startTime
	 * @param timeZone
	 * @return
	 */
	private Map&lt;ID, double[]&gt; convertDataMapFromIdealTimeToDSTAwareTime(Map&lt;ID, double[]&gt; sourceMap, double valueToInsertIntoGaps, Date startTime, Map&lt;ID, TimeZone&gt; childQueueTimeZones) {
<span class="nc" id="L2576">		Map&lt;ID, double[]&gt; resultMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L2577">		Duration fifteenMinutes = Duration.fromMinutes(15);</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">		for (ID childQueueId : sourceMap.keySet()) {</span>
<span class="nc" id="L2579">			double[] idealArray = sourceMap.get(childQueueId);</span>
<span class="nc" id="L2580">			double[] dstAwareArray = DSTConversionUtil.convertFromIdealTimeToDSTAwareTime(idealArray, valueToInsertIntoGaps, startTime, fifteenMinutes, childQueueTimeZones.get(childQueueId));</span>
<span class="nc" id="L2581">			resultMap.put(childQueueId, dstAwareArray);</span>
<span class="nc" id="L2582">		}</span>
<span class="nc" id="L2583">		return resultMap;</span>
	}

	/**
	 * Returns an array of values which are identical to the source values except
	 * that any negative values are replaced by zero.
	 *
	 * @param sourceArray
	 * @return
	 */
	private double[] setNegativeValuesToZero(double[] sourceArray) {
<span class="nc" id="L2594">		double[] targetArray = new double[sourceArray.length];</span>
<span class="nc bnc" id="L2595" title="All 2 branches missed.">		for (int index = 0; index &lt; sourceArray.length; ++index) {</span>
<span class="nc" id="L2596">			targetArray[index] = Math.max(0., sourceArray[index]);</span>
		}
<span class="nc" id="L2598">		return targetArray;</span>
	}

	/**
	 * Applies the specified forecast allocations to the specified parent forecast and
	 * saves the resulting child forecasts as the active forecast for each child queue.
	 *
	 * @param parentSpQueue the parent SP Queue
	 * @param parentSchedulingPeriod
	 * @param parentCampaign
	 * @param childAllocations a map from child SpQueueId to a time series of allocation
	 * percentages for the corresponding child queue
	 *
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public void allocateParentForecastAmongChildren(
			SPQueue parentSpQueue,
			SchedulingPeriod parentSchedulingPeriod,
			Campaign parentCampaign,
			Map&lt;ID, double[]&gt; childAllocations)
		throws BbmFinderException, RemoteException {
<span class="nc" id="L2620">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="nc" id="L2621">		QueueDAO qDAO = new QueueDAO();</span>
		try {
<span class="nc" id="L2623">			ForecastTraceCube meta = new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
<span class="nc" id="L2624">			Collection&lt;ID&gt; queueIds = Collections.singleton(parentSpQueue.getQueueID());</span>
<span class="nc" id="L2625">			Collection&lt;TraceCube&gt; rawParentForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
					meta,
<span class="nc" id="L2627">					parentCampaign.getID(),</span>
					queueIds,
<span class="nc" id="L2629">					parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L2630">					parentSchedulingPeriod.getEndTime());</span>
<span class="nc bnc" id="L2631" title="All 2 branches missed.">			ForecastTraceCube parentForecast = rawParentForecast.size() != 0 ?</span>
<span class="nc" id="L2632">					(ForecastTraceCube)rawParentForecast.iterator().next() :</span>
<span class="nc" id="L2633">					createZeroForecast(parentSpQueue.getQueueID(), parentSchedulingPeriod.getStartTime(), parentSchedulingPeriod.getEndTime());</span>
<span class="nc" id="L2634">			Map&lt;ID, TraceCube&gt; childForecasts = new HashMap&lt;ID, TraceCube&gt;();</span>
<span class="nc" id="L2635">			Collection&lt;ForecastProfile&gt; profiles = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="nc" id="L2636">			Collection&lt;SPQueue&gt; childSpQueues = new HashSet&lt;SPQueue&gt;();</span>
<span class="nc bnc" id="L2637" title="All 2 branches missed.">			for (ID childSpQueueId : childAllocations.keySet()) {</span>
<span class="nc" id="L2638">				SPQueue childSpQueue = spqDAO.getObjectByID(childSpQueueId);</span>
<span class="nc" id="L2639">				SchedulingPeriod childSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(childSpQueue.getSpID(), spqDAO.getDaoFieldInfo()));</span>
<span class="nc" id="L2640">				Collection&lt;TraceCube&gt; rawChildForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
<span class="nc" id="L2642">						childSchedulingPeriod.getCampaignID(),</span>
<span class="nc" id="L2643">						Collections.singleton(childSpQueue.getQueueID()),</span>
<span class="nc" id="L2644">						parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L2645">						parentSchedulingPeriod.getEndTime());</span>
<span class="nc bnc" id="L2646" title="All 2 branches missed.">				ForecastTraceCube childForecast = rawChildForecast.size() != 0 ?</span>
<span class="nc" id="L2647">						(ForecastTraceCube)rawChildForecast.iterator().next() :</span>
<span class="nc" id="L2648">						createZeroForecast(childSpQueue.getQueueID(), childSchedulingPeriod.getStartTime(), childSchedulingPeriod.getEndTime());</span>
<span class="nc" id="L2649">				childForecasts.put(childSpQueueId, childForecast);</span>
<span class="nc" id="L2650">				childSpQueues.add(childSpQueue);</span>
<span class="nc" id="L2651">				profiles.addAll(getOrCreateForecastProfiles(childSpQueueId));</span>
<span class="nc" id="L2652">			}</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">			for (ForecastProfile profile : profiles) {</span>
				// By definition, all child forecasts of distributed queues are manually defined
				// because they are derived by applying the manually defined allocation percentages
				// to the parent forecast, regardless of the source of the parent forecast.
<span class="nc" id="L2657">				profile.setIsModified(true);</span>
<span class="nc" id="L2658">			}</span>
			// Allocate volume
<span class="nc" id="L2660">			TraceOperator.distributeParentToChildren(parentForecast, childForecasts, new short[] {Trace.CV}, childAllocations);</span>
			// Copy AHT
<span class="nc bnc" id="L2662" title="All 2 branches missed.">			for (TraceCube childForecast : childForecasts.values()) {</span>
<span class="nc" id="L2663">				childForecast.setTraceValue(Trace.AHT, parentForecast.getTraceValueD(Trace.AHT, parentForecast.getRawStartDate(), parentForecast.getRawEndDate()), parentForecast.getRawStartDate());</span>
<span class="nc" id="L2664">			}</span>
<span class="nc" id="L2665">			Queue parentQueue = qDAO.getObjects(Collections.singleton(parentSpQueue.getQueueID())).iterator().next();</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">			if (Media.isMediaImmediate(parentQueue.getMediaID())) {</span>
<span class="nc" id="L2667">				saveImmediateMediaForecastAsActive(profiles, childForecasts, ForecastUpdateOriginalSource.ParentUpdate);</span>
			} else {
<span class="nc" id="L2669">				saveDeferredMediaForecastAsActive(profiles, childForecasts, childSpQueues, ForecastUpdateOriginalSource.ParentUpdate);</span>
			}
		}
<span class="nc" id="L2672">		catch (BbmTimeSeriesException btse) {</span>
<span class="nc" id="L2673">			handleException(btse);</span>
<span class="nc" id="L2674">			throw new BbmFinderException(btse);</span>
		}
<span class="nc" id="L2676">		catch (BbmCreateException bce) {</span>
<span class="nc" id="L2677">			handleException(bce);</span>
<span class="nc" id="L2678">			throw new BbmFinderException(bce);</span>
		}
<span class="nc" id="L2680">		catch (BbmUpdateException bue) {</span>
<span class="nc" id="L2681">			handleException(bue);</span>
<span class="nc" id="L2682">			throw new BbmFinderException(bue);</span>
		}
		finally {
<span class="nc" id="L2685">			spqDAO.cleanUp();</span>
<span class="nc" id="L2686">		}</span>
<span class="nc" id="L2687">	}</span>

	/**
	 * Loads any forecast profiles that exist for the specified SPQueue ID.  If there are none,
	 * creates a forecast profile for each week of the associated SP.
	 *
	 * @param spQueueID
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Collection&lt;ForecastProfile&gt; getOrCreateForecastProfiles(ID spQueueID)
			throws BbmFinderException, RemoteException {
<span class="nc" id="L2700">		Collection&lt;ForecastProfile&gt; profiles = getActiveForecastProfilesBySPQueueIDs(Collections.singleton(spQueueID));</span>
<span class="nc bnc" id="L2701" title="All 2 branches missed.">		if (profiles.isEmpty()) {</span>
<span class="nc" id="L2702">			SPQueue spq = m_campaignManager.getSPQueue(spQueueID);</span>
			// This roundabout way of obtaining the weeks of the SP ensures that the
			// HOOs and the profiles are in sync.  There may be even better ways of doing
			// this, though.  I copied it from ForecastModelService.
<span class="nc" id="L2706">			Collection&lt;CampaignHOO&gt; hoos = m_campaignManager.getCampaignHOOAssignmentsBySP(spq.getSpID());</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">			for (CampaignHOO hoo : hoos) {</span>
<span class="nc" id="L2708">				ForecastProfile forecastProfile = new ForecastProfile();</span>
<span class="nc" id="L2709">				forecastProfile.setSPQueueID(spQueueID);</span>
<span class="nc" id="L2710">				forecastProfile.setStartDate(hoo.getStartTime());</span>
<span class="nc" id="L2711">				forecastProfile.setEndDate(hoo.getEndTime());</span>
<span class="nc" id="L2712">				profiles.add(forecastProfile);</span>
<span class="nc" id="L2713">			}</span>
		}
<span class="nc" id="L2715">		return profiles;</span>
	}

	/**
	 * Creates a {@link ForecastTraceCube} whose volume, AHT, and CV/VH traces
	 * are all filled with zeros.
	 *
	 * @param queueId
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	private static ForecastTraceCube createZeroForecast(ID queueId, Date start, Date end) throws BbmTimeSeriesException {
<span class="nc" id="L2729">		short[] types = new short[] {Trace.CV, Trace.AHT, Trace.CV_VH};</span>
<span class="nc" id="L2730">		ForecastTraceCube result = new ForecastTraceCube(queueId, start, end, types);</span>
<span class="nc bnc" id="L2731" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L2732">			result.initTraceValue(type, 0);</span>
		}
<span class="nc" id="L2734">		return result;</span>
	}

	// }} ------------------- End Distributed Allocation -------------------- //

	/**
	 * Returns a trace cube containing any strategic forecast volume or AHT values
	 * that exist within the specified time range.  Any part of the trace cube
	 * for which values were not available will contain Trace.TRACENA.
	 *
	 * @param queueId
	 * @param startTime
	 * @param endTime
	 * @return
	 * @throws BbmFinderException
	 */
	public TraceCube getStrategicForecast(ID queueId, Date startTime, Date endTime)
			throws BbmFinderException {
<span class="nc" id="L2752">		StrategicForecastDAO strategicDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2754">			return strategicDAO.getStrategicForecastTraceCube(queueId, startTime, endTime);</span>
		}
<span class="nc" id="L2756">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2757">			handleException(bfe);</span>
<span class="nc" id="L2758">			throw bfe;</span>
		}
<span class="nc" id="L2760">		catch (Exception e) {</span>
<span class="nc" id="L2761">			handleException(e);</span>
<span class="nc" id="L2762">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L2765">			strategicDAO.cleanUp();</span>
		}
	}

	public void deleteStrategicForecast(ID queueId, Date startTime, Date endTime)
			throws BbmFinderException, BbmRemoveException {
<span class="nc" id="L2771">		StrategicForecastDAO strategicDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2773">			strategicDAO.deleteStrategicForecasts(queueId, startTime, endTime);</span>
<span class="nc" id="L2774">		} catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2775">			handleException(bfe);</span>
<span class="nc" id="L2776">			throw bfe;</span>
<span class="nc" id="L2777">		} catch (JdmoException e) {</span>
<span class="nc" id="L2778">			handleException(e);</span>
<span class="nc" id="L2779">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L2781">			strategicDAO.cleanUp();</span>
<span class="nc" id="L2782">		}</span>
<span class="nc" id="L2783">	}</span>


	public void createStrategicForecast(Collection&lt;StrategicForecast&gt; strategicForecastList)
			throws BbmCreateException {
<span class="nc" id="L2788">		methodStart(&quot;createStrategicForecast&quot;, strategicForecastList);</span>
<span class="nc" id="L2789">		StrategicForecastDAO strategicForecastDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2791">			strategicForecastDAO.createObjects(strategicForecastList);</span>
<span class="nc" id="L2792">		} catch (Exception e) {</span>
<span class="nc" id="L2793">			handleException(e);</span>
<span class="nc" id="L2794">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L2796">			methodFinish();</span>
<span class="nc" id="L2797">			strategicForecastDAO.cleanUp();</span>
<span class="nc" id="L2798">		}</span>
<span class="nc" id="L2799">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L2804">		return m_cat;</span>
	}

	/**
	 * This method is used by the outbound forecast API.  When saving an outbound forecast, the associated forecast profiles
	 * are saved first and when that occurs, it is possible that the IDs on the forecast profiles get updated (sometimes the profiles
	 * are cloned before they are saved if we are saving a new instance for example).  When this happens, the IDs on the old forecast
	 * profiles are no longer valid for the associated forecast profile lists.  What we need to do then is take the ID from the new
	 * profiles and assign that forecast profile ID to its associated forecasted call lists.  This method returns a map of new forecast
	 * profile IDs and the forecasted call lists that are associated to that ID.  The lists themselves will also have thier forecast profile IDs
	 * updated.
	 *
	 * The forecasted lists coming out of this method can then be saved since they now have the correct forecast profile ID.
	 */
	private Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; getOutboundProfileListsByForecastProfileID(Collection&lt;ForecastProfile&gt; newProfiles,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByOldProfile) {
		//We know that when we make the call to saveForecastInstance above, it is possible that the profiles
		//are actually deleted and new ones created rather than just updating.  What we need to do then is
		//update the forecast profile IDs on the forecast profile lists with the new IDs before we save the lists.
<span class="fc" id="L2823">		Map&lt;ForecastProfile, ID&gt; profileToNewIDMap = new HashMap&lt;ForecastProfile, ID&gt;();</span>
<span class="fc bfc" id="L2824" title="All 2 branches covered.">		for (ForecastProfile oldProfile : listsByOldProfile.keySet()) {</span>
<span class="fc bfc" id="L2825" title="All 2 branches covered.">			for (ForecastProfile newProfile : newProfiles) {</span>
<span class="pc bpc" id="L2826" title="1 of 2 branches missed.">				if (oldProfile.areSPQueuesAndStartDatesEqual(newProfile)) {</span>
<span class="fc" id="L2827">					profileToNewIDMap.put(oldProfile, newProfile.getStringID());</span>
				}
<span class="fc" id="L2829">			}</span>
<span class="fc" id="L2830">		}</span>
<span class="fc" id="L2831">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsByProfileId = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
<span class="fc bfc" id="L2832" title="All 2 branches covered.">		for (ForecastProfile oldProfile : listsByOldProfile.keySet()) {</span>
<span class="fc bfc" id="L2833" title="All 2 branches covered.">			for (ForecastProfileList profileList : listsByOldProfile.get(oldProfile)) {</span>
<span class="fc" id="L2834">				profileList.setProfileId(profileToNewIDMap.get(oldProfile));</span>
<span class="fc" id="L2835">			}</span>
<span class="fc" id="L2836">			listsByProfileId.put(profileToNewIDMap.get(oldProfile), listsByOldProfile.get(oldProfile));</span>
<span class="fc" id="L2837">		}</span>

<span class="fc" id="L2839">		return listsByProfileId;</span>
	}
	/*
	 * Though it is returning a collection of Interim Backlog it would only contain one backlog entry.
	 * As for every ForecastinstanceID and SPQueueID there is supposed to be only one backlog entry in the table
	 */
	public Collection&lt;ForecastInterimBacklog&gt; getInterimBacklogByInstanceIDnSPQID(ID forecastInstanceID , Collection&lt;ID&gt; spQueueIDs)throws BbmFinderException{

<span class="nc" id="L2847">		Collection&lt;ForecastInterimBacklog&gt; fibs = null;</span>
<span class="nc" id="L2848">		ForecastInterimBacklogDAO fibDAO  = null;</span>
		try {
<span class="nc" id="L2850">			fibDAO = new ForecastInterimBacklogDAO();</span>
<span class="nc" id="L2851">			fibs = fibDAO.getInterimBacklogForForecastInstance(spQueueIDs, DAOUtil.mapIDToSID(forecastInstanceID, new ForecastInstanceFieldInfo()));</span>
<span class="nc" id="L2852">		} catch (MultiUserException e) {</span>
<span class="nc" id="L2853">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2854">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2855">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2856">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2857">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2858">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L2859">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2860">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2861">		} catch (JdmoException e) {</span>
<span class="nc" id="L2862">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2863">			throw new BbmFinderException(e);</span>
		}finally{
<span class="nc bnc" id="L2865" title="All 4 branches missed.">			if(fibDAO != null){</span>
<span class="nc" id="L2866">				fibDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L2869">		return fibs;</span>
	}

	/**
	 * Indicates the original source of a forecast update.  Used to prevent infinite looping
	 * of updates in a distributed forecast because parent forecasts are updated when the child
	 * forecast is updated and vice versa.
	 */
<span class="pc" id="L2877">	public static enum ForecastUpdateOriginalSource {</span>
		/** A child forecast is being saved because of an update to a parent forecast. */
<span class="fc" id="L2879">		ParentUpdate,</span>
		/** A parent forecast is being saved because of an update to a child forecast. */
<span class="fc" id="L2881">		ChildUpdate,</span>
		/** Nothing is known about whether the forecast being saved is a parent forecast, a child forecast, or neither. */
<span class="fc" id="L2883">		UnknownUpdate</span>
	}

	/**
	 * Indicates how DST transition intervals are to be filled with data when converting
	 * from ideal time to DST-aware time, if the raw data was not already empty.
	 */
<span class="pc" id="L2890">	private static enum DSTTransitionFillType {</span>
		/** The transition period is to be filled with all zeros. */
<span class="nc" id="L2892">		FillWithZeros,</span>
		/** The transition period is to be filled with 100.0 / (number of queues) */
<span class="nc" id="L2894">		FillWithEvenAllocationAcrossQueues</span>
	}

	/**
	 * Loads and returns forecast data in a ForecastTraceCube for each of the given
	 * SPQueues in spQueueIDs.  The trace types of each cube are determined by the media
	 * type of the queue.
	 *
	 * If a combined SPQueue is handed in, the ForecastTraceCube that is returned will be
	 * an aggregation of the constituent sp queues.
	 *
	 * This method assumes that all of the given SPQueues belong to the same campaign.  The
	 * SPQueues can be any combination of media types.
	 *
	 * @param spQueueIDs - a collection of SPQueues for which forecast data will be retrieved.
	 * Must all belong to the same campaign but can be any combination of media type.
	 * @param campaignID - campaign ID of the given SPQueues.
	 * @param startDate - start period of the data to retrieve
	 * @param endDate - end period of the data to retrieve
	 * @return A map of SPQueueID -&gt; ForecastTraceCube
	 */
	public Map&lt;ID, ForecastTraceCube&gt; getForecastTraceCubesForSPQueues(
			Collection&lt;ID&gt; spQueueIDs,
			ID campaignID,
			Date startDate,
			Date endDate)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException
	{
<span class="fc" id="L2922">		Map&lt;ID, ForecastTraceCube&gt; retVal = new HashMap&lt;ID, ForecastTraceCube&gt;();</span>
<span class="fc" id="L2923">		Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesByIDs(spQueueIDs);</span>
		//Separate combined and non-combined spqueues and then group the non-combined queues by media type
<span class="fc" id="L2925">		Collection&lt;SPQueue&gt; combinedSPQueues = new ArrayList&lt;SPQueue&gt;();</span>
<span class="fc" id="L2926">		Collection&lt;SPQueue&gt; nonCombinedSPQueues = new ArrayList&lt;SPQueue&gt;(spQueues);</span>

		//First we'll separate the combined from the non-combined
<span class="fc bfc" id="L2929" title="All 2 branches covered.">		for (Iterator&lt;SPQueue&gt; iter = nonCombinedSPQueues.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2930">			SPQueue spQueue = iter.next();</span>
<span class="pc bpc" id="L2931" title="1 of 2 branches missed.">			if (spQueue.getQueueID() == null) {</span>
<span class="nc" id="L2932">				combinedSPQueues.add(spQueue);</span>
<span class="nc" id="L2933">				iter.remove();</span>
			}
<span class="fc" id="L2935">		}</span>

		//Group non-combined queues by media type.  Different media types use different trace types in their meta trace cubes
<span class="fc" id="L2938">		Map&lt;MediaType, Collection&lt;SPQueue&gt;&gt; nonCombinedSPQueueMediaMap = MediaType.getMediaTypeMapForSPQueues(nonCombinedSPQueues);</span>

		//Load forecast data for non-combined spqueues
<span class="fc bfc" id="L2941" title="All 2 branches covered.">		for (Map.Entry&lt;MediaType, Collection&lt;SPQueue&gt;&gt; entry : nonCombinedSPQueueMediaMap.entrySet()) {</span>
			//key = queueID, value = associated spqueue
<span class="fc" id="L2943">			Map&lt;ID, SPQueue&gt; queueIDSPQueueMap = ValueObjectUtil.getFieldObjectMap(</span>
<span class="fc" id="L2944">					SPQueueFieldInfo.SPQUEUE_QUEUEID, entry.getValue());</span>
<span class="fc" id="L2945">			Collection&lt;TraceCube&gt; forecasts = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
<span class="fc" id="L2946">					ForecastTraceCubeUtil.getMetaTraceCubeForMediaType(entry.getKey()), campaignID,</span>
<span class="fc" id="L2947">					queueIDSPQueueMap.keySet(), startDate, endDate);</span>
<span class="pc bpc" id="L2948" title="2 of 4 branches missed.">			if (forecasts != null &amp;&amp; forecasts.isEmpty() == false) {</span>
<span class="fc bfc" id="L2949" title="All 2 branches covered.">				for (TraceCube forecast : forecasts) {</span>
					//The TraceCubes have queueIDs set on them.  Use the queueID to look up the SPQueueID
					//and put the spqueueID + cube in the return map.
<span class="pc bpc" id="L2952" title="1 of 2 branches missed.">					if (queueIDSPQueueMap.containsKey(forecast.getQueueID())) {</span>
<span class="fc" id="L2953">						retVal.put(queueIDSPQueueMap.get(forecast.getQueueID()).getID(),</span>
								(ForecastTraceCube)forecast);
					}
<span class="fc" id="L2956">				}</span>
			}
<span class="fc" id="L2958">		}</span>

		//Load forecast data for combined spqueues
<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">		for (SPQueue combinedSPQueue : combinedSPQueues) {</span>
<span class="nc" id="L2962">			Collection&lt;TraceCube&gt; constituentForecasts = m_timeSeriesManager.getRawCombinedQueuesTimeSeries(</span>
<span class="nc" id="L2963">					ForecastTraceCubeUtil.getMetaTraceCubeForMediaType(MediaType.get(combinedSPQueue.getMediaID())),</span>
<span class="nc" id="L2964">					campaignID, combinedSPQueue.getMediaID(), startDate, endDate);</span>
<span class="nc bnc" id="L2965" title="All 4 branches missed.">			if (constituentForecasts != null &amp;&amp; constituentForecasts.isEmpty() == false) {</span>
				//Combine the constituent forecasts
<span class="nc" id="L2967">				Map&lt;ID, ID&gt; queueMediaMap = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc bnc" id="L2968" title="All 2 branches missed.">				for (TraceCube traceCube : constituentForecasts) {</span>
<span class="nc" id="L2969">					queueMediaMap.put(traceCube.getQueueID(), combinedSPQueue.getMediaID());</span>
<span class="nc" id="L2970">				}</span>
<span class="nc" id="L2971">				ForecastTraceCube[] forecastArray =</span>
<span class="nc" id="L2972">					(ForecastTraceCube[])constituentForecasts.toArray(new ForecastTraceCube[constituentForecasts.size()]);</span>
<span class="nc" id="L2973">				ForecastTraceCube aggregatedForecast = (ForecastTraceCube)TraceOperator.combineQueue(forecastArray, true, queueMediaMap);</span>
<span class="nc" id="L2974">				retVal.put(combinedSPQueue.getID(), aggregatedForecast);</span>
			}
<span class="nc" id="L2976">		}</span>

		//For any SPQueue that does not have forecast data associated to it, create a forecast trace cube populated with zero values
<span class="fc bfc" id="L2979" title="All 2 branches covered.">		for (SPQueue spQueue : spQueues) {</span>
<span class="pc bpc" id="L2980" title="1 of 2 branches missed.">			if (retVal.containsKey(spQueue.getID()) == false) {</span>
<span class="nc" id="L2981">				retVal.put(spQueue.getID(),</span>
<span class="nc" id="L2982">					ForecastTraceCubeUtil.createZeroForecast(spQueue.getMediaID(), spQueue.getQueueID(), startDate, endDate));</span>
			}
<span class="fc" id="L2984">		}</span>

<span class="fc" id="L2986">		return retVal;</span>
	}

	/**
	 * SP Queues that have already been cloned but do not yet have a forecast time series generated after the clone
	 * operation will need to have their forecasts calculated and persisted.  This method determines which of the
	 * given SP Queues require a recalculation of their forecast data.
	 * @param spDeid - The string based ID of the SP containing these SP Queues.
	 * @param spQueuesToIdentify - List of SP Queues to verify.
	 * @return - Collection&lt;SPQueue&gt; - A subset of spQueuesToIdentify containing the sp queues that require forecast
	 * generation.
	 */
	private Collection&lt;SPQueue&gt; filterQueuesRequiringForecastGeneration(ID spDeid,
			Collection&lt;SPQueue&gt; spQueuesToIdentify) throws JdmoException {

<span class="nc" id="L3001">		methodStart(&quot;filterQueuesRequiringForecastGeneration&quot;, spDeid, spQueuesToIdentify);</span>

<span class="nc bnc" id="L3003" title="All 4 branches missed.">		if (spQueuesToIdentify == null || spQueuesToIdentify.isEmpty()) {</span>
<span class="nc" id="L3004">			return Collections.emptyList();</span>
		}
<span class="nc" id="L3006">		Map&lt;ID, SPQueue&gt; spQueueMap =</span>
<span class="nc" id="L3007">				ValueObjectUtil.getFieldObjectMap(SPQueueFieldInfo.SPQUEUE_ID, spQueuesToIdentify);</span>

<span class="nc" id="L3009">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L3010">		Collection&lt;SPQueue&gt; retVal = new ArrayList&lt;SPQueue&gt;();</span>
		try {
<span class="nc" id="L3012">			JdmoQuery query = dmo.createQuery(&quot;CLONESP_CHECKRELATIVEPROFILEDATA&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="nc" id="L3013">			query.setParID(1, spDeid);</span>
<span class="nc" id="L3014">			JdmoRowset rs = dmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L3015" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3016">				ID spQueueNeedingForecast = rs.getID(1);</span>
<span class="nc bnc" id="L3017" title="All 2 branches missed.">				if (spQueueNeedingForecast != null) {</span>
<span class="nc" id="L3018">					retVal.add(spQueueMap.get(spQueueNeedingForecast));</span>
				} else {
<span class="nc" id="L3020">					m_cat.warn(&quot;CLONESP_CHECKRELATIVEPROFILEDATA returned NULL SPQueue IDs for SP &quot; + spDeid);</span>
				}
<span class="nc" id="L3022">			}</span>
<span class="nc" id="L3023">			rs.close();</span>
			//An SP Queue requires forecast generation if it does not already have ForecastTimeSeries data persisted in
			//the database AND it also has profile components linked to its forecast profile.
<span class="nc bnc" id="L3026" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3027">				m_cat.debug(&quot;ForecastTimeSeriesManager.filterQueuesRequiringForecastGeneration: Returning &quot; +</span>
<span class="nc" id="L3028">						Arrays.toString(retVal.toArray()));</span>
			}
<span class="nc" id="L3030">			return retVal;</span>
<span class="nc" id="L3031">		} catch (JdmoException ex) {</span>
<span class="nc" id="L3032">			handleException(ex);</span>
<span class="nc" id="L3033">			throw ex;</span>
		} finally {
<span class="nc" id="L3035">			dmo.cleanUp();</span>
<span class="nc" id="L3036">			methodFinish();</span>
		}
	}

	/**
	 * Generates forecast time series data for some SPQueues in the given target sp.  The SPQueues that will
	 * have their forecasts generated are the ones that could not have their forecasts generated in the
	 * Clone SP stored procedure because of limitations in that stored procedure.  The SPQueues requiring
	 * forecast generation are the ones which have forecasts containing relative profile components.
	 *
	 * This method is intended to be used during the Clone SP operation, after the CloneSp stored procedure
	 * has been executed.
	 *
	 * This method will generate forecast time series data for the SPQueues that require it, persist that
	 * forecast data, and then re-calculate and persist the FTE Requirements time series for those SPQueues.
	 * @param sp - The new, recently cloned SP.
	 */
	public void recalculateForecastDataForClonedSp(SchedulingPeriod sp) throws BbmException, RemoteException,
			JdmoException {

<span class="nc" id="L3056">		methodStart(&quot;recalculateForecastDataForClonedSp&quot;, sp);</span>

		try {
<span class="nc" id="L3059">			m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - generating data for Sp Id:&quot; +</span>
<span class="nc" id="L3060">					sp.getID());</span>
<span class="nc" id="L3061">			Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesBySPIDsFixed(Collections.singleton(sp.getID()));</span>

<span class="nc" id="L3063">			spQueues = filterQueuesRequiringForecastGeneration(sp.getDEID(), spQueues);</span>

<span class="nc bnc" id="L3065" title="All 2 branches missed.">			if (!spQueues.isEmpty()) {</span>
				// Doesn't need cleanup call.
<span class="nc" id="L3067">				QueueDAO queueDao = new QueueDAO();</span>
<span class="nc" id="L3068">				Campaign campaign = m_campaignManager.getCampaignByID(sp.getCampaignID());</span>
<span class="nc" id="L3069">				Collection&lt;ForecastProfile&gt; fps =</span>
<span class="nc" id="L3070">						getActiveForecastProfilesBySPQueueIDs(ValueObjectUtil.getIDFromObjects(spQueues));</span>
<span class="nc" id="L3071">				Collection&lt;Queue&gt; queues = queueDao.getObjects(</span>
<span class="nc" id="L3072">						ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues));</span>
<span class="nc" id="L3073">				Map&lt;ID, Queue&gt; queueIdMap = ValueObjectUtil.getIDObjectMap(queues);</span>
<span class="nc" id="L3074">				Map&lt;ID, SPQueue&gt; spQueueIdMap = ValueObjectUtil.getIDObjectMap(spQueues);</span>
<span class="nc" id="L3075">				ForecastCalculationResult result = recalculateForecastForForecastProfiles(fps, campaign, sp, spQueueIdMap,</span>
						queueIdMap);

<span class="nc" id="L3078">				Map&lt;ID, TraceCube&gt; forecastDataBySpQueueId = result.getConcatenatedForecastData();</span>

				//Convert OutboundClientForecastTraceCubes to standard ForecastTraceCubes before saving
<span class="nc" id="L3081">				convertOutboundForecastsToSavableFormat(forecastDataBySpQueueId, queueIdMap);</span>

				//Persist forecast time series data
<span class="nc" id="L3084">				saveForecastTimeSeries(forecastDataBySpQueueId, null);</span>

				//Persist forecasted outbound call lists
<span class="nc" id="L3087">				createForecastProfileLists(result.getForecastProfileLists());</span>

				//Generate FTE Requirements using new forecasts
<span class="nc" id="L3090">				FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIdMap.keySet(), forecastDataBySpQueueId,</span>
						m_whatIfMode);
			}
<span class="nc" id="L3093">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3094">			handleException(ex);</span>
<span class="nc" id="L3095">			throw ex;</span>
<span class="nc" id="L3096">		} catch (JdmoException ex) {</span>
<span class="nc" id="L3097">			handleException(ex);</span>
<span class="nc" id="L3098">			throw ex;</span>
<span class="nc" id="L3099">		} catch (BbmException ex) {</span>
<span class="nc" id="L3100">			handleException(ex);</span>
<span class="nc" id="L3101">			throw ex;</span>
		} finally {
<span class="nc" id="L3103">			methodFinish();</span>
<span class="nc" id="L3104">		}</span>
<span class="nc" id="L3105">	}</span>

	/**
	 * Recalculates forecast data for the given ForecastProfiles.
	 *
	 * @param fps - Collection of ForecastProfiles for which forecast data will be calculated
	 * @param campaign - Campaign linked to the forecast profiles
	 * @param sp - SP linked to the campaign/forecast profiles
	 * @param spQueueIdMap - ID/SPQueue map of SPQueues linked to the SP/forecast profiles
	 * @param queueIdMap - ID/Queue map of Queues linked to the SP/forecast profiles
	 * @return ForecastCalculationResult containing the calculated forecast time series data and calculated
	 * ForecastProfileLists for the given ForecastProfiles.
	 */
	private ForecastCalculationResult recalculateForecastForForecastProfiles(Collection&lt;ForecastProfile&gt; fps,
			Campaign campaign, SchedulingPeriod sp, Map&lt;ID, SPQueue&gt; spQueueIdMap, Map&lt;ID, Queue&gt; queueIdMap)
			throws BbmException, RemoteException {

<span class="nc" id="L3122">		methodStart(&quot;recalculateForecastForForecastProfiles&quot;, campaign, sp, fps, spQueueIdMap, queueIdMap);</span>

		try {
<span class="nc" id="L3125">			Map&lt;ID, Collection&lt;TraceCube&gt;&gt; recalculatedForecastsBySpQueue = new HashMap&lt;ID, Collection&lt;TraceCube&gt;&gt;();</span>
<span class="nc" id="L3126">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; recalculatedForecastProfileListsBySpQueue =</span>
					new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();

<span class="nc" id="L3129">			Collection&lt;Media&gt; allMedia = m_workloadManager.getAllMedia();</span>
<span class="nc" id="L3130">			Map&lt;ID, Media&gt; mediaIdMap = ValueObjectUtil.getIDObjectMap(allMedia);</span>
<span class="nc" id="L3131">			boolean useUnknownVolumeInForecast = getUseUnknownVolumeInForecasts();</span>
<span class="nc" id="L3132">			TimeContext tc = new TimeContext(campaign.getTimeZone(), campaign.getDayBoundaryOffset());</span>

<span class="nc bnc" id="L3134" title="All 2 branches missed.">			for (ForecastProfile fp : fps) {</span>
<span class="nc" id="L3135">				Queue queue = queueIdMap.get(spQueueIdMap.get(fp.getSPQueueID()).getQueueID());</span>
<span class="nc" id="L3136">				Profile p = new Profile(fp, queue, tc);</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3138">					m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - &quot; +</span>
<span class="nc" id="L3139">							&quot;Generating forecast for profile: Interval&quot; + p.getInterval().toString());</span>
				}

<span class="nc" id="L3142">				Media media = mediaIdMap.get(queue.getMediaID());</span>

<span class="nc" id="L3144">				IHistoryProvider historyProvider = HistoryProviderFactory.createHistoryProvider(campaign,</span>
<span class="nc" id="L3145">						media, p.getQueue(), tc, m_whatIfMode);</span>
<span class="nc" id="L3146">				Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; historyData = getHistoryDataForProfile(historyProvider, p);</span>
<span class="nc" id="L3147">				IForecastCalculator calculator = ForecastCalculatorFactory.createForecastCalculator(queue.getMediaID());</span>
<span class="nc" id="L3148">				Map&lt;ID, Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt;&gt; queueHistoryMap = new</span>
						HashMap&lt;ID, Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt;&gt;();
<span class="nc" id="L3150">				queueHistoryMap.put(queue.getID(), historyData);</span>
<span class="nc" id="L3151">				TraceCube forecast = calculator.calculate(p, sp, false, null, null,</span>
						queueHistoryMap, false, useUnknownVolumeInForecast);

<span class="nc" id="L3154">				enforceHoursOfOperation(campaign, sp, queue, forecast);</span>

<span class="nc bnc" id="L3156" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3157">					m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - &quot; +</span>
<span class="nc" id="L3158">							&quot;Forecast data calculated for Profile &quot; + p.toString() + &quot;: &quot; +</span>
<span class="nc" id="L3159">							forecast.toString());</span>
				}
<span class="nc bnc" id="L3161" title="All 2 branches missed.">				if (recalculatedForecastsBySpQueue.get(fp.getSPQueueID()) == null) {</span>
<span class="nc" id="L3162">					recalculatedForecastsBySpQueue.put(fp.getSPQueueID(), new ArrayList&lt;TraceCube&gt;());</span>
				}
<span class="nc" id="L3164">				recalculatedForecastsBySpQueue.get(fp.getSPQueueID()).add(forecast);</span>

<span class="nc bnc" id="L3166" title="All 2 branches missed.">				if (Media.isMediaOutbound(queue.getMediaID())) {</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">					if (recalculatedForecastProfileListsBySpQueue.get(fp.getSPQueueID()) == null) {</span>
<span class="nc" id="L3168">						recalculatedForecastProfileListsBySpQueue.put(fp.getSPQueueID(),</span>
								new ArrayList&lt;ForecastProfileList&gt;());
					}
<span class="nc" id="L3171">					Collection&lt;ForecastProfileList&gt; forecastProfileLists =</span>
<span class="nc" id="L3172">							getHistoricalOutboundCallLists(p, (OutboundHistoryProvider) historyProvider);</span>
<span class="nc bnc" id="L3173" title="All 2 branches missed.">					if (!forecastProfileLists.isEmpty()) {</span>
<span class="nc" id="L3174">						recalculatedForecastProfileListsBySpQueue.get(fp.getSPQueueID()).addAll(forecastProfileLists);</span>
					}
				}
<span class="nc" id="L3177">			}</span>

<span class="nc" id="L3179">			return new ForecastCalculationResult(recalculatedForecastsBySpQueue, recalculatedForecastProfileListsBySpQueue);</span>
		} finally {
<span class="nc" id="L3181">			methodFinish();</span>
		}
	}

	private void enforceHoursOfOperation(Campaign campaign, SchedulingPeriod sp, Queue queue, TraceCube forecast)
			throws BbmEJBCreateException, BbmFinderException, RemoteException {

<span class="nc bnc" id="L3188" title="All 2 branches missed.">		if (!Media.isMediaDeferred(queue.getMediaID())) {</span>
<span class="nc" id="L3189">			CampaignManager camManager = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L3190">			Collection&lt;CampaignHOO&gt; hoos = camManager.getCampaignHOOAssignments(campaign.getID(), sp.getStartTime(), sp.getEndTime(), false);</span>
<span class="nc" id="L3191">			TraceOperator.setOffHours(forecast, campaign.getTimeZone(), hoos);</span>
		}
<span class="nc" id="L3193">	}</span>

	private void createForecastProfileLists(Collection&lt;ForecastProfileList&gt; forecastProfileLists) throws BbmException {

<span class="nc" id="L3197">		methodStart(&quot;createForecastProfileLists&quot;, forecastProfileLists);</span>

<span class="nc" id="L3199">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>
		try {
<span class="nc" id="L3201">			dao.createObjects(forecastProfileLists);</span>
		} finally {
<span class="nc" id="L3203">			dao.cleanUp();</span>
<span class="nc" id="L3204">			methodFinish();</span>
<span class="nc" id="L3205">		}</span>
<span class="nc" id="L3206">	}</span>

	private Collection&lt;ForecastProfileList&gt; getHistoricalOutboundCallLists(Profile p,
			OutboundHistoryProvider historyProvider) throws BbmEJBCreateException, BbmFinderException {

<span class="nc" id="L3211">		methodStart(&quot;getHistoricalOutboundCallLists&quot;, p, historyProvider);</span>

		try {
<span class="nc" id="L3214">			Map&lt;TimeIntervalAtTime, List&lt;OutboundCallsList&gt;&gt; reforecastedOutboundCallLists =</span>
<span class="nc" id="L3215">					historyProvider.reforecastOutboundCallLists(Collections.singleton(p));</span>
<span class="nc" id="L3216">			Collection&lt;ForecastProfileList&gt; retVal = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">			for (Collection&lt;OutboundCallsList&gt; listOfLists : reforecastedOutboundCallLists.values()) {</span>
<span class="nc bnc" id="L3218" title="All 2 branches missed.">				for (OutboundCallsList list : listOfLists) {</span>
<span class="nc" id="L3219">					retVal.add(list.getForecastProfileList());</span>
<span class="nc" id="L3220">				}</span>
<span class="nc" id="L3221">			}</span>

<span class="nc bnc" id="L3223" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3224">				m_cat.debug(&quot;getHistoricalOutboundCallLists: returning the following ForecastProfileLists: &quot;);</span>
<span class="nc bnc" id="L3225" title="All 2 branches missed.">				for (ForecastProfileList list : retVal) {</span>
<span class="nc" id="L3226">					m_cat.debug(&quot;	&quot; + list.toString());</span>
<span class="nc" id="L3227">				}</span>
			}

<span class="nc" id="L3230">			return retVal;</span>
		} finally {
<span class="nc" id="L3232">			methodFinish();</span>
		}
	}

	/**
	 * Returns the history covering the time periods of each of the profile entries in the given profile.
	 * @return Map: Key = ProfileEntryHistoryPeriod, Value = History tracecube for that period
	 */
	private Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; getHistoryDataForProfile(IHistoryProvider historyProvider,
			Profile p) throws BbmException {
<span class="nc" id="L3242">		methodStart(&quot;getHistoryDataForProfile&quot;, historyProvider, p);</span>

		try {
<span class="nc" id="L3245">			Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; historyMap = new HashMap&lt;ProfileEntryHistoryPeriod, TraceCube&gt;();</span>
<span class="nc bnc" id="L3246" title="All 2 branches missed.">			for (ProfileEntry pe : p.getProfileEntries()) {</span>
<span class="nc" id="L3247">				TraceCube historyTraceCube = pe.getHistoryPeriod().getHistoryTraceCube(historyProvider);</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3249">					m_cat.debug(&quot;ForecastTimeSeriesManager.getHistoryDataForProfile for Profile: &quot; + p.toString() +</span>
<span class="nc" id="L3250">							&quot; History Data: &quot; + historyTraceCube.toString());</span>
				}
<span class="nc" id="L3252">				historyMap.put(pe.getHistoryPeriod(), historyTraceCube);</span>
<span class="nc" id="L3253">			}</span>
<span class="nc" id="L3254">			return historyMap;</span>
		} finally {
<span class="nc" id="L3256">			methodFinish();</span>
		}
	}

	/**
	 * Returns an ActualTraceCube for each queue which contains the history for that queue spanning the given
	 * date range.  The trace types in the returned cube will contain call volume and aht history data.
	 */
	public Map&lt;ID, ActualTraceCube&gt; getVolumeAndAhtHistory(Collection&lt;Queue&gt; queues, ID campaignId, Date startDate,
			Date endDate) throws BbmTimeSeriesException, BbmFinderException, BbmEJBCreateException, RemoteException {
<span class="nc" id="L3266">		methodStart(&quot;getVolumeAndAhtHistory&quot;, queues, campaignId, startDate, endDate);</span>

		try {
<span class="nc" id="L3269">			ActualTraceCube meta = new ActualTraceCube(new short[]{Trace.CV, Trace.AHT, Trace.CV_VH, Trace.VH});</span>
<span class="nc" id="L3270">			return getHistoryForForecasts(meta, queues, campaignId, startDate, endDate);</span>
<span class="nc" id="L3271">		} catch (BbmTimeSeriesException ex) {</span>
<span class="nc" id="L3272">			handleException(ex);</span>
<span class="nc" id="L3273">			throw ex;</span>
<span class="nc" id="L3274">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3275">			handleException(ex);</span>
<span class="nc" id="L3276">			throw ex;</span>
<span class="nc" id="L3277">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3278">			handleException(ex);</span>
<span class="nc" id="L3279">			throw ex;</span>
<span class="nc" id="L3280">		} catch (BbmEJBCreateException ex) {</span>
<span class="nc" id="L3281">			handleException(ex);</span>
<span class="nc" id="L3282">			throw ex;</span>
		} finally {
<span class="nc" id="L3284">			methodFinish();</span>
		}
	}

	/**
	 * Returns an ActualTraceCube for each queue which contains the history for that queue spanning the given
	 * date range.  The trace types in the returned cube will contain dials, connects/rpc, connect rate/rpcr,
	 * and aht/rpcaht.
	 */
	public Map&lt;ID, ActualTraceCube&gt; getOutboundHistory(Collection&lt;Queue&gt; queues, ID campaignId,
			Date startDate, Date endDate) throws RemoteException, BbmTimeSeriesException, BbmEJBCreateException,
			BbmFinderException {
<span class="nc" id="L3296">		methodStart(&quot;getOutboundHistory&quot;, queues, campaignId, startDate, endDate);</span>
		try {
<span class="nc" id="L3298">			ActualTraceCube meta = new ActualTraceCube(new short[]{Trace.DIALS, Trace.CONNECTS, Trace.RPC, Trace.CRATE,</span>
					Trace.AHT, Trace.RPCRATE, Trace.RPCAHT});
<span class="nc" id="L3300">			return getHistoryForForecasts(meta, queues, campaignId, startDate, endDate);</span>
<span class="nc" id="L3301">		} catch (BbmTimeSeriesException ex) {</span>
<span class="nc" id="L3302">			handleException(ex);</span>
<span class="nc" id="L3303">			throw ex;</span>
<span class="nc" id="L3304">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3305">			handleException(ex);</span>
<span class="nc" id="L3306">			throw ex;</span>
<span class="nc" id="L3307">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3308">			handleException(ex);</span>
<span class="nc" id="L3309">			throw ex;</span>
<span class="nc" id="L3310">		} catch (BbmEJBCreateException ex) {</span>
<span class="nc" id="L3311">			handleException(ex);</span>
<span class="nc" id="L3312">			throw ex;</span>
		} finally {
<span class="nc" id="L3314">			methodFinish();</span>
		}
	}

	private Map&lt;ID, ActualTraceCube&gt; getHistoryForForecasts(ActualTraceCube metaCube, Collection&lt;Queue&gt; queues,
			ID campaignId, Date startDate, Date endDate) throws BbmEJBCreateException, RemoteException,
			BbmTimeSeriesException, BbmFinderException {
<span class="nc" id="L3321">		Map&lt;ID, ActualTraceCube&gt; retVal = new HashMap&lt;ID, ActualTraceCube&gt;();</span>
<span class="nc" id="L3322">		boolean includeUnknownVolume = getUseUnknownVolumeInForecasts();</span>

<span class="nc" id="L3324">		List&lt;Queue&gt; queuesToLoadHistoryFor = new ArrayList&lt;Queue&gt;(queues);</span>
<span class="nc bnc" id="L3325" title="All 2 branches missed.">		for (Iterator&lt;Queue&gt; iter = queuesToLoadHistoryFor.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3326">			Queue queue = iter.next();</span>
<span class="nc bnc" id="L3327" title="All 2 branches missed.">			if (queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L3328">				retVal.put(queue.getID(), getHistoryForDistributedQueue(metaCube, queue, campaignId,</span>
						startDate, endDate, includeUnknownVolume));
<span class="nc" id="L3330">				iter.remove();</span>
			}
<span class="nc" id="L3332">		}</span>

<span class="nc bnc" id="L3334" title="All 2 branches missed.">		if (!queuesToLoadHistoryFor.isEmpty()) {</span>
<span class="nc" id="L3335">			Collection&lt;TraceCube&gt; history = timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
<span class="nc bnc" id="L3336" title="All 2 branches missed.">					metaCube, campaignId, ValueObjectUtil.getIDFromObjects(queuesToLoadHistoryFor), startDate,</span>
					endDate, false, !includeUnknownVolume);

<span class="nc bnc" id="L3339" title="All 2 branches missed.">			for (TraceCube tc : history) {</span>
<span class="nc" id="L3340">				retVal.put(tc.getQueueID(), (ActualTraceCube) tc);</span>
<span class="nc" id="L3341">			}</span>
		}

<span class="nc bnc" id="L3344" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3345">			StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L3346">			sb.append(&quot;ForecastTimeSeriesManager.getHistoryForForecasts - Returning &quot;);</span>
<span class="nc bnc" id="L3347" title="All 2 branches missed.">			for (ActualTraceCube history : retVal.values()) {</span>
<span class="nc" id="L3348">				sb.append(history.toString());</span>
<span class="nc" id="L3349">			}</span>
<span class="nc" id="L3350">			m_cat.debug(sb.toString());</span>
		}
<span class="nc" id="L3352">		return retVal;</span>
	}

	private ActualTraceCube getHistoryForDistributedQueue(ActualTraceCube metaCube, Queue distributedQueue,
			ID campaignId, Date startDate, Date endDate, boolean includeUnknownVolume)
			throws BbmTimeSeriesException, BbmFinderException, RemoteException {
		// Handle a distributed queue.  We return the aggregate of the histories of
		// all the requested queue's child queues.
<span class="nc" id="L3360">		Collection&lt;ID&gt; childQueueIds = workloadManager.getSubQueues(Collections.singleton(distributedQueue.getID()));</span>
<span class="nc bnc" id="L3361" title="All 2 branches missed.">		Collection&lt;TraceCube&gt; childHistories = timeSeriesManager.getRawMultipleQueuesTimeSeries(metaCube, campaignId,</span>
				childQueueIds, startDate, endDate, false, !includeUnknownVolume);
<span class="nc" id="L3363">		TraceCube[] childHistoryArray = new TraceCube[childHistories.size()];</span>
<span class="nc" id="L3364">		childHistoryArray = childHistories.toArray(childHistoryArray);</span>
<span class="nc" id="L3365">		Map&lt;ID, ID&gt; queueMediaMap = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc bnc" id="L3366" title="All 2 branches missed.">		for (TraceCube childHistory : childHistories) {</span>
<span class="nc" id="L3367">			queueMediaMap.put(childHistory.getQueueID(), distributedQueue.getMediaID());</span>
<span class="nc" id="L3368">		}</span>
<span class="nc bnc" id="L3369" title="All 2 branches missed.">		return (ActualTraceCube) TraceOperator.combineQueue(childHistoryArray,</span>
				!includeUnknownVolume, queueMediaMap);
	}

	private boolean getUseUnknownVolumeInForecasts() throws BbmEJBCreateException, RemoteException {
<span class="nc" id="L3374">		return BbmManagerFactory.getDBConfigManager().getBooleanValue(ConfigKey.FORECASTING_INCLUDEUNKNOWNCV);</span>
	}

	private static void convertOutboundForecastsToSavableFormat(Map&lt;ID, TraceCube&gt; forecastDataBySpQueueId,
			Map&lt;ID, Queue&gt; queueIdMap) throws BbmTimeSeriesException {
<span class="nc bnc" id="L3379" title="All 2 branches missed.">		for (ID spQueueId : forecastDataBySpQueueId.keySet()) {</span>
<span class="nc" id="L3380">			TraceCube forecast = forecastDataBySpQueueId.get(spQueueId);</span>
<span class="nc bnc" id="L3381" title="All 2 branches missed.">			if (Media.isMediaOutbound(queueIdMap.get(forecast.getQueueID()).getMediaID())) {</span>
<span class="nc" id="L3382">				forecastDataBySpQueueId.put(spQueueId,</span>
<span class="nc" id="L3383">						ForecastTraceCubeUtil.convertOutboundClientForecastIntoSavableFormat(forecast));</span>
			}
<span class="nc" id="L3385">		}</span>
<span class="nc" id="L3386">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>