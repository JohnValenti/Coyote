<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.ejb</a> &gt; <span class="el_source">RequestUtil.java</span></div><h1>RequestUtil.java</h1><pre class="source lang-java linenums">/*
 * RequestUtil.java
 *
 * Created on January 31, 2003, 6:58 PM
 */

package com.bluepumpkin.ejb.rm.requests.common.ejb;

import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.TimeZone;

import javax.ejb.EJBContext;
import javax.xml.parsers.DocumentBuilder;

import org.apache.log4j.Priority;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;

import com.bluepumpkin.common.base.BPException;
import com.bluepumpkin.common.base.PersonName;
import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.PrimitiveTypes;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMinMaxHour;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.UnavailabilityEvent;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsConflict;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffCalculatorException;
import com.bluepumpkin.ejb.bbm.vo.FieldInfoEntry;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectNode;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignmentFieldInfo;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.ResourceBundleKeyWrapper;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.l10n.UnlocalizedStringWrapper;
import com.bluepumpkin.ejb.rm.notification.util.NotificationUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.flextime.ejb.FlexTimeRequestManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableShiftDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleInstance;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableShift;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.ShiftSwapPostingManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.ejb.ShiftSwapRequestManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftSwapValidationCache;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb.TOWaitlistManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.ejb.TOWithdrawManager;
import com.bluepumpkin.ejb.rm.security.RmPrivilegeKeys;
import com.bluepumpkin.ejb.rm.setup.filingrules.model.RequestFilingRule;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;
import com.witness.web.uif.l10n.UIFWebBundleKey;

/**
 *
 * @author RRajendran
 */
<span class="nc bnc" id="L154" title="All 2 branches missed.">@SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="nc" id="L155">public class RequestUtil {</span>
	// controls the priority of tracing information written by RM subsystem.
	// Setting it to
	// INFO, instead of DEBUG, allows RM trace to be viewed without being
	// cluttered with DMO
	// trace (with priority DEBUG).
<span class="nc" id="L161">	public static Priority m_defaultTracePriority = Priority.DEBUG;</span>

	public static final int METHODTYPE_CREATOR = 1;
	public static final int METHODTYPE_FINDER = 2;
	public static final int METHODTYPE_MODIFIER = 4;
	public static final int METHODTYPE_PURGER = 8;
	public static final int METHODTYPE_ALL = METHODTYPE_CREATOR | METHODTYPE_FINDER | METHODTYPE_MODIFIER
			| METHODTYPE_PURGER;
	public static final int METHODTYPE_ALL_EXCEPT_FINDER = METHODTYPE_CREATOR | METHODTYPE_MODIFIER | METHODTYPE_PURGER;

	public static final String DAYRANGE_ALL_DAYS = RequestFilingRule.DAYRANGE_ALL_DAYS;
	public static final String DAYRANGE_DAY_TYPE = RequestFilingRule.DAYRANGE_DAY_TYPE;
	public static final String DAYRANGE_DATES = RequestFilingRule.DAYRANGE_DATES;

	public static final String DATECOMPARISION_ON_DATE = RequestFilingRule.DATECOMPARISION_ON_DATE;
	public static final String DATECOMPARISION_BEFORE_DATE = RequestFilingRule.DATECOMPARISION_BEFORE_DATE;
	public static final String DATECOMPARISION_AFTER_DATE = RequestFilingRule.DATECOMPARISION_AFTER_DATE;

	public static final String INTERVALTYPE_LESSTHAN = RequestFilingRule.INTERVALTYPE_LESSTHAN;
	public static final String INTERVALTYPE_EQUALTO = RequestFilingRule.INTERVALTYPE_EQUALTO;
	public static final String INTERVALTYPE_MORETHAN = RequestFilingRule.INTERVALTYPE_MORETHAN;

	public static final String TIMETYPE_BYDATE = RequestFilingRule.TIMETYPE_BYDATE;
	public static final String TIMETYPE_INTERVAL = RequestFilingRule.TIMETYPE_INTERVAL;

<span class="nc" id="L186">	private static Category m_cat = Log.initCategory(RequestUtil.class.getName());</span>

<span class="nc" id="L188">	protected static RmManagerFactory m_rmMgrFactory = null;</span>

<span class="nc" id="L190">	private static User m_bpSuperUser = null;</span>

<span class="nc" id="L192">	private static Boolean isRMDebugEnabled = null;</span>

	// used only in test mode.
	// private static User m_bpSuperUserForTest;

<span class="nc" id="L197">	private static float MINUTE_IN_MILLIS = 60.0f * 1000.0f;</span>

	public static final int ACTION_CREATE = 1;
	public static final int ACTION_UPDATE = 2;
	public static final int ACTION_DELETE = 3;
	public static final int ACTION_FETCH = 4;

	public static final String DAYS = &quot;days&quot;;
	public static final String HOURS = &quot;hours&quot;;
	public static final String MINUTES = &quot;minutes&quot;;

	/**
	 * Date representation for approx. Jan 1st 2020.
	 */
	// Date is relative to Jan 1st 1970.
<span class="nc" id="L212">	public static final Date MAX_DATE = new Date(50L * 365 * 24 * 60 * 60 * 1000L);</span>

	/**
	 * new Date(0)
	 */
<span class="nc" id="L217">	public static final Date DATE_MIN = new Date(0);</span>
	/**
	 * Date corresponding to Long.MAX_VALUE;
	 */
<span class="nc" id="L221">	public static final Date DATE_MAX = new Date(Long.MAX_VALUE);</span>

	// public static final DateFormat m_dateformatMedium =
	// DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.MEDIUM);
	// public static final DateFormat m_dateformatFull =
	// DateFormat.getDateTimeInstance(DateFormat.LONG, DateFormat.FULL);

	public static final String SORTDIR_ASC = &quot; ASC &quot;;
	public static final String SORTDIR_DESC = &quot; DESC &quot;;
	public static final String ALL_FILTER = &quot;ALL_FILTER&quot;;
	public static final String DEFAULT_FILTER = &quot;default filter&quot;;
	public static final String WAITLIST_FILTER = &quot;WAITLIST_FILTER&quot;;

	public static final String TABLE_EMPLOYEEAM_ALIAS = &quot;EMPAM&quot;;
	public static final String TABLE_TOWAITLIST_ALIAS = &quot;TOW&quot;;
<span class="nc" id="L236">	private static final Map m_empIDorNameToUserCache = new HashMap(32);</span>

	private static final short ORG_SCOPE = Organization.SCOPE_TYPE;

<span class="nc" id="L240">	public static class ExceptionMessage {</span>
		protected boolean m_useBundle;
		protected String m_bundleName;
		protected String m_msgKey;
		protected Object[] m_parms;
		protected String m_msg;

<span class="nc" id="L247">		public ExceptionMessage(String nonLocalizedMsg) {</span>
<span class="nc" id="L248">			m_useBundle = false;</span>
<span class="nc" id="L249">			m_msg = nonLocalizedMsg;</span>
<span class="nc" id="L250">		}</span>

<span class="nc" id="L252">		public ExceptionMessage(String bundleName, String msgKey, Object[] parms) {</span>
<span class="nc" id="L253">			m_useBundle = true;</span>
<span class="nc" id="L254">			m_bundleName = bundleName;</span>
<span class="nc" id="L255">			m_msgKey = msgKey;</span>
<span class="nc" id="L256">			m_parms = parms;</span>
<span class="nc" id="L257">		}</span>

		public String getUnLocalizedMessage() {
			// Error, if message is localized already
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if (m_useBundle) {</span>
				// just log the error and continue.
<span class="nc" id="L263">				RequestUtil.createRmException(RmEjbLogBundleKey.ERROR_MSG_LOCALIZED, m_cat);</span>
			}

<span class="nc" id="L266">			return m_msg;</span>
		}

		public String getBundleName() {
<span class="nc" id="L270">			return m_bundleName;</span>
		}

		public String getMsgKey() {
<span class="nc" id="L274">			return m_msgKey;</span>
		}

		public Object[] getMsgParms() {
<span class="nc" id="L278">			return m_parms;</span>
		}

		public boolean getUseBundle() {
<span class="nc" id="L282">			return m_useBundle;</span>
		}

	}

	/**
	 * Uses field names of a class to initialize the metadata array
	 * (FieldInfoEntry). Given a list of all fields of a class (static and
	 * instance) obtained thruough reflection, this list is filtered by the
	 * given field prefix to obtain the list of entires that describe the
	 * metadata (columns of the database)
	 *
	 * @param fieldEntries
	 *            array of FieldInfoEntries to be initialized
	 * @param classFields
	 *            array of Fields that describe the static and private instance
	 *            variables of a java class (obtained using Reflection).
	 * @param prefix
	 *            prefix to filter above field names.
	 */
	public final static void initFieldInfoEntries(FieldInfoEntry[] fieldEntries, Class classObj, String prefix,
			int numOfExpectedEntries) {

<span class="nc" id="L305">		int prefixLength = prefix.length();</span>
		// obtain all fields for the class.
<span class="nc" id="L307">		Field[] classFields = classObj.getDeclaredFields();</span>
		// number of entries extracted from the passed class object (classObj).
<span class="nc" id="L309">		int numOfExtractedEntries = 0;</span>
		// for each field in class
<span class="nc bnc" id="L311" title="All 2 branches missed.">		for (int i = 0; i &lt; classFields.length; i++) {</span>
			// process only public fields as the Java Reflection API prevents
			// access
			// to protected or private fields
<span class="nc bnc" id="L315" title="All 2 branches missed.">			if (!Modifier.isPublic(classFields[i].getModifiers())) {</span>
<span class="nc" id="L316">				continue;</span>
			}

			// does field name start with prefix? we are looking for field names
			// coded
			// in the format 'prefix_type_name'
<span class="nc" id="L322">			String fieldName = classFields[i].getName(); // get field name</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">			if (!fieldName.startsWith(prefix)) {</span>
<span class="nc" id="L324">				continue;</span>
			}

			// obtain the integer value of the field. This integer value is used
			// as an index
			// into FieldInfo.m_arrFieldInfo[] and
			// ValueObjectBase.m_arrFieldValues[]
<span class="nc" id="L331">			int fieldEntryIndex = 0;</span>
			try {
<span class="nc" id="L333">				fieldEntryIndex = classFields[i].getInt(null); // if field is an</span>
																// integer (must
																// be), get
																// value
<span class="nc" id="L337">			} catch (Exception e) { // field is not an integer type. move on.</span>
				// This only logs the exception. This exception is not thrown
				// since a throws declaration cannot be added
				// to the method signature (method called by static initializer
				// by value object classes).
<span class="nc" id="L342">				RmException rmExcept = createRmExceptionWrapper(e, m_cat);</span>
<span class="nc" id="L343">				throw new IllegalArgumentException(</span>
						&quot;classFields[i].getInt(null) failed. Check log file for exception details&quot;);
<span class="nc" id="L345">			}</span>

			// now extract 'name' component from the coded field name:
			// prefix_type_name
<span class="nc bnc" id="L349" title="All 4 branches missed.">			assert (fieldEntryIndex &lt; fieldEntries.length) : &quot;(fieldEntryIndex &lt; fieldEntries.length): &quot;</span>
					+ fieldEntryIndex + ',' + fieldEntries.length;
<span class="nc bnc" id="L351" title="All 2 branches missed.">			if (fieldEntryIndex &lt; fieldEntries.length) {</span>
<span class="nc" id="L352">				int fieldType = PrimitiveTypes.STRING;</span>
<span class="nc bnc" id="L353" title="All 8 branches missed.">				switch (fieldName.charAt(prefixLength)) { // obtain the 'type'</span>
															// code from field
															// name
				case 'I':
<span class="nc" id="L357">					fieldType = PrimitiveTypes.ID;</span>
<span class="nc" id="L358">					break;</span>
				case 'B':
<span class="nc" id="L360">					fieldType = PrimitiveTypes.BOOLEAN;</span>
<span class="nc" id="L361">					break;</span>
				case 'S':
<span class="nc" id="L363">					fieldType = PrimitiveTypes.STRING;</span>
<span class="nc" id="L364">					break;</span>
				case 'D':
<span class="nc" id="L366">					fieldType = PrimitiveTypes.DATETIME;</span>
<span class="nc" id="L367">					break;</span>
				case 'N':
<span class="nc" id="L369">					fieldType = PrimitiveTypes.INT;</span>
<span class="nc" id="L370">					break;</span>
				case 'F':
<span class="nc" id="L372">					fieldType = PrimitiveTypes.FLOAT;</span>
<span class="nc" id="L373">					break;</span>
				case 'd':
<span class="nc" id="L375">					fieldType = PrimitiveTypes.DOUBLE;</span>
<span class="nc" id="L376">					break;</span>
				default:
<span class="nc" id="L378">					throw new IllegalArgumentException(</span>
<span class="nc" id="L379">							&quot;Invalid fieldName.charAt(prefixLength): &quot; + fieldName.charAt(prefixLength));</span>
				}

				// store the 'name' part and type from the coded field name in
				// the fieldEntry array
<span class="nc" id="L384">				fieldEntries[fieldEntryIndex] = new FieldInfoEntry(fieldName.substring(prefixLength + 2), fieldType);</span>

<span class="nc" id="L386">				numOfExtractedEntries++;</span>
			}
		} // for (....)

<span class="nc bnc" id="L390" title="All 4 branches missed.">		assert (numOfExpectedEntries == numOfExtractedEntries) : &quot;( numOfExpectedEntries != numOfExtractedEntries ): &quot;</span>
				+ numOfExpectedEntries + ',' + numOfExtractedEntries;
<span class="nc" id="L392">	}</span>

	/**
	 * Finds employee IDs for the given organization node only and not the for
	 * the node and its subnodes Uses an EmployeeFilter to filter by an
	 * organizationID.
	 *
	 * @param orgID
	 *            the ID of an organization.
	 * @return A Collection of employee IDs
	 * @throws BbmFinderException
	 */
	public static Collection getEmployeeIDsByOrgNodeAndDates(ID orgID, int timePeriodType, Date dtStart, Date dtEnd)
			throws Exception {

		// todo: this is done thru' AM. Can't we utilize the
		// WORKRESOURCEORGANIZATION table instead.
<span class="nc" id="L409">		Collection empIDs = Collections.emptyList();</span>

		// Not using Collections.singleton()since called method modifies list.
<span class="nc" id="L412">		List orgIDList = new ArrayList(1);</span>
<span class="nc" id="L413">		orgIDList.add(orgID);</span>

		// construct the employee filter
<span class="nc" id="L416">		ArrayList filterParms = new ArrayList(1);</span>
<span class="nc" id="L417">		filterParms.add(orgIDList);</span>
<span class="nc" id="L418">		Filter filter = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, filterParms);</span>
		// QC53354/QA97533
<span class="nc" id="L420">		filter.setTimePeriodType(timePeriodType);</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		if (timePeriodType == Filter.TIMEPERIODTYPE_TIMEWINDOW) {</span>
<span class="nc" id="L422">			filter.setStartTime(dtStart);</span>
<span class="nc" id="L423">			filter.setEndTime(dtEnd);</span>
		}
		// filter.setUserID(getLoginUserID());
		// TODO: privilege checking disabled for employee filter.
<span class="nc" id="L427">		filter.setPriviledge(null);</span>

		// use the EmployeeFiltering object to obtain a list of employees.
<span class="nc" id="L430">		Collection colSortFields = Collections.emptyList();</span>
<span class="nc" id="L431">		EmployeeFilter eFilter = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L432">		empIDs = eFilter.getEmployeeIDs(filter, getBPSuperUser(), colSortFields, true, 0, Integer.MAX_VALUE);</span>

<span class="nc" id="L434">		return empIDs;</span>
	}

	/**
	 * Get the collection of employees that define the set whose requests should
	 * be purged.
	 *
	 * @param organizationID
	 *            the organization id
	 * @param isForBranch
	 *            true=&gt; the whole branch, all sub orgs, false =&gt; just the
	 *            referenced organization
	 * @param dtStart
	 *            the start date of the date range
	 * @param dtEnd
	 *            the end date of the date range
	 * @return a Collection of Employees
	 * @throws BbmException
	 */
	// QC53354/QA97533 take organizational effectivity into account when getting
	// employeeIDs
	public static Collection getEmployeeIDsInOrganization(ID organizationID, boolean isForBranch, Date dtStart,
			Date dtEnd) throws Exception {
		// todo: should this be a static method?
		Collection ids;

		// try {
<span class="nc" id="L461">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (isForBranch) {</span>
			// QC53354/QA97533 add dtStart and dtEnd
<span class="nc" id="L465">			Collection emps = wrm.getEmployees(organizationID, dtStart, dtEnd, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>

<span class="nc" id="L467">			ids = new ArrayList(emps.size());</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">			for (Iterator itr = emps.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L469">				ids.add(((Employee) itr.next()).getID());</span>
			}
<span class="nc" id="L471">		} else { // not ForBranch..only get employee under the orgID nodnce</span>
					// necessary?
			// todo: this is done thru' AM. Can't we utilize the
			// WORKRESOURCEORGANIZATION table instead.
			// QC53354/QA97533
<span class="nc" id="L476">			ids = getEmployeeIDsByOrgNodeAndDates(organizationID, Filter.TIMEPERIODTYPE_TIMEWINDOW, dtStart, dtEnd);</span>
		}
		// } c_atch (RemoteException remoteFail) {
		// //todo: log
		// //m_cat.error(organizationID, remoteFail);
		// t_hrow new BbmException(remoteFail);
		// }

<span class="nc bnc" id="L484" title="All 2 branches missed.">		return (ids == null) ? Collections.emptyList() : ids;</span>
	}

	/**
	 * Get the collection of employees that define the set whose requests should
	 * be purged.
	 *
	 * @param organizationID
	 *            the organization id
	 * @param isForBranch
	 *            true=&gt; the whole branch, all sub orgs, false =&gt; just the
	 *            referenced organization
	 */
	public static Collection getEmployeesInOrganization(ID organizationID, boolean isForBranch) throws Exception {

<span class="nc" id="L499">		Collection wrmc = Collections.emptyList();</span>
		// try {
<span class="nc" id="L501">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc bnc" id="L503" title="All 2 branches missed.">		if (isForBranch) {</span>
<span class="nc" id="L504">			wrmc = wrm.getEmployees(organizationID, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
		} else { // not ForBranch..only get employee under the orgID nod
			// QC53354/QA97533 getEmployeeIDsByOrgNodeOnly changed to use
			// effectivity
<span class="nc" id="L508">			Collection ids = getEmployeeIDsByOrgNodeAndDates(organizationID, Filter.TIMEPERIODTYPE_CURRENT, null, null);</span>
<span class="nc" id="L509">			wrmc = wrm.getEmployeesByIDs(ids, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
		}
		// } c_atch (RemoteException remoteFail) {
		// //todo: log
		// //m_cat.error(organizationID, remoteFail);
		// t_hrow new BbmRemoveException(remoteFail);
		// }

<span class="nc" id="L517">		return wrmc;</span>
	}

	public static Collection geWorkResAssnsForCampaignDuringPeriod(ID campaignID, Date start, Date end)
			throws Exception {
<span class="nc" id="L522">		CampaignManager cmpMgr = getCampaignManager();</span>

<span class="nc" id="L524">		return cmpMgr.getCampaignWorkResourceAssignments(campaignID, start, end);</span>
	}

	/**
	 * Get the start and end dates for this and next time off year for the given
	 * employee.
	 *
	 * @param empID
	 *            the id of the employee
	 * @return a two-element array of TimeRange objects. The first contains the
	 *         time off begin and end dates for this year, the second contains
	 *         the begin and end dates for next year.
	 */
	public static TimeRange[] getEmployeeTimeOffYearDates(ID empID, ID orgID) throws Exception {
<span class="nc" id="L538">		TimeRange[] result = null;</span>

<span class="nc" id="L540">		int[] startMonthDay = getEmployeeTimeOffYearStart(empID, orgID);</span>

		// Get the time zone for the employee's organization
<span class="nc" id="L543">		TimeZone tz = getTimezoneCurrentForEmployeeID(empID);</span>

		// Get the current time in the organization's timezone
<span class="nc" id="L546">		Calendar now = Calendar.getInstance(tz);</span>

<span class="nc" id="L548">		Date thisYearStart = null, thisYearEnd = null, nextYearStart = null, nextYearEnd = null;</span>

		// get the start date of the employee's time off year in the current
		// calendar year.
<span class="nc" id="L552">		Calendar start = getCalendar(now.get(Calendar.YEAR), startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L553">		Calendar end = getCalendarForwardOneYear(now.get(Calendar.YEAR), startMonthDay[0], startMonthDay[1], tz);</span>

		// Is employee start date for this year past today's date?
<span class="nc bnc" id="L556" title="All 2 branches missed.">		if (now.before(start)) {</span>
			// start is the beginning of next year.
<span class="nc" id="L558">			nextYearStart = start.getTime();</span>
<span class="nc" id="L559">			nextYearEnd = end.getTime();</span>

			// Compute this year's start and end
<span class="nc" id="L562">			start = getCalendar(now.get(Calendar.YEAR) - 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L563">			end = getCalendarForwardOneYear(now.get(Calendar.YEAR) - 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L564">			thisYearStart = start.getTime();</span>
<span class="nc" id="L565">			thisYearEnd = end.getTime();</span>
		} else { // Emplyee's start date for this year is before today's date.
			// start is the beginning of this year
<span class="nc" id="L568">			thisYearStart = start.getTime();</span>
<span class="nc" id="L569">			thisYearEnd = end.getTime();</span>

			// Compute next year's start and end
<span class="nc" id="L572">			start = getCalendar(now.get(Calendar.YEAR) + 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L573">			end = getCalendarForwardOneYear(now.get(Calendar.YEAR) + 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L574">			nextYearStart = start.getTime();</span>
<span class="nc" id="L575">			nextYearEnd = end.getTime();</span>
		}

<span class="nc" id="L578">		result = new TimeRange[] { new TimeRange(thisYearStart, thisYearEnd),</span>
				new TimeRange(nextYearStart, nextYearEnd), };

<span class="nc" id="L581">		return result;</span>
	}

	/**
	 * Get the time off year month and day for an employee
	 *
	 * @param emp
	 *            the employee
	 * @param org
	 *            the organization for the employee
	 * @return a two-element array of int. The first element is the month, the
	 *         second is the day.
	 */
	public static int[] getEmployeeTimeOffYearStart(Employee emp, Organization org) throws Exception {
<span class="nc" id="L595">		int[] result = new int[2];</span>
<span class="nc" id="L596">		OrganizationSetting settings = CacheUtilRM.getOrgSetting(org.getID());</span>

<span class="nc bnc" id="L598" title="All 4 branches missed.">		if ((settings != null) &amp;&amp; settings.getUseEmployeeFixedDate()) {</span>
			// The organization is using fixed date (Month and day)
<span class="nc" id="L600">			result[0] = settings.getEmployeeFixedDateMonth();</span>
<span class="nc" id="L601">			result[1] = settings.getEmployeeFixedDateDay();</span>
		} else {
			// organization uses employee anniversary date
			// obtain time zone for organization and start date for employee
<span class="nc" id="L605">			Calendar startDate = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L606">			startDate.setTime(emp.getStartTime());</span>
			// retrieve month and date
<span class="nc" id="L608">			result[0] = startDate.get(Calendar.MONTH);</span>
<span class="nc" id="L609">			result[1] = startDate.get(Calendar.DAY_OF_MONTH);</span>
		}
<span class="nc" id="L611">		return result;</span>
	}

	/**
	 * Get the time off year month and day for an employee
	 *
	 * @param empID
	 *            the id of the employee
	 * @param orgID
	 *            the organization id for the employee
	 * @return a two-element array of int. The first element is the month, the
	 *         second is the day.
	 */
	public static int[] getEmployeeTimeOffYearStart(ID empID, ID orgID) throws Exception {
<span class="nc" id="L625">		int[] result = new int[2];</span>

<span class="nc" id="L627">		OrganizationSetting settings = CacheUtilRM.getOrgSetting(orgID);</span>

<span class="nc bnc" id="L629" title="All 4 branches missed.">		if ((settings != null) &amp;&amp; settings.getUseEmployeeFixedDate()) {</span>
			// The organization is using fixed date
<span class="nc" id="L631">			result[0] = settings.getEmployeeFixedDateMonth();</span>
<span class="nc" id="L632">			result[1] = settings.getEmployeeFixedDateDay();</span>
		} else {
			// The organization uses employee anniversary
			// obtain work resource manager

			// obtain time zone for organization and start date for employee
<span class="nc" id="L638">			Calendar startDate = Calendar.getInstance(CacheUtilBBM.getOrganizationByID(orgID).getTimeZone());</span>
<span class="nc" id="L639">			startDate.setTime(</span>
<span class="nc" id="L640">					ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC).getStartTime());</span>

			// retrieve month and date
<span class="nc" id="L643">			result[0] = startDate.get(Calendar.MONTH);</span>
<span class="nc" id="L644">			result[1] = startDate.get(Calendar.DAY_OF_MONTH);</span>
		}
<span class="nc" id="L646">		return result;</span>
	}

	/**
	 * @param empID
	 * @return
	 */
	// public static User getUserForEmpID(ID empID) throws Exception {
	// UserManager um = BbmManagerFactory.getUserManager();
	// return um.getUserByEmployeeID(empID);
	// }
	//

	public static User getUserByEmpIDCached(ID empID) throws Exception {
<span class="nc" id="L660">		synchronized (m_empIDorNameToUserCache) {</span>
<span class="nc" id="L661">			User user = (User) m_empIDorNameToUserCache.get(empID);</span>

			// if not found in cache
<span class="nc bnc" id="L664" title="All 2 branches missed.">			if (user == null) {</span>
				// fetch from user manager
<span class="nc" id="L666">				UserManager um = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L667">				user = um.getUserByEmployeeID(empID);</span>

				// // store in cache.
				// m_empIDorNameToUserCache.put(empID, user);
				// m_empIDorNameToUserCache.put(user.getUserName().toLowerCase(),
				// user);
			}

			// return user.
<span class="nc" id="L676">			return user;</span>
<span class="nc" id="L677">		}</span>
	}

	public static User getUserByNameCached(String name) throws Exception {
<span class="nc" id="L681">		synchronized (m_empIDorNameToUserCache) {</span>
<span class="nc" id="L682">			User user = (User) m_empIDorNameToUserCache.get(name.toLowerCase());</span>

			// if not found in cache
<span class="nc bnc" id="L685" title="All 2 branches missed.">			if (user == null) {</span>
				// fetch from user manager
<span class="nc" id="L687">				UserManager um = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L688">				user = um.getUserByName(name);</span>

				// // store in cache.
				// m_empIDorNameToUserCache.put(name.toLowerCase(), user);
				// m_empIDorNameToUserCache.put(user.getEmployeeID(), user);
			}

			// return user.
<span class="nc" id="L696">			return user;</span>
<span class="nc" id="L697">		}</span>
	}

	public static String getLoginUserName(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L701">		String principalName = null;</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L703">			principalName = ejbCtx.getCallerPrincipal().getName();</span>
		} else {
<span class="nc" id="L705">			principalName = &quot;WSuperUser&quot;;</span>
		}

<span class="nc" id="L708">		return principalName;</span>
	}

	/**
	 * Finds the login user id from the EJB SessionContext.
	 *
	 * @param sessionContext
	 *            The SessionContext from the EJB.
	 * @return The ID of the logged in user.
	 * @throws BbmFinderException
	 */
	public static User getLoginUser(EJBContext ejbCtx) throws Exception {
		// get user secure fields
		User loginUser;

<span class="nc bnc" id="L723" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L724">			String principalName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L725">			loginUser = RequestUtil.getUserByNameCached(principalName);</span>
<span class="nc" id="L726">		} else {</span>
<span class="nc" id="L727">			loginUser = getBPSuperUser();</span>
		}

<span class="nc" id="L730">		return loginUser;</span>
	}

	public static ID getLoginUserID(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L734">		ID loginUserID = null;</span>

<span class="nc bnc" id="L736" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L737">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L738">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L739">			User user = userMgr.getUserByName(loginUserName);</span>
			// User user = userMgr.getUserByName(loginUserName);

<span class="nc" id="L742">			loginUserID = user.getID();</span>
<span class="nc" id="L743">		} else {</span>
<span class="nc" id="L744">			loginUserID = getBPSuperUser().getID();</span>
		}

<span class="nc" id="L747">		return loginUserID;</span>
	}

	public static ID getLoginUserEmpID(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L751">		ID loginUserEmpID = null;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L753">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L754">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L755">			User loginUser = userMgr.getUserByName(loginUserName);</span>
			// User loginUser = userMgr.getUserByName(loginUserName);
<span class="nc" id="L757">			loginUserEmpID = loginUser.getEmployeeID();</span>
<span class="nc" id="L758">		} else {</span>
<span class="nc" id="L759">			loginUserEmpID = getBPSuperUser().getEmployeeID();</span>
		}

<span class="nc" id="L762">		return loginUserEmpID;</span>
	}

	public static User getLoginUserBasic(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L766">		User loginUser = null;</span>

<span class="nc bnc" id="L768" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L769">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L770">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L771">			loginUser = userMgr.getUserByName(loginUserName);</span>
			// User loginUser = userMgr.getUserByName(loginUserName);
<span class="nc" id="L773">		} else {</span>
<span class="nc" id="L774">			loginUser = getBPSuperUser();</span>
		}

<span class="nc" id="L777">		return loginUser;</span>
	}

	public static synchronized User getBPSuperUser() throws Exception {

<span class="nc bnc" id="L782" title="All 2 branches missed.">		if (m_bpSuperUser == null) {</span>
<span class="nc" id="L783">			m_bpSuperUser = new SuperUserFacade();</span>
		}

<span class="nc" id="L786">		return m_bpSuperUser;</span>
	}

	public static Set getOrgIDsWithViewReqPrivilegesForEmpID(ID empID) throws Exception {
<span class="nc" id="L790">		UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>

		// Now get the set of organizations for which the manager has the
		// priviliage to view requests. This is slightly problematic since
		// it is possible that a manager could be given the privilage to
		// view time off requests for an organization, but not shift swap
		// requests. Coding to handle that would be very complicated, though,
		// and this is already pretty complicated. I'm going to make the
		// simplificiation that the priviliage to view one type of request
		// gives you to privilage to view any requests in the list. Operations
		// on the individual requests will still use the finer grained
		// privilage.
<span class="nc" id="L802">		Set orgs = new HashSet();</span>

<span class="nc bnc" id="L804" title="All 2 branches missed.">		for (Iterator it = RmPrivilegeKeys.MGR_VIEW_REQS_PRIVIDS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L805">			ID privID = (ID) it.next();</span>
<span class="nc" id="L806">			Collection i_orgs = RequestUtil.getOrgIDsWithPrivForEmpID(empID, privID, userMgr);</span>
<span class="nc" id="L807">			orgs.addAll(i_orgs);</span>
<span class="nc" id="L808">		}</span>

		// also get orgs over which the user has privs to view his own requests:
		// this is
		// required for the case when an agent is trying to view pending
		// requests through the
		// calendar drilldown
<span class="nc bnc" id="L815" title="All 2 branches missed.">		for (Iterator it = RmPrivilegeKeys.AGENT_VIEW_REQS_PRIVIDS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L816">			ID privID = (ID) it.next();</span>
<span class="nc" id="L817">			Collection i_orgs = RequestUtil.getOrgIDsWithPrivForEmpID(empID, privID, userMgr);</span>
<span class="nc" id="L818">			orgs.addAll(i_orgs);</span>
<span class="nc" id="L819">		}</span>

<span class="nc" id="L821">		return orgs;</span>
	}

	public static Collection getOrgIDsWithPrivForEmpID(ID empID, ID privID, UserManager userMgr) throws Exception {
<span class="nc bnc" id="L825" title="All 2 branches missed.">		userMgr = (userMgr == null) ? CoreManagerFactory.getUserManager(false) : userMgr;</span>
<span class="nc" id="L826">		User user = userMgr.getUserByEmployeeID(empID);</span>
<span class="nc" id="L827">		Collection orgIDs = user.getAuthorizedScopes(privID, ORG_SCOPE);</span>

<span class="nc" id="L829">		return orgIDs;</span>

	}

	/**
	 * @param userName
	 * @param privID
	 * @param object
	 * @return
	 */
	public static Collection getOrgIDsWithPrivForUserName(String userName, ID privID, UserManager userMgr)
			throws Exception {

<span class="nc bnc" id="L842" title="All 2 branches missed.">		userMgr = (userMgr == null) ? CoreManagerFactory.getUserManager(false) : userMgr;</span>

<span class="nc" id="L844">		User user = userMgr.getUserByName(userName);</span>
<span class="nc" id="L845">		Collection orgIDs = user.getAuthorizedScopes(privID, ORG_SCOPE);</span>
<span class="nc" id="L846">		return orgIDs;</span>
	}

	/**
	 * Returns 'null' if user has privilege for all the given orgIDs. A non-null
	 * orgID, for the which the user does not have the requested privilege, is
	 * returned otherwise.
	 *
	 * @param userName
	 * @param orgIDs
	 * @param privID
	 * @param raiseException
	 * @return
	 * @throws Exception
	 */
	public static ID checkPrivilegeForOrgs(String userName, Collection orgIDs, ID privID) throws Exception {
		// get the orgs for which the user has the specified privilege
<span class="nc" id="L863">		Collection privilegedOrgIDs = RequestUtil.getOrgIDsWithPrivForUserName(userName, privID, null);</span>

<span class="nc bnc" id="L865" title="All 2 branches missed.">		for (Iterator iter = orgIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L866">			ID orgID = (ID) iter.next();</span>

			// check if given orgID is in the collection of privileged orgs.
<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (!privilegedOrgIDs.contains(orgID)) {</span>
				// employee does not have specified privilege for this org
<span class="nc" id="L871">				return orgID;</span>
			}
<span class="nc" id="L873">		}</span>

		// employee has specified privilege for all orgs in the given collection
		// of orgIDs
<span class="nc" id="L877">		return null;</span>
	}

	/**
	 * Get the timezone for the current organization for an employee
	 *
	 * @param emplID
	 *            the employee id of the request to check
	 * @throws BbmFinderException
	 *             when organization id cannot be found
	 */
	public static TimeZone getTimezoneCurrentForEmployeeID(ID empID) throws Exception {

<span class="nc" id="L890">		TimeZone tz = null;</span>
		// if 'useRemoteRefs' or (dontUseRemoteRefs &amp;&amp; empID != null)
<span class="nc bnc" id="L892" title="All 6 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs || (!RmManagerFactory.m_useEJBRemoteRefs &amp;&amp; empID != null)) {</span>
			// Get the current organization for the employee
<span class="nc" id="L894">			ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>

			// todo: can the wrm be cached.
			// tz =
			// BbmManagerFactory.getWorkResourceManager().getOrganizationByID(orgID).getTimeZone();
<span class="nc" id="L899">			tz = CacheUtilBBM.getOrganizationByID(orgID).getTimeZone();</span>

			// Check to see that we got an org id
<span class="nc bnc" id="L902" title="All 2 branches missed.">			if (tz == null) {</span>
<span class="nc" id="L903">				throw createRmException(RmEjbLogBundleKey.CANNOT_FIND_TZ_FOR_ORG, new Object[] { orgID }, m_cat);</span>
			}
<span class="nc" id="L905">		} else { // dontUseRemoteRefs and empID == null</span>
<span class="nc" id="L906">			tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);</span>
		}

<span class="nc" id="L909">		return tz;</span>
	}

	/**
	 * @param date
	 * @param mgrTZ
	 * @return
	 */
	public static Calendar getCalendar(Date date, TimeZone tz) {
<span class="nc" id="L918">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L919">		cal.setTime(date);</span>
<span class="nc" id="L920">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L922">		return cal;</span>
	}

	/**
	 * Given a year, time zone and month/day, return a calendar set to that date
	 * or Feb 28 if it is Feb 29 during the given year.
	 */
	public static Calendar getCalendar(int year, int month, int day, TimeZone tz) {
		// Valid if leap year, if date is Feb 29th
<span class="nc bnc" id="L931" title="All 4 branches missed.">		if ((month == Calendar.FEBRUARY) &amp;&amp; (day == 29)) {</span>
<span class="nc" id="L932">			GregorianCalendar gc = new GregorianCalendar();</span>

<span class="nc bnc" id="L934" title="All 2 branches missed.">			if (!gc.isLeapYear(year)) {</span>
				// Use the 28th in non-leap years
<span class="nc" id="L936">				day = 28;</span>
			}
		}

		// create a calendar for the given day, month and year.
<span class="nc" id="L941">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L942">		cal.set(year, month, day, 0, 0, 0);</span>
<span class="nc" id="L943">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L944">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L946">		return cal;</span>
	}

	public static Calendar getEmployeeTimeOffYearStart(Date date, Organization org, int[] empTOYrStArr) {
<span class="nc" id="L950">		Calendar startCal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L951">		startCal.setTime(date);</span>
<span class="nc" id="L952">		startCal = RequestUtil.getCalendar(startCal.get(Calendar.YEAR), empTOYrStArr[0], empTOYrStArr[1],</span>
<span class="nc" id="L953">				org.getTimeZone());</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">		if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L955">			startCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
		}

<span class="nc bnc" id="L958" title="All 2 branches missed.">		if (startCal.getTime().after(date)) {</span>
<span class="nc" id="L959">			startCal.add(Calendar.YEAR, -1);</span>
		}
<span class="nc" id="L961">		return startCal;</span>
	}

	public static Calendar getEmployeeTimeOffYearEnd(Date date, Organization org, int[] empTOYrStArr) {
<span class="nc" id="L965">		Calendar empTOYearEndCal = getEmployeeTimeOffYearStart(date, org, empTOYrStArr);</span>
<span class="nc" id="L966">		empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">		if (!empTOYearEndCal.getTime().after(date)) {</span>
			// QC 82218; fix for leap year
<span class="nc" id="L969">			empTOYearEndCal.add(Calendar.MILLISECOND, 1);</span>
<span class="nc" id="L970">			empTOYearEndCal.set(Calendar.YEAR, empTOYearEndCal.get(Calendar.YEAR) + 1);</span>
<span class="nc" id="L971">			empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
		}
<span class="nc" id="L973">		return empTOYearEndCal;</span>
	}

	/**
	 * Given the start date for the time off year, return a calendar object set
	 * to the last day of the time off year.
	 */
	public static Calendar getCalendarForwardOneYear(int year, int month, int day, TimeZone tz) {
		// get the start date for the next year
<span class="nc" id="L982">		Calendar end = getCalendar(year + 1, month, day, tz);</span>

		// now subtract one second
<span class="nc" id="L985">		end.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L986">		end.getTime();</span>

<span class="nc" id="L988">		return end;</span>
	}

	public static Calendar getCalendarForDayStart(Date startTime, TimeZone tz) {
<span class="nc" id="L992">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc" id="L994">		cal.setTime(startTime);</span>
<span class="nc" id="L995">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L996">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L997">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L998">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L999">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L1001">		return cal;</span>
	}

	public static Calendar getCalendarForDayEnd(Date time, TimeZone tz) {
<span class="nc" id="L1005">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc" id="L1007">		cal.setTime(time);</span>
<span class="nc" id="L1008">		cal.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L1009">		cal.set(Calendar.MINUTE, 59);</span>
<span class="nc" id="L1010">		cal.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L1011">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L1012">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L1014">		return cal;</span>
	}

	public static Date getDateForDayStart(Date date, TimeZone tz) {
<span class="nc" id="L1018">		return getCalendarForDayStart(date, tz).getTime();</span>
	}

	public static Date getDateForDayEnd(Date date, TimeZone tz) {
<span class="nc" id="L1022">		return getCalendarForDayEnd(date, tz).getTime();</span>
	}

	public static Date getDateForYMDHMS(int year, int month, int day, int hour, int minute, int second, TimeZone tz) {
<span class="nc" id="L1026">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1027">		cal.set(year, month, day, hour, minute, second);</span>
<span class="nc" id="L1028">		cal.set(Calendar.MILLISECOND, 0);</span>

<span class="nc" id="L1030">		return cal.getTime();</span>
	}

	/**
	 * Set milliseconds to zero for the given date.
	 *
	 * @param deadLine
	 * @return
	 */
	public static Date getDateWithMillisReset(Date deadLine) {
<span class="nc" id="L1040">		return new Date((deadLine.getTime() / 1000L) * 1000L);</span>
	}

	public static Date getDateWithSecondsReset(Date deadLine) {
<span class="nc" id="L1044">		return new Date((deadLine.getTime() / 60000L) * 60000L);</span>
	}

	/**
	 * Get the date for 'n' days from the current date
	 *
	 * @param n
	 * @return
	 */
	public static Date getDateForDaysFromNow(int n) {
<span class="nc" id="L1054">		Date deadLine = new Date(System.currentTimeMillis() + n * 24 * 60 * 60 * 1000L); // current</span>
																							// time
																							// +
																							// 7
																							// days
<span class="nc" id="L1059">		deadLine = RequestUtil.getDateWithMillisReset(deadLine);</span>
<span class="nc" id="L1060">		return deadLine;</span>
	}

	public static Date getEarlierDate(Date date1, Date date2) {
<span class="nc bnc" id="L1064" title="All 2 branches missed.">		return (date1.before(date2) ? date1 : date2);</span>
	}

	public static Date getLaterDate(Date date1, Date date2) {
<span class="nc bnc" id="L1068" title="All 2 branches missed.">		return (date1.after(date2) ? date1 : date2);</span>
	}

	/**
	 * Return the day of week for the start of the org day in which the given
	 * date falls. Day of week is returned as a value between
	 * {@link Calendar#SUNDAY Sunday} and {@link Calendar#SATURDAY Saturday}.
	 *
	 * @param org
	 * @param date
	 * @return
	 */
	public static int getDayOfWeekForOrgDayStart(Organization org, Date date) {
<span class="nc" id="L1081">		Date orgDayStartDate = TOCalcUtil.getDateForOrgDayStart(org, date);</span>

<span class="nc" id="L1083">		Calendar orgDayStartCal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L1084">		orgDayStartCal.setTime(orgDayStartDate);</span>

<span class="nc" id="L1086">		return orgDayStartCal.get(Calendar.DAY_OF_WEEK);</span>
	}

	// public static String getDateFormtted(Date date, TimeZone tz) {
	// synchronized (m_dateformatFull){
	// m_dateformatFull.setTimeZone(tz);
	//
	// return m_dateformatFull.format(date);
	// }
	// }

	/**
	 * Is the given date between the specified time range (inclusive of time
	 * range's start and end)?
	 *
	 * @param givenDate
	 * @param start
	 * @param end
	 * @return
	 */
	public static boolean isDateBetween(Date givenDate, Date start, Date end) {
<span class="nc bnc" id="L1107" title="All 2 branches missed.">		start = (start == null) ? DATE_MIN : start;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">		end = (end == null) ? DATE_MAX : end;</span>

		// givenDate &gt;= start and givenDate &lt;= end;
<span class="nc bnc" id="L1111" title="All 4 branches missed.">		return (!givenDate.before(start)) &amp;&amp; (!givenDate.after(end));</span>
	}

	/**
	 * returns the overlap length in milliseconds.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: A 'null' for start or 'end' is not a valid value. Map the
	 * 'null' to the proper value (either Date(0) or Date(Long.MAX_VALUE))
	 * before calling this method.
	 *
	 * &lt;p&gt;
	 * Note: There is no overlap if
	 * &lt;li&gt;time1End == time2Start
	 * &lt;li&gt;if time1Start == time2End
	 *
	 * @param time1Start
	 * @param time1End
	 * @param time2Start
	 * @param time2End
	 * @return true if ranges overlap; false otherwise
	 */
	public static long getOverlapLength(Date time1Start, Date time1End, Date time2Start, Date time2End) {
<span class="nc" id="L1134">		long time1StartMs = time1Start.getTime();</span>
<span class="nc" id="L1135">		long time1EndMs = time1End.getTime();</span>
<span class="nc" id="L1136">		long time2StartMs = time2Start.getTime();</span>
<span class="nc" id="L1137">		long time2EndMs = time2End.getTime();</span>

<span class="nc bnc" id="L1139" title="All 4 branches missed.">		assert (time1StartMs &lt;= time1EndMs);</span>
<span class="nc bnc" id="L1140" title="All 4 branches missed.">		assert (time2StartMs &lt;= time2EndMs);</span>

<span class="nc" id="L1142">		long overlap = 0L;</span>
		// 4 cases:
		// time1Start between time2Start and time2End
		// time1End between time2Start and time2End
		// time1 contains time2.
		// time2 cotains time1
		//
		// if ranges overlap
<span class="nc bnc" id="L1150" title="All 4 branches missed.">		if ((time1StartMs &lt; time2EndMs) &amp;&amp; (time1EndMs &gt; time2StartMs)) {</span>
<span class="nc" id="L1151">			overlap = Math.min(time1EndMs, time2EndMs) - Math.max(time1StartMs, time2StartMs);</span>
		}

		// // time1Start between time2Start and time2End
		// if (time1StartMs &gt;= time2StartMs &amp;&amp; time1StartMs &lt; time2EndMs) {
		// long minEndTimeMs = Math.min(time1EndMs, time2EndMs);
		// overlap = minEndTimeMs - time1StartMs;
		// // time1End between time2Start and time2End
		// } else if (time1EndMs &gt; time2StartMs &amp;&amp; time1EndMs &lt;= time2EndMs) {
		// long maxStartTimeMs = Math.max(time1StartMs, time2StartMs);
		// overlap = time1EndMs - maxStartTimeMs;
		// // time1 contains time2.
		// } else if (time1StartMs &lt;= time2StartMs &amp;&amp; time1EndMs &gt;= time2EndMs)
		// {
		// overlap = time2EndMs - time2StartMs;
		// } //Note: time2 cotains time1 is covered by either the 1st or 2nd
		// 'if' above.

<span class="nc bnc" id="L1169" title="All 4 branches missed.">		assert overlap &gt;= 0 : &quot;overlap &gt;= 0: &quot; + overlap;</span>

<span class="nc" id="L1171">		return overlap;</span>
	}

	/**
	 * Returns the overlap interval between the two specified time ranges.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: this method may return 'null' if no the time ranges do not
	 * overlap.
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: A 'null' for start or 'end' is not a valid value. Map the
	 * 'null' to the proper value (either Date(0) or Date(Long.MAX_VALUE))
	 * before calling this method.
	 *
	 * @param time1Start
	 * @param time1End
	 * @param time2Start
	 * @param time2End
	 * @return 'null' if no overlap. Otherwise the overlapping time range.
	 */
	public static TimeRange getOverlapTimeRange(Date time1Start, Date time1End, Date time2Start, Date time2End) {

<span class="nc bnc" id="L1193" title="All 4 branches missed.">		assert (!time1Start.after(time1End));</span>
<span class="nc bnc" id="L1194" title="All 4 branches missed.">		assert (!time2Start.after(time2End));</span>

<span class="nc" id="L1196">		boolean hasOverlap = TimePeriodUtil.overlap(time1Start, time1End, time2Start, time2End);</span>

<span class="nc bnc" id="L1198" title="All 2 branches missed.">		if (!hasOverlap) {</span>
<span class="nc" id="L1199">			return null;</span>
		}

<span class="nc bnc" id="L1202" title="All 2 branches missed.">		Date overlapStartTime = time1Start.after(time2Start) ? time1Start : time2Start;</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">		Date overlapEndTime = time1End.before(time2End) ? time1End : time2End;</span>

<span class="nc" id="L1205">		return new TimeRange(overlapStartTime, overlapEndTime);</span>
	}

	public static TimeRange getOverlapTimeRange(TOHoursPerDay hrsPerDay, DailyHoursBuckets bkts) {
<span class="nc" id="L1209">		return getOverlapTimeRange(hrsPerDay.getStartTime(), hrsPerDay.getEndTime(),</span>
<span class="nc" id="L1210">				bkts.getDHBRangeStartAsOrgDayStart(), bkts.getDHBRangeEndAsOrgDayEnd());</span>
	}

	/**
	 * @param buffer1
	 * @param buffer2
	 * @param buffer3
	 * @return
	 */
	public static String concatStrBuffers(StringBuffer buffer1, StringBuffer buffer2, StringBuffer buffer3,
			String delimiter) {
<span class="nc" id="L1221">		StringBuffer concatStr = new StringBuffer(buffer1.length() + buffer2.length() + buffer3.length() + 64);</span>

<span class="nc" id="L1223">		return concatStr.append(buffer1).append(delimiter).append(buffer2).append(delimiter).append(buffer3).toString();</span>
	}

	protected static boolean isRmModuleException(BPException e) {
		// TODO: delete unnecessary exception types from RmModule.
<span class="nc bnc" id="L1228" title="All 6 branches missed.">		if (e instanceof RmException</span>
				|| /* e instanceof RmChangeStateException || */e instanceof RmHardValidationException
				|| /* e instanceof ValidationException || */e instanceof TimeOffCalculatorException) {
<span class="nc" id="L1231">			return true;</span>
		}

<span class="nc" id="L1234">		return false;</span>
	}

	public static BbmFinderException createBbmFinderExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1240" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BBM finder exception, just return.
<span class="nc bnc" id="L1242" title="All 2 branches missed.">			if (wrapped instanceof BbmFinderException) {</span>
				// BbmFinderException wrappedBbmExc = (BbmFinderException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1249">				return (BbmFinderException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1254">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1257">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
			// TODO: this will log BbmExceptions created in the RM module.
<span class="nc" id="L1262">			return createBbmFinderException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1263" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1266">			return createBbmFinderException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1267">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmFinderException createBbmFinderException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1273">		BbmFinderException exc = new BbmFinderException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1275">			cat.error(e, e);</span>
		}
<span class="nc" id="L1277">		return exc;</span>
	}

	public static BbmRemoveException createBbmRemoveExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1283" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BbmRemoveException, just return.
<span class="nc bnc" id="L1285" title="All 2 branches missed.">			if (wrapped instanceof BbmRemoveException) {</span>
				// BbmRemoveException wrappedBbmExc = (BbmRemoveException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1292">				return (BbmRemoveException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1297">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1300">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1304">			return createBbmRemoveException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1308">			return createBbmRemoveException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1309">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmRemoveException createBbmRemoveException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1315">		BbmRemoveException exc = new BbmRemoveException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1317">			cat.error(e, e);</span>
		}
<span class="nc" id="L1319">		return exc;</span>
	}

	public static BbmUpdateException createBbmUpdateExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1325" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BbmUpdateException, just return.
<span class="nc bnc" id="L1327" title="All 2 branches missed.">			if (wrapped instanceof BbmUpdateException) {</span>
				// BbmUpdateException wrappedBbmExc = (BbmUpdateException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1334">				return (BbmUpdateException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1339">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1342">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1346">			return createBbmUpdateException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1350">			return createBbmUpdateException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1351">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmUpdateException createBbmUpdateException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1357">		BbmUpdateException exc = new BbmUpdateException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1358" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1359">			cat.error(e, e);</span>
		}
<span class="nc" id="L1361">		return exc;</span>
	}

	public static BbmCreateException createBbmCreateExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1367" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a validaton exception, just return.
<span class="nc bnc" id="L1369" title="All 2 branches missed.">			if (wrapped instanceof BbmCreateException) {</span>
				// BbmCreateException wrappedBbmExc = (BbmCreateException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1376">				return (BbmCreateException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1381">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1384">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1388">			return createBbmCreateException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1392">			return createBbmCreateException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1393">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmCreateException createBbmCreateException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1399">		BbmCreateException exc = new BbmCreateException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1401">			cat.error(e, e);</span>
		}
<span class="nc" id="L1403">		return exc;</span>
	}

	/**
	 * Create and Log RmHardValidationException
	 *
	 * @param uiKey
	 *            - Rm Resource Bundle Key for UI
	 * @param logKey
	 *            - Rm Resource Bundle Key for Logging
	 * @param params
	 *            - Parameters that is part of the message
	 * @param cat
	 *            - Categroy to be used for logging if it is not null
	 * @return RmHardValidationException
	 */
	public static RmHardValidationException createAndLogRmHardValidationException(String uiKey, String logKey,
			Object[] params, Category cat) {
<span class="nc" id="L1421">		RmHardValidationException exc = new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, uiKey,</span>
				RmEjbLogBundleKey.BUNDLE_NAME, logKey, params);
<span class="nc bnc" id="L1423" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1424">			cat.debug(exc.getLocalizedMessage(), exc);</span>
		}
<span class="nc" id="L1426">		return exc;</span>
	}

	public static RmHardValidationException createRmHardValidationException(ValidationResult vr, Category cat) {
<span class="nc" id="L1430">		RmHardValidationException e = new RmHardValidationException(vr.getMessageBundle(), vr.getMessageResource(),</span>
<span class="nc" id="L1431">				vr.getMessageParms());</span>

		// since a hard validation error is a validation error and not a system
		// error, it is logged with
		// severity 'info' and not 'error' to avoid cluttering the log files.
<span class="nc bnc" id="L1436" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1437">			cat.debug(e, e);</span>
		}

<span class="nc" id="L1440">		return e;</span>
	}

	/**
	 * @param string
	 * @param objects
	 * @param m_cat2
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object[] parms,
			Category cat) {
<span class="nc" id="L1451">		RmHardValidationException exc = new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, msgKey, parms);</span>
		// since a hard validation error is a validation error and not a system
		// error, it is logged with
		// severity 'info' and not 'error' to avoid cluttering the log files.
<span class="nc bnc" id="L1455" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1456">			cat.debug(exc, exc);</span>
		}
<span class="nc" id="L1458">		return exc;</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Category cat) {
<span class="nc" id="L1468">		return createRmHardValidationException(msgKey, new Object[] { obj1 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Category cat) {
<span class="nc" id="L1480">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param obj3
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Object obj3, Category cat) {
<span class="nc" id="L1493">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2, obj3 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param obj3
	 * @param obj4
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Object obj3, Object obj4, Category cat) {
<span class="nc" id="L1507">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2, obj3, obj4 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Category cat) {
<span class="nc" id="L1516">		return createRmHardValidationException(msgKey, null, cat);</span>
	}

	// TODO: verify createRmException is never passed a RmEjbValidationBundleKey
	public static RmException createRmException(String msgKey, Category cat) {
<span class="nc" id="L1521">		return createRmException(msgKey, null, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Category cat) {
<span class="nc" id="L1525">		return createRmException(msgKey, new Object[] { parm1 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Category cat) {
<span class="nc" id="L1529">		return createRmException(msgKey, new Object[] { parm1, parm2 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Object parm3, Category cat) {
<span class="nc" id="L1533">		return createRmException(msgKey, new Object[] { parm1, parm2, parm3 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Object parm3, Object parm4,
			Category cat) {
<span class="nc" id="L1538">		return createRmException(msgKey, new Object[] { parm1, parm2, parm3, parm4 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object[] parms, Category cat) {
<span class="nc" id="L1542">		RmException rmExc = new RmException(RmEjbLogBundleKey.BUNDLE_NAME, msgKey, parms);</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1544">			cat.error(rmExc, rmExc);</span>
		}
<span class="nc" id="L1546">		return rmExc;</span>
	}

	private static RmException createRmException(Exception e, String bundleName, String msgKey, Object[] parms,
			Category cat) {
<span class="nc" id="L1551">		RmException rmExc = new RmException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1553">			cat.error(e, e);</span>
		}
<span class="nc" id="L1555">		return rmExc;</span>
	}

	// TODO: convert all throwXXXException()s to createXXXExceptions()
	// TODO: all throwXXXException() variants must use throwXXException(msgkey,
	// Object[] parms, cat).
	/**
	 * &lt;p&gt;
	 * Goal is to log the exception only once.
	 *
	 * &lt;p&gt;
	 * Passed exception is wrapped inside a newly created RMException.&lt;br&gt;
	 * If given exception is already an RmException, then it is not rewrapped.
	 * &lt;br&gt;
	 * If given exception is not an exception from the RM module, then it is
	 * logged (An exception from the RM module will always be logged when it was
	 * created). &lt;br&gt;
	 * TODO: enforce logging of RM module exceptions when created.
	 *
	 * @param e
	 * @param cat
	 * @return
	 */
	public static RmException createRmExceptionWrapper(Exception e, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1581" title="All 2 branches missed.">		if (e instanceof BPException) {</span>
			// if already a validaton exception, just return.
<span class="nc bnc" id="L1583" title="All 2 branches missed.">			if (e instanceof RmException) {</span>
<span class="nc" id="L1584">				return (RmException) e;</span>
			}

			// cast to BPException
<span class="nc" id="L1588">			BPException bpException = (BPException) e;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1591">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1595">			return createRmException(e, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1596" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1599">			return createRmException(e, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1600">					new Object[] { e.getMessage() }, cat);</span>
		}
	}

	/**
	 * @param string
	 * @return
	 */
	public static RuntimeException createRunTimeException(String msg, Category cat) {
<span class="nc" id="L1609">		RuntimeException exception = new RuntimeException(msg);</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1611">			cat.error(exception);</span>
		}

<span class="nc" id="L1614">		return exception;</span>
	}

	/**
	 * @param msg
	 * @param e
	 * @return
	 */
	public static RuntimeException createRunTimeException(String msg, Exception e, Category cat) {
<span class="nc" id="L1623">		RuntimeException exception = new RuntimeException(msg, e);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1625">			cat.error(exception);</span>
		}

<span class="nc" id="L1628">		return exception;</span>
	}

	/**
	 * @param cat
	 * @return
	 */
	public static IllegalArgumentException createIllegalArgumentException(String msg, Category cat) {
<span class="nc bnc" id="L1636" title="All 2 branches missed.">		IllegalArgumentException e = (msg != null) ? new IllegalArgumentException(msg) : new IllegalArgumentException();</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1638">			cat.error(e);</span>
		}

<span class="nc" id="L1641">		return e;</span>
	}

	/**
	 * Exceptions thrown in the RM module will be logged before being thrown.
	 * Exceptions thrown by other modules (BBM, AM etc) might not be logged when
	 * thrown. Java language exceptions are not logged when thrown.
	 *
	 * TODO: exception handling guidelines. Goals: Methods must throw a single
	 * exception to simplify exception handling for the caller(due to forcing
	 * checked exception handling by the compiler). Even though a single
	 * exception is thrown, it must be possible to identify the actual reason
	 * (error code) if necessary, for error handling by the caller. When
	 * exceptions are nested, due to the first requirement of only one
	 * exception, the internal information of BPException subtypes (bundle,
	 * msgKey, parms, severity code, message etc) must be extracted and wrapped
	 * in the newly thrown BPException subtype. Present exception types thrown
	 * in RM: BbmXXXX, ValidationException, RmHardValidationException,
	 * RmChangeStateException. Out of these, only RmHardValidationException is
	 * used by the caller (webtier) to identify a hard validation error. In
	 * fact, the webtier only uses the caught exceptions to display an error
	 * message and not recover from an error. Given that exceptions caught by
	 * callers are seldom used to recover from errors, it might be a good idea
	 * to to have a just a handfull of exceptions in the RM to prevent
	 * unnecessary wrapping and a short exception signature in the RM module
	 * methods. BP Exceptions, in the RM module, must be logged before they are
	 * thrown. BP Exceptions, from modules, other than RM, must be caught,
	 * logged, wrapped and then rethrown. Non BP Exceptions (Java exceptions)
	 * must also be caught, logged, wrapped and then rethrown.
	 *
	 * @param e
	 */
	public static ExceptionMessage getMsgFromFirstBPException(BPException e) {
		// Note: The innermost BPException either wraps a non BPException or
		// contains a
		// localized message (using bundle, msgkey and parms). It cannot contain
		// a
		// non localized message (ie. messages without bundlename).
		// (BPException implementation defaults to the common bundle for its
		// 'bundle' member variable).

		// get inner most BPException
<span class="nc" id="L1683">		BPException firstBPExcep = e.getFirstException();</span>

		// get wrapped non BPException
<span class="nc" id="L1686">		Exception nonBPException = firstBPExcep.getCoreException();</span>

		// TODO: must the locale be used?
		// if wrapped exception present.
<span class="nc bnc" id="L1690" title="All 2 branches missed.">		if (nonBPException != null) {</span>
<span class="nc" id="L1691">			return new ExceptionMessage(nonBPException.getClass().getName() + ':' + nonBPException.getMessage());</span>
		}

		// cannot contain non localized message (see above)
		/*
		 * if ( StringUtil.isEmpty(firstBPExcep.getBundleName()) ) { return new
		 * ExceptionMessage( firstBPExcep.getMessage() ); }
		 */

		// otherwise inner most BP Exception has a localized messgage.
<span class="nc" id="L1701">		return new ExceptionMessage(firstBPExcep.getBundleName(), firstBPExcep.getMsgID(),</span>
<span class="nc" id="L1702">				firstBPExcep.getParamObject());</span>
	}

	public static ExceptionMessage getMsgFromException(Exception e) {
		// if given exception is a BP Exception, extract exception information
<span class="nc bnc" id="L1707" title="All 2 branches missed.">		if (e instanceof BPException) {</span>
<span class="nc" id="L1708">			return getMsgFromFirstBPException((BPException) e);</span>
		}

		// if given exception is a non BP Exception, return embedded message.
<span class="nc" id="L1712">		return new ExceptionMessage(e.getClass().getName() + ':' + e.getMessage());</span>
	}

	/**
	 * Scans the parms array and localizes the parm if necessary (based on its
	 * datatype). Returns the given parms array with the localizable elements
	 * replaced with their localized strings.
	 *
	 * @param msgParms
	 * @return
	 */
	public static String getLocalizedMessage(String bundleName, String msgKey, Object[] msgParms, Localizer localizer,
			TimeZone tzView) {
<span class="nc" id="L1725">		TimeZone tzOrg = null;</span>
<span class="nc" id="L1726">		RequestFilingRule filingRule = null;</span>

		// localize the message parameters
<span class="nc bnc" id="L1729" title="All 4 branches missed.">		for (int i = 0; msgParms != null &amp;&amp; i &lt; msgParms.length; i++) {</span>
			// if type is Date
<span class="nc bnc" id="L1731" title="All 2 branches missed.">			if (msgParms[i] instanceof Date) {</span>
<span class="nc" id="L1732">				Date date = (Date) msgParms[i];</span>
<span class="nc" id="L1733">				msgParms[i] = localizer.formatDateTime(date, tzView);</span>
<span class="nc" id="L1734">			} // if type is ShiftsConflict.</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">			else if (msgParms[i] instanceof ShiftsConflict) {</span>
<span class="nc" id="L1736">				ShiftsConflict conflict = (ShiftsConflict) msgParms[i];</span>
<span class="nc" id="L1737">				msgParms[i] = conflict.getDisplayString(localizer, tzView);</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">			} else if (msgParms[i] instanceof UnlocalizedStringWrapper) {</span>
<span class="nc" id="L1739">				UnlocalizedStringWrapper unlocStringWrapper = (UnlocalizedStringWrapper) msgParms[i];</span>
<span class="nc" id="L1740">				msgParms[i] = unlocStringWrapper.getLocalizedString(localizer);</span>
<span class="nc bnc" id="L1741" title="All 2 branches missed.">			} else if (msgParms[i] instanceof ResourceBundleKeyWrapper) {</span>
<span class="nc" id="L1742">				ResourceBundleKeyWrapper resBundleWrapper = (ResourceBundleKeyWrapper) msgParms[i];</span>
				// Note: the parameter 'bundleName' for this method is not used
				// as the bundle name.
<span class="nc" id="L1745">				msgParms[i] = localizer.i18n(ResourceBundleKeyWrapper.getResBundleName(),</span>
<span class="nc" id="L1746">						resBundleWrapper.getResBundleMsgKey());</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">			} else if (msgParms[i] instanceof PersonName) { // Class 'Employee'</span>
															// implements the
															// 'PersonName'
															// interface
<span class="nc" id="L1751">				msgParms[i] = localizer.formatName((PersonName) msgParms[i]);</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">			} else if (msgParms[i] instanceof TimeZone) {</span>
<span class="nc" id="L1753">				tzOrg = (TimeZone) msgParms[i];</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">			} else if (msgParms[i] instanceof RequestFilingRule) {</span>
<span class="nc" id="L1755">				filingRule = (RequestFilingRule) msgParms[i];</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">			} else if (msgParms[i] instanceof LocalDate) {</span>
<span class="nc" id="L1757">				LocalDate date = (LocalDate) msgParms[i];</span>
<span class="nc" id="L1758">				msgParms[i] = localizer.formatDate(date, RegionalFormatBundleKey.DATE_FORMAT);</span>
			}
		}
<span class="nc" id="L1761">		msgParms = addExtendedFilingRuleParams(bundleName, msgParms, localizer, tzView, tzOrg, filingRule);</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">		return (msgParms != null) ? localizer.i18n(bundleName, msgKey, msgParms) : localizer.i18n(bundleName, msgKey);</span>
	}

	/**
	 * Add additional info about a filing rule to the msgParms array. The
	 * additional info is made up of the three parts that define the filing
	 * rule, so that the user will now which filing rule was violated. The three
	 * parts are: - Subtype string, which is the time off activity name - Date
	 * range data - File By data
	 */
	protected static Object[] addExtendedFilingRuleParams(String bundleName, Object[] msgParams, Localizer localizer,
			TimeZone tzView, TimeZone tzOrg, RequestFilingRule filingRule) {
<span class="nc bnc" id="L1774" title="All 2 branches missed.">		if (filingRule != null) {</span>
<span class="nc" id="L1775">			Object[] expandedMsgParams = new Object[msgParams.length + 1];</span>
			try {
				// make a copy of the params array, but exclude the last two
				// items because those are for the time zone and
				// the filing rule, which should be replaced by actual
				// description strings.
<span class="nc bnc" id="L1781" title="All 2 branches missed.">				TimeZone tz = tzOrg == null ? tzView : tzOrg;</span>
<span class="nc" id="L1782">				ResourceBundle rmEjbBundle = localizer.getBundle(bundleName);</span>
<span class="nc" id="L1783">				int i = 0;</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">				for (i = 0; i &lt; msgParams.length - 2; i++) {</span>
<span class="nc" id="L1785">					expandedMsgParams[i] = msgParams[i];</span>
				}

<span class="nc" id="L1788">				String requestTypeDesc = RequestUtil.getTimeOffOrFlexTimeSubtypesString(false, filingRule, rmEjbBundle,</span>
						localizer, false);
<span class="nc" id="L1790">				String dateRangeData = RequestUtil.getDateRangeData(localizer, filingRule, rmEjbBundle, tz);</span>
<span class="nc" id="L1791">				String fileByData = RequestUtil.getFileByData(filingRule, rmEjbBundle, localizer, tz);</span>
<span class="nc" id="L1792">				expandedMsgParams[i++] = requestTypeDesc;</span>
<span class="nc" id="L1793">				expandedMsgParams[i++] = dateRangeData;</span>
<span class="nc" id="L1794">				expandedMsgParams[i++] = fileByData;</span>
<span class="nc" id="L1795">				return expandedMsgParams;</span>
<span class="nc" id="L1796">			} catch (Exception ex) {</span>
				// do nothing, not critical.
			}
		}
<span class="nc" id="L1800">		return msgParams;</span>
	}

	public static Localizer getLocalizerForAppDefLocale() {
<span class="nc" id="L1804">		return DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object[] msgParms, TimeZone tzView) {

<span class="nc" id="L1809">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1811">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, msgParms, appDefLocaleLocalizer, tzView);</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey) {

<span class="nc" id="L1816">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

		// passing 'null' for the TZ is ok as the TZ is only used for the
		// parameters to a message format.
<span class="nc" id="L1820">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, null, appDefLocaleLocalizer, null);</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm, TimeZone tzView) {

<span class="nc" id="L1825">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1827">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm }, appDefLocaleLocalizer,</span>
				tzView);
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm1, Object msgParm2,
			TimeZone tzView) {

<span class="nc" id="L1834">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1836">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm1, msgParm2 },</span>
				appDefLocaleLocalizer, tzView);
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm1, Object msgParm2, Object msgParm3,
			TimeZone tzView) {

<span class="nc" id="L1843">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1845">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm1, msgParm2, msgParm3 },</span>
				appDefLocaleLocalizer, tzView);
	}

	public static String getLocalizedEmpNameByID(ID empID, Localizer localizer) throws Exception {
<span class="nc" id="L1850">		Employee emp = ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
<span class="nc" id="L1851">		String empName = localizer.formatName(emp);</span>

<span class="nc" id="L1853">		return empName;</span>
	}

	/**
	 * Get the holidays for the given org during the time period.
	 *
	 * @return collection of Holiday objects
	 */
	public static Collection getHolidaysDuringPeriod(Organization org, TimeRange range) throws Exception {
		// HolidayManager hm = BbmManagerFactory.getHolidayManager();
<span class="nc" id="L1863">		ID orgID = org.getID();</span>
<span class="nc" id="L1864">		TimeZone tz = org.getTimeZone();</span>
<span class="nc" id="L1865">		LocalDate startLocDate = new LocalDate(range.getStartDate(), tz);</span>
<span class="nc" id="L1866">		LocalDate endLocDate = new LocalDate(range.getEndDate(), tz);</span>
		// if day boundary is &gt;0, add day boundary offset to end date to catch
		// all holidays
<span class="nc bnc" id="L1869" title="All 2 branches missed.">		if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L1870">			endLocDate.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
		}

		// return hm.getHolidays(orgId, ldStart, ldEnd);
<span class="nc" id="L1874">		Collection holidays = CacheUtilBBM.getHolidaysForOrg(orgID, startLocDate, endLocDate);</span>
<span class="nc" id="L1875">		return holidays;</span>
	}

	/**
	 * Get the OrganizationHOO objects for the given org during the time period.
	 *
	 * @return collection of OrganizationHOO objects
	 */
	public static Collection getHooAssignmentsDuringPeriod(Organization org, TimeRange range) throws Exception {
<span class="nc" id="L1884">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1885">		ID orgId = org.getID();</span>

<span class="nc" id="L1887">		Collection hooAssns = wrm.getOrganizationHOOAssignments(orgId, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">		hooAssns = (hooAssns == null) ? Collections.emptyList() : hooAssns;</span>

<span class="nc" id="L1890">		return hooAssns;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static OrganizationHOOPeriod getHOOPeriod(ID orgID, Date start, Date end)
			throws BbmFinderException, RemoteException, BbmEJBCreateException {
<span class="nc" id="L1896">		List&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L1897">		orgIDs.add(orgID);</span>

<span class="nc" id="L1899">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1900">		Map&lt;ID, OrganizationHOOPeriod&gt; orgIdToHoopMap = wrm.getHOOPeriod(orgIDs, start, end);</span>
<span class="nc" id="L1901">		return orgIdToHoopMap.get(orgID);</span>
	}

	/**
	 * @param string
	 * @return
	 */
	public static Campaign getCampaignByName(String campName) throws Exception {
<span class="nc" id="L1909">		CampaignManager cm = getCampaignManager();</span>

		// no getCampaignForName() method in campaingManager. Have to use
		// getCampaingns() instead.
<span class="nc" id="L1913">		Collection allCamps = cm.getCampaigns();</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">		for (Iterator allCampsIter = allCamps.iterator(); allCampsIter.hasNext();) {</span>
<span class="nc" id="L1915">			Campaign camp = (Campaign) allCampsIter.next();</span>

<span class="nc bnc" id="L1917" title="All 2 branches missed.">			if (camp.getName().toLowerCase().equals(campName.toLowerCase())) {</span>
<span class="nc" id="L1918">				return camp;</span>
			}
<span class="nc" id="L1920">		}</span>

<span class="nc" id="L1922">		return null;</span>
	}

	public static Campaign getCampaignByID(ID campID, CampaignManager campMgr)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException, BbmEJBCreateException {
<span class="nc bnc" id="L1927" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>
<span class="nc" id="L1928">		return campMgr.getCampaignByID(campID);</span>
	}

	public static Collection getCampaignAssnsForWorkResDuringPeriod(ID empID, Date start, Date end) throws Exception {
		// try {
<span class="nc" id="L1933">		CampaignManager cm = getCampaignManager();</span>

		// todo: optimize with List, if possible
		// TODO: route thru validation cache.
<span class="nc" id="L1937">		Collection campWorkResAssns = cm.getWorkResourceCampaignAssignments(empID, start, end);</span>

<span class="nc" id="L1939">		return campWorkResAssns;</span>
		// } c_atch (Exception e) {
		// t_hrow createValidationExceptionWrapper(e, m_cat);
		// }
	}

	public static Collection getCampOrgAssignments(ID campaignID, Date aucStartTime, Date aucEndTime,
			CampaignManager campMgr) throws BbmEJBCreateException, BbmFinderException, RemoteException {

<span class="nc bnc" id="L1948" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>
<span class="nc" id="L1949">		return campMgr.getCampaignOrgAssignments(campaignID, aucStartTime, aucEndTime);</span>
	}

	/**
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @param campMgr
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private static Collection getSPIDsForEmpDuringTimeRange(ID empID, Date start, Date end, CampaignManager campMgr)
			throws Exception {

		// get SPs associated with employee.
<span class="nc" id="L1966">		Collection campWorkResAssns = RequestUtil.getCampaignAssnsForWorkResDuringPeriod(empID, start, end);</span>

<span class="nc" id="L1968">		Collection empSPIDDuringTimeRange = new ArrayList();</span>
<span class="nc bnc" id="L1969" title="All 2 branches missed.">		for (Iterator iter = campWorkResAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1970">			CampaignWorkResource campWorkRes = (CampaignWorkResource) iter.next();</span>
<span class="nc" id="L1971">			empSPIDDuringTimeRange.add(campWorkRes.getSPID());</span>
<span class="nc" id="L1972">		}</span>

<span class="nc" id="L1974">		return empSPIDDuringTimeRange;</span>
	}

	/**
	 * @param shiftAssnSPID
	 */
	private static SchedulingPeriod getSPForSPID(ID SPID, CampaignManager campMgr)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc bnc" id="L1982" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>

<span class="nc" id="L1984">		return campMgr.getSchedulingPeriodByID(SPID);</span>
	}

	public static Collection getSchedulingPeriod(Collection spIDs)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L1989">		CampaignManager campMgr = getCampaignManager();</span>

<span class="nc" id="L1991">		return campMgr.getSchedulingPeriodsByID(spIDs);</span>
	}

	public static Map getOrganizationsByNames(HashSet names, WorkResourceManager wrm) throws Exception {
<span class="nc bnc" id="L1995" title="All 2 branches missed.">		wrm = (wrm == null) ? BbmManagerFactory.getWorkResourceManager() : wrm;</span>

		// Can't use Collections.singleton() since method expects a HashSet
<span class="nc" id="L1998">		return wrm.getOrganizationIDsByNames(names);</span>
	}

	public static Organization getOrganizationByID(ID orgID, WorkResourceManager wrm) throws Exception {
<span class="nc" id="L2002">		return CacheUtilBBM.getOrganizationByID(orgID);</span>
	}

	public static Collection&lt;WorkResourceAssignment&gt; geOrgAssnsForWorkResDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L2006">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc" id="L2008">		return wrm.getWorkResourceAssignments(empID, start, end, false);</span>
	}

	/**
	 * Get the time off events for all the employees in the organization during
	 * the request time period.
	 *
	 * @param empIDsWithEvents
	 *            Optional. Can be null. If non-null, any empID with events are
	 *            added to this collection
	 */
	public static Collection getTimeoffEventsPubForOrg(Collection empIDs, TimeRange range, Collection empIDsWithEvents,
			ArrayList allotmentList) throws Exception {
<span class="nc" id="L2021">		Date start = range.getStartDate();</span>
<span class="nc" id="L2022">		Date end = range.getEndDate();</span>
<span class="nc" id="L2023">		Collection results = new ArrayList();</span>

<span class="nc" id="L2025">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L2026">		Collection listOfLists = sam.getPublishedEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF, empIDs, start,</span>
				end);

		// We don't need the separate lists, collect them as a single list.
<span class="nc" id="L2030">		Iterator empIDIter = empIDs.iterator();</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">		for (Iterator it = listOfLists.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2032">			Collection list = (Collection) it.next();</span>
<span class="nc" id="L2033">			Collection newList = new ArrayList();</span>

			// if needed, filter out non allotment events
<span class="nc bnc" id="L2036" title="All 2 branches missed.">			if (list != null) {</span>
<span class="nc bnc" id="L2037" title="All 2 branches missed.">				if (!allotmentList.isEmpty()) {</span>
					// iterate through the list
<span class="nc bnc" id="L2039" title="All 2 branches missed.">					for (Iterator iter = list.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2040">						TimeOffEvent toEvt = (TimeOffEvent) iter.next();</span>
						// get the activity of the time off
<span class="nc bnc" id="L2042" title="All 2 branches missed.">						if (allotmentList.contains(toEvt.getActivityID())) {</span>
<span class="nc" id="L2043">							newList.add(toEvt);</span>
						}
<span class="nc" id="L2045">					}</span>
				} else {
<span class="nc" id="L2047">					newList.addAll(list);</span>
				}
			}

<span class="nc" id="L2051">			ID currEmpID = (ID) empIDIter.next();</span>

			// The list for each empId may be null.
<span class="nc bnc" id="L2054" title="All 4 branches missed.">			if (newList != null &amp;&amp; !newList.isEmpty()) {</span>
<span class="nc" id="L2055">				results.addAll(newList);</span>

				// add the empID if necessary.
<span class="nc bnc" id="L2058" title="All 2 branches missed.">				if (empIDsWithEvents != null) {</span>
<span class="nc" id="L2059">					empIDsWithEvents.add(currEmpID);</span>
				}
			}
<span class="nc" id="L2062">		}</span>

<span class="nc" id="L2064">		return results;</span>
	}

	/**
	 * Called during approval or tentative approval. For approvals of request
	 * type &quot;debit&quot;, the time off length is frozen after approval (ie. not
	 * recalculated if factors affecting length change after approval).
	 *
	 * @param toReq
	 * @param choice
	 * @param toRule
	 * @return
	 * @throws BbmFinderException
	 * @throws TimeOffCalculatorException
	 */
	public static TimeOffEvent createTimeOffEventVO(TORequest toReq, TOChoice choice, short toRule)
			throws BbmFinderException, RmException, TimeOffCalculatorException {
<span class="nc" id="L2081">		TimeOffEvent toEvt = new TimeOffEvent();</span>
<span class="nc" id="L2082">		setCalendarEventAssignFields(toEvt, toReq, choice);</span>

		// if UI option == &quot;debit&quot; chosen
<span class="nc bnc" id="L2085" title="All 2 branches missed.">		if (toRule == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
			// Calculate the length of the time off event if approving.
			// if (
			// toReq.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED))
			// {
			// for QA53522 -Tentative Approved Time Off to be counted towards X
			// minutes
			// tentative requests should also be created with non zero length.
<span class="nc" id="L2093">			TORequestUtil.updateTOEventMinutes(toEvt, toReq, choice);</span>
			// }

			// use the computed length for the length of the timeoff. Since any
			// changes to the schedule under
			// the timeoff event, after the event is created, will not alter
			// this length, it mut never be changed.
<span class="nc" id="L2100">			toEvt.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES);</span>
		}
		// if UI option == &quot;debit-if-necessary&quot; chosen
<span class="nc bnc" id="L2103" title="All 2 branches missed.">		else if (toRule == TimeOffEvent.TIME_OFF_RULE_USE_SHIFT) {</span>
			// set the length of the time off event to 0. The length is computed
			// on the fly anytime it is needed.
<span class="nc" id="L2106">			toEvt.setCountsMinutesTowardsRules(0);</span>
			// Use the current schedule (shifts) under the TOEvent to calculate
			// the length of the timeoff event.
<span class="nc" id="L2109">			toEvt.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_SHIFT);</span>
		} else {
<span class="nc" id="L2111">			throw createRmException(RmEjbLogBundleKey.INVALID_VALUE, &quot;toRule&quot;, new Short(toRule), m_cat);</span>
		}

<span class="nc" id="L2114">		return toEvt;</span>
	}

	/**
	 * @param empID
	 * @param eventType
	 *            see {@link Event Event}
	 * @param published
	 * @param start
	 * @param end
	 * @param sam
	 * @return
	 * @throws Exception
	 */
	// TODO: refactor code to use this to retrive caleventassigns.
	public static Collection getEventsDuringPeriod(ID empID, int eventType, boolean published, Date start, Date end,
			ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L2131">		String methodName = &quot;getCalEventAssignsDuringPeriod&quot;;</span>
<span class="nc" id="L2132">		m_cat.debug(RmUtil.dumpEnterMethod(methodName,</span>
				new Object[] { empID, new Integer(eventType), new Boolean(published), start, end }));

<span class="nc bnc" id="L2135" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

<span class="nc" id="L2137">		Collection events = null;</span>
<span class="nc bnc" id="L2138" title="All 2 branches missed.">		if (!published) {</span>
<span class="nc" id="L2139">			events = sam.getEventsForWorkResourceByType(eventType, empID, start, end);</span>
		} else {
<span class="nc" id="L2141">			events = sam.getPublishedEventsForWorkResourceByType(eventType, empID, start, end);</span>
		}

<span class="nc" id="L2144">		m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>

<span class="nc" id="L2146">		return events;</span>
	}

	/**
	 * @param empID
	 * @param startDate
	 * @param endDate
	 * @param sam
	 * @return
	 */
	public static Collection getShiftAssignsDuringPeriod(ID empID, Date startDate, Date endDate, boolean pub,
			ScheduleAccessManager sam) throws Exception {

<span class="nc" id="L2159">		return getEventsDuringPeriod(empID, Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT,</span>
				pub, startDate, endDate, sam);
	}

	/**
	 * @param empID
	 * @param startDate
	 * @param endDate
	 * @param sam
	 * @return
	 */
	public static Collection getUnavailsDuringPeriod(ID empID, Date startDate, Date endDate, boolean pub,
			ScheduleAccessManager sam) throws Exception {

<span class="nc" id="L2173">		return getEventsDuringPeriod(empID, Event.EVENT_TYPE_UNAVAILABILITY, pub, startDate, endDate, sam);</span>
	}

	public static CalendarEventAssignment createCalendarEventAssignment(TORequest toReq, TOChoice apprChoice,
			boolean publish) throws BbmFinderException, RmException, TimeOffCalculatorException, BbmEJBCreateException,
			BbmScheduleConflictException, RemoteException, BbmCreateException, Exception {
		// create a new calendar event.
<span class="nc" id="L2180">		CalendarEventAssignment evt = null;</span>
<span class="nc" id="L2181">		String debitType = toReq.getTimeOffDebitType();</span>

<span class="nc" id="L2183">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

		// get overlap and trim existing time off events
<span class="nc" id="L2186">		TORequestUtil.trimOverlappingEvents(toReq, apprChoice, sam, publish);</span>

		// Create an unavailability event if debit type == DEBITTYPE_DONT_DEBIT
<span class="nc bnc" id="L2189" title="All 2 branches missed.">		if (debitType.equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
			// The constraint that &quot;Unavailability events must not overlap
			// shifts&quot;
			// has already been checked by the hard validation logic above.
<span class="nc" id="L2193">			evt = new UnavailabilityEvent();</span>
<span class="nc" id="L2194">			setCalendarEventAssignFields(evt, toReq, apprChoice);</span>
		}
		// Create a timeoff event if debit type == DEBITTYPE_DEBIT
<span class="nc bnc" id="L2197" title="All 2 branches missed.">		else if (debitType.equals(TORequest.DEBITTYPE_DEBIT)) {</span>
<span class="nc" id="L2198">			evt = createTimeOffEventVO(toReq, apprChoice, TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES);</span>
		}
		// create a timeoff event if debit type == DEBITTYPE_DEBIT_ONLY_IF
<span class="nc bnc" id="L2201" title="All 2 branches missed.">		else if (debitType.equals(TORequest.DEBITTYPE_DEBIT_ONLY_IF)) {</span>
<span class="nc" id="L2202">			evt = createTimeOffEventVO(toReq, apprChoice, TimeOffEvent.TIME_OFF_RULE_USE_SHIFT);</span>
		} else {
<span class="nc" id="L2204">			throw createRmException(RmEjbLogBundleKey.INVALID_VALUE, &quot;debitType&quot;, debitType, m_cat);</span>
		}
<span class="nc" id="L2206">		evt.setDescription(getAuditTrailStr(toReq));</span>
<span class="nc" id="L2207">		sam.createCalendarEventAssignment(evt);</span>
<span class="nc" id="L2208">		return evt;</span>
	}

	public static Collection getAuditTrail(TORequest request) throws BbmFinderException {
<span class="nc" id="L2212">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L2214">			dmo = new Jdmo(false);</span>
<span class="nc" id="L2215">			RequestAuditTrailDAO reqDAO = new RequestAuditTrailDAO(dmo);</span>
<span class="nc" id="L2216">			return reqDAO.getObjectsByParentID(request.getID());</span>
<span class="nc" id="L2217">		} catch (Exception e) {</span>
<span class="nc" id="L2218">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2220" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L2221">				dmo.cleanUp();</span>
			}
		}
	}

	public static String getAuditTrailStr(TORequest request) throws Exception {
<span class="nc" id="L2227">		StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L2228">		Collection auditTrails = getAuditTrail(request);</span>
<span class="nc" id="L2229">		TimeZone tz = request.getCache().getOrg().getTimeZone();</span>
<span class="nc" id="L2230">		Localizer localizer = RequestUtil.getLocalizerForAppDefLocale();</span>
<span class="nc bnc" id="L2231" title="All 4 branches missed.">		if (auditTrails != null &amp;&amp; !auditTrails.isEmpty()) {</span>
<span class="nc" id="L2232">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.LAST_MODIFIED)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2233">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.STATUS)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2234">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.COMMENTS)).append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L2235" title="All 2 branches missed.">			for (Iterator it = auditTrails.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2236">				RequestAuditTrail rat = (RequestAuditTrail) it.next();</span>
<span class="nc" id="L2237">				sb.append(localizer.formatDateTime(rat.getModifiedAt(), tz)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2238">				sb.append(getLocalizedMsgInAppDefLocale(NotificationUtil.getBundleKey(rat.getStatus()))).append(&quot;\t&quot;);</span>
<span class="nc" id="L2239">				sb.append(rat.getNote()).append(&quot;\n&quot;);</span>
<span class="nc" id="L2240">			}</span>
		}
<span class="nc bnc" id="L2242" title="All 4 branches missed.">		if (sb.toString() != null &amp;&amp; sb.length() &gt; 1000) {</span>
<span class="nc" id="L2243">			m_cat.info(&quot; The comments exceed allowed Chars so showing the last 1K only: &quot; + sb.toString());</span>
<span class="nc" id="L2244">			return sb.substring(sb.length() - 1000);</span>
		} else {
<span class="nc" id="L2246">			return sb.toString();</span>
		}
	}

	protected static void setCalendarEventAssignFields(CalendarEventAssignment calEvent, TORequest toReq,
			TOChoice toChoice) {
<span class="nc" id="L2252">		calEvent.setActivityID(toReq.getTimeOffType());</span>
<span class="nc" id="L2253">		calEvent.addWorkResourceID(toReq.getEmployeeID());</span>
<span class="nc" id="L2254">		calEvent.setDuration(</span>
<span class="nc" id="L2255">				Math.round(((toChoice.getEndDate().getTime() - toChoice.getStartDate().getTime()) / MINUTE_IN_MILLIS)));</span>
<span class="nc" id="L2256">		calEvent.setStartTime(toChoice.getStartDate());</span>
<span class="nc" id="L2257">	}</span>

	/**
	 * @param employeeID
	 * @param shiftAssn
	 * @param fixShiftAssnSPID
	 *            used to specify the behaviour if the shiftAssignment's SPID
	 *            does not match the employee's SPID during the shift assignment
	 *            timerange. If true and shiftAssn SPID does not match emp's
	 *            SPID, the SPID is set to 'null'. If false, an exception is
	 *            raised.
	 * @param sam
	 * @throws BbmCreateException
	 * @throws BbmScheduleConflictException
	 * @throws RemoteException
	 * @throws BbmEJBCreateException
	 */
	public static void createShiftAssignment(ID empID, ShiftAssignment shiftAssn, boolean fixShiftAssnSPID,
			ScheduleAccessManager sam) throws Exception {
<span class="nc bnc" id="L2276" title="All 2 branches missed.">		if (shiftAssn != null) {</span>
			// associate shiftAssignment with the given employee
<span class="nc" id="L2278">			shiftAssn.addWorkResourceID(empID);</span>

			// quirk of DAO framework: ValueObjectNode maintains four
			// collections of
			// children: read, created, updated and deleted. move the read
			// collection to the created collection.
			// todo: use the fieldInfo associated with ShiftAssignment to copy
			// all child
			// types. Ideal scenario: do a deep copy given a ValueObjectNode.
			// todo: remove hardcoded values below.
			// rewire the child objects for shift assignment (Shift Event
			// Assignments)
<span class="nc bnc" id="L2290" title="All 2 branches missed.">			for (Iterator itr = shiftAssn.getChildObjects(0).iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2291">				ShiftEventAssignment shiftEventAssn = (ShiftEventAssignment) itr.next();</span>
<span class="nc" id="L2292">				shiftEventAssn.addWorkResourceID(empID);</span>
<span class="nc" id="L2293">				shiftAssn.createChildObject(0, shiftEventAssn);</span>
<span class="nc" id="L2294">			}</span>

			// clear the 'read' collection after copying to 'created'
			// collection.
<span class="nc" id="L2298">			shiftAssn.clearChildObjectMap();</span>

			// Need to fix SP of created shift assignment.
			//
<span class="nc" id="L2302">			ID shiftAssnSPID = shiftAssn.getCampaignID();</span>
			// if (shiftAssn.SPID != null &amp;&amp; employeeID is not a member of
			// shiftAssn.SPID)
<span class="nc bnc" id="L2305" title="All 2 branches missed.">			if (shiftAssnSPID != null) {</span>
<span class="nc" id="L2306">				shiftAssn = fixShiftAssnSPIDIfNecess(empID, shiftAssn, fixShiftAssnSPID);</span>
			}

			// create shift assignment
<span class="nc bnc" id="L2310" title="All 2 branches missed.">			if (sam == null) {</span>
<span class="nc" id="L2311">				sam = WfmManagerFactory.getScheduleAccessManager();</span>
			}

			// lock the shift before saving
<span class="nc" id="L2315">			shiftAssn.setLocked(true);</span>
<span class="nc" id="L2316">			sam.createShiftAssignment(shiftAssn);</span>
		}
<span class="nc" id="L2318">	}</span>

	/**
	 * Fixes the SPID associated with the shiftAssn when the shiftAssn needs to
	 * be assigned to the specified empID (during a swap, a shift assignment is
	 * assigned from one employee to another. For this, in addition to switching
	 * the empID associated with the shiftAssignment to the second employee, the
	 * SPID field in the shiftAssn needs to be fixed as well).
	 *
	 * &lt;p&gt;
	 * Rules: During the shift's time range,
	 * &lt;li&gt;If empID is not assoicated with any SP, set ShiftAssn.SPID to 'null'.
	 * &lt;li&gt;if empID is associated with one SP, set shiftAssn.SPID = empSPID.
	 * &lt;li&gt;if empID is associaed with two or more SPs: if empSPIDs collection
	 * contains shiftAssn.SPID, then leave shiftAssn.SPID unchanged. Otherwise
	 * set shiftAssn.SPID to 'null'.
	 *
	 * @param empID
	 * @param shiftAssn
	 * @param fixShiftAssnSPID
	 * @return
	 * @throws Exception
	 */
	private static ShiftAssignment fixShiftAssnSPIDIfNecess(ID empID, ShiftAssignment shiftAssn,
			boolean fixShiftAssnSPID) throws Exception {

<span class="nc" id="L2344">		Date shiftStart = shiftAssn.getStartTime();</span>
<span class="nc" id="L2345">		Date shiftEnd = shiftAssn.getEndTime();</span>
		// Note: getCampignID() may return null.
<span class="nc" id="L2347">		ID shiftAssnSPID = shiftAssn.getCampaignID();</span>

		// empSPIDDuringShiftTimeRange can be 'null'
<span class="nc" id="L2350">		Collection empSPIDsDuringShift = getSPIDsForEmpDuringTimeRange(empID, shiftStart, shiftEnd, null);</span>

<span class="nc" id="L2352">		ID newSPID = null;</span>
<span class="nc bnc" id="L2353" title="All 2 branches missed.">		if (empSPIDsDuringShift.isEmpty()) {</span>
<span class="nc" id="L2354">			newSPID = null;</span>
<span class="nc bnc" id="L2355" title="All 2 branches missed.">		} else if (empSPIDsDuringShift.size() == 1) {</span>
<span class="nc" id="L2356">			newSPID = (ID) empSPIDsDuringShift.iterator().next();</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">		} else if (empSPIDsDuringShift.size() &gt; 1) {</span>
			// Note: shiftAssnSPID can be null.
<span class="nc bnc" id="L2359" title="All 2 branches missed.">			if (empSPIDsDuringShift.contains(shiftAssnSPID)) {</span>
<span class="nc" id="L2360">				newSPID = shiftAssnSPID;</span>
			} else {
<span class="nc" id="L2362">				newSPID = null;</span>
			}
		}

		// newSPID == null &amp;&amp; shiftAssnSPID == null ==&gt; both equal
		// newSPID == null &amp;&amp; shiftAssnSPID != null ==&gt; both not equal
		// newSPID != null &amp;&amp; shiftAssnSPID == null ==&gt; both not equal
		// newSPID != null &amp;&amp; shiftAssnSPID != null ==&gt; equal or not equal.
		// Note: both IDs can be null.
		//
		// if existing shiftAssn.SPID != the newSPID (to be assigned to the
		// shiftAssn).
<span class="nc bnc" id="L2374" title="All 8 branches missed.">		if ((newSPID == null &amp;&amp; shiftAssnSPID != null) || (newSPID != null &amp;&amp; !newSPID.equals(shiftAssnSPID))) {</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">			if (!fixShiftAssnSPID) {</span>
<span class="nc" id="L2376">				CampaignManager campMgr = getCampaignManager();</span>

				// throw exception; (SPID must not be fixed for tentative
				// approvals since it can't be undone).
<span class="nc" id="L2380">				String campName = &quot;&quot;;</span>
<span class="nc bnc" id="L2381" title="All 2 branches missed.">				if (shiftAssnSPID != null) {</span>
<span class="nc" id="L2382">					campName = getCampaignByID(getSPForSPID(shiftAssnSPID, campMgr).getCampaignID(), campMgr).getName();</span>
				}

<span class="nc" id="L2385">				throw RequestUtil.createRmHardValidationException(</span>
						RmEjbBundleKey.REQ_CANNOT_CREATE_SHIFTASSIGNMENT_WITH_EMP_SPID_MISMATCH,
<span class="nc" id="L2387">						ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC), shiftStart,</span>
						shiftEnd, campName, m_cat);
			} else {
<span class="nc bnc" id="L2390" title="All 2 branches missed.">				if (newSPID != null) {</span>
<span class="nc" id="L2391">					shiftAssn.setCampaignID(newSPID);</span>
				} else {
<span class="nc" id="L2393">					shiftAssn.setFieldNull(ShiftAssignmentFields.CAMPAIGNID);</span>
				}
			}
		}

<span class="nc" id="L2398">		return shiftAssn;</span>
	}

	// TESTME undoSwap
	public static ShiftAssignment deleteShiftAssignment(ShiftSwapItem ssItem1, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache) throws Exception {
		// try {
<span class="nc bnc" id="L2405" title="All 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L2406">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}

<span class="nc" id="L2409">		ShiftAssignment shiftAssignUnpub = ShiftSwapRequestUtil.getShiftAssignForSSItemAligned(ssItem1, false, sam,</span>
				ssCache);
<span class="nc bnc" id="L2411" title="All 2 branches missed.">		if (shiftAssignUnpub == null) {</span>
<span class="nc" id="L2412">			throw createAndLogRmHardValidationException(RmEjbBundleKey.SS_SHIFTNOTFOUND_FOR_SSITEM,</span>
<span class="nc" id="L2413">					RmEjbLogBundleKey.SS_SHIFTNOTFOUND_FOR_SSITEM, new Object[] { ssItem1.getStartDate(),</span>
<span class="nc" id="L2414">							ssItem1.getEndDate(), ssItem1.getEmployeeID(), ssItem1.getID() },</span>
					m_cat);
		}

		// delete shift assignment
<span class="nc" id="L2419">		sam.deleteShiftAssignments(Collections.singleton(shiftAssignUnpub.getID()));</span>

<span class="nc" id="L2421">		return shiftAssignUnpub;</span>
		// } c_atch (Exception e) {
		// t_hrow createValidationExceptionWrapper(e, m_cat);
		// }
	}

	public static String makeCacheKey(String keyPrefix, Object obj1) {
<span class="nc bnc" id="L2428" title="All 2 branches missed.">		if (obj1 == null) {</span>
<span class="nc" id="L2429">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L2432">		return keyPrefix + '_' + obj1;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2) {
<span class="nc bnc" id="L2436" title="All 4 branches missed.">		if (obj1 == null || obj2 == null) {</span>
<span class="nc" id="L2437">			throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2);</span>
		}

<span class="nc" id="L2440">		return keyPrefix + '_' + obj1 + '_' + obj2;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2, Object obj3) {
<span class="nc bnc" id="L2444" title="All 6 branches missed.">		if (obj1 == null || obj2 == null || obj3 == null) {</span>
<span class="nc" id="L2445">			throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2 + ',' + obj3);</span>
		}

<span class="nc" id="L2448">		return keyPrefix + '_' + obj1 + '_' + obj2 + '_' + obj3;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2, Object obj3, Object obj4) {
<span class="nc bnc" id="L2452" title="All 8 branches missed.">		if (obj1 == null || obj2 == null || obj3 == null || obj4 == null) {</span>
<span class="nc" id="L2453">			throw new IllegalArgumentException(</span>
					&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2 + ',' + obj3 + ',' + obj4);
		}

<span class="nc" id="L2457">		return keyPrefix + '_' + obj1 + '_' + obj2 + '_' + obj3 + '_' + obj4;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object[] objs) {
<span class="nc" id="L2461">		StringBuffer strBuf = new StringBuffer(keyPrefix);</span>

<span class="nc bnc" id="L2463" title="All 2 branches missed.">		for (int i = 0; i &lt; objs.length; i++) {</span>
<span class="nc bnc" id="L2464" title="All 2 branches missed.">			if (objs[i] == null) {</span>
<span class="nc" id="L2465">				throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + i);</span>
			}

<span class="nc" id="L2468">			strBuf.append('_').append(objs[i]);</span>
		}

<span class="nc" id="L2471">		return strBuf.toString();</span>
	}

	/**
	 * @param orgID
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public static OrganizationSetting getOrgSetting(ID orgID, OrganizationConfigManager orgCfgMgr) throws Exception {

		// Obtain the configuration settings for the employee's organization
<span class="nc" id="L2483">		return CacheUtilRM.getOrgSetting(orgID);</span>
	}

	public static void verifyAuditTrailOrdering(RequestAggregate reqAgg) throws Exception {
		// verify audit trail ordering
<span class="nc" id="L2488">		Date lastAuditTime = new Date(0);</span>
<span class="nc" id="L2489">		Collection auditTrails = reqAgg.getAuditTrail();</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">		for (Iterator itr = auditTrails.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2491">			RequestAuditTrail trail = (RequestAuditTrail) itr.next();</span>

<span class="nc bnc" id="L2493" title="All 2 branches missed.">			if (lastAuditTime.after(trail.getModifiedAt())) {</span>
<span class="nc" id="L2494">				throw createRmException(RmEjbLogBundleKey.AUDIT_TRAIL_INVALIDORDER, reqAgg.getID(), m_cat);</span>
			}

<span class="nc" id="L2497">			lastAuditTime = trail.getModifiedAt();</span>
<span class="nc" id="L2498">		}</span>
<span class="nc" id="L2499">	}</span>

	public static synchronized RmManagerFactory getRmManagerFactory() {
<span class="nc bnc" id="L2502" title="All 2 branches missed.">		if (m_rmMgrFactory == null) {</span>
<span class="nc" id="L2503">			m_rmMgrFactory = RmManagerFactory.getInstance(true);</span>
		}

<span class="nc" id="L2506">		return m_rmMgrFactory;</span>
	}

	// TODO: add caching.
	public static TORequestManager getTORequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2511" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2512">			return getRmManagerFactory().getTimeOffRequestManager(userName, password);</span>
		}
<span class="nc" id="L2514">		return getRmManagerFactory().getTimeOffRequestManager(userName, password);</span>
	}

	public static FlexTimeRequestManager getFlexTimeRequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2518" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2519">			return getRmManagerFactory().getFlexTimeRequestManager(userName, password);</span>
		}
<span class="nc" id="L2521">		return getRmManagerFactory().getFlexTimeRequestManager(userName, password);</span>
	}

	public static TOWaitlistManager getTOWaitlistManager() throws Exception {
<span class="nc" id="L2525">		return getRmManagerFactory().getTOWaitlistManager();</span>
	}

	public static TOHoursPerDayManager getTOHoursPerDayManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2529" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2530">			return getRmManagerFactory().getTOHoursPerDayManager();</span>
		}
<span class="nc" id="L2532">		return getRmManagerFactory().getTOHoursPerDayManager(userName, password);</span>
	}

	public static TOWithdrawManager getTOWithdrawManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2536" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2537">			return getRmManagerFactory().getTOWithdrawManager();</span>
		}
<span class="nc" id="L2539">		return getRmManagerFactory().getTOWithdrawManager(userName, password);</span>
	}

	// TODO: add caching.
	public static ShiftSwapRequestManager getSSRequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2544" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2545">			return getRmManagerFactory().getShiftSwapRequestManager();</span>
		}
<span class="nc" id="L2547">		return getRmManagerFactory().getShiftSwapRequestManager(userName, password);</span>
	}

	public static ShiftBidRequestManager getShiftBidRequestManager(String userName, String password)
			throws BbmCreateException {
<span class="nc bnc" id="L2552" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2553">			return getRmManagerFactory().getShiftBidRequestManager();</span>
		}
<span class="nc" id="L2555">		return getRmManagerFactory().getShiftBidRequestManager(userName, password);</span>
	}

	// TODO: add caching.
	public static ShiftBidAuctionManager getShiftBidAuctionMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2560" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2561">			return getRmManagerFactory().getShiftBidAuctionManager();</span>
		}
<span class="nc" id="L2563">		return getRmManagerFactory().getShiftBidAuctionManager(userName, password);</span>
	}

	// TODO: add caching.
	public static OrganizationConfigManager getOrgConfigMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2568" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2569">			return getRmManagerFactory().getOrganizationConfigManager();</span>
		}
<span class="nc" id="L2571">		return getRmManagerFactory().getOrganizationConfigManager(userName, password);</span>
	}

	public static ScheduleAccessManager getScheduleAccessManager() throws Exception {
<span class="nc" id="L2575">		return WfmManagerFactory.getScheduleAccessManager();</span>
	}

	/**
	 *
	 */
	public static WorkResourceManager getWorkResourceManager() throws Exception {
<span class="nc" id="L2582">		return BbmManagerFactory.getWorkResourceManager();</span>
	}

	/**
	 * @return
	 */
	public static UserManager getUserManager() throws Exception {
		// TODO Auto-generated method stub
<span class="nc" id="L2590">		return CoreManagerFactory.getUserManager(false);</span>
	}

	public static ActivityManager getActivityManager() throws BbmEJBCreateException {
<span class="nc" id="L2594">		return WfmManagerFactory.getActivityManager();</span>
	}

	/**
	 * @param userName
	 * @param password
	 * @return
	 */
	public static CommonRequestManager getCommonRequestManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2603" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2604">			return getRmManagerFactory().getCommonRequestManager();</span>
		}
<span class="nc" id="L2606">		return getRmManagerFactory().getCommonRequestManager(userName, password);</span>
	}

	/**
	 *
	 */
	public static ShiftSwapPostingManager getShiftSwapPostingMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2613" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2614">			return getRmManagerFactory().getShiftSwapPostingManager();</span>
		}
<span class="nc" id="L2616">		return getRmManagerFactory().getShiftSwapPostingManager(userName, password);</span>
	}

	public static CampaignManager getCampaignManager() throws BbmEJBCreateException {
<span class="nc" id="L2620">		return WfmManagerFactory.getCampaignManager();</span>
	}

	public static Collection getMapValues(Map map) {
		// get entry set
<span class="nc" id="L2625">		Set entrySet = map.entrySet();</span>

		// if entry set empty, then return empty collection.
<span class="nc bnc" id="L2628" title="All 2 branches missed.">		if (entrySet.isEmpty()) {</span>
<span class="nc" id="L2629">			return Collections.emptyList();</span>
		}

		// Now, add the values of the each map entry to the collection.
<span class="nc" id="L2633">		ArrayList arrList = new ArrayList();</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">		for (Iterator itr = entrySet.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2635">			Map.Entry mapEntry = (Map.Entry) itr.next();</span>
<span class="nc" id="L2636">			arrList.add(mapEntry.getValue());</span>
<span class="nc" id="L2637">		}</span>

		// return collection.
<span class="nc" id="L2640">		return arrList;</span>
	}

	/**
	 * @param collection
	 */
	public static Set getSetFromCollection(Collection collection) {
<span class="nc bnc" id="L2647" title="All 4 branches missed.">		if (collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L2648">			return new HashSet(); // caller modifies the returned set; return</span>
									// Collections.EMPTY_SET
		}

		// if (collection.size() == 1) {
		// caller modifies the returned set; Collections.singleton() is
		// immutable.
		// return Collections.singleton(collection.iterator().next());
		// }

<span class="nc" id="L2658">		HashSet set = new HashSet(collection.size());</span>
<span class="nc" id="L2659">		set.addAll(collection);</span>

<span class="nc" id="L2661">		return set;</span>
	}

	/**
	 * @param collection
	 * @return
	 */
	public static List getListFromCollection(Collection collection) {
<span class="nc bnc" id="L2669" title="All 4 branches missed.">		if (collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L2670">			return Collections.emptyList();</span>
		}

<span class="nc bnc" id="L2673" title="All 2 branches missed.">		if (collection.size() == 1) {</span>
<span class="nc" id="L2674">			return Collections.singletonList(collection.iterator().next());</span>
		}

<span class="nc" id="L2677">		ArrayList list = new ArrayList(collection.size());</span>
<span class="nc" id="L2678">		list.addAll(collection);</span>

<span class="nc" id="L2680">		return list;</span>
	}

	/**
	 * Returns a list with the IDs extracted from the given collection of
	 * objects subclassed from {@link ValueObjectBase ValueObjectBase} objects
	 * (all value objects constructed for data read from the database)
	 *
	 * @param valObjBases
	 * @return
	 */
	public static List getListOfIDsFromVOBases(Collection valObjBases) {
<span class="nc bnc" id="L2692" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2693">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2696">		List idList = new ArrayList(valObjBases.size());</span>
<span class="nc bnc" id="L2697" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2698">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2699">			idList.add(valObjBase.getID());</span>
<span class="nc" id="L2700">		}</span>

<span class="nc" id="L2702">		return idList;</span>
	}

	public static List getListOfFieldValuesFromVOBases(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2706" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2707">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2710">		List fieldValues = new ArrayList(valObjBases.size());</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2712">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2713">			fieldValues.add(valObjBase.getFieldValue(fieldIndex));</span>
<span class="nc" id="L2714">		}</span>

<span class="nc" id="L2716">		return fieldValues;</span>
	}

	public static Set getSetOfFieldValuesFromVOBases(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2720" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2721">			return Collections.emptySet();</span>
		}

<span class="nc" id="L2724">		Set fieldValues = new HashSet(valObjBases.size() * 2);</span>
<span class="nc bnc" id="L2725" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2726">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2727">			fieldValues.add(valObjBase.getFieldValue(fieldIndex));</span>
<span class="nc" id="L2728">		}</span>

<span class="nc" id="L2730">		return fieldValues;</span>
	}

	/**
	 * orders the given voBasesList using the passed idList and return the
	 * ordered list of voBases.
	 *
	 * &lt;p&gt;
	 * &lt;li&gt;for an ID in 'idList' not found in 'voBasesList', no voBase is added
	 * to the returned list.
	 * &lt;li&gt;for an ID in 'idList' found in 'voBaseList', the voBase is added to
	 * the returned list.
	 * &lt;li&gt;for a voBase in 'voBaseList' not found in 'idList', the voBase is not
	 * added to the returned list.
	 *
	 * @param reqIDs
	 * @param sbReqsAsList
	 * @return
	 */
	public static List getListOfVOBasesOrderedByIDList(List idList, List voBasesList) {
<span class="nc" id="L2750">		Map idToVOBaseMap = getMapOfIDsForVOBases(voBasesList);</span>

		// reuse 'sbReqsAsList' if 'reqIDs' list and 'sbReqsAsList' are same
		// size. Otherwise
		// allocate a new List.
<span class="nc" id="L2755">		int voBasesListSize = voBasesList.size();</span>
<span class="nc" id="L2756">		int idListSize = idList.size();</span>
<span class="nc bnc" id="L2757" title="All 2 branches missed.">		voBasesList = (idListSize == voBasesListSize) ? voBasesList : new ArrayList(voBasesListSize);</span>

<span class="nc bnc" id="L2759" title="All 2 branches missed.">		for (int i = 0; i &lt; idListSize; i++) {</span>
<span class="nc" id="L2760">			Object voBaseForID = idToVOBaseMap.get(idList.get(i));</span>

<span class="nc bnc" id="L2762" title="All 2 branches missed.">			if (voBaseForID != null) {</span>
<span class="nc" id="L2763">				voBasesList.set(i, voBaseForID);</span>
			}
		}

<span class="nc" id="L2767">		return voBasesList;</span>
	}

	/**
	 * Reverses the given list in-place.
	 *
	 * @param sbReqsList
	 */
	public static void getListReversed(List sbReqsList) {
<span class="nc" id="L2776">		int sbReqsListSize = sbReqsList.size();</span>

		// if passed list is empty or size == 1.
<span class="nc bnc" id="L2779" title="All 4 branches missed.">		if (sbReqsList.isEmpty() || (sbReqsListSize == 1)) {</span>
<span class="nc" id="L2780">			return;</span>
		}

<span class="nc" id="L2783">		int rev = sbReqsListSize - 1; // index moving in reverse direction.</span>
		// reverses even and odd sized lists correctly.
<span class="nc bnc" id="L2785" title="All 2 branches missed.">		for (int fwd = 0; fwd &lt; rev; fwd++, rev--) { // fwd == index moving in</span>
														// forward direction.
			// swap elements pointed by 'fwd' and 'rev'.
<span class="nc" id="L2788">			Object tmp = sbReqsList.get(fwd);</span>
<span class="nc" id="L2789">			sbReqsList.set(fwd, sbReqsList.get(rev));</span>
<span class="nc" id="L2790">			sbReqsList.set(rev, tmp);</span>
		}
<span class="nc" id="L2792">	}</span>

	/**
	 * Searches for the value object with the specified ID in the given list of
	 * valueObjects.
	 *
	 * @param sbReq
	 * @param sbReqsSortedForBidSched
	 * @return -1, if not found. the index, if found.
	 */
	public static int findInVOBaseListByID(List voBasesList, ID givenVOBaseID) {
		// TODO: improve later. presently just a linear scan.
<span class="nc bnc" id="L2804" title="All 4 branches missed.">		for (int idx = 0; voBasesList != null &amp;&amp; idx &lt; voBasesList.size(); idx++) {</span>
<span class="nc" id="L2805">			ValueObjectBase voBase = (ValueObjectBase) voBasesList.get(idx);</span>

<span class="nc bnc" id="L2807" title="All 2 branches missed.">			if (voBase.getID().equals(givenVOBaseID)) {</span>
<span class="nc" id="L2808">				return idx;</span>
			}
		}

<span class="nc" id="L2812">		return -1;</span>
	}

	/**
	 * Searches for the value object with the specified field value, at the
	 * given field index, in the given list of valueObjects.
	 *
	 * @param sbReq
	 * @param sbReqsSortedForBidSched
	 * @return -1 if not found. if found, the index at which the value object
	 *         was found.
	 */
	public static int findInVOBaseListByFieldValue(List voBasesList, int fieldIndex, Object fieldValue) {
		// TODO: improve later. presently just a linear scan.
<span class="nc bnc" id="L2826" title="All 4 branches missed.">		for (int idx = 0; voBasesList != null &amp;&amp; idx &lt; voBasesList.size(); idx++) {</span>
<span class="nc" id="L2827">			ValueObjectBase voBase = (ValueObjectBase) voBasesList.get(idx);</span>

<span class="nc bnc" id="L2829" title="All 2 branches missed.">			if (voBase.getFieldValue(fieldIndex).equals(fieldValue)) {</span>
<span class="nc" id="L2830">				return idx;</span>
			}
		}

<span class="nc" id="L2834">		return -1;</span>
	}

	/**
	 * Builds and returns a map of valObjBase.ID to valueObjectBase
	 *
	 * @param valObjBases
	 * @return
	 */
	public static Map getMapOfIDsForVOBases(Collection valObjBases) {
<span class="nc" id="L2844">		return addToMapOfIDsForVOBases(null, valObjBases);</span>
	}

	/**
	 * Builds and returns a map of valObjBase.ID to valueObjectBase
	 *
	 * @param valObjBases
	 * @return
	 */
	public static Map addToMapOfIDsForVOBases(Map IDToVOMap, Collection valObjBases) {
<span class="nc bnc" id="L2854" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc bnc" id="L2855" title="All 2 branches missed.">			return (IDToVOMap == null) ? Collections.emptyMap() : IDToVOMap;</span>
		}

<span class="nc bnc" id="L2858" title="All 2 branches missed.">		IDToVOMap = (IDToVOMap == null) ? new HashMap(valObjBases.size() * 2) : IDToVOMap;</span>
<span class="nc bnc" id="L2859" title="All 2 branches missed.">		for (Iterator VOIter = valObjBases.iterator(); VOIter.hasNext();) {</span>
<span class="nc" id="L2860">			ValueObjectBase vo = (ValueObjectBase) VOIter.next();</span>
<span class="nc" id="L2861">			IDToVOMap.put(vo.getID(), vo);</span>
<span class="nc" id="L2862">		}</span>

<span class="nc" id="L2864">		return IDToVOMap;</span>
	}

	/**
	 * Builds and returns a map of valObjectBase.&lt;specified field&gt; to
	 * valueObjectBase.
	 *
	 * @param valObjBases
	 * @param fieldIndex
	 * @return
	 */
	public static Map getMapOfFieldToVOBase(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2876" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2877">			return Collections.emptyMap();</span>
		}

<span class="nc" id="L2880">		Map fieldToVOMap = new HashMap(valObjBases.size() * 2);</span>
<span class="nc bnc" id="L2881" title="All 2 branches missed.">		for (Iterator VOIter = valObjBases.iterator(); VOIter.hasNext();) {</span>
<span class="nc" id="L2882">			ValueObjectBase vo = (ValueObjectBase) VOIter.next();</span>
<span class="nc" id="L2883">			fieldToVOMap.put(vo.getFieldValue(fieldIndex), vo);</span>
<span class="nc" id="L2884">		}</span>

<span class="nc" id="L2886">		return fieldToVOMap;</span>
	}

	/**
	 * Invokes {@link ValueObjectNode#moveChildrenFromCreatedToPersisted()
	 * moveChildrenFromCreatedToPersisted()} for each element in the collection.
	 *
	 * @param voNodes
	 */
	public static void moveChildrenFromCreatedToPersisted(Collection voNodes) {
<span class="nc bnc" id="L2896" title="All 2 branches missed.">		for (Iterator iter = voNodes.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2897">			ValueObjectNode voNode = (ValueObjectNode) iter.next();</span>
<span class="nc" id="L2898">			voNode.moveChildrenFromCreatedToPersisted();</span>
<span class="nc" id="L2899">		}</span>
<span class="nc" id="L2900">	}</span>

	/**
	 * Checks if any of the given events is contained within the onBits of the
	 * given timeMap. if so, returns the first such event.
	 *
	 * @param unpubCalEventsTimeMap
	 * @param shiftAssns
	 * @return The contained event, if found. Null otherwise
	 */
	public static Event verifyOnBitsContainEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2911" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2912">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2913" title="All 2 branches missed.">			if (timeMap.onBitsContainRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2914">				return event;</span>
			}
<span class="nc" id="L2916">		}</span>

<span class="nc" id="L2918">		return null;</span>
	}

	/**
	 * Checks if any of the given events overlaps the offBits of the given
	 * timeMap. if so, returns the first such event.
	 *
	 * @param unpubCalEventsTimeMap
	 * @param shiftAssns
	 * @return The contained event, if found. Null otherwise
	 */
	public static Event verifyOffBitsOverlapEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2930" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2931">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2932" title="All 2 branches missed.">			if (!timeMap.onBitsContainRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2933">				return event;</span>
			}
<span class="nc" id="L2935">		}</span>

<span class="nc" id="L2937">		return null;</span>
	}

	/**
	 * Checks if any of the given events overlaps the onBits of the given
	 * timeMap. if so, returns the first such event.
	 *
	 * @param schedShiftAssnsTimeMap
	 * @param sbrShiftAssns
	 * @return The overlapping event, if found. Null otherwise
	 */
	public static Event verifyOnBitsOverlapEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2949" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2950">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2951" title="All 2 branches missed.">			if (timeMap.onBitsOverlapRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2952">				return event;</span>
			}
<span class="nc" id="L2954">		}</span>

<span class="nc" id="L2956">		return null;</span>
	}

	/**
	 * @param shiftAssns
	 * @param toEmpID
	 * @param publish
	 * @param publishDateRange
	 *            if 'null' then each shift assignment is published
	 *            individually. If 'non-null' the specified interval is
	 *            published.
	 * @param deleteUnderlyingUnavails
	 * @param sam
	 * @return
	 * @throws Exception
	 */
	public static Collection moveShiftAssnsToEmp(Collection shiftAssns, ID toEmpID, boolean publish,
			TimeRange publishDateRange, boolean deleteUnderlyingUnavails, ScheduleAccessManager sam, boolean isMultiShiftBlocks) throws Exception {

<span class="nc" id="L2975">		List srcShiftAssnIDs = RequestUtil.getListOfIDsFromVOBases(shiftAssns);</span>

		// modify shift assignments's employeeID from phantom to actual employee
<span class="nc" id="L2978">		RequestUtil.replaceEmployeeIDForShiftAssignments(shiftAssns, toEmpID);</span>

		// delete shift assignments for phantom
<span class="nc bnc" id="L2981" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>
<span class="nc" id="L2982">		sam.deleteShiftAssignments(srcShiftAssnIDs);</span>
<span class="nc bnc" id="L2983" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2984">			m_cat.debug(&quot;Deleting shift assignments: IDs &quot; + RmUtil.dumpCollection(srcShiftAssnIDs));</span>
		}

		// delete underlying unavailabilities before creating the shift
		// assignments if parameter
		// deleteUnderlyingUnavails == true.
<span class="nc bnc" id="L2990" title="All 2 branches missed.">		if (deleteUnderlyingUnavails) {</span>
<span class="nc bnc" id="L2991" title="All 2 branches missed.">			for (Object shiftAssnsObj : shiftAssns) {</span>
<span class="nc" id="L2992">				ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsObj;</span>

				// delete underlying unavailabilies
<span class="nc" id="L2995">				ShiftSwapRequestUtil.deleteUnderlyingUnavailabilities(toEmpID, shiftAssn.getStartTime(),</span>
<span class="nc" id="L2996">						shiftAssn.getEndTime(), sam);</span>
<span class="nc" id="L2997">			}</span>
		}

<span class="nc" id="L3000">		Collection&lt;ID&gt; shiftAssnIDsToPublish = new ArrayList&lt;ID&gt;();</span>
		/**
		 * when a shift bidding is a multiple shift block bidding,
		 * the first shift block is going to update to include the next shift block
		 */
<span class="nc bnc" id="L3005" title="All 2 branches missed.">		if(isMultiShiftBlocks) {</span>
<span class="nc" id="L3006">			Collection&lt;BbmScheduleConflict&gt; listConflicts = sam.getConflictsForNewScheduleObjects(shiftAssns);</span>
<span class="nc bnc" id="L3007" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L3008">				Collection&lt;ShiftAssignment&gt; s = solveConflicts(listConflicts, publishDateRange, srcShiftAssnIDs);</span>
<span class="nc bnc" id="L3009" title="All 2 branches missed.">				for (ShiftAssignment shiftAssn : s) {</span>
<span class="nc" id="L3010">					sam.updateShiftAssignment(shiftAssn);</span>
<span class="nc" id="L3011">					shiftAssnIDsToPublish.add(shiftAssn.getID());</span>
<span class="nc" id="L3012">					m_cat.debug(&quot;Shift block merged into shift assignment ID: &quot; + shiftAssn.getID());</span>
<span class="nc" id="L3013">				}</span>
			}
		}

<span class="nc bnc" id="L3017" title="All 2 branches missed.">		if(shiftAssnIDsToPublish.isEmpty()) {</span>
			// create the shift assignments for the actual employee and publish if
			// necessary
<span class="nc" id="L3020">			Collection&lt;ID&gt; createdShiftAssnIDs = sam.createShiftAssignments(shiftAssns);</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3022">				m_cat.debug(&quot;created shift assignments: IDs &quot; + RmUtil.dumpCollection(createdShiftAssnIDs));</span>
			}
<span class="nc" id="L3024">			shiftAssnIDsToPublish.addAll(createdShiftAssnIDs);</span>
		}

<span class="nc" id="L3027">		int nMaxRetries = 3;</span>
<span class="nc" id="L3028">		int nRetry = 0;</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">		boolean publishByDateRange = publishDateRange != null;</span>
<span class="nc" id="L3030">		List createdShiftAssns = new ArrayList(shiftAssns.size());</span>
<span class="nc bnc" id="L3031" title="All 2 branches missed.">		for (ID createdShiftAssnID: shiftAssnIDsToPublish) {</span>

<span class="nc" id="L3033">			ShiftAssignment createdShiftAssn = sam.getShiftAssignmentByID(createdShiftAssnID);</span>
<span class="nc" id="L3034">			createdShiftAssns.add(createdShiftAssn);</span>

			// publish if necessary, shift by shift.
			// QC46055 some approved shiftbidrequests do not get published
<span class="nc bnc" id="L3038" title="All 4 branches missed.">			if (publish &amp;&amp; !publishByDateRange) {</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">				for (; nRetry &lt; nMaxRetries; nRetry++) {</span>
					try {
<span class="nc" id="L3041">						Date startTime = createdShiftAssn.getStartTime();</span>
<span class="nc" id="L3042">						Date endTime = createdShiftAssn.getEndTime();</span>
<span class="nc" id="L3043">						m_cat.debug(</span>
								&quot;publishing: empID, startTime, endTime: &quot; + toEmpID + ',' + startTime + ',' + endTime);
<span class="nc" id="L3045">						sam.publishSchedule(Collections.singleton(toEmpID), startTime, endTime);</span>
<span class="nc" id="L3046">						break;</span>
<span class="nc" id="L3047">					} catch (Exception e) {</span>
<span class="nc" id="L3048">						m_cat.debug(&quot;Publish shift bid schedule failed&quot;, e);</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">						if (nRetry &lt; nMaxRetries) {</span>
<span class="nc" id="L3050">							continue;</span>
						}
<span class="nc" id="L3052">						m_cat.info(&quot;Publish shift bid schedule failed after retrying &quot; + nRetry + &quot; times&quot;);</span>
<span class="nc" id="L3053">						throw e;</span>
					}
				}
			}
<span class="nc" id="L3057">		}</span>

		// QC46055 some approved shiftbidrequests do not get published
<span class="nc bnc" id="L3060" title="All 4 branches missed.">		if (publish &amp;&amp; publishByDateRange) {</span>
<span class="nc bnc" id="L3061" title="All 2 branches missed.">			for (; nRetry &lt; nMaxRetries; nRetry++) {</span>
				try {
<span class="nc" id="L3063">					Date startTime = publishDateRange.getStartDate();</span>
<span class="nc" id="L3064">					Date endTime = publishDateRange.getEndDate();</span>
<span class="nc" id="L3065">					m_cat.debug(&quot;publishing: empID, startTime, endTime: &quot; + toEmpID + ',' + startTime + ',' + endTime);</span>
<span class="nc" id="L3066">					sam.publishSchedule(Collections.singleton(toEmpID), startTime, endTime);</span>
<span class="nc" id="L3067">					break;</span>
<span class="nc" id="L3068">				} catch (Exception e) {</span>
<span class="nc" id="L3069">					m_cat.debug(&quot;Publish shift bid schedule failed&quot;, e);</span>
<span class="nc bnc" id="L3070" title="All 2 branches missed.">					if (nRetry &lt; nMaxRetries) {</span>
<span class="nc" id="L3071">						continue;</span>
					}
<span class="nc" id="L3073">					m_cat.info(&quot;Publish shift bid schedule failed after retrying &quot; + nRetry + &quot; times&quot;);</span>
<span class="nc" id="L3074">					throw e;</span>
				}
			}
		}

<span class="nc" id="L3079">		return createdShiftAssns;</span>
	}

	/**
	 * Solve conflict by stitching with gap activities
	 * @param conflicts - Collection of BbmScheduleConflict
	 * @param publishDateRange - Date range of SP conflicts exist in
	 * @param phantomIDs - Phantom IDs of shifts
	 * @return stitched shifts or empty list in case stitching not valid
	 * @throws Exception
	 */
	public static Collection&lt;ShiftAssignment&gt; solveConflicts(Collection&lt;BbmScheduleConflict&gt; conflicts,
			TimeRange publishDateRange, Collection&lt;ID&gt; phantomIDs) throws Exception{
<span class="nc" id="L3092">		Collection&lt;ShiftAssignment&gt; shifts = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc" id="L3093">		BbmScheduleConflict conflict=null;</span>

<span class="nc bnc" id="L3095" title="All 2 branches missed.">		for (BbmScheduleConflict c : conflicts) {</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">			if (c.getConflictType()!=BbmScheduleConflict.CONFLICT_OVERLAP_SHIFT &amp;&amp;</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">					c.getConflictType()!=BbmScheduleConflict.CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY){</span>
				//Unknown conflict type.
<span class="nc" id="L3099">				conflict=null;</span>
<span class="nc" id="L3100">				break;</span>
			}
<span class="nc" id="L3102">			conflict=c;</span>
<span class="nc" id="L3103">		}</span>

<span class="nc bnc" id="L3105" title="All 2 branches missed.">		if (conflict!=null){</span>
			//Check if conflict is on gaps
<span class="nc" id="L3107">			ShiftAssignment first = (ShiftAssignment) conflict.getFirstObject();</span>
<span class="nc" id="L3108">			ShiftAssignment second = (ShiftAssignment) conflict.getSecondObject();</span>

<span class="nc" id="L3110">			Set&lt;ID&gt; phantomIdSet = new HashSet&lt;ID&gt;(phantomIDs);</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">			if (phantomIdSet.contains(first.getID())){</span>
<span class="nc" id="L3112">				ShiftAssignment swap = first;</span>
<span class="nc" id="L3113">				first = second;</span>
<span class="nc" id="L3114">				second = swap;</span>
			}

<span class="nc" id="L3117">			TimeMap firstTimeMap = buildTimeMap(Collections.singleton(first), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc" id="L3118">			TimeMap secondTimeMap = buildTimeMap(Collections.singleton(second), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">			if(!firstTimeMap.intersects(secondTimeMap)){</span>
				//No overlap excluding gaps. Start stitching.
<span class="nc" id="L3121">				shifts.add(stitchAssignments(firstTimeMap, secondTimeMap, first, second));</span>
			}
		}

<span class="nc" id="L3125">		return shifts;</span>
	}

	/**
	 * stitchAssignments - Take first and second shifts and stitch them together to return a single event in the shifts
	 * TimeMap is a Bit array. For example an array could look like this:
	 *   000000011111111111100000111111000000
	 *   To find the start and end of the shift, we search the first &quot;On&quot; and the last &quot;On&quot;
	 *   Then we create gaps for the &quot;Off&quot;'s which are in between.
	 * @param firstTimeMap - first TimeMap
	 * @param secondTimeMap - second TimeMap
	 * @param first - first shift
	 * @param shifts - second shift
	 * @return Stitched shift
	 */
	public static ShiftAssignment stitchAssignments(TimeMap firstTimeMap, TimeMap secondTimeMap,
			ShiftAssignment first, ShiftAssignment second)
		throws Exception{

		//First time map is now a merge of the two Shift Assignments
<span class="nc" id="L3145">		firstTimeMap.or(secondTimeMap);</span>

		//Add non gap shift event assignments from second
<span class="nc bnc" id="L3148" title="All 2 branches missed.">		for(ShiftEventAssignment g:second.getChildren()){</span>
<span class="nc bnc" id="L3149" title="All 2 branches missed.">			if(g.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)!=0){</span>
<span class="nc" id="L3150">				first.addShiftEventAssignment(g);</span>
			}
<span class="nc" id="L3152">		}</span>

		//Set start and end based on TimeMap
<span class="nc" id="L3155">		Date cur = firstTimeMap.findFirstOn();</span>
<span class="nc" id="L3156">		first.setStartTime(cur);</span>
<span class="nc" id="L3157">		cur=firstTimeMap.findLastOn();</span>
		//Add 1 minute to include the last &quot;On&quot; bit in the time map.
<span class="nc" id="L3159">		long duration = ((cur.getTime() + TimeMap.ONE_MINUTE) - first.getStartTime().getTime()) / 60000; // minutes</span>
<span class="nc" id="L3160">		first.setDuration((int)duration);</span>

		//Delete gaps from first
<span class="nc bnc" id="L3163" title="All 2 branches missed.">		for(ShiftEventAssignment g:first.getChildren()){</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">			if(g.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)==0){</span>
<span class="nc" id="L3165">				first.removeShiftEventAssignment(g.getID());</span>
			}
<span class="nc" id="L3167">		}</span>

		//Fill gaps in between shifts
<span class="nc" id="L3170">		Date endDate = first.getEndTime();</span>
<span class="nc" id="L3171">		cur=first.getStartTime();</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">		while(cur.before(endDate)){</span>
			//cur is the first gap date
<span class="nc" id="L3174">			cur = firstTimeMap.findNextOff(cur);</span>
<span class="nc bnc" id="L3175" title="All 4 branches missed.">			if (cur.equals(endDate) || cur.after(endDate)){</span>
<span class="nc" id="L3176">				break;</span>
			}
			//endGap is the end time of the gap
<span class="nc" id="L3179">			Date endGap = firstTimeMap.findNextOn(cur);</span>
<span class="nc" id="L3180">			duration = (endGap.getTime() - cur.getTime()) / 60000; // minutes</span>
			//Create the gap and add it to the shift
<span class="nc" id="L3182">			ShiftEventAssignment gapSEA = createSEAFromParams(cur, Activity.ACTIVITY_SHIFT_OVERTIME_GAP,</span>
<span class="nc" id="L3183">					(int) duration, first.getWorkResourceID());</span>
<span class="nc" id="L3184">			first.addShiftEventAssignment(gapSEA);</span>
<span class="nc" id="L3185">			cur = endGap;</span>
<span class="nc" id="L3186">		}</span>
<span class="nc" id="L3187">		return first;</span>
	}

	/**
	 * Create a Shift Event Assignment activity
	 * @param start - Start time
	 * @param activityID
	 * @param duration
	 * @param workResourceID
	 * @return
	 */
	public static ShiftEventAssignment createSEAFromParams(Date start, ID activityID, int duration,
			ID workResourceID) {
<span class="nc" id="L3200">		ShiftEventAssignment sea = new ShiftEventAssignment();</span>
<span class="nc" id="L3201">		sea.setActivityID(activityID);</span>
<span class="nc" id="L3202">		sea.setStartTime(start);</span>
<span class="nc" id="L3203">		sea.setDuration(duration);</span>
<span class="nc" id="L3204">		sea.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L3205">		return sea;</span>
	}

	public static void replaceEmployeeIDForShiftAssignments(Collection&lt;ShiftAssignment&gt; shiftAssignments, ID empID) {
<span class="nc bnc" id="L3209" title="All 2 branches missed.">		for (ShiftAssignment shift : shiftAssignments) {</span>
<span class="nc" id="L3210">			shift.addWorkResourceID(empID);</span>

			// get shift event assignments for this shift assignment
<span class="nc" id="L3213">			Collection&lt;ShiftEventAssignment&gt; shiftEventAssns = shift.getChildren();</span>
			// remove the shift event assignment children for this shift
			// assignment.
<span class="nc" id="L3216">			shift.clearChildObjectMap(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc bnc" id="L3217" title="All 2 branches missed.">			for (ShiftEventAssignment shiftEvent : shiftEventAssns) {</span>
<span class="nc" id="L3218">				shiftEvent.addWorkResourceID(empID);</span>
				// add shift event to shift as a child to be created.
<span class="nc" id="L3220">				shift.addShiftEventAssignment(shiftEvent);</span>
<span class="nc" id="L3221">			}</span>
<span class="nc" id="L3222">		}</span>
<span class="nc" id="L3223">	}</span>

	public static Map&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; moveShiftAssnsToPhantom(
			Map&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt; assignedShiftAssignments, ShiftBidRequest request, ScheduleAccessManager sam, BiddableShiftDAO bShiftDAO) throws Exception {

<span class="nc" id="L3228">		Map&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; targetShiftAssignments = new HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt;();</span>

		// build mapping from source assignments to BiddableScheduleInstances
<span class="nc" id="L3231">		Map&lt;ShiftAssignment, Collection&lt;BiddableScheduleInstance&gt;&gt; source2ScheduleInstances = buildAssignment2ScheduleInstancesMapping(assignedShiftAssignments);</span>


<span class="nc" id="L3234">		Collection&lt;ID&gt; instanceIDs = new HashSet&lt;ID&gt;();</span>

<span class="nc bnc" id="L3236" title="All 2 branches missed.">		for (ShiftAssignment source : source2ScheduleInstances.keySet()) {</span>

<span class="nc" id="L3238">			Collection&lt;BiddableScheduleInstance&gt; instances = source2ScheduleInstances.get(source);</span>

			// get the original ID to avoid side effect when calling createShiftAssignmentForPhantomOnWithdrawal
<span class="nc" id="L3241">			ID sourceID = source.getID();</span>

<span class="nc bnc" id="L3243" title="All 2 branches missed.">			for (BiddableScheduleInstance bsi : instances) {</span>

<span class="nc" id="L3245">				instanceIDs.add(bsi.getID());</span>

				// Create the shift assignments for the phantom
				// BE CAREFUL: source object attributes will be modified as side effect of this call
<span class="nc" id="L3249">				ID createdShiftAssnID = createShiftAssignmentForPhantomOnWithdrawal(source, bsi, request, sam);</span>

				// get newly created shift assignments to return
<span class="nc bnc" id="L3252" title="All 2 branches missed.">				if (!targetShiftAssignments.containsKey(bsi.getID())) {</span>
<span class="nc" id="L3253">					targetShiftAssignments.put(bsi.getID(), new ArrayList&lt;ShiftAssignment&gt;());</span>
				}
<span class="nc" id="L3255">				targetShiftAssignments.get(bsi.getID()).add(sam.getShiftAssignmentByID(createdShiftAssnID));</span>

<span class="nc" id="L3257">			}</span>

			// remove blocks from employee shift
<span class="nc" id="L3260">			removePhantomBlocksFromAssignmentOnWithdrawal(sourceID, instances, request, sam);</span>

<span class="nc" id="L3262">		}</span>

		// delete BiddableShift objects for the requests
<span class="nc" id="L3265">		bShiftDAO.deleteObjectsWithParentIDs(instanceIDs);</span>

<span class="nc" id="L3267">		return targetShiftAssignments;</span>
	}

	private static Map&lt;ShiftAssignment, Collection&lt;BiddableScheduleInstance&gt;&gt; buildAssignment2ScheduleInstancesMapping(
			Map&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt; assignedShiftAssignments) {
<span class="nc" id="L3272">		Map&lt;ShiftAssignment, Collection&lt;BiddableScheduleInstance&gt;&gt; source2ScheduleInstances = new HashMap&lt;ShiftAssignment, Collection&lt;BiddableScheduleInstance&gt;&gt;();</span>
<span class="nc bnc" id="L3273" title="All 2 branches missed.">		for (BiddableScheduleInstance bsi : assignedShiftAssignments.keySet()) {</span>
<span class="nc bnc" id="L3274" title="All 2 branches missed.">			for (ShiftAssignment source : assignedShiftAssignments.get(bsi)) {</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">				if (!source2ScheduleInstances.containsKey(source)) {</span>
<span class="nc" id="L3276">					source2ScheduleInstances.put(source, new ArrayList&lt;BiddableScheduleInstance&gt;());</span>
				}
<span class="nc" id="L3278">				source2ScheduleInstances.get(source).add(bsi);</span>
<span class="nc" id="L3279">			}</span>
<span class="nc" id="L3280">		}</span>
<span class="nc" id="L3281">		return source2ScheduleInstances;</span>
	}

	private static ID createShiftAssignmentForPhantomOnWithdrawal(ShiftAssignment source, BiddableScheduleInstance bsi, ShiftBidRequest request, ScheduleAccessManager sam) throws Exception {
		ID result;

		boolean createSameShiftAssignment;

<span class="nc bnc" id="L3289" title="All 2 branches missed.">		if (!request.getOptMethods().getShiftBidAuction().getIsMultiShift()</span>
<span class="nc bnc" id="L3290" title="All 4 branches missed.">				|| source.getStartTime().equals(bsi.getPhantomStartTime()) &amp;&amp; source.getEndTime().equals(bsi.getPhantomEndTime())) {</span>

			// copy whole shift assignment
<span class="nc" id="L3293">			RequestUtil.replaceEmployeeIDForShiftAssignments(Arrays.asList(source), bsi.getPhantomEmployeeID());</span>
<span class="nc" id="L3294">			result = sam.createShiftAssignment(source);</span>

		} else {
<span class="nc" id="L3297">			TimeRange targetRange = new TimeRange(bsi.getPhantomStartTime(), bsi.getPhantomEndTime());</span>

<span class="nc bnc" id="L3299" title="All 2 branches missed.">			if (!targetRange.isInside(new TimeRange(source.getStartTime(), source.getEndTime()))) {</span>
				// this condition should never happen
<span class="nc" id="L3301">				throw new IllegalStateException();</span>
			}

			// copy only part of the shift assignment
<span class="nc" id="L3305">			ShiftAssignment target = createCustomShiftAssignment(source, bsi);</span>

<span class="nc bnc" id="L3307" title="All 2 branches missed.">			for (ShiftEventAssignment event : source.getChildren()) {</span>
<span class="nc" id="L3308">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L3309" title="All 4 branches missed.">				if (eventRange.equals(targetRange) || eventRange.getOverlapDuration(targetRange) &gt; 0) {</span>
<span class="nc" id="L3310">					target.addShiftEventAssignment(createCustomShiftEvent(event, bsi));</span>
				}
<span class="nc" id="L3312">			}</span>

<span class="nc" id="L3314">			result = sam.createShiftAssignment(target);</span>
		}

<span class="nc" id="L3317">		return result;</span>
	}

	public static ShiftEventAssignment createCustomShiftEvent(ShiftEventAssignment original, BiddableScheduleInstance bsi) {
<span class="nc" id="L3321">		TimeRange targetRange = new TimeRange(bsi.getPhantomStartTime(), bsi.getPhantomEndTime());</span>
<span class="nc" id="L3322">		TimeRange eventRange = new TimeRange(original.getStartTime(), original.getEndTime());</span>
<span class="nc" id="L3323">		TimeRange newEventRange = targetRange.getOverlapInterval(eventRange);</span>

<span class="nc" id="L3325">		ShiftEventAssignment event = new ShiftEventAssignment();</span>
<span class="nc" id="L3326">		event.setStartTime(newEventRange.getStartDate());</span>
<span class="nc" id="L3327">		event.setDuration((int) newEventRange.getDurationMin());</span>
<span class="nc" id="L3328">		event.setPaid(original.getPaid());</span>
<span class="nc" id="L3329">		event.setActivityID(original.getActivityID());</span>
<span class="nc bnc" id="L3330" title="All 2 branches missed.">		event.setShiftEventID((original.getDuration() == newEventRange.getDurationMin()) ? original.getShiftEventID() : null);</span>
<span class="nc" id="L3331">		event.addWorkResourceID(bsi.getPhantomEmployeeID());</span>
<span class="nc" id="L3332">		event.setOverlayPrecedence(original.getOverlayPrecedence());</span>
<span class="nc" id="L3333">		event.setOverTimeGapType(original.getOverTimeGapType());</span>
<span class="nc" id="L3334">		event.setSPID(original.getSPID());</span>
<span class="nc" id="L3335">		return event;</span>

	}

	public static ShiftAssignment createCustomShiftAssignment(ShiftAssignment original, BiddableScheduleInstance bsi) {
<span class="nc" id="L3340">		TimeRange targetRange = new TimeRange(bsi.getPhantomStartTime(), bsi.getPhantomEndTime());</span>

<span class="nc" id="L3342">		ShiftAssignment shift = new ShiftAssignment();</span>
<span class="nc" id="L3343">		shift.setStartTime(bsi.getPhantomStartTime());</span>
<span class="nc" id="L3344">		shift.setDuration((int) targetRange.getDurationMin());</span>
<span class="nc" id="L3345">		shift.setLocked(false);</span>
<span class="nc" id="L3346">		shift.setActivityID(original.getActivityID());</span>
<span class="nc" id="L3347">		shift.setShiftID(original.getShiftID());</span>
<span class="nc" id="L3348">		shift.addWorkResourceID(bsi.getPhantomEmployeeID());</span>
<span class="nc" id="L3349">		shift.setCampaignID(original.getCampaignID());</span>
<span class="nc" id="L3350">		shift.setOverlayPrecedence(original.getOverlayPrecedence());</span>
<span class="nc" id="L3351">		shift.setWorkPatternID(original.getWorkPatternID());</span>
<span class="nc" id="L3352">		shift.setShiftID(bsi.getPhantomShiftID());</span>
<span class="nc" id="L3353">		shift.setWorkPatternID(bsi.getPhantomShiftPatternID());</span>
<span class="nc" id="L3354">		shift.setDescription(bsi.getPhantomDescription());</span>

<span class="nc" id="L3356">		return shift;</span>
	}

	private static void removePhantomBlocksFromAssignmentOnWithdrawal(ID sourceID,
			Collection&lt;BiddableScheduleInstance&gt; instances, ShiftBidRequest request, ScheduleAccessManager sam)
			throws Exception {
<span class="nc" id="L3362">		boolean isMultiShiftBlocksBidding = request.getOptMethods().getShiftBidAuction().getIsMultiShift();</span>
<span class="nc" id="L3363">		ShiftAssignment source = null;</span>

<span class="nc bnc" id="L3365" title="All 2 branches missed.">		if (isMultiShiftBlocksBidding) {</span>
<span class="nc" id="L3366">			source = sam.getShiftAssignmentByID(sourceID);</span>
		}

		// delete the stitched shift
<span class="nc" id="L3370">		sam.deleteShiftAssignments(Arrays.asList(sourceID));</span>

<span class="nc bnc" id="L3372" title="All 2 branches missed.">		if (isMultiShiftBlocksBidding) {</span>
<span class="nc" id="L3373">			TimeRange sourceTimeRange = new TimeRange(source.getStartTime(), source.getEndTime());</span>

			// Build TimeMap of Source/Stitched Shift Assignment
<span class="nc" id="L3376">			TimeMap sourceTimeMap = buildTimeMap(Collections.singleton(source), sourceTimeRange, TimeMap.ONE_MINUTE,</span>
					false);

			// Clear bit ranges with the date range of Phantom Shift Blocks
<span class="nc bnc" id="L3380" title="All 2 branches missed.">			for (BiddableScheduleInstance instance : instances) {</span>
<span class="nc" id="L3381">				sourceTimeMap.clearRange(instance.getPhantomStartTime(), instance.getPhantomEndTime());</span>
<span class="nc" id="L3382">				removePhantomEvents(source, instance);</span>
<span class="nc" id="L3383">			}</span>

<span class="nc" id="L3385">			Date newShiftStart = sourceTimeMap.findFirstOn();</span>
<span class="nc" id="L3386">			Date newShiftEnd = sourceTimeMap.findLastOn();</span>
<span class="nc bnc" id="L3387" title="All 2 branches missed.">			if (!newShiftStart.equals(newShiftEnd)) {</span>
				// rebuilding the original shift of employee at the state before
				// the stitching
<span class="nc" id="L3390">				long duration = (newShiftEnd.getTime() + TimeMap.ONE_MINUTE) - newShiftStart.getTime();</span>
<span class="nc" id="L3391">				TimeRange newShiftTimeRange = new TimeRange(newShiftStart, duration);</span>
<span class="nc" id="L3392">				ShiftAssignment shift = createCustomShiftAssignment(newShiftTimeRange, source);</span>
<span class="nc" id="L3393">				fillGapsFromTimeMap(shift, sourceTimeMap);</span>

<span class="nc" id="L3395">				sam.createShiftAssignment(shift);</span>
			}
		}

<span class="nc" id="L3399">	}</span>

	private static void removePhantomEvents(ShiftAssignment source, BiddableScheduleInstance instance) {

<span class="nc" id="L3403">		TimeRange phantomTimeRange = new TimeRange(instance.getPhantomStartTime(), instance.getPhantomEndTime());</span>
<span class="nc bnc" id="L3404" title="All 2 branches missed.">		for (ShiftEventAssignment event : source.getChildren()) {</span>
<span class="nc bnc" id="L3405" title="All 2 branches missed.">			if (!event.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc" id="L3406">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L3407" title="All 4 branches missed.">				if (eventRange.equals(phantomTimeRange) || eventRange.getOverlapDuration(phantomTimeRange) &gt; 0) {</span>
<span class="nc" id="L3408">					source.removeShiftEventAssignment(event.getID());</span>
				}
			}
<span class="nc" id="L3411">		}</span>
<span class="nc" id="L3412">	}</span>

	private static void fillGapsFromTimeMap(ShiftAssignment shift, TimeMap sourceTimeMap) {

<span class="nc" id="L3416">		Date endDate = shift.getEndTime();</span>
<span class="nc" id="L3417">		Date cur = shift.getStartTime();</span>
<span class="nc bnc" id="L3418" title="All 2 branches missed.">		while (cur.before(endDate)) {</span>
			// cur is the first gap date
<span class="nc" id="L3420">			cur = sourceTimeMap.findNextOff(cur);</span>
<span class="nc bnc" id="L3421" title="All 4 branches missed.">			if (cur.equals(endDate) || cur.after(endDate)) {</span>
<span class="nc" id="L3422">				break;</span>
			}
			// endGap is the end time of the gap
<span class="nc" id="L3425">			Date endGap = sourceTimeMap.findNextOn(cur);</span>
<span class="nc" id="L3426">			long duration = (endGap.getTime() - cur.getTime()) / 60000; // minutes</span>
			// Create the gap and add it to the shift
<span class="nc" id="L3428">			ShiftEventAssignment gapSEA = createSEAFromParams(cur, Activity.ACTIVITY_SHIFT_OVERTIME_GAP, (int) duration,</span>
<span class="nc" id="L3429">					shift.getWorkResourceID());</span>
<span class="nc" id="L3430">			shift.addShiftEventAssignment(gapSEA);</span>
<span class="nc" id="L3431">			cur = endGap;</span>
<span class="nc" id="L3432">		}</span>
<span class="nc" id="L3433">	}</span>

	private static ShiftAssignment createCustomShiftAssignment(TimeRange newShiftTimeRange,
			ShiftAssignment sourceShift) {
<span class="nc" id="L3437">		ShiftAssignment shift = new ShiftAssignment();</span>
<span class="nc" id="L3438">		shift.setStartTime(newShiftTimeRange.getStartDate());</span>
<span class="nc" id="L3439">		shift.setDuration((int) newShiftTimeRange.getDurationMin());</span>
<span class="nc" id="L3440">		shift.setLocked(false);</span>
		//Set SPID
<span class="nc" id="L3442">		shift.setActivityID(sourceShift.getActivityID());</span>
<span class="nc" id="L3443">		shift.setShiftID(sourceShift.getShiftID());</span>
<span class="nc" id="L3444">		shift.addWorkResourceID(sourceShift.getWorkResourceID());</span>
<span class="nc" id="L3445">		shift.setCampaignID(sourceShift.getCampaignID());</span>
<span class="nc" id="L3446">		shift.setOverlayPrecedence(sourceShift.getOverlayPrecedence());</span>
<span class="nc" id="L3447">		shift.setWorkPatternID(sourceShift.getWorkPatternID());</span>
<span class="nc" id="L3448">		shift.setDescription(sourceShift.getDescription());</span>

		// move non phantom shift events to the new shift
<span class="nc bnc" id="L3451" title="All 2 branches missed.">		for (ShiftEventAssignment event : sourceShift.getChildren()) {</span>
<span class="nc bnc" id="L3452" title="All 2 branches missed.">			if (!event.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc" id="L3453">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L3454" title="All 4 branches missed.">				if (eventRange.equals(newShiftTimeRange) || eventRange.getOverlapDuration(newShiftTimeRange) &gt; 0) {</span>
<span class="nc" id="L3455">					event.setParentID(null);</span>
<span class="nc" id="L3456">					shift.addShiftEventAssignment(event);</span>
				}
			}
<span class="nc" id="L3459">		}</span>

<span class="nc" id="L3461">		return shift;</span>
	}

	/**
	 * Computes the total length of the given shift assignments taking into
	 * account paid/unpaid shift event assignments associated with the shift
	 * assignments. The returned length is in minutes.
	 *
	 * @param shiftAssns
	 * @return
	 */
	public static int computePaidShiftLength(ShiftAssignment shiftAssn) {
<span class="nc" id="L3473">		int totalMinutes = 0;</span>
<span class="nc bnc" id="L3474" title="All 2 branches missed.">		if (shiftAssn.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
			// compute the duration for the shift assignment
<span class="nc" id="L3476">			totalMinutes += shiftAssn.getDuration();</span>
<span class="nc" id="L3477">			Collection shiftEventAssns = shiftAssn.getChildren();</span>
<span class="nc bnc" id="L3478" title="All 2 branches missed.">			for (Iterator shiftEventAssnsIter = shiftEventAssns.iterator(); shiftEventAssnsIter.hasNext();) {</span>
<span class="nc" id="L3479">				Event shiftEventAssn = (Event) shiftEventAssnsIter.next();</span>
<span class="nc bnc" id="L3480" title="All 2 branches missed.">				if (!shiftEventAssn.getPaid()) {</span>
<span class="nc" id="L3481">					totalMinutes -= shiftEventAssn.getDuration();</span>
				}
<span class="nc" id="L3483">			}</span>
		}

<span class="nc" id="L3486">		return totalMinutes;</span>
	}

	/**
	 * Computes the total length of the given shift assignments taking into
	 * account paid/unpaid shift event assignments associated with the shift
	 * assignments. The returned length is in minutes.
	 *
	 * @param shiftAssns
	 * @return
	 */
	public static int computeScheduleLength(Collection shiftAssns) {
<span class="nc" id="L3498">		int totalMinutes = 0;</span>
<span class="nc bnc" id="L3499" title="All 2 branches missed.">		for (Iterator shiftAssnsIter = shiftAssns.iterator(); shiftAssnsIter.hasNext();) {</span>
<span class="nc" id="L3500">			ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsIter.next();</span>

<span class="nc" id="L3502">			totalMinutes += computePaidShiftLength(shiftAssn);</span>
<span class="nc" id="L3503">		}</span>

<span class="nc" id="L3505">		return totalMinutes;</span>
	}

	/**
	 * Note: This method may return a 'null' value.
	 *
	 * Return the proper {@link WorkResourceMinMaxHour WorkResourceMinMaxHour}
	 * element from the given collection for the specified time range. The
	 * chosen minMax assignment is the one with an effectivity which overlaps
	 * the given time range.
	 *
	 * @param minMaxAssns
	 * @param startTime
	 * @param endTime
	 * @return
	 */
	public static WorkResourceMinMaxHour getMinMaxHourAssnOverlappingTimeRange(Collection minMaxAssns, Date startTime,
			Date endTime) {

		// If a campaign(SP) override for min/max hours exists for this
		// employee, then
		// this override must be used. It seems
		// the returned elements in the collection are sorted by the start-time
		// of the
		// min/max hour assignment's effectivity period. Here is an example of a
		// returned collection:
		// starttime, endtime == null, SPStartTime.
		// starttime, endtime == SPStartTime, SPEndTime
		// starttime, endTime == SPEndTime, null.
<span class="nc" id="L3534">		long maxOverlap = 0;</span>
<span class="nc" id="L3535">		WorkResourceMinMaxHour wrMinMaxHourWithMaxOverlap = null;</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">		for (Iterator iter = minMaxAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3537">			WorkResourceMinMaxHour wrMinMaxHour = (WorkResourceMinMaxHour) iter.next();</span>

			// if strt time == null, adjust.
<span class="nc bnc" id="L3540" title="All 2 branches missed.">			if (wrMinMaxHour.getStartTime() == null) {</span>
<span class="nc" id="L3541">				wrMinMaxHour.setStartTime(new Date(0));</span>
			}

			// if end time == null, adjust
<span class="nc bnc" id="L3545" title="All 2 branches missed.">			if (wrMinMaxHour.getEndTime() == null) {</span>
<span class="nc" id="L3546">				wrMinMaxHour.setEndTime(new Date(Long.MAX_VALUE));</span>
			}

<span class="nc" id="L3549">			long overlapMs = RequestUtil.getOverlapLength(wrMinMaxHour.getStartTime(), wrMinMaxHour.getEndTime(),</span>
					startTime, endTime);

<span class="nc bnc" id="L3552" title="All 2 branches missed.">			if (overlapMs &gt; maxOverlap) {</span>
<span class="nc" id="L3553">				maxOverlap = overlapMs;</span>
<span class="nc" id="L3554">				wrMinMaxHourWithMaxOverlap = wrMinMaxHour;</span>
			}
<span class="nc" id="L3556">		}</span>

<span class="nc" id="L3558">		return wrMinMaxHourWithMaxOverlap;</span>
	}

	/**
	 * @param msg
	 * @return
	 * @throws Exception
	 */
	public static Element createXMLDoc(DocumentBuilder docBuilder, String rootElementName) throws Exception {
<span class="nc" id="L3567">		Document doc = docBuilder.newDocument();</span>

<span class="nc" id="L3569">		Element rootElement = doc.createElement(rootElementName);</span>
<span class="nc" id="L3570">		doc.appendChild(rootElement);</span>

		// Text textNode = doc.createTextNode(msg);
		// rootElement.appendChild(textNode);

<span class="nc" id="L3575">		return rootElement;</span>
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text) {

<span class="nc" id="L3589">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, (String[]) null, null);</span>
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrName1
	 * @param attrValue1
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String attrName1, String attrValue1) {

<span class="nc" id="L3606">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, new String[] { attrName1 },</span>
				new String[] { attrValue1 });
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrName1
	 * @param attrValue1
	 * @param attrName2
	 * @param attrValue2
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String attrName1, String attrValue1, String attrName2, String attrValue2) {

<span class="nc" id="L3626">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, new String[] { attrName1, attrName2 },</span>
				new String[] { attrValue1, attrValue2 });
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrNames
	 * @param attrValues
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String[] attrNames, String[] attrValues) {

		// get the owning document
<span class="nc bnc" id="L3645" title="All 2 branches missed.">		Document ownerDoc = (parentElem != null) ? parentElem.getOwnerDocument() : doc;</span>
		// create the child element
<span class="nc" id="L3647">		Element elem = ownerDoc.createElement(elemName);</span>

		// attach the child element to parent
<span class="nc bnc" id="L3650" title="All 2 branches missed.">		if (parentElem != null) {</span>
<span class="nc" id="L3651">			parentElem.appendChild(elem);</span>
		}

		// create the attributes
<span class="nc bnc" id="L3655" title="All 4 branches missed.">		for (int i = 0; attrNames != null &amp;&amp; i &lt; attrValues.length; i++) {</span>
<span class="nc" id="L3656">			createAndAppendAttr(elem, attrNames[i], attrValues[i]);</span>
		}

		// attach text node as child
<span class="nc bnc" id="L3660" title="All 2 branches missed.">		if (text != null) {</span>
<span class="nc" id="L3661">			Text textNode = ownerDoc.createTextNode(text);</span>
<span class="nc" id="L3662">			elem.appendChild(textNode);</span>
		}

<span class="nc" id="L3665">		return elem;</span>
	}

	public static void createAndAppendAttr(Element elem, String attrName, String attrValue) {
		// Document ownerDoc = elem.getOwnerDocument();
		//
		// // create attribute and set value.
		// Attr attr = ownerDoc.createAttribute(attrName);
		// attr.setValue(attrValue);
		// // attach attribute to child
<span class="nc" id="L3675">		elem.setAttribute(attrName, attrValue);</span>

		// return attr;
<span class="nc" id="L3678">	}</span>

	/**
	 * Either the element or the document must be specified and not both.
	 * Converts the XML DOM tree to a serialized string.
	 *
	 * @param element
	 * @param doc
	 * @return
	 * @throws Exception
	 */
	public static String getXMLStringForElemOrDoc(Element element, Document doc) throws Exception {
		// serialize the DOM tree to a string
<span class="nc" id="L3691">		StringWriter writer = new StringWriter();</span>

<span class="nc" id="L3693">		OutputFormat format = new OutputFormat();</span>
<span class="nc" id="L3694">		format.setPreserveSpace(true);</span>

<span class="nc" id="L3696">		XMLSerializer serializer = new XMLSerializer(writer, format);</span>
<span class="nc bnc" id="L3697" title="All 2 branches missed.">		if (element != null) {</span>
<span class="nc" id="L3698">			serializer.serialize(element);</span>
		} else {
<span class="nc" id="L3700">			serializer.serialize(doc);</span>
		}

<span class="nc" id="L3703">		writer.flush();</span>

<span class="nc" id="L3705">		String msgXML = writer.toString();</span>
<span class="nc" id="L3706">		writer.close();</span>

<span class="nc" id="L3708">		return msgXML;</span>
	}

	public static Activity getActivityByID(ID activityID)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L3713">		ActivityManager actMgr = getActivityManager();</span>

<span class="nc" id="L3715">		return actMgr.findActivityById(activityID);</span>
	}

	public static String getActivityNameByID(ID actID)
			throws BbmObjectNotFoundException, BbmEJBCreateException, BbmFinderException, RemoteException {
<span class="nc" id="L3720">		Activity act = getActivityByID(actID);</span>

<span class="nc" id="L3722">		return act.getName();</span>
	}

	/**
	 * @param collec1
	 * @param collec2
	 * @return a three element collections array.
	 *         &lt;li&gt;First collection in array contains elements in first set but
	 *         not in the second.
	 *         &lt;li&gt;Second collection in array contains the common elements.
	 *         &lt;li&gt;Third collection in array contains elements in second but not
	 *         in first.
	 */
	public static Collection[] diffObjectLists(Collection collec1, Collection collec2) {
<span class="nc" id="L3736">		Collection commonElems = new ArrayList(collec1.size());</span>

<span class="nc" id="L3738">		Set set1 = new HashSet(collec1);</span>
<span class="nc" id="L3739">		Set set2 = new HashSet(collec2);</span>

		// iterate thru obj1Set elements
<span class="nc bnc" id="L3742" title="All 2 branches missed.">		for (Iterator set1Iter = set1.iterator(); set1Iter.hasNext();) {</span>
<span class="nc" id="L3743">			Object set1Elem = set1Iter.next();</span>

			// attempt to remove obj1Elem from obj2Set
<span class="nc" id="L3746">			boolean removed = set2.remove(set1Elem);</span>
			// if element found in obj2Set
<span class="nc bnc" id="L3748" title="All 2 branches missed.">			if (removed) {</span>
				// add to commonSet
<span class="nc" id="L3750">				commonElems.add(set1Elem);</span>

				// remove from obj1Set
<span class="nc" id="L3753">				set1Iter.remove();</span>
			}
<span class="nc" id="L3755">		}</span>

		// At this point obj1Set contains elements not in obj2Set and vice
		// versa.
<span class="nc" id="L3759">		return new Collection[] { set1, commonElems, set2 };</span>
	}

	/**
	 * Order the given list of VOBases according to the given collection of
	 * voBaseIDs.
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method modifies the passed voBaseList argument.
	 *
	 * @param shiftBidderIDs
	 * @param list
	 * @return
	 */
	public static List orderVOsByGivenIDs(Collection voBaseIDs, List voBaseList) {
		// convert the voBaseList to a map.
<span class="nc" id="L3774">		Map idToVOBaseMap = getMapOfIDsForVOBases(voBaseList);</span>

<span class="nc" id="L3776">		int i = 0;</span>
<span class="nc bnc" id="L3777" title="All 2 branches missed.">		for (Iterator iter = voBaseIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3778">			Object voBaseID = iter.next();</span>

<span class="nc" id="L3780">			Object voBase = idToVOBaseMap.get(voBaseID);</span>
<span class="nc bnc" id="L3781" title="All 2 branches missed.">			if (voBase != null) {</span>
<span class="nc" id="L3782">				voBaseList.set(i++, voBase);</span>
			}
<span class="nc" id="L3784">		}</span>

<span class="nc" id="L3786">		return voBaseList;</span>
	}

	public static void resetRMDebugEnabled() {
<span class="nc" id="L3790">		isWaitListRankOnRqPageDisabled = null;</span>
<span class="nc" id="L3791">		isRMDebugEnabled = null;</span>
<span class="nc" id="L3792">	}</span>

	public static void setIsRmDebugEnabled(boolean enabled) {
<span class="nc" id="L3795">		isRMDebugEnabled = enabled;</span>
<span class="nc" id="L3796">	}</span>

	public static boolean isRMDebugEnabled() {
		try {
<span class="nc bnc" id="L3800" title="All 2 branches missed.">			if (isRMDebugEnabled == null) {</span>
<span class="nc" id="L3801">				isRMDebugEnabled = new Boolean(</span>
<span class="nc" id="L3802">						&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.RM_DEBUG_ENABLED)));</span>
			}
<span class="nc" id="L3804">		} catch (Exception e) {</span>
<span class="nc" id="L3805">			m_cat.error(e);</span>
<span class="nc" id="L3806">		}</span>
<span class="nc bnc" id="L3807" title="All 2 branches missed.">		return isRMDebugEnabled != null ? isRMDebugEnabled.booleanValue() : false;</span>
	}

<span class="nc" id="L3810">	private static Boolean isWaitListRankOnRqPageDisabled = null;</span>

	public static boolean isWaitListRankOnRqPageDisabled() {
		try {
<span class="nc bnc" id="L3814" title="All 2 branches missed.">			if (isWaitListRankOnRqPageDisabled == null) {</span>
<span class="nc" id="L3815">				isWaitListRankOnRqPageDisabled = new Boolean(&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager()</span>
<span class="nc" id="L3816">						.getValue(ConfigKey.RM_WAITLIST_RANK_ON_RQ_PAGE_DISABLED)));</span>
			}
<span class="nc" id="L3818">		} catch (Exception e) {</span>
<span class="nc" id="L3819">			m_cat.error(e);</span>
<span class="nc" id="L3820">		}</span>
<span class="nc bnc" id="L3821" title="All 2 branches missed.">		return isWaitListRankOnRqPageDisabled != null ? isWaitListRankOnRqPageDisabled.booleanValue() : false;</span>
	}

	public static boolean isTOAllocationCalendarAuditEnabled() {
<span class="nc" id="L3825">		boolean returnVal = false;</span>
		try {
<span class="nc" id="L3827">			returnVal = (&quot;true&quot;.equals(</span>
<span class="nc" id="L3828">					BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.TO_ALLOCATION_CALENDAR_AUDIT_ENABLED)));</span>
<span class="nc" id="L3829">		} catch (Exception e) {</span>
<span class="nc" id="L3830">			m_cat.error(e);</span>
<span class="nc" id="L3831">		}</span>
<span class="nc" id="L3832">		return returnVal;</span>
	}

<span class="nc" id="L3835">	private static Boolean isNetStaffingUpdateForTOMDisabled = null;</span>

	public static boolean isNetStaffingUpdateForTOMDisabled() {
		try {
<span class="nc bnc" id="L3839" title="All 2 branches missed.">			if (isNetStaffingUpdateForTOMDisabled == null) {</span>
<span class="nc" id="L3840">				isNetStaffingUpdateForTOMDisabled = new Boolean(&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager()</span>
<span class="nc" id="L3841">						.getValue(ConfigKey.NETSTAFFING_UPDATE_FOR_TOM_DISABLED)));</span>
			}
<span class="nc" id="L3843">		} catch (Exception e) {</span>
<span class="nc" id="L3844">			m_cat.error(e);</span>
<span class="nc" id="L3845">		}</span>
<span class="nc bnc" id="L3846" title="All 2 branches missed.">		return isNetStaffingUpdateForTOMDisabled != null ? isNetStaffingUpdateForTOMDisabled.booleanValue() : false;</span>
	}

	/**
	 * Make Shift Dates as Strings
	 *
	 * @param dayRange
	 *            - Date Range for Day
	 * @param sDate
	 *            - Start of Shift
	 * @param eDate
	 *            - End of Shift
	 * @param localizer
	 *            - Localizer
	 * @param tz
	 *            - TimeZone
	 */
	public static String makeShiftDatesString(CalendarRange dayRange, Date sDate, Date eDate, Localizer localizer,
			TimeZone tz) {
<span class="nc" id="L3865">		StringBuffer sb = new StringBuffer(100);</span>

		// --- start label ----
<span class="nc bnc" id="L3868" title="All 4 branches missed.">		if (dayRange != null &amp;&amp; dayRange.includes(sDate)) { // make time string</span>
<span class="nc" id="L3869">			sb.append(localizer.formatDate(sDate, tz, RegionalFormatBundleKey.TIME_FORMAT));</span>
		} else { // make date+time string
<span class="nc" id="L3871">			sb.append(localizer.formatDateTime(sDate, tz));</span>
		}

		// --- middle dash ---
<span class="nc" id="L3875">		sb.append(&quot; - &quot;);</span>

		// --- end label ---
<span class="nc bnc" id="L3878" title="All 4 branches missed.">		if (dayRange != null &amp;&amp; dayRange.includes(eDate)) { // make time string</span>
<span class="nc" id="L3879">			sb.append(localizer.formatDate(eDate, tz, RegionalFormatBundleKey.TIME_FORMAT));</span>
		} else { // make date+time string
<span class="nc" id="L3881">			sb.append(localizer.formatDateTime(eDate, tz));</span>
		}

<span class="nc" id="L3884">		return sb.toString();</span>
	}

	/**
	 * Get the display start time of a ShiftAssignment.
	 * &lt;P&gt;
	 *
	 * @return Date - event start time
	 */
	public static Date getDisplayStartTime(ShiftAssignment sa) {
<span class="nc" id="L3894">		Date startTime = sa.getFieldValueDate(ShiftAssignmentFields.STARTTIME);</span>

		// Hack to treat initial NO_ACTIVITY events as not part of the shift
<span class="nc" id="L3897">		Collection shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L3898" title="All 4 branches missed.">		if (shiftEventAssignments != null &amp;&amp; !shiftEventAssignments.isEmpty()) {</span>
<span class="nc" id="L3899">			Iterator it = shiftEventAssignments.iterator();</span>
<span class="nc bnc" id="L3900" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L3901">				ShiftEventAssignment sea = (ShiftEventAssignment) it.next();</span>
<span class="nc bnc" id="L3902" title="All 2 branches missed.">				if (sea.getActivityID().toInt() == Activity.NO_ACTIVITY</span>
<span class="nc bnc" id="L3903" title="All 2 branches missed.">						&amp;&amp; sea.getStartTime().equals(sa.getStartTime())) {</span>
<span class="nc" id="L3904">					startTime = sea.getEndTime();</span>
<span class="nc" id="L3905">					break;</span>
				}
<span class="nc" id="L3907">			}</span>
		}
<span class="nc" id="L3909">		return startTime;</span>
	}

	public static Collection findShifts(CalendarRange dayRange, Collection shifts) {
<span class="nc" id="L3913">		Collection results = new ArrayList(2);</span>
<span class="nc bnc" id="L3914" title="All 2 branches missed.">		for (Iterator it = shifts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3915">			ShiftAssignment sa = (ShiftAssignment) it.next();</span>
<span class="nc bnc" id="L3916" title="All 2 branches missed.">			if (dayRange.includes(getDisplayStartTime(sa))) {</span>
<span class="nc" id="L3917">				results.add(sa);</span>
			}
<span class="nc" id="L3919">		}</span>
<span class="nc" id="L3920">		return results;</span>
	}

	public static Collection getEmpIdsInOrg(ID orgID, Date startDate, Date endDate, boolean inclChildOrgs)
			throws Exception {
<span class="nc" id="L3925">		Set orgIDSet = new HashSet();</span>
<span class="nc" id="L3926">		orgIDSet.add(orgID);</span>
<span class="nc" id="L3927">		Set empIdsSet = new HashSet();</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">		if (inclChildOrgs) {</span>
<span class="nc" id="L3929">			orgIDSet.addAll(BbmManagerFactory.getWorkResourceManager()</span>
<span class="nc" id="L3930">					.getOrganizationsChildrenByIDs(Collections.singleton(orgID)));</span>
		}
<span class="nc bnc" id="L3932" title="All 2 branches missed.">		for (Iterator iterator = orgIDSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L3933">			ID orgIDVal = (ID) iterator.next();</span>
<span class="nc" id="L3934">			empIdsSet.addAll(</span>
<span class="nc" id="L3935">					ValueObjectUtil.getFieldObjectCol(WorkResourceAssignmentFieldInfo.WRASSIGNMENT_WORKRESOURCEID,</span>
<span class="nc" id="L3936">							CacheUtilBBM.getWorkResourceAssnForOrgID(orgIDVal, startDate, endDate)));</span>
<span class="nc" id="L3937">		}</span>
<span class="nc" id="L3938">		return empIdsSet;</span>
	}

	public static ValidationResult setValidationResult(ID empID, String empName, Validatable validatable,
			Collection results, String className) throws Exception {
<span class="nc" id="L3943">		ValidationResult result = null;</span>
<span class="nc bnc" id="L3944" title="All 4 branches missed.">		if (results != null &amp;&amp; !results.isEmpty()) {</span>
<span class="nc bnc" id="L3945" title="All 2 branches missed.">			for (Iterator itr = results.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3946">				ShiftsConflict conflict = (ShiftsConflict) itr.next();</span>
<span class="nc" id="L3947">				conflict.setWorkResourceName(empName);</span>
				// todo: we lose validation errors if results has 2 or more
<span class="nc" id="L3949">				result = ValidationUtil.setSoftValidationResult(validatable, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
						conflict, className);
<span class="nc" id="L3951">			}</span>
		}
<span class="nc" id="L3953">		return result;</span>
	}

	/**
	 * Get a filing rule's interval count and unit, based on request type (since
	 * Flex Time requests allow minutes)
	 *
	 * @param iIntervalCount
	 *            - interval count for the filing rule
	 * @param isFlex
	 *            - is this a Flex Time filing rule?
	 * @return a pair of Strings, where the key is the interval count, and the
	 *         value is the units string (days/hours/minutes).
	 */
	public static StringsPair getIntervalCountAndUnit(int iIntervalCount, boolean isFlexTime) {
		// Note: It seems like originally, we only stored days in the
		// REQUESTFILINGRULE.INTERVALDAYS field. Then
		// we started storing hours instead. But for Flex Time (FT), we need to
		// store minutes instead of hours.
		String intervalUnit;
<span class="nc bnc" id="L3973" title="All 2 branches missed.">		if (isFlexTime) {</span>
			// iInterval for Flex Time request filing rules stores the number of
			// minutes, regardless of the unit
<span class="nc bnc" id="L3976" title="All 2 branches missed.">			if (iIntervalCount % (24 * 60) == 0) {</span>
				// convert into days
<span class="nc" id="L3978">				iIntervalCount = iIntervalCount / (24 * 60);</span>
<span class="nc" id="L3979">				intervalUnit = DAYS;</span>
<span class="nc bnc" id="L3980" title="All 2 branches missed.">			} else if (iIntervalCount % 60 == 0) {</span>
				// convert into hours
<span class="nc" id="L3982">				iIntervalCount = iIntervalCount / 60;</span>
<span class="nc" id="L3983">				intervalUnit = HOURS;</span>
			} else {
				// no need to convert because it's already in minutes
<span class="nc" id="L3986">				intervalUnit = MINUTES;</span>
			}
		} else {
			// iInterval for all other request types stores the number of hours,
			// regardless of the unit
<span class="nc bnc" id="L3991" title="All 2 branches missed.">			if (iIntervalCount % 24 == 0) {</span>
				// convert into days
<span class="nc" id="L3993">				iIntervalCount = iIntervalCount / 24;</span>
<span class="nc" id="L3994">				intervalUnit = DAYS;</span>
			} else {
<span class="nc" id="L3996">				intervalUnit = HOURS;</span>
			}
		}
<span class="nc" id="L3999">		String intervalCount = Integer.toString(iIntervalCount);</span>
<span class="nc" id="L4000">		StringsPair intervalCountAndUnit = new StringsPair(intervalCount, intervalUnit);</span>
<span class="nc" id="L4001">		return intervalCountAndUnit;</span>
	}

	public static ActivityManager getActivityManager(boolean isInWhatIfMode) throws BbmException {
<span class="nc" id="L4005">		return WfmManagerFactory.getActivityManager(isInWhatIfMode);</span>
	}

	/**
	 * Get the subtypes string for a Time Off or Flex Time filing rule, which is
	 * displayed in the &quot;Request Type&quot; column of the filing rules list.
	 */
	public static String getTimeOffOrFlexTimeSubtypesString(boolean isInWhatIfMode, RequestFilingRule rule,
			ResourceBundle rmBundle, Localizer localizer, boolean isTimeOff)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException, BbmException {
		String subTypes;
		// Append TimeOff name
<span class="nc" id="L4017">		Activity activity = activity = getActivityManager(isInWhatIfMode).findActivityById(rule.getActivityId());</span>
<span class="nc bnc" id="L4018" title="All 2 branches missed.">		String timeoffName = activity == null ? &quot;&quot; : activity.getName();</span>

<span class="nc bnc" id="L4020" title="All 2 branches missed.">		if (isTimeOff) {</span>
<span class="nc" id="L4021">			subTypes = timeoffName;</span>
		} else {
<span class="nc bnc" id="L4023" title="All 2 branches missed.">			String beforeAfterKey = rule.getRequestSubType() == RequestFilingRule.REQUEST_SUB_TYPE_TIMEOFF_BEFORE_MAKEUP</span>
					? RmEjbBundleKey.ORG_RM_FILING_RULE_TIMEOFF_BEFORE_MAKEUP
					: RmEjbBundleKey.ORG_RM_FILING_RULE_TIMEOFF_AFTER_MAKEUP;
<span class="nc" id="L4026">			String beforeOrAfter = localizer.i18n(rmBundle, beforeAfterKey);</span>
<span class="nc" id="L4027">			subTypes = timeoffName + &quot;, &quot; + beforeOrAfter;</span>
		}
<span class="nc" id="L4029">		return subTypes;</span>
	}

	/**
	 * Get the subtypes string for a Shift Request filing rule, which is
	 * displayed in the &quot;Request Type&quot; column of the filing rules list.
	 */
	public static String getCustomShiftSubtypesString(RequestFilingRule rule, ResourceBundle rmBundle,
			Localizer localizer) {
<span class="nc" id="L4038">		String subTypes = &quot;&quot;;</span>
<span class="nc" id="L4039">		boolean foundOne = false;</span>
<span class="nc" id="L4040">		String comma = localizer.i18n(rmBundle, RmEjbBundleKey.COMMA_DELIMITER);</span>

<span class="nc bnc" id="L4042" title="All 2 branches missed.">		if (rule.getRequestSubTypeRegNewShift()) {</span>
<span class="nc" id="L4043">			subTypes = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_REG_NEW_SHIFT);</span>
<span class="nc" id="L4044">			foundOne = true;</span>
		}
<span class="nc bnc" id="L4046" title="All 2 branches missed.">		if (rule.getRequestSubTypeRegShiftChange()) {</span>
<span class="nc bnc" id="L4047" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L4048">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_REG_SHIFT_CHANGE);</span>
<span class="nc" id="L4049">			foundOne = true;</span>
		}
<span class="nc bnc" id="L4051" title="All 2 branches missed.">		if (rule.getRequestSubTypeOTNewShift()) {</span>
<span class="nc bnc" id="L4052" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L4053">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_OT_NEW_SHIFT);</span>
<span class="nc" id="L4054">			foundOne = true;</span>
		}
<span class="nc bnc" id="L4056" title="All 2 branches missed.">		if (rule.getRequestSubTypeOTShiftChange()) {</span>
<span class="nc bnc" id="L4057" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L4058">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_OT_SHIFT_CHANGE);</span>
		}
<span class="nc" id="L4060">		return subTypes;</span>
	}

	public static String getAllDaysLabel(ResourceBundle rmBundle, Localizer localizer) {
<span class="nc" id="L4064">		return localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_ALL_REQUESTS_LABEL);</span>
	}

	public static Collection getDayTypeList(ResourceBundle rmBundle, Localizer localizer) {
<span class="nc" id="L4068">		Collection dayTypeList = new ArrayList(7);</span>
<span class="nc" id="L4069">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4071">		dayTypeList.add(new StringsPair(&quot;weekend&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.WEEKEND)));</span>
<span class="nc" id="L4072">		dayTypeList.add(new StringsPair(&quot;sunday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.SUNDAY)));</span>
<span class="nc" id="L4073">		dayTypeList.add(new StringsPair(&quot;monday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.MONDAY)));</span>
<span class="nc" id="L4074">		dayTypeList.add(new StringsPair(&quot;tuesday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.TUESDAY)));</span>
<span class="nc" id="L4075">		dayTypeList.add(new StringsPair(&quot;wednesday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.WEDNESDAY)));</span>
<span class="nc" id="L4076">		dayTypeList.add(new StringsPair(&quot;thursday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.THURSDAY)));</span>
<span class="nc" id="L4077">		dayTypeList.add(new StringsPair(&quot;friday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.FRIDAY)));</span>
<span class="nc" id="L4078">		dayTypeList.add(new StringsPair(&quot;saturday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.SATURDAY)));</span>

<span class="nc" id="L4080">		dayTypeList.add(new StringsPair(&quot;workingholiday&quot;,</span>
<span class="nc" id="L4081">				localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_SETTINGS_TO_WORKING_LABEL)));</span>

<span class="nc" id="L4083">		return dayTypeList;</span>
	}

	/**
	 * Get the date range data part of the description for a filing rule.
	 */
	public static String getDateRangeData(Localizer localizer, RequestFilingRule rule, ResourceBundle rmBundle,
			TimeZone tz) {
<span class="nc" id="L4091">		String dayRange = rule.getDayRange();</span>
<span class="nc" id="L4092">		String dataToAdd = null;</span>
<span class="nc bnc" id="L4093" title="All 4 branches missed.">		if (dayRange == null || dayRange.equals(DAYRANGE_ALL_DAYS)) {</span>
<span class="nc" id="L4094">			dataToAdd = getAllDaysLabel(rmBundle, localizer);</span>
<span class="nc bnc" id="L4095" title="All 2 branches missed.">		} else if (dayRange.equals(DAYRANGE_DAY_TYPE)) {</span>
<span class="nc" id="L4096">			String dayType = rule.getDayType();</span>
<span class="nc" id="L4097">			Collection dTypeList = getDayTypeList(rmBundle, localizer);</span>
<span class="nc" id="L4098">			Object args[] = new Object[] { getSelectLabel(dayType, dTypeList) };</span>
<span class="nc" id="L4099">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_FOR_DAYS_LABEL, args);</span>
<span class="nc bnc" id="L4100" title="All 2 branches missed.">		} else if (dayRange.equals(DAYRANGE_DATES)) {</span>
<span class="nc" id="L4101">			String strFromDate = localizer.formatDateTime(rule.getStartDate(), tz);</span>
<span class="nc" id="L4102">			String strToDate = localizer.formatDateTime(rule.getEndDate(), tz);</span>
<span class="nc" id="L4103">			Object args[] = new Object[] { strFromDate, strToDate };</span>
<span class="nc" id="L4104">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_FROM_TO_DATE, args);</span>
		}
<span class="nc" id="L4106">		return dataToAdd;</span>
	}

	/**
	 * Get the date &quot;file by&quot; part of the description for a filing rule.
	 */
	public static String getFileByData(RequestFilingRule rule, ResourceBundle rmBundle, Localizer localizer,
			TimeZone tz) {
<span class="nc" id="L4114">		String dataToAdd = null;</span>
<span class="nc" id="L4115">		String timeType = rule.getTimeType();</span>
<span class="nc bnc" id="L4116" title="All 4 branches missed.">		if (timeType == null || timeType.equals(TIMETYPE_BYDATE)) {</span>
<span class="nc" id="L4117">			String dateCompar = rule.getDateComparision();</span>
<span class="nc bnc" id="L4118" title="All 2 branches missed.">			if (StringUtil.isEmpty(dateCompar)) {</span>
<span class="nc" id="L4119">				dateCompar = DATECOMPARISION_ON_DATE;</span>
			}
<span class="nc" id="L4121">			Collection dateCList = getDateComparisonList(localizer);</span>
<span class="nc" id="L4122">			String selectLabel = getSelectLabel(dateCompar, dateCList);</span>
<span class="nc" id="L4123">			String strByDate = localizer.formatDateTime(rule.getFileByDate(), tz);</span>
<span class="nc" id="L4124">			Object args[] = new Object[] { selectLabel, strByDate };</span>
<span class="nc" id="L4125">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_SB_ON_BEFORE_AFTER, args);</span>

<span class="nc bnc" id="L4127" title="All 2 branches missed.">		} else if (timeType.equals(TIMETYPE_INTERVAL)) {</span>
<span class="nc" id="L4128">			String intervalType = rule.getIntervalType();</span>
<span class="nc bnc" id="L4129" title="All 2 branches missed.">			if (StringUtil.isEmpty(intervalType)) {</span>
<span class="nc" id="L4130">				intervalType = INTERVALTYPE_LESSTHAN;</span>
			}

<span class="nc" id="L4133">			Collection iTypeList = getIntervalTypeList(localizer);</span>
<span class="nc" id="L4134">			String selectLabel = getSelectLabel(intervalType, iTypeList);</span>

			// Note: most request types store number of hours in the
			// IntervalDays field, but Flex Time stores minutes.
<span class="nc" id="L4138">			boolean isFlexTime = Request.REQUESTTYPE_FLEXTIME.equals(rule.getRequestType());</span>
<span class="nc" id="L4139">			StringsPair intervalCountAndUnit = RequestUtil.getIntervalCountAndUnit(rule.getIntervalDays(), isFlexTime);</span>
<span class="nc" id="L4140">			String intervalCount = intervalCountAndUnit.getKey();</span>
<span class="nc" id="L4141">			String sUnit = intervalCountAndUnit.getValue();</span>
<span class="nc" id="L4142">			String intervalUnits = localizer.i18n(rmBundle, getKeyForUnit(sUnit));</span>

<span class="nc bnc" id="L4144" title="All 2 branches missed.">			String timeLine = rule.getTimeLine() == RequestFilingRule.TIMELINE_IN_THE_PAST</span>
<span class="nc" id="L4145">					? localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_IN_PAST)</span>
<span class="nc" id="L4146">					: localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_IN_ADVANCE);</span>

<span class="nc" id="L4148">			Object args[] = new Object[] { selectLabel, intervalCount, intervalUnits, timeLine };</span>
<span class="nc" id="L4149">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_ADVANCE_LABEL, args);</span>
		}
<span class="nc" id="L4151">		return dataToAdd;</span>
	}

	/**
	 * Get the appropriate resource bundle key for the given interval unit.
	 *
	 * @param sUnit
	 *            - &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;
	 * @return - the associated RmWebBundleKey
	 */
	public static String getKeyForUnit(String sUnit) {
<span class="nc" id="L4162">		String sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_DAYS;</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">		if (sUnit.equals(RequestUtil.HOURS)) {</span>
<span class="nc" id="L4164">			sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_HOURS;</span>
<span class="nc bnc" id="L4165" title="All 2 branches missed.">		} else if (sUnit.equals(RequestUtil.MINUTES)) {</span>
<span class="nc" id="L4166">			sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_MINUTES;</span>
		}
<span class="nc" id="L4168">		return sKey;</span>
	}

	/**
	 * Get a list of key/value StringsPair's for the &quot;On, &quot;Before&quot; and &quot;After&quot;
	 * options.
	 */
	public static Collection getDateComparisonList(Localizer localizer) {
<span class="nc" id="L4176">		Collection dateComparisonList = new ArrayList(3);</span>
<span class="nc" id="L4177">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4179">		dateComparisonList</span>
<span class="nc" id="L4180">				.add(new StringsPair(&quot;on-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.ON_THE_FOLLOWING_DATE)));</span>
<span class="nc" id="L4181">		dateComparisonList.add(new StringsPair(&quot;before-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.BEFORE)));</span>
<span class="nc" id="L4182">		dateComparisonList.add(new StringsPair(&quot;after-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.AFTER)));</span>

<span class="nc" id="L4184">		return dateComparisonList;</span>
	}

	/**
	 * Return string pair collection for interval type list drop down.
	 *
	 * @param localizer
	 * @return collection of StringPair objects.
	 */
	public static Collection getIntervalTypeList(Localizer localizer) {
<span class="nc" id="L4194">		Collection intervalTypeList = new ArrayList(3);</span>
<span class="nc" id="L4195">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4197">		intervalTypeList.add(new StringsPair(&quot;less-than&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.LESS_THAN)));</span>
<span class="nc" id="L4198">		intervalTypeList.add(new StringsPair(&quot;equal-to&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.EQUAL_TO)));</span>
<span class="nc" id="L4199">		intervalTypeList.add(new StringsPair(&quot;more-than&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.MORE_THAN)));</span>

<span class="nc" id="L4201">		return intervalTypeList;</span>
	}

	public static String getSelectLabel(String key, Collection stringPairs) {
<span class="nc bnc" id="L4205" title="All 2 branches missed.">		if (stringPairs == null) {</span>
<span class="nc" id="L4206">			return &quot;&quot;;</span>
		}

<span class="nc" id="L4209">		String defaultValue = null;</span>
<span class="nc bnc" id="L4210" title="All 2 branches missed.">		for (Object obj : stringPairs) {</span>
<span class="nc" id="L4211">			StringsPair sp = (StringsPair) obj;</span>
<span class="nc bnc" id="L4212" title="All 2 branches missed.">			if (sp.getKey().equals(key)) {</span>
<span class="nc" id="L4213">				return sp.getValue();</span>
			}
<span class="nc bnc" id="L4215" title="All 2 branches missed.">			if (defaultValue == null) {</span>
<span class="nc" id="L4216">				defaultValue = sp.getValue();</span>
			}
<span class="nc" id="L4218">		}</span>

<span class="nc bnc" id="L4220" title="All 2 branches missed.">		return defaultValue == null ? &quot;&quot; : defaultValue;</span>
	}

	public static boolean checkGap(ShiftAssignment event, BitSet bits, long startingTime, long resolution, int limit) {
<span class="nc" id="L4224">		boolean ret = false;</span>
<span class="nc" id="L4225">		List&lt;ShiftEventAssignment&gt; assignments = new ArrayList&lt;ShiftEventAssignment&gt;(event.getChildren());</span>

<span class="nc bnc" id="L4227" title="All 2 branches missed.">		for (ShiftEventAssignment sea : assignments) {</span>
<span class="nc bnc" id="L4228" title="All 2 branches missed.">			if (sea.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">				if (!ret){</span>
					//This adds the bits of the full duration of the Shift Assignment
<span class="nc" id="L4231">					addToBits(bits, event.getStartTime().getTime(), event.getEndTime().getTime(), startingTime, resolution, limit, false);</span>
				}
				//Clear the bits of the gap
<span class="nc" id="L4234">				removeFromBits(bits, sea.getStartTime().getTime(), sea.getEndTime().getTime(), startingTime, resolution, limit, false);</span>
<span class="nc" id="L4235">				ret = true;</span>
			}

<span class="nc" id="L4238">		}</span>
<span class="nc" id="L4239">		return ret;</span>
	}

	// Convert event to interval index range and set in map
	private static  void addToBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean setEndBit) {
<span class="nc" id="L4244">		setBits(bits, eventStart, eventEnd, startingTime, resolution, limit, true, setEndBit);</span>
<span class="nc" id="L4245">	}</span>

	// Clear event to interval index range and set in map
	private static  void removeFromBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean setEndBit) {
<span class="nc" id="L4249">		setBits(bits, eventStart, eventEnd, startingTime, resolution, limit, false, setEndBit);</span>
<span class="nc" id="L4250">	}</span>

	private static  void  setBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean isAdd, boolean setEndBit) {
<span class="nc bnc" id="L4253" title="All 2 branches missed.">		if (!setEndBit){</span>
<span class="nc" id="L4254">			eventEnd--; //Reduce 1 mili sec so will not include last interval</span>
		}
<span class="nc" id="L4256">		int ixStrt = (int) ((eventStart - startingTime) / resolution);</span>
<span class="nc bnc" id="L4257" title="All 2 branches missed.">		ixStrt = (ixStrt &lt; 0) ? 0 : ixStrt;</span>

<span class="nc" id="L4259">		int ixEnd = (int) ((eventEnd - startingTime) / resolution);</span>
<span class="nc bnc" id="L4260" title="All 2 branches missed.">		ixEnd = (ixEnd &lt; 0) ? 0 : ixEnd;</span>

<span class="nc" id="L4262">		int upperBound = Math.min(ixEnd, limit);</span>
<span class="nc bnc" id="L4263" title="All 2 branches missed.">		for (int i = ixStrt; i &lt;= upperBound; i++) {</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">			if(isAdd){</span>
<span class="nc" id="L4265">				bits.set(i);</span>
			} else {
<span class="nc" id="L4267">				bits.clear(i);</span>
			}
		}
<span class="nc" id="L4270">	}</span>

	/**
	 * Build a time map object from events.
	 * 	Default for setEndBit is true
	 * @param events - Events to create the timemap
	 * @param range - time boundary of time map
	 * @param resolution - resolution in millis
	 * @return Time Map object
	 */
	public static  TimeMap buildTimeMap(Collection events, TimeRange range, long resolution){
<span class="nc" id="L4281">		return buildTimeMap(events, range, resolution, true);</span>
	}

	/**
	 * Build a time map object from events
	 * @param events - Events to create the timemap
	 * @param range - time boundary of time map
	 * @param resolution - resolution in millis
	 * @param setEndBit - If to set last bit in timemap in case endtime of event includes only first milli second of bit.
	 *                    For example event 10:00-11:00 will also mark bit of 11:00-11:01 in case this boolean is true
	 * @return Time Map object
	 */
	public static  TimeMap buildTimeMap(Collection events, TimeRange range, long resolution, boolean setEndBit) {
		// todo: more strict validation of passed arguments.
<span class="nc" id="L4295">		long startingTime = range.getStartDate().getTime();</span>
<span class="nc" id="L4296">		int limit = (int) ((range.getEndDate().getTime() - startingTime) / resolution);</span>
<span class="nc" id="L4297">		BitSet bits = new BitSet(limit);</span>

		// Did we find events?
<span class="nc bnc" id="L4300" title="All 2 branches missed.">		if (events != null) {</span>
			// Loop through the events. Check each one. If its overlap type
			// is OVERLAP_TYPE_MUST_OVERLAP_SHIFT, then add it to the map
<span class="nc bnc" id="L4303" title="All 2 branches missed.">			for (Object obj: events) {</span>
<span class="nc" id="L4304">				PlannedEvent plannedEvent = (PlannedEvent) obj;</span>

<span class="nc" id="L4306">				long eventStart = 0, eventEnd = 0;</span>
<span class="nc" id="L4307">				int eventType = plannedEvent.getEventType();</span>
<span class="nc bnc" id="L4308" title="All 6 branches missed.">				if (eventType == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT || eventType == Event.EVENT_TYPE_TIME_OFF</span>
						|| eventType == Event.EVENT_TYPE_UNAVAILABILITY) {
<span class="nc" id="L4310">					CalendarEventAssignment event = (CalendarEventAssignment) obj;</span>
<span class="nc" id="L4311">					eventStart = event.getStartTime().getTime();</span>
<span class="nc" id="L4312">					eventEnd = event.getEndTime().getTime();</span>
<span class="nc bnc" id="L4313" title="All 2 branches missed.">				} else if (eventType == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L4314">					ShiftAssignment event = (ShiftAssignment) obj;</span>
<span class="nc bnc" id="L4315" title="All 2 branches missed.">					if (checkGap(event, bits, startingTime, resolution, limit)) {</span>
<span class="nc" id="L4316">						continue;</span>
					}
<span class="nc" id="L4318">                    eventStart = event.getStartTime().getTime();</span>
<span class="nc" id="L4319">					eventEnd = event.getEndTime().getTime();</span>
<span class="nc" id="L4320">				} else {</span>
<span class="nc" id="L4321">					throw new IllegalArgumentException();</span>
				}
				// Convert event to interval index range and set in map
<span class="nc" id="L4324">                addToBits(bits, eventStart, eventEnd, startingTime, resolution, limit, setEndBit);</span>
<span class="nc" id="L4325">			} // end for (Iterator it=events.iterator()...</span>
		} // end if (events != null)

		// At this point, the BitSet is built and we can build the TimeMap
<span class="nc" id="L4329">		return new TimeMap(bits, resolution, range.getStartDate(), range.getEndDate());</span>
	}

	/**
	 * Gets a collection of IDs for the employee names. If employeeNames is null, null is returned.
	 */
	public static Collection&lt;ID&gt; getIDs(Collection&lt;EmployeeName&gt; employeeNames) {
<span class="nc bnc" id="L4336" title="All 2 branches missed.">		if (employeeNames == null) {</span>
<span class="nc" id="L4337">			return null;</span>
		}
<span class="nc" id="L4339">		List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;(employeeNames.size());</span>
<span class="nc bnc" id="L4340" title="All 2 branches missed.">		for (EmployeeName name : employeeNames) {</span>
<span class="nc" id="L4341">			ids.add(name.getID());</span>
<span class="nc" id="L4342">		}</span>
<span class="nc" id="L4343">		return ids;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>