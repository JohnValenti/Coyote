<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MD5.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb</a> &gt; <span class="el_source">MD5.java</span></div><h1>MD5.java</h1><pre class="source lang-java linenums">/*
 * Created on Aug 13, 2003
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb;

/**
 * @author rrajendran
 *
 * To change this generated comment go to 
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
import java.io.IOException;

// This class computes MD5 hashes.
// Manually translated by Jon Howell &lt;jonh@cs.dartmouth.edu&gt;
// from some public domain C code (md5.c) included with the ssh-1.2.22 source.
// Tue Jan 19 15:55:50 EST 1999
// $Id: MD5.java,v 1.3 1999/01/19 21:30:11 jonh Exp jonh $
//
// To compute the message digest of a chunk of bytes, create an
// MD5 object 'md5', call md5.update() as needed on buffers full
// of bytes, and then call md5.md5final(), which
// will fill a supplied 16-byte array with the digest.
//
// A main() method is included that hashes the data on System.in.
//
// It seems to run around 25-30 times slower (JDK1.1.6) than optimized C
// (gcc -O4, version 2.7.2.3). Measured on a Sun Ultra 5 (SPARC 270MHz).
//
// Comments from md5.c from ssh-1.2.22, the basis for this code:
//
/* This code has been heavily hacked by Tatu Ylonen &lt;ylo@cs.hut.fi&gt; to
   make it compile on machines like Cray that don't have a 32 bit integer
   type. */
/*
 * This code implements the MD5 message-digest algorithm.
 * The algorithm is due to Ron Rivest.  This code was
 * written by Colin Plumb in 1993, no copyright is claimed.
 * This code is in the public domain; do with it what you wish.
 *
 * Equivalent code is available from RSA Data Security, Inc.
 * This code has been tested against that, and is equivalent,
 * except that you don't need to include two pages of legalese
 * with every copy.
 *
 * To compute the message digest of a chunk of bytes, declare an
 * MD5Context structure, pass it to MD5Init, call MD5Update as
 * needed on buffers full of bytes, and then call MD5Final, which
 * will fill a supplied 16-byte array with the digest.
 */

public class MD5 {
    int buf[];  // These were originally unsigned ints.
                // This Java code makes an effort to avoid sign traps.
                // buf[] is where the hash accumulates.
    long bits;  // This is the count of bits hashed so far.
    byte in[];  // This is a buffer where we stash bytes until we have
                // enough (64) to perform a transform operation.
    int inint[];
                // inint[] used and discarded inside transform(),
                // but why allocate it over and over?
                // (In the C version this is allocated on the stack.)

<span class="nc" id="L67">    public MD5() {</span>
<span class="nc" id="L68">        buf = new int[4];</span>
        // fill the hash accumulator with a seed value
<span class="nc" id="L70">        buf[0] = 0x67452301;</span>
<span class="nc" id="L71">        buf[1] = 0xefcdab89;</span>
<span class="nc" id="L72">        buf[2] = 0x98badcfe;</span>
<span class="nc" id="L73">        buf[3] = 0x10325476;</span>

        // initially, we've hashed zero bits
<span class="nc" id="L76">        bits = 0L;</span>

<span class="nc" id="L78">        in = new byte[64];</span>
<span class="nc" id="L79">        inint = new int[16];</span>
<span class="nc" id="L80">    }</span>

    public void update(byte[] newbuf) {
<span class="nc" id="L83">        update(newbuf, 0, newbuf.length);</span>
<span class="nc" id="L84">    }</span>

    public void update(byte[] newbuf, int length) {
<span class="nc" id="L87">        update(newbuf, 0, length);</span>
<span class="nc" id="L88">    }</span>

    public void update(byte[] newbuf, int bufstart, int buflen) {
        int t;
<span class="nc" id="L92">        int len = buflen;</span>

        // shash old bits value for the &quot;Bytes already in&quot; computation
        // just below.
<span class="nc" id="L96">        t = (int) bits; // (int) cast should just drop high bits, I hope</span>

        /* update bitcount */
        /* the C code used two 32-bit ints separately, and carefully
         * ensured that the carry carried.
         * Java has a 64-bit long, which is just what the code really wants.
         */
<span class="nc" id="L103">        bits += (long)(len&lt;&lt;3);</span>

<span class="nc" id="L105">        t = (t &gt;&gt;&gt; 3) &amp; 0x3f;   /* Bytes already in this-&gt;in */</span>

        /* Handle any leading odd-sized chunks */
        /* (that is, any left-over chunk left by last update() */

<span class="nc bnc" id="L110" title="All 2 branches missed.">        if (t!=0) {</span>
<span class="nc" id="L111">            int p = t;</span>
<span class="nc" id="L112">            t = 64 - t;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (len &lt; t) {</span>
<span class="nc" id="L114">                System.arraycopy(newbuf, bufstart, in, p, len);</span>
<span class="nc" id="L115">                return;</span>
            }
<span class="nc" id="L117">            System.arraycopy(newbuf, bufstart, in, p, t);</span>
<span class="nc" id="L118">            transform();</span>
<span class="nc" id="L119">            bufstart += t;</span>
<span class="nc" id="L120">            len -= t;</span>
        }

        /* Process data in 64-byte chunks */
<span class="nc bnc" id="L124" title="All 2 branches missed.">        while (len &gt;= 64) {</span>
<span class="nc" id="L125">            System.arraycopy(newbuf, bufstart, in, 0, 64);</span>
<span class="nc" id="L126">            transform();</span>
<span class="nc" id="L127">            bufstart += 64;</span>
<span class="nc" id="L128">            len -= 64;</span>
        }

        /* Handle any remaining bytes of data. */
        /* that is, stash them for the next update(). */
<span class="nc" id="L133">        System.arraycopy(newbuf, bufstart, in, 0, len);</span>
<span class="nc" id="L134">    }</span>

    /*
     * Final wrapup - pad to 64-byte boundary with the bit pattern
     * 1 0* (64-bit count of bits processed, MSB-first)
     */
    public void md5final(byte[] digest) {
        /* &quot;final&quot; is a poor method name in Java. :v) */
        int count;
        int p;      // in original code, this is a pointer; in this java code
                    // it's an index into the array this-&gt;in.

        /* Compute number of bytes mod 64 */
<span class="nc" id="L147">        count = (int) ((bits &gt;&gt;&gt; 3) &amp; 0x3F);</span>
    
        /* Set the first char of padding to 0x80.  This is safe since there is
           always at least one byte free */
<span class="nc" id="L151">        p = count;</span>
<span class="nc" id="L152">        in[p++] = (byte) 0x80;</span>
    
        /* Bytes of padding needed to make 64 bytes */
<span class="nc" id="L155">        count = 64 - 1 - count;</span>
    
        /* Pad out to 56 mod 64 */
<span class="nc bnc" id="L158" title="All 2 branches missed.">        if (count &lt; 8) {</span>
            /* Two lots of padding:  Pad the first block to 64 bytes */
<span class="nc" id="L160">            zeroByteArray(in, p, count);</span>
<span class="nc" id="L161">            transform();</span>
        
            /* Now fill the next block with 56 bytes */
<span class="nc" id="L164">            zeroByteArray(in, 0, 56);</span>
        } else {
            /* Pad block to 56 bytes */
<span class="nc" id="L167">            zeroByteArray(in, p, count - 8);</span>
        }
    
        /* Append length in bits and transform */
        // Could use a PUT_64BIT... func here. This is a fairly
        // direct translation from the C code, where bits was an array
        // of two 32-bit ints.
<span class="nc" id="L174">        int lowbits =   (int) bits;</span>
<span class="nc" id="L175">        int highbits =  (int) (bits &gt;&gt;&gt; 32);</span>
<span class="nc" id="L176">        PUT_32BIT_LSB_FIRST(in, 56, lowbits);</span>
<span class="nc" id="L177">        PUT_32BIT_LSB_FIRST(in, 60, highbits);</span>
    
<span class="nc" id="L179">        transform();</span>
<span class="nc" id="L180">        PUT_32BIT_LSB_FIRST(digest,  0, buf[0]);</span>
<span class="nc" id="L181">        PUT_32BIT_LSB_FIRST(digest,  4, buf[1]);</span>
<span class="nc" id="L182">        PUT_32BIT_LSB_FIRST(digest,  8, buf[2]);</span>
<span class="nc" id="L183">        PUT_32BIT_LSB_FIRST(digest, 12, buf[3]);</span>

        /* zero sensitive data */
        /* notice this misses any sneaking out on the stack. The C
         * version uses registers in some spots, perhaps because
         * they care about this.
         */
<span class="nc" id="L190">        zeroByteArray(in);</span>
<span class="nc" id="L191">        zeroIntArray(buf);</span>
<span class="nc" id="L192">        bits = 0;</span>
<span class="nc" id="L193">        zeroIntArray(inint);</span>
<span class="nc" id="L194">    }</span>

    public static void main(String args[]) {
        // This main() method was created to easily test
        // this class. It hashes whatever's on System.in.

<span class="nc" id="L200">        byte buf[] = new byte[397];</span>
            // arbitrary buffer length designed to irritate update()
        int rc;
<span class="nc" id="L203">        MD5 md = new MD5();</span>
<span class="nc" id="L204">        byte out[] = new byte[16];</span>
        int i;
<span class="nc" id="L206">        int len = 0;</span>

        try {
<span class="nc bnc" id="L209" title="All 2 branches missed.">            while ((rc = System.in.read(buf, 0, 397)) &gt; 0) {</span>
<span class="nc" id="L210">                md.update(buf, rc);</span>
<span class="nc" id="L211">                len += rc;</span>
            }
<span class="nc" id="L213">        } catch (IOException ex) {</span>
<span class="nc" id="L214">            ex.printStackTrace();</span>
<span class="nc" id="L215">            return;</span>
<span class="nc" id="L216">        }</span>
<span class="nc" id="L217">        md.md5final(out);</span>

<span class="nc" id="L219">        System.out.println(&quot;file length: &quot;+len);</span>
<span class="nc" id="L220">        System.out.println(&quot;hash: &quot;+dumpBytes(out));</span>
<span class="nc" id="L221">    }</span>


    /////////////////////////////////////////////////////////////////////
    // Below here ye will only finde private functions                 //
    /////////////////////////////////////////////////////////////////////

    // There must be a way to do these functions that's
    // built into Java, and I just haven't noticed it yet.

    private void zeroByteArray(byte[] a) {
<span class="nc" id="L232">        zeroByteArray(a, 0, a.length);</span>
<span class="nc" id="L233">    }</span>

    private void zeroByteArray(byte[] a, int start, int length) {
<span class="nc" id="L236">        setByteArray(a, (byte) 0, start, length);</span>
<span class="nc" id="L237">    }</span>

    private void setByteArray(byte[] a, byte val, int start, int length) {
        int i;
<span class="nc" id="L241">        int end = start+length;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        for (i=start; i&lt;end; i++) {</span>
<span class="nc" id="L243">            a[i] = val;</span>
        }
<span class="nc" id="L245">    }</span>

    private void zeroIntArray(int[] a) {
<span class="nc" id="L248">        zeroIntArray(a, 0, a.length);</span>
<span class="nc" id="L249">    }</span>

    private void zeroIntArray(int[] a, int start, int length) {
<span class="nc" id="L252">        setIntArray(a, (int) 0, start, length);</span>
<span class="nc" id="L253">    }</span>

    private void setIntArray(int[] a, int val, int start, int length) {
        int i;
<span class="nc" id="L257">        int end = start+length;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">        for (i=start; i&lt;end; i++) {</span>
<span class="nc" id="L259">            a[i] = val;</span>
        }
<span class="nc" id="L261">    }</span>

    // In the C version, a call to MD5STEP is a macro-in-a-macro.
    // In this Java version, we pass an Fcore object to represent the
    // inner macro, and the MD5STEP() method performs the work of
    // the outer macro. It would be good if this could all get
    // inlined, but it would take a pretty aggressive compiler to
    // inline away the dynamic method lookup made by MD5STEP to
    // get to the Fcore.f function.

<span class="nc" id="L271">    private abstract class Fcore {</span>
        abstract int f(int x, int y, int z);
    }
<span class="nc" id="L274">    private Fcore F1 = new Fcore() {</span>
<span class="nc" id="L275">        int f(int x, int y, int z) { return (z ^ (x &amp; (y ^ z))); }};</span>
<span class="nc" id="L276">    private Fcore F2 = new Fcore() {</span>
<span class="nc" id="L277">        int f(int x, int y, int z) { return (y ^ (z &amp; (x ^ y))); }};</span>
<span class="nc" id="L278">    private Fcore F3 = new Fcore() {</span>
<span class="nc" id="L279">        int f(int x, int y, int z) { return (x ^ y ^ z); }};</span>
<span class="nc" id="L280">    private Fcore F4 = new Fcore() {</span>
<span class="nc" id="L281">        int f(int x, int y, int z) { return (y ^ (x | ~z)); }};</span>

    private int MD5STEP(Fcore f, int w, int x, int y, int z, int data, int s) {
<span class="nc" id="L284">        w += f.f(x, y, z) + data;</span>
<span class="nc" id="L285">        w = w&lt;&lt;s | w&gt;&gt;&gt;(32-s);</span>
<span class="nc" id="L286">        w += x;</span>
<span class="nc" id="L287">        return w;</span>
    }

    private void transform() {
        /* load in[] byte array into an internal int array */
        int i;
<span class="nc" id="L293">        int[] inint = new int[16];</span>

<span class="nc bnc" id="L295" title="All 2 branches missed.">        for (i=0; i&lt;16; i++) {</span>
<span class="nc" id="L296">            inint[i] = GET_32BIT_LSB_FIRST(in, 4*i);</span>
        }

        int a, b, c, d;
<span class="nc" id="L300">        a = buf[0];</span>
<span class="nc" id="L301">        b = buf[1];</span>
<span class="nc" id="L302">        c = buf[2];</span>
<span class="nc" id="L303">        d = buf[3];</span>

<span class="nc" id="L305">        a = MD5STEP(F1, a, b, c, d, inint[0]    + 0xd76aa478, 7);</span>
<span class="nc" id="L306">        d = MD5STEP(F1, d, a, b, c, inint[1]    + 0xe8c7b756, 12);</span>
<span class="nc" id="L307">        c = MD5STEP(F1, c, d, a, b, inint[2]    + 0x242070db, 17);</span>
<span class="nc" id="L308">        b = MD5STEP(F1, b, c, d, a, inint[3]    + 0xc1bdceee, 22);</span>
<span class="nc" id="L309">        a = MD5STEP(F1, a, b, c, d, inint[4]    + 0xf57c0faf, 7);</span>
<span class="nc" id="L310">        d = MD5STEP(F1, d, a, b, c, inint[5]    + 0x4787c62a, 12);</span>
<span class="nc" id="L311">        c = MD5STEP(F1, c, d, a, b, inint[6]    + 0xa8304613, 17);</span>
<span class="nc" id="L312">        b = MD5STEP(F1, b, c, d, a, inint[7]    + 0xfd469501, 22);</span>
<span class="nc" id="L313">        a = MD5STEP(F1, a, b, c, d, inint[8]    + 0x698098d8, 7);</span>
<span class="nc" id="L314">        d = MD5STEP(F1, d, a, b, c, inint[9]    + 0x8b44f7af, 12);</span>
<span class="nc" id="L315">        c = MD5STEP(F1, c, d, a, b, inint[10]   + 0xffff5bb1, 17);</span>
<span class="nc" id="L316">        b = MD5STEP(F1, b, c, d, a, inint[11]   + 0x895cd7be, 22);</span>
<span class="nc" id="L317">        a = MD5STEP(F1, a, b, c, d, inint[12]   + 0x6b901122, 7);</span>
<span class="nc" id="L318">        d = MD5STEP(F1, d, a, b, c, inint[13]   + 0xfd987193, 12);</span>
<span class="nc" id="L319">        c = MD5STEP(F1, c, d, a, b, inint[14]   + 0xa679438e, 17);</span>
<span class="nc" id="L320">        b = MD5STEP(F1, b, c, d, a, inint[15]   + 0x49b40821, 22);</span>
    
<span class="nc" id="L322">        a = MD5STEP(F2, a, b, c, d, inint[1]    + 0xf61e2562, 5);</span>
<span class="nc" id="L323">        d = MD5STEP(F2, d, a, b, c, inint[6]    + 0xc040b340, 9);</span>
<span class="nc" id="L324">        c = MD5STEP(F2, c, d, a, b, inint[11]   + 0x265e5a51, 14);</span>
<span class="nc" id="L325">        b = MD5STEP(F2, b, c, d, a, inint[0]    + 0xe9b6c7aa, 20);</span>
<span class="nc" id="L326">        a = MD5STEP(F2, a, b, c, d, inint[5]    + 0xd62f105d, 5);</span>
<span class="nc" id="L327">        d = MD5STEP(F2, d, a, b, c, inint[10]   + 0x02441453, 9);</span>
<span class="nc" id="L328">        c = MD5STEP(F2, c, d, a, b, inint[15]   + 0xd8a1e681, 14);</span>
<span class="nc" id="L329">        b = MD5STEP(F2, b, c, d, a, inint[4]    + 0xe7d3fbc8, 20);</span>
<span class="nc" id="L330">        a = MD5STEP(F2, a, b, c, d, inint[9]    + 0x21e1cde6, 5);</span>
<span class="nc" id="L331">        d = MD5STEP(F2, d, a, b, c, inint[14]   + 0xc33707d6, 9);</span>
<span class="nc" id="L332">        c = MD5STEP(F2, c, d, a, b, inint[3]    + 0xf4d50d87, 14);</span>
<span class="nc" id="L333">        b = MD5STEP(F2, b, c, d, a, inint[8]    + 0x455a14ed, 20);</span>
<span class="nc" id="L334">        a = MD5STEP(F2, a, b, c, d, inint[13]   + 0xa9e3e905, 5);</span>
<span class="nc" id="L335">        d = MD5STEP(F2, d, a, b, c, inint[2]    + 0xfcefa3f8, 9);</span>
<span class="nc" id="L336">        c = MD5STEP(F2, c, d, a, b, inint[7]    + 0x676f02d9, 14);</span>
<span class="nc" id="L337">        b = MD5STEP(F2, b, c, d, a, inint[12]   + 0x8d2a4c8a, 20);</span>
    
<span class="nc" id="L339">        a = MD5STEP(F3, a, b, c, d, inint[5]    + 0xfffa3942, 4);</span>
<span class="nc" id="L340">        d = MD5STEP(F3, d, a, b, c, inint[8]    + 0x8771f681, 11);</span>
<span class="nc" id="L341">        c = MD5STEP(F3, c, d, a, b, inint[11]   + 0x6d9d6122, 16);</span>
<span class="nc" id="L342">        b = MD5STEP(F3, b, c, d, a, inint[14]   + 0xfde5380c, 23);</span>
<span class="nc" id="L343">        a = MD5STEP(F3, a, b, c, d, inint[1]    + 0xa4beea44, 4);</span>
<span class="nc" id="L344">        d = MD5STEP(F3, d, a, b, c, inint[4]    + 0x4bdecfa9, 11);</span>
<span class="nc" id="L345">        c = MD5STEP(F3, c, d, a, b, inint[7]    + 0xf6bb4b60, 16);</span>
<span class="nc" id="L346">        b = MD5STEP(F3, b, c, d, a, inint[10]   + 0xbebfbc70, 23);</span>
<span class="nc" id="L347">        a = MD5STEP(F3, a, b, c, d, inint[13]   + 0x289b7ec6, 4);</span>
<span class="nc" id="L348">        d = MD5STEP(F3, d, a, b, c, inint[0]    + 0xeaa127fa, 11);</span>
<span class="nc" id="L349">        c = MD5STEP(F3, c, d, a, b, inint[3]    + 0xd4ef3085, 16);</span>
<span class="nc" id="L350">        b = MD5STEP(F3, b, c, d, a, inint[6]    + 0x04881d05, 23);</span>
<span class="nc" id="L351">        a = MD5STEP(F3, a, b, c, d, inint[9]    + 0xd9d4d039, 4);</span>
<span class="nc" id="L352">        d = MD5STEP(F3, d, a, b, c, inint[12]   + 0xe6db99e5, 11);</span>
<span class="nc" id="L353">        c = MD5STEP(F3, c, d, a, b, inint[15]   + 0x1fa27cf8, 16);</span>
<span class="nc" id="L354">        b = MD5STEP(F3, b, c, d, a, inint[2]    + 0xc4ac5665, 23);</span>
    
<span class="nc" id="L356">        a = MD5STEP(F4, a, b, c, d, inint[0]    + 0xf4292244, 6);</span>
<span class="nc" id="L357">        d = MD5STEP(F4, d, a, b, c, inint[7]    + 0x432aff97, 10);</span>
<span class="nc" id="L358">        c = MD5STEP(F4, c, d, a, b, inint[14]   + 0xab9423a7, 15);</span>
<span class="nc" id="L359">        b = MD5STEP(F4, b, c, d, a, inint[5]    + 0xfc93a039, 21);</span>
<span class="nc" id="L360">        a = MD5STEP(F4, a, b, c, d, inint[12]   + 0x655b59c3, 6);</span>
<span class="nc" id="L361">        d = MD5STEP(F4, d, a, b, c, inint[3]    + 0x8f0ccc92, 10);</span>
<span class="nc" id="L362">        c = MD5STEP(F4, c, d, a, b, inint[10]   + 0xffeff47d, 15);</span>
<span class="nc" id="L363">        b = MD5STEP(F4, b, c, d, a, inint[1]    + 0x85845dd1, 21);</span>
<span class="nc" id="L364">        a = MD5STEP(F4, a, b, c, d, inint[8]    + 0x6fa87e4f, 6);</span>
<span class="nc" id="L365">        d = MD5STEP(F4, d, a, b, c, inint[15]   + 0xfe2ce6e0, 10);</span>
<span class="nc" id="L366">        c = MD5STEP(F4, c, d, a, b, inint[6]    + 0xa3014314, 15);</span>
<span class="nc" id="L367">        b = MD5STEP(F4, b, c, d, a, inint[13]   + 0x4e0811a1, 21);</span>
<span class="nc" id="L368">        a = MD5STEP(F4, a, b, c, d, inint[4]    + 0xf7537e82, 6);</span>
<span class="nc" id="L369">        d = MD5STEP(F4, d, a, b, c, inint[11]   + 0xbd3af235, 10);</span>
<span class="nc" id="L370">        c = MD5STEP(F4, c, d, a, b, inint[2]    + 0x2ad7d2bb, 15);</span>
<span class="nc" id="L371">        b = MD5STEP(F4, b, c, d, a, inint[9]    + 0xeb86d391, 21);</span>
    
<span class="nc" id="L373">        buf[0] += a;</span>
<span class="nc" id="L374">        buf[1] += b;</span>
<span class="nc" id="L375">        buf[2] += c;</span>
<span class="nc" id="L376">        buf[3] += d;</span>
<span class="nc" id="L377">    }</span>

    private int GET_32BIT_LSB_FIRST(byte[] b, int off) {
<span class="nc" id="L380">        return</span>
            ((int)(b[off+0]&amp;0xff)) |
            ((int)(b[off+1]&amp;0xff) &lt;&lt; 8) |
            ((int)(b[off+2]&amp;0xff) &lt;&lt; 16) |
            ((int)(b[off+3]&amp;0xff) &lt;&lt; 24);
    }

    private void PUT_32BIT_LSB_FIRST(byte[] b, int off, int value) {
<span class="nc" id="L388">        b[off+0] = (byte) (value        &amp; 0xff);</span>
<span class="nc" id="L389">        b[off+1] = (byte) ((value &gt;&gt; 8) &amp; 0xff);</span>
<span class="nc" id="L390">        b[off+2] = (byte) ((value &gt;&gt; 16)&amp; 0xff);</span>
<span class="nc" id="L391">        b[off+3] = (byte) ((value &gt;&gt; 24)&amp; 0xff);</span>
<span class="nc" id="L392">    }</span>

    // These are debug routines I was using while trying to
    // get this code to generate the same hashes as the C version.
    // (IIRC, all the errors were due to the absence of unsigned
    // ints in Java.)
    /*
    private void debugStatus(String m) {
        System.out.println(m+&quot;:&quot;);
        System.out.println(&quot;in: &quot;+dumpBytes(in));
        System.out.println(&quot;bits: &quot;+bits);
        System.out.println(&quot;buf: &quot;
            +Integer.toHexString(buf[0])+&quot; &quot;
            +Integer.toHexString(buf[1])+&quot; &quot;
            +Integer.toHexString(buf[2])+&quot; &quot;
            +Integer.toHexString(buf[3]));
    }
    */

    private static String dumpBytes(byte[] bytes) {
        int i;
<span class="nc" id="L413">        StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">        for (i=0; i&lt;bytes.length; i++) {</span>
<span class="nc bnc" id="L415" title="All 4 branches missed.">            if (i%32 == 0 &amp;&amp; i!=0) {</span>
<span class="nc" id="L416">                sb.append(&quot;\n&quot;);</span>
            }
<span class="nc" id="L418">            String s = Integer.toHexString(bytes[i]);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">            if (s.length() &lt; 2) {</span>
<span class="nc" id="L420">                s = &quot;0&quot;+s;</span>
            }
<span class="nc bnc" id="L422" title="All 2 branches missed.">            if (s.length() &gt; 2) {</span>
<span class="nc" id="L423">                s = s.substring(s.length()-2);</span>
            }
<span class="nc" id="L425">            sb.append(s);</span>
        }
<span class="nc" id="L427">        return sb.toString();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>