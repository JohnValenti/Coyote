<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOValidationCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.validation</a> &gt; <span class="el_source">TOValidationCache.java</span></div><h1>TOValidationCache.java</h1><pre class="source lang-java linenums">/*
 * TOValidationCache.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.validation;

import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculator;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculatorHelper;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffDefault;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.BlackoutDay;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

//TODO: all logging category objects, m_cat, must be private final

/**
 * Specialized validation cache for Time Off requests.
 */
public class TOValidationCache extends ValidationCache {
    /**
     * Logging category
     */
<span class="nc" id="L65">    private static final Category m_cat = Log.initCategory(TOValidationCache.class.getName());</span>

    /**
     * Key for time range represented by this request.
     */
    private static final String REQUEST_TIME_RANGE = &quot;REQUEST_TIME_RANGE&quot;;

    /**
     * Key for the collection of blackout days for this request period.
     */
    private static final String REQUEST_BLACKOUT_DAYS = &quot;REQUEST_BLACKOUT_DAYS&quot;;

    /**
     * Key for blackout days TimeMap covering the period of this request.
     */
    private static final String BLACKOUT_TIMEMAP = &quot;BLACKOUT_TIMEMAP&quot;;

    /**
     * Key for time off year month and day for this employee
     */
    private static final String EMP_TO_YEAR_MONTH_DAY = &quot;EMP_TO_YEAR_MONTH_DAY&quot;;

    /**
     * Key for time off length calculator that covers period of request
     */
    private static final String TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP =
            &quot;TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP&quot;;


    /**
     * Key for time off length calculator for a given employee and given time range.
     */
    private static final String TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID =
            &quot;TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID&quot;;

    /**
     * Key for default time off allotment (for day and week)
     */
    private static final String TIME_OFF_ALLOTMENT_MAP_DEFAULT =
            &quot;TIME_OFF_ALLOTMENT_MAP_DEFAULT&quot;;

    /**
     * Key for yearly time off allotment
     */
    private static final String TIME_OFF_ALLOTMENT_MAP_YEARLY =
            &quot;TIME_OFF_ALLOTMENT_MAP_YEARLY&quot;;

    /**
     * Key for the collection of published schedule periods covering the request interval
     */
    private static final String PUBLISHED_PERIODS = &quot;PUBLISHED_PERIODS&quot;;

    /**
     * Key for the collection of scheduled time off events during the request interval
     */
    //private static final String TIME_OFF_EVENTS = &quot;TIME_OFF_EVENTS&quot;;

    /**
     * Key prefix for the single time off event (unpublished) associated with the given TOChoice
     */
    private static final String CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED = &quot;CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED&quot;;

    /**
     * Key prefix for the single time off event (published) associated with the given TOChoice.
     */
    private static final String CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED = &quot;CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED&quot;;

    /**
     * Key for the collection of calendar time off day objects during the request interval
     */
    private static final String CALENDAR_TIME_OFF_DAYS = &quot;CALENDAR_TIME_OFF_DAYS&quot;;

    /**
     * Key for the collection of time off events for the employees in the organization during the request interval
     */
    private static final String ORG_TIME_OFF_EVENTS = &quot;ORG_TIME_OFF_EVENTS&quot;;

    /**
     * Key for the collection of  emp ids in the organization during the request interval
     */
    private static final String ORG_EMPIDS = &quot;ORG_EMPIDS&quot;;

    /**
     * Key for last published shift for employee owning TORequest
     */
    private static final String LAST_PUB_SHIFT_EMP = &quot;LAST_PUB_SHIFT_EMP&quot;;

    /**
     * Key for last unpublished shift for employee owning TORequest
     */
    //private static final String LAST_UNPUB_SHIFT_EMP = &quot;LAST_UNPUB_SHIFT_EMP&quot;;

    /**
     * Key for Manager's &quot;timeoff workflow active&quot; setting in the organization config.
     */
    public static final String MANAGER_TIMEOFF_WORKFLOWACTIVE = &quot;MANAGER_TIMEOFF_WORKFLOWACTIVE&quot;;

<span class="nc" id="L162">    protected static final Date MAX_DATE = new Date(Long.MAX_VALUE); // any date will be earlier</span>
<span class="nc" id="L163">    protected static final Date MIN_DATE = new Date(0L); // any date (after 1970) will be later</span>
    protected static final int MINUTES_PER_DAY = 60 * 24;

<span class="nc" id="L166">    private TORequest m_tor = null;</span>
	/**
	 * Key for storing post TO Approval Netstaffing Cube
	 */
	public static final String POST_TO_APPROVAL_NETSTAFFING_CUBE = &quot;POST_TO_APPROVAL_NETSTAFFING_CUBE&quot;;
	public static final String PRE_TO_APPROVAL_NETSTAFFING_CUBE = &quot;PRE_TO_APPROVAL_NETSTAFFING_CUBE&quot;;
	private static final String IS_STAFFING_DATA_AVAILABLE = &quot;IS_STAFFING_DATA_AVAILABLE&quot;;


    /**
     * Create a new validation cache for a time off request.
     */
    public TOValidationCache(TORequest tor) {
<span class="nc" id="L179">        super(tor);</span>
<span class="nc" id="L180">        m_tor = tor;</span>

<span class="nc" id="L182">        m_cat.debug(&quot;TOValidationCache created: &quot; + toString());</span>
<span class="nc" id="L183">    }</span>

    @Override
	public String toString() {
<span class="nc" id="L187">        return m_tor.toString();</span>
    }

    /**
     * Get the date range represented by the choices in the request.  The
     * range is defined to be from the earliest start time to the latest
     * end time of all the choices in the time off request.
     */
    @Override
	public TimeRange getDateRange() throws Exception {
<span class="nc" id="L197">        TimeRange result = null;</span>
<span class="nc" id="L198">        result = (TimeRange) get(REQUEST_TIME_RANGE);</span>

        // If range was in the cache, use it
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L202">            m_cat.debug(&quot;getDateRange: &quot; + result.getStartDate() + &quot; to &quot; + result.getEndDate());</span>
<span class="nc" id="L203">            return result;</span>
        }

        // Either one or both was not in the cache, recompute them.  It's as easy
        // to do both as to do one.
<span class="nc" id="L208">        Date strt = MAX_DATE, end = MIN_DATE;</span>
<span class="nc" id="L209">        Iterator it = m_tor.getRequestChoiceList().iterator();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L211">            TOChoice c = (TOChoice) it.next();</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">            if (c.getStartDate().before(strt)) {</span>
<span class="nc" id="L214">                strt = c.getStartDate();</span>
            }

<span class="nc bnc" id="L217" title="All 2 branches missed.">            if (c.getEndDate().after(end)) {</span>
<span class="nc" id="L218">                end = c.getEndDate();</span>
            }
<span class="nc" id="L220">        }</span>

        //  Something's wrong if we haven't tightened this up a bit...
<span class="nc bnc" id="L223" title="All 4 branches missed.">        if ((strt == MAX_DATE) || (end == MIN_DATE)) {</span>
<span class="nc" id="L224">            throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_VALUE2,</span>
<span class="nc" id="L225">                    new Long(strt.getTime()), new Long(end.getTime()), m_cat);</span>
        }

<span class="nc" id="L228">        result = new TimeRange(strt, end);</span>

<span class="nc" id="L230">        put(REQUEST_TIME_RANGE, result);</span>

<span class="nc" id="L232">        m_cat.debug(&quot;getDateRange: &quot; + result.getStartDate() + &quot; to &quot; + result.getEndDate());</span>

<span class="nc" id="L234">        return result;</span>
    }

    /**
     * Get number of minutes offset for the organization day boundary.
     */
    public int getOrgDayOffset() throws Exception {
<span class="nc" id="L241">        Organization org = getOrg();</span>

<span class="nc" id="L243">        return org.getDayBoundaryOffset();</span>
    }

    //TODO: Cache will become stale when undoing(revert to pending), denying or approving a
    // tentatively approved TO Request.
    public CalendarEventAssignment getCalEventAssignForTOChoiceAligned(TORequest toReq,
                                                                       TOChoice apprChoice, boolean published, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L250">        String methodName = &quot;getCalEventAssignForTOChoiceAligned&quot;;</span>
<span class="nc" id="L251">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, toReq, apprChoice, new Boolean(published), sam));</span>

<span class="nc" id="L253">        String key = RequestUtil.makeCacheKey(CALEVENTASSIGN_FOR_TOCHOICE_ALIGNED, toReq.getID(), apprChoice.getID(), new Boolean(published));</span>

<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (containsKey(key)) {</span>
<span class="nc" id="L256">            CalendarEventAssignment event = (CalendarEventAssignment) get(key);</span>
<span class="nc" id="L257">            m_cat.debug(RmUtil.dumpExitMethod(methodName, event));</span>
<span class="nc" id="L258">            return event;</span>
        }

        // fetch the event.
<span class="nc" id="L262">        CalendarEventAssignment event =</span>
<span class="nc" id="L263">                TORequestUtil.getCalEventAssignForTOChoiceAligned(toReq, apprChoice, published, sam);</span>

<span class="nc" id="L265">        put(key, event);</span>

<span class="nc" id="L267">        return event;</span>
    }

    //  TODO: Cache may get stale if cached event updated. see above.
    public Collection getCalEventAssignsForTOChoiceOverlapped(TORequest toReq,
                                                              TOChoice apprChoice, boolean published, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L273">        String methodName = &quot;getCalEventAssignsForTOChoiceOverlapped&quot;;</span>
<span class="nc" id="L274">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, toReq, apprChoice, new Boolean(published), sam));</span>

<span class="nc" id="L276">        String key = RequestUtil.makeCacheKey(CALEVENTASSIGNS_FOR_TOCHOICE_OVERLAPPED,</span>
<span class="nc" id="L277">                toReq.getID(), apprChoice.getID(), new Boolean(published));</span>

<span class="nc" id="L279">        Collection events = null;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (containsKey(key)) {</span>
<span class="nc" id="L281">            events = (Collection) get(key);</span>
        } else {
<span class="nc" id="L283">            events = TORequestUtil.getCalEventAssignsForTOChoiceOverlapped(toReq, apprChoice, published, sam);</span>

<span class="nc" id="L285">            put(key, events);</span>
        }

<span class="nc" id="L288">        return events;</span>
    }
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
         // For QA53725 (Silk 91831) - Request management page takes time to load
      // the below change provides feature to query the pub events for certain time range
      public Collection getOrgTimeoffEventsPub(TimeRange range,ArrayList  allotmentList) throws Exception {
          Date start = range.getStartDate();
          Date end = range.getEndDate();
          Collection empIDs =RmManagerFactory.getInstance().getTimeOffRequestManager().getEmployeesInOrganization(null, getOrgID(), true);
          Collection results = RmManagerFactory.getInstance().getTOHoursPerDayManager().
                  getHoursPerDayForCalendar(empIDs,    start,end   , allotmentList,true);
          return results;
      }*/
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
    public Collection getEmployeeIDsForOrg()throws Exception {
        Collection empIDs = (Collection) get(ORG_EMPIDS);
        if (empIDs==null) {
            empIDs =RmManagerFactory.getInstance().getTimeOffRequestManager().getEmpIDsInOrganization(getOrgID(), startDate, endDate);
            put(ORG_EMPIDS, empIDs);
        }
        return empIDs;
    }*/

    /**
     * Get a time off calculator for the request's time range and employee
     */
    public TimeOffLengthCalculator getTimeOffLengthCalculator() throws Exception {
<span class="nc" id="L315">        TimeOffLengthCalculator result = (TimeOffLengthCalculator) get(TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP);</span>

<span class="nc bnc" id="L317" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L318">            m_cat.debug(&quot;getTimeOffLengthCalculator: &quot; + result);</span>
<span class="nc" id="L319">            return result;</span>
        }

<span class="nc" id="L322">        ShiftAssignment lastShift = null;</span>
<span class="nc" id="L323">        ID empID = m_tor.getEmployeeID();</span>
        try {
<span class="nc" id="L325">            lastShift = getLastPublishedShiftAssignment();</span>
<span class="nc" id="L326">        } catch (BbmObjectNotFoundException e) {</span>
            //TESTME handling exception from getLastPublishedShift()
<span class="nc" id="L328">            m_cat.l7dInfo(RmEjbLogBundleKey.USING_DEFAULT_LAST_SHIFT_FOR_EMP, new Object[]{empID}, e);</span>
<span class="nc" id="L329">            lastShift = TOCalcUtil.getDefaultLastShift();</span>
<span class="nc" id="L330">        }</span>
<span class="nc" id="L331">        TimeRange calcRange = getDateRange();</span>
<span class="nc" id="L332">        Collection timeOffDuringPeriod = TimeOffLengthCalculatorHelper.getTimeOffPubDuringInt(empID, calcRange.getStartDate(), calcRange.getEndDate(), null);</span>
<span class="nc" id="L333">        Date terminationDate = TimeOffLengthCalculatorHelper.getEmployeeTerminationDate(empID);</span>
        
       
<span class="nc" id="L336">        result = TimeOffLengthCalculatorHelper.getCalculator(empID,</span>
<span class="nc" id="L337">                getOrg(), calcRange,</span>
<span class="nc" id="L338">                getShiftsPubDuringPeriod(),</span>
<span class="nc" id="L339">                getUnavailabilityEventsPubAndUnpubDuringPeriod(),</span>
                timeOffDuringPeriod,
<span class="nc" id="L341">                getHOOAssignmentsDuringPeriod(),</span>
<span class="nc" id="L342">                getHolidaysDuringPeriod(),</span>
<span class="nc" id="L343">                lastShift, getTimeOffDefaultAllotmentMap(), terminationDate );</span>
        
<span class="nc" id="L345">        put(TIME_OFF_LENGTH_CALCULATOR_FOR_REQEMP, result);</span>

<span class="nc" id="L347">        m_cat.debug(&quot;getTimeOffLengthCalculator: &quot; + result);</span>

<span class="nc" id="L349">        return result;</span>
    }
    /*TO CALC Performance Enhancement, Rel 7.8.1, Sameet, July 2007
         public TimeOffLengthCalculator getTimeOffLengthCalcForEmp(ID empID, Date rangeStart, Date rangeEnd)
             throws BbmFinderException {

         // For QA53725 (Silk 91831) - Request management page takes time to load
         // The cache checks only for time range and reuses the TO calculator of one emp to another. This is fixed by caching by emp Id also
             String key = RequestUtil.makeCacheKey(TIME_OFF_LENGTH_CALCULATOR_FOR_EMPID, empID, rangeStart, rangeEnd);

             // check if calculator already cached.
             TimeOffLengthCalculator toCalc = (TimeOffLengthCalculator) get(key);
             // if found in cache
             if (toCalc != null) {
                 m_cat.debug(getCacheHitMsg(key, toCalc));
                 return toCalc;
             }

             // create calculator
             toCalc = TimeOffLengthCalculatorHelper.getCalculator(empID,null, rangeStart, rangeEnd,null);

             // cache calculator.
             put(key, toCalc);

             // return calculator
             m_cat.debug(getCacheMissMsg(key, toCalc));
             return toCalc;
         }
      */
    /**
     * Get the time off allotment map for this employee.  Returns a map of 'TO activity ID'
     * to TO allotment data (weekly and daily default for this activityID).
     */
    public Map getTimeOffDefaultAllotmentMap() throws Exception {
<span class="nc" id="L383">        Map result = (Map) get(TIME_OFF_ALLOTMENT_MAP_DEFAULT);</span>

<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L386">            m_cat.debug(&quot;getTimeOffDefaultAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>
<span class="nc" id="L387">            return result;</span>
        }

<span class="nc" id="L390">        Employee emp = getEmployee(Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFDEFAULT);</span>
<span class="nc" id="L391">        result = new HashMap();</span>

<span class="nc bnc" id="L393" title="All 2 branches missed.">        for (Iterator it = emp.getTimeOffDefaults().iterator(); it.hasNext();) {</span>
<span class="nc" id="L394">            EmployeeTimeOffDefault toallot = (EmployeeTimeOffDefault) it.next();</span>
<span class="nc" id="L395">            result.put(toallot.getActivityID(), toallot);</span>
<span class="nc" id="L396">        }</span>

<span class="nc" id="L398">        put(TIME_OFF_ALLOTMENT_MAP_DEFAULT, result);</span>

<span class="nc" id="L400">        m_cat.debug(&quot;getTimeOffDefaultAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>

<span class="nc" id="L402">        return result;</span>
    }

    /**
     * Get the time off allotment map for this employee
     */
    public Map getTimeOffYearlyAllotmentMap() throws Exception {
<span class="nc" id="L409">        Map result = (Map) get(TIME_OFF_ALLOTMENT_MAP_YEARLY);</span>

<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (result != null) {</span>
<span class="nc" id="L412">            m_cat.debug(&quot;getTimeOffYearlyAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>
<span class="nc" id="L413">            return result;</span>
        }

<span class="nc" id="L416">        Employee emp = getEmployee(Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFYEARLY);</span>
<span class="nc" id="L417">        result = new HashMap();</span>

<span class="nc bnc" id="L419" title="All 2 branches missed.">        for (Iterator it = emp.getTimeOffYearlys().iterator(); it.hasNext();) {</span>
<span class="nc" id="L420">            EmployeeTimeOffYearly toallot = (EmployeeTimeOffYearly) it.next();</span>
<span class="nc" id="L421">            result.put(toallot.getActivityID().toString() + toallot.getCalendarYear(), toallot);</span>
<span class="nc" id="L422">        }</span>

<span class="nc" id="L424">        put(TIME_OFF_ALLOTMENT_MAP_YEARLY, result);</span>

<span class="nc" id="L426">        m_cat.debug(&quot;getTimeOffYearlyAllotmentMap: &quot; + RmUtil.dumpMap(result));</span>

<span class="nc" id="L428">        return result;</span>
    }

    /**
     * The date range for the returned CalendarTimeOffDay objects collection
     * will include the date range for the time off request.
     * &lt;p/&gt;
     * &lt;p&gt; For example if the date range for the TO request is:
     * Sun Dec 21 06:00:00 GMT 2003, ends at: Wed Dec 31 06:00:00 GMT 2003;
     * then the CalendarTimeOffDay VOs returned will span from
     * 12/21/2003 00:00:00.0 to 1/1/2004 00:00:00.0.  Note that the date field
     * for CalendarTimeOffDay is a {@link LocalDate LocalDate}
     * &lt;p/&gt;
     * Get the collection of CalendarTimeOffDay objects for the requested range.
     */

    /*
     public Collection getTOAllocationCalendarDays() throws Exception {
         Collection result = (Collection) get(CALENDAR_TIME_OFF_DAYS);

          if (result != null) {
               m_cat.debug(&quot;getCTOs: &quot; + RmUtil.dumpCollection(result));
              return result;
          }

         getTOAllocationCalendarDays(getDateRange());
         put(CALENDAR_TIME_OFF_DAYS, result);

          m_cat.debug(&quot;getCTOs: &quot; + RmUtil.dumpCollection(result));

         return result;

     } */
    // For QA53725 (Silk 91831) - Request management page takes time to load
    //TODO Caching of the data to be done
    public Collection getTOAllocationCalendarDays(TimeRange range) throws Exception {
<span class="nc" id="L464">        Organization org = getOrg();</span>
<span class="nc" id="L465">        TimeZone tz = org.getTimeZone();</span>
<span class="nc" id="L466">        Calendar cal = RequestUtil.getCalendarForDayStart(range.getStartDate(), tz);</span>
        // get allocation hours for start date -1 for day boundary orgs; Sameet Jan 2009, Bug fix for
        // QC 26396 ;[7.8.3 - TO]TO request for agent is auto deny, evenif organization still have enought TO available for request.
<span class="nc bnc" id="L469" title="All 2 branches missed.">        if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L470">            TOCalcUtil.addDaysToCalendar(cal, -1);</span>
        }
<span class="nc" id="L472">        LocalDate strt = new LocalDate(cal);</span>

<span class="nc" id="L474">        cal = RequestUtil.getCalendarForDayStart(range.getEndDate(), tz);</span>
<span class="nc" id="L475">        TOCalcUtil.addDaysToCalendar(cal, 1);</span>
        //cal.add(Calendar.DAY_OF_MONTH, 1); // Point to the following day
<span class="nc" id="L477">        LocalDate end = new LocalDate(cal);</span>
<span class="nc" id="L478">        return getTOAllocationCalendarDays(strt, end);</span>
    }

    private Collection getTOAllocationCalendarDays(LocalDate startDate, LocalDate endDate) throws Exception {
<span class="nc" id="L482">        CalendarTimeOffDayFacade ctodf = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc bnc" id="L483" title="All 2 branches missed.">        if (getTOPool() != null) {</span>
<span class="nc" id="L484">            return ctodf.getCalendarTimeOffDays(getTOPool().getID(), startDate, endDate, false);</span>
        } else {
<span class="nc" id="L486">            return Collections.EMPTY_LIST;</span>
        }
    }

    /**
     * Method declared 'private' to enforce the fact that a request can be associated with
     * multiple org IDs.  For this reason getOrgIDs() is exposed instead.
     *
     * @return
     */
    protected ID getOrgID() throws Exception {
<span class="nc" id="L497">        return (ID) getOrgIDs().iterator().next();</span>
    }

    public ShiftAssignment getLastPublishedShiftAssignment() throws Exception {
<span class="nc" id="L501">        ShiftAssignment lastShift = (ShiftAssignment) get(LAST_PUB_SHIFT_EMP);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">        if ((lastShift) == null) {</span>
<span class="nc" id="L503">            lastShift = TOCalcUtil.getLastShiftAssignment(m_tor.getEmployeeID(), true);</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">            if(lastShift==null){</span>
<span class="nc" id="L505">                m_cat.debug(TOCalcUtil.formatEjbBundleMsg(BbmEjbBundleKey.TOCALC_USING_DEFAULT_LAST_SHIFT_FOR_EMP, m_tor.getEmployeeID()));</span>
<span class="nc" id="L506">                lastShift = TOCalcUtil.getDefaultLastShift();</span>
            }
<span class="nc" id="L508">            put(LAST_PUB_SHIFT_EMP, lastShift);</span>
        }
<span class="nc" id="L510">        m_cat.debug(&quot;getLastPublishedShiftAssignment: &quot; + lastShift);</span>
<span class="nc" id="L511">        return lastShift;</span>
    }


    /**
     * Get a TimeMap for blackout days for the organization during
     * the request time range
     *
     * @return TimeMap (resolution=15 minutes) of shifts during request period
     *         which require a shift.
     */
    public TimeMap getBlackoutDaysTimeMap() throws Exception {
        // Check to see if its in the cache already
<span class="nc" id="L524">        TimeMap bdTimeMapForReqTimeRange = (TimeMap) get(BLACKOUT_TIMEMAP);</span>
        // If it is not in the cache, then get it
<span class="nc bnc" id="L526" title="All 2 branches missed.">        if (bdTimeMapForReqTimeRange == null) {</span>
<span class="nc" id="L527">            CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L528">            boolean orgBlktOutEnabled = TORequestUtil.isBlackOutDaySettingEnabledForOrg();</span>
            //set 1 minute resolution if Black out days are enabled for Org else set it to one hour
<span class="nc bnc" id="L530" title="All 2 branches missed.">            long resolution = orgBlktOutEnabled ? TimeMap.ONE_MINUTE : TimeMap.ONE_HOUR;</span>
<span class="nc" id="L531">            ID orgID = getOrgID();</span>
<span class="nc" id="L532">            Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L533">            TimeRange range = getDateRange();</span>
<span class="nc" id="L534">            TimeZone tz = org.getTimeZone();</span>
            // Get the collection of blackout days that fall within the request period
<span class="nc" id="L536">            LocalDate strt = new LocalDate(RequestUtil.getCalendarForDayStart(range.getStartDate(), tz));</span>
<span class="nc" id="L537">            Calendar cal = RequestUtil.getCalendarForDayStart(range.getEndDate(), tz);</span>
<span class="nc" id="L538">            TOCalcUtil.addDaysToCalendar(cal, 1);</span>
<span class="nc" id="L539">            LocalDate end = new LocalDate(cal);</span>
<span class="nc" id="L540">            Collection blackouts = toCalFacade.getBlackoutDays(getTOPool().getID(), strt, end);</span>

            // Build the TimeMap for blackouts. The time map will use a resolution of 1 hour, so we know how many bits we'll need
<span class="nc" id="L543">            Date reqTimeRangeStartDate = range.getStartDate();</span>
<span class="nc" id="L544">            Date reqTimeRangeEndDate = range.getEndDate();</span>
<span class="nc" id="L545">            bdTimeMapForReqTimeRange = new TimeMap(resolution, reqTimeRangeStartDate, reqTimeRangeEndDate);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">            if (blackouts != null) {</span>
                // Loop through the blackout days and build the map
<span class="nc bnc" id="L548" title="All 2 branches missed.">                for (Iterator it = blackouts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L549">                    BlackoutDay bd = (BlackoutDay) it.next();</span>
                    // The hours/minutes/seconds for the blackout day is always 00:00:00 (midnight).
                    // Get the start of the organization day on which blackout day falls,
                    // taking into account the organization's day offset.
                    //QC106371 changes starts
<span class="nc" id="L554">                    TimeRange timeRange = TOCalcUtil.getTimeRangeForOrgDay(org.getTimeZone(), org.getDayBoundaryOffset(), bd.getBlackoutLocalDate().getTime(org.getTimeZone())) ;</span>
<span class="nc" id="L555">                    Date bdStart = timeRange.getStartDate();</span>
<span class="nc" id="L556">                    Date bdEnd = timeRange.getEndDate();</span>
                    //QC106371 changes ends
                    // get overlap between req's time range and blackout date.
<span class="nc" id="L559">                    TimeRange overlapTimeRange = RequestUtil.getOverlapTimeRange(reqTimeRangeStartDate, reqTimeRangeEndDate, bdStart, bdEnd);</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">                    if (overlapTimeRange == null) continue;</span>
<span class="nc" id="L561">                    bdTimeMapForReqTimeRange.setRange(overlapTimeRange.getStartDate(), overlapTimeRange.getEndDate());</span>
<span class="nc" id="L562">                }</span>
            }
<span class="nc bnc" id="L564" title="All 2 branches missed.">            if (orgBlktOutEnabled) {</span>
<span class="nc" id="L565">                Collection cHolidays = BbmManagerFactory.getHolidayManager().getHolidays(orgID, strt, end, new int[]{Holiday.DAYTYPE_BLACKOUTDAY});</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">                if (cHolidays != null) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">                    for (Iterator h = cHolidays.iterator(); h.hasNext();) {</span>
<span class="nc" id="L568">                        Holiday blktDay = (Holiday) h.next();</span>
<span class="nc" id="L569">                        Date bdStart = blktDay.getStartDate().getTime(org.getTimeZone());</span>
<span class="nc" id="L570">                        Date bdEnd = blktDay.getEndDate().getTime(org.getTimeZone());</span>
<span class="nc" id="L571">                        TimeRange overlapTimeRange = RequestUtil.getOverlapTimeRange(reqTimeRangeStartDate, reqTimeRangeEndDate, bdStart, bdEnd);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">                        if (overlapTimeRange == null) continue;</span>
<span class="nc" id="L573">                        bdTimeMapForReqTimeRange.setRange(overlapTimeRange.getStartDate(), overlapTimeRange.getEndDate());</span>
<span class="nc" id="L574">                    }</span>
                }
            }

<span class="nc" id="L578">            m_cat.debug(getCacheMissMsg(BLACKOUT_TIMEMAP, bdTimeMapForReqTimeRange));</span>
<span class="nc" id="L579">            put(BLACKOUT_TIMEMAP, bdTimeMapForReqTimeRange);// Save in cache</span>
        }
<span class="nc" id="L581">        return bdTimeMapForReqTimeRange;</span>
    }


    /**
     * Get the collection of soft validations for this requst
     */
    @Override
	public Collection&lt;String&gt; getValidators() throws Exception {
<span class="nc" id="L590">        return super.getValidators(getOrgID(), Request.REQUESTTYPE_TIMEOFF, m_tor.getTimeOffType());</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache#getEmployeeID()
      */
    @Override
	public ID getEmployeeID() {
<span class="nc" id="L598">        return m_tor.getEmployeeID();</span>
    }

    /**
     * Get the published periods for this employee
     */
    
    //JT
	public Collection&lt;PublishingPeriod&gt; getPublishedPeriods() throws Exception {

<span class="nc" id="L608">		Collection&lt;PublishingPeriod&gt; result = (Collection) get(PUBLISHED_PERIODS);</span>

<span class="nc bnc" id="L610" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L611">			return result;</span>
		}

<span class="nc" id="L614">		ScheduleAccessManager sam = getScheduleAccessManager();</span>

<span class="nc" id="L616">		TimeRange range = getDateRange();</span>
<span class="nc" id="L617">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; listOfPublishedPeriods = sam.getPublishedPeriods(Collections.singleton(m_tor.getEmployeeID()),</span>
<span class="nc" id="L618">				range.getStartDate(), range.getEndDate());</span>

<span class="nc" id="L620">		result = (Collection&lt;PublishingPeriod&gt;) listOfPublishedPeriods.get(0);</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L622">			result = Collections.emptyList();</span>
		}

<span class="nc" id="L625">		put(PUBLISHED_PERIODS, result);</span>

<span class="nc" id="L627">		return result;</span>
	}
    


    public boolean getManagerTimeOffWorkflowActive() throws Exception {
<span class="nc" id="L633">        String methodName = &quot;getManagerTimeOffWorkflowActive: &quot;;</span>

<span class="nc" id="L635">        Boolean workflowActive = (Boolean) get(MANAGER_TIMEOFF_WORKFLOWACTIVE);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">        if (workflowActive != null) {</span>
<span class="nc" id="L637">            m_cat.debug(methodName + workflowActive);</span>
<span class="nc" id="L638">            return workflowActive.booleanValue();</span>
        }

<span class="nc" id="L641">        workflowActive = new Boolean(RequestUtil.getOrgSetting(getOrgID(), null).getManagerTimeOffWorkflowActive());</span>
<span class="nc" id="L642">        m_cat.debug(methodName + workflowActive);</span>

<span class="nc" id="L644">        put(MANAGER_TIMEOFF_WORKFLOWACTIVE, workflowActive);</span>

<span class="nc" id="L646">        return workflowActive.booleanValue();</span>
	}
	
	//v11.1 new validation and trace cube fix
	
	public HashMap getPostTOReqTraceCube(TORequest tor, TOChoice toc, TimeRange tr) throws Exception {
<span class="nc" id="L652">		String key = RequestUtil.makeCacheKey(RECALC_TRACECUBE, tor.getEmployeeID()+&quot;:&quot;+toc.getID()); //combined to choice id here todo</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
			//get shift assignments overlaps with this to choice. it could be more that one shift assignment, but the most a tochoice can be 7 days long

<span class="nc" id="L656">			Collection pubShifts= getPublishedShiftAssignments(tor, toc);</span>
			//for each shift assignment, find the sp linked to it, and adjust Qs
<span class="nc" id="L658">			ShiftAssignment sa = null;</span>
<span class="nc" id="L659">			Collection events = null;</span>
<span class="nc" id="L660">			HashMap traceCubesMap = new HashMap();</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">			for (Iterator i = pubShifts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L662">				sa = (ShiftAssignment)i.next();</span>
<span class="nc" id="L663">				events = getScheduleAccessManager().getPublishedEventsForWorkResource(tor.getEmployeeID(), sa.getStartTime(), sa.getEndTime());</span>
<span class="nc" id="L664">				traceCubesMap = getTimeSeriesManager().reCalcAdjustedFTEAndStaffing(traceCubesMap, tr, events, sa, true);</span>
			}
<span class="nc" id="L666">			put(key, traceCubesMap);</span>
		}
<span class="nc" id="L668">		return (HashMap) get(key);</span>
	}

	public Collection getPublishedShiftAssignments(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L672">		String key = RequestUtil.makeCacheKey(EVENT_TYPE_SHIFT_ASSIGNMENT, toc.getID());</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L674">			Collection pubShifts = getScheduleAccessManager().getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, tor.getEmployeeID(), toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L675">			put(key, pubShifts);</span>
		}
<span class="nc" id="L677">		return (Collection) get(key);</span>
	}

	/**
	 * returns a NetStaffingCube as it would look after the Time-Off apporval.
	 * this is used for validation of under staffing / overstaffing.
	 * IMP*** The Netsaffing cube is not a reflection of what is in the DB
	 *
	 * @param tor
	 * @param toc
	 * @return
	 * @throws Exception
	 */
	public NetStaffingCube getPostTOApprovalNetStaffingCube(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L691">		String key = RequestUtil.makeCacheKey(POST_TO_APPROVAL_NETSTAFFING_CUBE, tor.getEmployeeID() + &quot;:&quot; + toc.getID());</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L693">			TimeRange range = new TimeRange(toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L694">			ID empID = tor.getEmployeeID();</span>
<span class="nc" id="L695">			NetStaffingCube nsCube = getTimeSeriesManager().getNetStaffing(empID, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L696" title="All 4 branches missed.">			if (nsCube == null || nsCube.getPredictTraceCubeMap().isEmpty()) {				</span>
<span class="nc" id="L697">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: range=&quot; + range + &quot;\tnsCube=&quot; + nsCube );</span>
<span class="nc" id="L698">				return null;</span>
			}
			
			
			//TimeRange netStaffingRange = nsCube.getMaxLeastTimeInterval()==SPQueue.LEAST_TIME_INTERVAL_WEEKLY?nsCube.getTimeRange():range;
<span class="nc" id="L703">			HashMap traceCubesMap = getPostTOReqTraceCube(tor, toc, nsCube.getTimeRange());</span>
<span class="nc" id="L704">			getAdjustedNetStaffingCube( traceCubesMap, nsCube);</span>
<span class="nc bnc" id="L705" title="All 4 branches missed.">			if (nsCube == null || traceCubesMap == null) {</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: TO CHOICE=&quot; + toc</span>
				        + &quot;\tnsCube=&quot; + nsCube + &quot;\ttraceCubesMap=&quot; +
<span class="nc" id="L708">				        traceCubesMap != null ? &quot;&quot; + traceCubesMap.size() : &quot; null &quot;);</span>
			}
<span class="nc" id="L710">			put(key, nsCube);</span>
		}
<span class="nc" id="L712">		return (NetStaffingCube) get(key);</span>
	}

	/**
	 * returns a NetStaffingCube as it currently looks (before the Time-Off apporval).
	 * this is used for validation of under staffing / overstaffing.
	 * @param tor
	 * @param toc
	 * @return
	 * @throws Exception
	 */
	public NetStaffingCube getPreTOApprovalNetStaffingCube(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L724">		String key = RequestUtil.makeCacheKey(PRE_TO_APPROVAL_NETSTAFFING_CUBE, tor.getEmployeeID() + &quot;:&quot; + toc.getID());</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L726">			TimeRange range = new TimeRange(toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L727">			ID empID = tor.getEmployeeID();</span>
<span class="nc" id="L728">			NetStaffingCube nsCube = getTimeSeriesManager().getNetStaffing(empID, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">			if (nsCube == null) {</span>
<span class="nc" id="L730">				m_cat.error(&quot;No Queues Found that match the skill set of EMP: range=&quot; + range + &quot;\tnsCube=&quot; + nsCube );</span>
<span class="nc" id="L731">				return null;</span>
			}
<span class="nc" id="L733">			put(key, nsCube);</span>
		}
<span class="nc" id="L735">		return (NetStaffingCube) get(key);</span>
	}

	/**
	 * Checks if Forecasted staffing &amp; FTE exists for the given Cuast-Shift Request for the said employee
	 *
	 * @param csr
	 * @return
	 * @throws Exception
	 */
	public boolean doesStaffingExistForPeriod(TORequest tor, TOChoice toc) throws Exception {
<span class="nc" id="L746">		String key = RequestUtil.makeCacheKey(IS_STAFFING_DATA_AVAILABLE, toc.getID());</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">		if (!containsKey(key)) {</span>
<span class="nc" id="L748">			TimeSeriesManager tsm = WfmManagerFactory.getTimeSeriesManager();</span>
<span class="nc" id="L749">			TimeRange range = new TimeRange(toc.getStartDate(), toc.getEndDate());</span>
<span class="nc" id="L750">			boolean stafingExists = tsm.doesStaffingExistForPeriod(tor.getEmployeeID(), range.getStartDate(), range.getEndDate());</span>
<span class="nc" id="L751">			put(key, stafingExists);</span>
		}
<span class="nc" id="L753">		return ((Boolean) get(key)).booleanValue();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>