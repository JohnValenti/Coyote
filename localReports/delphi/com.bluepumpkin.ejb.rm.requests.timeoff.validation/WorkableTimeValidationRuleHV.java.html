<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkableTimeValidationRuleHV.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.validation</a> &gt; <span class="el_source">WorkableTimeValidationRuleHV.java</span></div><h1>WorkableTimeValidationRuleHV.java</h1><pre class="source lang-java linenums">/*
 * WorkableTimeValidationRule.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.validation;

import java.util.Iterator;

import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.util.RmUtil;

/**
 * Rule to validate that agent only requests time off when they could be
 * working.  The conflicts checked are:
 * &lt;p/&gt;
 * &lt;ul&gt;
 * &lt;li&gt;&lt;b&gt;hours of operation&lt;/b&gt; -- the request must include time that is
 * during the hours of operation for the organization the employee belongs
 * to during the requested interval.&lt;/li&gt;
 * &lt;p/&gt;
 * &lt;li&gt;&lt;b&gt;non-working holiday&lt;/b&gt; -- the request must include time that is
 * not during non-working (i.e. paid) holidays.&lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;li&gt;&lt;b&gt;TODO: not impelemented; must overlap calendar events&lt;/b&gt; --
 * the request must not include
 * any time when the employee has a calendar event assigned in the
 * published schedule which must overlap a shift assignment.&lt;/li&gt;
 * &lt;p/&gt;
 * &lt;li&gt;&lt;b&gt;scheduled time off&lt;/b&gt; -- none of the TOChoices are completely
 * contained within scheduled TOEvents &lt;/li&gt; 
 * Note in 15.1.0_120 Extract this logic to a new rule WorkableTimeWithinScheduleTimeOffHV.java
 * &lt;p/&gt;
 * &lt;li&gt;&lt;b&gt;Unavailabilities&lt;/b&gt; -- TO choice must not completely overlap
 * an unavailability event.
 * &lt;p/&gt;
 * &lt;li&gt;&lt;b&gt;shift overlap&lt;/b&gt; -- TO choice must not overlap a shift (only for dont-debit
 * requests which map to an unavailability event)
 * &lt;/ul&gt;
 * &lt;p/&gt;
 * &lt;p/&gt;
 * &lt;b&gt;debit, debit-if and dont-debit type handling: &lt;/b&gt;&lt;br&gt;
 * &lt;li&gt;Scheduled time off events validation: applies for debit, debit-if and dont-debit. &lt;br&gt;
 * &lt;li&gt;Unavailability events validation: applies for debit, debit-if and dont-debit &lt;br&gt;
 * &lt;li&gt;Hours of operation validation: applies for debit, debit-if and dont-debit. &lt;br&gt;
 * &lt;li&gt;Paid holidays validation: applies to debit, debit-if and dont-debit. &lt;br&gt;
 * &lt;li&gt;shift overlap validation: applies only to dont-debit.
 * &lt;p/&gt;
 * &lt;p/&gt;
 * &lt;b&gt;Tentative request handling: &lt;/b&gt;&lt;br&gt;
 * &lt;li&gt; Scheduled TO events validation - skipped, as event for request already created in un-published schedule and this
 * validation is intended to be performed before event creation.
 * &lt;li&gt; Unavailability events validation -  skipped, as event for request already created in un-published schedule and this
 * validation is intended to be performed before event creation.
 */
<span class="nc" id="L65">public class WorkableTimeValidationRuleHV implements Validator {</span>

<span class="nc" id="L67">	public static final String m_className = WorkableTimeValidationRuleHV.class.getName();</span>

<span class="nc" id="L69">	private static Category m_cat = Log.initCategory(m_className);</span>

	/**
	 * Validate a time off request.  Ensure that the request is for time off
	 * when the employee might be working.
	 */
	@Override
	public ValidationResult validate(Validatable validatable) throws Exception {
<span class="nc" id="L77">		String methodName = &quot;validate&quot;;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L79">			m_cat.debug(RmUtil.dumpEnterMethod(methodName, validatable));</span>
		}

<span class="nc" id="L82">		TORequest tor = (TORequest) validatable;</span>
<span class="nc" id="L83">		TOChoice validationChoice = tor.getTOChoiceForValidation();</span>
		// Check against the hours of operation for the employee's organization
		// in the date range
<span class="nc" id="L86">		ValidationResult result = checkHoursOfOperation(tor, validationChoice);</span>

		// Check against the non-working holidays for the employee's org
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L90">			result = checkNonWorkingHolidays(tor, validationChoice);</span>
		}

		// Check for unavailability events.  The TOChoice cannot be contained
		// within an unavailability event.
<span class="nc bnc" id="L95" title="All 4 branches missed.">		if (result == null &amp;&amp; !tor.isTentative()) {</span>
<span class="nc" id="L96">			result = checkUnavailabilityEvents(tor, validationChoice);</span>
		}

		/* Check that the request includes time that is not already scheduled
		// as time off -Extract this logic to a new validation rule WorkableTimeWithinScheduleTimeOffHV.java 
		if (result == null &amp;&amp; !tor.isTentative())
			result = checkScheduledTimeOff(tor, validationChoice);
		 */

		// For TORequest of type &quot;don't debit&quot; (which maps to an unavailability event), check that
		// the request does not overlap any shifts.
<span class="nc bnc" id="L107" title="All 4 branches missed.">		if (result == null &amp;&amp; tor.isUnavailability()) {</span>
<span class="nc" id="L108">			result = checkShiftOverlap(tor, validationChoice);</span>
		}

<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L112">			m_cat.debug(RmUtil.dumpExitMethod(methodName, result));</span>
		}

<span class="nc" id="L115">		return result;</span>
	}

	/**
	 * Check the choices in the time off request against scheduled unavailability events.
	 */
	protected ValidationResult checkUnavailabilityEvents(TORequest tor, TOChoice validationChoice) throws Exception {
<span class="nc" id="L122">		ValidationResult result = null;</span>
		// Check to see if already in the cache
		//this method is redundant; this check is not reqd. it is unnecessarily loading the system. 
<span class="nc" id="L125">		TimeMap unavailsTimeMap = null;//tor.getCache().getUnavailabilityEventsPubAndUnpubTimeMap();</span>
		if (true) {
<span class="nc" id="L127">			return null; //bypass this check; it is irrelvant. the TOchoice will already be flagged by zero duration flag</span>
		}

		// clear the range of bits for the unavailability event created by tentative approval.
		/*if ( tor.isTentative() &amp;&amp; tor.isUnavailability() ) {
		  TOChoice tentApprChoice = tor.getApprovedChoice();
		}*/

		// Loop through the choices and check that each one contains some time that
		// is not marked as unavailable

		for (Iterator it = tor.getRequestChoiceList().iterator(); it.hasNext();) {
			TOChoice c = (TOChoice) it.next();
			if (validationChoice != null &amp;&amp; !validationChoice.equals(c)) {
				continue; //Validator should validate the Validation Choice only and skip all other choices.
			}
			if (unavailsTimeMap.onBitsContainRange(c.getStartDate(), c.getEndDate())) {
				// The given range is entirely within an unavailability event. Validation fails
				result = ValidationUtil.setHardValidationResult(c, RmEjbBundleKey.TO_TIME_MARKED_UNAVAILABLE, tor.getCache()
						.getEmployeeNameByID(), c.getStartDate(), c.getEndDate(), m_className);

				return result;
			}
		} // end while (it.hasNext())

		return result;
	}

	/**
	 * Check the choices in the time off request against the non-working
	 * holidays specified for the organization.
	 */
	protected ValidationResult checkNonWorkingHolidays(TORequest tor, TOChoice validationChoice) throws Exception {
<span class="nc" id="L160">		ValidationResult result = null;</span>

<span class="nc" id="L162">		TimeMap paidHoldiaysTimeMap = getHolidaysNonWorkingTimeMap(tor);</span>

		// Loop through the choices and check that each one contains some
		// time that is not part of a non-working holiday

<span class="nc bnc" id="L167" title="All 2 branches missed.">		for (Iterator&lt;TOChoice&gt; it = tor.getRequestChoiceList().iterator(); it.hasNext();) {</span>
<span class="nc" id="L168">			TOChoice c = (TOChoice) it.next();</span>
<span class="nc bnc" id="L169" title="All 4 branches missed.">			if (validationChoice != null &amp;&amp; !validationChoice.equals(c)) {</span>
<span class="nc" id="L170">				continue; //Validator should validate the Validation Choice only and skip all other choices.</span>
			}
<span class="nc bnc" id="L172" title="All 2 branches missed.">			if (paidHoldiaysTimeMap.onBitsContainRange(c.getStartDate(), c.getEndDate())) {</span>
				// The given range is completely contained with one day blocks of
				// time that are non-working holidays.  Validation fails
<span class="nc" id="L175">				result = ValidationUtil.setHardValidationResult(c, RmEjbBundleKey.TO_CONTAINED_IN_NWH,</span>
<span class="nc" id="L176">						tor.getCache().getEmployeeNameByID(), c.getStartDate(), c.getEndDate(), tor.getCache().getOrgNameForMsg(),</span>
						m_className);

<span class="nc" id="L179">				return result;</span>
			}
<span class="nc" id="L181">		} // end while (it.hasNext())</span>

<span class="nc" id="L183">		return result;</span>
	}

	/**
	 * Check the choices in the time off request against the hours of
	 * operation.  Each choice must include some time that is during
	 * hours of operation for the organization
	 */
	protected ValidationResult checkHoursOfOperation(TORequest tor, TOChoice validationChoice) throws Exception {
<span class="nc" id="L192">		ValidationResult result = null;</span>
<span class="nc" id="L193">		TimeMap hooTm = getHOOAssignmentsTimeMap(tor);</span>

		// Loop through the choices and check that each one contains some
		// time that is in the hours of operation
<span class="nc bnc" id="L197" title="All 2 branches missed.">		for (Iterator it = tor.getRequestChoiceList().iterator(); it.hasNext();) {</span>
<span class="nc" id="L198">			TOChoice c = (TOChoice) it.next();</span>
<span class="nc bnc" id="L199" title="All 4 branches missed.">			if (validationChoice != null &amp;&amp; !validationChoice.equals(c)) {</span>
<span class="nc" id="L200">				continue; //Validator should validate the Validation Choice only and skip all other choices.</span>
			}
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (!hooTm.onBitsOverlapRange(c.getStartDate(), c.getEndDate())) {</span>
				// The given range includes no 15 minute intervals that are
				// part of the hours of operation.  Validation fails
<span class="nc" id="L205">				result = ValidationUtil.setHardValidationResult(c, RmEjbBundleKey.TO_DOES_NOT_CONTAIN_HOO,</span>
<span class="nc" id="L206">						getEmployeeNameByID(tor), c.getStartDate(), c.getEndDate(), getOrgNameForMsg(tor), m_className);</span>
<span class="nc" id="L207">				return result;</span>
			}
<span class="nc" id="L209">		} // for(...)</span>

<span class="nc" id="L211">		return result;</span>
	}

	// TESTME
	protected ValidationResult checkShiftOverlap(TORequest tor, TOChoice validationChoice) throws Exception {
<span class="nc" id="L216">		ValidationResult result = null;</span>
<span class="nc" id="L217">		TimeMap unpubShiftsMap = getShiftsUnpubTimeMap(tor);</span>

		// Loop through the choices and check that each one contains some
		// time that is in the hours of operation
<span class="nc bnc" id="L221" title="All 2 branches missed.">		for (Iterator it = tor.getRequestChoiceList().iterator(); it.hasNext();) {</span>
<span class="nc" id="L222">			TOChoice c = (TOChoice) it.next();</span>
<span class="nc bnc" id="L223" title="All 4 branches missed.">			if (validationChoice != null &amp;&amp; !validationChoice.equals(c)) {</span>
<span class="nc" id="L224">				continue; //Validator should validate the Validation Choice only and skip all other choices.</span>
			}
<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (unpubShiftsMap.onBitsOverlapRange(c.getStartDate(), c.getEndDate())) {</span>
<span class="nc" id="L227">				result = ValidationUtil.setHardValidationResult(c, RmEjbBundleKey.TO_CHOICE_OVERLAPS_UNPUB_SHIFTS,</span>
<span class="nc" id="L228">						getEmployeeNameByID(tor), c.getStartDate(), c.getEndDate(), m_className);</span>

<span class="nc" id="L230">				return result;</span>
			}
<span class="nc" id="L232">		} // for(...)</span>

<span class="nc" id="L234">		return result;</span>
	}

	protected TimeMap getHOOAssignmentsTimeMap(TORequest tor) throws Exception {
<span class="nc" id="L238">    	return tor.getCache().getHOOAssignmentsTimeMap();</span>
    }
    
	protected String getOrgNameForMsg(TORequest tor) throws Exception {
<span class="nc" id="L242">    	return tor.getCache().getOrgNameForMsg();</span>
    }

	protected String getEmployeeNameByID(TORequest tor) throws Exception {
<span class="nc" id="L246">		return tor.getCache().getEmployeeNameByID();</span>
	}

	protected TimeMap getHolidaysNonWorkingTimeMap(TORequest tor) throws Exception {
<span class="nc" id="L250">    	return tor.getCache().getHolidaysNonWorkingTimeMap();</span>
    }

	protected TimeMap getShiftsUnpubTimeMap(TORequest tor) throws Exception {
<span class="nc" id="L254">    	return tor.getCache().getShiftsUnpubTimeMap();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>