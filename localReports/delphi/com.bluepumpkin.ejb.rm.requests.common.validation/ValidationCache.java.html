<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ValidationCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.validation</a> &gt; <span class="el_source">ValidationCache.java</span></div><h1>ValidationCache.java</h1><pre class="source lang-java linenums">/*
 * ValidationCache.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.common.validation;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMinMaxHour;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * Cache computation results that can be used by multiple validators. This class
 * should be overridden by subclass that add type-specific lookups.
 */
public abstract class ValidationCache {
	private static final int INIT_MAPSIZE = 53;

	private static final String EMP_KEY_PREFIX = &quot;EmpID:&quot;;
	private static final String ORG_KEY_PREFIX = &quot;OrgID:&quot;;
	private static final String VALIDATORS_PREFIX = &quot;VALIDATORS:&quot;;
	private static final String EMPLOYEE_NAME = &quot;EMPLOYEENAME:&quot;;
	private static final String EMPID_ORGID_PREFIX = &quot;EMPID2ORGID:&quot;;
	private static final String EMPID2ORG = &quot;EMPID2ORG:&quot;;
	private static final String EMPID2ORGTZ = &quot;EMPID2ORGTZ:&quot;;

	private static final String HOLIDAYSDURINGPERIOD = &quot;HOLIDAYSDURINGPERIOD&quot;;

	/**
	 * Map of request's Employee ID to their organization ID during the
	 * request's time range.
	 */
	private static final String EMPID_TO_ORGID_MAP_FOR_PERIOD = &quot;EMPID_TO_ORGID_MAP_FOR_PERIOD&quot;;

	/**
	 * Key for the non-working holidays TimeMap covering the period of this
	 * request.
	 */
	private static final String NWH_TIMEMAP = &quot;NWH_TIMEMAP&quot;;

	/**
	 * Key for the Hours of Operation TimeMap covering the period of this
	 * request.
	 */
	private static final String HOO_TIMEMAP = &quot;HOO_TIMEMAP&quot;;

	/**
	 * Key for the Hours of Operation objects covering the period of this
	 * request.
	 */
	private static final String REQUEST_HOOS = &quot;REQUEST_HOOS&quot;;

	/**
	 * Key for the collection of ids for the employees in the organization
	 * during the request interval
	 */
	private static final String ORG_EMPLOYEE_IDS = &quot;ORG_EMPLOYEE_IDS&quot;;

	/**
	 * Key for organization IDs that request's employee belong to during the
	 * request's time range.
	 */
	private static final String ORGIDS_FOR_REQ = &quot;ORGIDS_FOR_REQ&quot;;

	/**
	 * Key for TOPOOL ID that request's employee belongs to on the request start
	 * date.
	 */
	private static final String TOPOOL_FOR_REQ = &quot;TOPOOL_FOR_REQ&quot;;
	/**
	 * Key for published calendar events during this request
	 */
	private static final String REQUEST_CALENDAR_EVENTS = &quot;REQUEST_CALENDEAR_EVENTS&quot;;

	/**
	 * Key for the published calendar events TimeMap covering the period of this
	 * request.
	 */
	private static final String REQUEST_CALEVT_PUB_TIMEMAP = &quot;CALEVT_PUB_TIMEMAP&quot;;

	/**
	 * Key for the unpublished calendar events TimeMap covering the period of
	 * this request.
	 */
	private static final String REQUEST_CALEVT_UNPUB_TIMEMAP = &quot;CALEVT_UNPUB_TIMEMAP&quot;;

	/**
	 * Key for the unpublished calendar events TimeMap covering the period of
	 * this request.
	 */
	private static final String REQUEST_CALEVT_MUSTOVERLAP_UNPUB_TIMEMAP = &quot;CALEVT_MUSTOVERLAP_UNPUB_TIMEMAP&quot;;

	/**
	 * Key for scheduled time off events for employee during period.
	 */
	private static final String REQUEST_TIMEOFF_EVENTS_PUB_AND_UNPUB = &quot;REQUEST_TIMEOFF_EVENTS_PUB_AND_UNPUB&quot;;

	/**
	 * Key for scheduled time off events for employee during period.
	 */
	private static final String REQUEST_TIMEOFF_EVENTS_PUB = &quot;REQUEST_TIMEOFF_EVENTS_PUB&quot;;

	/**
	 * cache key for published timeoff events for an empid and time range.
	 */
	private static final String TIMEOFF_EVENTS_PUB_FOR_EMPID_RANGE = &quot;TIMEOFF_EVENTS_PUB_FOR_EMPID_RANGE&quot;;
	/**
	 * Key for scheduled timeoff TimeMap covering the period of this request.
	 */
	private static final String SCHEDTO_TIMEMAP = &quot;SCHEDTO_TIMEMAP&quot;;

	/**
	 * Key for scheduled unavailability TimeMap covering the period of this
	 * request.
	 */
	private static final String SCHEDULED_UNAVAIL_TIMEMAP = &quot;SCHEDULED_UNAVAIL_TIMEMAP&quot;;

	/**
	 * Key for scheduled unavailability events during the period of this
	 * request.
	 */
	private static final String REQUEST_UNAVAIL_EVENTS = &quot;REQUEST_UNAVAIL_EVENTS&quot;;

	/**
	 * Key for the shift (published) during the request period
	 */
	private static final String REQUEST_PUB_SHIFTS = &quot;REQUEST_PUB_SHIFTS&quot;;

	/**
	 * Key for the shifts (unpublished) during the request period
	 */
	private static final String REQUEST_UNPUB_SHIFTS = &quot;REQUEST_UNPUB_SHIFTS&quot;;

	/**
	 * Key for shifts (unpublished) TimeMap covering the period of this request.
	 */
	private static final String SCHEDULED_SHIFT_UNPUB_TIMEMAP = &quot;SCHEDULED_SHIFT_UNPUB_TIMEMAP&quot;;

	/**
	 * Key for shifts (published) TimeMap covering the period of this request.
	 */
	private static final String SCHEDULED_SHIFT_PUB_TIMEMAP = &quot;SCHEDULED_SHIFT_PUB_TIMEMAP&quot;;

	/**
	 * Key for the filing rule checker for this request.
	 */
	private static final String FILING_RULE_CHECKER = &quot;FILING_RULE_CHECKER&quot;;

	/**
	 * key for caching the organization setting.
	 */
	private static final String ORGSETTING_FOR_ORGID = &quot;ORGSETTING_FOR_ORGID&quot;;

	protected static final int MINUTES_PER_DAY = 60 * 24;

	protected static final String RECALC_TRACECUBE = &quot;RECALC_TRACECUBE&quot;;
	protected static final String EVENT_TYPE_SHIFT_ASSIGNMENT = &quot;EVENT_TYPE_SHIFT_ASSIGNMENT&quot;;

	/**
	 * key for caching the WorkResourceMinMaxHour object for the request's
	 * employee at the request's (or TOChoice's, if a TO request) start time.
	 */
	private static final String WORKRESOURCE_MIN_MAX_HOURS = &quot;WORKRESOURCE_MIN_MAX_HOURS&quot;;

	/**
	 * key for caching the TraceOperator.aggregatePeriodD() result for a
	 * particular queue, statistic, and date range.
	 */
	private static final String TRACECUBE_AGGREGATION = &quot;TRACECUBE_AGGREGATION&quot;;

	/**
	 * logging category.
	 */
<span class="nc" id="L225">	private static Category m_cat = Log.initCategory(ValidationCache.class.getName());</span>

<span class="nc" id="L227">	private Map m_map = null;</span>

	private final RequestAggregate m_reqAgg;

<span class="nc" id="L231">	protected ValidationCache(RequestAggregate reqAgg) {</span>
<span class="nc" id="L232">		m_reqAgg = reqAgg;</span>
<span class="nc" id="L233">	}</span>

	/**
	 * Get data from map by key
	 * 
	 * @param key
	 *            the key of the item to obtain
	 * @return the item or null if it hasn't been added to the map yet
	 */
	protected Object get(String key) {
<span class="nc" id="L243">		Map map = getMap();</span>
<span class="nc" id="L244">		return map.get(key);</span>
	}

	/**
	 * Set data into map by key
	 * 
	 * @param key
	 *            the key of the item
	 * @param value
	 *            the value to save at key
	 */
	protected void put(String key, Object value) {
<span class="nc" id="L256">		Map map = getMap();</span>
<span class="nc" id="L257">		map.put(key, value);</span>
<span class="nc" id="L258">	}</span>

	/**
	 * Remove data out of the map by key
	 * 
	 * @param key
	 *            the key of the item
	 */
	protected void remove(String key) {
<span class="nc" id="L267">		Map map = getMap();</span>
<span class="nc" id="L268">		map.remove(key);</span>
<span class="nc" id="L269">	}</span>

	/**
	 * @param keyName
	 * @param obj1
	 * @return
	 */
	protected Object getCacheHitMsg(String keyName, Object obj1) {
<span class="nc" id="L277">		return &quot;Cache Hit: &quot; + m_reqAgg.getID() + &quot;: &quot; + keyName + &quot;: &quot; + obj1;</span>
	}

	/**
	 * @param keyName
	 * @param obj1
	 * @return
	 */
	protected Object getCacheMissMsg(String keyName, Object obj1) {
<span class="nc" id="L286">		return &quot;Cache Miss: &quot; + m_reqAgg.getID() + &quot;: &quot; + keyName + &quot;: &quot; + obj1;</span>
	}

	protected boolean containsKey(String key) {
<span class="nc" id="L290">		return getMap().containsKey(key);</span>
	}

	/**
	 * Get the data map
	 */
	private Map getMap() {
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (m_map == null) {</span>
<span class="nc" id="L298">			m_map = new HashMap(INIT_MAPSIZE);</span>
		}

<span class="nc" id="L301">		return m_map;</span>
	}

	/**
	 * @return
	 */
	public String getRequestType() {
<span class="nc" id="L308">		return m_reqAgg.getRequestType();</span>
	}

	/**
	 * Request sub type only applies to certain request type. For TORequests,
	 * request sub type is the activity ID for the time off.
	 *
	 * @return
	 */
	public ID getRequestSubType() {
<span class="nc" id="L318">		return m_reqAgg.getRequestSubType();</span>
	}

	// must be overridden by the derived classes to provide a list of
	// soft validators
	public abstract Collection&lt;String&gt; getValidators() throws Exception;

	public Collection&lt;String&gt; getValidators(ID orgID, String reqType) throws Exception {

<span class="nc" id="L327">		return getValidators(orgID, reqType, null);</span>
	}

	/**
	 * Get the collection of validation rules to run for this request. This is
	 * the list of enabled validation rules for the given organization and for
	 * the given request type.
	 *
	 * &lt;p&gt;
	 * Note that only autoProcessing rules and filingRules for an organization
	 * have an effectivity timeRange. Validation rules do not have this
	 * effectivity.
	 *
	 * @param orgID
	 *            the organization
	 * @param reqType
	 *            request type
	 * @return a collection of String objects. Each one is the fully qualified
	 *         class name of a soft validation enabled for the the given
	 *         organization and request type
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public Collection&lt;String&gt; getValidators(ID orgID, String reqType, ID activityID) throws Exception {
<span class="nc bnc" id="L350" title="All 2 branches missed.">		String key = VALIDATORS_PREFIX + orgID + &quot;:&quot; + reqType + (activityID != null ? (&quot;:&quot; + activityID) : &quot;&quot;);</span>
<span class="nc" id="L351">		Collection&lt;String&gt; result = (Collection) get(key);</span>

<span class="nc bnc" id="L353" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L355">				m_cat.debug(&quot;getValidators: &quot; + RmUtil.dumpCollection(result));</span>
			}
<span class="nc" id="L357">			return result;</span>
		}

<span class="nc" id="L360">		result = CacheUtilRM.getEnabledValidationRules(orgID, reqType, activityID);</span>

<span class="nc" id="L362">		put(key, result);</span>

<span class="nc bnc" id="L364" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L365">			m_cat.debug(&quot;getValidators: &quot; + RmUtil.dumpCollection(result));</span>
		}

<span class="nc" id="L368">		return result;</span>
	}

	/**
	 * Return whether the rule is enabled for the given org This is required for
	 * rules that have additional params
	 *
	 * @param orgID
	 *            the organization
	 * @param reqType
	 *            request type
	 * @param className
	 *            validator name
	 * @return a collection of String objects. Each one is the fully qualified
	 *         class name of a soft validation enabled for the the given
	 *         organization and request type
	 */
	public boolean isValidationRequiredForOrg(ID orgID, String reqType, String className) throws Exception {

<span class="nc" id="L387">		String key = VALIDATORS_PREFIX + orgID + &quot;:&quot; + reqType;</span>

<span class="nc" id="L389">		Collection result = (Collection) get(key);</span>
<span class="nc" id="L390">		boolean isValRequired = false;</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L392">			result = CacheUtilRM.getEnabledValidationRules(orgID, reqType, null);</span>
		}

<span class="nc bnc" id="L395" title="All 2 branches missed.">		if (result != null) {</span>
			// iterate through collection to see if given validator exists
<span class="nc" id="L397">			Iterator valItr = result.iterator();</span>

<span class="nc bnc" id="L399" title="All 2 branches missed.">			while (valItr.hasNext()) {</span>
<span class="nc" id="L400">				String validator = (String) valItr.next();</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">				if (validator.equals(className)) {</span>
<span class="nc" id="L402">					return true;</span>
				}
<span class="nc" id="L404">			}</span>
		}

<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L408">			m_cat.debug(&quot;getValidators: &quot; + RmUtil.dumpCollection(result));</span>
		}

<span class="nc" id="L411">		return isValRequired;</span>
	}

	/**
	 * Return whether the rule is enabled for the given org and activity
	 * (timeoff type id) This is required for rules that have additional params
	 *
	 * @param orgID
	 *            the organization
	 * @param reqType
	 *            request type
	 * @param className
	 *            validator name
	 * @param activityID
	 *            id of activity (for time-off types)
	 * @return a collection of String objects. Each one is the fully qualified
	 *         class name of a soft validation enabled for the the given
	 *         organization and request type
	 */
	public boolean isValidationRequiredForOrgAndActivity(ID orgID, String reqType, String className, ID activityID)
			throws Exception {
<span class="nc bnc" id="L432" title="All 2 branches missed.">		String key = VALIDATORS_PREFIX + orgID + &quot;:&quot; + reqType + &quot;:&quot; + (activityID != null ? (&quot;:&quot; + activityID) : &quot;&quot;);</span>
<span class="nc" id="L433">		Collection result = (Collection) get(key);</span>
<span class="nc" id="L434">		boolean isValRequired = false;</span>
<span class="nc bnc" id="L435" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L436">			result = CacheUtilRM.getEnabledValidationRules(orgID, reqType, activityID);</span>
		}

<span class="nc bnc" id="L439" title="All 2 branches missed.">		if (result != null) {</span>
			// iterate through collection to see if given validator exists
<span class="nc" id="L441">			Iterator valItr = result.iterator();</span>

<span class="nc bnc" id="L443" title="All 2 branches missed.">			while (valItr.hasNext()) {</span>
<span class="nc" id="L444">				String validator = (String) valItr.next();</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">				if (validator.equals(className)) {</span>
<span class="nc" id="L446">					return true;</span>
				}
<span class="nc" id="L448">			}</span>
		}

<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L452">			m_cat.debug(&quot;getValidators: &quot; + RmUtil.dumpCollection(result));</span>
		}

<span class="nc" id="L455">		return isValRequired;</span>
	}

	/**
	 * Get a filing rules checker for this request. Subclasses may specialize
	 * this method if a different implementation from this default is required.
	 * In such cases, the parameter 'notUsed' can be used to pass additional
	 * information.
	 *
	 * @param notUsed
	 *            Not used in this implementation. Sub classes may decide to use
	 *            it when overriding this method.
	 */
	public FilingRuleChecker getFilingRuleChecker(Object notUsed) throws Exception {
		// Check to see if the checker is already in the cache
<span class="nc" id="L470">		FilingRuleChecker result = (FilingRuleChecker) get(FILING_RULE_CHECKER);</span>

		// If map was in the cache, use it
<span class="nc bnc" id="L473" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L474">			return result;</span>
		}

		// try {
<span class="nc" id="L478">		result = FilingRuleCheckerHelper.getChecker(getOrgID(), getRequestType(), getRequestSubType(), getDateRange());</span>
		// } c_atch (Exception e) {
		// //m_cat.error(e);
		// t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
		// }

		// Save in cache
<span class="nc" id="L485">		put(FILING_RULE_CHECKER, result);</span>

<span class="nc" id="L487">		return result;</span>
	}

	/**
	 * Method declared 'private' to enforce the fact that a request can be
	 * associated with multiple org IDs. For this reason getOrgIDs() is exposed
	 * instead.
	 *
	 * @return
	 */
	private ID getOrgID() throws Exception {
<span class="nc" id="L498">		return (ID) getOrgIDs().iterator().next();</span>
	}

	/**
	 * Used in error messages. Employee name is formatted simplistically.
	 */
	public String getEmployeeNameByID(ID id) throws Exception {
		// key for cache
<span class="nc" id="L506">		String key = EMPLOYEE_NAME + id;</span>
		// retrieve from cache.
<span class="nc" id="L508">		String name = (String) get(key);</span>

		// if cache hit, return name.
<span class="nc bnc" id="L511" title="All 2 branches missed.">		if (name != null) {</span>
<span class="nc" id="L512">			return name;</span>
		}

<span class="nc" id="L515">		EmployeeName eName = null;</span>
		// try {
<span class="nc" id="L517">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L518">		eName = wrm.getEmployeeNameByID(id);</span>
		// } c_atch (Exception e) {
		// t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
		// }

		// if no locale info, format name ourselves, simplistically
		// todo: why isn't locale used?
<span class="nc bnc" id="L525" title="All 2 branches missed.">		if (eName != null) {</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">			String fName = (eName.getFirstName() != null) ? eName.getFirstName() : &quot;&quot;;</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">			String lName = (eName.getLastName() != null) ? eName.getLastName() : &quot;&quot;;</span>

<span class="nc" id="L529">			name = fName + &quot; &quot; + lName;</span>
		}

		// store in cache
<span class="nc bnc" id="L533" title="All 2 branches missed.">		put(key, (name == null) ? &quot;&quot; : name);</span>
<span class="nc" id="L534">		return name;</span>
	}

	/**
	 * Get the employee object for the employee associated with this request
	 */
	public Employee getEmployee(long empDetailLevel) throws Exception {
<span class="nc" id="L541">		return getEmployeeForCurrTimeByID(getEmployeeID(), empDetailLevel);</span>
	}

	public abstract ID getEmployeeID();

	/**
	 * Get the employee object by ID. Retrieve from cache if available,
	 * otherwise read from database and save in cache.
	 * 
	 * @return an Employee, given it's ID.
	 * @throws BbmFinderException
	 */
	public Employee getEmployeeForCurrTimeByID(ID empID, long empDetailLevel) throws Exception {
<span class="nc" id="L554">		Map map = getMap();</span>
<span class="nc" id="L555">		String key = EMP_KEY_PREFIX + empID + ':' + empDetailLevel;</span>

<span class="nc" id="L557">		Employee emp = (Employee) map.get(key);</span>

<span class="nc bnc" id="L559" title="All 2 branches missed.">		if (emp != null) {</span>
<span class="nc" id="L560">			return emp;</span>
		}

<span class="nc" id="L563">		emp = ValidationUtil.getEmployeeByID(empID, null, empDetailLevel);</span>
<span class="nc" id="L564">		map.put(key, emp);</span>

<span class="nc" id="L566">		m_cat.debug(&quot;getEmployeeForCurrTimeByID(&quot; + empID + &quot;, &quot; + empDetailLevel + &quot;): &quot; + emp);</span>
<span class="nc" id="L567">		return emp;</span>
	}

	// /**
	// * Get an employee's name formatted for display in a message
	// */
	// public String getEmpNameForID(ID empID) throws ValidationException {
	// Employee emp = getCurrentTimeEmployeeByID(empID);
	//
	// return emp.getFirstName() + &quot; &quot; + emp.getLastName() /*+ &quot; [&quot; +
	// emp.getID() + &quot;]&quot;*/;
	// }

	/**
	 * Get employee identification for message.
	 */
	public String getEmployeeNameByID() throws Exception {
<span class="nc" id="L584">		return getEmployeeNameByID(getEmployeeID());</span>
	}

	/**
	 * Get the organization object by ID. Retrieve from cache if available,
	 * otherwise read from database and save in cache.
	 * 
	 * @return an Organization, given it's ID.
	 */
	public Organization getOrganizationByID(ID orgID) throws Exception {
<span class="nc" id="L594">		Map map = getMap();</span>
<span class="nc" id="L595">		String key = ORG_KEY_PREFIX + orgID;</span>

<span class="nc" id="L597">		Organization org = (Organization) map.get(key);</span>

<span class="nc bnc" id="L599" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L600">			org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L601">			map.put(key, org);</span>
		}

<span class="nc" id="L604">		m_cat.debug(&quot;getOrganizationByID(&quot; + orgID + &quot;): &quot; + org);</span>
<span class="nc" id="L605">		return org;</span>
	}

	/**
	 * Get the organization given an employee ID during a period.
	 * 
	 * @param empID
	 *            - an Employee ID
	 * @param start
	 *            - the starting time for the period
	 * @param end
	 *            - the ending time for the period
	 * @return the Organization
	 * @throws Exception
	 */
	public Organization getOrganizationForEmployeeDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L621">		String key = RequestUtil.makeCacheKey(EMPID2ORG, empID, start, end);</span>

<span class="nc" id="L623">		Organization org = (Organization) get(key);</span>

<span class="nc bnc" id="L625" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L626">			ID orgID = getOrgIDForEmployeeDuringPeriod(empID, start, end);</span>
<span class="nc" id="L627">			org = getOrganizationByID(orgID);</span>
<span class="nc" id="L628">			put(key, org);</span>
		}

<span class="nc" id="L631">		m_cat.debug(&quot;getOrganizationForEmployeeDuringPeriod(&quot; + empID + ',' + start + ',' + end + &quot;): &quot; + org);</span>
<span class="nc" id="L632">		return org;</span>
	}

	/**
	 * Get the organization ID given an employee ID during a period.
	 * 
	 * @param empID
	 *            - an Employee ID
	 * @param start
	 *            - the starting time for the period
	 * @param end
	 *            - the ending time for the period
	 * @return the Organization ID
	 * @throws Exception
	 */
	public ID getOrgIDForEmployeeDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L648">		String key = RequestUtil.makeCacheKey(EMPID_ORGID_PREFIX, empID, start, end);</span>

<span class="nc" id="L650">		ID orgID = (ID) get(key);</span>

<span class="nc bnc" id="L652" title="All 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L653">			orgID = ValidationUtil.getOrgIDForEmployeeDuringPeriod(empID, start, end);</span>
<span class="nc" id="L654">			put(key, orgID);</span>
		}

<span class="nc" id="L657">		m_cat.debug(&quot;getOrgIDForEmployeeDuringPeriod(&quot; + empID + ',' + start + ',' + end + &quot;): &quot; + orgID);</span>
<span class="nc" id="L658">		return orgID;</span>
	}

	/**
	 * Get the organization given an employee ID during a period.
	 * 
	 * @param empID
	 *            - an Employee ID
	 * @param start
	 *            - the starting time for the period
	 * @param end
	 *            - the ending time for the period
	 * @return the Organization
	 * @throws Exception
	 */
	public TimeZone getTimeZoneForEmployeeDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L674">		String key = RequestUtil.makeCacheKey(EMPID2ORGTZ, empID, start, end);</span>

		// if found in cache, return.
<span class="nc" id="L677">		TimeZone empOrgTZ = (TimeZone) get(key);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">		if (empOrgTZ != null) {</span>
<span class="nc" id="L679">			return empOrgTZ;</span>
		}

		// find TZ for employee's org.
		// Organization empOrg = getOrganizationForEmployeeDuringPeriod(empID,
		// start, end);
		// empOrgTZ = empOrg.getTimeZone();
<span class="nc" id="L686">		Collection wrAssns = ValidationUtil.getWorkResAssnWithTZForWRID(empID, start, end);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">		if (!wrAssns.isEmpty()) {</span>
			// just get the first one
<span class="nc" id="L689">			WorkResourceAssignment wrAssn = (WorkResourceAssignment) wrAssns.iterator().next();</span>
<span class="nc" id="L690">			empOrgTZ = wrAssn.getStartTimeZone();</span>
		}

		// save in cache.
<span class="nc" id="L694">		put(key, empOrgTZ);</span>

		// return empOrg's TZ.
<span class="nc" id="L697">		m_cat.debug(&quot;getOrgTZForEmployeeDuringPeriod(&quot; + empID + ',' + start + ',' + end + &quot;): &quot; + empOrgTZ);</span>
<span class="nc" id="L698">		return empOrgTZ;</span>
	}

	public abstract TimeRange getDateRange() throws Exception;

	/**
	 * Get the organization ID for the request's employee during the request's
	 * time range. Overridden by subclass
	 * {@link com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftSwapValidationCache
	 * ShiftSwapValidationCache}
	 */
	public Collection getOrgIDs() throws Exception {
<span class="nc" id="L710">		Collection result = (Collection) get(ORGIDS_FOR_REQ);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L712">			return result;</span>
		}

<span class="nc" id="L715">		result = getEmpIDToOrgIDMap().values();</span>

<span class="nc" id="L717">		put(ORGIDS_FOR_REQ, result);</span>

<span class="nc" id="L719">		m_cat.debug(&quot;getOrgIDs: &quot; + result);</span>
<span class="nc" id="L720">		return result;</span>
	}

	public TOPool getTOPool() throws Exception {
<span class="nc" id="L724">		TOPool toPool = (TOPool) get(TOPOOL_FOR_REQ);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">		if (toPool == null) {</span>
<span class="nc" id="L726">			Date startDate = getDateRange().getStartDate();</span>
<span class="nc" id="L727">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L728">			Collection empTOPoolAssnCol = toCalFacade.getValidEmpTOPoolAssignments(getEmployeeID(), startDate,</span>
					startDate);
<span class="nc bnc" id="L730" title="All 4 branches missed.">			if (empTOPoolAssnCol != null &amp;&amp; !empTOPoolAssnCol.isEmpty()) {</span>
<span class="nc" id="L731">				EmpTOPoolAssignment empTOPoolAssn = (EmpTOPoolAssignment) empTOPoolAssnCol.iterator().next();</span>
<span class="nc" id="L732">				ID pTOPoolID = empTOPoolAssn.getTOPoolID();</span>
<span class="nc" id="L733">				toPool = toCalFacade.getTOPool(pTOPoolID);</span>
<span class="nc" id="L734">				put(TOPOOL_FOR_REQ, toPool);</span>
			}
<span class="nc bnc" id="L736" title="All 2 branches missed.">			m_cat.debug(&quot;toPoolID: &quot; + (toPool != null ? toPool.toString()</span>
<span class="nc" id="L737">					: &quot;TOPool not found for given Date Range for empID=&quot; + getEmployeeID() + &quot;for Date=&quot; + startDate));</span>
		}
<span class="nc" id="L739">		return toPool;</span>
	}

	public OrganizationSetting getOrgSettingForOrgID(ID orgID) throws Exception {
<span class="nc" id="L743">		String cacheKey = RequestUtil.makeCacheKey(ORGSETTING_FOR_ORGID, orgID);</span>

<span class="nc" id="L745">		OrganizationSetting orgSetting = (OrganizationSetting) get(cacheKey);</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">		if (orgSetting != null) {</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L748">				m_cat.debug(getCacheHitMsg(cacheKey, orgSetting));</span>
			}
<span class="nc" id="L750">			return orgSetting;</span>
		}

<span class="nc" id="L753">		orgSetting = RequestUtil.getOrgSetting(orgID, null);</span>
<span class="nc" id="L754">		put(cacheKey, orgSetting);</span>

<span class="nc bnc" id="L756" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L757">			m_cat.debug(getCacheMissMsg(cacheKey, orgSetting));</span>
		}

<span class="nc" id="L760">		return orgSetting;</span>
	}

	/**
	 * Get the organization ID for the request's employee during the request's
	 * time range. Overridden by subclass
	 * {@link com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftSwapValidationCache
	 * ShiftSwapValidationCache}
	 */
	public Map getEmpIDToOrgIDMap() throws Exception {
		// try {
		// Check to see if the org id is already in the cache
<span class="nc" id="L772">		Map result = (Map) get(EMPID_TO_ORGID_MAP_FOR_PERIOD);</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L774">			return result;</span>
		}

		// TODO: collapse this and ReqAgg.getEmpIDTimeRangesPair() into one.
<span class="nc" id="L778">		TimeRange range = getDateRange();</span>

<span class="nc" id="L780">		ID empID = getEmployeeID();</span>
<span class="nc" id="L781">		result = Collections.singletonMap(empID,</span>
<span class="nc" id="L782">				ValidationUtil.getOrgIDForEmployeeDuringPeriod(empID, range.getStartDate(), range.getEndDate()));</span>

<span class="nc" id="L784">		put(EMPID_TO_ORGID_MAP_FOR_PERIOD, result);</span>

<span class="nc" id="L786">		m_cat.debug(&quot;getEmpIDToOrgIDMap: &quot; + result);</span>
<span class="nc" id="L787">		return result;</span>
		// } c_atch (Exception e) {
		// t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
		// }
	}

	/**
	 * Get the organization for this request and employee
	 */
	public Organization getOrg() throws Exception {
<span class="nc" id="L797">		return getOrganizationByID(getOrgID());</span>
	}

	/**
	 * Get organization identification for message.
	 */
	public String getOrgNameForMsg() throws Exception {
<span class="nc" id="L804">		Organization org = getOrg();</span>

<span class="nc" id="L806">		return org.getName(); // + &quot; [&quot; + org.getID() + &quot;]&quot;;</span>
	}

	/**
	 * Get organization timezone for message.
	 */
	public TimeZone getTimeZoneForOrg() throws Exception {
<span class="nc" id="L813">		Organization org = getOrg();</span>

<span class="nc" id="L815">		return org.getTimeZone();</span>
	}

	/**
	 * Get the holidays for the given org during the time period.
	 * 
	 * @return collection of Holiday objects
	 */
	public Collection getHolidaysDuringPeriod() throws Exception {
<span class="nc" id="L824">		Collection&lt;Holiday&gt; holsDuringPeriod = (Collection) get(HOLIDAYSDURINGPERIOD);</span>

		// If events are in the cache, use them
<span class="nc bnc" id="L827" title="All 2 branches missed.">		if (holsDuringPeriod != null) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L829">				m_cat.debug(&quot;getHolidaysDuringPeriod: &quot; + RmUtil.dumpCollection(holsDuringPeriod));</span>
			}
<span class="nc" id="L831">			return holsDuringPeriod;</span>
		}
<span class="nc" id="L833">		TimeRange range = getDateRange();</span>
<span class="nc" id="L834">		holsDuringPeriod = ValidationUtil.getHolidays(getOrg(), getTimeZoneForOrg(), range);</span>
<span class="nc" id="L835">		put(HOLIDAYSDURINGPERIOD, holsDuringPeriod);</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L837">			m_cat.debug(&quot;getHolidaysDuringPeriod: &quot; + RmUtil.dumpCollection(holsDuringPeriod));</span>
		}
<span class="nc" id="L839">		return holsDuringPeriod;</span>
	}

	/**
	 * Get a TimeMap for nonworking holidays during the request time range
	 * 
	 * @return TimeMap (resolution=15 minutes) of holidays during request period
	 */
	public TimeMap getHolidaysNonWorkingTimeMap() throws Exception {
		// Check to see if its in the cache already
<span class="nc" id="L849">		TimeMap nonWorkHolTimeMap = (TimeMap) get(NWH_TIMEMAP);</span>

		// If it was in the cache, use it
<span class="nc bnc" id="L852" title="All 2 branches missed.">		if (nonWorkHolTimeMap != null) {</span>
<span class="nc bnc" id="L853" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L854">				m_cat.debug(getCacheHitMsg(NWH_TIMEMAP, nonWorkHolTimeMap));</span>
			}
<span class="nc" id="L856">			return nonWorkHolTimeMap;</span>
		}

		// Get the collection of holidays that fall within the request period
<span class="nc" id="L860">		Collection&lt;Holiday&gt; holidays = getHolidaysDuringPeriod();</span>
<span class="nc" id="L861">		TimeZone orgTZ = getTimeZoneForOrg();</span>
<span class="nc" id="L862">		TimeRange reqTimeRange = getDateRange();</span>

		// Build the TimeMap for non-working holidays.
		// The time map will use a resolution of 1 day, so we know how
		// many bits we'll need
<span class="nc" id="L867">		Date reqTimeRangeStart = reqTimeRange.getStartDate();</span>
<span class="nc" id="L868">		Date reqTimeRangeEnd = reqTimeRange.getEndDate();</span>
<span class="nc" id="L869">		long reqTimeRangeStartMs = reqTimeRangeStart.getTime();</span>
<span class="nc" id="L870">		long reqTimeRangeEndMs = reqTimeRangeEnd.getTime();</span>
<span class="nc" id="L871">		int limit = (int) ((reqTimeRangeEndMs - reqTimeRangeStartMs) / TimeMap.FIFTEEN_MIN);</span>

<span class="nc" id="L873">		nonWorkHolTimeMap = new TimeMap(TimeMap.FIFTEEN_MIN, reqTimeRangeStart, reqTimeRangeEnd);</span>

		// Loop through the holidays, pick out the ones that are paid
		// i.e. &quot;non-working&quot;
<span class="nc bnc" id="L877" title="All 2 branches missed.">		for (Iterator it = holidays.iterator(); it.hasNext();) {</span>
<span class="nc" id="L878">			Holiday hol = (Holiday) it.next();</span>

			// only consider the holidays that are paid
<span class="nc bnc" id="L881" title="All 2 branches missed.">			if (hol.isPaidHoliday()) {</span>
<span class="nc" id="L882">				Date holStart = hol.getStartDate().getTime(orgTZ);</span>
<span class="nc" id="L883">				Date holEnd = hol.getEndDate().getTime(orgTZ);</span>

				// get overlap between request's time range and holiday time
				// range.
<span class="nc" id="L887">				TimeRange overlapTimeRange = RequestUtil.getOverlapTimeRange(reqTimeRangeStart, reqTimeRangeEnd,</span>
						holStart, holEnd);
				// if no overlap continue
<span class="nc bnc" id="L890" title="All 2 branches missed.">				if (overlapTimeRange == null) {</span>
<span class="nc" id="L891">					continue;</span>
				}

				// set bits in range.
<span class="nc" id="L895">				nonWorkHolTimeMap.setRange(overlapTimeRange.getStartDate(), overlapTimeRange.getEndDate());</span>
			}
<span class="nc" id="L897">		}</span>

<span class="nc bnc" id="L899" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L900">			m_cat.debug(getCacheMissMsg(NWH_TIMEMAP, nonWorkHolTimeMap));</span>
		}

		// Save in validation cache
<span class="nc" id="L904">		put(NWH_TIMEMAP, nonWorkHolTimeMap);</span>

<span class="nc" id="L906">		return nonWorkHolTimeMap;</span>
	}

	/**
	 * Get the OrganizationHOO objects for the given org during the time period.
	 * 
	 * @return collection of OrganizationHOO objects
	 */
	public Collection getHOOAssignmentsDuringPeriod() throws Exception {
<span class="nc" id="L915">		Collection result = (Collection) get(REQUEST_HOOS);</span>

		// If events were in the cache, use them
<span class="nc bnc" id="L918" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L920">				m_cat.debug(&quot;getHOOAssignmentsDuringPeriod: &quot; + RmUtil.dumpCollection(result));</span>
			}
<span class="nc" id="L922">			return result;</span>
		}

		// WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();
		// TODO: All methods in this class which only uses the first org ID in
		// the returned collection are
		// applicable for shiftBid or timeOff requests. Override these methods
		// for shiftSwapRequests
		// to throw exceptions since SSReqs have 2 org IDs and not one.
<span class="nc" id="L931">		ID orgID = getOrgID();</span>
<span class="nc" id="L932">		TimeRange range = getDateRange();</span>
		// result = wrm.getOrganizationHOOAssignments(orgID,
		// range.getStartDate(),
		// range.getEndDate());
<span class="nc" id="L936">		result = CacheUtilBBM.getOrganizationHOO(orgID, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L937" title="All 2 branches missed.">		result = (result == null) ? Collections.EMPTY_LIST : result;</span>

<span class="nc" id="L939">		put(REQUEST_HOOS, result);</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L941">			m_cat.debug(&quot;getHOOAssignmentsDuringPeriod: &quot; + RmUtil.dumpCollection(result));</span>
		}

<span class="nc" id="L944">		return result;</span>
	}

	/**
	 * Get a TimeMap for organizational HOO during the request time range
	 * 
	 * @return TimeMap (resolution=5 minutes) of holidays during request period
	 */
	public TimeMap getHOOAssignmentsTimeMap() throws Exception {
<span class="nc" id="L953">		return getHOOAssignmentsTimeMap(getDateRange());</span>
	}

	//public because of the need to mock this function to keep unit tests working
	protected TimeMap getHOOAssignmentsTimeMap(TimeRange reqTimeRange) throws Exception {

		// Check to see if its in the cache already
<span class="nc" id="L960">		TimeMap hooAssnTimeMapForReqTROrgDay = (TimeMap) get(HOO_TIMEMAP);</span>

		// If found in cache, return it.
<span class="nc bnc" id="L963" title="All 2 branches missed.">		if (hooAssnTimeMapForReqTROrgDay != null) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L965">				m_cat.debug(getCacheHitMsg(HOO_TIMEMAP, hooAssnTimeMapForReqTROrgDay));</span>
			}
<span class="nc" id="L967">			return hooAssnTimeMapForReqTROrgDay;</span>
		}
		

		// for each organization day in request time range
		// get hooAssn which applies for the current organization day.
		// get day open and day close for current organization day using the hooAssn.
		// set (dayOpen, dayClose) range in timeMap

<span class="nc" id="L976">		Organization reqEmpOrg = getOrg();</span>
<span class="nc" id="L977">		TimeZone reqEmpOrgTZ = reqEmpOrg.getTimeZone();</span>
		// request time range start adjusted to the closest org day start
		// (before request startTime)
<span class="nc" id="L980">		Date reqTRStartAsOrgDayStart = TOCalcUtil.getDateForOrgDayStart(reqEmpOrg, reqTimeRange.getStartDate());</span>
		// request time range end adjusted to the closest org day end (after req
		// endTime).
<span class="nc" id="L983">		Date reqTREndAsOrgDayEnd = TOCalcUtil.getDateForOrgDayEnd(reqEmpOrg, reqTimeRange.getEndDate());</span>

		// The time map will use a resolution of 5 minutes, so we know how
		// many bits we'll need
<span class="nc" id="L987">		final long fiveMinuteResolution = TimeMap.ONE_MINUTE * 5;</span>

		// HOO assignment time map for request time range adjusted org day
		// boundaries.
<span class="nc" id="L991">		hooAssnTimeMapForReqTROrgDay = new TimeMap(fiveMinuteResolution, reqTRStartAsOrgDayStart, reqTREndAsOrgDayEnd,</span>
				reqEmpOrg);

		// Get the OrganizationHOO objects during the time period of the request
<span class="nc" id="L995">		Collection hooAssns = getHOOAssignmentsDuringPeriod();</span>
<span class="nc bnc" id="L996" title="All 4 branches missed.">		if (hooAssns == null || hooAssns.isEmpty()) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L998">				m_cat.debug(getCacheMissMsg(HOO_TIMEMAP, hooAssnTimeMapForReqTROrgDay));</span>
			}
<span class="nc" id="L1000">			return hooAssnTimeMapForReqTROrgDay;</span>
		}

		// for each organization day in range
<span class="nc" id="L1004">		Date currOrgDayStart = reqTRStartAsOrgDayStart;</span>
		// start with any non-null HOO. The proper hoo will be determined
		// automatically within the loop.
<span class="nc" id="L1007">		OrganizationHOO currHOO = (OrganizationHOO) hooAssns.iterator().next();</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">		while (currOrgDayStart.before(reqTREndAsOrgDayEnd)) {</span>

			// if currOrgDay does not fall within the currHOOAssignment's
			// effectivity.
<span class="nc bnc" id="L1013" title="All 2 branches missed.">			if (!RequestUtil.isDateBetween(currOrgDayStart, currHOO.getStartTime(), currHOO.getEndTime())) {</span>
				// find the HOO assn within which the current organization day falls.
<span class="nc" id="L1015">				currHOO = findHOOAssnContainingDate(hooAssns, currOrgDayStart);</span>

				// if none found, generate an exception.
<span class="nc bnc" id="L1018" title="All 2 branches missed.">				if (currHOO == null) {</span>
<span class="nc" id="L1019">					throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.TO_NO_ORG_HOO_FOR_ORG_DAY,</span>
<span class="nc" id="L1020">							reqEmpOrg.getName(), currOrgDayStart, m_cat);</span>
				}
			}

<span class="nc" id="L1024">			Date orgDayBoundary = DateUtil.getDayStart(currOrgDayStart, reqEmpOrgTZ);</span>
			// get HOO open for organization day start
<span class="nc" id="L1026">			Date currOrgDayHOOOpen = currHOO.getDayOpen(orgDayBoundary, reqEmpOrgTZ);</span>
			// get HOO close for organization day start.
<span class="nc" id="L1028">			Date currOrgDayHOOClose = currHOO.getDayClose(orgDayBoundary, reqEmpOrgTZ);</span>

			// a 'null' value means the organization is not open for the specified day.
<span class="nc bnc" id="L1031" title="All 4 branches missed.">			if (currOrgDayHOOOpen != null &amp;&amp; currOrgDayHOOClose != null) {</span>
				// not clear if the computed hooOpen and hooClose can be outside
				// the timemap's range. To be safe,
				// compute the overlap region.
<span class="nc" id="L1035">				TimeRange overlapRange = RequestUtil.getOverlapTimeRange(reqTRStartAsOrgDayStart, reqTREndAsOrgDayEnd,</span>
						currOrgDayHOOOpen, currOrgDayHOOClose);
<span class="nc bnc" id="L1037" title="All 2 branches missed.">				if (overlapRange != null) {</span>
<span class="nc" id="L1038">					hooAssnTimeMapForReqTROrgDay.setRange(overlapRange.getStartDate(), overlapRange.getEndDate());</span>
				}
			}

			// move to next organization day start.
<span class="nc" id="L1043">			currOrgDayStart = TOCalcUtil.getDateForwardOneDay(currOrgDayStart, reqEmpOrgTZ);</span>
<span class="nc" id="L1044">		}</span>

		// Save in validation cache
<span class="nc" id="L1047">		put(HOO_TIMEMAP, hooAssnTimeMapForReqTROrgDay);</span>

<span class="nc bnc" id="L1049" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1050">			m_cat.debug(getCacheMissMsg(HOO_TIMEMAP, hooAssnTimeMapForReqTROrgDay));</span>
		}

<span class="nc" id="L1053">		return hooAssnTimeMapForReqTROrgDay;</span>
	}

	private Date applyDayBoundaryToHOO(Calendar cal, int dayBoundaryOffset, Date hooStartOrEnd) {
<span class="nc" id="L1057">		cal.setTime(hooStartOrEnd);</span>
<span class="nc" id="L1058">		cal.add(Calendar.HOUR_OF_DAY, dayBoundaryOffset / 60);</span>
<span class="nc" id="L1059">		cal.add(Calendar.MINUTE, dayBoundaryOffset % 60);</span>
<span class="nc" id="L1060">		cal.add(Calendar.SECOND, 0);</span>
<span class="nc" id="L1061">		cal.add(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L1062">		return cal.getTime();</span>
	}

	/**
	 * Note: this method may return 'null'. Find the HOO assignment whose
	 * effectivity contains the given date.
	 *
	 * @param hooAssns
	 * @param date
	 * @return
	 */
	private OrganizationHOO findHOOAssnContainingDate(Collection hooAssns, Date date) {

<span class="nc bnc" id="L1075" title="All 4 branches missed.">		if (hooAssns == null || hooAssns.isEmpty()) {</span>
<span class="nc" id="L1076">			return null;</span>
		}

<span class="nc" id="L1079">		OrganizationHOO orgHOO = null;</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">		for (Iterator iter = hooAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1081">			orgHOO = (OrganizationHOO) iter.next();</span>

<span class="nc bnc" id="L1083" title="All 2 branches missed.">			if (RequestUtil.isDateBetween(date, orgHOO.getStartTime(), orgHOO.getEndTime())) {</span>
<span class="nc" id="L1084">				break;</span>
			}
		}

<span class="nc" id="L1088">		return orgHOO;</span>
	}

	// /**
	// * Get a TimeMap for organizational HOO during
	// * the request time range
	// * @return TimeMap (resolution=5 minutes) of holidays during request
	// period
	// */
	// public TimeMap getHOOAssignmentsTimeMapOld() throws Exception {
	// // Check to see if its in the cache already
	// TimeMap result = (TimeMap) get(HOO_TIMEMAP);
	//
	// // If found in cache, return it.
	// if (result != null) {
	// if (m_cat.isDebugEnabled()) m_cat.debug(&quot;getHOOAssignmentsTimeMap: &quot; +
	// result);
	// return result;
	// }
	//
	// TimeRange reqTimeRange = getDateRange();
	//
	// // The time map will use a resolution of 5 minutes, so we know how
	// // many bits we'll need
	// final int resInMinutes = 5;
	// long resInMs = (long) TimeMap.ONE_MINUTE * resInMinutes;
	// long reqTimeRangeStart = reqTimeRange.getStartDate().getTime();
	// int limit = (int) ((reqTimeRange.getEndDate().getTime() -
	// reqTimeRangeStart) / resInMs);
	// BitSet hooBitSet = new BitSet(limit);
	//
	// // Compute the day and minute offset of the first interval
	// // initialize the variables used in the loop that follows
	// Calendar reqTimeRangeStartCal = Calendar.getInstance(getOrgTimeZone());
	// reqTimeRangeStartCal.setTime(reqTimeRange.getStartDate());
	// int currDayOfWeek = reqTimeRangeStartCal.get(Calendar.DAY_OF_WEEK); //day
	// of week
	// int currMinOfDay = (reqTimeRangeStartCal.get(Calendar.HOUR_OF_DAY) * 60)
	// + reqTimeRangeStartCal.get(Calendar.MINUTE);
	// int dayOfWeekOpenFromHOO = -1;
	// int dayOfWeekCloseFromHOO = -1;
	//
	// long currTimeInMS = reqTimeRangeStart;
	//
	// // Get the OrganizationHOO objects during the time period of the request
	// Collection hoos = getHOOAssignmentsDuringPeriod();
	// Iterator hoosIter = hoos.iterator();
	// // Set each bit in the map based on whether it represents a time during
	// // the organization's hours of operation. On =&gt; during hoo; Off =&gt;
	// otherwise
	// OrganizationHOO currHOO = null;
	// for (int bitsetIdx = 0; bitsetIdx &lt; limit; bitsetIdx++) {
	//
	// // Check to see we should use the next OrgHOO
	// if ((currHOO == null) || // first time
	// ((currHOO.getEndTime() != null) &amp;&amp; (currTimeInMS &gt;
	// currHOO.getEndTime().getTime()))) {
	// currHOO = (OrganizationHOO) hoosIter.next();
	//
	// // Check...this shouldn't happen
	// if (currHOO == null) {
	// // haven't built TimeMap yet, so validation will fail below
	// throw RequestUtil.createRmHardValidationException(
	// RmEjbBundleKey.TO_NO_ORG_HOO_TO_COVER_INTERVAL, m_cat);
	// }
	//
	// // We want to make the first time through the loop
	// // with a new HOO get the day open and close offsets,
	// // so force this by simulating the
	// // crossing of a day boundary (if we're not already
	// // crossing one)
	// if (currMinOfDay &lt; MINUTES_PER_DAY) {
	// currDayOfWeek -= 1;
	// currMinOfDay += MINUTES_PER_DAY;
	// }
	// }
	//
	// // OK, we have a valid HOO for the interval, now check to see
	// // if we crossed a day boundary with the loop variables
	// if (currMinOfDay &gt;= MINUTES_PER_DAY) { //are we in the next day?
	// currMinOfDay -= MINUTES_PER_DAY; // adjust minutes
	// currDayOfWeek = (currDayOfWeek == 7) ? 1 : currDayOfWeek + 1; // add 1 to
	// the day of week.
	//
	//
	// // Set the open and close times
	// dayOfWeekOpenFromHOO = currHOO.getDayOpen((short) currDayOfWeek);
	// dayOfWeekCloseFromHOO = currHOO.getDayClose((short) currDayOfWeek);
	// }
	//
	// // Now the easy part. We check to see that the time is in
	// // range, if so, then we set the bit on, otherwise leave it
	// // off
	// if ((currMinOfDay &gt;= dayOfWeekOpenFromHOO) &amp;&amp; (currMinOfDay &lt;
	// dayOfWeekCloseFromHOO)) {
	// hooBitSet.set(bitsetIdx);
	// }
	//
	//
	// // Increment vars for next iteration of the loop
	// // the crossing of day boundaries and HOO effective
	// // periods is handled above. Bit map index, ix, is
	// // the loop control variable.
	// currMinOfDay += resInMinutes;
	// currTimeInMS += resInMs;
	// } // end for (int ix = 0; ix&lt;limit; ix++)
	//
	//
	// // At this point, the BitSet is built and we can build
	// // the TimeMap
	// result = new TimeMap(hooBitSet, resInMs, reqTimeRange.getStartDate());
	//
	// // Save in validation cache
	// put(HOO_TIMEMAP, result);
	//
	// if (m_cat.isDebugEnabled()) m_cat.debug(&quot;getHOOAssignmentsTimeMap: &quot; +
	// result);
	//
	// return result;
	// }

	/**
	 * Get {@link CalendarEvent calendar events} (
	 * {@link CalendarEventAssignment CalendarEventAssignments} of type
	 * {@link Event#EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT
	 * EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT}) for the employee during the time
	 * range of this request.
	 *
	 * @return collection of {@link CalendarEvent CalendarEvent} objects
	 */
	public Collection getCalEventsDuringPeriod(boolean includePub, boolean includeUnpub, boolean mustOverlapOnly)
			throws Exception {
<span class="nc" id="L1220">		String cacheKey = RequestUtil.makeCacheKey(REQUEST_CALENDAR_EVENTS, new Boolean(includePub),</span>
				new Boolean(includeUnpub), new Boolean(mustOverlapOnly));

<span class="nc" id="L1223">		Collection results = null;</span>
<span class="nc" id="L1224">		results = (Collection) get(cacheKey);</span>

		// If events were in the cache, use them
<span class="nc" id="L1227">		String methodName = &quot;getCalendarEventsDuringPeriod(&quot; + includePub + ',' + includeUnpub + ',' + mustOverlapOnly</span>
				+ &quot;): &quot;;
<span class="nc bnc" id="L1229" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1230" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1231">				m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1233">			return results;</span>
		}

<span class="nc" id="L1236">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1237">		TimeRange range = getDateRange();</span>

		// try {
<span class="nc" id="L1240">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">		if (includePub) {</span>
<span class="nc" id="L1242">			Collection events = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT,</span>
<span class="nc" id="L1243">					empID, range.getStartDate(), range.getEndDate());</span>

<span class="nc bnc" id="L1245" title="All 2 branches missed.">			if (results == null) {</span>
<span class="nc" id="L1246">				results = events;</span>
			} else {
<span class="nc" id="L1248">				results.addAll(events);</span>
			}
		}

<span class="nc bnc" id="L1252" title="All 2 branches missed.">		if (includeUnpub) {</span>
<span class="nc" id="L1253">			Collection events = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT, empID,</span>
<span class="nc" id="L1254">					range.getStartDate(), range.getEndDate());</span>

<span class="nc bnc" id="L1256" title="All 2 branches missed.">			if (results == null) {</span>
<span class="nc" id="L1257">				results = events;</span>
			} else {
<span class="nc" id="L1259">				results.addAll(events);</span>
			}
		}

<span class="nc bnc" id="L1263" title="All 2 branches missed.">		if (mustOverlapOnly) {</span>
<span class="nc" id="L1264">			Collection temp = results;</span>
<span class="nc" id="L1265">			results = new ArrayList();</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">			for (Iterator eventIter = temp.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L1267">				CalendarEvent calEvt = (CalendarEvent) eventIter.next();</span>

<span class="nc bnc" id="L1269" title="All 2 branches missed.">				if (calEvt.getOverlapType() == CalendarEventTemplate.OVERLAP_TYPE_MUST_OVERLAP_SHIFT) {</span>
<span class="nc" id="L1270">					results.add(calEvt);</span>
				}
<span class="nc" id="L1272">			}</span>
		}
		// } c_atch (Exception e) {
		// //m_cat.error(e);
		// t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
		// }

		// Add results to cache
<span class="nc" id="L1280">		put(cacheKey, results);</span>

<span class="nc bnc" id="L1282" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1283">			m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
		}

<span class="nc" id="L1286">		return results;</span>
	}

	/**
	 * TODO: All other methods in the validation cache which fetch events from
	 * the schedule must go thru' this. Include the following smarts in this
	 * method:
	 * &lt;li&gt;if specified timerange is contained within an existing cached time
	 * range then return the cached results after restricting it.
	 * &lt;li&gt;The eventType parameter is a bit mask. If the specified eventType
	 * does not exist in the cache but a superset exists then return the cached
	 * superset after restricting it.
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @param evtType
	 * @param published
	 * @return
	 */
	public Collection getEventsDuringPeriod(ID empID, Date start, Date end, int evtTypeMask, boolean published)
			throws BbmEJBCreateException, BbmFinderException, RemoteException {

<span class="nc" id="L1309">		String cacheKey = RequestUtil.makeCacheKey(&quot;CACHEKEY_EVTSDURINGPERIOD&quot;,</span>
				new Object[] { empID, start, end, new Integer(evtTypeMask), new Boolean(published) });

<span class="nc" id="L1312">		Collection events = (Collection) get(cacheKey);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">		if (events != null) {</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1315">				m_cat.debug(getCacheHitMsg(cacheKey, events));</span>
			}
<span class="nc" id="L1317">			return events;</span>
		}

<span class="nc" id="L1320">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">		if (!published) {</span>
<span class="nc" id="L1322">			events = sam.getEventsForWorkResourceByType(evtTypeMask, empID, start, end);</span>
		} else {
<span class="nc" id="L1324">			events = sam.getPublishedEventsForWorkResourceByType(evtTypeMask, empID, start, end);</span>
		}

<span class="nc bnc" id="L1327" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1328">			m_cat.debug(getCacheMissMsg(cacheKey, events));</span>
		}
<span class="nc" id="L1330">		return events;</span>
	}

	/**
	 * Get a TimeMap for unpublished MUST_OVERLAP {@link CalendarEvent calendar
	 * events} for the employee during the time range of this request.
	 *
	 * @see #getCalEventsDuringPeriod(boolean, boolean, boolean)
	 *
	 * @return TimeMap (resolution=5 minutes) of calendar events during request
	 *         period which require a shift.
	 */
	public TimeMap getCalEventsMustOverlapDuringPeriodUnPubTimeMap() throws Exception {
<span class="nc" id="L1343">		TimeMap result = null;</span>

		// Check to see if the map is already in the cache
<span class="nc" id="L1346">		result = (TimeMap) get(REQUEST_CALEVT_MUSTOVERLAP_UNPUB_TIMEMAP);</span>

		// If map was in the cache, use it
<span class="nc" id="L1349">		String methodName = &quot;getCalEventsMustOverlapDuringPeriodUnPubTimeMap: &quot;;</span>
<span class="nc bnc" id="L1350" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1352">				m_cat.debug(methodName + result);</span>
			}
<span class="nc" id="L1354">			return result;</span>
		}

		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1359">		Collection events = getCalEventsDuringPeriod(false, true, true);</span>

<span class="nc" id="L1361">		result = RequestUtil.buildTimeMap(events, getDateRange(), TimeMap.ONE_MINUTE * 5L);</span>
<span class="nc" id="L1362">		put(REQUEST_CALEVT_MUSTOVERLAP_UNPUB_TIMEMAP, result); // Save in cache</span>

<span class="nc bnc" id="L1364" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1365">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1368">		return result;</span>
	}

	// /**
	// * Get unpublished {@link CalendarEventAssignment calendar events} of type
	// * {@link Event#EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT
	// EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT})
	// * for the employee during the time range of this request.
	// *
	// * @return collection of {@link CalendarEventAssignment
	// CalendarEventAssignment} objects
	// */
	// public Collection getCalEventsDuringPeriodUnPublished() throws
	// ValidationException {
	// Collection results = null;
	// results = (Collection) get(REQUEST_CALENDAR_EVENTS_UNPUB);
	//
	// // If events were in the cache, use them
	// String methodName = &quot;getCalendarEventsDuringPeriodUnPublished: &quot;;
	// if (results != null) {
	// m_cat.debug(methodName + RmUtil.dumpCollection(results));
	// return results;
	// }
	//
	// ID empID = getEmployeeID();
	// TimeRange range = getDateRange();
	//
	// try {
	// ScheduleAccessManager sam = BbmManagerFactory.getScheduleAccessManager();
	// results = sam.getEventsForWorkResourceByType(
	// Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT, empID,
	// range.getStartDate(), range.getEndDate());
	// } c_atch (Exception e) {
	// //m_cat.error(e);
	// t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
	// }
	//
	// // Add results to cache
	// put(REQUEST_CALENDAR_EVENTS_UNPUB, results);
	//
	// m_cat.debug(methodName + RmUtil.dumpCollection(results));
	//
	// return results;
	// }
	//
	/**
	 * Get a TimeMap for unpublished {@link CalendarEvent calendar events} for
	 * the employee during the time range of this request.
	 *
	 * @see #getCalEventsDuringPeriod(boolean, boolean, boolean)
	 *
	 * @return TimeMap (resolution=5 minutes) of calendar events during request
	 *         period which require a shift.
	 */
	public TimeMap getCalEventsDuringPeriodUnPubTimeMap() throws Exception {
<span class="nc" id="L1423">		TimeMap result = null;</span>

		// Check to see if the map is already in the cache
<span class="nc" id="L1426">		result = (TimeMap) get(REQUEST_CALEVT_UNPUB_TIMEMAP);</span>

		// If map was in the cache, use it
<span class="nc" id="L1429">		String methodName = &quot;getCalEventsDuringPeriodUnPubTimeMap: &quot;;</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1432">				m_cat.debug(methodName + result);</span>
			}
<span class="nc" id="L1434">			return result;</span>
		}

		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1439">		Collection events = getCalEventsDuringPeriod(false, true, false);</span>

<span class="nc" id="L1441">		result = RequestUtil.buildTimeMap(events, getDateRange(), TimeMap.ONE_MINUTE * 5L);</span>
<span class="nc" id="L1442">		put(REQUEST_CALEVT_UNPUB_TIMEMAP, result); // Save in cache</span>

<span class="nc bnc" id="L1444" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1445">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1448">		return result;</span>
	}

	/**
	 * Get a TimeMap for published {@link CalendarEvent calendarEvents} for the
	 * employee during the time range of this request.
	 *
	 * @see #getCalEventsDuringPeriod(boolean, boolean, boolean)
	 *
	 * @return TimeMap (resolution=5 minutes) of calendar events during request
	 *         period which require a shift.
	 */
	public TimeMap getCalEventsDuringPeriodPubTimeMap() throws Exception {
<span class="nc" id="L1461">		TimeMap result = null;</span>

		// Check to see if the map is already in the cache
<span class="nc" id="L1464">		result = (TimeMap) get(REQUEST_CALEVT_PUB_TIMEMAP);</span>

		// If map was in the cache, use it
<span class="nc" id="L1467">		String methodName = &quot;getCalEventsDuringPeriodPubTimeMap: &quot;;</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1470">				m_cat.debug(methodName + result);</span>
			}
<span class="nc" id="L1472">			return result;</span>
		}

		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1477">		Collection events = getCalEventsDuringPeriod(true, false, false);</span>

<span class="nc" id="L1479">		result = RequestUtil.buildTimeMap(events, getDateRange(), TimeMap.ONE_MINUTE * 5L);</span>
<span class="nc" id="L1480">		put(REQUEST_CALEVT_PUB_TIMEMAP, result); // Save in cache</span>

<span class="nc bnc" id="L1482" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1483">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1486">		return result;</span>
	}

	/**
	 * Get the scheduled time off events for the request employee during the
	 * request time range (both published and unpublished).
	 * 
	 * @return collection of CalendarEvent objects which hold the time off
	 *         information
	 */
	public Collection getTimeOffEventsPubAndUnpubDuringPeriod() throws Exception {
<span class="nc" id="L1497">		Collection results = (Collection) get(REQUEST_TIMEOFF_EVENTS_PUB_AND_UNPUB);</span>

		// If events were in the cache, use them
<span class="nc bnc" id="L1500" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1501" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1502">				m_cat.debug(&quot;getTimeOffEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1504">			return results;</span>
		}

		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1509">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1510">		TimeRange range = getDateRange();</span>
<span class="nc" id="L1511">		Date start = range.getStartDate();</span>
<span class="nc" id="L1512">		Date end = range.getEndDate();</span>

<span class="nc" id="L1514">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L1515">		results = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_TIME_OFF, empID, start, end);</span>

<span class="nc" id="L1517">		Collection unpubEvts = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_TIME_OFF, empID, start, end);</span>

<span class="nc" id="L1519">		results.addAll(unpubEvts); // return as a single collection</span>

		// Save in cache
<span class="nc" id="L1522">		put(REQUEST_TIMEOFF_EVENTS_PUB_AND_UNPUB, results);</span>

<span class="nc bnc" id="L1524" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1525">			m_cat.debug(&quot;getTimeOffEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
		}

<span class="nc" id="L1528">		return results;</span>
	}

	/**
	 * Get the scheduled time off events for the request employee during the
	 * request time range (published).
	 * 
	 * @return collection of CalendarEvent objects which hold the time off
	 *         information
	 */
	public Collection getTimeOffEventsPubDuringPeriod() throws Exception {
<span class="nc" id="L1539">		Collection results = (Collection) get(REQUEST_TIMEOFF_EVENTS_PUB);</span>

		// If events were in the cache, use them
<span class="nc bnc" id="L1542" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1544">				m_cat.debug(&quot;getTimeOffEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1546">			return results;</span>
		}

		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1551">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1552">		TimeRange range = getDateRange();</span>
<span class="nc" id="L1553">		Date start = range.getStartDate();</span>
<span class="nc" id="L1554">		Date end = range.getEndDate();</span>

<span class="nc" id="L1556">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L1557">		results = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_TIME_OFF, empID, start, end);</span>

		// Save in cache
<span class="nc" id="L1560">		put(REQUEST_TIMEOFF_EVENTS_PUB, results);</span>

<span class="nc bnc" id="L1562" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1563">			m_cat.debug(&quot;getTimeOffEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
		}

<span class="nc" id="L1566">		return results;</span>
	}

	public Collection getTimeOffEventsPubDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L1570">		String cacheKey = RequestUtil.makeCacheKey(TIMEOFF_EVENTS_PUB_FOR_EMPID_RANGE, empID, start, end);</span>
<span class="nc" id="L1571">		Collection results = (Collection) get(cacheKey);</span>

		// If events were in the cache, use them
<span class="nc bnc" id="L1574" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1576">				m_cat.debug(getCacheHitMsg(cacheKey, results));</span>
			}
<span class="nc" id="L1578">			return results;</span>
		}

		// Get the collection of calendar events for the specified period and
		// employee.
<span class="nc" id="L1583">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L1584">		results = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_TIME_OFF, empID, start, end);</span>

		// Save in cache
<span class="nc" id="L1587">		put(cacheKey, results);</span>

<span class="nc bnc" id="L1589" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1590">			m_cat.debug(getCacheMissMsg(cacheKey, results));</span>
		}

<span class="nc" id="L1593">		return results;</span>
	}

	/**
	 * Get the scheduled time off events for the employee during the period.
	 */
	/*
	 * public Collection getTimeOffEvents() throws ValidationException {
	 * Collection result = (Collection) get(TIME_OFF_EVENTS);
	 * 
	 * if (result != null) { m_cat.debug(&quot;getTimeOffEvents: &quot; +
	 * RmUtil.dumpCollection(result)); return result; }
	 * 
	 * try { ScheduleAccessManager sam =
	 * BbmManagerFactory.getScheduleAccessManager(); TimeRange range =
	 * getDateRange(); ID empID = m_tor.getEmployeeID(); Date start =
	 * range.getStartDate(); Date end = range.getEndDate();
	 * 
	 * result = sam.getPublishedEventsForWorkResourceByType(
	 * Event.EVENT_TYPE_TIME_OFF, empID, start, end);
	 * 
	 * Collection results2 = sam.getEventsForWorkResourceByType(
	 * Event.EVENT_TYPE_TIME_OFF, empID, start, end); result.addAll(results2);
	 * // combine the published and unpublished } c_atch (Exception e) {
	 * m_cat.error(e); throw RequestUtil.createValidationExceptionWrapper(e,
	 * m_cat); }
	 * 
	 * put(TIME_OFF_EVENTS, result);
	 * 
	 * m_cat.debug(&quot;getTimeOffEvents: &quot; + RmUtil.dumpCollection(result));
	 * 
	 * return result; }
	 */

	/**
	 *
	 * Get a TimeMap for time off events during this TO Request's time range
	 *
	 * @param tentApprChoice
	 * @return TimeMap (resolution=5 minutes) of shifts during request period
	 *         which require a shift.
	 * @throws Exception
	 */
	public TimeMap getTimeOffEventsPubAndUnpubTimeMap() throws Exception {
<span class="nc" id="L1637">		String methodName = &quot;getTimeOffEventsPubAndUnpubTimeMap&quot;;</span>

		// Check to see if its in the cache already
<span class="nc" id="L1640">		TimeMap result = (TimeMap) get(SCHEDTO_TIMEMAP);</span>

		// If it was in the cache, use it
<span class="nc bnc" id="L1643" title="All 2 branches missed.">		if (result == null) {</span>
<span class="nc" id="L1644">			result = RequestUtil.buildTimeMap(getTimeOffEventsPubAndUnpubDuringPeriod(), getDateRange(), TimeMap.ONE_MINUTE * 5L);</span>

			// Save in cache
<span class="nc" id="L1647">			put(SCHEDTO_TIMEMAP, result);</span>
		}

<span class="nc bnc" id="L1650" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1651">			m_cat.debug(RmUtil.dumpExitMethod(methodName, result));</span>
		}

<span class="nc" id="L1654">		return result;</span>
	}

	/**
	 * Get the scheduled unavailability events for the request employee during
	 * the request time range (both published and unpublished).
	 * 
	 * @return collection of CalendarEvent objects which hold the information
	 */
	public Collection getUnavailabilityEventsPubAndUnpubDuringPeriod() throws Exception {
<span class="nc" id="L1664">		Collection results = (Collection) get(REQUEST_UNAVAIL_EVENTS);</span>
		// If events were in the cache, use them
<span class="nc bnc" id="L1666" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1667" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1668">				m_cat.debug(&quot;getUnavailabilityEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1670">			return results;</span>
		}
		// Get the collection of calendar events that fall within the request
		// period
<span class="nc" id="L1674">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1675">		TimeRange range = getDateRange();</span>
<span class="nc" id="L1676">		Date start = range.getStartDate();</span>
<span class="nc" id="L1677">		Date end = range.getEndDate();</span>
<span class="nc" id="L1678">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
		/*
		 * results = sam.getPublishedEventsForWorkResourceByType(Event.
		 * EVENT_TYPE_UNAVAILABILITY, empID, start, end);
		 */
<span class="nc" id="L1683">		results = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_UNAVAILABILITY, empID, start, end);</span>
		// results.addAll(results2); // combine the published and unpublished
		// Save in cache
<span class="nc" id="L1686">		put(REQUEST_UNAVAIL_EVENTS, results);</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1688">			m_cat.debug(&quot;getUnavailabilityEventsDuringPeriod: &quot; + RmUtil.dumpCollection(results));</span>
		}
<span class="nc" id="L1690">		return results;</span>
	}

	/**
	 * Get a TimeMap for unavailability events during the request time range
	 * 
	 * @return TimeMap (resolution=5 minutes) of unavailability events during
	 *         request period
	 */
	public TimeMap getUnavailabilityEventsPubAndUnpubTimeMap() throws Exception {
		// Check to see if its in the cache already
<span class="nc" id="L1701">		TimeMap result = (TimeMap) get(SCHEDULED_UNAVAIL_TIMEMAP);</span>

		// If it was in the cache, use it
<span class="nc bnc" id="L1704" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc bnc" id="L1705" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1706">				m_cat.debug(&quot;getUnavailabilityEventsTimeMap: &quot; + result);</span>
			}
<span class="nc" id="L1708">			return result;</span>
		}

<span class="nc" id="L1711">		result = RequestUtil.buildTimeMap(getUnavailabilityEventsPubAndUnpubDuringPeriod(), getDateRange(),</span>
				TimeMap.ONE_MINUTE * 5L);

		// Save in validation cache
<span class="nc" id="L1715">		put(SCHEDULED_UNAVAIL_TIMEMAP, result);</span>

<span class="nc bnc" id="L1717" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1718">			m_cat.debug(&quot;getUnavailabilityEventsTimeMap: &quot; + result);</span>
		}

<span class="nc" id="L1721">		return result;</span>
	}

	/**
	 * Get the shifts scheduled for the employee (unpublished) during the period
	 */
	public Collection getShiftsUnpubDuringPeriod() throws Exception {
<span class="nc" id="L1728">		Collection results = null;</span>
<span class="nc" id="L1729">		results = (Collection) get(REQUEST_UNPUB_SHIFTS);</span>

		// If events were in the cache, use them
<span class="nc" id="L1732">		String methodName = &quot;getShiftsUnpubDuringPeriod: &quot;;</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1735">				m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1737">			return results;</span>
		}

<span class="nc" id="L1740">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1741">		TimeRange range = getDateRange();</span>

<span class="nc" id="L1743">		results = ValidationUtil.getEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, empID,</span>
<span class="nc" id="L1744">				range.getStartDate(), range.getEndDate());</span>
		// Save in cache
<span class="nc" id="L1746">		put(REQUEST_UNPUB_SHIFTS, results);</span>

<span class="nc bnc" id="L1748" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1749">			m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
		}

<span class="nc" id="L1752">		return results;</span>
	}

	/**
	 * Get the shifts scheduled for the employee (published) during the period
	 */
	public Collection getShiftsPubDuringPeriod() throws Exception {
<span class="nc" id="L1759">		Collection results = null;</span>
<span class="nc" id="L1760">		results = (Collection) get(REQUEST_PUB_SHIFTS);</span>

		// If events were in the cache, use them
<span class="nc" id="L1763">		String methodName = &quot;getShiftsPubDuringPeriod: &quot;;</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">		if (results != null) {</span>
<span class="nc bnc" id="L1765" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1766">				m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
			}
<span class="nc" id="L1768">			return results;</span>
		}

<span class="nc" id="L1771">		ID empID = getEmployeeID();</span>
<span class="nc" id="L1772">		TimeRange range = getDateRange();</span>

<span class="nc" id="L1774">		results = ValidationUtil.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, empID,</span>
<span class="nc" id="L1775">				range.getStartDate(), range.getEndDate());</span>
		// Save in cache
<span class="nc" id="L1777">		put(REQUEST_PUB_SHIFTS, results);</span>

<span class="nc bnc" id="L1779" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1780">			m_cat.debug(methodName + RmUtil.dumpCollection(results));</span>
		}

<span class="nc" id="L1783">		return results;</span>
	}

	/**
	 * Get a TimeMap for shifts for the request employee during the request time
	 * range that must overlap a shift.
	 *
	 * @return TimeMap (resolution=5 minutes) of shifts during request period
	 *         which require a shift.
	 */
	public TimeMap getShiftsUnpubTimeMap() throws Exception {
		// Check to see if the map is already in the cache
<span class="nc" id="L1795">		TimeMap result = (TimeMap) get(SCHEDULED_SHIFT_UNPUB_TIMEMAP);</span>

		// If map was in the cache, use it
<span class="nc" id="L1798">		String methodName = &quot;getShiftsUnpubTimeMap: &quot;;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L1800">			m_cat.debug(methodName + result);</span>
<span class="nc" id="L1801">			return result;</span>
		}

<span class="nc" id="L1804">		result = RequestUtil.buildTimeMap(getShiftsUnpubDuringPeriod(), getDateRange(), TimeMap.ONE_MINUTE * 5L, false);</span>

		// Save in cache
<span class="nc" id="L1807">		put(SCHEDULED_SHIFT_UNPUB_TIMEMAP, result);</span>

<span class="nc bnc" id="L1809" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1810">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1813">		return result;</span>
	}

	/**
	 * Get a TimeMap for shifts for the request employee during the request time
	 * range that must overlap a shift.
	 *
	 * @return TimeMap (resolution=5 minutes) of shifts during request period
	 *         which require a shift.
	 */
	public TimeMap getShiftsPubTimeMap() throws Exception {
		// Check to see if the map is already in the cache
<span class="nc" id="L1825">		TimeMap result = (TimeMap) get(SCHEDULED_SHIFT_PUB_TIMEMAP);</span>

		// If map was in the cache, use it
<span class="nc" id="L1828">		String methodName = &quot;getShiftsPubTimeMap: &quot;;</span>
<span class="nc bnc" id="L1829" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L1830">			m_cat.debug(methodName + result);</span>
<span class="nc" id="L1831">			return result;</span>
		}

<span class="nc" id="L1834">		result = RequestUtil.buildTimeMap(getShiftsPubDuringPeriod(), getDateRange(), TimeMap.ONE_MINUTE * 5L);</span>

		// Save in cache
<span class="nc" id="L1837">		put(SCHEDULED_SHIFT_PUB_TIMEMAP, result);</span>

<span class="nc bnc" id="L1839" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1840">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1843">		return result;</span>
	}

	public Collection getSchedulingPeriod(Collection campaignWKRSs) throws Exception {
<span class="nc bnc" id="L1847" title="All 4 branches missed.">		if (campaignWKRSs == null || campaignWKRSs.isEmpty()) {</span>
<span class="nc" id="L1848">			return Collections.EMPTY_LIST;</span>
		}

<span class="nc" id="L1851">		ArrayList spIDs = new ArrayList(campaignWKRSs.size());</span>
<span class="nc" id="L1852">		CampaignWorkResource campWKRS = null;</span>
<span class="nc bnc" id="L1853" title="All 2 branches missed.">		for (Iterator i = campaignWKRSs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1854">			campWKRS = (CampaignWorkResource) i.next();</span>
<span class="nc" id="L1855">			spIDs.add(campWKRS.getSPID());</span>
		}

<span class="nc" id="L1858">		return ValidationUtil.getSchedulingPeriods(spIDs);</span>

	}

	// required by newly added validations in v11.1
<span class="nc" id="L1863">	private TimeSeriesManager tsm = null;</span>

	public TimeSeriesManager getTimeSeriesManager() throws Exception {
<span class="nc bnc" id="L1866" title="All 2 branches missed.">		if (tsm == null) {</span>
<span class="nc" id="L1867">			tsm = WfmManagerFactory.getTimeSeriesManager();</span>
		}
<span class="nc" id="L1869">		return tsm;</span>
	}

<span class="nc" id="L1872">	private ScheduleAccessManager sam = null;</span>

	public ScheduleAccessManager getScheduleAccessManager() throws Exception {
<span class="nc bnc" id="L1875" title="All 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L1876">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}
<span class="nc" id="L1878">		return sam;</span>
	}

	/**
	 * Adjusts the NetstaffingCube with Staffing &amp; FTE values as they would look
	 * after approval of request. used by time-off and Cust-shift request area.
	 * Basically, we just plug the predictedTraceCubesMap into the nsCube's
	 * predictTraceCubeMap.
	 * 
	 * @param empID
	 * @param range
	 * @param predictedTraceCubesMap
	 * @return
	 * @throws Exception
	 */
	protected NetStaffingCube getAdjustedNetStaffingCube(HashMap predictedTraceCubesMap, NetStaffingCube nsCube)
			throws Exception {
<span class="nc" id="L1895">		return getAdjustedNetStaffingCube(predictedTraceCubesMap, nsCube, false);</span>
	}

	/**
	 * Adjusts the NetstaffingCube with Staffing &amp; FTE values as they would look
	 * after approval of request. used by time-off and Cust-shift request area.
	 * Basically, we just plug the predictedTraceCubesMap into the nsCube's
	 * predictTraceCubeMap, and optionally recalculate the Net Staffing values.
	 * 
	 * @param empID
	 * @param range
	 * @param predictedTraceCubesMap
	 * @param isRecalcNetStaffing
	 *            - Should the Trace.NETSTAFFING values be recalculated based on
	 *            the Adjusted FTE, Adjusted Staffing, and Required FTE?
	 * @return
	 * @throws Exception
	 */
	protected NetStaffingCube getAdjustedNetStaffingCube(HashMap predictedTraceCubesMap, NetStaffingCube nsCube,
			boolean isRecalcNetStaffing) throws Exception {
<span class="nc" id="L1915">		HashMap&lt;ID, PredictTraceCube&gt; pCubeMap = nsCube.getPredictTraceCubeMap();</span>
<span class="nc" id="L1916">		HashMap&lt;ID, RequireTraceCube&gt; rCubeMap = nsCube.getRequireTraceCubeMap();</span>

<span class="nc bnc" id="L1918" title="All 2 branches missed.">		for (Iterator iMap = predictedTraceCubesMap.values().iterator(); iMap.hasNext();) {</span>
<span class="nc" id="L1919">			Collection recalAfterCreate = (Collection) iMap.next();</span>
<span class="nc bnc" id="L1920" title="All 4 branches missed.">			if (recalAfterCreate != null &amp;&amp; !recalAfterCreate.isEmpty()) {</span>
<span class="nc bnc" id="L1921" title="All 2 branches missed.">				for (Iterator iterator = recalAfterCreate.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1922">					PredictTraceCube pCube = (PredictTraceCube) iterator.next();</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">					if (pCubeMap.containsKey(pCube.getSPQueueSID())) {</span>
<span class="nc" id="L1924">						pCubeMap.put(pCube.getSPQueueSID(), pCube); // replace</span>
																	// the cube

<span class="nc bnc" id="L1927" title="All 2 branches missed.">						if (isRecalcNetStaffing) {</span>
							// recalculate NetStaffing from the updated Adjusted
							// FTE, Adjusted Staffing, and Required FTE values.
<span class="nc" id="L1930">							RequireTraceCube rCube = rCubeMap.get(pCube.getSPQueueSID());</span>
<span class="nc" id="L1931">							TraceCube[] metaCubes = new TraceCube[5];</span>
<span class="nc" id="L1932">							metaCubes[2] = pCube;</span>
<span class="nc" id="L1933">							metaCubes[4] = rCube;</span>
<span class="nc" id="L1934">							TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(metaCubes);</span>
						}
					}
<span class="nc" id="L1937">				}</span>
			}
<span class="nc" id="L1939">		}</span>
<span class="nc" id="L1940">		return nsCube;</span>
	}

	/**
	 * Get the WorkResourceMinMaxHour for the specified employee at the
	 * specified time.
	 */
	public WorkResourceMinMaxHour getMinMaxHourAssignment(ID empID, Date startDate) throws Exception {
		// Check to see if the object is already in the cache
<span class="nc" id="L1949">		String cacheKey = WORKRESOURCE_MIN_MAX_HOURS + &quot;_&quot; + empID + &quot;_&quot; + startDate.getTime();</span>
<span class="nc" id="L1950">		WorkResourceMinMaxHour result = (WorkResourceMinMaxHour) get(cacheKey);</span>

		// If map object in the cache, use it
<span class="nc" id="L1953">		String methodName = &quot;getMinMaxHourAssignment: &quot;;</span>
<span class="nc bnc" id="L1954" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L1955">			m_cat.debug(methodName + result);</span>
<span class="nc" id="L1956">			return result;</span>
		}

<span class="nc" id="L1959">		Collection&lt;WorkResourceMinMaxHour&gt; wrMinMaxCol = WfmManagerFactory.getEmpWorkRuleManager()</span>
<span class="nc" id="L1960">				.getMinMaxHourAssignments(empID, startDate, startDate);</span>
<span class="nc bnc" id="L1961" title="All 2 branches missed.">		for (WorkResourceMinMaxHour wrMinMax : wrMinMaxCol) {</span>
<span class="nc" id="L1962">			result = wrMinMax;</span>
<span class="nc" id="L1963">			break; // there should only be one since we pass startDate,</span>
					// startDate.
		}

		// Save in cache
<span class="nc" id="L1968">		put(cacheKey, result);</span>

<span class="nc bnc" id="L1970" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1971">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L1974">		return result;</span>
	}

	/**
	 * Returns the aggregate value of the specified trace over the specified
	 * interval, with Double precision.
	 * &lt;p&gt;
	 * The result is not necessarily an integer. If an integer value is desired
	 * use TraceUtil.roundDouble to round the value to an integer.
	 *
	 * @param TraceCube
	 *            cube
	 * @param cubeCacheKey
	 *            - the unique identifier for this NetStaffingCube. It will be
	 *            used for caching aggregations in the ValidationCache.
	 * @param traceType
	 *            the trace to aggregate within the cube
	 * @param begin
	 *            interval start point
	 * @param end
	 *            interval end point
	 * @return the aggregate value for the specified period. This value is not
	 *         necessarily integral. If an integer value is desired use
	 *         TraceUtil.roundDouble to round the value to an integer.
	 */
	public double aggregatePeriodD(TraceCube cube, String cubeCacheKey, short traceType, int begin, int end) {
		// Check to see if the object is already in the cache
<span class="nc" id="L2001">		String cacheKey = TRACECUBE_AGGREGATION + &quot;_&quot; + cubeCacheKey + &quot;_Q&quot; + cube.getQueueID() + &quot;_Stat&quot; + traceType</span>
				+ &quot;_From&quot; + begin + &quot;_To&quot; + end;
<span class="nc" id="L2003">		Double result = (Double) get(cacheKey);</span>

		// If object found in the cache, use it
<span class="nc" id="L2006">		String methodName = &quot;aggregatePeriodD: &quot;;</span>
<span class="nc bnc" id="L2007" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L2008">			m_cat.debug(methodName + result);</span>
<span class="nc" id="L2009">			return result;</span>
		}

<span class="nc" id="L2012">		result = TraceOperator.aggregatePeriod(cube, traceType, begin, end);</span>

		// Save in cache
<span class="nc" id="L2015">		put(cacheKey, result);</span>

<span class="nc bnc" id="L2017" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2018">			m_cat.debug(methodName + result);</span>
		}

<span class="nc" id="L2021">		return result;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>