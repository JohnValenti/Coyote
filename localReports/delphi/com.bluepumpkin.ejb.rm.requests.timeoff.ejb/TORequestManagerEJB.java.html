<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TORequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.ejb</a> &gt; <span class="el_source">TORequestManagerEJB.java</span></div><h1>TORequestManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * TORequestManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.ejb;

import java.rmi.RemoteException;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeSet;

import javax.naming.Context;
import javax.naming.InitialContext;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategoryFilter;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.ReportDumpStatistic;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffYearlyDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.EmpTOAccruedNotificationDetail;
import com.bluepumpkin.ejb.rm.notification.model.RequestNotificationDetail;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.ejb.param.RequestCountParam;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleChecker;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDayFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexRequestMakeup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOIntervalCalendar;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequestFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffActivitySummary;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffEventSummary;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TOValidationCache;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TentativeRequestHardValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoiceHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprOrTentAppNotZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsHoliday;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceContainsOrgChange;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLength;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLengthHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationPublishedStatusRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.ValidTimeOffChoicesValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOff;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOffHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb.TOWaitlistManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.ejb.TOWithdrawManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.model.TOWithdraw;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBidDAO;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.model.TimeOffBid;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TOIntervalCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TONotifyMessageClient;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;

/**
 * @author Raja Rajendran
 *         &lt;p/&gt;
 *         &lt;p&gt;
 *         see {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest#getTimeOffDebitType() getTimeOffDebitType} for
 *         information about TO debit types and how they map to CalendarEventAssignments in the schedule.
 *         &lt;p/&gt;
 *         &lt;p&gt;
 *         see {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest#getTimeOffType() getTimeOffType} for information about
 *         activities and their attributes used in timeOff events.
 *         &lt;p/&gt;
 *         Tentative approvals require special hard validations
 *         &lt;p/&gt;
 *         if soft validations are disabled when fetching a request, time off lengths will not be computed.
 *         &lt;p/&gt;
 */
<span class="nc" id="L161">public class TORequestManagerEJB extends RequestAggregateManager { // OUTSIDE_CONTAINER</span>
<span class="nc" id="L162">	private static final String CLASS_NAME = TORequestManagerEJB.class.getName();</span>
<span class="nc" id="L163">	private static Category m_cat = Log.initCategory(CLASS_NAME);</span>

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

<span class="nc" id="L167">	private boolean WhatIfMode = false;</span>
<span class="nc" id="L168">	private static int REPORTDUMP_MAX_RETRY = 10;</span>
<span class="nc" id="L169">	private static int USERTRANSACTION_TIMEOUT = 600;</span>

	@Override
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="nc" id="L175">			Context initialContext = new InitialContext();</span>
<span class="nc" id="L176">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">			if (WIF != null) {</span>
<span class="nc" id="L178">				WhatIfMode = WIF.booleanValue();</span>
			}
<span class="nc" id="L180">		} catch (Exception e) {</span>
<span class="nc" id="L181">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="nc" id="L182">		}</span>
<span class="nc" id="L183">	}</span>

	/**
	 * Array of hard validation classes
	 */
<span class="nc" id="L188">	protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
<span class="nc" id="L189">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L191">			new ValidatorDescriptor(WorkableTimeValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L193">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOffHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L195">			new ValidatorDescriptor(AgentGoodStandingValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L196">			new ValidatorDescriptor(ValidTimeOffChoicesValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L197">			new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
			// validator run only when updating a requests as approved or tentatively approved and has the specified detail level.
<span class="nc" id="L200">			new ValidatorDescriptor(TimeOffChoiceApprOrTentAppNotZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_MODIFIER,</span>
					new String[] { RequestAuditTrail.STATUS_APPROVED, RequestAuditTrail.STATUS_TENTATIVE }, TORequest.DL_BASIC
							| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L203">			new ValidatorDescriptor(TimeOffChoiceHasZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC) };</span>

<span class="nc" id="L205">	protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArrWithAdvancedLicense = {</span>
<span class="nc" id="L206">			new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L208">			new ValidatorDescriptor(WorkableTimeValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L210">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOffHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L212">			new ValidatorDescriptor(AgentGoodStandingValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L214">			new ValidatorDescriptor(ValidTimeOffChoicesValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, TORequest.DL_BASIC),</span>
<span class="nc" id="L215">			new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
			// validator run only when updating a requests as approved or tentatively approved and has the specified detail level.
<span class="nc" id="L218">			new ValidatorDescriptor(TimeOffChoiceApprOrTentAppNotZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_MODIFIER,</span>
					new String[] { RequestAuditTrail.STATUS_APPROVED, RequestAuditTrail.STATUS_TENTATIVE }, TORequest.DL_BASIC
							| TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L221">			new ValidatorDescriptor(TimeoffIntervalAllocationPublishedStatusRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES),
<span class="nc" id="L223">			new ValidatorDescriptor(TimeoffIntervalAllocationReferenceScheduleRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
					TORequest.DL_BASIC),
<span class="nc" id="L225">			new ValidatorDescriptor(TimeOffChoiceHasZeroLengthHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null, TORequest.DL_BASIC),</span>

			//Time off Bid hard validation=&gt; Should move to Time Off Bid areas when TOB Enhancement is added.
<span class="nc" id="L228">			new ValidatorDescriptor(TimeOffBidPeriodPerChoiceHV.class.getName(), RequestUtil.METHODTYPE_ALL_EXCEPT_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES) };

<span class="nc" id="L231">	private final static ValidatorDescriptor[] m_softValidatorDescMandArr = {</span>
			// validator run only when fetching a request with the specified detail level.
<span class="nc" id="L233">			new ValidatorDescriptor(TimeOffChoiceHasZeroLength.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L235">			new ValidatorDescriptor(TimeOffChoiceContainsHoliday.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L237">			new ValidatorDescriptor(TimeOffChoiceContainsOrgChange.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH) };

<span class="nc" id="L240">	private final static ValidatorDescriptor[] m_softValidatorDescMandArrWithAdvanceLicense = {</span>
			// validator run only when fetching a request with the specified detail level.
<span class="nc" id="L242">			new ValidatorDescriptor(TimeOffChoiceHasZeroLength.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L244">			new ValidatorDescriptor(TimeOffChoiceContainsHoliday.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L246">			new ValidatorDescriptor(TimeOffChoiceContainsOrgChange.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L248">			new ValidatorDescriptor(WorkableTimeWithinScheduleTimeOff.class.getName(), RequestUtil.METHODTYPE_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L250">			new ValidatorDescriptor(AgentGoodStandingValidationRule.class.getName(), RequestUtil.METHODTYPE_FINDER, null,</span>
					TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH),
<span class="nc" id="L252">			new ValidatorDescriptor(TimeOffBidPeriodPerChoice.class.getName(), RequestUtil.METHODTYPE_FINDER, null, TORequest.DL_BASIC</span>
					| TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH) };

	{
<span class="nc" id="L256">		super.init(TORequestManagerEJB.class.getName());</span>
<span class="nc" id="L257">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L264">		return m_cat;</span>
	}

	/**
	 * Return the possible states for a request of this type.
	 *
	 * @return a List of the possible states for requests of this type.
	 */
	@Override
	public List getPossibleStates() {
<span class="nc" id="L274">		return RequestAuditTrail.TO_POSSIBLE_STATES;</span>
	}

	@Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc bnc" id="L279" title="All 2 branches missed.">		return hasAdvanceLicense() ? m_hardValidatorDescriptorArrWithAdvancedLicense : m_hardValidatorDescriptorArr;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
	 */
	@Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc bnc" id="L289" title="All 2 branches missed.">		return hasAdvanceLicense() ? m_softValidatorDescMandArrWithAdvanceLicense : m_softValidatorDescMandArr;</span>
	}

	// protected Collection getSoftValidationStates() {
	// return TORequest.getSoftValidationStates();
	// }

	@Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L298">		return new TORequestDAO(detailLevel);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
	 */
	@Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L308">		return RequestUtil.getTORequestMgr(null, null);</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
	 */
	@Override
	protected String getRequestType() {
<span class="nc" id="L318">		return Request.REQUESTTYPE_TIMEOFF;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#processBeforeCreate(com.bluepumpkin.ejb.rm.requests.common
	 * .model.RequestAggregate)
	 */
	@Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L330">		super.createRequestPreProcess(reqAgg, reqAggDAO);</span>

<span class="nc" id="L332">		TORequest tor = (TORequest) reqAgg;</span>

<span class="nc" id="L334">		tor.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>

		// validate debit type
<span class="nc" id="L337">		String debittype = tor.getTimeOffDebitType();</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">		if (debittype == null) {</span>
<span class="nc" id="L339">			tor.setTimeOffDebitType(TORequest.DEBITTYPE_DEBIT);</span>
		}
<span class="nc bnc" id="L341" title="All 2 branches missed.">		if (!TORequest.VALID_DEBITTYPES.contains(debittype)) {</span>
<span class="nc" id="L342">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_DEBIT_TYPE, new Object[] { debittype }, m_cat);</span>
		}

		// Check if Employee and activity are not null. They are defined as foreign keys in the
		// database, so let that constraint check that they are valid.
<span class="nc bnc" id="L347" title="All 2 branches missed.">		if (tor.getEmployeeID() == null) {</span>
<span class="nc" id="L348">			throw RequestUtil.createRmException(RmEjbLogBundleKey.REQUESTED_FOR_NULL, m_cat);</span>
		}

<span class="nc bnc" id="L351" title="All 2 branches missed.">		if (tor.getTimeOffType() == null) {</span>
<span class="nc" id="L352">			throw RequestUtil.createRmException(RmEjbLogBundleKey.ACTIVITY_NULL, m_cat);</span>
		}

		// Check that the request at least has choices specified. The validity
		// of the choices themselves will be checked in the TOChoiceDAO
<span class="nc" id="L357">		Collection&lt;TOChoice&gt; choices = tor.getRequestChoiceList();</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (choices.isEmpty()) {</span>
<span class="nc" id="L359">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_CHOICE_LIST, null, m_cat);</span>
		}

		// validate flex type
<span class="nc" id="L363">		int flextype = tor.getFlexType();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		if (!TORequest.VALID_FLEXTYPES.contains(flextype)) {</span>
<span class="nc" id="L365">			throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_FLEX_TYPE, new Object[] { flextype }, m_cat);</span>
		}

		// Check that the request at least has flex makeups specified if FLEXTYPE is flex with makeup.
		// The validity of the makeups themselves will be checked in the FlexRequestMakeupDAO.
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (flextype == TORequest.FLEXTYPE_FLEXWITHMAKEUP) {</span>
<span class="nc" id="L371">			Collection&lt;FlexRequestMakeup&gt; makeups = tor.getFlexRequestMakeupList();</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">			if (makeups.isEmpty()) {</span>
<span class="nc" id="L373">				throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_FLEXMAKEUP_LIST, null, m_cat);</span>
			}
		}

<span class="nc" id="L377">		updateExpiration(tor);</span>
<span class="nc" id="L378">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
	 */
	@Override
	protected void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception {
<span class="nc bnc" id="L387" title="All 2 branches missed.">		for (Iterator iter = reqAggs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L388">			TORequest toReq = (TORequest) iter.next();</span>

			// if no 'getRequestPostProcess' is needed, skip this.
<span class="nc bnc" id="L391" title="All 2 branches missed.">			if (!toReq.isGetRequestPostProcNeeded()) {</span>
<span class="nc" id="L392">				continue;</span>
			}

			// compute TO choices length only if the detail level is enabled.
<span class="nc bnc" id="L396" title="All 2 branches missed.">			if ((detailLevel &amp; TORequest.DL_TIMEOFF_CHOICES_LENGTH) != 0) {</span>
<span class="nc" id="L397">				TORequestUtil.fillTOChoicesLengthIfNecess(toReq, false);</span>
			}
<span class="nc bnc" id="L399" title="All 4 branches missed.">			if (toReq.isEligibleForAcceptWithdrawAction() || toReq.isEligibleForRejectWithdrawAction()) {</span>
<span class="nc" id="L400">				getTOWithdrawManager().runSoftValidationsForTOWithdrawRequest(toReq);</span>
			}
<span class="nc" id="L402">		}</span>
<span class="nc" id="L403">	}</span>

	@Override
	protected void getRequestPreValidationProcess(Collection reqAggs, long detailLevel) throws Exception {
<span class="nc" id="L407">		getTOHoursPerDayManager().getTOHoursPerDaysByTimeOffRequestIds(reqAggs);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">		for (Iterator iter = reqAggs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L409">			TORequest toReq = (TORequest) iter.next();</span>
			// allow waitlisting any number of times;
			// if (toReq.getWaitlistInfo() == null) {
<span class="nc" id="L412">			toReq.setEligibleForWaitlist(isRequestEligibleForWaitlist(toReq));</span>
			// }
<span class="nc" id="L414">		}</span>
<span class="nc" id="L415">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestWorkFlow(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean, boolean)
	 */
	@Override
	protected void _approveRequestWorkFlow(RequestAggregate reqAgg, ID choiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {

		// not clean but necessary. if specified choiceID is null, maps it
		// to the right TOChoice ID and set the ID in the request.
<span class="nc bnc" id="L430" title="All 2 branches missed.">		if (choiceID == null) {</span>
<span class="nc" id="L431">			choiceID = getApprChoiceIDIfNull(reqAgg, choiceID);</span>
		}

<span class="nc" id="L434">		super._approveRequestWorkFlow(reqAgg, choiceID, comment, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L435">	}</span>

	/**
	 * @param apprChoiceID if null, see {@link #getApprChoiceIDIfNull(RequestAggregate, ID) getApprChoiceIDIfNull()} method.
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#
	 *      _approveRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID,
	 *      java.lang.String, boolean)
	 */
	@Override
	protected void _approveRequest(RequestAggregate reqAgg, ID apprChoiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {

		// handle the case if the specified apprChoiceID == null.
<span class="nc" id="L448">		apprChoiceID = getApprChoiceIDIfNull(reqAgg, apprChoiceID);</span>

<span class="nc" id="L450">		m_cat.debug(RmUtil.dumpEnterMethod(&quot;_approveRequest&quot;, apprChoiceID, comment, new Boolean(suppressPrivilegeChecking)));</span>

<span class="nc" id="L452">		String methodName = &quot;_approveRequest&quot;; // passed to other methods</span>
<span class="nc" id="L453">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, apprChoiceID, comment, new Boolean(suppressPrivilegeChecking)));</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L455">			approveTORequest(reqAgg, apprChoiceID, comment, suppressPrivilegeChecking, loadedFromDB,false);</span>
		} else { //normal Time off requests
<span class="nc" id="L457">			approveTORequest(reqAgg, apprChoiceID, comment, suppressPrivilegeChecking, loadedFromDB, hasAdvanceLicense());</span>
		}

<span class="nc" id="L460">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L461">	}</span>

	private void approveTORequest(RequestAggregate reqAgg, ID apprChoiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB, boolean skipSomeHardRulesWhenUpdate) throws Exception {
<span class="nc" id="L465">		TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L466">		String oldStatus = toReq.getRequestStatus();</span>

		// to indicate that lengths are used in hard validator TimeOffChoiceApprOrTentApprNotZeroLengthHV.java.
<span class="nc" id="L469">		toReq.addDetailLevel(TORequest.DL_TIMEOFF_CHOICES_LENGTH);</span>
<span class="nc" id="L470">		toReq.addDetailLevel(TORequest.DL_AUDIT_TRAIL);</span>
<span class="nc" id="L471">		toReq.setTOChoiceForValidation(toReq.getTOChoice(apprChoiceID));</span>
		/*
		 * Only The choice that is being Approved should be validated. This is done to ensure that Hard validations are run only on
		 * the TO choice that is being approved. We are not interested in Hard validating other choices, since they are redundant
		 * here
		 */
<span class="nc" id="L477">		TOChoice apprChoice = updateRequestWithApprovedChoice(toReq, apprChoiceID, RequestAuditTrail.STATUS_APPROVED, comment,</span>
				RequestAuditTrail.STATUS_APPROVED, suppressPrivilegeChecking, loadedFromDB, skipSomeHardRulesWhenUpdate);

		// if approving a non tentatively approved request, create a new event in the schedule
		// if approving a tentatively approved request, no need to do anything since event already exists in unpublished schedule
		// This reqd for updating the requests comments in the TOEvent Description field
		// Sameet, Jan 2009
		// RequestAggregate req = getRequestByID(reqAgg.getID(), false, false, TORequest.DL_AUDIT_TRAIL);
		// String com = RequestUtil.getAuditTrailStr((TORequest) reqAgg);
<span class="nc" id="L486">		TOValidationCache cache = (TOValidationCache) toReq.getValidationCache();</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">		if (!oldStatus.equals(RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L488">			RequestUtil.createCalendarEventAssignment(toReq, apprChoice, true);// , com);</span>
		} else {
<span class="nc" id="L490">			CalendarEventAssignment event = TORequestUtil.getCalEventAssignForTOChoiceAligned(toReq, apprChoice, false, null);</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">			if (event != null &amp;&amp; event.getStartTime().equals(apprChoice.getStartDate())</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">					&amp;&amp; event.getEndTime().equals(apprChoice.getEndDate()) &amp;&amp; event.getActivityID().equals(toReq.getTimeOffType())) {</span>
<span class="nc" id="L493">				String com = RequestUtil.getAuditTrailStr((TORequest) reqAgg);</span>
<span class="nc" id="L494">				event.setDescription(com);</span>
<span class="nc" id="L495">				ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L496">				sam.updateCalendarEventAssignment(event);</span>
			}
		}
<span class="nc bnc" id="L499" title="All 4 branches missed.">		boolean stafingExists = !RequestUtil.isNetStaffingUpdateForTOMDisabled() &amp;&amp; cache.doesStaffingExistForPeriod(toReq, apprChoice);</span>
<span class="nc" id="L500">		HashMap postTracecubes = null;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">		if (stafingExists) {</span>
<span class="nc" id="L502">			NetStaffingCube nsCube = cache.getPostTOApprovalNetStaffingCube(toReq, apprChoice);</span>
<span class="nc bnc" id="L503" title="All 4 branches missed.">			if (nsCube != null &amp;&amp; !nsCube.getPredictTraceCubeMap().isEmpty()) {</span>
<span class="nc" id="L504">				postTracecubes = cache.getPostTOReqTraceCube(toReq, apprChoice, nsCube.getTimeRange());</span>
<span class="nc" id="L505">				cache.getTimeSeriesManager().updateAdjustedFTEAndStaffing(postTracecubes);</span>
			}
		}
		// publish event.
<span class="nc" id="L509">		publishTOChoiceTimeRange(reqAgg, apprChoice);</span>
<span class="nc bnc" id="L510" title="All 4 branches missed.">		if (stafingExists &amp;&amp; postTracecubes != null) {</span>
<span class="nc" id="L511">			cache.getTimeSeriesManager().updateAdjustedFTEAndStaffing(postTracecubes);</span>
		}

<span class="nc" id="L514">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
	 */
	@Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, ID choiceID, String comment) {
<span class="nc" id="L525">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestTentatively(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean)
	 */
	@Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, ID apprChoiceID, String comment, boolean loadedFromDB)
			throws Exception {

		// handle the case if the specified apprChoiceID == null.
<span class="nc" id="L539">		apprChoiceID = getApprChoiceIDIfNull(reqAgg, apprChoiceID);</span>

<span class="nc" id="L541">		String methodName = &quot;_approveRequestTentatively&quot;;</span>
<span class="nc" id="L542">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, apprChoiceID, comment));</span>

<span class="nc" id="L544">		TORequest toReq = (TORequest) reqAgg;</span>

<span class="nc" id="L546">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
		// check for overlapping calendar events
<span class="nc" id="L548">		Collection overlapEvents = TORequestUtil</span>
<span class="nc" id="L549">				.getCalEventAssignsForTOChoiceOverlapped(toReq, toReq.getTOChoice(apprChoiceID), false, sam);</span>

		// if found overlapping events, throw exception
<span class="nc bnc" id="L552" title="All 4 branches missed.">		if (overlapEvents != null &amp;&amp; !overlapEvents.isEmpty()) {</span>
<span class="nc" id="L553">			throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.TO_UNABLE_TO_UNDO_TENTAPPR, m_cat);</span>
		}

		// to indicate that lengths are used in hard validator TimeOffChoiceApprOrTentApprNotZeroLengthHV.java.
<span class="nc" id="L557">		toReq.addDetailLevel(TORequest.DL_TIMEOFF_CHOICES_LENGTH);</span>
<span class="nc" id="L558">		toReq.addDetailLevel(TORequest.DL_AUDIT_TRAIL);</span>
		// approve 1st timeoff choice if none specified
<span class="nc" id="L560">		TOChoice apprChoice = null;</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L562">			apprChoice = updateRequestWithApprovedChoice(toReq, apprChoiceID, RequestAuditTrail.STATUS_TENTATIVE, comment,</span>
				RequestAuditTrail.STATUS_TENTATIVE, false, loadedFromDB, false);
		} else {
<span class="nc" id="L565">			apprChoice = updateRequestWithApprovedChoice(toReq, apprChoiceID, RequestAuditTrail.STATUS_TENTATIVE, comment,</span>
<span class="nc" id="L566">					RequestAuditTrail.STATUS_TENTATIVE, false, loadedFromDB, hasAdvanceLicense());</span>
		}
		
		// RequestAggregate req = getRequestByID(reqAgg.getID(),false,false,TORequest.DL_AUDIT_TRAIL);
		// String com =RequestUtil.getAuditTrailStr((TORequest)reqAgg);
<span class="nc" id="L571">		RequestUtil.createCalendarEventAssignment(toReq, apprChoice, false);// ,com);</span>

<span class="nc" id="L573">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L574">	}</span>

	/**
	 * If the givenApprChoiceID is null: &lt;li&gt;first checks the approved choiceID in the request. if non-null, returns it. This is
	 * necessary since cofirm_all_tentative group action passes a tentatively approved request with a proper approvedChoiceID but
	 * specifies 'null' for the givenChoiceID. &lt;li&gt;If null, then returns the first TOChoice ID.
	 *
	 * @param reqAgg
	 * @param givenApprChoiceID
	 * @return
	 */
	private ID getApprChoiceIDIfNull(RequestAggregate reqAgg, ID givenApprChoiceID) {
		// if the given approved choice ID is not null, simply return.
<span class="nc bnc" id="L587" title="All 2 branches missed.">		if (givenApprChoiceID != null) {</span>
<span class="nc" id="L588">			return givenApprChoiceID;</span>
		}

<span class="nc" id="L591">		TORequest toReq = (TORequest) reqAgg;</span>

		// check if the approved choice ID is set in the request when the givenApprChoiceID == null
		//
		// Happens when using CONFIRM_TENT_ALL group processing. In this case,
		// the request has the approved choice ID but the group processing logic specifies 'null'
		// for the choiceID to be approved.
<span class="nc" id="L598">		givenApprChoiceID = toReq.getApprovedChoiceID();</span>
		// if still null, use the first choice
<span class="nc bnc" id="L600" title="All 2 branches missed.">		if (givenApprChoiceID == null) {</span>
<span class="nc" id="L601">			givenApprChoiceID = toReq.getFirstTOChoice().getID();</span>
		}

<span class="nc" id="L604">		return givenApprChoiceID;</span>
	}

	@Override
	protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB)
			throws Exception {
<span class="nc" id="L610">		String oldStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L611" title="All 2 branches missed.">		if(reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L612">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null,suppressPrivilegeChecking, loadedFromDB);</span>
		}else {
<span class="nc" id="L614">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L615">					hasAdvanceLicense());</span>
		}
<span class="nc bnc" id="L617" title="All 2 branches missed.">		if (oldStatus.equals(RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L618">			TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L619">			TOChoice apprChoice = toReq.getApprovedChoice();</span>
<span class="nc" id="L620">			TORequestUtil.deleteCalendarEventAssignment(toReq, apprChoice);</span>
		}
<span class="nc" id="L622">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests
	 * .common.model.RequestAggregate, java.lang.String)
	 */
	@Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
<span class="nc" id="L633">	}</span>

	@Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment) throws Exception {
<span class="nc" id="L637">		String methodName = &quot;_undoTentativeApprovalByID&quot;;</span>
<span class="nc" id="L638">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqID, objectVersionNumber, comment));</span>
<span class="nc" id="L639">		RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">		if (objectVersionNumber != null) {</span>
<span class="nc" id="L641">			reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
		}

		// change status to pending
<span class="nc" id="L645">		TORequest toReq = (TORequest) reqAgg;</span>

		// perform hard validation. Note that this is a hack. If hard validations are performed within
		// the _updateRequest() method below, a call to TORequest.getTOChoice(TORequest.getApprChoiceID()) fails in the
		// hardValidator TentativeRequestHardValidationRule. This is because TOReq.setApprovedChoiceID(null) is
		// invoked below before the hard validator is run. To get around this problem, the hard validations are
		// performed outside the _updateRequest() method. Note that 'true' is passed for the suppressHardVal
		// parameter in the _updateRequest() call below. Code needs to be refactored to fix this.
		//
		// All update operations need to perform the following:
		// load the entire request or fill the fields in a partial request (webtier passes an incomplete
		// VO when updating just one or two fields in the VO. for example when updating the
		// shiftBidRequest's usePoints field.).
		// checkStateTransistion
		// checkPrivilege
		// perform hardValidations
		// do other operations related to update (for example, on approval create TOEvent.
		// finally perform the update.
		//
		// The current logic does the following which is flawed.
		// load the entire request if necessary.
		// update part of the request (in this case apprChoice is set to null).
		// fill up the fields if the request is partial
		// checkStateTransitionAndPriv.
		// runHardValiations (Note, the request is in a partially updated state).
		// perform update
		// perform other operations related to update (Note this may happen before or after the above update operation).
<span class="nc" id="L672">		doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_MODIFIER, null, false);</span>

<span class="nc" id="L674">		TOChoice oldApprChoice = toReq.getApprovedChoice();</span>
<span class="nc" id="L675">		toReq.setApprovedChoiceID(null); // clear approved TOChoice</span>
<span class="nc" id="L676">		_updateRequest(toReq, RequestAuditTrail.STATUS_PENDING, comment, null, true, false, true);</span>

<span class="nc" id="L678">		TORequestUtil.deleteCalendarEventAssignment(toReq, oldApprChoice);</span>

<span class="nc" id="L680">		m_cat.debug(RmUtil.dumpExitMethod(methodName, reqAgg));</span>
<span class="nc" id="L681">		return reqAgg;</span>
	}

	/**
	 * &lt;li&gt;For TORequests, the TOChoices can be updated. This update is not done in place by updating the fields of the existing
	 * TOChoices. Instead existing TOChoices are deleted and the new ones are added.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#updateRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate,
	 *      com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO, boolean)
	 */
	@Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, boolean loadedFromDB)
			throws Exception {
<span class="nc bnc" id="L694" title="All 2 branches missed.">		boolean needToAllocDAO = (reqAggDAO == null);</span>
		try {
<span class="nc" id="L696">			TORequest tor = (TORequest) reqAgg;</span>

<span class="nc" id="L698">			long detailLevel = getDetailLevelForValidation();</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">			reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevel) : reqAggDAO;</span>
<span class="nc" id="L700">			TORequest TOReqFromDB = (TORequest) reqAggDAO.getRequestByID(tor.getID(), detailLevel);</span>

			// Validate that the request still belongs to the same employee
<span class="nc bnc" id="L703" title="All 2 branches missed.">			if (!tor.getEmployeeID().equals(TOReqFromDB.getEmployeeID())) {</span>
<span class="nc" id="L704">				throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_CHANGE_EMPLOYEEID,</span>
<span class="nc" id="L705">						new Object[] { tor.getID(), tor.getEmployeeID(), TOReqFromDB.getEmployeeID() }, m_cat);</span>
			}

			// TODO: expiration needs to be updated only when deleteAllChildObjectsFlag() is set.
<span class="nc" id="L709">			updateExpiration(tor);</span>

<span class="nc" id="L711">			return tor;</span>
		} finally {
<span class="nc bnc" id="L713" title="All 8 branches missed.">			if (needToAllocDAO &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L714">				reqAggDAO.cleanUp();</span>
			}
		}
	}

	@Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, Object[] optionalUndoData) throws Exception {

<span class="nc" id="L722">		TORequest toReq = (TORequest) reqAgg;</span>

		// if approved or tentatively approved
<span class="nc bnc" id="L725" title="All 4 branches missed.">		if (toReq.isApproved() || toReq.isTentative()) {</span>
<span class="nc" id="L726">			TOChoice apprChoice = toReq.getApprovedChoice();</span>
			// delete calendar event assignment
			// TODO: delete...() must take sam as an arg.
<span class="nc" id="L729">			TORequestUtil.deleteCalendarEventAssignment(toReq, apprChoice);</span>

			// erase event in published schedule
<span class="nc bnc" id="L732" title="All 2 branches missed.">			if (toReq.isApproved()) {</span>
<span class="nc" id="L733">				unPublishTOChoiceTimeRange(toReq, apprChoice);</span>
			}
		}

		// //delete request
		// reqAggDAO = (reqAggDAO == null) ? new TORequestDAO(TORequest.DL_BASIC) : reqAggDAO;
		// reqAggDAO.deleteObject(toReq.getID());
<span class="nc" id="L740">	}</span>

	/**
	 * @todo: all requests must support setExpirationDate(). In fact, all methods of 'Request' must be supported by RequestAggregate
	 *        subtypes. Use an interface to enforce this.
	 */
	protected void updateExpiration(TORequest toReq) throws Exception {
<span class="nc" id="L747">		Date expDate = new Date(Long.MAX_VALUE); // really big date...akin to never expires</span>

		// Calculate expiration date for this request from the list of associated TOChoices.
		// Also set the rank for the TOChoices.
		/*
		 * Sameet Nov 2006 RM Waitlist Rel: 7.8 Set the expiry Date to the Waitlist TOChoice Start date &amp; also set the Waitlist
		 * Expiry Date if not set by the user.
		 */
<span class="nc" id="L755">		ID apprChoiceID = getApprChoiceIDIfNull(toReq, null);</span>

<span class="nc bnc" id="L757" title="All 4 branches missed.">		if (apprChoiceID != null &amp;&amp; toReq.getTOChoice(apprChoiceID) != null) {</span>
<span class="nc" id="L758">			TOChoice approvedTOChoice = toReq.getTOChoice(apprChoiceID);</span>

<span class="nc bnc" id="L760" title="All 2 branches missed.">			if (TORequestUtil.isTimeOffChoiceForPastDate(toReq, approvedTOChoice)) {</span>
<span class="nc" id="L761">				expDate = new Date(RequestUtil.MAX_DATE.getTime()); // really big date...akin to never expires</span>
			} else {
<span class="nc" id="L763">				expDate = approvedTOChoice.getStartDate();</span>
			}

<span class="nc" id="L766">		} else {</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">			for (Iterator&lt;TOChoice&gt; it = toReq.getRequestChoiceList().iterator(); it.hasNext();) {</span>
<span class="nc" id="L768">				TOChoice choice = it.next();</span>
<span class="nc bnc" id="L769" title="All 4 branches missed.">				if (choice.isWaitlist() &amp;&amp; toReq.getWaitlistInfo() != null) {</span>
<span class="nc" id="L770">					expDate = choice.getStartDate();</span>
<span class="nc" id="L771">					break;</span>
				}
				// Rank values must be set by caller. Do not set it here.
				// Ensure consistent rank values, 1..n.
				// choice.setRank(r++);
				// expiration date is earliest start date among the TOChoices
				// OR
				// Waitlist Choice start date if request is waitlisted
<span class="nc" id="L779">				Date start = choice.getStartDate();</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">				if (start.before(expDate)) {</span>
<span class="nc" id="L781">					expDate = start;</span>
				}

				// Allow TO in the Past Sameet Feb 2009
<span class="nc bnc" id="L785" title="All 2 branches missed.">				if (toReq.getSubmittedOn() == null) {</span>
<span class="nc" id="L786">					RequestAggregate reqFromDB = getRequestByID(toReq.getID(), true, false, Request.DL_BASIC);</span>
<span class="nc" id="L787">					toReq.setSubmittedOn(reqFromDB.getSubmittedOn());</span>
				}
<span class="nc bnc" id="L789" title="All 2 branches missed.">				if (TORequestUtil.isTimeOffChoiceForPastDate(toReq, choice)) {</span>

<span class="nc" id="L791">					expDate = new Date(RequestUtil.MAX_DATE.getTime()); // really big date...akin to never expires</span>
<span class="nc" id="L792">					break;</span>
				}
<span class="nc" id="L794">			}</span>
<span class="nc bnc" id="L795" title="All 4 branches missed.">			if (toReq.getWaitlistInfo() != null &amp;&amp; toReq.getWaitlistInfo().getTOWaitlistExpiryDate() == null) {</span>

<span class="nc" id="L797">				toReq.getWaitlistInfo().setTOWaitlistExpiryDate(expDate);</span>
			}
		}
<span class="nc" id="L800">		toReq.setExpirationDate(expDate);</span>
<span class="nc" id="L801">	}</span>

	private TOChoice updateRequestWithApprovedChoice(TORequest toReq, ID apprChoiceID, String newState, String comment,
			String methodSubType, boolean suppressPrivilegeChecking, boolean loadedFromDB, boolean skipSomeHardRulesWhenUpdate)
			throws Exception { // NOSONAR
		// obtain the 1st timeoff choice if none specified
<span class="nc" id="L807">		toReq.setApprovedChoiceID(apprChoiceID);</span>
<span class="nc" id="L808">		Collection&lt;TOChoice&gt; col = toReq.getRequestChoiceList();</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">		if (col != null &amp;&amp; col.size() &gt; 1) {</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">			for (Iterator&lt;TOChoice&gt; iterator = col.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L811">				TOChoice choice = iterator.next();</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">				if (choice.getID().equals(apprChoiceID)) {</span>
<span class="nc" id="L813">					choice.setRank(1);</span>
<span class="nc" id="L814">					toReq.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
				} else {
<span class="nc" id="L816">					choice.setRank(0);</span>
<span class="nc" id="L817">					toReq.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
				}
<span class="nc" id="L819">			}</span>
		}
<span class="nc" id="L821">		_updateRequest(toReq, newState, comment, methodSubType, false, suppressPrivilegeChecking, loadedFromDB, skipSomeHardRulesWhenUpdate);</span>
<span class="nc" id="L822">		TOChoice apprChoice = toReq.getApprovedChoice();</span>
<span class="nc" id="L823">		return apprChoice;</span>
	}

	/**
	 * @return
	 */
	@Override
	protected ID getPrivIDApproveEscalated() {
<span class="nc" id="L831">		return PrivilegeKeys.TOM_APPROVEESCALATEDREQUESTS_ID;</span>
	}

	/**
	 * @return
	 */
	@Override
	protected ID getPrivIDApprovePending() {
<span class="nc" id="L839">		return PrivilegeKeys.TOM_APPROVEPENDINGREQUESTS_ID;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDEscalate()
	 */
	@Override
	protected ID getPrivIDEscalate() {
<span class="nc" id="L849">		return PrivilegeKeys.TOM_ESCALATEDENIEDREQUESTS_ID;</span>
	}

	/**
	 * @return
	 */
	@Override
	protected ID getPrivIDModifyReqsForEmp() {
<span class="nc" id="L857">		return PrivilegeKeys.TOM_MODIFYREQUESTSFOREMPLOYEE_ID;</span>
	}

	/**
	 * @return
	 */
	@Override
	protected ID getPrivIDModifyPersonalReqs() {
		// TODO Auto-generated method stub
<span class="nc" id="L866">		return PrivilegeKeys.TOM_MODIFYPERSONALREQUESTS_ID;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
	 */
	@Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L876">		return PrivilegeKeys.TOM_PURGEREQUESTS_ID;</span>
	}

	private void publishTOChoiceTimeRange(RequestAggregate reqAgg, TOChoice apprChoice) throws Exception { // NOSONAR
<span class="nc" id="L880">		m_cat.debug(&quot;Publishing TOReq, apprvChoice: &quot; + reqAgg + '\n' + apprChoice);</span>
<span class="nc" id="L881">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L882">		sam.publishTimeOffEvents(Collections.singleton(reqAgg.getEmployeeID()), apprChoice.getStartDate(), apprChoice.getEndDate());</span>
<span class="nc" id="L883">	}</span>

	private void unPublishTOChoiceTimeRange(RequestAggregate reqAgg, TOChoice apprChoice) throws Exception {
<span class="nc" id="L886">		m_cat.debug(&quot;Un-Publishing TOReq, apprvChoice: &quot; + reqAgg + '\n' + apprChoice);</span>
<span class="nc" id="L887">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L888">		sam.unPublishTimeOffEvents(Collections.singleton(reqAgg.getEmployeeID()), apprChoice.getStartDate(), apprChoice.getEndDate());</span>
<span class="nc" id="L889">	}</span>

	/**
	 * Add columns necessary to process a query governed by the given filter. The caller has already added columns from the REQUEST
	 * (as A), EMPLOYEE (as B) and PERSON (as C) tables. Columns from new tables should start with D as a column synonym. See
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified, {@link #addToWhereClause addToWhereClause} for
	 * how the where clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by a
	 * request manager to reflect type-specific filtered queries. Columns added by this method should insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic columns have already been added, this method should append its
	 *            columns.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToSelectColumns(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc bnc" id="L904" title="All 4 branches missed.">		if (Request.SORT_CS_STARTTIME == sortColumn || Request.SORT_CS_ENDTIME == sortColumn) {</span>
<span class="nc" id="L905">			query.append(&quot;, max(TOR.FLEXTYPE) AS FLEXTYPE &quot;);</span>
		} else {
<span class="nc" id="L907">			query.append(&quot;, TOR.FLEXTYPE &quot;);</span>
		}

		// Note: Since a 'SELECT DISTINCT' clause may be used in the query, any columns used for sorting must be
		// listed in the 'SELECT' statement.
		//
		// Add TimeOff specific columns to result set. The result set columns
		// need to contain any column that might be sorted on. For TIME OFF
		// requests, we might want to sort on the start or end date of the
		// first choice. We add the TIMEOFFREQUESTCHOICE choice table twice
		// but when referred to as E, it represents only the first choice
<span class="nc bnc" id="L918" title="All 2 branches missed.">		if (sortColumn == Request.SORT_TO_ACTIVITY) {</span>
<span class="nc" id="L919">			query.append(&quot;, TOR.ACTIVITYID &quot;);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_DEBIT_TYPE) {</span>
<span class="nc" id="L921">			query.append(&quot;, TOR.DEBITTYPE &quot;);</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_START) {</span>
<span class="nc" id="L923">			query.append(&quot;, TORC1.STARTTIME &quot;);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_END) {</span>
<span class="nc" id="L925">			query.append(&quot;, TORC1.ENDTIME &quot;);</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_SENIORITY) {</span>
<span class="nc" id="L927">			query.append(&quot;, &quot; + TABLE_EMPLOYEEAM_ALIAS + &quot;.STARTTIME &quot;);</span>
		} // else if (sortColumn == Request.SORT_ORGANIZATION_NAME){
			// query.append(&quot;, &quot;).append(&quot; ORG.NAME &quot;);
			// }
<span class="nc" id="L931">	}</span>

	/**
	 * Add tables necessary to process a query governed by the given filter. The caller has already added the REQUEST (as A),
	 * EMPLOYEE (as B) and PERSON (as C) tables. New tables should start with D as a column synonym. See
	 * {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified, {@link #addToWhereClause
	 * addToWhereClause} for how the where clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by
	 * clause is modified by a request manager to reflect type-specific filtered queries. Tables added by this method should insert
	 * a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic tables have already been added, this method should append its
	 *            tables with a leading comma and start with D as a synonym.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToFromClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
		// Add tables for TimeOff specific columns to result set. The result set columns
		// need to contain any column that might be sorted on. For TIME OFF
		// requests, we might want to sort on the start or end date of the
		// first choice. Since we also want to look at the date information
		// in other choices, we include the TIMEOFFREQUESTCHOICE table twice
<span class="nc" id="L952">		query.append(&quot;, TIMEOFFREQUEST TOR, TIMEOFFREQUESTCHOICE TORC1, V_TIMEOFFREQUESTCHOICE TORC2 &quot;); // , ORGANIZATION ORG &quot;);</span>

		// If we need to filter on full or partial day, then we'll need the EMPLOYEETIMEOFF
		// table as well
<span class="nc bnc" id="L956" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY)) {</span>
<span class="nc" id="L957">			query.append(&quot;, EMPLOYEETIMEOFF ET &quot;);</span>
		}
<span class="nc bnc" id="L959" title="All 2 branches missed.">		if (RequestAuditTrail.isRequestForWithdrawalStates((String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY))) {</span>
<span class="nc" id="L960">			query.append(&quot;, TIMEOFFWITHDRAWALREQUEST TWR &quot;);</span>
		}

<span class="nc bnc" id="L963" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L964">			query.append(&quot;, TIMEOFFBID TOB, TIMEOFFBIDDER TOBD, TIMEOFFBIDACTIVITY TBA, ACTIVITY ACT&quot;);</span>
		}
<span class="nc" id="L966">	}</span>

	/**
	 * Add conditions necessary to process a query governed by the given filter. The caller has already added the generic where
	 * conditions. See {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified, {@link #addToFromClause
	 * addToFromClause} for how the from clause is modified, and {@link #addOrderByClause addOrderByClause} for how the order by
	 * clause is modified by a request manager to reflect type-specific filtered queries. Conditions added by this method should
	 * insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic where clauses have already been added, this method should
	 *            append its conditions with a leading AND and both front and rear pad with a space.
	 * @param requestFilter the request filter
	 */
	@Override
	public void addToWhereClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L981">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L982">		StringsPair dates = null;</span>
<span class="nc" id="L983">		String rangeStart = &quot;&quot;;</span>
<span class="nc" id="L984">		String rangeEnd = &quot;&quot;;</span>

		try {
<span class="nc bnc" id="L987" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L988">				TimeOffBidDAO dao = new TimeOffBidDAO();</span>

				try {
<span class="nc" id="L991">					ID bidID = new ID(requestFilter.getValueForKey(RequestFilter.TOBID_KEY).toString());</span>
<span class="nc" id="L992">					TimeOffBid bid = dao.getObjectByID(bidID);</span>
<span class="nc" id="L993">					rangeStart = JdmoUtil.formatDBString(bid.getRequestStartTime());</span>
<span class="nc" id="L994">					rangeEnd = JdmoUtil.formatDBString(bid.getRequestEndTime());</span>
<span class="nc" id="L995">				} catch (Exception e) {</span>
<span class="nc" id="L996">					dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L997">					rangeStart = dates.getKey();</span>
<span class="nc" id="L998">					rangeEnd = dates.getValue();</span>
<span class="nc" id="L999">					m_cat.debug(&quot;Unable to retrieve Bid for ID &quot;);</span>
				} finally {
<span class="nc bnc" id="L1001" title="All 6 branches missed.">					if (dao != null) {</span>
<span class="nc" id="L1002">						dao.cleanUp();</span>
					}
				}
<span class="nc" id="L1005">			} else {</span>
				// QA 95168
<span class="nc" id="L1007">				dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1008">				rangeStart = dates.getKey();</span>
<span class="nc" id="L1009">				rangeEnd = dates.getValue();</span>
			}

<span class="nc" id="L1012">			Date dtNow = new Date();</span>
<span class="nc" id="L1013">			String strDtNow = JdmoUtil.formatDBString(dtNow);</span>
			// END QA 95168

<span class="nc" id="L1016">			query.append(&quot; AND TOR.ID=REQ.ID &quot;)// join TIMEOFFREQUEST to REQUEST</span>
<span class="nc" id="L1017">					.append(&quot; AND TORC1.TIMEOFFREQUESTID=REQ.ID &quot;)// join TIMEOFFREQUESTID to REQUEST</span>
<span class="nc" id="L1018">					.append(&quot; AND TORC2.TIMEOFFREQUESTID=REQ.ID &quot;)// join TIMEOFFREQUESTID to REQUEST</span>
<span class="nc" id="L1019">					.append(&quot; AND TORC1.RANK=1 &quot;)// table E is only the first choices</span>
					// .append(&quot; AND ORG.ID = WRO.ORGANIZATIONID &quot;) //TO get the Organization Name
					// QA 94310: Get Request within Organization assignment only! This prevent duplicate/triplicate/...
					// if agent was assigned to more than 1 Organization during the time window
					// QA 95168: fix date restrictions in query
<span class="nc" id="L1024">					.append(&quot;AND &quot;);</span>
<span class="nc" id="L1025">			RmUtil.appendRequestDateRangeClauses(query, &quot;&quot;, &quot;TORC2&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L1026">			query.append(&quot; &quot;);</span>
			// query.append(&quot; AND (TORC2.STARTTIME &gt;= WRO.STARTTIME AND (WRO.ENDTIME IS NULL OR TORC2.STARTTIME &lt; WRO.ENDTIME ))&quot;);
			// query.append(&quot; AND &quot;);

<span class="nc" id="L1030">			String filterStatus = (String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY);</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">			if (RequestAuditTrail.isRequestForWithdrawalStates(filterStatus)) { // include the Join to the WIthdrawal request tabel</span>
																				// only if the withdraw states are queried.
<span class="nc" id="L1033">				query.append(&quot; AND TWR.TIMEOFFREQUESTID = REQ.ID &quot;);</span>
<span class="nc" id="L1034">				query.append(&quot; AND TWR.REQUESTSTATUS='&quot;).append(filterStatus).append(&quot;' &quot;);</span>
			}

			// See if we're only interested in the first choices
<span class="nc" id="L1038">			String numChoicesFromFilter = (String) requestFilter.getValueForKey(RequestFilter.TO_NUMBER_OF_CHOICES_KEY);</span>

<span class="nc bnc" id="L1040" title="All 2 branches missed.">			if (RequestFilter.FIRST_ONLY_TO_CHOICE.equals(numChoicesFromFilter)) {</span>
				// restrict the second TIMEOFFREQUESTCHOICE choice table to first choices
<span class="nc" id="L1042">				query.append(&quot; AND TORC2.RANK=1 &quot;);</span>
			}

			// If we need to filter on full or partial day, add that filter
<span class="nc bnc" id="L1046" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY)) {</span>
<span class="nc" id="L1047">				query.append(&quot; AND ET.EMPLOYEEID=REQ.EMPLOYEEID AND ET.ACTIVITYID=TOR.ACTIVITYID &quot;);</span>

<span class="nc" id="L1049">				String fullOrPartial = (String) requestFilter.getValueForKey(RequestFilter.TO_FULL_OR_PARTIAL_DAY_KEY);</span>

<span class="nc bnc" id="L1051" title="All 2 branches missed.">				if (RequestFilter.TO_PARTIAL_DAY.equals(fullOrPartial)) {</span>
					// Partial day
<span class="nc" id="L1053">					query.append(&quot; AND TORC2.DURATIONHOURS &lt;  ET.HOURSPERDAY &quot;);</span>
				} else {
					// Full day
<span class="nc" id="L1056">					query.append(&quot; AND TORC2.DURATIONHOURS &gt;= ET.HOURSPERDAY &quot;);</span>
				}
			}

			// if filtering by timeoff activity is necessary
<span class="nc bnc" id="L1061" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TO_ACTIVITY_ID_KEY)) {</span>
				// obtain the activity ID
<span class="nc" id="L1063">				ID activityID = (ID) requestFilter.getValueForKey(RequestFilter.TO_ACTIVITY_ID_KEY);</span>
				// append to the where clause.
<span class="nc" id="L1065">				query.append(&quot; AND TOR.ACTIVITYID = &quot;).append(activityID).append(' ');</span>
			}

<span class="nc" id="L1068">			appendFlexTypeWhereClause(query, requestFilter, sortColumn);</span>

			// Add Where for Time Off Bid Selection
<span class="nc bnc" id="L1071" title="All 2 branches missed.">			if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L1072">				query.append(&quot; AND ACT.ID = TOR.ACTIVITYID AND TBA.ACTIVITYID = ACT.ID AND TOB.ID = TBA.TIMEOFFBIDID&quot;)</span>
<span class="nc" id="L1073">						.append(&quot; AND TOB.ID = TOBD.TIMEOFFBIDID AND (TOB.BIDSTARTTIME&lt;=REQ.SUBMITTEDON and REQ.SUBMITTEDON&lt;=TOB.BIDENDTIME)&quot;)</span>
<span class="nc" id="L1074">						.append(&quot; AND (TOB.REQUESTSTARTTIME&lt;=TORC2.STARTTIME and TORC2.ENDTIME&lt;=TOB.REQUESTENDTIME)&quot;)</span>
<span class="nc" id="L1075">						.append(&quot; AND TOBD.EMPLOYEEID = REQ.EMPLOYEEID&quot;).append(&quot; AND TOB.ID = &quot;)</span>
<span class="nc" id="L1076">						.append(requestFilter.getValueForKey(RequestFilter.TOBID_KEY)).append(&quot; &quot;);</span>
			}
		} finally {
<span class="nc bnc" id="L1079" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1080">				dmo.cleanUp();</span>
			}
		}
<span class="nc" id="L1083">	}</span>

	/**
	 * Add the appropriate FLEXTYPE clause to the query (either FLEXTYPE_NONE or FLEXTYPE_FLEXWITHMAKEUP).
	 */
	protected void appendFlexTypeWhereClause(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L1089">		query.append(&quot; AND TOR.FLEXTYPE = &quot;).append(TORequest.FLEXTYPE_NONE).append(' ');</span>
<span class="nc" id="L1090">	}</span>

	/**
	 * Add conditions necessary to process a query governed by the given filter. The caller has already added everthing but the
	 * order by clause. See {@link #aaddToSelectColumns addToSelectColumns} for how the column list is modified,
	 * {@link #addToFromClause addToFromClause} for how the from clause is modified, and {@link #addToWhereClause addToWhereClause}
	 * for how the where clause is modified by a request manager to reflect type-specific filtered queries. Conditions added by this
	 * method should insert a leading comma.
	 *
	 * @param query the string buffer being constructed, the generic where clauses have already been added, this method should
	 *            append its conditions with a leading AND and both front and rear pad with a space.
	 * @param requestFilter the request filter
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDir This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the sort is ascending or descending.
	 *            (Note spaces around values for convenience.)
	 */
	@Override
	public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc bnc" id="L1109" title="All 2 branches missed.">		if (sortColumn == Request.SORT_TO_ACTIVITY) {</span>
<span class="nc" id="L1110">			query.append(&quot; ORDER BY TOR.ACTIVITYID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_DEBIT_TYPE) {</span>
<span class="nc" id="L1112">			query.append(&quot; ORDER BY TOR.DEBITTYPE &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_START) {</span>
<span class="nc" id="L1114">			query.append(&quot; ORDER BY TORC1.STARTTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">		} else if (sortColumn == Request.SORT_TO_FIRST_END) {</span>
<span class="nc" id="L1116">			query.append(&quot; ORDER BY TORC1.ENDTIME &quot;).append(sortDir);</span>
		}
<span class="nc" id="L1118">	}</span>

	/**
	 * Return a collection of {@link com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName EmployeeName} objects for all employees
	 * in the given organization that have a time off event scheduled beginning during the organization day which contains the given
	 * date. If an employee id is supplied, the returned list of EmployeeNames is further restrcited to just those employees that
	 * are supervised by the manager with the given employee id.
	 *
	 * @param mgrEmpID employee id of manager that supervises employees, can be null. If null, then all employees in the
	 *            organization with time off on the date will be returned.
	 * @param orgID the organization id
	 * @param date a date (in the organization's time zone) that identifies the range of time off events to search for. The specific
	 *            range used is the organization day (as defined by the organization day boundary) that contains the given date.
	 * @return Collection of {@link com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName EmployeeName} objects
	 * @throws BbmFinderException
	 */
	public Collection getEmpNamesForScheduledTO(ID mgrEmpID, ID orgID, ID pTOPoolID, Date date) throws BbmFinderException {
<span class="nc" id="L1135">		methodStart(&quot;getEmpNamesForScheduledTO&quot;, mgrEmpID, orgID, date);</span>
		try {
			// pTOPoolID = new ID(10);
<span class="nc" id="L1138">			Map nameMap = new HashMap();</span>
			// Get the organization object so that we have the timezone and day offset
<span class="nc" id="L1140">			Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L1141">			Collection allotmentList = TOCalendarUtil.getListOfAllAllotmentActivities();</span>
<span class="nc" id="L1142">			Date start = null;</span>
<span class="nc" id="L1143">			Date end = null;</span>
<span class="nc" id="L1144">			HashSet empIds = new HashSet();</span>
<span class="nc" id="L1145">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(date);</span>

<span class="nc" id="L1147">			Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1148">			cal.setTime(date);</span>
<span class="nc" id="L1149">			cal.add(Calendar.DAY_OF_MONTH, -2);</span>
<span class="nc" id="L1150">			start = cal.getTime();</span>
<span class="nc" id="L1151">			cal.add(Calendar.DAY_OF_MONTH, 4);</span>
<span class="nc" id="L1152">			end = cal.getTime();</span>
<span class="nc" id="L1153">			Collection childOrgs = Collections.EMPTY_LIST;</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">			if (pTOPoolID == null) {</span>
				// empIds.addAll(RequestUtil.getEmpIdsInOrg( orgID, empStartDate, end,true));
<span class="nc" id="L1156">				Pair pair = getEmpIdsInOrgForMgr(null, orgID, true, empStartDate, end);</span>
<span class="nc" id="L1157">				empIds.addAll((Collection) pair.getFirst());</span>
<span class="nc" id="L1158">				childOrgs = (Collection) pair.getSecond();</span>
<span class="nc" id="L1159">			} else {</span>
<span class="nc" id="L1160">				CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L1161">				empIds.addAll(toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, end));</span>
			}
<span class="nc" id="L1163">			TimeRange range = new TimeRange(start, end);</span>
<span class="nc" id="L1164">			DailyHoursBuckets bkts = TOCalendarUtil.getTOScheduledData(pTOPoolID, org, childOrgs, empIds, range, allotmentList, true);</span>

<span class="nc" id="L1166">			List toHrsPerDayCol = bkts.getTOHoursPerDayForDate(date);</span>
<span class="nc" id="L1167">			double totalHrsForTheDate = bkts.getBucketHours(date);</span>
<span class="nc bnc" id="L1168" title="All 4 branches missed.">			if (toHrsPerDayCol != null &amp;&amp; !toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L1169">				Set empIdsSet = new HashSet();</span>
<span class="nc" id="L1170">				empIdsSet.addAll(ValueObjectUtil.getFieldObjectCol(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID, toHrsPerDayCol));</span>
<span class="nc" id="L1171">				WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1172">				nameMap = wrm.getEmployeeNamesByIDs(empIdsSet);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1174">					TORequestUtil.formatEmpNames(date, empIds, orgID, nameMap, range, allotmentList, totalHrsForTheDate);</span>
				}
			}
<span class="nc" id="L1177">			return RequestUtil.getMapValues(nameMap);</span>
<span class="nc" id="L1178">		} catch (Exception e) {</span>
<span class="nc" id="L1179">			handleException(e);</span>
<span class="nc" id="L1180">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1182">			methodFinish();</span>
		}
	}

	/**
	 * Get the time off activity summary data for an employee for the given time off year.
	 * &lt;p/&gt;
	 * &lt;p&gt;
	 * For the given TOYear (start and end of the TOYear is based on orgConfig settings which can either be 'use employee's anniv
	 * date' or 'use fixed date') summarize the time off statistics for each activity which is marked (requesttable, timeoff and
	 * hasAllocations). The summary includes the fields in {@link TimeOffActivitySummary TimeOffActivitySummary} class which are:
	 * &lt;li&gt;total allocated hours
	 * &lt;li&gt;used hours
	 * &lt;li&gt;scheduled hours
	 * &lt;li&gt;remaining hours
	 * &lt;li&gt;pending hours.
	 *
	 * @param empID the employee for whom the time off activity data is returned.
	 * @param year the employee year in question. The time off year that begins on a date in this year will be used.
	 * @param requestableOnly - If true, we will include activities only if they are enabled for the &quot;Is Requestable&quot; attribute.
	 * @param withAllotmentOnly - If true, we will include activities only if they are enabled for the
	 *            &quot;Is Time Off With Allottment/Accrual&quot; attribute.
	 * @return an array of TimeOffActivitySummary objects
	 * @throws BbmFinderException when errors encountered during the construction of the TimeOffActivitySummary objects
	 * @see TimeOffActivitySummary
	 */
	public HashMap getTOActivitySummaryData(Collection empIDs, int year, ID activityID, Date dt, boolean requestableOnly,
			boolean withAllotmentOnly) throws BbmFinderException {
<span class="nc" id="L1210">		HashMap empSummaryMap = new HashMap();</span>
		try {
<span class="nc" id="L1212">			long startTime = new Date().getTime();</span>
<span class="nc" id="L1213">			ReportDumpStatistic statistic = new ReportDumpStatistic();</span>
<span class="nc" id="L1214">			HashMap dataForAllEmps = getEmployeeData(statistic, empIDs, activityID, year, dt, requestableOnly, withAllotmentOnly,</span>
					null, null);
<span class="nc bnc" id="L1216" title="All 2 branches missed.">			for (Iterator iterator = dataForAllEmps.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1217">				ID empId = (ID) iterator.next();</span>
<span class="nc" id="L1218">				HashMap empData = (HashMap) dataForAllEmps.get(empId);</span>
<span class="nc" id="L1219">				empSummaryMap.put(empId, getTOActivitySummaryData(statistic, empId, empData, true));</span>
<span class="nc" id="L1220">			}</span>
<span class="nc bnc" id="L1221" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1222">				m_cat.info(&quot;getTOActivitySummaryData Total Time for &quot; + empIDs.size() + &quot; Emps = &quot; + (new Date().getTime() - startTime)</span>
						+ &quot;MSecs&quot;);
			}
<span class="nc" id="L1225">		} catch (Exception e) {</span>
<span class="nc" id="L1226">			handleException(e);</span>
<span class="nc" id="L1227">		}</span>
<span class="nc" id="L1228">		return empSummaryMap;</span>
	}

	private TimeOffActivitySummary[] getTOActivitySummaryData(ReportDumpStatistic statistic, ID empID, HashMap empData,
			boolean computeSchedAndPending) throws BbmFinderException {
<span class="nc" id="L1233">		String _method_ = &quot;getTOActivitySummaryData&quot;;</span>
<span class="nc" id="L1234">		methodStart(_method_, empID);</span>
<span class="nc" id="L1235">		long timeStart = System.currentTimeMillis();</span>

		try {
<span class="nc" id="L1238">			Calendar empTOYearStCal = (Calendar) empData.get(&quot;empTOYearStCal&quot;);</span>
<span class="nc" id="L1239">			Calendar empTOYearEnCal = (Calendar) empData.get(&quot;empTOYearEnCal&quot;);</span>
<span class="nc" id="L1240">			Employee emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L1241">			Organization org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc" id="L1242">			HashMap orgActivityMap = (HashMap) empData.get(&quot;ActivityMap&quot;);</span>
<span class="nc" id="L1243">			HashMap actCatMap = (HashMap) empData.get(&quot;ActivityCatMap&quot;);</span>
			// if no org activities are found, short circuit.
<span class="nc bnc" id="L1245" title="All 2 branches missed.">			if (orgActivityMap.isEmpty()) {</span>
<span class="nc" id="L1246">				m_cat.debug(&quot;No activities found with the attributes: (requestable, timeoff, withallotment) for orgID: &quot; + org.getID());</span>
<span class="nc" id="L1247">				return new TimeOffActivitySummary[0];</span>
			}
			// Use the returned set of activities to build a map of summaries for this employee
			// Later, we'll add to the counters in each summary element
			// for each activity, retrieve yearly allocation.
<span class="nc" id="L1252">			Map actIDToTOActSummMap = new HashMap();</span>
<span class="nc" id="L1253">			setTOActSummWithColorAndYearlyAlloc(empID, empTOYearStCal.getTime(), empTOYearEnCal.getTime(), orgActivityMap.values(),</span>
					actIDToTOActSummMap, actCatMap, empData);
<span class="nc" id="L1255">			long timeAfterGetRemaining = System.currentTimeMillis();</span>
<span class="nc" id="L1256">			statistic.add(&quot;m_TimeSpentOnGetRemaining&quot;, timeAfterGetRemaining - timeStart);</span>
<span class="nc bnc" id="L1257" title="All 2 branches missed.">			if (computeSchedAndPending) {</span>
<span class="nc" id="L1258">				fillPendingAndScheduledHoursForSummary(empData, actIDToTOActSummMap);</span>
			}
<span class="nc" id="L1260">			long timeAfterGetPendAndSched = System.currentTimeMillis();</span>
<span class="nc" id="L1261">			statistic.add(&quot;m_TimeSpentOnGetPendAndSched&quot;, timeAfterGetPendAndSched - timeAfterGetRemaining);</span>
<span class="nc" id="L1262">			return (TimeOffActivitySummary[]) actIDToTOActSummMap.values().toArray(</span>
<span class="nc" id="L1263">					new TimeOffActivitySummary[actIDToTOActSummMap.values().size()]);</span>
<span class="nc" id="L1264">		} catch (Exception e) {</span>
<span class="nc" id="L1265">			handleException(e);</span>
<span class="nc" id="L1266">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1268">			methodFinish();</span>
		}
	}

	private HashMap getEmployeeData(ReportDumpStatistic statistic, Collection empIDs, ID activityID, int year, Date date,
			boolean requestableOnly, boolean withAllotmentOnly, HashMap orgActivityMap, HashMap orgActCatMap) throws Exception { // NOSONAR 
<span class="nc" id="L1274">		long timeStart = System.currentTimeMillis();</span>
<span class="nc" id="L1275">		HashMap dataForAllEmps = new HashMap();</span>
		// Get the organization id
<span class="nc" id="L1277">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1278">		ActivityManager actMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L1279">		Collection emps = wrm.getEmployeesByIDs(empIDs, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
<span class="nc" id="L1280">		long timeAfterGetEmps = System.currentTimeMillis();</span>
<span class="nc" id="L1281">		statistic.add(&quot;m_TimeSpentOnGetEmps&quot;, timeAfterGetEmps - timeStart);</span>
<span class="nc" id="L1282">		HashMap empOrgMap = getEmpOrgIDs(wrm, empIDs);</span>
<span class="nc" id="L1283">		TreeSet orgIDSet = new TreeSet(empOrgMap.values());</span>
<span class="nc" id="L1284">		HashMap orgIDMap = ValueObjectUtil.getIDObjectMap(wrm.getOrganizationsByIDs(orgIDSet));</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">		if (activityID == null) {</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">			if (orgActivityMap == null) {</span>
<span class="nc" id="L1287">				orgActivityMap = getOrgActivitiesMap(orgIDSet, requestableOnly, withAllotmentOnly);</span>
			}
<span class="nc bnc" id="L1289" title="All 2 branches missed.">			if (orgActCatMap == null) {</span>
<span class="nc" id="L1290">				orgActCatMap = getOrgActivityCategoryMap(orgIDSet);</span>
			}
		}
<span class="nc bnc" id="L1293" title="All 2 branches missed.">		Collection singActivityList = activityID != null ? Collections.singleton(activityID) : null;</span>
		// ActivityTimeOff Balance
<span class="nc" id="L1295">		HashMap empTOYearStDateMap = new HashMap();</span>
<span class="nc" id="L1296">		HashMap empTOYearEnDateMap = new HashMap();</span>
<span class="nc" id="L1297">		int stYear = 0;</span>
<span class="nc" id="L1298">		int enYear = 0;</span>
<span class="nc" id="L1299">		Calendar now = Calendar.getInstance();</span>
<span class="nc" id="L1300">		TreeSet empIdsRequestingCurYear = new TreeSet();</span>
<span class="nc" id="L1301">		long timeAfterGetActivity = System.currentTimeMillis();</span>
<span class="nc" id="L1302">		statistic.add(&quot;m_TimeSpentOnGetActivity&quot;, timeAfterGetActivity - timeAfterGetEmps);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">		for (Iterator iterator = emps.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1304">			Employee emp = (Employee) iterator.next();</span>
<span class="nc" id="L1305">			Organization org = (Organization) orgIDMap.get(empOrgMap.get(emp.getID()));</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">			if (activityID != null) {</span>
<span class="nc" id="L1307">				Activity act = WfmManagerFactory.getActivityManager().findActivityById(activityID);</span>
<span class="nc" id="L1308">				orgActivityMap = new HashMap();</span>
<span class="nc" id="L1309">				HashMap actIDMap = new HashMap();</span>
<span class="nc" id="L1310">				actIDMap.put(act.getID(), act);</span>
<span class="nc" id="L1311">				orgActivityMap.put(org.getID(), actIDMap);</span>
<span class="nc" id="L1312">				orgActCatMap = new HashMap();</span>
			}
			// Get the month and day for the employee's time off year
<span class="nc" id="L1315">			int[] empTOYrStArr = RequestUtil.getEmployeeTimeOffYearStart(emp, org);</span>
			// Compute the range to use for building the summary
<span class="nc" id="L1317">			HashMap empData = new HashMap();</span>
<span class="nc" id="L1318">			empData.put(&quot;AnniverseryMonthYear&quot;, empTOYrStArr);</span>

<span class="nc" id="L1320">			Calendar empTOYearStCal = null;</span>
<span class="nc" id="L1321">			Calendar empTOYearEnCal = null;</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">			if (date != null) {</span>
				/*
				 * empTOYearStCal = Calendar.getInstance(org.getTimeZone()); empTOYearStCal.setTime(date); empTOYearStCal =
				 * RequestUtil.getCalendar(empTOYearStCal.get(Calendar.YEAR), md[0], md[1], org.getTimeZone()); if
				 * (empTOYearStCal.getTime().after(date)) { empTOYearStCal.add(Calendar.YEAR, -1); }
				 */
<span class="nc" id="L1328">				empTOYearStCal = RequestUtil.getEmployeeTimeOffYearStart(date, org, empTOYrStArr);</span>
<span class="nc" id="L1329">				empTOYearEnCal = RequestUtil.getEmployeeTimeOffYearEnd(date, org, empTOYrStArr);</span>
			} else {
<span class="nc" id="L1331">				empTOYearStCal = RequestUtil.getCalendar(year, empTOYrStArr[0], empTOYrStArr[1], org.getTimeZone());</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L1333">					empTOYearStCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
				}
<span class="nc" id="L1335">				empTOYearEnCal = RequestUtil.getCalendarForwardOneYear(year, empTOYrStArr[0], empTOYrStArr[1], org.getTimeZone());</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L1337">					empTOYearEnCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
				}
			}
<span class="nc bnc" id="L1340" title="All 2 branches missed.">			if (empTOYearEnCal.after(now)) {</span>
<span class="nc" id="L1341">				empIdsRequestingCurYear.add(emp.getID());</span>
			}
<span class="nc" id="L1343">			empData.put(&quot;empTOYearStCal&quot;, empTOYearStCal);</span>
<span class="nc" id="L1344">			empTOYearStDateMap.put(emp.getID(), empTOYearStCal);</span>
<span class="nc bnc" id="L1345" title="All 4 branches missed.">			if (stYear == 0 || stYear &gt; empTOYearStCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1346">				stYear = empTOYearStCal.get(Calendar.YEAR);</span>
			}

<span class="nc" id="L1349">			empData.put(&quot;empTOYearEnCal&quot;, empTOYearEnCal);</span>
<span class="nc" id="L1350">			empTOYearEnDateMap.put(emp.getID(), empTOYearEnCal);</span>
<span class="nc bnc" id="L1351" title="All 4 branches missed.">			if (enYear == 0 || enYear &lt; empTOYearEnCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1352">				enYear = empTOYearEnCal.get(Calendar.YEAR);</span>
			}

<span class="nc" id="L1355">			empData.put(&quot;Employee&quot;, emp);</span>
<span class="nc" id="L1356">			empData.put(&quot;Organization&quot;, org);</span>
<span class="nc bnc" id="L1357" title="All 2 branches missed.">			if (orgActivityMap.get(org.getID()) == null) {</span>
<span class="nc" id="L1358">				m_cat.info(&quot;orgActivityMap null for org= &quot; + org.getID());</span>
			}

<span class="nc" id="L1361">			empData.put(&quot;ActivityMap&quot;, orgActivityMap.get(org.getID()));</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">			if (orgActCatMap != null) {</span>
<span class="nc" id="L1363">				empData.put(&quot;ActivityCatMap&quot;, orgActCatMap.get(org.getID()));</span>
			}
<span class="nc" id="L1365">			dataForAllEmps.put(emp.getID(), empData);</span>
<span class="nc" id="L1366">		}</span>
<span class="nc" id="L1367">		long timeAfterGetTOYearRange = System.currentTimeMillis();</span>
<span class="nc" id="L1368">		statistic.add(&quot;m_timeForGetTOYearRange&quot;, timeAfterGetTOYearRange - timeAfterGetActivity);</span>
		// Need to get Last updated balance date before start of year (Starting balance)
<span class="nc" id="L1370">		HashMap minDateMap = new HashMap();</span>
<span class="nc" id="L1371">		minDateMap.putAll(empTOYearStDateMap);</span>
		if (true) {// TOAccrualCalculator.hasLicenseForAccrual()) {
<span class="nc" id="L1373">			HashMap empActTOBalMap = actMgr.getActivityTOBalanceMap(empIDs, singActivityList, null);</span>
<span class="nc" id="L1374">			HashMap empTOAccruedMap = new HashMap();</span>

			// get latest Last updated balance date for current TO Year and future Years.
<span class="nc" id="L1377">			empTOAccruedMap.putAll(wrm.getLastUpdatedTOAccrued(empTOYearEnDateMap, singActivityList, null));</span>
<span class="nc" id="L1378">			HashMap empTOAccruedForStBalMap = wrm.getLastUpdatedTOAccrued(empTOYearStDateMap, singActivityList, null);</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">			for (Iterator iterator = empTOYearStDateMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1380">				ID empID = (ID) iterator.next();</span>
<span class="nc" id="L1381">				HashMap hashMap = (HashMap) empTOAccruedForStBalMap.get(empID);</span>
				// update the MinDate to query only if balance is available hence ; the carry over will be zero anyways.
<span class="nc bnc" id="L1383" title="All 4 branches missed.">				if (hashMap != null &amp;&amp; !hashMap.isEmpty()) {</span>
<span class="nc" id="L1384">					Calendar minDateCal = (Calendar) empTOYearStDateMap.get(empID);</span>
<span class="nc" id="L1385">					Date minDate = new Date(minDateCal.getTime().getTime());</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">					for (Iterator iterator1 = hashMap.values().iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L1387">						EmployeeTimeOffAccrued accrued = (EmployeeTimeOffAccrued) iterator1.next();</span>
<span class="nc bnc" id="L1388" title="All 4 branches missed.">						if (minDate == null || accrued.getAccruedAtDate().before(minDate)) {</span>
<span class="nc" id="L1389">							minDate = accrued.getAccruedAtDate();</span>
						}
<span class="nc" id="L1391">					}</span>
<span class="nc" id="L1392">					minDateCal = Calendar.getInstance(); // Need a copy here</span>
<span class="nc" id="L1393">					minDateCal.setTime(minDate);</span>
<span class="nc" id="L1394">					minDateMap.put(empID, minDateCal);</span>
<span class="nc bnc" id="L1395" title="All 4 branches missed.">					if (stYear == 0 || stYear &gt; minDateCal.get(Calendar.YEAR)) {</span>
<span class="nc" id="L1396">						stYear = minDateCal.get(Calendar.YEAR);</span>
					}
				}
<span class="nc" id="L1399">				HashMap empData = (HashMap) dataForAllEmps.get(empID);</span>
<span class="nc" id="L1400">				HashMap actTOBalMap = (HashMap) empActTOBalMap.get(empID);</span>
<span class="nc bnc" id="L1401" title="All 2 branches missed.">				if (actTOBalMap == null) {</span>
<span class="nc" id="L1402">					actTOBalMap = new HashMap();</span>
				}
<span class="nc" id="L1404">				empData.put(&quot;actTOBalMap&quot;, actTOBalMap);</span>
<span class="nc" id="L1405">				HashMap tOAccruedMap = (HashMap) empTOAccruedMap.get(empID);</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">				if (tOAccruedMap == null) {</span>
<span class="nc" id="L1407">					tOAccruedMap = new HashMap();</span>
				}
<span class="nc" id="L1409">				empData.put(&quot;tOAccruedMap&quot;, tOAccruedMap);</span>

<span class="nc" id="L1411">				HashMap tOAccruedStBalMap = (HashMap) empTOAccruedForStBalMap.get(empID);</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">				if (tOAccruedStBalMap == null) {</span>
<span class="nc" id="L1413">					tOAccruedStBalMap = new HashMap();</span>
				}
<span class="nc" id="L1415">				empData.put(&quot;tOAccruedStBalMap&quot;, tOAccruedStBalMap);</span>

<span class="nc" id="L1417">			}</span>
		}
<span class="nc" id="L1419">		long timeAfterGetSTBal = System.currentTimeMillis();</span>
<span class="nc" id="L1420">		statistic.add(&quot;m_timeForGetSTBal&quot;, timeAfterGetSTBal - timeAfterGetTOYearRange);</span>

		// EmployeeTimeOFF Allotment based on the latest balance
<span class="nc" id="L1423">		HashMap empToYearlyAllotmentMap = wrm.getEmployeeTimeOffYearlyMap(empIDs, singActivityList, null, stYear - 2, enYear);</span>
<span class="nc" id="L1424">		long timeAfterYrlyAllotMap = System.currentTimeMillis();</span>
<span class="nc" id="L1425">		statistic.add(&quot;m_timeForYrlyAllotMap&quot;, timeAfterYrlyAllotMap - timeAfterGetSTBal);</span>

		// TimeOff Events based on last updated date before TO year
<span class="nc bnc" id="L1428" title="All 2 branches missed.">		HashMap empHrsPerDayMap = getTOHoursPerDayManager().getHoursPerDayForRange(minDateMap, empTOYearEnDateMap,</span>
				(activityID != null ? singActivityList : null));

<span class="nc bnc" id="L1431" title="All 2 branches missed.">		for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1432">			ID empID = (ID) iterator.next();</span>
<span class="nc" id="L1433">			HashMap empData = (HashMap) dataForAllEmps.get(empID);</span>
<span class="nc" id="L1434">			Collection hrsPerDayCol = (Collection) empHrsPerDayMap.get(empID);</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">			if (hrsPerDayCol == null) {</span>
<span class="nc" id="L1436">				hrsPerDayCol = new ArrayList();</span>
			}
<span class="nc" id="L1438">			empData.put(&quot;hrsPerDayCol&quot;, hrsPerDayCol);</span>
<span class="nc" id="L1439">			HashMap yearlyAllotmentMap = (HashMap) empToYearlyAllotmentMap.get(empID);</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">			if (yearlyAllotmentMap == null) {</span>
<span class="nc" id="L1441">				yearlyAllotmentMap = new HashMap();</span>
			}
<span class="nc" id="L1443">			empData.put(&quot;yearlyAllotmentMap&quot;, yearlyAllotmentMap);</span>
<span class="nc" id="L1444">		}</span>
<span class="nc" id="L1445">		long timeAfterHrsPerDay = System.currentTimeMillis();</span>
<span class="nc" id="L1446">		statistic.add(&quot;m_timeForHrsPerDay&quot;, timeAfterHrsPerDay - timeAfterYrlyAllotMap);</span>
<span class="nc" id="L1447">		return dataForAllEmps;</span>
	}

	public HashMap getOrgActivitiesMap(Collection orgIDs, boolean requestableOnly, boolean withAllotmentOnly) throws Exception {
<span class="nc" id="L1451">		HashMap orgActMap = new HashMap();</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">		for (Iterator iterator = orgIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1453">			ID orgId = (ID) iterator.next();</span>
			// HashMap actMap
<span class="nc" id="L1455">			orgActMap.put(orgId, ValueObjectUtil.getIDObjectMap(getTimeOffActs(orgId, requestableOnly, withAllotmentOnly)));</span>
<span class="nc" id="L1456">		}</span>
<span class="nc" id="L1457">		return orgActMap;</span>
	}

	public HashMap getOrgActivityCategoryMap(Collection orgIDs) throws Exception {
<span class="nc" id="L1461">		HashMap orgActCatMap = new HashMap();</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">		for (Iterator iterator = orgIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1463">			ID orgId = (ID) iterator.next();</span>
			// HashMap actCatMap
<span class="nc" id="L1465">			orgActCatMap.put(orgId, getActivityCategoryWithAlloc(orgId));</span>
<span class="nc" id="L1466">		}</span>
<span class="nc" id="L1467">		return orgActCatMap;</span>
	}

	public HashMap getEmpOrgIDs(WorkResourceManager wrm, Collection empIDs) throws Exception {
<span class="nc" id="L1471">		HashMap empOrgMap = new HashMap();</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">		if (wrm == null) {</span>
<span class="nc" id="L1473">			wrm = BbmManagerFactory.getWorkResourceManager();</span>
		}
		// get organization at the start of the given calc date range.
<span class="nc" id="L1476">		Map wrOrgMap = wrm.getValidWorkResourceAssignments(empIDs, new LocalDate(new Date()), new LocalDate(new Date()), false);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">		for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1478">			ID empId = (ID) iterator.next();</span>
<span class="nc" id="L1479">			ID orgId = null;</span>
<span class="nc" id="L1480">			Collection wrOrg = (Collection) wrOrgMap.get(empId);</span>
<span class="nc bnc" id="L1481" title="All 4 branches missed.">			if (wrOrg != null &amp;&amp; !wrOrg.isEmpty()) {</span>
<span class="nc" id="L1482">				WorkResourceAssignment wra = (WorkResourceAssignment) wrOrg.iterator().next();</span>
<span class="nc" id="L1483">				orgId = wra.getOrganizationID();</span>
			}
<span class="nc bnc" id="L1485" title="All 2 branches missed.">			if (orgId == null) {</span>
<span class="nc" id="L1486">				orgId = Organization.ROOT_ORG_ID_OBJ;</span>
			}
<span class="nc" id="L1488">			empOrgMap.put(empId, orgId);</span>
<span class="nc" id="L1489">		}</span>
<span class="nc" id="L1490">		return empOrgMap;</span>
	}

	private void fillPendingAndScheduledHoursForSummary(HashMap empData, Map actIDToTOActSummMap) throws Exception {

<span class="nc" id="L1495">		Calendar empTOYearStCal = (Calendar) empData.get(&quot;empTOYearStCal&quot;);</span>
<span class="nc" id="L1496">		Calendar empTOYearEnCal = (Calendar) empData.get(&quot;empTOYearEnCal&quot;);</span>
<span class="nc" id="L1497">		Employee emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L1498">		Organization org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc" id="L1499">		Collection hrsPerDayCol = (Collection) empData.get(&quot;hrsPerDayCol&quot;);</span>
<span class="nc" id="L1500">		Calendar nowCal = Calendar.getInstance(org.getTimeZone());</span>
		// process scheduled/taken time- off
<span class="nc bnc" id="L1502" title="All 2 branches missed.">		if (hrsPerDayCol != null) {</span>
<span class="nc bnc" id="L1503" title="All 2 branches missed.">			for (Iterator it = hrsPerDayCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1504">				TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">				if (!hoursPerDay.getStartTime().before(empTOYearEnCal.getTime())</span>
<span class="nc bnc" id="L1506" title="All 2 branches missed.">						|| !hoursPerDay.getEndTime().after(empTOYearStCal.getTime())) {</span>
<span class="nc" id="L1507">					continue; // this event is not even relevant</span>
				}
<span class="nc" id="L1509">				float duration = 0.0f;</span>
<span class="nc" id="L1510">				boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(empTOYearStCal.getTime());</span>
<span class="nc" id="L1511">				boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(empTOYearEnCal.getTime());</span>
<span class="nc bnc" id="L1512" title="All 4 branches missed.">				if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc" id="L1513">					DailyHoursBuckets dailyBuckets = null;</span>
					try {
<span class="nc bnc" id="L1515" title="All 2 branches missed.">						dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L1516" title="All 2 branches missed.">								isToEvtStartBeforeStart ? empTOYearStCal.getTime() : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L1517">								isToEvtEndAfterEnd ? empTOYearEnCal.getTime() : hoursPerDay.getEndTime());</span>
<span class="nc" id="L1518">					} catch (Exception e) {</span>
<span class="nc" id="L1519">						e.printStackTrace(); // To change body of catch statement use File | Settings | File Templates.</span>
<span class="nc" id="L1520">					}</span>
<span class="nc" id="L1521">					duration += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L1522">				} else {</span>
<span class="nc" id="L1523">					duration += (hoursPerDay.getTotalMinutes() / 60f);</span>
				}
				// Get the summary object for this activity
<span class="nc" id="L1526">				ID timeOffEvtActID = hoursPerDay.getActivityID();</span>
<span class="nc" id="L1527">				TimeOffActivitySummary summary = (TimeOffActivitySummary) actIDToTOActSummMap.get(Activity.getActivity_ActCategoryComb(</span>
						timeOffEvtActID, null));

				// Note: if no yearly timeoff allocation is specified for the timeoff event's activity,
				// then the summary for this activity will not be found in the map above. Refer to the comments
				// associated iwth activityManager.findOrganizationActivities() call above. As a result, the
				// time off summary screen in the UI will not list the proper hours for 'pending', 'scheduled' etc
				// for the timeoff event's activity.
<span class="nc bnc" id="L1535" title="All 4 branches missed.">				if (summary == null || summary.getActivityID() == null) {</span>
<span class="nc" id="L1536">					continue;</span>
				}
<span class="nc bnc" id="L1538" title="All 4 branches missed.">				if (hoursPerDay.getTOChoiceID() != null &amp;&amp; hoursPerDay.getExpiryDate().after(nowCal.getTime())) {</span>
<span class="nc" id="L1539">					summary.addToPending(duration);</span>
				} else {
					// If it is in the past, it represents time off
					// taken, if it is in the future, it's scheduled.
					// for these purposes, use the start date of the event
<span class="nc bnc" id="L1544" title="All 2 branches missed.">					if (!hoursPerDay.getEndTime().after(nowCal.getTime())) {// used</span>
<span class="nc" id="L1545">						summary.addToUsed(duration);</span>
<span class="nc bnc" id="L1546" title="All 2 branches missed.">					} else if (!hoursPerDay.getStartTime().before(nowCal.getTime())) {// scheduled</span>
<span class="nc" id="L1547">						summary.addToScheduled(duration);</span>
					} else {// overlaps current time
						// get the daily break down and allocate accordingly
						// used
<span class="nc" id="L1551">						DailyHoursBuckets usedDailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc" id="L1552">								hoursPerDay.getStartTime(), nowCal.getTime());</span>
<span class="nc" id="L1553">						summary.addToUsed(usedDailyBuckets.getTotalHours());</span>

						// scheduled
<span class="nc" id="L1556">						org = TOHoursPerDayUtil.getOrganization(hoursPerDay);</span>
<span class="nc" id="L1557">						Date nowOrgStartDate = TOCalcUtil.getDateForOrgDayStart(org.getTimeZone(), org.getDayBoundaryOffset(),</span>
<span class="nc" id="L1558">								nowCal.getTime());</span>
						// forward one day, because current day is calculated for used hours as above
<span class="nc" id="L1560">						Date nextOrgStartDate = TOCalcUtil.getDateForwardOneDay(nowOrgStartDate, org.getTimeZone());</span>

<span class="nc bnc" id="L1562" title="All 2 branches missed.">						if (nextOrgStartDate.before(hoursPerDay.getEndTime())) {</span>
<span class="nc" id="L1563">							DailyHoursBuckets schedDailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc" id="L1564">									nextOrgStartDate, hoursPerDay.getEndTime());</span>
<span class="nc" id="L1565">							summary.addToScheduled(schedDailyBuckets.getTotalHours());</span>
						}
					}
				}
<span class="nc" id="L1569">			}</span>
		}
		// Compute total hours for all &amp;
		// compute the Pending , used and sched hours for activity category
<span class="nc bnc" id="L1573" title="All 2 branches missed.">		for (Iterator iterator = actIDToTOActSummMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1574">			TimeOffActivitySummary summary = (TimeOffActivitySummary) iterator.next();</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">			if (summary.getActivityID() == null) { // this is Activity category</span>
<span class="nc" id="L1576">				float usedHrs = 0f;</span>
<span class="nc" id="L1577">				float schedHrs = 0f;</span>
<span class="nc" id="L1578">				float pendHrs = 0f;</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">				for (Iterator iterator1 = actIDToTOActSummMap.values().iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L1580">					TimeOffActivitySummary activitySummary = (TimeOffActivitySummary) iterator1.next();</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">					if (activitySummary.getActivityCategory() != null</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">							&amp;&amp; activitySummary.getActivityCategory().getID().equals(summary.getActivityCategory().getID())) {</span>
<span class="nc" id="L1583">						usedHrs += activitySummary.getUsed();</span>
<span class="nc" id="L1584">						schedHrs += activitySummary.getScheduled();</span>
<span class="nc" id="L1585">						pendHrs += activitySummary.getPending();</span>
					}
<span class="nc" id="L1587">				}</span>
<span class="nc" id="L1588">				summary.setPending(pendHrs);</span>
<span class="nc" id="L1589">				summary.setScheduled(schedHrs);</span>
<span class="nc" id="L1590">				summary.setUsed(usedHrs);</span>
<span class="nc" id="L1591">				summary.setTotal(usedHrs + schedHrs + summary.getRemaining());</span>
			}
<span class="nc bnc" id="L1593" title="All 2 branches missed.">			if (summary.getActivityCategory() == null) {</span>
				if (true) {// TOAccrualCalculator.hasLicenseForAccrual()) {
<span class="nc" id="L1595">					summary.setTotal(summary.getUsed() + summary.getScheduled() + summary.getRemaining());</span>
				} else {
					summary.setRemaining(summary.getTotal() - (summary.getUsed() + summary.getScheduled()));
				}
			}
<span class="nc" id="L1600">		}</span>
<span class="nc" id="L1601">	}</span>

	/**
	 * @param requestableOnly - If true, we will include activities only if they are enabled for the &quot;Is Requestable&quot; attribute.
	 * @param withAllotmentOnly - If true, we will include activities only if they are enabled for the
	 *            &quot;Is Time Off With Allottment/Accrual&quot; attribute.
	 */
	public TimeOffActivitySummary[] getTOActivitySummaryData(ID empID, int year, ID activityID, boolean requestableOnly,
			boolean withAllotmentOnly) throws BbmFinderException {
<span class="nc" id="L1610">		TimeOffActivitySummary[] summary = null;</span>
<span class="nc" id="L1611">		HashMap summaryMap = getTOActivitySummaryData(Collections.singleton(empID), year, activityID, null, requestableOnly,</span>
				withAllotmentOnly);
<span class="nc bnc" id="L1613" title="All 2 branches missed.">		if (!summaryMap.isEmpty()) {</span>
<span class="nc" id="L1614">			summary = (TimeOffActivitySummary[]) summaryMap.values().iterator().next();</span>
		}
<span class="nc" id="L1616">		return summary;</span>
	}

	/**
	 * Get the time off activities for the given employee for the given time frame.
	 *
	 * @param empID the employee for whom the time off activity data is returned.
	 * @param start the start of the period
	 * @param end the end of the period
	 * @return a Collection of TimeOffEvents
	 * @throws BbmFinderException when errors encountered during the construction of the TimeOffActivitySummary
	 */
	public Collection getTOActivities(ID empID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1629">		String _method_ = &quot;getTOActivities&quot;;</span>
<span class="nc" id="L1630">		methodStart(_method_, empID, start, end);</span>

<span class="nc" id="L1632">		TORequestDAO toDAO = null;</span>
<span class="nc" id="L1633">		ArrayList toActivities = new ArrayList();</span>
<span class="nc" id="L1634">		String setterID = CLASS_NAME + '.' + _method_;</span>

		try {

			// Get the organization id
<span class="nc" id="L1639">			ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>

<span class="nc" id="L1641">			TOHoursPerDayManager hoursPerDayManager = getTOHoursPerDayManager();</span>
<span class="nc" id="L1642">			ArrayList empIds = new ArrayList(1);</span>
<span class="nc" id="L1643">			empIds.add(empID);</span>

<span class="nc" id="L1645">			Collection orgActivities = getTimeOffActs(orgID, false, false);</span>
<span class="nc" id="L1646">			ArrayList activityIds = new ArrayList();</span>
<span class="nc bnc" id="L1647" title="All 2 branches missed.">			for (Iterator it = orgActivities.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1648">				Activity activity = (Activity) it.next();</span>
<span class="nc" id="L1649">				activityIds.add(activity.getID());</span>
<span class="nc" id="L1650">			}</span>

<span class="nc" id="L1652">			Collection scheduleOrTakenTimeOffEvents = hoursPerDayManager.getHoursPerDayForCalendar(empIds, start, end, activityIds, true);</span>

			// Process the returned time off events from schedule and add it to summary.
			// TODO: must process &quot;debit&quot; and &quot;debit-if-necessary&quot; properly.
<span class="nc bnc" id="L1656" title="All 2 branches missed.">			if (scheduleOrTakenTimeOffEvents != null) {</span>
				// get activityname collection
<span class="nc" id="L1658">				HashMap actNameMap = getActivityNameMap(scheduleOrTakenTimeOffEvents);</span>

<span class="nc bnc" id="L1660" title="All 2 branches missed.">				for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1661">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>

<span class="nc" id="L1663">					float duration = (hoursPerDay.getTotalMinutes() / 60f);</span>

<span class="nc" id="L1665">					toActivities.add(new TimeOffEventSummary(hoursPerDay.getStartTime(), hoursPerDay.getEndTime(), (String) actNameMap</span>
<span class="nc" id="L1666">							.get(hoursPerDay.getActivityID()), duration));</span>
<span class="nc" id="L1667">				}</span>
			}
<span class="nc" id="L1669">			return toActivities;</span>
<span class="nc" id="L1670">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1671">			handleException(e);</span>
<span class="nc" id="L1672">			throw (e);</span>
<span class="nc" id="L1673">		} catch (Exception e) {</span>
<span class="nc" id="L1674">			handleException(e);</span>
<span class="nc" id="L1675">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc bnc" id="L1678" title="All 4 branches missed.">			if (toDAO != null) {</span>
<span class="nc" id="L1679">				toDAO.cleanUp();</span>
			}
<span class="nc" id="L1681">			methodFinish();</span>
		}
	}

	private HashMap getActivityNameMap(Collection scheduleOrTakenTimeOffEvents) throws Exception {
<span class="nc" id="L1686">		ArrayList actList = new ArrayList();</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">		for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1688">			TOHoursPerDay timeoffEvt = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L1689" title="All 2 branches missed.">			if (!actList.contains(timeoffEvt.getActivityID())) {</span>
<span class="nc" id="L1690">				actList.add(timeoffEvt.getActivityID());</span>
			}
<span class="nc" id="L1692">		}</span>

		// get the activity names for display
<span class="nc" id="L1695">		Collection activityColl = WfmManagerFactory.getActivityManager().findActivities(actList);</span>
<span class="nc" id="L1696">		HashMap activityNameMap = new HashMap(activityColl.size());</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">		for (Iterator actIt = activityColl.iterator(); actIt.hasNext();) {</span>
<span class="nc" id="L1698">			Activity act = (Activity) actIt.next();</span>
<span class="nc" id="L1699">			activityNameMap.put(act.getID(), act.getName());</span>
<span class="nc" id="L1700">		}</span>
<span class="nc" id="L1701">		return activityNameMap;</span>
	}

	private void setTOActSummWithColorAndYearlyAlloc(ID empID, Date stDate, Date asOfDate, Collection orgActivities,
			Map actIDToTOActSummMap, HashMap actCatMap, HashMap empDataMap) throws Exception { // NOSONAR

<span class="nc" id="L1707">		Date now = new Date();</span>
<span class="nc" id="L1708">		Date adjustedStartDate = null;</span>
<span class="nc" id="L1709">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1710">		cal.setTime(stDate);</span>
<span class="nc" id="L1711">		cal.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L1712">		Date nextDate = cal.getTime(); // This date is required for calculating the carry over</span>
<span class="nc" id="L1713">		boolean calculateAccrued = true;</span>
		// As Of Date is End Date so this applies only for TO Summary for Past year.
<span class="nc bnc" id="L1715" title="All 2 branches missed.">		if (asOfDate.before(now)) {</span>
<span class="nc" id="L1716">			Employee emp = (Employee) empDataMap.get(&quot;Employee&quot;);</span>
<span class="nc bnc" id="L1717" title="All 2 branches missed.">			adjustedStartDate = (emp.getStartTime().after(stDate) ? emp.getStartTime() : stDate);</span>
			// No need to calculate carryover if emp start date falls after start date of the TO year.
<span class="nc bnc" id="L1719" title="All 2 branches missed.">			if (emp.getStartTime().after(stDate)) {</span>
<span class="nc" id="L1720">				nextDate = null;</span>
			}
<span class="nc bnc" id="L1722" title="All 2 branches missed.">			calculateAccrued = !(emp.getStartTime().after(asOfDate));</span>
		}
<span class="nc" id="L1724">		EmployeeTimeOffAccrued accruedTO = null;</span>
<span class="nc" id="L1725">		HashMap tOAccruedMap = (HashMap) empDataMap.get(&quot;tOAccruedMap&quot;);</span>
<span class="nc" id="L1726">		HashMap tOAccruedStBalMap = (HashMap) empDataMap.get(&quot;tOAccruedStBalMap&quot;);</span>
<span class="nc bnc" id="L1727" title="All 2 branches missed.">		for (Iterator it = orgActivities.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1728">			Activity orgAct = (Activity) it.next();</span>
			// TimeOffActivitySummary represents the details about a time off activity for the given employee.
<span class="nc" id="L1730">			TimeOffActivitySummary summary = new TimeOffActivitySummary();</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">			ActivityCategory aCat = actCatMap != null ? (ActivityCategory) actCatMap.get(orgAct.getActivityCategoryId()) : null;</span>
<span class="nc bnc" id="L1732" title="All 4 branches missed.">			if (aCat != null &amp;&amp; aCat.isTOAllotment()) {</span>
<span class="nc" id="L1733">				summary = new TimeOffActivitySummary(null, aCat, aCat.getName(), null);</span>
<span class="nc bnc" id="L1734" title="All 2 branches missed.">				if (!actIDToTOActSummMap.containsKey(summary.getActivity_ActCategoryComb())) {</span>
<span class="nc" id="L1735">					TOAccrual accrual = null;</span>
<span class="nc" id="L1736">					accruedTO = null;</span>
<span class="nc bnc" id="L1737" title="All 2 branches missed.">					if (calculateAccrued) {</span>
<span class="nc bnc" id="L1738" title="All 4 branches missed.">						if (tOAccruedMap != null &amp;&amp; !tOAccruedMap.isEmpty()) {</span>
<span class="nc" id="L1739">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedMap.get(summary.getActivity_ActCategoryComb());</span>
						}
<span class="nc" id="L1741">						accrual = calculateAccruedTO(empID, null, aCat.getID(), adjustedStartDate, asOfDate, accruedTO, empDataMap);</span>

					} else {
<span class="nc" id="L1744">						m_cat.debug(&quot;Skipping this ActivityCategory:&quot; + aCat.getID() + &quot; ; &quot; + adjustedStartDate + &quot; ; &quot; + asOfDate);</span>
					}
<span class="nc bnc" id="L1746" title="All 2 branches missed.">					summary.setRemaining((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">					summary.setEmployeeTimeOffAccrued((accrual != null) ? accrual.getAccruedTO() : null); // Story 5861 - Time</span>
																											// Summary/My Schedule
																											// Summary Time-Off
																											// Changes

					// no need to Calculate carry over for First TO year of employee
<span class="nc" id="L1753">					accrual = null;</span>
<span class="nc" id="L1754">					accruedTO = null;</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">					if (nextDate != null) {</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">						if (tOAccruedStBalMap != null) {</span>
<span class="nc" id="L1757">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedStBalMap.get(summary.getActivity_ActCategoryComb());</span>
						}
						// accrual = calculateAccruedTO(empID, null, aCat.getID(), stDate, nextDate, accruedTO, empDataMap);
<span class="nc" id="L1760">						accrual = TOAccrualCalculator.getTOAccrdForGivenDtWthOverlapTOAtStofYr(empID, null, aCat.getID(), stDate, nextDate,</span>
								accruedTO, empDataMap);
					}
<span class="nc bnc" id="L1763" title="All 2 branches missed.">					summary.setCarryOver((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc" id="L1764">					actIDToTOActSummMap.put(summary.getActivity_ActCategoryComb(), summary);</span>
				}
				// TODO:

				/**
				 * This was found during the FIX for QC# This is wrong instantiation of the object here, but UI is using it to
				 * display the Time Off Summary records by activity category. The Activity ID and Activity Category are mutually
				 * exclusive, so only one of them should be not null while creating the TimeOffActivitySummary object
				 */

<span class="nc" id="L1774">				summary = new TimeOffActivitySummary(orgAct.getID(), aCat, orgAct.getName(), orgAct.getColor());</span>
<span class="nc" id="L1775">				actIDToTOActSummMap.put(Activity.getActivity_ActCategoryComb(orgAct.getID(), null), summary);</span>
			} else {
<span class="nc" id="L1777">				summary = new TimeOffActivitySummary(orgAct.getID(), null, orgAct.getName(), orgAct.getColor());</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">				if (orgAct.isTimeoffWithAllotment()) {</span>
<span class="nc" id="L1779">					TOAccrual accrual = null;</span>
<span class="nc" id="L1780">					accruedTO = null;</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">					if (calculateAccrued) {</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">						if (tOAccruedMap != null) {</span>
<span class="nc" id="L1783">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedMap.get(summary.getActivity_ActCategoryComb());</span>
						}
<span class="nc" id="L1785">						accrual = calculateAccruedTO(empID, orgAct.getID(), null, adjustedStartDate, asOfDate, accruedTO, empDataMap);</span>

					} else {
<span class="nc" id="L1788">						m_cat.debug(&quot;Skipping this activityID&quot; + orgAct.getID() + &quot; ; &quot; + adjustedStartDate + &quot; ; &quot; + asOfDate);</span>
					}
<span class="nc bnc" id="L1790" title="All 2 branches missed.">					summary.setRemaining((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">					summary.setEmployeeTimeOffAccrued((accrual != null) ? accrual.getAccruedTO() : null); // Story 5861 - Time</span>
																											// Summary/My Schedule
																											// Summary Time-Off
																											// Changes

					// no need to Calculate carry over for First TO year of employee
<span class="nc" id="L1797">					accrual = null;</span>
<span class="nc" id="L1798">					accruedTO = null;</span>
<span class="nc bnc" id="L1799" title="All 2 branches missed.">					if (nextDate != null) {</span>
<span class="nc bnc" id="L1800" title="All 2 branches missed.">						if (tOAccruedStBalMap != null) {</span>
<span class="nc" id="L1801">							accruedTO = (EmployeeTimeOffAccrued) tOAccruedStBalMap.get(summary.getActivity_ActCategoryComb());</span>
						}
						// accrual = calculateAccruedTO(empID, orgAct.getID(), null, stDate, nextDate, accruedTO, empDataMap);
<span class="nc" id="L1804">						accrual = TOAccrualCalculator.getTOAccrdForGivenDtWthOverlapTOAtStofYr(empID, orgAct.getID(), null, stDate,</span>
								nextDate, accruedTO, empDataMap);
					}
<span class="nc bnc" id="L1807" title="All 2 branches missed.">					summary.setCarryOver((accrual != null) ? (float) accrual.getEstimatedAccrHrs() : 0.0f);</span>
				}
<span class="nc" id="L1809">				actIDToTOActSummMap.put(summary.getActivity_ActCategoryComb(), summary);</span>
			}
<span class="nc" id="L1811">		}</span>
<span class="nc" id="L1812">	}</span>

	/**
	 * Returns a collection of organization activities with the attributes TimeOffWithAllocation and requestable for the specified
	 * orgID.
	 *
	 * @param orgID
	 * @return
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */

	// QC44912 requests don't appear in My Time Off Report tab if non-requestable, without allotment
	private Collection getTimeOffActs(ID orgID, boolean requestableOnly, boolean withAllotmentOnly) throws BbmEJBCreateException,
			BbmFinderException, RemoteException {
		// Get organizational activities of type timeoff for given employee.
		// Optionally only activities that are requestable and/or only with allotments will be returned.
		// see javadoc for TORequestManagerEJB for more information about activity attributes.
		// Note: if timeoff allotment is not specified for an activity, then this activity will not be
		// returned by the following filter.
<span class="nc" id="L1833">		ActivityFilter activityFilter = new ActivityFilter();</span>
<span class="nc" id="L1834">		activityFilter.setTimeoff(true);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">		if (withAllotmentOnly) {</span>
<span class="nc" id="L1836">			activityFilter.setTimeoffWithAllotment(true);</span>
		}
<span class="nc bnc" id="L1838" title="All 2 branches missed.">		if (requestableOnly) {</span>
<span class="nc" id="L1839">			activityFilter.setRequestable(true);</span>
		}

<span class="nc" id="L1842">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L1843">		Collection orgActivities = activityMgr.findOrganizationActivities(orgID, activityFilter);</span>
<span class="nc" id="L1844">		return orgActivities;</span>
	}

	/**
	 * Returns a collection of organization activity categories that support Time-Off allocation by groups requestable for the
	 * specified orgID.
	 *
	 * @param orgID
	 * @return
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private HashMap getActivityCategoryWithAlloc(ID orgID) throws BbmEJBCreateException, BbmFinderException, RemoteException {
<span class="nc" id="L1858">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L1859">		ActivityCategoryFilter filter = new ActivityCategoryFilter();</span>
<span class="nc" id="L1860">		filter.setTimeoffWithAllotment(true);</span>
<span class="nc" id="L1861">		ArrayList list = new ArrayList();</span>
<span class="nc" id="L1862">		list.add(orgID);</span>
<span class="nc" id="L1863">		return ValueObjectUtil.getIDObjectMap(activityMgr.findOrganizationActivityCategories(list, filter, true));</span>
	}

	/**
	 * Return an array of {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData} objects that
	 * contain time off calendar data for the given employee. The TOCalendarDayData objects contain, for each organization day in
	 * the range: - the allocated hours for the employee's organization - the pending hours (first choice only) for the employee -
	 * the hours scheduled in time off events for the employee - the hours remaining for the employee's organization =(allocated -
	 * scheduledForAllEmployees)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the scheduled time off for all employees
	 * in the organization) for each day in the range.
	 *
	 * @param empID the employee id
	 * @param startDate the beginning of the range. This is the beginning of an organization day in the organization's local time
	 *            zone.
	 * @param endDate the end of the range.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public TOCalendarDayData[] getTOCalendarDetailData(ID empID, Date startDate, Date endDate, boolean isTOPoolView,Organization currentEmpOrg)
			throws BbmFinderException {
<span class="nc" id="L1885">		return TOCalendarUtil.getTOCalendarForEmp(empID, startDate, endDate, isTOPoolView,currentEmpOrg);</span>
	}

	/**
	 * Gets the time off interval calendar for the employee. See getTOCalendarDetailData.
	 *
	 * @param empID The employee's ID.
	 * @param startDate The start of the range.
	 * @param endDate The exclusive end of the range.
	 * @param timeZone The viewing time zone.
	 * @param isTOPoolView True if we are viewing the time off pool. Otherwise, only the employee's data will be returned
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public TOIntervalCalendar getTOIntervalCalendarForEmp(ID empID, Date startDate, Date endDate, TimeZone timeZone, boolean isTOPoolView)
			throws BbmFinderException {
<span class="nc" id="L1902">		return TOIntervalCalendarUtil.getTOIntervalCalendarForEmp(empID, startDate, endDate, timeZone, isTOPoolView);</span>
	}

	/**
	 * Return an array of {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData} objects that
	 * contain time off calendar data for employees in the given organization. The optional empID input is the employee id of a
	 * supervisor for the organization. If it is not null, then the interest set of employees is all employees in the organization
	 * that the given supervisor supervises. If the supervisor id is null, then the interest set is all the employees in the
	 * organization.
	 * &lt;p/&gt;
	 * The returned TOCalendarDayData objects contain, for each organization day in the range: - the allocated hours for the
	 * organization, - the pending hours (first choice only) for the employees in the interest set - the hours scheduled in time off
	 * events for the employees in the interest set - the hours remaining for the organization =(allocated - scheduled)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the scheduled time off for all employees
	 * in the organization) for each day in the range.
	 *
	 * @param empID the employee id of a supervisor or null
	 * @param orgID the organization id
	 * @param startDate the beginning of the range. This is the beginning of an organization day in the organization's local time
	 *            zone.
	 * @param endDate the end of the range.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public TOCalendarDayData[] getTOCalendarDetailDataForManager(ID mgrEmpID, ID orgID, ID pTOPoolID, Date startDate, Date endDate)
			throws BbmFinderException {
		try {
<span class="nc" id="L1930">			Collection empIds = getTOCalendarEmpIdsInOrgForMgr(orgID, pTOPoolID, startDate, endDate);</span>
<span class="nc" id="L1931">			return TOCalendarUtil.getTOCalendarForManager(orgID, pTOPoolID, empIds, startDate, endDate);</span>
<span class="nc" id="L1932">		} catch (Exception e) {</span>
<span class="nc" id="L1933">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	/**
	 * If a TOP ID is specified, this gets a collection of employees that are assigned to it during the range. Otherwise, null is
	 * returned. This was extracted from getTOCalendarDetailDataForManager so it can be used with getTOIntervalCalendarForManager.
	 *
	 * @param orgID The organization's ID.
	 * @param pTOPoolID If specified the employee's belonging to this TOP will be returned.
	 * @param startDate
	 * @param endDate
	 * @return
	 * @throws Exception
	 */
	private Collection getTOCalendarEmpIdsInOrgForMgr(ID orgID, ID pTOPoolID, Date startDate, Date endDate) throws Exception {
<span class="nc" id="L1949">		Collection empIds = null;</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">		if (pTOPoolID == null) {</span>
<span class="nc" id="L1951">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(startDate);</span>
<span class="nc" id="L1952">			Pair pair = getEmpIdsInOrgForMgr(null, orgID, true, empStartDate, endDate);</span>
<span class="nc" id="L1953">			empIds = (Collection) pair.getFirst();</span>
		}
<span class="nc" id="L1955">		return empIds;</span>
	}

	/**
	 * Build a set of the employee IDs using &lt;li&gt;all employees in the specified organization which the currently logged in user has
	 * privilege to 'view' (AM employeeFilter implicitly uses this view privilege). &lt;li&gt;**and** restrict further to employee IDs
	 * which the specified manager supervises (if mgrEmpID is specified).
	 */
	private Pair getEmpIdsInOrgForMgr(ID mgrEmpID, ID orgID, boolean suppressPrivilege, Date startDate, Date endDate) throws Exception { // NOSONAR
<span class="nc" id="L1964">		ArrayList alParameters = new ArrayList();</span>
<span class="nc" id="L1965">		Collection colOrganizationIDs = new ArrayList();</span>
		// always get child orgs
<span class="nc" id="L1967">		colOrganizationIDs.add(orgID);</span>
<span class="nc" id="L1968">		colOrganizationIDs.addAll(BbmManagerFactory.getWorkResourceManager().getOrganizationsChildrenByIDs(Collections.singleton(orgID)));</span>
		/* colOrganizationIDs = DAOUtil.getChildOrganizations(orgID, new Jdmo()); */
<span class="nc" id="L1970">		alParameters.add(colOrganizationIDs);</span>
		// Build an employee filter using what we know to get a collection
		// of employee ids. The filter is made of compounding sub filter
		// objects.
<span class="nc" id="L1974">		ArrayList filters = new ArrayList();</span>
		// Build the organization subfilter
<span class="nc" id="L1976">		ArrayList parms = new ArrayList(1);</span>
<span class="nc" id="L1977">		parms.add(orgID);</span>
<span class="nc" id="L1978">		com.bluepumpkin.ejb.bbm.employeefilter.model.Filter f = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(</span>
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.ORGANIZATIONID,
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_EQUALS, parms);

<span class="nc bnc" id="L1982" title="All 2 branches missed.">		if (suppressPrivilege) {</span>
<span class="nc" id="L1983">			f.setPriviledge(null);</span>
		}
<span class="nc bnc" id="L1985" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L1986">			f.setTimePeriodType(com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L1987">			f.setStartTime(startDate);</span>
<span class="nc" id="L1988">			f.setEndTime(endDate);</span>
		}
<span class="nc" id="L1990">		filters.add(f);</span>

		// Do we want to further restrict by supervisor?
<span class="nc bnc" id="L1993" title="All 2 branches missed.">		if (mgrEmpID != null) {</span>
<span class="nc" id="L1994">			ArrayList sups = new ArrayList(1);</span>
<span class="nc" id="L1995">			sups.add(mgrEmpID);</span>

			// add supervisor subfilter to filters
<span class="nc" id="L1998">			com.bluepumpkin.ejb.bbm.employeefilter.model.Filter fsup = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(</span>
					com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.MANAGERID,
					com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_EQUALS, sups);
<span class="nc bnc" id="L2001" title="All 2 branches missed.">			if (suppressPrivilege) {</span>
<span class="nc" id="L2002">				fsup.setPriviledge(null);</span>
			}

<span class="nc" id="L2005">			filters.add(fsup);</span>
		}

		// Now make the compound filter we'll use to get the list of
		// employee ids
<span class="nc" id="L2010">		com.bluepumpkin.ejb.bbm.employeefilter.model.Filter cmpFltr = new com.bluepumpkin.ejb.bbm.employeefilter.model.Filter(0, // not</span>
																																	// used
																																	// for
																																	// AND
																																	// filters
				com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.OPERATOR_AND, filters);
<span class="nc bnc" id="L2016" title="All 2 branches missed.">		if (suppressPrivilege) {</span>
<span class="nc" id="L2017">			cmpFltr.setPriviledge(null);</span>
		}
<span class="nc bnc" id="L2019" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L2020">			cmpFltr.setTimePeriodType(com.bluepumpkin.ejb.bbm.employeefilter.model.Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2021">			cmpFltr.setStartTime(startDate);</span>
<span class="nc" id="L2022">			cmpFltr.setEndTime(endDate);</span>
		}
		// Use the compound filter to get a collection of employee ids
<span class="nc" id="L2025">		Collection empIds = null;</span>
<span class="nc" id="L2026">		com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter empFltr = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L2027">		User user = RequestUtil.getLoginUser(m_sessionContext);</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">		if (user == null) {</span>
			/*
			 * If User Object is null then this is defintely invoked from a CRON or BACKGROUND process Setting it to
			 * SuperUserFacade() is OK here.
			 */
<span class="nc" id="L2033">			user = new SuperUserFacade();</span>
		}
<span class="nc" id="L2035">		empIds = empFltr.getEmployeeIDs(cmpFltr, // Filter</span>
				user, // User
				Collections.EMPTY_LIST, // sort fields
				false, // is ascending, don't care about order
				0, // offset
				Integer.MAX_VALUE); // max number of ids

		// The employee ids cannot be an empty set, or else we'll find nothing.
<span class="nc bnc" id="L2043" title="All 4 branches missed.">		if ((empIds == null) || (empIds.size() == 0)) {</span>
<span class="nc" id="L2044">			m_cat.debug(&quot;&gt;&gt;&gt;getEmployeesInOrganization: No users in organizations!.&quot;);</span>
<span class="nc" id="L2045">			empIds = Collections.EMPTY_SET;</span>
		}
<span class="nc" id="L2047">		return new Pair(empIds, colOrganizationIDs);</span>
	}

	/**
	 * Gets the time off interval calendar for a manager.
	 *
	 * @param orgID The selected organization's ID.
	 * @param toPoolID The time off pool's ID to view. Null will return the organization's TOIC.
	 * @param startDate The start of the range.
	 * @param endDate The exclusive end of the range.
	 * @throws BbmFinderException
	 */
	public TOIntervalCalendar getTOIntervalCalendarForManager(ID orgID, ID toPoolID, Date startDate, Date endDate)
			throws BbmFinderException {
		try {
<span class="nc" id="L2062">			return TOIntervalCalendarUtil.getTOIntervalCalendarForManager(orgID, toPoolID, startDate, endDate);</span>
<span class="nc" id="L2063">		} catch (Exception e) {</span>
<span class="nc" id="L2064">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability')
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection getTimeOffTypes(ID pOrganizationId) throws BbmFinderException {
<span class="nc" id="L2077">		String _method_ = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L2078">		methodStart(_method_, pOrganizationId);</span>

		// create filter.
<span class="nc" id="L2081">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default

<span class="nc" id="L2084">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L2089">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2090">			return am.findOrganizationActivities(pOrganizationId, filter);</span>
<span class="nc" id="L2091">		} catch (Exception e) {</span>
<span class="nc" id="L2092">			handleException(e);</span>
<span class="nc" id="L2093">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2095">			methodFinish();</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attributes 'Requestable' and
	 * ('Timeoff' or 'Unavailability')
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @param flexType - to identify if it's a flex or TO request
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection getTimeOffTypes(ID pOrganizationId, int flexType) throws BbmFinderException {
<span class="nc" id="L2109">		String methodName = &quot;getTimeOffTypes&quot;;</span>
<span class="nc" id="L2110">		methodStart(methodName, pOrganizationId, flexType);</span>

		// create filter.
<span class="nc" id="L2113">		ActivityFilter filter = new ActivityFilter();</span>
		// gets active by default
<span class="nc" id="L2115">		filter.setRequestable(true);</span>
		// filter 'Requestable' activities.
		// Since 'Requestable' activities are automatically 'timeoff' or 'Unavailability',
		// they are not explicitly specified
		try {
<span class="nc" id="L2120">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2121">			return am.findOrganizationActivities(pOrganizationId, filter, flexType);</span>
<span class="nc" id="L2122">		} catch (Exception e) {</span>
<span class="nc" id="L2123">			handleException(e);</span>
<span class="nc" id="L2124">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2126">			methodFinish();</span>
		}
	}

	/**
	 * Returns a filtered collection, from the list of activities for the given organization with attribute 'TimeoffWithAllotment'.
	 *
	 * @param pOrganizationId- Id for the organization.
	 * @return Collection - Collection of the activityIDs.
	 * @throws - BbmFinderException.
	 */
	public Collection getAccruableTimeOffTypes(ID pOrganizationId) throws BbmFinderException {
<span class="nc" id="L2138">		String _method_ = &quot;getAccruableTimeOffTypes&quot;;</span>
<span class="nc" id="L2139">		methodStart(_method_, pOrganizationId);</span>

		// create filter.
<span class="nc" id="L2142">		ActivityFilter filter = new ActivityFilter(); // gets active by default</span>
		// filter 'Time Off With Accrual' activities (they must be time off)
<span class="nc" id="L2144">		filter.setTimeoffWithAllotment(true);</span>
		// NOTE: There is a problem with this filter. It is supposed to get aall activities with accrual.
		// But the ActivityFilter doesn't return those that fall under an accruable activity category because
		// those activities internally do not have the ISTIMEOFFWITHALLOTTMENT flag set in the ACTIVITY table.
		// We need to add code that checks the activity's category as well. If the category is for accrual,
		// then the activity should be too and we would include it in the result.

<span class="nc" id="L2151">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2152">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2154">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2156">			ActivityManager am = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L2157">			return am.findOrganizationActivities(pOrganizationId, filter);</span>
<span class="nc" id="L2158">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2159">			m_cat.error(e, e);</span>
<span class="nc" id="L2160">			handleException(e);</span>
<span class="nc" id="L2161">			throw (e);</span>
<span class="nc" id="L2162">		} catch (Exception e) {</span>
<span class="nc" id="L2163">			handleException(e);</span>
<span class="nc" id="L2164">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2166" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2167">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2169">			methodFinish();</span>
		}
	}

	public TOWaitlistManager getTOWaitlistManager() throws BbmCreateException {
<span class="nc" id="L2174">		return RmManagerFactory.getInstance(true).getTOWaitlistManager(null, null);</span>
	}

	public void createTOWaitlistRequest(TOWaitlist pTOWaitlist) throws Exception {
<span class="nc" id="L2178">		getTOWaitlistManager().createTOWaitlistRequest(pTOWaitlist);</span>
<span class="nc" id="L2179">	}</span>

	public void removeTORequestFromWaitlist(ID toReqID) {
<span class="nc" id="L2182">		RequestAggregateDAO reqAggDao = null;</span>
<span class="nc" id="L2183">		long detailLevel = Request.DL_BASIC;</span>
		try {
<span class="nc" id="L2185">			reqAggDao = getDAO(detailLevel);</span>
<span class="nc" id="L2186">			RequestAggregate reqAgg = reqAggDao.getRequestByID(toReqID, detailLevel);</span>
<span class="nc bnc" id="L2187" title="All 2 branches missed.">			if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L2188">				reqAgg.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
<span class="nc" id="L2189">				updateRequest(reqAgg, &quot;Removed Request from Waitlist&quot;);</span>
			}
<span class="nc" id="L2191">			deleteTOWaitlistRequestSetting(toReqID);</span>
<span class="nc" id="L2192">		} catch (Exception e) {</span>
<span class="nc" id="L2193">		}</span>
<span class="nc" id="L2194">	}</span>

	public void deleteTOWaitlistRequestSetting(ID toRequestId) throws BbmRemoveException {
		try {
<span class="nc" id="L2198">			getTOWaitlistManager().deleteTOWaitlistRequestSetting(toRequestId);</span>
<span class="nc" id="L2199">		} catch (Exception e) {</span>
<span class="nc" id="L2200">			m_cat.error(e, e);</span>
<span class="nc" id="L2201">			handleException(e);</span>
<span class="nc" id="L2202">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L2203">		}</span>
<span class="nc" id="L2204">	}</span>

	public void addRequestTOWaitlist(ID userID, TORequest request, String comment, Date expiryDate, boolean isManager) throws RmException {
<span class="nc" id="L2207">		String _method_ = &quot;waitlistRequest&quot;;</span>
<span class="nc" id="L2208">		methodStart(_method_, userID, request, comment, expiryDate);</span>
		try {
<span class="nc" id="L2210">			TOWaitlist waitlist = request.getWaitlistInfo();</span>
<span class="nc bnc" id="L2211" title="All 2 branches missed.">			if (waitlist == null) {</span>
<span class="nc" id="L2212">				waitlist = new TOWaitlist();</span>
<span class="nc" id="L2213">				waitlist.setTOWaitlistCreatorID(userID);</span>
<span class="nc" id="L2214">				waitlist.setTOWaitlistCreationDate(new Date());</span>
			}
<span class="nc bnc" id="L2216" title="All 2 branches missed.">			if (expiryDate == null) {</span>
<span class="nc" id="L2217">				expiryDate = request.getExpirationDate(); // set the waitlist expiry date to the Request Expiration Date.</span>
			}
<span class="nc" id="L2219">			waitlist.setTOWaitlistExpiryDate(expiryDate);</span>
<span class="nc" id="L2220">			request.setWaitlistInfo(waitlist);</span>
<span class="nc" id="L2221">			String oldStatus = request.getRequestStatus();</span>
<span class="nc bnc" id="L2222" title="All 4 branches missed.">			if (isManager &amp;&amp; !isRequestEligibleForWaitlist(request)) {</span>
				// Set manually added to true if request is not eligible for waitlist and manager is forcing it to waitlist
<span class="nc bnc" id="L2224" title="All 4 branches missed.">				waitlist.setManuallyAdded(!isRequestEligibleForWaitlist(request) &amp;&amp; RequestAuditTrail.STATUS_DENIED.equals(oldStatus));</span>
<span class="nc" id="L2225">				comment = RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.MANUALLY_WAITLISTED) + &quot; &quot; + comment;</span>
<span class="nc" id="L2226">				_waitlistRequestWorkFlow(request, request.getFirstTOChoice().getID(), comment, true, true);</span>
			} else {
				// update the request to trigger auto validation rules
<span class="nc bnc" id="L2229" title="All 2 branches missed.">				if (RequestAuditTrail.STATUS_DENIED.equals(request.getRequestStatus())) {</span>
<span class="nc" id="L2230">					request.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
				}
<span class="nc" id="L2232">				RmManagerFactory.getInstance().getTimeOffRequestManager().updateRequest(request, comment);</span>
			}
<span class="nc" id="L2234">		} catch (Exception e) {</span>
<span class="nc" id="L2235">			handleException(e);</span>
<span class="nc" id="L2236">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2238">			methodFinish();</span>
<span class="nc" id="L2239">		}</span>
<span class="nc" id="L2240">	}</span>

	@Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsSorted, RequestFilter reqFilter, int sortColumn,
			int sortDirection, boolean inclExpired, long detailLevel, boolean runSoftValids, boolean runNetStaffingSoftVal)
			throws RmException, RmHardValidationException {
<span class="nc bnc" id="L2246" title="All 2 branches missed.">		String sortDirStr = sortDirection == SupportNavigation.SORT_DESCENDING ? RequestUtil.SORTDIR_DESC : RequestUtil.SORTDIR_ASC;</span>
<span class="nc" id="L2247">		String _method_ = &quot;applyFilterAndSortCriteriaForRequests&quot;;</span>
<span class="nc" id="L2248">		methodStart(_method_, reqIDsSorted, reqFilter, new Integer(sortColumn), sortDirStr);</span>
<span class="nc" id="L2249">		Pair returnPair = new Pair(reqIDsSorted, null);</span>
		try {
			// this API should be called only if in memory sorting is required.
			// This is true when we need to get waitlist priority order which is applicable to the waitlisted requests only.
<span class="nc bnc" id="L2253" title="All 2 branches missed.">			if (RequestAuditTrail.STATUS_WAITLIST.equals(reqFilter.getValueForKey(RequestFilter.STATUS_KEY))) {</span>
				// Compute the waitlist priority order only if TOPool Key is set
<span class="nc bnc" id="L2255" title="All 2 branches missed.">				if (reqFilter.isKeySet(RequestFilter.TOPOOL_KEY)) {</span>
<span class="nc" id="L2256">					ID pTOPoolID = (ID) reqFilter.getValueForKey(RequestFilter.TOPOOL_KEY);</span>
<span class="nc" id="L2257">					returnPair = getTOWaitlistManager().sortAndSetPriortyOrderForWaitlists(reqIDsSorted, pTOPoolID, sortColumn, sortDirStr,</span>
							detailLevel, runSoftValids);
				}
				// IF the sort column requires an in memory sort
<span class="nc bnc" id="L2261" title="All 2 branches missed.">				if (Request.getMethodForSortOrderColumn(sortColumn) != null) {</span>
<span class="nc" id="L2262">					Pair[] sortSeqPairArray = new Pair[1];</span>
<span class="nc" id="L2263">					sortSeqPairArray[0] = new Pair(&quot;&quot; + sortColumn, sortDirStr);</span>
					// get the request from DB again only if the Requests are not available here
					// we get all the requests in the earlier call made to compute the Waitlist priorty Order
<span class="nc" id="L2266">					List sbReqsList = (List) returnPair.getSecond();</span>
<span class="nc bnc" id="L2267" title="All 4 branches missed.">					if (sbReqsList == null || sbReqsList.isEmpty()) {</span>
<span class="nc" id="L2268">						detailLevel |= TORequest.DL_AUDIT_TRAIL | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH</span>
								| TORequest.DL_TIMEOFF_WAITLIST;
<span class="nc" id="L2270">						Collection sbReqs = getRequestsById(reqIDsSorted, inclExpired, runSoftValids, runNetStaffingSoftVal, detailLevel);</span>
<span class="nc" id="L2271">						sbReqsList = RequestUtil.getListFromCollection(sbReqs);</span>
					}
<span class="nc bnc" id="L2273" title="All 2 branches missed.">					if (sbReqsList.size() &gt; 1) { // throws UnsupportedOperationException if the size is one</span>
<span class="nc" id="L2274">						Collections.sort(sbReqsList, new TORequestUtil.TOWailistComparator(sortSeqPairArray));</span>
					}
<span class="nc bnc" id="L2276" title="All 4 branches missed.">					if (sbReqsList != null &amp;&amp; !sbReqsList.isEmpty()) {</span>
<span class="nc" id="L2277">						returnPair = new Pair(RequestUtil.getListOfIDsFromVOBases(sbReqsList), sbReqsList);</span>
					}
				}
			}
<span class="nc" id="L2281">		} catch (Exception e) {</span>
<span class="nc" id="L2282">			handleException(e);</span>
<span class="nc" id="L2283">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2285">			methodFinish();</span>
<span class="nc" id="L2286">		}</span>
<span class="nc" id="L2287">		return returnPair;</span>
	}

	/**
	 * overridden by TORequestManagerEJB only.
	 *
	 * @param reqAgg for further information.
	 * @param toChoiceID
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected boolean _waitlistRequest(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2303">		boolean result = false;</span>
		try {
<span class="nc bnc" id="L2305" title="All 2 branches missed.">			if (!RequestAuditTrail.STATUS_WAITLIST.equals(reqAgg.getRequestStatus())) { // no point in changing the status from</span>
																						// waitlist to waitlist again.
<span class="nc" id="L2307">				reqAgg.setRequestStatus(RequestAuditTrail.STATUS_WAITLIST);</span>
<span class="nc" id="L2308">				TORequest toRequest = (TORequest) reqAgg;</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">				if (toChoiceID == null) {</span>
<span class="nc" id="L2310">					TOChoice toChoice = toRequest.getWaitlistTOChoice();</span>
<span class="nc" id="L2311">					toChoiceID = toChoice.getID();</span>
				}
<span class="nc" id="L2313">				Collection col = toRequest.getRequestChoiceList();</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">				for (Iterator iterator = col.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2315">					TOChoice choice = (TOChoice) iterator.next();</span>
<span class="nc bnc" id="L2316" title="All 2 branches missed.">					if (choice.getID().equals(toChoiceID)) {</span>
<span class="nc" id="L2317">						choice.setRank(1);</span>
<span class="nc" id="L2318">						choice.setIsWaitlist(true);</span>
<span class="nc" id="L2319">						toRequest.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
					} else {
<span class="nc bnc" id="L2321" title="All 4 branches missed.">						if (choice.getRank() == 1 || choice.isWaitlist()) {</span>
<span class="nc" id="L2322">							choice.setRank(0);</span>
<span class="nc" id="L2323">							choice.setIsWaitlist(false);</span>
<span class="nc" id="L2324">							toRequest.updateChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, choice);</span>
						}
					}
<span class="nc" id="L2327">				}</span>
<span class="nc" id="L2328">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L2329">				result = true; // returns true if update is successful ; else exception is thrown</span>
			}
			// QA 94537 - timeoff go from pending to waitlisted state alert is sending mutiple emails to timeoff requester when a
			// schedule is published.
			// keep result = false because there isn't any update here and prevent the alert email will be sent out
<span class="nc" id="L2334">		} catch (Exception e) {</span>
<span class="nc" id="L2335">			handleException(e);</span>
<span class="nc" id="L2336">			throw new BbmUpdateException(e.getMessage());</span>
<span class="nc" id="L2337">		}</span>
<span class="nc" id="L2338">		return result;</span>
	}

	/**
	 * implemented for TORequestManagerEJB only
	 *
	 * @param reqAgg for further information.
	 */
	@Override
	public boolean areWaitlistPreferencesSetForRequest(RequestAggregate reqAgg) throws BbmException {

		try {
<span class="nc bnc" id="L2350" title="All 2 branches missed.">			if (!reqAgg.isTimeOffRequest()) {</span>
<span class="nc" id="L2351">				return false; // return False for all other types of requests</span>
			}
<span class="nc" id="L2353">			TOWaitlist toWaitlist = getTOWaitlistManager().getTOWaitlistByTimeOffRequestId(((TORequest) reqAgg).getID());</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">			return (toWaitlist != null);// Return false if user did not opt for waitlist</span>
<span class="nc" id="L2355">		} catch (Exception e) {</span>
<span class="nc" id="L2356">			handleException(e);</span>
<span class="nc" id="L2357">			throw new BbmException(e);</span>
		}
	}

	@Override
	public boolean canRequestBeWaitlistedBasedOnValidations(int[] apprDenyResult1, Collection[] apprDenyValResults1) throws BbmException {
		try {
			// Return False if
			// 1&gt; Waitlist result is not available
			// 2&gt; Waitlist Result = DONT Waitlist
			// 3&gt; Waitlist Result = No Violations found.
			// 4&gt; Waitlist Validation Result for Violations is null or empty.
<span class="nc bnc" id="L2369" title="All 8 branches missed.">			if (apprDenyResult1.length &lt; 3</span>
					|| apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_DONOT_WAITLIST
					|| apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_NO_VIOLATIONS
					|| apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == null
<span class="nc bnc" id="L2373" title="All 2 branches missed.">					|| apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].isEmpty()) {</span>
<span class="nc" id="L2374">				return false;</span>
			}
<span class="nc bnc" id="L2376" title="All 2 branches missed.">			if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_WAITLIST] == AutoProcessingRuleChecker.AUTOPROC_WAITLIST_CLAUSE_VIOLATIONS_FOUND) {</span>
				// return True if no violations for Denial are found
<span class="nc bnc" id="L2378" title="All 4 branches missed.">				if (apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY] == null || apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].isEmpty()) {</span>
<span class="nc" id="L2379">					return true;</span>
				}
				// return False if Denial violation count exceeds the Waitlist violation count
<span class="nc bnc" id="L2382" title="All 2 branches missed.">				if (apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].size() &gt; apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].size()) {</span>
<span class="nc" id="L2383">					return false;</span>
				}
				// Compare the Denial violations &amp; waitlist violations.
				// If Denial Violations are different from Waitlist then return False; else True.
<span class="nc" id="L2387">				HashSet denySet = new HashSet(apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].size());</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">				for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2389">					ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="nc" id="L2390">					denySet.add(validationResult.getValidatorName());</span>
<span class="nc" id="L2391">				}</span>
<span class="nc bnc" id="L2392" title="All 2 branches missed.">				for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_WAITLIST].iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2393">					ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="nc" id="L2394">					denySet.remove(validationResult.getValidatorName());</span>
<span class="nc" id="L2395">				}</span>
<span class="nc" id="L2396">				return denySet.isEmpty(); // Return True if no denial clause is left ; else return False.</span>
			}
<span class="nc" id="L2398">			return true;</span>
<span class="nc" id="L2399">		} catch (Exception e) {</span>
<span class="nc" id="L2400">			handleException(e);</span>
<span class="nc" id="L2401">			throw new BbmException(e);</span>
		}
	}

	/**
	 * overridden by TORequestManagerEJB only, returns true for the waitlist feature.
	 *
	 * @param reqAgg for further information.
	 */
	@Override
	public boolean ignoreAmbiguousAutoProcessResults(RequestAggregate reqAgg) {
<span class="nc" id="L2412">		return false;</span>
	}

	@Override
	public boolean isRequestEligibleForWaitlist(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L2417">		String _method_ = &quot;isRequestEligibleForWaitlist&quot;;</span>
<span class="nc" id="L2418">		methodStart(_method_, reqAgg);</span>
		// we want to check the &quot;add to waitlist&quot; eligibilty in this method so setting it to true;
<span class="nc" id="L2420">		boolean checkForWaitlist = true;</span>
		try {
<span class="nc bnc" id="L2422" title="All 6 branches missed.">			if (reqAgg != null &amp;&amp; reqAgg.isElgibleForWaitlist() &amp;&amp; TORequestUtil.isTOWaitlistEnabled(reqAgg)) {</span>
				// Need to get all the Time Range Pairs to decide if any one Choice Can be waitlisted.
<span class="nc" id="L2424">				Pair pair = ((TORequest) reqAgg).getAllEmpIDTimeRangePairs();</span>
<span class="nc" id="L2425">				Collection empIDTimeRangePairs = (Collection) pair.getFirst();</span>
<span class="nc" id="L2426">				ArrayList toChoiceList = (ArrayList) pair.getSecond();</span>
<span class="nc" id="L2427">				Iterator iter = empIDTimeRangePairs.iterator();</span>
<span class="nc" id="L2428">				int counter = 0;</span>
<span class="nc bnc" id="L2429" title="All 2 branches missed.">				for (; iter.hasNext(); counter++) {</span>
<span class="nc" id="L2430">					Collection[] apprDenyValResults1 = new Collection[3];</span>
<span class="nc" id="L2431">					Map ruleNameToValResultsMap = new HashMap(19);</span>
<span class="nc" id="L2432">					Pair empIDTimeRangePair = (Pair) iter.next();</span>
<span class="nc" id="L2433">					ID empID = (ID) empIDTimeRangePair.getFirst();</span>
<span class="nc" id="L2434">					TimeRange timeRange = (TimeRange) empIDTimeRangePair.getSecond();</span>
<span class="nc" id="L2435">					TOChoice toChoice = (TOChoice) toChoiceList.get(counter);</span>
<span class="nc" id="L2436">					((TORequest) reqAgg).setTOChoiceForValidation(toChoice);</span>
<span class="nc" id="L2437">					int[] apprDenyResult1 = runAutoProcessForTimeRange(empID, timeRange, true, true, apprDenyValResults1, reqAgg,</span>
							ruleNameToValResultsMap);
<span class="nc" id="L2439">					String requestStatus = getDecisionBasedOnAutProcessRuleEngineResult(reqAgg, apprDenyResult1, apprDenyValResults1,</span>
							checkForWaitlist);
<span class="nc" id="L2441">					((TORequest) reqAgg).setTOChoiceForValidation(null);</span>
<span class="nc bnc" id="L2442" title="All 2 branches missed.">					if (requestStatus.equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L2443">						((TORequest) reqAgg).setTOChoiceEligibleForWaitlist(toChoice);</span>
<span class="nc" id="L2444">						return true;</span>
<span class="nc bnc" id="L2445" title="All 2 branches missed.">					} else if (requestStatus.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2446">						break;</span>
					}
				}
			}
<span class="nc" id="L2450">			return false;</span>
<span class="nc" id="L2451">		} catch (Exception e) {</span>
<span class="nc" id="L2452">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2454">			methodFinish();</span>
		}
	}

	public TOWithdrawManager getTOWithdrawManager() throws BbmCreateException {
<span class="nc" id="L2459">		return RmManagerFactory.getInstance(true).getTOWithdrawManager(null, null);</span>
	}

	@Override
	protected boolean _acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2465">		String methodName = &quot;_acceptWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2466">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2468">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// set the original TORequest to withdrawan as one transaction
<span class="nc" id="L2470">			TORequest toRequest = (TORequest) reqAgg;</span>
<span class="nc" id="L2471">			TOChoice apprChoice = toRequest.getApprovedChoice();</span>
<span class="nc" id="L2472">			_undoSchedule(reqAgg, null, null);</span>

			// toRequest.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAWN);
			// set the underlying TimeOffWithdrawRequest to Accepted
<span class="nc" id="L2476">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2477">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_ACCEPT);</span>
<span class="nc" id="L2478">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2479" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2480">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2482">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), false);</span>
<span class="nc" id="L2483">			_updateRequest(reqAgg, RequestAuditTrail.STATUS_WITHDRAWN, comment, null, false, suppressPrivilegeChecking, loadedFromDB, true);</span>
<span class="nc" id="L2484">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2485">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2486">			TONotifyMessageClient.scanTOWaitlist(toRequest, apprChoice);</span>
<span class="nc" id="L2487">			return true;</span>
<span class="nc" id="L2488">		} catch (Exception e) {</span>
<span class="nc" id="L2489">			handleException(e);</span>
<span class="nc" id="L2490">			throw new BbmUpdateException(e.getMessage());</span>
		} finally {
<span class="nc" id="L2492">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	@Override
	protected boolean _rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2499">		String methodName = &quot;_rejectWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2500">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2502">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// leave the original TORequest unchanged
<span class="nc" id="L2504">			TORequest toRequest = (TORequest) reqAgg;</span>
			// set the underlying TimeOffWithdrawRequest to rejected
<span class="nc" id="L2506">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2507">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REJECT);</span>
<span class="nc" id="L2508">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2510">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2512">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), true);</span>
<span class="nc bnc" id="L2513" title="All 2 branches missed.">			if (reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L2514">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
			} else {
<span class="nc" id="L2516">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L2517">						hasAdvanceLicense());</span>
			}
<span class="nc" id="L2519">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2520">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2521">			return true;</span>
<span class="nc" id="L2522">		} catch (Exception e) {</span>
<span class="nc" id="L2523">			handleException(e);</span>
<span class="nc" id="L2524">			throw new BbmUpdateException(e.getMessage());</span>
		} finally {
<span class="nc" id="L2526">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	// Check if request is eligible for accepting the withdraw
	@Override
	public boolean isEligibleForAcceptWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2533" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForAcceptWithdrawAction();</span>
	}

	/*
	 * //Check if request is eligible for requesting the withdraw public Pair
	 * isEligibleForRequestWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException { Pair pair = new Pair(new
	 * Boolean(&quot;true&quot;), null); if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {
	 * TimeOffChoiceHasNoUnderlyingEvent validator = new TimeOffChoiceHasNoUnderlyingEvent(); try { ValidationResult result =
	 * validator.validate(reqAgg); if (result != null) { //mark request as invalid in all other cases if
	 * (!result.getMessageResource().equals(RmEjbBundleKey.TIMEOFF_WITHDRAW_UNDERLYING_EVENT_NOT_EXIST_IN_UNPUB)) {
	 * markRequestAsInvalid(reqAgg, result, null); } String hardValLocalizedMsg =
	 * result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg.getValidationCache().getTimeZoneForOrg()); pair
	 * = new Pair(new Boolean(&quot;false&quot;), hardValLocalizedMsg); } } catch (Exception e) { e.printStackTrace(); //To change body of
	 * catch statement usen File | Settings | File Templates. } } return pair; }
	 */
	public Pair&lt;Boolean, String&gt; isEligibleForRequestWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L2549">		Pair&lt;Boolean, String&gt; pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;true&quot;), null);</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">		if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
			// QA-103536 -- Skipped the TimeOffChoiceHasNoUnderlyingEvent validator and created a new
			// validateApprovedRequestForWithdraw() method in TORequestUtil.java

			// TimeOffChoiceHasNoUnderlyingEvent validator = new TimeOffChoiceHasNoUnderlyingEvent();
			try {
				// QA-103536 fix .
<span class="nc" id="L2557">				ValidationResult result = TORequestUtil.validateApprovedRequestForWithdraw(reqAgg);</span>
<span class="nc bnc" id="L2558" title="All 2 branches missed.">				if (result != null) {</span>
					// mark request as invalid in all other cases
<span class="nc bnc" id="L2560" title="All 2 branches missed.">					if (!result.getMessageResource().equals(RmEjbBundleKey.TIMEOFF_WITHDRAW_UNDERLYING_EVENT_NOT_EXIST_IN_UNPUB)) {</span>
<span class="nc" id="L2561">						markRequestAsInvalid(reqAgg, result, null);</span>
					}
<span class="nc" id="L2563">					String hardValLocalizedMsg = result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg</span>
<span class="nc" id="L2564">							.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L2565">					pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;false&quot;), hardValLocalizedMsg);</span>
				}
<span class="nc" id="L2567">			} catch (Exception e) {</span>
<span class="nc" id="L2568">				e.printStackTrace(); // To change body of catch statement usen File | Settings | File Templates.</span>
<span class="nc" id="L2569">			}</span>
		}
<span class="nc" id="L2571">		return pair;</span>
	}

	// Check if request is eligible for rejecting the withdraw
	@Override
	public boolean isEligibleForRejectWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2577" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForRejectWithdrawAction();</span>
	}

	@Override
	public boolean requestWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws BbmUpdateException {
<span class="nc" id="L2582">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2583">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2585">			TORequest request = (TORequest) reqAgg;</span>
<span class="nc" id="L2586">			TOWithdraw withdraw = new TOWithdraw();</span>
<span class="nc" id="L2587">			withdraw.setTORequestID(request.getID());</span>
<span class="nc" id="L2588">			withdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>
<span class="nc" id="L2589">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L2590">			withdraw.setCreatorID(user.getID());</span>
<span class="nc" id="L2591">			withdraw.setCreationDate(new Date());</span>
<span class="nc" id="L2592">			request.setWithdrawInfo(withdraw);</span>
<span class="nc" id="L2593">			setAuditTrail(reqAgg, comment, withdraw.getRequestStatus(), true);</span>
<span class="nc bnc" id="L2594" title="All 2 branches missed.">			if (reqAgg.isFlexTimeRequest()){</span>
<span class="nc" id="L2595">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false, false, false); </span>
			} else {
<span class="nc" id="L2597">				_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false, false, hasAdvanceLicense()); </span>
			}
<span class="nc" id="L2599">			reqAgg = getRequestByID(reqAgg.getID(), false, false, reqAgg.getDetailLevel());</span>
<span class="nc" id="L2600">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, withdraw.getRequestStatus()));</span>
<span class="nc" id="L2601">			_autoProcessWithdraw(reqAgg, &quot;auto-process&quot;, true);</span>
<span class="nc" id="L2602">			return true;</span>
<span class="nc" id="L2603">		} catch (Exception e) {</span>
<span class="nc" id="L2604">			handleException(e);</span>
<span class="nc" id="L2605">			throw new BbmUpdateException(e.getMessage());</span>
		} finally {
<span class="nc" id="L2607">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	@Override
	protected boolean isEligibleForCancelWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L2613" title="All 4 branches missed.">		return reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForCancelWithdrawAction();</span>
	}

	/**
	 * applies to Cancelling Withdrawal of approved Requests
	 *
	 * @param reqAgg
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected boolean _cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L2628">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L2629">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L2631">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
			// leave the original TORequest unchanged ; just update the comments
<span class="nc" id="L2633">			TORequest toRequest = (TORequest) reqAgg;</span>
			// set the underlying TimeOffWithdrawRequest to cancelled
<span class="nc" id="L2635">			TOWithdraw toWithdraw = toRequest.getWithdrawInfo();</span>
<span class="nc" id="L2636">			toWithdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_CANCEL);</span>
<span class="nc" id="L2637">			toWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L2638" title="All 2 branches missed.">			if (user != null) {</span>
<span class="nc" id="L2639">				toWithdraw.setModifierID(user.getID());</span>
			}
<span class="nc" id="L2641">			setAuditTrail(reqAgg, comment, toWithdraw.getRequestStatus(), true);</span>
<span class="nc" id="L2642">			_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, suppressPrivilegeChecking, loadedFromDB,</span>
<span class="nc" id="L2643">					hasAdvanceLicense());</span>
<span class="nc" id="L2644">			getTOWithdrawManager().updateTOWithdrawRequest(toWithdraw);</span>
<span class="nc" id="L2645">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, toWithdraw.getRequestStatus()));</span>
<span class="nc" id="L2646">			return true;</span>
<span class="nc" id="L2647">		} catch (Exception e) {</span>
<span class="nc" id="L2648">			handleException(e);</span>
<span class="nc" id="L2649">			throw new BbmUpdateException(e.getMessage());</span>
		} finally {
<span class="nc" id="L2651">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	public void setAuditTrail(RequestAggregate request, String comment, String status, boolean setAuditTrailState) throws Exception {
<span class="nc" id="L2656">		User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L2657">		RequestAuditTrail raTrail = RequestDAO.createAuditTrailObject(status, new Date(), comment, RmEjbBundleKey.UPDATED, user.getID());</span>
<span class="nc" id="L2658">		raTrail.setIsStatusChange(true);</span>
<span class="nc" id="L2659">		request.setAuditTrail(raTrail);</span>
<span class="nc" id="L2660">		request.setAuditTrailSet(setAuditTrailState);</span>
<span class="nc" id="L2661">	}</span>

	@Override
	protected void updateRequestPostProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, boolean loadedFromDB, String origState)
			throws Exception {
		/*
		 * TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE); msg.setObject(new Pair(reqAgg, new
		 * Boolean(!RequestAuditTrail.STATUS_APPROVED.equals(origState)))); msg.sendMessage();
		 */
<span class="nc bnc" id="L2670" title="All 2 branches missed.">		getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, !RequestAuditTrail.STATUS_APPROVED.equals(origState));</span>

<span class="nc" id="L2672">		getTimeOffIntervalAllocationManager().onUpdateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2673">	}</span>

	@Override
	protected void createRequestPostProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
		/*
		 * TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE); msg.setObject(new Pair(reqAgg, new
		 * Boolean(!RequestAuditTrail.STATUS_APPROVED.equals(origState)))); msg.sendMessage();
		 */
<span class="nc" id="L2681">		getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, true);</span>
<span class="nc" id="L2682">		getTimeOffIntervalAllocationManager().onCreateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2683">	}</span>

	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L2688">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L2689">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L2691">		TORequestDAO toReqDao = null;</span>
<span class="nc" id="L2692">		String setterID = CLASS_NAME + '.' + _method_;</span>

		try {

<span class="nc" id="L2696">			String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L2698">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L2700">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L2703">			toReqDao = new TORequestDAO(TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES);</span>
<span class="nc" id="L2704">			toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, getRequestType(), subType);</span>
<span class="nc" id="L2705">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2712">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2713">			throw e;</span>
<span class="nc" id="L2714">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L2715">			m_cat.error(e, e);</span>
<span class="nc" id="L2716">			handleException(e);</span>
<span class="nc" id="L2717">			throw e;</span>
<span class="nc" id="L2718">		} catch (Exception e) {</span>
<span class="nc" id="L2719">			handleException(e);</span>
<span class="nc" id="L2720">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc bnc" id="L2723" title="All 4 branches missed.">			if (toReqDao != null) {</span>
<span class="nc" id="L2724">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L2726">			methodFinish();</span>
<span class="nc" id="L2727">		}</span>
<span class="nc" id="L2728">	}</span>

	@Override
	protected void invalidateRequestPostProcess(Jdmo jdmo, RequestAggregate reqAgg, String comment) throws BbmUpdateException {
		try {
<span class="nc" id="L2733">			getTOHoursPerDayManager().updateTOHoursPerDayForTORequest((TORequest) reqAgg, false);</span>
<span class="nc" id="L2734">			getTimeOffIntervalAllocationManager().onUpdateTORequest((TORequest) reqAgg);</span>
<span class="nc" id="L2735">		} catch (Exception e) {</span>
<span class="nc" id="L2736">			handleException(e);</span>
<span class="nc" id="L2737">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L2738">		}</span>
<span class="nc" id="L2739">		super.invalidateRequestPostProcess(jdmo, reqAgg, comment);</span>
<span class="nc" id="L2740">	}</span>

	/**
	 * Calculate the accrued Time-off for an employee of given activity at given date
	 *
	 * @return number of hours
	 * @throws BbmFinderException
	 */
	public TOAccrual calculateAccruedTO(ID empID, ID activityID, ID actCatID, Date asOfDate) throws RmException {
<span class="nc" id="L2749">		return TOAccrualCalculator.getTOAccruedForGivenDate(empID, activityID, actCatID, null, asOfDate, null, null);</span>
	}

	private TOAccrual calculateAccruedTO(ID empID, ID activityID, ID actCatID, Date startDate, Date asOfDate,
			EmployeeTimeOffAccrued accruedTO, HashMap empActivityDataMap) {
<span class="nc" id="L2754">		return TOAccrualCalculator</span>
<span class="nc" id="L2755">				.getTOAccruedForGivenDate(empID, activityID, actCatID, startDate, asOfDate, accruedTO, empActivityDataMap);</span>
	}

	/**
	 * Dump the Remaining and Carryover hours into the EmployeeTimeOffAllotment table for Time Off Summary reports. This method
	 * breaks the employee ids into chunks, so that each chunk can be updated in its own transaction. If the chunkSize, lookBack or
	 * lookForward parameters are -1, then their value is gotten from a BPCONFIG setting.
	 *
	 * @param ids - a collection of employee id's to dump the data for.
	 * @param threadID - The thread number. Employees are dumped in multiple threads, and each thread is given a number, starting
	 *            with 1.
	 * @param lookBack - How manay years back to dump. Pass -1 to get the value from the BPCONFIG table.
	 * @param lookForward - How manay years forward to dump. Pass -1 to get the value from the BPCONFIG table.
	 * @param start - Used to determine the lookBack. If not null, this date overrides lookBack.
	 * @param end - Used to determine the lookForward. If not null, this date overrides lookForward.
	 */
	public Collection dumpTOReportDataWithResult(Collection ids, int threadID, int lookBack, int lookForward, Date start, Date end)
			throws BbmUpdateException {
<span class="nc" id="L2773">		methodStart(&quot;dumpTOReportDataWithResult&quot;, ids, new Integer(threadID), new Integer(lookBack), new Integer(lookForward));</span>
<span class="nc" id="L2774">		long starttime = System.currentTimeMillis();</span>
<span class="nc" id="L2775">		ReportDumpStatistic statistic = new ReportDumpStatistic();</span>
<span class="nc" id="L2776">		int chunkSize = -1; // no longer a parameter</span>
<span class="nc" id="L2777">		boolean bShowPrintln = RequestUtil.isRMDebugEnabled();</span>
<span class="nc" id="L2778">		m_cat.info(&quot;TOReportDump threadID=&quot; + threadID + &quot; chunkSize=&quot; + chunkSize + &quot; lookBack=&quot; + lookBack + &quot; lookForward=&quot;</span>
				+ lookForward);
		try {
<span class="nc" id="L2781">			Collection colEmployeeIDs = null;</span>
<span class="nc bnc" id="L2782" title="All 2 branches missed.">			if (ids == null) {</span>
				// dump all employees
<span class="nc" id="L2784">				EmployeeFilter employeeFilter = BbmManagerFactory.getEmployeeFilter(WhatIfMode);</span>
<span class="nc" id="L2785">				colEmployeeIDs = employeeFilter.getEmployeeIDs(Filter.createAllFilter(User.SUPER_USERID), -1, true, 0, Integer.MAX_VALUE);</span>
<span class="nc" id="L2786">			} else {</span>
<span class="nc" id="L2787">				colEmployeeIDs = ids;</span>
			}

			try {
				// get the lookback and lookforward values from db if necessary
<span class="nc" id="L2792">				DBConfigManager m_dbConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc bnc" id="L2793" title="All 2 branches missed.">				if (lookBack &lt; 0) {</span>
<span class="nc" id="L2794">					lookBack = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_LOOKBACK_YEARS);</span>
				}
<span class="nc bnc" id="L2796" title="All 2 branches missed.">				if (lookBack &lt; 0) {</span>
<span class="nc" id="L2797">					lookBack = 1; // default is 1 year</span>
				}

<span class="nc bnc" id="L2800" title="All 2 branches missed.">				if (lookForward &lt; 0) {</span>
<span class="nc" id="L2801">					lookForward = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_LOOKFORWARD_YEARS);</span>
				}
<span class="nc bnc" id="L2803" title="All 2 branches missed.">				if (lookForward &lt; 0) {</span>
<span class="nc" id="L2804">					lookForward = 1; // default is 1 year</span>
				}

				// //start and end dates override lookBack and lookForward
<span class="nc bnc" id="L2808" title="All 4 branches missed.">				if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L2809">					Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L2810">					cal.setTime(new Date());</span>
<span class="nc" id="L2811">					int curYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L2813">					cal.setTime(start);</span>
<span class="nc" id="L2814">					int startYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L2816">					cal.setTime(end);</span>
<span class="nc" id="L2817">					int endYear = cal.get(Calendar.YEAR);</span>

<span class="nc" id="L2819">					lookBack = curYear - startYear;</span>
<span class="nc" id="L2820">					lookForward = endYear - curYear;</span>
				}

				// get the transaction timeout from db
<span class="nc" id="L2824">				int nUserTransactionTimeOut = m_dbConfigManager.getIntValue(ConfigKey.REPORTDUMP_USER_TRANSACTION_TIMEOUT);</span>
<span class="nc bnc" id="L2825" title="All 4 branches missed.">				if (nUserTransactionTimeOut &gt;= 120 &amp;&amp; nUserTransactionTimeOut &lt;= 1200) {</span>
<span class="nc" id="L2826">					USERTRANSACTION_TIMEOUT = nUserTransactionTimeOut;</span>
				}

				// get the max number of retries from db
<span class="nc" id="L2830">				int nReportDumpMaxRetry = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_MAX_RETRY);</span>
<span class="nc bnc" id="L2831" title="All 2 branches missed.">				if (nReportDumpMaxRetry &gt; 0) {</span>
<span class="nc" id="L2832">					REPORTDUMP_MAX_RETRY = nReportDumpMaxRetry;</span>
				}

				// get chunk size from db if necessary
<span class="nc bnc" id="L2836" title="All 2 branches missed.">				if (chunkSize &lt;= 0) {</span>
<span class="nc" id="L2837">					chunkSize = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_TIME_OFF_DUMP_CHUNK_SIZE);</span>
<span class="nc bnc" id="L2838" title="All 2 branches missed.">					if (chunkSize &lt; 0) {</span>
<span class="nc" id="L2839">						chunkSize = 100;</span>
					}
				}

<span class="nc" id="L2843">			} catch (Exception e) {</span>
<span class="nc" id="L2844">				m_cat.error(e);</span>
<span class="nc" id="L2845">			}</span>

<span class="nc" id="L2847">			Collection colEmployeeIDsChunk = new LinkedList();</span>
<span class="nc" id="L2848">			Collection colEmployeeIDsFailed = new LinkedList();</span>
<span class="nc" id="L2849">			int nTotalEmployees = colEmployeeIDs.size();</span>
<span class="nc" id="L2850">			int nNumEmployeesDumped = 0;</span>
<span class="nc" id="L2851">			syncTOAllocation();</span>
			// break the employees up into chunks, and dump each chunk
<span class="nc" id="L2853">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L2854">			HashSet orgIDSet = new HashSet();</span>
<span class="nc" id="L2855">			orgIDSet.add(Organization.ROOT_ORG_ID_OBJ);</span>
<span class="nc" id="L2856">			orgIDSet.addAll(wrm.getOrganizationsChildrenByIDs(Collections.singleton(Organization.ROOT_ORG_ID_OBJ)));</span>
<span class="nc" id="L2857">			HashMap orgActCatMap = null;</span>
<span class="nc" id="L2858">			HashMap orgActivityMap = null;</span>

<span class="nc bnc" id="L2860" title="All 2 branches missed.">			for (Iterator i2 = colEmployeeIDs.iterator(); i2.hasNext();) {</span>
<span class="nc" id="L2861">				ID idEmployee = (ID) i2.next();</span>
<span class="nc" id="L2862">				colEmployeeIDsChunk.add(idEmployee);</span>
<span class="nc bnc" id="L2863" title="All 4 branches missed.">				if (colEmployeeIDsChunk.size() &lt; chunkSize &amp;&amp; i2.hasNext()) {</span>
<span class="nc" id="L2864">					continue;</span>
				}
<span class="nc" id="L2866">				int nMaxRetry = REPORTDUMP_MAX_RETRY;</span>
<span class="nc" id="L2867">				int nRetry = 0;</span>
<span class="nc" id="L2868">				for (; true; nRetry++) {</span>
					try {
<span class="nc bnc" id="L2870" title="All 2 branches missed.">						if (orgActivityMap == null) {</span>
<span class="nc" id="L2871">							orgActivityMap = getOrgActivitiesMap(orgIDSet, false, false);</span>
						}
<span class="nc bnc" id="L2873" title="All 2 branches missed.">						if (orgActCatMap == null) {</span>
<span class="nc" id="L2874">							orgActCatMap = getOrgActivityCategoryMap(orgIDSet);</span>
						}
<span class="nc bnc" id="L2876" title="All 2 branches missed.">						if (isTemporarilyStopReportDump()) {</span>
							// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L2878">							return colEmployeeIDsFailed;</span>
						}
<span class="nc" id="L2880">						dumpTOReportDataForChunk(statistic, colEmployeeIDsChunk, lookBack, lookForward, bShowPrintln, orgActivityMap,</span>
								orgActCatMap);
<span class="nc" id="L2882">					} catch (Exception e) {</span>
<span class="nc" id="L2883">						handleException(e);</span>
<span class="nc bnc" id="L2884" title="All 2 branches missed.">						if (nRetry &lt; nMaxRetry) {</span>
<span class="nc bnc" id="L2885" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2886">								m_cat.debug(&quot;Exception in dumpTOReportDataChunk: retry count = &quot; + new Integer(nRetry));</span>
							}
<span class="nc" id="L2888">							continue;</span>
						}
<span class="nc" id="L2890">						colEmployeeIDsFailed.addAll(colEmployeeIDsChunk);</span>
<span class="nc" id="L2891">						m_cat.info(&quot;TO ReportChunk failed for EmployeeIDs: &quot; + colEmployeeIDsChunk);</span>
<span class="nc" id="L2892">					}</span>
<span class="nc" id="L2893">					break;</span>
				}
<span class="nc bnc" id="L2895" title="All 2 branches missed.">				if (nRetry &lt; nMaxRetry) {</span>
<span class="nc" id="L2896">					nNumEmployeesDumped += colEmployeeIDsChunk.size();</span>
				}

<span class="nc" id="L2899">				m_cat.info(&quot;Stats: TO Chunk Dumped, Size = &quot; + nTotalEmployees + &quot;Dumped: &quot; + nNumEmployeesDumped + &quot; Failed Emps: &quot;</span>
<span class="nc" id="L2900">						+ RmUtil.dumpCommaSeparated(colEmployeeIDsFailed));</span>
<span class="nc" id="L2901">				colEmployeeIDsChunk.clear();</span>
<span class="nc" id="L2902">			}</span>
<span class="nc" id="L2903">			long endtime = System.currentTimeMillis();</span>
<span class="nc" id="L2904">			long lTotalTime = endtime - starttime;</span>
<span class="nc" id="L2905">			m_cat.info(&quot;Stats: TOReportDump Complete; Total time=&quot; + (lTotalTime / 60000) + &quot; Mins: Total=&quot; + nTotalEmployees + &quot;: Dumped=&quot;</span>
<span class="nc" id="L2906">					+ nNumEmployeesDumped + &quot;: Failed=&quot; + colEmployeeIDsFailed.size() + &quot;\n\t\tTimeSpentOnGetRemaining: &quot;</span>
<span class="nc" id="L2907">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetRemaining&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetPendAndSched: &quot;
<span class="nc" id="L2909">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetPendAndSched&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetEmps: &quot;
<span class="nc" id="L2911">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetEmps&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeSpentOnGetActivity: &quot;
<span class="nc" id="L2913">					+ decFormat.format(((double) statistic.get(&quot;m_TimeSpentOnGetActivity&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\ttimeForGetTOYearRange: &quot;
<span class="nc" id="L2915">					+ decFormat.format(((double) statistic.get(&quot;m_timeForGetTOYearRange&quot;) / lTotalTime) * 100.0)</span>
<span class="nc" id="L2916">					+ &quot;\n\t\ttimeForGetSTBal: &quot; + decFormat.format(((double) statistic.get(&quot;m_timeForGetSTBal&quot;) / lTotalTime) * 100.0)</span>
					+ &quot;\n\t\ttimeForYrlyAllotMap: &quot;
<span class="nc" id="L2918">					+ decFormat.format(((double) statistic.get(&quot;m_timeForYrlyAllotMap&quot;) / lTotalTime) * 100.0) + &quot;\n\t\ttimeForHrsPerDay: &quot;</span>
<span class="nc" id="L2919">					+ decFormat.format(((double) statistic.get(&quot;m_timeForHrsPerDay&quot;) / lTotalTime) * 100.0) + &quot;\n\t\ttimeForExecuteBatch: &quot;</span>
<span class="nc" id="L2920">					+ decFormat.format(((double) statistic.get(&quot;m_timeForExecuteBatch&quot;) / lTotalTime) * 100.0));</span>
<span class="nc" id="L2921">			AuditTrailEntry entry = new AuditTrailEntry(</span>
					AuditTrailEntry.MODULE_ADAPTER,
					AuditTrailEntry.ACTION_TO_DUMP,
					new ID(0),
					&quot;Time Off Dump&quot;,
					new Date(starttime), new Date(endtime));
<span class="nc" id="L2927">			Calendar cal = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L2928">			cal.setTime(new Date());</span>
<span class="nc" id="L2929">			int curYear = cal.get(Calendar.YEAR);</span>
<span class="nc" id="L2930">			entry.addProperty(&quot;Duration&quot;, &quot;&quot; + (endtime - starttime) / 60000, &quot;minutes&quot;, false);</span>
<span class="nc" id="L2931">			entry.addProperty(&quot;Time Range&quot;, &quot;&quot; + (curYear - lookBack) + &quot; to &quot; + (curYear + lookForward), &quot;string&quot;, false);</span>
<span class="nc" id="L2932">			entry.addProperty(&quot;Number of Employees&quot;, &quot;&quot; + nTotalEmployees, &quot;int&quot;, false);</span>
			try {
<span class="nc" id="L2934">				BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(entry);</span>
<span class="nc" id="L2935">			} catch (Exception e) {</span>
<span class="nc" id="L2936">				m_cat.warn(&quot;Exception occurred during Time Off Dump audit.&quot;);</span>
<span class="nc" id="L2937">			}</span>
<span class="nc" id="L2938">			return colEmployeeIDsFailed;</span>
<span class="nc" id="L2939">		} catch (Exception e) {</span>
<span class="nc" id="L2940">			e.printStackTrace();</span>
<span class="nc" id="L2941">			handleException(e, false);</span>
<span class="nc" id="L2942">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L2944">			methodFinish();</span>
		}
	}

<span class="nc" id="L2948">	private static DecimalFormat decFormat = new DecimalFormat(&quot;#.#&quot;);</span>

	/**
	 * Insert missing rows in EMPLOYEETIMEOFFALLOTMENT table.
	 */
	private void syncTOAllocation() throws BbmFinderException {
<span class="nc" id="L2954">		Jdmo jdmo = null;</span>
		try {
<span class="nc" id="L2956">			jdmo = new Jdmo();</span>
<span class="nc" id="L2957">			jdmo.executeCommand(&quot;ins_miss_empallotment&quot;);</span>
<span class="nc" id="L2958">		} catch (Exception e) {</span>
<span class="nc" id="L2959">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2961" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L2962">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L2965">	}</span>

	private boolean isTemporarilyStopReportDump() {
		try {
<span class="nc" id="L2969">			return BbmManagerFactory.getDBConfigManager().isTemporarilyStopReportDump();</span>
			// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L2971">		} catch (Exception e) {</span>
<span class="nc" id="L2972">			m_cat.error(e, e);// To change body of catch statement use File | Settings | File Templates.</span>
<span class="nc" id="L2973">			return false;</span>
		}
	}

	/**
	 * Dump the Remaining and Carryover hours into the EmployeeTimeOffAllotment table for Time Off Summary reports for a single
	 * employee.
	 *
	 * @param empIDs - Collection of employees whose time off data needs updating.
	 * @param lookBack - How manay years back to dump.
	 * @param lookForward - How manay years forward to dump.
	 * @param bShowPrintln - true if we were launched from the DumpReportDataServlet. False otherwise.
	 */
	public void dumpTOReportDataForChunk(ReportDumpStatistic statistic, Collection empIDs, int lookBack, int lookForward,
			boolean bShowPrintln, HashMap orgActivityMap, HashMap orgActCatMap) throws BbmUpdateException {
<span class="nc" id="L2988">		methodStart(&quot;dumpTOReportDataForEmployee&quot;, empIDs, new Integer(lookBack), new Integer(lookForward));</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">		if (isTemporarilyStopReportDump()) {</span>
			// stop report dump as is if this flag is set; user wants to suspend and start again.
<span class="nc" id="L2991">			return;</span>
		}
<span class="nc bnc" id="L2993" title="All 2 branches missed.">		if (bShowPrintln) {</span>
<span class="nc" id="L2994">			m_cat.info(&quot;dumpTOReportDataForEmployee empID=&quot; + RmUtil.dumpCommaSeparated(empIDs) + &quot; lookBack=&quot; + lookBack + &quot; lookForward=&quot;</span>
					+ lookForward);
		}
<span class="nc" id="L2997">		Jdmo jdmo = null;</span>
<span class="nc" id="L2998">		long starttime = System.currentTimeMillis();</span>
<span class="nc" id="L2999">		long timeForFetch = 0;</span>
<span class="nc" id="L3000">		long timeForCompare = 0;</span>
<span class="nc" id="L3001">		long timeForExecuteBatch = 0;</span>
<span class="nc" id="L3002">		EmployeeTimeOffYearlyDAO dao = null;</span>
<span class="nc" id="L3003">		int updateCounter = 0;</span>
<span class="nc" id="L3004">		ArrayList empTOYrlyList = new ArrayList();</span>
		try {
<span class="nc" id="L3006">			dao = new EmployeeTimeOffYearlyDAO();</span>
<span class="nc" id="L3007">			jdmo = dao.getDMO();</span>
			// Get the years to be dumped for this employee
<span class="nc" id="L3009">			Calendar nowCal = Calendar.getInstance();</span>
<span class="nc" id="L3010">			int curYear = nowCal.get(Calendar.YEAR);</span>
<span class="nc" id="L3011">			int startYear = curYear - lookBack;</span>
<span class="nc" id="L3012">			int endYear = curYear + lookForward;</span>
<span class="nc bnc" id="L3013" title="All 2 branches missed.">			for (int yeartoDump = startYear; yeartoDump &lt;= endYear; yeartoDump++) {</span>
<span class="nc" id="L3014">				int count = 0;</span>
<span class="nc" id="L3015">				long timeBeforeFetch = System.currentTimeMillis();</span>
<span class="nc" id="L3016">				HashMap dataForAllEmps = getEmployeeData(statistic, empIDs, null, yeartoDump, null, false, false, orgActivityMap,</span>
						orgActCatMap);
<span class="nc" id="L3018">				timeForFetch += (System.currentTimeMillis() - timeBeforeFetch);</span>
<span class="nc" id="L3019">				long timeBeforeCompare = System.currentTimeMillis();</span>
<span class="nc" id="L3020">				String lookupKeyForActivityComb = null;</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">				for (Iterator iterator = dataForAllEmps.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L3022">					ID empId = (ID) iterator.next();</span>
<span class="nc" id="L3023">					HashMap empData = (HashMap) dataForAllEmps.get(empId);</span>
<span class="nc" id="L3024">					HashMap yearlyAllotmentMap = (HashMap) empData.get(&quot;yearlyAllotmentMap&quot;);</span>
<span class="nc" id="L3025">					count++;</span>

<span class="nc" id="L3027">					TimeOffActivitySummary[] toActSummaries = getTOActivitySummaryData(statistic, empId, empData, true);</span>

<span class="nc bnc" id="L3029" title="All 4 branches missed.">					for (int i = 0; (toActSummaries != null) &amp;&amp; i &lt; toActSummaries.length; i++) {</span>
<span class="nc" id="L3030">						TimeOffActivitySummary sumry = toActSummaries[i];</span>

<span class="nc bnc" id="L3032" title="All 4 branches missed.">						if (sumry.getActivityID() != null &amp;&amp; sumry.getActivityCategory() != null) {</span>
<span class="nc" id="L3033">							lookupKeyForActivityComb = Activity.getActivity_ActCategoryComb(sumry.getActivityID(), null);</span>
						} else {
<span class="nc" id="L3035">							lookupKeyForActivityComb = sumry.getActivity_ActCategoryComb();</span>
						}

<span class="nc" id="L3038">						HashMap yrlMap = (HashMap) yearlyAllotmentMap.get(lookupKeyForActivityComb);</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">						EmployeeTimeOffYearly yrly = (yrlMap != null ? (EmployeeTimeOffYearly) yrlMap.get(&quot;&quot; + yeartoDump) : null);</span>
						// Finally, update the etoa row in the database with the new remaining, carryover values
						// If it has changed from last update
<span class="nc bnc" id="L3042" title="All 4 branches missed.">						if (yrly != null &amp;&amp; !sumry.compareWithTimeOffYearly(yrly)) {</span>
<span class="nc" id="L3043">							updateCounter++;</span>
<span class="nc" id="L3044">							String strQuery = &quot;UPDATE EMPLOYEETIMEOFFALLOTMENT SET remaining=&quot; + sumry.getRemaining() + &quot;, carryover=&quot;</span>
<span class="nc" id="L3045">									+ sumry.getCarryOver() + &quot;,USED=&quot; + sumry.getUsed() + &quot;,SCHEDULED=&quot; + sumry.getScheduled()</span>
<span class="nc" id="L3046">									+ &quot;, PENDING=&quot; + sumry.getPending() + &quot; WHERE ID=&quot; + yrly.getID();</span>
<span class="nc bnc" id="L3047" title="All 2 branches missed.">							if (bShowPrintln) {</span>
<span class="nc" id="L3048">								m_cat.info(&quot;strQuery for batch=&quot; + strQuery + &quot;\t YRLY=&quot; + yrly);</span>
							}
<span class="nc" id="L3050">							jdmo.addBatch(strQuery);</span>
<span class="nc bnc" id="L3051" title="All 4 branches missed.">						} else if (yrly == null</span>
								&amp;&amp; sumry != null) {
<span class="nc" id="L3053">							m_cat.info(&quot;EmployeeTimeOffYearly Not found; EMPID=&quot; + empId + &quot;:ACT=&quot; + sumry.getActivity_ActCategoryComb()</span>
									+ &quot; :year=&quot; + yeartoDump + &quot;: summary=&quot; + sumry);
<span class="nc" id="L3055">							yrly = new EmployeeTimeOffYearly();</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">							if (sumry.getActivityID() == null) {</span>
<span class="nc" id="L3057">								yrly.setActivityCategoryID(sumry.getActivityCategory().getID());</span>
							} else {
<span class="nc" id="L3059">								yrly.setActivityID(sumry.getActivityID());</span>
							}
<span class="nc" id="L3061">							yrly.setCalendarYear(yeartoDump);</span>
<span class="nc" id="L3062">							yrly.setEmployeeID(empId);</span>
<span class="nc" id="L3063">							yrly.setPending(sumry.getPending());</span>
<span class="nc" id="L3064">							yrly.setUsed(sumry.getUsed());</span>
<span class="nc" id="L3065">							yrly.setScheduled(sumry.getScheduled());</span>
<span class="nc" id="L3066">							yrly.setRemaining(sumry.getRemaining());</span>
<span class="nc" id="L3067">							yrly.setCarryover(sumry.getCarryOver());</span>
<span class="nc" id="L3068">							empTOYrlyList.add(yrly);</span>
						}
					}
<span class="nc" id="L3071">				}</span>
<span class="nc" id="L3072">				timeForCompare += (System.currentTimeMillis() - timeBeforeCompare);</span>
			}
<span class="nc" id="L3074">			long timeBeforeExecuteBatch = System.currentTimeMillis();</span>
<span class="nc" id="L3075">			jdmo.executeBatch();</span>
<span class="nc bnc" id="L3076" title="All 4 branches missed.">			if (empTOYrlyList != null &amp;&amp; !empTOYrlyList.isEmpty()) {</span>
<span class="nc" id="L3077">				dao.createObjects(empTOYrlyList);</span>
			}
<span class="nc" id="L3079">			timeForExecuteBatch = (System.currentTimeMillis() - timeBeforeExecuteBatch);</span>
<span class="nc" id="L3080">			statistic.add(&quot;m_timeForExecuteBatch&quot;, timeForExecuteBatch);</span>
<span class="nc" id="L3081">		} catch (Exception e) {</span>
<span class="nc" id="L3082">			e.printStackTrace();</span>
<span class="nc" id="L3083">			handleException(e);</span>
<span class="nc" id="L3084">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3086">			methodFinish();</span>
<span class="nc bnc" id="L3087" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L3088">				dao.cleanUp();</span>
			}
<span class="nc bnc" id="L3090" title="All 4 branches missed.">			m_cat.info(&quot;dumpTOReportDataForChunk EMPSIZE =&quot; + (empIDs != null ? empIDs.size() : 0) + &quot;,updates=&quot; + updateCounter + &quot;,ins=&quot;</span>
<span class="nc" id="L3091">					+ empTOYrlyList.size() + &quot;,TOTALTime=&quot; + ((System.currentTimeMillis() - starttime) / 1000) + &quot;,&quot; + timeForFetch + &quot;,&quot;</span>
					+ timeForCompare + &quot;,&quot; + timeForExecuteBatch);
<span class="nc" id="L3093">		}</span>
<span class="nc" id="L3094">	}</span>

	public void notifyOnChangeInEmpTOAccrued(Collection colEmpTOAccrued) {
		try {
<span class="nc" id="L3098">			JMSNotifyUtil.notifyOnUserAction(new EmpTOAccruedNotificationDetail(colEmpTOAccrued));</span>
<span class="nc" id="L3099">		} catch (Exception e) {</span>
<span class="nc" id="L3100">			handleException(e);</span>
<span class="nc" id="L3101">		}</span>
<span class="nc" id="L3102">	}</span>

	/**
	 * Count number of request type, and status per employeeID within a time range of time off request dates
	 *
	 * @param countParam
	 * @return
	 * @throws RmException
	 */
	public Map&lt;ID, Integer&gt; getNumberOfRequestPerPeriod(RequestCountParam countParam) throws RmException {
<span class="nc" id="L3112">		methodStart(&quot;countNumberOfRequest&quot;, countParam);</span>
<span class="nc" id="L3113">		RequestDAO requestDAO = null;</span>

		try {
<span class="nc" id="L3116">			requestDAO = new RequestDAO(countParam.getRequestType(), TORequest.DL_BASIC);</span>
<span class="nc" id="L3117">			return requestDAO.getNumberOfRequestPerPeriod(countParam);</span>
<span class="nc" id="L3118">		} catch (Exception e) {</span>
<span class="nc" id="L3119">			handleException(e);</span>
<span class="nc" id="L3120">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3122" title="All 4 branches missed.">			if (requestDAO != null) {</span>
<span class="nc" id="L3123">				requestDAO.cleanUp();</span>
			}
		}
	}

	private boolean hasAdvanceLicense() {
<span class="nc" id="L3129">		return LicenseUtil.isAdvancedRMLicense();</span>
	}

	/**It serves for new Group Action: Approve Time Off Choice without violations
	 * @param reqAgg
	 * @param apprChoiceID will be replaced by valid ChoiceId based on user rank.Choice is valid if it does not have any validations 
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected void _approveRequestChoice(RequestAggregate reqAgg, ID apprChoiceID, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L3143">		String methodName = &quot;_approveRequestChoice&quot;; // passed to other methods</span>
<span class="nc" id="L3144">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment, new Boolean(suppressPrivilegeChecking)));</span>
<span class="nc" id="L3145">		TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L3146">		ID apprValidChoiceID = TORequestUtil.getValidChoiceIdCanBeApproved(toReq);</span>
<span class="nc bnc" id="L3147" title="All 2 branches missed.">		if (apprValidChoiceID != null) { //Only approve if the TO request has choice does not have violations.</span>
<span class="nc" id="L3148">			approveTORequest(reqAgg, apprValidChoiceID, comment, suppressPrivilegeChecking, loadedFromDB, hasAdvanceLicense());</span>
		}
<span class="nc" id="L3150">		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>

<span class="nc" id="L3152">	}</span>

	@Override
	public void changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
			throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L3157">		_changeRequestStateByID(reqID, newState, objectVersionNumber, comment, hasAdvanceLicense());</span>
<span class="nc" id="L3158">	}</span>

	@Override
	protected void markRequestViolateSpecialRulesAsInValidIfNeeded(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc bnc" id="L3162" title="All 2 branches missed.">		if (LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L3163">			TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L3164">			List&lt;TOChoice&gt; choiceList = toReq.getRequestChoiceList();</span>
<span class="nc" id="L3165">			int numOfChoices = choiceList.size();</span>
<span class="nc" id="L3166">			int numOfViolations = 0;</span>
<span class="nc" id="L3167">			boolean checkHasSomeSpecificHardRulesViolated = false;</span>
<span class="nc" id="L3168">			ValidationResult hardValResult = null;</span>
<span class="nc bnc" id="L3169" title="All 2 branches missed.">			for (Iterator&lt;TOChoice&gt; iter = choiceList.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3170">				TOChoice choice = iter.next();</span>
<span class="nc" id="L3171">				Collection&lt;ValidationResult&gt; listValidator = choice.getValidationResults(true);</span>
<span class="nc bnc" id="L3172" title="All 2 branches missed.">				if (!listValidator.isEmpty()) {</span>
<span class="nc" id="L3173">					numOfViolations++;</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">					for (Iterator&lt;ValidationResult&gt; vIter = listValidator.iterator(); vIter.hasNext();) {</span>
<span class="nc" id="L3175">						ValidationResult vResult = vIter.next();</span>
<span class="nc" id="L3176">						checkHasSomeSpecificHardRulesViolated = TORequestUtil.checkHasSomeSpecificHardRulesViolated(vResult);</span>
<span class="nc bnc" id="L3177" title="All 2 branches missed.">						if (checkHasSomeSpecificHardRulesViolated) {</span>
<span class="nc" id="L3178">							hardValResult = vResult;</span>
<span class="nc" id="L3179">							break;</span>
						}
<span class="nc" id="L3181">					}</span>
				}
<span class="nc" id="L3183">			}</span>
			//If there is 1 special soft rule violated and all choices violated on all soft validation rules, the request will be mark as invalid
			//since actullay, the special soft rule here is really hard validation rule
<span class="nc bnc" id="L3186" title="All 4 branches missed.">			if (numOfViolations == numOfChoices &amp;&amp; hardValResult != null) {</span>
<span class="nc" id="L3187">				super.markRequestAsInvalid(reqAgg, hardValResult, reqAggDAO);</span>
			}
		}
<span class="nc" id="L3190">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>