<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOCalendarUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">TOCalendarUtil.java</span></div><h1>TOCalendarUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.util;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntryFieldInfo;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailProperty;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.CalendarTimeOffDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.verint.ejb.wfm.WfmManagerFactory;

/*
 * The methods are not made static to enable caching of TO Calculator created, if needed
 */

public class TOCalendarUtil {
<span class="nc" id="L59">	private static Category m_cat = Log.initCategory(TOCalendarUtil.class.getName());</span>
	//These constants are used for storing different buckets in an Array.
	public static final int BKT_PENDING = 0;
	public static final int BKT_SCHED = 1;
	//TODO: change this name to something that can be understood
	public static final int BKT_SCHED_TOPOOL = 2;
	public static final int MILLIS_IN_MINUTE = 60000;

<span class="nc" id="L67">	private TOCalendarUtil() {</span>

<span class="nc" id="L69">	}</span>

	/**
	 * Called by the validation rules to find the scheduled data.
	 * For each day in the given time range and for the passed collection of time off events,
	 * the following information is returned:
	 * &lt;li&gt; the total scheduled TO hours
	 *
	 * @param org   organization for which scheduled hours per day is to be computed
	 * @param range
	 * @throws Exception
	 */
	public static DailyHoursBuckets getTOScheduledData(ID pTOPoolID, Organization org, Collection childOrgs, Collection empIDs, TimeRange range, Collection allotmentList, boolean inclTOHrsPerDayDetails) throws Exception {
<span class="nc" id="L82">		TimeZone orgTimeZone = org.getTimeZone();</span>
		// orgScheduledBuckets: scheduled TO hours/day for all employees in the organization.
<span class="nc" id="L84">		DailyHoursBuckets toPoolSchedBkts = new DailyHoursBuckets(org.getDayBoundaryOffset(), orgTimeZone, range, inclTOHrsPerDayDetails);</span>
<span class="nc" id="L85">		Collection hrsPerDayCol = getHoursPerDayForRange(empIDs, range, allotmentList, true);</span>
		// fill the orgScheduled and interestSetScheduled buckets.
<span class="nc" id="L87">		TimeRange minMaxRange = getMinMaxRange(new Collection[]{hrsPerDayCol});</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">		if (minMaxRange == null) {</span>
<span class="nc" id="L89">			minMaxRange = range;</span>
		}
<span class="nc" id="L91">		Date stDate = TOCalendarUtil.getBackAyearforDate(minMaxRange.getStartDate());</span>
<span class="nc" id="L92">		Date enDate = minMaxRange.getEndDate();</span>
<span class="nc" id="L93">		HashMap wras = RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(empIDs,</span>
		        new LocalDate(stDate, orgTimeZone),
		        new LocalDate(enDate, orgTimeZone), false);
<span class="nc" id="L96">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L97">		HashMap empTOPoolAssnMap = toCalFacade.getTOPoolsForWorkResources(empIDs, stDate, enDate);</span>
		//pass intSetEmpIDs only when TOPoolID is null; i.e. in org mode only
<span class="nc bnc" id="L99" title="All 2 branches missed.">		Collection intSetEmpIDs = pTOPoolID != null ? null : empIDs;</span>
<span class="nc" id="L100">		fillSchedDailyHoursBuckets(false,pTOPoolID, hrsPerDayCol, intSetEmpIDs, null, toPoolSchedBkts, childOrgs, wras, empTOPoolAssnMap);</span>
<span class="nc" id="L101">		return toPoolSchedBkts;</span>
	}

	public static DailyHoursBuckets getTOScheduledData(ID pTOPoolID, Organization org, TimeRange range, Collection allotList) throws Exception {
<span class="nc" id="L105">		Date empStartDate = getBackAyearforDate(range.getStartDate()); // emp may have belonged to other time off pool/org in past, so look back a year.</span>
<span class="nc" id="L106">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L107">		Collection pTOPoolEmpIDs = toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, range.getEndDate());</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">		if (allotList == null) {</span>
<span class="nc" id="L109">			allotList = getListOfAllAllotmentActivities();</span>
		}
<span class="nc" id="L111">		return getTOScheduledData(pTOPoolID, org, Collections.emptyList(), pTOPoolEmpIDs, range, allotList, false);</span>
	}

	public static DailyHoursBuckets getTOAllocatedData(ID poolID, Organization org, TimeRange toRange) throws Exception {
<span class="nc" id="L115">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L116">		TimeZone tz = org.getTimeZone();</span>

<span class="nc" id="L118">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(orgDayOffset, tz, toRange);</span>
<span class="nc" id="L119">		Collection&lt;CalendarTimeOffDay&gt; toDailyAllocs = new ArrayList&lt;CalendarTimeOffDay&gt;();</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">		if (poolID != null) {</span>
<span class="nc" id="L121">			toDailyAllocs.addAll(getTOAllocationCalendar(poolID, org.getID(), tz, toRange));</span>
<span class="nc" id="L122">			fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, toDailyAllocs);</span>
		}
<span class="nc" id="L124">		return toAllocHrsBkts;</span>
	}

	public static String getTOAllocationCalendarForTimeOffDays(ID poolID, Organization org, CalendarTimeOffDay[] toDailyAllocs, TimeRange toRange) throws Exception {
<span class="nc" id="L128">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(org.getDayBoundaryOffset(), org.getTimeZone(), toRange);</span>
		// make toAllocHrsBkts from the toDailyAllocs
<span class="nc" id="L130">		fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, Arrays.asList(toDailyAllocs));</span>

<span class="nc" id="L132">		StringBuilder toAllocCalendar = new StringBuilder();</span>
<span class="nc" id="L133">		toAllocCalendar.append(&quot;Alloc=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(toAllocHrsBkts));</span>
<span class="nc" id="L134">		return toAllocCalendar.toString();</span>
	}

	public static String getTOCalendar(DailyHoursBuckets allocHrs, DailyHoursBuckets beforeScheduledHrs, DailyHoursBuckets afterScheduledHrs) {
<span class="nc" id="L138">		StringBuilder toCalendar = new StringBuilder();</span>
<span class="nc" id="L139">		toCalendar.append(&quot;Alloc=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(allocHrs));</span>
<span class="nc" id="L140">		toCalendar.append(&quot;\tSched(Before)=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(beforeScheduledHrs));</span>
<span class="nc" id="L141">		toCalendar.append(&quot;\tSched(After)=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(afterScheduledHrs));</span>
<span class="nc" id="L142">		return toCalendar.toString();</span>
	}


	@SuppressWarnings(&quot;unchecked&quot;)
	public static Map&lt;Integer, List&lt;AuditTrailEntry&gt;&gt; getTOCalendarFromAudits(ID poolID, ID empID, Date auditStart, Date auditEnd, Date fromDay) {
<span class="nc" id="L148">		EventAuditTrailManager auditTrailManager = null;</span>
<span class="nc" id="L149">		Collection&lt;AuditTrailEntry&gt; auditEntries = new ArrayList&lt;AuditTrailEntry&gt;();</span>
<span class="nc" id="L150">		Collection&lt;ID&gt; workResourceIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L151">		Map&lt;ID, Collection&lt;AuditTrailEntry&gt;&gt; auditEntriesMap = new HashMap&lt;ID, Collection&lt;AuditTrailEntry&gt;&gt;();</span>

		try {
<span class="nc bnc" id="L154" title="All 2 branches missed.">			if (poolID != null) {</span>
<span class="nc" id="L155">				workResourceIDs.add(poolID);</span>
<span class="nc" id="L156">				Collection&lt;ID&gt; empsInPool = RmManagerFactory.getInstance().getTimeOffDayFacade().getEmployeeIDsForTOPool(poolID, auditStart, auditEnd);</span>
<span class="nc" id="L157">				workResourceIDs.addAll(empsInPool);</span>
			}
<span class="nc bnc" id="L159" title="All 2 branches missed.">			if (empID != null) {</span>
<span class="nc" id="L160">				workResourceIDs.add(empID);</span>
			}
<span class="nc" id="L162">			auditTrailManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L163">			auditEntriesMap = auditTrailManager.getAuditTrail(workResourceIDs, AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT, 0, auditStart, auditEnd, fromDay);</span>
<span class="nc" id="L164">		} catch (Exception e) {}</span>

		// put all audit entries in a list
<span class="nc bnc" id="L167" title="All 2 branches missed.">		for (ID auditEntryKey : auditEntriesMap.keySet()) {</span>
<span class="nc" id="L168">			Collection&lt;AuditTrailEntry&gt; entries = auditEntriesMap.get(auditEntryKey);</span>
<span class="nc" id="L169">			auditEntries.addAll(entries);</span>
<span class="nc" id="L170">		}</span>

		// get a list of audit entries grouped by their action type
<span class="nc" id="L173">		Map&lt;Integer, List&lt;AuditTrailEntry&gt;&gt; ateMap = new HashMap&lt;Integer, List&lt;AuditTrailEntry&gt;&gt;();</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">		for (AuditTrailEntry ate : auditEntries) {</span>
<span class="nc" id="L175">			Integer ateActType = new Integer(ate.getActionType());</span>

<span class="nc" id="L177">			Collection&lt;AuditTrailProperty&gt; atps = ate.getChildObjects(AuditTrailEntryFieldInfo.CHILD_PROPERTIES);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">			for (AuditTrailProperty atp : atps) {</span>
<span class="nc" id="L179">				ate.addProperty(atp.getName(), atp.getVaue(), atp.getType(), atp.isBeforeValue());</span>
<span class="nc" id="L180">			}</span>

<span class="nc" id="L182">			List&lt;AuditTrailEntry&gt; ateList = ateMap.get(ateActType);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">			if (ateList == null) {</span>
<span class="nc" id="L184">				ateList = new ArrayList&lt;AuditTrailEntry&gt;();</span>
			}
<span class="nc" id="L186">			ateList.add(ate);</span>
<span class="nc" id="L187">			ateMap.put(ateActType, ateList);</span>
<span class="nc" id="L188">		}</span>
<span class="nc" id="L189">		return ateMap;</span>
	}

	private static void fillTOAllocationCalendarForTOPool(DailyHoursBuckets allocBkts, Organization org, Collection toDailyAllocs) throws Exception {
		// use a buckets object for the available hours
<span class="nc" id="L194">		TimeZone orgTimeZone = org.getTimeZone();</span>

		// start date for the availBuckets date range expanded to the orgDayStart
<span class="nc" id="L197">		Date allocBktsStDate = allocBkts.getDHBRangeStartAsOrgDayStart();</span>

		// end date for the availBuckets date range expanded to the orgDayEnd
<span class="nc" id="L200">		Date allocBktsEnDate = allocBkts.getDHBRangeEndAsOrgDayEnd();</span>
		// Access TOAllocation calendar and find allocated hours per day, initialize available bucket array with these numbers

<span class="nc" id="L203">		Calendar cal = Calendar.getInstance(orgTimeZone);</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">		for (Iterator itt = toDailyAllocs.iterator(); itt.hasNext();) {</span>

<span class="nc" id="L206">			CalendarTimeOffDay toDayAlloc = (CalendarTimeOffDay) itt.next();</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">			if (toDayAlloc == null) {</span>
<span class="nc" id="L208">				continue;</span>
			}
<span class="nc" id="L210">			LocalDate toDayAllocLocalDate = toDayAlloc.getTimeOffLocalDate();</span>
			// convert local date to java.util.Date in the bucket's timezone.
<span class="nc" id="L212">			Date toDayAllocDate = toDayAllocLocalDate.getTime(allocBkts.getTimeZone());</span>
<span class="nc" id="L213">			int dayBoundaryOffset = org.getDayBoundaryOffset();</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">			if (dayBoundaryOffset &gt; 0) {</span>
<span class="nc" id="L215">				cal.setTime(toDayAllocDate);</span>
				// QC 41795 / QA 95083 DST issue: standardize setting of dayBoundaryOffset
<span class="nc" id="L217">				TOCalcUtil.setCalMinsOffsetFromMidnight(cal, dayBoundaryOffset);</span>
<span class="nc" id="L218">				toDayAllocDate = cal.getTime();</span>
			}
			// if the TOAllocations date is outside the buckets range, skip this TODayAllocation.
<span class="nc bnc" id="L221" title="All 4 branches missed.">			if (toDayAllocDate.before(allocBktsStDate) || toDayAllocDate.after(allocBktsEnDate)) {</span>
<span class="nc" id="L222">				continue;</span>
			}
<span class="nc" id="L224">			allocBkts.addToBucket(toDayAllocDate, (float) toDayAlloc.getAllocatedHours());</span>
<span class="nc" id="L225">		}</span>
<span class="nc" id="L226">	}</span>


	/**
	 * Called on behalf of the manager or the agent, from the UI, to retrieve necessary data to render
	 * the TOCalendar for the manager. For each day in the given time range and for the passed interestSet
	 * of 'employees', the following information is returned:
	 * &lt;li&gt; the total scheduled TO hours
	 * &lt;li&gt; the total pending TO hours
	 * &lt;li&gt; the available (allocated) TO hours
	 * &lt;li&gt; dayType: see below.
	 * &lt;p/&gt;
	 * &lt;p/&gt;
	 * Day types in order of decreasing precedence:
	 * &lt;li&gt; Scheduled TO days (only for agent calendar).
	 * &lt;li&gt; Pending TO days (only for agent calendar).
	 * &lt;li&gt; blackout days.
	 * &lt;li&gt; paid holidays (non working holidays)
	 * &lt;li&gt; days of non operation
	 * &lt;li&gt; unpaid holidays (working holidays)
	 * &lt;li&gt; TO_HOURS_NOTAVAILABLE_DAY_TYPE / TO_HOURS_AVAILABLE_DAY_TYPE
	 * &lt;p/&gt;
	 *
	 * @param intSetEmpIDs Collection of employee IDs to display pending / sched hours only
	 * @param empIDs       collection of employee ids to display color /availability of hours
	 * @param org          org selected in left pane / or Org of the employee
	 * @return
	 * @throws Exception
	 */
	private static TOCalendarDayData[] getTOCalendar(boolean isIndvlEmp, Collection intSetEmpIDs, Collection empIDs, ID pTOPoolID, Organization org, TimeRange toCalRange) throws Exception {
<span class="nc" id="L256">		long startTime = Calendar.getInstance().getTime().getTime();</span>
<span class="nc" id="L257">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L258">		TimeZone orgTimeZone = org.getTimeZone();</span>

<span class="nc" id="L260">		DailyHoursBuckets[] pendAndSchedBktArray = fillPendingAndSchedBkts(isIndvlEmp, intSetEmpIDs, empIDs, pTOPoolID, org, toCalRange);</span>

<span class="nc" id="L262">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange);</span>
<span class="nc" id="L263">		ArrayList toDailyAllocs = new ArrayList();</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
<span class="nc" id="L265">			toDailyAllocs.addAll(getTOAllocationCalendar(pTOPoolID, org.getID(), orgTimeZone, toCalRange));</span>
<span class="nc" id="L266">			fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, toDailyAllocs);</span>
		}
		// Now, build the result array fill in its data based on the contents of the different buckets.
<span class="nc" id="L269">		TOCalendarDayData[] pTOCalDayDataArray = new TOCalendarDayData[toAllocHrsBkts.getSize()];</span>
<span class="nc" id="L270">		fillCalDayDataAndMarkDayAvailability(org, pTOPoolID, toAllocHrsBkts, pendAndSchedBktArray, pTOCalDayDataArray);</span>

		// Get the holiday data during the range
<span class="nc" id="L273">		Collection holidayCol = RequestUtil.getHolidaysDuringPeriod(org, toCalRange);</span>

		// Mark all the &quot;unpaid&quot; holidays, i.e working holidays. We'll mark the Paid holidays after handing the
		// non-operation days since Paid holidays have precedence over days of non-operation
<span class="nc" id="L277">		markHolidays(holidayCol, org, toAllocHrsBkts, pTOCalDayDataArray, true);</span>

		// Now, mark the days of non-operation
<span class="nc" id="L280">		Collection hoos = RequestUtil.getHooAssignmentsDuringPeriod(org, toCalRange);</span>

		// Loop through all the OrganizationHOO objects returned and apply any
		// non-operation days to the result array
<span class="nc" id="L284">		markNonOperationalDays(hoos, toCalRange, orgTimeZone, toAllocHrsBkts, pTOCalDayDataArray, orgDayOffset);</span>

		// Now, go through the holidays again and mark the paid holidays,  i.e. ones that are non-working
<span class="nc" id="L287">		markHolidays(holidayCol, org, toAllocHrsBkts, pTOCalDayDataArray, false);</span>
<span class="nc bnc" id="L288" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
			// Finally, loop through the Calendar Timeoff Days read above and mark the blackout days. These have the highest precedence
<span class="nc" id="L290">			markBlackOutDays(toDailyAllocs, toAllocHrsBkts, pTOCalDayDataArray, org);</span>
		}
<span class="nc" id="L292">		markOrgBlackOutDays(holidayCol, toAllocHrsBkts, pTOCalDayDataArray, org);</span>
		// Pending and scheduled days only apply for agent's TO Calendar.
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (isIndvlEmp) {</span>
			// Note: Scheduled_DAY_TYPE has higher precedence than PENDING_DAY_TYPE
<span class="nc" id="L296">			markPendingOrScheduledDays(pTOCalDayDataArray, pendAndSchedBktArray);</span>
		}
<span class="nc" id="L298">		m_cat.debug(&quot;Time taken for loading calendar is &quot; + (startTime - Calendar.getInstance().getTime().getTime()));</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for(int i=0 ;i&lt;pTOCalDayDataArray.length;i++){</span>
<span class="nc" id="L300">			pTOCalDayDataArray[i].setM_org(org);</span>
		}
<span class="nc" id="L302">		return pTOCalDayDataArray;</span>
	}

	private static DailyHoursBuckets[] fillPendingAndSchedBkts(boolean isIndvlEmp, Collection intSetEmpIDs, Collection orgEmpIDs, ID pTOPoolID, Organization org, TimeRange toCalRange) throws Exception {
<span class="nc" id="L306">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L307">		TimeZone orgTimeZone = org.getTimeZone();</span>
		//This is for showing Scheduled Hours on Calendar. can be used in org mode or for specific TOPool
<span class="nc" id="L309">		DailyHoursBuckets intSetSchedHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange, isIndvlEmp);</span>
		//This is for showing Pending Hours on Calendar. can be used in org mode or for specific TOPool
<span class="nc" id="L311">		DailyHoursBuckets intSetPendHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange, isIndvlEmp);</span>


		// orgSchedBuckets: scheduled TO hours/day for all employees in the organization.
		// Note: orgSchedBuckets is not returned to the caller. Only used to determine the colors.
		// i.e. if a given day has exceeded/not exceeded the allocated TO hours.
		//This is for finding actual scheduled hours for the TOPool. is not applicable for Org Mode
<span class="nc" id="L318">		DailyHoursBuckets toPoolSchedHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange);</span>
<span class="nc" id="L319">		HashSet allEmpIds = new HashSet((orgEmpIDs.size() + intSetEmpIDs.size()) * 2);</span>
<span class="nc" id="L320">		allEmpIds.addAll(orgEmpIDs);</span>
<span class="nc" id="L321">		allEmpIds.addAll(intSetEmpIDs);</span>

<span class="nc" id="L323">		Collection allotmentList = getListOfDailyPoolAllotmentActivities();</span>
<span class="nc" id="L324">		Collection[] hrsPerDayCol = getHoursPerDayForCalendar(allEmpIds, intSetEmpIDs, toCalRange, allotmentList);</span>
<span class="nc" id="L325">		Collection hrsPerDayPendCol = hrsPerDayCol[TOCalendarUtil.BKT_PENDING];  	//has pending data</span>
<span class="nc" id="L326">		Collection hrsPerDaySchedCol = hrsPerDayCol[TOCalendarUtil.BKT_SCHED];   //this collection has scheduled data</span>


<span class="nc" id="L329">		Collection childOrgs = new ArrayList();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">		if (pTOPoolID == null) {</span>
<span class="nc" id="L331">			childOrgs.add(org.getID());   // get all child orgs</span>
<span class="nc" id="L332">			childOrgs.addAll(BbmManagerFactory.getWorkResourceManager().getOrganizationsChildrenByIDs(Collections.singleton(org.getID())));</span>
		}
<span class="nc" id="L334">		TimeRange minMaxRange = getMinMaxRange(hrsPerDayCol);</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if (minMaxRange == null) {</span>
<span class="nc" id="L336">			minMaxRange = toCalRange;</span>
		}
		
<span class="nc" id="L339">		Date stDate = getBackAyearforDate(minMaxRange.getStartDate());</span>
<span class="nc" id="L340">		Date enDate = minMaxRange.getEndDate();</span>

<span class="nc" id="L342">		HashMap wras = RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(allEmpIds,</span>
<span class="nc" id="L343">		        new LocalDate(stDate, org.getTimeZone()), new LocalDate(enDate, org.getTimeZone()), false);</span>
<span class="nc" id="L344">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L345">		HashMap empTOPoolAssnMap = toCalFacade.getTOPoolsForWorkResources(allEmpIds, stDate, enDate);</span>
		// fill the orgScheduled and interestSetScheduled buckets.
<span class="nc" id="L347">		fillSchedDailyHoursBuckets(isIndvlEmp,pTOPoolID, hrsPerDaySchedCol, intSetEmpIDs, intSetSchedHrsBkts, toPoolSchedHrsBkts, childOrgs, wras, empTOPoolAssnMap);</span>
<span class="nc" id="L348">		fillTOPendingDailyHoursBuckets( isIndvlEmp,pTOPoolID, hrsPerDayPendCol, intSetEmpIDs, intSetPendHrsBkts, childOrgs, wras, empTOPoolAssnMap);</span>
<span class="nc" id="L349">		DailyHoursBuckets[] bktArray = new DailyHoursBuckets[3];</span>
<span class="nc" id="L350">		bktArray[BKT_PENDING] = intSetPendHrsBkts;</span>
<span class="nc" id="L351">		bktArray[BKT_SCHED] = intSetSchedHrsBkts;</span>
<span class="nc" id="L352">		bktArray[BKT_SCHED_TOPOOL] = toPoolSchedHrsBkts;</span>
<span class="nc" id="L353">		return bktArray;</span>

	}

	private static void markPendingOrScheduledDays(TOCalendarDayData[] result, DailyHoursBuckets[] pendAndSchedBktArray) {
		// scan each day of the time off calendar
<span class="nc bnc" id="L359" title="All 4 branches missed.">		if (pendAndSchedBktArray == null || pendAndSchedBktArray.length &lt; 2) {</span>
<span class="nc" id="L360">			return;  //No point in going ahead we do not have Pending and Scheduled hours</span>
		}
<span class="nc" id="L362">		DailyHoursBuckets schedBkts = pendAndSchedBktArray[BKT_SCHED];</span>
<span class="nc" id="L363">		DailyHoursBuckets pendBkts = pendAndSchedBktArray[BKT_PENDING];</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		Calendar currDayCal = schedBkts != null ? schedBkts.getFirstDay() : pendBkts.getFirstDay();</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">		Date endDate = schedBkts != null ? schedBkts.getDHBRangeEndAsOrgDayEnd() : pendBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">		for (int i = 0; !currDayCal.getTime().after(endDate) &amp;&amp; i &lt; result.length; i++) {</span>
<span class="nc" id="L367">			Date currDay = currDayCal.getTime();</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">			ArrayList toHrsPerDaySchedCol = schedBkts != null ? schedBkts.getTOHoursPerDayForDate(currDay) : null;</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">			ArrayList toHrsPerDayPendCol = pendBkts != null ? pendBkts.getTOHoursPerDayForDate(currDay) : null;</span>
			// Figure out what type of day this is.
			// At this point, we just care about whether there is a pending or scheduled Time Off that intersects this day.
			// Does not matter how many hours are accounted for that;
			// we will show it as scheduled Time-off day even if accounted hours are zero because emp has sched TO on that day.
<span class="nc bnc" id="L374" title="All 4 branches missed.">			if (toHrsPerDaySchedCol != null &amp;&amp; !toHrsPerDaySchedCol.isEmpty()) {</span>
<span class="nc" id="L375">				result[i].setDayType(TOCalendarDayData.SCHEDULED_DAY_TYPE);</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">			} else if (toHrsPerDayPendCol != null &amp;&amp; !toHrsPerDayPendCol.isEmpty()) {</span>
<span class="nc" id="L377">				result[i].setDayType(TOCalendarDayData.PENDING_DAY_TYPE);</span>
			}
<span class="nc" id="L379">			TOCalcUtil.addDaysToCalendar(currDayCal, 1);</span>
		}
<span class="nc" id="L381">	}</span>

	/**
	 * Fills the following information for each TODay in the passed TOCalendarDayData[].
	 * &lt;li&gt; allocated hours for the org
	 * &lt;li&gt; pending hours for a subset of the employees in the org
	 * &lt;li&gt; scheduled hours for a subset of the employees in the org
	 * &lt;li&gt; remaining hours for the org
	 * &lt;li&gt; Mark each day as TO_HOURS_AVAILABLE_DAY_TYPE or TO_HOURS_AVAILABLE_DAY_TYPE
	 *
	 * @param org
	 * @param allocatedBuckets     Contains the number of allocated hours per day for the org
	 * @param pendAndSchedBktArray contains
	 *                             scheduledBuckets  Contains the number of scheduled hours per day for a subset of the employees in the interest set
	 *                             toPoolScheduledBuckets Contains the number of scheduled hours per day for all of the employees in the TOPool
	 *                             pendingBuckets   Contains the number of pending hours per day for a subset of the employees in the interest set
	 * @param result
	 */
	private static void fillCalDayDataAndMarkDayAvailability(Organization org, ID pTOPoolID,
	                                                         DailyHoursBuckets allocatedBuckets,
	                                                         DailyHoursBuckets[] pendAndSchedBktArray,
	                                                         TOCalendarDayData[] result) {
<span class="nc" id="L403">		Calendar currDayCal = allocatedBuckets.getFirstDay();</span>
<span class="nc" id="L404">		Date dailyBktsRangeEndDate = allocatedBuckets.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		for (int i = 0; !currDayCal.getTime().after(dailyBktsRangeEndDate); i++) {</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">			if (i &lt; result.length) {// #29337: Prevent array index out of bounds</span>
				// exception.
<span class="nc" id="L408">				Date dateCurrDay = currDayCal.getTime();</span>
<span class="nc" id="L409">				result[i] = new TOCalendarDayData(dateCurrDay, org, pTOPoolID);</span>
<span class="nc" id="L410">				result[i].setHourAvail(allocatedBuckets.getBucketHours(dateCurrDay));</span>
<span class="nc" id="L411">				result[i].setHourPending(pendAndSchedBktArray[BKT_PENDING].getBucketHours(dateCurrDay));</span>
<span class="nc" id="L412">				result[i].setScheduledTO(pendAndSchedBktArray[BKT_SCHED].getBucketHours(dateCurrDay));</span>

<span class="nc" id="L414">				float hoursAvailable = allocatedBuckets.getBucketHours(dateCurrDay) - pendAndSchedBktArray[BKT_SCHED_TOPOOL].getBucketHours(dateCurrDay);</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">				if (hoursAvailable &lt; 0) {</span>
<span class="nc" id="L416">					hoursAvailable = 0;</span>
				}
<span class="nc" id="L418">				result[i].setHourRemaining(hoursAvailable);</span>

				// Figure out what type of day this is. At this point, we merely figure out whether the day has available hours or
				// not. We'll add holiday, non-operation and blackout days later (see below methods). (recall they all override
				// available/non-available dayTypes)
<span class="nc bnc" id="L423" title="All 2 branches missed.">				if (allocatedBuckets.getBucketHours(dateCurrDay) &gt; pendAndSchedBktArray[BKT_SCHED_TOPOOL].getBucketHours(dateCurrDay)) {</span>
<span class="nc" id="L424">					result[i].setDayType(TOCalendarDayData.TO_HOURS_AVAILABLE_DAY_TYPE);</span>
				} else {
<span class="nc" id="L426">					result[i].setDayType(TOCalendarDayData.NO_TO_HOURS_AVAILABLE_DAY_TYPE);</span>
				}
			}
<span class="nc" id="L429">			TOCalcUtil.addDaysToCalendar(currDayCal, 1);</span>
		}
<span class="nc" id="L431">	}</span>

	/**
	 * Mark non operational days in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using the org's HOO,
	 *
	 * @param hoos
	 * @param TOCalRange
	 * @param orgTimeZone
	 * @param availableBuckets
	 * @param TOCalDayDataArr
	 */
	private static void markNonOperationalDays(Collection hoos, TimeRange TOCalRange, TimeZone orgTimeZone,
			DailyHoursBuckets availableBuckets, TOCalendarDayData[] TOCalDayDataArr, int dayBoundaryOffset) {
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (hoos == null) {</span>
<span class="nc" id="L446">			hoos = Collections.emptyList();</span>
		}

<span class="nc" id="L449">		Calendar orgTZCal = Calendar.getInstance(orgTimeZone);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">		for (Iterator hoosIter = hoos.iterator(); hoosIter.hasNext();) {</span>
<span class="nc" id="L451">			OrganizationHOO hoo = (OrganizationHOO) hoosIter.next();</span>

			// Note: if the HOO is not defined for the entire TOCalendar range, then the TOCalendar's
			// range needs to be adjusted.
			//
			// Pick the later of TOCalendar range startDate or HOO effectivity startDate
<span class="nc" id="L457">			Date hooStartTime = hoo.getStartTime();</span>
<span class="nc" id="L458">			Date adjTOCalStart = TOCalRange.getStartDate();</span>
<span class="nc bnc" id="L459" title="All 4 branches missed.">			adjTOCalStart = ((hooStartTime != null) &amp;&amp; hooStartTime.after(adjTOCalStart)) ? hooStartTime : adjTOCalStart;</span>

			// Pick the earlier of TOCalendar range endDate or HOO effectivity endDate
<span class="nc" id="L462">			Date hooEndTime = hoo.getEndTime();</span>
<span class="nc" id="L463">			Date adjTOCalEnd = TOCalRange.getEndDate();</span>
<span class="nc bnc" id="L464" title="All 4 branches missed.">			adjTOCalEnd = ((hooEndTime != null) &amp;&amp; hooEndTime.before(adjTOCalEnd)) ? hooEndTime : adjTOCalEnd;</span>

<span class="nc" id="L466">			orgTZCal.setTime(adjTOCalStart); // reuse calendar</span>

			do {
<span class="nc" id="L469">				int day = orgTZCal.get(Calendar.DAY_OF_WEEK);</span>

<span class="nc bnc" id="L471" title="All 2 branches missed.">				if (!hoo.isActive((short) day)) {</span>
					// transalte time to day index (array index).
<span class="nc" id="L473">					int ix = availableBuckets.getIndex(orgTZCal.getTime());</span>
<span class="nc" id="L474">					TOCalDayDataArr[ix].setDayType(TOCalendarDayData.NON_OPERATION_DAY_TYPE);</span>
				}

<span class="nc" id="L477">				TOCalcUtil.addDaysToCalendar(orgTZCal, 1);</span>
<span class="nc" id="L478">				TOCalcUtil.setCalMinsOffsetFromMidnight(orgTZCal, dayBoundaryOffset);</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">			} while (!orgTZCal.getTime().after(adjTOCalEnd));</span>

			// As a corner case its possible to have TOCalendarDayData for a date that falls after the end date, adjTOCalEnd.
			// For such scenarios, make a check to see if the TOCalendarDayData is for a non-operational day.
			// For scenarios that are not this corner case, you could get an illegal argument exception when
			// accessing daily hours bucket for a date that is after its range's end date.
			// Then, there is no need to check the corner case non-operational day.
			try {
<span class="nc" id="L487">				int ix = availableBuckets.getIndex(orgTZCal.getTime());</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">				if (ix == TOCalDayDataArr.length - 1) {</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">					if (!hoo.isActive((short) orgTZCal.get(Calendar.DAY_OF_WEEK))) {</span>
<span class="nc" id="L490">						TOCalDayDataArr[ix].setDayType(TOCalendarDayData.NON_OPERATION_DAY_TYPE);</span>
					}
				}
<span class="nc" id="L493">			} catch (IllegalArgumentException e) {}</span>

<span class="nc" id="L495">		}</span>
<span class="nc" id="L496">	}</span>

	/**
	 * Mark blackout days in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using black out days defined in the TOAllocation calendar.
	 *
	 * @param toDayAllocs
	 * @param result
	 */
	private static void markBlackOutDays(Collection toDayAllocs, DailyHoursBuckets availBkts, TOCalendarDayData[] result, Organization org) {
<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (toDayAllocs == null) {</span>
<span class="nc" id="L507">			toDayAllocs = Collections.emptyList();</span>
		}

<span class="nc" id="L510">		Date availBktsRangeStart = availBkts.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L511">		Date availBktsRangeEnd = availBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc" id="L512">		TimeZone availBktsTZ = availBkts.getTimeZone();</span>
<span class="nc" id="L513">		Calendar cal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">		for (Iterator toDayAllocsIter = toDayAllocs.iterator(); toDayAllocsIter.hasNext();) {</span>
<span class="nc" id="L515">			CalendarTimeOffDay toDailyAlloc = (CalendarTimeOffDay) toDayAllocsIter.next();</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">			if (toDailyAlloc.isBlackOutDay()) {</span>
<span class="nc" id="L518">				LocalDate toDailyAllocLocalDate = toDailyAlloc.getTimeOffLocalDate();</span>
<span class="nc" id="L519">				Date toDailyAllocDate = toDailyAllocLocalDate.getTime(availBktsTZ);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L521">					cal.setTime(toDailyAllocDate);</span>
					// QC 41795 / QA 95083 DST issue: standardize setting of dayBoundaryOffset
<span class="nc" id="L523">					TOCalcUtil.setCalMinsOffsetFromMidnight(cal, org.getDayBoundaryOffset());</span>
<span class="nc" id="L524">					toDailyAllocDate = cal.getTime();</span>
				}
				// ensure that the date for the 'dailyTOAlloc' falls within the bucket's time range.
				// Otherwise an 'illegalArgumentException' will be thrown in the next call.
<span class="nc bnc" id="L528" title="All 4 branches missed.">				if (toDailyAllocDate.before(availBktsRangeStart) || toDailyAllocDate.after(availBktsRangeEnd)) {</span>
<span class="nc" id="L529">					continue;</span>
				}
<span class="nc" id="L531">				int ix = availBkts.getIndex(toDailyAllocDate);</span>
<span class="nc" id="L532">				result[ix].setDayType(TOCalendarDayData.BLACKOUT_DAY_TYPE);</span>
			}
<span class="nc" id="L534">		}</span>
<span class="nc" id="L535">	}</span>

	private static void markOrgBlackOutDays(Collection holidayCol, DailyHoursBuckets availBkts, TOCalendarDayData[] result, Organization org) {
		//mark the blackout days only if they are enabled for the org.
<span class="nc bnc" id="L539" title="All 2 branches missed.">		if (!TORequestUtil.isBlackOutDaySettingEnabledForOrg()) {</span>
<span class="nc" id="L540">			return;</span>
		}
<span class="nc" id="L542">		Date availBucketsStartDate = availBkts.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L543">		Date availBucketsEndDate = availBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc" id="L544">		TimeZone availBucketsTimeZone = availBkts.getTimeZone();</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">		for (Iterator iterator = holidayCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L546">			Holiday holiday = (Holiday) iterator.next();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">			if (!holiday.isBlackOutDay()) {</span>
<span class="nc" id="L548">				continue; //We are interested in blackout days only</span>
			}
<span class="nc" id="L550">			Date holidayStart = holiday.getStartDate().getTime(availBucketsTimeZone);</span>
<span class="nc" id="L551">			Date holidayEnd = holiday.getEndDate().getTime(availBucketsTimeZone);</span>
			// ignore any holidays with no overlap
<span class="nc" id="L553">			long overlap = RequestUtil.getOverlapLength(availBucketsStartDate, availBucketsEndDate, holidayStart, holidayEnd);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">			if (overlap == 0) {</span>
<span class="nc" id="L555">				continue;</span>
			}
			// a holiday can start before the availableBuckets.startDate. Adjust holidayStart to beginning
			// of availableBuckets.startDate if necessary.
<span class="nc bnc" id="L559" title="All 2 branches missed.">			Date overlapHolStart = holidayStart.before(availBucketsStartDate) ? availBucketsStartDate : holidayStart;</span>

			// a holiday might end after availBuckets.endDate. In this case adjust the holidayEnd to
			// availableBuckets.endDate if necessary.
<span class="nc bnc" id="L563" title="All 2 branches missed.">			Date overlapHolEnd = holidayEnd.after(availBucketsEndDate) ? availBucketsEndDate : holidayEnd;</span>
			// The result array is indexed identically as the availableBuckets array
<span class="nc" id="L565">			int ix = availBkts.getIndex(overlapHolStart);</span>
<span class="nc" id="L566">			int overlapHolEndIdx = availBkts.getIndex(overlapHolEnd);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">			for (; ix &lt;= overlapHolEndIdx; ix++) {</span>
<span class="nc" id="L568">				result[ix].setDayType(TOCalendarDayData.BLACKOUT_DAY_TYPE);</span>
			}
<span class="nc" id="L570">		}</span>
<span class="nc" id="L571">	}</span>

	private static TimeRange getMinMaxRange(Collection[] hrsPerDayCol) {
<span class="nc" id="L574">		Date startDate = null;</span>
<span class="nc" id="L575">		Date endDate = null;</span>
		TOHoursPerDay hoursPerDay;
<span class="nc bnc" id="L577" title="All 4 branches missed.">		for (int i = 0; hrsPerDayCol != null &amp;&amp; i &lt; hrsPerDayCol.length; i++) {</span>
<span class="nc" id="L578">			Collection toHoursPerDayCol = hrsPerDayCol[i];</span>
<span class="nc bnc" id="L579" title="All 4 branches missed.">			if (toHoursPerDayCol != null &amp;&amp; !toHoursPerDayCol.isEmpty()) {</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">				for (Iterator it = toHoursPerDayCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L581">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L582" title="All 4 branches missed.">					startDate = startDate == null || startDate.after(hoursPerDay.getStartTime()) ? hoursPerDay.getStartTime() : startDate;</span>
<span class="nc bnc" id="L583" title="All 4 branches missed.">					endDate = endDate == null || endDate.before(hoursPerDay.getEndTime()) ? hoursPerDay.getEndTime() : endDate;</span>
				}
			}
		}
<span class="nc" id="L587">		TimeRange range = null;</span>
<span class="nc bnc" id="L588" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L589">			range = new TimeRange(startDate, endDate);</span>
		}
<span class="nc" id="L591">		return range;</span>
	}

	/**
	 * &lt;li&gt; Fetches all published toEvents for orgEmployees during the specified time range.
	 * &lt;li&gt; for each toEvent, computes the daily hours for the event and adds it to the
	 * orgScheduledBucket and scheduledBucket (if necessary).
	 *
	 * @param interestSet
	 * @param schedBkts
	 * @param intSetSchedBkts
	 * @param empTOPoolAssnMap
	 * @throws Exception
	 */
	private static void fillSchedDailyHoursBuckets(boolean isIndvlEmp,ID pTOPoolID, Collection toHrsPerDayCol, Collection interestSet,
	                                               DailyHoursBuckets schedBkts, DailyHoursBuckets intSetSchedBkts, Collection childOrgs, HashMap empWrs, HashMap empTOPoolAssnMap) throws Exception {
<span class="nc bnc" id="L607" title="All 4 branches missed.">		if (toHrsPerDayCol == null || toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L608">			return;</span>
		}
<span class="nc bnc" id="L610" title="All 2 branches missed.">		for (Iterator itt = toHrsPerDayCol.iterator(); itt.hasNext();) {</span>
<span class="nc" id="L611">			TOHoursPerDay hrsPerDay = (TOHoursPerDay) itt.next();</span>
<span class="nc" id="L612">			Organization currOrg = getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc" id="L613">			TimeRange overlapTimeRange = getRelevantTimeRange(isIndvlEmp,pTOPoolID, intSetSchedBkts, childOrgs, empTOPoolAssnMap, currOrg, hrsPerDay);</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">			if(overlapTimeRange==null) {</span>
<span class="nc" id="L615">				continue;</span>
				// add the time off hours for this time off event to the org bucket(which holds the cumulative timeoff for all employees in the org)
				// using overlapStartTime and overlapEndTime to ensure that hours are processed only for the
				// overlap region to avoid IllegalArgumentException (actually IndexOutOfBoundException)
			}

			//This block is for colors or for calculating correct hours
<span class="nc bnc" id="L622" title="All 8 branches missed.">			if (intSetSchedBkts != null &amp;&amp;(pTOPoolID != null || (childOrgs.contains(currOrg.getID()) &amp;&amp; interestSet.contains(hrsPerDay.getEmployeeID())))) {</span>
<span class="nc" id="L623">				addHoursToDailyBuckets(intSetSchedBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
			}
			//This block displays the Scheduled hours
<span class="nc bnc" id="L626" title="All 6 branches missed.">			if (schedBkts != null &amp;&amp; interestSet != null &amp;&amp; interestSet.contains(hrsPerDay.getEmployeeID())) {</span>
<span class="nc" id="L627">				addHoursToDailyBuckets(schedBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
			}
<span class="nc" id="L629">		}</span>
<span class="nc" id="L630">	}</span>
	public static TimeRange getRelevantTimeRange(boolean isIndvlEmp,ID pTOPoolID, DailyHoursBuckets bkts,Collection childOrgs, HashMap empTOPoolAssnMap, Organization currOrg, TOHoursPerDay hrsPerDay) throws Exception {
<span class="nc bnc" id="L632" title="All 2 branches missed.">		if (currOrg == null) {</span>
<span class="nc" id="L633">			m_cat.debug(&quot;ignoring TOHoursPerday because currOrg == null: HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L634">			return null; //employee has been terminated or has been changed org and does not belong to the current requested list</span>
		}
<span class="nc bnc" id="L636" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
			//check if employee belongs to same TOPool on start date. if not then skip this TO Event
<span class="nc" id="L638">			ID empTOPoolID = getTOPoolIDforDate(hrsPerDay.getStartTime(), (Collection) empTOPoolAssnMap.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc bnc" id="L639" title="All 4 branches missed.">			if (empTOPoolID == null || !empTOPoolID.equals(pTOPoolID)) {</span>
<span class="nc bnc" id="L640" title="All 2 branches missed.">				if (!isIndvlEmp) {</span>
<span class="nc" id="L641">					m_cat.debug(&quot;ignoring TOHoursPerday because employee does not belong to this TOPOOL=&quot; + empTOPoolID + &quot;: HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L642">					return null;  // Return null because it is a TOPOOL View and this request does not belong to the given TO Pool</span>
				}
				//proceed for the user even if request does not belong to the current TOPOOL.
				// We still check if the request intersects with TOPOOL effectviity. if yes, then add it in current TOPOOL
				// because the TO has been requested in the earlier TOPOOL and has overflown into time range of this pool.
				//the time off falls in the transition zone.
<span class="nc" id="L648">				EmpTOPoolAssignment poolAss = getEmpTOPoolAssignment(pTOPoolID, (Collection) empTOPoolAssnMap.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">				if (poolAss == null || !TimePeriodUtil.overlap(poolAss.getStartTime(), poolAss.getEndTime(), hrsPerDay.getStartTime(), hrsPerDay.getEndTime())) {</span>
<span class="nc" id="L650">					m_cat.debug(&quot;ignoring TOHoursPerday because TO does not belong to / intersect with this TOPOOL=&quot; + empTOPoolID + &quot;: HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L651">					return null;</span>
				}
			}
<span class="nc bnc" id="L654" title="All 4 branches missed.">		} else if (childOrgs == null || !childOrgs.contains(currOrg.getID())) {</span>
<span class="nc" id="L655">			m_cat.debug(&quot;ignoring TOHoursPerday because childOrgs == null || !childOrgs.contains(currOrg.getID()): HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L656">			return null; //employee has been terminated or has been changed org and does not belong to the current requested list</span>
		}
<span class="nc" id="L658">		return RequestUtil.getOverlapTimeRange(hrsPerDay, bkts);</span>
	}

	public static Organization getOrgforDate(Date startDate, Collection wrs) throws Exception {
<span class="nc bnc" id="L662" title="All 2 branches missed.">		if (wrs != null) {</span>
<span class="nc" id="L663">			Iterator it = wrs.iterator();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L665">				WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L666" title="All 6 branches missed.">				if (!startDate.before(wra.getStartTime()) &amp;&amp; (wra.getEndTime() == null || startDate.before(wra.getEndTime()))) {</span>
<span class="nc" id="L667">					return ValidationUtil.getOrganizationByID(wra.getOrganizationID());</span>
				}
<span class="nc" id="L669">			}</span>
		}
<span class="nc" id="L671">		return null;</span>
	}

	public static ID getTOPoolIDforDate(Date startDate, Collection pTOPoolCol) throws Exception {
<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (pTOPoolCol != null) {</span>
<span class="nc" id="L676">			Iterator it = pTOPoolCol.iterator();</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L678">				EmpTOPoolAssignment pTOPoolAssn = (EmpTOPoolAssignment) it.next();</span>
<span class="nc bnc" id="L679" title="All 6 branches missed.">				if (!startDate.before(pTOPoolAssn.getStartTime()) &amp;&amp; (pTOPoolAssn.getEndTime() == null || startDate.before(pTOPoolAssn.getEndTime()))) {</span>
<span class="nc" id="L680">					return pTOPoolAssn.getTOPoolID();</span>
				}
<span class="nc" id="L682">			}</span>
		}
<span class="nc" id="L684">		return null;</span>
	}

	public static EmpTOPoolAssignment getEmpTOPoolAssignment(ID toPoolID, Collection pTOPoolCol){
<span class="nc bnc" id="L688" title="All 2 branches missed.">		if (pTOPoolCol != null) {</span>
<span class="nc" id="L689">			Iterator it = pTOPoolCol.iterator();</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L691">				EmpTOPoolAssignment pTOPoolAssn = (EmpTOPoolAssignment) it.next();</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">				if (pTOPoolAssn.getTOPoolID().equals(toPoolID)) {</span>
<span class="nc" id="L693">					return pTOPoolAssn;</span>
				}
<span class="nc" id="L695">			}</span>
		}
<span class="nc" id="L697">		return null;</span>
	}

	private static void fillTOPendingDailyHoursBuckets(boolean isIndvlEmp,ID pTOPoolID, Collection toHrsPerDayCol, Collection interestSet,
			 DailyHoursBuckets pendBkts, Collection childOrgs, HashMap empWrs, HashMap empTOPoolAssnMap) throws Exception {
<span class="nc bnc" id="L702" title="All 4 branches missed.">		if (toHrsPerDayCol == null || toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L703">			return;</span>
		}
<span class="nc bnc" id="L705" title="All 2 branches missed.">		for (Iterator itt = toHrsPerDayCol.iterator(); itt.hasNext();) {</span>
<span class="nc" id="L706">			TOHoursPerDay hrsPerDay = (TOHoursPerDay) itt.next();</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">			if (!interestSet.contains(hrsPerDay.getEmployeeID())) {</span>
<span class="nc" id="L708">				continue;</span>
			}
<span class="nc" id="L710">			Organization currOrg = getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc" id="L711">			TimeRange overlapTimeRange = getRelevantTimeRange(isIndvlEmp,pTOPoolID, pendBkts, childOrgs, empTOPoolAssnMap, currOrg, hrsPerDay);</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">			if (overlapTimeRange == null) {</span>
<span class="nc" id="L713">				continue;</span>
			}
			// add the time off hours for this time off event to the org bucket (which holds the cumulative timeoff for
			// all employees in the org) using overlapStartTime and overlapEndTime to ensure that hours are processed
			// only for the overlap region to avoid IllegalArgumentException (actually IndexOutOfBoundException)
<span class="nc" id="L718">			addHoursToDailyBuckets(pendBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
<span class="nc" id="L719">		}</span>
<span class="nc" id="L720">	}</span>

	/**
	 * Mark working holidays in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using the holidays defined for the org.
	 *
	 * @param holidays
	 * @param orgTz
	 * @param availableBuckets
	 * @param result
	 */
	private static void markHolidays(Collection holidays, Organization org, DailyHoursBuckets availableBuckets,
			TOCalendarDayData[] result, boolean markUnPaid) {
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (holidays == null) {</span>
<span class="nc" id="L734">			holidays = Collections.emptyList();</span>
		}

<span class="nc" id="L737">		Date availBucketsStartDate = availableBuckets.getRange().getStartDate();</span>
<span class="nc" id="L738">		Date availBucketsEndDate = availableBuckets.getDHBRangeEndAsOrgDayEnd();</span>

<span class="nc" id="L740">		TimeZone availBucketsTimeZone = availableBuckets.getTimeZone();</span>

<span class="nc bnc" id="L742" title="All 2 branches missed.">		for (Iterator it = holidays.iterator(); it.hasNext();) {</span>
<span class="nc" id="L743">			Holiday holiday = (Holiday) it.next();</span>
<span class="nc bnc" id="L744" title="All 8 branches missed.">			if ((markUnPaid &amp;&amp; holiday.isUnPaidHoliday()) || (holiday.isPaidHoliday() &amp;&amp; !markUnPaid)) {</span>
<span class="nc" id="L745">				Date holidayStart = holiday.getStartDate().getTime(availBucketsTimeZone);</span>
<span class="nc" id="L746">				Date holidayEnd = holiday.getEndDate().getTime(availBucketsTimeZone);</span>
				// ignore any holidays with no overlap
<span class="nc" id="L748">				long overlap = RequestUtil.getOverlapLength(availBucketsStartDate, availBucketsEndDate, holidayStart, holidayEnd);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">				if (overlap == 0) {</span>
<span class="nc" id="L750">					continue;</span>
				}
				// a holiday can start before the availableBuckets.startDate. Adjust holidayStart to beginning
				// of availableBuckets.startDate if necessary.
<span class="nc bnc" id="L754" title="All 2 branches missed.">				Date overlapHolStart = holidayStart.before(availBucketsStartDate) ? availBucketsStartDate : holidayStart;</span>

				// a holiday might end after availBuckets.endDate. In this case adjust the holidayEnd to
				// availableBuckets.endDate if necessary.
<span class="nc bnc" id="L758" title="All 2 branches missed.">				Date overlapHolEnd = holidayEnd.after(availBucketsEndDate) ? availBucketsEndDate : holidayEnd;</span>
				// The result array is indexed identically as the availableBuckets array
<span class="nc" id="L760">				int ix = availableBuckets.getIndex(overlapHolStart);</span>
<span class="nc" id="L761">				int overlapHolEndIdx = availableBuckets.getIndex(overlapHolEnd);</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">				for (; ix &lt;= overlapHolEndIdx; ix++) {</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">					result[ix].setDayType(markUnPaid ? TOCalendarDayData.UNPAID_HOLIDAY_DAY_TYPE : TOCalendarDayData.PAID_HOLIDAY_DAY_TYPE);</span>
				}
			}
<span class="nc" id="L766">		}</span>
<span class="nc" id="L767">	}</span>


	/**
	 * Get the collection of CalendarTimeOffDay objects for the requested range for the organization
	 * Returns a collection of CalendarTimeOffDay objects.
	 */
	private static Collection getTOAllocationCalendar(ID pTOPoolID, ID orgId, TimeZone tz, TimeRange range) throws Exception {
<span class="nc" id="L775">		Calendar vCal = Calendar.getInstance(tz);</span>

		// Build the LocalDate objects that bound the range of time off calendar days
		// we need to proecess this request.
<span class="nc" id="L779">		vCal.setTime(range.getStartDate());</span>
<span class="nc" id="L780">		vCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L781">		vCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L782">		vCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L783">		vCal.set(Calendar.MILLISECOND, 0);</span>
		// force evaluation of fields
<span class="nc" id="L785">		vCal.getTime();</span>
<span class="nc" id="L786">		LocalDate strt = new LocalDate(vCal);</span>

<span class="nc" id="L788">		vCal.setTime(range.getEndDate());</span>
<span class="nc" id="L789">		vCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L790">		vCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L791">		vCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L792">		vCal.set(Calendar.MILLISECOND, 0);</span>
		// force evaluation of fields
<span class="nc" id="L794">		vCal.getTime();</span>
		// Point to the following day
<span class="nc" id="L796">		vCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L797">		LocalDate end = new LocalDate(vCal);</span>

<span class="nc" id="L799">		CalendarTimeOffDayFacade ctodf = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>

<span class="nc" id="L801">		return ctodf.getCalendarTimeOffDays(pTOPoolID, strt, end, true); // get CTO info, including blackouts</span>

	}

	/**
	 * adds hours from the srcBuckets to the destBuckets based on pure Date only.
	 * i.e. hours for buckets from different timezones or orgs having diff day boundaries will be purely added based on
	 * actual date instead of time component.
	 * i.e. if Dest Bucket is PST TZ and SRC Bucket is EST TZ and if the Src Bucket has 12 am to 2 am EST Time off on 4th Jan then
	 * it will still show on 4th Jan when seen in TO Calendar for PST (eventhough it is actualy 9 pm to 11 pm PST on 3rd Jan.
	 * Same applies to Day boundary as well.
	 *
	 * @param destBkt
	 * @param orgSrc
	 */
	private static void addHoursToDailyBuckets(DailyHoursBuckets destBkt, TOHoursPerDay hrsPerDay,
			TimeRange range, Organization orgSrc) {
<span class="nc" id="L818">		DailyHoursBuckets srcBkt = TOHoursPerDayUtil.getDailyHoursBuckets(orgSrc, hrsPerDay);</span>
<span class="nc" id="L819">		Calendar cal = Calendar.getInstance(orgSrc.getTimeZone());</span>
<span class="nc" id="L820">		cal.setTime(range.getStartDate());</span>
<span class="nc" id="L821">		cal = new LocalDate(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DAY_OF_MONTH)).getCal();</span>
<span class="nc" id="L822">		TOCalcUtil.addDaysToCalendar(cal, -1);  // start from earlier day to be sure.</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">		while (!srcBkt.getDHBRangeEndAsOrgDayEnd().before(cal.getTime())) {</span>
			try {
<span class="nc" id="L825">				Date srcDate = srcBkt.getOrgDayStart(cal);</span>
<span class="nc" id="L826">				Date destDate = destBkt.getOrgDayStart(cal);</span>
<span class="nc bnc" id="L827" title="All 4 branches missed.">				if (srcBkt.isDateInRange(srcDate) &amp;&amp; destBkt.isDateInRange(destDate)) {</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">					if (destBkt.isInclTOHrsPerDayDetails()) {</span>
<span class="nc" id="L829">						destBkt.addToBucket(destDate, srcBkt.getBucketHours(srcDate), hrsPerDay);</span>
					} else {
<span class="nc" id="L831">						destBkt.addToBucket(destDate, srcBkt.getBucketHours(srcDate));</span>
					}
				} else {
<span class="nc" id="L834">					m_cat.debug(&quot;dt=&quot; + cal.getTime() + &quot;\tSRC Date=&quot; + srcDate + &quot;\tSRC In Range=&quot; + srcBkt.isDateInRange(srcDate)</span>
<span class="nc" id="L835">					        + &quot;\tDestDate=&quot; + destDate + &quot;\tDest In Range=&quot; + destBkt.isDateInRange(destDate));</span>
				}
<span class="nc" id="L837">			} catch (Exception e) {</span>
<span class="nc" id="L838">				m_cat.error(&quot;Thrown exception while moving hrs between buckets in cal.getTime()=&quot; + cal.getTime(), e);</span>
<span class="nc" id="L839">			}</span>
<span class="nc" id="L840">			TOCalcUtil.addDaysToCalendar(cal, 1);</span>
		}
<span class="nc" id="L842">	}</span>


	/**
	 * This method returns the HoursPerDay to be used for Calendar.
	 * @param empIDs to get the Hours Per day for
	 * @param calRange date range all HrsPerDay contained in the range
	 * @param activityIDs is activityIDs is null or empty then return all, else only specified by the Collection
	 * @param schedOrPending, true For Scheduled &amp; used; false for Pending only
	 */
	public static Collection[] getHoursPerDayForCalendar(Collection empIDsSched, Collection empIDsPending, TimeRange calRange, Collection activityIDs) throws Exception {
<span class="nc" id="L853">		TOHoursPerDayManager hoursPerDayManager = RequestUtil.getTOHoursPerDayManager(null, null);</span>
		// QC49742-QA96869 if activityIDs is empty, all activities should not be returned
<span class="nc bnc" id="L855" title="All 2 branches missed.">		return hoursPerDayManager.getHoursPerDayForCalendar(empIDsSched, empIDsPending, calRange.getStartDate(), calRange.getEndDate(),</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">		        (activityIDs == null || activityIDs.isEmpty() ? Collections.singleton(Activity.ACTIVITY_NONE) : activityIDs));</span>
	}

	public static Collection getHoursPerDayForRange(Collection empIDs, TimeRange calRange, Collection activityIDs, boolean schedOrPending) throws Exception {
<span class="nc" id="L860">		TOHoursPerDayManager hoursPerDayManager = RequestUtil.getTOHoursPerDayManager(null, null);</span>
		// QC49742-QA96869 if activityIDs is empty, all activities should not be returned
<span class="nc bnc" id="L862" title="All 2 branches missed.">		return hoursPerDayManager.getHoursPerDayForCalendar(empIDs, calRange.getStartDate(), calRange.getEndDate(),</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">		        (activityIDs == null || activityIDs.isEmpty() ? Collections.singleton(Activity.ACTIVITY_NONE) : activityIDs),</span>
		        schedOrPending);
	}

	//get all allotment activities (both daily and interval)
	public static Collection&lt;ID&gt; getListOfAllAllotmentActivities() throws BbmFinderException {
		try {

<span class="nc" id="L871">		boolean onlyUseAllotmentAct = useOnlyAllotmentActivities();</span>
		// QC49742-QA96869 if not using allotments, then all time off activities should be returned.
<span class="nc" id="L873">		ActivityFilter filter = new ActivityFilter();</span>
<span class="nc" id="L874">		filter.setTimeoff(true);</span>

		//if only using allotment activities, get all time off activities with allotment in a list
<span class="nc bnc" id="L877" title="All 2 branches missed.">		if (onlyUseAllotmentAct) {</span>
<span class="nc" id="L878">			filter.setTimeoffWithAllotment(true);//			get all allotment time off activities</span>
		}
<span class="nc" id="L880">		return WfmManagerFactory.getActivityManager().findActivitiesIds(filter);</span>
<span class="nc" id="L881">		} catch (Exception e) {</span>
<span class="nc" id="L882">			throw new BbmFinderException(e);</span>
		}
	}

	public static Collection&lt;ID&gt; getListOfDailyPoolAllotmentActivities() throws BbmFinderException {

<span class="nc bnc" id="L888" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
			//if the advanced license is off then every activity is considered to be a daily pool activity 
<span class="nc" id="L890">			return getListOfAllAllotmentActivities();</span>
		}

<span class="nc" id="L893">		return getListOfExplicitDailyPoolAllotmentActivities();</span>
	}

	//similar to getListOfAllotmentActivities, however returns only activities that are explicitly checked for daily pool
	private static Collection&lt;ID&gt; getListOfExplicitDailyPoolAllotmentActivities() throws BbmFinderException {

		try {
<span class="nc" id="L900">			boolean onlyUseAllotmentAct = useOnlyAllotmentActivities();</span>
<span class="nc" id="L901">			return WfmManagerFactory.getActivityManager().getDailyPoolAllotmentActivityIDs(onlyUseAllotmentAct);</span>
<span class="nc" id="L902">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L903">			throw new BbmFinderException(e);</span>
<span class="nc" id="L904">		} catch (RemoteException e) {</span>
<span class="nc" id="L905">			throw new BbmFinderException(e);</span>
		}

	}

	private static boolean useOnlyAllotmentActivities() throws RemoteException, BbmEJBCreateException {
<span class="nc" id="L911">		return &quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(</span>
				ConfigKey.TIMEOFF_ONLY_COUNT_ACTIVITIES_WITH_ALLOTMENT));
	}

	public static Date getBackAyearforDate(Date date) {
<span class="nc" id="L916">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L917">		cal.setTime(date);</span>
<span class="nc" id="L918">		cal.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L919">		return cal.getTime();</span>
	}

	/**
	 * Return an array of
	 * {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData}
	 * objects that contain time off calendar data for the given employee. The TOCalendarDayData
	 * objects contain, for each organization day in the range:
	 * - the allocated hours for the employee's organization
	 * - the pending hours (first choice only) for the employee
	 * - the hours scheduled in time off events for the employee
	 * - the hours remaining for the employee's organization =(allocated - scheduledForAllEmployees)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the
	 * Need the damn dates in a local date which is bascially only the date without time or timezone.
	 * unfortunately java does not have any data structure to hold it hence we have a LOCALDATE
	 * scheduled time off for all employees in the organization) for each day in the range.
	 *
	 * @param empID     the employee id
	 * @param startDateRange the beginning of the range.
	 * @param endDateRange   the end of the range.                                                               1
	 * @return an array of TOCalendarDayData objects
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public static TOCalendarDayData[] getTOCalendarForEmp(ID empID, Date startDateRange, Date endDateRange, boolean isTOPoolView,
			Organization currentEmpOrg) throws BbmFinderException {
<span class="nc" id="L946">		long currentime = new Date().getTime();</span>
		try {
<span class="nc" id="L948">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L949">			TOCalendarDayData[] totalDayData = null;</span>
			//QC 179110: Employee can be assigned to different organizations which have different non-working days
			//Therefore, we should iterate for each period of work assignment instead of getting full period from date navigation as before
<span class="nc" id="L952">			Collection&lt;WorkResourceAssignment&gt; orgAssignsForEmp= RequestUtil.geOrgAssnsForWorkResDuringPeriod(empID,startDateRange,endDateRange);</span>
<span class="nc" id="L953">			boolean firstWrkAssn = true;</span>
<span class="nc" id="L954">			int counter=0;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">			for(WorkResourceAssignment wrkAssign:orgAssignsForEmp){</span>
<span class="nc" id="L956">				counter++;</span>
<span class="nc" id="L957">				Organization wrkOrg = BbmManagerFactory.getWorkResourceManager().getOrganizationByID(wrkAssign.getOrganizationID());</span>
<span class="nc" id="L958">				Date startDate =getStartDateForWorkResourceOnCalendar(startDateRange,wrkAssign.getStartTime(),wrkOrg,currentEmpOrg,firstWrkAssn);</span>
<span class="nc" id="L959">				Date endDate = getEndDateForWorkResourceOnCalendar(endDateRange,wrkAssign.getEndTime(),wrkOrg,currentEmpOrg);</span>
				// Get the organization that the employee is in on the start date
<span class="nc" id="L961">				Collection empTOPoolAssnCol = toCalFacade.getValidEmpTOPoolAssignments(empID, startDate, endDate);</span>
<span class="nc" id="L962">				ID pTOPoolID = null;</span>
				
<span class="nc" id="L964">				Date prevEndDate = new Date(startDate.getTime());</span>
<span class="nc bnc" id="L965" title="All 2 branches missed.">				for (Iterator it = empTOPoolAssnCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L966">					EmpTOPoolAssignment empTOAss = (EmpTOPoolAssignment) it.next();</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">					if (!isOverlap(empTOAss, startDate, endDate)) {</span>
<span class="nc" id="L968">						continue;</span>
					}
<span class="nc" id="L970">					pTOPoolID = empTOAss.getTOPoolID();</span>
<span class="nc bnc" id="L971" title="All 2 branches missed.">					if (prevEndDate.before(empTOAss.getStartTime())) {</span>
						//fill GAPs at start or between EMP TO assignments
<span class="nc" id="L973">						TOCalendarDayData[] temp1=getTOCalendarForRange(empID, null, prevEndDate, empTOAss.getStartTime(), isTOPoolView);</span>
<span class="nc" id="L974">						totalDayData = appendDayData(totalDayData, temp1, prevEndDate);</span>
<span class="nc" id="L975">						prevEndDate = new Date(empTOAss.getStartTime().getTime());</span>
					}
					//adjust end date
<span class="nc bnc" id="L978" title="All 4 branches missed.">					Date rangeEndDate = (empTOAss.getEndTime() == null || empTOAss.getEndTime().after(endDate)) ? endDate :empTOAss.getEndTime();</span>
					//append to total array
<span class="nc bnc" id="L980" title="All 2 branches missed.">					if (prevEndDate.before(rangeEndDate)) {</span>
<span class="nc" id="L981">						TOCalendarDayData[] temp2=getTOCalendarForRange(empID, pTOPoolID, prevEndDate, rangeEndDate, isTOPoolView);</span>
						/*Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
						 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
						 */
<span class="nc" id="L985">						temp2=getCorrectDaydataBeforeAppendTotalArray(temp2,prevEndDate);</span>
<span class="nc" id="L986">						totalDayData = appendDayData(totalDayData,temp2	, prevEndDate);</span>
					}
<span class="nc" id="L988">					prevEndDate = new Date(rangeEndDate.getTime());</span>
<span class="nc" id="L989">				}</span>
				//End for employee Pool assignment
				
<span class="nc bnc" id="L992" title="All 4 branches missed.">				if (prevEndDate != null &amp;&amp; prevEndDate.before(endDate)) { //gap at end</span>
<span class="nc" id="L993">					TOCalendarDayData[] dayData=getTOCalendarForRange(empID, null, prevEndDate, endDate, isTOPoolView);</span>
					/*Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
					 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
					*/
<span class="nc" id="L997">					dayData=getCorrectDaydataBeforeAppendTotalArray(dayData,prevEndDate);</span>
<span class="nc" id="L998">					totalDayData = appendDayData(totalDayData, dayData, prevEndDate);</span>
				}

				//Fill gap with emptyData in the case employee ends on a day in the range(startDateRange,endDateRange)
<span class="nc bnc" id="L1002" title="All 4 branches missed.">				if(counter==orgAssignsForEmp.size()&amp;&amp;endDate.before(endDateRange)){</span>
<span class="nc" id="L1003">					TimeRange toCalRange = new TimeRange(endDate, endDateRange);</span>
<span class="nc" id="L1004">					DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(wrkOrg.getDayBoundaryOffset(), wrkOrg.getTimeZone(), toCalRange);</span>
	
<span class="nc" id="L1006">					TOCalendarDayData[] pTOCalDayDataArray = new TOCalendarDayData[toAllocHrsBkts.getSize()];</span>
<span class="nc" id="L1007">					Calendar cal1=  Calendar.getInstance(wrkOrg.getTimeZone());</span>
<span class="nc" id="L1008">					cal1.setTime(toCalRange.getStartDate());</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">					for(int j=0;j&lt;pTOCalDayDataArray.length;j++){</span>
<span class="nc" id="L1010">						pTOCalDayDataArray[j]=new TOCalendarDayData(cal1.getTime(), wrkOrg, null);</span>
<span class="nc" id="L1011">						cal1.add(Calendar.DAY_OF_MONTH, 1);  </span>
					}
								
<span class="nc" id="L1014">					totalDayData = appendDayData(totalDayData, pTOCalDayDataArray, endDate);</span>
				}
<span class="nc" id="L1016">				firstWrkAssn=false;</span>
<span class="nc" id="L1017">			}</span>
			//End for orgAssignsForEmp
<span class="nc" id="L1019">			return totalDayData;</span>
<span class="nc" id="L1020">		} catch (Exception e) {</span>
<span class="nc" id="L1021">			m_cat.error(e);</span>
<span class="nc" id="L1022">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1024" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1025">				m_cat.debug(&quot;TOTAL TIME FOR CAL=&quot; + (new Date().getTime() - currentime));</span>
			}
		}
	}
	
	/**
	 * Get correct start date  based on the timezone of the organization which employee is assigned to during assignment,
	 *  not the timezone of current Org of employee
	 */
	public static Date getStartDateForWorkResourceOnCalendar(Date startDateRange,Date wrkAssignStartDate, Organization orgAssigned,
			Organization currentOrg, boolean firstWrkAssn) {
<span class="nc bnc" id="L1036" title="All 4 branches missed.">		if(wrkAssignStartDate == null || wrkAssignStartDate.before(startDateRange)) {</span>
			//Start date will be the startDateRange which is adjusted based on the the time_zone and boundary of the organization assignment
<span class="nc bnc" id="L1038" title="All 2 branches missed.">			if(!orgAssigned.getTimeZone().equals(currentOrg.getTimeZone())) {</span>
<span class="nc" id="L1039">				return getAdjustedDateOnAssignedOrg(startDateRange, orgAssigned, currentOrg);</span>
			}
<span class="nc" id="L1041">			return startDateRange;</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">		} else if(firstWrkAssn) {</span>
			//Start date will be  the startDateRange which is adjusted based on the the time_zone and boundary of the first organization assignment
<span class="nc" id="L1044">			return getAdjustedDateOnAssignedOrg(startDateRange, orgAssigned, currentOrg);</span>
		} else {
<span class="nc" id="L1046">			return wrkAssignStartDate;</span>
		}
	}

	/**
	 * Get correct end date  based on the timezone of the organization which employee is assigned to during assignment,
	 * not the timezone of current Org of employee
	 */
	public static Date getEndDateForWorkResourceOnCalendar(Date endDateRange,Date wrkAssignEndDate, Organization orgAssigned,Organization currentOrg) 
			throws BbmException, RemoteException{
		Date adjustEndDate;
<span class="nc bnc" id="L1057" title="All 4 branches missed.">		if(wrkAssignEndDate==null||wrkAssignEndDate.after(endDateRange)) {</span>
<span class="nc" id="L1058">			adjustEndDate = endDateRange;</span>
			//End date will be the endDateRange which is adjusted based on the the time_zone and boundary of the organization assignment
<span class="nc bnc" id="L1060" title="All 2 branches missed.">			if(!orgAssigned.getTimeZone().equals(currentOrg.getTimeZone())) {</span>
<span class="nc" id="L1061">				return getAdjustedDateOnAssignedOrg(adjustEndDate, orgAssigned, currentOrg);</span>
			}	
		} else {
<span class="nc" id="L1064">			adjustEndDate = wrkAssignEndDate;</span>
		}
<span class="nc" id="L1066">		return adjustEndDate;</span>
	}

	private static Date getAdjustedDateOnAssignedOrg(Date startDate, Organization orgAssigned, Organization currentOrg) {
<span class="nc" id="L1070">		LocalDate localStartDate = new LocalDate(startDate, currentOrg.getTimeZone());</span>
<span class="nc" id="L1071">		Date date = TimeZoneUtil.toDate(localStartDate, orgAssigned.getTimeZone());</span>
<span class="nc" id="L1072">		int dayBoundaryOffSet = orgAssigned.getDayBoundaryOffset() - currentOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L1073">		long number = date.getTime();</span>
<span class="nc" id="L1074">		return new Date(number + (dayBoundaryOffSet * MILLIS_IN_MINUTE));</span>
	}

	/**
	 * Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
	 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
	 */
	private static  TOCalendarDayData[] getCorrectDaydataBeforeAppendTotalArray(TOCalendarDayData[] dayData, Date startDate){
<span class="nc" id="L1082">		int i=0;</span>
<span class="nc" id="L1083">		TOCalendarDayData[] tempDayData= dayData;</span>
<span class="nc bnc" id="L1084" title="All 4 branches missed.">		if(dayData!=null&amp;&amp;dayData.length&gt;0){</span>
<span class="nc" id="L1085">			Date dateOfFirstElement=dayData[0].getDate();</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">			if(dateOfFirstElement.before(startDate)){</span>
<span class="nc" id="L1087">				int len=dayData.length-1;</span>
<span class="nc" id="L1088">				 tempDayData= new TOCalendarDayData[len]; </span>
<span class="nc bnc" id="L1089" title="All 4 branches missed.">				for (int j = 1; dayData != null &amp;&amp; j &lt; dayData.length; j++) {</span>
<span class="nc" id="L1090">					tempDayData[i] = dayData[j];</span>
<span class="nc" id="L1091">					i++;</span>
				}
			} 
		}
<span class="nc" id="L1095">		return tempDayData;</span>
	}
	
	protected static boolean isOverlap(EmpTOPoolAssignment poolAssignment, Date start, Date end) {
<span class="nc bnc" id="L1099" title="All 6 branches missed.">		if ((poolAssignment.getEndTime() == null || start.before(poolAssignment.getEndTime())) &amp;&amp; end.after(poolAssignment.getStartTime())) {</span>
<span class="nc" id="L1100">			return true;</span>
		}
<span class="nc" id="L1102">		return false;</span>
	}
	@SuppressWarnings(&quot;unchecked&quot;)
	private static TOCalendarDayData[] getTOCalendarForRange(ID empID, ID pTOPoolID, Date rangeStartDate, Date rangeEndDate,
			boolean isTOPoolView) throws Exception {
<span class="nc bnc" id="L1107" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1108">			m_cat.info(&quot;empID=&quot; + empID + &quot;,  pTOPoolID=&quot; + pTOPoolID + &quot;, rangeStart =&quot; + rangeStartDate + &quot;, rangeEnd =&quot; + rangeEndDate</span>
					+ &quot;,  isTOPoolView=&quot; + isTOPoolView);
		}
	
		//calculate date from past year, we will load time offs for all employees of the said TOPool from this date.
		// This is done to take care of employees that change TOPools before the passed start date but have a time off
		//extending into this periods. so it would be counted in this Time-Off Pool.
		
<span class="nc" id="L1116">		Date empStartDate = getBackAyearforDate(rangeEndDate);</span>
<span class="nc" id="L1117">		rangeEndDate = new Date(rangeEndDate.getTime() - 1); // NOSONAR</span>
		Collection&lt;ID&gt; pTOPoolEmpIDs;
<span class="nc bnc" id="L1119" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
			
<span class="nc" id="L1121">			pTOPoolEmpIDs = RmManagerFactory.getInstance().getTimeOffDayFacade()</span>
<span class="nc" id="L1122">					.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, rangeEndDate);</span>
		} else {
			// If no TOPOOL is found then only show pending / scheduled hours. No need to show the colors or allocations
<span class="nc" id="L1125">			pTOPoolEmpIDs = Collections.singleton(empID);</span>
		}
<span class="nc" id="L1127">		Organization org = ValidationUtil.getOrganizationByID(TOCalcUtil.getOrgIDForEmployeeID(empID, rangeStartDate));</span>
		Collection&lt;ID&gt; interestSetEmpIDs;
<span class="nc bnc" id="L1129" title="All 2 branches missed.">		if (isTOPoolView) {</span>
<span class="nc" id="L1130">			interestSetEmpIDs = pTOPoolEmpIDs;</span>
		} else {
			//for Employee's view
<span class="nc" id="L1133">			interestSetEmpIDs = Collections.singleton(empID);</span>
		}
<span class="nc" id="L1135">		TimeRange range = new TimeRange(rangeStartDate, rangeEndDate);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">		boolean isIndvlEmp = !isTOPoolView;</span>
<span class="nc" id="L1137">		return getTOCalendar(isIndvlEmp, interestSetEmpIDs, pTOPoolEmpIDs, pTOPoolID, org, range);</span>
	}

	//QC 95169 fix . Ported the back ported appendDayData() from V11.1
	private static TOCalendarDayData[] appendDayData(TOCalendarDayData[] totalDayData, TOCalendarDayData[] dayData, Date startDate) {
		TOCalendarDayData[] tempDayData;
<span class="nc" id="L1143">		int i = 0;</span>
		// this flag is used to determine if we need to ignore the first element in the new array(dayData)
		// When emp has an org change between orgs having different day boundaries.
		// QC201438_Case1 : We may ignore the last element of current array(totalDayData) instead of the first array
<span class="nc" id="L1147">		boolean ignoreFirstElem=false;</span>
		//ignore the last element of data of last assignment in case the employee changed to another organization to have timezone after the previous time zone
<span class="nc" id="L1149">		boolean ignoreLastElem=false;</span>
<span class="nc bnc" id="L1150" title="All 2 branches missed.">		if (totalDayData != null) {</span>
<span class="nc" id="L1151">			String lastDate = totalDayData[totalDayData.length - 1].getUniqueDateStr();</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">			String firstDate = dayData[0]!=null?dayData[0].getUniqueDateStr():null;</span>
			
<span class="nc" id="L1154">			int len = totalDayData.length + dayData.length;</span>
<span class="nc bnc" id="L1155" title="All 4 branches missed.">			if (lastDate!=null&amp;&amp;lastDate.equals(firstDate)) {//Ignore one element</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">				if(totalDayData[totalDayData.length - 1].getDate().before(startDate)){</span>
<span class="nc" id="L1157">					ignoreLastElem= true;</span>
				} else {
<span class="nc" id="L1159">					ignoreFirstElem=true;</span>
				}
<span class="nc" id="L1161">				len = len - 1;</span>
			}
<span class="nc" id="L1163">			tempDayData = new TOCalendarDayData[len];</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">			int lenTotalDayData = ignoreLastElem?totalDayData.length-1:totalDayData.length;</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">			for (i = 0; i &lt; lenTotalDayData;){</span>
<span class="nc" id="L1166">				tempDayData[i] = totalDayData[i];</span>
<span class="nc" id="L1167">				i++;</span>
			}
<span class="nc" id="L1169">		} else {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">			Date firstDayInDayData = dayData[0] != null ? dayData[0].getDate(): null;</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">			ignoreFirstElem =firstDayInDayData!=null&amp;&amp; firstDayInDayData.before(startDate);</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">			tempDayData = ignoreFirstElem ? new TOCalendarDayData[dayData.length - 1] : new TOCalendarDayData[dayData.length];</span>
		}
<span class="nc bnc" id="L1174" title="All 2 branches missed.">		if(ignoreFirstElem) {</span>
<span class="nc" id="L1175">			m_cat.info(&quot;IGNORED ROW &quot;+dayData[0]);</span>
		}
		//now add the new day data
		
<span class="nc bnc" id="L1179" title="All 6 branches missed.">		for (int j = ignoreFirstElem ? 1 : 0; dayData != null &amp;&amp; j &lt; dayData.length; j++) {</span>
<span class="nc" id="L1180">			tempDayData[i++] = dayData[j];</span>
		}
<span class="nc" id="L1182">		return tempDayData;</span>
	}
	
	/**
	 * Return an array of
	 * {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData}
	 * objects that contain time off calendar data for employees in the given organization. The
	 * optional empID input is the employee id of a supervisor for the organization. If it is not
	 * null, then the interest set of employees is all employees in the organization that the
	 * given supervisor supervises. If the supervisor id is null, then the interest set is
	 * all the employees in the organization.
	 * &lt;p/&gt;
	 * The returned TOCalendarDayData objects contain, for each organization day in the range:
	 * - the allocated hours for the organization,
	 * - the pending hours (first choice only) for the employees in the interest set
	 * - the hours scheduled in time off events for the employees in the interest set
	 * - the hours remaining for the organization =(allocated - scheduled)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the
	 * scheduled time off for all employees in the organization) for each day in the range.
	 *
	 * @param orgID     the organization id
	 * @param startDate the beginning of the range. This is the beginning of an organization day
	 *                  in the organization's local time zone.
	 * @param endDate   the end of the range.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public static TOCalendarDayData[] getTOCalendarForManager(ID orgID, ID pTOPoolID, Collection orgEmpIDs, Date startDate, Date endDate)
			throws BbmFinderException {
<span class="nc" id="L1212">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1213">		long empSize = 0;</span>
		try {
<span class="nc" id="L1215">			Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L1216">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(startDate);</span>
<span class="nc" id="L1217">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L1218">			Set interestSetEmpIDs = new HashSet();</span>
<span class="nc" id="L1219">			Set pTOPoolEmpIDs = new HashSet();</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">			if (pTOPoolID != null) {</span>
<span class="nc" id="L1221">				interestSetEmpIDs.addAll(toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, endDate));</span>
<span class="nc" id="L1222">				pTOPoolEmpIDs = interestSetEmpIDs;</span>
			} else {
<span class="nc" id="L1224">				interestSetEmpIDs.addAll(orgEmpIDs);</span>
			}
<span class="nc" id="L1226">			empSize = interestSetEmpIDs.size();</span>
<span class="nc" id="L1227">			TimeRange range = new TimeRange(startDate, endDate);</span>
<span class="nc" id="L1228">			return getTOCalendar(false, interestSetEmpIDs, pTOPoolEmpIDs, pTOPoolID, org, range);</span>
<span class="nc" id="L1229">		} catch (Exception e) {</span>
<span class="nc" id="L1230">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1232" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1233">				m_cat.debug(&quot;TOTAL TIME FOR CAL=&quot; + (new Date().getTime() - currentime) + &quot; : TOTAL EMPS=&quot; + empSize);</span>
			}
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>