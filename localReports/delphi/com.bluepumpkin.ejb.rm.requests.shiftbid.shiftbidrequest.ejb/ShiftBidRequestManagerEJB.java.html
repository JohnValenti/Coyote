<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb</a> &gt; <span class="el_source">ShiftBidRequestManagerEJB.java</span></div><h1>ShiftBidRequestManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.TimeZone;

import org.apache.log4j.Level;
import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ShiftAssignmentDAO;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.core.filterconfig.model.Filter;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmAggregateException;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.SerializedAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuctionFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleInstance;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableShift;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.MultiShiftBidException;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestBiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidderFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.UnsubmittedShiftBidPreference;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AgentSchedulesInSPNotChangeHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AuctionIsValidHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleDoesNotAllowOvertimeHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleDoesNotOverlapShiftAssignmentsHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleFollowsWorkPatternHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.BiddableScheduleSingleActivityShiftAssignmentsHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.CalendarEventsValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxBidsPerEmployeeNotExceededHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxConsecutiveDaysForSBReqHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MaxShiftBlocksPerBidNotExceededHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.MinMaxHoursPerDayHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoApprovedShiftBidRequestsForBidderHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoMultipleShiftAssignmentsForADayHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoShiftBidRequestDuplicateNamesHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.NoShiftsForBidderDuringSPHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.RequestBiddableSchedulesAreValidHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidRequestMeetDeadlineHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidRequestNoDuplicatesHV;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.ShiftBidderInGoodStandingHV;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.Base58;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;


/**
 *
 * see {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager ShiftBidAuctionManager}
 * for a description of the shift bidding process.
 *
 * Title:        ShiftBidRequestManagerEJB
 * Description:  EJB for ShiftBidRequest
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Jagdish Seelam
 * @version 1.0
 */
<span class="nc bnc" id="L123" title="All 2 branches missed.">public class ShiftBidRequestManagerEJB extends RequestAggregateManager  { //OUTSIDE_CONTAINER</span>
//public class ShiftBidRequestManagerEJB extends RequestAggregateManager implements ShiftBidRequestManager { //OUTSIDE_CONTAINER
<span class="nc" id="L125">    private static final String COLNAME_SHIFTBIDREQUEST_SHIFTBIDAUCTIONID =</span>
        ShiftBidRequestFieldInfo.m_strTableName + '.' + ShiftBidRequestFieldInfo.COLNAME_AUCTIONID;

<span class="nc" id="L128">    private static final String COLNAME_SHIFTBIDREQUEST_SHIFTBIDDERID =</span>
        ShiftBidRequestFieldInfo.m_strTableName + '.' + ShiftBidRequestFieldInfo.COLNAME_SHIFTBIDDERID;

    private static final String COLNAME_SHIFTBIDDER_ID = ShiftBidderFieldInfo.m_strTableName + &quot;.ID&quot;;

<span class="nc" id="L133">    private static final String COLNAME_SHIFTBIDDER_DEADLINE =</span>
        ShiftBidderFieldInfo.m_strTableName + '.' + ShiftBidderFieldInfo.COLNAME_DEADLINE;

<span class="nc" id="L136">    private static final String COLNAME_PREFERENCE =</span>
        ShiftBidRequestFieldInfo.m_strTableName + &quot;.&quot; + ShiftBidRequestFieldInfo.COLNAME_PREFERENCE;

<span class="nc" id="L139">	private static final String COLNAME_SHIFTBIDDER_BONUSTHISAUCTION =</span>
		ShiftBidderFieldInfo.m_strTableName + '.' + ShiftBidderFieldInfo.COLNAME_BONUSTHISAUCTION;

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

	public static final String COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS = TABLE_EMPLOYEEAM_ALIAS + &quot;.ASSIGNEDPOINTS&quot;;

	public static final String COLNAME_EMPLOYEEAM_RANK = &quot;EMPLOYEERANK.RANK&quot;;

	public static final String COLNAME_EMPLOYEEAM_STARTTIME = TABLE_EMPLOYEEAM_ALIAS + &quot;.STARTTIME&quot;;

<span class="nc" id="L150">	public static final String COLNAME_SHIFTBIDAUCTION_ID =</span>
		ShiftBidAuctionFieldInfo.m_strTableName + &quot;.ID&quot;;

<span class="nc" id="L153">    private static final String m_className = ShiftBidRequestManagerEJB.class.getName();</span>

<span class="nc" id="L155">    private static final Category m_cat = Log.initCategory(m_className);</span>


    // states for which soft validations are performed
//    private static final Collection m_softValidationStates = Arrays.asList(
//        new String[] {
//            RequestAuditTrail.STATUS_PENDING,
//            RequestAuditTrail.STATUS_ESCALATED
//        });

<span class="nc" id="L165">    public static final List m_possibleStates = RequestAuditTrail.SBR_POSSIBLE_STATES;</span>

<span class="nc" id="L167">    protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
        // this must be run before most other rules as without a valid biddable schedule
        // the other validators will certainly fail.
<span class="nc" id="L170">        new ValidatorDescriptor(RequestBiddableSchedulesAreValidHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L172">        new ValidatorDescriptor(AuctionIsValidHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFTBID_AUCTION),
        // Must be run after AuctionIsValidHV.java as the expiration date is set by this rule.
<span class="nc" id="L175">        new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L177">        new ValidatorDescriptor(MaxBidsPerEmployeeNotExceededHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftBidRequest.DL_BASIC ), //validator needs just the auctionID and shiftBidderID.
// Commented as org holidays are not used by DE for scheduling yet.  Decided after an e-mail discussion.
//        new HardValidatorDescriptor(BiddableSchedOrgHolidayNoOverlapHV.class.getName(), RequestUtil.METHODTYPE_ALL,
//            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L182">        new ValidatorDescriptor(AgentSchedulesInSPNotChangeHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
                ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L184">        new ValidatorDescriptor(BiddableScheduleDoesNotOverlapShiftAssignmentsHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L186">        new ValidatorDescriptor(BiddableScheduleSingleActivityShiftAssignmentsHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
                ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L188">        new ValidatorDescriptor(BiddableScheduleFollowsWorkPatternHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC ),
<span class="nc" id="L190">        new ValidatorDescriptor(CalendarEventsValidationRuleHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL),
<span class="nc" id="L192">        new ValidatorDescriptor(ShiftBidderInGoodStandingHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_EMPLOYEE),
<span class="nc" id="L194">        new ValidatorDescriptor(ShiftBidRequestNoDuplicatesHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_BIDDABLESCHEDULE_IDS),
<span class="nc" id="L196">        new ValidatorDescriptor(MinMaxHoursPerDayHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL | ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L198">        new ValidatorDescriptor(BiddableScheduleDoesNotAllowOvertimeHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
                ShiftBidRequest.DL_BASIC ),
<span class="nc" id="L200">        new ValidatorDescriptor(NoMultipleShiftAssignmentsForADayHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
                ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL | ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L202">        new ValidatorDescriptor(NoShiftsForBidderDuringSPHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC |ShiftBidRequest.DL_SHIFTBID_AUCTION),
<span class="nc" id="L204">        new ValidatorDescriptor(NoApprovedShiftBidRequestsForBidderHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            ShiftBidRequest.DL_BASIC),
<span class="nc" id="L206">        new ValidatorDescriptor(NoShiftBidRequestDuplicateNamesHV.class.getName(),</span>
            RequestUtil.METHODTYPE_CREATOR | RequestUtil.METHODTYPE_MODIFIER, null, ShiftBidRequest.DL_BASIC),
<span class="nc" id="L208">        new ValidatorDescriptor(ShiftBidRequestMeetDeadlineHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftBidRequest.DL_BASIC),
<span class="nc" id="L210">        new ValidatorDescriptor(MaxShiftBlocksPerBidNotExceededHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
                ShiftBidRequest.DL_BASIC ),
<span class="nc" id="L212">        new ValidatorDescriptor(MaxConsecutiveDaysForSBReqHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
        		ShiftBidRequest.DL_BASIC)
    };

<span class="nc" id="L216">    private final static ValidatorDescriptor[] m_softValidatorDescMandArr = {</span>
    };

    {
<span class="nc" id="L220">        super.init( ShiftBidRequestManagerEJB.class.getName() );</span>
<span class="nc" id="L221">    }</span>

    /** override the base class to provide the appropriate logging category */
    @Override
	protected Category getCategory() {
<span class="nc" id="L226">        return m_cat;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#getPossibleStates()
     */
    @Override
	public List getPossibleStates() {
<span class="nc" id="L234">        return m_possibleStates;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getDAO()
     */
    @Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L242">        return new ShiftBidRequestDAO(detailLevel);</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getHardValidatorNames()
     */
    @Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L250">        return m_hardValidatorDescriptorArr;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
     */
    @Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L258">        return m_softValidatorDescMandArr;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
     */
    @Override
	protected IRequestType getRequestManager() throws Exception {
        //TODO: should we pass nulls or the user credentials?
<span class="nc" id="L267">        return RequestUtil.getShiftBidRequestManager(null, null);</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidationStates()
     */
//    protected Collection getSoftValidationStates() {
//        return ShiftBidRequest.getSoftValidationStates();
//    }

//    /* (non-Javadoc)
//     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#validNewState(java.lang.String)
//     */
//    protected void validNewState(String newState) throws {
//        //RequestAuditTrail.STATUS_ESCALATED is not a valid state for shiftbid requests.
//        if (newState.equals(RequestAuditTrail.STATUS_INVALID) ||
//                newState.equals(RequestAuditTrail.STATUS_PENDING) ||
//                newState.equals(RequestAuditTrail.STATUS_WITHDRAWN) ||
//                newState.equals(RequestAuditTrail.STATUS_APPROVED) ||
//                newState.equals(RequestAuditTrail.STATUS_DENIED) ||
//                newState.equals(RequestAuditTrail.STATUS_TENTATIVE))
//            return;
//
//        throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_REQUEST_STATUS,
//            new Object[] { newState }, m_cat );
//    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
     */
    @Override
	protected String getRequestType() {
<span class="nc" id="L299">        return Request.REQUESTTYPE_SHIFTBID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToSelectColumns(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
     */
    @Override
	public void addToSelectColumns(StringBuffer selectClause, RequestFilter requestFilter, int sortColumn){

        // DIRECT_DB_ACCESS
        // Add columns specified in the SORT clause.
<span class="nc bnc" id="L310" title="All 2 branches missed.">        if (sortColumn == Request.SORT_SHIFTBID_PREFERENCE)</span>
<span class="nc" id="L311">            selectClause.append(&quot;, SHIFTBIDREQUEST.PREFERENCE &quot;);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">        else if (sortColumn == Request.SORT_SHIFTBID_ISBONUSUSED)</span>
<span class="nc" id="L313">            selectClause.append(&quot;, SHIFTBIDREQUEST.ISBONUSUSED &quot;);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">        else if (sortColumn == Request.SORT_SHIFTBID_SENIORITY)</span>
<span class="nc" id="L315">            selectClause.append(&quot;, &quot;).append(COLNAME_EMPLOYEEAM_STARTTIME).append(' ');</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">        else if (sortColumn == Request.SORT_SHIFTBID_POINTS)</span>
<span class="nc" id="L317">            selectClause.append(&quot;, &quot;).append(COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS).append(' ');</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">        else if (sortColumn == Request.SORT_SHIFTBID_BIDDERBONUS)</span>
<span class="nc" id="L319">            selectClause.append(&quot;, SHIFTBIDDER.BONUSTHISAUCTION &quot;);</span>

		// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
		// used as the secondary sort key irrespective of the primary sort key used.
		// (needed for group approvals; see javadoc for addOrderByClause()).
		//
		// If PREFERENCE column already added, do not add again
<span class="nc bnc" id="L326" title="All 2 branches missed.">		if (sortColumn != Request.SORT_SHIFTBID_PREFERENCE) {</span>
<span class="nc" id="L327">			selectClause.append(&quot;, &quot;).append(ShiftBidRequestFieldInfo.m_strTableName).</span>
<span class="nc" id="L328">				append('.').append(ShiftBidRequestFieldInfo.COLNAME_PREFERENCE).append(' ');</span>
		}

<span class="nc" id="L331">    }</span>

    /**
     * {@link RequestFilter#BID_DEADLINE_KEY BID_DEADLINE_KEY}: join ShiftBidRequest, ShiftBidder&lt;br&gt;
     * {@link RequestFilter#BID_PREF_KEY BID_PREF_KEY}: join ShiftBidRequest. &lt;br&gt;
     * {@link RequestFilter#BID_REQUESTED_DAY BID_REQUESTED_DAY}: done by
     * {@link #filterReqAggUsingReqFilter(RequestAggregate, RequestFilter) filterReqAggUsingReqFilter} method.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToFromClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
     */
    @Override
	public void addToFromClause(StringBuffer fromClause, RequestFilter reqFilter, int sortColumn)  {

		// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
		// used as the secondary sort key irrespective of the primary sort key used.
		// (needed for group approvals; see javadoc for addOrderByClause()).
<span class="nc" id="L347">        boolean joinSBReqTable = true;</span>

<span class="nc" id="L349">        boolean joinShiftBidderTable = false;</span>


<span class="nc bnc" id="L352" title="All 3 branches missed.">        switch (sortColumn) {</span>
            // if sorting by fields in shift bid request, then join table.
            case Request.SORT_SHIFTBID_ISBONUSUSED:
            case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L356">                joinSBReqTable = true;</span>
<span class="nc" id="L357">                break;</span>
            case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L359">                joinSBReqTable = true;</span>
<span class="nc" id="L360">                joinShiftBidderTable = true;</span>
                break;
            //Note: EMPLOYEEAM table, needed for sorting SBReqs by SENIORITY, RANK and POINTS, is already 'joined' with
            // the 'request' table in CommonReqMgr.getSelectFromWhereOrderByClause().
            //case Request.SORT_SHIFTBID_SENIORITY:
            //case Request.SORT_SHIFTBID_RANK:
            //case Request.SORT_SHIFTBID_POINTS:
            //    break;
        }

        // Filter by the shift bidder deadline date
<span class="nc bnc" id="L371" title="All 2 branches missed.">        if (reqFilter.isKeySet(RequestFilter.BID_DEADLINE_KEY)) {</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (!reqFilter.isKeySet(RequestFilter.BID_DEADLINE_OPERATOR_KEY))</span>
<span class="nc" id="L373">                throw new IllegalArgumentException(&quot;RequestFilter.BID_DEADLINE_KEY cannot be set without specifiying RequestFilter.BID_DEADLINE_OPERATOR_KEY as well&quot;);</span>

            // SHIFTBIDDER table needed to use SHIFTBIDDER.DEADLINE in the 'where' clause
<span class="nc" id="L376">            joinShiftBidderTable = true;</span>
<span class="nc" id="L377">            joinSBReqTable = true;  //need sbReq.shiftBidderID column to join with shiftBidder table</span>
        }

        // filter by shift bid request's preference key.
<span class="nc bnc" id="L381" title="All 2 branches missed.">        if (reqFilter.isKeySet(RequestFilter.BID_PREF_KEY)) {</span>
<span class="nc" id="L382">            joinSBReqTable = true;</span>
        }

<span class="nc bnc" id="L385" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_BONUS_KEY)) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.BID_BONUS_OPERATOR_KEY)) {</span>
<span class="nc" id="L387">				throw new IllegalArgumentException(RequestFilter.BID_BONUS_OPERATOR_KEY);</span>
			}

<span class="nc" id="L390">			joinShiftBidderTable = true;</span>
<span class="nc" id="L391">			joinSBReqTable = true;  //need sbReq.shiftBidderID column to join with shiftBidder table</span>
		}

<span class="nc bnc" id="L394" title="All 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.BID_POINTS_KEY)) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">			if ( !reqFilter.isKeySet(RequestFilter.BID_POINTS_OPERATOR_KEY)) {</span>
<span class="nc" id="L396">				throw new IllegalArgumentException(RequestFilter.BID_POINTS_OPERATOR_KEY);</span>
			}

			// the points column belongs to employeeAM table which is always included in the 'from'
			// clause for the query.  See CmnReqMgr.getReqsForMgr().
		}

        //RequestFilter.BID_REQUESTED_DAY_KEY implemented by filterReqAggUsingReqFilter() method.

<span class="nc" id="L405">        fromClause.append(&quot;, &quot;).append(ShiftBidAuctionFieldInfo.m_strTableName);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">        fromClause = (joinSBReqTable)?fromClause.append(&quot;, &quot; + ShiftBidRequestFieldInfo.m_strTableName):fromClause;</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">        fromClause = (joinShiftBidderTable)?fromClause.append(&quot;, &quot; + ShiftBidderFieldInfo.m_strTableName):fromClause;</span>
<span class="nc" id="L408">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addToWhereClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
     */
    @Override
	public void addToWhereClause(StringBuffer whereClause, RequestFilter reqFilter, int sortColumn)
    	throws RmException, RmHardValidationException {
        try {
            //QA 95168 Request must be within range of filter start and end dates, which are always
        	// present because the calendar date picker is always visible on the page. Query must also
        	// take the request employee's organization within the context of the dates
<span class="nc" id="L420">            StringsPair datesPair = RmFilterUtil.getStartAndEndDates(reqFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>

<span class="nc" id="L422">            Date dtNow = new Date();</span>
<span class="nc" id="L423">    		String strDtNow = JdmoUtil.formatDBString(dtNow);</span>

<span class="nc" id="L425">            whereClause.append(&quot; AND &quot;)</span>
<span class="nc" id="L426">                       .append(COLNAME_SHIFTBIDAUCTION_ID).append(&quot;=&quot;).append(COLNAME_SHIFTBIDREQUEST_SHIFTBIDAUCTIONID)</span>
<span class="nc" id="L427">        	           .append(&quot; AND &quot;);</span>
<span class="nc" id="L428">		    RmUtil.appendRequestDateRangeClauses(whereClause, &quot;&quot;, ShiftBidAuctionFieldInfo.m_strTableName,</span>
<span class="nc" id="L429">		    									 datesPair.getKey(), datesPair.getValue(), strDtNow);</span>
<span class="nc" id="L430">		    whereClause.append(&quot; &quot;);</span>
    	    //End #95168

			// If requestFilter type == shift-bid, then SHIFTBIDREQUEST.PREFERENCE must always be
			// used as the secondary sort key irrespective of the primary sort key used.
			// (needed for group approvals; see javadoc for addOrderByClause()).
<span class="nc" id="L436">            boolean sbReqTableJoinFlag = true;</span>

<span class="nc" id="L438">            boolean shiftBidderTableJoinFlag = false;</span>


<span class="nc bnc" id="L441" title="All 3 branches missed.">            switch (sortColumn) {</span>
                // if sorting enabled by shift bid request fields, join the shift bid request table
                case Request.SORT_SHIFTBID_ISBONUSUSED:
                case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L445">                    sbReqTableJoinFlag = true;</span>
<span class="nc" id="L446">                    break;</span>
                case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L448">                    sbReqTableJoinFlag = true;</span>
<span class="nc" id="L449">                    shiftBidderTableJoinFlag = true;</span>
                    break;
            }

            // if sorting
            // Filter by ShiftBidRequest.Preference
<span class="nc bnc" id="L455" title="All 2 branches missed.">            if (reqFilter.isKeySet(RequestFilter.BID_PREF_KEY)) {</span>
                // get the preference value set in the filter.
<span class="nc" id="L457">                Integer pref = (Integer)reqFilter.getValueForKey(RequestFilter.BID_PREF_KEY);</span>
<span class="nc" id="L458">                int prefInt = pref.intValue();</span>

                // need to join the sbReq table to filter by preference
<span class="nc" id="L461">                sbReqTableJoinFlag = true;</span>
                // check if preference filter is 'preferences 5 and above'
<span class="nc bnc" id="L463" title="All 2 branches missed.">                if (prefInt == RequestFilter.BID_PREF_VALUE_FIVEANDABOVE) {</span>
<span class="nc" id="L464">                    whereClause.append(&quot; AND &quot; + COLNAME_PREFERENCE + &quot;&gt;= 5 &quot;);</span>
                } else {
<span class="nc" id="L466">                    whereClause.append(&quot; AND &quot; + COLNAME_PREFERENCE + '=' + pref + ' ');</span>
                }
            }

            // Filter by the shift bidder deadline date: deadline &lt; givenDate; deadline &gt; givenDate or
            // deadline between date1 and date2
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (reqFilter.isKeySet(RequestFilter.BID_DEADLINE_KEY)) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">                if (!reqFilter.isKeySet(RequestFilter.BID_DEADLINE_OPERATOR_KEY))</span>
<span class="nc" id="L474">                    throw new IllegalArgumentException(&quot;RequestFilter.BID_DEADLINE_KEY cannot be set without &quot; +</span>
                        &quot;specifiying RequestFilter.BID_DEADLINE_OPERATOR_KEY as well&quot;);

<span class="nc" id="L477">                sbReqTableJoinFlag = true;</span>
<span class="nc" id="L478">                shiftBidderTableJoinFlag = true;</span>

                // retrieve the bid deadline
<span class="nc" id="L481">                Date bidDeadline = (Date) reqFilter.getValueForKey(RequestFilter.BID_DEADLINE_KEY);</span>

                // get the bid deadline operator
<span class="nc" id="L484">                String bidDeadlineOp = (String) reqFilter.getValueForKey(RequestFilter.BID_DEADLINE_OPERATOR_KEY);</span>

<span class="nc bnc" id="L486" title="All 2 branches missed.">                if (bidDeadlineOp.equals(Filter.LESS_THAN_OPERATION)) {</span>
<span class="nc" id="L487">                    whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; &lt; '&quot; + JdmoUtil.formatDBString(bidDeadline) + '\'');</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">                } else if (bidDeadlineOp.equals(Filter.GREATER_THAN_OPERATION)) {</span>
<span class="nc" id="L489">                    whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; &gt; '&quot; + JdmoUtil.formatDBString(bidDeadline) + '\'');</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">                } else if (bidDeadlineOp.equals(Filter.EQUAL_OPERATION)) {</span>
                    //get the timezone for the logged in employee (manager).
<span class="nc" id="L492">                    ID empID = RequestUtil.getLoginUserBasic(m_sessionContext).getEmployeeID();</span>
<span class="nc" id="L493">                    TimeZone mgrTZ = ValidationUtil.getOrganizationForEmployeeDuringPeriod(</span>
<span class="nc" id="L494">                        empID, bidDeadline, bidDeadline).getTimeZone();</span>

                    // get the dates for midnight to midnight for the bid deadline date in the manager's timezone
<span class="nc" id="L497">                    Date dayBeginForBidDeadline = RequestUtil.getDateForDayEnd(bidDeadline, mgrTZ);</span>
<span class="nc" id="L498">                    Date dayEndForBidDeadline = RequestUtil.getDateForDayEnd(bidDeadline, mgrTZ);</span>

<span class="nc" id="L500">                    whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_DEADLINE + &quot; BETWEEN '&quot; + JdmoUtil.formatDBString(dayBeginForBidDeadline)</span>
<span class="nc" id="L501">                        + &quot;' AND '&quot; + JdmoUtil.formatDBString(dayEndForBidDeadline) + '\'');</span>
<span class="nc" id="L502">                } else {</span>
<span class="nc" id="L503">                    throw new IllegalArgumentException(&quot;Invalid bid deadline operator value: &quot; + bidDeadlineOp);</span>
                }
            }

            //RequestFilter.BID_REQUESTED_DAY_KEY implemented by filterReqAggUsingReqFilter.

            // if filtering by bidder bonus.
<span class="nc bnc" id="L510" title="All 2 branches missed.">            if (reqFilter.isKeySet(RequestFilter.BID_BONUS_KEY)) {</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">				if ( !reqFilter.isKeySet(RequestFilter.BID_BONUS_OPERATOR_KEY)) {</span>
<span class="nc" id="L512">					throw new IllegalArgumentException(RequestFilter.BID_BONUS_OPERATOR_KEY);</span>
				}

<span class="nc" id="L515">				sbReqTableJoinFlag = true;</span>
<span class="nc" id="L516">				shiftBidderTableJoinFlag = true;</span>

<span class="nc" id="L518">				whereClause.append(&quot; AND &quot; + getWhereClauseForFilterKeyWithIntVal(reqFilter, COLNAME_SHIFTBIDDER_BONUSTHISAUCTION,</span>
					RequestFilter.BID_BONUS_OPERATOR_KEY, RequestFilter.BID_BONUS_KEY) );
            }

	        // if filtering by employee accumulated points
<span class="nc bnc" id="L523" title="All 2 branches missed.">	        if (reqFilter.isKeySet(RequestFilter.BID_POINTS_KEY)) {</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">		        if (!reqFilter.isKeySet(RequestFilter.BID_POINTS_OPERATOR_KEY)) {</span>
<span class="nc" id="L525">			        throw new IllegalArgumentException(RequestFilter.BID_POINTS_OPERATOR_KEY);</span>
		        }

<span class="nc" id="L528">		        whereClause.append(&quot; AND &quot; + getWhereClauseForFilterKeyWithIntVal(reqFilter, COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS,</span>
		                RequestFilter.BID_POINTS_OPERATOR_KEY, RequestFilter.BID_POINTS_KEY));
	        }

	        // if filtering by employee rank
<span class="nc bnc" id="L533" title="All 2 branches missed.">	        if (reqFilter.isKeySet(RequestFilter.EMP_RANK_OPERATOR_KEY)) {</span>
<span class="nc" id="L534">		        whereClause.append(&quot;AND &quot;);</span>
<span class="nc" id="L535">		        whereClause.append(getWhereClauseForFilterKeyWithIntVal(reqFilter, &quot;EMPRANK.RANK&quot;, RequestFilter.EMP_RANK_OPERATOR_KEY, RequestFilter.EMP_RANK_KEY));</span>
	        }

<span class="nc bnc" id="L538" title="All 2 branches missed.">	        if (sbReqTableJoinFlag)</span>
<span class="nc" id="L539">		        whereClause.append(&quot; AND REQ.ID = SHIFTBIDREQUEST.ID &quot;);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">	        if (shiftBidderTableJoinFlag)</span>
<span class="nc" id="L541">		        whereClause.append(&quot; AND &quot; + COLNAME_SHIFTBIDDER_ID + &quot; = &quot; + COLNAME_SHIFTBIDREQUEST_SHIFTBIDDERID);</span>

<span class="nc" id="L543">        } catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L550">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L551">			throw e;</span>
<span class="nc" id="L552">		} catch (RmException e) {</span>
<span class="nc" id="L553">			m_cat.error(e, e);</span>
<span class="nc" id="L554">			handleException(e);</span>
<span class="nc" id="L555">			throw e;</span>
<span class="nc" id="L556">        } catch (Exception e) {</span>
<span class="nc" id="L557">			handleException(e);</span>
<span class="nc" id="L558">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
<span class="nc" id="L559">        }</span>
<span class="nc" id="L560">    }</span>

    /**
	 * @param reqFilter
	 * @param colname_shiftbidder_bonusthisauction
	 * @param string
	 * @param string2
	 * @return
	 */
	private String getWhereClauseForFilterKeyWithIntVal(RequestFilter reqFilter,
		String columnName, String operatorKey, String filterKey) {

		// translate filter opeartor to SQL operator.
<span class="nc" id="L573">		String filtOperatorVal = (String) reqFilter.getValueForKey(operatorKey);</span>
<span class="nc" id="L574">		String sqlOperator = null;</span>
<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (filtOperatorVal.equals(Filter.LESS_THAN_OPERATION)) {</span>
<span class="nc" id="L576">			sqlOperator = &quot; &lt; &quot;;</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">		} else if (filtOperatorVal.equals(Filter.EQUAL_OPERATION)) {</span>
<span class="nc" id="L578">			sqlOperator = &quot; = &quot;;</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">		} else if (filtOperatorVal.equals(Filter.GREATER_THAN_OPERATION)) {</span>
<span class="nc" id="L580">			sqlOperator = &quot; &gt; &quot;;</span>
		} else {
<span class="nc" id="L582">			throw RequestUtil.createIllegalArgumentException(filtOperatorVal, m_cat);</span>
		}

		// get value of filter key.
<span class="nc" id="L586">		Integer filtKeyValInt = (Integer) reqFilter.getValueForKey(filterKey);</span>

		// get where clause: columnName + operator + valueOfFilterKey
<span class="nc" id="L589">		return columnName + &quot; &quot; + sqlOperator + &quot; &quot; + filtKeyValInt.toString();</span>
	}

	/**
     * &lt;p&gt; if fetching reqs of type 'shiftbidreqs', automatically add 'preference' as the
     * secondary sort key.  This is necessary for group processing of shiftbidreqs as
     * the req with the highest 'preference' in a group of requests, with the same value for the
     * primary sort key, for an employee, must be group processed (approval process) first.
	 *
     * &lt;p&gt; For example, if sorting by rank as the primary sort key and if an employee has submitted
     * 4 reqs, then the req with the highest priority must be approved first when performing
     * group approval.
	 *
     * &lt;p&gt; Note: it is guaranteed that the 'order by' phrase has already been added to the
     * 'query' since the reqs are always sorted by a primary key.  So we do not have be
     * concerned about adding or not adding the 'order by' clause
	 *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addOrderByClause(java.lang.StringBuffer, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, java.lang.String)
     */
    @Override
	public void addOrderByClause(StringBuffer orderByClause, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc" id="L610">        final String orderByPhrase = &quot; ORDER BY &quot;;</span>

        // flag to indicate if an &quot;ORDER BY&quot; cluase was added during processing.
<span class="nc" id="L613">        boolean orderByClauseAdded = true;</span>
<span class="nc bnc" id="L614" title="All 6 branches missed.">		switch (sortColumn) {</span>
            case Request.SORT_SHIFTBID_PREFERENCE:
<span class="nc" id="L616">                orderByClause.append(&quot; ORDER BY SHIFTBIDREQUEST.PREFERENCE &quot;).append(sortDir);</span>
<span class="nc" id="L617">                break;</span>
            case Request.SORT_SHIFTBID_ISBONUSUSED:
<span class="nc" id="L619">                orderByClause.append(&quot; ORDER BY SHIFTBIDREQUEST.ISBONUSUSED &quot;).append(sortDir);</span>
<span class="nc" id="L620">                break;</span>
            case Request.SORT_SHIFTBID_SENIORITY:
                //DIRECT_DB_ACCESS
<span class="nc" id="L623">                orderByClause.append(orderByPhrase).append(COLNAME_EMPLOYEEAM_STARTTIME).append(' ').append(invertSortDir(sortDir));</span>
<span class="nc" id="L624">                break;</span>
            case Request.SORT_SHIFTBID_POINTS:
                //DIRECT_DB_ACCESS
<span class="nc" id="L627">                orderByClause.append(orderByPhrase).append(COLNAME_EMPLOYEEAM_ASSIGNEDPOINTS).append(' ').append(sortDir);</span>
<span class="nc" id="L628">                break;</span>
            case Request.SORT_SHIFTBID_BIDDERBONUS:
<span class="nc" id="L630">                orderByClause.append(&quot; ORDER BY SHIFTBIDDER.BONUSTHISAUCTION &quot;).append(sortDir);</span>
<span class="nc" id="L631">				break;</span>
			default:
<span class="nc" id="L633">				orderByClauseAdded = false;</span>
		}

		// see javadoc for an explanation as to why this is done.
		//
		// do not add the 'PREFERENCE' column again if already added.
		// do not add the secondary sort if sorting by 'PREFERENCE' (inmemory sort).
<span class="nc bnc" id="L640" title="All 6 branches missed.">		if ((orderByClauseAdded || sortColumn &gt; 0) &amp;&amp; sortColumn != Request.SORT_SHIFTBID_PREFERENCE) {</span>
<span class="nc" id="L641">			orderByClause.append(&quot;, &quot;).append(ShiftBidRequestFieldInfo.m_strTableName).</span>
<span class="nc" id="L642">			        append('.').append(ShiftBidRequestFieldInfo.COLNAME_PREFERENCE).</span>
<span class="nc" id="L643">			        append(&quot; &quot;).append(RequestUtil.SORTDIR_ASC);</span>
		}
<span class="nc" id="L645">	}</span>

//    public RequestAggregate filterReqAggUsingReqFilter(RequestAggregate reqAgg, RequestFilter reqFilter) throws RmException {
//        try {
//            // check if any one of request's shift assignments falls on the given day.
//            if (reqFilter.isKeySet(RequestFilter.BID_REQUESTED_DAY_KEY)) {
//                int dayOfWeekFromFilter =
//                    ((Integer)reqFilter.getValueForKey(RequestFilter.BID_REQUESTED_DAY_KEY)).intValue();
//
//                ShiftBidRequest sbReq = (ShiftBidRequest) reqAgg;
//                m_cat.debug(&quot;Filter shiftbid request for dayOfWeek: id, dayofweek: &quot; + sbReq.getID() + ',' + dayOfWeekFromFilter);
//
//                // get timeZone for the org the 'loggedIn' employee (the manager) belongs to.
//                ID mgrID = RequestUtil.getLoginUser().getEmployeeID();
//                //ID mgrID = new ID(2); //uncomment for unit test outside container
//                Date curTime = new Date();
//                TimeZone mgrTZ = ValidationUtil.getOrganizationForEmployeeDuringPeriod(mgrID,curTime, curTime).getTimeZone();
//
//                Calendar cal = Calendar.getInstance(mgrTZ);
//
//                // iterate thru' shift assignments and find if any satisfies the filter.
//                List shiftAssns = sbReq.getOptMethods().getShiftAssignments();
//                boolean shiftAssnFound = false;
//                for (Iterator shiftAssnsIter = shiftAssns.iterator(); shiftAssnsIter.hasNext();) {
//                    ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsIter.next();
//
//                    // does day of week for shift assignment match the filter's day of week?
//                    cal.setTime(shiftAssn.getStartTime()); cal.getTime(); //force field evaluation
//                    if (cal.get(Calendar.DAY_OF_WEEK) == dayOfWeekFromFilter) {
//                        m_cat.debug(&quot;Filter match. ShiftAssignment falls on dayOfWeek: ID &quot; + shiftAssn.getID());
//                        shiftAssnFound = true;
//                        break;
//                    }
//                }
//                // if no shift assignment satisfies the filter, return null.
//                if (!shiftAssnFound) {
//                    m_cat.debug(&quot;Filter did not match. shiftBidReq ID &quot; + sbReq.getID());
//                    return null;
//                }
//            }
//
//            // request satisfies filter conditions.
//            return reqAgg;
//        } catch (Exception e) {
//            t_hrow RequestUtil.createRmExceptionWrapper(e, m_cat);
//        }
//    }

    /**
     *
     * used to filter and sort request IDs for CmReqManager.getRequestsForManager() API.  Does filtering and sorting
     * that cannot be done at the SQL level (For example, RequestFilter.BID_REQUESTED_DAY_KEY).
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#applyFilterAndSortCriteriaForRequests(java.util.List, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, int)
     *
     * @param mgrEmpID empID of manager on behalf of whom requests are being fetched.
     * @param reqIDsSorted list of reqIDs for which filtering and sorting needs to be applied.  &lt;b&gt; This list
     * may already be sorted and hence the list ordering must be preserved by this method for the
     * returned list of request IDs. &lt;/b&gt;
     * @param reqFilter
     * @param sortColumn
     * @param inclExpired
     *
     * @param detailLevel
     * @return list of reqIDs after filtering and sorting.
     */
    @Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsSorted, RequestFilter reqFilter,
    		int sortColumn, int sortDir, boolean inclExpired, long detailLevel,
			boolean runSoftValids, boolean runNetStaffingSoftVal) throws RmException, RmHardValidationException {

<span class="nc" id="L716">        String _method_ = &quot;applyFilterAndSortCriteriaForRequests&quot;;</span>
<span class="nc" id="L717">        methodStart(_method_, reqIDsSorted, reqFilter, new Integer(sortColumn), new Integer(sortDir));</span>

<span class="nc" id="L719">        ShiftBidRequestDAO sbrDAO = null;</span>
<span class="nc" id="L720">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L721">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L723">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L725">			super.applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsSorted, reqFilter, sortColumn, sortDir, inclExpired, detailLevel,  runSoftValids, runNetStaffingSoftVal);</span>

<span class="nc" id="L727">            boolean filterByReqDay = reqFilter.isKeySet(RequestFilter.BID_REQUESTED_DAY_KEY);</span>
<span class="nc" id="L728">            boolean filterByBidderScore = reqFilter.isKeySet(RequestFilter.BID_SCORE_KEY);</span>
<span class="nc" id="L729">            boolean filterByReqDateRange = reqFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>

<span class="nc bnc" id="L731" title="All 2 branches missed.">            boolean sortByBidderScore = (sortColumn == Request.SORT_SHIFTBID_SCORE);</span>

<span class="nc bnc" id="L733" title="All 6 branches missed.">            boolean filterDoneInThisMethod = filterByReqDay || filterByBidderScore || filterByReqDateRange;</span>
<span class="nc" id="L734">            boolean sortDoneInThisMethod = sortByBidderScore;</span>

            // check if this method needs to do any processing
<span class="nc bnc" id="L737" title="All 4 branches missed.">            boolean needToProcess = filterDoneInThisMethod || sortDoneInThisMethod;</span>
            // if no processing needs to be done, simply return.
<span class="nc bnc" id="L739" title="All 2 branches missed.">            if (!needToProcess) return new Pair(reqIDsSorted,null);</span>

            //set the proper detailLevel (based on the filter and sort criteria).
<span class="nc" id="L742">             detailLevel |=  ShiftBidRequest.DL_BASIC;</span>

<span class="nc bnc" id="L744" title="All 2 branches missed.">            if (inclExpired) detailLevel |= Request.DL_INCLUDE_EXPIRED;</span>

<span class="nc bnc" id="L746" title="All 4 branches missed.">            if (sortByBidderScore || filterByBidderScore)</span>
<span class="nc" id="L747">                detailLevel |= ShiftBidRequest.DL_SCORECOMPUTED_FOR_SHIFTBID_REQUEST;</span>

<span class="nc bnc" id="L749" title="All 4 branches missed.">            if (filterByReqDay || filterByReqDateRange )</span>
<span class="nc" id="L750">                detailLevel |= ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL;</span>

            // Requests are fetched using the DAO, without performing hard validations, for speed.
            // Not performing validations is not an issue since this method is only a part of the processing
            // to fetch sorted request IDs and not requests.  When the requests are actually fetched using the request
            // IDs, the validations are done.
            //sbrDAO = new ShiftBidRequestDAO(detailLevel);
<span class="nc" id="L757">            Collection sbReqs = getRequestsById(reqIDsSorted, false, runSoftValids, runNetStaffingSoftVal, detailLevel);</span>
            //Collection sbReqs = sbrDAO.getRequestsByIDs(reqIDsSorted, detailLevel);

            // compute score for requests
<span class="nc bnc" id="L761" title="All 4 branches missed.">            if (sortByBidderScore || filterByBidderScore) {</span>
<span class="nc" id="L762">                ShiftBidAuctionUtil.computeBonusAndScoreForSBReqs(sbReqs);</span>
            }

            // 3 possible scenarios here:
            //
            // filter &amp;&amp; noSort: filter and sort by applyFilterAndSort()
            // noFilter &amp;&amp; sort: sort by Collections.sort().
            // filter &amp;&amp; sort  : filter by applyFilterAndSort() first; then sort by Collections.sort().
<span class="nc bnc" id="L770" title="All 2 branches missed.">            if (filterDoneInThisMethod) {</span>
				// order the fetched sbReqs collection using the reqIDs collection.

                // create a map for fast lookup
<span class="nc" id="L774">                Map reqIDToSBReqMap = RequestUtil.getMapOfIDsForVOBases(sbReqs);</span>

                // Using a linked list as requests need to be removed from the list during filtering.
                // sbReqs LinkedList ordered by reqIDs collection.
<span class="nc" id="L778">                LinkedList sbReqsLLOrderedByReqIDsColl = new LinkedList();</span>

                // for each request ID.
<span class="nc bnc" id="L781" title="All 2 branches missed.">                for (Iterator iter = reqIDsSorted.iterator(); iter.hasNext(); ) {</span>
                    // find the corr sbReq.
<span class="nc" id="L783">                    Object sbReq = reqIDToSBReqMap.get(iter.next());</span>
                    // add to the ordered collection.
<span class="nc bnc" id="L785" title="All 2 branches missed.">                    if (sbReq != null) {</span>
<span class="nc" id="L786">                        sbReqsLLOrderedByReqIDsColl.add(sbReq);</span>
                    }
<span class="nc" id="L788">                }</span>

<span class="nc" id="L790">                sbReqs = applyRequestFilterForReqs(mgrEmpID, sbReqsLLOrderedByReqIDsColl, reqFilter);</span>
            }

<span class="nc bnc" id="L793" title="All 2 branches missed.">			if (sortDoneInThisMethod) {</span>
				// if filtering not done, then sbReqsList can be null.
<span class="nc" id="L795">				List sbReqsList = RequestUtil.getListFromCollection(sbReqs);</span>
<span class="nc" id="L796">				sortSBReqsByScoreAndPreference(sbReqsList, sortDir);</span>
<span class="nc" id="L797">                sbReqs = sbReqsList;</span>
			}

            //return sorted ID list.
<span class="nc" id="L801">            return new Pair(RequestUtil.getListOfIDsFromVOBases(sbReqs),sbReqs);</span>
<span class="nc" id="L802">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L809">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L810">			throw e;</span>
<span class="nc" id="L811">		} catch (RmException e) {</span>
<span class="nc" id="L812">			m_cat.error(e, e);</span>
<span class="nc" id="L813">			handleException(e);</span>
<span class="nc" id="L814">			throw e;</span>
<span class="nc" id="L815">        } catch (Exception e) {</span>
<span class="nc" id="L816">            handleException(e);</span>
<span class="nc" id="L817">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L819" title="All 6 branches missed.">            if (cacheEnabled) ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc bnc" id="L820" title="All 6 branches missed.">            if (sbrDAO != null) sbrDAO.cleanUp();</span>
<span class="nc" id="L821">            methodFinish();</span>
        }
    }

    /**
     * @param sbReqsList
     * @param sortDir
     */
    private void sortSBReqsByScoreAndPreference(List sbReqsList, int sortDir) {
        // guard against sorting Collections.singleton()
<span class="nc bnc" id="L831" title="All 2 branches missed.">        if (sbReqsList.size() &gt; 1) {</span>
        	//QA 89422 - WFM 7.7.3 - When applying for shift bidding, the system is not assigning shifts as per the scores.
        	//Preference is always sorted ASC, although score is sorted ASC or DESC

            //Collections.sort(sbReqsList,
            //    new ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScoreAndPref(null, false));

            // TODO: when sorting by 'score' (primary sort key) in descending order, the secondary
            // sort (on preference) must still be in ascending order.  This implementation, if
            // descending sort is specified, sorts by descending order on both the primary and
            // secondary key.
<span class="nc bnc" id="L842" title="All 2 branches missed.">            if (sortDir == SupportNavigation.SORT_DESCENDING) {</span>
                //RequestUtil.getListReversed(sbReqsList);
<span class="nc" id="L844">            	Collections.sort(sbReqsList,</span>
                        new ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScoreAndPrefDESC(null, false));
            } else {
<span class="nc" id="L847">            	Collections.sort(sbReqsList,</span>
                        new ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScoreAndPrefASC(null, false));
            }
            //End #89422
        }
<span class="nc" id="L852">    }</span>

    /**
     * Filters the given request collection using the filter conditions specified in the request filter.
     * This method:
     * &lt;li&gt; removes requests from the parameter sbReqsLL collection.
     * &lt;li&gt; Returns the requests which satisfy the filter condition.
     * &lt;li&gt; returned requests are in the same order as the sbReqsLL collection passed as a parameter.
     *
     * @param reqIDsSorted
     * @param sbReqs
     * @param reqFilter
     */
    private Collection applyRequestFilterForReqs(ID mgrEmpID, LinkedList sbReqsLL,
        RequestFilter reqFilter) throws Exception {

        // if filter key not set, simply return the passed sbReqs
<span class="nc" id="L869">        boolean filterByBID_REQUESTED_DAY = reqFilter.isKeySet(RequestFilter.BID_REQUESTED_DAY_KEY);</span>
<span class="nc" id="L870">        boolean filterByBID_SCORE = reqFilter.isKeySet(RequestFilter.BID_SCORE_KEY);</span>
<span class="nc" id="L871">        boolean filterByREQUEST_DATE_RANGE = reqFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>

<span class="nc bnc" id="L873" title="All 6 branches missed.">        if ( !(filterByBID_REQUESTED_DAY || filterByBID_SCORE || filterByREQUEST_DATE_RANGE) )</span>
<span class="nc" id="L874">            return sbReqsLL;</span>

<span class="nc bnc" id="L876" title="All 2 branches missed.">        if (filterByBID_REQUESTED_DAY) {</span>
<span class="nc" id="L877">            sbReqsLL = applyFilterForBID_REQUESTED_DAY(mgrEmpID, sbReqsLL, reqFilter);</span>
        }

<span class="nc bnc" id="L880" title="All 2 branches missed.">        if (filterByBID_SCORE) {</span>
<span class="nc" id="L881">            sbReqsLL = applyFilterForBID_SCORE(mgrEmpID, sbReqsLL, reqFilter);</span>
        }

<span class="nc bnc" id="L884" title="All 2 branches missed.">        if (filterByREQUEST_DATE_RANGE) {</span>
<span class="nc" id="L885">            sbReqsLL = applyFilterForREQUEST_DATE_RANGE(mgrEmpID, sbReqsLL, reqFilter);</span>
        }

<span class="nc" id="L888">        return sbReqsLL;</span>
    }

    /**
     * @param mgrEmpID
     * @param sbReqsLL
     * @param reqFilter
     * @return
     */
    private LinkedList applyFilterForREQUEST_DATE_RANGE(ID mgrEmpID, LinkedList sbReqsLL, RequestFilter reqFilter) {

        // get the date range from the filter.
<span class="nc" id="L900">        reqFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L901">        List dates = (List) reqFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L902">        Date rangeStartDate = (Date) dates.get(0);</span>
<span class="nc" id="L903">        Date rangeEndDate = (Date) dates.get(1);</span>

<span class="nc bnc" id="L905" title="All 2 branches missed.">        for (Iterator iter = sbReqsLL.iterator(); iter.hasNext(); ) {</span>
            // obtain sbReq corresponding to ID.
<span class="nc" id="L907">            ShiftBidRequest sbReq = (ShiftBidRequest) iter.next();</span>

            // if sbReq not found, continue.
<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (sbReq == null) continue;</span>

            // iterate thru' shift assignments and find if any satisfies the filter.
<span class="nc" id="L913">            List shiftAssns = sbReq.getOptMethods().getShiftAssignments();</span>
	        //the list will  be empy  if the request is approved, which is not correct.
	        // So put a hack to ignore the request with not Shift assignments.
	        //The requests will anyway be filtered based on the Shift bid auction start-end dates.
	        //Sameet Apr 2007 SILK#92886
<span class="nc bnc" id="L918" title="All 4 branches missed.">	        if(shiftAssns==null || shiftAssns.size()==0){</span>
<span class="nc" id="L919">		        continue;</span>
	        }
<span class="nc" id="L921">            boolean overlapFound = false;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">            for (Iterator shiftAssnsIter = shiftAssns.iterator(); shiftAssnsIter.hasNext();) {</span>
<span class="nc" id="L923">                ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsIter.next();</span>

<span class="nc" id="L925">                Date shiftAssnStart = shiftAssn.getStartTime();</span>
<span class="nc" id="L926">                Date shiftAssnEnd = shiftAssn.getEndTime();</span>

                // does day of week for shift assignment match the filter's day of week?
<span class="nc bnc" id="L929" title="All 2 branches missed.">                if (TimePeriodUtil.overlap(rangeStartDate, rangeEndDate, shiftAssnStart, shiftAssnEnd)) {</span>
<span class="nc" id="L930">                    m_cat.debug(&quot;Filter match. ShiftAssignment falls on dayOfWeek: ID &quot; + shiftAssn.getID());</span>
<span class="nc" id="L931">                    overlapFound = true;</span>
<span class="nc" id="L932">                    break;</span>
                }
<span class="nc" id="L934">            }</span>

            // if a shift assignment satisfies the filter, add request to list.
<span class="nc bnc" id="L937" title="All 2 branches missed.">            if ( !overlapFound ) {</span>
<span class="nc" id="L938">                iter.remove();</span>
            }
<span class="nc" id="L940">        }</span>

<span class="nc" id="L942">        return sbReqsLL;</span>
    }

    /**
     * The filtered requests returned must be in the same order as the specified reqIDsSorted collection
     * argument
     *
     * @param mgrEmpID
     * @param reqIDsSorted
     * @param filteredSBReqList
     * @param reqIDToSBReqMap
     * @param reqFilter
     * @return
     */
    private LinkedList applyFilterForBID_SCORE(ID mgrEmpID, LinkedList sbReqsLL,
        RequestFilter reqFilter) {

        // check if the proper filter key is set.
<span class="nc bnc" id="L960" title="All 2 branches missed.">        if ( !reqFilter.isKeySet(RequestFilter.BID_SCORE_KEY) ) {</span>
<span class="nc" id="L961">            throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
        }

        // check if the proper filter key is set.
<span class="nc bnc" id="L965" title="All 2 branches missed.">        if (!reqFilter.isKeySet(RequestFilter.BID_SCORE_OPERATOR_KEY)) {</span>
<span class="nc" id="L966">            throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
        }

        // get score specified in the filter.
<span class="nc" id="L970">        int reqScoreFromFilter = ((Integer) reqFilter.getValueForKey(RequestFilter.BID_SCORE_KEY)).intValue();</span>
        // get score operator specified in the filter.
<span class="nc" id="L972">        String bidderScoreOpFromFilter = (String) reqFilter.getValueForKey(RequestFilter.BID_SCORE_OPERATOR_KEY);</span>

<span class="nc bnc" id="L974" title="All 2 branches missed.">        for (Iterator iter = sbReqsLL.iterator(); iter.hasNext(); ) {</span>
            // obtain sbReq corresponding to ID.
<span class="nc" id="L976">            ShiftBidRequest sbReq = (ShiftBidRequest) iter.next();</span>

            // get score for the request.
<span class="nc" id="L979">            int reqScoreUsingBonusFlag = sbReq.getOptMethods().getScoreUsingIsBonusFlag();</span>

<span class="nc" id="L981">            boolean sbReqSatisfiesFilter = false;</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">            if (bidderScoreOpFromFilter.equals(Filter.LESS_THAN_OPERATION)) {</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">                sbReqSatisfiesFilter = (reqScoreUsingBonusFlag &lt; reqScoreFromFilter)?true:false;</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">            } else if (bidderScoreOpFromFilter.equals(Filter.GREATER_THAN_OPERATION)) {</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                sbReqSatisfiesFilter = (reqScoreUsingBonusFlag &gt; reqScoreFromFilter)?true:false;</span>
<span class="nc bnc" id="L986" title="All 2 branches missed.">            } else if (bidderScoreOpFromFilter.equals(Filter.EQUAL_OPERATION)) {</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">                sbReqSatisfiesFilter = (reqScoreUsingBonusFlag == reqScoreFromFilter)?true:false;</span>
            } else {
<span class="nc" id="L989">                throw RequestUtil.createIllegalArgumentException(bidderScoreOpFromFilter, m_cat);</span>
            }

            // if request does not satisfy filter condition
<span class="nc bnc" id="L993" title="All 2 branches missed.">            if (!sbReqSatisfiesFilter) {</span>
<span class="nc" id="L994">                iter.remove();</span>
            }
<span class="nc" id="L996">        }</span>

<span class="nc" id="L998">        return sbReqsLL;</span>
    }

    /**
     * The filtered requests returned must be in the same order as the reqIDsSorted collection
     * passed as an argument
     *
     * @param mgrEmpID
     * @param reqIDsSorted
     * @param sbReqs
     * @param reqIDToSBReqMap
     * @param reqFilter
     * @return
     * @throws Exception
     */
    private LinkedList applyFilterForBID_REQUESTED_DAY(ID mgrEmpID, LinkedList sbReqsLL,
        RequestFilter reqFilter) throws Exception {

<span class="nc" id="L1016">        int dayOfWeekFromFilter = ((Integer)reqFilter.getValueForKey(RequestFilter.BID_REQUESTED_DAY_KEY)).intValue();</span>

<span class="nc" id="L1018">        Date curTime = new Date();</span>
<span class="nc" id="L1019">        TimeZone mgrTZ = ValidationUtil.getOrganizationForEmployeeDuringPeriod(mgrEmpID, curTime, curTime).getTimeZone();</span>

<span class="nc" id="L1021">        Calendar calForMgrTZ = Calendar.getInstance(mgrTZ);</span>

<span class="nc bnc" id="L1023" title="All 2 branches missed.">        for (Iterator iter = sbReqsLL.iterator(); iter.hasNext(); ) {</span>
            // obtain sbReq corresponding to ID.
<span class="nc" id="L1025">            ShiftBidRequest sbReq = (ShiftBidRequest) iter.next();</span>

            // if sbReq not found, continue.
<span class="nc bnc" id="L1028" title="All 2 branches missed.">            if (sbReq == null) continue;</span>

            // iterate thru' shift assignments and find if any satisfies the filter.
<span class="nc" id="L1031">            List shiftAssns = sbReq.getOptMethods().getShiftAssignments();</span>
<span class="nc" id="L1032">            boolean shiftAssnFound = false;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">            for (Iterator shiftAssnsIter = shiftAssns.iterator(); shiftAssnsIter.hasNext();) {</span>
<span class="nc" id="L1034">                ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsIter.next();</span>

                // does day of week for shift assignment match the filter's day of week?
<span class="nc" id="L1037">                calForMgrTZ.setTime(shiftAssn.getStartTime()); calForMgrTZ.getTime(); //force field evaluation</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">                if (calForMgrTZ.get(Calendar.DAY_OF_WEEK) == dayOfWeekFromFilter) {</span>
<span class="nc" id="L1039">                    m_cat.debug(&quot;Filter match. ShiftAssignment falls on dayOfWeek: ID &quot; + shiftAssn.getID());</span>
<span class="nc" id="L1040">                    shiftAssnFound = true;</span>
<span class="nc" id="L1041">                    break;</span>
                }
<span class="nc" id="L1043">            }</span>

            // if a shift assignment satisfies the filter, add request to list.
<span class="nc bnc" id="L1046" title="All 2 branches missed.">            if ( !shiftAssnFound ) {</span>
<span class="nc" id="L1047">                iter.remove();</span>
            }
<span class="nc" id="L1049">        }</span>

<span class="nc" id="L1051">        return sbReqsLL;</span>
    }


	public  String createShiftsDataList(ShiftBidRequest sbr )throws Exception {
<span class="nc" id="L1056">		ShiftBidAuction sba=RmManagerFactory.getInstance().getShiftBidAuctionManager().getAuctionByID(sbr.getShiftBidAuctionID(), ShiftBidAuction.DL_CAMPAIGN);</span>
<span class="nc" id="L1057">		SchedulingPeriod schedPeriod = sba.getOptMethods().getSP();</span>
<span class="nc" id="L1058">		Collection shifts = sbr.getOptMethods().getShiftAssignments();</span>
<span class="nc" id="L1059">		TimeZone campaignTz = WfmManagerFactory.getCampaignManager().getCampaignByID(schedPeriod.getCampaignID()).getTimeZone();</span>
<span class="nc" id="L1060">		TimeZone userViewingTz =campaignTz;</span>
<span class="nc" id="L1061">		StringBuffer result = new StringBuffer();</span>

<span class="nc" id="L1063">		Localizer localizer = RequestUtil.getLocalizerForAppDefLocale();</span>
<span class="nc" id="L1064">		Locale locale = localizer.getLocaleContext().getRegionalFormatLocale();</span>
<span class="nc" id="L1065">		CalendarRange cRange = new CalendarRange(schedPeriod.getStartTime(), schedPeriod.getEndTime(), userViewingTz, locale);</span>
<span class="nc" id="L1066">		Calendar startCal = cRange.getStartCalendar();</span>
<span class="nc" id="L1067">		Calendar endCal = cRange.getEndCalendar();</span>
<span class="nc" id="L1068">		String dayPatterm = RegionalFormatBundleKey.DATE_NOYEAR_DAYINWEEKFULL_FORMAT;</span>
<span class="nc" id="L1069">		result.append(&quot;&lt;TABLE&gt;&quot;);</span>
<span class="nc" id="L1070">		boolean retVal=false;</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">		while (endCal.after(startCal)) {</span>
<span class="nc" id="L1072">			Date currentDate = startCal.getTime();</span>
<span class="nc" id="L1073">			CalendarRange dayRange = DateTimeUtil.makeDayRange(currentDate, campaignTz);</span>
<span class="nc" id="L1074">			Collection selectedShiftList = RequestUtil.findShifts(dayRange, shifts);</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">			if (!selectedShiftList.isEmpty()) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">				for (Iterator it = selectedShiftList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1077">					ShiftAssignment sa = (ShiftAssignment) it.next();</span>
<span class="nc" id="L1078">					Date startDate = RequestUtil.getDisplayStartTime(sa);</span>
<span class="nc" id="L1079">					Date endDate = sa.getEndTime();</span>
<span class="nc" id="L1080">					String saDisp = RequestUtil.makeShiftDatesString(dayRange, startDate, endDate, localizer, userViewingTz);</span>
<span class="nc" id="L1081">					result.append(&quot;&lt;TR class=\&quot;tblRow\&quot;&gt;&lt;TD&gt;&quot;).append(localizer.formatDate(currentDate, campaignTz, dayPatterm));</span>
<span class="nc" id="L1082">					result.append(&quot;&lt;/TD&gt;&lt;TD&gt;&quot;).append(saDisp).append(&quot;&lt;/TD&gt;&lt;/TR&gt;&quot;);</span>
<span class="nc" id="L1083">					retVal=true;</span>
<span class="nc" id="L1084">				}</span>
			}
<span class="nc" id="L1086">			startCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1087">		}</span>
<span class="nc" id="L1088">		result.append(&quot;&lt;/TABLE&gt;&quot;);</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">		return (retVal?result.toString():&quot;&quot;);</span>
	}

    //TODO: if a biddableScheduleInstance becomes invalid, need to create a new BiddableSchedule and assign
    // the instance to it.
    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String, boolean)
     */
    @Override
	protected void _approveRequest(RequestAggregate reqAgg, ID apprChoiceID, String comment,
                                   boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1100">	    ShiftBidRequestDAO sbrDAO = null;</span>
        try {
<span class="nc" id="L1102">	        m_cat.debug(&quot;Approving request: ID = &quot; + reqAgg.getID());</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">	        comment = ((comment != null) ? comment + &quot;&lt;BR&gt;&quot; : &quot;&quot;) + createShiftsDataList((ShiftBidRequest) reqAgg);</span>
	        //udpate status to approved, validate status transition, check privilege and run hard validations
<span class="nc" id="L1105">	        _updateRequest(reqAgg, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED,</span>
	                suppressPrivilegeChecking, loadedFromDB);

	        // Request refetched,  ignoring the loadedFromDB flag, as the hard validation rule
	        // RequestBiddableSchedulesAreValidHV could have rewired the biddable
	        // schedule instances associated with the biddable request.
<span class="nc" id="L1111">	        long detailLevelForVal = getDetailLevelForValidation();</span>
<span class="nc" id="L1112">	        sbrDAO = new ShiftBidRequestDAO(detailLevelForVal);</span>
<span class="nc" id="L1113">	        ShiftBidRequest sbrFromDB = (ShiftBidRequest) sbrDAO.getRequestByID(reqAgg.getID(), detailLevelForVal);</span>

	        //commenting this since this method always returns only the first available instance of Shift assignment
	        //We need the First free instance
	        //List phanShiftAssns = sbrFromDB.getOptMethods().getShiftAssignments();
<span class="nc" id="L1118">	        List bidSchedList = sbrFromDB.getOptMethods().getBiddableSchedules();</span>
<span class="nc" id="L1119">	        ID bidderEmpID = sbrFromDB.getEmployeeID();</span>
	        // move and publish shift assignments (from phantom to actual employee)
<span class="nc" id="L1121">	        TimeRange dateRange = reqAgg.getValidationCache().getDateRange();</span>
	        //this call has been removed &amp;  moved to persistApprovedSchedDetails
	        //Collection empShiftAssns = RequestUtil.moveShiftAssnsToEmp(phanShiftAssns, bidderEmpID, true,dateRange, true, null);

<span class="nc" id="L1125">	        boolean isMultiShiftBlocks = sbrFromDB.getOptMethods().getShiftBidAuction().getIsMultiShift();</span>

<span class="nc" id="L1127">	        Employee bidderEmp = sbrFromDB.getOptMethods().getEmployee();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">	        int employeePoints = (sbrFromDB.getIsBonusUsed() ? bidderEmp.getAssignedPoints() : 0);</span>
<span class="nc" id="L1129">	        persistApprovedSchedDetails(bidSchedList, dateRange, bidderEmpID, employeePoints, isMultiShiftBlocks);</span>

	        // switch bidder state from &quot;added&quot; to &quot;scheduled&quot;.
<span class="nc" id="L1132">	        ShiftBidder bidder = sbrFromDB.getOptMethods().getShiftBidder();</span>
<span class="nc" id="L1133">	        bidder.getSetters().setStatus(ShiftBidder.STATUS_UNAVAILABLE);</span>

<span class="nc" id="L1135">	        ID bidderID = bidder.getID();</span>

	        // On request approval, reset accumulated bonus for employee
<span class="nc" id="L1138">	        boolean bidderEmpUpdated = false;</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">	        if (sbrFromDB.getIsBonusUsed()) { //if request has &quot;use bonus&quot; set.</span>
		        // On request approval, reset accumulated bonus for employee
<span class="nc" id="L1141">		        m_cat.debug(&quot;Resetting accumulated bonus points to zero: bidderID, empID = &quot; + bidderID + ',' + bidderEmpID);</span>
<span class="nc" id="L1142">		        bidderEmp.setAssignedPoints(0);</span>
<span class="nc" id="L1143">		        bidderEmpUpdated = true;</span>
	        }

            // on request approval, add biddable schedule bonus to employee's bonus.
<span class="nc" id="L1147">            int bonusToBeAwarded = sbrFromDB.getOptMethods().getBonusToBeAwarded();</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">            if (bonusToBeAwarded &gt; 0) {</span>
<span class="nc" id="L1149">                int accumPoints = bidderEmp.getAssignedPoints() + bonusToBeAwarded;</span>
<span class="nc" id="L1150">                m_cat.debug(&quot;Setting accumulated bonus points: bidderID, empID, bonuspoints = &quot; +</span>
                    bidderID + ',' + bidderEmpID + ',' + accumPoints);
<span class="nc" id="L1152">                bidderEmp.setAssignedPoints(accumPoints);</span>
<span class="nc" id="L1153">                bidderEmpUpdated = true;</span>
            }

            // add bidder employee to shift bidder for cascaded update.
<span class="nc bnc" id="L1157" title="All 2 branches missed.">            if (bidderEmpUpdated)</span>
<span class="nc" id="L1158">                bidder.getSetters().updateEmployee(bidderEmp);</span>

            // if the bidder's employee object is added to the udpate list, a cascaded update
            // will be done.
<span class="nc" id="L1162">            ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(sbrFromDB.getShiftBidAuctionID(),</span>
<span class="nc" id="L1163">                Collections.singleton(bidder), null, null);</span>

            // Need to invalidate all other shift bid requests for this employee since an employee
            // can only have one approved shift bid request.  This is automatically done by
            // the hard validator NoApprovedShiftBidRequestForBidderHV.java when the other requests are fetched.
            // invalidateOtherPendingEscalatedReqsForBidder(sbrFromDB, sbrDAO);                               st

            // refetch request as sam.deleteShiftAssignments() above also deletes biddableShifts.  Thus
            // the shift assignments or biddable shifts associated with the shift bid request are no longer valid.
<span class="nc" id="L1172">            sbrFromDB = (ShiftBidRequest) sbrDAO.getRequestByID(reqAgg.getID(), detailLevelForVal);</span>

            // Shift Assns which belong to the firstAvailBidSchedInst were moved from phantom to shift bidder.
            // Find the next available bidSchedInst for the biddable schedules and update BiddableSched.FirstAvailBidSchedInstID.
<span class="nc" id="L1176">            List bidScheds = sbrFromDB.getOptMethods().getBiddableSchedules();</span>

            //Note:  This will remove the biddableScheduleInstances used up by this approval (reassigned
            // from phantom to this bidder) from the biddableSchedle, updates BidSched.numOfAvailInstances and
            // updates BidSched.firstBiddableScheduleInstace.
<span class="nc" id="L1181">            ShiftBidAuctionUtil.validateBiddableScheds(null, bidScheds, sbrFromDB.getDetailLevel(),</span>
                RequestUtil.ACTION_FETCH, false, false);

        } finally  {
<span class="nc bnc" id="L1185" title="All 4 branches missed.">            if (sbrDAO != null) sbrDAO.cleanUp();</span>
        }
<span class="nc" id="L1187">    }</span>


    /*
     * Persist the details of the approved sched since the shift for the phantom will be deleted after
     * being assigned to the employee
     * Steps: Create biddableShifts for each of the shifts in the phantom
     * Assign these shifts to the BiddableScheduleInstance
     * Set status of this instance to assigned
     * Set the number of available instances of the biddableschedule to 0
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    private void persistApprovedSchedDetails(List&lt;BiddableSchedule&gt; bidSchedList, TimeRange dateRange, ID bidderEmpID, int pointsUsed, boolean isMultiShiftBlocks) throws Exception {
<span class="nc" id="L1200">        BiddableScheduleDAO bsDAO = null;</span>
<span class="nc" id="L1201">        BiddableScheduleDAO bsDAO1 = null;</span>
<span class="nc" id="L1202">        BiddableScheduleInstanceDAO bsiDAO = null;</span>
<span class="nc" id="L1203">        ShiftAssignmentDAO shiftAssnDao = null;</span>
        try {
<span class="nc" id="L1205">            bsDAO = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC);</span>

<span class="nc" id="L1207">            bsDAO1 = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC |</span>
                    BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES |
                    BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES);
<span class="nc" id="L1210">            bsiDAO = new BiddableScheduleInstanceDAO(BiddableScheduleInstance.DL_BASIC);</span>

<span class="nc" id="L1212">            shiftAssnDao = new ShiftAssignmentDAO();</span>

<span class="nc" id="L1214">            Collection&lt;BiddableScheduleInstance&gt; allBiddableInstances = new ArrayList&lt;BiddableScheduleInstance&gt;();</span>
<span class="nc" id="L1215">            Set&lt;ID&gt; allEmpShiftAssnIDs = new HashSet&lt;ID&gt;();</span>

<span class="nc bnc" id="L1217" title="All 2 branches missed.">            for (Iterator&lt;BiddableSchedule&gt; it = bidSchedList.iterator(); it.hasNext(); ) {</span>

                // Update BiddableSchedule in memory and database
<span class="nc" id="L1220">                ID firstAvailBidSchedInstanceID = updateBiddableSchedule(bsDAO, bsDAO1, it.next());</span>

                // Retrieve the shift Assignments related to the biddable schedule Instance
<span class="nc" id="L1223">                Collection&lt;ShiftAssignment&gt; phanShiftAssns = getShiftAssignmentsByBiddableScheduleInstanceID(firstAvailBidSchedInstanceID);</span>

                // Update the BidschedInstance in memory (but not to database yet)
<span class="nc" id="L1226">                BiddableScheduleInstance bsi = updateBiddableInstance((BiddableScheduleInstance) bsiDAO.getObjectByID(firstAvailBidSchedInstanceID),</span>
                        bidderEmpID, pointsUsed, isMultiShiftBlocks, phanShiftAssns);
<span class="nc" id="L1228">                allBiddableInstances.add(bsi);</span>

                // Create employee's shift assignments and delete phantom's shift assignments
<span class="nc bnc" id="L1231" title="All 2 branches missed.">                boolean bPublish = !it.hasNext(); // only publish on last iteration of the loop</span>
<span class="nc" id="L1232">                Collection&lt;ShiftAssignment&gt; empShiftAssns = RequestUtil.moveShiftAssnsToEmp(phanShiftAssns, bidderEmpID, bPublish, dateRange, true, null, isMultiShiftBlocks);</span>
<span class="nc" id="L1233">                allEmpShiftAssnIDs.addAll(getIDs(empShiftAssns));</span>

                // Create new BiddableShift (because old BiddableShift was cascade deleted when deleting phantom's shift assignments above)
<span class="nc" id="L1236">                updateBiddableShiftsForBiddableScheduleInstance(firstAvailBidSchedInstanceID, empShiftAssns);</span>
<span class="nc" id="L1237">            }</span>

            // Update (in memory) BidschedInstance's with employee 'final' shift assignment's checksum (to support withdrawal)
<span class="nc bnc" id="L1240" title="All 2 branches missed.">            if (isMultiShiftBlocks) {</span>
<span class="nc" id="L1241">                updateBiddableSchedulesChecksum(allBiddableInstances, shiftAssnDao.getObjectsByIDs(allEmpShiftAssnIDs));</span>
            }

            // Save BidschedInstance's to database
<span class="nc" id="L1245">            bsiDAO.updateObjects(allBiddableInstances);</span>

        } finally {
<span class="nc bnc" id="L1248" title="All 4 branches missed.">            if (shiftAssnDao != null) {</span>
<span class="nc" id="L1249">                shiftAssnDao.cleanUp();</span>
            }
<span class="nc bnc" id="L1251" title="All 4 branches missed.">            if (bsiDAO != null) {</span>
<span class="nc" id="L1252">                bsiDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L1254" title="All 4 branches missed.">            if (bsDAO != null) {</span>
<span class="nc" id="L1255">                bsDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L1257" title="All 4 branches missed.">            if (bsDAO1 != null) {</span>
<span class="nc" id="L1258">                bsDAO1.cleanUp();</span>
            }
        }
<span class="nc" id="L1261">    }</span>

    private Set&lt;ID&gt; getIDs(Collection&lt;? extends ValueObjectBase&gt; vos) {
<span class="nc" id="L1264">        Set&lt;ID&gt; result = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">        for (ValueObjectBase vo : vos) {</span>
<span class="nc" id="L1266">            result.add(vo.getID());</span>
<span class="nc" id="L1267">        }</span>
<span class="nc" id="L1268">        return result;</span>
    }

    private void updateBiddableSchedulesChecksum(Collection&lt;BiddableScheduleInstance&gt; biddableInstances, Collection&lt;ShiftAssignment&gt; allEmpShiftAssns)
            throws IOException {

        // Calculate checksum from shift assignments
<span class="nc" id="L1275">        Map&lt;ShiftAssignment, String&gt; checksums = new HashMap&lt;ShiftAssignment, String&gt;();</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">        for (ShiftAssignment shiftAssn : allEmpShiftAssns) {</span>
<span class="nc" id="L1277">            checksums.put(shiftAssn, ShiftBidAuctionUtil.computeMD5(shiftAssn));</span>
<span class="nc" id="L1278">        }</span>

        // Update checksum
<span class="nc bnc" id="L1281" title="All 2 branches missed.">        for (BiddableScheduleInstance bsi : biddableInstances) {</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">            for (Map.Entry&lt;ShiftAssignment, String&gt; checksum : checksums.entrySet()) {</span>
<span class="nc" id="L1283">                TimeRange shiftDuration = new TimeRange(checksum.getKey().getStartTime(), checksum.getKey().getEndTime());</span>
<span class="nc" id="L1284">                TimeRange blockDuration = new TimeRange(bsi.getPhantomStartTime(), bsi.getPhantomEndTime());</span>
<span class="nc" id="L1285">                int relativeLocation = blockDuration.getRelativeLocationTo(shiftDuration);</span>
<span class="nc bnc" id="L1286" title="All 4 branches missed.">                if (relativeLocation == TimeRange.INTERVAL_EQUALS || relativeLocation == TimeRange.INTERVAL_IN) {</span>
<span class="nc" id="L1287">                    bsi.setBidSchedInstChecksum(checksum.getValue());</span>
<span class="nc" id="L1288">                    break;</span>
                }
<span class="nc" id="L1290">            }</span>
<span class="nc" id="L1291">        }</span>

<span class="nc" id="L1293">    }</span>

    private BiddableScheduleInstance updateBiddableInstance(BiddableScheduleInstance bsi, ID bidderEmpID, int pointsUsed, boolean isMultiShiftBlocks,
            Collection&lt;ShiftAssignment&gt; phanShiftAssns) {
<span class="nc" id="L1297">        bsi.setStatus(BiddableScheduleInstance.STATUS_ASSIGNED);</span>
<span class="nc" id="L1298">        bsi.setEmployeeID(bidderEmpID);</span>
<span class="nc" id="L1299">        bsi.setPointsUsed(pointsUsed);</span>
<span class="nc bnc" id="L1300" title="All 4 branches missed.">        if (isMultiShiftBlocks &amp;&amp; phanShiftAssns.iterator().hasNext()) {</span>
<span class="nc" id="L1301">            ShiftAssignment sa = phanShiftAssns.iterator().next();</span>
<span class="nc" id="L1302">            bsi.setPhantomStartTime(sa.getStartTime());</span>
<span class="nc" id="L1303">            bsi.setPhantomEndTime(sa.getEndTime());</span>
<span class="nc" id="L1304">            bsi.setPhantomShiftID(sa.getShiftID());</span>
<span class="nc" id="L1305">            bsi.setPhantomShiftPatternID(sa.getWorkPatternID());</span>
<span class="nc" id="L1306">            bsi.setPhantomDescription(sa.getDescription());</span>
        }
<span class="nc" id="L1308">        return bsi;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    private ID updateBiddableSchedule(BiddableScheduleDAO bsDAO, BiddableScheduleDAO bsDAO1, BiddableSchedule sched)
            throws Exception {
<span class="nc" id="L1314">        int availableInstances = 0;</span>
<span class="nc" id="L1315">        BiddableSchedule bSched = (BiddableSchedule) bsDAO1.getObjectByID(sched.getID());</span>
<span class="nc" id="L1316">        List&lt;BiddableScheduleInstance&gt; bidSchedInstList = bSched.getOptMethods().getBiddableScheduleInstances();</span>
<span class="nc" id="L1317">        ID firstAvailBidSchedInstanceID = null;</span>
<span class="nc" id="L1318">        ID secondAvailBidSchedInstanceID = null;</span>
<span class="nc bnc" id="L1319" title="All 4 branches missed.">        if (bidSchedInstList != null &amp;&amp; !bidSchedInstList.isEmpty()) {</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">            for (Iterator&lt;BiddableScheduleInstance&gt; iterator = bidSchedInstList.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1321">                BiddableScheduleInstance biddableInstance = (BiddableScheduleInstance) iterator.next();</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">                if (biddableInstance.getStatus() == BiddableScheduleInstance.STATUS_UNASSIGNED) {</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">                    if (firstAvailBidSchedInstanceID == null) {</span>
<span class="nc" id="L1324">                        firstAvailBidSchedInstanceID = biddableInstance.getID();</span>
                    } else {
<span class="nc" id="L1326">                        availableInstances++;</span>
<span class="nc" id="L1327">                        secondAvailBidSchedInstanceID = biddableInstance.getID();</span>
                    }
                }
<span class="nc" id="L1330">            }</span>
        }
<span class="nc bnc" id="L1332" title="All 2 branches missed.">        if (firstAvailBidSchedInstanceID == null) {</span>
<span class="nc" id="L1333">            throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.SBR_ONE_OR_MORE_BIDSCHEDS_BECAME_INVALID,</span>
<span class="nc" id="L1334">                    bSched.getShiftBidAuctionID(), m_cat);</span>
        }
<span class="nc bnc" id="L1336" title="All 2 branches missed.">        if (secondAvailBidSchedInstanceID != null) {</span>
<span class="nc" id="L1337">        	sched.getSetters().setFirstAvailBiddableSchedInstanceID(secondAvailBidSchedInstanceID);</span>
        }
<span class="nc" id="L1339">        sched.getSetters().setNumOfAvailInstances(availableInstances);</span>
<span class="nc" id="L1340">        bsDAO.updateObject(sched);</span>
<span class="nc" id="L1341">        return firstAvailBidSchedInstanceID;</span>
    }

    public Collection&lt;ShiftAssignment&gt; getShiftAssignmentsByBiddableScheduleInstanceID(ID bidSchedInstanceID) throws BbmFinderException {
<span class="nc" id="L1345">        Jdmo dmo = null;</span>
<span class="nc" id="L1346">        BiddableShiftDAO bShiftDAO = null;</span>
<span class="nc" id="L1347">        ShiftAssignmentDAO shiftAssnDao = null;</span>
<span class="nc" id="L1348">        Collection&lt;ID&gt; phanShiftAssnIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1349">        Collection&lt;ShiftAssignment&gt; phanShiftAssns = new ArrayList&lt;ShiftAssignment&gt;();</span>
        try {
<span class="nc" id="L1351">            dmo = new Jdmo(false);</span>
<span class="nc" id="L1352">            bShiftDAO = new BiddableShiftDAO(dmo, BiddableShift.DL_BASIC);</span>
<span class="nc" id="L1353">            shiftAssnDao = new ShiftAssignmentDAO(dmo);</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1355">            Collection&lt;BiddableShift&gt; biddableShiftCol = bShiftDAO.getObjectsByParentID(bidSchedInstanceID);</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">            for (Iterator&lt;BiddableShift&gt; iterator = biddableShiftCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1357">                BiddableShift shift = iterator.next();</span>
<span class="nc" id="L1358">                phanShiftAssnIDs.add(shift.getShiftAssignmentID());</span>
<span class="nc" id="L1359">            }</span>
<span class="nc" id="L1360">            phanShiftAssns = shiftAssnDao.getObjectsByIDs(phanShiftAssnIDs);</span>
<span class="nc" id="L1361">        } catch (Exception e) {</span>
<span class="nc" id="L1362">            e.printStackTrace();</span>
<span class="nc" id="L1363">            m_cat.error(&quot;Exception in (ShiftBidRequestManagerEJB.getShiftAssignmentsByBiddableScheduleInstanceID )&quot;, e);</span>

        } finally {
<span class="nc bnc" id="L1366" title="All 6 branches missed.">            if (shiftAssnDao != null) {</span>
<span class="nc" id="L1367">                shiftAssnDao.cleanUp();</span>
            }
<span class="nc bnc" id="L1369" title="All 6 branches missed.">            if (bShiftDAO != null) {</span>
<span class="nc" id="L1370">                bShiftDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L1372" title="All 6 branches missed.">            if (dmo != null) {</span>
<span class="nc" id="L1373">                dmo.cleanUp();</span>
            }
        }
<span class="nc" id="L1376">        return phanShiftAssns;</span>
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    public void updateBiddableShiftsForBiddableScheduleInstance(ID bidSchedInstanceID, Collection&lt;ShiftAssignment&gt; empShiftAssns) {
<span class="nc" id="L1381">        Jdmo dmo = null;</span>
<span class="nc" id="L1382">        BiddableShiftDAO bShiftDAO = null;</span>
        try {
<span class="nc" id="L1384">            int shiftOrder = 1;</span>
<span class="nc" id="L1385">            dmo = new Jdmo(false);</span>
<span class="nc" id="L1386">            bShiftDAO = new BiddableShiftDAO(dmo, BiddableShift.DL_BASIC);</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">            for (Iterator&lt;ShiftAssignment&gt; shiftAssnsIter = empShiftAssns.iterator(); shiftAssnsIter.hasNext(); shiftOrder++) {</span>
<span class="nc" id="L1388">                ShiftAssignment sa = shiftAssnsIter.next();</span>
<span class="nc" id="L1389">                BiddableShift shift = new BiddableShift(BiddableShift.DL_BASIC);</span>
<span class="nc" id="L1390">                shift.setBiddableShiftInstanceID(bidSchedInstanceID);</span>
<span class="nc" id="L1391">                shift.setShiftAssignmentID(sa.getID());</span>
<span class="nc" id="L1392">                shift.setOrder(shiftOrder);</span>
<span class="nc" id="L1393">                bShiftDAO.createObject(shift);</span>
            }
<span class="nc" id="L1395">        } catch (Exception e) {</span>
<span class="nc" id="L1396">            e.printStackTrace();</span>
<span class="nc" id="L1397">            m_cat.error(&quot;Exception in (ShiftBidRequestManagerEJB.updateBiddableShiftForBiddableScheduleInstance )&quot;, e);</span>

        } finally {
<span class="nc bnc" id="L1400" title="All 6 branches missed.">            if (bShiftDAO != null) {</span>
<span class="nc" id="L1401">                bShiftDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L1403" title="All 6 branches missed.">            if (dmo != null) {</span>
<span class="nc" id="L1404">                dmo.cleanUp();</span>
            }
        }
<span class="nc" id="L1407">    }</span>

    /**
     * @param sbrFromDB
     */
//    private void invalidateOtherPendingEscalatedReqsForBidder(ShiftBidRequest sbrFromDB,
//        ShiftBidRequestDAO sbrDAO) throws Exception {
//
//        Collection otherSBReqs = sbrDAO.getRequestsUsingFilter( new FilterExpr[] {
//            new FilterExpr(FilterExpr.LHS_REQUESTSTATUS, FilterExpr.OP_IN, new String[] {RequestAuditTrail.STATUS_PENDING, RequestAuditTrail.STATUS_ESCALATED}),
//            new FilterExpr(FilterExpr.LHS_BIDDERIDS, FilterExpr.OP_EQUALTO, sbrFromDB.getShiftBidderID())
//        }, ShiftBidRequest.DL_BASIC);
//
//        for (Iterator otherSBReqsIter = otherSBReqs.iterator(); otherSBReqsIter.hasNext();) {
//            ShiftBidRequest otherSBReq = (ShiftBidRequest) otherSBReqsIter.next();
//
//            sbrDAO.changeRequestState(otherSBReq, RequestAuditTrail.STATUS_INVALID,
//                &quot;Invalidating: found already approved req: ID = &quot; + sbrFromDB.getID() + '(' + RmEjbBundleKey.UN LOCALIZED_MESSAGE + ')');
//        }
//    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
     */
    @Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, ID choiceID, String comment) {
        try {
<span class="nc" id="L1434">            addNextShiftBidderIfNecessary(reqAgg);</span>
<span class="nc" id="L1435">        } catch (Exception e) {</span>
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            // Exception is not rethrown but just logged.  Necessary to prevent the entire transaction
            // from being rolled back if the next shift bidder cannot be added successfully.
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
<span class="nc" id="L1440">            m_cat.error(&quot;_approveRequestPostProcess&quot;, e);</span>
<span class="nc" id="L1441">        }</span>
<span class="nc" id="L1442">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestTentatively(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
     */
    @Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, ID choiceID, String comment, boolean loadedFromDB)
        throws Exception
    {
        //validate request

        //mark request as tentatively approved.

        //make schedule changes.
<span class="nc" id="L1456">        throw new UnsupportedOperationException(m_tentativeNotImplemented+ reqAgg);</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String, boolean)
     */
    //TODO: Pass DAO as an argument to reduce # of DAOs created during request processing.
    @Override
	protected void _denyRequest(RequestAggregate reqAgg,  String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB)
        throws Exception
    {
        //do not have to validate request.

        //if tentatively approved, undo changes.

        //mark request denied.
<span class="nc" id="L1472">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null,</span>
            suppressPrivilegeChecking, loadedFromDB);
<span class="nc" id="L1474">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
    	//QA58518: deny should not trigger addition of next agent
        /*try {
            addNextShiftBidderIfNecessary(reqAgg);
        } catch (Exception e) {
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            // Exception is not rethrown but just logged.  Necessary to prevent the entire transaction
            // from being rolled back if the next shift bidder cannot be added successfully.
            //XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
            m_cat.error(&quot;_denyRequestPostProcess&quot;, e);
        }*/
<span class="nc" id="L1491">    }</span>


    /**
     * Called when a shift bid request is approved, denied, autoapproved or autodenied.
     *
     * Adds the next bidder provided the following conditions are met:
     * &lt;li&gt; if auction associated with the given shift bid request is in serialized mode
     * &lt;li&gt; if the bidder associated with the given shift bid request is the current bidder of the
     *   auction.
     * @param reqAgg
     */
    private void addNextShiftBidderIfNecessary(RequestAggregate reqAgg)  throws Exception {
<span class="nc" id="L1504">        SerializedAuctionDAO aucSerDAO = null;</span>
        try {
<span class="nc" id="L1506">            ShiftBidRequest sbReq = (ShiftBidRequest) reqAgg;</span>
            // check if this is a serailized auction and if so, if this request's bidder is the current bidder.
<span class="nc" id="L1508">            aucSerDAO = new SerializedAuctionDAO();</span>

<span class="nc" id="L1510">            ID auctionID = sbReq.getShiftBidAuctionID();</span>
<span class="nc" id="L1511">            SerializedAuction aucSer = aucSerDAO.getSerializedAuctionForAuctionID(auctionID);</span>

            // if auction is not in serialization mode, end of story.
<span class="nc bnc" id="L1514" title="All 2 branches missed.">            if (aucSer == null) return;</span>

            // if request does not belong to the current bidder for the serialized auction
<span class="nc" id="L1517">            ID reqBidderID = sbReq.getShiftBidderID();</span>
<span class="nc" id="L1518">            ID serAucCurrentBidderID = aucSer.getCurrentBidderID();</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">            if (!reqBidderID.equals(serAucCurrentBidderID)) {</span>
<span class="nc" id="L1520">                m_cat.debug(&quot;Not adding next bidder since request does not belong to current bidder: &quot; +</span>
                    &quot; reqBidderID, serAucCurrBidderID: &quot; + reqBidderID + ',' + serAucCurrentBidderID);
<span class="nc" id="L1522">                return;</span>
            }

            // Otherwise, add next shift bidder to auction.
<span class="nc" id="L1526">            ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(aucSer, aucSerDAO, null);</span>
        } finally {
<span class="nc bnc" id="L1528" title="All 8 branches missed.">            if (aucSerDAO != null) aucSerDAO.cleanUp();</span>
        }
<span class="nc" id="L1530">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoTentativeApprovalByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String)
     */
    @Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment)
        throws Exception
    {
        //validate request

        //mark request as pending from tentatively approved.

        //undo any schedule changes.

<span class="nc" id="L1545">        throw new UnsupportedOperationException(m_tentativeNotImplemented);</span>
    }


    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optUndoData) throws Exception
    {
<span class="nc" id="L1556">        throw new UnsupportedOperationException();</span>

//        //delete request.
//        reqAggDAO = (reqAggDAO == null)?getDAO(ShiftBidRequest.DL_BASIC):reqAggDAO;
//        reqAggDAO.deleteRequest(reqAgg.getID());
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#checkUpdatePrivilege(com.bluepumpkin.ejb.bbm.security.model.User, com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
//    protected void checkUpdatePrivilege(User user, RequestAggregate reqAgg, String newState)
//        throws Exception
//    {
//        //  Auto-generated method stub
//
//    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDApproveEscalated()
     */
    @Override
	protected ID getPrivIDApproveEscalated() {
<span class="nc" id="L1578">        return PrivilegeKeys.SB_APPROVEESCALATEDBIDS_ID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDApprovePending()
     */
    @Override
	protected ID getPrivIDApprovePending() {
<span class="nc" id="L1586">        return PrivilegeKeys.SB_APPROVEPENDINGBIDS_ID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDEscalate()
     */
    @Override
	protected ID getPrivIDEscalate() {
<span class="nc" id="L1594">        return PrivilegeKeys.SB_ESCALATEDENIEDBIDS_ID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDModifyPersonalReqs()
     */
    @Override
	protected ID getPrivIDModifyPersonalReqs() {
<span class="nc" id="L1602">        return PrivilegeKeys.SB_MODIFYPERSONALBIDS_ID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDModifyReqsForEmp()
     */
    @Override
	protected ID getPrivIDModifyReqsForEmp() {
<span class="nc" id="L1610">        return PrivilegeKeys.SB_MODIFYSHIFTBIDSFOREMP_ID;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
     */
    @Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L1618">        return PrivilegeKeys.SB_PURGEREQUESTS_ID;</span>
    }

    /**
     * This method:
     * &lt;li&gt; does some basic validations of the given shiftBidRequest
     * &lt;li&gt; and loads the necessary child objects for running hard validations.
     *
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#createRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO)
        throws Exception
    {
<span class="nc" id="L1632">        ShiftBidderDAO shiftBidderDAO = null;</span>
        try  {
<span class="nc" id="L1634">            super.createRequestPreProcess(reqAgg, reqAggDAO);</span>

<span class="nc" id="L1636">            ShiftBidRequest sbRequest = (ShiftBidRequest) reqAgg;</span>

            // Error if both employeeID and shiftBidderID not set
<span class="nc bnc" id="L1639" title="All 4 branches missed.">            if (sbRequest.getShiftBidderID() == null &amp;&amp; sbRequest.getEmployeeID() == null)   {</span>
<span class="nc" id="L1640">                throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
            }

            // Error if auction ID not set
<span class="nc bnc" id="L1644" title="All 2 branches missed.">            if (sbRequest.getShiftBidAuctionID() == null)</span>
<span class="nc" id="L1645">                throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>

            //translate empID to shiftBidderID if necessary.
<span class="nc bnc" id="L1648" title="All 2 branches missed.">            if (sbRequest.getShiftBidderID() == null)   {</span>
<span class="nc" id="L1649">                shiftBidderDAO = new ShiftBidderDAO(reqAggDAO.getDMO(), ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L1651">                ShiftBidder shiftBidder = shiftBidderDAO.getShiftBidderForEmpAndAuctionID(sbRequest.getEmployeeID(),</span>
<span class="nc" id="L1652">                    sbRequest.getShiftBidAuctionID(), ShiftBidder.DL_BASIC);</span>

<span class="nc bnc" id="L1654" title="All 2 branches missed.">                if (shiftBidder == null)</span>
<span class="nc" id="L1655">                    throw RequestUtil.createRmException(RmEjbLogBundleKey.SBR_CANNOT_FIND_SHIFTBIDDER,</span>
<span class="nc" id="L1656">                    	sbRequest.getEmployeeID(), sbRequest.getShiftBidAuctionID(), m_cat);</span>

<span class="nc" id="L1658">                sbRequest.setShiftBidderID(shiftBidder.getID());</span>
            }

            // obtain employeeID if necessary.
<span class="nc bnc" id="L1662" title="All 2 branches missed.">            if (sbRequest.getEmployeeID() == null)  {</span>
<span class="nc" id="L1663">                shiftBidderDAO = new ShiftBidderDAO(reqAggDAO.getDMO(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L1664">                ShiftBidder shiftBidder = shiftBidderDAO.getShiftBidderByID(sbRequest.getShiftBidderID(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L1665">                sbRequest.setEmployeeID(shiftBidder.getEmployeeID());</span>
            }

<span class="nc bnc" id="L1668" title="All 2 branches missed.">            if (sbRequest.getName() == null) sbRequest.setName(&quot;Default ShiftBidRequest Name&quot;);</span>

            // score for this request.  This field is not used but can't be null.  So Setting it to zero.
<span class="nc" id="L1671">            sbRequest.getSetters().setScore(0);</span>

            // load all associated data.
<span class="nc" id="L1674">            loadAssocDataForCreateReqValidation(sbRequest);</span>
        } finally  {
<span class="nc bnc" id="L1676" title="All 4 branches missed.">            if (shiftBidderDAO != null) shiftBidderDAO.cleanUp();</span>
        }
<span class="nc" id="L1678">    }</span>

    /**
     * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager#validateRequestBeforeCreate(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate)
     */
    public RequestAggregate validateRequestBeforeCreate(RequestAggregate reqAgg)
    	throws RmException, RmHardValidationException {
<span class="nc" id="L1685">        String _method_ = &quot;validateRequestBeforeCreate&quot;;</span>
<span class="nc" id="L1686">        methodStart(_method_, reqAgg);</span>

<span class="nc" id="L1688">        ShiftBidRequestDAO sbReqDAO = null;</span>
<span class="nc" id="L1689">        BiddableScheduleDAO bidSchedDAO = null;</span>
<span class="nc" id="L1690">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1691">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1693">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // if requestID != null and any hard validations fail, during doHardValidations() below, the
            // request is marked 'invalid' in the DB by doHardValidations().  This scenario happens when
            // the webtier calls validateRequestBeforeCreate() twice, once before call to createRequest()
            // once after call to createRequest().  The 2nd call has a non-null requestID which results
            // in the request getting marked as 'invalid'.
<span class="nc" id="L1700">            reqAgg.setID(null);</span>

            //The passed shiftBidRequest only has ShiftBidRequestBiddableSChedule children.  We need
            // more info to compute the rank and run the hard validations.  The primary hard validation to  be run
            // is if the given set of biddable schedules are valid (ie, shift assignments will not overlap
            // unavailabilities etc).
<span class="nc" id="L1706">            sbReqDAO = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>

            // assign default values to request fields
<span class="nc" id="L1709">            assignDefaultsForReqAgg(reqAgg);</span>

            // this preprocesses the request and loads the necessary child objects.
<span class="nc" id="L1712">            createRequestPreProcess(reqAgg, sbReqDAO);</span>

<span class="nc" id="L1714">            doHardValidations(reqAgg, RequestUtil.METHODTYPE_CREATOR, null, true);</span>

            // Now we have a shift bid request with the following hierarchy:
            // ShiftBidReq --&gt; ShiftBidReqBidSched --&gt; BidSched --&gt; FirstBidSchedInst --&gt; BiddableShift --&gt; ShiftAssignments
<span class="nc" id="L1718">            bidSchedDAO = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC);</span>
            // set a dummy ID for the request. Necessary since the rank computation logic needs to find
            // this request in a sorted list of requests which it does using the request's ID.  Note that
            // setting the ID to a non-null well is never recommended since the code in this module uses
            // the fact that the ID is null or non-null to determine if the request is being newly
            // created or is already persisted in the DB.
<span class="nc" id="L1724">            reqAgg.setID(new ID(Integer.MAX_VALUE));</span>
<span class="nc" id="L1725">            ShiftBidAuctionUtil.computeRankForShiftBidRequest((ShiftBidRequest) reqAgg, false, null, bidSchedDAO);</span>
<span class="nc" id="L1726">            reqAgg.setID(null);</span>

<span class="nc" id="L1728">            return reqAgg;</span>
<span class="nc" id="L1729">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1736">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1737">			throw e;</span>
<span class="nc" id="L1738">		} catch (RmException e) {</span>
<span class="nc" id="L1739">			m_cat.error(e, e);</span>
<span class="nc" id="L1740">			handleException(e);</span>
<span class="nc" id="L1741">			throw e;</span>
<span class="nc" id="L1742">        } catch (Exception e) {</span>
            // reset the ID temporarily set to Integer.MAX_VALUE earlier.
<span class="nc" id="L1744">            reqAgg.setID(null);</span>

<span class="nc" id="L1746">            handleException(e);</span>
<span class="nc" id="L1747">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1749" title="All 4 branches missed.">            if (cacheEnabled) ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>

<span class="nc bnc" id="L1751" title="All 4 branches missed.">            if (sbReqDAO != null) sbReqDAO.cleanUp();</span>
<span class="nc bnc" id="L1752" title="All 4 branches missed.">            if (bidSchedDAO != null) bidSchedDAO.cleanUp();</span>

<span class="nc" id="L1754">            methodFinish();</span>
        }
    }

    /**
     * This method:
     * &lt;li&gt; loads the biddable schedules associated with the shift bid request.
     * &lt;li&gt; attaches the biddable schedule to the proper shiftbidRequestBidSched as a child.
     * &lt;li&gt; fills the shiftBidReqBidSched.order field which maintains the order of the shift assignments assoc
     * with the shift bid request (in a single shift auction).
     * &lt;li&gt; loads the shift bid auction and assoicates it with the shift bid request.
     * &lt;li&gt; loads the shift bidder and makes it a child of sbREq.
     *
     * @param sbReq
     * @throws Exception
     */
    private void loadAssocDataForCreateReqValidation(ShiftBidRequest sbReq) throws Exception{
<span class="nc" id="L1771">        long detailLevelForFetch = 0;;</span>

//        boolean fetchShiftAssns = (sbReq.getDetailLevel() &amp; ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL) == 0;
//        detailLevelForFetch = (fetchShiftAssns)?detailLevelForFetch | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL:detailLevelForFetch;
//
//        boolean fetchShiftBidAuction = (sbReq.getDetailLevel() &amp; ShiftBidRequest.DL_SHIFTBID_AUCTION) != 0;
//        detailLevelForFetch = (fetchShiftBidAuction)?detailLevelForFetch | ShiftBidRequest.DL_SHIFTBID_AUCTION:detailLevelForFetch;
//
//        if (detailLevelForFetch == 0) return;
//

        // fetch the associated shift bid auction.
<span class="nc" id="L1783">        ShiftBidAuction sbAuction = sbReq.getValidationCacheSBR().getShiftBidAuction();</span>
<span class="nc" id="L1784">        sbReq.getSetters().setShiftBidAuction(sbAuction);</span>

        // if scoring disabled in auction, then reset &quot;use scoring&quot; flag for request.
<span class="nc bnc" id="L1787" title="All 2 branches missed.">        if (!sbAuction.getUsesScoring())</span>
<span class="nc" id="L1788">            sbReq.setIsBonusUsed(false);</span>

        // fetch the biddableSchedules and associate them with the ShiftBidRequestbiddableSchedule children.
<span class="nc" id="L1791">        List SBRBSList = sbReq.getOptMethods().getShiftBidRequestBiddableSchedules();</span>
<span class="nc bnc" id="L1792" title="All 4 branches missed.">        assert SBRBSList.size() != 0:&quot;SBRBSList.size() != 0&quot;;</span>

        // load biddable schedules using the biddbale schedule IDs in the request.
<span class="nc" id="L1795">        Collection&lt;BiddableSchedule&gt; bidSchedsFromDB = sbReq.getValidationCacheSBR().getBiddableSchedules();</span>


<span class="nc" id="L1798">        validateAllBidsInAuction(bidSchedsFromDB, sbAuction);</span>

<span class="nc" id="L1800">        assocBidSchedsToShiftBidReqBidSched(SBRBSList, bidSchedsFromDB, sbAuction);</span>

        // After attaching the biddable schedules as children of ShiftBidrequestBiddableSchedules, adjust the detail
        // level for the shiftBidReq.
<span class="nc" id="L1804">        sbReq.addDetailLevel(ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);</span>

        // Set expiration date if request is being created.
<span class="nc bnc" id="L1807" title="All 2 branches missed.">        if (sbReq.getExpirationDate() == null) sbReq.setExpirationDate(sbAuction.getStartTime());</span>

        // fetch the associated shift bidder
<span class="nc" id="L1810">        ShiftBidder shiftBidder = sbReq.getValidationCacheSBR().getShiftBidder();</span>
<span class="nc" id="L1811">        sbReq.getSetters().setShiftBidder(shiftBidder);</span>
<span class="nc" id="L1812">    }</span>

	private void validateAllBidsInAuction(Collection&lt;BiddableSchedule&gt; bidSchedsFromDB, ShiftBidAuction sbAuction)
			throws RmHardValidationException {
<span class="nc" id="L1816">		ID auctionID = sbAuction.getID();</span>
<span class="nc bnc" id="L1817" title="All 2 branches missed.">		for (BiddableSchedule bidSchedule : bidSchedsFromDB) {</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">			if (!bidSchedule.getShiftBidAuctionID().equals(auctionID)) {</span>
<span class="nc" id="L1819">				throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.SBR_BIDDABLE_SCHEDULE_NOT_IN_AUCTION,</span>
<span class="nc" id="L1820">						bidSchedule.getID(), sbAuction.getName(), m_cat);</span>
			}
<span class="nc" id="L1822">		}</span>
<span class="nc" id="L1823">	}</span>

	/**
     * Associate the biddable schedules loaded from DB with ShiftBidRequestBiddableSchedule
     * Also set the proper order for the ShiftBidRequestBiddableSchedule.
     *
     * @param SBRBSList
     * @param bidSchedsFromDB
     * @param sbAuction
     */
    private void assocBidSchedsToShiftBidReqBidSched(List SBRBSList, Collection bidSchedsFromDB, ShiftBidAuction sbAuction) {
        //if auction type == full period schedule.
<span class="nc bnc" id="L1835" title="All 2 branches missed.">        if (sbAuction.getIsFullPeriodSchedule()) {</span>
            // full period auctions can have only one bidSched
<span class="nc bnc" id="L1837" title="All 4 branches missed.">            assert bidSchedsFromDB.size() == 1:&quot;bidSchedsFromDB.size() == 1&quot;;</span>

<span class="nc" id="L1839">			setSingleBiddableScheduleItemOrder(SBRBSList, bidSchedsFromDB);</span>
        } else { // auction type == single shift schedule
            // Order the ShiftBidRequestBiddbaleSchedules associated with this request using the
            // (indirectly) associated shift assignments.
            // ShiftBidRequestBiddableSchedule --&gt; BiddableSchedule --&gt; ShiftAssignemnt
<span class="nc bnc" id="L1844" title="All 2 branches missed.">            if (SBRBSList.size() &gt; 1) {</span>
                // obtain map of biddableSchedule.ID to ShiftBidRequestBiddableSchedule
<span class="nc" id="L1846">                Map bidSchedIDToSBR_BS_Map = new HashMap(5);</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">                for (Iterator SBRBSListIter = SBRBSList.iterator(); SBRBSListIter.hasNext();) {</span>
<span class="nc" id="L1848">                    ShiftBidRequestBiddableSchedule sbrBS = (ShiftBidRequestBiddableSchedule) SBRBSListIter.next();</span>
<span class="nc" id="L1849">                    bidSchedIDToSBR_BS_Map.put(sbrBS.getBiddableScheduleID(), sbrBS);</span>
<span class="nc" id="L1850">                }</span>

                // obtain map of shift assignment ID to biddableSchdule.
                // Also compile a shift assignment list associated with the biddable schedules
<span class="nc" id="L1854">                List shiftAssnsList = new ArrayList(5);</span>
<span class="nc" id="L1855">                Map shiftAssnIDToBiddableSchedMap = new HashMap(5);</span>
<span class="nc bnc" id="L1856" title="All 2 branches missed.">                for (Iterator bidSchedFromDBIter = bidSchedsFromDB.iterator(); bidSchedFromDBIter.hasNext();) {</span>
<span class="nc" id="L1857">                    BiddableSchedule bidSched = (BiddableSchedule) bidSchedFromDBIter.next();</span>

<span class="nc" id="L1859">                    List bidSchedShifts = bidSched.getOptMethods().getShiftAssignments();</span>
<span class="nc bnc" id="L1860" title="All 4 branches missed.">                    assert bidSchedShifts.size() == 1:&quot;bidSchedShifts.size() == 1&quot;;</span>

<span class="nc" id="L1862">                    shiftAssnsList.addAll(bidSchedShifts);</span>
                    //Note: this is a single shift auction. so a biddable schedule is associated with only one shift assn.
<span class="nc" id="L1864">                    shiftAssnIDToBiddableSchedMap.put(((ShiftAssignment)bidSchedShifts.get(0)).getID(), bidSched);</span>
<span class="nc" id="L1865">                }</span>

                // sort the shift assignments
<span class="nc" id="L1868">                Collections.sort(shiftAssnsList, new ShiftBidAuctionUtil.ShiftAssignmentComparator());</span>

                // iterate thru' the sorted shift assignments and identify the ShiftBidRequestBiddableSchedule each is
                // associated with.  Then set the 'itemorder' field in the shiftbidRequestBiddableSchedule.
<span class="nc bnc" id="L1872" title="All 2 branches missed.">                for (int shiftAssnIdx = 0; shiftAssnIdx &lt; shiftAssnsList.size(); shiftAssnIdx++) {</span>
<span class="nc" id="L1873">                    ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsList.get(shiftAssnIdx);</span>
<span class="nc" id="L1874">                    BiddableSchedule bidSched = (BiddableSchedule) shiftAssnIDToBiddableSchedMap.get(shiftAssn.getID());</span>
<span class="nc" id="L1875">                    ShiftBidRequestBiddableSchedule sbrBS = (ShiftBidRequestBiddableSchedule) bidSchedIDToSBR_BS_Map.get(bidSched.getID());</span>

<span class="nc" id="L1877">                    sbrBS.setOrder(shiftAssnIdx + 1);</span>
                }

                // Attach BiddableSchedules as children of shiftBidRequestBiddableschedule.
<span class="nc" id="L1881">                Map bidSchedMap = RequestUtil.getMapOfIDsForVOBases(bidSchedsFromDB);</span>
<span class="nc bnc" id="L1882" title="All 2 branches missed.">                for (int idx = 0; idx &lt; SBRBSList.size(); idx++) {</span>
<span class="nc" id="L1883">                    ShiftBidRequestBiddableSchedule sbrBidSched = (ShiftBidRequestBiddableSchedule) SBRBSList.get(idx);</span>
<span class="nc" id="L1884">                    sbrBidSched.setBiddableSchedule((BiddableSchedule) bidSchedMap.get(sbrBidSched.getBiddableScheduleID()));</span>
                }
<span class="nc" id="L1886">            } else {</span>
                // Only one shiftbidRequestBiddableSchedule. Just set the item order
<span class="nc" id="L1888">				setSingleBiddableScheduleItemOrder(SBRBSList, bidSchedsFromDB);</span>
			}
		}
<span class="nc" id="L1891">	}</span>

	protected void setSingleBiddableScheduleItemOrder(List SBRBSList, Collection bidSchedsFromDB) {
<span class="nc" id="L1894">		Iterator it = bidSchedsFromDB.iterator();</span>
<span class="nc bnc" id="L1895" title="All 2 branches missed.">		if (it.hasNext()) {</span>
<span class="nc" id="L1896">                ShiftBidRequestBiddableSchedule sbrBS = ((ShiftBidRequestBiddableSchedule)SBRBSList.get(0));</span>
<span class="nc" id="L1897">                sbrBS.setOrder(1);</span>
<span class="nc" id="L1898">			sbrBS.setBiddableSchedule((BiddableSchedule) it.next());</span>
        }
<span class="nc" id="L1900">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#updateRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        boolean loadedFromDB) throws Exception
    {
        // updatable fields: Name, Preference, isBonusUsed,
        //verify if fields have valid values.

        //verify if immutable fields have changed (compare with request in db).
<span class="nc" id="L1913">        ShiftBidRequest sbReqFromDB = (ShiftBidRequest) reqAgg;</span>
        // reload from DB if the given request was not loadedFromDB or the detail level is not adequate for validation
<span class="nc" id="L1915">        long detailForVal = getDetailLevelForValidation();</span>
<span class="nc bnc" id="L1916" title="All 4 branches missed.">        if ( !loadedFromDB || ((reqAgg.getDetailLevel() &amp; detailForVal) != detailForVal) )  {</span>
<span class="nc" id="L1917">            ShiftBidRequestDAO sbReqDAO = (ShiftBidRequestDAO) reqAggDAO;</span>
<span class="nc" id="L1918">            sbReqFromDB =</span>
<span class="nc" id="L1919">                (ShiftBidRequest) sbReqDAO.getRequestByID(reqAgg.getID(), detailForVal);</span>

            //set updatable fields
<span class="nc bnc" id="L1922" title="All 2 branches missed.">            if (!StringUtil.isEmpty(reqAgg.getObjectVersionNumber())) sbReqFromDB.getAggregatedRequest().setObjectVersionNumber(reqAgg.getObjectVersionNumber());</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">            if (!StringUtil.isEmpty(reqAgg.getRequestStatus())) sbReqFromDB.setRequestStatus(reqAgg.getRequestStatus());</span>

<span class="nc" id="L1925">            ShiftBidRequest sbReqGiven = (ShiftBidRequest) reqAgg;</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">            if (!StringUtil.isEmpty(sbReqGiven.getName())) sbReqFromDB.setName(sbReqGiven.getName());</span>
<span class="nc" id="L1927">            sbReqFromDB.setPreference(sbReqGiven.getPreference());</span>

            //if &quot;auction uses scoring&quot; flag == false, then &quot;use bonus&quot; flag for the bid request must be reset.
<span class="nc" id="L1930">            sbReqFromDB.setIsBonusUsed(sbReqGiven.getIsBonusUsed());</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">            if (sbReqGiven.getIsBonusUsed()) {</span>
<span class="nc" id="L1932">                ShiftBidAuction sbAuctionForReq = sbReqFromDB.getOptMethods().getShiftBidAuction();</span>
                // if &quot;auction uses scoring&quot; == false, then reset &quot;use bonus&quot; flag for request.
<span class="nc bnc" id="L1934" title="All 2 branches missed.">                if (!sbAuctionForReq.getUsesScoring())</span>
<span class="nc" id="L1935">                    sbReqFromDB.setIsBonusUsed(false);</span>
            }
        }

<span class="nc" id="L1939">        return sbReqFromDB;</span>
    }

//    /* (non-Javadoc)
//     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#checkPrivilegeForOrgs(java.util.Collection, int)
//     */
//    protected void checkPrivilegeForOrgs(Collection orgID, int privilege) throws Exception {
//        // verify if the current user has the given privilege for the collection of orgs.
//    }

    /**
     * Computes the following:
     * &lt;li&gt; bonus computed (using bidder's accumulated bonus and shiftBidder bonus)
     * &lt;li&gt; bonus to be awarded (sum of bonuses assoicated with the biddableSchedules for the shift bid request).
     * &lt;li&gt; score for request with bonus (weighted sum of seniority, rank and computed bonus)
     * &lt;li&gt; score for request without bonus (weighted sum of seniority and rank)
     * &lt;li&gt; rank for request with score
     * &lt;li&gt; rank for request without score.
     *
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
     */
    @Override
	protected void getRequestPostProcess(Collection reqAggs, long givenDetailLevel) throws Exception {
        // iterate thru' the shift bid requests
<span class="nc" id="L1963">        BiddableScheduleDAO bidSchedDAO = null;</span>
<span class="nc" id="L1964">        ShiftBidAuctionDAO sbAuctionDAO = null;</span>
        try {
            // declared outside the loop since object life time spans loop iterations.
            // cache.  Map of bidSchedID to bidSched.
<span class="nc" id="L1968">            Map cacheBidSchedIDToBidSchedMap = null;</span>
<span class="nc" id="L1969">            Map cacheOrgIDToOrgSetting = null;</span>
<span class="nc" id="L1970">            Map methodDataCacheMap = null;</span>
<span class="nc bnc" id="L1971" title="All 2 branches missed.">            for (Iterator reqAggsIter = reqAggs.iterator(); reqAggsIter.hasNext();) {</span>
<span class="nc" id="L1972">                ShiftBidRequest sbReqGiven = (ShiftBidRequest) reqAggsIter.next();</span>
<span class="nc bnc" id="L1973" title="All 2 branches missed.">                if ( !sbReqGiven.isGetRequestPostProcNeeded()) continue;</span>

                // get associated auction for this shift bid request.
<span class="nc" id="L1976">                ShiftBidAuction sbAuction = null;</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">                if ( (sbReqGiven.getDetailLevel() &amp; ShiftBidRequest.DL_SHIFTBID_AUCTION) == 0 ) {</span>
<span class="nc bnc" id="L1978" title="All 2 branches missed.">                    sbAuctionDAO = (sbAuctionDAO == null)?new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC):sbAuctionDAO;</span>
<span class="nc" id="L1979">                    sbAuction = sbAuctionDAO.getAuctionByID(sbReqGiven.getShiftBidAuctionID(), ShiftBidAuction.DL_BASIC);</span>
                } else {
<span class="nc" id="L1981">                    sbAuction = sbReqGiven.getOptMethods().getShiftBidAuction();</span>
                }

                // compute bonus, score with bonus and score without bonus.
<span class="nc" id="L1985">                long detailLevelToCheck = ShiftBidRequest.DL_SCORECOMPUTED_FOR_SHIFTBID_REQUEST |</span>
                    ShiftBidRequest.DL_BIDRANK_FOR_SHIFTBIDREQUEST;
<span class="nc bnc" id="L1987" title="All 2 branches missed.">                if ( (givenDetailLevel &amp; detailLevelToCheck) != 0 ) {</span>
                    // instantiate cache if necessary.
<span class="nc bnc" id="L1989" title="All 2 branches missed.">                    cacheOrgIDToOrgSetting = (cacheOrgIDToOrgSetting == null)?new HashMap():cacheOrgIDToOrgSetting;</span>
<span class="nc bnc" id="L1990" title="All 2 branches missed.">                    methodDataCacheMap = (methodDataCacheMap == null)?new HashMap(10):methodDataCacheMap;</span>

<span class="nc" id="L1992">                    ShiftBidAuctionUtil.computeBonusAndScoreWithAndWithoutPoints(sbReqGiven, null, null,</span>
                        null, (OrganizationSetting) null, cacheOrgIDToOrgSetting, methodDataCacheMap);
                }

<span class="nc bnc" id="L1996" title="All 2 branches missed.">                cacheBidSchedIDToBidSchedMap =</span>
                    (cacheBidSchedIDToBidSchedMap == null)?new HashMap():cacheBidSchedIDToBidSchedMap;
<span class="nc bnc" id="L1998" title="All 2 branches missed.">                bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(BiddableSchedule.DL_BASIC):bidSchedDAO;</span>

                // compute the rank of this shift bid request, in the context of this request's shiftBidder,
                // among all the requests submitted towards this shiftbid request's biddableschedule.
<span class="nc" id="L2002">                detailLevelToCheck = ShiftBidRequest.DL_BIDRANK_FOR_SHIFTBIDREQUEST;</span>
                // Note: Though sbAuction.getUsesScoring() is also checked in computeBonusAndScoreWithAndWithoutPoints()
                // method which is lower in the call heirarchy (indirectly called by this method), checking
                // it here prevents a lot of unnecessary processing (especially loading of sbReqs
                // associated with each bidSched of sbReqGiven).
<span class="nc bnc" id="L2007" title="All 4 branches missed.">                if ( sbAuction.getUsesScoring() &amp;&amp; (givenDetailLevel &amp; detailLevelToCheck) != 0 ) {</span>
                    // compute rank for this shift bid request.  When computing the rank,
                    // add the sorted list of shift bid requests, based on request's score with and without bonus,
                    // for each biddable schedule, to the passed map for caching.
<span class="nc bnc" id="L2011" title="All 2 branches missed.">                	boolean incExpired = ((givenDetailLevel &amp; RequestDetailLevel.DL_INCLUDE_EXPIRED) == 0) ? false : true;</span>
<span class="nc" id="L2012">                	ShiftBidAuctionUtil.computeRankForShiftBidRequest(sbReqGiven, true,</span>
                			cacheBidSchedIDToBidSchedMap, bidSchedDAO, incExpired);
                }

                // Now compute the bonus that will be added to the accumulated bonus for this employee if
                // this shift bid request is approved.  This bonus is associated with the biddable schedules
                // for this request.
                // Code moved to ShiftBidRequest.ShiftBidRequestOptMethods.getComputedBonus().
<span class="nc" id="L2020">            }</span>
        } finally {
<span class="nc bnc" id="L2022" title="All 4 branches missed.">            if (bidSchedDAO != null) bidSchedDAO.cleanUp();</span>
<span class="nc bnc" id="L2023" title="All 4 branches missed.">            if (sbAuctionDAO != null) sbAuctionDAO.cleanUp();</span>
        }
<span class="nc" id="L2025">    }</span>

    //get the requests associated with a bidder
    public ID getApprovedRequestID(ID shiftBidderID, ID auctionID) throws Exception
    {
<span class="nc" id="L2030">        ShiftBidRequestDAO sbrDAO = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
        try {
<span class="nc" id="L2032">            m_cat.debug(&quot;Getting requests for agent ID = &quot; + shiftBidderID);</span>
<span class="nc" id="L2033">            return sbrDAO.getApprovedRequestIDByShiftBidderAndAuctionID(shiftBidderID, auctionID);</span>
        } finally {
<span class="nc bnc" id="L2035" title="All 4 branches missed.">           if (sbrDAO != null) sbrDAO.cleanUp();</span>
        }
    }

    public void withdrawApprovedBidRequest(ShiftBidRequest request, String comment) throws RmHardValidationException,Exception {
<span class="nc" id="L2040">        Jdmo dmo = null;</span>
<span class="nc" id="L2041">        BiddableScheduleDAO bsDAO = null;</span>
<span class="nc" id="L2042">        ShiftBidderDAO sbDAO = null;</span>
<span class="nc" id="L2043">        BiddableScheduleInstanceDAO bsInsDAO = null;</span>
<span class="nc" id="L2044">        BiddableShiftDAO bShiftDAO = null;</span>
        try {
<span class="nc" id="L2046">            dmo = new Jdmo(false);</span>
<span class="nc" id="L2047">            bsDAO = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC</span>
                    | BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES | BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES);
<span class="nc" id="L2049">            sbDAO = new ShiftBidderDAO(RequestDetailLevel.DL_SHIFTBIDDER);</span>
<span class="nc" id="L2050">            bsInsDAO = new BiddableScheduleInstanceDAO(BiddableScheduleInstance.DL_BASIC);</span>
<span class="nc" id="L2051">            bShiftDAO = new BiddableShiftDAO(dmo, BiddableShift.DL_BASIC);</span>

<span class="nc" id="L2053">            ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L2054">            Employee bidderEmp = request.getOptMethods().getEmployee();</span>
<span class="nc" id="L2055">            ShiftBidder bidder = request.getOptMethods().getShiftBidder();</span>

            //get the biddable schedules associated with the request
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2059">            List&lt;ShiftBidRequestBiddableSchedule&gt; sbrbSchedList = request.getOptMethods().getShiftBidRequestBiddableSchedules();</span>
<span class="nc bnc" id="L2060" title="All 6 branches missed.">            if (sbrbSchedList != null &amp;&amp; bidderEmp != null &amp;&amp; bidder != null) {</span>


                // Get assigned BiddableScheduleInstance's
<span class="nc" id="L2064">                Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; assignedBiddableScheduleInstances = getAssignedBiddableScheduleInstances(bsDAO, bsInsDAO, bidderEmp.getID(), sbrbSchedList);</span>

                // Update ShiftBidder (status) and Employee (assigned points)
<span class="nc" id="L2067">                withdrawUpdateShiftBidderAndEmployee(request, sbDAO, bidderEmp, bidder, sbrbSchedList, assignedBiddableScheduleInstances);</span>

                // Update BiddableShift and shift assignments (for employee and phantoms)
<span class="nc" id="L2070">                withdrawUpdateBiddableShiftsAndShiftAssignments(request, sam, bShiftDAO, assignedBiddableScheduleInstances);</span>

                // Update BiddableSchedule, BiddableScheduleInstance
                // This will change BiddableScheduleInstances so it must be after withdrawUpdateBiddableShiftsAndShiftAssignments which is using some info from BiddableScheduleInstances
<span class="nc" id="L2074">                withdrawUpdateBiddableSchedulesAndBiddableScheduleInstances(bsDAO, bsInsDAO, assignedBiddableScheduleInstances);</span>


            }

            //update employee request with status==withdrawn
<span class="nc" id="L2080">            changeRequestStateByID(request.getID(), RequestAuditTrail.STATUS_WITHDRAWN, request.getObjectVersionNumber(), comment);</span>
        } finally {
<span class="nc bnc" id="L2082" title="All 4 branches missed.">            if (bsInsDAO != null) {</span>
<span class="nc" id="L2083">                bsInsDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L2085" title="All 4 branches missed.">            if (bsDAO != null) {</span>
<span class="nc" id="L2086">                bsDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L2088" title="All 4 branches missed.">            if (sbDAO != null) {</span>
<span class="nc" id="L2089">                sbDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L2091" title="All 4 branches missed.">            if (bShiftDAO != null) {</span>
<span class="nc" id="L2092">                bShiftDAO.cleanUp();</span>
            }
<span class="nc bnc" id="L2094" title="All 4 branches missed.">            if (dmo != null) {</span>
<span class="nc" id="L2095">                dmo.cleanUp();</span>
            }
        }
<span class="nc" id="L2098">    }</span>

    private Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; getAssignedBiddableScheduleInstances(
            BiddableScheduleDAO bsDAO, BiddableScheduleInstanceDAO bsInsDAO,
            ID employeeID, List&lt;ShiftBidRequestBiddableSchedule&gt; sbrbSchedList)
            throws Exception {
<span class="nc" id="L2104">        Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; assignedInstances = new HashMap&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt;();</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">        for (ShiftBidRequestBiddableSchedule sbrbSched : sbrbSchedList) {</span>
<span class="nc" id="L2106">            BiddableSchedule bSched = (BiddableSchedule) bsDAO.getObjectByID(sbrbSched.getBiddableScheduleID());</span>
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L2108">            Collection&lt;BiddableScheduleInstance&gt; bsiColl = bsInsDAO.getObjects(&quot; BIDDABLESCHEDULEID= &quot; + sbrbSched.getBiddableScheduleID()</span>
                + &quot; and EMPLOYEEID=&quot; + employeeID + &quot; and STATUS=&quot; + BiddableScheduleInstance.STATUS_ASSIGNED);
<span class="nc bnc" id="L2110" title="All 2 branches missed.">            if (bsiColl.isEmpty()) {</span>
<span class="nc" id="L2111">                throw new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.SBR_WITHDRAW_NO_EMPLOYEE_FOUND, null);</span>
            }
<span class="nc" id="L2113">            assignedInstances.put(bSched, bsiColl);</span>
<span class="nc" id="L2114">        }</span>
<span class="nc" id="L2115">        return assignedInstances;</span>
    }

    private Map&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt; getShiftAssignmentsByBiddableScheduleInstances(
            Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; biddableScheduleInstances) throws BbmFinderException {
<span class="nc" id="L2120">        Map&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt; assignedShiftAssignments = new HashMap&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt;();</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">        for (Collection&lt;BiddableScheduleInstance&gt; bsiColl : biddableScheduleInstances.values()) {</span>
<span class="nc bnc" id="L2122" title="All 2 branches missed.">            for (BiddableScheduleInstance bsi : bsiColl) {</span>
<span class="nc" id="L2123">                assignedShiftAssignments.put(bsi, getShiftAssignmentsByBiddableScheduleInstanceID(bsi.getID()));</span>
<span class="nc" id="L2124">            }</span>
<span class="nc" id="L2125">        }</span>
<span class="nc" id="L2126">        return assignedShiftAssignments;</span>
    }


    @SuppressWarnings(&quot;unchecked&quot;)
    private void withdrawUpdateShiftBidderAndEmployee(ShiftBidRequest request, ShiftBidderDAO sbDAO, Employee bidderEmp,
            ShiftBidder bidder, List&lt;ShiftBidRequestBiddableSchedule&gt; sbrbSchedList,
            Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; assignedBiddableScheduleInstances)
            throws Exception {
        //update employee points if relevant,
        /*Fix for Bug# 91880, Sameet, Apr 2006
        Rollback bonus points awarded to an emp for a Bid that is withdrawn after approval*/
<span class="nc bnc" id="L2138" title="All 2 branches missed.">        if (!sbrbSchedList.isEmpty()) {</span>
<span class="nc" id="L2139">            int totalPointsTobeRedeemed = 0;</span>
<span class="nc" id="L2140">            int totalSchedBonusPoints = 0;</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">            for (BiddableSchedule bSched : assignedBiddableScheduleInstances.keySet()) {</span>
<span class="nc bnc" id="L2142" title="All 2 branches missed.">                for (BiddableScheduleInstance bsi : assignedBiddableScheduleInstances.get(bSched)) {</span>
<span class="nc" id="L2143">                    totalPointsTobeRedeemed = bsi.getPointsUsed(); //All bsi's have the same redmption value, and we only need to redeem it once.</span>
<span class="nc" id="L2144">                }</span>
<span class="nc" id="L2145">                totalSchedBonusPoints += bSched.getBonusPoints();</span>
<span class="nc" id="L2146">            }</span>
<span class="nc" id="L2147">            int bonusPoints = bidderEmp.getAssignedPoints() + totalPointsTobeRedeemed - totalSchedBonusPoints;</span>
<span class="nc" id="L2148">            m_cat.debug(&quot;Rolling back accumulated bonus points for this bid: empID = &quot; + request.getEmployeeID() + &quot;, Assigning POINTS=&quot; + bonusPoints + &quot;, Rolled back points=&quot; + totalSchedBonusPoints);</span>

<span class="nc bnc" id="L2150" title="All 2 branches missed.">            if (bonusPoints &lt; 0) {</span>
<span class="nc" id="L2151">                m_cat.debug(&quot;setting bonus points for this bid: empID = &quot; + request.getEmployeeID() + &quot; to Zero since, bonus Pts=&quot; + bonusPoints);</span>
<span class="nc" id="L2152">                bonusPoints = 0;</span>
            }
<span class="nc" id="L2154">            bidderEmp.setAssignedPoints(bonusPoints);</span>
        }
        //set bidder status to added and update bidder
<span class="nc" id="L2157">        bidder.getSetters().setStatus(ShiftBidder.STATUS_ADDED);</span>
<span class="nc" id="L2158">        bidder.getSetters().updateEmployee(bidderEmp);</span>
<span class="nc" id="L2159">        sbDAO.updateObject(bidder);</span>
<span class="nc" id="L2160">    }</span>

    @SuppressWarnings(&quot;unchecked&quot;)
    private void withdrawUpdateBiddableSchedulesAndBiddableScheduleInstances(BiddableScheduleDAO bsDAO,
            BiddableScheduleInstanceDAO bsInsDAO,
            Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; assignedBiddableScheduleInstances)
            throws Exception {
<span class="nc bnc" id="L2167" title="All 2 branches missed.">        for (BiddableSchedule bSched : assignedBiddableScheduleInstances.keySet()) {</span>
<span class="nc bnc" id="L2168" title="All 2 branches missed.">            for (BiddableScheduleInstance bsi : assignedBiddableScheduleInstances.get(bSched)) {</span>
                //update the biddable schedule with instances += 1
<span class="nc" id="L2170">                bSched.getSetters().setNumOfAvailInstances(bSched.getNumOfAvailableInstances() + 1);</span>
<span class="nc" id="L2171">                bSched.getSetters().setFirstAvailBiddableSchedInstanceID(bsi.getID());</span>

<span class="nc" id="L2173">                bsi.setStatus(BiddableScheduleInstance.STATUS_UNASSIGNED);</span>
<span class="nc" id="L2174">                bsi.setEmployeeID(null);</span>
<span class="nc" id="L2175">                bsi.setPointsUsed(0);</span>

                // for multishift requests, clear approval info
<span class="nc" id="L2178">                bsi.setPhantomStartTime(null);</span>
<span class="nc" id="L2179">                bsi.setPhantomEndTime(null);</span>
<span class="nc" id="L2180">                bsi.setBidSchedInstChecksum(null);</span>
<span class="nc" id="L2181">                bsi.setPhantomShiftID(null);</span>
<span class="nc" id="L2182">                bsi.setPhantomShiftPatternID(null);</span>
<span class="nc" id="L2183">                bsi.setPhantomDescription(null);</span>

                //update instance
<span class="nc" id="L2186">                bsInsDAO.updateObject(bsi);</span>
<span class="nc" id="L2187">                bsDAO.updateObject(bSched);</span>
<span class="nc" id="L2188">            }</span>
<span class="nc" id="L2189">        }</span>
<span class="nc" id="L2190">    }</span>

    private void withdrawUpdateBiddableShiftsAndShiftAssignments(ShiftBidRequest request, ScheduleAccessManager sam,
            BiddableShiftDAO bShiftDAO, Map&lt;BiddableSchedule, Collection&lt;BiddableScheduleInstance&gt;&gt; assignedBiddableScheduleInstances)
            throws Exception {

        // If employee cannot have existing schedules (auction has IncPrevSchedEmp = false), delete employee published schedules
        // If employee can have existing schedules (auction has IncPrevSchedEmp = true), republish employee schedule (to avoid data loss)

<span class="nc" id="L2199">        Collection&lt;TimeRange&gt; timeRangesToPublish = new HashSet&lt;TimeRange&gt;();</span>

        // Get assigned shift assignments
<span class="nc" id="L2202">        Map&lt;BiddableScheduleInstance, Collection&lt;ShiftAssignment&gt;&gt; assignedShiftAssignments = getShiftAssignmentsByBiddableScheduleInstances(assignedBiddableScheduleInstances);</span>

        // For multishift: make sure that the shifts are not changed since approval
<span class="nc bnc" id="L2205" title="All 2 branches missed.">        if (request.getOptMethods().getShiftBidAuction().getIsMultiShift()) {</span>
<span class="nc bnc" id="L2206" title="All 2 branches missed.">            for (BiddableScheduleInstance bsi : assignedShiftAssignments.keySet()) {</span>
<span class="nc" id="L2207">                Collection&lt;ShiftAssignment&gt; saList = assignedShiftAssignments.get(bsi);</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">                for (ShiftAssignment sa : saList) {</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">                    if (!ShiftBidAuctionUtil.computeMD5(sa).equals(bsi.getBidSchedInstCheckSum())) {</span>
<span class="nc" id="L2210">                        throw new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.SBR_WITHDRAW_UNDERLYING_SHIFT_MISMATCH, null);</span>
                    }
<span class="nc" id="L2212">                }</span>
<span class="nc" id="L2213">            }</span>
        }

<span class="nc bnc" id="L2216" title="All 2 branches missed.">        if (!request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp()) {</span>
            // legacy logic using unpublish method for whole request range
<span class="nc" id="L2218">            Date startPub = null;</span>
<span class="nc" id="L2219">            Date endPub = null;</span>
<span class="nc bnc" id="L2220" title="All 2 branches missed.">            for (BiddableSchedule bSched : assignedBiddableScheduleInstances.keySet()) {</span>
<span class="nc bnc" id="L2221" title="All 2 branches missed.">                for (BiddableScheduleInstance bsi : assignedBiddableScheduleInstances.get(bSched)) {</span>
<span class="nc" id="L2222">                    Collection&lt;ShiftAssignment&gt; saList = assignedShiftAssignments.get(bsi);</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">                    for (ShiftAssignment sa : saList) {</span>
<span class="nc bnc" id="L2224" title="All 4 branches missed.">                        if (startPub == null || sa.getStartTime().before(startPub)) {</span>
<span class="nc" id="L2225">                            startPub = sa.getStartTime();</span>
                        }
<span class="nc bnc" id="L2227" title="All 4 branches missed.">                        if (endPub == null || sa.getEndTime().after(endPub)) {</span>
<span class="nc" id="L2228">                            endPub = sa.getEndTime();</span>
                        }
<span class="nc" id="L2230">                    }</span>
<span class="nc" id="L2231">                }</span>
<span class="nc" id="L2232">            }</span>

<span class="nc bnc" id="L2234" title="All 4 branches missed.">            if (startPub != null &amp;&amp; endPub != null) {</span>
<span class="nc" id="L2235">                timeRangesToPublish.add(new TimeRange(startPub, endPub));</span>
            }
<span class="nc" id="L2237">        } else {</span>
            // new logic use publish method for separate shift durations
<span class="nc bnc" id="L2239" title="All 2 branches missed.">            for (BiddableScheduleInstance bsi : assignedShiftAssignments.keySet()) {</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">                for (ShiftAssignment sa : assignedShiftAssignments.get(bsi)) {</span>
<span class="nc" id="L2241">                    timeRangesToPublish.add(new TimeRange(sa.getStartTime(), sa.getEndTime()));</span>
<span class="nc" id="L2242">                }</span>
<span class="nc" id="L2243">            }</span>
        }

        // create phantom shift assignments and update (or remove) employee shift assignments
        // BE CAREFUL: assignedShiftAssignments will be modified as side effect of this call
<span class="nc" id="L2248">        Map&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; targetShiftAssignments = RequestUtil.moveShiftAssnsToPhantom(assignedShiftAssignments, request, sam, bShiftDAO);</span>

        // recreate BiddableShift objects (because old BiddableShift objects were cascade deleted when deleting source shift assignments above)
<span class="nc bnc" id="L2251" title="All 2 branches missed.">        for (ID bsiID : targetShiftAssignments.keySet()) {</span>
<span class="nc" id="L2252">            updateBiddableShiftsForBiddableScheduleInstance(bsiID, targetShiftAssignments.get(bsiID));</span>
<span class="nc" id="L2253">        }</span>

        // Update employee published schedule
<span class="nc bnc" id="L2256" title="All 4 branches missed.">        if (!request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp() &amp;&amp; timeRangesToPublish.size() == 1) {</span>
            // legacy logic
<span class="nc" id="L2258">            TimeRange timeRangeToPublish = timeRangesToPublish.iterator().next();</span>
<span class="nc" id="L2259">            sam.unPublishSchedule(Collections.singleton(request.getEmployeeID()), timeRangeToPublish.getStartDate(), timeRangeToPublish.getEndDate());</span>
<span class="nc bnc" id="L2260" title="All 2 branches missed.">        }  else if (request.getOptMethods().getShiftBidAuction().getIncPrevSchedEmp()) {</span>
            // new logic
<span class="nc bnc" id="L2262" title="All 2 branches missed.">            for (TimeRange timeRangeToPublish : timeRangesToPublish) {</span>
<span class="nc" id="L2263">                sam.publishSchedule(Collections.singleton(request.getEmployeeID()), timeRangeToPublish.getStartDate(), timeRangeToPublish.getEndDate());</span>
<span class="nc" id="L2264">            }</span>
        }
<span class="nc" id="L2266">    }</span>

	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
    throws BbmRemoveException, RmHardValidationException
	{
<span class="nc" id="L2272">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L2273">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L2275">		ShiftBidRequestDAO toReqDao = null;</span>
<span class="nc" id="L2276">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2277">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2279">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2281">		    String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L2283">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L2285">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L2288">		    toReqDao =  new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);</span>
<span class="nc" id="L2289">		    toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
<span class="nc" id="L2290">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2296">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2297">			throw e;</span>
<span class="nc" id="L2298">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L2299">			m_cat.error(e, e);</span>
<span class="nc" id="L2300">			handleException(e);</span>
<span class="nc" id="L2301">			throw e;</span>
<span class="nc" id="L2302">		} catch (Exception e) {</span>
<span class="nc" id="L2303">		    handleException(e);</span>
<span class="nc" id="L2304">		    throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2306" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2307">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2309" title="All 4 branches missed.">			if (toReqDao != null) {</span>
<span class="nc" id="L2310">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L2312">		    methodFinish();</span>
<span class="nc" id="L2313">		}</span>
<span class="nc" id="L2314">	}</span>


	public Map&lt;ID, Integer&gt; getUnsubmittedSchedulePreference(ID auctionID, ID employeeID) {
<span class="nc" id="L2318">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L2320">			return dao.getUnsubmittedSchedulePreference(auctionID, employeeID);</span>
		} finally {
<span class="nc" id="L2322">			dao.cleanUp();</span>
		}
	}

	public void updateUnsubmittedSchedulePreference(Collection&lt;UnsubmittedShiftBidPreference&gt; preferences) {
<span class="nc" id="L2327">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L2329">			dao.updateUnsubmittedSchedulePreference(preferences);</span>
		} finally {
<span class="nc" id="L2331">			dao.cleanUp();</span>
<span class="nc" id="L2332">		}</span>
<span class="nc" id="L2333">	}</span>

	//The transaction setting for this method is set to &quot;NotSupported&quot; in ejb-jar.xml
	//createRequest which in the main call to create an individual request also has &quot;NotSupported&quot; specified
	//This ensures that each create logic runs in its own transaction and an error on one does not cause the whole process
	//to be rolledback
	public void createRequestsFromUnsubmittedPreferences(ShiftBidAuction auction, ID bidderID, int employeeRank) {

<span class="nc" id="L2341">		ID auctionID = auction.getID();</span>
<span class="nc" id="L2342">		String auctionName = auction.getName();</span>

<span class="nc" id="L2344">		List&lt;UnsubmittedShiftBidPreference&gt; unsubmittedPreferences = UnsubmittedSchedulePreferenceDao</span>
<span class="nc" id="L2345">				.getUnsubmittedSchedulePreferencesForBidder(auctionID, bidderID);</span>

<span class="nc" id="L2347">		Collections.sort(unsubmittedPreferences, UnsubmittedShiftBidPreference.PREFERENCE_COMPARATOR);</span>
<span class="nc" id="L2348">		validateMultiSubmit(auction, bidderID, unsubmittedPreferences, employeeRank);</span>

<span class="nc" id="L2350">		String auctionNamePrefix = auctionName.substring(0, Math.min(auctionName.length(), 14));</span>

<span class="nc" id="L2352">		Random random = new Random();</span>
<span class="nc" id="L2353">		RmAggregateException aggregateException = new RmAggregateException();</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">		for (UnsubmittedShiftBidPreference pref : unsubmittedPreferences) {</span>
<span class="nc" id="L2355">			MultiShiftBidException exception = createRequestFromPreference(auctionID, bidderID, auctionNamePrefix, pref, random);</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			if (exception != null) {</span>
<span class="nc" id="L2357">				aggregateException.addException(exception);</span>
			}
<span class="nc" id="L2359">		}</span>

<span class="nc bnc" id="L2361" title="All 2 branches missed.">		if (aggregateException.hasExceptions()) {</span>
<span class="nc" id="L2362">			throw aggregateException;</span>
		}
<span class="nc" id="L2364">	}</span>

	private void validateMultiSubmit(ShiftBidAuction auction, ID bidderID, Collection&lt;UnsubmittedShiftBidPreference&gt; preferences,
			int employeeRank) {

<span class="nc" id="L2369">		int submittableRequests = getNumberOfSubmittableRequest(preferences);</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">		if (submittableRequests &lt;= 0) {</span>
<span class="nc" id="L2371">			throw getWrappedHardValidationException(RmEjbBundleKey.NO_SUBMITTABLE_REQUESTS);</span>
		}

<span class="nc bnc" id="L2374" title="All 2 branches missed.">		if (auction.getIsRequiredBids()) {</span>
<span class="nc" id="L2375">			int totalRequests = getTotalSubmittedBids(auction.getID(), bidderID) + submittableRequests;</span>
<span class="nc" id="L2376">			int minSubmissions = auction.getNumOfBidSubmissions() + employeeRank;</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">			if (totalRequests &lt; minSubmissions) {</span>
<span class="nc" id="L2378">				throw getWrappedHardValidationException(RmEjbBundleKey.MIN_NUMBER_OF_SUBMISSIONS_NOT_MET);</span>
			}
		}
<span class="nc" id="L2381">	}</span>

	private RmAggregateException getWrappedHardValidationException(String msgID) {
<span class="nc" id="L2384">		RmAggregateException aggregateException = new RmAggregateException();</span>
<span class="nc" id="L2385">		MultiShiftBidException exp = new MultiShiftBidException(RmEjbBundleKey.BUNDLE_NAME, msgID);</span>
<span class="nc" id="L2386">		aggregateException.addException(exp);</span>
<span class="nc" id="L2387">		return aggregateException;</span>
	}


	private int getNumberOfSubmittableRequest(Collection&lt;UnsubmittedShiftBidPreference&gt; preferences) {
<span class="nc" id="L2392">		int count = 0;</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">		for (UnsubmittedShiftBidPreference pref : preferences) {</span>
<span class="nc bnc" id="L2394" title="All 2 branches missed.">			if (pref.getPreference() &gt; 0) {</span>
<span class="nc" id="L2395">				count++;</span>
			}
<span class="nc" id="L2397">		}</span>
<span class="nc" id="L2398">		return count;</span>
	}

	private MultiShiftBidException createRequestFromPreference(ID auctionID, ID bidderID, String auctionNamePrefix,
			UnsubmittedShiftBidPreference preference, Random random) {

<span class="nc" id="L2404">		int pref = preference.getPreference();</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">		if (pref &lt;= 0) {</span>
<span class="nc" id="L2406">			return null;</span>
		}

<span class="nc" id="L2409">		ID biddableScheduleId = preference.getBiddableScheduleID();</span>
<span class="nc" id="L2410">		String bidName = auctionNamePrefix + &quot; &quot; + smallUniqueString(biddableScheduleId.toInt(), random);</span>
<span class="nc" id="L2411">		ShiftBidRequest request = new ShiftBidRequest(ShiftBidRequest.DL_BASIC);</span>
<span class="nc" id="L2412">		request.setShiftBidAuctionID(auctionID);</span>
<span class="nc" id="L2413">		request.setShiftBidderID(bidderID);</span>
<span class="nc" id="L2414">		request.setName(bidName);</span>
<span class="nc" id="L2415">		request.setPreference(pref);</span>
		//set biddableScheduleID
<span class="nc" id="L2417">		request.setBiddableScheduleIDs(Collections.singletonList(biddableScheduleId));</span>
<span class="nc" id="L2418">		String comment = &quot;auto generated&quot;;</span>
		try {
<span class="nc" id="L2420">			createRequest(request, comment);</span>
<span class="nc" id="L2421">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L2422">			return new MultiShiftBidException(e, getTemplateNameFromBiddableScheduleID(biddableScheduleId));</span>
<span class="nc" id="L2423">		} catch (Exception e) {</span>
<span class="nc" id="L2424">			return new MultiShiftBidException(e, getTemplateNameFromBiddableScheduleID(biddableScheduleId));</span>
<span class="nc" id="L2425">		}</span>

<span class="nc" id="L2427">		return null;</span>
	}

	/*
	 * This used to be a call to UUID.randomUUID() before it was decided that the string generated was too ugly to use as a name.
	 * This attempts to create a 15 char unique string that is good enough for this specific case.
	 *
	 * The name generated need to be unique for the bidderID. This means that biddableScheduleId should be good enough
	 * in most cases since an employee in an auction can only bid on a biddable schedule once. However, the request can be withdrawn
	 * or become invalid. We mix in some bits from the current clock time and a call to random to handle this and concurrency.
	 *
	 */
	private static String smallUniqueString(int biddableScheduleId, Random random) {
<span class="nc" id="L2440">		long time = System.currentTimeMillis();</span>

		//Least significant 35 bits of time. Enough for about 14 months in milliseconds
<span class="nc" id="L2443">		final long leastSignificant35BitsMask = 0x7ffffffffL;</span>

		//reverse so that we keep the bits that are most frequently changing (in case we end up truncating the final string)
<span class="nc" id="L2446">		long timeBits = (Long.reverse(time) &gt;&gt; 35) &amp; leastSignificant35BitsMask;</span>

		//limit the bits we use from biddableScheduleId so that we have enough space for the clock and random bits
<span class="nc" id="L2449">		int idBits = 0xfffff &amp; biddableScheduleId;</span>

		//Use Base58 to get a shorter string so we can get more bits into a string of size 15 (we are limited to alphanumeric so can't use
		// Base64)
		//0 is not in the alphabet for Base58 encoding so it can be used as a separator between the idBits and the time &amp; random bits
<span class="nc" id="L2454">		String uniqueString = String.format(&quot;%s0%s%s&quot;,</span>
<span class="nc" id="L2455">				Base58.encode(idBits),</span>
<span class="nc" id="L2456">				Base58.encode(timeBits),</span>
<span class="nc" id="L2457">				Base58.encode(random.nextInt(0xffffff)));</span>

<span class="nc bnc" id="L2459" title="All 2 branches missed.">		if (uniqueString.length() &gt; 15) {</span>
<span class="nc" id="L2460">			return uniqueString.substring(0, 15);</span>
		}

<span class="nc" id="L2463">		return uniqueString;</span>
	}

	public String getTemplateNameFromBiddableScheduleID(ID biddableScheduleID) {
<span class="nc" id="L2467">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L2469">			return dao.getTemplateNameFromBiddableScheduleID(biddableScheduleID);</span>
		} finally {
<span class="nc" id="L2471">			dao.cleanUp();</span>
		}

	}

	public int getTotalSubmittedBids(ID auctionID, ID bidderID) {
<span class="nc" id="L2477">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L2479">			return dao.getTotalSubmittedBids(auctionID, bidderID);</span>
		} finally {
<span class="nc" id="L2481">			dao.cleanUp();</span>
		}

	}

	/**
	 * &lt;p&gt;
	 * Gets the number of requests by the employee for the specified list of auctions.
	 * &lt;/p&gt;
	 * &lt;p&gt;
	 * The map's key is the auction ID and the value is the count.
	 * &lt;/p&gt;
	 */
	public Map&lt;ID, Integer&gt; getRequestCountsForEmployeeAuctions(ID employeeID, Collection&lt;ID&gt; auctionIDs)
			throws RmException {
<span class="nc" id="L2496">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc" id="L2498">			return dao.getRequestCountsForEmployeeAuctions(employeeID, auctionIDs);</span>
<span class="nc" id="L2499">		} catch (Exception e) {</span>
<span class="nc" id="L2500">			handleException(e);</span>
<span class="nc" id="L2501">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2503">			dao.cleanUp();</span>
		}
	}

	/**
	 * Updates the preferences for the specified requests.
	 */
	public void updatePreferences(Collection&lt;ShiftBidRequest&gt; requests)
			throws RmException, RmHardValidationException {
<span class="nc" id="L2512">		ShiftBidRequestDAO dao = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
		try {
<span class="nc bnc" id="L2514" title="All 2 branches missed.">			if (requests.isEmpty()) {</span>
<span class="nc" id="L2515">				return;</span>
			}
<span class="nc" id="L2517">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>

<span class="nc" id="L2519">			Set&lt;ID&gt; employeeIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L2520" title="All 2 branches missed.">			for (ShiftBidRequest request : requests) {</span>
<span class="nc" id="L2521">				ID employeeID = request.getEmployeeID();</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">				if (!employeeIDs.contains(employeeID)) {</span>
<span class="nc" id="L2523">					ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(employeeID);</span>

					// we aren't changing status so use it for both
<span class="nc" id="L2526">					String status = request.getRequestStatus();</span>
<span class="nc" id="L2527">					checkModifyPrivilege(user, request, status, status, orgID);</span>

<span class="nc" id="L2529">					employeeIDs.add(request.getEmployeeID());</span>
				}
<span class="nc" id="L2531">			}</span>

<span class="nc" id="L2533">			dao.updatePreferences(requests);</span>
<span class="nc" id="L2534">        } catch (RmHardValidationException ex) {</span>
<span class="nc" id="L2535">            handleException(Level.DEBUG, ex);</span>
<span class="nc" id="L2536">			throw ex;</span>
<span class="nc" id="L2537">		} catch (Exception e) {</span>
<span class="nc" id="L2538">			handleException(e);</span>
<span class="nc" id="L2539">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2541">			dao.cleanUp();</span>
<span class="nc" id="L2542">		}</span>
<span class="nc" id="L2543">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>