<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CacheSkill.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.wfm.cache</a> &gt; <span class="el_source">CacheSkill.java</span></div><h1>CacheSkill.java</h1><pre class="source lang-java linenums">/*
 * Created on Sep 23, 2004
 *
 * To change the template for this generated file go to
 * Window&amp;gt;Preferences&amp;gt;Java&amp;gt;Code Generation&amp;gt;Code and Comments
 */
package com.verint.ejb.wfm.cache;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;

import com.bluepumpkin.common.base.Log;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.cache.Cache;
import com.bluepumpkin.ejb.bbm.cache.CacheManager;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * @author rrajendran
 *
 *         To change the template for this generated type comment go to
 *         Window&amp;gt;Preferences&amp;gt;Java&amp;gt;Code Generation&amp;gt;Code and Comments
 */
public class CacheSkill extends Cache {
<span class="nc" id="L32">	private static final Category m_cat = Log.initCategory(CacheSkill.class.getName());</span>

<span class="nc" id="L34">	private SkillManager m_skillManager = null;</span>
	// instance initializer
	{
		try {
<span class="nc" id="L38">			m_skillManager = WfmManagerFactory.getSkillManager();</span>
<span class="nc" id="L39">		} catch (Exception e) {</span>
<span class="nc" id="L40">			throw new RuntimeException(e);</span>
<span class="nc" id="L41">		}</span>
	}

	public static class CacheKeySkill extends CacheKey {
<span class="nc" id="L45">		public static String[] m_cacheKeyFieldNames = new String[] { &quot;m_skillID&quot; };</span>

		public ID m_skillID;

		/**
		 * @param cacheKeyFieldNames
		 */
		public CacheKeySkill(ID skillID) {
<span class="nc" id="L53">			super(m_cacheKeyFieldNames);</span>

<span class="nc" id="L55">			m_skillID = skillID;</span>
<span class="nc" id="L56">		}</span>

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode() {
<span class="nc" id="L65">			return m_skillID.hashCode();</span>
		}
		
		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L70" title="All 4 branches missed.">			if (obj == null || !(obj instanceof CacheKeySkill)) {</span>
<span class="nc" id="L71">				return false;</span>
			}
<span class="nc" id="L73">			ID otherSkillID = ((CacheKeySkill)obj).m_skillID;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">			if (m_skillID == null) {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">				return otherSkillID == null;</span>
			}
<span class="nc" id="L77">			return m_skillID.equals(otherSkillID);</span>
		}
	}

	/**
	 * @param cacheMgr
	 */
	public CacheSkill(CacheManager cacheMgr) {
<span class="nc" id="L85">		super(cacheMgr);</span>
<span class="nc" id="L86">	}</span>

	/**
	 * This method will find the skillIDs which are not already cached and load
	 * them into the cache. If a skillID's skill is marked 'deleted', then it is
	 * stored in the cache as map to a 'null'.
	 * 
	 * @param skillIDs
	 */
	private void addUncachedSkillIDsToCache(Collection&lt;ID&gt; skillIDs) throws BbmFinderException, RemoteException {
		// find skillIDs not in cache.
<span class="nc" id="L97">		Collection&lt;ID&gt; uncachedSkillIDs = null;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iter = skillIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L99">			ID skillID = iter.next();</span>

			// if skillID not in cache.
<span class="nc" id="L102">			CacheKeySkill skillKey = new CacheKeySkill(skillID);</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">			if (!containsKey(skillKey)) {</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">				uncachedSkillIDs = (uncachedSkillIDs == null) ? new ArrayList&lt;ID&gt;() : uncachedSkillIDs;</span>
				// add to uncached ID list.
<span class="nc" id="L106">				uncachedSkillIDs.add(skillID);</span>
			} else {
<span class="nc bnc" id="L108" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L109">					m_cat.debug(CACHE_HIT_MSG + skillKey);</span>
			}
<span class="nc" id="L111">		}</span>

		// if no uncached skill IDs found, simply return.
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (uncachedSkillIDs == null) {</span>
<span class="nc" id="L115">			return;</span>
		}

		// Now bulk load the uncached skillIDs
		//
		// Note: do not use skillMgr.getSkillByID() call. This method throws an
		// exception
		// if the skill is not found (because it is marked deleted) but also
		// marks the transaction
		// for rollback. This prevents logic after the rollback from obtaining
		// any DB connections.
<span class="nc" id="L126">		Collection&lt;Skill&gt; uncachedSkills = m_skillManager.getSkillsByIDs(uncachedSkillIDs);</span>

		// add the loaded skills
<span class="nc bnc" id="L129" title="All 2 branches missed.">		for (Iterator&lt;Skill&gt; iter = uncachedSkills.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L130">			Skill skill = iter.next();</span>

<span class="nc" id="L132">			CacheKeySkill skillKey = new CacheKeySkill(skill.getID());</span>
<span class="nc" id="L133">			put(skillKey, skill);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L135">				m_cat.debug(CACHE_MISS_MSG + skillKey);</span>
			}
<span class="nc" id="L137">		}</span>

		// handle the skill IDs that were not loaded as the skill was marked
		// 'deleted'. Map these
		// skills to 'null'.
<span class="nc bnc" id="L142" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iter = uncachedSkillIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L143">			ID uncachedSkillID = iter.next();</span>

			// if the skillID not found in cache, it was not added by the
			// 'loading' logic above.
			// This means the skillID is marked deleted.
<span class="nc" id="L148">			CacheKeySkill skillKey = new CacheKeySkill(uncachedSkillID);</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">			if (!containsKey(skillKey)) {</span>
				// map it to a 'null'.
<span class="nc" id="L151">				put(skillKey, null);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L153">					m_cat.debug(CACHE_MISS_MSG + skillKey);</span>
			}
<span class="nc" id="L155">		}</span>
<span class="nc" id="L156">	}</span>

	/**
	 * Get the skill for the specified skillID. Note: The returned skill might
	 * be &lt;b&gt;null&lt;/b&gt;. For an explanation of this behavior see
	 * {@link #getSkillIDsNotDeleted(Collection)
	 * getSkillIDsNotDeleted(Collection)} method.
	 * 
	 * @param skillID
	 * @return
	 */
	public Skill getSkillByID(ID skillID) throws BbmFinderException, RemoteException {
<span class="nc" id="L168">		addUncachedSkillIDsToCache(Collections.singleton(skillID));</span>

<span class="nc" id="L170">		return getSkillFromCache(skillID);</span>
	}

	/**
	 * Remove skillIDs which are marked 'deleted' from the specified collection.
	 * Return the filtered skillIDs.
	 * 
	 * &lt;p&gt;
	 * In BBM, a workresource might be associated with a skillID but the skill
	 * referred to by the skillID might be marked 'deleted'. So to find the
	 * skill assignments for a workresource, first the skillAssignments are
	 * fetched and then the skill IDs in the skill assignments are validated to
	 * ensure that they do not refer to 'deleted' skills.
	 * 
	 * @param skillIDs
	 * @return
	 */
	public Collection&lt;ID&gt; getSkillIDsNotDeleted(Collection&lt;ID&gt; skillIDs) throws BbmFinderException, RemoteException {
<span class="nc" id="L188">		addUncachedSkillIDsToCache(skillIDs);</span>

<span class="nc" id="L190">		Collection&lt;ID&gt; notDeletedSkillIDs = new ArrayList&lt;ID&gt;(skillIDs.size());</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iter = skillIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L192">			ID skillID = iter.next();</span>

<span class="nc" id="L194">			Skill skill = getSkillFromCache(skillID);</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">			if (skill != null) {</span>
<span class="nc" id="L196">				notDeletedSkillIDs.add(skillID);</span>
			}
<span class="nc" id="L198">		}</span>

<span class="nc" id="L200">		return notDeletedSkillIDs;</span>
	}

	/**
	 * @param skillID
	 * @return
	 */
	private Skill getSkillFromCache(ID skillID) {
<span class="nc" id="L208">		return (Skill) get(new CacheKeySkill(skillID));</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>