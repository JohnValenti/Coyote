<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeCollectorManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.am.timecollection.ejb</a> &gt; <span class="el_source">TimeCollectorManagerEJB.java</span></div><h1>TimeCollectorManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.am.timecollection.ejb;

import java.rmi.ConnectException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.ListIterator;
import java.util.Map;
import java.util.Set;

import javax.ejb.EJBException;

import com.bluepumpkin.common.config.ConfigManager;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.LogMessage;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.am.AmManagerFactory;
import com.bluepumpkin.ejb.am.Log;
import com.bluepumpkin.ejb.am.base.AmException;
import com.bluepumpkin.ejb.am.base.AmInvalidActivityException;
import com.bluepumpkin.ejb.am.base.AmNoTimeRecordException;
import com.bluepumpkin.ejb.am.base.AmNotLastEndShiftException;
import com.bluepumpkin.ejb.am.base.AmRawEndShiftException;
import com.bluepumpkin.ejb.am.base.AmTimeRecordEndShiftException;
import com.bluepumpkin.ejb.am.l10n.AmEjbBundleKey;
import com.bluepumpkin.ejb.am.l10n.AmEjbLogBundleKey;
import com.bluepumpkin.ejb.am.timecollection.jms.ChangeStateStatusMessage;
import com.bluepumpkin.ejb.am.timecollection.model.PunchStatus;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntry;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntryHandler;
import com.bluepumpkin.ejb.am.timecollection.model.RawTimeEntrySort;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.EmployeeEvent;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeRecordException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.config.model.ConfigDAO;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeRecordManager;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeTrackingManager;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeEntrySourceCode;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecordEntry;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeTrackingEvent;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.licensing.LicenseKeys;

/**
 * Title:        Blue Pumpkin Software Activity Management
 *
 * Description:  EJB Implementation for Time Collection
 *				 It may decide not to create RawTimeEntry, if there is no Payroll License
 *				 It will never send JMS message, as there is no need for Agent Control now
 *				 The only AutoClose policy is add one minute after last open entry in previous shift
 *				 HAA Feed is a seperate implementation now
 *				 Event Audit Trail is introduced for HAA and AutoClose
 *				 Cache is used to cache last entry for a given employee to reduce DB query overhead
 * Copyright:    Copyright (c) 2003
 * Company:      Blue Pumpkin Software, Inc
 * @author       Sheng Song
 * @version 2.0
 * @author       Richard Chandler
 * @version 1.0
 */


<span class="fc" id="L97">public class TimeCollectorManagerEJB extends SessionEJBBase {</span>
<span class="fc" id="L98">	private final static ID GL = Activity.ACTIVITY_GENERAL_TRAINING;</span>
<span class="fc" id="L99">	private final static ID GLENDS = Activity.ACTIVITY_LEARNING_END;</span>
<span class="fc" id="L100">	private final static ID GLSTART = Activity.ACTIVITY_LEARNING_START;</span>
	

	/**
	 * ejb managers
	 */
<span class="fc" id="L106">	private TimeRecordManager m_timeRecordManager = null;</span>
<span class="fc" id="L107">	private TimeTrackingManager m_timeTrackingManager = null;</span>
<span class="fc" id="L108">	private ActivityManager m_activityManager = null;</span>
<span class="fc" id="L109">	private DBConfigManager m_DBConfigManager = null;</span>
<span class="fc" id="L110">	private EventAuditTrailManager m_auditManager = null;</span>
<span class="fc" id="L111">	private HAATimeEntryManager m_haaManager = null;</span>
<span class="fc" id="L112">	private WorkResourceManager m_workResourceManager = null;</span>

	// IDs should not be inserted from MyTime
<span class="fc" id="L115">	private final static ID[] ProhibitInsertActivities = {Activity.ACTIVITY_NONE,</span>
														  Activity.ACTIVITY_UNKNOWN};

	// BP Config attributes
	private final static boolean PerformAutoClose = true; //should time collection auto close records? Always auto close
<span class="fc" id="L120">	private static boolean IsConfigDataLoaded = false; //ensure that bp config is loaded only once</span>
<span class="fc" id="L121">	private static boolean CreateTimeRecords = true; //should time collection create records in the database?</span>
<span class="fc" id="L122">	private static boolean PerformAutoMerge = true; // should time collection merge records?</span>
<span class="fc" id="L123">	private static boolean FixZeroDuration = true;</span>

<span class="fc" id="L125">	private static int AutoCloseTimeoutInMillis = 600 * TimeZoneUtil.MINUTE_IN_MILLISECONDS; //time out for auto close decision</span>
<span class="fc" id="L126">	private static int AutoMergeTimeoutInMillis = 120 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>

	// License for generation of RawTimeEntries
<span class="fc" id="L129">	private static boolean NeedRawEntry = false;</span>

	// Activity information
	private static final int PAID_ACTIVE = 1;
	private static final int PAID_INACTIVE = -2;
	private static final int UNPAID_ACTIVE = 0;
	private static final int UNPAID_INACTIVE = -3;

	// cache usage
<span class="fc" id="L138">	private boolean ActivityCached = false;</span>
	/**
	 * time dependent cache for preformance
	 */
	private final static int MINUTE = 60000;
	private final static int ACTIVITIES_ISPAID_TIMEOUT = 15*TimeZoneUtil.MINUTE_IN_MILLISECONDS;
<span class="fc" id="L144">	private static long ActivitedIsPaidChecked = 0;</span>
<span class="fc" id="L145">	private static Hashtable ActivitiesIsPaidCacheTable = null;</span>
<span class="fc" id="L146">	private static long UnknownEventInterval = 720 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>

	// initialization code
<span class="fc" id="L149">	private final static String clsName = TimeCollectorManagerEJB.class.getName();</span>
<span class="fc" id="L150">	private static Category m_cat = Log.initCategory(clsName);</span>

	protected Category getCategory() {
<span class="fc" id="L153">		return m_cat;</span>
	}

	{
<span class="fc" id="L157">		super.init(clsName);</span>
<span class="fc" id="L158">	}</span>

	/**
	 * &lt;B&gt;ejbCreate&lt;/B&gt;
	 *
	 * creates ejb managers during ejb create
	 *
	 */
	public void ejbCreate() {
		try {
			//----------------------------------------------
			// ejbs
			//----------------------------------------------
<span class="fc" id="L171">			m_timeRecordManager = WfmManagerFactory.getTimeRecordManager();</span>
<span class="fc" id="L172">			m_timeTrackingManager = BbmManagerFactory.getTimeTrackingManager();</span>
<span class="fc" id="L173">			m_activityManager = WfmManagerFactory.getActivityManager();</span>
<span class="fc" id="L174">			m_DBConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="fc" id="L175">			m_auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="fc" id="L176">			m_haaManager = AmManagerFactory.getHAAManager();</span>
<span class="fc" id="L177">			m_workResourceManager = BbmManagerFactory.getWorkResourceManager();</span>
			
			//----------------------------------------------
			// get db config init parameters
			//----------------------------------------------
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">			if(!IsConfigDataLoaded) {</span>
				// check license manager for Payroll License
<span class="fc" id="L184">				NeedRawEntry = CoreManagerFactory.getLicenseManager().isLicensed(LicenseKeys.APP_PAYROLL);</span>
				// load other config data
<span class="fc" id="L186">				String valueStr = null;</span>
<span class="fc" id="L187">				int valueInt = 0;</span>
				// create time records?
<span class="fc" id="L189">				valueStr = m_DBConfigManager.getValue(TimeCollectorManager.CREATE_TIMERECORDS_KEY);</span>
<span class="pc bpc" id="L190" title="3 of 4 branches missed.">				if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L191">					CreateTimeRecords = false;</span>
				} else {
<span class="fc" id="L193">					CreateTimeRecords = true;</span>
				}
				// Fix Zero duration entry?
<span class="fc" id="L196">				valueStr = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_EXPOSE_ZERO_DURATION);</span>
<span class="fc" id="L197">				ConfigDAO configDao = new ConfigDAO();</span>
				try {
<span class="fc" id="L199">				String dbValue = configDao.GetValue(ConfigKey.TIMERECORDS_EXPOSE_ZERO_DURATION);</span>
<span class="pc bpc" id="L200" title="3 of 6 branches missed.">				if( valueStr == null || (dbValue != null &amp;&amp; !dbValue.trim().equalsIgnoreCase(valueStr)) ){</span>
<span class="nc" id="L201">					m_cat.error(&quot; ******** Value of FixZeroDuration from DB=&quot; + dbValue + &quot; does not match cached value=&quot; + valueStr + &quot; using DB value&quot;);</span>
<span class="nc" id="L202">					valueStr = dbValue;</span>
				}
				} finally {
<span class="pc" id="L205">					configDao.cleanUp();</span>
<span class="fc" id="L206">				}</span>
<span class="pc bpc" id="L207" title="2 of 4 branches missed.">				if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L208">					FixZeroDuration = false;</span>
				} else {
<span class="fc" id="L210">					FixZeroDuration = true;</span>
				}
<span class="fc" id="L212">				m_cat.info(&quot; ******** Value of FixZeroDuration=&quot; + FixZeroDuration + &quot; cacheUsed=&quot; + m_DBConfigManager.cacheUsed() );</span>
				// Auto merge
<span class="fc" id="L214">				valueStr = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_AUTO_MERGE);</span>
<span class="pc bpc" id="L215" title="2 of 4 branches missed.">				if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;false&quot;)) {</span>
<span class="nc" id="L216">					PerformAutoMerge = false;</span>
				} else {
<span class="fc" id="L218">					PerformAutoMerge = true;</span>
				}
<span class="pc bpc" id="L220" title="1 of 2 branches missed.">				if (PerformAutoMerge) {</span>
<span class="fc" id="L221">					valueInt = m_DBConfigManager.getIntValue(ConfigKey.TIMERECORDS_MERGE_WITH_TIMEOUT);</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">					if (valueInt != ConfigManager.NOVALUE) AutoMergeTimeoutInMillis = valueInt * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
				}
				// Auto Close
<span class="fc" id="L225">				valueInt = m_DBConfigManager.getIntValue(ConfigKey.TIMERECORDS_TIMEOUT);</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">				if (valueInt != ConfigManager.NOVALUE) AutoCloseTimeoutInMillis = valueInt * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
				// If cache is enabled at first, instantiate cache
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">				if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.ACTIVITY_CACHE_USAGE))</span>
<span class="fc" id="L229">					ActivityCached = true;</span>
<span class="fc" id="L230">				valueStr = m_DBConfigManager.getValue(TimeCollectorManager.UNKNOWN_EVENT_TIME_RANGE);</span>
<span class="pc bpc" id="L231" title="3 of 4 branches missed.">				if (valueStr != null &amp;&amp; valueStr.length() &gt; 0) {</span>
<span class="nc" id="L232">					UnknownEventInterval = Integer.parseInt(valueStr) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
				}
			}
<span class="nc" id="L235">		} catch (Exception e) {</span>
			// log problem but continue operation with default values
			// alos set m_isConfigDataLoaded to false so next ejb will try to load agian
<span class="nc" id="L238">			m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_BP_CONFIG, e);</span>
<span class="nc" id="L239">			setBPConfigDefaults();</span>
		} finally {
<span class="pc" id="L241">			IsConfigDataLoaded = true;</span>
<span class="pc" id="L242">		}</span>
<span class="fc" id="L243">	}</span>


	/**
	= * &lt;B&gt;ejbRemove&lt;/B&gt;
	 *
	 * creates ejb managers during ejb create
	 *
	 */
	public void ejbRemove() {
		try {
<span class="nc bnc" id="L254" title="All 2 branches missed.">			if (m_DBConfigManager != null)</span>
<span class="nc" id="L255">				m_DBConfigManager.remove();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (m_activityManager != null)</span>
<span class="nc" id="L257">				m_activityManager.remove();</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">			if (m_timeRecordManager != null)</span>
<span class="nc" id="L259">				m_timeRecordManager.remove();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">			if (m_auditManager != null)</span>
<span class="nc" id="L261">				m_auditManager.remove();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">			if (m_haaManager != null)</span>
<span class="nc" id="L263">				m_haaManager.remove();</span>
<span class="nc" id="L264">		} catch (Exception ignore) {</span>
<span class="nc" id="L265">			m_cat.l7dError(ignore.getMessage());</span>
<span class="nc" id="L266">		}</span>
<span class="nc" id="L267">	}</span>


	/**
	 * &lt;B&gt;deleteUnknownActivities&lt;/B&gt;
	 *
	 *   deletes 'Unknown Activities' with given Date from db
	 *   these activities are system generated activities
	 *   and meant as temporary placeholders
	 *
	 *  @param date    date to delete
	 * @deprecated
	 *
	 */
	public void deleteUnknownActivities(Date date) throws AmException {
<span class="nc" id="L282">		methodStart(&quot;deleteUnknownActivities&quot;, date);</span>
		try {
<span class="nc" id="L284">			TimeCollectorDAO.deleteUnknownActivities(date);</span>
<span class="nc" id="L285">		} catch( JdmoException e ) {</span>
<span class="nc" id="L286">			handleException(e,false);</span>
<span class="nc" id="L287">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L289">			methodFinish();</span>
<span class="nc" id="L290">		}</span>
<span class="nc" id="L291">	}</span>

	/**
	 * &lt;B&gt;manualEndShift&lt;/B&gt;
	 *
	 *   TimeRecord id exist in RawTimeEntry table
	 *     insert an end shift in the RawTimeEntry table
	 *   Other wise end the shift in the TimeEntryEvent table
	 *
	 *  @param timeRecordID      Time Record ID
	 *  @param employeeID      Employee ID
	 *  @param remarkerID	manager ID
	 *  @param endDate    Date of end shift
	 *  @param deviceID  MyTime device id
	 *
	 */
	public void manualEndShift(ID timeRecordID, ID employeeID, ID remarkerID,
							   Date endDate, String deviceID)
							   throws AmRawEndShiftException, AmTimeRecordEndShiftException, AmException {
<span class="nc" id="L310">		methodStart(&quot;manualEndShift&quot;, timeRecordID, employeeID, endDate, deviceID);</span>
		try {
			//---------------------------------------------------------------------
			//  FIRST check TimeRecord table
			//    does timerecord id exist?
			//    will this be the last entry?
			//---------------------------------------------------------------------
<span class="nc bnc" id="L317" title="All 2 branches missed.">			if (!TimeCollectorDAO.lastEntryAndEndShift(timeRecordID, endDate)) {</span>
<span class="nc" id="L318">				throw new AmNotLastEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_NOT_LAST_END_SHIFT_ERROR);</span>
			} else {
<span class="nc" id="L320">				ID rawEntryID = null;</span>
<span class="nc" id="L321">				RawTimeEntry rawTimeEntry = new RawTimeEntry(employeeID, Activity.ACTIVITY_NONE,</span>
											timeRecordID, null,	RawTimeEntry.MANUAL_END_SHIFT, endDate);
<span class="nc" id="L323">				rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.MANUAL);</span>
				//---------------------------------------------------------------------
				//  if license requires RawTimeEntry create raw time entry
				//  if RawTimeEntry table doesn't already have an end shift
				//    create RawTimeEntry END_SHIFT entry in database
				//---------------------------------------------------------------------
<span class="nc bnc" id="L329" title="All 2 branches missed.">				if (NeedRawEntry) {</span>
					//------------------------------------------------------------
					//  if no BPX pre-set status to successful
					//------------------------------------------------------------
<span class="nc" id="L333">					rawTimeEntry.setPunchStatus(ChangeStateStatusMessage.SUCCESSFUL);</span>
					//------------------------------------------------------------
					//  create entry in RAWTIMEENTRY table
					//------------------------------------------------------------
<span class="nc" id="L337">					rawEntryID = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
<span class="nc" id="L338">					rawTimeEntry.setId(rawEntryID);</span>
				}
				//---------------------------------------------------------------------
				//  SECOND, always create TimeEntryEvent END_SHIFT entry in database
				//---------------------------------------------------------------------
				try {
					//---------------------------------------------------------------------
					//  check if timerecord is closed before inserting END_SHIFT
					//---------------------------------------------------------------------
<span class="nc" id="L347">					TimeRecordEntry timeRecordEntry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, remarkerID, false);</span>
<span class="nc" id="L348">					m_timeRecordManager.createTimeRecordEntry(timeRecordID, timeRecordEntry);</span>
<span class="nc" id="L349">				} catch (Exception e) {</span>
<span class="nc" id="L350">					handleException(e);</span>
<span class="nc" id="L351">					throw new AmTimeRecordEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_TIMERECORD_END_SHIFT_ERROR);</span>
<span class="nc" id="L352">				}</span>
			}
<span class="nc" id="L354">		} catch (JdmoException e) {</span>
<span class="nc" id="L355">			handleException(e);</span>
<span class="nc" id="L356">			throw new AmRawEndShiftException(AmEjbBundleKey.TIMECOLLECTOR_RAW_END_SHIFT_ERROR);</span>
		} finally {
<span class="nc" id="L358">			methodFinish();</span>
<span class="nc" id="L359">		}</span>
<span class="nc" id="L360">	}</span>

	/**
	 * &lt;B&gt;findCurrentActivity&lt;/B&gt;
	 *
	 *  locates last activity for given employee id
	 *
	 *  @param employeeID ID of employee
	 *
	 *  @return Activity, employees current Activity
	 *
	 */
	public Activity findCurrentActivity(ID employeeID) throws AmException {
<span class="fc" id="L373">		methodStart(&quot;findCurrentActivity&quot;,employeeID);</span>
		try {
			// If cache used, get last activity id from cached event
<span class="fc" id="L376">			Event event = m_timeRecordManager.getLastEntry(employeeID, null);</span>
<span class="pc bpc" id="L377" title="1 of 4 branches missed.">			if (event != null &amp;&amp; event.getActivityID() != null)</span>
<span class="fc" id="L378">				return m_activityManager.findActivityById(event.getActivityID());</span>
<span class="fc" id="L379">			return null;</span>
<span class="nc" id="L380">		} catch(Exception e) {</span>
<span class="nc" id="L381">			handleException(e,false);</span>
<span class="nc" id="L382">			throw new AmException(e);</span>
		} finally {
<span class="pc" id="L384">			methodFinish();</span>
		}
	}

	/**
	 * &lt;B&gt;findEventHistoryForEmployee&lt;/B&gt;
	 * &lt;P&gt;
	 * To obtain event history for given employee in a given period of time
	 *
	 *  @param employeeID      ID of employee
	 *  @param startDate       time to begin search
	 *  @param endDate         time to end search
	 * &lt;P&gt;
	 *  @return Collection of MyTimeEvent objects
	 *
	 */
	public Collection findEventHistoryForEmployee(  ID employeeID,
													Date startDate,
													Date endDate) throws AmException {
<span class="nc" id="L403">		methodStart(&quot;findEventHistoryForEmployee&quot;, employeeID, startDate, endDate);</span>
		try {
<span class="nc" id="L405">			return m_timeRecordManager.getValidEventsForWorkResource(employeeID, startDate, endDate);</span>
<span class="nc" id="L406">		} catch(Exception e) {</span>
<span class="nc" id="L407">			handleException(e, false);</span>
<span class="nc" id="L408">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L410">			methodFinish();</span>
		}
	}


	/**
	 * findPreceedingRawTimeEntries
	 *
	 * finds the rawtimeentry for each employee and datasource
	 *
	 *
	 * @return Collection of RawTimeEntry objects
	 */
	public Collection findPreceedingRawTimeEntries() throws AmException {
<span class="nc" id="L424">		methodStart(&quot;findPreceedingRawTimeEntries&quot;);</span>
		try {
<span class="nc" id="L426">			return m_timeRecordManager.findLastEntries();</span>
<span class="nc" id="L427">		} catch(Exception e) {</span>
<span class="nc" id="L428">			handleException(e,false);</span>
<span class="nc" id="L429">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L431">			methodFinish();</span>
		}
	}
	/**
	 * findPreceedingRawTimeEntries
	 *
	 * finds the rawtimeentry for each employee and datasource
	 * that precedes the given date
	 *
	 * @param employeeIDs    collection of employee ID's
	 * @param dataSourceID   ID of dataSource
	 * @param date           date search criteria
	 *
	 * @return Collection of RawTimeEntry objects
	 */
	public Collection findPreceedingRawTimeEntries(  Collection employeeIDs,
													 ID dataSourceID,
													 Date date)
			throws AmException {
<span class="nc" id="L450">		methodStart(&quot;findPreceedingRawTimeEntries&quot;, employeeIDs, dataSourceID, date);</span>
		try {
<span class="nc" id="L452">			return m_timeRecordManager.findLastEntries(employeeIDs, dataSourceID, date);</span>
<span class="nc" id="L453">		} catch(Exception e) {</span>
<span class="nc" id="L454">			handleException(e,false);</span>
<span class="nc" id="L455">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L457">			methodFinish();</span>
		}
	}

	/**
	 * findPunchErrorsForEmployee
	 *
	 * returns a collection of PunchErrors for employees
	 * last punch (rawtimeentry)
	 *
	 * @param employeeID   employee ID
	 *
	 * @return Collection of PunchError objects
	 */
	public Collection findPunchErrorsForEmployee(ID employeeID) throws AmException {
<span class="nc" id="L472">		methodStart(&quot;findPunchErrorsForEmployee&quot;,employeeID);</span>
		try {
<span class="nc" id="L474">			return null;</span>
		} finally {
<span class="nc" id="L476">			methodFinish();</span>
		}
	}

	/**
	 * findPunchErrorsForPunchID
	 *
	 * returns a collection of PunchErrors for a given RawTimeEntry ID
	 *
	 * @param rawTimeEntryID   RawTimeEntry ID used for search
	 *
	 * @return Collection of PunchError objects
	 */
	public Collection findPunchErrorsForRawTimeEntryID(ID rawTimeEntryID) throws AmException {
<span class="nc" id="L490">		methodStart(&quot;findPunchErrorsForRawTimeEntryID&quot;,rawTimeEntryID);</span>
		try {
<span class="nc" id="L492">			return null;</span>
		} finally {
<span class="nc" id="L494">			methodFinish();</span>
		}
	}

	/**
	 * &lt;B&gt;getPunchStatus&lt;/B&gt;
	 * &lt;P&gt;
	 *  pulls status of activity change from RawTimeEntry table
	 *
	 *  @param rawTimeEntryID      ID
	 * &lt;P&gt;
	 *  @return      int value of status
	 *               ChangeStateStatusMessage.UNDETERMINED = 0;
	 *               ChangeStateStatusMessage.SUCCESSFUL = 1;
	 *               ChangeStateStatusMessage.SUCCESSFUL_WITH_WARNINGS = 2;
	 *               ChangeStateStatusMessage.FAILED = 3;
	 *
	 */
	public PunchStatus getPunchStatus(ID rawTimeEntryID) throws AmException {
<span class="nc" id="L513">		methodStart(&quot;findPunchStatus&quot;,rawTimeEntryID);</span>
		try {
<span class="nc" id="L515">			return null;</span>
		} finally {
<span class="nc" id="L517">			methodFinish();</span>
		}
	}

	/**
	 * If eLearning import is per window, we can optimize by import in group
	 * @param empEntryMap
	 * @throws AmException
	 */
	public void insertELEntries(Map empEntryMap, Date start, Date end) throws AmException {
<span class="nc" id="L527">		methodStart(&quot;insertELEntries&quot;, empEntryMap, start, end);</span>
		try {
<span class="nc" id="L529">			insertHAAEntries(empEntryMap, empEntryMap.keySet(), start, end, true);				</span>
<span class="nc" id="L530">		} catch(AmException e) {</span>
<span class="nc" id="L531">			throw e;</span>
<span class="nc" id="L532">		} catch(Exception e) {</span>
<span class="nc" id="L533">			throw new AmException(e);</span>
		} finally {			
<span class="nc" id="L535">			methodFinish();</span>
<span class="nc" id="L536">		}		</span>
<span class="nc" id="L537">	}</span>
	
	
	/**
	 * Handle Historical Agent Adherence data, for a given time window
	 * Based on DataSourceFailure ID to retrieve HAA entries
	 * Based on DataSourceID to obtain Employee-DataSource association
	 *
	 * @param acdFailureID
	 * @param dataSourceID
	 * @param start
	 * @param end
	 * @throws AmException
	 */
	public void insertHAAEntries(ID acdFailureID, ID dataSourceID, Date start, Date end) throws AmException {
<span class="nc" id="L552">		methodStart(&quot;insertHAAEntries&quot;, acdFailureID, dataSourceID, start, end);</span>
<span class="nc" id="L553">		Jdmo jdmo = new Jdmo();</span>
		try {
			// fetch all HAA entries
<span class="nc" id="L556">			HashMap haaEntryMap = m_haaManager.getHAATimeEntries(acdFailureID);</span>
			// try to figure out the Employees to be fixed
<span class="nc" id="L558">			int empSize = 100;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">			if (!haaEntryMap.isEmpty())</span>
<span class="nc" id="L560">				empSize = haaEntryMap.keySet().size();</span>
			// fetch associated employees
<span class="nc" id="L562">			String strSQL = &quot;SELECT EMPLOYEEID FROM EMPLOYEEDATASOURCE WHERE DATASOURCEID=?&quot;;</span>
<span class="nc" id="L563">			HashSet empSet = new HashSet(empSize);</span>
<span class="nc" id="L564">			JdmoQuery jQuery = jdmo.createQuery(strSQL, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L565">			jQuery.setParID(1, dataSourceID);</span>
<span class="nc" id="L566">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L568">				empSet.add(rs.getID(1));</span>
			}
<span class="nc" id="L570">			rs.close();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L572">				m_cat.debug(&quot;Find following employees &quot;+empSet+&quot; associated with datasource &quot;+dataSourceID);</span>
			}
<span class="nc" id="L574">			insertHAAEntries(haaEntryMap, empSet, start, end, false);</span>
<span class="nc" id="L575">		} catch(AmException e) {</span>
<span class="nc" id="L576">			throw e;</span>
<span class="nc" id="L577">		} catch(Exception e) {</span>
<span class="nc" id="L578">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L580">			jdmo.cleanUp();</span>
<span class="nc" id="L581">			methodFinish();</span>
<span class="nc" id="L582">		}</span>
<span class="nc" id="L583">	}</span>

	private void adjustELEntries( ArrayList extRecordList, Collection elEntries, Date start, Date end )
	{
<span class="nc bnc" id="L587" title="All 4 branches missed.">		if( extRecordList == null || extRecordList.size() &lt;= 0 )</span>
<span class="nc" id="L588">			return;</span>

<span class="nc bnc" id="L590" title="All 4 branches missed.">		if( elEntries == null || elEntries.size() &lt;= 0 )</span>
<span class="nc" id="L591">			return;</span>

		// get existing GL's
<span class="nc" id="L594">		ArrayList gList = new ArrayList();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (int i = 0; i &lt; extRecordList.size(); i++) </span>
		{
<span class="nc" id="L597">			TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L598">			ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext(); ) </span>
			{
<span class="nc" id="L601">				TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
<span class="nc bnc" id="L602" title="All 4 branches missed.">				if( entry.getActivityID().equals(GL) || entry.getActivityID().equals(GLSTART) )</span>
				{
<span class="nc" id="L604">					gList.add(entry);</span>
				}
<span class="nc" id="L606">			}</span>
		}

<span class="nc bnc" id="L609" title="All 2 branches missed.">		if( gList.size() &lt;= 0 )</span>
<span class="nc" id="L610">			return;</span>
		
		// scan and group ELentries as begin/end, compare
		// this with the GL's (above) and adjust the time stamps. 
		// This is assuming elEntries are sorted
<span class="nc" id="L615">		Iterator iter = elEntries.iterator();</span>
<span class="nc" id="L616">		RawTimeEntry beginEL = null;</span>
<span class="nc" id="L617">		RawTimeEntry endEL = null;</span>
<span class="nc" id="L618">		TimeRecordEntry glCur = null;</span>
<span class="nc" id="L619">		TimeRecordEntry glNext = null;</span>
		
<span class="nc" id="L621">		Date newEnd = null;</span>
<span class="nc" id="L622">		Date newStart = null;</span>
		
<span class="nc" id="L624">		Iterator gIter = gList.iterator();</span>
<span class="nc bnc" id="L625" title="All 2 branches missed.">		while( iter.hasNext() )</span>
		{
<span class="nc" id="L627">			RawTimeEntry rte = (RawTimeEntry)iter.next();</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">			if( rte.getActivityID().equals(GLENDS) )</span>
<span class="nc" id="L629">				endEL = rte;</span>
			else
<span class="nc" id="L631">				beginEL = rte;</span>
			
			// compare with GL 
<span class="nc bnc" id="L634" title="All 4 branches missed.">			if( beginEL != null &amp;&amp; endEL != null )</span>
			{
<span class="nc bnc" id="L636" title="All 4 branches missed.">				if( glCur == null &amp;&amp; gIter.hasNext() )</span>
<span class="nc" id="L637">					glCur = (TimeRecordEntry)gIter.next();</span>

<span class="nc bnc" id="L639" title="All 4 branches missed.">				if( glNext == null &amp;&amp; gIter.hasNext() )</span>
<span class="nc" id="L640">					glNext = (TimeRecordEntry)gIter.next();</span>
				
				// EL before GL so truncate EL time to GL and set the new start time
<span class="nc bnc" id="L643" title="All 4 branches missed.">				if( glCur != null &amp;&amp; beginEL.getSortTime().before(glCur.getSortTime()) )</span>
				{
<span class="nc" id="L645">					beginEL.setPunchTimestamp( glCur.getSortTime().getTime());</span>
<span class="nc" id="L646">					beginEL.setPunchDate(glCur.getSortTime());</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">					if( newStart == null )</span>
<span class="nc" id="L648">						newStart = beginEL.getSortTime();</span>
				}

				// EL end crosses the next GL so truncate EL end and set the new end time   
<span class="nc bnc" id="L652" title="All 4 branches missed.">				if( glNext != null &amp;&amp; endEL.getSortTime().after(glNext.getSortTime()) )</span>
				{
<span class="nc" id="L654">					Date endDate = new Date( glNext.getSortTime().getTime() - 1000L );</span>
<span class="nc" id="L655">					endEL.setPunchTimestamp(endDate.getTime());</span>
<span class="nc" id="L656">					endEL.setPunchDate(endDate);</span>
				}

<span class="nc" id="L659">				newEnd = endEL.getSortTime();</span>
				
<span class="nc" id="L661">				beginEL = null;</span>
<span class="nc" id="L662">				endEL = null;</span>
<span class="nc" id="L663">				glCur = glNext;</span>
<span class="nc" id="L664">				glNext = null;</span>
			}
<span class="nc" id="L666">		}</span>
		
		// adjust the start and end times
<span class="nc bnc" id="L669" title="All 2 branches missed.">		if( newStart != null )</span>
<span class="nc" id="L670">			start.setTime( newStart.getTime() );</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">		if( newEnd != null )</span>
<span class="nc" id="L673">			end.setTime( newEnd.getTime() );</span>
<span class="nc" id="L674">	}</span>
	
	private boolean isDuplicate( ArrayList extRecordList, Collection elEntries, Date start, Date end )
	{
<span class="nc bnc" id="L678" title="All 4 branches missed.">		if( extRecordList == null || extRecordList.size() &lt;= 0 )</span>
<span class="nc" id="L679">			return false;</span>

<span class="nc bnc" id="L681" title="All 4 branches missed.">		if( elEntries == null || elEntries.size() &lt;= 0 )</span>
<span class="nc" id="L682">			return false;</span>

<span class="nc" id="L684">		int matchCounter = 0;</span>
		
<span class="nc" id="L686">		Iterator iter = elEntries.iterator();</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">		while( iter.hasNext() )</span>
		{
<span class="nc" id="L689">			RawTimeEntry rteStart = (RawTimeEntry)iter.next();</span>
<span class="nc" id="L690">			RawTimeEntry rteEnd = null;</span>
<span class="nc" id="L691">			long duration = 0;</span>
			
<span class="nc bnc" id="L693" title="All 2 branches missed.">			if( iter.hasNext() )</span>
			{
<span class="nc" id="L695">				rteEnd = (RawTimeEntry)iter.next();</span>
<span class="nc" id="L696">				duration = (rteEnd.getPunchTimestamp() - rteStart.getPunchTimestamp())/60000L;</span>
			}
			
<span class="nc bnc" id="L699" title="All 2 branches missed.">			for( int i=0; i &lt; extRecordList.size(); ++i ) </span>
			{
<span class="nc" id="L701">				TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L702">				ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext(); ) </span>
				{
<span class="nc" id="L705">					TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">					if( entry.getActivityID().equals( rteStart.getActivityID() ) &amp;&amp;</span>
<span class="nc bnc" id="L707" title="All 2 branches missed.">							entry.getStartTime().equals( rteStart.getStartTime() ) &amp;&amp;</span>
<span class="nc bnc" id="L708" title="All 4 branches missed.">							(entry.getDuration() == duration || duration == 0) )</span>
					{
<span class="nc" id="L710">						++matchCounter;</span>
<span class="nc" id="L711">						break;</span>
					}
<span class="nc" id="L713">				}</span>
			}
<span class="nc" id="L715">		}</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">		return matchCounter == elEntries.size() / 2 ? true : false;</span>
	}
	
	public void insertHAAEntries(Map haaEntryMap, Collection empSet, Date start, Date end, boolean eLearning) throws AmException
	{
<span class="nc" id="L722">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L724">			HashSet empSetCopy = new HashSet(empSet);</span>
			// Then load all timerecords cross the haa window
			// If HAA window is between two entries, there will return no TimeRecord either
<span class="nc" id="L727">			HashMap extRecordMap = m_timeRecordManager.getEventsForWorkResourceWithOpenShift(empSet, TimeZoneUtil.toTimestamp(start), TimeZoneUtil.toTimestamp(end));</span>
			// define arraylist to save EventAuditTrail
<span class="nc" id="L729">			ArrayList eventAuditList = new ArrayList(empSet.size());</span>
			// insert HAA per employee with HAA entries
			
			// Fetch Employee Name first
<span class="nc" id="L733">			HashMap mapEmpNames  = m_workResourceManager.getEmployeeNamesByIDs(empSet);</span>
<span class="nc" id="L734">			EmployeeName empName = null;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">			for (Iterator empIt = empSet.iterator(); empIt.hasNext(); ) {</span>
<span class="nc" id="L736">				ID empID = (ID)empIt.next();</span>
<span class="nc" id="L737">				ArrayList haaEntryList = (ArrayList)haaEntryMap.get(empID);</span>
				// get existing entry
<span class="nc" id="L739">				ArrayList extRecordList = (ArrayList)extRecordMap.get(empID);</span>

				// adjust EL entries
<span class="nc bnc" id="L742" title="All 2 branches missed.">				if( eLearning )</span>
				{
<span class="nc" id="L744">					this.adjustELEntries( extRecordList, haaEntryList, start, end );</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">					if( isDuplicate(extRecordList, haaEntryList, start, end) )</span>
<span class="nc" id="L746">						continue;</span>
				}
				
				// create audit trail entry
<span class="nc" id="L750">				empName = (EmployeeName)mapEmpNames.get(empID);				</span>
<span class="nc" id="L751">				AuditTrailEntry auditEntry = new AuditTrailEntry(</span>
													AuditTrailEntry.MODULE_TIMERECORD, 
													AuditTrailEntry.ACTION_UPDATE_OBJECT,
<span class="nc" id="L754">													empID, empName.getDisplayName(DefaultLocalizationManager.getDefaultInstance().getLocalizer()), start, end);</span>
<span class="nc" id="L755">				auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>
				
<span class="nc" id="L757">				eventAuditList.add(auditEntry);</span>
<span class="nc bnc" id="L758" title="All 4 branches missed.">				if (haaEntryList != null &amp;&amp; !haaEntryList.isEmpty()) {</span>
					// locate first and last raw Time entry
<span class="nc" id="L760">					RawTimeEntry firstEntry = (RawTimeEntry)haaEntryList.get(0);</span>
<span class="nc" id="L761">					RawTimeEntry lastEntry = (RawTimeEntry)haaEntryList.get(haaEntryList.size()-1);</span>
					
					// check if the HAA window cross any existing TimeRecord just before/after
					// to save the last Entry just before start of HAA
<span class="nc" id="L765">					ID prvTimeRecordID = null;</span>
<span class="nc" id="L766">					ID prvActivityID = null;</span>
<span class="nc" id="L767">					ID prvRawEntryID = null;</span>
<span class="nc" id="L768">					ID prvEntryID = null;</span>
<span class="nc" id="L769">					Date prvEntryStart = null;</span>
<span class="nc" id="L770">					int prvEntryTimeSourceCode = 0;</span>
					
					// to save the next entry just after the end of HAA
<span class="nc" id="L773">					ID nxtTimeRecordID = null;</span>
<span class="nc" id="L774">					ID nxtActivityID = null;</span>
<span class="nc" id="L775">					Date nxtEntryStart = null;</span>
<span class="nc" id="L776">					int recordSize = 0;</span>
<span class="nc bnc" id="L777" title="All 4 branches missed.">					if (extRecordList != null &amp;&amp; !extRecordList.isEmpty()) {</span>
<span class="nc" id="L778">						recordSize = extRecordList.size();</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">						for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L780">							TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L781">							ArrayList entryList = curRecord.getChild();</span>
<span class="nc" id="L782">							boolean foundPrv = false;</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">							for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L784">								TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
								
<span class="nc bnc" id="L786" title="All 4 branches missed.">								if (!foundPrv &amp;&amp; entry.getSortTime().before(firstEntry.getSortTime())) {</span>
<span class="nc" id="L787">									prvTimeRecordID = curRecord.getID();</span>
<span class="nc" id="L788">									prvActivityID = entry.getActivityID();</span>
<span class="nc" id="L789">									prvEntryStart = entry.getSortTime();</span>
<span class="nc" id="L790">									prvRawEntryID = entry.getRawTimeEntryID();</span>
<span class="nc" id="L791">									prvEntryID = entry.getID();</span>
								}
								else {
<span class="nc" id="L794">									foundPrv = true;</span>
								}
<span class="nc bnc" id="L796" title="All 2 branches missed.">								if (entry.getSortTime().after(lastEntry.getSortTime())) {</span>
									// no need fetch next timerecord
<span class="nc" id="L798">									nxtTimeRecordID = curRecord.getID();</span>
<span class="nc" id="L799">									nxtActivityID = entry.getActivityID();</span>
<span class="nc" id="L800">									nxtEntryStart = entry.getSortTime();</span>
<span class="nc" id="L801">									break;</span>
								}
<span class="nc" id="L803">							}</span>
						}
					}
					// looking for preceding or next timerecord, may consider limit search window for one day bf/af
					// Find the preceding timerecord ID, ActivityID, and timestamp
<span class="nc bnc" id="L808" title="All 2 branches missed.">					if (prvTimeRecordID == null) {</span>
<span class="nc" id="L809">						String queryPrv =</span>
	&quot;select TIMERECORDID, ACTIVITYID, STARTTIME, RAWTIMEENTRYID, ID, TIMESOURCECODE from TIMEENTRYEVENT where UPDATETIMESTAMP=(&quot; +
	&quot;select max(UPDATETIMESTAMP) from TIMEENTRYEVENT where UPDATETIMESTAMP&lt;? and EMPLOYEEID=?) and EMPLOYEEID=?&quot;;
<span class="nc" id="L812">						JdmoQuery jQuery2 = jdmo.createQuery(queryPrv, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L813">						jQuery2.setParLong(1, start.getTime());</span>
<span class="nc" id="L814">						jQuery2.setParID(2, empID);</span>
<span class="nc" id="L815">						jQuery2.setParID(3, empID);</span>
<span class="nc" id="L816">						JdmoRowset rs2 = jdmo.createRowset(jQuery2, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L817" title="All 2 branches missed.">						if (rs2.next()) {</span>
<span class="nc" id="L818">							prvTimeRecordID = rs2.getID(1);</span>
<span class="nc" id="L819">							prvActivityID = rs2.getID(2);</span>
<span class="nc" id="L820">							prvEntryStart = TimeZoneUtil.toDate(rs2.getTimestamp(3));</span>
<span class="nc" id="L821">							prvRawEntryID = rs2.getID(4);</span>
<span class="nc" id="L822">							prvEntryID = rs2.getID(5);</span>
<span class="nc" id="L823">							prvEntryTimeSourceCode = rs2.getInt(6);</span>
						}
<span class="nc" id="L825">						rs2.close();</span>
					}
					// Find the succeeding timerecord ID, ActivityID, and timestamp
<span class="nc bnc" id="L828" title="All 2 branches missed.">					if (nxtTimeRecordID == null) {</span>
						// Then search for the next TimeRecord
<span class="nc" id="L830">						String queryNxt =</span>
	&quot;select TIMERECORDID, ACTIVITYID, STARTTIME from TIMEENTRYEVENT where UPDATETIMESTAMP=(&quot; +
	&quot;select min(UPDATETIMESTAMP) from TIMEENTRYEVENT where UPDATETIMESTAMP&gt;? and EMPLOYEEID=?) and EMPLOYEEID=?&quot;;
<span class="nc" id="L833">						JdmoQuery jQuery3 = jdmo.createQuery(queryNxt, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L834">						jQuery3.setParLong(1, end.getTime());</span>
<span class="nc" id="L835">						jQuery3.setParID(2, empID);</span>
<span class="nc" id="L836">						jQuery3.setParID(3, empID);</span>
<span class="nc" id="L837">						JdmoRowset rs3 = jdmo.createRowset(jQuery3, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L838" title="All 2 branches missed.">						if (rs3.next()) {</span>
<span class="nc" id="L839">							nxtTimeRecordID = rs3.getID(1);</span>
<span class="nc" id="L840">							nxtActivityID = rs3.getID(2);</span>
<span class="nc" id="L841">							nxtEntryStart = TimeZoneUtil.toDate(rs3.getTimestamp(3));</span>
						}
<span class="nc" id="L843">						rs3.close();</span>
					}
					// special handle the case, the HAA window is between two entries of one TR
<span class="nc bnc" id="L846" title="All 4 branches missed.">					if (extRecordList == null || extRecordList.isEmpty()) {</span>
<span class="nc bnc" id="L847" title="All 6 branches missed.">						if (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; prvTimeRecordID.equals(nxtTimeRecordID)) {</span>
<span class="nc" id="L848">							extRecordList = new ArrayList();</span>
<span class="nc" id="L849">							extRecordList.add(m_timeRecordManager.getTimeRecordByID(prvTimeRecordID));							</span>
<span class="nc" id="L850">							recordSize = extRecordList.size();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">							for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L852">								TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L853">								ArrayList entryList = curRecord.getChild();</span>
<span class="nc" id="L854">								boolean foundPrv = false;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">								for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L856">									TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
<span class="nc bnc" id="L857" title="All 4 branches missed.">									if (!foundPrv &amp;&amp; entry.getSortTime().before(firstEntry.getSortTime())) {							</span>
<span class="nc" id="L858">										prvActivityID = entry.getActivityID();</span>
<span class="nc" id="L859">										prvEntryStart = entry.getSortTime();</span>
<span class="nc" id="L860">										prvRawEntryID = entry.getRawTimeEntryID();</span>
<span class="nc" id="L861">										prvEntryID = entry.getID();</span>
<span class="nc" id="L862">										prvEntryTimeSourceCode = entry.getTimeSourceCode();</span>
									} else {
<span class="nc" id="L864">										foundPrv = true;</span>
									}
<span class="nc bnc" id="L866" title="All 2 branches missed.">									if (entry.getSortTime().after(lastEntry.getSortTime())) {</span>
										// no need fetch next timerecord							
<span class="nc" id="L868">										nxtActivityID = entry.getActivityID();</span>
<span class="nc" id="L869">										nxtEntryStart = entry.getSortTime();</span>
<span class="nc" id="L870">										break;</span>
									}
<span class="nc" id="L872">								}</span>
							}
						}
					}					
					// check merge/autoclose condition
<span class="nc" id="L877">					boolean autoUpdatePrv = false;</span>
<span class="nc" id="L878">					boolean autoMergePrv = false;</span>
<span class="nc" id="L879">					boolean autoClosePrv = false;</span>
					// auto create a new record if first entry no need append/merge
<span class="nc" id="L881">					boolean autoGen = false;</span>
					// if next Entry can update last entry, remove last entry
<span class="nc" id="L883">					boolean autoRm = false;</span>
<span class="nc" id="L884">					boolean autoMergeNxt = false;</span>
<span class="nc" id="L885">					boolean autoCloseNxt = false;</span>
					
					// if HAA entry is zero duration to previous entry, just update previous entry
<span class="nc bnc" id="L888" title="All 6 branches missed.">					if (FixZeroDuration &amp;&amp; prvTimeRecordID != null &amp;&amp; (firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &lt; 1000) )</span>
<span class="nc" id="L889">						autoUpdatePrv = true;</span>
					// if last HAA entry falls in same time as next entry, just remove last entry
<span class="nc bnc" id="L891" title="All 4 branches missed.">					if (nxtTimeRecordID != null &amp;&amp; lastEntry.getSortTime().getTime() == nxtEntryStart.getTime()) {</span>
<span class="nc" id="L892">						autoRm = true;</span>
<span class="nc" id="L893">						haaEntryList.remove(haaEntryList.size()-1);</span>
					}
					// Most of the cases, there is previous TimeRecord and succeeding TimeRecord
<span class="nc bnc" id="L896" title="All 2 branches missed.">					if (PerformAutoMerge) {</span>
<span class="nc bnc" id="L897" title="All 6 branches missed.">						if (!autoUpdatePrv &amp;&amp; prvTimeRecordID != null &amp;&amp; prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp;</span>
<span class="nc bnc" id="L898" title="All 4 branches missed.">							(firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &lt;= AutoMergeTimeoutInMillis) &amp;&amp;</span>
									!eLearning)
							// auto merge with previous record
<span class="nc" id="L901">							autoMergePrv = true;</span>
<span class="nc bnc" id="L902" title="All 6 branches missed.">						if (!autoRm &amp;&amp; nxtTimeRecordID != null &amp;&amp; lastEntry.isEndShift() &amp;&amp;</span>
<span class="nc bnc" id="L903" title="All 4 branches missed.">							(nxtEntryStart.getTime() - lastEntry.getSortTime().getTime() &lt;= AutoMergeTimeoutInMillis) &amp;&amp;</span>
							!eLearning )
							// next record auto merge with haa
<span class="nc" id="L906">							autoMergeNxt = true;</span>
					}
					if (PerformAutoClose) {
						// check Auto close
<span class="nc bnc" id="L910" title="All 6 branches missed.">						if (!autoUpdatePrv &amp;&amp; prvTimeRecordID != null &amp;&amp; !prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp;</span>
<span class="nc bnc" id="L911" title="All 4 branches missed.">							(firstEntry.getSortTime().getTime() - prvEntryStart.getTime() &gt;= AutoCloseTimeoutInMillis) &amp;&amp;</span>
							!eLearning) {
							// should auto close previous record first
<span class="nc" id="L914">							autoClosePrv = true;</span>
						}
<span class="nc bnc" id="L916" title="All 6 branches missed.">						if (!autoRm &amp;&amp; nxtTimeRecordID != null &amp;&amp; !lastEntry.isEndShift() &amp;&amp;</span>
<span class="nc bnc" id="L917" title="All 4 branches missed.">							(nxtEntryStart.getTime() - lastEntry.getSortTime().getTime() &gt;= AutoCloseTimeoutInMillis) &amp;&amp;</span>
							!eLearning) {
<span class="nc" id="L919">							autoCloseNxt = true;</span>
						}
					}
<span class="nc bnc" id="L922" title="All 6 branches missed.">					if (prvTimeRecordID == null || (prvActivityID.equals(Activity.ACTIVITY_NONE) &amp;&amp; !autoMergePrv)) {</span>
<span class="nc" id="L923">						autoGen = true;</span>
					}
<span class="nc bnc" id="L925" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L926">						m_cat.debug(&quot;In HAA, AutoUpdatePrv=&quot;+autoUpdatePrv+&quot;,AutoMergePrv=&quot;+autoMergePrv+</span>
									&quot;, AutoClosePrv=&quot;+autoClosePrv+&quot;, AutoGen=&quot;+autoGen+&quot;, AutoRm=&quot;+autoRm+&quot;, AutoMergeNxt=&quot;+autoMergeNxt+&quot;, AutoCloseNxt=&quot;+autoCloseNxt);
					}
					// mix existing entries with HAA entries, and rebuild the timerecords
<span class="nc" id="L930">					Set treRemoveSet = new HashSet();								</span>
					// to support eLearning feed, here need scan the underlying entries
					// if no General Learning activity, but with other activities, won't impose the feed
					// if no entries at all, create feed regardless (which could be after endshift, etc.)
					// if found General Learning in between, then realign feed start time to it, remove General Learning, impose feed
					// 					
					// mix HAA with existing entries
<span class="nc" id="L937">					ArrayList mixedEntryList = new ArrayList();</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">					if (eLearning) {</span>
						// track what eLearning Entries will be imposed
<span class="nc" id="L940">						ArrayList elEntryList = new ArrayList();</span>
<span class="nc" id="L941">						boolean findGL = false;						</span>
<span class="nc bnc" id="L942" title="All 4 branches missed.">						if (prvTimeRecordID != null &amp;&amp; prvActivityID.equals(GL)) {</span>
							// there is entry before EL window and it is General Learning, need keep it
<span class="nc" id="L944">							findGL = true;</span>
							// enhanced to compare with each HAA chunk's first entry, if not before it, need be removed
<span class="nc bnc" id="L946" title="All 2 branches missed.">							if (!prvEntryStart.before(((RawTimeEntry)haaEntryList.get(0)).getSortTime()))</span>
<span class="nc" id="L947">								treRemoveSet.add(prvEntryID);</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L949">								m_cat.debug(&quot;Find General Learning entry &quot;+prvEntryID+&quot; at &quot;+prvEntryStart);</span>
							}
						}
						// prepare underlying entries list
<span class="nc" id="L953">						ArrayList underList = new ArrayList();</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">						if (prvTimeRecordID != null) {</span>
<span class="nc" id="L955">							TimeRecordEntry prvEntry = new TimeRecordEntry();</span>
<span class="nc" id="L956">							prvEntry.setID(prvEntryID);</span>
<span class="nc" id="L957">							prvEntry.setActivityID(prvActivityID);</span>
<span class="nc" id="L958">							prvEntry.setSortTime(prvEntryStart);</span>
<span class="nc" id="L959">							prvEntry.setTimeSourceCode(prvEntryTimeSourceCode);</span>
<span class="nc" id="L960">							underList.add(prvEntry);</span>
						}
						// now scan other entries
<span class="nc bnc" id="L963" title="All 2 branches missed.">						if (recordSize != 0) {</span>
<span class="nc" id="L964">							RawTimeEntry lastEL = null;</span>
							// need add existing records which is from MyTime/Manager back to HAA window
<span class="nc bnc" id="L966" title="All 2 branches missed.">							for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L967">								TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L968">								ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L969" title="All 2 branches missed.">								for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L970">									TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
<span class="nc bnc" id="L971" title="All 4 branches missed.">									if (!entry.getSortTime().before(start) &amp;&amp; !entry.getSortTime().after(end)) {</span>
										// in EL, keep every existing entries.
<span class="nc bnc" id="L973" title="All 2 branches missed.">										if (entry.getID() != prvEntryID)</span>
<span class="nc" id="L974">											underList.add(entry);										</span>
<span class="nc bnc" id="L975" title="All 4 branches missed.">										if (!findGL &amp;&amp; entry.getActivityID().equals(GL)) {</span>
											
											// find GL in the middle for the first time, then just keep the last EL entry before it, 
											// and remove this entry from DB
<span class="nc bnc" id="L979" title="All 2 branches missed.">											if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L980">												m_cat.debug(&quot;Find GL in the middle for the first time at &quot;+entry);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">											for (ListIterator haaIt = haaEntryList.listIterator(); haaIt.hasNext(); ) {</span>
<span class="nc" id="L982">												RawTimeEntry haaEntry = (RawTimeEntry)haaIt.next();</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">												if (haaEntry.getSortTime().before(entry.getSortTime())) {</span>
<span class="nc" id="L984">													lastEL = haaEntry;</span>
<span class="nc" id="L985">													haaIt.remove();</span>
												} else
													break;
<span class="nc" id="L988">											}</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">											if (lastEL != null)</span>
<span class="nc" id="L990">												haaEntryList.add(0, lastEL);</span>
<span class="nc" id="L991">											findGL = true;</span>
<span class="nc" id="L992">											treRemoveSet.add(entry.getID());</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">											if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L994">												m_cat.debug(&quot;Find GL in the middle for the first time and left ELEntries &quot;+haaEntryList);											</span>
											continue;
										}
<span class="nc bnc" id="L997" title="All 2 branches missed.">										else if (entry.getActivityID().equals(GL)) {</span>
											
											// if there are multiple GLs, just use the first GL as cutting off line, simply remove the remaining GLs
											//treRemoveSet.add(entry.getID());

<span class="nc bnc" id="L1002" title="All 2 branches missed.">											if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1003">												m_cat.debug(&quot;Find other GL in the middle, remove it &quot;+entry);											</span>
											continue;
										}
									}
<span class="nc" id="L1007">								}</span>
							}				
						}						
<span class="nc bnc" id="L1010" title="All 2 branches missed.">						if (findGL) {</span>
<span class="nc bnc" id="L1011" title="All 2 branches missed.">							if (!underList.isEmpty()) {</span>
								// find GL and underlying entries, now rebuild entries
								// it may dup entries, move EndShift to a different time
<span class="nc" id="L1014">								ListIterator itHA = haaEntryList.listIterator();</span>
<span class="nc" id="L1015">								RawTimeEntry elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc" id="L1016">								TimeRecordEntry lastTRE = null;						</span>
<span class="nc bnc" id="L1017" title="All 2 branches missed.">								for (ListIterator itUnder = underList.listIterator(); itUnder.hasNext(); ) {</span>
<span class="nc" id="L1018">									TimeRecordEntry exEntry = (TimeRecordEntry)itUnder.next();</span>
<span class="nc" id="L1019">									lastTRE = exEntry;</span>
									
									
<span class="nc bnc" id="L1022" title="All 2 branches missed.">									if (exEntry.getSortTime().before(elEntry.getSortTime())) {</span>

										// Check and truncate learning end if it crosses the next activity 
										// and the next activity is not an end shift
										
<span class="nc bnc" id="L1027" title="All 2 branches missed.">										if (exEntry.getActivityID().equals(GL)) {									</span>
											// dup last EL entry at this GL time first, if prev TRE is not GL
<span class="nc" id="L1029">											int prvIdx = itUnder.previousIndex()-1;</span>
<span class="nc" id="L1030">											boolean prvGL = false;</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">											if (prvIdx &gt;= 0 ) {</span>
<span class="nc" id="L1032">												TimeRecordEntry prvEntry = (TimeRecordEntry)underList.get(prvIdx);</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">												prvGL = prvEntry.getActivityID().equals(GL) || </span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">												prvEntry.getActivityID().equals(Activity.ACTIVITY_NONE) || </span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">												prvEntry.getActivityID().equals(Activity.ACTIVITY_MERGE);												</span>
											}
<span class="nc bnc" id="L1037" title="All 4 branches missed.">											if (!elEntryList.isEmpty() &amp;&amp; !prvGL) {</span>
<span class="nc" id="L1038">												RawTimeEntry lstEL = (RawTimeEntry)elEntryList.get(elEntryList.size()-1);</span>
												// if last EL is GLENDS, no need to add it again
<span class="nc bnc" id="L1040" title="All 2 branches missed.">												if (!lstEL.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1041">													RawTimeEntry dupEL = new RawTimeEntry();</span>
<span class="nc" id="L1042">													dupEL.setEmployeeID(lstEL.getEmployeeID()); </span>
<span class="nc" id="L1043">													dupEL.setActivityId(lstEL.getActivityID());</span>
<span class="nc" id="L1044">													dupEL.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L1045">													dupEL.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L1046">													dupEL.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
<span class="nc" id="L1047">													elEntryList.add(dupEL);</span>
<span class="nc" id="L1048">												} else {</span>
<span class="nc" id="L1049">													treRemoveSet.remove(exEntry.getID());</span>
												}
											}
											// save ELs, until the next TRE's start time, then next EL must be after next TRE
<span class="nc bnc" id="L1053" title="All 2 branches missed.">											if (itUnder.hasNext()) {</span>
<span class="nc" id="L1054">												exEntry = (TimeRecordEntry)itUnder.next();</span>
<span class="nc" id="L1055">												itUnder.previous();</span>
											} else {
<span class="nc" id="L1057">												elEntry = addEL(elEntryList, elEntry, lastTRE);												</span>
<span class="nc" id="L1058">												break;</span>
											}

											do {
												// skip if elentries are same
<span class="nc bnc" id="L1063" title="All 2 branches missed.">												if( elEntry.getActivityID().equals(exEntry.getActivityID() ) &amp;&amp; </span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">														elEntry.getSortTime().equals(exEntry.getSortTime())	)</span>
												{
													// skip the GL end
<span class="nc bnc" id="L1067" title="All 2 branches missed.">													if (itHA.hasNext())	{</span>
<span class="nc" id="L1068">														elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc bnc" id="L1069" title="All 2 branches missed.">														if(elEntry.getActivityID().equals(GLENDS))	{</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">															if (itHA.hasNext()) {</span>
<span class="nc" id="L1071">																elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc" id="L1072">																continue;</span>
															}
															else
																break;
														}
														continue;
													}
													else
														break;
													
												}
												
<span class="nc bnc" id="L1084" title="All 2 branches missed.">												if( elEntry.getSortTime().after(exEntry.getSortTime()) ) {</span>
													
													// truncate this EL to the prev TRE, only if it's not end shift
<span class="nc" id="L1087">													itHA.remove();</span>
<span class="nc" id="L1088">													elEntry = null;</span>
													
<span class="nc bnc" id="L1090" title="All 2 branches missed.">													if( exEntry.getActivityID().equals(Activity.ACTIVITY_NONE) ) </span>
<span class="nc" id="L1091">														break;</span>
												}
												else {
<span class="nc" id="L1094">													elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
												}
												
<span class="nc bnc" id="L1097" title="All 2 branches missed.">												if (itHA.hasNext())</span>
<span class="nc" id="L1098">													elEntry = (RawTimeEntry)itHA.next();</span>
												else {													
													break;
												}
											}while( true );
											
											
<span class="nc bnc" id="L1105" title="All 2 branches missed.">											if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1106">												m_cat.debug(&quot;Find a GL in the middle, elEntry has &quot;+elEntryList);																																		</span>
											// additionally break if no more EL entries
<span class="nc bnc" id="L1108" title="All 2 branches missed.">											if (elEntry == null)</span>
<span class="nc" id="L1109">												break;											</span>
<span class="nc" id="L1110">										} else {</span>
											// keep this entry, skip all ELs till next TRE (if not GL), keep last entry if it is GL
											// if this is EndShift/Merged entry, need extend it till next entry start.									
<span class="nc bnc" id="L1113" title="All 2 branches missed.">											if (exEntry.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">													exEntry.getActivityID().equals(Activity.ACTIVITY_MERGE)) {</span>
												// ignore any endshift before EL starts
<span class="nc bnc" id="L1116" title="All 2 branches missed.">												if (exEntry.getSortTime().before(start))</span>
<span class="nc" id="L1117">													continue;												</span>
												// add back endshift
<span class="nc" id="L1119">												RawTimeEntry rteEnd = new RawTimeEntry();</span>
<span class="nc" id="L1120">												rteEnd.setEmployeeID(exEntry.getEmployeeID());</span>
<span class="nc" id="L1121">												rteEnd.setActivityId(exEntry.getActivityID());	</span>
<span class="nc" id="L1122">												rteEnd.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
												
												// dup last EL entry at this GL time first, if prev TRE is not GL
<span class="nc" id="L1125">												int prvIdx = itUnder.previousIndex()-1;</span>
<span class="nc" id="L1126">												boolean prvGL = false;</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">												if (prvIdx &gt;= 0 ) {</span>
<span class="nc" id="L1128">													TimeRecordEntry prvEntry = (TimeRecordEntry)underList.get(prvIdx);</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">													prvGL = prvEntry.getActivityID().equals(GL) || </span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">													prvEntry.getActivityID().equals(Activity.ACTIVITY_NONE) || </span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">													prvEntry.getActivityID().equals(Activity.ACTIVITY_MERGE);</span>
												}
<span class="nc" id="L1133">												treRemoveSet.add(exEntry.getID());</span>
<span class="nc bnc" id="L1134" title="All 4 branches missed.">												if (!elEntryList.isEmpty() &amp;&amp; !prvGL) {</span>
<span class="nc" id="L1135">													RawTimeEntry lstEL = (RawTimeEntry)elEntryList.get(elEntryList.size()-1);</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">													if (!lstEL.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1137">														RawTimeEntry dupEL = new RawTimeEntry();</span>
<span class="nc" id="L1138">														dupEL.setEmployeeID(lstEL.getEmployeeID());</span>
<span class="nc" id="L1139">														dupEL.setActivityId(lstEL.getActivityID());</span>
<span class="nc" id="L1140">														dupEL.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L1141">														dupEL.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L1142">														dupEL.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
														
<span class="nc" id="L1144">														elEntryList.add(dupEL);</span>
<span class="nc" id="L1145">													} else {</span>
<span class="nc" id="L1146">														treRemoveSet.remove(exEntry.getID());</span>
													}
												}
<span class="nc" id="L1149">												Date endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1150">												elEntry = addEL(elEntryList, elEntry, lastTRE);												</span>
<span class="nc bnc" id="L1151" title="All 2 branches missed.">												if (itUnder.hasNext()) {																						</span>
<span class="nc" id="L1152">													exEntry = (TimeRecordEntry)itUnder.next();</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">													while (itHA.hasNext()) {</span>
<span class="nc" id="L1154">														elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">														if (elEntry.getSortTime().before(exEntry.getSortTime())){															</span>
<span class="nc" id="L1156">															endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1157">															elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
														} else
															break;
													} 				
<span class="nc" id="L1161">													itUnder.previous();</span>
												} else {
													// add all remaining										
<span class="nc bnc" id="L1164" title="All 2 branches missed.">													while (itHA.hasNext()) {</span>
<span class="nc" id="L1165">														elEntry = (RawTimeEntry)itHA.next();														</span>
<span class="nc" id="L1166">														endTime = elEntry.getSortTime();</span>
<span class="nc" id="L1167">														elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
													}																							
												}
<span class="nc" id="L1170">												rteEnd.setPunchDate(endTime);</span>
<span class="nc" id="L1171">												rteEnd.setPunchTimestamp(endTime.getTime());</span>
<span class="nc" id="L1172">												RawTimeEntry lstEntry = (RawTimeEntry)elEntryList.get(elEntryList.size()-1);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">												if (lstEntry.getActivityID().equals(GLENDS)) {</span>
													// replace last GL Ends with this End Shift
<span class="nc" id="L1175">													elEntryList.remove(elEntryList.size()-1);</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">												} else if( lastTRE.getActivityID().equals(rteEnd.getActivityID()) &amp;&amp;</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">														rteEnd.getActivityID().equals(Activity.ACTIVITY_NONE) ){</span>

													// don't add 2 end shifts, this will result in an records merge 
													// activity
<span class="nc" id="L1181">													continue;</span>
												} else {
													// not GL Ends, create a system auto close, plus 1 second
<span class="nc" id="L1184">													rteEnd.setPunchTimestamp(rteEnd.getPunchTimestamp() + 1000l);</span>
<span class="nc" id="L1185">													rteEnd.setPunchDate(new Date(rteEnd.getPunchDate().getTime() + 1000l));</span>
<span class="nc" id="L1186">													rteEnd.setPunchTimeCode(RawTimeEntry.AUTOCLOSE_END_SHIFT);</span>
												}										
<span class="nc" id="L1188">												elEntryList.add(rteEnd);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">												if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1190">													m_cat.debug(&quot;Find an EndShift in the middle, add new one at &quot;+rteEnd+&quot; elEntry has &quot;+elEntryList);																							</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">												if (elEntry == null) {													</span>
<span class="nc" id="L1192">													break;</span>
												}
<span class="nc" id="L1194">											} else {</span>
												
<span class="nc bnc" id="L1196" title="All 2 branches missed.">												if (itUnder.hasNext()) {</span>
<span class="nc" id="L1197">													exEntry = (TimeRecordEntry)itUnder.next();</span>
<span class="nc" id="L1198">													itUnder.previous();</span>
												} else {												
													break;
												}
<span class="nc bnc" id="L1202" title="All 2 branches missed.">												if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1203">													m_cat.debug(&quot;Find a entry after current EL, next under Entry is &quot;+exEntry);			</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">												if (exEntry.getActivityID().equals(GL)) {</span>
													// now progress EL to the one just before GL
<span class="nc bnc" id="L1206" title="All 2 branches missed.">													if (itHA.hasNext()) {</span>
														// skip till one just before exEntry ends
<span class="nc" id="L1208">														RawTimeEntry nxtEntry = elEntry;</span>
														do {
<span class="nc" id="L1210">															elEntry = nxtEntry;</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">															if (itHA.hasNext())</span>
<span class="nc" id="L1212">																nxtEntry = (RawTimeEntry)itHA.next();</span>
															else {
																break;
															}
<span class="nc bnc" id="L1216" title="All 2 branches missed.">														} while (nxtEntry.getSortTime().before(exEntry.getSortTime()));</span>
<span class="nc" id="L1217">														itHA.previous();</span>
													}
<span class="nc bnc" id="L1219" title="All 2 branches missed.">													if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1220">														m_cat.debug(&quot;As next under Entry is GL, just keep last EL before this GL &quot;+elEntry);	</span>
													continue;
												}
<span class="nc" id="L1223">												boolean findEL = elEntry.getSortTime().after(exEntry.getSortTime());</span>
<span class="nc bnc" id="L1224" title="All 4 branches missed.">												while (!findEL &amp;&amp; itHA.hasNext()) {</span>
<span class="nc" id="L1225">													elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">													if (elEntry.getSortTime().after(exEntry.getSortTime())) {</span>
<span class="nc" id="L1227">														findEL = true;</span>
<span class="nc" id="L1228">														break;</span>
													}  																																		
												}
<span class="nc bnc" id="L1231" title="All 2 branches missed.">												if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1232">													m_cat.debug(&quot;Continue to skip EL, next EL is &quot;+elEntry);																																			</span>
<span class="nc bnc" id="L1233" title="All 4 branches missed.">												if (!findEL &amp;&amp; !itHA.hasNext())</span>
<span class="nc" id="L1234">													break;</span>
<span class="nc" id="L1235">											}	</span>
										}
									} else {
<span class="nc bnc" id="L1238" title="All 2 branches missed.">										if (exEntry.getActivityID().equals(GL)) {</span>
<span class="nc" id="L1239">											Date lstELTime = null;</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">											if (exEntry.getActivityID().equals(GLENDS)) {</span>
<span class="nc" id="L1241">												treRemoveSet.remove(exEntry.getID());</span>
											} else {
<span class="nc" id="L1243">												elEntry.setPunchTimestamp(exEntry.getSortTime().getTime());</span>
<span class="nc" id="L1244">												elEntry.setPunchDate(exEntry.getSortTime());</span>
<span class="nc" id="L1245">												elEntry.setTimeSourceCode(exEntry.getTimeSourceCode());</span>
<span class="nc" id="L1246">												elEntryList.add(elEntry);</span>
<span class="nc" id="L1247">												lstELTime = exEntry.getSortTime();</span>
<span class="nc" id="L1248">												elEntry = null;</span>
											}				
<span class="nc bnc" id="L1250" title="All 2 branches missed.">											if (itHA.hasNext()) {</span>
												// check next EL																		
<span class="nc bnc" id="L1252" title="All 2 branches missed.">												if (itUnder.hasNext()) {</span>
													// get next underlying entry
<span class="nc" id="L1254">													exEntry = (TimeRecordEntry)itUnder.next();</span>
													// add all ELs before next entry
													do  {
<span class="nc" id="L1257">														elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">														if (elEntry.getSortTime().before(exEntry.getSortTime())){</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">															if (lstELTime != null &amp;&amp; </span>
<span class="nc bnc" id="L1260" title="All 4 branches missed.">																(elEntry.getSortTime().equals(lstELTime) || </span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">																	(FixZeroDuration &amp;&amp; (elEntry.getSortTime().getTime() - lstELTime.getTime()) &lt; 1000))) {</span>
<span class="nc" id="L1262">																elEntryList.remove(elEntryList.size()-1);</span>
															}												
<span class="nc" id="L1264">															elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
															
														} else
															break;
<span class="nc bnc" id="L1268" title="All 2 branches missed.">													} while (itHA.hasNext());													</span>
<span class="nc" id="L1269">													itUnder.previous();</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">													if (elEntry == null) </span>
<span class="nc" id="L1271">														break;</span>
													else
														continue;
												}
											}
<span class="nc" id="L1276">											elEntry = null;</span>
<span class="nc" id="L1277">											break;</span>
										} else {
											
<span class="nc bnc" id="L1280" title="All 2 branches missed.">											if (itHA.hasNext()) {</span>
												// skip till one just before exEntry ends
<span class="nc" id="L1282">												RawTimeEntry nxtEntry = elEntry;</span>
												do {
<span class="nc" id="L1284">													elEntry = nxtEntry;</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">													if (itHA.hasNext())</span>
<span class="nc" id="L1286">														nxtEntry = (RawTimeEntry)itHA.next();</span>
													else {
														break;
													}
<span class="nc bnc" id="L1290" title="All 2 branches missed.">												} while (nxtEntry.getSortTime().before(exEntry.getSortTime()));</span>
<span class="nc" id="L1291">												itHA.previous();</span>
											}
										}
									}										
<span class="nc" id="L1295">								}</span>
								// special handle last entry cases
<span class="nc bnc" id="L1297" title="All 4 branches missed.">								if (elEntry == null &amp;&amp; itHA.hasNext())</span>
<span class="nc" id="L1298">									elEntry = (RawTimeEntry)itHA.next();</span>
<span class="nc bnc" id="L1299" title="All 2 branches missed.">								if (elEntry != null) {</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">									if (lastTRE.getSortTime().before(elEntry.getSortTime())) {	</span>
										
										
<span class="nc bnc" id="L1303" title="All 2 branches missed.">										if (lastTRE.getActivityID().equals(GL)) {</span>
											// add all EL events after GL											
<span class="nc" id="L1305">											elEntry = addEL(elEntryList, elEntry, lastTRE);</span>
<span class="nc bnc" id="L1306" title="All 2 branches missed.">											while (itHA.hasNext())</span>
<span class="nc" id="L1307">												addEL(elEntryList, (RawTimeEntry)itHA.next(), lastTRE);</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">										} else if (lastTRE.getActivityID().equals(Activity.ACTIVITY_NONE) ||</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">												lastTRE.getActivityID().equals(Activity.ACTIVITY_MERGE)) {	</span>
											// special case, shift closed, then remove this end shift, impose all ELs and create a new EndShift at the end
<span class="nc bnc" id="L1311" title="All 2 branches missed.">											while (itHA.hasNext())</span>
<span class="nc" id="L1312">												addEL(elEntryList, (RawTimeEntry)itHA.next(), lastTRE);</span>
											// handle new EndShift, remove last EL?
<span class="nc" id="L1314">											treRemoveSet.add(lastTRE.getID());												</span>
											// add back endshift
<span class="nc" id="L1316">											RawTimeEntry rteEnd = new RawTimeEntry();</span>
<span class="nc" id="L1317">											rteEnd.setEmployeeID(lastTRE.getEmployeeID());</span>
<span class="nc" id="L1318">											rteEnd.setActivityId(lastTRE.getActivityID());</span>
<span class="nc" id="L1319">											rteEnd.setPunchDate(end);</span>
<span class="nc" id="L1320">											rteEnd.setPunchTimestamp(end.getTime());</span>
											
<span class="nc" id="L1322">											RawTimeEntry lstEntry = (RawTimeEntry)elEntryList.get(elEntryList.size()-1);											</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">											if (lstEntry.getActivityID().equals(GLENDS) || </span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">												lstEntry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
												// replace last GL Ends with this End Shift
<span class="nc" id="L1326">												elEntryList.remove(elEntryList.size()-1);												</span>
											} else {
												// not GL Ends, create a system auto close, plus 1 second
<span class="nc" id="L1329">												rteEnd.setPunchTimestamp(rteEnd.getPunchTimestamp() + 1000l);</span>
<span class="nc" id="L1330">												rteEnd.setPunchDate(new Date(rteEnd.getPunchDate().getTime() + 1000l));</span>
<span class="nc" id="L1331">												rteEnd.setPunchTimeCode(RawTimeEntry.AUTOCLOSE_END_SHIFT);</span>
											}										
<span class="nc" id="L1333">											elEntryList.add(rteEnd);									</span>
<span class="nc" id="L1334">										}</span>
									} else {
<span class="nc bnc" id="L1336" title="All 2 branches missed.">										if (lastTRE.getActivityID().equals(GL)) {</span>
											// align last EL to lastTRE start time and save, ignore the remaining ELs
<span class="nc" id="L1338">											RawTimeEntry lstEL = null;</span>
											do {
<span class="nc" id="L1340">												lstEL = elEntry;</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">												if (itHA.hasNext())</span>
<span class="nc" id="L1342">													elEntry = (RawTimeEntry)itHA.next();</span>
												else
													break;
<span class="nc bnc" id="L1345" title="All 2 branches missed.">											} while (lastTRE.getSortTime().after(elEntry.getSortTime()));</span>
<span class="nc bnc" id="L1346" title="All 2 branches missed.">											if (!lstEL.getActivityID().equals(GLENDS)) {												</span>
<span class="nc" id="L1347">												lstEL.setPunchTimestamp(lastTRE.getSortTime().getTime());</span>
<span class="nc" id="L1348">												lstEL.setPunchDate(lastTRE.getStartTime());</span>
<span class="nc" id="L1349">												addEL(elEntryList, lstEL, lastTRE);</span>
<span class="nc" id="L1350">												elEntryList.add(lstEL);</span>
											} else {
<span class="nc" id="L1352">												treRemoveSet.remove(lastTRE.getID());</span>
											}
										}
									}
								}
<span class="nc" id="L1357">							} else {</span>
								// directly impose, no special handling, should happen most of the time
<span class="nc" id="L1359">								elEntryList.addAll(haaEntryList);</span>
							}
						} else {
							// no underlying GL, just give up
							// need consider End Shift case? agent just log off phone and forgot to use GL 
						}						
<span class="nc" id="L1365">						mixedEntryList.addAll(elEntryList);</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1367">							m_cat.debug(&quot;ELEntries are &quot;+elEntryList);</span>
<span class="nc" id="L1368">							m_cat.debug(&quot;Removed entries &quot;+treRemoveSet);</span>
<span class="nc" id="L1369">							m_cat.debug(&quot;Mixed entries &quot;+mixedEntryList);</span>
						}
<span class="nc" id="L1371">					} else {										</span>
						// for regular HAA 
<span class="nc bnc" id="L1373" title="All 2 branches missed.">						if (recordSize != 0) {</span>
<span class="nc" id="L1374">							mixedEntryList.addAll(haaEntryList);</span>
							// need add existing records which is from MyTime/Manager back to HAA window
<span class="nc bnc" id="L1376" title="All 2 branches missed.">							for (int i = 0; i &lt; recordSize; i++) {</span>
<span class="nc" id="L1377">								TimeRecord curRecord = (TimeRecord)extRecordList.get(i);</span>
<span class="nc" id="L1378">								ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">								for (Iterator it = entryList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1380">									TimeRecordEntry entry = (TimeRecordEntry)it.next();</span>
<span class="nc bnc" id="L1381" title="All 4 branches missed.">									if (!entry.getSortTime().before(start) &amp;&amp; !entry.getSortTime().after(end)) {</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">										if (entry.getTimeSourceCode() != TimeEntrySourceCode.HAAFEED &amp;&amp;</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">											entry.getTimeSourceCode() != TimeEntrySourceCode.RAWPUNCH &amp;&amp;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">											entry.getTimeSourceCode() != TimeEntrySourceCode.AUTO_CLOSE &amp;&amp;</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">											entry.getTimeSourceCode() != TimeEntrySourceCode.AUTO_MERGE) {</span>
												// entry is within haa window, retain it
												// it is not from Raw Punch and HAA
<span class="nc" id="L1388">												mixedEntryList.add(entry);</span>
											} else {
<span class="nc" id="L1390">												treRemoveSet.add(entry.getID());</span>
											}
									}
<span class="nc" id="L1393">								}</span>
							}
						}
					}
					// resort HAA Entry based on sort time, and produce new records
<span class="nc" id="L1398">					Collections.sort(mixedEntryList, RawTimeEntrySort.PUNCHTIME_ORDER);</span>
					// TODO: if HAA is after eLearning feed, then it need 
					// apply auto close/merge rules on the records
<span class="nc" id="L1401">					boolean containEndShift = false;</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">					for (ListIterator i = mixedEntryList.listIterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1403">						EmployeeEvent event = (EmployeeEvent)i.next();						</span>
						// if endshift is last entry in the list and from existing TR, no need to reconsider it
<span class="nc bnc" id="L1405" title="All 6 branches missed.">						containEndShift = event.getActivityID().equals(Activity.ACTIVITY_NONE) &amp;&amp; (!((event.getID() != null) &amp;&amp; !i.hasNext()));</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">						if (!i.hasNext())</span>
<span class="nc" id="L1407">							break;</span>
<span class="nc" id="L1408">						EmployeeEvent nextEvent = (EmployeeEvent)i.next();</span>
						// remove 0 duration entry always
<span class="nc bnc" id="L1410" title="All 6 branches missed.">						if (FixZeroDuration &amp;&amp; (nextEvent.getSortTime().getTime() - event.getSortTime().getTime() &lt; 1000) ||</span>
							// not eLearning mode, if two events have same Activity, should discard the next Event
							// when two events are both from RawPunch
<span class="nc bnc" id="L1413" title="All 2 branches missed.">						   (!eLearning &amp;&amp; nextEvent.getActivityID().equals(event.getActivityID())) &amp;&amp;</span>
<span class="nc bnc" id="L1414" title="All 4 branches missed.">							(nextEvent.getTimeSourceCode() == event.getTimeSourceCode() &amp;&amp; event.getTimeSourceCode() == TimeEntrySourceCode.RAWPUNCH)) {</span>
							// if event will be gone, then check if it exists on DB, then
<span class="nc bnc" id="L1416" title="All 2 branches missed.">							if (event.getID() != null)</span>
<span class="nc" id="L1417">								treRemoveSet.add(event.getID());</span>
<span class="nc" id="L1418">							i.previous();</span>
<span class="nc" id="L1419">							i.remove();</span>
<span class="nc" id="L1420">							continue;</span>
						}
						// if activity is end shift, check auto merge condition
<span class="nc bnc" id="L1423" title="All 2 branches missed.">						if (event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
							// if two EndShift are next to each other, just auto merge
<span class="nc bnc" id="L1425" title="All 4 branches missed.">							if (nextEvent.getActivityID().equals(Activity.ACTIVITY_NONE) ||	(PerformAutoMerge &amp;&amp;</span>
<span class="nc bnc" id="L1426" title="All 2 branches missed.">								((nextEvent.getSortTime().getTime() - event.getSortTime().getTime()) &lt;= AutoMergeTimeoutInMillis))) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">								if (event instanceof RawTimeEntry) {</span>
									// need perform auto merge
<span class="nc" id="L1429">									RawTimeEntry rte = (RawTimeEntry)event;</span>
<span class="nc" id="L1430">									rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1431">									rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1432">									rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1433">								} else {</span>
<span class="nc" id="L1434">									TimeRecordEntry tre = (TimeRecordEntry)event;</span>
<span class="nc" id="L1435">									tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1436">								}</span>
							}
						} else {
							// check if need add auto close
							if (PerformAutoClose) {
<span class="nc bnc" id="L1441" title="All 2 branches missed.">								if (!nextEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc bnc" id="L1442" title="All 4 branches missed.">									if ((nextEvent.getSortTime().getTime() - event.getSortTime().getTime()) &gt;= AutoCloseTimeoutInMillis &amp;&amp; !eLearning) {</span>
<span class="nc" id="L1443">										RawTimeEntry autoClose = new RawTimeEntry(event.getEmployeeID(),</span>
																Activity.ACTIVITY_NONE,
<span class="nc" id="L1445">																event.getTimeRecordID(), null,</span>
																RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1447">																new Date(event.getSortTime().getTime()+MINUTE));</span>
										// Add in between the two entries
<span class="nc" id="L1449">										i.previous();</span>
<span class="nc" id="L1450">										i.add(autoClose);</span>
<span class="nc" id="L1451">									}</span>
								} else {
									// if next event is end shift, move iterator back, no need auto close
<span class="nc" id="L1454">									i.previous();</span>
								}
							}
						}
<span class="nc" id="L1458">					}</span>
					// now insert by shift
					// if HAA is within one timerecord, and has end shift inside HAA, may need split records, this rarely happens
<span class="nc bnc" id="L1461" title="All 10 branches missed.">					boolean splitTR = (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; prvTimeRecordID.equals(nxtTimeRecordID) &amp;&amp; containEndShift &amp;&amp; !eLearning);</span>
					// if two records are not same, may consider merge, this happens in extreme condition
<span class="nc bnc" id="L1463" title="All 8 branches missed.">					boolean mergeTR = (prvTimeRecordID != null &amp;&amp; nxtTimeRecordID != null &amp;&amp; !prvTimeRecordID.equals(nxtTimeRecordID) &amp;&amp; !eLearning);</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">					if(m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1465">						m_cat.debug(&quot;Further decision, SplitTR=&quot;+splitTR+&quot;, MergeTR=&quot;+mergeTR+&quot;, PrvRecordID=&quot;+prvTimeRecordID+&quot;, NxtRecordID=&quot;+nxtTimeRecordID);</span>
					}
<span class="nc" id="L1467">					ID origTRID = null;</span>
					// when split, will create a new TR, and update old entry TRID
<span class="nc bnc" id="L1469" title="All 2 branches missed.">					if (splitTR)</span>
<span class="nc" id="L1470">						origTRID = nxtTimeRecordID;</span>
					// first remove entries not included in HAA
<span class="nc bnc" id="L1472" title="All 2 branches missed.">					if (!treRemoveSet.isEmpty()) {</span>
<span class="nc" id="L1473">						m_timeRecordManager.removeTimeRecordEntry(treRemoveSet);</span>
					}
<span class="nc" id="L1475">					ArrayList shiftEventList = new ArrayList(mixedEntryList.size());</span>
<span class="nc" id="L1476">					boolean firstShift = true;</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">					for (Iterator i = mixedEntryList.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1478">						EmployeeEvent event = (EmployeeEvent)i.next();</span>
<span class="nc" id="L1479">						shiftEventList.add(event);</span>
<span class="nc bnc" id="L1480" title="All 4 branches missed.">						if (!i.hasNext() || event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1481">							ArrayList rteList = new ArrayList(shiftEventList.size()+1);</span>
<span class="nc" id="L1482">							ArrayList createList = new ArrayList(shiftEventList.size()+1);</span>
<span class="nc" id="L1483">							ArrayList updateIDList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1484">							ArrayList updateActList = new ArrayList(shiftEventList.size());</span>
<span class="nc bnc" id="L1485" title="All 2 branches missed.">							if (firstShift) {</span>
								// a shift is found, start process it
<span class="nc bnc" id="L1487" title="All 2 branches missed.">								if (autoUpdatePrv) {</span>
									// if need raw time entry, and the previous entry has raw time entry, then update it
<span class="nc bnc" id="L1489" title="All 4 branches missed.">									if (NeedRawEntry &amp;&amp; prvRawEntryID != null) {</span>
<span class="nc" id="L1490">										EmployeeEvent sEvent = (EmployeeEvent)shiftEventList.get(0);</span>
										// in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1492" title="All 2 branches missed.">										if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1493">											((RawTimeEntry)sEvent).setId(prvRawEntryID);</span>
<span class="nc" id="L1494">											TimeCollectorDAO.updateRawTimeEntry((RawTimeEntry)sEvent);</span>
										}
									}
									// handle TimeEntryEvent
<span class="nc" id="L1498">									EmployeeEvent sEvent = (EmployeeEvent)shiftEventList.get(0);</span>
									// in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1500" title="All 2 branches missed.">									if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1501">										TimeRecordEntry tre = convertHAATimeEntry((RawTimeEntry)sEvent, prvTimeRecordID, empID, null, isPaid(sEvent.getActivityID()));</span>
<span class="nc" id="L1502">										tre.setID(prvEntryID);</span>
<span class="nc" id="L1503">										m_timeRecordManager.updateTimeRecordEntry(tre);</span>
									}
									// set audit trail with right start time
<span class="nc" id="L1506">									auditEntry.setImpactStart(prvEntryStart);</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">								} else if (autoMergePrv) {</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">									if (NeedRawEntry) {</span>
										// in case the first entry is no long raw time entry (0 duration removal)
<span class="nc bnc" id="L1510" title="All 2 branches missed.">										if (prvRawEntryID != null)</span>
<span class="nc" id="L1511">											TimeCollectorDAO.updateRawTimeEntryForMerge(prvRawEntryID);</span>
									}
									// handle TimeEntryEvent
<span class="nc bnc" id="L1514" title="All 2 branches missed.">									if (prvEntryID != null)</span>
<span class="nc" id="L1515">										m_timeRecordManager.updateTimeRecordEntryForMerge(prvEntryID);</span>
									// set audit trail with right start time
<span class="nc" id="L1517">									auditEntry.setImpactStart(prvEntryStart);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">								} else if (autoClosePrv) {</span>
<span class="nc" id="L1519">									RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
																	Activity.ACTIVITY_NONE,
																	prvTimeRecordID, null,
																	RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1523">																	new Date(prvEntryStart.getTime()+MINUTE));</span>
<span class="nc bnc" id="L1524" title="All 2 branches missed.">									if (NeedRawEntry) {</span>
<span class="nc" id="L1525">										rteList.add(autoClose);</span>
									}
									// handle TimeEntryEvent
<span class="nc" id="L1528">									createList.add(convertHAATimeEntry(autoClose, prvTimeRecordID, empID, null, isPaid(Activity.ACTIVITY_NONE)));</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">									if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1530">										m_cat.debug(&quot;In autoClosePrv creating new TimeRecord, after autoclose with &quot;+autoClose);</span>
									}									
									// create a new TR
<span class="nc" id="L1533">									prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
									// set audit trail with right start time
<span class="nc" id="L1535">									auditEntry.setImpactStart(autoClose.getSortTime());</span>
<span class="nc" id="L1536">								} else {</span>
									// if no special handling is found
<span class="nc bnc" id="L1538" title="All 8 branches missed.">									if (!i.hasNext() &amp;&amp; (prvActivityID == null || prvActivityID.equals(Activity.ACTIVITY_NONE))</span>
<span class="nc bnc" id="L1539" title="All 4 branches missed.">										&amp;&amp; nxtTimeRecordID != null &amp;&amp; !event.getActivityID().equals(Activity.ACTIVITY_NONE) &amp;&amp; !autoCloseNxt) {</span>
										// if only one shift, if not appending to previous record, then append to next record
<span class="nc" id="L1541">										prvTimeRecordID = nxtTimeRecordID;</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">									} else if (autoGen) {</span>
<span class="nc bnc" id="L1543" title="All 2 branches missed.">										if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1544">											m_cat.debug(&quot;In autoGen creating new TimeRecord, prvActivity=&quot;+prvActivityID+&quot;, nxtTimeRecordID=&quot;+nxtTimeRecordID+&quot;, event is &quot;+event+&quot;, autoCloseNxt=&quot;+autoCloseNxt);</span>
										}																			
										// just append HAA entries to previous TR, if no TR found create one
<span class="nc" id="L1547">										prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
									}
								}
								// set the timerecorod ID
								//auditEntry.setEventID(prvTimeRecordID);
								// if only one shift, do an earlier auto merge with next record fix
<span class="nc bnc" id="L1553" title="All 2 branches missed.">								if (!i.hasNext()) {</span>
<span class="nc bnc" id="L1554" title="All 2 branches missed.">									if (autoMergeNxt) {</span>
<span class="nc" id="L1555">										EmployeeEvent lastEvent = (EmployeeEvent)shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc bnc" id="L1556" title="All 2 branches missed.">										if (lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
											// need change the activity
<span class="nc bnc" id="L1558" title="All 2 branches missed.">											if (lastEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1559">												RawTimeEntry rte = (RawTimeEntry)lastEvent;</span>
<span class="nc" id="L1560">												rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1561">												rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1562">												rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1563">											} else {</span>
<span class="nc" id="L1564">												TimeRecordEntry tre = (TimeRecordEntry)lastEvent;</span>
<span class="nc" id="L1565">												tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
											}
										}
										// set audit trail with right end time
<span class="nc" id="L1569">										auditEntry.setImpactEnd(lastEvent.getSortTime());</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">									} else if (autoCloseNxt) {</span>
										// if only one shift, do earlier autoClose fix
										// find last event, add an AutoClose event after it
<span class="nc" id="L1573">										EmployeeEvent lastEvent = (EmployeeEvent)shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc" id="L1574">										RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
																		Activity.ACTIVITY_NONE,
																		prvTimeRecordID, null,
																		RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1578">																		new Date(lastEvent.getStartTime().getTime() + MINUTE));</span>
<span class="nc" id="L1579">										shiftEventList.add(autoClose);</span>
										// set audit trail with right end time
<span class="nc" id="L1581">										auditEntry.setImpactEnd(autoClose.getSortTime());</span>
<span class="nc bnc" id="L1582" title="All 2 branches missed.">									} else if (event.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1583">										mergeTR = false;</span>
									}
								}
								// if need update prv shift, remove the first entry now which has been handled
<span class="nc bnc" id="L1587" title="All 2 branches missed.">								if (autoUpdatePrv)</span>
<span class="nc" id="L1588">									shiftEventList.remove(0);</span>
								// if only one shift, consider merge condition now, if no auto close condition exist, merge
								// TimeRecordID may be changed in previous step, so check it again here
<span class="nc bnc" id="L1591" title="All 8 branches missed.">								if (!i.hasNext() &amp;&amp; mergeTR &amp;&amp; !autoCloseNxt &amp;&amp; !autoClosePrv) {</span>
<span class="nc" id="L1592">									m_timeRecordManager.updateTimeRecordEntry(nxtTimeRecordID, prvTimeRecordID, null);</span>
								}
<span class="nc" id="L1594">								firstShift = false;</span>
							} else {
								// if not first shift and it has new
<span class="nc bnc" id="L1597" title="All 2 branches missed.">								if (i.hasNext()) {</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">									if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1599">										m_cat.debug(&quot;In another shift, creating new TimeRecord&quot;);</span>
									}
									// should create a new TimeRecord
<span class="nc" id="L1602">									prvTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
								} else {
									// if it is the last chunk, just break
									break;
								}
							}
<span class="nc" id="L1608">							Iterator rsi = shiftEventList.iterator();</span>
<span class="nc" id="L1609">							Iterator si = shiftEventList.iterator();</span>
							// create RTE in batch
<span class="nc bnc" id="L1611" title="All 2 branches missed.">							if (NeedRawEntry) {</span>
<span class="nc bnc" id="L1612" title="All 2 branches missed.">								while (rsi.hasNext()) {</span>
<span class="nc" id="L1613">									EmployeeEvent sEvent = (EmployeeEvent)rsi.next();</span>
<span class="nc bnc" id="L1614" title="All 2 branches missed.">									if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1615">										((RawTimeEntry)sEvent).setTimeRecordID(prvTimeRecordID);</span>
<span class="nc" id="L1616">										rteList.add(sEvent);</span>
									}
<span class="nc" id="L1618">								}</span>
<span class="nc" id="L1619">								TimeCollectorDAO.createRawTimeEntries(rteList);</span>
							}
							// create/update TEE(one condition is timerecord ID is different, the other is AutoMerge)
<span class="nc bnc" id="L1622" title="All 2 branches missed.">							while (si.hasNext()) {</span>
<span class="nc" id="L1623">								EmployeeEvent sEvent = (EmployeeEvent)si.next();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">								if (sEvent instanceof RawTimeEntry) {</span>
									// for RawTimeEntry, we need create them
<span class="nc" id="L1626">									createList.add(convertHAATimeEntry((RawTimeEntry)sEvent, prvTimeRecordID, empID, null, isPaid(sEvent.getActivityID())));</span>
								} else {
<span class="nc" id="L1628">									TimeRecordEntry tre = (TimeRecordEntry)sEvent;</span>
									// if entry is dirty, implies the activity ID is modified
<span class="nc bnc" id="L1630" title="All 2 branches missed.">									if (tre.getDirty()) {</span>
<span class="nc" id="L1631">										updateActList.add(sEvent);</span>
									}
<span class="nc bnc" id="L1633" title="All 2 branches missed.">									if (!tre.getTimeRecordID().equals(prvTimeRecordID)) {</span>
										// for TimeEntryEvent, we will update the timerecord ID, if it is different
<span class="nc" id="L1635">										updateIDList.add(tre.getID());</span>
									}
								}
<span class="nc" id="L1638">							}</span>
							// only need create raw time entries
<span class="nc" id="L1640">							m_timeRecordManager.createTimeRecordEntry(prvTimeRecordID, createList);</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">							if (!updateIDList.isEmpty())</span>
<span class="nc" id="L1642">								m_timeRecordManager.updateTimeRecordEntry(prvTimeRecordID, updateIDList);</span>
<span class="nc bnc" id="L1643" title="All 2 branches missed.">							if (!updateActList.isEmpty())</span>
<span class="nc" id="L1644">								m_timeRecordManager.updateTimeRecordEntryActivity(prvTimeRecordID, updateActList);</span>
							// clear the shiftEvnetList
<span class="nc" id="L1646">							shiftEventList.clear();</span>
						}
<span class="nc" id="L1648">					}</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">					if (splitTR) {</span>
						// as there are at least two shifts, so split situation just happened
<span class="nc" id="L1651">						ID newTRID = null;</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">						if (nxtTimeRecordID.equals(origTRID)) {</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1654">								m_cat.debug(&quot;In splitTR, creating new TimeRecord, origTRID=&quot;+origTRID+&quot;, nxtTimeRecordID=&quot;+nxtTimeRecordID);</span>
							}
<span class="nc" id="L1656">							nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
<span class="nc" id="L1657">							newTRID = nxtTimeRecordID;</span>
						} else
<span class="nc" id="L1659">							newTRID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
						// update timeentry after nxtEntryStart with origTRID to newTRID
<span class="nc" id="L1661">						m_timeRecordManager.updateTimeRecordEntry(origTRID, newTRID, nxtEntryStart);</span>
					}
					// last shift Event handling
<span class="nc bnc" id="L1664" title="All 2 branches missed.">					if (!shiftEventList.isEmpty()) {</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">						if (autoCloseNxt) {</span>
							// no need to merge with next timerecord, just create a new record
<span class="nc" id="L1667">							nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
							// find last event, add an AutoClose event after it
<span class="nc" id="L1669">							EmployeeEvent lastEvent = (EmployeeEvent)shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc" id="L1670">							RawTimeEntry autoClose = new RawTimeEntry(empID,</span>
															Activity.ACTIVITY_NONE,
															nxtTimeRecordID, null,
															RawTimeEntry.AUTOCLOSE_END_SHIFT,
<span class="nc" id="L1674">															new Date(lastEvent.getSortTime().getTime() + MINUTE));</span>
<span class="nc" id="L1675">							shiftEventList.add(autoClose);</span>
							// set audit trail with right end time
<span class="nc" id="L1677">							auditEntry.setImpactEnd(autoClose.getSortTime());</span>
<span class="nc bnc" id="L1678" title="All 2 branches missed.">						} else if (autoMergeNxt) {</span>
<span class="nc" id="L1679">							EmployeeEvent lastEvent = (EmployeeEvent)shiftEventList.get(shiftEventList.size() - 1);</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">							if (lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
								// need change the activity
<span class="nc bnc" id="L1682" title="All 2 branches missed.">								if (lastEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1683">									RawTimeEntry rte = (RawTimeEntry)lastEvent;</span>
<span class="nc" id="L1684">									rte.setActivityId(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1685">									rte.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1686">									rte.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
<span class="nc" id="L1687">								} else {</span>
<span class="nc" id="L1688">									TimeRecordEntry tre = (TimeRecordEntry)lastEvent;</span>
<span class="nc" id="L1689">									tre.setActivityID(Activity.ACTIVITY_MERGE);</span>
								}
							}
<span class="nc" id="L1692">						} else {</span>
<span class="nc bnc" id="L1693" title="All 2 branches missed.">							if (nxtTimeRecordID == null) {</span>
<span class="nc bnc" id="L1694" title="All 2 branches missed.">								if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1695">									m_cat.debug(&quot;In last shift, nxtTimeRecordID is null, so creating new TimeRecord for &quot;+shiftEventList);</span>
								}
<span class="nc" id="L1697">								nxtTimeRecordID = m_timeRecordManager.createTimeRecord(new TimeRecord(empID));</span>
							}
						}
<span class="nc" id="L1700">						Iterator rsi = shiftEventList.iterator();</span>
<span class="nc" id="L1701">						Iterator si = shiftEventList.iterator();</span>
<span class="nc" id="L1702">						ArrayList rteList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1703">						ArrayList createList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1704">						ArrayList updateIDList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1705">						ArrayList updateActList = new ArrayList(shiftEventList.size());</span>
<span class="nc" id="L1706">						createHAAEntries(rsi, si, shiftEventList, rteList, createList, updateIDList, updateActList, nxtTimeRecordID, empID);</span>
					}
				}// finished one employee HAA
<span class="nc" id="L1709">			}</span>
			// remove employees unknown activity cross HAA window
<span class="nc bnc" id="L1711" title="All 4 branches missed.">			if (!empSetCopy.isEmpty() &amp;&amp; !eLearning) {</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1713">					m_cat.debug(&quot;In HAA, now remove unknown activities for &quot;+empSetCopy+&quot; from &quot;+start+&quot; to &quot;+end);</span>
				}
<span class="nc" id="L1715">				m_timeRecordManager.removeUnknownTimeRecordEntry(empSetCopy, start, end);</span>
			}
<span class="nc bnc" id="L1717" title="All 2 branches missed.">			if (NeedRawEntry) {</span>
				// remove unknown activity from RawTimeEntry table
<span class="nc" id="L1719">				TimeCollectorDAO.deleteUnknownActivities(empSetCopy, start, end);</span>
			}
			// last step create audit trail and refresh cache
<span class="nc" id="L1722">			m_auditManager.createAuditEntry(eventAuditList);</span>
<span class="nc" id="L1723">			m_timeRecordManager.refreshCacheForWorkResource(empSetCopy);</span>
<span class="nc" id="L1724">		} catch(JdmoException e) {</span>
<span class="nc" id="L1725">			handleException(e);</span>
<span class="nc" id="L1726">			throw new AmException(e);</span>
<span class="nc" id="L1727">		} catch(BbmCreateException e) {</span>
<span class="nc" id="L1728">			handleException(e);</span>
<span class="nc" id="L1729">			throw new AmException(e);</span>
<span class="nc" id="L1730">		} catch(BbmRemoveException e) {</span>
<span class="nc" id="L1731">			handleException(e);</span>
<span class="nc" id="L1732">			throw new AmException(e);</span>
<span class="nc" id="L1733">		} catch(BbmUpdateException e) {</span>
<span class="nc" id="L1734">			handleException(e);</span>
<span class="nc" id="L1735">			throw new AmException(e);</span>
<span class="nc" id="L1736">		} catch(BbmFinderException e) {</span>
<span class="nc" id="L1737">			handleException(e);</span>
<span class="nc" id="L1738">			throw new AmException(e);</span>
<span class="nc" id="L1739">		} catch(BbmTimeRecordException e) {</span>
<span class="nc" id="L1740">			handleException(e);</span>
<span class="nc" id="L1741">			throw new AmException(e);</span>
<span class="nc" id="L1742">		} catch(RemoteException e) {</span>
<span class="nc" id="L1743">			handleException(e);</span>
<span class="nc" id="L1744">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L1746">			jdmo.cleanUp();</span>
<span class="nc" id="L1747">		}</span>
<span class="nc" id="L1748">	}</span>

	/**
	 * internal function to create HAA entries and TimeRecordEntries
	 * @param rawEntryIterator
	 * @param timeEntryIterator
	 * @param shiftEventList
	 * @param rteList
	 * @param createList
	 * @param updateIDList
	 * @param updateActList
	 * @param timeRecordID
	 * @param empID
	 * @throws JdmoException
	 * @throws BbmUpdateException
	 * @throws BbmCreateException
	 * @throws RemoteException
	 */
	private void createHAAEntries(Iterator rawEntryIterator, Iterator timeEntryIterator,
								  ArrayList shiftEventList,
								  ArrayList rteList,
								  ArrayList createList,
								  ArrayList updateIDList,
								  ArrayList updateActList,
								  ID timeRecordID,
								  ID empID) throws JdmoException, BbmUpdateException, BbmCreateException, RemoteException
	{
		// create RTE in batch
<span class="nc bnc" id="L1776" title="All 2 branches missed.">		if (NeedRawEntry) {</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">			while (rawEntryIterator.hasNext()) {</span>
<span class="nc" id="L1778">				EmployeeEvent sEvent = (EmployeeEvent)rawEntryIterator.next();</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">				if (sEvent instanceof RawTimeEntry) {</span>
<span class="nc" id="L1780">					((RawTimeEntry)sEvent).setTimeRecordID(timeRecordID);</span>
<span class="nc" id="L1781">					rteList.add(sEvent);</span>
				}
<span class="nc" id="L1783">			}</span>
<span class="nc" id="L1784">			TimeCollectorDAO.createRawTimeEntries(rteList);</span>
		}
		// create/update TEE(one condition is timerecord ID is different, the other is AutoMerge)
<span class="nc bnc" id="L1787" title="All 2 branches missed.">		while (timeEntryIterator.hasNext()) {</span>
<span class="nc" id="L1788">			EmployeeEvent sEvent = (EmployeeEvent)timeEntryIterator.next();</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">			if (sEvent instanceof RawTimeEntry) {</span>
				// for RawTimeEntry, we need create them
<span class="nc" id="L1791">				createList.add(convertHAATimeEntry((RawTimeEntry)sEvent, timeRecordID, empID, null, isPaid(sEvent.getActivityID())));</span>
			} else {
<span class="nc" id="L1793">				TimeRecordEntry tre = (TimeRecordEntry)sEvent;</span>
				// if entry is dirty, implies the activity ID is modified
<span class="nc bnc" id="L1795" title="All 2 branches missed.">				if (tre.getDirty()) {</span>
<span class="nc" id="L1796">					updateActList.add(sEvent);</span>
				}
<span class="nc bnc" id="L1798" title="All 2 branches missed.">				if (!tre.getTimeRecordID().equals(timeRecordID)) {</span>
					// for TimeEntryEvent, we will update the timerecord ID, if it is different
<span class="nc" id="L1800">					updateIDList.add(tre.getID());</span>
				}
			}
<span class="nc" id="L1803">		}</span>
		// only need create raw time entries
<span class="nc" id="L1805">		m_timeRecordManager.createTimeRecordEntry(timeRecordID, createList);</span>
<span class="nc bnc" id="L1806" title="All 2 branches missed.">		if (!updateIDList.isEmpty())</span>
<span class="nc" id="L1807">			m_timeRecordManager.updateTimeRecordEntry(timeRecordID, updateIDList);</span>
<span class="nc bnc" id="L1808" title="All 2 branches missed.">		if (!updateActList.isEmpty())</span>
<span class="nc" id="L1809">			m_timeRecordManager.updateTimeRecordEntryActivity(timeRecordID, updateActList);</span>
<span class="nc" id="L1810">	}</span>

	/**
	 * &lt;B&gt;insertRawTimeEntry&lt;/B&gt;
	 * &lt;P&gt;
	 *  represents an activity change by a user
	 *  will create TimeRecord if start shift
	 *  creates RawTimeEntry and TimeEntryEvent records
	 *  sends JMS message to bpx
	 *
	 *  @param rawTimeEntry        raw time data to be inserted
	 *  @param deviceID            device id from user
	 * &lt;P&gt;
	 *  @return                    ID of new entry
	 *
	 */
	public ID insertRawTimeEntry(RawTimeEntry rawTimeEntry, String deviceID)
			throws AmInvalidActivityException, AmNoTimeRecordException, AmException {
<span class="fc" id="L1828">		methodStart(&quot;insertRawTimeEntry&quot;, rawTimeEntry, deviceID);</span>
<span class="fc" id="L1829">		ID newID = null;</span>
<span class="fc" id="L1830">		rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.MYTIME);</span>
		// If RawTimeEntry's activity is not longer active, just reject
<span class="fc" id="L1832">		int isPaid = getIsPaidForActivity(rawTimeEntry.getActivityID());</span>
<span class="pc bpc" id="L1833" title="1 of 2 branches missed.">		if (isPaid &lt; 0)</span>
<span class="nc" id="L1834">			throw new AmInvalidActivityException(AmEjbBundleKey.TIMECOLLECTOR_ACTIVITY_NOTFOUND_ERROR);</span>
		try {
			//---------------------------------------------------------------------
			//  Don't allow these activity to be added
			//  (except for end shift since the ACTIVITY_NONE is in this list)
			//---------------------------------------------------------------------
<span class="fc bfc" id="L1840" title="All 2 branches covered.">			if (rawTimeEntry.getPunchTimeCode() != RawTimeEntry.END_SHIFT ) {</span>
<span class="fc bfc" id="L1841" title="All 2 branches covered.">				for (int i=0; i&lt;ProhibitInsertActivities.length; i++ ) {</span>
<span class="pc bpc" id="L1842" title="1 of 2 branches missed.">					if (rawTimeEntry.getActivityID().equals(ProhibitInsertActivities[i]) ) {</span>
<span class="nc" id="L1843">						throw new AmInvalidActivityException(AmEjbBundleKey.TIMECOLLECTOR_INVALID_ACTIVITY_ERROR);</span>
					}
				}
			}

<span class="fc" id="L1848">			long punchTimeMillis = System.currentTimeMillis();</span>
<span class="fc" id="L1849">			rawTimeEntry.setPunchDate(RawTimeEntry.roundSeconds(new Date(punchTimeMillis)));</span>
<span class="fc" id="L1850">			rawTimeEntry.setPunchTimestamp(punchTimeMillis);</span>

			//---------------------------------------------------------------------
			//  if create time records aren't config, just do nothing
			//---------------------------------------------------------------------
<span class="pc bpc" id="L1855" title="1 of 2 branches missed.">			if (!CreateTimeRecords) {</span>
<span class="nc" id="L1856">				return newID;</span>
			}

			//---------------------------------------------------------------------
			//  TimeRecord ID
			//    get current TimeRecord ID if it exists,
			//    or create new TimeRecord
			//      if create new, mark entry as START_SHIFT
			//---------------------------------------------------------------------
<span class="fc" id="L1865">			ID employeeID = rawTimeEntry.getEmployeeID();</span>
<span class="fc" id="L1866">			boolean doNotAutoClose = rawTimeEntry.isEndShift();</span>
<span class="fc" id="L1867">			TimeRecordEntry lastEvent = m_timeRecordManager.getLastEntry(employeeID, rawTimeEntry.getSortTime());</span>
<span class="fc" id="L1868">			Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, rawTimeEntry.getSortTime(), doNotAutoClose, false);</span>
<span class="fc" id="L1869">			ID timeRecordID = (ID)result[0];</span>
<span class="fc" id="L1870">			Boolean merge = (Boolean)result[1];</span>
<span class="fc" id="L1871">			boolean mergeNeeded = false;</span>
<span class="pc bpc" id="L1872" title="1 of 2 branches missed.">			if (merge != null) {</span>
<span class="fc" id="L1873">				mergeNeeded = merge.booleanValue();</span>
			}

			// check dual endShift, last Activity is EndShift, current one is EndShift also
<span class="pc bpc" id="L1877" title="3 of 6 branches missed.">			if (result[5] != null &amp;&amp; result[5].equals(Activity.ACTIVITY_NONE) &amp;&amp; doNotAutoClose) {</span>
<span class="nc" id="L1878">				throw new AmNoTimeRecordException(AmEjbBundleKey.TIMECOLLECTOR_TIMERECORD_END_SHIFT_ERROR);</span>
			}

			// check if should just update previous entry
<span class="fc" id="L1882">			boolean updatePrv = false;</span>
<span class="fc bfc" id="L1883" title="All 2 branches covered.">			if (result[2] != null) {</span>
<span class="pc bpc" id="L1884" title="2 of 4 branches missed.">				if (FixZeroDuration &amp;&amp; Math.abs(rawTimeEntry.getSortTime().getTime() - ((Date)result[2]).getTime()) &lt; 1000) {</span>
<span class="nc" id="L1885">					updatePrv = true;</span>
				}
			}
			//---------------------------------------------------------
			// if we're merging, remove START_SHIFT code
			// new design is always remove start shifts, or BPX should never send this type
			//---------------------------------------------------------
<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">			if (rawTimeEntry.getPunchTimeCode() == RawTimeEntry.START_SHIFT) {</span>
<span class="nc" id="L1893">				rawTimeEntry.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
			}

<span class="fc bfc" id="L1896" title="All 2 branches covered.">			if (timeRecordID == null) {</span>
				//---------------------------------------------------------
				// if insert is END SHIFT and NO current TimeRecord found
				// throw an exception
				//    no RawTimeEntry created,
				//    no messsage sent to BPX
				//---------------------------------------------------------
<span class="pc bpc" id="L1903" title="1 of 2 branches missed.">				if( rawTimeEntry.isEndShift() ) {</span>
<span class="nc" id="L1904">					throw new AmNoTimeRecordException(AmEjbBundleKey.TIMECOLLECTOR_NO_TIME_RECORD_ERROR);</span>
				}
				// if no timerecord is found, create a new TimeRecord
<span class="fc" id="L1907">				TimeRecord timeRecord = createNewTimeRecord(employeeID);</span>
<span class="fc" id="L1908">				timeRecordID = timeRecord.getID();</span>
<span class="fc" id="L1909">				rawTimeEntry.setPunchTimeCode(RawTimeEntry.START_ACTIVITY);</span>
			}
			//---------------------------------------------------------------------
			//  now that we have a TimeRecord ID
			//  update the  object RawTimeEntry
			//  we need to do this before we create the RawTimeEntry
			//---------------------------------------------------------------------
<span class="fc" id="L1916">			rawTimeEntry.setTimeRecordID(timeRecordID);</span>

			//---------------------------------------------------------------------
			// Set the punch status. If the punch is to be sent to BPX, the initial status is 'Undetermined'
			// and Msg Processor updates the status when it gets it from BPX, otherwise, the punch status is
			// always successful
			//---------------------------------------------------------------------
<span class="fc" id="L1923">			rawTimeEntry.setPunchStatus(ChangeStateStatusMessage.SUCCESSFUL);</span>

			//---------------------------------------------------------------------
			//  create RawTimeEntry entrys in database, if it is needed
			//  this is done first regardless of what else fails
			//---------------------------------------------------------------------
<span class="pc bpc" id="L1929" title="1 of 2 branches missed.">			if (NeedRawEntry) {</span>
				// if no need update previous, or raw time entry is null, just create
<span class="nc bnc" id="L1931" title="All 4 branches missed.">				if (!updatePrv || result[4] == null)</span>
<span class="nc" id="L1932">					newID = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
				else {
					// quick update
<span class="nc" id="L1935">					rawTimeEntry.setId((ID)result[4]);</span>
<span class="nc" id="L1936">					TimeCollectorDAO.updateRawTimeEntry(rawTimeEntry);</span>
				}
			}
			//----------------------------------------------
			//  create a TimeRecordEntry (TimeEntryEvent)
			//----------------------------------------------
<span class="fc" id="L1942">			TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, isPaid(isPaid));</span>
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">			if (timeRecordID != null) {</span>
<span class="pc bpc" id="L1944" title="1 of 2 branches missed.">				if (!mergeNeeded) {</span>
<span class="pc bpc" id="L1945" title="1 of 2 branches missed.">					if (updatePrv) {</span>
<span class="nc" id="L1946">						entry.setID((ID)result[3]);</span>
<span class="nc" id="L1947">						m_timeRecordManager.updateTimeRecordEntry(entry);</span>
<span class="nc" id="L1948">						return entry.getID();</span>
					} else
<span class="fc" id="L1950">						newID = m_timeRecordManager.createTimeRecordEntry(timeRecordID, entry);</span>
				} else {
<span class="nc" id="L1952">					newID = m_timeRecordManager.createTimeRecordEntryForMerge(timeRecordID, entry, null);</span>
				}
			}
<span class="fc" id="L1955">			return newID;</span>
<span class="nc" id="L1956">		} catch (AmNoTimeRecordException e) {</span>
			// leave handling to the caller (can be a user error)
<span class="nc" id="L1958">			throw e;</span>
<span class="nc" id="L1959">		} catch (AmInvalidActivityException e) {</span>
<span class="nc" id="L1960">			handleException(e);</span>
<span class="nc" id="L1961">			throw e;</span>
<span class="nc" id="L1962">		} catch (JdmoException e) {</span>
<span class="nc" id="L1963">			handleException(e);</span>
<span class="nc" id="L1964">			throw new AmException(e);</span>
<span class="nc" id="L1965">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1966">			handleException(e);</span>
<span class="nc" id="L1967">			throw new AmException(e);</span>
<span class="nc" id="L1968">		} catch (Exception e) {</span>
<span class="nc" id="L1969">			handleException(e);</span>
<span class="nc" id="L1970">			throw new AmException(e);</span>
		} finally {
<span class="pc" id="L1972">			methodFinish();</span>
		}
	}

	/**
	 * &lt;B&gt;insertRawTimeEntries&lt;/B&gt;
	 * &lt;P&gt;
	 *  represents an activity change by a user
	 *  will create TimeRecord if start shift
	 *  creates RawTimeEntry and TimeEntryEvent records
	 *
	 *  @param rawTimeEntries      raw time data to be inserted
	 *  @param historical          true if not real time entry
	 * &lt;P&gt;
	 *  @return                    Collection of new ID's created
	 *                             returned in same order of rawTimeEntries
	 * @deprecated
	 */
	public Collection insertRawTimeEntries(Collection rawTimeEntries, boolean historical) throws AmException {
<span class="nc" id="L1991">		return null;</span>
	}

	/**
	 * &lt;B&gt;insertRawTimeEntries&lt;/B&gt;
	 * &lt;P&gt;
	 *  @deprecated
	 *  represents an activity change by a user
	 *  will create TimeRecord if start shift
	 *  creates RawTimeEntry and TimeEntryEvent records
	 *
	 *  @param rawTimeEntries      raw time data to be inserted
	 *  @param deviceId            device id from user
	 *  @param historical          true if not real time entry
	 * &lt;P&gt;
	 *  @return                    Collection of new ID's created
	 *                             returned in same order of rawTimeEntries

	 */
	public Collection insertRawTimeEntries( Collection rawTimeEntries,
											String deviceId,
											boolean historical )
			throws AmException {

<span class="nc" id="L2015">		return null;</span>
	}

	/**
	 * BPX will make sure there is no zero duration entries
	 * @param rawTimeEntries
	 * @throws AmException
	 */
	public void insertTimeEntries(Collection rawTimeEntries, 
										boolean insertToPrimaryTimeLine) throws AmException 
	{
<span class="nc" id="L2026">		methodStart(&quot;insertTimeEntries&quot;, rawTimeEntries, new Boolean(insertToPrimaryTimeLine));</span>

		try
		{
<span class="nc bnc" id="L2030" title="All 4 branches missed.">			if( rawTimeEntries == null || rawTimeEntries.size() &lt;= 0 )</span>
<span class="nc" id="L2031">				return;</span>
			
<span class="nc bnc" id="L2033" title="All 2 branches missed.">			if( insertToPrimaryTimeLine )</span>
			{
<span class="nc" id="L2035">				insertRawTimeEntries(rawTimeEntries);</span>
			}
			else
			{
				try
				{
<span class="nc" id="L2041">					ArrayList evList = new ArrayList();</span>
<span class="nc" id="L2042">					Iterator iter = rawTimeEntries.iterator();</span>
<span class="nc bnc" id="L2043" title="All 2 branches missed.">					while( iter.hasNext() )</span>
					{
<span class="nc" id="L2045">						RawTimeEntry rte = (RawTimeEntry)iter.next();</span>
<span class="nc" id="L2046">						TimeTrackingEvent tte = new TimeTrackingEvent();</span>
						
<span class="nc" id="L2048">						tte.setEmployeeID( rte.getEmployeeID() );</span>
<span class="nc" id="L2049">						tte.setDataSourceID( rte.getDataSourceId() );</span>
<span class="nc" id="L2050">						tte.setActivityID( rte.getActivityID() );</span>
<span class="nc" id="L2051">						tte.setStartTime( rte.getStartTime() );</span>
						
<span class="nc" id="L2053">						evList.add(tte);</span>
						
<span class="nc" id="L2055">					}</span>
<span class="nc" id="L2056">					m_timeTrackingManager.createEvents(evList);</span>
<span class="nc" id="L2057">				} catch (BbmCreateException e) {</span>
<span class="nc" id="L2058">					handleException(e,false);</span>
<span class="nc" id="L2059">					throw new AmException(e);</span>
<span class="nc" id="L2060">				} catch (RemoteException e) {</span>
<span class="nc" id="L2061">					handleException(e);</span>
<span class="nc" id="L2062">					throw new EJBException(e);</span>
<span class="nc" id="L2063">				} </span>
			}
		}
		finally {
<span class="nc" id="L2067">					methodFinish();</span>
<span class="nc" id="L2068">		}</span>

<span class="nc" id="L2070">	}</span>
	/**
	 * BPX will make sure there is no zero duration entries
	 * @param rawTimeEntries
	 * @throws AmException
	 */
	public void insertRawTimeEntries(Collection rawTimeEntries) throws AmException {
<span class="nc" id="L2077">		methodStart(&quot;insertRawTimeEntries&quot;, rawTimeEntries);</span>
<span class="nc" id="L2078">		m_cat.debug(new LogMessage(rawTimeEntries, &quot;***********Entered Method with &quot; + rawTimeEntries.size() + &quot; enteries.&quot;));</span>
<span class="nc" id="L2079">		Collection rawTimeEntriesCopy = new ArrayList(rawTimeEntries);</span>

		//---------------------------------------------------------------------
		//  first make sure we have data
		//---------------------------------------------------------------------
<span class="nc bnc" id="L2084" title="All 4 branches missed.">		if( rawTimeEntriesCopy == null || rawTimeEntriesCopy.size() == 0 ) {</span>
<span class="nc" id="L2085">			return;</span>
		}
<span class="nc" id="L2087">		Exception cachedExp = null;</span>
		try {
<span class="nc" id="L2089">			Collection employeeIDs = getEmployeeIDs(rawTimeEntries);</span>
<span class="nc" id="L2090">			HashMap lastEventMap = m_timeRecordManager.getLastEntries(employeeIDs, null);</span>

			//---------------------------------------------------------------------
			//  set up our RawTimeEntry handler
			//  get employee id and first shift (applied auto merge rules)
			//---------------------------------------------------------------------
<span class="nc" id="L2096">			RawTimeEntryHandler rawTimeEntryHandler = new RawTimeEntryHandler(rawTimeEntriesCopy, PerformAutoMerge, AutoMergeTimeoutInMillis);</span>

<span class="nc" id="L2098">			ID employeeID = rawTimeEntryHandler.nextEmployeeId();</span>
<span class="nc" id="L2099">			m_cat.debug(&quot;Processing employee with ID= &quot; + employeeID);</span>
<span class="nc" id="L2100">			ArrayList nextShiftOfRawTimeEntries = rawTimeEntryHandler.nextEmployeeShift();</span>
<span class="nc" id="L2101">			m_cat.debug(&quot;number of enteries in nextShiftOfRawTimeEntries = &quot; + nextShiftOfRawTimeEntries.size());</span>

<span class="nc" id="L2103">			HashSet employeeHandled = new HashSet();</span>

			//---------------------------------------------------------------------
			//  get RawTimeEntries in groups of shifts
			//---------------------------------------------------------------------
			// We always get last event in the whole system, so it may be event from manager, and be after some events from BPX
			// A simple filter logic is introduced to discard any entries before last Event			
			
<span class="nc bnc" id="L2111" title="All 2 branches missed.">			while (!nextShiftOfRawTimeEntries.isEmpty()) {</span>
<span class="nc" id="L2112">				boolean bInsertEnrty = true;</span>
<span class="nc bnc" id="L2113" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2114">					m_cat.debug(&quot;Before normalization, raw entries are &quot;+nextShiftOfRawTimeEntries);</span>
				}
				// normalize raw entries
<span class="nc" id="L2117">				RawTimeEntryHandler.normalizeEntries(nextShiftOfRawTimeEntries, FixZeroDuration);</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2119">					m_cat.debug(&quot;After normalization, raw entries are &quot;+nextShiftOfRawTimeEntries);</span>
				}								
				// group works into one seperate tx
				// if it is first time to handle Employee, there are some logical conditions to judge
<span class="nc" id="L2123">				RawTimeEntry minRawTimeEntry = null;</span>
<span class="nc" id="L2124">				TimeRecordEntry lastEvent = null;</span>
<span class="nc" id="L2125">				boolean empHandled = employeeHandled.contains(employeeID);</span>
<span class="nc" id="L2126">				m_cat.debug(&quot;Employee Id = &quot; + employeeID + &quot; ishandled= &quot; + empHandled);</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">				if (!empHandled) {	</span>
<span class="nc" id="L2128">					m_cat.debug(&quot;Employee Id = &quot; + employeeID + &quot; Not Handled.&quot;);</span>
					// first time, it is from the cache map, after that it will be the last Entry in shift
<span class="nc" id="L2130">					lastEvent = (TimeRecordEntry)lastEventMap.get(employeeID);</span>
<span class="nc" id="L2131">					boolean prvRecordClosed = true;</span>
<span class="nc bnc" id="L2132" title="All 2 branches missed.">					if (lastEvent != null)						</span>
<span class="nc" id="L2133">						prvRecordClosed = lastEvent.getActivityID().equals(Activity.ACTIVITY_NONE);					</span>
					// Find earliest entry in the shift, which is after last event					
<span class="nc bnc" id="L2135" title="All 2 branches missed.">					for (Iterator it = nextShiftOfRawTimeEntries.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2136">						RawTimeEntry entry = (RawTimeEntry)it.next();</span>
<span class="nc" id="L2137">						boolean isEndShift = entry.getActivityID().equals(Activity.ACTIVITY_NONE);</span>
						// if previous record is closed or not exist, we should remove end shift at the beginning
<span class="nc bnc" id="L2139" title="All 4 branches missed.">						if (prvRecordClosed &amp;&amp; isEndShift) {</span>
<span class="nc" id="L2140">							m_cat.debug(&quot;prvRecordClosed &amp;&amp; isEndShift are true, ignoring entry= &quot; + entry);</span>
<span class="nc" id="L2141">							it.remove();</span>
<span class="nc" id="L2142">							continue;</span>
						}
<span class="nc bnc" id="L2144" title="All 2 branches missed.">						if (lastEvent == null </span>
<span class="nc bnc" id="L2145" title="All 4 branches missed.">								|| entry.getSortTime().after(lastEvent.getSortTime())</span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">								|| (!FixZeroDuration &amp;&amp; entry.getSortTime().equals(lastEvent.getSortTime()))) {</span>
<span class="nc" id="L2147">							m_cat.debug(&quot; **** setting min rte=&quot; +  entry);</span>
<span class="nc" id="L2148">							minRawTimeEntry = entry;</span>
<span class="nc" id="L2149">							break;</span>
						} else {
							// remove entries before last event
<span class="nc" id="L2152">							m_cat.debug(&quot;entry before last event, ignoring entry= &quot; + entry);</span>
<span class="nc" id="L2153">							it.remove();</span>
						}
<span class="nc" id="L2155">					}</span>
<span class="nc bnc" id="L2156" title="All 2 branches missed.">					if (minRawTimeEntry == null)</span>
					{
						// Fix for QA77876
						// If there is only one event in the collection for employee and if it is logout
						// and if previous event for employee was logout or endshift
						// the loop terminates for all employees.

<span class="nc" id="L2163">						m_cat.debug(&quot;minRawTimeEntry is null&quot;);</span>
<span class="nc" id="L2164">						bInsertEnrty = false;</span>
					}
<span class="nc" id="L2166">				} else {</span>
					// need remove empty TR case, which has only one entry
<span class="nc bnc" id="L2168" title="All 4 branches missed.">					if (!nextShiftOfRawTimeEntries.isEmpty() &amp;&amp; nextShiftOfRawTimeEntries.size() == 1) {</span>
<span class="nc" id="L2169">						RawTimeEntry entry = (RawTimeEntry)nextShiftOfRawTimeEntries.get(0);</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">						if (entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
							// skip this case
<span class="nc bnc" id="L2172" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2173">								m_cat.debug(&quot;Detect an empty TR with only one EndShift, just skipt &quot;+entry);</span>
							}
<span class="nc" id="L2175">							bInsertEnrty = false;</span>
						}						
					}
				}
				try {
					// each chunk is inserted in a seperate transaction
<span class="nc bnc" id="L2181" title="All 2 branches missed.">					if(bInsertEnrty)</span>
<span class="nc" id="L2182">						((TimeCollectorManager)m_sessionContext.getEJBObject()).insertRawTimeEntriesPerChunk(employeeID, nextShiftOfRawTimeEntries, empHandled, lastEvent, minRawTimeEntry);</span>
<span class="nc" id="L2183">				} catch(RemoteException e) {</span>
<span class="nc bnc" id="L2184" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2185">						m_cat.debug(&quot;Failed to insert a chunk for employee &quot;+employeeID+&quot;, lastEvent is &quot;+lastEvent+&quot;, employee is handled &quot;+empHandled+&quot; minEntry &quot;+minRawTimeEntry);</span>
<span class="nc" id="L2186">						m_cat.debug(&quot;Chunk failed contains &quot;+nextShiftOfRawTimeEntries);</span>
					}
<span class="nc" id="L2188">					handleException(e);</span>
<span class="nc" id="L2189">					throw new EJBException(e);</span>
				}  
<span class="nc" id="L2191">				catch(Exception e) {</span>
<span class="nc bnc" id="L2192" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2193">						m_cat.debug(&quot;Failed to insert a chunk for employee &quot;+employeeID+&quot;, lastEvent is &quot;+lastEvent+&quot;, employee is handled &quot;+empHandled+&quot; minEntry &quot;+minRawTimeEntry);</span>
<span class="nc" id="L2194">						m_cat.debug(&quot;Chunk failed contains &quot;+nextShiftOfRawTimeEntries);</span>
					}
<span class="nc" id="L2196">					handleException(e);</span>
					//we want to cache the at least one exception so BPX will report failure 
<span class="nc" id="L2198">					cachedExp = e;</span>
<span class="nc" id="L2199">				}</span>
				// continue to next Employee
<span class="nc" id="L2201">				m_cat.debug(&quot;Add Employee ID &quot;+employeeID);</span>
<span class="nc" id="L2202">				employeeHandled.add(employeeID);</span>
<span class="nc" id="L2203">				employeeID = rawTimeEntryHandler.nextEmployeeId();</span>
<span class="nc" id="L2204">				m_cat.debug(&quot;Next employee ID=  &quot;+employeeID);</span>
<span class="nc" id="L2205">				nextShiftOfRawTimeEntries = rawTimeEntryHandler.nextEmployeeShift();</span>
<span class="nc" id="L2206">				m_cat.debug(&quot;nextShiftOfRawTimeEntries=  &quot;+ nextShiftOfRawTimeEntries);</span>
<span class="nc" id="L2207">			}</span>
<span class="nc" id="L2208">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2209">			handleException(e,false);</span>
<span class="nc" id="L2210">			throw new AmException(e);</span>
<span class="nc" id="L2211">		} catch (RemoteException e) {</span>
<span class="nc" id="L2212">			handleException(e);</span>
<span class="nc" id="L2213">			throw new EJBException(e);</span>
		} finally {
<span class="nc" id="L2215">			methodFinish();</span>
<span class="nc bnc" id="L2216" title="All 4 branches missed.">			if (cachedExp!= null)</span>
<span class="nc" id="L2217">				throw new AmException(cachedExp); </span>
		}
<span class="nc" id="L2219">	}</span>

	/**
	 * Internal helper function to group insertion of raw time entries in chunk, and in one transaction
	 * Not to be invoked directly by other 
	 * @param employeeID
	 * @param lastEvent
	 * @param nextShiftOfRawTimeEntries
	 * @param empHandled
	 * @param minRawTimeEntry1
	 * @throws Exception
	 */
	public void insertRawTimeEntriesPerChunk(ID employeeID, ArrayList nextShiftOfRawTimeEntries, boolean empHandled, TimeRecordEntry lastEvent, RawTimeEntry minRawTimeEntry1) throws AmException, RemoteException {
		try {
<span class="nc" id="L2233">			m_cat.debug(new LogMessage(employeeID, &quot;Enter function insertRawTimeEntriesPerChunk&quot; +</span>
					     &quot; employeeID= &quot;+ employeeID +
					     &quot; nextShiftOfRawTimeEntries= &quot; + nextShiftOfRawTimeEntries +
					     &quot; empHandled= &quot;+ empHandled +
					     &quot; lastEvent= &quot; + lastEvent +
					     &quot; minRawTimeEntry1+ &quot; +  minRawTimeEntry1));
	
<span class="nc" id="L2240">			ID timeRecordID = null;</span>
<span class="nc" id="L2241">			boolean mergeNeeded = false;</span>
<span class="nc" id="L2242">			boolean updatePrv = false;</span>
<span class="nc" id="L2243">			ID prvEntryID = null;</span>
<span class="nc" id="L2244">			ID prvRawEntryID = null;</span>
<span class="nc" id="L2245">			ID prvActivityID = null;</span>
<span class="nc" id="L2246">			int prvTimeSourceCode = TimeEntrySourceCode.RAWPUNCH;	</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">			if (!empHandled) {</span>
				//-------------------------------------------------------------------
				// if the minRawTimeEntry is end shift, do not autoclose
				//-------------------------------------------------------------------
<span class="nc" id="L2251">				boolean doNotAutoClose = minRawTimeEntry1.isEndShift();</span>
<span class="nc" id="L2252">				Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, minRawTimeEntry1.getPunchDate(), doNotAutoClose, false);</span>
<span class="nc" id="L2253">				timeRecordID = (ID)result[0];</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">				if (timeRecordID != null) {</span>
<span class="nc" id="L2255">					Boolean merge = (Boolean)result[1];</span>
<span class="nc bnc" id="L2256" title="All 2 branches missed.">					if (merge != null) {</span>
<span class="nc" id="L2257">						mergeNeeded = merge.booleanValue();</span>
					}
<span class="nc" id="L2259">					prvActivityID = (ID)result[5];</span>
<span class="nc" id="L2260">					Integer sourceCode = (Integer)result[6];</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">					prvTimeSourceCode = sourceCode != null?sourceCode.intValue():prvTimeSourceCode;</span>
					// check if need update previous entry
<span class="nc bnc" id="L2263" title="All 2 branches missed.">					if (result[2] != null) {</span>
<span class="nc bnc" id="L2264" title="All 4 branches missed.">						if (FixZeroDuration &amp;&amp; ( Math.abs(minRawTimeEntry1.getSortTime().getTime() - ((Date)result[2]).getTime())) &lt; 1000) {</span>
<span class="nc" id="L2265">							updatePrv = true;</span>
<span class="nc" id="L2266">							prvEntryID = (ID)result[3];</span>
<span class="nc" id="L2267">							prvRawEntryID = (ID)result[4];</span>
						}
					}
				}
			}
			
			//-------------------------------------------------------------------
			//  if we don't have a timerecord
			//    create one now
			//    make sure merge condition is not set
			//-------------------------------------------------------------------
<span class="nc bnc" id="L2278" title="All 2 branches missed.">			if (timeRecordID == null) {</span>
<span class="nc" id="L2279">				TimeRecord timeRecord = createNewTimeRecord(employeeID);</span>
<span class="nc" id="L2280">				timeRecordID = timeRecord.getID();</span>
<span class="nc" id="L2281">				mergeNeeded = false;</span>
			}
			
			// check if the first Event has the same Activity/TimeSourceCode as previous Event
			// if so no need to create duplicated Activity Event
<span class="nc" id="L2286">			RawTimeEntry minRawTimeEntry =(RawTimeEntry)nextShiftOfRawTimeEntries.get(0);</span>
<span class="nc bnc" id="L2287" title="All 8 branches missed.">			if ( FixZeroDuration &amp;&amp; </span>
					!mergeNeeded &amp;&amp; prvTimeSourceCode == TimeEntrySourceCode.RAWPUNCH &amp;&amp;
					prvActivityID != null &amp;&amp;
<span class="nc bnc" id="L2290" title="All 2 branches missed.">					minRawTimeEntry.getActivityID().equals(prvActivityID) &amp;&amp;</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">					minRawTimeEntry.getTimeSourceCode() == prvTimeSourceCode) {</span>
<span class="nc" id="L2292">				nextShiftOfRawTimeEntries.remove(0);</span>
<span class="nc" id="L2293">				updatePrv = false;</span>
			}
			
			//---------------------------------------------------------------------
			//  now that we have a TimeRecord ID
			//  update each of the RawTimeEntry value objects
			//---------------------------------------------------------------------
<span class="nc" id="L2300">			setTimeRecordID(nextShiftOfRawTimeEntries, timeRecordID);</span>
			
			//---------------------------------------------------------------------
			//  CREATE RawTimeEntry entrys in database in bulk
			//  this is done first regardless of what else fails
			//---------------------------------------------------------------------
<span class="nc bnc" id="L2306" title="All 2 branches missed.">			if (NeedRawEntry) {</span>
<span class="nc bnc" id="L2307" title="All 4 branches missed.">				if (updatePrv &amp;&amp; prvRawEntryID != null) {</span>
<span class="nc" id="L2308">					minRawTimeEntry.setId(prvRawEntryID);</span>
<span class="nc" id="L2309">					TimeCollectorDAO.updateRawTimeEntry(minRawTimeEntry);</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">					if (nextShiftOfRawTimeEntries.size() &gt; 1) {</span>
<span class="nc" id="L2311">						ArrayList createList = new ArrayList(nextShiftOfRawTimeEntries.subList(1, nextShiftOfRawTimeEntries.size()-1));</span>
<span class="nc" id="L2312">						TimeCollectorDAO.createRawTimeEntries(createList);</span>
<span class="nc" id="L2313">					}</span>
				} else {
<span class="nc" id="L2315">					TimeCollectorDAO.createRawTimeEntries(nextShiftOfRawTimeEntries);</span>
				}
			}
			//---------------------------------------------------------------------
			//  now CREATE TimeEntryEvent entries for each RawTimeEntry
			//---------------------------------------------------------------------
<span class="nc" id="L2321">			ArrayList timeEntryList = new ArrayList(nextShiftOfRawTimeEntries.size());</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">			for (Iterator i = nextShiftOfRawTimeEntries.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2323">				RawTimeEntry rawTimeEntry = (RawTimeEntry)i.next();</span>
				//----------------------------------------------
				// create a TimeRecordEntry (TimeEntryEvent)
				// for each RawTimeEntry
				//----------------------------------------------
<span class="nc" id="L2328">				rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2329">				TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, isPaid(getIsPaidForActivity(rawTimeEntry.getActivityID())));</span>
<span class="nc" id="L2330">				timeEntryList.add(entry);</span>
<span class="nc" id="L2331">			}</span>
			// Create through TimeRecordManager
<span class="nc bnc" id="L2333" title="All 2 branches missed.">			if (mergeNeeded) {</span>
				// fetch the first entry and create it with merge, then the left are just normal insert
<span class="nc" id="L2335">				TimeRecordEntry firstEntry = (TimeRecordEntry)timeEntryList.remove(0);</span>
<span class="nc" id="L2336">				m_timeRecordManager.createTimeRecordEntryForMerge(timeRecordID, firstEntry, null);</span>
<span class="nc" id="L2337">			} else {</span>
<span class="nc bnc" id="L2338" title="All 2 branches missed.">				if (updatePrv) {</span>
<span class="nc" id="L2339">					TimeRecordEntry firstEntry = (TimeRecordEntry)timeEntryList.remove(0);</span>
<span class="nc" id="L2340">					firstEntry.setID(prvEntryID);</span>
<span class="nc" id="L2341">					m_timeRecordManager.updateTimeRecordEntry(firstEntry);</span>
				}
			}
<span class="nc bnc" id="L2344" title="All 2 branches missed.">			if (!timeEntryList.isEmpty())</span>
<span class="nc" id="L2345">				m_timeRecordManager.createTimeRecordEntry(timeRecordID, timeEntryList);</span>
<span class="nc" id="L2346">		} catch(JdmoException e) {</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">			if(e.isConnectivityException())</span>
<span class="nc" id="L2348">				throw new ConnectException(e.getMessage(),e);</span>
<span class="nc" id="L2349">			throw new AmException(e);</span>
<span class="nc" id="L2350">		} catch(BbmException e) {</span>
<span class="nc" id="L2351">			throw new AmException(e);</span>
<span class="nc" id="L2352">		} catch(RemoteException e) {</span>
<span class="nc" id="L2353">			throw new EJBException(e);</span>
<span class="nc" id="L2354">		}</span>
<span class="nc" id="L2355">	}</span>
	/**
	 * &lt;B&gt;insertPunchTimeErrors&lt;/B&gt;
	 *
	 *  inserts errors from bpx in database
	 *
	 *  @param changeStateStatusMessages      Collection of status messages
	 *                                        returned from bpx
	 */
	public void insertPunchTimeErrors(Collection changeStateStatusMessages) throws AmException {
<span class="nc" id="L2365">		methodStart(&quot;insertPunchTimeErrors&quot;, changeStateStatusMessages);</span>
		try {
		} finally {
<span class="nc" id="L2368">			methodFinish();</span>
		}
<span class="nc" id="L2370">	}</span>
	/**
	 * &lt;B&gt;insertUnknownActivity&lt;/B&gt;
	 *
	 *  insert Activity.ACTIVITY_UNKNOWN for each given employee associated with the DataSource
	 *  if their last record is open and has entry created from ACD
	 *
	 *  @param dataSourceID       ID of datasource
	 *  @param date               time of unknown activity
	 *
	 */
	public void insertUnknownActivity(ID dataSourceID, Date date) throws AmException {
<span class="nc" id="L2382">		methodStart(&quot;insertUnkonwActivity&quot;, dataSourceID, date);</span>
<span class="nc" id="L2383">		int isUnknownActivityPaid = getIsPaidForActivity(Activity.ACTIVITY_UNKNOWN);</span>
<span class="nc" id="L2384">		boolean unKnownPaid = isPaid(isUnknownActivityPaid);</span>
<span class="nc" id="L2385">		Jdmo jdmo = new Jdmo();</span>
		try {
			// First find all employees associated with the DataSource
<span class="nc" id="L2388">			String strSQL = &quot;SELECT EMPLOYEEID FROM EMPLOYEEDATASOURCE WHERE DATASOURCEID=?&quot;;</span>
<span class="nc" id="L2389">			HashSet employeeIDs = new HashSet();</span>
<span class="nc" id="L2390">			JdmoQuery jQuery = jdmo.createQuery(strSQL, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2391">			jQuery.setParID(1, dataSourceID);</span>
<span class="nc" id="L2392">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2394">				employeeIDs.add(rs.getID(1));</span>
			}
<span class="nc" id="L2396">			rs.close();</span>
			// list of employees that have unknown activity in past
<span class="nc" id="L2398">			ArrayList empList = new ArrayList();</span>
			// Now work on each employee, and check if need close previous record, but not auto merge
<span class="nc" id="L2400">			HashMap lastEventMap = m_timeRecordManager.getLastEntries(employeeIDs, null);</span>
<span class="nc" id="L2401">			HashSet recordSet = new HashSet(employeeIDs.size());</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">			for (Iterator i = employeeIDs.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2403">				ID employeeID = (ID)i.next();</span>
<span class="nc" id="L2404">				TimeRecordEntry lastEvent = (TimeRecordEntry)lastEventMap.get(employeeID);</span>
<span class="nc" id="L2405">				Object[] result = findCurrentTimeRecordID(employeeID, lastEvent, date, false, true);</span>
<span class="nc" id="L2406">				ID timeRecordID = (ID)result[0];</span>
<span class="nc" id="L2407">				Boolean merge = (Boolean)result[1];</span>
				// if need merge, means prv record is closed, ignore it recreate a new TR
				// if no prv record is chosen, just create a new TR
<span class="nc bnc" id="L2410" title="All 4 branches missed.">				if (merge.booleanValue() || timeRecordID == null) {</span>
<span class="nc bnc" id="L2411" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2412">						m_cat.debug(&quot;In Unknown window, the previous record is either closed or not exist, record id &quot;+result[0]+&quot; and needMerge is &quot;+result[1]+&quot; for employee &quot;+employeeID);</span>
					}
				} else {
					// We only create unknown shift, if previous shift is still open.
					// unknown event is historic, that is it occurs before
					// the last event, skip this employee and process later
<span class="nc bnc" id="L2418" title="All 2 branches missed.">					if( lastEvent.getStartTime().after(date) )</span>
					{
<span class="nc" id="L2420">						empList.add(employeeID);</span>
<span class="nc" id="L2421">						continue;</span>
					}
<span class="nc" id="L2423">					Pair empRecordPair = new Pair(timeRecordID, employeeID);</span>
<span class="nc" id="L2424">					recordSet.add(empRecordPair);</span>
				}
<span class="nc" id="L2426">			}</span>

<span class="nc" id="L2428">			ArrayList rawTimeEntries = new ArrayList(employeeIDs.size());</span>
<span class="nc" id="L2429">			ArrayList timeEntries = new ArrayList(employeeIDs.size());			</span>
<span class="nc bnc" id="L2430" title="All 2 branches missed.">			for (Iterator it = recordSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2431">				Pair empRecordPair = (Pair)it.next();</span>
<span class="nc" id="L2432">				ID timeRecordID = (ID)empRecordPair.getFirst();</span>
<span class="nc" id="L2433">				ID employeeID = (ID)empRecordPair.getSecond();</span>
<span class="nc" id="L2434">				RawTimeEntry rawTimeEntry =</span>
					new RawTimeEntry(null, employeeID,
							Activity.ACTIVITY_UNKNOWN,
							timeRecordID,
							dataSourceID,
							null,
							RawTimeEntry.START_ACTIVITY,
							date);
<span class="nc" id="L2442">				rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2443">				rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2444">				TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, unKnownPaid);</span>
<span class="nc" id="L2445">				timeEntries.add(tre);</span>
<span class="nc" id="L2446">			}</span>
			// create
<span class="nc bnc" id="L2448" title="All 2 branches missed.">			if (NeedRawEntry) {</span>
<span class="nc" id="L2449">				TimeCollectorDAO.createRawTimeEntries(rawTimeEntries);</span>
			}
<span class="nc" id="L2451">			m_timeRecordManager.createTimeRecordEntry(timeEntries);</span>
			// process skipped employees 
<span class="nc bnc" id="L2453" title="All 2 branches missed.">			if( empList.size() &gt; 0 )</span>
			{
<span class="nc" id="L2455">				timeEntries.clear();</span>
<span class="nc" id="L2456">				rawTimeEntries.clear();</span>

<span class="nc" id="L2458">				Date dtStart = new Date ( date.getTime() - UnknownEventInterval );</span>
<span class="nc" id="L2459">				Date dtEnd = new Date ( date.getTime() + UnknownEventInterval );</span>
				
				// get the timerecord id for the unknown event date
<span class="nc" id="L2462">				Map extRecordMap = m_timeRecordManager.getEventsForWorkResource(empList, dtStart, dtEnd);</span>

<span class="nc bnc" id="L2464" title="All 2 branches missed.">				for( int i=0; i &lt; empList.size(); ++i )</span>
				{
<span class="nc" id="L2466">					ID employeeID = (ID)empList.get(i);</span>
<span class="nc" id="L2467">					ArrayList extRecordList = (ArrayList)extRecordMap.get(employeeID);</span>
<span class="nc bnc" id="L2468" title="All 4 branches missed.">					if( extRecordList == null || extRecordList.isEmpty()) </span>
					{
<span class="nc" id="L2470">						continue; // no time record so skip</span>
					}

					// search for the correct time record
<span class="nc" id="L2474">					ID timeRecordID = null;</span>
					
<span class="nc bnc" id="L2476" title="All 2 branches missed.">					for( int j=0; j &lt; extRecordList.size(); ++j )</span>
					{
<span class="nc" id="L2478">						TimeRecord curRecord = (TimeRecord)extRecordList.get(j);</span>
<span class="nc" id="L2479">						ArrayList entryList = curRecord.getChild();</span>
<span class="nc bnc" id="L2480" title="All 4 branches missed.">						if( entryList == null || entryList.size() &lt;= 0 )</span>
<span class="nc" id="L2481">							continue;</span>
						
<span class="nc" id="L2483">						TimeRecordEntry first = (TimeRecordEntry)entryList.get(0);</span>
<span class="nc" id="L2484">						TimeRecordEntry last = (TimeRecordEntry)entryList.get(entryList.size()-1);</span>

						// if first activity is end shift then skip
<span class="nc bnc" id="L2487" title="All 2 branches missed.">						if( first.getActivityID().equals(Activity.ACTIVITY_NONE) )</span>
<span class="nc" id="L2488">							continue;</span>

<span class="nc bnc" id="L2490" title="All 4 branches missed.">						if( date.after(first.getStartTime()) &amp;&amp; date.before(last.getStartTime()) )</span>
						{
<span class="nc" id="L2492">							timeRecordID = curRecord.getID();</span>
<span class="nc" id="L2493">							break;</span>
						}
					}
					
<span class="nc bnc" id="L2497" title="All 2 branches missed.">					if( timeRecordID == null )</span>
<span class="nc" id="L2498">						continue;</span>
	
<span class="nc" id="L2500">						RawTimeEntry rawTimeEntry =</span>
							new RawTimeEntry(null, employeeID,
									Activity.ACTIVITY_UNKNOWN,
									timeRecordID,
									dataSourceID,
									null,
									RawTimeEntry.START_ACTIVITY,
									date);
<span class="nc" id="L2508">						rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.RAWPUNCH);</span>
<span class="nc" id="L2509">						rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2510">						TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, null, unKnownPaid);</span>
<span class="nc" id="L2511">						timeEntries.add(tre);</span>
				}

				// create
<span class="nc bnc" id="L2515" title="All 2 branches missed.">				if (NeedRawEntry) {</span>
<span class="nc" id="L2516">					TimeCollectorDAO.createRawTimeEntries(rawTimeEntries);</span>
				}
<span class="nc" id="L2518">				m_timeRecordManager.createTimeRecordEntry(timeEntries);</span>
			}
<span class="nc" id="L2520">		} catch(JdmoException e) {</span>
<span class="nc" id="L2521">			handleException(e);</span>
<span class="nc" id="L2522">			throw new AmException(e);</span>
<span class="nc" id="L2523">		} catch(BbmFinderException e) {</span>
<span class="nc" id="L2524">			handleException(e);</span>
<span class="nc" id="L2525">			throw new AmException(e);</span>
<span class="nc" id="L2526">		} catch(BbmCreateException e) {</span>
<span class="nc" id="L2527">			handleException(e);</span>
<span class="nc" id="L2528">			throw new AmException(e);</span>
<span class="nc" id="L2529">		} catch(RemoteException e) {</span>
<span class="nc" id="L2530">			handleException(e);</span>
<span class="nc" id="L2531">			throw new AmException(e);</span>
		} /*catch (BbmTimeRecordException e) {
			handleException(e);
			throw new AmException(e);
		} */finally {
<span class="nc" id="L2536">			jdmo.cleanUp();</span>
<span class="nc" id="L2537">			methodFinish();</span>
<span class="nc" id="L2538">		}</span>
<span class="nc" id="L2539">	}</span>

	/**
	 * &lt;B&gt;insertUnknownActivity&lt;/B&gt;
	 *
	 *  insert Activity.ACTIVITY_UNKNOWN for each given employee, no update for 0 duration entry
	 *
	 *  @param employeeIDs        list of employee IDs for insert
	 *  @param dataSourceID       ID of datasource
	 *  @param date               time of unknown activity
	 *
	 *  @return                   Collection of new ID's
	 *
	 */
	public Collection insertUnknownActivity(  Collection employeeIDs,
											  ID dataSourceID,
											  Date date ) throws AmException {
<span class="nc" id="L2556">		return null;</span>
	}

	/**
	 * &lt;B&gt;updateRawTimeEntry&lt;/B&gt;
	 *
	 * updates fields of given RawTimeEntry
	 *
	 * @param rawTimeEntry        raw time data to be updated
	 */
	public void updateRawTimeEntry(RawTimeEntry rawTimeEntry) throws AmException {
<span class="nc" id="L2567">		ArrayList rawTimeEntries = new ArrayList(1);</span>
<span class="nc" id="L2568">		rawTimeEntries.add(rawTimeEntry);</span>
<span class="nc" id="L2569">		updateRawTimeEntries(rawTimeEntries);</span>
<span class="nc" id="L2570">	}</span>

	/**
	 * &lt;B&gt;updateRawTimeEntries&lt;/B&gt;
	 * updates fields of given RawTimeEntry's, quick update
	 *
	 * @param rawTimeEntries       collection of raw time data to be updated
	 * &lt;P&gt;
	 * @return                     collection of ID's that couldn't be updated
	 */
	public Collection updateRawTimeEntries(Collection rawTimeEntries) throws AmException {
<span class="nc" id="L2581">		methodStart(&quot;updateRawTimeEntries&quot;, rawTimeEntries);</span>
<span class="nc" id="L2582">		Collection rawTimeEntriesCopy = new ArrayList(rawTimeEntries);</span>
<span class="nc" id="L2583">		Collection updateErrors = new ArrayList();</span>
		try {
			//-----------------------------------------------------------------
			// first batch update the rawTimeEntries, if they exist
			//-----------------------------------------------------------------
<span class="nc bnc" id="L2588" title="All 2 branches missed.">			if (NeedRawEntry) {</span>
<span class="nc" id="L2589">				TimeCollectorDAO.updateRawTimeEntryActivities(rawTimeEntriesCopy);</span>
			}
			//-----------------------------------------------------------------
			// now we need to update the TimeRecordEntries (TimeEntryEvents)
			// update only if now error updating
			//-----------------------------------------------------------------
<span class="nc" id="L2595">			Collection recordEntryCol = new ArrayList();</span>
<span class="nc bnc" id="L2596" title="All 2 branches missed.">			for (Iterator i = rawTimeEntriesCopy.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2597">					RawTimeEntry rawTimeEntry = (RawTimeEntry)i.next();</span>
					//-------------------------------------------------------------------
					//  if RawTimeEntry.ID stop TimeRecordEntry update and log error
					//-------------------------------------------------------------------
<span class="nc bnc" id="L2601" title="All 2 branches missed.">					if (rawTimeEntry.getID() == null) {</span>
<span class="nc" id="L2602">						m_cat.l7dError( AmEjbLogBundleKey.TIMECOLLECTOR_TIMERECORDENTRY_UPDATE_FAILURE,</span>
								new Object[] {rawTimeEntry} );
<span class="nc bnc" id="L2604" title="All 2 branches missed.">					} else if (!updateErrors.contains(rawTimeEntry.getID())) {</span>
<span class="nc" id="L2605">						int isPaid = getIsPaidForActivity(rawTimeEntry.getActivityID());</span>

						//-----------------------------------------------------------------
						// create new TimeRecordEntry. Only the activityID, isPaid and RawTimeEntryID are importent here
						//-----------------------------------------------------------------
<span class="nc" id="L2610">						TimeRecordEntry timeRecordEntry = null;</span>
<span class="nc bnc" id="L2611" title="All 2 branches missed.">						if (NeedRawEntry) {</span>
<span class="nc" id="L2612">							timeRecordEntry	= new TimeRecordEntry(  null,</span>
<span class="nc" id="L2613">											rawTimeEntry.getID(),</span>
<span class="nc" id="L2614">											rawTimeEntry.getActivityID(),</span>
<span class="nc" id="L2615">											rawTimeEntry.getDataSourceId(),</span>
											null,
											null,
											null,
											TimeEntrySourceCode.RAWPUNCH,
<span class="nc" id="L2620">											isPaid(isPaid),</span>
											null);
						} else {
							// If there is no raw timeentry, then the ID from RawTimeEntry is TimeRecordEntry ID
<span class="nc" id="L2624">							timeRecordEntry	= new TimeRecordEntry( rawTimeEntry.getId(),</span>
											null,
<span class="nc" id="L2626">											rawTimeEntry.getActivityID(),</span>
<span class="nc" id="L2627">											rawTimeEntry.getDataSourceId(),</span>
											null,
											null,
											null,
											TimeEntrySourceCode.RAWPUNCH,
<span class="nc" id="L2632">											isPaid(isPaid),</span>
											null);
						}
<span class="nc" id="L2635">						timeRecordEntry.setEmployeeID(rawTimeEntry.getEmployeeID());</span>
						//-----------------------------------------------------------------
						// now we can update the TimeRecordEntry
						//-----------------------------------------------------------------
<span class="nc" id="L2639">						recordEntryCol.add(timeRecordEntry);</span>

					}
<span class="nc" id="L2642">				m_timeRecordManager.quickUpdateTimeRecordEntry(recordEntryCol);</span>
<span class="nc" id="L2643">			}</span>
<span class="nc" id="L2644">			return updateErrors;</span>
<span class="nc" id="L2645">		} catch(Exception e) {</span>
<span class="nc" id="L2646">			handleException(e);</span>
<span class="nc" id="L2647">			throw new AmException(e);</span>
		} finally {
<span class="nc" id="L2649">			methodFinish();</span>
		}
	}

	/**
	 * &lt;B&gt;findCurrentTimeRecordId&lt;/B&gt;
	 *
	 *  Find the current TimeRecord ID for this employee
	 *  looks for last entry (from cache, or DB)
	 *  IF not END_SHIFT (after apply auto close/merge rules)
	 *   	returns its TimeRecord ID
	 *
	 * @param employeeID
	 * @param punchDate
	 * @param doNotAutoClose
	 * @return Object (TimeRecordID, MergeNeeded, StartTime, ID, RTEID)
	 * @throws JdmoException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Object[] findCurrentTimeRecordID(ID employeeID, TimeRecordEntry lastEvent, Date punchDate, boolean doNotAutoClose, boolean doNotAutoMerge) throws JdmoException, BbmFinderException, RemoteException {
<span class="fc" id="L2670">		Object[] result = new Object[7];</span>
<span class="fc" id="L2671">		result[1]= Boolean.FALSE;</span>
<span class="fc" id="L2672">		ID foundTimeRecordID = null;</span>
<span class="fc" id="L2673">		ID foundEventID = null;</span>
<span class="fc" id="L2674">		ID foundEventActivityID = null;</span>
<span class="fc" id="L2675">		long foundEventTimestamp = 0;</span>
<span class="pc bpc" id="L2676" title="1 of 2 branches missed.">		long punchTime = (punchDate==null)?System.currentTimeMillis():punchDate.getTime();</span>
<span class="fc bfc" id="L2677" title="All 2 branches covered.">		if (lastEvent != null) {</span>
<span class="fc" id="L2678">			result[2] = lastEvent.getSortTime();</span>
<span class="fc" id="L2679">			result[3] = lastEvent.getID();</span>
<span class="fc" id="L2680">			result[4] = lastEvent.getRawTimeEntryID();</span>
<span class="fc" id="L2681">			result[5] = lastEvent.getActivityID();</span>
<span class="fc" id="L2682">			result[6] = NumberFactory.newInteger(lastEvent.getTimeSourceCode());</span>
			// If find cached object, handle it and return
<span class="pc bpc" id="L2684" title="1 of 2 branches missed.">			if (lastEvent.getSortTime() != null) {</span>
<span class="fc" id="L2685">				foundTimeRecordID = lastEvent.getTimeRecordID();</span>
<span class="fc" id="L2686">				foundEventID = lastEvent.getID();</span>
<span class="fc" id="L2687">				foundEventActivityID = lastEvent.getActivityID();</span>
<span class="fc" id="L2688">				foundEventTimestamp = lastEvent.getSortTime().getTime();</span>
				// handle merge or auto close
<span class="fc" id="L2690">				Pair pair = handleMergeAndClose(employeeID, foundTimeRecordID, foundEventID, foundEventActivityID, punchTime, foundEventTimestamp, doNotAutoClose, doNotAutoMerge);</span>
<span class="fc" id="L2691">				result[0] = pair.getFirst();</span>
<span class="fc" id="L2692">				result[1] = pair.getSecond();</span>
			}
		}
<span class="fc" id="L2695">		return result;</span>
	}

	/**
	 * Util function to auto merge/close entries based on the configured rules
	 * @param employeeID
	 * @param foundTimeRecordID
	 * @param eventID
	 * @param activityID
	 * @param punchTime
	 * @param lastEventTime
	 * @param doNotAutoClose
	 * @return [TimeRecordID, needMerge]
	 * @throws JdmoException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Pair handleMergeAndClose(ID employeeID, ID foundTimeRecordID, ID eventID, ID activityID, long punchTime, long lastEventTime, boolean doNotAutoClose, boolean doNotAutoMerge) throws JdmoException, BbmFinderException, RemoteException
	{
<span class="fc" id="L2714">		Pair pair = new Pair(foundTimeRecordID, Boolean.FALSE);</span>
<span class="fc" id="L2715">		boolean needMerge = false;</span>
		// Check the gap between last Entry and punchTime
<span class="fc" id="L2717">		long minutesSinceLastActivityChange =  Math.abs(punchTime - lastEventTime);</span>
		// if last Event is EndShift consider AutoMerge, else consider AutoClose
<span class="pc bpc" id="L2719" title="1 of 2 branches missed.">		if (activityID.equals(Activity.ACTIVITY_NONE)) {			</span>
<span class="nc bnc" id="L2720" title="All 4 branches missed.">			if (PerformAutoMerge &amp;&amp; (minutesSinceLastActivityChange &lt;= AutoMergeTimeoutInMillis)) {</span>
<span class="nc bnc" id="L2721" title="All 4 branches missed.">				if (NeedRawEntry &amp;&amp; !doNotAutoMerge)</span>
<span class="nc" id="L2722">					TimeCollectorDAO.updateRawTimeEntryForMerge(eventID);</span>
<span class="nc" id="L2723">				needMerge = true;</span>
			}
<span class="nc bnc" id="L2725" title="All 2 branches missed.">			if (!needMerge) {</span>
<span class="nc" id="L2726">				foundTimeRecordID = null;</span>
			}
		} else {
<span class="pc bpc" id="L2729" title="1 of 4 branches missed.">			if (!doNotAutoClose &amp;&amp; PerformAutoClose &amp;&amp;</span>
				(minutesSinceLastActivityChange &gt;= AutoCloseTimeoutInMillis)) {
				//---------------------------------------------------------
				//  AUTO CLOSE, don't use timerecordid
				//---------------------------------------------------------
<span class="nc" id="L2734">				autocloseShift(employeeID, foundTimeRecordID, punchTime, lastEventTime);</span>
<span class="nc" id="L2735">				foundTimeRecordID = null;</span>
			}
		}
<span class="fc" id="L2738">		pair.setFirst(foundTimeRecordID);</span>
<span class="fc" id="L2739">		pair.setSecond(new Boolean(needMerge));</span>
<span class="fc" id="L2740">		return pair;</span>
	}

	/**
	 * &lt;B&gt;autocloseShift&lt;/B&gt;
	 *
	 *  Auto-Close an open time record. Will not throw in case of an error.
	 *
	 *  @param employeeId employee id
	 *  @param timeRecordId timerecord id
	 *  @param newEventTimeMilli the new event, that generated the auto close, time in milliseconds
	 *  @param lastEventTimeMilli the last recorded event in milliseconds
	 */
	private void autocloseShift(ID employeeId, ID timeRecordId, long newEventTimeMilli, long lastEventTimeMilli) {
		// determine the auto close time
<span class="nc" id="L2755">		Date autoCloseDate = new Date(lastEventTimeMilli + MINUTE);</span>
		// Create the raw time entry
<span class="nc" id="L2757">		RawTimeEntry rawTimeEntry = new RawTimeEntry(employeeId, Activity.ACTIVITY_NONE,</span>
									timeRecordId, null,	RawTimeEntry.AUTOCLOSE_END_SHIFT, autoCloseDate);
<span class="nc" id="L2759">		rawTimeEntry.setTimeSourceCode(TimeEntrySourceCode.AUTO_CLOSE);</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">		if (NeedRawEntry) {</span>
			try {
<span class="nc" id="L2762">				ID newId = TimeCollectorDAO.createRawTimeEntry(rawTimeEntry);</span>
<span class="nc" id="L2763">				rawTimeEntry.setId(newId);</span>
<span class="nc" id="L2764">			} catch(JdmoException e) {</span>
				// if failed to auto-close, simply log on info level and not throw. Sometimes, there will be duplicate key exception
				// in RawTimeEntry table since we are basically giving an arbitrary time for end of shift.
<span class="nc" id="L2767">				m_cat.l7dInfo(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_AUTO_CLOSE, new Object[] {rawTimeEntry}, e);</span>
<span class="nc" id="L2768">				return;</span>
<span class="nc" id="L2769">			}</span>
		}
		// Handle TimeRecordEntry
		try {
			// Create TimeEntryEvent
<span class="nc" id="L2774">			TimeRecordEntry entry = convertRawTimeEntry(rawTimeEntry, timeRecordId, employeeId, null, false);</span>
<span class="nc" id="L2775">			m_timeRecordManager.createTimeRecordEntry(timeRecordId, entry, false);</span>
			// Create AuditTrailEntry
<span class="nc" id="L2777">			EmployeeName empName = m_workResourceManager.getEmployeeNameByID(employeeId);</span>
<span class="nc" id="L2778">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD, AuditTrailEntry.ACTION_DELETE_OBJECT, employeeId, empName.getDisplayName(DefaultLocalizationManager.getDefaultInstance().getLocalizer()), autoCloseDate, new Date(newEventTimeMilli));</span>
<span class="nc" id="L2779">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>
<span class="nc" id="L2780">			m_auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L2781">		} catch(Exception e) {</span>
<span class="nc" id="L2782">			m_cat.l7dInfo(AmEjbLogBundleKey.TIMECOLLECTOR_FAILURE_AUTO_CLOSE, new Object[] {rawTimeEntry}, e);</span>
<span class="nc" id="L2783">			return;</span>
<span class="nc" id="L2784">		}</span>
<span class="nc" id="L2785">	}</span>

	/**
	 * &lt;B&gt;createNewTimeRecord&lt;/B&gt;
	 *
	 * creates a TimeRecord for the given employee id
	 * &lt;P&gt;
	 *  @param employeeID   ID of employee to create time record for
	 * &lt;P&gt;
	 *  @return            TimeRecord
	 *
	 */
	private TimeRecord createNewTimeRecord(ID employeeID) {
<span class="fc" id="L2798">		TimeRecord timeRecord = null;</span>
		try {
<span class="fc" id="L2800">			timeRecord = new TimeRecord(employeeID);</span>
<span class="fc" id="L2801">			timeRecord.setID(m_timeRecordManager.createTimeRecord(timeRecord));</span>
<span class="nc" id="L2802">		} catch (Exception e) {</span>
<span class="nc" id="L2803">			m_cat.l7dError( AmEjbLogBundleKey.TIMECOLLECTOR_TIMERECORD_CREATE_FAILURE,</span>
					new Object[] {employeeID},e );
<span class="fc" id="L2805">		}</span>
<span class="fc" id="L2806">		return timeRecord;</span>
	}

	/**
	 * &lt;B&gt;getIsPaidForActivity&lt;/B&gt;
	 * &lt;P&gt;
	 * is isPaid value from given activity id
	 *
	 *  @param activityID    id of activity to look up
	 *  &lt;P&gt;
	 *  @return      short, 0 is not paid, 1 is paid, -1 cannot find, -2 inactive paid, -3 inactive unpaid
	 */
	private int getIsPaidForActivity(ID activityID) {
		// if activity is cached, then just go activity manager for latest activity object
<span class="pc bpc" id="L2820" title="1 of 2 branches missed.">		if (ActivityCached) {</span>
			try {
<span class="fc" id="L2822">				Activity activity = m_activityManager.findActivityById(activityID);</span>
<span class="fc bfc" id="L2823" title="All 2 branches covered.">				int isPaid = activity.isPaid()?PAID_ACTIVE:UNPAID_ACTIVE;</span>
<span class="pc bpc" id="L2824" title="1 of 2 branches missed.">				isPaid = activity.isDeleted()?isPaid-3:isPaid;</span>
<span class="pc bpc" id="L2825" title="1 of 2 branches missed.">				if (ActivitiesIsPaidCacheTable != null)</span>
<span class="nc" id="L2826">					ActivitiesIsPaidCacheTable.put(activity.getID(), NumberFactory.newInteger(isPaid));</span>
<span class="fc" id="L2827">				return isPaid;</span>
<span class="nc" id="L2828">			} catch (Exception e) {</span>
<span class="nc" id="L2829">				m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_ACTIVITY_CACHE_ERROR,e);</span>
<span class="nc" id="L2830">				return -1;</span>
			}
		}
		//---------------------------------------------------
		//  first determine if we need to refesh cache
		//---------------------------------------------------
<span class="nc bnc" id="L2836" title="All 2 branches missed.">		if ( (ActivitiesIsPaidCacheTable == null) ||</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">			 (ActivitedIsPaidChecked+ACTIVITIES_ISPAID_TIMEOUT &lt; System.currentTimeMillis()) ) {</span>
<span class="nc" id="L2838">			refreshActivitesIsPaidCache();</span>
		}
<span class="nc bnc" id="L2840" title="All 4 branches missed.">		if (activityID != null &amp;&amp; ActivitiesIsPaidCacheTable != null) {</span>
<span class="nc" id="L2841">			Integer isPaidObj = (Integer)ActivitiesIsPaidCacheTable.get(activityID);</span>
<span class="nc bnc" id="L2842" title="All 2 branches missed.">			if(isPaidObj != null) {</span>
<span class="nc" id="L2843">				return isPaidObj.intValue();</span>
			}
		}
<span class="nc" id="L2846">		return -1;</span>
	}

	/**
	 * &lt;B&gt;refreshActivitesIsPaidCache&lt;/B&gt;
	 * &lt;P&gt;
	 * time dependent cache of activities id/ispaid for TimeCollectorEJB only
	 * &lt;P&gt;
	 *
	 */
	private void refreshActivitesIsPaidCache() {
		//---------------------------------------------------
		//  first determine if we need to check database
		//---------------------------------------------------
		try {
<span class="nc" id="L2861">			ActivityFilter activityFilter = new ActivityFilter(ActivityFilter.FILTER_NONE);</span>
<span class="nc" id="L2862">			Collection activities = m_activityManager.findActivities(activityFilter);</span>

			//---------------------------------------------------
			//  timeout of current check
			//---------------------------------------------------
<span class="nc" id="L2867">			ActivitedIsPaidChecked = System.currentTimeMillis();</span>

<span class="nc" id="L2869">			ActivitiesIsPaidCacheTable = new Hashtable(activities.size());</span>
<span class="nc bnc" id="L2870" title="All 2 branches missed.">			for (Iterator i = activities.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2871">				Activity activity = (Activity)i.next();</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">				int isPaid = activity.isPaid()?PAID_ACTIVE:UNPAID_ACTIVE;</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">				isPaid = activity.isDeleted()?isPaid-3:isPaid;</span>
<span class="nc" id="L2874">				ActivitiesIsPaidCacheTable.put(activity.getID(), NumberFactory.newInteger(isPaid));</span>
<span class="nc" id="L2875">			}</span>
<span class="nc" id="L2876">		} catch (Exception e) {</span>
<span class="nc" id="L2877">			m_cat.l7dError(AmEjbLogBundleKey.TIMECOLLECTOR_ACTIVITY_CACHE_ERROR,e);</span>
<span class="nc" id="L2878">		}</span>
<span class="nc" id="L2879">	}</span>

	/**
	 * &lt;B&gt;setTimeRecordID&lt;/B&gt;
	 * &lt;P&gt;
	 *  sets each RatTimeEntry's TimeRecord id to given id
	 *
	 *  @param rawTimeEntries      Collection of raw time data to be updated
	 *  @param timeRecordID      TimeRecordID
	 * &lt;P&gt;
	 *
	 */
	private void setTimeRecordID(Collection rawTimeEntries, ID timeRecordID) {
		//---------------------------------------------------------------------
		//  update TimeRecord ID each of the RawTimeEntry value objects
		//---------------------------------------------------------------------
<span class="nc bnc" id="L2895" title="All 2 branches missed.">		for (Iterator i = rawTimeEntries.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2896">			RawTimeEntry rawTimeEntry = (RawTimeEntry)i.next();</span>
<span class="nc" id="L2897">			rawTimeEntry.setTimeRecordID(timeRecordID);</span>
<span class="nc" id="L2898">		}</span>
<span class="nc" id="L2899">	}</span>

	private boolean isPaid(ID activityID) {
<span class="nc" id="L2902">		return isPaid(getIsPaidForActivity(activityID));</span>
	}

	private static boolean isPaid(int flag) {
<span class="pc bpc" id="L2906" title="1 of 3 branches missed.">		switch(flag) {</span>
			case UNPAID_ACTIVE:
			case UNPAID_INACTIVE:
<span class="fc" id="L2909">				return false;</span>
			case PAID_ACTIVE:
			case PAID_INACTIVE:
<span class="fc" id="L2912">				return true;</span>
			default:
<span class="nc" id="L2914">				return false;</span>
		}
	}

	private static TimeRecordEntry convertHAATimeEntry(RawTimeEntry rawTimeEntry, ID timeRecordID, ID employeeID, ID remarkerID, boolean isPaid) {
<span class="nc" id="L2919">		TimeRecordEntry tre = convertRawTimeEntry(rawTimeEntry, timeRecordID, employeeID, remarkerID, isPaid);</span>
<span class="nc" id="L2920">		return tre;</span>
	}

	private static TimeRecordEntry convertRawTimeEntry(RawTimeEntry rawTimeEntry, ID timeRecordID, ID employeeID, ID remarkerID, boolean isPaid) {
		//----------------------------------------------
		// create a TimeRecordEntry (TimeEntryEvent)
		//----------------------------------------------
<span class="fc" id="L2927">		TimeRecordEntry timeRecordEntry	= new TimeRecordEntry(null,</span>
<span class="fc" id="L2928">											rawTimeEntry.getID(),</span>
<span class="fc" id="L2929">											rawTimeEntry.getActivityID(),</span>
<span class="fc" id="L2930">											rawTimeEntry.getDataSourceId(),</span>
<span class="fc" id="L2931">											rawTimeEntry.getStartTime(),</span>
											null,
<span class="fc" id="L2933">											rawTimeEntry.getSortTime(),</span>
<span class="fc" id="L2934">											rawTimeEntry.getTimeSourceCode(),</span>
											isPaid,
<span class="fc" id="L2936">											rawTimeEntry.getRemark());</span>
<span class="fc" id="L2937">		timeRecordEntry.setParentID(timeRecordID);</span>
<span class="fc" id="L2938">		timeRecordEntry.setEmployeeID(employeeID);</span>
<span class="fc" id="L2939">		timeRecordEntry.setRemarkerID(remarkerID);</span>
<span class="fc" id="L2940">		return timeRecordEntry;</span>
	}

	private static Collection getEmployeeIDs(Collection entries) {
<span class="nc" id="L2944">		HashSet empSet = new HashSet(100);</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">		for (Iterator it = entries.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2946">			EmployeeEvent event = (EmployeeEvent)it.next();</span>
<span class="nc" id="L2947">			empSet.add(event.getEmployeeID());</span>
<span class="nc" id="L2948">		}</span>
<span class="nc" id="L2949">		return empSet;</span>
	}

	private static void setBPConfigDefaults() {
<span class="nc" id="L2953">		CreateTimeRecords = true;</span>
<span class="nc" id="L2954">		PerformAutoMerge = true;</span>
<span class="nc" id="L2955">		AutoCloseTimeoutInMillis = 600 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L2956">		AutoMergeTimeoutInMillis = 120 * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L2957">	}</span>
	
	private static RawTimeEntry addEL(Collection elCol, RawTimeEntry elEntry, TimeRecordEntry lastTRE) {
<span class="nc bnc" id="L2960" title="All 4 branches missed.">		if (elEntry.getActivityID().equals(GLENDS) &amp;&amp; lastTRE != null) {</span>
<span class="nc" id="L2961">			elEntry.setActivityId(lastTRE.getActivityID());</span>
<span class="nc" id="L2962">			elEntry.setTimeSourceCode( lastTRE.getTimeSourceCode() );</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2964">				m_cat.debug(&quot;Replaced EL Ends with last TRE &quot;+elEntry+&quot; with last TRE &quot;+lastTRE);</span>
			}
		}
<span class="nc" id="L2967">		elCol.add(elEntry);</span>
<span class="nc" id="L2968">		return null;</span>
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>