<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarEventsValidationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.swap.request.validation</a> &gt; <span class="el_source">CalendarEventsValidationRule.java</span></div><h1>CalendarEventsValidationRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.swap.request.validation;

import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodImpl;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.util.RmUtil;


//calendar events like unavailability
//check for calendar events, which can not overlap with a shift employee is getting in the swap.

/**
 * &lt;p&gt; Rule from UI: Swapped shifts will not overlap scheduled calendar events (this includes
 * time off(paid, unpaid vacation etc) and calendar events (like meetings and training) ).
 *
 * &lt;p&gt;
 * For each employee ensures that:
 * &lt;li&gt; No MAY_OVERLAP calendar and time off events lose their overlap after the swapped in shift is received.
 * &lt;li&gt; No unavailabilites overlap the shift assignment being received as part of the swap (any
 * overlapping unavailabilites are deleted when the SSReq is approved).
 *
 * &lt;p&gt;
 * Equally applies for tentative and non tentative requests as only the published schedule
 * is used.
 * 
 * &lt;p&gt; calendar event assignments in the system are stored in the CalendarEventAssignment DB table.  
 * The eventType column defines the type of Calendar Event:
 * &lt;li&gt; TimeOff: Represented by {@link com.bluepumpkin.ejb.bbm.activity.model.Event#EVENT_TYPE_TIME_OFF EVENT_TYPE_TIME_OFF}
 * &lt;li&gt; Unavailability: Represented by {@link com.bluepumpkin.ejb.bbm.activity.model.Event#EVENT_TYPE_UNAVAILABILITY EVENT_TYPE_UNAVAILABILITY }
 * &lt;li&gt; Calendar Event: Represented by {@link com.bluepumpkin.ejb.bbm.activity.model.Event#EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT  }
 *
 * &lt;p&gt; Calendar event assignments also have an overlap attribute:
 * &lt;li&gt; {@link com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate#OVERLAP_TYPE_MUST_OVERLAP_SHIFT OVERLAP_TYPE_MUST_OVERLAP_SHIFT}
 * &lt;li&gt; {@link com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate#OVERLAP_TYPE_MAY_OVERLAP_SHIFT OVERLAP_TYPE_MAY_OVERLAP_SHIFT}
 *
 */
public class CalendarEventsValidationRule implements Validator
{
<span class="nc" id="L59">    private static final String m_className = CalendarEventsValidationRule.class.getName();</span>

    // category for logging.
<span class="nc" id="L62">    private static final Category m_cat = Log.initCategory(m_className);</span>

<span class="nc" id="L64">    public CalendarEventsValidationRule() {</span>
<span class="nc" id="L65">    }</span>

    public ValidationResult validate(Validatable validatable) throws Exception  {
<span class="nc" id="L68">        ShiftSwapRequest ssr = (ShiftSwapRequest) validatable;</span>
<span class="nc" id="L69">        String methodName = &quot;validate&quot;;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) m_cat.debug(RmUtil.dumpEnterMethod(methodName, ssr));</span>

        // ssitems is an ordered list item(0) ... item(N-1)
        // item(A) gives its shift to item((A+1)modN)
        // item(A) receives its new shift from item((A+N-1)modN)
      
<span class="nc" id="L76">        List ssItems = ssr.getShiftSwapItems();</span>
<span class="nc" id="L77">        int itemsSize = ssItems.size();</span>
        
<span class="nc" id="L79">        ValidationResult result = null;</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">        for (int i = 0; i &lt; itemsSize; i++) {</span>
            // shift assignment this employee is exporting.
<span class="nc" id="L82">            ShiftSwapItem itemOut = (ShiftSwapItem) ssItems.get(i);</span>

            // shift assignment this employee is importing.
<span class="nc" id="L85">            int inIndex = ( i - 1 + itemsSize ) % itemsSize;</span>
<span class="nc" id="L86">            ShiftSwapItem itemIn = (ShiftSwapItem) ssItems.get(inIndex);</span>
    
<span class="nc" id="L88">            ValidationResult tempResult = null;</span>
            // if received item is of type 'shift'
            //if ( itemIn.isSwapTypeShift() ) {
				//if (pubEvtsOverlappingItemIn != null &amp;&amp; !pubEvtsOverlappingItemIn.isEmpty()) {
<span class="nc" id="L92">                    tempResult = checkMayOverlapCalAndTO_EvtsForReceivedShift(ssr, itemIn, itemOut);</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">					result = (tempResult != null)?tempResult:result;</span>

                    // verify if any unavailabilities overlap.
<span class="nc" id="L96">                    tempResult = checkPubUnavailsDuringShiftReceived(ssr, itemIn, itemOut);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">					result = (tempResult != null)?tempResult:result;</span>
				//}
            //}
        }

<span class="nc bnc" id="L102" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) m_cat.debug(RmUtil.dumpExitMethod(methodName, result));</span>
        
<span class="nc" id="L104">        return result;</span>
    }

     /**
     * No MAY_OVERLAP calendar and time off events lose their overlap after the swapped in shift is received.
     *
     * @param validatbale
     * @param employeeId
     * @param itemIn
     * @param sam
     * @throws Exception
     */
    private ValidationResult checkMayOverlapCalAndTO_EvtsForReceivedShift(ShiftSwapRequest ssr,
            ShiftSwapItem itemIn, ShiftSwapItem itemOut) throws Exception {
        
<span class="nc" id="L119">    	ValidationResult result = null;</span>
    	
<span class="nc" id="L121">    	ShiftAssignment[] SAsOnReceivedShiftOrgDay = ssr.getCache().getSwappedSAForReqWithStartDateOnSameOrgDay(true, null);</span>

<span class="nc" id="L123">		ShiftAssignment[] SAsForExportedShift = ssr.getCache().getShiftAssignsForReqAligned(true, null);</span>

		// check ssItem1 received by emp2.            
<span class="nc" id="L126">		ShiftAssignment SAOnReceivedShiftOrgDayForEmp2 = SAsOnReceivedShiftOrgDay[0];</span>
<span class="nc" id="L127">		ShiftAssignment SAForExportedShiftForEmp2 = SAsForExportedShift[1];</span>
           
<span class="nc" id="L129">		ShiftSwapValidationCache vc = ssr.getCache();</span>
		
		// if shift exists on received shift's org day
<span class="nc bnc" id="L132" title="All 4 branches missed.">		if (SAOnReceivedShiftOrgDayForEmp2 != null &amp;&amp; SAForExportedShiftForEmp2 != null) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">			if ( SAForExportedShiftForEmp2.equals(SAOnReceivedShiftOrgDayForEmp2) ) {</span>
				
				//Swap 2 shift on the same Org Day for 2 employee 
				//    ssItemOut, empID1                    
				//  ===================                  
				//         |  ^                            
				//         |  |                            
				//         |  |                            
				//         V  |                            
				//  ====================                 
				//    ssItemIn, empID2
				// 
				// Validation Rule :
				//		Get all Event for empID1. 
				// 		Validate one by one to verify if the event overlap with the shift pickup from empID2 (ssItemIn) 
				// 		after doing the swap.
				//
				
<span class="nc" id="L151">				Date itemOutStart = itemOut.getStartDate();</span>
<span class="nc" id="L152">				Date itemOutEnd = itemOut.getEndDate();</span>
<span class="nc" id="L153">		        Date itemInStart = itemIn.getStartDate();</span>
<span class="nc" id="L154">		        Date itemInEnd = itemIn.getEndDate();</span>

<span class="nc" id="L156">				ID empID = itemOut.getEmployeeID();</span>
<span class="nc" id="L157">		    	Collection pubEvtsOverlappingItemIn = ssr.getCache().getEventsDuringPeriod(itemOut.getEmployeeID(), </span>
		    			itemInStart, itemInEnd, 
		            Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT | Event.EVENT_TYPE_TIME_OFF,
		            true);
<span class="nc" id="L161">		    	Collection pubEvtsOverlappingItemout = ssr.getCache().getEventsDuringPeriod(itemOut.getEmployeeID(), </span>
						itemOutStart, itemOutEnd, 
		            Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT | Event.EVENT_TYPE_TIME_OFF,
		            true);
<span class="nc" id="L165">		    	pubEvtsOverlappingItemIn.addAll(pubEvtsOverlappingItemout); // take all events of employee of item2 which occur during the periods of both shifts</span>

<span class="nc bnc" id="L167" title="All 4 branches missed.">		    	if (pubEvtsOverlappingItemIn == null || pubEvtsOverlappingItemIn.isEmpty()) {</span>
<span class="nc" id="L168">		    		return null;</span>
		    	}

			        // For each calendar event
<span class="nc bnc" id="L172" title="All 2 branches missed.">		        for (Iterator it = pubEvtsOverlappingItemIn.iterator(); it.hasNext();) {</span>
		            // CalendarEventAssignment is the base class for TOEvents and CalendarEvents.
<span class="nc" id="L174">		            CalendarEventAssignment calEventAssnDuringItemOut = (CalendarEventAssignment) it.next();</span>
					// process only calendar events and time off events.
<span class="nc bnc" id="L176" title="All 2 branches missed.">		            if (calEventAssnDuringItemOut == null) continue;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">		            if (calEventAssnDuringItemOut.getEventType() != Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT &amp;&amp;</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">			            		calEventAssnDuringItemOut.getEventType() != Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L179">						continue;</span>
					} 

		            // only CalenderEvents (and not TOEvents) support 'overlap type' attribute.
		            //
		            // if event is a calendar event (and not a time off event).
<span class="nc bnc" id="L185" title="All 2 branches missed.">		            if (calEventAssnDuringItemOut.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT ) {</span>
<span class="nc" id="L186">		                CalendarEvent calEvent = (CalendarEvent) calEventAssnDuringItemOut;</span>
		                // if event is a MUST_OVERLAP calendar event, then process next event.  MUST_OVERLAP
		                // events are processed in the hard validation rule CalendarEventsHardValidationRule.java.
		                // Shahar - Noticed all calendar events I create are of type OVERLAP_TYPE_MUST_OVERLAP_SHIFT, therefore ignored by this rule. Did not touch this as this wasn't a problem in the ESR I fix.
<span class="nc bnc" id="L190" title="All 2 branches missed.">		                if (calEvent.getOverlapType() == CalendarEventTemplate.OVERLAP_TYPE_MUST_OVERLAP_SHIFT)</span>
<span class="nc" id="L191">		                    continue;</span>
		            }
		            // At this point, event is either a MAY_OVERLAP calendar event, a calendar event with
		            // 'overlap type' == null or a TO Event.
		            //get overlap with other event
<span class="nc" id="L196">		            TimePeriod p1 = new TimePeriodImpl(itemIn.getStartDate(), itemIn.getEndDate());</span>
			            
<span class="nc" id="L198">			        TimePeriod p2 = new TimePeriodImpl(calEventAssnDuringItemOut.getStartTime(), calEventAssnDuringItemOut.getEndTime());</span>
			           
<span class="nc" id="L200">			        TimePeriodUtil.retainOverlappedPeriod(p1, p2);</span>
			        // check whether calendar event assignment overlaps shift being received
			        // if calendar event's start time is during swapped in shift's time.
<span class="nc" id="L203">			        Date calEvtItemInStartTime = calEventAssnDuringItemOut.getStartTime();</span>
<span class="nc" id="L204">		            Date calEvtItemInEndTime = calEventAssnDuringItemOut.getEndTime();</span>
			            
<span class="nc bnc" id="L206" title="All 4 branches missed.">		            if ( (itemIn.isSwapTypeShift() &amp;&amp; (p1.getStartTime().before(itemOutStart) || </span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">		            		p1.getEndTime().after(itemOutEnd))) </span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">		                || !itemIn.isSwapTypeShift() ) {</span>
<span class="nc bnc" id="L209" title="All 2 branches missed.">		                String key = calEventAssnDuringItemOut.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT?</span>
		                		RmEjbBundleKey.SS_CALENDAR_EVENTS_MAY_OVERLAP:RmEjbBundleKey.SS_TIMEOFF_EVENTS_MAY_OVERLAP;
<span class="nc" id="L211">		            	result = failValidation(vc, empID, key, ssr, calEvtItemInStartTime, calEvtItemInEndTime);</span>
		            }
<span class="nc" id="L213">		        }</span>
<span class="nc" id="L214">			}</span>
		}
		//Swap 2 shifts on difference Org Day
		//Or swap shifts for 2 employee on the same Org's Day, but the one of the employees don't have a shift on that day (may have TOEvent, CalendarEvent)
		else {
			
		    //    ssItemOut, empID1                    
			//  ===================                   		- - - - - - - - - - -
			//          |               		                       ^
			//          |       		                               |
			//          |		                                       |
			//          V                                   		   |
			//  - - - - - - - - - -                    		  ====================
			// empID2 : TOEvent/CalEvent w/o shift.              ssItemIn, empID2
			//
			//
			//
			//
			//
			//    ssItemOut, empID1                    
			//  ===================                  
			//          |                            
			//          |                            
			//          |                            
			//          V                            
			//  - - - - - - - - - -
			//  empID2 : TOEvent/CalEvent without shift.
			// Validation Rule:
			// 		Get all Event of empIDs in the same Org Day of ssItemOut
			//		Validate one by one to verify not overlap shift ssItemOut after doing swap
			//		Note: 

<span class="nc" id="L246">			Date itemOutStart = itemOut.getStartDate();</span>
<span class="nc" id="L247">			Date itemOutEnd = itemOut.getEndDate();</span>
			
<span class="nc" id="L249">			ID empID = itemOut.getEmployeeID();</span>
<span class="nc" id="L250">	    	Collection pubEvtsOverlappingItemIn = ssr.getCache().getEventsDuringPeriod(itemIn.getEmployeeID(), </span>
					itemOutStart, itemOutEnd, 
	            Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT | Event.EVENT_TYPE_TIME_OFF,
	            true);
<span class="nc bnc" id="L254" title="All 4 branches missed.">	    	if (pubEvtsOverlappingItemIn == null || pubEvtsOverlappingItemIn.isEmpty())</span>
<span class="nc" id="L255">	    		return null;</span>

	        // For each calendar event
<span class="nc bnc" id="L258" title="All 2 branches missed.">	        for (Iterator it = pubEvtsOverlappingItemIn.iterator(); it.hasNext();) {</span>
	            // CalendarEventAssignment is the base class for TOEvents and CalendarEvents.
<span class="nc" id="L260">	            CalendarEventAssignment calEventAssnDuringItemOut = (CalendarEventAssignment) it.next();</span>

	            // process only calendar events and time off events.
<span class="nc bnc" id="L263" title="All 2 branches missed.">		        if (calEventAssnDuringItemOut == null) continue;</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">	            if (calEventAssnDuringItemOut.getEventType() != Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT &amp;&amp;</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">	            		calEventAssnDuringItemOut.getEventType() != Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L266">					continue;</span>
				} 

	            // only CalenderEvents (and not TOEvents) support 'overlap type' attribute.
		        // if event is a calendar event (and not a time off event).
<span class="nc bnc" id="L271" title="All 2 branches missed.">		        if (calEventAssnDuringItemOut.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT ) {</span>
<span class="nc" id="L272">	                CalendarEvent calEvent = (CalendarEvent) calEventAssnDuringItemOut;</span>
	                // if event is a MUST_OVERLAP calendar event, then process next event.  MUST_OVERLAP
	                // events are processed in the hard validation rule CalendarEventsHardValidationRule.java.
<span class="nc bnc" id="L275" title="All 2 branches missed.">	                if (calEvent.getOverlapType() == CalendarEventTemplate.OVERLAP_TYPE_MUST_OVERLAP_SHIFT)</span>
<span class="nc" id="L276">	                    continue;</span>
<span class="nc" id="L277">	            }</span>
		        // QC58109 do not allow one-way shift swaps that include a time off event
<span class="nc bnc" id="L279" title="All 2 branches missed.">	            else if (calEventAssnDuringItemOut.getEventType() == Event.EVENT_TYPE_TIME_OFF &amp;&amp;</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">	            		ssr.getSwapType().equals(ShiftSwapRequest.SHIFTSWAP_TYPE_ONEWAY)) {</span>
<span class="nc" id="L281">	            	String key = RmEjbBundleKey.SS_TIMEOFF_OVERLAPS_SHIFT;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">	            	Date dtStart = calEventAssnDuringItemOut.getStartTime().after(itemOutStart) ? calEventAssnDuringItemOut.getStartTime(): itemOutStart;</span>
<span class="nc bnc" id="L283" title="All 2 branches missed.">	            	Date dtEnd = calEventAssnDuringItemOut.getEndTime().before(itemOutEnd) ? calEventAssnDuringItemOut.getEndTime(): itemOutEnd;</span>
<span class="nc" id="L284">	            	result = failValidation(vc, itemIn.getEmployeeID(), key, ssr, dtStart, dtEnd);</span>
	            }

	            //get overlap with original event
	            // check whether calendar event assignment overlaps shift being received
	            // if calendar event's start time is during swapped in shift's time.
<span class="nc" id="L290">	            Date calEvtItemInStartTime = calEventAssnDuringItemOut.getStartTime();</span>
<span class="nc" id="L291">	            Date calEvtItemInEndTime = calEventAssnDuringItemOut.getEndTime();</span>
		            
<span class="nc bnc" id="L293" title="All 4 branches missed.">	            if ( (itemOut.isSwapTypeShift() &amp;&amp; (calEvtItemInStartTime.before(itemOutStart) || </span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">	            		calEvtItemInEndTime.after(itemOutEnd))) </span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">	                || !itemIn.isSwapTypeShift() ) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">	                String key = calEventAssnDuringItemOut.getEventType() == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT?</span>
	                		RmEjbBundleKey.SS_CALENDAR_EVENTS_MAY_OVERLAP:RmEjbBundleKey.SS_TIMEOFF_EVENTS_MAY_OVERLAP;
<span class="nc" id="L298">	                result = failValidation(vc, empID, key, ssr, calEvtItemInStartTime, calEvtItemInEndTime);</span>
	            }
<span class="nc" id="L300">	        }</span>
		}
<span class="nc" id="L302">        return result;</span>
    }

    // QC58109 refactor 
    private ValidationResult failValidation(ShiftSwapValidationCache vc, ID empID, String key,
    		ShiftSwapRequest ssr, Date startTime, Date endTime) throws Exception {
<span class="nc" id="L308">        ValidationResult result = null;</span>
        
<span class="nc" id="L310">    	String empName = vc.getEmployeeNameByID(empID);</span>
<span class="nc" id="L311">        result = ValidationUtil.setSoftValidationResult(ssr, key, empName, startTime, endTime, m_className);</span>
        
<span class="nc" id="L313">        return result;</span>
    }

    /**
     * For the given employee ID, verify he/she does not have any 'UNAVAILABLE'
     * calender events during the shift passed.
     *
     * @param employeeId - the ID of the employee who is receiving a shift
     * @param itemIn - the shift to be received
     * @param sam - An instance of ScheduleAccessManager
     * @return A ValidationResult, or null if there were no validation errors.
     */
    private ValidationResult checkPubUnavailsDuringShiftReceived (ShiftSwapRequest ssr, ShiftSwapItem itemOut,
        ShiftSwapItem itemIn) throws Exception {

<span class="nc" id="L328">    	Date itemInStart = itemIn.getStartDate();</span>
<span class="nc" id="L329">		Date itemInEnd = itemIn.getEndDate();</span>
<span class="nc" id="L330">		ID empID = itemOut.getEmployeeID();</span>
<span class="nc" id="L331">    	Collection pubEvtsOverlappingItemIn = ssr.getCache().getEventsDuringPeriod(itemOut.getEmployeeID(), </span>
    			itemInStart, itemInEnd, 
            Event.EVENT_TYPE_UNAVAILABILITY,
            true);
<span class="nc bnc" id="L335" title="All 4 branches missed.">    	if (pubEvtsOverlappingItemIn == null || pubEvtsOverlappingItemIn.isEmpty())</span>
<span class="nc" id="L336">    		return null;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for (Iterator iter = pubEvtsOverlappingItemIn.iterator(); iter.hasNext();) {</span>
			// CalendarEventAssignment is the base class for TOEvents and CalendarEvents.
<span class="nc" id="L339">            CalendarEventAssignment calEventAssn = </span>
<span class="nc" id="L340">            	(CalendarEventAssignment) iter.next();</span>

<span class="nc" id="L342">            ShiftSwapValidationCache ssVC = ssr.getCache();</span>

<span class="nc bnc" id="L344" title="All 2 branches missed.">            String empName = (empID != null)?ssVC.getEmployeeNameByID(empID):&quot;&quot;;</span>

<span class="nc" id="L346">            Date unavailStartTime = calEventAssn.getStartTime();</span>
<span class="nc" id="L347">            Date unavailEndTime = calEventAssn.getEndTime();</span>

<span class="nc" id="L349">            return ValidationUtil.setSoftValidationResult (</span>
                ssr, RmEjbBundleKey.SS_CALENDAR_EVENTS_UNAVAILABILITY, empName,
                unavailStartTime, unavailEndTime, m_className);
        }

<span class="nc" id="L354">        return null;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>