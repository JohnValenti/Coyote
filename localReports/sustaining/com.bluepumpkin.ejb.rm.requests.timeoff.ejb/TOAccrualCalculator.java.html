<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOAccrualCalculator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.ejb</a> &gt; <span class="el_source">TOAccrualCalculator.java</span></div><h1>TOAccrualCalculator.java</h1><pre class="source lang-java linenums">/*
	 * TOAccrualCalculator.java
	 *
	 * Copyright (c) 2008, Verint, Inc.
	 * Sameet Joshi
	 * All rights reserved.
	 */
package com.bluepumpkin.ejb.rm.requests.timeoff.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Filter.Filter;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityCategory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityTimeOffBalance;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffAccruedDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTimeOffYearlyDAO;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.verint.ejb.wfm.WfmManagerFactory;


<span class="nc" id="L54">public class TOAccrualCalculator {</span>
<span class="fc" id="L55">	private static final String m_className = TOAccrualCalculator.class.getName();</span>
<span class="fc" id="L56">	private static Category m_cat = Log.initCategory(m_className);</span>

	public static boolean hasLicenseForAccrual() {
<span class="fc" id="L59">         return true; //Accrual license has been retired. Accrual is always enabled.</span>
	}
	private static Set getActivityIDsForActivityCatID(Map activityMap, ID actCatID) {
<span class="nc" id="L62">		TreeSet activityIDSet = new TreeSet();</span>
<span class="nc bnc" id="L63" title="All 4 branches missed.">		if (activityMap != null &amp;&amp; !activityMap.isEmpty()) {</span>
<span class="nc bnc" id="L64" title="All 2 branches missed.">			for (Iterator iterator = activityMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L65">				Activity activity = (Activity) iterator.next();</span>
<span class="nc bnc" id="L66" title="All 4 branches missed.">				if (activity != null &amp;&amp; activity.getActivityCategoryId().equals(actCatID)) {</span>
<span class="nc" id="L67">					activityIDSet.add(activity.getID());</span>
				}
<span class="nc" id="L69">			}</span>
		}
<span class="nc" id="L71">		return activityIDSet;</span>
	}

	private static TOAccrual validateAndInitData(Jdmo dmo, ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empData) throws Exception {

<span class="fc" id="L76">		TOAccrual toAccrual = null;</span>
<span class="pc bpc" id="L77" title="5 of 8 branches missed.">		if (empID == null || (activityID == null &amp;&amp; actCatID == null) || endDate == null) {</span>
<span class="nc" id="L78">			m_cat.info(&quot;TimeOff Accrual Calc invalid data received empID=&quot; + empID + &quot; , activityID=&quot; + activityID + &quot;;actCatID=&quot; + actCatID + &quot; ;Date=&quot; + endDate);</span>
			//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_INVALID_DATA, m_cat);
<span class="nc" id="L80">			toAccrual = new TOAccrual();</span>
<span class="nc" id="L81">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_INVALID_DATA, null, m_className);</span>
<span class="nc" id="L82">			return toAccrual;</span>
		}
<span class="fc" id="L84">		Organization org = null;</span>
<span class="fc" id="L85">		ActivityTimeOffBalance actTOBal = null;</span>
<span class="fc" id="L86">		Activity activity = null;</span>
<span class="fc" id="L87">		ActivityCategory cat = null;</span>
<span class="fc" id="L88">		int[] empTOYrStArr = null;</span>
<span class="fc" id="L89">		ValidationResult result = null;</span>
<span class="fc" id="L90">		Employee emp = null;</span>
<span class="fc" id="L91">		TreeSet hrsPerDaySet = null;</span>
<span class="fc" id="L92">		HashMap yearlyAllotMapForActOrActCat = null;</span>
<span class="fc" id="L93">		Set activityIDs = new TreeSet();</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">		if (empData != null) {</span>
<span class="nc" id="L95">			emp = (Employee) empData.get(&quot;Employee&quot;);</span>
<span class="nc" id="L96">			org = (Organization) empData.get(&quot;Organization&quot;);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (activityID != null) {</span>
<span class="nc" id="L98">				HashMap orgActivityMap = (HashMap) empData.get(&quot;ActivityMap&quot;);</span>
<span class="nc" id="L99">				activity = (Activity) orgActivityMap.get(activityID);</span>
<span class="nc" id="L100">				activityIDs.add(activityID);</span>
			}
<span class="nc bnc" id="L102" title="All 2 branches missed.">			if (actCatID != null) {</span>
<span class="nc" id="L103">				HashMap actCatMap = (HashMap) empData.get(&quot;ActivityCatMap&quot;);</span>
<span class="nc" id="L104">				cat = (ActivityCategory) actCatMap.get(actCatID);</span>
<span class="nc" id="L105">				activityIDs = getActivityIDsForActivityCatID((HashMap) empData.get(&quot;ActivityMap&quot;), actCatID);</span>
			}
<span class="nc" id="L107">			empTOYrStArr = (int[]) empData.get(&quot;AnniverseryMonthYear&quot;);</span>

<span class="nc" id="L109">			HashMap actTOBalMap = (HashMap) empData.get(&quot;actTOBalMap&quot;);</span>
<span class="nc bnc" id="L110" title="All 2 branches missed.">			if (actTOBalMap != null) {</span>
<span class="nc" id="L111">				actTOBal = (ActivityTimeOffBalance) actTOBalMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
			}
<span class="nc bnc" id="L113" title="All 2 branches missed.">			if (actTOBal == null) {</span>
<span class="nc" id="L114">				actTOBal = ActivityTimeOffBalance.getDefault(empID, activityID, actCatID);</span>
			}
<span class="nc" id="L116">			HashMap yearlyAllotmentMap = (HashMap) empData.get(&quot;yearlyAllotmentMap&quot;);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			if (yearlyAllotmentMap != null) {</span>
<span class="nc" id="L118">				yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				if (yearlyAllotMapForActOrActCat == null) {</span>
<span class="nc" id="L120">					yearlyAllotMapForActOrActCat = new HashMap();</span>
				}
			}
<span class="nc" id="L123">			Collection hrsPerDayCol = (Collection) empData.get(&quot;hrsPerDayCol&quot;);</span>
			//Sameet Nov 2010; changing this implementation to stop Unnecessary Database calls when in fact no HRs Per Day exist.
			//Done for TO REPORTDUMP refactoring.
<span class="nc" id="L126">			hrsPerDaySet = new TreeSet();</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">			if (hrsPerDayCol != null &amp;&amp; !hrsPerDayCol.isEmpty()) {</span>
<span class="nc bnc" id="L128" title="All 2 branches missed.">				for (Iterator iterator = hrsPerDayCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L129">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L130" title="All 4 branches missed.">					if (hoursPerDay != null &amp;&amp; hoursPerDay.getTOEventID() != null) {</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">						if (hrsPerDaySet == null) hrsPerDaySet = new TreeSet();</span>
<span class="nc" id="L132">						hrsPerDaySet.add(hoursPerDay);</span>
					}
<span class="nc" id="L134">				}</span>
			}
<span class="nc" id="L136">		} else {</span>
<span class="fc" id="L137">			ID orgID = ValidationUtil.getOrgIDForEmployeeDuringPeriod(empID, new Date(), endDate);</span>
<span class="fc" id="L138">			org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">			if(emp==null)emp = BbmManagerFactory.getWorkResourceManager().getEmployeeByID(empID, null, 0);</span>
<span class="fc" id="L140">			empTOYrStArr = RequestUtil.getEmployeeTimeOffYearStart(emp, org);</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">			activity = activityID != null ? getActivity(activityID) : null;</span>
<span class="pc bpc" id="L142" title="2 of 4 branches missed.">			if (actCatID == null &amp;&amp; activity != null) {</span>
<span class="fc" id="L143">				actCatID = activity.getActivityCategoryId();</span>
			}
<span class="fc" id="L145">			cat = getActivityCategory(actCatID);</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">			if (cat.isTOAllotment()) {//This activity uses group accrual by activity so set activity  and activityid to null</span>
<span class="nc" id="L147">				activity = null;</span>
<span class="nc" id="L148">				activityID = null;</span>
<span class="nc" id="L149">				activityIDs.addAll(getTOActivityIDs(actCatID));</span>
			} else {
<span class="fc" id="L151">				cat = null;   //need to explicitly set ActivityCategory to null if it does not support accrual by group.</span>
<span class="fc" id="L152">				actCatID = null;</span>
<span class="pc bpc" id="L153" title="1 of 2 branches missed.">				if (activity.isTimeoffWithAllotment()) {</span>
					//Accrual is enabled at activity level
				} else {
					//Accrual is not enabled for this activity
<span class="nc" id="L157">					m_cat.info(&quot;Accrual is not enabled for this activity for empID=&quot; + empID + &quot; ,activityID=&quot; + activityID + &quot; ,orgID=&quot; + orgID);</span>
					//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, m_cat);
<span class="nc" id="L159">					toAccrual = new TOAccrual();</span>
<span class="nc" id="L160">					ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
<span class="nc" id="L161">					return toAccrual;</span>
				}
<span class="fc" id="L163">				activityIDs.add(activityID);</span>
			}
			//Get the EMPLOYEE TIMEOFF ACCRUED &amp; Last update Date
			//Sometimes we will pass the last accrued date &amp; balance. This is used for sending alerts
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">			if (accruedTO == null) {</span>
<span class="fc" id="L168">				accruedTO = getLastUpdatedTOAccrued(dmo, empID, activityID, actCatID, startDate);</span>
			}
			/* not having EmployeeTimeOffAccrued is OK
			if (accruedTO == null) {
				m_cat.info(&quot;Employee TimeOff Accrued is null for empID=&quot; + empID + &quot; , activityID=&quot; + activityID);
				throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUED_NA, m_cat);
			}*/
			//get activity TO Balance
<span class="fc" id="L176">			actTOBal = getActivityTimeOffBalance(empID, activityID, actCatID);</span>
		}
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		if (actTOBal == null) {</span>
			//m_cat.info(&quot;Activity TimeOff Balance is null for empID=&quot; + empID + &quot; ,activityID=&quot; + activityID + &quot; ,orgID=&quot; + orgID);
			//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_ACTIVITY_TO_BAL_NA, m_cat);
<span class="nc" id="L181">			result = ValidationUtil.getValidationResult(RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.TO_ACCRUAL_ACTIVITY_TO_BAL_NA, null, m_className, true);</span>
		}
		//No Activity  Time Off Balance settings exist for this activity / act Cat. &amp; No Last updated balance available.
		//This will enforce the Max Carry Over to 0 and the Hours will be calculated from start of employee's TO Year
<span class="pc bpc" id="L185" title="1 of 4 branches missed.">		if (accruedTO == null &amp;&amp; actTOBal.getID() == null) {</span>
<span class="fc" id="L186">			actTOBal.setMaxCarryOver(0);</span>
		}
		/* moved inside TOAccrual
				if (startDate == null) {
					startDate = adjustStartDate(activity, actTOBal, accruedTO, org, empTOYrStArr, startDate, endDate);
				} else {*/
		//If start date is not null then the request is not for present year. it is only for past.
		//ignore the accrued balance in this case
		/* Since we always query for last updated balance less than start date this will never happen.
		if (accruedTO != null &amp;&amp; accruedTO.getAccruedAtDate().after(startDate)) {
			accruedTO = null;
		}*/
		/*
				if (accruedTO != null) {
				startDate = accruedTO.getAccruedAtDate();
			}
		}*/
		//construct the holder object that will have all TO accrual related info for this period.
<span class="fc" id="L204">		toAccrual = TOAccrual.getTOAccrualRow(emp, activity, cat, actTOBal, accruedTO, empTOYrStArr, empID, org, startDate, endDate);</span>
		/*  Moved to getTOAccruedForGivenDate()because the End Date will change
		    based on available TO Events when Accrual Calc is invoked from Employee Hours Validation rule
		    Sameet Nov 2009 QC 48578
				if (empData == null) {
					HashMap yearlyAllotmentMap = getEmployeeTimeOffYearly(dmo, toAccrual);
					if (yearlyAllotmentMap != null) {
						yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));
					}
					if (yearlyAllotMapForActOrActCat == null) {
						yearlyAllotMapForActOrActCat = new HashMap();
					}
				} */
<span class="pc bpc" id="L217" title="1 of 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L218">			toAccrual.addValidationResult(result);</span>
		} else {
<span class="fc" id="L220">			toAccrual.setHrsPerDaySet(hrsPerDaySet);</span>
<span class="fc" id="L221">			toAccrual.setEmployeeTimeOffYearlyMap(yearlyAllotMapForActOrActCat);</span>
<span class="fc" id="L222">			toAccrual.setActivityIDs(activityIDs);</span>
		}
<span class="fc" id="L224">		return toAccrual;</span>
	}

	//Assumes the activity category passed in has isTOAllotment set to true
	private static Collection getTOActivityIDs(ID activityCategoryID) throws BbmEJBCreateException, RemoteException, BbmFinderException {
<span class="nc" id="L229">		ActivityFilter filter = new ActivityFilter();</span>

		//QC:137557 setting filter.setTimeoffWithAllotment(true) will filter out activities that does not have ISTIMEOFFWITHALLOTMENT set to true
		// but this is not correct since it is set at the activity category level in this specific case 

<span class="nc" id="L234">		filter.setActivityCategoryId(activityCategoryID, Filter.OP_EQUAL);</span>
<span class="nc" id="L235">		return WfmManagerFactory.getActivityManager().findActivitiesIds(filter);</span>
	}


	private static Set&lt;TOHoursPerDay&gt; getSchedOrUsedTOEvents(TOAccrual toAccrual, TOHoursPerDay hoursPerDayTOAdd,
			boolean calcTillLastAvailEvent, Date enDate) throws Exception {
		//boolean printData=toAccrual.getHrsPerDaySet() == null;
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		if (toAccrual.getHrsPerDaySet() != null) {</span>
<span class="nc" id="L243">			return toAccrual.getHrsPerDaySet();</span>
		}
<span class="fc" id="L245">		TreeSet schedOrUsedTOEventSet = new TreeSet();</span>
<span class="fc" id="L246">		TOHoursPerDayManager hoursPerDayManager = RmManagerFactory.getInstance(true).getTOHoursPerDayManager(null, null);</span>
<span class="pc bpc" id="L247" title="3 of 4 branches missed.">		Date endDate = hoursPerDayTOAdd != null || calcTillLastAvailEvent ? RequestUtil.MAX_DATE : toAccrual.endDate;</span>
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if(enDate != null){</span>
<span class="fc" id="L249">            endDate = enDate;</span>
        }
<span class="fc" id="L251">		Collection schedOrUsedTOEvents = hoursPerDayManager.getHoursPerDayForCalendar(Collections.singletonList(toAccrual.getEmployeeID()), toAccrual.startDate, endDate, toAccrual.getActivityIDs(), true);</span>
<span class="fc" id="L252">		schedOrUsedTOEventSet.addAll(schedOrUsedTOEvents);//Hrs Per Day need to be sorted by start time</span>
<span class="pc bpc" id="L253" title="3 of 4 branches missed.">		if (hoursPerDayTOAdd != null || calcTillLastAvailEvent) {</span>
<span class="pc bpc" id="L254" title="2 of 4 branches missed.">			if (schedOrUsedTOEventSet != null &amp;&amp; !schedOrUsedTOEventSet.isEmpty()) {</span>
<span class="nc" id="L255">				TOHoursPerDay hoursPerDay = (TOHoursPerDay) schedOrUsedTOEventSet.last();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">				if (hoursPerDay.getEndTime().after(toAccrual.endDate)) {</span>
<span class="nc" id="L257">					toAccrual.endDate = new Date(hoursPerDay.getEndTime().getTime());</span>
				}
<span class="nc bnc" id="L259" title="All 2 branches missed.">                if(enDate!=null){</span>
<span class="nc" id="L260">                    toAccrual.endDate = new Date(enDate.getTime());</span>
                }
			}
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">			if (hoursPerDayTOAdd != null) {</span>
<span class="fc" id="L264">				schedOrUsedTOEventSet.add(hoursPerDayTOAdd);</span>
			}
		}
		//if(printData)System.out.println(&quot;Returned value=&quot;+schedOrUsedTOEventSet.size() +&quot;: EMPID=&quot;+toAccrual.getEmployeeID()  );
<span class="fc" id="L268">		return schedOrUsedTOEventSet;</span>
	}

	public static TOAccrual getTOAccruedForValidation(Date stDate, TOHoursPerDay hrsPerDaytoVal, Date enDate) {
<span class="fc" id="L272">		Jdmo dmo = null;</span>
<span class="fc" id="L273">		TOAccrual toAccrual = null;</span>
		try {
<span class="fc" id="L275">			dmo = new Jdmo();</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">			toAccrual = validateAndInitData(dmo, hrsPerDaytoVal.getEmployeeID(), hrsPerDaytoVal.getActivityID(), null, stDate,</span>
<span class="fc" id="L277">                    enDate!=null ?enDate:hrsPerDaytoVal.getEndTime(), null, null);</span>
<span class="fc" id="L278">			toAccrual = getTOAccruedForGivenDate(toAccrual, hrsPerDaytoVal, dmo, false, enDate);</span>
<span class="nc" id="L279">		} catch (Exception e) {</span>
<span class="nc" id="L280">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L281">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="pc bpc" id="L283" title="5 of 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
		}
<span class="fc" id="L285">		return toAccrual;</span>
	}

	public static TOAccrual getTOAccruedForBalanceCheck(EmployeeTimeOffAccrued accrued, Date endDate) {
<span class="nc" id="L289">		Jdmo dmo = null;</span>
<span class="nc" id="L290">		TOAccrual toAccrual = null;</span>
		try {
<span class="nc" id="L292">			dmo = new Jdmo();</span>
<span class="nc" id="L293">			toAccrual = validateAndInitData(dmo, accrued.getEmployeeID(), accrued.getActivityID(), accrued.getActivityCategoryId(), null, endDate, accrued, null);</span>
<span class="nc" id="L294">			toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, true, null);</span>
<span class="nc" id="L295">		} catch (Exception e) {</span>
<span class="nc" id="L296">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L297">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="nc bnc" id="L299" title="All 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
		}
		
<span class="nc" id="L302">		return toAccrual;</span>
	}

	public static TOAccrual getTOAccruedForGivenDate(ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empDataMap) {
<span class="nc" id="L306">		Jdmo dmo = null;</span>
<span class="nc" id="L307">		TOAccrual toAccrual = null;</span>
		try {
<span class="nc" id="L309">			dmo = new Jdmo();</span>
<span class="nc" id="L310">			toAccrual = validateAndInitData(dmo, empID, activityID, actCatID, startDate, endDate, accruedTO, empDataMap);</span>
<span class="nc" id="L311">			toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, false, null);</span>
<span class="nc" id="L312">		} catch (Exception e) {</span>
<span class="nc" id="L313">			m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L314">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
		} finally {
<span class="nc bnc" id="L316" title="All 6 branches missed.">			if (dmo != null) dmo.cleanUp();</span>
<span class="nc bnc" id="L317" title="All 12 branches missed.">			if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;TO Accr for empID=&quot; + empID + &quot; for actID=&quot; + activityID + &quot;: actCatID=&quot; + actCatID + &quot;: as Of &quot; + endDate + &quot;: accrhrs=&quot; + (toAccrual != null ? &quot;&quot; + toAccrual.getEstimatedAccrHrs() : &quot;null&quot;));</span>
		}
		
<span class="nc" id="L320">		return toAccrual;</span>
	}

    public static TOAccrual getTOAccrdForGivenDtWthOverlapTOAtStofYr(ID empID, ID activityID, ID actCatID, Date startDate, Date endDate, EmployeeTimeOffAccrued accruedTO, HashMap empDataMap) {
<span class="nc" id="L324">        Jdmo dmo = null;</span>
<span class="nc" id="L325">        TOAccrual toAccrual = null;</span>
        try {
<span class="nc" id="L327">            dmo = new Jdmo();</span>

<span class="nc" id="L329">            Date stDate = new Date(startDate.getTime());</span>
<span class="nc" id="L330">            toAccrual = validateAndInitData(dmo, empID, activityID, actCatID, startDate, endDate, accruedTO, empDataMap);</span>

<span class="nc" id="L332">            toAccrual.setStDateForStartingBalance(stDate);</span>
<span class="nc" id="L333">            toAccrual = getTOAccruedForGivenDate(toAccrual, null, dmo, false, null);</span>
<span class="nc" id="L334">        } catch (Exception e) {</span>
<span class="nc" id="L335">            m_cat.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L336">            ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_NOT_ENABLED, null, m_className);</span>
        } finally {
<span class="nc bnc" id="L338" title="All 6 branches missed.">            if (dmo != null) dmo.cleanUp();</span>
<span class="nc bnc" id="L339" title="All 12 branches missed.">            if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;getTOAccrdForGivenDtWthOverlapTOAtStofYr() method--&gt;TO Accr for empID=&quot; + empID + &quot; for actID=&quot; + activityID + &quot;: actCatID=&quot; + actCatID + &quot;: as Of &quot; + endDate + &quot;: accrhrs=&quot; + (toAccrual != null ? &quot;&quot; + toAccrual.getEstimatedAccrHrs() : &quot;null&quot;));</span>
        }
        
<span class="nc" id="L342">        return toAccrual;</span>
    }

	private static TOAccrual getTOAccruedForGivenDate(TOAccrual toAccrual, TOHoursPerDay hrsPerDaytoVal, Jdmo dmo, boolean calcTillLastAvailEvent, Date enDate) throws Exception {
<span class="fc" id="L346">		Set&lt;TOHoursPerDay&gt; schedOrUsedTOEventSet = getSchedOrUsedTOEvents(toAccrual, hrsPerDaytoVal, calcTillLastAvailEvent, enDate);</span>
		/*End Date will change based on available TO Events when Accrual Calc is invoked from Employee Hours Validation rule
		  Sameet Nov 2009 QC 48578*/
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		if (toAccrual.getEmployeeTimeOffYearlyMap() == null) {</span>
<span class="fc" id="L350">			toAccrual.setEmployeeTimeOffYearlyMap(getEmployeeTimeOffYearly(dmo, toAccrual));</span>
		}
<span class="fc" id="L352">		Calendar startCal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="fc" id="L353">		startCal.setTime(toAccrual.startDate);</span>
<span class="fc" id="L354">		Calendar empTOYearStartCal = RequestUtil.getEmployeeTimeOffYearStart(toAccrual.startDate, toAccrual.org, toAccrual.empTOYrStArr);</span>
		// Get the ending of the time off year (inclusive)
<span class="fc" id="L356">		Calendar empTOYearEndCal = RequestUtil.getEmployeeTimeOffYearEnd(toAccrual.startDate, toAccrual.org, toAccrual.empTOYrStArr);</span>
<span class="fc" id="L357">		Date empTOYearStartDate = empTOYearStartCal.getTime();</span>
<span class="fc" id="L358">		Date empTOYearEndDate = empTOYearEndCal.getTime();</span>
		do {
<span class="pc bpc" id="L360" title="1 of 2 branches missed.">			Date startPeriod = toAccrual.startDate.before(empTOYearStartDate) ? empTOYearStartDate : toAccrual.startDate;</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">			Date endPeriod = toAccrual.endDate.after(empTOYearEndDate) ? empTOYearEndDate : toAccrual.endDate;</span>
<span class="fc" id="L362">			int startYear = toAccrual.getEmployeeTimeOffYear(startPeriod);</span>
<span class="fc" id="L363">			EmployeeTimeOffYearly toYearly = toAccrual.getEmployeeTimeOffYearly(startYear);</span>
<span class="pc bpc" id="L364" title="1 of 4 branches missed.">			if (toYearly == null || toYearly.getAccrualRateForYear() == EmployeeTimeOffYearly.ACCRUAL_RATE_NA) {</span>
				//m_cat.info(&quot;Employee TimeOff Accrual Rate for year is null for &quot; + toAccrual + &quot;, YEAR=&quot; + startYear);
				//Cannot proceed with Accrual calculation when acc
<span class="fc" id="L367">				ValidationUtil.setSoftValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, &quot;&quot; + startYear, m_className);</span>
<span class="fc" id="L368">				return toAccrual;</span>
				//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, m_cat);
			}
<span class="fc" id="L371">			int endYear = toAccrual.getEmployeeTimeOffYear(endPeriod);</span>
<span class="fc" id="L372">			toYearly = toAccrual.getEmployeeTimeOffYearly(endYear);</span>
<span class="pc bpc" id="L373" title="2 of 4 branches missed.">			if (toYearly == null || toYearly.getAccrualRateForYear() == EmployeeTimeOffYearly.ACCRUAL_RATE_NA) {</span>
				//m_cat.info(&quot;Employee TimeOff Accrual Rate for year is null for &quot; + toAccrual + &quot;, YEAR=&quot; + endYear);
				//Cannot proceed with Accrual calculation when acc
<span class="nc" id="L376">				ValidationUtil.setSoftValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, &quot;&quot; + endYear, m_className);</span>
<span class="nc" id="L377">				return toAccrual;</span>
				//throw RequestUtil.createRmException(RmEjbBundleKey.TO_ACCRUAL_EMP_TO_ACCRUAL_RATE_NA, m_cat);
			}

<span class="pc bpc" id="L381" title="5 of 6 branches missed.">			if (toAccrual.actTOBal.getMaxCarryOver() == 0 &amp;&amp; toAccrual.getAccruedTO() != null &amp;&amp; toAccrual.getAccruedTO().getAccruedAtDate().before(startPeriod)) {</span>
<span class="nc" id="L382">				toAccrual.setEstimatedAccrHrs(0);</span>
				//set the estimated hrs to 0 because no carry over is allowed from previous years
			}
<span class="fc" id="L385">			getAccruedHrsWithinYear(dmo, toAccrual, startPeriod, endPeriod, toYearly, schedOrUsedTOEventSet);</span>
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">			if (!endPeriod.equals(toAccrual.endDate)) { //Check for Max balance carry over here</span>
<span class="nc bnc" id="L387" title="All 4 branches missed.">				if (toAccrual.actTOBal != null &amp;&amp; toAccrual.getEstimatedAccrHrs() &gt; toAccrual.actTOBal.getMaxCarryOver()) {</span>
<span class="nc" id="L388">					toAccrual.setEstimatedAccrHrs(toAccrual.actTOBal.getMaxCarryOver());</span>
				}
			}
			// bump to the next year
			//Bug Fix for 40978; [10SP4_TO Accrual] TO Hour is calculated using incorrect Accrual Rate for Year
			//(using Accrual Rate of next year to calculate for current year and so on..)
			//empTOYear++;
			// compute TOYear start and end for next year.
			//empTOYearEndCal.add(Calendar.SECOND,1);
			//empTOYearStartCal = empTOYearEndCal;
			//RequestUtil.getCalendar(empTOYear, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1], toAccrual.org.getTimeZone());
			//empTOYearEndCal = RequestUtil.getCalendarForwardOneYear(empTOYear, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1], toAccrual.org.getTimeZone());
<span class="fc" id="L400">			empTOYearEndCal.add(Calendar.MILLISECOND, 1);</span>
<span class="fc" id="L401">			empTOYearStartDate = empTOYearEndCal.getTime();</span>
			//empTOYear = empTOYearEndCal.get(Calendar.YEAR);
			// QC 144918: Leap Day: First add the year to get the calendar back to March 1st Leap Year,
			// and then subtract the millisecond so February 29th isn't missed.
<span class="fc" id="L405">			empTOYearEndCal.add(Calendar.YEAR, 1);</span>
<span class="fc" id="L406">			empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
<span class="fc" id="L407">			empTOYearEndDate = empTOYearEndCal.getTime();</span>
<span class="pc bpc" id="L408" title="1 of 2 branches missed.">		} while (!toAccrual.endDate.before(empTOYearStartDate));</span>
		//} while (toAccrual.endDate.after(empTOYearStartDate));
		//Bug Fix for 44720; [10SP4_TO Accrual] Accrued hours at start date of TO Year is not correct
/*			return toAccrual;
		} catch (RmException ex) {
			throw ex;*/
<span class="fc" id="L414">		return toAccrual;</span>
	}

	public static HashMap getEmployeeTimeOffYearly(Jdmo dmo, TOAccrual toAccrual) throws Exception {
<span class="fc" id="L418">		HashMap yearlyAllotMapForActOrActCat = null;</span>
<span class="fc" id="L419">		EmployeeTimeOffYearlyDAO dao = new EmployeeTimeOffYearlyDAO(dmo);</span>
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">		ID activityID = toAccrual.getActivity() != null ? toAccrual.getActivity().getID() : null;</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		ID actCatID = toAccrual.getActivityCategory() != null ? toAccrual.getActivityCategory().getID() : null;</span>
<span class="pc bpc" id="L422" title="1 of 2 branches missed.">		Collection actIDs = activityID != null ? Collections.singletonList(activityID) : null;</span>
<span class="pc bpc" id="L423" title="1 of 2 branches missed.">		Collection actCatIDs = actCatID != null ? Collections.singletonList(actCatID) : null;</span>

<span class="fc" id="L425">		Calendar cal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="fc" id="L426">		cal.setTime(toAccrual.startDate);</span>
<span class="fc" id="L427">		int stYear = cal.get(Calendar.YEAR) - 2;</span>
<span class="fc" id="L428">		cal.setTime(toAccrual.endDate);</span>
<span class="fc" id="L429">		int enYear = cal.get(Calendar.YEAR);</span>
<span class="fc" id="L430">		HashMap map = dao.getEmployeeTimeOffYearlyMap(Collections.singletonList(toAccrual.getEmployeeID()), actIDs, actCatIDs, stYear, enYear);</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">		HashMap yearlyAllotmentMap = map != null ? (HashMap) map.get(toAccrual.getEmployeeID()) : null;</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">		if (yearlyAllotmentMap != null) {</span>
<span class="fc" id="L433">			yearlyAllotMapForActOrActCat = (HashMap) yearlyAllotmentMap.get(Activity.getActivity_ActCategoryComb(activityID, actCatID));</span>
		}
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">		if (yearlyAllotMapForActOrActCat == null) {</span>
<span class="nc" id="L436">			yearlyAllotMapForActOrActCat = new HashMap();</span>
		}
<span class="fc" id="L438">		return yearlyAllotMapForActOrActCat;</span>
	}


	public static EmployeeTimeOffAccrued getLastUpdatedTOAccrued(Jdmo dmo, ID empID, ID activityID, ID actCatID, Date startDate) throws Exception {
<span class="fc" id="L443">		EmployeeTimeOffAccruedDAO dao = null;</span>
		try {
<span class="fc bfc" id="L445" title="All 2 branches covered.">			dao = (dmo == null) ? new EmployeeTimeOffAccruedDAO() : new EmployeeTimeOffAccruedDAO(dmo);</span>
<span class="fc" id="L446">			return dao.getLastUpdatedTOAccruedBeforeDate(empID, activityID, actCatID, startDate);</span>
<span class="nc" id="L447">		} catch (Exception e) {</span>
<span class="nc" id="L448">			e.printStackTrace();</span>
<span class="nc" id="L449">			return null;</span>
		} finally {
<span class="pc bpc" id="L451" title="9 of 12 branches missed.">			if (dmo == null &amp;&amp; dao != null) { //Cleanup only if the dmo was /DAO was created here</span>
<span class="pc" id="L452">				dao.cleanUp();</span>
			}
		}
	}

	public static ActivityTimeOffBalance getActivityTimeOffBalance(ID empID, ID activityID, ID actCatID) throws Exception {
<span class="fc" id="L458">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		Collection actIDs = activityID != null ? Collections.singletonList(activityID) : null;</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">		Collection actCatIDs = actCatID != null ? Collections.singletonList(actCatID) : null;</span>
<span class="fc" id="L461">		Collection activityBalCol = activityMgr.getTOBalanceForActivities(Collections.singletonList(empID), actIDs, actCatIDs);</span>
<span class="pc bpc" id="L462" title="2 of 4 branches missed.">		return (activityBalCol != null &amp;&amp; !activityBalCol.isEmpty()</span>
<span class="pc" id="L463">		        ? (ActivityTimeOffBalance) activityBalCol.iterator().next()</span>
<span class="fc" id="L464">		        : ActivityTimeOffBalance.getDefault(empID, activityID, actCatID));</span>
	}

	public static Activity getActivity(ID activityID) throws Exception {

<span class="fc" id="L469">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="fc" id="L470">		return activityMgr.findActivityById(activityID);</span>
	}

	public static ActivityCategory getActivityCategory(ID activityCategoryID) throws Exception {

<span class="fc" id="L475">		ActivityManager activityMgr = WfmManagerFactory.getActivityManager();</span>
<span class="fc" id="L476">		return activityMgr.findActivityCategoryById(activityCategoryID);</span>
	}

	private static double getAccruedHrsWithinYear(Jdmo dmo, TOAccrual toAccrual, Date startDate, Date endDate, EmployeeTimeOffYearly toYearly, Collection schedOrUsedTOEvents) throws Exception {
<span class="fc" id="L480">		double accruedHrsForPeriod = toAccrual.getEstimatedAccrHrs();</span>
<span class="fc" id="L481">		boolean chkAccrualForEachTO = true;//toAccrual.actTOBal != null &amp;&amp; ((toAccrual.getEstimatedAccrHrs() + accrHrsForEntireRange) &gt; toAccrual.actTOBal.getMaxBalance());</span>
		/*
		if (!chkAccrualForEachTO) {     //No need to compute Accrued Hrs on each TO, just calculate for whole period.
			accruedHrsForPeriod += accrHrsForEntireRange;
		}*/
<span class="fc" id="L486">		double usedHrsForPeriod = 0;</span>

		//Handle scenario where there is no TO for the given range.
<span class="pc bpc" id="L489" title="2 of 4 branches missed.">		if (schedOrUsedTOEvents == null || schedOrUsedTOEvents.isEmpty()) {</span>
<span class="nc" id="L490">			double[] accrHrsForEntireRange = calcAccruedHrsForPeriod(dmo, toAccrual, startDate, endDate);</span>

<span class="nc" id="L492">			accruedHrsForPeriod += accrHrsForEntireRange[0];</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">			if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L494">				accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
			}
<span class="nc" id="L496">			toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="nc" id="L497">			        toYearly.getAccrualRateForYear(),</span>
			        null,
			        startDate, endDate, endDate,
			        chkAccrualForEachTO,
			        0,
			        accrHrsForEntireRange[0],
			        0,
			        accruedHrsForPeriod, (int) accrHrsForEntireRange[1]);
<span class="nc" id="L505">		} else {</span>
<span class="fc" id="L506">			ArrayList removeList = new ArrayList(schedOrUsedTOEvents.size());</span>
<span class="fc" id="L507">			Date lastTODate = new Date(startDate.getTime());</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">			for (Iterator it = schedOrUsedTOEvents.iterator(); it.hasNext();) {</span>
<span class="fc" id="L509">				TOHoursPerDay hrsPerDay = (TOHoursPerDay) it.next();</span>
<span class="pc bpc" id="L510" title="1 of 2 branches missed.">				if (   !( hrsPerDay.getStartTime().before(endDate) ) || //Ignore any event that doesn't begin before the enddate , including event starting on the enddate  </span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">						   !( hrsPerDay.getEndTime().after(startDate) ) ||  //Ignore any event that ends before the startdate ,including event ending on the startdate</span>
<span class="pc bpc" id="L512" title="1 of 2 branches missed.">						   !toAccrual.getActivityIDs().contains(hrsPerDay.getActivityID())) //Ignore any events that are not part of the Accrual</span>
				{
<span class="nc" id="L514">					continue;</span>
				}

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">                if((toAccrual.getStDateForStartingBalance() != null) &amp;&amp;</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">                        (hrsPerDay.getStartTime().equals(toAccrual.getStDateForStartingBalance())</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">                                || ( hrsPerDay.getStartTime().before(toAccrual.getStDateForStartingBalance())</span>
                                            &amp;&amp;
<span class="nc bnc" id="L521" title="All 2 branches missed.">                                     hrsPerDay.getEndTime().after(toAccrual.getStDateForStartingBalance())))){</span>
<span class="nc" id="L522">                    continue;</span>

                }
				//removeList.add(hrsPerDay);
<span class="fc" id="L526">				boolean isToEvtStartBeforeStart = hrsPerDay.getStartTime().before(startDate);</span>
<span class="fc" id="L527">				boolean isToEvtEndAfterEnd = hrsPerDay.getEndTime().after(endDate);</span>
<span class="fc" id="L528">				double usedHrsForThisTO = 0;</span>
<span class="fc" id="L529">				double accrdHrsForThisTO = 0;</span>
<span class="fc" id="L530">				int accrualCount = 0;</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">				Date adjStDate = isToEvtStartBeforeStart ? startDate : hrsPerDay.getStartTime();</span>
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">				Date adjEnDate = isToEvtEndAfterEnd ? endDate : hrsPerDay.getEndTime();</span>

<span class="pc bpc" id="L534" title="2 of 4 branches missed.">				if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc" id="L535">					DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hrsPerDay, adjStDate, adjEnDate);</span>
<span class="nc" id="L536">					usedHrsForThisTO += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L537">				} else {</span>
<span class="fc" id="L538">					usedHrsForThisTO += (hrsPerDay.getTotalMinutes() / 60f);</span>
				}

<span class="pc bpc" id="L541" title="1 of 2 branches missed.">				if (chkAccrualForEachTO) {</span>
<span class="fc" id="L542">					double[] accrdHrsForThisTORange = calcAccruedHrsForPeriod(dmo, toAccrual, lastTODate, adjStDate);         </span>
<span class="fc" id="L543">					accrdHrsForThisTO = accrdHrsForThisTORange[0];</span>
<span class="fc" id="L544">					accrualCount = (int) accrdHrsForThisTORange[1];</span>
				}
<span class="fc" id="L546">				accruedHrsForPeriod += accrdHrsForThisTO;</span>
<span class="pc bpc" id="L547" title="1 of 2 branches missed.">				if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L548">					accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
				}
<span class="fc" id="L550">				usedHrsForPeriod += usedHrsForThisTO;</span>
<span class="fc" id="L551">				accruedHrsForPeriod -= usedHrsForThisTO;</span>
<span class="fc" id="L552">				toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="fc" id="L553">				        toYearly.getAccrualRateForYear(),</span>
				        hrsPerDay,
				        lastTODate, adjStDate, adjEnDate,
				        chkAccrualForEachTO,
				        usedHrsForThisTO,
				        accrdHrsForThisTO,
				        usedHrsForPeriod,
				        accruedHrsForPeriod, accrualCount);

<span class="fc" id="L562">				lastTODate = new Date(adjStDate.getTime());</span>
<span class="fc" id="L563">			}</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">			if (chkAccrualForEachTO) {</span>
<span class="fc" id="L565">				double[] accrdHrsForThisTORange = calcAccruedHrsForPeriod(dmo, toAccrual, lastTODate, endDate);</span>
<span class="fc" id="L566">				double accrdHrsForThisTO = accrdHrsForThisTORange[0];</span>
<span class="fc" id="L567">				int accrualCount = (int) accrdHrsForThisTORange[1];</span>
<span class="fc" id="L568">				accruedHrsForPeriod += accrdHrsForThisTO;</span>
<span class="pc bpc" id="L569" title="1 of 2 branches missed.">				if (accruedHrsForPeriod &gt; toAccrual.actTOBal.getMaxBalance()) {</span>
<span class="nc" id="L570">					accruedHrsForPeriod = toAccrual.actTOBal.getMaxBalance();</span>
				}
<span class="fc" id="L572">				toAccrual.addTOAccrlDetailRow(toYearly.getCalendarYear(),</span>
<span class="fc" id="L573">				        toYearly.getAccrualRateForYear(),</span>
				        null,
				        lastTODate, endDate, endDate,
				        chkAccrualForEachTO,
				        0,
				        accrdHrsForThisTO,
				        0,
				        accruedHrsForPeriod, accrualCount);
			}
<span class="fc" id="L582">			schedOrUsedTOEvents.removeAll(removeList);</span>
		}
		//if (RequestUtil.isRMDebugEnabled()m_cat.info(&quot;getAccruedHrsWithinYear start=&quot; + startDate + &quot;; end=&quot; + endDate + &quot;; usedHrsForPeriod=&quot; + usedHrsForPeriod + &quot; ; accruedHrsForPeriod=&quot; + accruedHrsForPeriod);

<span class="fc" id="L586">		toAccrual.setEstimatedAccrHrs(accruedHrsForPeriod);</span>
<span class="fc" id="L587">		return accruedHrsForPeriod;</span>
	}

	private static double[] calcAccruedHrsForPeriod(Jdmo dmo, TOAccrual toAccrual, Date start, Date end) throws Exception {
<span class="fc" id="L591">		EmployeeTimeOffYearly toYearlyStart = toAccrual.getEmployeeTimeOffYearly(toAccrual.getEmployeeTimeOffYear(start));</span>
<span class="fc" id="L592">		EmployeeTimeOffYearly toYearlyPrevAccrPeriod = null;</span>
<span class="fc" id="L593">		Date adjEnd = null;</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">		if (toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_PRORATED_ON_NEXT</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">		        || toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_ALL_HOURS_ON_NEXT) {</span>
<span class="nc" id="L596">			Calendar cal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="nc" id="L597">			cal.setTime(start);</span>
<span class="nc" id="L598">			toAccrual.decrementPeriod(cal);</span>
<span class="nc" id="L599">			toYearlyPrevAccrPeriod = toAccrual.getEmployeeTimeOffYearly(toAccrual.getEmployeeTimeOffYear(cal.getTime()));</span>

<span class="nc" id="L601">			toAccrual.incrementPeriod(cal);</span>
<span class="nc" id="L602">			adjEnd = cal.getTime();</span>
		}
		//Decide whether we want to calculate accrual for two different accrual rates or only one.
		//if adjEnd.after(end) then no need to calculate accrual in two parts since the next accrual is after the end date.
		//we might as well calculate with  one call, since we do not even want to calculate accrual for next accrual schedule.
		//QC 49312 ; Sameet Nov 2009
<span class="pc bpc" id="L608" title="7 of 8 branches missed.">		if (toYearlyPrevAccrPeriod == null || toYearlyStart.equals(toYearlyPrevAccrPeriod) || (adjEnd!=null &amp;&amp; adjEnd.after(end))) {</span>
<span class="fc" id="L609">			return calcAccruedHrsForPeriod(dmo, toAccrual, start, end, toYearlyStart);</span>
		} else {
<span class="nc" id="L611">			double[] accrdHrsForStart = calcAccruedHrsForPeriod(dmo, toAccrual, start, adjEnd, toYearlyPrevAccrPeriod);</span>
<span class="nc" id="L612">			toAccrual.addTOAccrlDetailRow(toYearlyPrevAccrPeriod.getCalendarYear(),</span>
<span class="nc" id="L613">			        toYearlyPrevAccrPeriod.getAccrualRateForYear(),</span>
			        null,
			        start, adjEnd, adjEnd,
			        true,
			        0,
			        accrdHrsForStart[0],
			        0,
			        TOAccrual.NUMBER_NA, (int) accrdHrsForStart[1]);
<span class="nc" id="L621">			double[] accrdHrsForEnd = calcAccruedHrsForPeriod(dmo, toAccrual, adjEnd, end, toYearlyStart);</span>
			//Date endAdjusted is hack for debugging purposes only so that toAccrual.toHtml() displays all the info correctly
			//should not have any effect on business logic.
			//TODO: to find a better  way to do this
<span class="nc" id="L625">			Date endAdjusted = new Date(end.getTime() - 1);</span>
<span class="nc" id="L626">			toAccrual.addTOAccrlDetailRow(toYearlyStart.getCalendarYear(),</span>
<span class="nc" id="L627">			        toYearlyStart.getAccrualRateForYear(),</span>
			        null,
			        adjEnd, endAdjusted, end,
			        true,
			        0,
			        accrdHrsForEnd[0],
			        0,
			        TOAccrual.NUMBER_NA, (int) accrdHrsForEnd[1]);
<span class="nc" id="L635">			return new double[]{accrdHrsForStart[0] + accrdHrsForEnd[0], accrdHrsForStart[1] + accrdHrsForEnd[1]};</span>
		}
	}

	private static double[] calcAccruedHrsForPeriod(Jdmo dmo, TOAccrual toAccrual, Date start, Date end, EmployeeTimeOffYearly toYearly) throws Exception {

<span class="fc" id="L641">		int countBetnPeriod = toAccrual.getCountInBetween(start, end);</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">		double accrRate = toYearly.getAccrualRateForYear() != EmployeeTimeOffYearly.ACCRUAL_RATE_NA ? toYearly.getAccrualRateForYear() : 0;</span>
<span class="fc" id="L643">		double accruedHrs = 0;</span>
<span class="pc bpc" id="L644" title="3 of 4 branches missed.">		if (toAccrual.isAccrualPolicyAdjustmentReqd(start, end) &amp;&amp; !toAccrual.isAccrualPolicyAdjusted()) {</span>
<span class="nc" id="L645">			EmployeeTimeOffAccrued accrued = toAccrual.adjustAccruedTOByAccrualPolicy(start, end);</span>
<span class="nc bnc" id="L646" title="All 6 branches missed.">			if (accrued != null &amp;&amp; (toAccrual.getToAccrualPolicy() == Activity.ACCRUAL_POLICY_PRORATED_ON_NEXT) &amp;&amp; countBetnPeriod &gt; 0) {</span>
<span class="nc" id="L647">				countBetnPeriod--;  //Since its already counted when adjusting the accrual policy</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriod setting countBetnPeriod by -1 = &quot; + countBetnPeriod);</span>
			}
<span class="nc bnc" id="L650" title="All 2 branches missed.">			accruedHrs += (accrued != null ? accrued.getAccruedHours() : 0);</span>
<span class="nc bnc" id="L651" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriod ACCRD HRS BY POLICY= &quot; + (accrued != null ? &quot;&quot; + accrued.getAccruedHours() : &quot;NULL&quot;));</span>
		}
<span class="fc" id="L653">		accruedHrs += (accrRate * countBetnPeriod);</span>
<span class="pc bpc" id="L654" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) m_cat.info(&quot;calcAccruedHrsForPeriodXXX start=&quot; + start + &quot;; end=&quot; + end + &quot;; count=&quot; + countBetnPeriod + &quot; ; Accrual Rate=&quot; + toYearly.getAccrualRateForYear() + &quot; ; Accrued hours=&quot; + accruedHrs);</span>
<span class="fc" id="L655">		return new double[]{accruedHrs, countBetnPeriod};</span>
	}
	/*
		public static int getCountBetweenPeriod(TOAccrual toAccrual, Date start, Date end) {
			int count = 0;
			Calendar calStart = Calendar.getInstance(toAccrual.org.getTimeZone());
			calStart.setTime(start);
			Calendar calEnd = Calendar.getInstance(toAccrual.org.getTimeZone());
			calEnd.setTime(end);
			switch (toAccrual.toAccrualSchedule) {
				case TO_ACCRUAL_SCHEDULE_DAILY:
					count = DateUtil.getDayCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_SEMI_MONTHLY:
					count = DateUtil.getSemiMonthCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_MONTHLY:
					count = DateUtil.getMonthCountInBetween(calStart, calEnd);
					break;
				case TO_ACCRUAL_SCHEDULE_YEARLY:
					count = DateUtil.getYearsCountInBetween(calStart, calEnd, toAccrual.empTOYrStArr[0], toAccrual.empTOYrStArr[1]);
					break;
			}
			return count;
		}        */
}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>