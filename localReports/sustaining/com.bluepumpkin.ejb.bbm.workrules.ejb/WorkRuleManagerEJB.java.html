<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkRuleManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.ejb</a> &gt; <span class="el_source">WorkRuleManagerEJB.java</span></div><h1>WorkRuleManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.workrules.ejb;

import java.lang.reflect.Array;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.base.BPException;
import com.bluepumpkin.common.datatypes.DayOfWeek;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.PaginationPair;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.ScopeID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.localization.LocaleContext;
import com.bluepumpkin.common.localization.LocalizationManager;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmDuplicateExternalIdentException;
import com.bluepumpkin.ejb.bbm.base.BbmDuplicateNameException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.ejb.SchedulingPeriodDAO;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignOrg;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOEJBUtil;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.TimePeriodOfDayDAO;
import com.bluepumpkin.ejb.bbm.empworkrule.model.TimePeriodOfDay;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkUnit;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkUnit.WorkUnitType;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.paypolicy.ejb.EarningTypeSync;
import com.bluepumpkin.ejb.bbm.paypolicy.model.EarningType;
import com.bluepumpkin.ejb.bbm.vo.DBSortField;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.OrganizationDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager.AssignmentRuleValidationError;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager.RotationValidationError;
import com.bluepumpkin.ejb.bbm.workrules.model.*;
import com.bluepumpkin.ejb.bbm.workrules.model.CalendarPeriod.CalendarUnit;
import com.bluepumpkin.ejb.bbm.workrules.model.ComplexWorkRule.WorkUnitCountConstraint;
import com.bluepumpkin.ejb.bbm.workrules.timebanking.ejb.TimeBankPlannerDataDAO;
import com.bluepumpkin.ejb.bbm.workrules.timebanking.model.TimeBankPlannerData;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.bbm.copy.ejb.CopyDAO;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.Scope;
import com.witness.ejb.core.security.model.User;

<span class="fc" id="L91">public class WorkRuleManagerEJB extends SessionEJBBase {</span>
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
<span class="fc" id="L96">	private boolean m_isWhatIf = false;</span>
	private WorkResourceManager m_workResourceManager;
	private CampaignManager m_campaignManager;
	private ActivityManager m_activityManager;

<span class="fc" id="L101">	private static Category m_cat = Log.initCategory(WorkRuleManagerEJB.class.getName());</span>

	/** override the base class to provide the appropriate logging category */
	protected Category getCategory() {
<span class="fc" id="L105">		return m_cat;</span>
	}

	{
<span class="fc" id="L109">		super.init(WorkRuleManagerEJB.class.getName());</span>
<span class="fc" id="L110">	}</span>

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L116">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L117">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">			if (WIF != null) {</span>
<span class="fc" id="L119">				m_isWhatIf = WIF.booleanValue();</span>
			}
<span class="fc" id="L121">			m_workResourceManager = BbmManagerFactory.getWorkResourceManager(m_isWhatIf);</span>
<span class="fc" id="L122">			m_campaignManager = WfmManagerFactory.getCampaignManager(m_isWhatIf);</span>
<span class="nc" id="L123">		} catch (Exception e) {</span>
<span class="nc" id="L124">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L125">		}</span>
<span class="fc" id="L126">	}</span>

	protected void init(String catName) {
<span class="nc" id="L129">		super.init(WorkRuleManagerEJB.class.getName());</span>
<span class="nc" id="L130">	}</span>

	public ID createWorkRule(WorkRule pWorkRule) throws WorkRuleException, BbmCreateException {
<span class="nc" id="L133">		methodStart(&quot;createWorkRule&quot;, pWorkRule);</span>
		try {
<span class="nc" id="L135">			return (new WorkRulesDAO()).CreateWorkRule(pWorkRule);</span>
<span class="nc" id="L136">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L137">			handleException(e);</span>
<span class="nc" id="L138">			throw e;</span>
<span class="nc" id="L139">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L140">			handleException(e);</span>
<span class="nc" id="L141">			throw e;</span>
		} finally {
<span class="nc" id="L143">			methodFinish();</span>
		}
	}

	public void updateWorkRule(WorkRule pWorkRule) throws WorkRuleException, BbmUpdateException {
<span class="nc" id="L148">		methodStart(&quot;updateWorkRule&quot;, pWorkRule);</span>
		try {
<span class="nc" id="L150">			(new WorkRulesDAO()).UpdateWorkRule(pWorkRule);</span>
<span class="nc" id="L151">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L152">			handleException(e);</span>
<span class="nc" id="L153">			throw e;</span>
<span class="nc" id="L154">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L155">			handleException(e);</span>
<span class="nc" id="L156">			throw e;</span>
		} finally {
<span class="nc" id="L158">			methodFinish();</span>
<span class="nc" id="L159">		}</span>
<span class="nc" id="L160">	}</span>

	public void removeWorkRule(ID idWorkRule) throws BbmRemoveException {
<span class="nc" id="L163">		methodStart(&quot;removeWorkRule&quot;, idWorkRule);</span>
		try {
<span class="nc" id="L165">			(new WorkRulesDAO()).RemoveWorkRule(idWorkRule);</span>
<span class="nc" id="L166">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L167">			handleException(e);</span>
<span class="nc" id="L168">			throw e;</span>
		} finally {
<span class="nc" id="L170">			methodFinish();</span>
<span class="nc" id="L171">		}</span>
<span class="nc" id="L172">	}</span>

	public HashMap getWorkRulesForOrganization(ID idOrganization) throws WorkRuleException, BbmFinderException {
<span class="nc" id="L175">		methodStart(&quot;getWorkRulesForOrganization&quot;, idOrganization);</span>
		try {
<span class="nc" id="L177">			return (new WorkRulesDAO()).GetWorkRulesForOrganization(idOrganization, WorkRule.PAYRULE, -1);</span>
<span class="nc" id="L178">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L179">			handleException(e);</span>
<span class="nc" id="L180">			throw e;</span>
<span class="nc" id="L181">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L182">			handleException(e);</span>
<span class="nc" id="L183">			throw e;</span>
		} finally {
<span class="nc" id="L185">			methodFinish();</span>
		}
	}

	public HashMap getWorkRulesForOrganization(ID idOrganization, int eType) throws WorkRuleException,
			BbmFinderException {
<span class="nc" id="L191">		methodStart(&quot;getWorkRulesForOrganization&quot;, idOrganization, new Integer(eType));</span>
		try {
<span class="nc" id="L193">			return (new WorkRulesDAO()).GetWorkRulesForOrganization(idOrganization, eType, -1);</span>
<span class="nc" id="L194">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L195">			handleException(e);</span>
<span class="nc" id="L196">			throw e;</span>
<span class="nc" id="L197">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L198">			handleException(e);</span>
<span class="nc" id="L199">			throw e;</span>
		} finally {
<span class="nc" id="L201">			methodFinish();</span>
		}
	}

	public HashMap getWorkRulesForOrganizationDuration(ID idOrganization, int nDuration, int eType)
			throws WorkRuleException, BbmFinderException {
<span class="nc" id="L207">		methodStart(&quot;getWorkRulesForOrganizationDuration&quot;, idOrganization, new Integer(nDuration), new Integer(eType));</span>
		try {
<span class="nc" id="L209">			return (new WorkRulesDAO()).GetWorkRulesForOrganization(idOrganization, eType, nDuration);</span>
<span class="nc" id="L210">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L211">			handleException(e);</span>
<span class="nc" id="L212">			throw e;</span>
<span class="nc" id="L213">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L214">			handleException(e);</span>
<span class="nc" id="L215">			throw e;</span>
		} finally {
<span class="nc" id="L217">			methodFinish();</span>
		}
	}

	public HashMap getWorkRuleTemplates() throws BbmFinderException {
<span class="nc" id="L222">		methodStart(&quot;getWorkRulesTemplates&quot;);</span>
		try {
<span class="nc" id="L224">			return (new WorkRulesDAO()).getWorkRuleTemplates(WorkRule.PAYRULE);</span>
<span class="nc" id="L225">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L226">			handleException(e);</span>
<span class="nc" id="L227">			throw e;</span>
		} finally {
<span class="nc" id="L229">			methodFinish();</span>
		}
	}

	public HashMap getWorkRuleTemplates(int eType) throws BbmFinderException {
<span class="nc" id="L234">		methodStart(&quot;getWorkRulesTemplates&quot;, new Integer(eType));</span>
		try {
<span class="nc" id="L236">			return (new WorkRulesDAO()).getWorkRuleTemplates(eType);</span>
<span class="nc" id="L237">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L238">			handleException(e);</span>
<span class="nc" id="L239">			throw e;</span>
		} finally {
<span class="nc" id="L241">			methodFinish();</span>
		}
	}

	public Pair expandRuleWindow(HashMap hWorkRules, LocalDate dtStartDate, LocalDate dtEndDate)
			throws WorkRuleException {
<span class="nc" id="L247">		methodStart(&quot;expandRuleWindowStartDate&quot;, hWorkRules, dtStartDate, dtEndDate);</span>
		try {
<span class="nc" id="L249">			ArrayList aWorkRules = new ArrayList(hWorkRules.values());</span>
<span class="nc" id="L250">			Collections.sort(aWorkRules);</span>

<span class="nc" id="L252">			return WorkRuleUtil.ExpandRuleWindow(aWorkRules, dtStartDate, dtEndDate);</span>
<span class="nc" id="L253">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L254">			handleException(e);</span>
<span class="nc" id="L255">			throw e;</span>
		} finally {
<span class="nc" id="L257">			methodFinish();</span>
		}
	}

	public Collection getConflictsForEmployee(LocalDate dtStartDate, LocalDate dtEndDate, ID idWorkResource,
			Organization pOrganization, HashMap hWorkRules, Collection cEvents) throws WorkRuleException {
<span class="nc" id="L263">		methodStart(&quot;getConflictsForEmployee&quot;, dtStartDate, dtEndDate, idWorkResource);</span>
		try {
<span class="nc" id="L265">			return WorkRuleUtil.getConflictsForEmployee(dtStartDate, dtEndDate, idWorkResource, pOrganization,</span>
					hWorkRules, cEvents, false);
<span class="nc" id="L267">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L268">			handleException(e);</span>
<span class="nc" id="L269">			throw e;</span>
		} finally {
<span class="nc" id="L271">			methodFinish();</span>
		}
	}

	public HashMap getInitializedWorkRulesByIDs(Collection cWorkRuleIDs, Collection cOrgs, Collection cWorkResourceIDs,
			LocalDate dtStart, LocalDate dtEnd, int eOverlap) throws BbmFinderException, WorkRuleException {
<span class="nc" id="L277">		methodStart(&quot;getInitializedWorkRulesByIDs&quot;, cWorkRuleIDs, cOrgs, cWorkResourceIDs);</span>
		try {
<span class="nc" id="L279">			HashMap hWorkRules = (new WorkRulesDAO()).GetWorkRulesByIDs(cWorkRuleIDs);</span>

<span class="nc" id="L281">			ArrayList aWorkRules = new ArrayList(hWorkRules.values());</span>
<span class="nc" id="L282">			Collections.sort(aWorkRules);</span>

<span class="nc" id="L284">			LocalDate dtNewStart = WorkRuleUtil.ExpandRuleWindowStartDate(aWorkRules, dtStart, dtEnd);</span>

			// initialize the work rules before returning them
<span class="nc bnc" id="L287" title="All 2 branches missed.">			for (Iterator w = hWorkRules.values().iterator(); w.hasNext();) {</span>
<span class="nc" id="L288">				WorkRule pWorkRule = (WorkRule) w.next();</span>
<span class="nc" id="L289">				pWorkRule.initialize(dtNewStart, dtEnd, cOrgs, cWorkResourceIDs, eOverlap);</span>
<span class="nc" id="L290">			}</span>
<span class="nc" id="L291">			return hWorkRules;</span>
<span class="nc" id="L292">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L293">			handleException(e);</span>
<span class="nc" id="L294">			throw e;</span>
<span class="nc" id="L295">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L296">			handleException(e);</span>
<span class="nc" id="L297">			throw e;</span>
		} finally {
<span class="nc" id="L299">			methodFinish();</span>
		}
	}

	public HashMap getWorkRulesByIDs(Collection cWorkRuleIDs) throws BbmFinderException, WorkRuleException {
<span class="nc" id="L304">		methodStart(&quot;getWorkRulesByIDs&quot;, cWorkRuleIDs);</span>
		try {
<span class="nc" id="L306">			return (new WorkRulesDAO()).GetWorkRulesByIDs(cWorkRuleIDs);</span>
<span class="nc" id="L307">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L308">			handleException(e);</span>
<span class="nc" id="L309">			throw e;</span>
<span class="nc" id="L310">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L311">			handleException(e);</span>
<span class="nc" id="L312">			throw e;</span>
		} finally {
<span class="nc" id="L314">			methodFinish();</span>
		}
	}

	public WorkRule getWorkRuleByID(ID idWorkRule) throws WorkRuleException, BbmFinderException {
<span class="nc" id="L319">		methodStart(&quot;getWorkRuleByID&quot;, idWorkRule);</span>
		try {
<span class="nc" id="L321">			LinkedList llWorkRuleIDs = new LinkedList();</span>
<span class="nc" id="L322">			llWorkRuleIDs.add(idWorkRule);</span>

<span class="nc" id="L324">			HashMap hWorkRules = (new WorkRulesDAO()).GetWorkRulesByIDs(llWorkRuleIDs);</span>
<span class="nc" id="L325">			return (WorkRule) hWorkRules.get(idWorkRule);</span>

<span class="nc" id="L327">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L328">			handleException(e);</span>
<span class="nc" id="L329">			throw e;</span>
<span class="nc" id="L330">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L331">			handleException(e);</span>
<span class="nc" id="L332">			throw e;</span>
		} finally {
<span class="nc" id="L334">			methodFinish();</span>
		}
	}

	public HashMap getWorkRuleSentences(HashMap hWorkRules, LocaleContext locale) throws BbmFinderException,
			WorkRuleException {

<span class="nc" id="L341">		methodStart(&quot;getWorkRuleSentences&quot;, hWorkRules);</span>
		try {
<span class="nc" id="L343">			Collection cActivityIDs = DisplayUtil.getActivityIDsForWorkRules(hWorkRules.values());</span>
<span class="nc" id="L344">			HashMap hActivities = new HashMap();</span>
<span class="nc" id="L345">			Localizer localizer = null;</span>

			try {
<span class="nc" id="L348">				ActivityManager pActivityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L349">				Collection cActivites = pActivityManager.findActivities(new ActivityFilter());</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">				for (Iterator a = cActivites.iterator(); a.hasNext();) {</span>
<span class="nc" id="L351">					Activity pActivity = (Activity) a.next();</span>
<span class="nc" id="L352">					hActivities.put(pActivity.getID(), pActivity);</span>
<span class="nc" id="L353">				}</span>
<span class="nc" id="L354">				LocalizationManager l10nMgr = DefaultLocalizationManager.getInstance();</span>
<span class="nc" id="L355">				localizer = l10nMgr.getLocalizer(locale);</span>

<span class="nc" id="L357">			} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L358">				handleException(e);</span>
<span class="nc" id="L359">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L360">			} catch (BbmException e) {</span>
<span class="nc" id="L361">				handleException(e);</span>
<span class="nc" id="L362">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L363">			} catch (RemoteException e) {</span>
<span class="nc" id="L364">				handleException(e);</span>
<span class="nc" id="L365">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L366">			}</span>

<span class="nc" id="L368">			Collection cShiftIDs = DisplayUtil.getShiftIDsForWorkRules(hWorkRules.values());</span>
<span class="nc" id="L369">			HashMap hShifts = new HashMap();</span>

<span class="nc" id="L371">			Collection cEarningTypeIDs = DisplayUtil.getEarningTypeIDsForWorkRules(hWorkRules.values());</span>
<span class="nc" id="L372">			HashMap hEarningTypes = new HashMap();</span>

			try {
<span class="nc" id="L375">				EarningTypeSync pEarningTypeManager = BbmManagerFactory.getEarningTypeSync();</span>
<span class="nc" id="L376">				EarningType[] aEarningTypes = pEarningTypeManager.getAllEarningTypes();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">				for (int i = 0; i &lt; Array.getLength(aEarningTypes); i++) {</span>
<span class="nc" id="L378">					EarningType pEarningType = aEarningTypes[i];</span>
<span class="nc" id="L379">					hEarningTypes.put(pEarningType.getId(), pEarningType);</span>
				}
<span class="nc" id="L381">			} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L382">				handleException(e);</span>
<span class="nc" id="L383">				throw new WorkRuleException(&quot;could not get Earning Types&quot;);</span>
<span class="nc" id="L384">			} catch (JdmoException e) {</span>
<span class="nc" id="L385">				handleException(e);</span>
<span class="nc" id="L386">				throw new WorkRuleException(&quot;could not get Earning Types&quot;);</span>
<span class="nc" id="L387">			} catch (RemoteException e) {</span>
<span class="nc" id="L388">				handleException(e);</span>
<span class="nc" id="L389">				throw new WorkRuleException(&quot;could not get Earning Types&quot;);</span>
<span class="nc" id="L390">			}</span>

<span class="nc" id="L392">			HashMap hWorkRuleTemplates = (new WorkRulesDAO()).getWorkRuleTemplates(-1);</span>

<span class="nc" id="L394">			HashMap hSentences = new HashMap();</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">			for (Iterator i = hWorkRules.values().iterator(); i.hasNext();) {</span>
<span class="nc" id="L396">				WorkRule pWorkRule = (WorkRule) i.next();</span>
<span class="nc" id="L397">				WorkRuleTemplate pWorkRuleTemplate = (WorkRuleTemplate) hWorkRuleTemplates.get(pWorkRule</span>
<span class="nc" id="L398">						.getWorkRuleTemplateId());</span>
<span class="nc" id="L399">				hSentences.put(pWorkRule.getId(), DisplayUtil.displaySentence(pWorkRule, pWorkRuleTemplate,</span>
						hActivities, hEarningTypes, hShifts, localizer));
<span class="nc" id="L401">			}</span>

<span class="nc" id="L403">			return hSentences;</span>
<span class="nc" id="L404">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L405">			handleException(e);</span>
<span class="nc" id="L406">			throw e;</span>
<span class="nc" id="L407">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L408">			handleException(e);</span>
<span class="nc" id="L409">			throw e;</span>
		} finally {
<span class="nc" id="L411">			methodFinish();</span>
		}
	}

	public Collection getParsedSentence(WorkRuleTemplate pWorkRuleTemplate, WorkRule pWorkRule, ID idOrganization,
			LocaleContext locale) throws RemoteException, WorkRuleException {
<span class="nc" id="L417">		methodStart(&quot;getParsedSentence&quot;, pWorkRuleTemplate);</span>
		try {
<span class="nc" id="L419">			HashMap hActivities = new HashMap();</span>
<span class="nc" id="L420">			Localizer localizer = null;</span>
			try {
<span class="nc" id="L422">				ActivityManager pActivityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L423">				Collection cActivites = pActivityManager.findOrganizationActivities(idOrganization,</span>
						new ActivityFilter());
<span class="nc bnc" id="L425" title="All 2 branches missed.">				for (Iterator a = cActivites.iterator(); a.hasNext();) {</span>
<span class="nc" id="L426">					Activity pActivity = (Activity) a.next();</span>
<span class="nc" id="L427">					hActivities.put(pActivity.getID(), pActivity);</span>
<span class="nc" id="L428">				}</span>
<span class="nc" id="L429">				LocalizationManager l10nMgr = DefaultLocalizationManager.getInstance();</span>
<span class="nc" id="L430">				localizer = l10nMgr.getLocalizer(locale);</span>

<span class="nc" id="L432">			} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L433">				handleException(e);</span>
<span class="nc" id="L434">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L435">			} catch (BbmException e) {</span>
<span class="nc" id="L436">				handleException(e);</span>
<span class="nc" id="L437">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L438">			} catch (RemoteException e) {</span>
<span class="nc" id="L439">				handleException(e);</span>
<span class="nc" id="L440">				throw new WorkRuleException(&quot;could not get Activities&quot;);</span>
<span class="nc" id="L441">			}</span>

<span class="nc" id="L443">			HashMap hShifts = new HashMap();</span>
			/*
			 * try { ShiftManager pShiftManager =
			 * BbmManagerFactory.getShiftManager(); hShifts =
			 * pShiftManager.getShiftsForOrganization(idOrganization); } catch
			 * (BbmEJBCreateException e) { handleException(e); throw new
			 * WorkRuleException(&quot;could not get Shifts Types&quot;); } catch
			 * (BbmFinderException e) { handleException(e); throw new
			 * WorkRuleException(&quot;could not get Shifts Types&quot;); } catch
			 * (RemoteException e) { handleException(e); throw new
			 * WorkRuleException(&quot;could not get Shifts Types&quot;); }
			 */

<span class="nc" id="L456">			return DisplayUtil.parseSentence(pWorkRule, pWorkRuleTemplate, hActivities, hShifts, localizer);</span>

<span class="nc" id="L458">		} catch (WorkRuleException e) {</span>
<span class="nc" id="L459">			handleException(e);</span>
<span class="nc" id="L460">			throw e;</span>
		} finally {
<span class="nc" id="L462">			methodFinish();</span>
		}
	}

	public void updatePostedConflicts(HashMap pEmployeeConflicts, ID idPayPeriod) throws BbmUpdateException {
<span class="nc" id="L467">		methodStart(&quot;updatePostedConflicts&quot;, pEmployeeConflicts, idPayPeriod);</span>
		try {
<span class="nc" id="L469">			(new WorkRulesDAO()).updatePostedConflicts(pEmployeeConflicts, idPayPeriod);</span>
<span class="nc" id="L470">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L471">			handleException(e);</span>
<span class="nc" id="L472">			throw e;</span>
		} finally {
<span class="nc" id="L474">			methodFinish();</span>
<span class="nc" id="L475">		}</span>
<span class="nc" id="L476">	}</span>

	public HashMap getPostedConflicts(Collection pEmployeeIDs, ID idPayPeriod) throws BbmFinderException {
<span class="nc" id="L479">		methodStart(&quot;getPostedConflicts&quot;, pEmployeeIDs, idPayPeriod);</span>
		try {
<span class="nc" id="L481">			return (new WorkRulesDAO()).getPostedConflicts(pEmployeeIDs, idPayPeriod);</span>
<span class="nc" id="L482">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L483">			handleException(e);</span>
<span class="nc" id="L484">			throw e;</span>
		} finally {
<span class="nc" id="L486">			methodFinish();</span>
		}
	}

	// web calendar, only getObjects api in dao works now.
	public Shift getShift(ID idShift) throws BbmFinderException {
<span class="fc" id="L492">		methodStart(&quot;getShift&quot;, idShift);</span>
<span class="fc" id="L493">		ShiftDAO dao = null;</span>
		try {
<span class="fc" id="L495">			dao = new ShiftDAO();</span>
<span class="fc" id="L496">			return (Shift) (dao.getObjectByID(idShift));</span>
<span class="nc" id="L497">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L498">			handleException(e);</span>
<span class="nc" id="L499">			throw e;</span>
		} finally {
<span class="pc bpc" id="L501" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L502">				dao.cleanUp();</span>
			}
<span class="pc" id="L504">			methodFinish();</span>
		}
	}

	public Collection&lt;Shift&gt; getShifts(Collection&lt;ID&gt; empIDs, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L509">		methodStart(&quot;getShifts&quot;, empIDs, start, end);</span>
<span class="nc" id="L510">		ShiftDAO dao = null;</span>
		try {
<span class="nc" id="L512">			dao = new ShiftDAO();</span>
<span class="nc" id="L513">			Collection&lt;ID&gt; orgIDs = getOrganizationIDList(dao.getDMO(), empIDs, start, end);</span>
<span class="nc" id="L514">			StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L515">			sb.append(&quot; ORGANIZATIONID IN &quot;).append(dao.getDMO().createInClause(orgIDs));</span>
<span class="nc" id="L516">			Collection&lt;Shift&gt; shifts = dao.getObjects(sb.toString());</span>
			// remove predefined SHIFT_OFF fromt the list
<span class="nc" id="L518">			Shift shift = null;</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			for (Iterator&lt;Shift&gt; i = shifts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L520">				shift = i.next();</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">				if (shift.getID().toInt() == ShiftFieldInfo.POSSIBLE_DAYS_OFF_SHIFT_ID) { </span>
					// predefined SHIFT_OFF
<span class="nc" id="L523">					i.remove();</span>
				}
			}
<span class="nc" id="L526">			return shifts;</span>
<span class="nc" id="L527">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L528">			handleException(e);</span>
<span class="nc" id="L529">			throw e;</span>
<span class="nc" id="L530">		} catch (Exception e) {</span>
<span class="nc" id="L531">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L533" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L534">				dao.cleanUp();</span>
			}
<span class="nc" id="L536">			methodFinish();</span>
		}
	}

	public Collection&lt;Shift&gt; getShiftsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="fc" id="L541">		methodStart(&quot;getShiftsByID&quot;, ids);</span>
<span class="fc" id="L542">		ShiftDAO dao = null;</span>
		try {
<span class="fc" id="L544">			dao = new ShiftDAO();</span>
<span class="fc" id="L545">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L546">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L547">			handleException(e);</span>
<span class="nc" id="L548">			throw e;</span>
		} finally {
<span class="pc bpc" id="L550" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L551">				dao.cleanUp();</span>
			}
<span class="pc" id="L553">			methodFinish();</span>
		}
	}

	/**
	 * Returns shifts by name for the given local scope (no inherited shifts)
	 * 
	 * @param scopeID
	 * @param names
	 * @return
	 * @throws BbmFinderException
	 */
	public Collection&lt;Shift&gt; getShiftsByName(ScopeID scopeID, Collection&lt;String&gt; names) throws BbmFinderException {
<span class="nc" id="L566">		methodStart(&quot;getShiftsByName&quot;, names);</span>
<span class="nc" id="L567">		ShiftDAO dao = null;</span>
		try {
<span class="nc" id="L569">			dao = new ShiftDAO();</span>
<span class="nc" id="L570">			StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L571">			ArrayList&lt;ID&gt; orgIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L572">			ArrayList&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L573" title="All 2 branches missed.">			if (scopeID.getType() == Scope.ORG_SCOPE) {</span>
<span class="nc" id="L574">				orgIds.add(scopeID.getID());</span>
<span class="nc" id="L575">				sb.append(&quot; ORGANIZATIONID IN (&quot;).append(JdmoUtil.createIDList(orgIds)).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">			} else if (scopeID.getType() == Scope.CAMPAIGN_SCOPE) {</span>
<span class="nc" id="L577">				campaignIds.add(scopeID.getID());</span>
<span class="nc" id="L578">				sb.append(&quot; CAMPAIGNID IN (&quot;).append(JdmoUtil.createIDList(campaignIds)).append(&quot;)&quot;);</span>
			}
<span class="nc" id="L580">			return dao.getObjects(sb.toString());</span>
<span class="nc" id="L581">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L582">			handleException(e);</span>
<span class="nc" id="L583">			throw e;</span>
		} finally {
<span class="nc bnc" id="L585" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L586">				dao.cleanUp();</span>
			}
<span class="nc" id="L588">			methodFinish();</span>
		}
	}

	// the ScopeID only has SID
	public Collection getShiftOTExtension(ScopeID scopeID, Date start, Date end) throws BbmFinderException {
<span class="fc" id="L594">		methodStart(&quot;getAllShiftOTExtensions&quot;, scopeID, start, end);</span>
<span class="fc" id="L595">		ShiftOTExtensionDAO dao = null;</span>
		try {
<span class="fc" id="L597">			dao = new ShiftOTExtensionDAO();</span>
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">			if (scopeID == null) {</span>
<span class="nc" id="L599">				return dao.getObjects(&quot;&quot;);</span>
			} else {
				// resolve the scope ID
<span class="fc" id="L602">				ArrayList orgIDs = new ArrayList();</span>
<span class="fc" id="L603">				StringBuffer sb = new StringBuffer(200);</span>
				// so far shift ot extension only has two scopes:org and
				// campaign
<span class="pc bpc" id="L606" title="1 of 2 branches missed.">				if (scopeID.getType() == Scope.ORG_SCOPE) {</span>
<span class="nc" id="L607">					orgIDs.add(scopeID.getID());</span>
				}
<span class="pc bpc" id="L609" title="1 of 2 branches missed.">				if (scopeID.getType() == Scope.CAMPAIGN_SCOPE) {</span>
<span class="fc" id="L610">					sb.append(&quot; CAMPAIGNID in ( select id from campaign where sid =&quot;).append(scopeID.getID())</span>
<span class="fc" id="L611">							.append(&quot;)&quot;);</span>
					// get linked org list and their parents
<span class="fc" id="L613">					Collection campOrgs = getCampaignManager().getCampaignOrgAssignments(scopeID.getID(), start, end);</span>

<span class="fc" id="L615">					CampaignOrg assignment = null;</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">					for (Iterator i = campOrgs.iterator(); i.hasNext();) {</span>
<span class="fc" id="L617">						assignment = (CampaignOrg) i.next();</span>
<span class="fc" id="L618">						orgIDs.add(assignment.getOrganizationID());</span>
					}
				}
<span class="fc" id="L621">				orgIDs.addAll(getWorkResourceManager().getOrganizationsParentsByIDs(orgIDs));</span>
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">				if (!orgIDs.isEmpty()) {</span>
<span class="pc bpc" id="L623" title="1 of 2 branches missed.">					if (scopeID.getType() == Scope.CAMPAIGN_SCOPE) {</span>
<span class="fc" id="L624">						sb.append(&quot; or &quot;);</span>
					}
<span class="fc" id="L626">					sb.append(&quot; ORGANIZATIONID IN &quot;).append(dao.getDMO().createInClause(orgIDs));</span>
				}
<span class="fc" id="L628">				return dao.getObjects(sb.toString());</span>
			}
<span class="nc" id="L630">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L631">			handleException(e);</span>
<span class="nc" id="L632">			throw e;</span>
<span class="nc" id="L633">		} catch (Exception e) {</span>
<span class="nc" id="L634">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L636" title="5 of 6 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L637">				dao.cleanUp();</span>
			}
<span class="pc" id="L639">			methodFinish();</span>
		}
	}

	// the following API is dedicated for no campaign mode of web calendar
	public Collection getShiftOTExtension(Collection empIDs, Date start, Date end) throws BbmFinderException {
<span class="fc" id="L645">		methodStart(&quot;getShiftOTExtension&quot;, empIDs, start, end);</span>
<span class="fc" id="L646">		ShiftOTExtensionDAO dao = null;</span>
		try {
<span class="fc" id="L648">			dao = new ShiftOTExtensionDAO();</span>
<span class="fc" id="L649">			Collection orgIDs = getOrganizationIDList(dao.getDMO(), empIDs, start, end);</span>
<span class="fc" id="L650">			StringBuffer sb = new StringBuffer(200);</span>
<span class="fc" id="L651">			sb.append(&quot; ORGANIZATIONID IN &quot;).append(dao.getDMO().createInClause(orgIDs));</span>
<span class="fc" id="L652">			return dao.getObjects(sb.toString());</span>
<span class="nc" id="L653">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L654">			handleException(e);</span>
<span class="nc" id="L655">			throw e;</span>
<span class="nc" id="L656">		} catch (Exception e) {</span>
<span class="nc" id="L657">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L659" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L660">				dao.cleanUp();</span>
			}
<span class="pc" id="L662">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftOTExtension&gt; getShiftOTExtensionsByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="fc" id="L669">		methodStart(&quot;getShiftOTExtensionsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>
<span class="fc" id="L670">		ShiftOTExtensionDAO dao = null;</span>
		try {
<span class="fc" id="L672">			dao = new ShiftOTExtensionDAO();</span>
<span class="fc" id="L673">			return dao.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap,</span>
					filteredIDs);
<span class="nc" id="L675">		} catch (Exception e) {</span>
<span class="nc" id="L676">			handleException(e);</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L678">				throw (BbmFinderException) e;</span>
<span class="nc" id="L679">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L681" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L682">				dao.cleanUp();</span>
<span class="pc" id="L683">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftOTExtension&gt; getShiftOTExtensionsBySchedulingPeriod(SchedulingPeriod sp,
			boolean isAscendingSort, int pageIDSize, int pageIndex,
			LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="nc" id="L690">		methodStart(&quot;getShiftOTExtensionsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>
<span class="nc" id="L691">		ShiftOTExtensionDAO dao = null;</span>
		try {
<span class="nc" id="L693">			dao = new ShiftOTExtensionDAO();</span>
<span class="nc" id="L694">			return dao.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs);
<span class="nc" id="L696">		} catch (Exception e) {</span>
<span class="nc" id="L697">			handleException(e);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L699">				throw (BbmFinderException) e;</span>
<span class="nc" id="L700">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L702" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L703">				dao.cleanUp();</span>
			}
<span class="nc" id="L705">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftOTExtension&gt; getShiftOTExtensionsByIDs(Collection&lt;ID&gt; shiftOTExtensionIDs)
			throws BbmFinderException {
<span class="fc" id="L711">		methodStart(&quot;getShiftOTExtensionsByIDs&quot;, shiftOTExtensionIDs);</span>

<span class="fc" id="L713">		ShiftOTExtensionDAO soteDAO = new ShiftOTExtensionDAO();</span>
		try {
<span class="fc" id="L715">			return soteDAO.getObjectsByIDs(shiftOTExtensionIDs);</span>
<span class="nc" id="L716">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L717">			handleException(ex);</span>
<span class="nc" id="L718">			throw ex;</span>
		} finally {
<span class="pc" id="L720">			soteDAO.cleanUp();</span>
<span class="pc" id="L721">			methodFinish();</span>
		}
	}

	public ShiftOTExtension getShiftOTExtensionByID(ID shiftOTExtensionID) throws BbmFinderException {
<span class="nc" id="L726">		methodStart(&quot;getShiftOTExtensionsByIDs&quot;, shiftOTExtensionID);</span>

<span class="nc" id="L728">		ShiftOTExtensionDAO soteDAO = new ShiftOTExtensionDAO();</span>
		try {
<span class="nc" id="L730">			return soteDAO.getObjectByID(shiftOTExtensionID);</span>
<span class="nc" id="L731">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L732">			handleException(ex);</span>
<span class="nc" id="L733">			throw ex;</span>
		} finally {
<span class="nc" id="L735">			soteDAO.cleanUp();</span>
<span class="nc" id="L736">			methodFinish();</span>
		}
	}

	public void deleteOTExtensions(Collection&lt;ID&gt; otextensionIDs) throws BbmRemoveException, RemoteException {
<span class="fc" id="L741">		methodStart(&quot;deleteOTExtensions&quot;, otextensionIDs);</span>
<span class="fc" id="L742">		ShiftOTExtensionDAO otextensionDAO = new ShiftOTExtensionDAO();</span>
		try {
			// No need to set modified by and modified date because the DAOBase
			// method
			// assumes that when deleting via update that there is are
			// DELETEONDATE, MODIFIEDBY
			// and MODIFIED (date) fields on the table.
<span class="fc" id="L749">			otextensionDAO.deleteObjectsViaUpdate(otextensionIDs, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L750">		} catch (BbmRemoveException ex) {</span>
<span class="nc" id="L751">			handleException(ex);</span>
<span class="nc" id="L752">			throw ex;</span>
		} finally {
<span class="pc" id="L754">			otextensionDAO.cleanUp();</span>
<span class="pc" id="L755">			methodFinish();</span>
<span class="fc" id="L756">		}</span>
<span class="fc" id="L757">	}</span>

	public ID createOTExtension(ShiftOTExtension objValue) throws BbmCreateException,
			BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="fc" id="L761">		methodStart(&quot;createOTExtension&quot;, objValue);</span>

<span class="fc" id="L763">		ShiftOTExtensionDAO dao = new ShiftOTExtensionDAO();</span>
		try {
<span class="fc" id="L765">			objValue.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L766">			objValue.setCreatedDate(new Date());</span>
<span class="fc" id="L767">			objValue.setModifiedBy(null);</span>
<span class="fc" id="L768">			objValue.setModifiedDate(null);</span>
<span class="fc" id="L769">			return DAOUtil.mapIDToSID(dao.createObject(objValue), new ShiftOTExtensionFieldInfo());</span>
		} finally {
<span class="pc" id="L771">			dao.cleanUp();</span>
<span class="pc" id="L772">			methodFinish();</span>
		}
	}

	public void updateOTExtensions(Collection&lt;ShiftOTExtension&gt; otExtensions) throws BbmUpdateException,
			RemoteException {
<span class="fc" id="L778">		methodStart(&quot;updateOTExtensions&quot;, otExtensions);</span>
<span class="fc" id="L779">		ShiftOTExtensionDAO otExtensionDAO = new ShiftOTExtensionDAO();</span>
		try {
<span class="fc" id="L781">			String modifiedBy = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L782">			Date modifiedDate = new Date(System.currentTimeMillis());</span>
<span class="fc bfc" id="L783" title="All 2 branches covered.">			for (ShiftOTExtension extension : otExtensions) {</span>
<span class="fc" id="L784">				extension.setModifiedBy(modifiedBy);</span>
<span class="fc" id="L785">				extension.setModifiedDate(modifiedDate);</span>
<span class="fc" id="L786">			}</span>
<span class="fc" id="L787">			otExtensionDAO.updateObjects(otExtensions);</span>
<span class="nc" id="L788">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L789">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="pc" id="L791">			otExtensionDAO.cleanUp();</span>
<span class="pc" id="L792">			methodFinish();</span>
<span class="fc" id="L793">		}</span>
<span class="fc" id="L794">	}</span>

	public void copyOTExtensions(Collection&lt;ID&gt; otExtensionIDs, boolean isOrgMode, ID ownerID,
			LocaleContext localeContext) throws BbmCreateException, BbmDuplicateExternalIdentException,
			BbmFinderException, RemoteException {
<span class="nc" id="L799">		methodStart(&quot;copyOTExtensions&quot;, otExtensionIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L800">		ShiftOTExtensionDAO dao = new ShiftOTExtensionDAO();</span>

		try {
<span class="nc" id="L803">			dao.copyOTExtensions(otExtensionIDs, isOrgMode, ownerID, localeContext, m_sessionContext</span>
<span class="nc" id="L804">					.getCallerPrincipal().getName());</span>
<span class="nc" id="L805">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L806">			handleException(ex);</span>
<span class="nc" id="L807">			throw ex;</span>
<span class="nc" id="L808">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L809">			handleException(ex);</span>
<span class="nc" id="L810">			throw ex;</span>
		} finally {
<span class="nc" id="L812">			methodFinish();</span>
<span class="nc" id="L813">		}</span>
<span class="nc" id="L814">	}</span>

	public HashMap&lt;ID, String&gt; getOTExtensionNamesByOrg(ID orgID) throws BbmFinderException {
<span class="fc" id="L817">		methodStart(&quot;getOTExtensionNamesByOrg&quot;, orgID);</span>
<span class="fc" id="L818">		ShiftOTExtensionDAO shiftOTDAO = new ShiftOTExtensionDAO();</span>

		try {
<span class="fc" id="L821">			return shiftOTDAO.getOTExtensionNamesByOrg(orgID);</span>
<span class="nc" id="L822">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L823">			handleException(ex);</span>
<span class="nc" id="L824">			throw ex;</span>
		} finally {
<span class="pc" id="L826">			shiftOTDAO.cleanUp();</span>
<span class="pc" id="L827">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, String&gt; getOTExtensionNamesBySchedulingPeriod(SchedulingPeriod sp) throws BbmFinderException {
<span class="nc" id="L832">		methodStart(&quot;getOTExtensionNamesBySchedulingPeriod&quot;, sp);</span>
<span class="nc" id="L833">		ShiftOTExtensionDAO shiftOTDAO = new ShiftOTExtensionDAO();</span>

		try {
<span class="nc" id="L836">			return shiftOTDAO.getOTExtensionNamesBySchedulingPeriod(sp);</span>
<span class="nc" id="L837">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L838">			handleException(ex);</span>
<span class="nc" id="L839">			throw ex;</span>
		} finally {
<span class="nc" id="L841">			shiftOTDAO.cleanUp();</span>
<span class="nc" id="L842">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;VTOEvent&gt; getVTOEventsByOrgHierarchy(ID orgID, boolean isAscendingSort, int pageIDSize,
			int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs)
			throws BbmFinderException {
<span class="fc" id="L849">		methodStart(&quot;getVTOEventsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>
<span class="fc" id="L850">		VTOEventDAO dao = null;</span>
		try {
<span class="fc" id="L852">			dao = new VTOEventDAO();</span>
<span class="fc" id="L853">			return dao.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap,</span>
					filteredIDs);
<span class="nc" id="L855">		} catch (Exception e) {</span>
<span class="nc" id="L856">			handleException(e);</span>
<span class="nc bnc" id="L857" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L858">				throw (BbmFinderException) e;</span>
<span class="nc" id="L859">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L861" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L862">				dao.cleanUp();</span>
			}
<span class="pc" id="L864">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;VTOEvent&gt; getVTOEventsBySchedulingPeriod(SchedulingPeriod sp, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="nc" id="L871">		methodStart(&quot;getVTOEventsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>
<span class="nc" id="L872">		VTOEventDAO dao = null;</span>
		try {
<span class="nc" id="L874">			dao = new VTOEventDAO();</span>
<span class="nc" id="L875">			return dao.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs);
<span class="nc" id="L877">		} catch (Exception e) {</span>
<span class="nc" id="L878">			handleException(e);</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L880">				throw (BbmFinderException) e;</span>
<span class="nc" id="L881">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L883" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L884">				dao.cleanUp();</span>
<span class="nc" id="L885">			methodFinish();</span>
		}
	}

	public Collection&lt;VTOEvent&gt; getVTOEventsByIDs(Collection&lt;ID&gt; vtoEventIDs) throws BbmFinderException {
<span class="fc" id="L890">		methodStart(&quot;getVTOEventsByIDs&quot;, vtoEventIDs);</span>
<span class="fc" id="L891">		VTOEventDAO dao = new VTOEventDAO();</span>
		try {
<span class="fc" id="L893">			return dao.getObjectsByIDs(vtoEventIDs);</span>
<span class="nc" id="L894">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L895">			handleException(ex);</span>
<span class="nc" id="L896">			throw ex;</span>
		} finally {
<span class="pc" id="L898">			dao.cleanUp();</span>
<span class="pc" id="L899">			methodFinish();</span>
		}
	}

	public VTOEvent getVTOEventByID(ID vtoEventID) throws BbmFinderException {
<span class="nc" id="L904">		methodStart(&quot;getVTOEventsByIDs&quot;, vtoEventID);</span>
<span class="nc" id="L905">		VTOEventDAO dao = new VTOEventDAO();</span>
		try {
<span class="nc" id="L907">			return dao.getObjectByID(vtoEventID);</span>
<span class="nc" id="L908">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L909">			handleException(ex);</span>
<span class="nc" id="L910">			throw ex;</span>
		} finally {
<span class="nc" id="L912">			dao.cleanUp();</span>
<span class="nc" id="L913">			methodFinish();</span>
		}
	}

	public ID createVTOEvent(VTOEvent objValue) throws BbmCreateException, BbmDuplicateExternalIdentException,
			RemoteException {
<span class="fc" id="L919">		methodStart(&quot;createVTOEvent&quot;, objValue);</span>

<span class="fc" id="L921">		VTOEventDAO dao = new VTOEventDAO();</span>
		try {
<span class="fc" id="L923">			objValue.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L924">			objValue.setCreatedDate(new Date(System.currentTimeMillis()));</span>
<span class="fc" id="L925">			objValue.setModifiedBy(null);</span>
<span class="fc" id="L926">			objValue.setModifiedDate(null);</span>
<span class="fc" id="L927">			return DAOEJBUtil.createObject(dao, objValue, this, &quot;createVTOEvent&quot;);</span>
		} finally {
<span class="pc" id="L929">			dao.cleanUp();</span>
<span class="pc" id="L930">			methodFinish();</span>
		}
	}

	public void updateVTOEvents(Collection&lt;VTOEvent&gt; vtoEvents) throws BbmUpdateException {
<span class="nc" id="L935">		methodStart(&quot;updateVTOEvents&quot;, vtoEvents);</span>
<span class="nc" id="L936">		VTOEventDAO vtoDAO = new VTOEventDAO();</span>
		try {
<span class="nc bnc" id="L938" title="All 2 branches missed.">			for (VTOEvent vtotEvent : vtoEvents) {</span>
<span class="nc" id="L939">				vtotEvent.setModifiedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L940">				vtotEvent.setModifiedDate(new Date(System.currentTimeMillis()));</span>
<span class="nc" id="L941">			}</span>
<span class="nc" id="L942">			vtoDAO.updateObjects(vtoEvents);</span>
<span class="nc" id="L943">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L944">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="nc" id="L946">			vtoDAO.cleanUp();</span>
<span class="nc" id="L947">			methodFinish();</span>
<span class="nc" id="L948">		}</span>
<span class="nc" id="L949">	}</span>

	public void deleteVTOEvents(Collection&lt;ID&gt; vtoEventIDs) throws BbmRemoveException, RemoteException {
<span class="fc" id="L952">		methodStart(&quot;deleteVTOEvents&quot;, vtoEventIDs);</span>

<span class="fc" id="L954">		VTOEventDAO vtoDAO = new VTOEventDAO();</span>
		try {
			// No need to set modified by and modified date because the DAOBase
			// method
			// assumes that when deleting via update that there is are
			// DELETEONDATE, MODIFIEDBY
			// and MODIFIED (date) fields on the table.
<span class="fc" id="L961">			vtoDAO.deleteObjectsViaUpdate(vtoEventIDs, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L962">		} catch (Exception ex) {</span>
<span class="nc" id="L963">			handleException(ex);</span>
<span class="nc" id="L964">			throw new BbmRemoveException(ex);</span>
		} finally {
<span class="pc" id="L966">			vtoDAO.cleanUp();</span>
<span class="pc" id="L967">			methodFinish();</span>
<span class="fc" id="L968">		}</span>
<span class="fc" id="L969">	}</span>

	public void copyVTOEvents(Collection&lt;ID&gt; vtoEventIDs, boolean isOrgMode, ID ownerID, LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L973">		methodStart(&quot;copyVTOEvents&quot;, vtoEventIDs, isOrgMode);</span>
<span class="nc" id="L974">		CopyDAO dao = new CopyDAO();</span>
<span class="nc" id="L975">		Collection&lt;VTOEvent&gt; vtoEventsToCopy = getVTOEventsByIDs(vtoEventIDs);</span>

		try {
<span class="nc bnc" id="L978" title="All 2 branches missed.">			for (VTOEvent vtoEvent : vtoEventsToCopy) {</span>
<span class="nc" id="L979">				vtoEvent.setID(null);</span>
<span class="nc" id="L980">				vtoEvent.setModifiedBy(null);</span>
<span class="nc" id="L981">				vtoEvent.setModifiedDate(null);</span>

<span class="nc" id="L983">				vtoEvent.setName(dao.getNewNameForCopiedValueObjectWithLengthLimitation(vtoEvent.getName(), &quot;VTOEVENT&quot;,</span>
						localeContext, VTOEventFieldInfo.VTOEVENT_NAME_MAX_LENGTH));

<span class="nc bnc" id="L986" title="All 2 branches missed.">				if (isOrgMode) {</span>
<span class="nc" id="L987">					vtoEvent.setCampaignID(null);</span>
<span class="nc" id="L988">					vtoEvent.setOrganizationID(ownerID);</span>
				} else {
<span class="nc" id="L990">					vtoEvent.setOrganizationID(null);</span>
<span class="nc" id="L991">					vtoEvent.setCampaignID(ownerID);</span>
				}
<span class="nc" id="L993">				createVTOEvent(vtoEvent);</span>
<span class="nc" id="L994">			}</span>
<span class="nc" id="L995">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L996">			handleException(ex);</span>
<span class="nc" id="L997">			throw ex;</span>
<span class="nc" id="L998">		} catch (BbmDuplicateExternalIdentException ex) {</span>
<span class="nc" id="L999">			handleException(ex);</span>
<span class="nc" id="L1000">			throw ex;</span>
<span class="nc" id="L1001">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1002">			handleException(ex);</span>
<span class="nc" id="L1003">			throw ex;</span>
		} finally {
<span class="nc" id="L1005">			methodFinish();</span>
<span class="nc" id="L1006">		}</span>
<span class="nc" id="L1007">	}</span>

	public HashMap&lt;ID, String&gt; getVTONamesByOrg(ID orgID) throws BbmFinderException {
<span class="fc" id="L1010">		methodStart(&quot;getVTONamesByOrg&quot;, orgID);</span>
<span class="fc" id="L1011">		VTOEventDAO vtoDAO = new VTOEventDAO();</span>

		try {
<span class="fc" id="L1014">			return vtoDAO.getVTONamesByOrg(orgID);</span>
<span class="nc" id="L1015">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1016">			handleException(ex);</span>
<span class="nc" id="L1017">			throw ex;</span>
		} finally {
<span class="pc" id="L1019">			vtoDAO.cleanUp();</span>
<span class="pc" id="L1020">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, String&gt; getVTONamesBySchedulingPeriod(SchedulingPeriod sp) throws BbmFinderException {
<span class="nc" id="L1025">		methodStart(&quot;getVTONamesBySchedulingPeriod&quot;, sp);</span>
<span class="nc" id="L1026">		VTOEventDAO vtoDAO = new VTOEventDAO();</span>

		try {
<span class="nc" id="L1029">			return vtoDAO.getVTONamesBySchedulingPeriod(sp);</span>
<span class="nc" id="L1030">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1031">			handleException(ex);</span>
<span class="nc" id="L1032">			throw ex;</span>
		} finally {
<span class="nc" id="L1034">			vtoDAO.cleanUp();</span>
<span class="nc" id="L1035">			methodFinish();</span>
		}
	}

	/**
	 * Get getCurrentShiftPatternsByOrgHierarchy without filtering by Name,
	 * filterByName =null
	 * 
	 * @param orgID
	 * @param isAscendingSort
	 * @param pageIDSize
	 * @param pageIndex
	 * @param sortFieldMap
	 * @param filteredIDs
	 * @return
	 * @throws BbmFinderException
	 */
	public PaginationPair&lt;ShiftPattern&gt; getCurrentShiftPatternsByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="nc" id="L1055">		methodStart(&quot;getCurrentShiftPatternsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex,</span>
				sortFieldMap);
<span class="nc" id="L1057">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1059">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1060">			return dao.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap,</span>
					filteredIDs, null);
<span class="nc" id="L1062">		} catch (Exception e) {</span>
<span class="nc" id="L1063">			handleException(e);</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1065">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1066">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1068" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1069">				dao.cleanUp();</span>
<span class="nc" id="L1070">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftPattern&gt; getCurrentShiftPatternsByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="fc" id="L1077">		methodStart(&quot;getCurrentShiftPatternsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex,</span>
				filterByName);
<span class="fc" id="L1079">		ShiftPatternDAO dao = null;</span>
		try {
<span class="fc" id="L1081">			dao = new ShiftPatternDAO();</span>
<span class="fc" id="L1082">			return dao.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap,</span>
					filteredIDs, filterByName);
<span class="nc" id="L1084">		} catch (Exception e) {</span>
<span class="nc" id="L1085">			handleException(e);</span>
<span class="nc bnc" id="L1086" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1087">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1088">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1090" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L1091">				dao.cleanUp();</span>
<span class="pc" id="L1092">			methodFinish();</span>
		}
	}

	/**
	 * getCurrentWeeklyShiftPatternsByOrgHierarchy without filtering by Name,
	 * passed filterByName =null
	 * */
	public PaginationPair&lt;ShiftPattern&gt; getCurrentWeeklyShiftPatternsByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="nc" id="L1103">		methodStart(&quot;getCurrentWeeklyShiftPatternsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex,</span>
				sortFieldMap);
<span class="nc" id="L1105">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1107">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1108">			return dao.getCompleteWeeklyPaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, null);
<span class="nc" id="L1110">		} catch (Exception e) {</span>
<span class="nc" id="L1111">			handleException(e);</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1113">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1114">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1116" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1117">				dao.cleanUp();</span>
<span class="nc" id="L1118">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftPattern&gt; getCurrentWeeklyShiftPatternsByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="fc" id="L1125">		methodStart(&quot;getCurrentWeeklyShiftPatternsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex,</span>
				sortFieldMap);
<span class="fc" id="L1127">		ShiftPatternDAO dao = null;</span>
		try {
<span class="fc" id="L1129">			dao = new ShiftPatternDAO();</span>
<span class="fc" id="L1130">			return dao.getCompleteWeeklyPaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, filterByName);
<span class="nc" id="L1132">		} catch (Exception e) {</span>
<span class="nc" id="L1133">			handleException(e);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1135">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1136">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1138" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L1139">				dao.cleanUp();</span>
<span class="pc" id="L1140">			methodFinish();</span>
		}
	}

	/**
	 * Returns the shift patterns defined for a specific organization (excluding
	 * hierarchy org scoped items).
	 * 
	 * @param orgID
	 *            Organization ID
	 * @return Collection collection of shift patterns
	 * @see ShiftPattern
	 * @throws BbmFinderException
	 *             If the organization cannot be found
	 */
	public Collection&lt;ShiftPattern&gt; getCurrentShiftPatternsByOrg(ID orgID) throws BbmFinderException {
<span class="nc" id="L1156">		methodStart(&quot;getCurrentShiftPatternsByOrg&quot;, orgID);</span>
<span class="nc" id="L1157">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1159">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1160">			return dao.getCurrentShiftPatternsByOrg(orgID);</span>
<span class="nc" id="L1161">		} catch (Exception e) {</span>
<span class="nc" id="L1162">			handleException(e);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1164">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1165">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1167" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1168">				dao.cleanUp();</span>
<span class="nc" id="L1169">			methodFinish();</span>
		}
	}

	/**
	 ** Get getCurrentShiftPatternsBySchedulingPeriod without filtering by Name,
	 * filterByName =null
	 * */
	public PaginationPair&lt;ShiftPattern&gt; getCurrentShiftPatternsBySchedulingPeriod(SchedulingPeriod sp,
			boolean isAscendingSort, int pageIDSize, int pageIndex,
			LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs) throws BbmFinderException {
<span class="nc" id="L1180">		methodStart(&quot;getCurrentShiftPatternsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex,</span>
				sortFieldMap);
<span class="nc" id="L1182">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1184">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1185">			return dao.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, null);
<span class="nc" id="L1187">		} catch (Exception e) {</span>
<span class="nc" id="L1188">			handleException(e);</span>
<span class="nc bnc" id="L1189" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1190">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1191">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1193" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1194">				dao.cleanUp();</span>
<span class="nc" id="L1195">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftPattern&gt; getCurrentShiftPatternsBySchedulingPeriod(SchedulingPeriod sp,
			boolean isAscendingSort, int pageIDSize, int pageIndex,
			LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs, String filterByName)
			throws BbmFinderException {
<span class="nc" id="L1203">		methodStart(&quot;getCurrentShiftPatternsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex,</span>
				filterByName);
<span class="nc" id="L1205">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1207">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1208">			return dao.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, filterByName);
<span class="nc" id="L1210">		} catch (Exception e) {</span>
<span class="nc" id="L1211">			handleException(e);</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1213">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1214">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1216" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1217">				dao.cleanUp();</span>
<span class="nc" id="L1218">			methodFinish();</span>
		}
	}

	/**
	 * Returns the shift patterns for a scheduling period that have been defined
	 * in the campaign only (not the organizations that participate).
	 * 
	 * @param sp
	 *            Scheduling period.
	 * @return Collection of shift patterns
	 * @throws BbmFinderException
	 */
	public Collection&lt;ShiftPattern&gt; getCurrentShiftPatternsBySchedulingPeriodCampaignOnly(SchedulingPeriod sp)
			throws BbmFinderException {
<span class="nc" id="L1233">		methodStart(&quot;getCurrentShiftPatternsBySchedulingPeriodCampaignOnly&quot;, sp);</span>
<span class="nc" id="L1234">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1236">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1237">			return dao.getShiftPatternsBySchedulingPeriodCampaignOnly(sp);</span>
<span class="nc" id="L1238">		} catch (Exception e) {</span>
<span class="nc" id="L1239">			handleException(e);</span>
<span class="nc bnc" id="L1240" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L1241">				throw (BbmFinderException) e;</span>
<span class="nc" id="L1242">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1244" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1245">				dao.cleanUp();</span>
<span class="nc" id="L1246">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftPattern&gt; getShiftPatternsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="fc" id="L1251">		methodStart(&quot;getShiftPatternsByIDs&quot;, ids);</span>
<span class="fc" id="L1252">		ShiftPatternDAO dao = new ShiftPatternDAO();</span>
		try {
<span class="fc" id="L1254">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L1255">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1256">			handleException(e);</span>
<span class="nc" id="L1257">			throw e;</span>
<span class="nc" id="L1258">		} catch (Exception e) {</span>
<span class="nc" id="L1259">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1261">			dao.cleanUp();</span>
<span class="pc" id="L1262">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftPattern&gt; getAvailableShiftPatternsForEmployees(Collection&lt;ID&gt; workResourceIDs,
			Date startDate, Date endDate, ID employeeTypeID, SchedulingPeriod selectedSchedulingPeriod,
			boolean isAscendingSort, int pageIDSize, int pageIndex,
			LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs, String filterByName)
			throws BbmFinderException {
<span class="fc" id="L1271">		methodStart(&quot;getAvailableShiftPatternsForEmployees&quot;, workResourceIDs, startDate, endDate, filterByName);</span>
<span class="fc" id="L1272">		ShiftPatternDAO dao = new ShiftPatternDAO();</span>
<span class="fc" id="L1273">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
		try {
<span class="fc" id="L1275">			Collection&lt;ID&gt; employeeOrgsAndParents = null;</span>
<span class="fc" id="L1276">			HashSet&lt;ID&gt; spOrgsAndParents = null;</span>
<span class="pc bpc" id="L1277" title="1 of 2 branches missed.">			if (selectedSchedulingPeriod == null) {</span>
<span class="fc" id="L1278">				employeeOrgsAndParents = getWorkResourceManager().getOrgIDsThatMayOwnFlowDownObjects(workResourceIDs,</span>
						startDate, endDate);
			} else {
<span class="nc" id="L1281">				Collection&lt;ID&gt; linkedOrgs = spDAO.getLinkedOrgsforSP(selectedSchedulingPeriod.getID());</span>
<span class="nc" id="L1282">				spOrgsAndParents = new HashSet&lt;ID&gt;(getWorkResourceManager().getOrganizationsParentsByIDs(linkedOrgs));</span>
<span class="nc" id="L1283">				spOrgsAndParents.addAll(linkedOrgs);</span>
			}
<span class="fc" id="L1285">			return dao.getAvailableShiftPatternsForEmployees(employeeOrgsAndParents, spOrgsAndParents, workResourceIDs,</span>
					startDate, endDate, employeeTypeID, selectedSchedulingPeriod, isAscendingSort, pageIDSize,
					pageIndex, sortFieldMap, filteredIDs, filterByName);
<span class="nc" id="L1288">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1289">			handleException(e);</span>
<span class="nc" id="L1290">			throw e;</span>
<span class="nc" id="L1291">		} catch (Exception e) {</span>
<span class="nc" id="L1292">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1294">			dao.cleanUp();</span>
<span class="pc" id="L1295">			spDAO.cleanUp();</span>
<span class="pc" id="L1296">			methodFinish();</span>
		}
	}

	public ShiftPattern createShiftPattern(ShiftPattern shiftPattern) throws BbmCreateException,
			BbmDuplicateExternalIdentException, RemoteException, BbmDuplicateNameException {
<span class="fc" id="L1302">		methodStart(&quot;createShiftPattern&quot;, shiftPattern);</span>

<span class="fc" id="L1304">		Collection&lt;ID&gt; organizationIDs = new ArrayList&lt;ID&gt;();</span>

<span class="pc bpc" id="L1306" title="1 of 2 branches missed.">		if (shiftPattern.getOrganizationID() != null) {</span>
<span class="fc" id="L1307">			organizationIDs.add(shiftPattern.getOrganizationID());</span>
		}

<span class="fc" id="L1310">		ShiftPatternDAO dao = new ShiftPatternDAO();</span>

		try {
			// build up combined collection representing the full organization
			// path.
<span class="fc" id="L1315">			ArrayList&lt;ID&gt; orgTree = new ArrayList&lt;ID&gt;();</span>
<span class="pc bpc" id="L1316" title="1 of 2 branches missed.">			if (!organizationIDs.isEmpty()) {</span>
<span class="fc" id="L1317">				Collection&lt;ID&gt; orgAncestors = (Collection&lt;ID&gt;) getWorkResourceManager().getOrganizationsParentsByIDs(</span>
						organizationIDs);
<span class="fc" id="L1319">				Collection&lt;ID&gt; orgDescendants = (Collection&lt;ID&gt;) getWorkResourceManager()</span>
<span class="fc" id="L1320">						.getOrganizationsChildrenByIDs(organizationIDs);</span>

<span class="fc bfc" id="L1322" title="All 2 branches covered.">				for (ID orgId : orgAncestors) {</span>
<span class="pc bpc" id="L1323" title="1 of 2 branches missed.">					if (!orgTree.contains(orgId)) {</span>
<span class="fc" id="L1324">						orgTree.add(orgId);</span>
					}
<span class="fc" id="L1326">				}</span>

<span class="fc bfc" id="L1328" title="All 2 branches covered.">				for (ID orgId : orgDescendants) {</span>
<span class="pc bpc" id="L1329" title="1 of 2 branches missed.">					if (!orgTree.contains(orgId)) {</span>
<span class="fc" id="L1330">						orgTree.add(orgId);</span>
					}
<span class="fc" id="L1332">				}</span>
			}

			// include definitions at the current organization
<span class="pc bpc" id="L1336" title="1 of 2 branches missed.">			if (!orgTree.contains(shiftPattern.getOrganizationID())) {</span>
<span class="fc" id="L1337">				orgTree.add(shiftPattern.getOrganizationID());</span>
			}

			// See if the name is already in use within the organization path.
<span class="pc bpc" id="L1341" title="1 of 2 branches missed.">			if (dao.isShiftPatternNameUsed(shiftPattern, orgTree)) {</span>
<span class="nc" id="L1342">				throw new BbmDuplicateNameException(BbmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L1343">						BbmEjbBundleKey.SHIFT_PATTERN_NAME_IN_USE, new Object[] { shiftPattern.getName() });</span>
			}

<span class="fc" id="L1346">			shiftPattern.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L1347">			shiftPattern.setCreatedDate(new Date(System.currentTimeMillis()));</span>
<span class="fc" id="L1348">			shiftPattern.setModifiedBy(null);</span>
<span class="fc" id="L1349">			shiftPattern.setCreatedDate(null);</span>
<span class="fc" id="L1350">			dao.createObject(shiftPattern);</span>
<span class="fc" id="L1351">			return shiftPattern;</span>
<span class="nc" id="L1352">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1353">			handleException(e);</span>
<span class="nc" id="L1354">			throw e;</span>
<span class="nc" id="L1355">		} catch (BbmDuplicateNameException e) {</span>
<span class="nc" id="L1356">			throw e;</span>
<span class="nc" id="L1357">		} catch (Exception e) {</span>
<span class="nc" id="L1358">			handleException(e);</span>
<span class="nc" id="L1359">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1361">			dao.cleanUp();</span>
<span class="pc" id="L1362">			methodFinish();</span>
		}
	}

	public void updateShiftPatterns(Collection&lt;ShiftPattern&gt; shiftPatterns) throws BbmUpdateException,
			BbmDuplicateNameException {
<span class="fc" id="L1368">		methodStart(&quot;updateShiftPatterns&quot;, shiftPatterns);</span>
<span class="fc" id="L1369">		ShiftPatternDAO dao = new ShiftPatternDAO();</span>
<span class="fc" id="L1370">		String modifiedBy = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L1371">		Date modifiedDate = new Date(System.currentTimeMillis());</span>
		try {
<span class="fc bfc" id="L1373" title="All 2 branches covered.">			for (ShiftPattern pattern : shiftPatterns) {</span>
<span class="fc" id="L1374">				Collection&lt;ID&gt; organizationIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L1375">				organizationIDs.add(pattern.getOrganizationID());</span>

<span class="fc" id="L1377">				Collection orgAncestors = getWorkResourceManager().getOrganizationsParentsByIDs(organizationIDs);</span>
<span class="fc" id="L1378">				Collection orgDescendants = getWorkResourceManager().getOrganizationsChildrenByIDs(organizationIDs);</span>

				// build up combined collection representing the full
				// organization path.
<span class="fc" id="L1382">				HashSet&lt;ID&gt; orgTree = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L1383">				orgTree.addAll(orgAncestors);</span>
<span class="fc" id="L1384">				orgTree.addAll(orgDescendants);</span>
<span class="fc" id="L1385">				orgTree.add(pattern.getOrganizationID());</span>

				// See if the name is already in use within the organization
				// path.
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">				if (dao.isShiftPatternNameUsed(pattern, orgTree)) {</span>
<span class="nc" id="L1390">					throw new BbmDuplicateNameException(BbmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L1391">							BbmEjbBundleKey.SHIFT_PATTERN_NAME_IN_USE, new Object[] { pattern.getName() });</span>
				}

<span class="fc" id="L1394">				pattern.setModifiedBy(modifiedBy);</span>
<span class="fc" id="L1395">				pattern.setModifiedDate(modifiedDate);</span>
<span class="fc" id="L1396">			}</span>
<span class="fc" id="L1397">			dao.updateObjects(shiftPatterns);</span>
<span class="nc" id="L1398">		} catch (BbmUpdateException ex) {</span>
<span class="nc" id="L1399">			handleException(ex);</span>
<span class="nc" id="L1400">			throw ex;</span>
<span class="nc" id="L1401">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L1402">			handleException(ex);</span>
<span class="nc" id="L1403">			throw new BbmUpdateException(ex);</span>
<span class="nc" id="L1404">		} catch (BbmDuplicateNameException e) {</span>
<span class="nc" id="L1405">			throw e;</span>
<span class="nc" id="L1406">		} catch (Exception e) {</span>
<span class="nc" id="L1407">			handleException(e);</span>
<span class="nc" id="L1408">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc" id="L1410">			dao.cleanUp();</span>
<span class="pc" id="L1411">			methodFinish();</span>
<span class="fc" id="L1412">		}</span>
<span class="fc" id="L1413">	}</span>

	public void deleteShiftPatterns(Collection&lt;ID&gt; shiftPatternIDs) throws BbmRemoveException {
<span class="fc" id="L1416">		methodStart(&quot;deleteShiftPatterns&quot;, shiftPatternIDs);</span>
<span class="fc" id="L1417">		ShiftPatternDAO shiftPatternDAO = new ShiftPatternDAO();</span>
		try {
			// No need to set modified by and modified date because the DAOBase
			// method
			// assumes that when deleting via update that there is are
			// DELETEONDATE, MODIFIEDBY
			// and MODIFIED (date) fields on the table.
<span class="fc" id="L1424">			shiftPatternDAO.deleteObjectsViaUpdate(shiftPatternIDs, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L1425">		} catch (BbmRemoveException ex) {</span>
<span class="nc" id="L1426">			handleException(ex);</span>
<span class="nc" id="L1427">			throw ex;</span>
		} finally {
<span class="pc" id="L1429">			shiftPatternDAO.cleanUp();</span>
<span class="pc" id="L1430">			methodFinish();</span>
<span class="fc" id="L1431">		}</span>
<span class="fc" id="L1432">	}</span>

	public void copyShiftPatterns(Collection&lt;ID&gt; shiftPatternIDs, boolean isOrgMode, ID ownerID,
			LocaleContext localeContext) throws BbmCreateException, BbmDuplicateExternalIdentException,
			BbmFinderException, RemoteException {
<span class="nc" id="L1437">		methodStart(&quot;copyShiftPatterns&quot;, shiftPatternIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L1438">		ShiftPatternDAO dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1439">		dao.setIsByOrg(isOrgMode);</span>
<span class="nc" id="L1440">		dao.setOwnerID(ownerID);</span>
<span class="nc" id="L1441">		dao.setLocaleContext(localeContext);</span>

		try {
<span class="nc" id="L1444">			dao.copyObjects(dao.getObjectsByIDs(shiftPatternIDs));</span>
<span class="nc" id="L1445">		} catch (WorkRuleExcessiveNameLengthException ex) {</span>
<span class="nc" id="L1446">			handleException(ex);</span>
<span class="nc" id="L1447">			throw ex;</span>
<span class="nc" id="L1448">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L1449">			handleException(ex);</span>
<span class="nc" id="L1450">			throw ex;</span>
<span class="nc" id="L1451">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1452">			handleException(ex);</span>
<span class="nc" id="L1453">			throw ex;</span>
		} finally {
<span class="nc" id="L1455">			methodFinish();</span>
<span class="nc" id="L1456">		}</span>
<span class="nc" id="L1457">	}</span>

	private Collection&lt;ID&gt; getOrganizationIDList(Jdmo dmo, Collection&lt;ID&gt; empIDs, Date start, Date end)
			throws Exception {
<span class="fc" id="L1461">		HashSet&lt;ID&gt; orgIDs = new HashSet&lt;ID&gt;();</span>
		// find the org assignment for all the emp in the specific time period
<span class="fc" id="L1463">		StringBuffer sb = new StringBuffer(200);</span>
<span class="fc" id="L1464">		sb.append(&quot;select organizationid from workresourceorganization where starttime &lt; '&quot;)</span>
<span class="fc" id="L1465">				.append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
<span class="fc" id="L1466">		sb.append(&quot; and (endtime is null or endtime &gt; '&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;')&quot;);</span>
<span class="fc" id="L1467">		sb.append(&quot; and workresourceid in &quot;).append(dmo.createInClause(empIDs));</span>

<span class="fc" id="L1469">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="fc bfc" id="L1470" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L1471">			orgIDs.add(rs.getID(1));</span>
		}
<span class="fc" id="L1473">		orgIDs.addAll(getWorkResourceManager().getOrganizationsParentsByIDs(orgIDs));</span>
<span class="fc" id="L1474">		return orgIDs;</span>
	}

	private WorkResourceManager getWorkResourceManager() throws Exception {
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">		if (m_workResourceManager == null)</span>
<span class="nc" id="L1479">			m_workResourceManager = BbmManagerFactory.getWorkResourceManager(m_isWhatIf);</span>
<span class="fc" id="L1480">		return m_workResourceManager;</span>
	}

	private ActivityManager getActivityManager() throws Exception {
<span class="fc bfc" id="L1484" title="All 2 branches covered.">		if (m_activityManager == null)</span>
<span class="fc" id="L1485">			m_activityManager = WfmManagerFactory.getActivityManager(m_isWhatIf);</span>
<span class="fc" id="L1486">		return m_activityManager;</span>
	}

	private CampaignManager getCampaignManager() throws Exception {
<span class="pc bpc" id="L1490" title="1 of 2 branches missed.">		if (m_campaignManager == null)</span>
<span class="nc" id="L1491">			m_campaignManager = WfmManagerFactory.getCampaignManager(m_isWhatIf);</span>
<span class="fc" id="L1492">		return m_campaignManager;</span>
	}

	public Collection getAllTimeBanks() throws BbmFinderException, RemoteException {
<span class="nc" id="L1496">		methodStart(&quot;getAllTimeBanks&quot;);</span>
<span class="nc" id="L1497">		TimeBankDAO dao = null;</span>
		try {
<span class="nc" id="L1499">			dao = new TimeBankDAO();</span>
<span class="nc" id="L1500">			return dao.getObjects(&quot;&quot;);</span>
<span class="nc" id="L1501">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1502">			handleException(e);</span>
<span class="nc" id="L1503">			throw e;</span>
		} finally {
<span class="nc bnc" id="L1505" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1506">				dao.cleanUp();</span>
<span class="nc" id="L1507">			methodFinish();</span>
		}
	}

	public TimeBank getTimeBank(ID idTimeBank) throws BbmFinderException, RemoteException {
<span class="nc" id="L1512">		methodStart(&quot;getTimeBank&quot;, idTimeBank);</span>
<span class="nc" id="L1513">		TimeBankDAO dao = null;</span>
		try {
<span class="nc" id="L1515">			dao = new TimeBankDAO();</span>
<span class="nc" id="L1516">			return (TimeBank) dao.getObjectByID(idTimeBank);</span>
<span class="nc" id="L1517">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1518">			handleException(e);</span>
<span class="nc" id="L1519">			throw e;</span>
		} finally {
<span class="nc bnc" id="L1521" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1522">				dao.cleanUp();</span>
<span class="nc" id="L1523">			methodFinish();</span>
		}
	}

	public Collection&lt;TimeBank&gt; getTimeBanks(Collection&lt;ID&gt; timeBankIDs) throws BbmFinderException, RemoteException {
<span class="fc" id="L1528">		methodStart(&quot;getTimeBanks&quot;, timeBankIDs);</span>
<span class="fc" id="L1529">		TimeBankDAO dao = null;</span>
		try {
<span class="fc" id="L1531">			dao = new TimeBankDAO();</span>
<span class="fc" id="L1532">			return (Collection&lt;TimeBank&gt;) dao.getObjectsByIDs(timeBankIDs);</span>
<span class="nc" id="L1533">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1534">			handleException(e);</span>
<span class="nc" id="L1535">			throw e;</span>
		} finally {
<span class="pc bpc" id="L1537" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L1538">				dao.cleanUp();</span>
<span class="pc" id="L1539">			methodFinish();</span>
		}
	}

	/**
	 * Persists a newly created instance of a time bank in the database.
	 * 
	 */
	public ID createTimeBank(TimeBank tb) throws BbmCreateException, RemoteException {
<span class="nc" id="L1548">		methodStart(&quot;getTimeBank&quot;, tb);</span>
<span class="nc" id="L1549">		TimeBankDAO dao = null;</span>
		try {
<span class="nc" id="L1551">			dao = new TimeBankDAO();</span>
<span class="nc" id="L1552">			return dao.createObject(tb);</span>
<span class="nc" id="L1553">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1554">			throw e;</span>
		} finally {
<span class="nc bnc" id="L1556" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1557">				dao.cleanUp();</span>
<span class="nc" id="L1558">			methodFinish();</span>
		}
	}

	public Collection getTimeBanksForOrganization(ID orgID) throws BbmFinderException, RemoteException {
<span class="nc" id="L1563">		return getTimeBanksForOrganizations(new ArrayList(Arrays.asList(orgID)), true);</span>
	}

	public Collection getTimeBanksForOrganizations(Collection orgIds, boolean findParentOrgs)
			throws BbmFinderException, RemoteException {
<span class="nc" id="L1568">		methodStart(&quot;getTimeBanksForOrganizations&quot;, orgIds, new Boolean(findParentOrgs));</span>
<span class="nc" id="L1569">		Jdmo dmo = new Jdmo(true);</span>
		try {
			Collection listOrgs;
<span class="nc bnc" id="L1572" title="All 2 branches missed.">			if (findParentOrgs)</span>
<span class="nc" id="L1573">				listOrgs = DAOUtil.getParentOrganizationsCollection(orgIds, dmo);</span>
			else
<span class="nc" id="L1575">				listOrgs = orgIds;</span>
<span class="nc" id="L1576">			listOrgs.addAll(orgIds);</span>
<span class="nc" id="L1577">			ArrayList listTimeBanks = new ArrayList();</span>
<span class="nc" id="L1578">			ArrayList allTimeBanks = (ArrayList) getAllTimeBanks();</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">			for (Iterator it = allTimeBanks.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1580">				TimeBank tb = (TimeBank) it.next();</span>
<span class="nc bnc" id="L1581" title="All 2 branches missed.">				if (listOrgs.contains(tb.getOrganizationID()))</span>
<span class="nc" id="L1582">					listTimeBanks.add(tb);</span>
<span class="nc" id="L1583">			}</span>
<span class="nc" id="L1584">			return listTimeBanks;</span>
<span class="nc" id="L1585">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1586">			handleException(e);</span>
<span class="nc" id="L1587">			throw e;</span>
		} finally {
<span class="nc" id="L1589">			dmo.cleanUp();</span>
<span class="nc" id="L1590">			methodFinish();</span>
		}
	}

	public void deleteTimeBank(ID idTimeBank) throws RemoteException, BbmRemoveException {
<span class="nc" id="L1595">		methodStart(&quot;deleteTimeBank&quot;, idTimeBank);</span>
<span class="nc" id="L1596">		TimeBankDAO dao = new TimeBankDAO();</span>
		try {
<span class="nc" id="L1598">			dao.deleteObject(idTimeBank);</span>
<span class="nc" id="L1599">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1600">			handleException(e);</span>
<span class="nc" id="L1601">			throw e;</span>
		} finally {
<span class="nc" id="L1603">			dao.cleanUp();</span>
<span class="nc" id="L1604">			methodFinish();</span>
<span class="nc" id="L1605">		}</span>
<span class="nc" id="L1606">	}</span>

	public void updateTimeBank(TimeBank tb) throws BbmUpdateException, MultiUserException, RemoteException {
<span class="nc" id="L1609">		methodStart(&quot;updateTimeBank&quot;, tb);</span>
<span class="nc" id="L1610">		TimeBankDAO dao = new TimeBankDAO();</span>
		try {
<span class="nc" id="L1612">			tb.setDeleteChildrenBeforeCreate(TimeBankFieldInfo.CHILD_TARGETMINS);</span>
<span class="nc" id="L1613">			tb.setDeleteChildrenBeforeCreate(TimeBankFieldInfo.CHILD_INTERPERIOD);</span>
<span class="nc" id="L1614">			dao.updateObject(tb);</span>
<span class="nc" id="L1615">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1616">			handleException(e);</span>
<span class="nc" id="L1617">			throw e;</span>
		} finally {
<span class="nc" id="L1619">			dao.cleanUp();</span>
<span class="nc" id="L1620">			methodFinish();</span>
<span class="nc" id="L1621">		}</span>
<span class="nc" id="L1622">	}</span>

	public ComplexWorkRule getComplexWorkRuleByID(ID idWorkRule) throws WorkRuleException, BbmFinderException {
<span class="nc" id="L1625">		methodStart(&quot;getComplexWorkRuleByID&quot;, idWorkRule);</span>
<span class="nc" id="L1626">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="nc" id="L1628">			ArrayList&lt;ID&gt; ids = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L1629">			ids.add(idWorkRule);</span>

<span class="nc" id="L1631">			Collection rules = dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L1632">			return (ComplexWorkRule) rules.iterator().next();</span>
			// return (ComplexWorkRule) dao.getObjectByID(idWorkRule); it is not
			// loading relationship, larry chase,
			// please take a look
<span class="nc" id="L1636">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1637">			handleException(e);</span>
<span class="nc" id="L1638">			throw e;</span>
		} finally {
<span class="nc bnc" id="L1640" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1641">				dao.cleanUp();</span>
<span class="nc" id="L1642">			methodFinish();</span>
		}
	}

	public Collection&lt;ComplexWorkRule&gt; getComplexWorkRulesByIDs(Collection&lt;ID&gt; workRuleIDs) throws WorkRuleException,
			BbmFinderException {
<span class="fc" id="L1648">		methodStart(&quot;getComplexWorkRulesByIDs&quot;, workRuleIDs);</span>
<span class="fc" id="L1649">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="fc" id="L1651">			return dao.getObjectsByIDs(workRuleIDs);</span>
<span class="nc" id="L1652">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1653">			handleException(e);</span>
<span class="nc" id="L1654">			throw e;</span>
		} finally {
<span class="pc bpc" id="L1656" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L1657">				dao.cleanUp();</span>
<span class="pc" id="L1658">			methodFinish();</span>
		}
	}

	public Collection&lt;Rotation&gt; getRotationsByIDs(Collection&lt;ID&gt; rotationIDs) throws WorkRuleException,
			BbmFinderException {
<span class="fc" id="L1664">		methodStart(&quot;getRotationsByIDs&quot;, rotationIDs);</span>
<span class="fc" id="L1665">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="fc" id="L1667">			return dao.getObjectsByIDs(rotationIDs);</span>
<span class="nc" id="L1668">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1669">			handleException(e);</span>
<span class="nc" id="L1670">			throw e;</span>
		} finally {
<span class="pc bpc" id="L1672" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L1673">				dao.cleanUp();</span>
<span class="pc" id="L1674">			methodFinish();</span>
		}
	}

	/**
	 * Retrieves Rotations for given org and its ancestors, not filtering by
	 * Name
	 * 
	 * @param selectedOrgID
	 * @param pageSize
	 * @param pageIndex
	 * @param sortFields
	 * @param isAscending
	 * @return
	 * @throws BbmFinderException
	 */
	public PaginationPair&lt;Rotation&gt; getRotationsForOrgAndAncestors(ID selectedOrgID, int pageSize, int pageIndex,
			LinkedHashMap&lt;RotationSortField, Comparator&gt; sortFields, boolean isAscending) throws BbmFinderException {

<span class="nc" id="L1693">		methodStart(&quot;getRotationsForOrgAndAncestors&quot;, selectedOrgID, pageSize, pageIndex);</span>
<span class="nc" id="L1694">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="nc" id="L1696">			StringBuffer whereClause = new StringBuffer();</span>
<span class="nc" id="L1697">			whereClause.append(&quot;ORGANIZATIONID IN (SELECT ID from FN_TF_CF_getParentOrgsIncludingChild(&quot;)</span>
<span class="nc" id="L1698">					.append(JdmoUtil.asSqlLiteral(selectedOrgID)).append(&quot;) )&quot;);</span>
<span class="nc" id="L1699">			return dao.getCompletePaginationDataSet(whereClause.toString(), isAscending, pageSize, pageIndex,</span>
					new LinkedHashMap&lt;DBSortField, Comparator&gt;(sortFields), new LinkedList&lt;ID&gt;());
		} finally {
<span class="nc" id="L1702">			dao.cleanUp();</span>
<span class="nc" id="L1703">			methodFinish();</span>
		}
	}

	/**
	 * Retrieves Rotations for given org and its ancestors, support filtering by
	 * Name
	 * 
	 * @param selectedOrgID
	 * @param pageSize
	 * @param pageIndex
	 * @param sortFields
	 * @param isAscending
	 * @param filterByName
	 * @return
	 * @throws BbmFinderException
	 */
	public PaginationPair&lt;Rotation&gt; getRotationsForOrgAndAncestors(ID selectedOrgID, int pageSize, int pageIndex,
			LinkedHashMap&lt;RotationSortField, Comparator&gt; sortFields, boolean isAscending, String filterByName)
			throws BbmFinderException {

<span class="fc" id="L1724">		methodStart(&quot;getRotationsForOrgAndAncestors&quot;, selectedOrgID, pageSize, pageIndex, isAscending, filterByName);</span>
<span class="fc" id="L1725">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="fc" id="L1727">			return dao.getRotationsForOrgAndAncestors(selectedOrgID, pageSize, pageIndex, sortFields, isAscending,</span>
					filterByName);
		} finally {
<span class="pc" id="L1730">			dao.cleanUp();</span>
<span class="pc" id="L1731">			methodFinish();</span>
		}
	}

	public Collection&lt;RotationValidationError&gt; validate(Rotation rotation) throws BbmFinderException {
<span class="fc" id="L1736">		methodStart(&quot;validate&quot;, rotation);</span>
<span class="fc" id="L1737">		OrganizationDAO oDao = new OrganizationDAO();</span>
		try {
<span class="fc" id="L1739">			Collection&lt;RotationValidationError&gt; retVal = new LinkedHashSet&lt;RotationValidationError&gt;();</span>

			// Owner Org
<span class="pc bpc" id="L1742" title="1 of 2 branches missed.">			boolean orgSpecified = rotation.getOrganizationID() != null;</span>
<span class="pc bpc" id="L1743" title="1 of 2 branches missed.">			if (!orgSpecified)</span>
<span class="nc" id="L1744">				retVal.add(RotationValidationError.OwnerOrgNotSpecified);</span>

			// Alignment Date
<span class="pc bpc" id="L1747" title="1 of 2 branches missed.">			boolean alignmentDateSpecified = rotation.getAlignmentDate() != null;</span>
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">			if (!alignmentDateSpecified)</span>
<span class="nc" id="L1749">				retVal.add(RotationValidationError.AlignmentDateNotSpecified);</span>

			// Alignment Date Aligned with week start
<span class="pc bpc" id="L1752" title="2 of 4 branches missed.">			if (orgSpecified &amp;&amp; alignmentDateSpecified) {</span>
<span class="fc" id="L1753">				Organization o = getWorkResourceManager().getOrganizationByID(rotation.getOrganizationID());</span>
<span class="fc" id="L1754">				Calendar c = Calendar.getInstance(o.getTimeZone());</span>
<span class="fc" id="L1755">				c.setTime(rotation.getAlignmentDate().getTime(o.getTimeZone()));</span>
<span class="pc bpc" id="L1756" title="1 of 2 branches missed.">				if (c.get(Calendar.DAY_OF_WEEK) != o.getWeekStartDate()) {</span>
<span class="nc" id="L1757">					retVal.add(RotationValidationError.AlignmentDateNotAlignedWithWeekStart);</span>
				}
			}

			// Name Required
<span class="pc bpc" id="L1762" title="1 of 2 branches missed.">			if (StringUtil.isEmpty(rotation.getName()))</span>
<span class="nc" id="L1763">				retVal.add(RotationValidationError.NameNotSpecified);</span>

			// Name Duplicate
<span class="pc bpc" id="L1766" title="1 of 2 branches missed.">			if (orgSpecified) {</span>
<span class="fc" id="L1767">				Jdmo dmo = oDao.getDMO();</span>
				// query rotation names instead of the whole object
<span class="fc" id="L1769">				String query = &quot;SELECT NAME, SID FROM COMPLEXWORKRULE A WHERE (ORGANIZATIONID IN (SELECT ID from FN_TF_CF_getParentOrgsIncludingChild(&quot;</span>
<span class="fc" id="L1770">						+ rotation.getOrganizationID()</span>
						+ &quot;) )) AND WORKUNITCOUNTCONSTRAINT = 6 and name = &quot;
<span class="fc" id="L1772">						+ JdmoUtil.asSqlLiteral(rotation.getName());</span>
<span class="fc" id="L1773">				JdmoRowset rs = dmo.createRowset(query);</span>
<span class="pc bpc" id="L1774" title="1 of 2 branches missed.">				while (rs.next()) {</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">					if (!rs.getID(2).equals(rotation.getID())) {</span>
<span class="nc" id="L1776">						retVal.add(RotationValidationError.NameMustBeUnique);</span>
<span class="nc" id="L1777">						break;</span>
					}
				}
			}
			// Shift Patterns
<span class="pc bpc" id="L1782" title="1 of 2 branches missed.">			if (rotation.getShiftPatterns().size() &gt; 52) {</span>
<span class="nc" id="L1783">				retVal.add(RotationValidationError.TooManyWorkPatterns);</span>
			}
<span class="pc bpc" id="L1785" title="1 of 2 branches missed.">			if (rotation.getShiftPatterns().size() &lt; 2) {</span>
<span class="nc" id="L1786">				retVal.add(RotationValidationError.NotEnoughWorkPatterns);</span>
			}

<span class="fc" id="L1789">			return retVal;</span>
<span class="nc" id="L1790">		} catch (RemoteException ex) {</span>
<span class="nc" id="L1791">			throw new BbmFinderException(ex);</span>

<span class="nc" id="L1793">		} catch (Exception ex) {</span>
<span class="nc" id="L1794">			throw new BbmFinderException(ex);</span>
		} finally {
<span class="pc" id="L1796">			methodFinish();</span>
		}
	}

	private void printGAG() {
		// remove this method this is for testing :)
<span class="nc" id="L1802">		System.out.println(&quot;Added for testing. Please remove it.&quot;);</span>
<span class="nc" id="L1803">	}</span>

	public void deleteRotations(Collection&lt;ID&gt; rotationIDs) throws BbmRemoveException, RemoteException {
<span class="nc" id="L1806">		methodStart(&quot;deleteRotations&quot;, rotationIDs);</span>
<span class="nc" id="L1807">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="nc" id="L1809">			dao.deleteObjects(rotationIDs);</span>
<span class="nc" id="L1810">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1811">			throw e;</span>
<span class="nc" id="L1812">		} catch (Exception e) {</span>
<span class="nc" id="L1813">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L1815">			dao.cleanUp();</span>
<span class="nc" id="L1816">			methodFinish();</span>
<span class="nc" id="L1817">		}</span>
<span class="nc" id="L1818">	}</span>

	public void copyRotationsToOrg(Collection&lt;ID&gt; rotationIDs, ID orgID, LocaleContext localeContext)
			throws BbmCreateException, RemoteException {
<span class="nc" id="L1822">		methodStart(&quot;copyRotationsToOrg&quot;, rotationIDs, orgID);</span>
<span class="nc" id="L1823">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="nc" id="L1825">			Organization org = getWorkResourceManager().getOrganizationByID(orgID);</span>
<span class="nc" id="L1826">			dao.copyToOrg(rotationIDs, org, localeContext);</span>
<span class="nc" id="L1827">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1828">			throw e;</span>
<span class="nc" id="L1829">		} catch (Exception e) {</span>
<span class="nc" id="L1830">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1832">			dao.cleanUp();</span>
<span class="nc" id="L1833">			methodFinish();</span>
<span class="nc" id="L1834">		}</span>
<span class="nc" id="L1835">	}</span>

	private void checkPermissionsToEditAssignmentRules(Collection&lt;ID&gt; assignmentRuleIDs) throws SecurityException,
			BPException, RemoteException {
<span class="nc" id="L1839">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="nc" id="L1841">			Collection&lt;ComplexWorkRule&gt; cwrs = dao.getObjectsByIDs(assignmentRuleIDs);</span>
<span class="nc" id="L1842">			HashSet&lt;ID&gt; orgIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">			for (ComplexWorkRule cwr : cwrs)</span>
<span class="nc" id="L1844">				orgIDs.add(cwr.getOrganizationID());</span>
<span class="nc" id="L1845">			checkPermissionsToEditWorkRules(orgIDs);</span>
		} finally {
<span class="nc" id="L1847">			dao.cleanUp();</span>
<span class="nc" id="L1848">		}</span>
<span class="nc" id="L1849">	}</span>

	// return a list of shift pattern in right order
	public Collection getShiftPatternByWorkUnitID(ID workUnitID) throws BbmFinderException {
<span class="nc" id="L1853">		methodStart(&quot;getShiftPatternByWorkUnitID&quot;, workUnitID);</span>
<span class="nc" id="L1854">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L1856">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L1857">			StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L1858">			sb.append(&quot; A.ID IN (select shiftpatternid from workunitshiftpattern where workunitid = '&quot;)</span>
<span class="nc" id="L1859">					.append(workUnitID).append(&quot;'&quot;).append(&quot;)&quot;);</span>
<span class="nc" id="L1860">			Collection shiftPatterns = dao.getObjects(sb.toString());</span>
<span class="nc" id="L1861">			HashMap shiftPatternIDObjectMap = ValueObjectUtil.getIDObjectMap(shiftPatterns);</span>

			// apply the order
<span class="nc" id="L1864">			sb = new StringBuffer(200);</span>
<span class="nc" id="L1865">			sb.append(</span>
					&quot;select a.sid from shiftpattern a, workunitshiftpattern b where a.id = b.shiftpatternid and b.workunitid = '&quot;)
<span class="nc" id="L1867">					.append(workUnitID).append(&quot;'&quot;).append(&quot; order by b.week&quot;);</span>
<span class="nc" id="L1868">			JdmoRowset rs = dao.getDMO().createRowset(sb.toString());</span>
<span class="nc" id="L1869">			ArrayList list = new ArrayList();</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1871">				list.add(shiftPatternIDObjectMap.get(rs.getID(1)));</span>
			}
<span class="nc" id="L1873">			return list;</span>
<span class="nc" id="L1874">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1875">			handleException(e);</span>
<span class="nc" id="L1876">			throw e;</span>
<span class="nc" id="L1877">		} catch (Exception e) {</span>
<span class="nc" id="L1878">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1880" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L1881">				dao.cleanUp();</span>
<span class="nc" id="L1882">			methodFinish();</span>
		}
	}

	public void deleteShifts(Collection&lt;ID&gt; shiftIDs) throws BbmRemoveException {
<span class="fc" id="L1887">		methodStart(&quot;deleteShifts&quot;, shiftIDs);</span>
<span class="fc" id="L1888">		ShiftDAO shiftDAO = new ShiftDAO();</span>
		try {
			// No need to set modified by and modified date because the DAOBase
			// method
			// assumes that when deleting via update that there is are
			// DELETEONDATE, MODIFIEDBY
			// and MODIFIED (date) fields on the table.
<span class="fc" id="L1895">			shiftDAO.deleteObjectsViaUpdate(shiftIDs, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L1896">		} catch (BbmRemoveException ex) {</span>
<span class="nc" id="L1897">			handleException(ex);</span>
<span class="nc" id="L1898">			throw ex;</span>
		} finally {
<span class="pc" id="L1900">			shiftDAO.cleanUp();</span>
<span class="pc" id="L1901">			methodFinish();</span>
<span class="fc" id="L1902">		}</span>
<span class="fc" id="L1903">	}</span>

	public HashMap&lt;ID, String&gt; getShiftNamesByOrg(ID orgID) throws BbmFinderException {
<span class="fc" id="L1906">		methodStart(&quot;getShiftNamesByOrg&quot;, orgID);</span>
<span class="fc" id="L1907">		ShiftDAO shiftDAO = new ShiftDAO();</span>

		try {
<span class="fc" id="L1910">			return shiftDAO.getShiftNamesByOrg(orgID);</span>
<span class="nc" id="L1911">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1912">			handleException(ex);</span>
<span class="nc" id="L1913">			throw ex;</span>
		} finally {
<span class="pc" id="L1915">			shiftDAO.cleanUp();</span>
<span class="pc" id="L1916">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, String&gt; getShiftNamesBySchedulingPeriod(SchedulingPeriod sp) throws BbmFinderException {
<span class="nc" id="L1921">		methodStart(&quot;getShiftNamesBySchedulingPeriod&quot;, sp);</span>
<span class="nc" id="L1922">		ShiftDAO shiftDAO = new ShiftDAO();</span>

		try {
<span class="nc" id="L1925">			return shiftDAO.getShiftNamesBySchedulingPeriod(sp);</span>
<span class="nc" id="L1926">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1927">			handleException(ex);</span>
<span class="nc" id="L1928">			throw ex;</span>
		} finally {
<span class="nc" id="L1930">			shiftDAO.cleanUp();</span>
<span class="nc" id="L1931">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;Shift&gt; getCurrentShiftsByOrgHierarchy(ID orgID, boolean isAscendingSort, int pageIDSize,
			int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; comparators, Collection&lt;ID&gt; filteredIDs,
			String filterByName) throws BbmFinderException {
<span class="fc" id="L1938">		methodStart(&quot;getCurrentShiftsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, comparators);</span>
<span class="fc" id="L1939">		ShiftDAO shiftDAO = new ShiftDAO();</span>

		try {
<span class="fc" id="L1942">			return shiftDAO.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					comparators, filteredIDs, filterByName);
<span class="nc" id="L1944">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1945">			handleException(ex);</span>
<span class="nc" id="L1946">			throw ex;</span>
		} finally {
<span class="pc" id="L1948">			shiftDAO.cleanUp();</span>
<span class="pc" id="L1949">			methodFinish();</span>
		}
	}

	/**
	 * Returns the currently active shifts for an organization hierarchy
	 * 
	 * @param orgID
	 * @return
	 */
	public Collection&lt;Shift&gt; getCurrentShiftsByOrgHierarchy(ID orgID) throws BbmFinderException {
<span class="nc" id="L1960">		methodStart(&quot;getCurrentShiftsByOrgHierarchy&quot;, orgID);</span>
<span class="nc" id="L1961">		ShiftDAO shiftDAO = new ShiftDAO();</span>
		try {
<span class="nc" id="L1963">			return shiftDAO.getObjects(DAOUtil.getCurrentObjectsByOrgHierarchySQLString(orgID));</span>
<span class="nc" id="L1964">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1965">			handleException(ex);</span>
<span class="nc" id="L1966">			throw ex;</span>
		} finally {
<span class="nc" id="L1968">			shiftDAO.cleanUp();</span>
<span class="nc" id="L1969">			methodFinish();</span>
		}
	}

	/**
	 * Returns the shifts for a specific organization scope absent of inherited
	 * shift definitions from the hierarchy.
	 * 
	 * @param orgID
	 *            Organization ID
	 * @return Collection of Shifts
	 * @throws BbmFinderException
	 * @see Shift
	 */
	public Collection&lt;Shift&gt; getCurrentShiftsByOrg(ID orgID) throws BbmFinderException {
<span class="nc" id="L1984">		methodStart(&quot;getCurrentShiftsByOrg&quot;, orgID);</span>
<span class="nc" id="L1985">		ShiftDAO shiftDAO = new ShiftDAO();</span>
		try {
<span class="nc" id="L1987">			return shiftDAO.getObjects(DAOUtil.getCurrentObjectsByOrgSQLString(orgID));</span>
<span class="nc" id="L1988">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L1989">			handleException(ex);</span>
<span class="nc" id="L1990">			throw ex;</span>
		} finally {
<span class="nc" id="L1992">			shiftDAO.cleanUp();</span>
<span class="nc" id="L1993">			methodFinish();</span>
		}
	}

	/**
	 * Returns the currently active shifts for a schedule period
	 * 
	 * @param schedulingPeriod
	 *            Scheduling period
	 * @return Collection of shifts
	 * @see Shift
	 */
	public Collection&lt;Shift&gt; getCurrentShiftsBySchedulingPeriod(SchedulingPeriod schedulingPeriod)
			throws BbmFinderException {
<span class="nc" id="L2007">		methodStart(&quot;getCurrentShiftsBySchedulingPeriod&quot;, schedulingPeriod);</span>
<span class="nc" id="L2008">		ShiftDAO shiftDAO = new ShiftDAO();</span>
		try {
<span class="nc" id="L2010">			return shiftDAO.getObjects(DAOUtil.getCurrentObjectsBySchedulingPeriodSQLString(schedulingPeriod));</span>
<span class="nc" id="L2011">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2012">			handleException(ex);</span>
<span class="nc" id="L2013">			throw ex;</span>
		} finally {
<span class="nc" id="L2015">			shiftDAO.cleanUp();</span>
<span class="nc" id="L2016">			methodFinish();</span>
		}
	}

	/**
	 * Returns the currently active shifts for a schedule period campaign scope
	 * only aka (local)
	 * 
	 * @param schedulingPeriod
	 *            Scheduling period
	 * @return Collection of shifts
	 * @see Shift
	 */
	public Collection&lt;Shift&gt; getCurrentShiftsBySchedulingPeriodCampaignOnly(SchedulingPeriod schedulingPeriod)
			throws BbmFinderException {
<span class="nc" id="L2031">		methodStart(&quot;getCurrentObjectsBySchedulingPeriodCampaignOnlySQLString&quot;, schedulingPeriod);</span>
<span class="nc" id="L2032">		ShiftDAO shiftDAO = new ShiftDAO();</span>
		try {
<span class="nc" id="L2034">			return shiftDAO.getObjects(DAOUtil</span>
<span class="nc" id="L2035">					.getCurrentObjectsBySchedulingPeriodCampaignOnlySQLString(schedulingPeriod));</span>
<span class="nc" id="L2036">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2037">			handleException(ex);</span>
<span class="nc" id="L2038">			throw ex;</span>
		} finally {
<span class="nc" id="L2040">			shiftDAO.cleanUp();</span>
<span class="nc" id="L2041">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;Shift&gt; getCurrentShiftsBySchedulingPeriod(SchedulingPeriod sp, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; comparators,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="nc" id="L2048">		methodStart(&quot;getCurrentShiftsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex, comparators);</span>
<span class="nc" id="L2049">		ShiftDAO shiftDAO = new ShiftDAO();</span>

		try {
<span class="nc" id="L2052">			return shiftDAO.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					comparators, filteredIDs, filterByName);
<span class="nc" id="L2054">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2055">			handleException(ex);</span>
<span class="nc" id="L2056">			throw ex;</span>
		} finally {
<span class="nc" id="L2058">			shiftDAO.cleanUp();</span>
<span class="nc" id="L2059">			methodFinish();</span>
		}
	}

	public Collection&lt;Shift&gt; getShifts(Collection&lt;ID&gt; shiftIDs) throws BbmFinderException {
<span class="nc" id="L2064">		methodStart(&quot;getShifts&quot;, shiftIDs);</span>

<span class="nc" id="L2066">		ShiftDAO sDAO = new ShiftDAO();</span>

		try {
<span class="nc" id="L2069">			return sDAO.getObjectsByIDs(shiftIDs);</span>
<span class="nc" id="L2070">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2071">			handleException(ex);</span>
<span class="nc" id="L2072">			throw ex;</span>
		} finally {
<span class="nc" id="L2074">			sDAO.cleanUp();</span>
<span class="nc" id="L2075">			methodFinish();</span>
		}
	}

	public Shift createShift(Shift objValue) throws BbmCreateException, BbmDuplicateExternalIdentException,
			RemoteException {
<span class="fc" id="L2081">		methodStart(&quot;createShift&quot;, objValue);</span>

<span class="fc" id="L2083">		ShiftDAO dao = new ShiftDAO();</span>
		try {
<span class="fc" id="L2085">			objValue.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L2086">			objValue.setCreatedDate(new Date());</span>
<span class="fc" id="L2087">			objValue.setModifiedBy(null);</span>
<span class="fc" id="L2088">			objValue.setModifiedDate(null);</span>
<span class="fc" id="L2089">			objValue.setFieldNull(ShiftFieldInfo.SHIFT_DELETEONDATE);</span>
<span class="fc" id="L2090">			dao.createObject(objValue);</span>
<span class="fc" id="L2091">			return objValue;</span>
		} finally {
<span class="pc" id="L2093">			dao.cleanUp();</span>
<span class="pc" id="L2094">			methodFinish();</span>
		}
	}

	public void copyShifts(Collection&lt;ID&gt; shiftIDs, boolean isOrgMode, ID ownerID, LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L2100">		methodStart(&quot;copyShifts&quot;, shiftIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L2101">		ShiftDAO dao = new ShiftDAO();</span>

		try {
<span class="nc" id="L2104">			dao.copyShifts(shiftIDs, isOrgMode, ownerID, localeContext, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2105">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L2106">			handleException(ex);</span>
<span class="nc" id="L2107">			throw ex;</span>
<span class="nc" id="L2108">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2109">			handleException(ex);</span>
<span class="nc" id="L2110">			throw ex;</span>
		} finally {
<span class="nc" id="L2112">			methodFinish();</span>
<span class="nc" id="L2113">		}</span>
<span class="nc" id="L2114">	}</span>

	public void updateShifts(Collection&lt;Shift&gt; shifts) throws BbmUpdateException {
<span class="nc" id="L2117">		methodStart(&quot;updateShifts&quot;, shifts);</span>
<span class="nc" id="L2118">		ShiftDAO sDAO = new ShiftDAO();</span>
		try {
<span class="nc bnc" id="L2120" title="All 2 branches missed.">			for (Shift shift : shifts) {</span>
<span class="nc" id="L2121">				shift.setModifiedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2122">				shift.setModifiedDate(new Date());</span>
<span class="nc" id="L2123">			}</span>
<span class="nc" id="L2124">			sDAO.updateObjects(shifts);</span>
<span class="nc" id="L2125">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L2126">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="nc" id="L2128">			sDAO.cleanUp();</span>
<span class="nc" id="L2129">			methodFinish();</span>
<span class="nc" id="L2130">		}</span>
<span class="nc" id="L2131">	}</span>

	public PaginationPair&lt;ShiftEvent&gt; getShiftEventsByOrgHierarchy(ID orgID, boolean isAscendingSort, int pageIDSize,
			int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap, Collection&lt;ID&gt; filteredIDs,
			String filterByName) throws BbmFinderException {
<span class="fc" id="L2136">		methodStart(&quot;getShiftEventsByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>

<span class="fc" id="L2138">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="fc" id="L2140">			return seDAO.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, filterByName);
<span class="nc" id="L2142">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2143">			handleException(ex);</span>
<span class="nc" id="L2144">			throw ex;</span>
		} finally {
<span class="pc" id="L2146">			seDAO.cleanUp();</span>
<span class="pc" id="L2147">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEventsByOrgHierarchy(ID orgID) throws BbmFinderException {
<span class="fc" id="L2152">		methodStart(&quot;getShiftEventsByOrgHierarchy&quot;, orgID);</span>

<span class="fc" id="L2154">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="fc" id="L2156">			StringBuffer whereClause = new StringBuffer();</span>
<span class="fc" id="L2157">			whereClause.append(DAOUtil.getCurrentObjectsByOrgHierarchySQLString(orgID));</span>
<span class="fc" id="L2158">			return seDAO.getObjects(whereClause.toString());</span>
<span class="nc" id="L2159">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2160">			handleException(ex);</span>
<span class="nc" id="L2161">			throw ex;</span>
		} finally {
<span class="pc" id="L2163">			seDAO.cleanUp();</span>
<span class="pc" id="L2164">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEventsByOrg(ID orgID) throws BbmFinderException {
<span class="nc" id="L2169">		methodStart(&quot;getShiftEventsByOrg&quot;, orgID);</span>

<span class="nc" id="L2171">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="nc" id="L2173">			StringBuffer whereClause = new StringBuffer();</span>
<span class="nc" id="L2174">			whereClause.append(DAOUtil.getCurrentObjectsByOrgSQLString(orgID));</span>
<span class="nc" id="L2175">			return seDAO.getObjects(whereClause.toString());</span>
<span class="nc" id="L2176">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2177">			handleException(ex);</span>
<span class="nc" id="L2178">			throw ex;</span>
		} finally {
<span class="nc" id="L2180">			seDAO.cleanUp();</span>
<span class="nc" id="L2181">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ShiftEvent&gt; getShiftEventsBySchedulingPeriod(SchedulingPeriod sp, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; sortFieldMap,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="nc" id="L2188">		methodStart(&quot;getShiftEventsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex, sortFieldMap);</span>

<span class="nc" id="L2190">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="nc" id="L2192">			return seDAO.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize, pageIndex,</span>
					sortFieldMap, filteredIDs, filterByName);
<span class="nc" id="L2194">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2195">			handleException(ex);</span>
<span class="nc" id="L2196">			throw ex;</span>
		} finally {
<span class="nc" id="L2198">			seDAO.cleanUp();</span>
<span class="nc" id="L2199">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEventsBySchedulingPeriod(SchedulingPeriod sp) throws BbmFinderException {
<span class="fc" id="L2204">		methodStart(&quot;getShiftEventsBySchedulingPeriod&quot;, sp);</span>

<span class="fc" id="L2206">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="fc" id="L2208">			StringBuffer whereClause = new StringBuffer();</span>
<span class="fc" id="L2209">			whereClause.append(DAOUtil.getCurrentObjectsBySchedulingPeriodSQLString(sp));</span>
<span class="fc" id="L2210">			return seDAO.getObjects(whereClause.toString());</span>
<span class="nc" id="L2211">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2212">			handleException(ex);</span>
<span class="nc" id="L2213">			throw ex;</span>
		} finally {
<span class="pc" id="L2215">			seDAO.cleanUp();</span>
<span class="pc" id="L2216">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEventsBySchedulingPeriodCampaignOnly(SchedulingPeriod sp)
			throws BbmFinderException {
<span class="nc" id="L2222">		methodStart(&quot;getShiftEventsBySchedulingPeriod&quot;, sp);</span>

<span class="nc" id="L2224">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="nc" id="L2226">			StringBuffer whereClause = new StringBuffer();</span>
<span class="nc" id="L2227">			whereClause.append(DAOUtil.getCurrentObjectsBySchedulingPeriodCampaignOnlySQLString(sp));</span>
<span class="nc" id="L2228">			return seDAO.getObjects(whereClause.toString());</span>
<span class="nc" id="L2229">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2230">			handleException(ex);</span>
<span class="nc" id="L2231">			throw ex;</span>
		} finally {
<span class="nc" id="L2233">			seDAO.cleanUp();</span>
<span class="nc" id="L2234">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEvents(Collection&lt;ID&gt; shiftEventIDs) throws BbmFinderException {
<span class="fc" id="L2239">		methodStart(&quot;getShiftEvents&quot;, shiftEventIDs);</span>

<span class="fc" id="L2241">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="fc" id="L2243">			return seDAO.getObjectsByIDs(shiftEventIDs);</span>
<span class="nc" id="L2244">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2245">			handleException(ex);</span>
<span class="nc" id="L2246">			throw ex;</span>
		} finally {
<span class="pc" id="L2248">			seDAO.cleanUp();</span>
<span class="pc" id="L2249">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEvent&gt; getShiftEvents(Collection&lt;ID&gt; empIDs, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L2254">		methodStart(&quot;getShiftEvents&quot;, empIDs, start, end);</span>
<span class="nc" id="L2255">		ShiftEventDAO dao = null;</span>
		try {
<span class="nc" id="L2257">			dao = new ShiftEventDAO();</span>
<span class="nc" id="L2258">			Collection&lt;ID&gt; orgIDs = getOrganizationIDList(dao.getDMO(), empIDs, start, end);</span>
<span class="nc" id="L2259">			StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L2260">			sb.append(&quot; ORGANIZATIONID IN &quot;).append(dao.getDMO().createInClause(orgIDs));</span>
<span class="nc" id="L2261">			return dao.getObjects(sb.toString());</span>
<span class="nc" id="L2262">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2263">			handleException(e);</span>
<span class="nc" id="L2264">			throw e;</span>
<span class="nc" id="L2265">		} catch (Exception e) {</span>
<span class="nc" id="L2266">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2268" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L2269">				dao.cleanUp();</span>
<span class="nc" id="L2270">			methodFinish();</span>
		}
	}

	public ShiftEvent getShiftEvent(ID shiftEventID) throws BbmFinderException {
<span class="nc" id="L2275">		methodStart(&quot;getShiftEvent&quot;, shiftEventID);</span>
<span class="nc" id="L2276">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="nc" id="L2278">			return seDAO.getObjectByID(shiftEventID);</span>
<span class="nc" id="L2279">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2280">			handleException(ex);</span>
<span class="nc" id="L2281">			throw ex;</span>
		} finally {
<span class="nc" id="L2283">			seDAO.cleanUp();</span>
<span class="nc" id="L2284">			methodFinish();</span>
		}
	}

	public ShiftEvent createShiftEvent(ShiftEvent objValue) throws BbmCreateException,
			BbmDuplicateExternalIdentException, RemoteException {
<span class="fc" id="L2290">		methodStart(&quot;createShiftEvent&quot;, objValue);</span>

<span class="fc" id="L2292">		ShiftEventDAO dao = new ShiftEventDAO();</span>
		try {
<span class="fc" id="L2294">			objValue.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L2295">			objValue.setCreatedDate(new Date(System.currentTimeMillis()));</span>
<span class="fc" id="L2296">			objValue.setModifiedBy(null);</span>
<span class="fc" id="L2297">			objValue.setModifiedDate(null);</span>
<span class="fc" id="L2298">			DAOEJBUtil.createObject(dao, objValue, this, &quot;createShiftEvent&quot;);</span>
<span class="fc" id="L2299">			return objValue;</span>
		} finally {
<span class="pc" id="L2301">			dao.cleanUp();</span>
<span class="pc" id="L2302">			methodFinish();</span>
		}
	}

	public void updateShiftEvents(Collection&lt;ShiftEvent&gt; shiftEvents) throws BbmUpdateException {
<span class="nc" id="L2307">		methodStart(&quot;updateShiftEvents&quot;, shiftEvents);</span>
<span class="nc" id="L2308">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
<span class="nc bnc" id="L2310" title="All 2 branches missed.">			for (ShiftEvent shiftEvent : shiftEvents) {</span>
<span class="nc" id="L2311">				shiftEvent.setModifiedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2312">				shiftEvent.setModifiedDate(new Date(System.currentTimeMillis()));</span>
<span class="nc" id="L2313">			}</span>
<span class="nc" id="L2314">			seDAO.updateObjects(shiftEvents);</span>
<span class="nc" id="L2315">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L2316">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="nc" id="L2318">			seDAO.cleanUp();</span>
<span class="nc" id="L2319">			methodFinish();</span>
<span class="nc" id="L2320">		}</span>
<span class="nc" id="L2321">	}</span>

	public void deleteShiftEvents(Collection&lt;ID&gt; shiftEventIDs) throws BbmRemoveException, RemoteException {
<span class="fc" id="L2324">		methodStart(&quot;deleteShiftEvents&quot;, shiftEventIDs);</span>

<span class="fc" id="L2326">		ShiftEventDAO seDAO = new ShiftEventDAO();</span>
		try {
			// No need to set modified by and modified date because the DAOBase
			// method
			// assumes that when deleting via update that there is are
			// DELETEONDATE, MODIFIEDBY
			// and MODIFIED (date) fields on the table.
<span class="fc" id="L2333">			seDAO.deleteObjectsViaUpdate(shiftEventIDs, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2334">		} catch (Exception ex) {</span>
<span class="nc" id="L2335">			handleException(ex);</span>
<span class="nc" id="L2336">			throw new BbmRemoveException(ex);</span>
		} finally {
<span class="pc" id="L2338">			seDAO.cleanUp();</span>
<span class="pc" id="L2339">			methodFinish();</span>
<span class="fc" id="L2340">		}</span>
<span class="fc" id="L2341">	}</span>

	public void copyShiftEvents(Collection&lt;ID&gt; shiftEventIDs, boolean isOrgMode, ID ownerID, LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L2345">		methodStart(&quot;copyShiftEvents&quot;, shiftEventIDs, isOrgMode);</span>
<span class="nc" id="L2346">		CopyDAO dao = new CopyDAO();</span>
<span class="nc" id="L2347">		Collection&lt;ShiftEvent&gt; shiftEventsToCopy = getShiftEvents(shiftEventIDs);</span>

		try {
<span class="nc bnc" id="L2350" title="All 2 branches missed.">			for (ShiftEvent shiftEvent : shiftEventsToCopy) {</span>
<span class="nc" id="L2351">				shiftEvent.setID(null);</span>
<span class="nc" id="L2352">				shiftEvent.setDEID(null);</span>
<span class="nc" id="L2353">				shiftEvent.setModifiedBy(null);</span>
<span class="nc" id="L2354">				shiftEvent.setModifiedDate(null);</span>

<span class="nc" id="L2356">				shiftEvent</span>
<span class="nc" id="L2357">						.setName(dao.getNewNameForCopiedValueObjectWithLengthLimitation(shiftEvent.getName(),</span>
								&quot;SHIFTEVENT&quot;, localeContext, ShiftEventFieldInfo.SHIFTEVENT_NAME_MAX_LENGTH));

<span class="nc bnc" id="L2360" title="All 2 branches missed.">				if (isOrgMode) {</span>
<span class="nc" id="L2361">					shiftEvent.setCampaignID(null);</span>
<span class="nc" id="L2362">					shiftEvent.setOrganizationID(ownerID);</span>
				} else {
<span class="nc" id="L2364">					shiftEvent.setOrganizationID(null);</span>
<span class="nc" id="L2365">					shiftEvent.setCampaignID(ownerID);</span>
				}
<span class="nc" id="L2367">				createShiftEvent(shiftEvent);</span>
<span class="nc" id="L2368">			}</span>
<span class="nc" id="L2369">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L2370">			handleException(ex);</span>
<span class="nc" id="L2371">			throw ex;</span>
<span class="nc" id="L2372">		} catch (BbmDuplicateExternalIdentException ex) {</span>
<span class="nc" id="L2373">			handleException(ex);</span>
<span class="nc" id="L2374">			throw ex;</span>
<span class="nc" id="L2375">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2376">			handleException(ex);</span>
<span class="nc" id="L2377">			throw ex;</span>
		} finally {
<span class="nc" id="L2379">			methodFinish();</span>
<span class="nc" id="L2380">		}</span>
<span class="nc" id="L2381">	}</span>

	public Collection&lt;ShiftPattern&gt; getShiftPatternsByOrgHierarchy(ID orgID) throws BbmFinderException {
<span class="nc" id="L2384">		methodStart(&quot;getCurrentShiftPatternsByOrgHierarchy&quot;, orgID);</span>
<span class="nc" id="L2385">		ShiftPatternDAO dao = null;</span>
		try {
<span class="nc" id="L2387">			dao = new ShiftPatternDAO();</span>
<span class="nc" id="L2388">			return dao.getCurrentShiftPatternsByOrgHierarchy(orgID);</span>
<span class="nc" id="L2389">		} catch (Exception e) {</span>
<span class="nc" id="L2390">			handleException(e);</span>
<span class="nc bnc" id="L2391" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L2392">				throw (BbmFinderException) e;</span>
<span class="nc" id="L2393">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2395" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L2396">				dao.cleanUp();</span>
<span class="nc" id="L2397">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, String&gt; getShiftPatternsIDNameByOrgHierarchyOrderByName(ID orgID) throws BbmFinderException {
<span class="fc" id="L2402">		methodStart(&quot;getShiftPatternsIDNameByOrgHierarchyOrderByName&quot;, orgID);</span>
<span class="fc" id="L2403">		ShiftPatternDAO dao = null;</span>
		try {
<span class="fc" id="L2405">			dao = new ShiftPatternDAO();</span>
<span class="fc" id="L2406">			return dao.getCurrentShiftPatternsIDNameByOrgHierarchyOrderByName(orgID);</span>
<span class="nc" id="L2407">		} catch (Exception e) {</span>
<span class="nc" id="L2408">			handleException(e);</span>
<span class="nc bnc" id="L2409" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L2410">				throw (BbmFinderException) e;</span>
<span class="nc" id="L2411">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L2413" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L2414">				dao.cleanUp();</span>
<span class="pc" id="L2415">			methodFinish();</span>
		}
	}

	public Collection getComplexWorkRulesForOrgs(Collection colOrgIDs) throws BbmFinderException {
<span class="fc" id="L2420">		methodStart(&quot;getComplexWorkRulesForOrgs&quot;, colOrgIDs);</span>
<span class="fc" id="L2421">		ComplexWorkRuleDAO dao = null;</span>
		try {
<span class="fc" id="L2423">			dao = new ComplexWorkRuleDAO();</span>
<span class="fc" id="L2424">			return dao.getComplexWorkRulesForOrgs(colOrgIDs);</span>
<span class="nc" id="L2425">		} catch (Exception e) {</span>
<span class="nc" id="L2426">			handleException(e);</span>
<span class="nc bnc" id="L2427" title="All 2 branches missed.">			if (e instanceof BbmFinderException)</span>
<span class="nc" id="L2428">				throw (BbmFinderException) e;</span>
<span class="nc" id="L2429">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L2431" title="3 of 4 branches missed.">			if (dao != null)</span>
<span class="pc" id="L2432">				dao.cleanUp();</span>
<span class="pc" id="L2433">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ComplexWorkRule&gt; getComplexWorkRulesForOrgAndAncestors(ID selectedOrgID, int pageSize,
			int pageIndex, LinkedHashMap&lt;ComplexWorkRuleSortField, Comparator&lt;?&gt;&gt; sortFields, boolean isAscending)
			throws BbmFinderException {
<span class="fc" id="L2440">		methodStart(&quot;getComplexWorkRulesForOrgAndAncestors&quot;, selectedOrgID, pageSize, pageIndex);</span>
<span class="fc" id="L2441">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="fc" id="L2443">			StringBuffer whereClause = new StringBuffer();</span>
<span class="fc" id="L2444">			whereClause.append(&quot;ORGANIZATIONID IN (SELECT ID from FN_TF_CF_getParentOrgsIncludingChild('&quot;)</span>
<span class="fc" id="L2445">					.append(JdmoUtil.asSqlLiteral(selectedOrgID)).append(&quot;') )&quot;);</span>
<span class="fc" id="L2446">			return dao.getCompletePaginationDataSet(whereClause.toString(), isAscending, pageSize, pageIndex,</span>
					new LinkedHashMap&lt;DBSortField, Comparator&gt;(sortFields), new LinkedList&lt;ID&gt;());
		} finally {
<span class="pc" id="L2449">			dao.cleanUp();</span>
<span class="pc" id="L2450">			methodFinish();</span>
		}
	}

	// performance tuning for web calendar
	public Collection&lt;Shift&gt; getAllShifts() throws BbmFinderException, RemoteException {
<span class="fc" id="L2456">		methodStart(&quot;getAllShifts&quot;);</span>
<span class="fc" id="L2457">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L2459">			ShiftDAO shiftDao = new ShiftDAO(dmo);</span>
<span class="fc" id="L2460">			Collection thinShifts = new ArrayList();</span>

			// call jDMO to fetch the data
			try {
<span class="fc" id="L2464">				String fullSqlQuery = &quot;SELECT A.ID,A.SID,A.CAMPAIGNID,A.ACTIVITYID,A.NAME,A.DESCRIPTION,A.SHIFTLENGTH,A.MINSPACING,A.MAXSPACING,A.ORGANIZATIONID,A.DELETEONDATE,A.CREATED,A.CREATEDBY,A.MODIFIED,A.MODIFIEDBY FROM SHIFT A  WHERE (A.DELETEONDATE IS NULL OR A.DELETEONDATE &gt; &quot;</span>
<span class="fc" id="L2465">						+ JdmoUtil.asSqlLiteral(new Date(System.currentTimeMillis())) + &quot;)&quot;;</span>
<span class="fc" id="L2466">				JdmoRowset rs = dmo.createRowset(fullSqlQuery);</span>
<span class="fc bfc" id="L2467" title="All 2 branches covered.">				while (rs.next()) {</span>
<span class="fc" id="L2468">					Object item = shiftDao.readObjectFromDB(rs);</span>
<span class="fc" id="L2469">					thinShifts.add(item);</span>
<span class="fc" id="L2470">				}</span>
<span class="nc" id="L2471">			} catch (Exception e) {</span>
<span class="nc" id="L2472">				throw new BbmFinderException(e);</span>
<span class="fc" id="L2473">			}</span>

<span class="fc" id="L2475">			HashMap sidShift = ValueObjectUtil.getIDObjectMap(thinShifts);</span>

			// RichObjectDAO is very slow, manual assembling shift events here
			// just like what we did for shift
<span class="fc" id="L2479">			Collection thinShiftEvents = new ArrayList();</span>
<span class="fc" id="L2480">			ShiftEventDAO shiftEventDao = new ShiftEventDAO(dmo);</span>
<span class="fc" id="L2481">			StringBuffer fullSqlQuery = shiftEventDao.getSelectStatement();</span>
<span class="fc" id="L2482">			fullSqlQuery.append(&quot; FROM SHIFTEVENT A  WHERE (A.DELETEONDATE IS NULL OR A.DELETEONDATE &gt; &quot;);</span>
<span class="fc" id="L2483">			fullSqlQuery.append(JdmoUtil.asSqlLiteral(new Date(System.currentTimeMillis())));</span>
<span class="fc" id="L2484">			fullSqlQuery.append(&quot;) AND &quot;);</span>
<span class="fc" id="L2485">			fullSqlQuery</span>
<span class="fc" id="L2486">					.append(&quot; ID in (SELECT DISTINCT SHIFTEVENTID FROM SHIFTEVENTSHIFT WHERE SHIFTID IN (SELECT ID FROM SHIFT WHERE SID IN &quot;)</span>
<span class="fc" id="L2487">					.append(dmo.createInClause(sidShift.keySet())).append(&quot;))&quot;);</span>
<span class="fc" id="L2488">			JdmoRowset rs = dmo.createRowset(fullSqlQuery.toString());</span>
			try {
<span class="fc bfc" id="L2490" title="All 2 branches covered.">				while (rs.next()) {</span>
<span class="fc" id="L2491">					Object item = shiftEventDao.readObjectFromDB(rs);</span>
<span class="fc" id="L2492">					thinShiftEvents.add(item);</span>
<span class="fc" id="L2493">				}</span>
				// get activity and additionalactivity
<span class="fc" id="L2495">				Collection allActivities = getActivityManager().getAllActivities();</span>
<span class="fc" id="L2496">				HashMap activityIDObjectMap = ValueObjectUtil.getIDObjectMap(allActivities);</span>

<span class="fc" id="L2498">				Set shiftEventDEIDs = ValueObjectUtil.extractFieldSet(ShiftEventFieldInfo.SHIFTEVENT_ID,</span>
						thinShiftEvents);
<span class="fc" id="L2500">				fullSqlQuery = new StringBuffer(200);</span>
<span class="fc" id="L2501">				fullSqlQuery</span>
<span class="fc" id="L2502">						.append(&quot;SELECT A.ACTIVITYID,A.SHIFTEVENTID FROM SHIFTEVENTACTIVITY A  WHERE  SHIFTEVENTID IN &quot;);</span>
<span class="fc" id="L2503">				fullSqlQuery.append(dmo.createInClause(shiftEventDEIDs));</span>
<span class="fc" id="L2504">				HashMap&lt;ID, Collection&gt; eventActivities = new HashMap(shiftEventDEIDs.size());</span>

<span class="fc" id="L2506">				ID activitySID = null;</span>
<span class="fc" id="L2507">				ID shiftEventDEID = null;</span>
<span class="fc" id="L2508">				Collection list = null;</span>
<span class="fc" id="L2509">				rs = dmo.createRowset(fullSqlQuery.toString());</span>
<span class="pc bpc" id="L2510" title="1 of 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L2511">					activitySID = rs.getID(1);</span>
<span class="nc" id="L2512">					shiftEventDEID = rs.getID(2);</span>
<span class="nc bnc" id="L2513" title="All 2 branches missed.">					if (eventActivities.get(shiftEventDEID) == null)</span>
<span class="nc" id="L2514">						eventActivities.put(shiftEventDEID, new ArrayList());</span>

<span class="nc" id="L2516">					list = (Collection) eventActivities.get(shiftEventDEID);</span>
<span class="nc" id="L2517">					list.add(activityIDObjectMap.get(activitySID));</span>
				}
				// assembling now
<span class="fc" id="L2520">				Collection additionalActivities = null;</span>
<span class="fc bfc" id="L2521" title="All 2 branches covered.">				for (ShiftEvent event : (Collection&lt;ShiftEvent&gt;) thinShiftEvents) {</span>
<span class="fc" id="L2522">					event.setRelatedObjects(ShiftEvent.ACTIVITY_RELATIONSHIP_KEY,</span>
<span class="fc" id="L2523">							Arrays.asList(activityIDObjectMap.get(event.getActivityID())));</span>
<span class="fc" id="L2524">					additionalActivities = eventActivities.get(event.getDEID());</span>
<span class="pc bpc" id="L2525" title="1 of 2 branches missed.">					if (additionalActivities != null)</span>
<span class="nc" id="L2526">						event.setRelatedObjects(ShiftEvent.SHIFT_EVENT_ACTIVITY_RELATIONSHIP_KEY, additionalActivities);</span>
<span class="fc" id="L2527">				}</span>
<span class="nc" id="L2528">			} catch (Exception e) {</span>
<span class="nc" id="L2529">				throw new BbmFinderException(e);</span>
<span class="fc" id="L2530">			}</span>
<span class="fc" id="L2531">			HashMap sidShiftEvent = ValueObjectUtil.getIDObjectMap(thinShiftEvents);</span>

<span class="fc" id="L2533">			ShiftStartDAO shiftStartDAO = new ShiftStartDAO(dmo);</span>
<span class="fc" id="L2534">			Collection shiftStarts = ((DAOBase) shiftStartDAO).getObjects(null);</span>
			// group shift starts by shift string id
<span class="fc" id="L2536">			ShiftStart shiftStart = null;</span>
<span class="fc" id="L2537">			HashMap relationshipShiftStart = new HashMap();</span>
<span class="fc" id="L2538">			ID shiftStringID = null;</span>
<span class="fc" id="L2539">			Collection startList = null;</span>
<span class="fc bfc" id="L2540" title="All 2 branches covered.">			for (Iterator i = shiftStarts.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2541">				shiftStart = (ShiftStart) i.next();</span>
<span class="fc" id="L2542">				shiftStringID = shiftStart.getShiftID();</span>
<span class="fc bfc" id="L2543" title="All 2 branches covered.">				if (relationshipShiftStart.get(shiftStringID) == null)</span>
<span class="fc" id="L2544">					relationshipShiftStart.put(shiftStringID, new ArrayList());</span>

<span class="fc" id="L2546">				startList = (Collection) relationshipShiftStart.get(shiftStringID);</span>
<span class="fc" id="L2547">				startList.add(shiftStart);</span>
			}

<span class="fc" id="L2550">			StringBuffer sb = new StringBuffer(200);</span>
<span class="fc" id="L2551">			sb.append(&quot;select SHIFT.SID, SHIFTEVENT.sid from SHIFT, SHIFTEVENTSHIFT, shiftevent where SHIFT.ID = shifteventshift.shiftid and SHIFTEVENT.ID = SHIFTEVENTSHIFT.SHIFTEVENTID order by shift.sid&quot;);</span>
<span class="fc" id="L2552">			rs = dmo.createRowset(sb.toString());</span>
<span class="fc" id="L2553">			HashMap relationshipEvent = new HashMap();</span>
<span class="fc" id="L2554">			ID shiftSID = null;</span>
<span class="fc" id="L2555">			ID eventSID = null;</span>
<span class="fc" id="L2556">			Collection eventList = null;</span>
<span class="fc" id="L2557">			Object obj = null;</span>
<span class="fc bfc" id="L2558" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L2559">				shiftSID = rs.getID(1);</span>
<span class="fc" id="L2560">				eventSID = rs.getID(2);</span>
<span class="fc bfc" id="L2561" title="All 2 branches covered.">				if (relationshipEvent.get(shiftSID) == null)</span>
<span class="fc" id="L2562">					relationshipEvent.put(shiftSID, new ArrayList());</span>

<span class="fc" id="L2564">				eventList = (Collection) relationshipEvent.get(shiftSID);</span>
<span class="fc" id="L2565">				obj = sidShiftEvent.get(eventSID);</span>
<span class="pc bpc" id="L2566" title="1 of 2 branches missed.">				if (obj != null) // if shift event has been deleted, it should</span>
									// not in the list?
<span class="fc" id="L2568">					eventList.add(obj);</span>
			}

<span class="fc" id="L2571">			Shift shift = null;</span>
<span class="fc" id="L2572">			Collection events = null;</span>
<span class="fc" id="L2573">			Collection starts = null;</span>

<span class="fc" id="L2575">			ArrayList&lt;Shift&gt; shiftsToReturn = new ArrayList(sidShift.size());</span>
<span class="fc bfc" id="L2576" title="All 2 branches covered.">			for (Iterator i = sidShift.values().iterator(); i.hasNext();) {</span>
<span class="fc" id="L2577">				shift = (Shift) i.next();</span>
<span class="fc" id="L2578">				events = (ArrayList) relationshipEvent.get(shift.getID());</span>
<span class="fc bfc" id="L2579" title="All 2 branches covered.">				if (events != null)</span>
<span class="fc" id="L2580">					shift.setShiftEvents(events);</span>
<span class="fc" id="L2581">				starts = (ArrayList) relationshipShiftStart.get(shift.getDEID());</span>
<span class="fc bfc" id="L2582" title="All 2 branches covered.">				if (starts != null)</span>
<span class="fc" id="L2583">					shift.setShiftStarts(starts);</span>

<span class="fc" id="L2585">				shiftsToReturn.add(shift);</span>
			}

<span class="fc" id="L2588">			return shiftsToReturn;</span>
<span class="nc" id="L2589">		} catch (JdmoException ex) {</span>
<span class="nc" id="L2590">			throw new BbmFinderException(ex);</span>
<span class="nc" id="L2591">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2592">			handleException(e);</span>
<span class="nc" id="L2593">			throw e;</span>
		} finally {
<span class="pc bpc" id="L2595" title="3 of 4 branches missed.">			if (dmo != null)</span>
<span class="pc" id="L2596">				dmo.cleanUp();</span>
<span class="pc" id="L2597">			methodFinish();</span>
		}
	}

	public Collection&lt;ID&gt; getShiftIDsOrderByName(Collection&lt;ID&gt; empIDs, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L2602">		methodStart(&quot;getShiftIDsOrderByName&quot;, empIDs, start, end);</span>
<span class="nc" id="L2603">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L2605">			dmo = new Jdmo();</span>
<span class="nc" id="L2606">			Collection&lt;ID&gt; orgIDs = getOrganizationIDList(dmo, empIDs, start, end);</span>
<span class="nc" id="L2607">			StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L2608">			sb.append(&quot; select sid from shift where ORGANIZATIONID IN &quot;).append(dmo.createInClause(orgIDs));</span>
<span class="nc" id="L2609">			sb.append(</span>
					&quot; and (DELETEONDATE IS NULL OR DELETEONDATE &gt; &quot;
<span class="nc" id="L2611">							+ JdmoUtil.asSqlLiteral(new Date(System.currentTimeMillis()))).append(&quot;)&quot;);</span>
<span class="nc" id="L2612">			sb.append(&quot; order by name&quot;);</span>

<span class="nc" id="L2614">			JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc" id="L2615">			ArrayList ids = new ArrayList();</span>
<span class="nc bnc" id="L2616" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2617">				ids.add(rs.getID(1));</span>
			}
			// remove predefined SHIFT_OFF from the list
<span class="nc" id="L2620">			ID id = null;</span>
<span class="nc bnc" id="L2621" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; i = ids.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2622">				id = (ID) i.next();</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">				if (id.toInt() == ShiftFieldInfo.POSSIBLE_DAYS_OFF_SHIFT_ID) // predefined</span>
																				// SHIFT_OFF
<span class="nc" id="L2625">					i.remove();</span>
			}
<span class="nc" id="L2627">			return ids;</span>
<span class="nc" id="L2628">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2629">			handleException(e);</span>
<span class="nc" id="L2630">			throw e;</span>
<span class="nc" id="L2631">		} catch (Exception e) {</span>
<span class="nc" id="L2632">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2634" title="All 4 branches missed.">			if (dmo != null)</span>
<span class="nc" id="L2635">				dmo.cleanUp();</span>
<span class="nc" id="L2636">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ProjectRules&gt; getProjectRulesByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; comparators,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="nc" id="L2643">		methodStart(&quot;getProjectRulesByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, comparators);</span>
<span class="nc" id="L2644">		ProjectRulesDAO projRulesDAO = new ProjectRulesDAO();</span>

		try {
<span class="nc" id="L2647">			return projRulesDAO.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					comparators, filteredIDs, filterByName);
<span class="nc" id="L2649">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2650">			handleException(ex);</span>
<span class="nc" id="L2651">			throw ex;</span>
		} finally {
<span class="nc" id="L2653">			projRulesDAO.cleanUp();</span>
<span class="nc" id="L2654">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;ProjectRules&gt; getCurrentProjectsBySchedulingPeriod(SchedulingPeriod sp,
			boolean isAscendingSort, int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; comparators,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="nc" id="L2661">		methodStart(&quot;getCurrentShiftsBySchedulingPeriod&quot;, sp, isAscendingSort, pageIDSize, pageIndex, comparators);</span>
<span class="nc" id="L2662">		ProjectRulesDAO projRulesDAO = new ProjectRulesDAO();</span>

		try {
<span class="nc" id="L2665">			return projRulesDAO.getCompletePaginationDataSetForSchedulingPeriod(sp, isAscendingSort, pageIDSize,</span>
					pageIndex, comparators, filteredIDs, filterByName);
<span class="nc" id="L2667">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2668">			handleException(ex);</span>
<span class="nc" id="L2669">			throw ex;</span>
		} finally {
<span class="nc" id="L2671">			projRulesDAO.cleanUp();</span>
<span class="nc" id="L2672">			methodFinish();</span>
		}
	}

	public void deleteProjects(Collection&lt;ID&gt; projectIDs) throws BbmRemoveException, RemoteException {
<span class="nc" id="L2677">		methodStart(&quot;deleteProjects&quot;, projectIDs);</span>
<span class="nc" id="L2678">		ProjectRulesDAO projRulesDAO = new ProjectRulesDAO();</span>

		try {
			/**
			 * Fix for QC#85497 , As the FnS Desktop Client Scheduler is not
			 * able to take care of the deleted Project Rules based on the
			 * delete on date, changing the functionality to delete the rules by
			 * removing the rows completely from the backend.
			 */

			// projRulesDAO.deleteObjectsViaUpdate(projectIDs,
			// m_sessionContext.getCallerPrincipal().getName());
<span class="nc" id="L2690">			projRulesDAO.deleteObjects(projectIDs);</span>

<span class="nc" id="L2692">		} catch (BbmRemoveException ex) {</span>
<span class="nc" id="L2693">			handleException(ex);</span>
<span class="nc" id="L2694">			throw ex;</span>
		} finally {
<span class="nc" id="L2696">			projRulesDAO.cleanUp();</span>
<span class="nc" id="L2697">			methodFinish();</span>
<span class="nc" id="L2698">		}</span>
<span class="nc" id="L2699">	}</span>

	public Collection&lt;ProjectRules&gt; getProjectRulesByID(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc" id="L2702">		methodStart(&quot;getProjectRulesByID&quot;, ids);</span>
<span class="nc" id="L2703">		ProjectRulesDAO dao = null;</span>
		try {
<span class="nc" id="L2705">			dao = new ProjectRulesDAO();</span>
<span class="nc" id="L2706">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L2707">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2708">			handleException(e);</span>
<span class="nc" id="L2709">			throw e;</span>
		} finally {
<span class="nc bnc" id="L2711" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L2712">				dao.cleanUp();</span>
<span class="nc" id="L2713">			methodFinish();</span>
		}
	}

	public ID createProjectRule(ProjectRules objValue) throws BbmCreateException, BbmDuplicateExternalIdentException,
			RemoteException {
<span class="nc" id="L2719">		methodStart(&quot;createProjectRule&quot;, objValue);</span>

<span class="nc" id="L2721">		ProjectRulesDAO dao = new ProjectRulesDAO();</span>
		try {
<span class="nc" id="L2723">			objValue.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2724">			objValue.setCreatedDate(new Date());</span>
<span class="nc" id="L2725">			objValue.setModifiedBy(null);</span>
<span class="nc" id="L2726">			objValue.setModifiedDate(null);</span>
<span class="nc" id="L2727">			return dao.createObject(objValue);</span>
		} finally {
<span class="nc" id="L2729">			dao.cleanUp();</span>
<span class="nc" id="L2730">			methodFinish();</span>
		}
	}

	public void updateProjectRule(Collection&lt;ProjectRules&gt; projRules) throws BbmUpdateException {
<span class="nc" id="L2735">		methodStart(&quot;updateProjects&quot;, projRules);</span>
<span class="nc" id="L2736">		ProjectRulesDAO dao = new ProjectRulesDAO();</span>
		try {
<span class="nc bnc" id="L2738" title="All 2 branches missed.">			for (ProjectRules lProjRule : projRules) {</span>
<span class="nc" id="L2739">				lProjRule.setModifiedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L2740">				lProjRule.setModifiedDate(new Date());</span>
<span class="nc" id="L2741">			}</span>
<span class="nc" id="L2742">			dao.updateObjects(projRules);</span>
<span class="nc" id="L2743">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L2744">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="nc" id="L2746">			dao.cleanUp();</span>
<span class="nc" id="L2747">			methodFinish();</span>
<span class="nc" id="L2748">		}</span>
<span class="nc" id="L2749">	}</span>

	public void copyProjects(Collection&lt;ID&gt; projectIDs, boolean isOrgMode, ID ownerID, LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L2753">		methodStart(&quot;copyProjects&quot;, projectIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L2754">		ProjectRulesDAO dao = new ProjectRulesDAO();</span>

		try {
<span class="nc" id="L2757">			dao.copyProjects(projectIDs, isOrgMode, ownerID, localeContext, m_sessionContext.getCallerPrincipal()</span>
<span class="nc" id="L2758">					.getName());</span>
<span class="nc" id="L2759">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L2760">			handleException(ex);</span>
<span class="nc" id="L2761">			throw ex;</span>
<span class="nc" id="L2762">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L2763">			handleException(ex);</span>
<span class="nc" id="L2764">			throw ex;</span>
		} finally {
<span class="nc" id="L2766">			methodFinish();</span>
<span class="nc" id="L2767">		}</span>
<span class="nc" id="L2768">	}</span>

	public void saveRotation(Rotation rotation) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L2771">		methodStart(&quot;saveRotation&quot;, rotation);</span>
<span class="fc" id="L2772">		RotationDAO dao = new RotationDAO();</span>
		try {

<span class="pc bpc" id="L2775" title="1 of 2 branches missed.">			if (validate(rotation).size() &gt; 0)</span>
<span class="nc" id="L2776">				throw new BbmCreateException(&quot;did not validate&quot;);</span>

<span class="pc bpc" id="L2778" title="1 of 2 branches missed.">			if (rotation.getID() == null) {</span>
<span class="fc" id="L2779">				rotation.setFieldValue(ComplexWorkRuleFieldInfo.Column.CreatedBy.getIndex(), m_sessionContext</span>
<span class="fc" id="L2780">						.getCallerPrincipal().getName());</span>
<span class="fc" id="L2781">				rotation.setFieldValue(ComplexWorkRuleFieldInfo.Column.CreatedOn.getIndex(), new Date());</span>
<span class="fc" id="L2782">				dao.createObject(rotation);</span>
			} else {
<span class="nc" id="L2784">				rotation.setFieldValue(ComplexWorkRuleFieldInfo.Column.ModifiedBy.getIndex(), m_sessionContext</span>
<span class="nc" id="L2785">						.getCallerPrincipal().getName());</span>
<span class="nc" id="L2786">				rotation.setFieldValue(ComplexWorkRuleFieldInfo.Column.ModifiedOn.getIndex(), new Date());</span>
<span class="nc" id="L2787">				dao.updateObject(rotation);</span>
			}
<span class="nc" id="L2789">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L2790">			throw e;</span>
<span class="nc" id="L2791">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2792">			throw e;</span>
<span class="nc" id="L2793">		} catch (Exception e) {</span>
<span class="nc" id="L2794">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc" id="L2796">			dao.cleanUp();</span>
<span class="pc" id="L2797">			methodFinish();</span>
<span class="fc" id="L2798">		}</span>
<span class="fc" id="L2799">	}</span>

	public Collection&lt;Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt;&gt; saveAssignmentRule(ComplexWorkRule assignmentRule)
			throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L2803">		methodStart(&quot;saveAssignmentRule&quot;, assignmentRule);</span>
		Collection&lt;Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt;&gt; retVal;
		try {
<span class="fc" id="L2806">			retVal = validate(assignmentRule);</span>
<span class="pc bpc" id="L2807" title="1 of 2 branches missed.">			for (Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt; errorPair : retVal) {</span>
<span class="nc" id="L2808">				AssignmentRuleValidationError error = errorPair.getFirst();</span>
<span class="nc bnc" id="L2809" title="All 2 branches missed.">				if (!error.isWarning())</span>
<span class="nc" id="L2810">					return retVal;</span>
<span class="nc" id="L2811">			}</span>
<span class="nc" id="L2812">		} catch (BbmFinderException e1) {</span>
<span class="nc" id="L2813">			throw new BbmCreateException(e1);</span>
<span class="fc" id="L2814">		}</span>

<span class="fc" id="L2816">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="fc" id="L2818">			checkPermissionsToEditWorkRules(assignmentRule.getOrganizationID());</span>

<span class="pc bpc" id="L2820" title="1 of 2 branches missed.">			if (assignmentRule.getID() == null) {</span>
<span class="fc" id="L2821">				assignmentRule.setFieldValue(ComplexWorkRuleFieldInfo.Column.CreatedBy.getIndex(), m_sessionContext</span>
<span class="fc" id="L2822">						.getCallerPrincipal().getName());</span>
<span class="fc" id="L2823">				assignmentRule.setFieldValue(ComplexWorkRuleFieldInfo.Column.CreatedOn.getIndex(), new Date());</span>
<span class="fc" id="L2824">				dao.createObject(assignmentRule);</span>
			} else {
<span class="nc" id="L2826">				assignmentRule.setFieldValue(ComplexWorkRuleFieldInfo.Column.ModifiedBy.getIndex(), m_sessionContext</span>
<span class="nc" id="L2827">						.getCallerPrincipal().getName());</span>
<span class="nc" id="L2828">				assignmentRule.setFieldValue(ComplexWorkRuleFieldInfo.Column.ModifiedOn.getIndex(), new Date());</span>
<span class="nc" id="L2829">				dao.updateObject(assignmentRule);</span>
			}
<span class="nc" id="L2831">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L2832">			throw e;</span>
<span class="nc" id="L2833">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2834">			throw e;</span>
<span class="nc" id="L2835">		} catch (Exception e) {</span>
<span class="nc" id="L2836">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc" id="L2838">			dao.cleanUp();</span>
<span class="pc" id="L2839">			methodFinish();</span>
<span class="fc" id="L2840">		}</span>

<span class="fc" id="L2842">		return retVal;</span>
	}

	private void checkPermissionsToEditWorkRules(Collection&lt;ID&gt; orgIDs) throws RemoteException, BPException {
<span class="nc bnc" id="L2846" title="All 2 branches missed.">		for (ID id : orgIDs)</span>
<span class="nc" id="L2847">			checkPermissionsToEditWorkRules(id);</span>
<span class="nc" id="L2848">	}</span>

	private void checkPermissionsToEditWorkRules(ID orgID) throws BPException, RemoteException {
<span class="fc" id="L2851">		User user = CoreManagerFactory.getUserManager(m_isWhatIf).getUserByName(</span>
<span class="fc" id="L2852">				m_sessionContext.getCallerPrincipal().getName());</span>
<span class="pc bpc" id="L2853" title="2 of 4 branches missed.">		if (orgID == null || !user.isAuthorized(PrivilegeKeys.FS_EDITWORKRULES_ID, new ScopeID(orgID, Scope.ORG_SCOPE))) {</span>
<span class="nc" id="L2854">			throw new SecurityException(&quot;Not authorized to edit work rules owned by org id: &quot; + orgID);</span>
		}
<span class="fc" id="L2856">	}</span>

	public Collection&lt;Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt;&gt; validate(ComplexWorkRule assignmentRule)
			throws BbmFinderException {
<span class="fc" id="L2860">		methodStart(&quot;validate&quot;, assignmentRule);</span>
<span class="fc" id="L2861">		OrganizationDAO oDao = new OrganizationDAO();</span>
		try {
<span class="fc" id="L2863">			Collection&lt;AssignmentRuleValidationError&gt; errors = new LinkedHashSet&lt;AssignmentRuleValidationError&gt;();</span>

			// Owner Org
<span class="pc bpc" id="L2866" title="1 of 2 branches missed.">			boolean orgSpecified = assignmentRule.getOrganizationID() != null;</span>
<span class="pc bpc" id="L2867" title="1 of 2 branches missed.">			if (!orgSpecified) {</span>
<span class="nc" id="L2868">				errors.add(AssignmentRuleValidationError.OwnerOrgNotSpecified);</span>
			}

			// Name Required
<span class="pc bpc" id="L2872" title="1 of 2 branches missed.">			if (StringUtil.isEmpty(assignmentRule.getName())) {</span>
<span class="nc" id="L2873">				errors.add(AssignmentRuleValidationError.NameNotSpecified);</span>
			}

			// Name Duplicate
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">			if (orgSpecified) {</span>
<span class="fc" id="L2878">				Jdmo dmo = oDao.getDMO();</span>

				// query rotation names instead of the whole object
<span class="fc" id="L2881">				String query = &quot;SELECT NAME, SID FROM COMPLEXWORKRULE A WHERE (ORGANIZATIONID IN (SELECT ID from FN_TF_CF_getParentOrgsIncludingChild(&quot;</span>
<span class="fc" id="L2882">						+ assignmentRule.getOrganizationID()</span>
						+ &quot;) )) AND WORKUNITCOUNTCONSTRAINT &lt;&gt; 6 and name = &quot;
<span class="fc" id="L2884">						+ JdmoUtil.asSqlLiteral(assignmentRule.getName());</span>
<span class="fc" id="L2885">				JdmoRowset rs = dmo.createRowset(query);</span>
<span class="pc bpc" id="L2886" title="1 of 2 branches missed.">				while (rs.next()) {</span>
<span class="nc bnc" id="L2887" title="All 2 branches missed.">					if (!rs.getID(2).equals(assignmentRule.getID())) {</span>
<span class="nc" id="L2888">						errors.add(AssignmentRuleValidationError.NameMustBeUnique);</span>
<span class="nc" id="L2889">						break;</span>
					}
				}
			}

			// Validations from Sentence.cpp

<span class="fc" id="L2896">			WorkUnit wu = assignmentRule.getWorkUnit();</span>
<span class="fc" id="L2897">			WorkUnitType wut = null;</span>
<span class="pc bpc" id="L2898" title="1 of 2 branches missed.">			if (wu == null) {</span>
<span class="nc" id="L2899">				errors.add(AssignmentRuleValidationError.WorkUnitMissing);</span>
			} else {
<span class="fc" id="L2901">				wut = assignmentRule.getWorkUnit().getWorkUnitType();</span>
			}
<span class="pc bpc" id="L2903" title="1 of 2 branches missed.">			if (wut != null) {</span>
<span class="pc bpc" id="L2904" title="3 of 5 branches missed.">				switch (wut) {</span>
				case Hours: {
<span class="fc" id="L2906">					break;</span>
				}
				case ShiftEvent: {
<span class="nc bnc" id="L2909" title="All 2 branches missed.">					if (wu.getShiftEventID() == null) {</span>
<span class="nc" id="L2910">						errors.add(AssignmentRuleValidationError.ShiftEventNotSpecified);</span>
					}
					break;
				}

				case Activity: {

					// TODO Figure out where the ActivityID is stored (on the
					// Shift?)

					/*
					 * if (idActivity == NOVALUE) {
					 * cbpsReasonInvalid.FormatMessage(IDS_NEEDSVALIDSHIFT);
					 * return FALSE; }
					 */
<span class="nc" id="L2925">					break;</span>
				}

				case Rotation: {
<span class="nc" id="L2929">					throw new IllegalArgumentException(&quot;Rotations now use a separate API from assignment rules&quot;);</span>

					/*
					 * POSITION p = cIDSetWorkPatterns.GetHeadPosition(); while
					 * (p) { ID idWorkPattern = cIDSetWorkPatterns.GetNext(p);
					 * if (idWorkPattern == NOVALUE || idWorkPattern ==
					 * theWorkRuleManager
					 * -&gt;WorkPatternTable().GetDeletedWorkPatternPlaceholder())
					 * {
					 * cbpsReasonInvalid.FormatMessage(IDS_NEEDSVALIDWORKPATTERN
					 * ); return FALSE; } } break;
					 */
				}
				}
			} // wut!= null

<span class="fc" id="L2945">			CalendarPeriod cp = assignmentRule.getCalendarPeriod();</span>
<span class="pc bpc" id="L2946" title="1 of 4 branches missed.">			if (cp == null || cp.getAlignmentDate() == null) {</span>
				// Missing CalendarPeriod is not always a bug.
				// For example, if you do a rule
				// &quot;Must Work, At Least 2, Consecutive Days, Any Time of Day&quot;,
				// there is no period selector.
				// The F&amp;S Thick Client will not store a CalendarPeriod record.
				//
				// Eventually, we will probably want to identify the specific
				// instances where it is required, but for now, just allow it to
				// be missing.

				// errors.add(AssignmentRuleValidationError.AlignmentDateMissing);
			} else {
<span class="fc" id="L2959">				LocalDate startDate = cp.getAlignmentDate();</span>
<span class="fc" id="L2960">				LocalDate endDate = assignmentRule.getEndDate();</span>
<span class="pc bpc" id="L2961" title="1 of 2 branches missed.">				if (endDate == null)</span>
<span class="nc" id="L2962">					errors.add(AssignmentRuleValidationError.EndDateMissing);</span>
				else {
<span class="pc bpc" id="L2964" title="1 of 2 branches missed.">					if (!endDate.getTime(TimeZoneUtil.GMT_TIMEZONE).after(startDate.getTime(TimeZoneUtil.GMT_TIMEZONE)))</span>
<span class="nc" id="L2965">						errors.add(AssignmentRuleValidationError.EndDateNotAfterStart);</span>
				}
			}

<span class="fc" id="L2969">			List&lt;Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt;&gt; retVal = new ArrayList&lt;Pair&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt;&gt;();</span>
<span class="pc bpc" id="L2970" title="1 of 2 branches missed.">			for (AssignmentRuleValidationError error : errors) {</span>
<span class="nc" id="L2971">				retVal.add(new Pair&lt;WorkRuleManager.AssignmentRuleValidationError, List&lt;?&gt;&gt;(error, Collections</span>
<span class="nc" id="L2972">						.emptyList()));</span>
<span class="nc" id="L2973">			}</span>
<span class="pc bpc" id="L2974" title="1 of 2 branches missed.">			for (Map.Entry&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt; entry : validateAssignmentRuleCalendarUnit(</span>
<span class="fc" id="L2975">					assignmentRule).entrySet()) {</span>
<span class="nc" id="L2976">				retVal.add(new Pair&lt;WorkRuleManager.AssignmentRuleValidationError, List&lt;?&gt;&gt;(entry.getKey(), entry</span>
<span class="nc" id="L2977">						.getValue()));</span>
<span class="nc" id="L2978">			}</span>

<span class="fc" id="L2980">			return retVal;</span>
<span class="nc" id="L2981">		} catch (Exception ex) {</span>
<span class="nc" id="L2982">			throw new BbmFinderException(ex);</span>
		} finally {
<span class="pc" id="L2984">			methodFinish();</span>
		}
	}

	/**
	 * Validates the CalendarUnit of the Assignment Rule. This validates the
	 * alignment date, whether or not the min and max work unit counts will fit,
	 * and other things.
	 * 
	 * @param assignmentRule
	 * @return
	 * @throws BbmFinderException
	 */
	private LinkedHashMap&lt;AssignmentRuleValidationError, List&lt;?&gt;&gt; validateAssignmentRuleCalendarUnit(
			ComplexWorkRule assignmentRule) throws BbmFinderException {
<span class="fc" id="L2999">		LinkedHashMap&lt;WorkRuleManager.AssignmentRuleValidationError, List&lt;?&gt;&gt; retVal = new LinkedHashMap&lt;WorkRuleManager.AssignmentRuleValidationError, List&lt;?&gt;&gt;();</span>

		// Check the Work Unit. If it isn't there, just return, since this
		// method isn't for checking the Work Unit
<span class="fc" id="L3003">		WorkUnit wu = assignmentRule.getWorkUnit();</span>
<span class="pc bpc" id="L3004" title="1 of 2 branches missed.">		if (wu == null)</span>
<span class="nc" id="L3005">			return retVal;</span>
<span class="fc" id="L3006">		WorkUnitType wut = wu.getWorkUnitType();</span>

		// Validations from Sentence.cpp

		// Check the Length of the Calendar Period
<span class="pc bpc" id="L3011" title="3 of 12 branches missed.">		if (wut != WorkUnitType.MustStartBetween &amp;&amp; wut != WorkUnitType.MustEndBetween &amp;&amp; wut != WorkUnitType.Teams</span>
				&amp;&amp; wut != WorkUnitType.SupervisorTeams &amp;&amp; wut != WorkUnitType.LeadTeams &amp;&amp; wut != WorkUnitType.NumSeats) {

			// Check For a CalendarPeriod
<span class="fc" id="L3015">			CalendarPeriod cp = assignmentRule.getCalendarPeriod();</span>
<span class="pc bpc" id="L3016" title="1 of 2 branches missed.">			if (cp != null) {</span>
<span class="fc" id="L3017">				CalendarUnit cu = cp.getCalendarUnit();</span>
<span class="fc" id="L3018">				int count = cp.getUnitCount();</span>
<span class="fc" id="L3019">				double numDays = count * cu.getNumDays();</span>
<span class="pc bpc" id="L3020" title="1 of 2 branches missed.">				if (numDays &gt; (366 * 2)) {</span>
<span class="nc" id="L3021">					retVal.put(AssignmentRuleValidationError.CalendarPeriodTooLong, Collections.emptyList());</span>
				}
			}
		}

		// Check min and max work unit counts against calendar period
<span class="fc bfc" id="L3027" title="All 2 branches covered.">		switch (wut) {</span>
		case ConsecutiveDayOfWeek:
		case ConsecutiveShift:
		case ConsecutiveFullWeekend:
		case ConsecutivePartialWeekend:
		case ConsecutiveDayOff:
		case ConsecutiveDayOfWeekOff:
		case ConsecutiveFullWeekendOff:
		case ConsecutivePartialWeekendOff:
		case MustStart:
		case Teams:
		case SupervisorTeams:
		case LeadTeams:
		case MustStartBetween:
		case MustEnd:
		case MustEndBetween:
		case NumSeats:
		case MinShiftSpacing:
		case MinShiftEventSpacing:
		case Dollars:
		case Activity:
		case ConsecutiveDay:
<span class="fc" id="L3049">			break;</span>
		default: {
			// Check For a CalendarPeriod
<span class="fc" id="L3052">			CalendarPeriod cp = assignmentRule.getCalendarPeriod();</span>
<span class="pc bpc" id="L3053" title="1 of 2 branches missed.">			if (cp == null) {</span>
<span class="nc" id="L3054">				retVal.put(AssignmentRuleValidationError.CalendarPeriodMissing, Collections.emptyList());</span>
<span class="nc" id="L3055">				return retVal;</span>
			}

<span class="fc" id="L3058">			int nCalendarUnitCount = cp.getUnitCount();</span>
			int nMaxPossibleWorkUnitCount;
<span class="pc bpc" id="L3060" title="1 of 2 branches missed.">			if (wut == WorkUnitType.ConsecutiveDay) {</span>
<span class="nc" id="L3061">				nMaxPossibleWorkUnitCount = 21;</span>
<span class="nc" id="L3062">				nCalendarUnitCount = 21;</span>
			} else
<span class="fc" id="L3064">				nMaxPossibleWorkUnitCount = getMaxPossibleWorkUnitCount(wut, cp.getCalendarUnit(), nCalendarUnitCount);</span>

<span class="fc" id="L3066">			WorkUnitCountConstraint wucc = assignmentRule.getWorkUnitCountConstraint();</span>
<span class="pc bpc" id="L3067" title="1 of 2 branches missed.">			if (wucc == null) {</span>
<span class="nc" id="L3068">				retVal.put(AssignmentRuleValidationError.WorkUnitCountConstraintMissing, Collections.emptyList());</span>
			} else {
<span class="fc" id="L3070">				int lMinWorkUnitCount = assignmentRule.getMinWorkUnitCount();</span>
<span class="fc" id="L3071">				int lMaxWorkUnitCount = assignmentRule.getMaxWorkUnitCount();</span>

<span class="pc bpc" id="L3073" title="2 of 6 branches missed.">				switch (wucc) {</span>
				case AtLeast:
<span class="pc bpc" id="L3075" title="1 of 2 branches missed.">					if (lMinWorkUnitCount &gt; nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3076">						retVal.put(</span>
								AssignmentRuleValidationError.UnsatisfiedRule,
<span class="nc" id="L3078">								Arrays.asList(new Object[] { lMinWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3079">										cp.getCalendarUnit() }));</span>
					}
					break;
				case NoMoreThan:
<span class="pc bpc" id="L3083" title="1 of 2 branches missed.">					if (lMaxWorkUnitCount &gt;= nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3084">						retVal.put(</span>
								AssignmentRuleValidationError.RedundantRule,
<span class="nc" id="L3086">								Arrays.asList(new Object[] { lMaxWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3087">										cp.getCalendarUnit() }));</span>
					}
					break;
				case AutoRotation:
				case Rotation:
				case Exactly:
<span class="pc bpc" id="L3093" title="1 of 2 branches missed.">					if (lMinWorkUnitCount &gt; nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3094">						retVal.put(</span>
								AssignmentRuleValidationError.UnsatisfiedRule,
<span class="nc" id="L3096">								Arrays.asList(new Object[] { lMinWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3097">										cp.getCalendarUnit() }));</span>
					}
					break;
				case Between:
<span class="pc bpc" id="L3101" title="1 of 2 branches missed.">					if (lMinWorkUnitCount &gt; nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3102">						retVal.put(</span>
								AssignmentRuleValidationError.UnsatisfiedRule,
<span class="nc" id="L3104">								Arrays.asList(new Object[] { lMinWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3105">										cp.getCalendarUnit() }));</span>
					}
<span class="pc bpc" id="L3107" title="1 of 2 branches missed.">					if (lMaxWorkUnitCount &gt; nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3108">						retVal.put(</span>
								AssignmentRuleValidationError.RedundantRule,
<span class="nc" id="L3110">								Arrays.asList(new Object[] { lMaxWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3111">										cp.getCalendarUnit() }));</span>
					}
					break;
				case Fairly:
				case FairlyStartingBetween:
				case FairlyEndingBetween:
<span class="nc bnc" id="L3117" title="All 2 branches missed.">					if (1 &gt; nMaxPossibleWorkUnitCount) {</span>
<span class="nc" id="L3118">						retVal.put(</span>
								AssignmentRuleValidationError.RedundantRule,
<span class="nc" id="L3120">								Arrays.asList(new Object[] { lMaxWorkUnitCount, wu, nCalendarUnitCount,</span>
<span class="nc" id="L3121">										cp.getCalendarUnit() }));</span>
					}
					break;
				}
			}
		}
		}

<span class="fc bfc" id="L3129" title="All 2 branches covered.">		if (assignmentRule.getCalendarPeriod() != null) {</span>
<span class="fc" id="L3130">			CalendarPeriod cp = assignmentRule.getCalendarPeriod();</span>

<span class="pc bpc" id="L3132" title="1 of 2 branches missed.">			if (cp.getCalendarUnit() == CalendarUnit.Week) {</span>
				Calendar orgAlignmentDate;
<span class="fc" id="L3134">				DayOfWeek orgStartDayOfWeek = null;</span>
				try {
<span class="fc" id="L3136">					Organization o = getWorkResourceManager().getOrganizationByID(assignmentRule.getOrganizationID());</span>
<span class="fc" id="L3137">					orgStartDayOfWeek = o.getWeekStartDay();</span>
<span class="nc" id="L3138">				} catch (RemoteException ex) {</span>
<span class="nc" id="L3139">					throw new BbmFinderException(ex);</span>
<span class="nc" id="L3140">				} catch (Exception ex) {</span>
<span class="nc" id="L3141">					throw new BbmFinderException(ex);</span>
<span class="fc" id="L3142">				}</span>

<span class="pc bpc" id="L3144" title="1 of 2 branches missed.">				if (orgStartDayOfWeek.getCalendarConstant() != cp.getAlignmentDate().get(Calendar.DAY_OF_WEEK)) {</span>
<span class="nc" id="L3145">					WorkUnitCountConstraint eWorkUnitCountConstraint = assignmentRule.getWorkUnitCountConstraint();</span>
<span class="nc bnc" id="L3146" title="All 6 branches missed.">					if (eWorkUnitCountConstraint == WorkUnitCountConstraint.Fairly</span>
							|| eWorkUnitCountConstraint == WorkUnitCountConstraint.FairlyStartingBetween
							|| eWorkUnitCountConstraint == WorkUnitCountConstraint.FairlyEndingBetween) {
<span class="nc" id="L3149">						retVal.put(AssignmentRuleValidationError.AlignmentDateBoundaryMismatchWarning,</span>
<span class="nc" id="L3150">								Collections.emptyList());</span>
					} else {
<span class="nc" id="L3152">						retVal.put(AssignmentRuleValidationError.AlignmentDateBoundaryMismatch, Collections.emptyList());</span>
					}
				}
			}
		}
<span class="fc" id="L3157">		return retVal;</span>
	}

	private float getDaysPerWorkUnit(WorkUnitType eWorkUnitType) {
<span class="fc" id="L3161">		float days = 0;</span>
<span class="pc bpc" id="L3162" title="1 of 4 branches missed.">		switch (eWorkUnitType) {</span>
		case ConsecutiveShift:
		case ConsecutiveDay:
		case ConsecutiveDayOff:
		case Shift:
		case ShiftEvent:
		case Activity:
		case AnyDay:
<span class="fc" id="L3170">			days = 1;</span>
<span class="fc" id="L3171">			break;</span>
		case Rotation:
		case FullWeekend:
		case PartialWeekend:
		case Weekend:
		case DayOfWeek:
		case ConsecutiveDayOfWeek:
		case ConsecutiveDayOfWeekOff:
		case ConsecutiveFullWeekend:
		case ConsecutiveFullWeekendOff:
		case ConsecutivePartialWeekend:
		case ConsecutivePartialWeekendOff:
<span class="fc" id="L3183">			days = 7;</span>
<span class="fc" id="L3184">			break;</span>
		case Hours:
<span class="fc" id="L3186">			days = .0625f;</span>
<span class="fc" id="L3187">			break;</span>
		default:
			break;
		}
<span class="fc" id="L3191">		return days;</span>
	}

	private int getMaxPossibleWorkUnitCount(WorkUnitType eWorkUnitType, CalendarUnit eCalendarUnit,
			int nCalendarUnitCount) {
<span class="fc" id="L3196">		float daysPerWorkUnit = getDaysPerWorkUnit(eWorkUnitType);</span>
<span class="fc" id="L3197">		float daysInCalendarPeriod = eCalendarUnit.getNumDays() * nCalendarUnitCount;</span>
<span class="fc" id="L3198">		int nMaxPossibleWorkUnitCount = (int) (daysInCalendarPeriod / daysPerWorkUnit);</span>
<span class="fc" id="L3199">		return nMaxPossibleWorkUnitCount;</span>
	}

	public void copyAssignmentRulesToOrg(Collection&lt;ID&gt; assignmentRuleIDs, ID orgID, LocaleContext localeContext)
			throws BbmCreateException {
<span class="nc" id="L3204">		methodStart(&quot;copyAssignmentRulesToOrg&quot;, assignmentRuleIDs, orgID);</span>
<span class="nc" id="L3205">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="nc" id="L3207">			checkPermissionsToEditWorkRules(orgID);</span>
<span class="nc" id="L3208">			dao.copyToOrg(assignmentRuleIDs, orgID, localeContext, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L3209">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3210">			throw e;</span>
<span class="nc" id="L3211">		} catch (Exception e) {</span>
<span class="nc" id="L3212">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L3214">			dao.cleanUp();</span>
<span class="nc" id="L3215">			methodFinish();</span>
<span class="nc" id="L3216">		}</span>
<span class="nc" id="L3217">	}</span>

	public void deleteAssignmentRules(Collection&lt;ID&gt; ids) throws RemoteException, BbmRemoveException {
<span class="nc" id="L3220">		methodStart(&quot;deleteAssignmentRules&quot;, ids);</span>
<span class="nc" id="L3221">		ComplexWorkRuleDAO dao = new ComplexWorkRuleDAO();</span>
		try {
<span class="nc" id="L3223">			checkPermissionsToEditAssignmentRules(ids);</span>
<span class="nc" id="L3224">			dao.deleteObjects(ids);</span>
<span class="nc" id="L3225">		} catch (RemoteException e) {</span>
<span class="nc" id="L3226">			throw e;</span>
<span class="nc" id="L3227">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L3228">			throw e;</span>
<span class="nc" id="L3229">		} catch (Exception e) {</span>
<span class="nc" id="L3230">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3232">			methodFinish();</span>
<span class="nc" id="L3233">		}</span>
<span class="nc" id="L3234">	}</span>

	public Collection&lt;TimePeriodOfDay&gt; getTimePeriodsOfDay() throws BbmFinderException {
<span class="fc" id="L3237">		methodStart(&quot;getTimePeriodsOfDay&quot;);</span>
<span class="fc" id="L3238">		TimePeriodOfDayDAO dao = new TimePeriodOfDayDAO();</span>
		try {
<span class="fc" id="L3240">			return dao.getObjects(null);</span>
		} finally {
<span class="pc" id="L3242">			dao.cleanUp();</span>
<span class="pc" id="L3243">			methodFinish();</span>
		}
	}

	public Collection getRotationRulesNameByShiftPatternIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="fc" id="L3248">		methodStart(&quot;getRotationRulesNameByShiftPatternIDs&quot;, ids);</span>
<span class="fc" id="L3249">		RotationDAO dao = new RotationDAO();</span>
		try {
<span class="fc" id="L3251">			return dao.getRotationRulesNameByShiftPatternIDs(ids);</span>
		} finally {
<span class="pc" id="L3253">			dao.cleanUp();</span>
<span class="pc" id="L3254">			methodFinish();</span>
		}
	}

	public PaginationPair&lt;TimeBank&gt; getCurrentTimeBanksByOrgHierarchy(ID orgID, boolean isAscendingSort,
			int pageIDSize, int pageIndex, LinkedHashMap&lt;DBSortField, Comparator&gt; comparators,
			Collection&lt;ID&gt; filteredIDs, String filterByName) throws BbmFinderException {
<span class="nc" id="L3261">		methodStart(&quot;getCurrentTimeBanksByOrgHierarchy&quot;, orgID, isAscendingSort, pageIDSize, pageIndex, comparators);</span>
<span class="nc" id="L3262">		TimeBankDAO timeBankDAO = new TimeBankDAO();</span>
		try {
<span class="nc" id="L3264">			return timeBankDAO.getCompletePaginationDataSetForOrg(orgID, isAscendingSort, pageIDSize, pageIndex,</span>
					comparators, filteredIDs, filterByName);
<span class="nc" id="L3266">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3267">			handleException(ex);</span>
<span class="nc" id="L3268">			throw ex;</span>
		} finally {
<span class="nc" id="L3270">			timeBankDAO.cleanUp();</span>
<span class="nc" id="L3271">			methodFinish();</span>
		}
	}

	public Collection&lt;ID&gt; createTimeBanks(Collection&lt;TimeBank&gt; tbs) throws BbmCreateException {
<span class="nc" id="L3276">		methodStart(&quot;createTimeBanks&quot;, tbs);</span>
<span class="nc" id="L3277">		TimeBankDAO dao = null;</span>
		try {
<span class="nc" id="L3279">			dao = new TimeBankDAO();</span>
<span class="nc" id="L3280">			return dao.createObjects(tbs);</span>
<span class="nc" id="L3281">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3282">			throw e;</span>
		} finally {
<span class="nc bnc" id="L3284" title="All 4 branches missed.">			if (dao != null)</span>
<span class="nc" id="L3285">				dao.cleanUp();</span>
<span class="nc" id="L3286">			methodFinish();</span>
		}
	}

	public void updateTimeBanks(Collection&lt;TimeBank&gt; timeBanks) throws BbmUpdateException {
<span class="nc" id="L3291">		methodStart(&quot;updateTimeBanks&quot;, timeBanks);</span>
<span class="nc" id="L3292">		TimeBankDAO tbDAO = new TimeBankDAO();</span>
		try {
<span class="nc bnc" id="L3294" title="All 2 branches missed.">			for (TimeBank timeBank : timeBanks) {</span>
<span class="nc" id="L3295">				timeBank.setModifiedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L3296">				timeBank.setModifiedDate(new Date());</span>
<span class="nc" id="L3297">			}</span>
<span class="nc" id="L3298">			tbDAO.updateObjects(timeBanks);</span>
<span class="nc" id="L3299">		} catch (MultiUserException ex) {</span>
<span class="nc" id="L3300">			throw new BbmUpdateException(ex);</span>
		} finally {
<span class="nc" id="L3302">			tbDAO.cleanUp();</span>
<span class="nc" id="L3303">			methodFinish();</span>
<span class="nc" id="L3304">		}</span>
<span class="nc" id="L3305">	}</span>
	/**
	 * Finds if timebankplannerdata with same name exists
	 *
	 * @param name: timebankplannerdata
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public boolean isTimebankPlannerDataNameExists(String name) throws BbmFinderException, RemoteException {
<span class="nc" id="L3314">		methodStart(&quot;isTimebankPlannerDataNameExists&quot;, name);</span>
		try {
<span class="nc" id="L3316">			TimeBankPlannerDataDAO dao = new TimeBankPlannerDataDAO();</span>
<span class="nc" id="L3317">			ID tbPlannerId = dao.getTimeBankPlannerDataIDByName(name);</span>
<span class="nc bnc" id="L3318" title="All 2 branches missed.">			return tbPlannerId != null;</span>
<span class="nc" id="L3319">		} catch (JdmoException ex) {</span>
<span class="nc" id="L3320">			handleException(ex);</span>
<span class="nc" id="L3321">			throw new BbmFinderException(ex);</span>
		} finally {
<span class="nc" id="L3323">			methodFinish();</span>
		}
	}

	/**
	 * Deletes timebankplannerdata given the name
	 *
	 * @param name
	 * @throws BbmRemoveException
	 * @throws RemoteException
	 */

	public void deleteTimebankPlannerData(String name) throws BbmRemoveException, RemoteException {
<span class="nc" id="L3336">		methodStart(&quot;deleteTimebankPlannerData&quot;, name);</span>
		try {
<span class="nc" id="L3338">			TimeBankPlannerDataDAO dao = new TimeBankPlannerDataDAO();</span>
<span class="nc" id="L3339">			dao.deleteTimeBankPlannerDataByName(name);</span>
<span class="nc" id="L3340">		} catch (BbmRemoveException ex) {</span>
<span class="nc" id="L3341">			handleException(ex);</span>
<span class="nc" id="L3342">			throw ex;</span>
		} finally {
<span class="nc" id="L3344">			methodFinish();</span>
<span class="nc" id="L3345">		}</span>
<span class="nc" id="L3346">	}</span>

	/**
	 * Creates timebankplannerdata
	 *
	 * @throws BbmCreateException
	 * @throws RemoteException
	 */

	public void saveTimebankPlannerData(Collection&lt;TimeBankPlannerData&gt; timeBankPlannerData) throws BbmCreateException, RemoteException {
<span class="nc" id="L3356">		methodStart(&quot;saveTimebankPlannerData&quot;, timeBankPlannerData);</span>
<span class="nc" id="L3357">		TimeBankPlannerDataDAO dao = null;</span>
		try {
<span class="nc" id="L3359">			dao = new TimeBankPlannerDataDAO();</span>
<span class="nc" id="L3360">			dao.createObjects(timeBankPlannerData);</span>
<span class="nc" id="L3361">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3362">			handleException(e);</span>
<span class="nc" id="L3363">			throw e;</span>
		} finally {
<span class="nc bnc" id="L3365" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L3366">				dao.cleanUp();</span>
			}
<span class="nc" id="L3368">			methodFinish();</span>
<span class="nc" id="L3369">		}</span>
<span class="nc" id="L3370">	}</span>
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>