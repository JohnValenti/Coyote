<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">TraceUtil.java</span></div><h1>TraceUtil.java</h1><pre class="source lang-java linenums">/*
 * (c) 2007-2011 Verint Systems, Inc.
 */
//TODO: Insert correct original year of publication
package com.bluepumpkin.ejb.bbm.timeseries.util;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.MathUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrForecastedTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrRequiredTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceChunk;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.workload.model.TimeUnit;
/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  TraceUtil object, Utility class for all Trace operations
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Sheng Song
 * @version 2.0
 */

<span class="pc bpc" id="L38" title="1 of 2 branches missed.">public class TraceUtil implements Serializable {</span>
//	static final long serialVersionUID = -6716073332438940759L;

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
<span class="fc" id="L45">	public static final ActualTraceCube META_ACTUAL = new ActualTraceCube();</span>
<span class="fc" id="L46">	public static final ActualTraceCube META_REPORT_ACTUAL = new ActualTraceCube(new short[] {Trace.CV, Trace.AHT,Trace.PCA,</span>
																							  Trace.ASA,Trace.ABANDONMENT,
																							  Trace.BACKLOG,Trace.STAFFING,
																							  Trace.OCCUPANCY,Trace.FTE,
																							  Trace.DIALS,Trace.CONNECTS,
																							  Trace.CRATE,Trace.RPC,
																							  Trace.RPCRATE,Trace.RPCAHT, Trace.VH, Trace.VAR});
<span class="fc" id="L53">	public static final ActualTraceCube META_ACTUAL_STAFFING = new ActualTraceCube(new short[] {Trace.STAFFING});</span>
<span class="fc" id="L54">	public static final ForecastTraceCube META_FORECAST = new ForecastTraceCube(new short[]{ Trace.CV, Trace.AHT, Trace.CRATE, Trace.RPCAHT, Trace.RPCRATE});</span>
<span class="fc" id="L55">	public static final PredictTraceCube META_REPORT_PREDICT = new PredictTraceCube(new short[] {Trace.PCA,Trace.ASA,</span>
																								 Trace.ABANDONMENT,Trace.BACKLOG,
																								 Trace.STAFFING,Trace.OCCUPANCY,
																								 Trace.FTE,Trace.DIALS,Trace.CONNECTS,Trace.RPC });
<span class="fc" id="L59">	public static final PredictTraceCube META_PREDICT = new PredictTraceCube();</span>
<span class="fc" id="L60">	public static final RequireTraceCube META_REQUIRE = new RequireTraceCube();</span>
<span class="fc" id="L61">	public static final ServiceGoalTraceCube META_REPORT_SERVICEGOAL =	new ServiceGoalTraceCube(new short[] {Trace.PCA, Trace.ASA, Trace.ABANDONMENT});</span>
<span class="fc" id="L62">	public static final ServiceGoalTraceCube META_SERVICEGOAL =	new ServiceGoalTraceCube();</span>

<span class="fc" id="L64">	public static final ActualTraceCube META_ACTUAL_FORECAST = new ActualTraceCube(ForecastTraceCube.TYPES);</span>
<span class="fc" id="L65">    public static final ActualTraceCube META_ACTUAL_COMBINE = new ActualTraceCube(new short[]{Trace.ABANDONMENT, Trace.AHT, Trace.ASA, Trace.BACKLOG, Trace.CV, Trace.PCA});</span>
<span class="fc" id="L66">	public static final ActualTraceCube META_ACTUAL_STFOCU = new ActualTraceCube(new short[]{Trace.STAFFING, Trace.OCCUPANCY});</span>
<span class="fc" id="L67">	public static final ForecastTraceCube META_FORECAST_COMBINE = new ForecastTraceCube(ForecastTraceCube.TYPES);</span>
<span class="fc" id="L68">	public static final ServiceGoalTraceCube META_SG_PCA = new ServiceGoalTraceCube(ServiceGoalTraceCube.PCA_ABN);</span>
<span class="fc" id="L69">	public static final ServiceGoalTraceCube META_SG_ASA = new ServiceGoalTraceCube(ServiceGoalTraceCube.ASA_ABN);</span>

<span class="fc" id="L71">	public static final AggrForecastedTraceCube META_AGGR_FORECAST = new AggrForecastedTraceCube();</span>
<span class="fc" id="L72">	public static final AggrRequiredTraceCube META_AGGR_REQUIRE = new AggrRequiredTraceCube();</span>

<span class="fc" id="L74">	public static final TraceChunk NULL_TraceChunk = new TraceChunk(null, null);</span>
<span class="fc" id="L75">	public static final TraceChunk[] NULL_TraceChunkArray = new TraceChunk[]{NULL_TraceChunk,</span>
																			NULL_TraceChunk,
																			NULL_TraceChunk,
																			NULL_TraceChunk,
																			NULL_TraceChunk};

	public static final short TIMEINTERVAL_STAT = 0;
	public static final short NUMBER_STAT = 1;
	public static final short PERCENTAGE_STAT = 2;

	public static final short QueueCampaign = 0;
	public static final short ForecastTrace = 1;
	public static final short PredictTrace = 2;
	public static final short ServiceGoalTrace = 3;
	public static final short RequireTrace = 4;
	public static final short MAXAREA = 5;

	public static short getAreaType(TraceCube cube) {
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (cube instanceof ForecastTraceCube)</span>
<span class="nc" id="L94">			return 1;</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">		if (cube instanceof PredictTraceCube)</span>
<span class="nc" id="L96">			return 2;</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (cube instanceof ServiceGoalTraceCube)</span>
<span class="nc" id="L98">			return 3;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">		if (cube instanceof RequireTraceCube)</span>
<span class="nc" id="L100">			return 4;</span>
<span class="nc" id="L101">		return 0;</span>
	}
	/**
	 * Routine to convert a Date to &quot;StartDate&quot; and &quot;OffSet&quot;, related to the schema
	 * The OffSet is always based on GMT
	 * @param Date, any date
	 * @return Object[], 0 is the &quot;StartDate&quot;, 1 is the &quot;OffSet&quot;
	 */
	public static InsertionPoint getInsertionPoint(Date date) {
<span class="fc" id="L110">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L111">		cal.setTime(date);</span>
<span class="fc" id="L112">		short hour = (short)cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L113">		short min = (short)cal.get(Calendar.MINUTE);</span>
<span class="fc" id="L114">		short offSet = (short) (hour * 4 + min / 15);</span>
<span class="fc" id="L115">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L116">		cal.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L117">		cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L118">		cal.set(Calendar.MILLISECOND, 0);</span>
		// If the Date is just midnight, it will be counted as 1st point
<span class="fc" id="L120">		return new InsertionPoint(cal.getTime(), ++offSet);</span>
	}

	/**
	 * This class represents an insertion point, represented as a Date and a
	 * short index into the 15-minute intervals comprising that date.
	 * &lt;p&gt;
	 * This class is not immutable since the Date object is not immutable.
	 * To improve performance its fields are public and are not defensively
	 * copied on read/write.  Modifying the date field after instantiation
	 * may produce undesirable results.
	 */
<span class="nc" id="L132">	public static class InsertionPoint {</span>
		/** The base date for the insertion point. */
		public final Date startDate;
		/** The index into the date in 15-minute intervals.  Midnight is represented as 1. */
		public final short offset;
<span class="fc" id="L137">		public InsertionPoint(Date date, short offset) {</span>
<span class="fc" id="L138">			this.startDate = date;</span>
<span class="fc" id="L139">			this.offset = offset;</span>
<span class="fc" id="L140">		}</span>
	}

	/**
	 * A shallow copy of the TraceCube to another type of TraceCube
	 * @param TraceCube, any existing TraceCube
	 * @param TraceCube, a MetaCube defined in TraceUtil
	 * @return TraceCube, an instanceof MetaCube
	 */
	public static TraceCube convertTraceCube(TraceCube tc, TraceCube metaTC)
		throws BbmTimeSeriesException {
<span class="pc bpc" id="L151" title="2 of 4 branches missed.">		if (tc == null || metaTC == null)</span>
<span class="nc" id="L152">			return null;</span>
<span class="fc" id="L153">		long milli = tc.getRawEndDate().getTime();</span>
<span class="fc" id="L154">		int points = tc.getMaximumLength(tc.getTraceTypes());</span>
<span class="fc" id="L155">		short[] types = new short[tc.getTraceTypes().length];</span>
<span class="fc" id="L156">		System.arraycopy(tc.getTraceTypes(), 0, types, 0, types.length);</span>
<span class="fc" id="L157">		int origPoints = gapOffSet(tc.getStartDate(), tc.getStartOffSet(), tc.getRawEndDate());</span>
<span class="fc" id="L158">		origPoints++;</span>
<span class="fc" id="L159">		milli += (points - origPoints) * 15l * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">		ID queueID = tc.getQueueID() == null ? null : new ID(tc.getQueueID());</span>
<span class="fc" id="L161">		TraceCube result = metaTC.newInstance(queueID, (Date)tc.getRawStartDate().clone(), new Date(milli),	types);</span>
<span class="fc" id="L162">		return result;</span>
	}

	/**
	 * Date need be snapped into closest 15 minutes interval time
	 * @param Date, original
	 * @return Date, snapped date
	 */
	public static Date snapDate(Date date) {
<span class="fc bfc" id="L171" title="All 2 branches covered.">		if (date == null)</span>
<span class="fc" id="L172">			return null;</span>
<span class="fc" id="L173">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L174">		cal.setTime(date);</span>
<span class="fc" id="L175">		cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L176">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L177">		int minute = cal.get(Calendar.MINUTE);</span>
<span class="fc" id="L178">		minute = minute / Trace.INTERVAL;</span>
<span class="fc" id="L179">		cal.set(Calendar.MINUTE, Trace.INTERVAL * minute);</span>
<span class="fc" id="L180">		return cal.getTime();</span>
	}
	/**
	 * validate multiple tracecubes, must have same length, same trace types
	 * as invalid parameters won't be continued in operation, just throw exception
	 * @return TraceCube, a holder traceCube which has the same start/end definition of first TraceCube
	 */
	public static TraceCube validateTraceCubes(TraceCube[] cubes) throws BbmTimeSeriesException {
<span class="fc" id="L188">		TraceCube firstCube = null;</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">		for (int i=0; i&lt;cubes.length; i++) {</span>
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">			if (cubes[i] != null) {</span>
<span class="fc" id="L191">				firstCube = cubes[i];</span>
<span class="fc" id="L192">				break;</span>
			}
		}
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">		if (firstCube == null)</span>
<span class="nc" id="L196">			return null;</span>
<span class="fc" id="L197">		short[] types = firstCube.getTraceTypes();</span>
<span class="fc" id="L198">		int length = firstCube.getMaximumLength(types);</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">		for (int i=1; i&lt;cubes.length; i++) {</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">			if (cubes[i] == null)</span>
<span class="nc" id="L201">				continue;</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">			if (!cubes[i].matchingTypes(types)) {</span>
<span class="nc" id="L203">				throw new BbmTimeSeriesException(BbmTimeSeriesException.CUBES_DIFF_TYPE);</span>
			}
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">			if (cubes[i].getMaximumLength(types) != length) {</span>
<span class="nc" id="L206">				throw new BbmTimeSeriesException(BbmTimeSeriesException.CUBES_DIFF_LENGTH);</span>
			}
		}
<span class="fc" id="L209">		return firstCube.cloneTraceCube();</span>
	}
	/**
	 * For aggregated view, we have to include more trace types
	 * For example, AHT aggregation requires CV
	 * @param short, type
	 * @return short
	 */
	public static short[] getAggTraceType(TraceCube actualCube, TraceCube forecastCube,int excPoints, short type) {
		// Occupancy is Sum(Staffing*Occupancy)/Sum(Staffing)
		// ASA is Sum((CV - ABN)*ASA)/Sum(CV - ABN)
		// AHT/PCA is Sum(CV*AHT)/Sum(CV)
<span class="nc bnc" id="L221" title="All 12 branches missed.">		switch(type) {</span>
			case Trace.AHT:
				{
<span class="nc" id="L224">					boolean addCV = false, addConnects = false;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">					for (int i = 0; i &lt; excPoints; i++) {</span>
<span class="nc bnc" id="L226" title="All 4 branches missed.">						if (actualCube.getTraceValueD(Trace.CV_VH, i) &gt; 0 || forecastCube.getTraceValueD(Trace.CV_VH, i) &gt; 0) {</span>
<span class="nc" id="L227">							addCV = true;</span>
						}
<span class="nc bnc" id="L229" title="All 4 branches missed.">						if (actualCube.getTraceValueD(Trace.CONNECTS, i) &gt; 0 || forecastCube.getTraceValueD(Trace.CONNECTS, i) &gt; 0) {</span>
<span class="nc" id="L230">							addConnects = true;</span>
						}
<span class="nc bnc" id="L232" title="All 4 branches missed.">						if (addCV &amp;&amp; addConnects) {</span>
<span class="nc" id="L233">							return new short[]{Trace.CV_VH, Trace.CONNECTS};</span>
						}
					}
<span class="nc bnc" id="L236" title="All 2 branches missed.">					return new short[]{(addConnects ? Trace.CONNECTS : Trace.CV_VH)};</span>
				}
			case Trace.FORECASTING_AHT:
<span class="nc" id="L239">				return new short[] {Trace.CV_VH, Trace.CRATE};</span>
			case Trace.PCA:
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
<span class="nc" id="L243">				return new short[] {Trace.VAR};</span>
			case Trace.OCCUPANCY:
<span class="nc" id="L245">				return new short[] {Trace.STAFFING};</span>
			case Trace.ASA:
			case Trace.SERVICE_GOALS_ASA:
<span class="nc" id="L248">				return new short[] {Trace.CV, Trace.ABANDONMENT};</span>
			case Trace.CONNECTS:
<span class="nc" id="L250">				 return new short[] {Trace.DIALS, Trace.CRATE};</span>
			case Trace.CRATE:
<span class="nc" id="L252">				 return new short[] {Trace.CONNECTS, Trace.DIALS};</span>
			case Trace.RPC:
<span class="nc" id="L254">				return new short[] {Trace.DIALS, Trace.RPCRATE};</span>
			case Trace.RPCRATE:
<span class="nc" id="L256">				return new short[] {Trace.RPC, Trace.DIALS};</span>
			case Trace.RPCAHT :
<span class="nc" id="L258">				return new short[] {Trace.RPC};</span>
			case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L260">				return new short[] {Trace.RPCRATE};</span>
			default:
<span class="nc" id="L262">				return null;</span>
		}
	}
	/**
	 * For aggregated view, we have to include more trace types
	 * For example, AHT aggregation requires CV
	 * @param short[], types
	 * @return short[]
	 */
	public static short[] getAggTraceType(short[] types) {
		// Occupancy is Sum(Staffing*Occupancy)/Sum(Staffing)
		// ASA is Sum((CV - ABN)*ASA)/Sum(CV - ABN)
		// AHT/PCA is Sum(CV*AHT)/Sum(CV)
<span class="fc" id="L275">		boolean needCV = false;</span>
<span class="fc" id="L276">		boolean hasCV = false;</span>
<span class="fc" id="L277">		boolean needABN = false;</span>
<span class="fc" id="L278">		boolean hasABN = false;</span>
<span class="fc" id="L279">		boolean needSTF = false;</span>
<span class="fc" id="L280">		boolean hasSTF = false;</span>
<span class="fc" id="L281">	    boolean needDials =false;</span>
<span class="fc" id="L282">	    boolean hasDials =false;</span>
<span class="fc" id="L283">		boolean needConnects=false;</span>
<span class="fc" id="L284">		boolean hasConnects=false;</span>
<span class="fc" id="L285">		boolean needCRate =false;</span>
<span class="fc" id="L286">		boolean hasCRate=false;</span>
<span class="fc" id="L287">		boolean needRPC =false;</span>
<span class="fc" id="L288">		boolean hasRPC =false;</span>
<span class="fc" id="L289">		boolean needRPCRate =false;</span>
<span class="fc" id="L290">		boolean hasRPCRate =false;</span>
<span class="fc" id="L291">		boolean needVH = false;</span>
<span class="fc" id="L292">		boolean hasVH = false;</span>
<span class="fc" id="L293">		boolean needVAR = false;</span>
<span class="fc" id="L294">		boolean hasVAR = false;</span>
<span class="fc" id="L295">		boolean needCV_VH  = false;</span>
<span class="fc" id="L296">		boolean hasCV_VH  = false;</span>
<span class="fc" id="L297">		boolean needFTE =false;</span>
<span class="fc" id="L298">		boolean hasFTE =false;</span>
<span class="fc" id="L299">		boolean needASTF = false;</span>
<span class="fc" id="L300">		boolean hasASTF = false;</span>
<span class="fc" id="L301">		boolean needAFTE =false;</span>
<span class="fc" id="L302">		boolean hasAFTE =false;</span>

<span class="fc bfc" id="L304" title="All 2 branches covered.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="pc bpc" id="L305" title="2 of 23 branches missed.">			switch(types[i]) {</span>
				case Trace.CV:
<span class="fc" id="L307">					hasCV = true;</span>
<span class="fc" id="L308">					break;</span>
				case Trace.AHT:
<span class="fc" id="L310">					needCV = true;</span>
<span class="fc" id="L311">					needConnects=true;</span>
<span class="fc" id="L312">					needCRate=true;</span>
<span class="fc" id="L313">					needDials=true;</span>
<span class="fc" id="L314">					needCV_VH=true;</span>
<span class="fc" id="L315">					needVH=true;</span>
<span class="fc" id="L316">					break;</span>
				case Trace.PCA:
				case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
				case Trace.SERVICE_GOALS_PCA_DEFERRED:
<span class="fc" id="L320">					needCV = true;</span>
<span class="fc" id="L321">					needVAR=true;</span>
<span class="fc" id="L322">					needVH=true;</span>
<span class="fc" id="L323">					needABN = true;</span>
<span class="fc" id="L324">					break;</span>
				case Trace.ABANDONMENT:
<span class="fc" id="L326">					hasABN = true;</span>
<span class="fc" id="L327">					break;</span>
				case Trace.OCCUPANCY:
<span class="fc" id="L329">					needSTF = true;</span>
<span class="fc" id="L330">					break;</span>
				case Trace.STAFFING:
<span class="fc" id="L332">					hasSTF = true;</span>
<span class="fc" id="L333">					needFTE=true;</span>
<span class="fc" id="L334">					break;</span>
				case Trace.FTE:
<span class="fc" id="L336">					hasFTE = true;</span>
<span class="fc" id="L337">					break;</span>
				case Trace.ASTAFFING:
<span class="fc" id="L339">					hasASTF = true;</span>
<span class="fc" id="L340">					needAFTE=true;</span>
<span class="fc" id="L341">					break;</span>
				case Trace.AFTE:
<span class="fc" id="L343">					hasAFTE = true;</span>
<span class="fc" id="L344">					break;</span>
				case Trace.NETSTAFFING:
<span class="fc" id="L346">					needASTF=true;</span>
<span class="fc" id="L347">					needAFTE=true;</span>
<span class="fc" id="L348">					needFTE=true;</span>
<span class="fc" id="L349">					needSTF=true;</span>
<span class="fc" id="L350">					break;</span>
				case Trace.ASA:
				case Trace.SERVICE_GOALS_ASA:
<span class="fc" id="L353">					needABN = true;</span>
<span class="fc" id="L354">					needCV = true;</span>
<span class="fc" id="L355">					break;</span>
				case Trace.DIALS:
<span class="fc" id="L357">					hasDials =true;</span>
<span class="fc" id="L358">					break;</span>
				case Trace.CONNECTS:
<span class="fc" id="L360">					hasConnects =true;</span>
<span class="fc" id="L361">					needCRate =true;</span>
<span class="fc" id="L362">					needDials=true;</span>
<span class="fc" id="L363">					break;</span>
				case Trace.CRATE:
<span class="fc" id="L365">					hasCRate = true;</span>
<span class="fc" id="L366">					needConnects = true;</span>
<span class="fc" id="L367">					needDials = true;</span>
<span class="fc" id="L368">					break;</span>
				case Trace.RPC:
<span class="fc" id="L370">					hasRPC = true;</span>
<span class="fc" id="L371">					needRPCRate = true;</span>
<span class="fc" id="L372">					needDials = true;</span>
<span class="fc" id="L373">					break;</span>
				case Trace.RPCRATE:
<span class="fc" id="L375">					hasRPCRate = true;</span>
<span class="fc" id="L376">					needRPC = true;</span>
<span class="fc" id="L377">					needDials = true;</span>
<span class="fc" id="L378">					break;</span>
				case Trace.RPCAHT:
<span class="fc" id="L380">					needRPC = true;</span>
<span class="fc" id="L381">					needRPCRate = true;</span>
<span class="fc" id="L382">					needDials = true;</span>
<span class="fc" id="L383">					break;</span>
				case Trace.VH:
<span class="fc" id="L385">					hasVH = true;</span>
<span class="fc" id="L386">					break;</span>
				case Trace.VAR:
<span class="fc" id="L388">					hasVAR = true;</span>
<span class="fc" id="L389">					break;</span>
				case Trace.CV_VH:
<span class="fc" id="L391">					hasCV_VH = true;</span>
<span class="fc" id="L392">					break;</span>
				case Trace.FORECASTING_AHT:
<span class="nc" id="L394">					needCV = true;</span>
<span class="nc" id="L395">					needCRate=true;</span>
<span class="nc" id="L396">					needCV_VH=true;</span>
<span class="nc" id="L397">					needVH=true;</span>
<span class="nc" id="L398">					break;</span>
				case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L400">					needRPCRate = true;</span>
					break;
			}
		}
		// At most add 8 more types
<span class="fc" id="L405">		short[] result = new short[types.length + 11];</span>
<span class="fc" id="L406">		int length = types.length;</span>
<span class="fc" id="L407">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="pc bpc" id="L408" title="1 of 4 branches missed.">		if (needCV &amp;&amp; !hasCV) {</span>
<span class="fc" id="L409">			result[length++] = Trace.CV;</span>
		}
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">		if (needABN &amp;&amp; !hasABN) {</span>
<span class="fc" id="L412">			result[length++] = Trace.ABANDONMENT;</span>
		}
<span class="pc bpc" id="L414" title="1 of 4 branches missed.">		if (needSTF &amp;&amp; !hasSTF) {</span>
<span class="nc" id="L415">			result[length++] = Trace.STAFFING;</span>
		}
<span class="pc bpc" id="L417" title="1 of 4 branches missed.">		if (needFTE &amp;&amp; !hasFTE) {</span>
<span class="nc" id="L418">			result[length++] = Trace.FTE;</span>
		}
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">		if (needASTF &amp;&amp; !hasASTF) {</span>
<span class="nc" id="L421">			result[length++] = Trace.ASTAFFING;</span>
		}
<span class="pc bpc" id="L423" title="1 of 4 branches missed.">		if (needAFTE &amp;&amp; !hasAFTE) {</span>
<span class="nc" id="L424">			result[length++] = Trace.AFTE;</span>
		}
<span class="fc bfc" id="L426" title="All 4 branches covered.">		if (needDials &amp;&amp; !hasDials) {</span>
<span class="fc" id="L427">			result[length++] = Trace.DIALS;</span>
		}
<span class="fc bfc" id="L429" title="All 4 branches covered.">		if (needConnects &amp;&amp; !hasConnects) {</span>
<span class="fc" id="L430">			result[length++] = Trace.CONNECTS;</span>
		}
<span class="fc bfc" id="L432" title="All 4 branches covered.">		if (needCRate &amp;&amp; !hasCRate) {</span>
<span class="fc" id="L433">			result[length++] = Trace.CRATE;</span>
		}
<span class="pc bpc" id="L435" title="1 of 4 branches missed.">		if (needRPC &amp;&amp; !hasRPC) {</span>
<span class="nc" id="L436">			result[length++] = Trace.RPC;</span>
		}
<span class="pc bpc" id="L438" title="1 of 4 branches missed.">		if (needRPCRate &amp;&amp; !hasRPCRate) {</span>
<span class="nc" id="L439">			result[length++] = Trace.RPCRATE;</span>
		}
<span class="pc bpc" id="L441" title="1 of 4 branches missed.">		if (needVH &amp;&amp; !hasVH) {</span>
<span class="fc" id="L442">			result[length++] = Trace.VH;</span>
		}
<span class="pc bpc" id="L444" title="1 of 4 branches missed.">		if (needVAR &amp;&amp; !hasVAR) {</span>
<span class="fc" id="L445">			result[length++] = Trace.VAR;</span>
		}
<span class="fc bfc" id="L447" title="All 4 branches covered.">		if (needCV_VH &amp;&amp; !hasCV_VH) {</span>
<span class="fc" id="L448">			result[length++] = Trace.CV_VH;</span>
		}
<span class="fc" id="L450">		short[] retResult = new short[length];</span>
<span class="fc" id="L451">		System.arraycopy(types, 0, retResult, 0, types.length);</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">		if (length &gt; types.length)</span>
<span class="fc" id="L453">    		System.arraycopy(result, types.length, retResult, types.length, length-types.length);</span>
<span class="fc" id="L454">		return retResult;</span>
	}

	/**
	 * Aggregatable check
	 * @param TraceCube
	 * @param short, type
	 * @return boolean
	 */
	public static boolean aggregatable(TraceCube cube, short type) {
<span class="nc bnc" id="L464" title="All 2 branches missed.">		if (cube.getTraceValueD(type) == null)</span>
<span class="nc" id="L465">			return false;</span>
<span class="nc" id="L466">		short[] oType = new short[1];</span>
<span class="nc" id="L467">		oType[0] = type;</span>
<span class="nc" id="L468">		short[] aType = getAggTraceType(oType);</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">		for (int i=0; i&lt;aType.length; i++) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">			if (cube.getTraceValueD(aType[i]) == null)</span>
<span class="nc" id="L471">				return false;</span>
			continue;
		}
<span class="nc" id="L474">		return true;</span>
	}
	/**
	 * Different trace statistics has different value type
	 * @param short, type
	 * @param short, metric type
	 */
	public static short getMetricType(short type) {
<span class="nc bnc" id="L482" title="All 4 branches missed.">		switch(type) {</span>
			case Trace.CV:
			case Trace.OCCUPANCY:
			case Trace.BACKLOG:
			case Trace.ABANDONMENT:
			case Trace.DIALS:
			case Trace.CONNECTS:
			case Trace.RPC:
			case Trace.VH:
			case Trace.VAR:
			case Trace.MAX_DIALS:
<span class="nc" id="L493">				return NUMBER_STAT;</span>
			case Trace.PCA:
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
			case Trace.CRATE:
			case Trace.FORECASTING_CRATE:
			case Trace.RPCRATE:
			case Trace.FORECASTING_RPCRATE:
<span class="nc" id="L501">				return PERCENTAGE_STAT;</span>
			case Trace.FTE:
			case Trace.STAFFING:
			case Trace.AHT:
			case Trace.FORECASTING_AHT:
			case Trace.ASA:
			case Trace.SERVICE_GOALS_ASA:
			case Trace.RPCAHT:
			case Trace.FORECASTING_RPCAHT:
			case Trace.DEADLINE_TIME:
			case Trace.SERVICE_GOALS_DEADLINE_TIME:
			case Trace.AFTE:
			case Trace.ASTAFFING:
			case Trace.NETSTAFFING:
<span class="nc" id="L515">				return TIMEINTERVAL_STAT;</span>
		}
<span class="nc" id="L517">		return (short)-1;</span>
	}
	/**
	 * For combined view, we have to include more trace types
	 * For example, ASA is Sum(ABN*ASA)/Sum(ABN)
	 * @param short[], types
	 * @return short[]
	 */
	public static short[] getCmbTraceType(short[] types) {
<span class="fc" id="L526">           return getAggTraceType( types);</span>
	}
	/**
	 * Filter out Trace Types, based on supported Trace Types of the TraceCube
	 * @param short[], types
	 * @return short[]
	 */
	public static short[] getSupportedTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L534">		int j = 0;</span>
<span class="nc" id="L535">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">			if (!cube.supportType(types[i]))</span>
<span class="nc" id="L538">				removed[j++] = types[i];</span>
		}
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">			if (j == types.length)</span>
<span class="nc" id="L542">				return null;</span>
<span class="nc" id="L543">			short[] result = new short[types.length-j];</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">			for (int i=0, k=0, l=0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L546">					result[i++] = types[l];</span>
<span class="nc" id="L547">					continue;</span>
				}
<span class="nc bnc" id="L549" title="All 2 branches missed.">				if (types[l] != removed[k])</span>
<span class="nc" id="L550">					result[i++] = types[l];</span>
				else
<span class="nc" id="L552">					k++;</span>
			}
<span class="nc" id="L554">			return result;</span>
		}
<span class="nc" id="L556">        short[] result = new short[types.length];</span>
<span class="nc" id="L557">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L558">        return result;</span>
	}

	/**
	 * Helper function to tell if a type is defined in the given cube or not
	 * @param cube
	 * @param type
	 * @return
	 */
	public static boolean containTraceType(TraceCube cube, short type) {
<span class="nc bnc" id="L568" title="All 2 branches missed.">	    if (cube.getTraceTypes() != null) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">	        for (int i=0; i&lt;cube.getTraceTypes().length; i++) {</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">	            if (type == cube.getTraceTypes()[i])</span>
<span class="nc" id="L571">	                return true;</span>
	        }
	    }
<span class="nc" id="L574">	    return false;</span>
	}
	/**
	 * Get Trace Types, that is support to particular TraceCube
	 * @param TraceCube, cube
	 * @param short[], Trace Types
	 * @return short[], Valid Trace Types
	 */
	public static short[] containTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L583">		int j = 0;</span>
<span class="nc" id="L584">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">			if (cube.getTraceValueD(types[i]) == null)</span>
<span class="nc" id="L587">				removed[j++] = types[i];</span>
		}
<span class="nc bnc" id="L589" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">			if (j == types.length)</span>
<span class="nc" id="L591">				return null;</span>
<span class="nc" id="L592">			short[] result = new short[types.length-j];</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">			for (int i=0, k=0, l=0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L595">					result[i++] = types[l];</span>
<span class="nc" id="L596">					continue;</span>
				}
<span class="nc bnc" id="L598" title="All 2 branches missed.">				if (types[l] != removed[k])</span>
<span class="nc" id="L599">					result[i++] = types[l];</span>
				else
<span class="nc" id="L601">					k++;</span>
			}
<span class="nc" id="L603">			return result;</span>
		}
<span class="nc" id="L605">        short[] result = new short[types.length];</span>
<span class="nc" id="L606">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L607">        return result;</span>
	}
    /**
     * Based a cube, given an array of trace types
     * Only return types not support by the given cube
     * @param TraceCube, cube
     * @param short[], types
     * @return short[][], [0] unsupported types, [1] supported types
     */
    public static short[][] filterOutTraceType(TraceCube cube, short[] types) {
<span class="nc bnc" id="L617" title="All 2 branches missed.">        if (cube == null) {</span>
            // This means it doesn't support combined mode, everything goes to individual queues
<span class="nc" id="L619">            short[][] result = new short[2][0];</span>
<span class="nc" id="L620">            result[0] = null;</span>
<span class="nc" id="L621">            result[1] = new short[types.length];</span>
<span class="nc" id="L622">            System.arraycopy(types, 0, result[1], 0, types.length);</span>
<span class="nc" id="L623">            return result;</span>
        };
<span class="nc" id="L625">		short[] removed = new short[types.length];</span>
<span class="nc" id="L626">        short[] retained = new short[types.length];</span>
<span class="nc" id="L627">        short[] supported = cube.getTraceTypes();</span>
<span class="nc" id="L628">        int k=0, l=0;</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L630">            boolean found = false;</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">            for (int j=0; j&lt;supported.length; j++) {</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">                if (types[i] == supported[j]) {</span>
<span class="nc" id="L633">                    found = true;</span>
<span class="nc" id="L634">                    retained[l++] = types[i];</span>
<span class="nc" id="L635">                    break;</span>
                }
            }
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (!found)</span>
<span class="nc" id="L639">                removed[k++] = types[i];</span>
		}
<span class="nc bnc" id="L641" title="All 4 branches missed.">		if (k != 0 || l!=0) {</span>
<span class="nc" id="L642">            short[][] result = new short[2][0];</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">            if (k != 0) {</span>
<span class="nc" id="L644">    			short[] resultRemoved = new short[k];</span>
<span class="nc" id="L645">                System.arraycopy(removed, 0, resultRemoved, 0, k);</span>
<span class="nc" id="L646">                result[0] = resultRemoved;</span>
<span class="nc" id="L647">            } else</span>
<span class="nc" id="L648">                result[0] = null;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (l!=0) {</span>
<span class="nc" id="L650">    			short[] resultRetained = new short[l];</span>
<span class="nc" id="L651">                System.arraycopy(retained, 0, resultRetained, 0, l);</span>
<span class="nc" id="L652">                result[1] = resultRetained;</span>
<span class="nc" id="L653">            } else</span>
<span class="nc" id="L654">                result[1] = null;</span>
<span class="nc" id="L655">			return result;</span>
		}
<span class="nc" id="L657">		return null;</span>
    }
	/**
	 * Filter out Trace Types, that is not valid to particular TraceCube, or not dirty
	 * @param TraceCube, cube
	 * @param short[], Trace Types
	 * @return short[], Valid Trace Types
	 */
	public static short[] filterTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L666">		int j = 0;</span>
<span class="nc" id="L667">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L668" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">			if (cube.getTraceValueD(types[i]) == null ||</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">				!cube.isDirty(types[i]))</span>
<span class="nc" id="L671">				removed[j++] = types[i];</span>
		}
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">			if (j == types.length)</span>
<span class="nc" id="L675">				return null;</span>
<span class="nc" id="L676">			short[] result = new short[types.length-j];</span>
<span class="nc bnc" id="L677" title="All 2 branches missed.">			for (int i=0, k=0, l=0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L679">					result[i++] = types[l];</span>
<span class="nc" id="L680">					continue;</span>
				}
<span class="nc bnc" id="L682" title="All 2 branches missed.">				if (types[l] != removed[k])</span>
<span class="nc" id="L683">					result[i++] = types[l];</span>
				else
<span class="nc" id="L685">					k++;</span>
			}
<span class="nc" id="L687">			return result;</span>
		}
<span class="nc" id="L689">		short[] result = new short[types.length];</span>
<span class="nc" id="L690">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L691">		return result;</span>
	}
	/**
	 * Calculate points in between start and end dates in a given TimeZone
	 * Additional flag indicating if DST should be considered or not
	 * @param Date, start
	 * @param Date, end
	 * @param TimeZone, tz
	 * @param boolean considerDST
	 * @return int, points
	 */
	public static int gapOffSet(Date start, Date end, TimeZone tz, boolean considerDST) {
<span class="fc" id="L703">		int initPoints = dissectPeriod(start, end)[1];</span>
<span class="pc bpc" id="L704" title="3 of 6 branches missed.">		if (tz== null || !tz.useDaylightTime() || !considerDST ||</span>
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">			tz.inDaylightTime(start) == tz.inDaylightTime(end)) {</span>
<span class="fc" id="L706">			return initPoints;</span>
		}
		// divide DST adjustment by 15 minutes
<span class="nc" id="L709">		int points = tz.getDSTSavings()/900000;</span>
		// From STD to DST, we lost points
<span class="nc bnc" id="L711" title="All 2 branches missed.">		if (!tz.inDaylightTime(start)) {</span>
<span class="nc" id="L712">			return initPoints + points;</span>
		}
<span class="nc" id="L714">		return initPoints - points;</span>
	}
	/**
	 * To calculate the gapOffSet between any given date and a base
	 * @param Date, start time treated as midnight
	 * @param short, offSet
	 * @param Date, end
	 * @return int
	 */
	public static int gapOffSet(Date start, short offSet, Date end) {
<span class="fc" id="L724">		InsertionPoint resultObject = getInsertionPoint(end);</span>
<span class="fc" id="L725">		int result = resultObject.offset;</span>
<span class="fc" id="L726">		Date endDate = resultObject.startDate;</span>
		// Next line can be tuned later
<span class="fc" id="L728">		int days = TimeZoneUtil.numberOfDaysRound(start, endDate);</span>
<span class="fc" id="L729">		result = Trace.DAYPOINTS*days+result-offSet;</span>
<span class="fc" id="L730">		return result;</span>
	}
	/**
	 * Dissect a Period into Starting Day OffSet and OffSet between Period
	 * @param Date, start
	 * @param Date, end
	 * @return int[], 0 is Start Day OffSet, 1 is Gap OffSet
	 */
	public static int[] dissectPeriod(Date start, Date end) {
<span class="fc" id="L739">		int[] result = new int[2];</span>
<span class="fc" id="L740">		InsertionPoint startPoint = getInsertionPoint(start);</span>
<span class="fc" id="L741">		InsertionPoint endPoint = getInsertionPoint(end);</span>
<span class="fc" id="L742">		result[0] = startPoint.offset;</span>
<span class="fc" id="L743">		result[1] = endPoint.offset;</span>
<span class="fc" id="L744">		int days = TimeZoneUtil.numberOfDaysRound(startPoint.startDate, endPoint.startDate);</span>
<span class="fc" id="L745">		result[1] = Trace.DAYPOINTS*days-result[0]+result[1];</span>
<span class="fc" id="L746">		return result;</span>
	}
	/**
	 * Simpler routine, just to calculate the OffSet to mid-night
	 * Mid-night starts from 1
	 */
	public static short getOffSet(Date date) {
<span class="nc" id="L753">		return getOffSet(date, TimeZoneUtil.GMT_TIMEZONE);</span>
	}
	public static short getOffSet(Date date, TimeZone tz) {
<span class="nc" id="L756">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L757">		cal.setTime(date);</span>
<span class="nc" id="L758">		short hour = (short)cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L759">		short min = (short)cal.get(Calendar.MINUTE);</span>
<span class="nc" id="L760">		short offSet = (short)(hour*4 + min/15);</span>
<span class="nc" id="L761">		return ++offSet;</span>
	}
	/**
	 * Routine to check if the Type is predefined or not
	 */
	public static boolean isPredefinedType(short type) {
<span class="nc bnc" id="L767" title="All 2 branches missed.">		for (int i = 0; i &lt; Trace.TYPES.length; i++) {</span>
<span class="nc bnc" id="L768" title="All 2 branches missed.">			if (type == Trace.TYPES[i])</span>
<span class="nc" id="L769">				return true;</span>
		}
<span class="nc" id="L771">		return false;</span>
	}

	/**
	 * Giving a day find the absolute offset in the TraceCube
	 * @param TraceCube, cube
	 * @param TimeZone, tz
	 * @param int, day, which day
	 * @param boolean, considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getDailyRange(TraceCube cube, TimeZone tz, int day, boolean considerDST) {
<span class="nc bnc" id="L783" title="All 2 branches missed.">		if (cube == null)</span>
<span class="nc" id="L784">			return null;</span>
<span class="nc" id="L785">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L786" title="All 4 branches missed.">		if (start == null || tz == null)</span>
<span class="nc" id="L787">			return null;</span>
<span class="nc" id="L788">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L789">		cal.setTime(start);</span>
<span class="nc" id="L790">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L791">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L792">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L793">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L794">		cal.add(Calendar.DATE, 1);</span>
		// First day's absolute ending position
<span class="nc" id="L796">		int pos = Trace.DAYPOINTS - cube.getStartOffSet();</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (!tz.equals(TimeZoneUtil.GMT_TIMEZONE)) {</span>
<span class="nc" id="L798">			pos = TraceUtil.dissectPeriod(start, cal.getTime())[1]-1;</span>
		}
<span class="nc" id="L800">		int[] result = new int[2];</span>
<span class="nc" id="L801">		result[1] = pos;</span>
		// If trying to get first day
<span class="nc bnc" id="L803" title="All 2 branches missed.">		if (day == 0)</span>
<span class="nc" id="L804">			return result;</span>
		// Need figure out how to adjust days based on TimeZone
<span class="nc" id="L806">		int begin = 0;</span>
<span class="nc" id="L807">		int end = pos;</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">		if (!considerDST || !tz.useDaylightTime()) {</span>
<span class="nc" id="L809">			result[0] = end+1+Trace.DAYPOINTS*(day-1);</span>
<span class="nc" id="L810">			result[1] = result[0]+Trace.DAYPOINTS-1;</span>
		} else {
<span class="nc" id="L812">			begin = end + 1;</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">			while (day&gt;0) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L815">				start = cal.getTime();</span>
<span class="nc" id="L816">				cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L817">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L818">				day--;</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">				if (day &gt; 0)</span>
<span class="nc" id="L820">					begin = end + 1;</span>
			}
<span class="nc" id="L822">			result[0] = begin;</span>
<span class="nc" id="L823">			result[1] = end;</span>
		}
<span class="nc" id="L825">		return result;</span>
	}

	/**
	 * Giving an hour find the absolute offset in the TraceCube
	 * @param TraceCube, cube
	 * @param TimeZone, tz
	 * @param int, hour, which hour
	 * @param boolean, considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getHourlyRange(TraceCube cube, TimeZone tz, int hour, boolean considerDST) {
<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (cube == null)</span>
<span class="nc" id="L838">			return null;</span>
<span class="nc" id="L839">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L840" title="All 4 branches missed.">		if (start == null || tz == null)</span>
<span class="nc" id="L841">			return null;</span>
<span class="nc" id="L842">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L843">		cal.setTime(start);</span>
<span class="nc" id="L844">		int startMin = cal.get(Calendar.MINUTE);</span>
<span class="nc" id="L845">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L846">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L847">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L848">		cal.add(Calendar.HOUR_OF_DAY, 1);</span>
		// Get the absolute position
<span class="nc" id="L850">		int pos = startMin/15;</span>
		// Need figure out how many hours
<span class="nc" id="L852">		int begin = 0;</span>
		// if end point is already 3, then firt hour only one point
<span class="nc bnc" id="L854" title="All 2 branches missed.">		int end = (3-pos)==0?3:(3-pos);</span>
		// if there is no DST, or DST's offset is multiple of hours
<span class="nc bnc" id="L856" title="All 4 branches missed.">		boolean normHandling = !tz.useDaylightTime() || tz.getDSTSavings()%3600000 == 0;</span>
<span class="nc" id="L857">		int[] result = new int[2];</span>
<span class="nc" id="L858">		result[0] = begin;</span>
<span class="nc" id="L859">		result[1] = end;</span>
<span class="nc bnc" id="L860" title="All 4 branches missed.">		if (!considerDST || normHandling) {</span>
<span class="nc bnc" id="L861" title="All 2 branches missed.">			if (hour &gt;0) {</span>
<span class="nc" id="L862">				result[0] = result[1]+1+4*(hour-1);</span>
<span class="nc" id="L863">				result[1] = result[0]+3;</span>
			}
		} else {
<span class="nc" id="L866">			begin = end + 1;</span>
<span class="nc" id="L867">			int hours = 0;</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">			while (hours &lt; hour) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L870">				start = cal.getTime();</span>
<span class="nc" id="L871">				cal.add(Calendar.HOUR, 1);</span>
<span class="nc" id="L872">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L873">				result[0] = begin;</span>
<span class="nc" id="L874">				result[1] = end;</span>
<span class="nc" id="L875">				begin = end + 1;</span>
<span class="nc" id="L876">				hours++;</span>
			}
		}
<span class="nc" id="L879">		return result;</span>
	}

	/**
	 * Giving a week find the absolute offset in the TraceCube
	 * @param TraceCube, cube
	 * @param TimeZone, tz
	 * @param int, week, which week
	 * @param int, first day of a week
	 * @param boolean, considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getWeeklyRange(TraceCube cube, TimeZone tz, int week, int firstDayOfWeek, boolean considerDST) {
<span class="nc bnc" id="L892" title="All 2 branches missed.">		if (cube == null)</span>
<span class="nc" id="L893">			return null;</span>
<span class="nc" id="L894">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L895" title="All 4 branches missed.">		if (start == null || tz == null)</span>
<span class="nc" id="L896">			return null;</span>
<span class="nc" id="L897">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L898">		cal.setTime(start);</span>
<span class="nc" id="L899">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L900">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L901">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L902">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L903">		int currentDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
		// If start day is the first day of the week
<span class="nc bnc" id="L905" title="All 2 branches missed.">		if (currentDayOfWeek == firstDayOfWeek) {</span>
<span class="nc" id="L906">			cal.add(Calendar.WEEK_OF_YEAR, 1);</span>
		} else {
			do {
<span class="nc" id="L909">				cal.add(Calendar.DATE, 1);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">			} while(cal.get(Calendar.DAY_OF_WEEK) != firstDayOfWeek);</span>
		}
		// First day's absolute ending position
<span class="nc" id="L913">		int pos = TraceUtil.dissectPeriod(start, cal.getTime())[1]-1;</span>
		// Need figure out how many days
<span class="nc" id="L915">		int begin = 0;</span>
<span class="nc" id="L916">		int end = pos;</span>
<span class="nc" id="L917">		int[] result = new int[2];</span>
<span class="nc" id="L918">		result[0] = begin;</span>
<span class="nc" id="L919">		result[1] = end;</span>
<span class="nc bnc" id="L920" title="All 4 branches missed.">		if (!considerDST || !tz.useDaylightTime()) {</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">			if (week &gt; 0) {</span>
<span class="nc" id="L922">				result[0] = result[1]+1+Trace.WEEKPOINTS*(week-1);</span>
<span class="nc" id="L923">				result[1] = result[0]+Trace.WEEKPOINTS-1;</span>
			}
		} else {
<span class="nc" id="L926">			begin = end + 1;</span>
<span class="nc" id="L927">			int weeks = 0;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">			while (weeks &lt; week) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L930">				start = cal.getTime();</span>
<span class="nc" id="L931">				cal.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc" id="L932">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L933">				result[0] = begin;</span>
<span class="nc" id="L934">				result[1] = end;</span>
<span class="nc" id="L935">				begin = end + 1;</span>
<span class="nc" id="L936">				weeks ++;</span>
			}
		}
<span class="nc" id="L939">		return result;</span>
	}

	/**
	 * Returns a new trace cube, most of whose data are identical to the source trace cube,
	 * but whose start date is the specified new start date.  Only the date portion of the
	 * new start date is used; the hours and minutes are copied from the start date of the
	 * source trace cube.
	 *
	 * The potential differences involve daylight savings.  In particular, the local
	 * time of day for each point in the new trace cube must match the local time of day
	 * for the corresponding point in the source trace cube.  This means that some or
	 * all points in the resulting trace cube might be offset from the corresponding
	 * points in the source trace cube.
	 *
	 * Only the trace types returned by &lt;code&gt;sourceCube.getTraceTypes()&lt;/code&gt; are
	 * processed; any data in other types will be missing from the resulting trace
	 * cube.
	 *
	 * @param sourceCube
	 * @param newRawStartDate
	 * @param timeZone
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	public static TraceCube getTimeShiftedTraceCube(TraceCube sourceCube, Date newRawStartDate, TimeZone timeZone)
			throws BbmTimeSeriesException {

<span class="nc" id="L967">		Date oldRawStartDate = sourceCube.getRawStartDate();</span>
<span class="nc" id="L968">		Date oldRawEndDate = sourceCube.getRawEndDate();</span>
<span class="nc" id="L969">		Calendar oldRawStartCal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L970">		oldRawStartCal.setTime(oldRawStartDate);</span>
<span class="nc" id="L971">		Calendar newRawStartCal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L972">		newRawStartCal.setTime(newRawStartDate);</span>
<span class="nc" id="L973">		newRawStartCal.set(Calendar.HOUR_OF_DAY, oldRawStartCal.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L974">		newRawStartCal.set(Calendar.MINUTE, oldRawStartCal.get(Calendar.MINUTE));</span>
<span class="nc" id="L975">		newRawStartCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L976">		newRawStartCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L977">		newRawStartDate = newRawStartCal.getTime();</span>

		// Calculate new end date based on current raw start date, new raw start date,
		// and time zone.
<span class="nc" id="L981">		Date newRawEndDate = TimeZoneUtil.getShiftedDate(oldRawStartDate, newRawStartDate, oldRawEndDate, timeZone);</span>

<span class="nc bnc" id="L983" title="All 2 branches missed.">		assert TimeZoneUtil.numberOfDaysRound(oldRawStartDate, oldRawEndDate) ==</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">			   TimeZoneUtil.numberOfDaysRound(newRawStartDate, newRawEndDate);</span>

<span class="nc" id="L986">		TraceCube result = sourceCube.newInstance(sourceCube.getQueueID(), newRawStartDate, newRawEndDate, sourceCube.getTraceTypes());</span>

<span class="nc" id="L988">		int totalNewMinutes = TimeZoneUtil.numberOfMinutes(newRawStartDate, newRawEndDate);</span>
<span class="nc" id="L989">		int newPointsCount = totalNewMinutes / TraceCube.INTERVAL;</span>
		// Create an array indexed by index into the target trace array, whose values
		// are the indices of the corresponding elements in the source trace array.
<span class="nc" id="L992">		int[] sourceIndices = new int[newPointsCount];</span>
<span class="nc" id="L993">		int deltaIndex = 0;</span>
		// For each 15-minute interval in the new trace, we calculate the index in the source trace
		// that corresponds to the same local time on the corresponding day of the target trace.
<span class="nc bnc" id="L996" title="All 2 branches missed.">		for (Date currentTargetDate = newRawStartDate; currentTargetDate.before(newRawEndDate); currentTargetDate = new Date(currentTargetDate.getTime() + TraceCube.INTERVAL_IN_MILLIS)) {</span>
<span class="nc" id="L997">			Date currentSourceDate = TimeZoneUtil.getShiftedDate(newRawStartDate, oldRawStartDate, currentTargetDate, timeZone);</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">			if (currentSourceDate == null) {</span>
<span class="nc" id="L999">				sourceIndices[deltaIndex] = -1;</span>
			} else {
<span class="nc" id="L1001">				sourceIndices[deltaIndex] = (int)( (currentSourceDate.getTime() - oldRawStartDate.getTime()) / TraceCube.INTERVAL_IN_MILLIS );</span>
			}
<span class="nc" id="L1003">			deltaIndex++;</span>
		}

		// We rely on sourceCube to have accurate information about its populated trace types.
<span class="nc bnc" id="L1007" title="All 2 branches missed.">		for (short traceType : sourceCube.getTraceTypes()) {</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">			if (sourceCube.getTraceValueD(traceType) != null) {</span>
<span class="nc" id="L1009">				result.setTraceValue(traceType, getTimeShiftedTrace(sourceCube.getTraceValueD(traceType), sourceIndices));</span>
			}
		}

<span class="nc" id="L1013">		return result;</span>
	}

	/**
	 * Returns a new trace, using the supplied source indices to map source
	 * array values into the new array.  If an index is -1, that element is
	 * considered unavailable and TRACENA is inserted in the new array at
	 * that point.
	 *
	 * @param sourceTrace
	 * @param timeDeltasMinutes
	 * @return
	 */
	private static double[] getTimeShiftedTrace(double[] sourceTrace, int[] sourceIndices) {
<span class="nc" id="L1027">		double[] resultTrace = new double[sourceIndices.length];</span>

<span class="nc bnc" id="L1029" title="All 2 branches missed.">		for (int resultIndex = 0; resultIndex &lt; resultTrace.length; ++resultIndex) {</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">			if (sourceIndices[resultIndex] == -1) {</span>
<span class="nc" id="L1031">				resultTrace[resultIndex] = Trace.TRACENA;</span>
			} else {
<span class="nc" id="L1033">				resultTrace[resultIndex] = sourceTrace[sourceIndices[resultIndex]];</span>
			}
		}

<span class="nc" id="L1037">		return resultTrace;</span>
	}

	//TODO: This should be named &quot;round&quot; as it can be called with a float argument.
	/**
	 * This function standardizes rounding used in the Trace domain.
	 *
	 * Rounds a value to the nearest integer.  Values ending in .5 are rounded towards
	 * positive infinity.
	 */
	public static int roundDouble(double value) {
<span class="fc" id="L1048">		return MathUtil.roundHalfCeiling(value);</span>
	}

	/**
	 * validate multiple tracecubes, must have same length, same trace types
	 * as invalid parameters won't be continued in operation, just throw exception
	 * @return TraceCube, a holder traceCube which has the same start/end definition of first TraceCube
	 */
	public static TraceCube validateTraceCubes(TraceCube[] cubes, int[] weight) throws BbmTimeSeriesException {
<span class="nc bnc" id="L1057" title="All 2 branches missed.">		if (weight.length != cubes.length)</span>
<span class="nc" id="L1058">			throw new BbmTimeSeriesException(BbmTimeSeriesException.WEIGHT_INVALID);</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">		for (int i=0; i&lt;weight.length; i++) {</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">			if (weight[i] &lt;= 0)</span>
<span class="nc" id="L1061">				throw new BbmTimeSeriesException(BbmTimeSeriesException.WEIGHT_INVALID);</span>
		}
<span class="nc" id="L1063">		return validateTraceCubes(cubes);</span>
	}

	/**
	 * Get a slice from a TraceCube, for UI display
	 * @param TraceCube, source tracecube
	 * @param Date, start
	 * @param Date, end
	 * @return TraceCube
	 */
	public static TraceCube sliceTraceCube(TraceCube tc, Date startDate, Date endDate) throws BbmTimeSeriesException {
<span class="nc bnc" id="L1074" title="All 2 branches missed.">		if (tc == null)</span>
<span class="nc" id="L1075">			return null;</span>
<span class="nc" id="L1076">		TraceCube slice = tc.newInstance(tc.getQueueID(), startDate, endDate, tc.getTraceTypes());</span>
<span class="nc" id="L1077">		short[] types = tc.getTraceTypes();</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L1079">			boolean isDirty = tc.isDirty(types[i]);</span>
<span class="nc" id="L1080">			slice.setTraceValue(types[i], tc.getTraceValueD(types[i], startDate, endDate));</span>
			//This is done here because setting the trace values on the slices
			//  has the unfortunate side effect of setting the dirty flag.  So,
			//  we will clear out the dirty flag caused by this change unless
			//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1085" title="All 2 branches missed.">			if (!isDirty) {</span>
<span class="nc" id="L1086">				tc.setTypeDirty(types[i], false);</span>
			}
		}
<span class="nc" id="L1089">		return slice;</span>
	}
    public static TraceCube combinedCube(TraceCube metaTC) {
<span class="nc bnc" id="L1092" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube)</span>
<span class="nc" id="L1093">            return META_ACTUAL_COMBINE;</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">        if (metaTC instanceof ForecastTraceCube)</span>
<span class="nc" id="L1095">            return META_FORECAST_COMBINE;</span>
<span class="nc" id="L1096">        return null;</span>
    }
    public static TraceCube newMetaInstance(TraceCube metaTC, short[] types) throws BbmTimeSeriesException{
<span class="nc bnc" id="L1099" title="All 2 branches missed.">        if (types == null)</span>
<span class="nc" id="L1100">            return null;</span>
<span class="nc" id="L1101">		TraceCube tc = null;</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube)</span>
<span class="nc" id="L1103">			tc = new ForecastTraceCube();</span>
<span class="nc bnc" id="L1104" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube)</span>
<span class="nc" id="L1105">			tc = new PredictTraceCube();</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube)</span>
<span class="nc" id="L1107">			tc = new RequireTraceCube();</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube)</span>
<span class="nc" id="L1109">			tc = new ActualTraceCube();</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube)</span>
<span class="nc" id="L1111">			tc = new ServiceGoalTraceCube();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">        if (tc != null)</span>
<span class="nc" id="L1113">            tc.setTraceType(types);</span>
<span class="nc" id="L1114">		return tc;</span>
    }
	public static TraceCube newInstance(TraceCube metaTC, ID queueID, Date start, Date end) throws BbmTimeSeriesException{
<span class="nc" id="L1117">		TraceCube tc = null;</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube)</span>
<span class="nc" id="L1119">			tc = new ForecastTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1120" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube)</span>
<span class="nc" id="L1121">			tc = new PredictTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube)</span>
<span class="nc" id="L1123">			tc = new RequireTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube)</span>
<span class="nc" id="L1125">			tc = new ActualTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube)</span>
<span class="nc" id="L1127">			tc = new ServiceGoalTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc" id="L1128">		return tc;</span>
	}

	/**
	 * Gets a List of TraceChunk objects representing values in this TraceCube.  If startDate or endDate falls
	 * outside of the bounds of the TraceCube, then TraceChunk objects will be returned for those dates but they
	 * will have zero values for their trace types.
	 */
	public static List&lt;TraceChunk&gt; getTraceChunks(TraceCube traceCube, Date startDate, Date endDate) {
<span class="nc" id="L1137">		short[] types = traceCube.getTraceTypes();</span>
<span class="nc" id="L1138">		int[][] values = traceCube.getTraceValues();</span>
<span class="nc" id="L1139">		Calendar timeCursor = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L1140">		timeCursor.setTime(startDate);</span>
<span class="nc" id="L1141">		List&lt;TraceChunk&gt; retVal = new ArrayList&lt;TraceChunk&gt;(values[types[0]].length);</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">		while (timeCursor.getTime().before(endDate)) {</span>
<span class="nc" id="L1143">			TraceChunk chunk = new TraceChunk(traceCube.getQueueID(), timeCursor.getTime());</span>
<span class="nc" id="L1144">			double[] valuesAtInterval = new double[types.length];</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">			for (int typeIndex = 0; typeIndex &lt; types.length; typeIndex++) {</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">				if (traceCube.fallsIn(timeCursor.getTime())) {</span>
<span class="nc" id="L1147">					valuesAtInterval[typeIndex] = traceCube.getTraceValueD(types[typeIndex], timeCursor.getTime());</span>
				}
			}
<span class="nc" id="L1150">			chunk.setTraceValues(types, valuesAtInterval);</span>
<span class="nc" id="L1151">			retVal.add(chunk);</span>
<span class="nc" id="L1152">			timeCursor.add(Calendar.MINUTE, Trace.INTERVAL);</span>
<span class="nc" id="L1153">		}</span>
<span class="nc" id="L1154">		return retVal;</span>
	}

	/**
	 * Returns true if any type in the given trace cube has its dirty flag set.
	 */
	public static boolean isTraceCubeDirty(TraceCube tc) {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">		for (short type : tc.getTraceTypes()) {</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">			if (tc.isDirty(type)) {</span>
<span class="nc" id="L1163">				return true;</span>
			}
		}
<span class="nc" id="L1166">		return false;</span>
	}

	/**
	 * Clears the dirty flag for all types in the trace cube.
	 */
	public static void clearDirtyTraceCube(TraceCube tc) {
<span class="nc bnc" id="L1173" title="All 2 branches missed.">		for (short type : tc.getTraceTypes()) {</span>
<span class="nc" id="L1174">			tc.setTypeDirty(type, false);</span>
		}
<span class="nc" id="L1176">	}</span>

	/**
	 * Convert values in a trace cube to seconds for the given trace types. The values in the original
	 * trace cube are assumed to be in the given time unit.
	 *
	 * @param cube the cube
	 * @param types the types trace types to do the conversion for
	 * @param timeUnit the time unit to convert values from
	 */
	public static void convertValuesToSeconds(TraceCube cube, short[] types, TimeUnit timeUnit) {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L1188">			boolean isDirty = cube.isDirty(type);</span>
<span class="nc" id="L1189">			double[] values = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">			if (values != null) {</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">				for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">					if (values[i] &gt;= 0)</span>
<span class="nc" id="L1193">						values[i] = timeUnit.convertValueToSeconds(values[i]);</span>
				}
<span class="nc" id="L1195">				cube.setTraceValue(type, values);</span>
				//This is done here because setting the undefined values to zero
				//  has the unfortunate side effect of setting the dirty flag.  So,
				//  we will clear out the dirty flag caused by this change unless
				//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1200" title="All 2 branches missed.">				if (!isDirty) {</span>
<span class="nc" id="L1201">					cube.setTypeDirty(type, false);</span>
				}
			}
		}
<span class="nc" id="L1205">	}</span>

	/**
	 * Convert values in a trace cube from seconds to values in given time unit.
	 *
	 * @param cube the cube
	 * @param types the types trace types to do the conversion for
	 * @param timeUnit the time unit to convert seconds values to
	 */
	public static void convertSeconds(TraceCube cube, short[] types, TimeUnit timeUnit) {
<span class="nc bnc" id="L1215" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L1216">			boolean isDirty = cube.isDirty(type);</span>
<span class="nc" id="L1217">			double[] values = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L1218" title="All 2 branches missed.">			if (values != null) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">				for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="nc bnc" id="L1220" title="All 2 branches missed.">					if (values[i] &gt;= 0) {</span>
<span class="nc" id="L1221">						values[i] = timeUnit.convertSeconds(values[i]);</span>
					}
				}
<span class="nc" id="L1224">				cube.setTraceValue(type, values);</span>
				//This is done here because setting the undefined values to zero
				//  has the unfortunate side effect of setting the dirty flag.  So,
				//  we will clear out the dirty flag caused by this change unless
				//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1229" title="All 2 branches missed.">				if (!isDirty) {</span>
<span class="nc" id="L1230">					cube.setTypeDirty(type, false);</span>
				}
			}
		}
<span class="nc" id="L1234">	}</span>

	/**
	 * Sets all undefined trace values in the trace cube
	 * (values that are less than 0) to 0.
	 */
	public static void setUndefinedValuesToZero(TraceCube cube) {
<span class="fc bfc" id="L1241" title="All 2 branches covered.">		for (short type : cube.getTraceTypes()) {</span>
<span class="fc" id="L1242">			boolean isDirty = cube.isDirty(type);</span>
<span class="fc" id="L1243">			double[] values = cube.getTraceValueD(type);</span>
<span class="fc bfc" id="L1244" title="All 2 branches covered.">			for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="fc bfc" id="L1245" title="All 2 branches covered.">				if (values[i] &lt; 0) {</span>
<span class="fc" id="L1246">					values[i] = 0;</span>
				}
			}
<span class="fc" id="L1249">			cube.setTraceValue(type, values);</span>
			//This is done here because setting the undefined values to zero
			//  has the unfortunate side effect of setting the dirty flag.  So,
			//  we will clear out the dirty flag caused by this change unless
			//  the cube was already dirty beforehand.
<span class="fc bfc" id="L1254" title="All 2 branches covered.">			if (!isDirty) {</span>
<span class="fc" id="L1255">				cube.setTypeDirty(type, false);</span>
			}
		}
<span class="fc" id="L1258">	}</span>

	/**
	 * Sets all trace values for the given trace types in the given trace cube to zero.
	 */
	public static &lt;T extends TraceCube&gt; void zeroOutTraceCubeValues(T cube, short[] traceTypes) throws BbmTimeSeriesException {
<span class="fc bfc" id="L1264" title="All 2 branches covered.">		for (short type : traceTypes) {</span>
<span class="fc" id="L1265">			cube.initTraceValue(type, 0);</span>
		}
<span class="fc" id="L1267">	}</span>

	/**
	 * In some trace cubes, certain trace types are dependent on other trace types to have a non-negative value if their own
	 * trace values are to have meaning.  This method will set the value of the base trace types to zero if the
	 * base trace type value is less than zero AND the corresponding value of the dependent trace type is non-negative.
	 */
	public static void adjustDependentTraceValues(TraceCube traceCube, short dependentTraceType, short baseTraceType) {
<span class="fc" id="L1275">		double[] baseTraceValues = traceCube.getTraceValueD(baseTraceType);</span>
<span class="fc" id="L1276">		double[] dependentTraceValues = traceCube.getTraceValueD(dependentTraceType);</span>
<span class="fc bfc" id="L1277" title="All 2 branches covered.">		for (int i = 0; i &lt;= dependentTraceValues.length - 1; i++) {</span>
<span class="pc bpc" id="L1278" title="1 of 4 branches missed.">			if (dependentTraceValues[i] &gt;= 0 &amp;&amp; baseTraceValues[i] &lt; 0)</span>
<span class="nc" id="L1279">				baseTraceValues[i] = 0;</span>
		}
<span class="fc" id="L1281">		traceCube.setTraceValue(baseTraceType, baseTraceValues);</span>
<span class="fc" id="L1282">	}</span>
    //bad hack as usual to accomdate introduction of new trace type NETSTAFFING that allows negative values.
    public static double adjustTraceValue(short traceType, double traceVal) {
<span class="pc bpc" id="L1285" title="1 of 6 branches missed.">	    if (Trace.isValidValue(traceVal) &amp;&amp; traceType != Trace.NETSTAFFING &amp;&amp; traceVal &lt; 0) {</span>
		    /* these are the old values; return new TRACENA for trace types other than Netstaffing. as per Jason, Sept 2011
	           TRACENA = -1;
	           TRACEOFF = -2;
	           TRACEUNB = -3;
	           TRACEINCOMP = -4; */
<span class="nc bnc" id="L1291" title="All 2 branches missed.">		    if (traceVal == -1) {</span>
<span class="nc" id="L1292">			    traceVal = Trace.TRACENA;</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">		    } else if (traceVal == -2) {</span>
<span class="nc" id="L1294">			    traceVal = Trace.TRACEOFF;</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">		    } else if (traceVal == -4) {</span>
<span class="nc" id="L1296">			    traceVal = Trace.TRACEINCOMP;</span>
		    }
	    }
<span class="fc" id="L1299">	    return traceVal;</span>
    }

	//bad hack as usual to accomdate introduction of new trace type NETSTAFFING that allows negative values.
	public static double[] adjustTraceValue(short traceType, double[] traceVal) {
<span class="pc bpc" id="L1304" title="1 of 4 branches missed.">		for (int i = 0; traceVal != null &amp;&amp; i &lt; traceVal.length; i++) {</span>
<span class="fc" id="L1305">			traceVal[i] = adjustTraceValue(traceType,traceVal[i]);</span>
		}
<span class="fc" id="L1307">		return traceVal;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>