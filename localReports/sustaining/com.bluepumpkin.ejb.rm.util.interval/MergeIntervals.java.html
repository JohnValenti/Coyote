<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MergeIntervals.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util.interval</a> &gt; <span class="el_source">MergeIntervals.java</span></div><h1>MergeIntervals.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.util.interval;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

/**
 * Merges two lists of intervals into one.  
 */
<span class="nc bnc" id="L11" title="All 2 branches missed.">public class MergeIntervals&lt;A extends Interval, B extends Interval, R extends Interval&gt; {</span>

	List&lt;R&gt; result;

	MergeIntervalOperations&lt;A, B, R&gt; operations;

<span class="nc" id="L17">	private MergeIntervals() {</span>

<span class="nc" id="L19">	}</span>

	private void addToResult(R elem) {
<span class="nc bnc" id="L22" title="All 2 branches missed.">		if (elem != null) {</span>
<span class="nc" id="L23">			result.add(elem);</span>
		}
<span class="nc" id="L25">	}</span>

	//returns the element from list at the give index. If we have reached the end of the list we dump all the elements from the other list 
	//into the list to be returned and return null signaling that we have reached the end
	private &lt;T1 extends Interval, T2 extends Interval&gt; R extractElementFromList(Iterator&lt;T1&gt; iterator, Iterator&lt;T2&gt; otherList,
			R currentOtherElement, Select&lt;T1, R&gt; select1, Select&lt;T2, R&gt; select2, long expectedMinStart) {
<span class="nc bnc" id="L31" title="All 2 branches missed.">		if (!iterator.hasNext()) {</span>
<span class="nc" id="L32">			addToResult(currentOtherElement);</span>

<span class="nc bnc" id="L34" title="All 2 branches missed.">			while (otherList.hasNext()) {</span>
<span class="nc" id="L35">				T2 other = otherList.next();</span>
<span class="nc" id="L36">				result.add(select2.apply(other));</span>
<span class="nc" id="L37">			}</span>
<span class="nc" id="L38">			return null;</span>
		}
<span class="nc" id="L40">		T1 intr = iterator.next();</span>

<span class="nc bnc" id="L42" title="All 2 branches missed.">		if (intr == null) {</span>
<span class="nc" id="L43">			throw new IllegalArgumentException(&quot;One of the input collection for merge interval contains a null object&quot;);</span>
		}

<span class="nc bnc" id="L46" title="All 2 branches missed.">		if (intr.start() &lt; expectedMinStart) {</span>
<span class="nc" id="L47">			throw new IllegalArgumentException(</span>
					&quot;The arguments for merge interval collections must be sorted in ascending order and should not contain overlapping inside a collection&quot;);
		}

<span class="nc" id="L51">		return select1.apply(intr);</span>
	}

	/*
	 * This function assumes that elem1 starts before elem2 on entry
	 * 	
	 * 	1.  elem1 does not overlap elem2
	 * 		If elem1 ends before elem2 then elem1 does not overlap elem2 and elem1 can be added to the result list
	 * 		we then return null so that the next iteration of the main loop will extract a replacement for elem1 (from whichever list was the source for elem1 in the first place)
	 * 	
	 * 	2. elem2 overlaps elem2 
	 * 		In this case we add the non overlapping portion of elem1 [elem1.start(),elem2.start()) to the result list 
	 * 		and cut out this portion from elem1. i.e. we return the [elem2.start(),elem1.end()) as the new elem1 
	 * 
	 */
	private R handleStartBefore(R elem1, R elem2) {
<span class="nc bnc" id="L67" title="All 4 branches missed.">		assert elem1.start() &lt; elem2.start() : &quot;MergeIntervals: elem1 should start before elem2 in handleStartBefore&quot;;</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (elem1.end() &lt;= elem2.start()) {</span>
			//elem1 start before elem2 and does not overlap elem2 (might touch elem2, but that is OK)
<span class="nc" id="L71">			result.add(elem1);</span>
<span class="nc" id="L72">			return null;</span>
		}

		//elem1 start before elem2, but overlaps elem2

		//add the portion that does not overlap
<span class="nc" id="L78">		R nonOverlappingSeg = operations.copy(elem1, elem1.start(), elem2.start());</span>
<span class="nc" id="L79">		result.add(nonOverlappingSeg);</span>
		//shorten the current elem1
<span class="nc" id="L81">		return operations.copy(elem1, elem2.start(), elem1.end());</span>
	}

	/*
	 * This function assumes that elem1 and elem2 start at the same time and elem1 ends before elem2 on entry
	 * 
	 * 1. Create a truncated version of elem2 that ends at the same time as elem1
	 * 2. Merge this truncated version of elem2 and elem1 and add to result list
	 * 3. Return the remaining portion of elem2 
	 * 
	 */
	private R handleEndsBefore(R elem1, R elem2) {
<span class="nc bnc" id="L93" title="All 4 branches missed.">		assert elem1.start() == elem2.start() : &quot;MergeIntervals: elem1 should start at the same time as elem2 in handleEndsBefore&quot;;</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">		assert elem1.end() &lt; elem2.end() : &quot;MergeIntervals: elem1 should end before elem2 in handleEndsBefore&quot;;</span>

		//elem1 ends before elem2. 
<span class="nc" id="L97">		R overlappingElem2 = operations.copy(elem2, elem2.start(), elem1.end());</span>
<span class="nc" id="L98">		R overlappHandledSegment = operations.merge(elem1, overlappingElem2);</span>
<span class="nc" id="L99">		addToResult(overlappHandledSegment);</span>
<span class="nc" id="L100">		return operations.copy(elem2, elem1.end(), elem2.end());</span>
	}

	private Select&lt;A, R&gt; getSelect1() {
<span class="nc" id="L104">		return new Select&lt;A, R&gt;() {</span>
			@Override
			public R apply(A a) {
<span class="nc" id="L107">				return operations.select1(a);</span>
			}
		};
	}

	private Select&lt;B, R&gt; getSelect2() {
<span class="nc" id="L113">		return new Select&lt;B, R&gt;() {</span>
			@Override
			public R apply(B b) {
<span class="nc" id="L116">				return operations.select2(b);</span>
			}
		};
	}

	private &lt;T&gt; List&lt;R&gt; convertList(Collection&lt;T&gt; input, Select&lt;T, R&gt; map) {
<span class="nc" id="L122">		List&lt;R&gt; ret = new ArrayList&lt;R&gt;(input.size());</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">		for (T elem : input) {</span>
<span class="nc" id="L124">			ret.add(map.apply(elem));</span>
<span class="nc" id="L125">		}</span>
<span class="nc" id="L126">		return ret;</span>
	}

	private List&lt;R&gt; merge(Collection&lt;A&gt; collection1, Collection&lt;B&gt; collection2, // NOSONAR
			MergeIntervalOperations&lt;A, B, R&gt; operations) {

<span class="nc" id="L132">		this.operations = operations;</span>
<span class="nc" id="L133">		this.result = new ArrayList&lt;R&gt;();</span>

<span class="nc" id="L135">		Select&lt;A, R&gt; select1 = getSelect1();</span>
<span class="nc" id="L136">		Select&lt;B, R&gt; select2 = getSelect2();</span>

<span class="nc bnc" id="L138" title="All 4 branches missed.">		if (collection2 == null || collection2.isEmpty()) {</span>
<span class="nc" id="L139">			return convertList(collection1, select1);</span>
		}

<span class="nc bnc" id="L142" title="All 4 branches missed.">		if (collection1 == null || collection1.isEmpty()) {</span>
<span class="nc" id="L143">			return convertList(collection2, select2);</span>
		}

<span class="nc" id="L146">		R elem1 = null;</span>
<span class="nc" id="L147">		R elem2 = null;</span>

<span class="nc" id="L149">		Iterator&lt;A&gt; iter1 = collection1.iterator();</span>
<span class="nc" id="L150">		Iterator&lt;B&gt; iter2 = collection2.iterator();</span>

		//the expected minimum start for the next element from collection 1. 
		//Used only to check that collection 1 is sorted ascending by start and contains no overlap
<span class="nc" id="L154">		long expectedMinStart1 = Long.MIN_VALUE;</span>
		//the expected minimum start for the next element from collection 2. 
		//Used only to check that collection 2 is sorted ascending by start and contains no overlap
<span class="nc" id="L157">		long expectedMinStart2 = Long.MIN_VALUE;</span>

		while (true) { // NOSONAR

<span class="nc bnc" id="L161" title="All 2 branches missed.">			if (elem1 == null) {</span>
<span class="nc" id="L162">				elem1 = extractElementFromList(iter1, iter2, elem2, select1, select2, expectedMinStart1);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">				if (elem1 == null) {</span>
<span class="nc" id="L164">					return result;</span>
				}
<span class="nc" id="L166">				expectedMinStart1 = elem1.end();</span>
			}

<span class="nc bnc" id="L169" title="All 2 branches missed.">			if (elem2 == null) {</span>
<span class="nc" id="L170">				elem2 = extractElementFromList(iter2, iter1, elem1, select2, select1, expectedMinStart2);</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">				if (elem2 == null) {</span>
<span class="nc" id="L172">					return result;</span>
				}
<span class="nc" id="L174">				expectedMinStart2 = elem2.end();</span>
			}

<span class="nc bnc" id="L177" title="All 4 branches missed.">			assert elem1.start() &lt; elem1.end() : &quot;MergeIntervals: collection1 contains empty/invalid interval&quot;;</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">			assert elem2.start() &lt; elem2.end() : &quot;MergeIntervals: collection2 contains empty/invalid interval&quot;;</span>

<span class="nc bnc" id="L180" title="All 2 branches missed.">			if (elem1.start() &lt; elem2.start()) {</span>
<span class="nc" id="L181">				elem1 = handleStartBefore(elem1, elem2);</span>
<span class="nc" id="L182">				continue;</span>
			}

<span class="nc bnc" id="L185" title="All 2 branches missed.">			if (elem2.start() &lt; elem1.start()) {</span>
<span class="nc" id="L186">				elem2 = handleStartBefore(elem2, elem1);</span>
<span class="nc" id="L187">				continue;</span>
			}

			//if we got here both elem1 and elem2 start at the same time.

<span class="nc bnc" id="L192" title="All 2 branches missed.">			if (elem1.end() &lt; elem2.end()) {</span>
				//elem1 ends before elem2. 
<span class="nc" id="L194">				elem2 = handleEndsBefore(elem1, elem2);</span>
<span class="nc" id="L195">				elem1 = null;</span>
<span class="nc" id="L196">				continue;</span>
			}

<span class="nc bnc" id="L199" title="All 2 branches missed.">			if (elem2.end() &lt; elem1.end()) {</span>
				//elem2 ends before elem1
<span class="nc" id="L201">				elem1 = handleEndsBefore(elem2, elem1);</span>
<span class="nc" id="L202">				elem2 = null;</span>
<span class="nc" id="L203">				continue;</span>
			}

			//both elem1 and elem2 overlap completely 
<span class="nc" id="L207">			addToResult(operations.merge(elem1, elem2));</span>
<span class="nc" id="L208">			elem1 = null;</span>
<span class="nc" id="L209">			elem2 = null;</span>
		}

	}

	/**
	 * Merges two lists of intervals into one. The copy function
	 * is used to create new chopped intervals that represents the
	 * overlaps/overhangs The merge function is used to merge blocks that
	 * overlap exactly after the intervals are chopped for overlaps/overhangs
	 * 
	 * &lt;pre&gt;
	 * For example:
	 *          list 1:            |------------1----------------|
	 *          list 2:                        |------------2------------------|
	 *          output list:       |-Chop 1----|--- Merged ------|-Chop 2------|
	 * 
	 * &lt;/pre&gt;
	 * 
	 * Assumes that list 1 and list 2 does not contain null or overlapping
	 * intervals and that they are sorted by start.
	 * 
	 */
	public static &lt;A extends Interval, B extends Interval, R extends Interval&gt; List&lt;R&gt; mergeIntervalCollections(Collection&lt;A&gt; collection1,
			Collection&lt;B&gt; collection2, MergeIntervalOperations&lt;A, B, R&gt; operations) {

<span class="nc" id="L235">		MergeIntervals&lt;A, B, R&gt; intervalList = new MergeIntervals&lt;A, B, R&gt;();</span>
<span class="nc" id="L236">		return intervalList.merge(collection1, collection2, operations);</span>

	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>