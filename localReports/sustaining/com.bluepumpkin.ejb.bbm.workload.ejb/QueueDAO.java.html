<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QueueDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workload.ejb</a> &gt; <span class="el_source">QueueDAO.java</span></div><h1>QueueDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.workload.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  DAO object to serialize Queue object
 * Copyright:    Copyright (c) 2001
 * Company:      Blue Pumpkin Software, Inc
 * @author       lixin zhang
 * @version      1.0
 */

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoPKGeneratorFactory;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriodFieldInfo;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.workload.model.MediaFieldInfo;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueFieldInfo;
import com.bluepumpkin.ejb.bbm.workload.model.QueuePaginationData;

public class QueueDAO extends DAOBase{
<span class="fc" id="L43">	private static FieldInfo m_fieldInfo = new QueueFieldInfo();</span>

	protected FieldInfo getFieldInfo() {
<span class="fc" id="L46">		return m_fieldInfo;</span>
	}

	/**
	 * default constructor
	 */
<span class="fc" id="L52">	public QueueDAO() {</span>
<span class="fc" id="L53">	}</span>

	/**
	 * get queue object given its sid
	 */
	static Queue getQueueByID(ID sID) throws JdmoException {
<span class="fc" id="L59">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L61">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select A.ID, A.NAME, A.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.SID as QUEUEID, A.ORGANIZATIONID, C.NAME as ORGANIZATIONNAME, B.SID as MEDIAID, B.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE A, MEDIA B, ORGANIZATION C where A.ORGANIZATIONID = C.ID and A.MEDIAID = B.ID and A.SID=?&quot;);
<span class="fc" id="L63">			final JdmoQuery jq = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L64">			jq.setParID(1, sID);</span>
<span class="fc" id="L65">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L66">			Queue queue = null;</span>
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">			if (rs.next()) {</span>
<span class="fc" id="L68">				queue = getQueue(rs);</span>
			}
<span class="fc" id="L70">			return queue;</span>
		} finally {
<span class="pc" id="L72">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * get queue object given its sid
	 */
	static Collection&lt;Queue&gt; getAllQueues() throws JdmoException {
<span class="fc" id="L80">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L82">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION c where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID&quot;);
<span class="fc" id="L84">			return getQueues(jdmo, pStmt);</span>
		} finally {
<span class="pc" id="L86">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * it only returns queues that have not been linked to a SP
	 * 
	 * @param searchString
	 * @param mediaType
	 * @param orgIds
	 * @return
	 * @throws JdmoException
	 */
	static List&lt;Queue&gt; getQueuesByOrgIdsMediaTypeAndSearchString(String searchString, ID mediaType, List&lt;ID&gt; orgIds,
			int type, ID queueId, int totalrows) throws JdmoException {
<span class="fc" id="L101">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L103">			final StringBuffer pStmt = new StringBuffer(&quot;select TOP &quot;)</span>
<span class="fc" id="L104">					.append(totalrows)</span>
<span class="fc" id="L105">					.append(&quot; a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION c where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID &quot;);</span>
<span class="pc bpc" id="L106" title="3 of 4 branches missed.">			if ((searchString != null) &amp;&amp; !searchString.trim().isEmpty()) {</span>
<span class="nc" id="L107">				pStmt.append(&quot; and a.NAME LIKE '%&quot;).append(JdmoUtil.formatDBString(searchString)).append(&quot;%'&quot;);</span>
			}
<span class="fc" id="L109">			pStmt.append(&quot; and b.SID = &quot;).append(mediaType).append(&quot; and c.ID in &quot;).append(jdmo.createInClause(orgIds))</span>
<span class="fc" id="L110">					.append(&quot; and a.QUEUETYPE = &quot;).append(type)</span>
<span class="fc" id="L111">					.append(&quot; and (a.PARENTQUEUEID not in (select ID from QUEUE where SID = &quot;).append(queueId)</span>
<span class="fc" id="L112">					.append(&quot;) OR a.PARENTQUEUEID is null)&quot;)</span>
<span class="fc" id="L113">					.append(&quot; and a.id not in (&quot;)		// it only returns queues that have not been linked to an SP</span>
<span class="fc" id="L114">					.append(&quot; select distinct qq.id&quot;)</span>
<span class="fc" id="L115">					.append(&quot; from CAMPAIGN cp inner join sp s on s.CAMPAIGNID = cp.ID&quot;)</span>
<span class="fc" id="L116">					.append(&quot; inner join SPQUEUE sq on s.ID = sq.SPID&quot;)</span>
<span class="fc" id="L117">					.append(&quot; inner join QUEUE qq on qq.id = sq.QUEUEID&quot;)</span>
<span class="fc" id="L118">					.append(&quot; where qq.PARENTQUEUEID is null)&quot;)</span>
<span class="fc" id="L119">					.append(&quot; ORDER BY NAME&quot;);</span>
<span class="fc" id="L120">			final JdmoRowset rs = jdmo.createRowset(pStmt.toString());</span>
<span class="fc" id="L121">			final List&lt;Queue&gt; queuesColl = new ArrayList&lt;Queue&gt;();</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L123">				queuesColl.add(getQueue(rs));</span>
			}
<span class="fc" id="L125">			return queuesColl;</span>
		} finally {
<span class="pc" id="L127">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * get queue object given its sid
	 */
	static Collection&lt;Queue&gt; getQueuesByOrgID(ID orgID) throws JdmoException {
<span class="nc" id="L135">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L137">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, C.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION C where a.MEDIAID = b.ID and a.ORGANIZATIONID = c.ID and A.ORGANIZATIONID = &quot;);
<span class="nc" id="L139">			pStmt.append(orgID.toString());</span>
<span class="nc" id="L140">			return getQueues(jdmo, pStmt);</span>
		} finally {
<span class="nc" id="L142">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * get queue object given its sid
	 */
	static Collection&lt;Queue&gt; getQueuesByRecursedOrgID(ID orgID) throws JdmoException {
<span class="fc" id="L150">		return getQueuesByRecursedOrgID(orgID, null);</span>
	}

	/**
	 * get queue object given its sid and a Media DEID
	 * 
	 * @param orgID
	 *            - the ID of the org for which you want to get all the queues
	 *            available to it (including those defined at parent orgs)
	 * @param mediaIDs
	 *            - a collection of DEID's (String ID's) of the Medias that you
	 *            want to filter the queues by (EX: &quot;ID_PHONE       &quot;). Pass
	 *            null for all.
	 * @return all of the queues defined at orgID (or one of its parent orgs)
	 *         which are of the specified media type.
	 */
	static Collection&lt;Queue&gt; getQueuesByRecursedOrgID(ID orgID, Collection&lt;ID&gt; mediaIDs) throws JdmoException {
<span class="fc" id="L167">		final Jdmo jdmo = new Jdmo();</span>
		try {

<span class="fc" id="L170">			final Collection&lt;ID&gt; queueIds = new ArrayList&lt;ID&gt;();</span>

<span class="fc" id="L172">			final StringBuffer query = new StringBuffer();</span>
<span class="fc" id="L173">			query.append(&quot;SELECT ID, Name, ParentID&quot;).append(&quot; FROM ORGANIZATION&quot;).</span>
<span class="fc" id="L174">				append(&quot; WHERE ID = &quot;).append(JdmoUtil.asSqlLiteral(orgID));</span>

<span class="fc" id="L176">			final JdmoRowset x = jdmo.createRowset(query.toString());</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">			if (x.next()) {</span>
<span class="fc" id="L179">				final ID idOrg = x.getID(&quot;ID&quot;);</span>
<span class="fc" id="L180">				final ID idOrgParent = x.getID(&quot;ParentID&quot;);</span>
<span class="fc" id="L181">				final Collection&lt;ID&gt; qcoll = recurseQueuesUP(idOrg, idOrgParent, mediaIDs);</span>
<span class="fc" id="L182">				queueIds.addAll(qcoll);</span>
			}

<span class="pc bpc" id="L185" title="2 of 4 branches missed.">			if ((queueIds == null) || queueIds.isEmpty()) {</span>
<span class="nc" id="L186">				return Collections.&lt;Queue&gt;emptyList();</span>
			} else {
<span class="fc" id="L188">				return getQueuesByIDs(queueIds);</span>
			}
		} finally {
<span class="pc" id="L191">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param orgID
	 *            - the ID of the org for which you want to get all the queues
	 *            available to it (including those defined at parent orgs)
	 * @param sortColumn
	 *            - the column on which the sorting will be done
	 * @param sortOrder
	 *            - the order in which sorting will be done basically ASC or
	 *            DESC
	 * @param from
	 *            - the row number to start with
	 * @param to
	 *            - the row number till which you need the record
	 * @param down
	 *            - if true will pull the children for the organization
	 * @param queueTypes
	 *            - list of Queue Types you want to filter with. this can be
	 *            null or empty if you do not want to filter by Queue Types
	 * @return all of the queues defined at orgID (or one of its parent or child
	 *         orgs).
	 */
	static QueuePaginationData getPaginatedQueuesByRecursedOrgID(ID orgID, String sortColumn, String sortOrder, int from,
			int limit, boolean down, Collection&lt;ID&gt; queueTypes) throws JdmoException {
<span class="fc" id="L218">		final QueuePaginationData queuePaginationData = new QueuePaginationData();</span>

		// If the Organization ID is not passed then just return the Object
<span class="pc bpc" id="L221" title="1 of 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L222">			return queuePaginationData;</span>
		}

		// In case the Sort Column is passed as NULL or EMPTY
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">		if (StringUtil.isEmpty(sortColumn)) {</span>
<span class="nc" id="L227">			sortColumn = &quot;NAME&quot;;</span>
		}

<span class="fc" id="L230">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L232">			final List&lt;Queue&gt; queues = new ArrayList&lt;Queue&gt;();</span>

<span class="fc" id="L234">			final StringBuffer query = new StringBuffer(getOrganizationHierarchyQuery(down));</span>
<span class="fc" id="L235">			query.append(&quot;-- Doing a query on queue based on Organization heirarchy result \n&quot;)</span>
<span class="fc" id="L236">					.append(&quot;Select * from( SELECT ROW_NUMBER() OVER (ORDER BY &quot;)</span>
<span class="fc" id="L237">					.append(sortColumn)</span>
<span class="fc" id="L238">					.append(&quot; &quot;)</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">					.append(&quot;descending&quot;.equalsIgnoreCase(sortOrder) ? &quot;DESC&quot; // This</span>
																				// is
																				// written
																				// in
																				// this
																				// way
																				// to
																				// handle
																				// if
																				// NULL
																				// sortOrder
																				// is
																				// passed
							: &quot;ASC&quot;)
<span class="fc" id="L253">					.append(&quot; &quot;)</span>
<span class="fc" id="L254">					.append(&quot;) AS rownum ,TEMP.*, COUNT(*) OVER() AS total &quot;)</span>
<span class="fc" id="L255">					.append(&quot;FROM ( &quot;)</span>
<span class="fc" id="L256">					.append(&quot;SELECT a.SID AS QUEUEID &quot;)</span>
<span class="fc" id="L257">					.append(&quot;,a.NAME, a.DESCRIPTION, A.PARENTQUEUEID &quot;)</span>
<span class="fc" id="L258">					.append(&quot;,(SELECT sid FROM QUEUE q WHERE a.parentqueueid = q.id ) AS PARENTSID&quot;)</span>
<span class="fc" id="L259">					.append(&quot;,A.QUEUETYPE, A.ORGANIZATIONID&quot;)</span>
<span class="fc" id="L260">					.append(&quot;,c.NAME AS ORGANIZATIONNAME, b.SID AS MEDIAID&quot;)</span>
<span class="fc" id="L261">					.append(&quot;,b.NAME AS MEDIANAME, B.ID AS MEDIASTRID, &quot;)</span>
<span class="fc" id="L262">					.append(&quot;CASE A.QUEUETYPE &quot;)</span>
<span class="fc" id="L263">					.append(&quot;when 0 then 'NORMAL' &quot;)</span>
<span class="fc" id="L264">					.append(&quot;when 1 then 'DISTRIBUTED' &quot;)</span>
<span class="fc" id="L265">					.append(&quot;when 2 then 'VIRTUAL' &quot;)</span>
<span class="fc" id="L266">					.append(&quot;when 3 then 'PROCESS' &quot;)</span>
<span class="fc" id="L267">					.append(&quot;end as TYPENAME, &quot;)</span>
<span class="fc" id="L268">					.append(&quot;e.DSG as DSG &quot;)</span>
<span class="fc" id="L269">					.append(&quot;FROM QUEUE a left join (select Q.ID,Q.NAME,Q.SID,TOPDSG.DATASOURCEGROUPID,TOPDSG.NAME as DSG from queue q &quot;)</span>
<span class="fc" id="L270">					.append(&quot;cross apply (select TOP 1 DATASOURCEGROUPid,DSG.NAME from QUEUEGROUP QG inner join DATASOURCEGROUP DSG ON DSG.ID = QG.DATASOURCEGROUPID WHERE Q.SID = QG.QUEUEID ORDER BY DSG.NAME ASC) TOPDSG )&quot;)</span>
<span class="fc" id="L271">					.append(&quot; as e on a.SID = e.SID&quot;).append(&quot;, MEDIA b, ORGANIZATION c &quot;).append(&quot;, (&quot;);</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">			if (down) {</span>
<span class="nc" id="L273">				query.append(&quot;SELECT * FROM ORGANIZATIONHIERARCHICYDOWN UNION &quot;);</span>
			}
<span class="fc" id="L275">			query.append(&quot;SELECT * FROM ORGANIZATIONHIERARCHICYUP) d &quot;).append(</span>
					&quot;WHERE a.ORGANIZATIONID = c.ID AND a.MEDIAID = b.ID AND a.ORGANIZATIONID = d.ID&quot;);
<span class="pc bpc" id="L277" title="3 of 4 branches missed.">			if ((queueTypes != null) &amp;&amp; (queueTypes.size() &gt; 0)) {</span>
<span class="nc" id="L278">				query.append(&quot; and a.QUEUETYPE  in &quot;).append(jdmo.createInClause(queueTypes)).append(&quot; &quot;);</span>
			}
<span class="fc" id="L280">			query.append(&quot;) AS TEMP) As Temp2 &quot;).append(&quot;WHERE rownum &gt;= ? AND rownum &lt;= ?&quot;);</span>

<span class="fc" id="L282">			final JdmoQuery jq = jdmo.createQuery(query.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L283">			int parameterNumber = 1;</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">			if (down) {</span>
<span class="nc" id="L285">				jq.setParID(parameterNumber++, orgID);</span>
			}
<span class="fc" id="L287">			jq.setParID(parameterNumber++, orgID);</span>
<span class="fc" id="L288">			jq.setParInt(parameterNumber++, from);</span>
<span class="fc" id="L289">			jq.setParInt(parameterNumber++, limit);</span>
<span class="fc" id="L290">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="fc bfc" id="L292" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L293">				queuePaginationData.setTotal(rs.getInt(&quot;total&quot;));</span>
<span class="fc" id="L294">				queues.add(getQueue(rs));</span>
			}
<span class="fc" id="L296">			queuePaginationData.setQueues(queues);</span>
<span class="fc" id="L297">			return queuePaginationData;</span>

		} finally {
<span class="pc" id="L300">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param orgID
	 *            - the ID of the org for which you want to get all the queues
	 *            available to it (including those defined at parent orgs)
	 * @param sortColumn
	 *            - the column on which the sorting will be done
	 * @param sortOrder
	 *            - the order in which sorting will be done basically ASC or
	 *            DESC
	 * @param from
	 *            - the row number to start with
	 * @param to
	 *            - the row number till which you need the record
	 * @param down
	 *            - if true will pull the children for the organization
	 * @param queueTypes
	 *            - list of Queue Types you want to filter with. this can be
	 *            null or empty if you do not want to filter by Queue Types
	 * @return all of the parent queues defined at orgID (or one of its parent
	 *         or child orgs).
	 */
	static QueuePaginationData getPaginatedParentQueuesByRecursedOrgID(ID orgID, String sortColumn, String sortOrder,
			int from, int limit, boolean down, Collection&lt;ID&gt; queueTypes) throws JdmoException {
<span class="fc" id="L327">		final QueuePaginationData queuePaginationData = new QueuePaginationData();</span>

		// If the Organization ID is not passed then just return the Object
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L331">			return queuePaginationData;</span>
		}

		// In case the Sort Column is passed as NULL or EMPTY
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">		if (StringUtil.isEmpty(sortColumn)) {</span>
<span class="nc" id="L336">			sortColumn = &quot;NAME&quot;;</span>
		}

<span class="fc" id="L339">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L341">			final List&lt;Queue&gt; queues = new ArrayList&lt;Queue&gt;();</span>

<span class="fc" id="L343">			final StringBuffer query = new StringBuffer(getOrganizationHierarchyQuery(down));</span>
<span class="fc" id="L344">			query.append(&quot;,&quot;)</span>
<span class="fc" id="L345">					.append(&quot;-- This will pull the Down Heirarchy Data for Organization \n&quot;)</span>
<span class="fc" id="L346">					.append(&quot;QUEUEHIERARCHICY (ID, NAME, PARENTID)&quot;)</span>
<span class="fc" id="L347">					.append(&quot; AS (SELECT ID, NAME, PARENTQUEUEID &quot;)</span>
<span class="fc" id="L348">					.append(&quot;FROM QUEUE &quot;)</span>
<span class="fc" id="L349">					.append(&quot;UNION ALL &quot;)</span>
<span class="fc" id="L350">					.append(&quot;SELECT QUEUE.ID, QUEUE.NAME, QUEUE.PARENTQUEUEID &quot;)</span>
<span class="fc" id="L351">					.append(&quot;FROM QUEUE &quot;)</span>
<span class="fc" id="L352">					.append(&quot;INNER JOIN QUEUEHIERARCHICY ON QUEUE.PARENTQUEUEID = QUEUEHIERARCHICY.ID &quot;)</span>
<span class="fc" id="L353">					.append(&quot;WHERE QUEUE.PARENTQUEUEID IS NOT NULL) &quot;)</span>
<span class="fc" id="L354">					.append(&quot;-- Doing a query on queue based on Organization heirarchy result \n&quot;)</span>
<span class="fc" id="L355">					.append(&quot;Select * from( SELECT ROW_NUMBER() OVER (ORDER BY &quot;)</span>
<span class="fc" id="L356">					.append(sortColumn)</span>
<span class="fc" id="L357">					.append(&quot; &quot;)</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">					.append(&quot;descending&quot;.equalsIgnoreCase(sortOrder) ? &quot;DESC&quot; // This</span>
																				// is
																				// written
																				// in
																				// this
																				// way
																				// to
																				// handle
																				// if
																				// NULL
																				// sortOrder
																				// is
																				// passed
							: &quot;ASC&quot;)
<span class="fc" id="L372">					.append(&quot; &quot;)</span>
<span class="fc" id="L373">					.append(&quot;) AS rownum ,TEMP.*, COUNT(*) OVER() AS total &quot;)</span>
<span class="fc" id="L374">					.append(&quot;FROM ( &quot;)</span>
<span class="fc" id="L375">					.append(&quot;SELECT a.SID AS QUEUEID &quot;)</span>
<span class="fc" id="L376">					.append(&quot;,a.NAME, a.DESCRIPTION, A.PARENTQUEUEID &quot;)</span>
<span class="fc" id="L377">					.append(&quot;,(SELECT sid FROM QUEUE q WHERE a.parentqueueid = q.id ) AS PARENTSID&quot;)</span>
<span class="fc" id="L378">					.append(&quot;,A.QUEUETYPE, A.ORGANIZATIONID&quot;)</span>
<span class="fc" id="L379">					.append(&quot;,c.NAME AS ORGANIZATIONNAME, b.SID AS MEDIAID&quot;)</span>
<span class="fc" id="L380">					.append(&quot;,b.NAME AS MEDIANAME, B.ID AS MEDIASTRID, &quot;)</span>
<span class="fc" id="L381">					.append(&quot;CASE A.QUEUETYPE &quot;)</span>
<span class="fc" id="L382">					.append(&quot;when 0 then 'NORMAL' &quot;)</span>
<span class="fc" id="L383">					.append(&quot;when 1 then 'DISTRIBUTED' &quot;)</span>
<span class="fc" id="L384">					.append(&quot;when 2 then 'VIRTUAL' &quot;)</span>
<span class="fc" id="L385">					.append(&quot;when 3 then 'PROCESS' &quot;)</span>
<span class="fc" id="L386">					.append(&quot;end as TYPENAME, &quot;)</span>
<span class="fc" id="L387">					.append(&quot;e.DSG as DSG &quot;)</span>
<span class="fc" id="L388">					.append(&quot;FROM QUEUE a left join (SELECT distinct r.parentid, STUFF((SELECT distinct ','+ a.NAME FROM QUEUEHIERARCHICY a WHERE r.parentid = a.parentid &quot;)</span>
<span class="fc" id="L389">					.append(&quot;FOR xml PATH (''), TYPE) .value('.', 'VARCHAR(max)'), 1, 1, '') AS DSG FROM QUEUEHIERARCHICY r)&quot;)</span>
<span class="fc" id="L390">					.append(&quot; as e on a.ID = e.PARENTID&quot;).append(&quot;, MEDIA b, ORGANIZATION c &quot;).append(&quot;, (&quot;);</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">			if (down) {</span>
<span class="nc" id="L392">				query.append(&quot;SELECT * FROM ORGANIZATIONHIERARCHICYDOWN UNION &quot;);</span>
			}
<span class="fc" id="L394">			query.append(&quot;SELECT * FROM ORGANIZATIONHIERARCHICYUP) d &quot;).append(</span>
					&quot;WHERE a.ORGANIZATIONID = c.ID AND a.MEDIAID = b.ID AND a.ORGANIZATIONID = d.ID&quot;);
<span class="pc bpc" id="L396" title="2 of 4 branches missed.">			if ((queueTypes != null) &amp;&amp; (queueTypes.size() &gt; 0)) {</span>
<span class="fc" id="L397">				query.append(&quot; and a.QUEUETYPE  in &quot;).append(jdmo.createInClause(queueTypes)).append(&quot; &quot;);</span>
			}
<span class="fc" id="L399">			query.append(&quot;) AS TEMP) As Temp2 &quot;).append(&quot;WHERE rownum &gt;= ? AND rownum &lt;= ?&quot;);</span>

<span class="fc" id="L401">			final JdmoQuery jq = jdmo.createQuery(query.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L402">			int parameterNumber = 1;</span>
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">			if (down) {</span>
<span class="nc" id="L404">				jq.setParID(parameterNumber++, orgID);</span>
			}
<span class="fc" id="L406">			jq.setParID(parameterNumber++, orgID);</span>
<span class="fc" id="L407">			jq.setParInt(parameterNumber++, from);</span>
<span class="fc" id="L408">			jq.setParInt(parameterNumber++, limit);</span>
<span class="fc" id="L409">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="fc bfc" id="L411" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L412">				queuePaginationData.setTotal(rs.getInt(&quot;total&quot;));</span>
<span class="fc" id="L413">				queues.add(getQueue(rs));</span>
			}
<span class="fc" id="L415">			queuePaginationData.setQueues(queues);</span>
<span class="fc" id="L416">			return queuePaginationData;</span>

		} finally {
<span class="pc" id="L419">			jdmo.cleanUp();</span>
		}
	}

	static String getOrganizationHierarchyQuery(boolean down) {
<span class="fc" id="L424">		final StringBuilder query = new StringBuilder();</span>
<span class="fc" id="L425">		query.append(&quot;WITH&quot;);</span>
<span class="fc bfc" id="L426" title="All 2 branches covered.">		if (down) {</span>
<span class="fc" id="L427">			query.append(&quot;-- This will pull the Down Heirarchy Data for Organization \n&quot;)</span>
<span class="fc" id="L428">					.append(&quot;ORGANIZATIONHIERARCHICYDOWN (ID, NAME, PARENTID) &quot;)</span>
<span class="fc" id="L429">					.append(&quot;AS (SELECT ID, NAME, PARENTID &quot;)</span>
<span class="fc" id="L430">					.append(&quot;FROM ORGANIZATION &quot;)</span>
<span class="fc" id="L431">					.append(&quot;WHERE ID = ? &quot;)</span>
<span class="fc" id="L432">					.append(&quot;UNION ALL &quot;)</span>
<span class="fc" id="L433">					.append(&quot;SELECT ORGANIZATION.ID, ORGANIZATION.NAME, ORGANIZATION.PARENTID &quot;)</span>
<span class="fc" id="L434">					.append(&quot;FROM ORGANIZATION &quot;)</span>
<span class="fc" id="L435">					.append(&quot;INNER JOIN ORGANIZATIONHIERARCHICYDOWN ON ORGANIZATION.PARENTID = ORGANIZATIONHIERARCHICYDOWN.ID &quot;)</span>
<span class="fc" id="L436">					.append(&quot;WHERE ORGANIZATION.PARENTID IS NOT NULL), &quot;);</span>
		}

<span class="fc" id="L439">		query.append(&quot;-- This will pull the Up Heirarchy Data for Organization \n&quot;)</span>
<span class="fc" id="L440">				.append(&quot;ORGANIZATIONHIERARCHICYUP (ID, NAME, PARENTID) &quot;).append(&quot;AS (&quot;).append(&quot;SELECT ID,NAME,ParentID &quot;)</span>
<span class="fc" id="L441">				.append(&quot;FROM ORGANIZATION &quot;).append(&quot;WHERE ID = ? &quot;).append(&quot;UNION ALL &quot;)</span>
<span class="fc" id="L442">				.append(&quot;SELECT ORGANIZATION.ID, ORGANIZATION.NAME, ORGANIZATION.PARENTID &quot;).append(&quot;FROM ORGANIZATION &quot;)</span>
<span class="fc" id="L443">				.append(&quot;INNER JOIN ORGANIZATIONHIERARCHICYUP ON ORGANIZATION.ID = ORGANIZATIONHIERARCHICYUP.PARENTID &quot;)</span>
<span class="fc" id="L444">				.append(&quot;WHERE ORGANIZATION.PARENTID IS NOT NULL AND ORGANIZATION.ID != - 3001) &quot;);</span>
<span class="fc" id="L445">		return query.toString();</span>
	}

	static Collection&lt;ID&gt; recurseQueuesUP(ID idOrg, ID idOrgParent, Collection&lt;ID&gt; mediaIDs) throws JdmoException {
<span class="fc" id="L449">		final Jdmo jdmo = new Jdmo();</span>

		try {

<span class="fc" id="L453">			final Collection&lt;ID&gt; queueIds_local = new ArrayList&lt;ID&gt;();</span>

			// get the queues for this org....
<span class="fc" id="L456">			StringBuffer query = new StringBuffer();</span>
<span class="fc" id="L457">			query.append(&quot;SELECT q.SID, q.NAME&quot;).append(&quot; FROM QUEUE q&quot;).append(&quot; WHERE q.ORGANIZATIONID = &quot;).append(idOrg);</span>

<span class="pc bpc" id="L459" title="1 of 4 branches missed.">			if ((mediaIDs != null) &amp;&amp; (mediaIDs.size() &gt; 0)) {</span>
<span class="fc" id="L460">				query.append(&quot; and q.MEDIAID in ( select ID from MEDIA where SID in &quot;).append(jdmo.createInClause(mediaIDs))</span>
<span class="fc" id="L461">						.append(&quot; ) &quot;);</span>
			}

<span class="fc" id="L464">			JdmoRowset r = jdmo.createRowset(query.toString());</span>
<span class="fc bfc" id="L465" title="All 2 branches covered.">			while (r.next()) {</span>
<span class="fc" id="L466">				queueIds_local.add(r.getID(&quot;SID&quot;));</span>
			}
<span class="fc" id="L468">			r.close();</span>

<span class="fc bfc" id="L470" title="All 2 branches covered.">			if (!idOrg.equals(idOrgParent)) // when OrgID = Parent ID, we've</span>
											// reached the top.
			{
				// get the next layer of organizations...
<span class="fc" id="L474">				query = new StringBuffer();</span>
<span class="fc" id="L475">				query.append(&quot; SELECT ID, Name, ParentID&quot;).append(&quot; FROM ORGANIZATION &quot;).append(&quot; WHERE ID = &quot;)</span>
<span class="fc" id="L476">						.append(idOrgParent);</span>

<span class="fc" id="L478">				r = jdmo.createRowset(query.toString());</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">				while (r.next()) {</span>
<span class="fc" id="L480">					final ID idNextOrg = r.getID(&quot;ID&quot;);</span>
<span class="fc" id="L481">					final ID idNextOrgParent = r.getID(&quot;ParentID&quot;); // todo</span>
																	// CHECK
																	// THIS
<span class="fc" id="L484">					final Collection&lt;ID&gt; qcoll = recurseQueuesUP(idNextOrg, idNextOrgParent, mediaIDs);</span>
<span class="fc" id="L485">					queueIds_local.addAll(qcoll);</span>
<span class="fc" id="L486">				}</span>
<span class="fc" id="L487">				r.close();</span>
			}

<span class="fc" id="L490">			return queueIds_local;</span>

		} finally {
<span class="pc" id="L493">			jdmo.cleanUp();</span>
		}

	}

	/**
	 * get queue object given its sid
	 */
	static Collection&lt;Queue&gt; getQueuesByRecursedOrgIDDown(ID orgID) throws JdmoException {
<span class="nc" id="L502">		return getQueuesByRecursedOrgIDDown(orgID, null);</span>
	}

	/**
	 * get queue object given its sid and a Media DEID
	 * 
	 * @param orgID
	 *            - the ID of the org for which you want to get all the queues
	 *            available to it (including those defined at parent orgs)
	 * @param mediaIDs
	 *            - a collection of DEID's (String ID's) of the Medias that you
	 *            want to filter the queues by (EX: &quot;ID_PHONE       &quot;). Pass
	 *            null for all.
	 * @return all of the queues defined at orgID (or one of its parent orgs)
	 *         which are of the specified media type.
	 */
	static Collection&lt;Queue&gt; getQueuesByRecursedOrgIDDown(ID orgID, Collection&lt;ID&gt; mediaIDs) throws JdmoException {
<span class="nc" id="L519">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L521">			final Collection&lt;ID&gt; queueIds = new ArrayList&lt;ID&gt;();</span>

<span class="nc" id="L523">			final StringBuffer query = new StringBuffer();</span>
<span class="nc" id="L524">			query.append(&quot;SELECT ID, Name, ParentID&quot;).append(&quot; FROM ORGANIZATION&quot;).append(&quot; WHERE ID = &quot;).append(orgID);</span>

<span class="nc" id="L526">			final JdmoRowset x = jdmo.createRowset(query.toString());</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">			if (x.next()) {</span>
<span class="nc" id="L529">				final ID idOrg = x.getID(&quot;ID&quot;);</span>
<span class="nc" id="L530">				final Collection&lt;ID&gt; qcoll = recurseQueuesDOWN(idOrg, mediaIDs);</span>
<span class="nc" id="L531">				queueIds.addAll(qcoll);</span>
			}

<span class="nc bnc" id="L534" title="All 4 branches missed.">			if ((queueIds == null) || queueIds.isEmpty()) {</span>
<span class="nc" id="L535">				return null;</span>
			} else {
<span class="nc" id="L537">				return getQueuesByIDs(queueIds);</span>
			}
		} finally {
<span class="nc" id="L540">			jdmo.cleanUp();</span>
		}
	}

	static Collection&lt;ID&gt; recurseQueuesDOWN(ID idOrg, Collection&lt;ID&gt; mediaIDs) throws JdmoException {
<span class="nc" id="L545">		final Jdmo jdmo = new Jdmo();</span>

		try {
<span class="nc" id="L548">			final Collection&lt;ID&gt; queueIds_local = new ArrayList&lt;ID&gt;();</span>

			// get the queues for this org....
<span class="nc" id="L551">			StringBuffer query = new StringBuffer();</span>
<span class="nc" id="L552">			query.append(&quot;SELECT q.SID, q.NAME&quot;).append(&quot; FROM QUEUE q&quot;).append(&quot; WHERE q.ORGANIZATIONID = &quot;).append(idOrg);</span>

<span class="nc bnc" id="L554" title="All 4 branches missed.">			if ((mediaIDs != null) &amp;&amp; (mediaIDs.size() &gt; 0)) {</span>
<span class="nc" id="L555">				query.append(&quot; and q.MEDIAID in ( select ID from MEDIA where SID in &quot;).append(jdmo.createInClause(mediaIDs))</span>
<span class="nc" id="L556">						.append(&quot; ) &quot;);</span>
			}

<span class="nc" id="L559">			JdmoRowset r = jdmo.createRowset(query.toString());</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L561">				queueIds_local.add(r.getID(&quot;SID&quot;));</span>

			}
<span class="nc" id="L564">			r.close();</span>

			// get the next layer of organizations...
<span class="nc" id="L567">			query = new StringBuffer();</span>
<span class="nc" id="L568">			query.append(&quot; SELECT ID, Name, ParentID&quot;).append(&quot; FROM ORGANIZATION &quot;).append(&quot; WHERE ParentID = &quot;)</span>
<span class="nc" id="L569">					.append(idOrg);</span>

<span class="nc" id="L571">			r = jdmo.createRowset(query.toString());</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L573">				final ID idNextOrg = r.getID(&quot;ID&quot;);</span>
<span class="nc" id="L574">				final Collection&lt;ID&gt; qcoll = recurseQueuesDOWN(idNextOrg, mediaIDs);</span>
<span class="nc" id="L575">				queueIds_local.addAll(qcoll);</span>
<span class="nc" id="L576">			}</span>
<span class="nc" id="L577">			r.close();</span>

<span class="nc" id="L579">			return queueIds_local;</span>

		} finally {
<span class="nc" id="L582">			jdmo.cleanUp();</span>
		}

	}

	/**
	 * get queue objects given their SIDs
	 */
	static Collection&lt;Queue&gt; getQueuesByIDs(Collection&lt;? extends ID&gt; colIDs) throws JdmoException {
<span class="fc" id="L591">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L593">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID, (select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION c where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID and a.SID in &quot;);
<span class="fc" id="L595">			pStmt.append(jdmo.createInClause(colIDs));</span>
<span class="fc" id="L596">			return getQueues(jdmo, pStmt);</span>
		} finally {
<span class="pc" id="L598">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * create queue
	 */
	static ID createQueue(Queue objValue) throws JdmoException {
<span class="fc" id="L606">		final Jdmo jdmo = new Jdmo();</span>
		try {
			// get ID from DE
<span class="fc" id="L609">			final String idStr = DAOUtil.getDEID(jdmo);</span>

			// parameters must have escaped character processing, when prepared
			// statement style ? is not used
<span class="fc" id="L613">			final String escapedQueueName = JdmoUtil.formatDBString(objValue.getName());</span>

<span class="fc" id="L615">			final String pStmt1 = &quot;insert into QUEUE (ID, NAME, DESCRIPTION, MEDIAID, QUEUETYPE, ORGANIZATIONID) values (?, ?, ?, ?, ?, ?)&quot;;</span>
<span class="fc" id="L616">			Object[] param = new Object[6];</span>
<span class="fc" id="L617">			param[0] = idStr;</span>

			// These don't need escaping because they are bound to ? style
			// prepared statement thingies
<span class="fc" id="L621">			param[1] = objValue.getName();</span>
<span class="fc" id="L622">			param[2] = objValue.getDescription();</span>

<span class="fc" id="L624">			param[3] = objValue.getMediaStrID();</span>
<span class="fc" id="L625">			param[4] = new Integer(objValue.getQueueType());</span>
<span class="fc" id="L626">			param[5] = objValue.getOrganizationID();</span>

<span class="pc bpc" id="L628" title="1 of 2 branches missed.">			if (param[5] == null) { // failsafe. No defined org ID = system org.</span>
<span class="nc" id="L629">				objValue.setOrganizationID(new ID(-3002));</span>
<span class="nc" id="L630">				param[5] = objValue.getOrganizationID();</span>
			}

<span class="fc" id="L633">			jdmo.executePCommand(pStmt1, param);</span>

			// Query the new row for its database generated SID
<span class="fc" id="L636">			StringBuffer pStmt = new StringBuffer(&quot;select SID from QUEUE where ID=?&quot;);</span>
<span class="fc" id="L637">			final JdmoQuery jq1 = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L638">			jq1.setParString(1, idStr);</span>
<span class="fc" id="L639">			JdmoRowset rs = jdmo.createRowset(jq1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="fc" id="L641">			ID queueID = null;</span>
<span class="pc bpc" id="L642" title="1 of 2 branches missed.">			if (rs.next()) {</span>
<span class="fc" id="L643">				queueID = rs.getID(1);</span>

				// Create a QUEUE edm in EDM table (this is used for warehouse
				// number crunching, based on concept of extended dimension)
				// TODO: Logic of EDM relationship to QUEUE seems like it
				// belongs in biz layer not DAO layer
<span class="fc" id="L649">				pStmt = new StringBuffer(&quot;SELECT * FROM EDM WHERE UPPER(RTRIM(LTRIM(NAME))) = UPPER('&quot;);</span>
<span class="fc" id="L650">				pStmt.append((escapedQueueName).trim());</span>
<span class="fc" id="L651">				pStmt.append(&quot;')&quot;);</span>
<span class="fc" id="L652">				rs = jdmo.createRowset(pStmt.toString(), Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">				if (!rs.next()) {</span>
<span class="fc" id="L654">					pStmt = new StringBuffer(&quot;INSERT INTO EDM (ID, EDTID, NAME, DESCRIPTION, &quot;);</span>
<span class="fc" id="L655">					pStmt.append(&quot;ISDEFAULT, CREATIONDATE, ISACTIVE, ISAUTOMAPPING) &quot;);</span>
<span class="fc" id="L656">					pStmt.append(&quot;VALUES (?, -277000, ?, ?, 0, GETDATE(), 1, 1)&quot;);</span>
<span class="fc" id="L657">					final ID edmId = JdmoPKGeneratorFactory.create(&quot;EDM&quot;, false).generate(jdmo.getConnection(), &quot;EDM&quot;);</span>
<span class="fc" id="L658">					param = new Object[3];</span>
<span class="fc" id="L659">					param[0] = edmId.toString();</span>

					// These don't need escaping because they are bound to ?
					// style prepared statement thingies
<span class="fc" id="L663">					param[1] = objValue.getName();</span>
<span class="fc" id="L664">					param[2] = objValue.getDescription();</span>

<span class="fc" id="L666">					jdmo.executePCommand(pStmt.toString(), param);</span>

					// Create EMD mapping to F&amp;S data source: Insert data into
					// EDMDATASOURCE, EDMDATASOURCEEXT
					// EDMDATASOURCE Table
<span class="fc" id="L671">					pStmt = new StringBuffer(&quot;INSERT INTO EDMDATASOURCE (ID, DATASOURCEID, INDATASOURCEID, EDMID) &quot;);</span>
<span class="fc" id="L672">					pStmt.append(&quot;VALUES (?, null, -50000, ?)&quot;);</span>
<span class="fc" id="L673">					final ID edmDataSourceId = JdmoPKGeneratorFactory.create(&quot;EDMDATASOURCE&quot;, false).generate(</span>
<span class="fc" id="L674">							jdmo.getConnection(), &quot;EDMDATASOURCE&quot;);</span>
<span class="fc" id="L675">					param = new Object[2];</span>
<span class="fc" id="L676">					param[0] = edmDataSourceId.toString();</span>
<span class="fc" id="L677">					param[1] = edmId.toString();</span>
<span class="fc" id="L678">					jdmo.executePCommand(pStmt.toString(), param);</span>
					// EDMDATASOURCEEXT Table
<span class="fc" id="L680">					pStmt = new StringBuffer(&quot;INSERT INTO EDMDATASOURCEEXT (ID, EXTERNALEDMIDENT, EDMDATASOURCEID) &quot;);</span>
<span class="fc" id="L681">					pStmt.append(&quot;VALUES (?, ?, ?)&quot;);</span>
<span class="fc" id="L682">					final ID edmDataSourceExtId = JdmoPKGeneratorFactory.create(&quot;EDMDATASOURCEEXT&quot;, false).generate(</span>
<span class="fc" id="L683">							jdmo.getConnection(), &quot;EDMDATASOURCEEXT&quot;);</span>
<span class="fc" id="L684">					param = new Object[3];</span>
<span class="fc" id="L685">					param[0] = edmDataSourceExtId.toString();</span>
<span class="fc" id="L686">					param[1] = idStr;</span>
<span class="fc" id="L687">					param[2] = edmDataSourceId.toString();</span>
<span class="fc" id="L688">					jdmo.executePCommand(pStmt.toString(), param);</span>
				}
			}
<span class="fc" id="L691">			return queueID;</span>
		} finally {
<span class="pc" id="L693">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Remove a Queue by SID
	 * 
	 * @param SID
	 */
	static void deleteQueues(Collection&lt;ID&gt; colIDs) throws JdmoException {
<span class="nc" id="L703">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L705" title="All 2 branches missed.">			for (final Iterator&lt;ID&gt; it = colIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L706">				final Object[] param = new Object[1];</span>
<span class="nc" id="L707">				param[0] = it.next();</span>
<span class="nc" id="L708">				jdmo.executePCommand(&quot;delete QUEUEHISTORYTIMESERIES where QUEUEID in (select ID from QUEUE where SID=?)&quot;,</span>
						param);
<span class="nc" id="L710">				jdmo.executePCommand(&quot;delete SKILLQUEUE where QUEUEID in (select ID from QUEUE where SID=?)&quot;, param);</span>
<span class="nc" id="L711">				jdmo.executePCommand(&quot;delete TRACETRACK where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L712">				jdmo.executePCommand(&quot;delete QUEUEGROUP where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L713">				jdmo.executePCommand(&quot;delete PULSENOTEQUEUE where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L714">				jdmo.executePCommand(&quot;delete VCTEVENT where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L715">				jdmo.executePCommand(&quot;delete VCTQUEUEPROCESSING where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L716">				jdmo.executePCommand(&quot;delete PROCESSQUEUE where PARENTQUEUEID=?&quot;, param);</span>
<span class="nc" id="L717">				jdmo.executePCommand(&quot;delete PROCESSQUEUE where QUEUEID=?&quot;, param);</span>
<span class="nc" id="L718">				jdmo.executePCommand(&quot;delete PROFILETIMESERIES where QUEUEID in (select ID from QUEUE where SID=?)&quot;, param); // M</span>
																																// Nguyen
																																// 9/30/2008
																																// Fix
																																// QA
																																// 91063
<span class="nc" id="L724">				jdmo.executePCommand(&quot;delete QUEUE where SID=?&quot;, param);</span>
<span class="nc" id="L725">			}</span>
		} finally {
<span class="nc" id="L727">			jdmo.cleanUp();</span>
<span class="nc" id="L728">		}</span>
<span class="nc" id="L729">	}</span>

	/**
	 * Remove a Queue by SID
	 * 
	 * @param SID
	 */
	static void updateQueue(Queue objValue) throws JdmoException {

		// objValue.print();
<span class="nc" id="L739">		final Jdmo jdmo = new Jdmo();</span>
		try {
			// Keep the old name (escaped) as well as the new name (escaped)
			// except for ? style prepared statements
<span class="nc" id="L743">			final String oldQueueNameEscaped = JdmoUtil.formatDBString(getQueueNameByID(objValue.getID()));</span>
<span class="nc" id="L744">			final String queueNameEscaped = JdmoUtil.formatDBString(objValue.getName());</span>

<span class="nc" id="L746">			StringBuffer pStmt = new StringBuffer(&quot;update QUEUE set NAME=?, &quot;)</span>
<span class="nc" id="L747">					.append(&quot;DESCRIPTION=?, MEDIAID=?, PARENTQUEUEID= ?, QUEUETYPE=?, ORGANIZATIONID=? where SID=?&quot;);</span>
<span class="nc" id="L748">			final Object[] param = new Object[7];</span>
<span class="nc" id="L749">			param[0] = objValue.getName();</span>
<span class="nc" id="L750">			param[1] = objValue.getDescription();</span>
<span class="nc" id="L751">			param[2] = objValue.getMediaStrID();</span>
<span class="nc" id="L752">			final String parentID = objValue.getParentQueueID();</span>
<span class="nc" id="L753">			final Object jobj = new JdmoParam(null, 3);</span>
<span class="nc bnc" id="L754" title="All 4 branches missed.">			param[3] = (((parentID == null) || parentID.trim().equals(&quot;&quot;)) ? jobj : parentID);</span>
<span class="nc" id="L755">			param[4] = new Integer(objValue.getQueueType());</span>
<span class="nc" id="L756">			param[5] = objValue.getOrganizationID().toString();</span>
<span class="nc" id="L757">			param[6] = objValue.getID();</span>
<span class="nc" id="L758">			jdmo.executePCommand(pStmt.toString(), param);</span>

			// Update to new name, desc in EDM table (using name as the pseudo
			// Key a/k/a alternate unique key)
<span class="nc" id="L762">			final String strQueueDesc = JdmoUtil.formatDBString(objValue.getDescription());</span>

<span class="nc" id="L764">			pStmt = new StringBuffer(&quot;UPDATE EDM SET NAME = '&quot;);</span>
<span class="nc" id="L765">			pStmt.append(queueNameEscaped).append(&quot;' &quot;);</span>
<span class="nc" id="L766">			pStmt.append(&quot;, DESCRIPTION = '&quot;);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">			pStmt.append(strQueueDesc != null ? strQueueDesc : &quot;&quot;);</span>
<span class="nc" id="L768">			pStmt.append(&quot;' &quot;);</span>
<span class="nc" id="L769">			pStmt.append(&quot;WHERE NAME='&quot;);</span>
<span class="nc" id="L770">			pStmt.append(oldQueueNameEscaped).append(&quot;' &quot;);</span>
<span class="nc" id="L771">			jdmo.executeCommand(pStmt.toString());</span>

		} finally {
<span class="nc" id="L774">			jdmo.cleanUp();</span>
<span class="nc" id="L775">		}</span>

<span class="nc" id="L777">	}</span>

	static String getQueueNameByID(ID idQueue) throws JdmoException {
<span class="nc" id="L780">		final Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L782">			final StringBuffer pStmt = new StringBuffer(&quot;select NAME from QUEUE where SID=?&quot;);</span>
<span class="nc" id="L783">			final JdmoQuery jq = dmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L784">			jq.setParID(1, idQueue);</span>
<span class="nc" id="L785">			final JdmoRowset rs = dmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L786">			String queueName = null;</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L788">				queueName = rs.getString(1);</span>
			}
<span class="nc" id="L790">			return queueName;</span>
		} finally {
<span class="nc" id="L792">			dmo.cleanUp();</span>
		}
	}

	/**
	 * Routine to return the ID of a queue given the name. Throws an erro if
	 * name is not unique
	 * 
	 * @param name
	 * @return ID
	 * @throws JdmoException
	 */
	static ID getQueueIDByName(String name) throws JdmoException {
<span class="nc" id="L805">		ID queueID = null;</span>

<span class="nc" id="L807">		final Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L809">			final StringBuffer pStmt = new StringBuffer(&quot;select SID from QUEUE where NAME=?&quot;);</span>
<span class="nc" id="L810">			final JdmoQuery jq = dmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L811">			jq.setParString(1, name);</span>
<span class="nc" id="L812">			final JdmoRowset rs = dmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc bnc" id="L814" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L815">				queueID = rs.getID(1);</span>

				// check unique
<span class="nc bnc" id="L818" title="All 2 branches missed.">				if (rs.next()) {</span>
<span class="nc" id="L819">					throw new JdmoException(&quot;Non unique queue name; &quot; + name);</span>
				}
			}

		} finally {
<span class="nc" id="L824">			dmo.cleanUp();</span>
<span class="nc" id="L825">		}</span>

<span class="nc" id="L827">		return queueID;</span>
	}

	static HashMap&lt;ID, String&gt; getQueueNamesByIDs(Collection&lt;ID&gt; idCol) throws JdmoException {
<span class="nc" id="L831">		final Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L833">			final StringBuffer pStmt = new StringBuffer(&quot;select SID, NAME from QUEUE where SID in &quot;);</span>
<span class="nc" id="L834">			pStmt.append(dmo.createInClause(idCol));</span>
<span class="nc" id="L835">			final JdmoRowset rs = dmo.createRowset(pStmt.toString());</span>
<span class="nc" id="L836">			final HashMap&lt;ID, String&gt; nameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L838">				nameMap.put(rs.getID(1), rs.getString(2));</span>
			}
<span class="nc" id="L840">			return nameMap;</span>
		} finally {
<span class="nc" id="L842">			dmo.cleanUp();</span>
		}
	}

	/**
	 * Get a pair of maps given a collection of queue DE String ids
	 * 
	 * @return a map of queue DEID to queue name, and a map of queue DEID to SID
	 */
	static Pair&lt;Map&lt;ID, String&gt;, Map&lt;ID, ID&gt;&gt; getQueueNameSIDMapsByDEIDs(Collection&lt;ID&gt; idCol) throws JdmoException {
<span class="nc" id="L852">		final Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L854">			final StringBuffer pStmt = new StringBuffer(&quot;select ID, SID, NAME from QUEUE where ID in &quot;);</span>
<span class="nc" id="L855">			pStmt.append(dmo.createInClause(idCol));</span>
<span class="nc" id="L856">			final JdmoRowset rs = dmo.createRowset(pStmt.toString());</span>
<span class="nc" id="L857">			final Map&lt;ID, String&gt; nameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc" id="L858">			final Map&lt;ID, ID&gt; sidMap = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L860">				nameMap.put(rs.getID(1), rs.getString(3));</span>
<span class="nc" id="L861">				sidMap.put(rs.getID(1), rs.getID(2));</span>
			}
<span class="nc" id="L863">			return new Pair&lt;Map&lt;ID, String&gt;, Map&lt;ID, ID&gt;&gt;(nameMap, sidMap);</span>
		} finally {
<span class="nc" id="L865">			dmo.cleanUp();</span>
		}
	}

	/**
	 *
	 * @param colIDs
	 *            - collection of queue SIDs
	 * @throws JdmoException
	 */
	static void unLinkQueuesParents(Collection&lt;ID&gt; colIDs) throws JdmoException {
<span class="fc" id="L876">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L878">			final StringBuffer pStmt = new StringBuffer(&quot;update QUEUE set PARENTQUEUEID=NULL where SID in &quot;);</span>
<span class="fc" id="L879">			pStmt.append(jdmo.createInClause(colIDs));</span>
<span class="fc" id="L880">			jdmo.executeCommand(pStmt.toString());</span>
		} finally {
<span class="pc" id="L882">			jdmo.cleanUp();</span>
<span class="fc" id="L883">		}</span>
<span class="fc" id="L884">	}</span>

	/**
	 *
	 * @param queueID
	 *            - queue SID
	 * @param colIDs
	 *            - collection of queue SIDs
	 * @throws JdmoException
	 */
	static void linkQueues(ID queueID, Collection&lt;ID&gt; colIDs) throws JdmoException {
<span class="fc" id="L895">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L897">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;update QUEUE set PARENTQUEUEID=(select ID from QUEUE q where SID =?)  where SID in &quot;);
<span class="fc" id="L899">			pStmt.append(jdmo.createInClause(colIDs));</span>
<span class="fc" id="L900">			final Object[] param = new Object[1];</span>
<span class="fc" id="L901">			param[0] = queueID;</span>

<span class="fc" id="L903">			jdmo.executePCommand(pStmt.toString(), param);</span>
		} finally {
<span class="pc" id="L905">			jdmo.cleanUp();</span>
<span class="fc" id="L906">		}</span>

<span class="fc" id="L908">	}</span>

	/**
	 * get queues given type bit mask
	 */
	static Collection&lt;Queue&gt; getQueuesByType(int queueTypeBitMask) throws JdmoException {
<span class="nc" id="L914">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L916">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, C.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION c where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID&quot;);
<span class="nc" id="L918">			final List&lt;ID&gt; primQueues = new ArrayList&lt;ID&gt;(3);</span>
<span class="nc" id="L919">			final List&lt;ID&gt; parentQueues = new ArrayList&lt;ID&gt;(2);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_NORMAL) != 0) {</span>
<span class="nc" id="L921">				primQueues.add(new ID(Queue.QUEUE_TYPE_NORMAL));</span>
			}

<span class="nc bnc" id="L924" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_PROCESS) != 0) {</span>
<span class="nc" id="L925">				primQueues.add(new ID(Queue.QUEUE_TYPE_PROCESS));</span>
			}

<span class="nc bnc" id="L928" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_DISTRIBUTED) != 0) {</span>
<span class="nc" id="L929">				primQueues.add(new ID(Queue.QUEUE_TYPE_DISTRIBUTED));</span>
			}
<span class="nc bnc" id="L931" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_VIRTUAL) != 0) {</span>
<span class="nc" id="L932">				primQueues.add(new ID(Queue.QUEUE_TYPE_VIRTUAL));</span>
			}

<span class="nc bnc" id="L935" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_SUB_DISTRIBUTED) != 0) {</span>
<span class="nc" id="L936">				parentQueues.add(new ID(Queue.QUEUE_TYPE_DISTRIBUTED));</span>
			}
<span class="nc bnc" id="L938" title="All 2 branches missed.">			if ((queueTypeBitMask &amp; Queue.QUEUE_TYPE_BIT_SUB_VIRTUAL) != 0) {</span>
<span class="nc" id="L939">				parentQueues.add(new ID(Queue.QUEUE_TYPE_VIRTUAL));</span>
			}

<span class="nc bnc" id="L942" title="All 4 branches missed.">			if (!primQueues.isEmpty() || !parentQueues.isEmpty()) {</span>
<span class="nc" id="L943">				pStmt.append(&quot; AND (&quot;);</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">				if (!primQueues.isEmpty()) {</span>
<span class="nc" id="L945">					pStmt.append(&quot;QUEUETYPE IN &quot;);</span>
<span class="nc" id="L946">					pStmt.append(jdmo.createInClause(primQueues));</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">					if (!parentQueues.isEmpty()) {</span>
<span class="nc" id="L948">						pStmt.append(&quot; OR (PARENTQUEUEID in (select ID from QUEUE where queuetype in &quot;);</span>
<span class="nc" id="L949">						pStmt.append(jdmo.createInClause(parentQueues));</span>
<span class="nc" id="L950">						pStmt.append(&quot; ))&quot;);</span>
					}
				} else {
<span class="nc" id="L953">					pStmt.append(&quot; AND PARENTQUEUEID in (select ID from QUEUE where queuetype in &quot;);</span>
<span class="nc" id="L954">					pStmt.append(jdmo.createInClause(parentQueues));</span>
<span class="nc" id="L955">					pStmt.append(&quot; )&quot;);</span>
				}
<span class="nc" id="L957">				pStmt.append(&quot; )&quot;);</span>

			}
<span class="nc" id="L960">			return getQueues(jdmo, pStmt);</span>
		} finally {
<span class="nc" id="L962">			jdmo.cleanUp();</span>
		}

	}

	/**
	 *
	 * @param distributedQueues
	 *            - collection of distributed queues IDs
	 * @return Collection of Queues
	 */
	static Collection&lt;Queue&gt; getSubQueueus(Collection&lt;ID&gt; distributedQueuesIDs) throws JdmoException {
<span class="nc" id="L974">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L976">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,(select sid from queue q where a.parentqueueid = q.id) as PARENTSID , A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b, ORGANIZATION c where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID&quot;);
<span class="nc" id="L978">			pStmt.append(&quot; AND A.PARENTQUEUEID in (select a.ID from QUEUE where A.SID in &quot;);</span>
<span class="nc" id="L979">			pStmt.append(jdmo.createInClause(distributedQueuesIDs));</span>
<span class="nc" id="L980">			pStmt.append(&quot;)&quot;);</span>
<span class="nc" id="L981">			return getQueues(jdmo, pStmt);</span>
		} finally {
<span class="nc" id="L983">			jdmo.cleanUp();</span>
		}
	}

	static Collection&lt;ID&gt; getSubQueuesIDs(Collection&lt;ID&gt; queuesIDs) throws JdmoException {
<span class="fc" id="L988">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L990">			final StringBuffer pStmt = new StringBuffer(</span>
					&quot;select a.SID as QUEUEID from QUEUE a where A.PARENTQUEUEID in (select q.ID from QUEUE q where q.SID in &quot;);
<span class="fc" id="L992">			pStmt.append(jdmo.createInClause(queuesIDs));</span>
<span class="fc" id="L993">			pStmt.append(&quot;)&quot;);</span>
<span class="fc" id="L994">			final JdmoQuery jq = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L995">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L996">			final List&lt;ID&gt; collIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L997" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L998">				collIDs.add(new ID(rs.getInt(&quot;QUEUEID&quot;)));</span>
			}
<span class="fc" id="L1000">			return collIDs;</span>
		} finally {
<span class="pc" id="L1002">			jdmo.cleanUp();</span>
		}

	}

	private static Collection&lt;Queue&gt; getQueues(Jdmo jdmo, StringBuffer pStmt) throws JdmoException {
<span class="fc" id="L1008">		final JdmoQuery jq = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L1009">		final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L1010">		final ArrayList&lt;Queue&gt; queuesColl = new ArrayList&lt;Queue&gt;();</span>
<span class="fc bfc" id="L1011" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L1012">			queuesColl.add(getQueue(rs));</span>
		}
<span class="fc" id="L1014">		return queuesColl;</span>

	}

	/**
	 * Returns the non-combined queues in the given SP with the given media ID.
	 * If a null media ID is specified, this method will return all non-combined
	 * queues in the SP.
	 */
	public static Collection&lt;Queue&gt; getNonCombinedQueuesByMediaAndSP(ID mediaID, ID spID) throws JdmoException {
<span class="fc" id="L1024">		final Jdmo jdmo = new Jdmo();</span>
		try {

<span class="fc" id="L1027">			spID = DAOUtil.mapIDToDEID(spID, new SchedulingPeriodFieldInfo());</span>
<span class="fc" id="L1028">			mediaID = DAOUtil.mapIDToDEID(mediaID, new MediaFieldInfo());</span>

<span class="fc" id="L1030">			String query = &quot;select a.SID as QUEUEID, a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,&quot;</span>
					+ &quot;(select sid from queue q where a.parentqueueid = q.id) as PARENTSID ,&quot;
					+ &quot;A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID,&quot;
					+ &quot;b.NAME as MEDIANAME, B.ID as MEDIASTRID from QUEUE a, MEDIA b,&quot;
					+ &quot;ORGANIZATION c, SPQUEUE d where a.ORGANIZATIONID = c.ID and a.MEDIAID = b.ID and &quot;
<span class="fc" id="L1035">					+ &quot;a.ID = d.QUEUEID and &quot; + &quot;d.SPID = &quot; + JdmoUtil.asSqlLiteral(spID) + &quot; and &quot;</span>
					+ &quot;d.QUEUEID IS NOT NULL&quot;;
<span class="fc bfc" id="L1037" title="All 2 branches covered.">			if (mediaID != null) {</span>
<span class="fc" id="L1038">				query += &quot; and a.MEDIAID =  &quot; + JdmoUtil.asSqlLiteral(mediaID);</span>
			}
<span class="fc" id="L1040">			final StringBuffer pStmt = new StringBuffer(query);</span>
<span class="fc" id="L1041">			return getQueues(jdmo, pStmt);</span>
<span class="nc" id="L1042">		} catch (final BbmFinderException e) {</span>
<span class="nc" id="L1043">			throw new JdmoException(e);</span>
		} finally {
<span class="pc" id="L1045">			jdmo.cleanUp();</span>
		}
	}

	public static Collection&lt;ID&gt; getRootLinkQueueIDs(ID spID) throws JdmoException {
<span class="fc" id="L1050">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L1052">			final StringBuffer pStmt = new StringBuffer(&quot;SELECT	DISTINCT Q.SID FROM VCTCHAIN VC, VCTCHAINQUEUE VCQ, &quot;</span>
					+ &quot;VCTQUEUECONFIGURATION VQC, QUEUE Q, SPQUEUE SPQ, QUEUE Q2, &quot;
					+ &quot;VCTQUEUECONFIGURATION VQC2, MEDIA M, SP WHERE VCQ.VCTCHAINID = VC.ID &quot;
					+ &quot;AND M.ID = Q.MEDIAID AND VQC.ID = VC.VCTQUEUECONFIGURATIONID &quot;
					+ &quot;AND VQC.QUEUEID = Q.SID AND SPQ.QUEUEID = Q.ID AND SPQ.SPID = SP.ID &quot; + &quot;AND SP.SID=&quot;
<span class="fc" id="L1057">					+ JdmoUtil.asSqlLiteral(spID) + &quot;AND SPQ.QUEUEID IS NOT NULL AND ISMULTISELECT = 0 AND &quot;</span>
					+ &quot;Q2.SID = VCQ.QUEUEID AND VQC2.QUEUEID = VCQ.QUEUEID &quot; + &quot;AND ((VC.TARGETEVENT = 1) OR &quot;
					+ &quot;(VC.TARGETEVENT = 3 AND VQC2.COLLECTIONTYPE = 3)) &quot;
					+ &quot;AND VQC.QUEUEID NOT IN (SELECT QUEUEID FROM VCTCHAINQUEUE)&quot;);
<span class="fc" id="L1061">			final ArrayList&lt;ID&gt; queueIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L1062">			final JdmoQuery jq = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L1063">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="pc bpc" id="L1064" title="1 of 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1065">				queueIDs.add(rs.getID(1));</span>
			}
<span class="fc" id="L1067">			return queueIDs;</span>
		} finally {
<span class="pc" id="L1069">			jdmo.cleanUp();</span>
		}
	}

	public static Queue getQueue(JdmoRowset rs) throws JdmoException {
<span class="fc" id="L1074">		final Queue queue = new Queue();</span>
<span class="fc" id="L1075">		queue.setID(new ID(rs.getInt(&quot;QUEUEID&quot;)));</span>
<span class="fc" id="L1076">		queue.setName(rs.getString(&quot;NAME&quot;));</span>
<span class="fc" id="L1077">		queue.setDescription(rs.getString(&quot;DESCRIPTION&quot;));</span>
<span class="fc" id="L1078">		queue.setMediaID(new ID(rs.getInt(&quot;MEDIAID&quot;)));</span>
<span class="fc" id="L1079">		queue.setMediaName(rs.getString(&quot;MEDIANAME&quot;));</span>
<span class="fc" id="L1080">		queue.setMediaStrID(rs.getString(&quot;MEDIASTRID&quot;));</span>
<span class="fc" id="L1081">		queue.setQueueType(rs.getInt(&quot;QUEUETYPE&quot;));</span>
<span class="fc" id="L1082">		queue.setParentQueueID(rs.getString(&quot;PARENTQUEUEID&quot;));</span>
<span class="fc" id="L1083">		queue.setParentID(rs.getID(&quot;PARENTSID&quot;));</span>
<span class="fc" id="L1084">		queue.setOrganizationID(rs.getID(&quot;ORGANIZATIONID&quot;));</span>
<span class="fc" id="L1085">		queue.setOrganizationName(rs.getString(&quot;ORGANIZATIONNAME&quot;));</span>
<span class="fc" id="L1086">		return queue;</span>
	}

	/**
	 * This method is used by Strategic Planner application
	 *
	 * @param rs - result set contains information from QUEUE, ORGANIZATION and TIMEZONE tables
	 * @return Queue Note: Not all the Queue information are set
	 * @throws JdmoException
	 */
	public static Queue getQueueInfoForPlanner(JdmoRowset rs) throws JdmoException {
<span class="nc" id="L1097">		final Queue queue = new Queue();</span>
<span class="nc" id="L1098">		queue.setID(new ID(rs.getInt(&quot;QUEUEID&quot;)));</span>
<span class="nc" id="L1099">		queue.setDEID(new ID(rs.getString(&quot;ID&quot;)));</span>
<span class="nc" id="L1100">		queue.setName(rs.getString(&quot;NAME&quot;));</span>
<span class="nc" id="L1101">		queue.setMediaStrID(rs.getString(&quot;MEDIAID&quot;));</span>
<span class="nc" id="L1102">		queue.setOrganizationID(rs.getID(&quot;ORGANIZATIONID&quot;));</span>
<span class="nc" id="L1103">		return queue;</span>
	}

	/**

	/**
	 * Get the queues corresponding to the SIDs in {@code queueIDs}, or all
	 * queues if {@code queueIDs} is {@code null}.
	 */
	public Collection&lt;Queue&gt; getObjects(Collection&lt;ID&gt; queueIDs) throws BbmFinderException {
		try {
<span class="pc bpc" id="L1114" title="1 of 2 branches missed.">			if (queueIDs == null) {</span>
<span class="nc" id="L1115">				return getAllQueues();</span>
			}
<span class="fc" id="L1117">			return getQueuesByIDs(queueIDs);</span>
<span class="nc" id="L1118">		} catch (final JdmoException e) {</span>
<span class="nc" id="L1119">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * This function returns List of Parent and Child Organization Id's for the
	 * given Organization ID
	 * 
	 * @param orgId
	 * @return List of ID
	 * @throws JdmoException
	 */
	public static List&lt;ID&gt; getOrganizationHierarchy(ID orgId, boolean down) throws JdmoException {
<span class="fc" id="L1132">		final Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L1134">			final StringBuilder pStmt = new StringBuilder(getOrganizationHierarchyQuery(down));</span>
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">			if (down) {</span>
<span class="fc" id="L1136">				pStmt.append(&quot;-- Doing a Union for both the Up and Down heirarchy result \n&quot;).append(</span>
						&quot; SELECT * FROM ORGANIZATIONHIERARCHICYDOWN  union &quot;);
			}
<span class="fc" id="L1139">			pStmt.append(&quot;select * from ORGANIZATIONHIERARCHICYUP&quot;);</span>
<span class="fc" id="L1140">			final ArrayList&lt;ID&gt; orgIds = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L1141">			final JdmoQuery jq = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L1142">			jq.setParID(1, orgId);</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">			if (down) {</span>
<span class="fc" id="L1144">				jq.setParID(2, orgId);</span>
			}
<span class="fc" id="L1146">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc bfc" id="L1147" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L1148">				orgIds.add(rs.getID(1));</span>
			}
<span class="fc" id="L1150">			return orgIds;</span>
		} finally {
<span class="pc" id="L1152">			jdmo.cleanUp();</span>
		}
	}

	public static String getSqlQueryToGetQueuesWithHistoricalDataInThePeriod(Date startDate, Date endDate) {
<span class="nc" id="L1157">		StringBuffer stringBuffer = new StringBuffer();</span>
<span class="nc" id="L1158">		stringBuffer.append(&quot;SELECT DISTINCT QUEUE.SID AS QUEUEID, QUEUE.NAME, QUEUE.ID,QUEUE.ORGANIZATIONID, QUEUE.MEDIAID, TIMEZONEMAP.JAVATZIDENT TZ \n&quot;);</span>
<span class="nc" id="L1159">		stringBuffer.append(&quot;FROM QUEUEHISTORYTIMESERIES, QUEUE, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP, SPQUEUE \n&quot;);</span>
<span class="nc" id="L1160">		stringBuffer.append(&quot;WHERE QUEUEHISTORYTIMESERIES.QUEUEID=QUEUE.ID AND \n&quot;);</span>
<span class="nc" id="L1161">		stringBuffer.append(&quot;(SPQUEUE.QUEUEID = QUEUE.ID OR SPQUEUE.QUEUEID = QUEUE.PARENTQUEUEID) AND \n&quot;);</span>
<span class="nc" id="L1162">		stringBuffer.append(&quot; SP.ID = SPQUEUE.SPID AND \n&quot;);</span>
<span class="nc" id="L1163">		stringBuffer.append(&quot; CAMPAIGN.ID = SP.CAMPAIGNID AND \n&quot;);</span>
<span class="nc" id="L1164">		stringBuffer.append(&quot; CAMPAIGN.TIMEZONEID = TIMEZONE.ID AND \n&quot;);</span>
<span class="nc" id="L1165">		stringBuffer.append(&quot; TIMEZONE.STANDARDNAME = TIMEZONEMAP.WINTZSTDNAME AND \n&quot;);</span>
<span class="nc" id="L1166">		stringBuffer.append(&quot; QUEUE.QUEUETYPE = 0 AND \n&quot;);</span>
<span class="nc" id="L1167">		stringBuffer.append(&quot; QUEUEHISTORYTIMESERIES.TIME &gt;=&quot;);</span>
<span class="nc" id="L1168">		JdmoUtil.asSqlLiteral(startDate, stringBuffer);</span>
<span class="nc" id="L1169">		stringBuffer.append(&quot;AND QUEUEHISTORYTIMESERIES.TIME &lt;&quot;);</span>
<span class="nc" id="L1170">		JdmoUtil.asSqlLiteral(endDate, stringBuffer);</span>
<span class="nc" id="L1171">		return stringBuffer.toString();</span>
	}

	public static StringBuilder getSqlQueryToGetQueuesForImport() {
<span class="nc" id="L1175">		StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L1176">		pStmt.append(&quot;SELECT QUEUE.SID AS QUEUEID, QUEUE.NAME, QUEUE.ID,QUEUE.ORGANIZATIONID, QUEUE.MEDIAID, TIMEZONEMAP.JAVATZIDENT TZ \n&quot;);</span>
<span class="nc" id="L1177">		pStmt.append(&quot;FROM QUEUE, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP, SPQUEUE  \n&quot;);</span>
<span class="nc" id="L1178">		pStmt.append(&quot;WHERE QUEUE.ID in (SELECT DISTINCT QUEUEID from QUEUEHISTORYTIMESERIES) AND \n&quot;);</span>
<span class="nc" id="L1179">		pStmt.append(&quot;(SPQUEUE.QUEUEID = QUEUE.ID OR SPQUEUE.QUEUEID = QUEUE.PARENTQUEUEID) AND  \n&quot;);</span>
<span class="nc" id="L1180">		pStmt.append(&quot; SP.ID = SPQUEUE.SPID AND  \n&quot;);</span>
<span class="nc" id="L1181">		pStmt.append(&quot;CAMPAIGN.ID = SP.CAMPAIGNID AND \n&quot;);</span>
<span class="nc" id="L1182">		pStmt.append(&quot;CAMPAIGN.TIMEZONEID = TIMEZONE.ID AND  \n&quot;);</span>
<span class="nc" id="L1183">		pStmt.append(&quot;TIMEZONEMAP.WINTZSTDNAME = TIMEZONE.STANDARDNAME AND  \n&quot;);</span>
<span class="nc" id="L1184">		pStmt.append(&quot;QUEUE.QUEUETYPE = 0 \n&quot;);</span>
<span class="nc" id="L1185">		pStmt.append(&quot;GROUP BY QUEUE.SID, QUEUE.NAME,QUEUE.ID,QUEUE.MEDIAID,TIMEZONEMAP.JAVATZIDENT,QUEUE.ORGANIZATIONID ORDER BY QUEUE.NAME&quot;);</span>
<span class="nc" id="L1186">		return pStmt;</span>
	}

	public static StringBuilder getSqlQueryToGetQueuesForLongtermForecast() {
<span class="nc" id="L1190">		StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L1191">		pStmt.append(&quot;SELECT QUEUE.SID AS QUEUEID, QUEUE.NAME, QUEUE.ID,QUEUE.ORGANIZATIONID, QUEUE.MEDIAID, TIMEZONEMAP.JAVATZIDENT as TZ \n&quot;);</span>
<span class="nc" id="L1192">		pStmt.append(&quot;FROM QUEUEHISTORYTIMESERIES, QUEUE, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP, SPQUEUE  \n&quot;);</span>
<span class="nc" id="L1193">		pStmt.append(&quot;WHERE QUEUEHISTORYTIMESERIES.QUEUEID=QUEUE.ID AND \n&quot;);</span>
<span class="nc" id="L1194">		pStmt.append(&quot;(SPQUEUE.QUEUEID = QUEUE.ID OR SPQUEUE.QUEUEID = QUEUE.PARENTQUEUEID) AND  \n&quot;);</span>
<span class="nc" id="L1195">		pStmt.append(&quot;SP.ID = SPQUEUE.SPID AND  \n&quot;);</span>
<span class="nc" id="L1196">		pStmt.append(&quot;CAMPAIGN.ID = SP.CAMPAIGNID AND \n&quot;);</span>
<span class="nc" id="L1197">		pStmt.append(&quot;CAMPAIGN.TIMEZONEID = TIMEZONE.ID AND  \n&quot;);</span>
<span class="nc" id="L1198">		pStmt.append(&quot;TIMEZONEMAP.WINTZSTDNAME = TIMEZONE.STANDARDNAME AND  \n&quot;);</span>
<span class="nc" id="L1199">		pStmt.append(&quot;(QUEUE.QUEUETYPE = 0 OR QUEUE.QUEUETYPE = 2)\n&quot;);</span>
<span class="nc" id="L1200">		pStmt.append(&quot;GROUP BY QUEUE.SID, QUEUE.NAME,QUEUE.ID,QUEUE.MEDIAID,TIMEZONEMAP.JAVATZIDENT,QUEUE.ORGANIZATIONID ORDER BY QUEUE.NAME&quot;);</span>
<span class="nc" id="L1201">		return pStmt;</span>
	}

	public static StringBuilder getSqlQueryToGetQueueForExport() {
<span class="nc" id="L1205">		return new StringBuilder(&quot;SELECT QUEUE.SID AS QUEUEID, QUEUE.NAME, QUEUE.ID, QUEUE.ORGANIZATIONID, QUEUE.MEDIAID, TIMEZONEMAP.JAVATZIDENT as TZ  \n&quot; +</span>
				&quot;FROM QUEUE, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP, SPQUEUE \n&quot; +
				&quot;WHERE SP.ID = SPQUEUE.SPID AND  \n&quot; +
				&quot;CAMPAIGN.ID = SP.CAMPAIGNID AND  \n&quot; +
				&quot;CAMPAIGN.TIMEZONEID = TIMEZONE.ID AND \n&quot; +
				&quot;TIMEZONEMAP.WINTZSTDNAME = Timezone.STANDARDNAME \n&quot; +
				&quot;GROUP BY  QUEUE.SID, QUEUE.NAME,QUEUE.ID,QUEUE.MEDIAID, TIMEZONEMAP.JAVATZIDENT, QUEUE.ORGANIZATIONID ORDER BY QUEUE.NAME\n&quot;);

	}

	@Override
	protected ValueObjectBase createValueObject() {
<span class="nc" id="L1217">		return (new Queue());</span>
	}

	/**
	 *  compose a complete sql query statement for finder methods
	 *  @param  strWhere the where condition need to append to the query
	 */
	@Override
	protected StringBuffer getQuerySQL(StringBuffer strWhere)
	{
<span class="nc" id="L1227">		StringBuilder strSQL = new StringBuilder(&quot;select a.id,a.SID , a.NAME, a.DESCRIPTION, A.PARENTQUEUEID,&quot;);</span>
<span class="nc" id="L1228">				strSQL.append(&quot; (SELECT SID FROM QUEUE Q WHERE A.PARENTQUEUEID = Q.ID) as PARENTSID , &quot;);</span>
<span class="nc" id="L1229">				strSQL.append(&quot; A.QUEUETYPE, A.ORGANIZATIONID, c.NAME as ORGANIZATIONNAME, b.SID as MEDIAID, b.NAME as MEDIANAME,b.mediaimmediate as MEDIATYPE, &quot; );</span>
<span class="nc" id="L1230">				strSQL.append(&quot; B.ID as STRID from QUEUE a, MEDIA b, ORGANIZATION c &quot; );</span>
<span class="nc" id="L1231">				strSQL.append(&quot; WHERE a.ORGANIZATIONID = c.ID AND a.MEDIAID = b.ID  &quot; );</span>

		//As the where is already added above
<span class="nc" id="L1234">		boolean bHasWhere = true;</span>

<span class="nc bnc" id="L1236" title="All 4 branches missed.">		if (strWhere != null &amp;&amp; strWhere.length() &gt; 0)</span>
<span class="nc bnc" id="L1237" title="All 2 branches missed.">			strSQL.append(bHasWhere ? &quot; AND &quot; : &quot; WHERE &quot;).append(strWhere);</span>

<span class="nc" id="L1239">		return new StringBuffer(strSQL.toString());</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>