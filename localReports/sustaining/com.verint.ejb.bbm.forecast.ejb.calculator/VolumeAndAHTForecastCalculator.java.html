<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>VolumeAndAHTForecastCalculator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.ejb.calculator</a> &gt; <span class="el_source">VolumeAndAHTForecastCalculator.java</span></div><h1>VolumeAndAHTForecastCalculator.java</h1><pre class="source lang-java linenums">/*
 * (c) 2011 Verint Systems, Inc.
 */
package com.verint.ejb.bbm.forecast.ejb.calculator;

import com.bluepumpkin.common.datatypes.Duration;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.time.TimeInterval;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.time.TimeUnits;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.ForecastAlgorithm;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.verint.ejb.bbm.forecast.model.Profile;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntry;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntryHistoryPeriod;

import java.util.*;


/**
 * Returns a tracecube of forecast data calculated for the given forecast profile / queue model.
 * The returned trace cube will span the length of the profile (defined by Profile.getInterval()).
 */
<span class="nc" id="L34">public class VolumeAndAHTForecastCalculator implements IForecastCalculator {</span>

	public TraceCube calculate(Profile p, SchedulingPeriod sp, boolean modelHasForecastData, TraceCube forecastData,
			TraceCube strategicForecast, Map&lt;ID, Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt;&gt; historyData,
			boolean useSFWeight, boolean useUnknownVolumeInForecast, boolean useWeightedSmoothing) {

<span class="nc" id="L40">		TimeIntervalAtTime spWeek = p.getInterval();</span>
<span class="nc" id="L41">		TimeContext timeContext = spWeek.getDuration().getTimeContext();</span>
<span class="nc" id="L42">		ID queueID = p.getQueue().getID();</span>
<span class="nc" id="L43">		int numDataPointsInSPWeek = p.getInterval().getDuration().getIntervalSubdivisions(p.getInterval().getStartTime(),</span>
<span class="nc" id="L44">				new TimeInterval(TimeUnits.Minute, 15, p.getInterval().getDuration().getTimeContext())).size();</span>
<span class="nc" id="L45">		double[] ahtForecast = new double[numDataPointsInSPWeek];</span>
<span class="nc" id="L46">		Arrays.fill(ahtForecast, 0);</span>
<span class="nc" id="L47">		double[] volumeForecast = new double[numDataPointsInSPWeek];</span>
<span class="nc" id="L48">		Arrays.fill(volumeForecast, 0);</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">		if (p.isModified() &amp;&amp; modelHasForecastData)  {</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">			if (forecastData != null) {</span>
<span class="nc" id="L51">				ahtForecast = forecastData.getTraceValueD(Trace.AHT);</span>
<span class="nc" id="L52">				volumeForecast = forecastData.getTraceValueD(Trace.CV);</span>
			}
		} else {
<span class="nc bnc" id="L55" title="All 2 branches missed.">			if (p.getProfileEntries().size() &gt; 0) {</span>
				// Run forecast algorithm
				// Create objects needed for forecast algorithm
<span class="nc" id="L58">				Collection&lt;ForecastAlgorithm.ProfileEntry&gt; volumeEntries = new HashSet&lt;ForecastAlgorithm.ProfileEntry&gt;();</span>
<span class="nc" id="L59">				Collection&lt;ForecastAlgorithm.ProfileEntry&gt; ahtEntries = new HashSet&lt;ForecastAlgorithm.ProfileEntry&gt;();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">				for (ProfileEntry pe : p.getProfileEntries()) {</span>
<span class="nc" id="L61">					TraceCube historyWeekTraceData = historyData.get(p.getQueue().getID()).get(pe.getHistoryPeriod());</span>

<span class="nc" id="L63">					double[] volumeData = getDstAdjustedHistoryTraceData(historyWeekTraceData, pe, spWeek, timeContext,</span>
							numDataPointsInSPWeek, Trace.CV);
<span class="nc" id="L65">					volumeEntries.add(new ForecastAlgorithm.ProfileEntry(volumeData, pe.getWeight()));</span>

<span class="nc" id="L67">					double[] ahtData = getDstAdjustedHistoryTraceData(historyWeekTraceData, pe, spWeek, timeContext,</span>
							numDataPointsInSPWeek, Trace.AHT);
<span class="nc" id="L69">					double[] volumeHandledData = null;</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">					if (calculateDefaultAHTForProfile(p)) {</span>
<span class="nc" id="L71">						volumeHandledData = getDstAdjustedHistoryTraceData(historyWeekTraceData, pe, spWeek, timeContext,</span>
								numDataPointsInSPWeek, Trace.VH);
					}

<span class="nc" id="L75">					ahtEntries.add(new ForecastAlgorithm.ProfileEntry(ahtData, volumeData, volumeHandledData, pe.getWeight()));</span>
<span class="nc" id="L76">				}</span>
				// Get forecasted values
<span class="nc" id="L78">				double[] tacticalAhtForecast = ForecastAlgorithm.getPointWeightedAverageForecastWithSmoothing(ahtEntries,</span>
<span class="nc" id="L79">						calculateDefaultAHTForProfile(p), useWeightedSmoothing);</span>
<span class="nc" id="L80">				double[] tacticalVolumeForecast = ForecastAlgorithm.getSeriesWeightedAverageForecastWithCarryover(</span>
						volumeEntries, useUnknownVolumeInForecast);
<span class="nc bnc" id="L82" title="All 4 branches missed.">				if (!useSFWeight || strategicForecast == null) {</span>
<span class="nc" id="L83">					ahtForecast = tacticalAhtForecast;</span>
<span class="nc" id="L84">					volumeForecast = tacticalVolumeForecast;</span>
				} else {
<span class="nc" id="L86">					int numrows = Math.round(((float)spWeek.getEndTime().getTime() -</span>
<span class="nc" id="L87">							spWeek.getStartTime().getTime()) / (24*60*60*1000));//MILLIS_PER_DAY</span>

<span class="nc" id="L89">					TraceCube tc = forecastData;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">					if (tc == null) {</span>
						try {
<span class="nc" id="L92">							tc = new ForecastTraceCube(queueID, sp.getStartTime(), sp.getEndTime(),</span>
									new short[] {Trace.CV, Trace.AHT});
<span class="nc" id="L94">						} catch (BbmTimeSeriesException e) {</span>
<span class="nc" id="L95">							throw new RuntimeException(e);</span>
<span class="nc" id="L96">						}</span>
					}
<span class="nc" id="L98">					tc.setTraceValue(Trace.CV, tacticalVolumeForecast, spWeek.getStartTime());</span>
<span class="nc" id="L99">					tc.setTraceValue(Trace.AHT, tacticalAhtForecast, spWeek.getStartTime());</span>


					//TODO: populate cv_vh with cv: but, why??? Aren't ForecastedTraceCube always supposed to use CV?????
<span class="nc" id="L103">					strategicForecast.setTraceValue(Trace.CV_VH, strategicForecast.getTraceValueD(Trace.CV),spWeek.getStartTime());</span>
<span class="nc" id="L104">					tc.setTraceValue(Trace.CV_VH, tacticalVolumeForecast, spWeek.getStartTime());</span>

<span class="nc" id="L106">					double[] cvScalePerDay = new double[numrows];</span>
<span class="nc" id="L107">					double[] ahtScalePerDay = new double[numrows];</span>
<span class="nc" id="L108">					int n = 0;</span>
<span class="nc" id="L109">					Date currentTime = spWeek.getStartTime();</span>

<span class="nc bnc" id="L111" title="All 2 branches missed.">					while(currentTime.before(spWeek.getEndTime())) // || currentTime.equals(spWeek.getEndTime()))</span>
					{
						// getNextTime : use TimeInterval/TimeUnits = 1 day (remove the local method)
<span class="nc" id="L114">						Date nextTime = getNextTime(currentTime,1);</span>
<span class="nc bnc" id="L115" title="All 4 branches missed.">						if (nextTime.before(spWeek.getEndTime()) &amp;&amp; TimeZoneUtil.numberOfMinutes(nextTime, spWeek.getEndTime()) &lt; 2*60) {</span>
							//dst transition day
<span class="nc" id="L117">							nextTime = spWeek.getEndTime();</span>
						}
<span class="nc" id="L119">						int startIndex = TraceUtil.gapOffSet(tc.getStartDate(), tc.getStartOffSet(), currentTime);</span>
<span class="nc" id="L120">						int endIndex = TraceUtil.gapOffSet(tc.getStartDate(), tc.getStartOffSet(), nextTime) - 1;</span>

<span class="nc" id="L122">						int startIndexSF = TraceUtil.gapOffSet(strategicForecast.getStartDate(), strategicForecast.getStartOffSet(), currentTime);</span>
<span class="nc" id="L123">						int endIndexSF = TraceUtil.gapOffSet(strategicForecast.getStartDate(), strategicForecast.getStartOffSet(), nextTime) - 1;</span>

<span class="nc" id="L125">						int tacticalCV = TraceUtil.roundDouble(TraceOperator.aggregatePeriod(tc, Trace.CV, startIndex, endIndex));</span>
<span class="nc" id="L126">						int strategicCV = TraceUtil.roundDouble(TraceOperator.aggregatePeriod(strategicForecast, Trace.CV, startIndexSF, endIndexSF));</span>

<span class="nc" id="L128">						int tacticalAHT = TraceUtil.roundDouble(TraceOperator.aggregatePeriod(tc, Trace.AHT, startIndex, endIndex));</span>
<span class="nc" id="L129">						int strategicAHT = TraceUtil.roundDouble(TraceOperator.aggregatePeriod(strategicForecast, Trace.AHT, startIndexSF, endIndexSF));</span>

<span class="nc" id="L131">						double forecastCV = tacticalCV;</span>
<span class="nc" id="L132">						double forecastAHT = tacticalAHT;</span>

<span class="nc bnc" id="L134" title="All 6 branches missed.">						if (tacticalCV &gt; 0 &amp;&amp; strategicCV &gt;= 0 &amp;&amp; p.getStrategicVolumeWeight() != 0) {</span>
<span class="nc" id="L135">							forecastCV = tacticalCV + ((strategicCV - tacticalCV) * (double) p.getStrategicVolumeWeight() / 100.0);</span>
						}

<span class="nc bnc" id="L138" title="All 6 branches missed.">						if (tacticalAHT &gt; 0 &amp;&amp; strategicAHT &gt;= 0 &amp;&amp; p.getStrategicAverageHandlingTimeWeight() != 0) {</span>
<span class="nc" id="L139">							forecastAHT = tacticalAHT + ((strategicAHT - tacticalAHT) * (double) p.getStrategicAverageHandlingTimeWeight() / 100.0);</span>
						}

<span class="nc bnc" id="L142" title="All 2 branches missed.">						if (tacticalCV &gt; 0) {</span>
<span class="nc" id="L143">							cvScalePerDay[n] = forecastCV / tacticalCV;</span>
						}
<span class="nc bnc" id="L145" title="All 2 branches missed.">						if (tacticalAHT &gt; 0) {</span>
<span class="nc" id="L146">							ahtScalePerDay[n] = forecastAHT / tacticalAHT;</span>
						}
<span class="nc" id="L148">						n++;</span>
<span class="nc" id="L149">						currentTime = nextTime;</span>
<span class="nc" id="L150">					}</span>

<span class="nc" id="L152">					Calendar startCal = Calendar.getInstance(spWeek.getDuration().getTimeContext().getTimeZone());</span>
<span class="nc" id="L153">					startCal.setTime(spWeek.getStartTime());</span>
<span class="nc" id="L154">					volumeForecast = ForecastAlgorithm.getTacticalForecastWithStrategicWeight(tacticalVolumeForecast, cvScalePerDay, startCal);</span>
<span class="nc" id="L155">					ahtForecast = ForecastAlgorithm.getTacticalForecastWithStrategicWeight(tacticalAhtForecast,ahtScalePerDay, startCal);</span>
				}
			}
		}
		//Update the forecast trace cube in the model with the calculated forecast.  Create a new forecast trace cube for the
		//SP if one does not yet exist in the model.
<span class="nc" id="L161">		TraceCube ftc = forecastData;</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (ftc == null) {</span>
			try {
<span class="nc" id="L164">				ftc = new ForecastTraceCube(queueID, spWeek.getStartTime(), new Date(spWeek.getEndTime().getTime() -1),</span>
						new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});
<span class="nc" id="L166">			} catch (BbmTimeSeriesException e) {</span>
<span class="nc" id="L167">				throw new RuntimeException(e);</span>
<span class="nc" id="L168">			}</span>
		}
<span class="nc" id="L170">		ftc.setTraceValue(Trace.CV, volumeForecast, spWeek.getStartTime());</span>
<span class="nc" id="L171">		ftc.setTraceValue(Trace.AHT, ahtForecast, spWeek.getStartTime());</span>
<span class="nc" id="L172">		return ftc;</span>
	}

	private Date getNextTime(Date curDate, int numDays) {
<span class="nc" id="L176">		GregorianCalendar cal = new GregorianCalendar();</span>
<span class="nc" id="L177">		cal.setTime(curDate);</span>
<span class="nc" id="L178">		cal.add(Calendar.DATE, numDays);</span>
<span class="nc" id="L179">		return cal.getTime();</span>
	}

	/**
	 * Returns true if we need to calculate a Default AHT value for the zero-values
	 * in the AHT history data.  As of this writing, this applies to deferred media queues.
	 */
	private boolean calculateDefaultAHTForProfile(Profile profile) {
<span class="nc" id="L187">		return Media.isMediaDeferred(profile.getQueue().getMediaID());</span>
	}

	private double[] getDstAdjustedHistoryTraceData(TraceCube historyWeekTraceData, ProfileEntry pe,
			TimeIntervalAtTime spWeek, TimeContext timeContext, int numDataPointsInSPWeek, short traceType) {
<span class="nc" id="L192">		double[] historyData = historyWeekTraceData.getTraceValueD(traceType,</span>
<span class="nc" id="L193">				pe.getHistoryPeriod().getTimeIntervalRepresentingPeriod().getStartTime(),</span>
<span class="nc" id="L194">				new Date(pe.getHistoryPeriod().getTimeIntervalRepresentingPeriod().getEndTime().getTime() - 1));</span>
<span class="nc bnc" id="L195" title="All 2 branches missed.">		if (historyData.length != numDataPointsInSPWeek) {</span>
			//If the length of the history data does not equal the length of the SP week (in other words the two do not have the
			//same number of 15 minute intervals) then this means there is a DST transition in one but not the other.  We then need
			//to change the size of the history data (either by adding 15 minute intervals or subtracting 15 minute intervals representing the
			//extra or subtracted hour from the DST interval) so that it matches the size of the sp week.
<span class="nc" id="L200">			historyData = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(historyData, Trace.TRACENA,</span>
<span class="nc" id="L201">					pe.getHistoryPeriod().getTimeIntervalRepresentingPeriod().getStartTime(),</span>
<span class="nc" id="L202">					Duration.fromMinutes(Trace.INTERVAL), timeContext);</span>
<span class="nc" id="L203">			historyData = DSTConversionUtil.convertFromIdealTimeToDSTAwareTime(historyData, Trace.TRACENA,</span>
<span class="nc" id="L204">					spWeek.getStartTime(), Duration.fromMinutes(Trace.INTERVAL), timeContext);</span>
		}

<span class="nc" id="L207">		return historyData;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>