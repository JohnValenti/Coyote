<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RecurringEventTemplateBase.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">RecurringEventTemplateBase.java</span></div><h1>RecurringEventTemplateBase.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Base functionality shared among the non-floating recurring
 *               event template and recurring floating event template value
 *               object classes
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;

<span class="nc" id="L31">public abstract class RecurringEventTemplateBase extends ValueObjectAggEventTemplate {</span>
	/** meta data info. */
<span class="nc" id="L33">	private static FieldInfo m_fields = new RecurringEventTemplateFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="nc" id="L36">		return m_fields;</span>
	}

	/** cache the value of the day map for faster lookups */
<span class="nc" id="L40">	private Set&lt;Integer&gt; m_setDayMap = null;</span>

	/** cache the recurring event exception map for faster lookups */
<span class="nc" id="L43">	private Map&lt;ID, List&lt;Date&gt;&gt; m_mapExceptions = null;</span>

	/**
	 * Returns the type of the calendar event template object. This could be one
	 * of the int values defined as constants above: simple, floating or
	 * recurring or recurring floating
	 */
	public abstract short getTemplateType();

	/**
	 * Returns the recurrence type of the event (one of the values defined in
	 * the enumeration above)
	 */
	public short getRecurrenceType() {
<span class="nc" id="L57">		return getFieldValueShort(RecurringEventTemplateFields.RECURRENCETYPE);</span>
	}

	/**
	 * Sets the recurrence type of the event.
	 */
	public void setRecurrenceType(short val) {
<span class="nc" id="L64">		setFieldValue(RecurringEventTemplateFields.RECURRENCETYPE, val);</span>
<span class="nc" id="L65">	}</span>

	/**
	 * Returns the recurrence periodicity interval for this event. For example,
	 * if recurrentce type is RECURRENCE_TYPE_WEEKLY, and the value of
	 * periodicity interval is 2, that means the event occurs every 2 weeks.
	 */
	public int getPeriodicityInterval() {
<span class="nc" id="L73">		return getFieldValueInt(RecurringEventTemplateFields.PERIODICITYINTERVAL);</span>
	}

	/**
	 * Sets the priodicity interval the event.
	 */
	public void setPeriodicityInterval(int val) {
<span class="nc" id="L80">		setFieldValue(RecurringEventTemplateFields.PERIODICITYINTERVAL, val);</span>
<span class="nc" id="L81">	}</span>

	/**
	 * Returns the earliest date for which this recurring event will occur. The
	 * date will be interpreted as a moment in time (in GMT) that corresponds to
	 * the beginning of the day in the timezone of recurrence
	 */
	public Date getRecurringStartDate() {
<span class="nc" id="L89">		return getFieldValueDate(RecurringEventTemplateFields.STARTDATE);</span>
	}

	/**
	 * Sets the earliest date for which this recurring event will occur The date
	 * will be interpreted as a moment in time (in GMT) that corresponds to the
	 * beginning of the day in the timezone of recurrence
	 */
	public void setRecurringStartDate(Date dateStart) {
<span class="nc" id="L98">		setFieldValue(RecurringEventTemplateFields.STARTDATE, dateStart);</span>
<span class="nc" id="L99">	}</span>

	/**
	 * Returns the latest date for which this recurring event will occur. The
	 * date will be interpreted as a moment in time (in GMT) that corresponds to
	 * the beginning of the day in the timezone of recurrence If the recurring
	 * event is open-ended, this method will return null.
	 */
	public Date getRecurringEndDate() {
<span class="nc" id="L108">		return getFieldValueDate(RecurringEventTemplateFields.ENDDATE);</span>
	}

	/**
	 * Sets the latest date for which this recurring event will occur. The date
	 * will be interpreted as a moment in time (in GMT) that corresponds to the
	 * beginning of the day in the timezone of recurrence
	 */
	public void setRecurringEndDate(Date dateEnd) {
<span class="nc" id="L117">		setFieldValue(RecurringEventTemplateFields.ENDDATE, dateEnd);</span>
<span class="nc" id="L118">	}</span>

	/**
	 * Returns the data structure that represents which days in the week the
	 * event can start. The data structure is an set that contains all possible
	 * days of the week when this event can start. The days of the week are
	 * enumerated using the values from the java.util.Calendar class, i.e.
	 * Calendar.SUNDAY = 1, Calendar.MONDAY = 2 and so on.
	 */
	public Set&lt;Integer&gt; getDayMap() {
<span class="nc bnc" id="L128" title="All 2 branches missed.">		if (m_setDayMap == null) {</span>
<span class="nc" id="L129">			String strDayMap = getFormattedFieldValue(RecurringEventTemplateFields.WEEKDAYMASK);</span>
			/* cache the value for faster lookups */
<span class="nc" id="L131">			m_setDayMap = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			for (int i = 0; i &lt; 7; i++) {</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">				if (strDayMap.charAt(i) != '0') {</span>
<span class="nc" id="L134">					m_setDayMap.add(NumberFactory.newInteger(i + 1));</span>
				}
			}
		}
<span class="nc" id="L138">		return m_setDayMap;</span>
	}

	/**
	 * Sets the data structure that represents which days in the week the event
	 * can start. See explanation above for the data structure.
	 */
	public void setDayMap(Set&lt;Integer&gt; setDayMap) {
<span class="nc" id="L146">		StringBuffer buf = new StringBuffer(&quot;0000000&quot;);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		for (Iterator&lt;Integer&gt; it = setDayMap.iterator(); it.hasNext();) {</span>
<span class="nc" id="L148">			Integer n = it.next();</span>
<span class="nc" id="L149">			buf.setCharAt(n.intValue() - 1, '1');</span>
<span class="nc" id="L150">		}</span>
<span class="nc" id="L151">		setFieldValue(RecurringEventTemplateFields.WEEKDAYMASK, buf.toString());</span>
		/* invalidate cache so it will be recomputed next time */
<span class="nc" id="L153">		m_setDayMap = null;</span>
<span class="nc" id="L154">	}</span>

	/**
	 * This is a helper function that determines whether the recurring event
	 * template day map contains a given day of the week
	 */
	public boolean canOccurOnWeekday(int dayOfWeek) {
<span class="nc" id="L161">		return getDayMap().contains(NumberFactory.newInteger(dayOfWeek));</span>
	}

	/**
	 * Sets the timezone for this recurring event template
	 */
	public void setTimeZone(TimeZone tz) {
<span class="nc" id="L168">		setFieldValue(RecurringEventTemplateFields.TIMEZONE, tz);</span>
<span class="nc" id="L169">	}</span>

	/**
	 * Returns the timezone for this recurring event template
	 */
	public TimeZone getTimeZone() {
<span class="nc" id="L175">		return getFieldValueTimeZone(RecurringEventTemplateFields.TIMEZONE);</span>
	}

	/**
	 * Returns the earliest date for which this recurring event will occur. The
	 * returned date will be adjusted to start at the very beginning of the date
	 */
	protected Date getAdjustedRecurringStartDate() {
<span class="nc" id="L183">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L184">		cal.setLenient(true);</span>

		/*
		 * set the recurring start date to the very beginning of the day since I
		 * will be using that for date comparisons later
		 */
<span class="nc" id="L190">		cal.setTime(getRecurringStartDate());</span>
<span class="nc" id="L191">		TimeZoneUtil.getMinOfCalendar(cal);</span>
<span class="nc" id="L192">		return cal.getTime();</span>
	}

	/**
	 * Returns the latest date for which this recurring event will occur. The
	 * returned date will be adjusted as follows:
	 *
	 */
	protected Date getAdjustedRecurringEndDate() {
<span class="nc" id="L201">		Date recurringEndDate = getRecurringEndDate();</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">		if (recurringEndDate != null) {</span>
<span class="nc" id="L203">			Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L204">			cal.setLenient(true);</span>

			/*
			 * if the recurring end date is set, it is probably set to something
			 * like Sat 6/22/2002 00:00:00, which in actuality means that if the
			 * template states that the recurring event is to occur on Sat at
			 * 3pm, there SHOULD be an instance of this event that starts on Sat
			 * 6/22/2002 15:00:00.
			 *
			 * So, I will adjust the recurring end date to just before midnight
			 * on that date, since I will use that value later for date
			 * comparisons
			 */
<span class="nc" id="L217">			cal.setTime(recurringEndDate);</span>
<span class="nc" id="L218">			TimeZoneUtil.getMaxOfCalendar(cal);</span>
<span class="nc" id="L219">			recurringEndDate = cal.getTime();</span>
		}
<span class="nc" id="L221">		return recurringEndDate;</span>
	}

	/**
	 * Returns the collection of event instances that overlap with the given
	 * event
	 */
	public Collection&lt;CalendarEventAssignment&gt; whichInstancesOverlapWithEvent(Event event) {
<span class="nc" id="L229">		return getRecurringEvents(event.getStartTime(), event.getEndTime(), event.getWorkResourceIDs());</span>
	}

	/**
	 * Returns the recurring event instances for the given set of workresources
	 * on a given day
	 */
	public Collection&lt;CalendarEventAssignment&gt; getRecurringEventsOnDay(Collection&lt;ID&gt; workResourceIDs, Date dtDay) {
<span class="nc" id="L237">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L238">		cal.setTime(dtDay);</span>
<span class="nc" id="L239">		Date dtStart = TimeZoneUtil.getMinOfCalendar(cal).getTime();</span>
<span class="nc" id="L240">		Date dtEnd = TimeZoneUtil.getMaxOfCalendar(cal).getTime();</span>
<span class="nc" id="L241">		return getRecurringEvents(dtStart, dtEnd, workResourceIDs);</span>
	}

	/**
	 * Returns the collection of event instances that overlap with some event
	 * instances of the given recrring event template
	 */
	public boolean anyInstancesOverlapWithTemplate(RecurringEventTemplateBase recTemplate) {
		/* first see if the two templates even overlap */
<span class="nc" id="L250">		Date earliestTime1 = this.getEarliestPossibleStartTime();</span>
<span class="nc" id="L251">		Date earliestTime2 = recTemplate.getEarliestPossibleStartTime();</span>
<span class="nc" id="L252">		Date latestTime1 = this.getLatestPossibleEndTime();</span>
<span class="nc" id="L253">		Date latestTime2 = recTemplate.getLatestPossibleEndTime();</span>
<span class="nc bnc" id="L254" title="All 4 branches missed.">		if (latestTime2 != null &amp;&amp; earliestTime1.after(latestTime2)) {</span>
<span class="nc" id="L255">			return false;</span>
		}
<span class="nc bnc" id="L257" title="All 4 branches missed.">		if (latestTime1 != null &amp;&amp; latestTime1.before(earliestTime2)) {</span>
<span class="nc" id="L258">			return false;</span>
		}

		/*
		 * in order to find whether we have any overlaps, we shall instantiate
		 * recurring events over the lowest common denominator of the recurring
		 * periodicity intervals of the two templates and then go through the
		 * resulting collections of events to see if there are any overlaps. To
		 * see why we use lowest common denominator, look at this example: - we
		 * have a recurring event that occurs every two weeks - we have a
		 * recurring event that occurs every three weeks
		 * 
		 * week 1 2 3 4 5 6 7 event 1 x x x x event 2 x x x
		 * 
		 * Say event1 occurs on Sat only and event 1 occurs on Sat and Sun.
		 * event1 start date is on Sat, whereas event2 start date is on Sun. The
		 * first event that overlaps will not happen until Sat of week 7, i.e.
		 * week 1 + 2*3 = 7.
		 */

<span class="nc" id="L278">		Calendar cal = Calendar.getInstance();</span>
		/* first we need to find the point of overlap */
<span class="nc bnc" id="L280" title="All 2 branches missed.">		if (earliestTime1.after(earliestTime2)) {</span>
<span class="nc" id="L281">			cal.setTimeZone(this.getTimeZone());</span>
<span class="nc" id="L282">			cal.setTime(earliestTime1);</span>
		} else {
<span class="nc" id="L284">			cal.setTimeZone(recTemplate.getTimeZone());</span>
<span class="nc" id="L285">			cal.setTime(earliestTime2);</span>
		}

<span class="nc" id="L288">		int nWeeks = this.getPeriodicityInterval() * recTemplate.getPeriodicityInterval();</span>

<span class="nc" id="L290">		Date dtStartCheck = cal.getTime();</span>
<span class="nc" id="L291">		cal.add(Calendar.WEEK_OF_MONTH, nWeeks);</span>
<span class="nc" id="L292">		Date dtEndCheck = cal.getTime();</span>

<span class="nc" id="L294">		Collection&lt;ID&gt; commonWorkResourceIDs = new ArrayList&lt;ID&gt;(getWorkResourceIDs());</span>
<span class="nc" id="L295">		commonWorkResourceIDs.retainAll(recTemplate.getWorkResourceIDs());</span>
		// fix QC50904: if two one week length recurring templates overlap, the
		// code is not detected

<span class="nc bnc" id="L299" title="All 2 branches missed.">		Date latestTimeOfBoth = latestTime1.after(latestTime2) ? latestTime1 : latestTime2;</span>
<span class="nc bnc" id="L300" title="All 4 branches missed.">		while (dtStartCheck.before(latestTimeOfBoth) &amp;&amp; dtEndCheck.after(latestTimeOfBoth)</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">				|| dtEndCheck.before(latestTimeOfBoth)) {</span>

<span class="nc" id="L303">			Collection&lt;CalendarEventAssignment&gt; events1 = this.getRecurringEvents(dtStartCheck, dtEndCheck, this.getWorkResourceIDs());</span>
<span class="nc" id="L304">			Collection&lt;CalendarEventAssignment&gt; events2 = recTemplate.getRecurringEvents(dtStartCheck, dtEndCheck, this.getWorkResourceIDs());</span>

			/* now see if any of the events overlap each other */
<span class="nc bnc" id="L307" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it1 = events1.iterator(); it1.hasNext();) {</span>
<span class="nc" id="L308">				Event event1 = it1.next();</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAssignment&gt; it2 = events2.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L310">					Event event2 = it2.next();</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">					if (event1.getStartTime().before(event2.getEndTime())</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">							&amp;&amp; event1.getEndTime().after(event2.getStartTime())) {</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">						for (Iterator&lt;ID&gt; it3 = event1.getWorkResourceIDs().iterator(); it3.hasNext();) {</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">							if (event2.getWorkResourceIDs().contains(it3.next())) {</span>
<span class="nc" id="L315">								return true;</span>
							}
						}
					}
<span class="nc" id="L319">				}</span>
<span class="nc" id="L320">			}</span>

			// if no conflict, check if it is becuase of exception. if so, check
			// next period
			// to fix bug QC38993:SP4+v11:two recurring templates conflict is
			// not detected if the first instance of later started recurring
			// template is deleted
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (hasException(commonWorkResourceIDs, dtStartCheck, dtEndCheck)</span>
<span class="nc bnc" id="L328" title="All 2 branches missed.">					|| recTemplate.hasException(commonWorkResourceIDs, dtStartCheck, dtEndCheck)) {</span>
<span class="nc" id="L329">				dtStartCheck = dtEndCheck;</span>
<span class="nc" id="L330">				cal.add(Calendar.WEEK_OF_MONTH, nWeeks);</span>
<span class="nc" id="L331">				dtEndCheck = cal.getTime();</span>
			} else {
<span class="nc" id="L333">				return false;</span>
			}
<span class="nc" id="L335">		}</span>
<span class="nc" id="L336">		return false;</span>
	}

	private boolean hasException(Collection&lt;ID&gt; workResourceIDs, Date start, Date end) {
<span class="nc" id="L340">		buildExceptionMap();</span>
<span class="nc" id="L341">		ID workResourceID = null;</span>
<span class="nc" id="L342">		List&lt;Date&gt; exceptionDates = null;</span>
<span class="nc" id="L343">		Date exceptionDate = null;</span>
<span class="nc" id="L344">		start = TimeZoneUtil.getMidNightDate(start);</span>
<span class="nc bnc" id="L345" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; i = workResourceIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L346">			workResourceID = (ID) i.next();</span>
<span class="nc" id="L347">			exceptionDates = m_mapExceptions.get(workResourceID);</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">			if (exceptionDates != null &amp;&amp; !exceptionDates.isEmpty()) {</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">				for (Iterator&lt;Date&gt; iDate = exceptionDates.iterator(); iDate.hasNext();) {</span>
<span class="nc" id="L350">					exceptionDate = iDate.next();</span>
<span class="nc bnc" id="L351" title="All 4 branches missed.">					if (!exceptionDate.before(start) &amp;&amp; !exceptionDate.after(end)) {</span>
<span class="nc" id="L352">						return true;</span>
					}
				}
			}
		}
<span class="nc" id="L357">		return false;</span>
	}

	/**
	 * This method will return all recurrent event instances for this recurring
	 * event template that overlap with the specified time interval for the
	 * given set of work resources
	 *
	 * @param dtStart
	 *            beginning of the time interval
	 * @param dtEnd
	 *            end of the time interval
	 * @param workResourceIDs
	 *            set of work resource IDs for which to retrieve recurring event
	 *            instances. If this parameter is null then events for all
	 *            recurring event template attendees will be retrieved
	 */
	public Collection&lt;CalendarEventAssignment&gt; getRecurringEvents(Date dtStart, Date dtEnd, Collection&lt;ID&gt; workResourceIDs) {
<span class="nc" id="L375">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L376">		cal.setLenient(true);</span>

		/*
		 * Compute the recurring events starting with whichever comes later: 1)
		 * for the week previous to the start date, since there may be a
		 * recurring event that starts right before midnight on the last day of
		 * the previous week 2) the recurring start date
		 */
<span class="nc" id="L384">		cal.setTime(getAdjustedRecurringStartDate());</span>
<span class="nc" id="L385">		Date dtFirstPossibleWeek = cal.getTime();</span>

<span class="nc" id="L387">		cal.setTime(dtStart);</span>
<span class="nc" id="L388">		cal.add(Calendar.WEEK_OF_MONTH, -1);</span>
<span class="nc" id="L389">		Date dtBeginWeek = cal.getTime();</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">		if (dtBeginWeek.before(dtFirstPossibleWeek)) {</span>
<span class="nc" id="L391">			dtBeginWeek = dtFirstPossibleWeek;</span>
		}

		/*
		 * Compute the recurring events ending with whichever comes the
		 * earliest: 1) one week past the given end date, since there there
		 * could be less than a week between the start date and the end date to
		 * avoid terminating the following loop prematurely 2) if the event has
		 * a recurring end date, one week past the recurring end date, for the
		 * same reason as above
		 */
<span class="nc" id="L402">		cal.setTime(dtEnd);</span>
<span class="nc" id="L403">		cal.add(Calendar.WEEK_OF_MONTH, 1);</span>
<span class="nc" id="L404">		Date dtEndWeek = cal.getTime();</span>

<span class="nc" id="L406">		Date recurringEndDate = getAdjustedRecurringEndDate();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (recurringEndDate != null) {</span>
<span class="nc" id="L408">			cal.setTime(recurringEndDate);</span>
<span class="nc" id="L409">			cal.add(Calendar.WEEK_OF_MONTH, 1);</span>
<span class="nc" id="L410">			Date dtLastPossibleWeek = cal.getTime();</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">			if (dtEndWeek.after(dtLastPossibleWeek)) {</span>
<span class="nc" id="L412">				dtEndWeek = dtLastPossibleWeek;</span>
			}
		}

<span class="nc" id="L416">		Set&lt;CalendarEventAssignment&gt; events = new HashSet&lt;CalendarEventAssignment&gt;(); // to provent dup events</span>

<span class="nc bnc" id="L418" title="All 2 branches missed.">		for (cal.setTime(dtBeginWeek); !cal.getTime().after(dtEndWeek); cal.add(Calendar.WEEK_OF_MONTH, 1)) {</span>
<span class="nc" id="L419">			events.addAll(getRecurringEventsStartingInTheWeekOf(cal.getTime(), workResourceIDs));</span>
		}

		/*
		 * now that we've got this collection, go through it and make sure only
		 * those events that actually overlap with the given time interval are
		 * left
		 */
<span class="nc bnc" id="L427" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; it = events.iterator(); it.hasNext();) {</span>
<span class="nc" id="L428">			Event event = it.next();</span>
<span class="nc bnc" id="L429" title="All 4 branches missed.">			if (!event.getStartTime().before(dtEnd) || !event.getEndTime().after(dtStart)) {</span>
<span class="nc" id="L430">				it.remove();</span>
			}
<span class="nc" id="L432">		}</span>
<span class="nc" id="L433">		return new ArrayList&lt;CalendarEventAssignment&gt;(events);</span>
	}

	/* This method will be implemented by the derived class */
	protected abstract Collection&lt;CalendarEventAssignment&gt; getRecurringEventsStartingInTheWeekOf(Date dtInWeek,
			Collection&lt;ID&gt; workresourceIDs);

	/**
	 * Returns true if there is an exception to this recurring event template
	 * rule on the specified date for the given employee
	 */
	public boolean existsExceptionOnDate(Date date, ID workResourceID) {
<span class="nc" id="L445">		buildExceptionMap();</span>

<span class="nc" id="L447">		List&lt;Date&gt; listDates = m_mapExceptions.get(workResourceID);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (listDates != null) {</span>
			/*
			 * the input date and the exception is in the timezone of the
			 * recurring event template
			 */
<span class="nc" id="L453">			Calendar cal1 = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L454">			cal1.setTime(date);</span>
<span class="nc" id="L455">			Calendar cal2 = Calendar.getInstance(getTimeZone());</span>

<span class="nc bnc" id="L457" title="All 2 branches missed.">			for (Iterator&lt;Date&gt; it = listDates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L458">				Date exceptionDate = it.next();</span>
<span class="nc" id="L459">				cal2.setTime(exceptionDate);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">				if (cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR)</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">						&amp;&amp; cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH)</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">						&amp;&amp; cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE)) {</span>
<span class="nc" id="L463">					return true;</span>
				}
<span class="nc" id="L465">			}</span>
		}
<span class="nc" id="L467">		return false;</span>
	}

	private void buildExceptionMap() {
<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (m_mapExceptions == null) {</span>
			/* let's build the exception map for faster lookups */
<span class="nc" id="L473">			m_mapExceptions = new HashMap&lt;ID, List&lt;Date&gt;&gt;();</span>

<span class="nc" id="L475">			Collection&lt;RecurringEventException&gt; colExceptions = getChildObjects(RecurringEventTemplateFields.CHILD_EXCEPTION);</span>

<span class="nc bnc" id="L477" title="All 2 branches missed.">			for (Iterator&lt;RecurringEventException&gt; it = colExceptions.iterator(); it.hasNext();) {</span>
<span class="nc" id="L478">				RecurringEventException eventException = it.next();</span>
<span class="nc" id="L479">				ID workResourceID2 = eventException.getWorkResourceID();</span>
<span class="nc" id="L480">				List&lt;Date&gt; listDates = m_mapExceptions.get(workResourceID2);</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">				if (listDates == null) {</span>
<span class="nc" id="L482">					listDates = new ArrayList&lt;Date&gt;();</span>
<span class="nc" id="L483">					m_mapExceptions.put(workResourceID2, listDates);</span>
				}
<span class="nc" id="L485">				listDates.add(eventException.getExceptionDate());</span>
<span class="nc" id="L486">			}</span>
		}
<span class="nc" id="L488">	}</span>

	/**
	 * Returns the actual attendee list for the event instance on the given date
	 */
	protected Collection&lt;ID&gt; getEventInstanceAttendees(Date dtTime) {
<span class="nc" id="L494">		List&lt;ID&gt; workResourceIDs = new ArrayList&lt;ID&gt;();</span>

		/*
		 * start with all of the work resources from the template and remove
		 * those that hav an exception on the given date
		 */
<span class="nc bnc" id="L500" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; it = getWorkResourceIDs().iterator(); it.hasNext();) {</span>
<span class="nc" id="L501">			ID workResourceID = it.next();</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">			if (!existsExceptionOnDate(dtTime, workResourceID)) {</span>
<span class="nc" id="L503">				workResourceIDs.add(workResourceID);</span>
			}
<span class="nc" id="L505">		}</span>
<span class="nc" id="L506">		return workResourceIDs;</span>
	}

	public abstract Collection&lt;BbmScheduleConflict&gt; getConflictsForTemplate(boolean isNewObject,
		Collection&lt;ShiftAssignment&gt; shifts, Collection&lt;CalendarEventAssignment&gt; events,
		Collection&lt;RecurringEventTemplateBase&gt; templates);

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>