<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RecurringFloatingEventTemplate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">RecurringFloatingEventTemplate.java</span></div><h1>RecurringFloatingEventTemplate.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Value object class that adds to the Calendar Event Template
 *               to furthur describe Recurring Events that are floating.
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleDAOUtil;

<span class="nc" id="L17">public class RecurringFloatingEventTemplate extends RecurringEventTemplateBase {</span>
	static final long serialVersionUID = 3614339314866181370L;

<span class="nc" id="L20">	private static final int[][] m_weekDaysToFields = new int[][] {</span>
			{ RecurringEventTemplateFields.FLOATDAY1STARTOFFSET, RecurringEventTemplateFields.FLOATDAY1ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY2STARTOFFSET, RecurringEventTemplateFields.FLOATDAY2ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY3STARTOFFSET, RecurringEventTemplateFields.FLOATDAY3ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY4STARTOFFSET, RecurringEventTemplateFields.FLOATDAY4ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY5STARTOFFSET, RecurringEventTemplateFields.FLOATDAY5ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY6STARTOFFSET, RecurringEventTemplateFields.FLOATDAY6ENDOFFSET },
			{ RecurringEventTemplateFields.FLOATDAY7STARTOFFSET, RecurringEventTemplateFields.FLOATDAY7ENDOFFSET } };

	/**
	 * Returns the type of the calendar event template object. This could be one
	 * of the int values defined as constants above: simple, floating or
	 * recurring or recurring floating
	 */
	public short getTemplateType() {
<span class="nc" id="L35">		return CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING;</span>
	}

	/**
	 * Returns the earliest possible time that some instance of this recurring
	 * event template may begin
	 */
	public Date getEarliestPossibleStartTime() {
<span class="nc" id="L43">		Date dtFirstOccurrenceStart = getAdjustedRecurringStartDate();</span>
<span class="nc" id="L44">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L45">		cal.setLenient(true);</span>
<span class="nc" id="L46">		cal.setTime(dtFirstOccurrenceStart);</span>
<span class="nc" id="L47">		cal.add(Calendar.MINUTE, getFirstDayStartOffset());</span>
<span class="nc" id="L48">		return cal.getTime();</span>
	}

	private int getFirstDayStartOffset() {
<span class="nc bnc" id="L52" title="All 2 branches missed.">		for (int ix = 0; ix &lt; 7; ix++) {</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">			if (getFieldValue(m_weekDaysToFields[ix][0]) != null) {</span>
<span class="nc" id="L54">				return getFieldValueInt(m_weekDaysToFields[ix][0]);</span>
			}
		}
<span class="nc" id="L57">		return 0;</span>
	}

	private int getLastDayStartOffset() {
<span class="nc bnc" id="L61" title="All 2 branches missed.">		for (int ix = 6; ix &gt;= 0; ix--) {</span>
<span class="nc bnc" id="L62" title="All 2 branches missed.">			if (getFieldValue(m_weekDaysToFields[ix][0]) != null) {</span>
<span class="nc" id="L63">				return getFieldValueInt(m_weekDaysToFields[ix][0]);</span>
			}
		}
<span class="nc" id="L66">		return 0;</span>
	}

	/**
	 * Return the latest possible time that some instance of this recurring
	 * event template may end
	 */
	public Date getLatestPossibleEndTime() {
<span class="nc" id="L74">		Date dtLastOccurrenceEnd = getAdjustedRecurringEndDate();</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">		if (dtLastOccurrenceEnd != null) {</span>
<span class="nc" id="L76">			Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L77">			cal.setLenient(true);</span>
<span class="nc" id="L78">			cal.setTime(dtLastOccurrenceEnd);</span>
<span class="nc" id="L79">			cal.add(Calendar.MINUTE, 1); // // dtLastOccurrenceEnd is the last</span>
											// minute of the day, add it back
<span class="nc" id="L81">			cal.add(Calendar.MINUTE, getLastDayStartOffset());</span>
<span class="nc" id="L82">			cal.add(Calendar.MINUTE, getDuration());</span>
<span class="nc" id="L83">			dtLastOccurrenceEnd = cal.getTime();</span>
		}
<span class="nc" id="L85">		return dtLastOccurrenceEnd;</span>
	}

	/**
	 * This is an override of a base class function to implement proper
	 * instantiation of recurring floating events
	 *
	 * @param dtInWeek
	 *            arbitrary point in time, such that events for the week that
	 *            contains this point will be retrieved. See the method
	 *            RecurringEventTemplate.getRecurringEventsStartingInTheWeekOf
	 *            for more detailed definition of the &quot;week&quot;
	 * @param workResourceIDs
	 *            set of work resource IDs for which to retrieve recurring event
	 *            instances. If this parameter is null then events for all
	 *            recurring event template attendees will be retrieved
	 */
	protected Collection&lt;CalendarEventAssignment&gt; getRecurringEventsStartingInTheWeekOf(Date dtInWeek, Collection&lt;ID&gt; workResourceIDs) {
<span class="nc" id="L103">		Date recurringStartDate = getAdjustedRecurringStartDate();</span>
<span class="nc" id="L104">		Date recurringEndDate = getAdjustedRecurringEndDate();</span>

<span class="nc" id="L106">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L107">		cal.setLenient(true);</span>
<span class="nc" id="L108">		cal.setTime(recurringStartDate);</span>
<span class="nc" id="L109">		cal.add(Calendar.WEEK_OF_MONTH, 1);</span>
<span class="nc" id="L110">		Date dtWeekEnd = cal.getTime();</span>

		/*
		 * march forward by adding the appropriate number of weeks until I can
		 * find the appropriate week that encompasses the given date
		 */
<span class="nc bnc" id="L116" title="All 2 branches missed.">		while (!dtWeekEnd.after(dtInWeek)) {</span>
<span class="nc" id="L117">			cal.add(Calendar.WEEK_OF_MONTH, getPeriodicityInterval());</span>
<span class="nc" id="L118">			dtWeekEnd = cal.getTime();</span>
		}

<span class="nc" id="L121">		List&lt;CalendarEventAssignment&gt; events = new ArrayList&lt;CalendarEventAssignment&gt;();</span>

		/* set the calendar to the very beginning of the week */
<span class="nc" id="L124">		cal.add(Calendar.WEEK_OF_MONTH, -1);</span>

<span class="nc" id="L126">		Date instanceStart = null;</span>

		// Date instanceStart = null;
<span class="nc" id="L129">		Collection&lt;ID&gt; attendees = getWorkResourceIDs(); // all attendees defined in</span>
														// template
<span class="nc bnc" id="L131" title="All 2 branches missed.">		for (; cal.getTime().before(dtWeekEnd); cal.add(Calendar.DAY_OF_WEEK, 1)) {</span>
<span class="nc" id="L132">			cal.set(Calendar.MINUTE, getDayStartOffset(cal.get(Calendar.DAY_OF_WEEK)));</span>
<span class="nc" id="L133">			Date dtTime = cal.getTime();</span>

			/*
			 * make sure we don't return any events that actually start before
			 * the recurring start date
			 */
<span class="nc bnc" id="L139" title="All 2 branches missed.">			if (dtTime.before(recurringStartDate)) {</span>
<span class="nc" id="L140">				continue;</span>
			}

			/*
			 * make sure we don't return any events that actually start after
			 * the recurring end date
			 */
<span class="nc bnc" id="L147" title="All 4 branches missed.">			if (recurringEndDate != null &amp;&amp; dtTime.after(recurringEndDate)) {</span>
<span class="nc" id="L148">				break;</span>
			}

			/*
			 * find out what are the actual attendees for this event instance
			 * and get a fresh instance of the event for thee given date
			 * 
			 * for recurring floating template, exception will be set to the
			 * first day of floating period, but since it used to set exception
			 * on any date , so we consider it here.
			 */
<span class="nc" id="L159">			Collection&lt;ID&gt; eventAttendees = getEventInstanceAttendees(dtTime);</span>
<span class="nc" id="L160">			attendees.retainAll(eventAttendees); // remove the attendees who has</span>
													// exception

			/*
			 * as soon as we find the first day of the week where the event
			 * could start, we create a single instance of a floating event on
			 * that day and then return it
			 */
<span class="nc bnc" id="L168" title="All 2 branches missed.">			if (canOccurOnWeekday(cal.get(Calendar.DAY_OF_WEEK))) {</span>

				/*
				 * iterate through all work resources for this event instance to
				 * see if there is an intersection with the passwed in
				 * collection of work resource IDs
				 */
<span class="nc bnc" id="L175" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it = eventAttendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L176">					ID workResourceID = it.next();</span>

					/* skip those work resources that the client did not ask for */
<span class="nc bnc" id="L179" title="All 4 branches missed.">					if (workResourceIDs != null &amp;&amp; !workResourceIDs.contains(workResourceID))</span>
<span class="nc" id="L180">						continue;</span>

					/*
					 * now now we know that there is an event on this date that
					 * includes at least one of the passed in work resources,
					 * create a single instance that includes all attendees and
					 * add it to the collection to be returned
					 */
					//events.add(getEventInstance(dtTime, eventAttendees));
<span class="nc bnc" id="L189" title="All 2 branches missed.">					if (instanceStart == null)</span>
<span class="nc" id="L190">						instanceStart = dtTime;//find the first valid instance</span>
<span class="nc" id="L191">				}</span>
			}
		}
<span class="nc bnc" id="L194" title="All 4 branches missed.">		if (instanceStart != null &amp;&amp; !attendees.isEmpty()) {</span>
<span class="nc" id="L195">			events.add(getEventInstance(instanceStart, attendees));</span>
		}
<span class="nc" id="L197">		return events;</span>
	}

	@Override
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForTemplate(boolean isNewObject,
	    Collection&lt;ShiftAssignment&gt; shifts, Collection&lt;CalendarEventAssignment&gt; events,
	    Collection&lt;RecurringEventTemplateBase&gt; templates) {
<span class="nc" id="L204">		Collection&lt;BbmScheduleConflict&gt; cConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>

<span class="nc" id="L206">		Date earliestStart = getEarliestPossibleStartTime();</span>
<span class="nc" id="L207">		Date latestEnd = getLatestPossibleEndTime();</span>

<span class="nc bnc" id="L209" title="All 10 branches missed.">		if (earliestStart == null || latestEnd == null || (events.isEmpty() &amp;&amp; shifts.isEmpty() &amp;&amp; templates.isEmpty())) {</span>
<span class="nc" id="L210">			return cConflicts;</span>
		}

<span class="nc" id="L213">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L214">		cal.setTime(earliestStart);</span>
<span class="nc" id="L215">		Date startOfWeek = cal.getTime();</span>

<span class="nc" id="L217">		int nStartTimeCount = getStartTimeCount();</span>
<span class="nc" id="L218">		int weekCounter = 0;</span>
<span class="nc" id="L219">		Collection&lt;CalendarEventAssignment&gt; overlapEvents = null;</span>
<span class="nc" id="L220">		Collection&lt;ShiftAssignment&gt; overlapShifts = null;</span>

 		do {
<span class="nc" id="L223">			boolean isGoodLocationFound = false;</span>

<span class="nc bnc" id="L225" title="All 2 branches missed.">			loopAllAvailableStartTimesForFloatingEvent : for (int nStartTime = 0; nStartTime &lt; nStartTimeCount; nStartTime++) {</span>

<span class="nc" id="L227">				Date startTime = getStartTime(nStartTime, startOfWeek);</span>
<span class="nc" id="L228">				Date endTime = new Date(startTime.getTime() + getDuration()*60000);</span>

<span class="nc" id="L230">				overlapEvents = ScheduleDAOUtil.findOverlap(events, startTime, endTime);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAssignment&gt; it = overlapEvents.iterator(); it.hasNext(); ){</span>
<span class="nc" id="L232">					CalendarEventAssignment calendarEvent = it.next();</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">					if ((isNewObject || !getID().equals(calendarEvent.getID()))</span>
<span class="nc bnc" id="L234" title="All 2 branches missed.">							&amp;&amp; getOverlayPrecedence() == calendarEvent.getOverlayPrecedence()) {</span>
<span class="nc" id="L235">						continue loopAllAvailableStartTimesForFloatingEvent;</span>
					}
<span class="nc" id="L237">				}</span>

<span class="nc" id="L239">				overlapShifts = ScheduleDAOUtil.findOverlap(shifts, startTime, endTime);</span>
<span class="nc bnc" id="L240" title="All 2 branches missed.">				for (Iterator&lt;ShiftAssignment&gt; it = overlapShifts.iterator(); it.hasNext(); ){</span>
<span class="nc" id="L241">					ShiftAssignment shift = it.next();</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">					if (shift.getOverlayPrecedence() == getOverlayPrecedence()) {</span>
<span class="nc" id="L243">						continue loopAllAvailableStartTimesForFloatingEvent;</span>
					}
<span class="nc" id="L245">				}</span>

<span class="nc bnc" id="L247" title="All 2 branches missed.">				for (Iterator&lt;RecurringEventTemplateBase&gt; it = templates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L248">					RecurringEventTemplateBase recTemplate = it.next();</span>
<span class="nc bnc" id="L249" title="All 4 branches missed.">					if ((isNewObject || !getID().equals(recTemplate.getID()))</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">							&amp;&amp; getOverlayPrecedence() == recTemplate.getOverlayPrecedence()) {</span>
<span class="nc" id="L251">						Collection&lt;CalendarEventAssignment&gt; recurringEvents = recTemplate.getRecurringEvents(</span>
<span class="nc" id="L252">								startTime, endTime, getWorkResourceIDs());</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">						if (!recurringEvents.isEmpty()) {</span>
<span class="nc" id="L254">							continue loopAllAvailableStartTimesForFloatingEvent;</span>
						}
					}
<span class="nc" id="L257">				}</span>

				// find the good location, so break the loop and go to next periodic week
<span class="nc" id="L260">				isGoodLocationFound = true;</span>
<span class="nc" id="L261">				break;</span>
			}

<span class="nc bnc" id="L264" title="All 2 branches missed.">			if (isGoodLocationFound) {</span>
				//if found a location then jump to the start of next floating period - add week(s) accordingly
<span class="nc" id="L266">				cal.add(Calendar.WEEK_OF_MONTH, getPeriodicityInterval() - weekCounter);</span>
<span class="nc" id="L267">				weekCounter = 0;</span>
			} else {
<span class="nc" id="L269">				weekCounter++;</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">				if (weekCounter == getPeriodicityInterval()) {</span>
					//we havent found a good location in a floating period. Report Conflict.
<span class="nc" id="L272">					cal.add(Calendar.WEEK_OF_MONTH, -(weekCounter-1));</span>
<span class="nc" id="L273">					cConflicts.add(new BbmScheduleConflict(this, cal.getTime()));</span>
<span class="nc" id="L274">					cal.add(Calendar.WEEK_OF_MONTH, getPeriodicityInterval());</span>
<span class="nc" id="L275">					weekCounter = 0;</span>
				} else {
<span class="nc" id="L277">					cal.add(Calendar.WEEK_OF_MONTH, 1);</span>
				}
			}
<span class="nc" id="L280">		    startOfWeek = cal.getTime();</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">	    } while (startOfWeek.before(latestEnd));</span>

<span class="nc" id="L283">		return cConflicts;</span>
	}

	/**
	 * Returns the earliest time during the day for which this floating event
	 * can begin. This offset is counted in minutes in the timezone of the
	 * floating event template.
	 */
	public int getDayStartOffset(int nDayOfWeek) {
<span class="nc bnc" id="L292" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L293">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L296">		return getFieldValueInt(m_weekDaysToFields[nDayOfWeek - 1][0]);</span>
	}

	/**
	 * Returns the nth possible start time that an instance of this floating
	 * event template may begin
	 */
	public Date getStartTime(int nStartTime, Date startDayOfWeek) {
		/* calculate the event start time */
<span class="nc" id="L305">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L306">		cal.setTime(startDayOfWeek);</span>
<span class="nc" id="L307">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L308">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L309">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L310">		cal.set(Calendar.MINUTE, 0);</span>

<span class="nc" id="L312">		Calendar cal2 = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L313">		cal2.setTime(startDayOfWeek);</span>
<span class="nc" id="L314">		cal2.add(Calendar.WEEK_OF_MONTH, 1);</span>
<span class="nc" id="L315">		cal2.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L316">		cal2.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L317">		cal2.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L318">		cal2.set(Calendar.MINUTE, 59);</span>

<span class="nc" id="L320">		int nStartMinute = nStartTime * 15;</span>

<span class="nc bnc" id="L322" title="All 2 branches missed.">		while (cal.before(cal2)) {</span>

<span class="nc" id="L324">			int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">			if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">				if (getDayStartOffset(dayOfWeek) + nStartMinute &lt;= getDayEndOffset(dayOfWeek)) {</span>
<span class="nc" id="L328">					cal.set(Calendar.MINUTE, getDayStartOffset(dayOfWeek) + nStartMinute);</span>
<span class="nc" id="L329">					return cal.getTime();</span>
				} else {
					// this start time occurs on a future day, decrement the
					// nStartMinute
<span class="nc" id="L333">					nStartMinute -= getDayEndOffset(dayOfWeek) - getDayStartOffset(dayOfWeek) + 15;</span>
				}
			}
<span class="nc" id="L336">			cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L337">		}</span>
<span class="nc" id="L338">		return null;</span>
	}

	/**
	 * Returns total number of start times for a day
	 * @return
	 */
	public int getStartTimeCount() {
<span class="nc" id="L346">		int nStartTimes = 0;</span>
<span class="nc bnc" id="L347" title="All 2 branches missed.">		for (int i = 1; i &lt;= 7; i++) {</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">			if (canOccurOnWeekday(i)) {</span>
<span class="nc" id="L349">				nStartTimes += 1 + (getDayEndOffset(i) - getDayStartOffset(i)) / 15;</span>
			}
		}
<span class="nc" id="L352">		return nStartTimes;</span>
	}

	/**
	 * Sets the earliest time during the day for which this floating event can
	 * begin. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public void setDayStartOffset(int nDayOfWeek, int offset) {
<span class="nc bnc" id="L361" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L362">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L365">		setFieldValue(m_weekDaysToFields[nDayOfWeek - 1][0], offset);</span>
<span class="nc" id="L366">	}</span>

	/**
	 * Returns the latest time during the day for which this floating event can
	 * end. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public int getDayEndOffset(int nDayOfWeek) {
<span class="nc bnc" id="L374" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L375">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L378">		return getFieldValueInt(m_weekDaysToFields[nDayOfWeek - 1][1]);</span>
	}

	/**
	 * Sets the latest time during the day for which this floating event can
	 * end. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public void setDayEndOffset(int nDayOfWeek, int offset) {
<span class="nc bnc" id="L387" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L388">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L391">		setFieldValue(m_weekDaysToFields[nDayOfWeek - 1][1], offset);</span>
<span class="nc" id="L392">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>