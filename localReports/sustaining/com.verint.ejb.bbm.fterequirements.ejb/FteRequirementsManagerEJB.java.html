<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FteRequirementsManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.fterequirements.ejb</a> &gt; <span class="el_source">FteRequirementsManagerEJB.java</span></div><h1>FteRequirementsManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * (c) 2011-2012 Verint Systems, Inc.
 */
package com.verint.ejb.bbm.fterequirements.ejb;

import java.rmi.RemoteException;
import java.util.*;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.datatypes.Duration;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.*;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueueFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.SPShrinkage;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.time.TimeContextFactory;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.ClientServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.AverageSecondsToAnswerWithAbandonment;
import com.bluepumpkin.ejb.bbm.timeseries.util.AverageSecondsToAnswerWithPatience;
import com.bluepumpkin.ejb.bbm.timeseries.util.AverageSecondsToAnswerWithPatience.PatienceSource;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.FteUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.FteUtil.Project;
import com.bluepumpkin.ejb.bbm.timeseries.util.IServiceGoal;
import com.bluepumpkin.ejb.bbm.timeseries.util.PercentCallsAnswered;
import com.bluepumpkin.ejb.bbm.timeseries.util.ServiceGoalsTraceUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.MediaType;
import com.bluepumpkin.ejb.bbm.workload.model.ServiceGoalsType;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.bbm.forecast.ejb.ForecastProfileDAO;
import com.verint.ejb.bbm.forecast.ejb.ForecastProfileListDAO;
import com.verint.ejb.bbm.forecast.ejb.ForecastTimeSeriesManager;
import com.verint.ejb.bbm.forecast.model.ForecastProfile;
import com.verint.ejb.bbm.forecast.model.ForecastProfileFieldInfo;
import com.verint.ejb.bbm.forecast.model.ForecastProfileList;
import com.verint.ejb.bbm.forecast.model.ForecastProfileProject;
import com.verint.ejb.bbm.fterequirements.model.RequiredTimeSeries;
import com.verint.ejb.bbm.fterequirements.model.RequiredTimeSeriesFieldInfo;
import com.verint.ejb.bbm.fterequirements.util.FteRequirementsTimeSeriesUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

@SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L70">public class FteRequirementsManagerEJB extends SessionEJBBase {</span>

<span class="fc" id="L72">	private static Category cat = Log.initCategory(FteRequirementsManagerEJB.class.getName());</span>

	private DBConfigManager dbConfigManager;
	private TimeSeriesManager timeSeriesManager;
	private ForecastTimeSeriesManager forecastTimeSeriesManager;
	private CampaignManager campaignManager;

<span class="fc" id="L79">	private boolean whatIfMode = false;</span>

    /** override the base class to provide the appropriate logging category */
    @Override
	protected Category getCategory() {
<span class="fc" id="L84">        return cat;</span>
    }

    {
<span class="fc" id="L88">        super.init(FteRequirementsManagerEJB.class.getName());</span>
<span class="fc" id="L89">    }</span>

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L95">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L96">			Boolean WIF = (Boolean)initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">			if (WIF != null)</span>
<span class="fc" id="L98">				whatIfMode = WIF.booleanValue();</span>
<span class="fc" id="L99">			dbConfigManager = BbmManagerFactory.getDBConfigManager(whatIfMode);</span>
<span class="fc" id="L100">			timeSeriesManager = WfmManagerFactory.getTimeSeriesManager(whatIfMode);</span>
<span class="fc" id="L101">			forecastTimeSeriesManager = WfmManagerFactory.getForecastTimeSeriesManager(whatIfMode);</span>
<span class="fc" id="L102">			campaignManager = WfmManagerFactory.getCampaignManager(whatIfMode);</span>
<span class="nc" id="L103">		} catch (Exception e) {</span>
<span class="nc" id="L104">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="fc" id="L105">		}</span>
<span class="fc" id="L106">	}</span>

	/**
	 * Calculates FTE requirements for each SP Queue.
	 * Returns a collection of RequiredTimeSeries objects for each spQueueID which represent the FTE Requirements for the spQueue.
	 *
	 * Note that if FTE Requirements for an SP Queue have been manually modified (which only applies to immediate media queues in
	 * unskilled SPs) then this method will not return any RequiredTimeSeries objects for that SPQueue.  If that SPQueue is the only
	 * one being processed, then an empty collection is returned.  This is done because we do not want to overwrite the manually
	 * modified FTE Requirements with those that are calculated from the forecast, service goals, and shrinkage factors for that SP Queue.
	 *
	 * @param spQueueIDs - the IDs of the SPQueues for which we'd like to calculate FTE Requirements
	 * @param forecastsBySPQueueID - forecast data for the given SPQueueIDs.  This parameter is optional: if it is null, the forecast
	 * data will be loaded as needed.  If the map is non-null but does not contain forecast data for one of the SPQueues, forecast data
	 * will be loaded as needed.  Include this map if you have forecast data available and would like faster processing time.
	 * @return - A collection of RequiredTimeSeries records representing fte requirements data for the given sp queues.
	 */
	public Collection&lt;RequiredTimeSeries&gt; calculateFteRequirementsForSPQueues(Collection&lt;ID&gt; spQueueIDs,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID) throws BbmFinderException {
<span class="fc" id="L125">		return calculateFteRequirementsForSPQueues(spQueueIDs, forecastsBySPQueueID, false, true, true);</span>
	}

	/**
	 * Calculates FTE requirements for each SP Queue, without using minimum occupancy to limit the returned
	 * FTE values.  This method assumes that each SP Queue belongs to the same Scheduling Period.
	 * Returns a collection of RequiredTimeSeries objects for each spQueueID which represent the FTE Requirements for the spQueue.
	 *
	 * @param useMinimumOccupancy if {@code false}, then the returned FTE level does not reflect
	 * minimum occupancy; if {@code true} then minimum occupancy is taken into account.  Only affects
	 * results for an unskilled SP with a PCA service goal type.
	 * @param useShrinkage If true, we compute the required FTE using the full formula, which includes reverse-compensating for shrinkage.
	 * 
	 * Note that if FTE Requirements for an SP Queue have been manually modified (which only applies to immediate media queues in
	 * unskilled SPs) then this method will not return any RequiredTimeSeries objects for that SPQueue.  If that SPQueue is the only
	 * one being processed, then an empty collection is returned.  This is done because we do not want to overwrite the manually
	 * modified FTE Requirements with those that are calculated from the forecast, service goals, and shrinkage factors for that SP Queue.
	 */
	public Collection&lt;RequiredTimeSeries&gt; calculateFteRequirementsForSPQueues(Collection&lt;ID&gt; spQueueIDs,
			boolean useMinimumOccupancy, boolean useShrinkage)
			throws BbmFinderException {
<span class="fc" id="L146">		return calculateFteRequirementsForSPQueues(spQueueIDs, null, false, useMinimumOccupancy, useShrinkage);</span>
	}

	/**
	 * Calculates FTE requirements for each SP Queue.
	 * @param spQueueIDs - the IDs of the SPQueues for which we'd like to calculate FTE Requirements
	 * @param forecastsBySPQueueID - forecast data for the given SPQueueIDs.  This parameter is optional: if it is null, the forecast
	 * data will be loaded as needed.  If the map is non-null but does not contain forecast data for one of the SPQueues, forecast data
	 * will be loaded as needed.  Include this map if you have forecast data available and would like faster processing time.
	 * @param forceRecalculationForManuallyEditedQueues - if set to true, then FTE Requirements will be calculated for SP Queues even if
	 * their FTE Requirements have been manually modified (this only applies to immediate media queues in unskilled SPs).
	 * @param useMinimumOccupancy if {@code false}, then the returned FTE level does not reflect
	 * minimum occupancy; if {@code true} then minimum occupancy is taken into account.  Only affects
	 * results for an unskilled SP with a PCA service goal type.
	 * @param useShrinkage If true, we compute the required FTE using the full formula, which includes reverse-compensating for shrinkage.
	 * @return - A collection of RequiredTimeSeries records representing fte requirements data for the given sp queues.
	 */
	private Collection&lt;RequiredTimeSeries&gt; calculateFteRequirementsForSPQueues(
			Collection&lt;ID&gt; spQueueIDs,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			boolean forceRecalculationForManuallyEditedQueues, boolean useMinimumOccupancy, boolean useShrinkage)
			throws BbmFinderException {

<span class="fc" id="L169">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="fc" id="L170">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="fc" id="L171">		SPShrinkageDAO spsDAO = new SPShrinkageDAO();</span>
<span class="fc" id="L172">		CampaignDAO cDAO = new CampaignDAO();</span>

		try {
<span class="fc" id="L175">			Collection&lt;SPQueue&gt; spQueues = spqDAO.getObjectsByIDs(spQueueIDs);</span>

<span class="pc bpc" id="L177" title="2 of 4 branches missed.">			if (spQueues != null &amp;&amp; spQueues.size() &gt; 0) {</span>
				//Retrieve the SchedulingPeriod associated to the SPQueues
<span class="fc" id="L179">				Map&lt;SchedulingPeriod, Collection&lt;SPQueue&gt;&gt; spsBySPQueue = spDAO.getSchedulingPeriodsForSPQueues(spQueues);</span>
				//Retrieve the campaigns linked to the scheduling periods (key = spid, value = associated campaign)
<span class="fc" id="L181">				Map&lt;ID, Campaign&gt; campaignsBySPID = cDAO.getCampaignsLinkedToSchedulingPeriods(spsBySPQueue.keySet());</span>

<span class="fc" id="L183">				String loginUserName = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L184">				Map&lt;ID, Collection&lt;SPShrinkage&gt;&gt; spShrinkageBySPID =</span>
<span class="fc" id="L185">					spsDAO.getOrCreateShrinkageBySPIDs(campaignsBySPID.keySet(), loginUserName);</span>

				//FTE requirements will be calculated for each media type and will be stored as a RequiredTimeSeries
				//for each queue.  This collection of RequiredTimeSeries will be returned by this method after the calculations
				//have been made.
<span class="fc" id="L190">				Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>

<span class="fc bfc" id="L192" title="All 2 branches covered.">				for (SchedulingPeriod sp : spsBySPQueue.keySet()) {</span>
<span class="fc" id="L193">					Campaign campaign = campaignsBySPID.get(sp.getID());</span>
<span class="fc" id="L194">					Collection&lt;SPShrinkage&gt; spShrinkage = spShrinkageBySPID.get(sp.getID());</span>

					//We need to adjust the end date of the SP when retrieving forecast/service goals trace data so
					//that we get the correct number of intervals back.  If we use the end time of the SP we get one
					//additional interval past the end of the SP that we don't want.
<span class="fc" id="L199">					Date adjustedSPEndDate = new Date(sp.getEndTime().getTime() - 60000);</span>

					//This map will be used to separate the spqueues in the SP by media type.  We will process
					//each media type separately.
<span class="fc" id="L203">					HashMap&lt;ID, Collection&lt;SPQueue&gt;&gt; mediaSPQueueMap = new HashMap&lt;ID, Collection&lt;SPQueue&gt;&gt;();</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">					for (SPQueue spQueue : spsBySPQueue.get(sp)) {</span>
						//We do not process &quot;combined-combined&quot; (null media type) queues or immediate media queues
						//that have manually modified FTE unless the forceCalculationForManuallyEditedQueues
						//flag is set.
<span class="fc bfc" id="L208" title="All 2 branches covered.">						if (spQueue.getMediaID() != null &amp;&amp;</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">								!(Media.isMediaImmediate(spQueue.getMediaID()) &amp;&amp;</span>
<span class="pc bpc" id="L210" title="3 of 4 branches missed.">										sp.isManualFteRequirementsMode() &amp;&amp;</span>
										!forceRecalculationForManuallyEditedQueues)) {
<span class="fc bfc" id="L212" title="All 2 branches covered.">							if (mediaSPQueueMap.containsKey(spQueue.getMediaID()) == false) {</span>
<span class="fc" id="L213">								ArrayList&lt;SPQueue&gt; spQueueList = new ArrayList&lt;SPQueue&gt;();</span>
<span class="fc" id="L214">								spQueueList.add(spQueue);</span>
<span class="fc" id="L215">								mediaSPQueueMap.put(spQueue.getMediaID(), spQueueList);</span>
<span class="fc" id="L216">							} else {</span>
<span class="fc" id="L217">								mediaSPQueueMap.get(spQueue.getMediaID()).add(spQueue);</span>
							}
						}
<span class="fc" id="L220">					}</span>

					//FTE requirements will be calculated for each media type and will be stored as a RequiredTimeSeries
					//for each queue.  This collection of RequiredTimeSeries will be returned by this method after the calculations
					//have been made.	
<span class="fc bfc" id="L225" title="All 2 branches covered.">					for (ID mediaID : mediaSPQueueMap.keySet()) {</span>
<span class="fc" id="L226">						Collection&lt;SPQueue&gt; mediaSPQueues = mediaSPQueueMap.get(mediaID);</span>
<span class="fc" id="L227">						Map&lt;SPQueue, TraceCube&gt; forecastData = new HashMap&lt;SPQueue, TraceCube&gt;();</span>

<span class="fc bfc" id="L229" title="All 2 branches covered.">						if (sp.getSkillBased() == false) {</span>
							//If the SP is unskilled, then we need to ensure that the spQueues we are calculating FTE requirements for
							// are all for the combined queue (null queue ID).
							//For each non-combined spqueue, we need to find its related combined spqueue and then remove
							// the non-combined spqueue from the list of spqueues that we will be calculating FTE for.
<span class="fc" id="L234">							mediaSPQueues = spqDAO.getCombinedSPQueues(mediaSPQueues);</span>

							// Get forecast data for all media other than projects.
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">							if (MediaType.get(mediaID) != MediaType.PROJECT) {</span>
<span class="fc bfc" id="L238" title="All 2 branches covered.">								for (SPQueue spQueue : mediaSPQueues) {</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">									if (MediaType.get(spQueue.getMediaID()) != MediaType.PROJECT) {</span>
<span class="pc bpc" id="L240" title="1 of 4 branches missed.">                                        if (forecastsBySPQueueID != null &amp;&amp; forecastsBySPQueueID.get(spQueue.getID()) != null) {</span>
<span class="nc" id="L241">                                            forecastData.put(spQueue, forecastsBySPQueueID.get(spQueue));</span>
                                        } else {
                                            //This call returns a list of trace cubes containing forecast data for each constituent queue in the
                                            // combined queue.  We need to aggregate this forecast data, which we do immediately after this call.
<span class="fc" id="L245">                                            Collection&lt;TraceCube&gt; combinedQueueConstituentForecasts = timeSeriesManager.getRawCombinedQueuesTimeSeries(</span>
<span class="fc" id="L246">                                                getForecastMetaTraceCubeForMediaType(MediaType.get(mediaID)),</span>
<span class="fc" id="L247">                                                sp.getCampaignID(), spQueue.getMediaID(),</span>
<span class="fc" id="L248">                                                sp.getStartTime(), adjustedSPEndDate);</span>
<span class="pc bpc" id="L249" title="2 of 4 branches missed.">                                            if (combinedQueueConstituentForecasts != null &amp;&amp; combinedQueueConstituentForecasts.size() &gt; 0) {</span>
<span class="fc bfc" id="L250" title="All 2 branches covered.">                                                if (combinedQueueConstituentForecasts.size() &gt; 1) {</span>
<span class="fc" id="L251">                                                    TraceCube aggregatedForecastData = TraceOperatorAdapter.combineQueue(combinedQueueConstituentForecasts, true, whatIfMode);</span>
<span class="fc" id="L252">                                                    forecastData.put(spQueue, aggregatedForecastData);</span>
<span class="fc" id="L253">                                                } else {</span>
<span class="fc" id="L254">                                                    forecastData.put(spQueue, combinedQueueConstituentForecasts.iterator().next());</span>
                                                }
                                            }
                                        }
									}
<span class="fc" id="L259">								}</span>
							}
						} else {	//Skill-based: fte requirements are only calculated for non-combined queues.  We need to filter out the combined queues from the given list of spqueues.
<span class="fc bfc" id="L262" title="All 2 branches covered.">							for (Iterator&lt;SPQueue&gt; iter = mediaSPQueues.iterator(); iter.hasNext();) {</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">								if (iter.next().getQueueID() == null) {		//Non-combined sp queues have a queue ID, so we filter out all spqueues that have a null queue ID as those are the combined queues.</span>
<span class="fc" id="L264">									iter.remove();</span>
								}
							}
							// Get forecast data for all media other than projects.
<span class="pc bpc" id="L268" title="1 of 2 branches missed.">							if (MediaType.get(mediaID) != MediaType.PROJECT) {</span>
<span class="fc" id="L269">                                Set&lt;ID&gt; queueIDsWithoutForecastData = new HashSet&lt;ID&gt;();</span>
<span class="fc bfc" id="L270" title="All 2 branches covered.">                                if (forecastsBySPQueueID != null) {</span>
<span class="fc bfc" id="L271" title="All 2 branches covered.">                                    for (SPQueue spQueue : mediaSPQueues) {</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">                                        if (forecastsBySPQueueID.get(spQueue.getID()) == null) {</span>
<span class="nc" id="L273">                                        	queueIDsWithoutForecastData.add(spQueue.getQueueID());</span>
                                        } else {
<span class="fc" id="L275">                                            forecastData.put(spQueue, forecastsBySPQueueID.get(spQueue.getID()));</span>
                                        }
<span class="fc" id="L277">                                    }</span>
                                } else {
<span class="fc" id="L279">                                	queueIDsWithoutForecastData.addAll(</span>
<span class="fc" id="L280">                                            ValueObjectUtil.getFieldObjectCol(</span>
                                                    SPQueueFieldInfo.SPQUEUE_QUEUEID, mediaSPQueues));
                                }
<span class="fc bfc" id="L283" title="All 2 branches covered.">                                if (queueIDsWithoutForecastData.isEmpty() == false) {</span>
<span class="fc" id="L284">                                    Collection&lt;TraceCube&gt; nonCombinedQueueTraceCubes =</span>
<span class="fc" id="L285">                                            timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
<span class="fc" id="L286">                                            getForecastMetaTraceCubeForMediaType(MediaType.get(mediaID)),</span>
<span class="fc" id="L287">                                            sp.getCampaignID(), queueIDsWithoutForecastData,</span>
<span class="fc" id="L288">                                            sp.getStartTime(), adjustedSPEndDate);</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                                    for (SPQueue spQueue : mediaSPQueues) {</span>
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">                                        for (TraceCube tc : nonCombinedQueueTraceCubes) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">                                            if (tc.getQueueID().equals(spQueue.getQueueID())) {</span>
<span class="fc" id="L292">                                                forecastData.put(spQueue, tc);</span>
<span class="fc" id="L293">                                                break;</span>
                                            }
<span class="fc" id="L295">                                        }</span>
<span class="fc" id="L296">                                    }</span>
                                }
							}
						}

						//Calculate FTE requirements based on media type
<span class="pc bpc" id="L302" title="3 of 6 branches missed.">						switch (MediaType.get(mediaID)) {</span>
							case IMMEDIATE:
								//Retrieve the service levels associated to the forecasts
<span class="fc" id="L305">								Map&lt;SPQueue, TraceCube&gt; serviceGoalsData = new HashMap&lt;SPQueue, TraceCube&gt;();</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">								for (SPQueue spQueue : mediaSPQueues) {</span>
<span class="fc" id="L307">									short[] traceType = null;</span>
<span class="pc bpc" id="L308" title="2 of 3 branches missed.">									switch(ServiceGoalsType.get(MediaType.IMMEDIATE, spQueue)) {</span>
									case SERVICE_LEVEL:
<span class="fc" id="L310">										traceType = new short[] { Trace.PCA };</span>
<span class="fc" id="L311">										break;</span>
									case ASA:
<span class="nc" id="L313">										traceType = new short[] { Trace.ASA };</span>
										break;
									}
<span class="fc bfc" id="L316" title="All 2 branches covered.">									if (spQueue.getQueueID() == null) {	//combined queue</span>
										//The ClientServiceGoalTraceCube will collect and aggregate the service goals for the combined queue
<span class="fc" id="L318">										ClientServiceGoalTraceCube clientServiceGoalsTraceCube = ServiceGoalsTraceUtil.getServiceGoalsTraceCube(</span>
<span class="fc" id="L319">												sp.getCampaignID(), null, spQueue.getMediaID(), sp.getStartTime(), adjustedSPEndDate, whatIfMode);</span>
<span class="fc" id="L320">										serviceGoalsData.put(spQueue, clientServiceGoalsTraceCube.getServiceGoals(</span>
<span class="fc" id="L321">												new ServiceGoalTraceCube(null, sp.getStartTime(), adjustedSPEndDate, traceType)));</span>
<span class="fc" id="L322">									} else {</span>
<span class="fc" id="L323">										Collection&lt;TraceCube&gt; serviceGoals = timeSeriesManager.getRawMultipleQueuesTimeSeries(new ServiceGoalTraceCube(traceType),</span>
<span class="fc" id="L324">												sp.getCampaignID(), Collections.singleton(spQueue.getQueueID()), sp.getStartTime(), adjustedSPEndDate);</span>
<span class="pc bpc" id="L325" title="2 of 4 branches missed.">										if (serviceGoals != null &amp;&amp; serviceGoals.size() &gt; 0) {</span>
<span class="fc" id="L326">											serviceGoalsData.put(spQueue, serviceGoals.iterator().next());</span>
										}
									}
<span class="fc" id="L329">								}</span>
<span class="fc" id="L330">								retVal.addAll(calculateImmediateMediaFteRequirements(forecastData, serviceGoalsData, sp, spShrinkage,</span>
									campaign, useMinimumOccupancy, useShrinkage));
<span class="fc" id="L332">								break;</span>
							case DEFERRED:
<span class="fc" id="L334">								retVal.addAll(calculateDeferredMediaFteRequirements(forecastData, sp, spShrinkage, campaign));</span>
<span class="fc" id="L335">								break;</span>
							case PROJECT:
<span class="nc" id="L337">								retVal.addAll(calculateProjectMediaFteRequirements(mediaSPQueues, sp, campaign));</span>
<span class="nc" id="L338">								break;</span>
							case OUTBOUND:
<span class="fc" id="L340">								retVal.addAll(calculateOutboundMediaFteRequirements(forecastData, sp, spShrinkage, campaign));</span>
<span class="fc" id="L341">								break;</span>
							case UNKNOWN:
<span class="nc" id="L343">								throw new UnsupportedOperationException(&quot;calculateFteRequirementsForSPQueues - Could not determine media type from the given SPQueues.&quot;);</span>
							default:
<span class="nc" id="L345">								throw new UnsupportedOperationException(&quot;calculateFteRequirementsForSPQueues - Could not determine media type from the given SPQueues.&quot;);</span>
						}
<span class="fc" id="L347">					}</span>
<span class="fc" id="L348">				}</span>
<span class="fc" id="L349">				return retVal;</span>
			}
<span class="nc" id="L351">			return Collections.emptySet();</span>
<span class="nc" id="L352">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L353">			throw new BbmFinderException(e);</span>
<span class="nc" id="L354">		} catch (RemoteException e) {</span>
<span class="nc" id="L355">			throw new BbmFinderException(e);</span>
<span class="nc" id="L356">		} catch (BbmTimeSeriesException e) {</span>
<span class="nc" id="L357">			throw new BbmFinderException(e);</span>
<span class="nc" id="L358">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L359">			throw new BbmFinderException(e);</span>
<span class="nc" id="L360">		} catch (JdmoException e) {</span>
<span class="nc" id="L361">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L363">			spDAO.cleanUp();</span>
<span class="pc" id="L364">			spqDAO.cleanUp();</span>
<span class="pc" id="L365">			spsDAO.cleanUp();</span>
<span class="pc" id="L366">			cDAO.cleanUp();</span>
<span class="pc" id="L367">			methodFinish();</span>
		}
	}

	/**
	 * Calculates FTE requirements for each SPQueue in the forecastData/serviceGoals data maps.
	 * Uses FteUtil for the FTE calculations.  To be used for immediate media queues only.
	 *
	 * @param useMinimumOccupancy if {@code false}, then the returned FTE level does not reflect
	 * minimum occupancy; if {@code true} then minimum occupancy is taken into account.  Only affects
	 * results for an unskilled SP with a PCA service goal type.
	 */
	public Collection&lt;RequiredTimeSeries&gt; calculateImmediateMediaFteRequirements(
			Map&lt;SPQueue, ? extends TraceCube&gt; forecastData,
			Map&lt;SPQueue, ? extends TraceCube&gt; serviceGoalsData,
			SchedulingPeriod sp,
			Collection&lt;SPShrinkage&gt; spShrinkage,
			Campaign campaign,
			boolean useMinimumOccupancy,
			boolean useShrinkage)
		throws BbmCreateException, RemoteException {

<span class="fc" id="L389">		TimeContext tc = TimeContextFactory.getTimeContext(campaign);</span>

<span class="fc" id="L391">		Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>
<span class="fc" id="L392">		int minimumOccupancy = dbConfigManager.getIntValue(ConfigKey.FORECASTING_MIN_OCCUPANCY_PERCENTAGE);</span>

		//For each forecast profile, calculate the agent requirements
<span class="fc bfc" id="L395" title="All 2 branches covered.">		for (SPQueue spQueue : forecastData.keySet()) {</span>
<span class="fc" id="L396">			IServiceGoal serviceGoal = null;</span>
<span class="pc bpc" id="L397" title="2 of 3 branches missed.">			switch(ServiceGoalsType.get(MediaType.IMMEDIATE, spQueue)) {</span>
				case ASA:
<span class="nc bnc" id="L399" title="All 4 branches missed.">					if (sp.getSkillBased() || spQueue.isPatienceUsedInUnskilledASACalcs()) {</span>
<span class="nc" id="L400">						serviceGoal = new AverageSecondsToAnswerWithPatience(</span>
<span class="nc" id="L401">								serviceGoalsData.get(spQueue),</span>
								Trace.ASA,
<span class="nc" id="L403">								spQueue.getPatience(),</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">								sp.getSkillBased() ? PatienceSource.SetExplicitly : PatienceSource.DerivedFromASA);</span>
					} else {
<span class="nc" id="L406">						serviceGoal = new AverageSecondsToAnswerWithAbandonment(</span>
<span class="nc" id="L407">								serviceGoalsData.get(spQueue),</span>
								Trace.ASA,
<span class="nc" id="L409">								Math.round(spQueue.getMaxAbandonsPercent()));</span>
					}
<span class="nc" id="L411">					break;</span>
				case SERVICE_LEVEL:
<span class="fc" id="L413">					serviceGoal = new PercentCallsAnswered(serviceGoalsData.get(spQueue),</span>
<span class="fc" id="L414">							Trace.PCA, spQueue.getSlAnswerWaitingTime());</span>
<span class="fc" id="L415">					break;</span>
				default:
<span class="nc" id="L417">					throw new UnsupportedOperationException(&quot;Service level type not supported.&quot;);</span>
			}

			//Ensure that AHT values are non-negative if the matching Volume data is non-negative.
<span class="fc" id="L421">			TraceUtil.adjustDependentTraceValues(forecastData.get(spQueue), Trace.CV, ForecastTraceCube.AHT);</span>

			//We need to create arrays for both shrinkage and modeling factor values
			//The array size is the number of 15 minute intervals present in the scheduling period
<span class="fc" id="L425">			float[] shrinkageValues = FteRequirementsTimeSeriesUtil.getShrinkageValuesFromSPShrinkage(spShrinkage, sp, tc);</span>
<span class="fc" id="L426">			float[] modelingFactors = FteRequirementsTimeSeriesUtil.getModelingFactorsFromSPShrinkage(spShrinkage, sp, tc);</span>

			//Calculate the FTE Requirements for the queue for the entire sp interval
<span class="fc" id="L429">			int[] periodRequirements = FteUtil.getFteRequirementsImmediate(forecastData.get(spQueue),</span>
					Trace.CV, Trace.AHT, serviceGoal, shrinkageValues, modelingFactors,
<span class="fc" id="L431">					minimumOccupancy, useMinimumOccupancy, useShrinkage, sp.getStartTime(), sp.getEndTime());</span>
<span class="fc" id="L432">			periodRequirements = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(periodRequirements, 0,</span>
<span class="fc" id="L433">					sp.getStartTime(), Duration.fromMinutes(15), tc);</span>

			//Once fte requirements have been calculated, create a RequiredTimeSeries for each day in the 
			//interval and initialize them with the calculated fte requirements for that day
<span class="fc" id="L437">			retVal.addAll(createRequiredTimeSeries(spShrinkage, sp, campaign.getTimeZone(), spQueue, periodRequirements));</span>
<span class="fc" id="L438">		}</span>

<span class="fc" id="L440">		return retVal;</span>
	}

	/**
	 * Calculates FTE requirements for each SPQueue in the forecastData map.
	 * Uses FteUtil for the FTE calculations.  To be used for deferred media queues only.
	 */
	private Collection&lt;RequiredTimeSeries&gt; calculateDeferredMediaFteRequirements(
			Map&lt;SPQueue, ? extends TraceCube&gt; forecastData,
			SchedulingPeriod sp,
			Collection&lt;SPShrinkage&gt; spShrinkage,
			Campaign campaign) throws BbmCreateException, RemoteException {

<span class="fc" id="L453">		Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>

		//Whether or not we use starting backlog to calculate FTE Requirements depends on whether a flag in bpconfig is set
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">		boolean fteRequirementsIncludeBacklog = (1 == dbConfigManager.getIntValue(ConfigKey.FTE_REQUIREMENTS_INCLUDE_BACKLOG));</span>

<span class="fc" id="L458">		TimeContext tc = TimeContextFactory.getTimeContext(campaign);</span>

		//Calculate the FTE requirements for each sp queue
<span class="fc bfc" id="L461" title="All 2 branches covered.">		for (SPQueue spQueue : forecastData.keySet()) {</span>
			//We need to create arrays for both shrinkage and modeling factor values
			//The array size is the number of 15 minute intervals present in the scheduling period
<span class="fc" id="L464">			float[] shrinkageValues = FteRequirementsTimeSeriesUtil.getShrinkageValuesFromSPShrinkage(spShrinkage, sp, tc);</span>
<span class="fc" id="L465">			float[] modelingFactors = FteRequirementsTimeSeriesUtil.getModelingFactorsFromSPShrinkage(spShrinkage, sp, tc);</span>
			//Calculate fte requirements for the queue for the entire sp interval
<span class="fc" id="L467">			int[] periodRequirements = FteUtil.getFteRequirementsDeferred(forecastData.get(spQueue), Trace.CV,</span>
<span class="fc" id="L468">					Trace.AHT, shrinkageValues, modelingFactors,  Math.round(spQueue.getStartingBacklog()),</span>
<span class="fc" id="L469">					fteRequirementsIncludeBacklog, sp.getStartTime(), sp.getEndTime());</span>
<span class="fc" id="L470">			periodRequirements = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(periodRequirements, 0,</span>
<span class="fc" id="L471">					sp.getStartTime(), Duration.fromMinutes(15), tc);</span>

			//Once fte requirements have been calculated, create a RequiredTimeSeries for each day in the 
			//interval and initialize them with the calculated fte requirements for that day
<span class="fc" id="L475">			retVal.addAll(createRequiredTimeSeries(spShrinkage, sp, campaign.getTimeZone(), spQueue, periodRequirements));</span>
<span class="fc" id="L476">		}</span>

<span class="fc" id="L478">		return retVal;</span>
	}

	/**
	 * Calculates Fte requirements for each SPQueue in the forecastData map.
	 * Uses FteUtil for the Fte calculations.  To be used for outbound media queues only.
	 * @throws BbmCreateException
	 * @throws BbmFinderException
	 */
	private Collection&lt;RequiredTimeSeries&gt; calculateOutboundMediaFteRequirements(
			Map&lt;SPQueue, ? extends TraceCube&gt; forecastData,
			SchedulingPeriod sp,
			Collection&lt;SPShrinkage&gt; spShrinkage,
			Campaign campaign) throws BbmCreateException, BbmFinderException {

<span class="fc" id="L493">		TimeContext tc = TimeContextFactory.getTimeContext(campaign);</span>

<span class="fc" id="L495">		Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>
<span class="fc" id="L496">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
<span class="fc" id="L497">		ForecastProfileListDAO fplDAO = new ForecastProfileListDAO();</span>

		try {
			//Create a map of forecasted call lists for each SP Queue we are processing
<span class="fc" id="L501">			HashMap&lt;ID, SPQueue&gt; spQueueIDMap = ValueObjectUtil.getIDObjectMap(forecastData.keySet());</span>
<span class="fc" id="L502">			Collection&lt;ForecastProfile&gt; activeForecastProfiles = fpDAO.getActive(spQueueIDMap.keySet());</span>
<span class="fc" id="L503">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsByForecastProfileID =</span>
<span class="fc" id="L504">				fplDAO.getForecastProfileListsByForecastProfileIDs(</span>
<span class="fc" id="L505">						ValueObjectUtil.getFieldObjectCol(ForecastProfileFieldInfo.FORECASTPROFILE_ID,</span>
								activeForecastProfiles));
<span class="fc" id="L507">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsBySPQueueID = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">			for (SPQueue spQueue : forecastData.keySet()) {</span>
<span class="fc" id="L509">				forecastProfileListsBySPQueueID.put(spQueue.getID(), new HashSet&lt;ForecastProfileList&gt;());</span>
<span class="fc" id="L510">			}</span>
<span class="fc bfc" id="L511" title="All 2 branches covered.">			for (ForecastProfile profile : activeForecastProfiles) {</span>
<span class="fc" id="L512">				Collection&lt;ForecastProfileList&gt; listsForProfile = forecastProfileListsByForecastProfileID.get(profile.getID());</span>
<span class="pc bpc" id="L513" title="1 of 4 branches missed.">				if (listsForProfile != null &amp;&amp; listsForProfile.isEmpty() == false) {</span>
<span class="fc" id="L514">					forecastProfileListsBySPQueueID.get(profile.getSPQueueID()).addAll(listsForProfile);</span>
				}
<span class="fc" id="L516">			}</span>

			//Calculate the FTE requirements for each sp queue
<span class="fc bfc" id="L519" title="All 2 branches covered.">			for (SPQueue spQueue : forecastData.keySet()) {</span>
				//We need to create arrays for both shrinkage and modeling factor values
				//The array size is the number of 15 minute intervals present in the scheduling period
<span class="fc" id="L522">				float[] shrinkageValues = FteRequirementsTimeSeriesUtil.getShrinkageValuesFromSPShrinkage(spShrinkage, sp, tc);</span>
<span class="fc" id="L523">				float[] modelingFactors = FteRequirementsTimeSeriesUtil.getModelingFactorsFromSPShrinkage(spShrinkage, sp, tc);</span>
				//Calculate fte requirements for the queue for the entire sp interval
<span class="fc" id="L525">				int[] periodRequirements = FteUtil.getFteRequirementsOutbound(forecastData.get(spQueue), Trace.CRATE,</span>
<span class="fc" id="L526">						Trace.RPCRATE, Trace.AHT, spQueue.getSlAnswerWaitingTime(), ServiceGoalsType.get(MediaType.OUTBOUND, spQueue),</span>
<span class="fc" id="L527">						shrinkageValues, modelingFactors, forecastProfileListsBySPQueueID.get(spQueue.getID()),</span>
<span class="fc" id="L528">						sp.getStartTime(), sp.getEndTime(), sp.getStartTime(), sp.getEndTime());</span>
<span class="fc" id="L529">				periodRequirements = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(periodRequirements, 0,</span>
<span class="fc" id="L530">						sp.getStartTime(), Duration.fromMinutes(15), tc);</span>

				//Once fte requirements have been calculated, create a RequiredTimeSeries for each day in the 
				//interval and initialize them with the calculated fte requirements for that day
<span class="fc" id="L534">				retVal.addAll(createRequiredTimeSeries(spShrinkage, sp, campaign.getTimeZone(), spQueue, periodRequirements));</span>
<span class="fc" id="L535">			}</span>
		} finally {
<span class="pc" id="L537">			fpDAO.cleanUp();</span>
<span class="pc" id="L538">			fplDAO.cleanUp();</span>
<span class="fc" id="L539">		}</span>

<span class="fc" id="L541">		return retVal;</span>
	}

	/**
	 * Calculates FTE requirements for each SPQueue in the {@code spQueues} collection.
	 * Uses FteUtil for the FTE calculations.  To be used for project media queues only.
	 */
	private Collection&lt;RequiredTimeSeries&gt; calculateProjectMediaFteRequirements(
			Collection&lt;SPQueue&gt; spQueues,
			SchedulingPeriod sp,
			Campaign campaign)
				throws BbmCreateException, RemoteException, BbmFinderException, JdmoException {

<span class="nc" id="L554">		TimeContext tc = TimeContextFactory.getTimeContext(campaign);</span>

<span class="nc" id="L556">		Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>
<span class="nc" id="L557">		SPQueueDAO dao = new SPQueueDAO();</span>

		try {
			// Calculate the FTE requirements for each SPQueue
<span class="nc bnc" id="L561" title="All 2 branches missed.">			for (SPQueue spQueue : spQueues) {</span>
				// This accumulates FTE requirements for every project interval in this SPQueue.
<span class="nc" id="L563">				int[] spqRequirements = null;</span>
<span class="nc" id="L564">				Collection&lt;ForecastProfileProject&gt; projectsForSpQueue = new ArrayList&lt;ForecastProfileProject&gt;();</span>

				//If a combined queue is handed in (queue ID == null), then we need to retrieve the projects from the constituent queues as
				//they are stored on the constituents, not the combined queue.
<span class="nc bnc" id="L568" title="All 2 branches missed.">				if (spQueue.getQueueID() == null) {</span>
<span class="nc" id="L569">					Collection&lt;SPQueue&gt; constituentSPQueues = dao.getNonCombinedSPQueuesByMediaAndSP(spQueue.getSpID(), spQueue.getMediaID());</span>
<span class="nc bnc" id="L570" title="All 4 branches missed.">					if (constituentSPQueues != null &amp;&amp; constituentSPQueues.size() &gt; 0) {</span>
<span class="nc" id="L571">						projectsForSpQueue.addAll(forecastTimeSeriesManager.getActiveProjects(ValueObjectUtil.getIDFromObjects(constituentSPQueues)));</span>
					}
<span class="nc" id="L573">				} else {</span>
<span class="nc" id="L574">					projectsForSpQueue = forecastTimeSeriesManager.getActiveProjects(Collections.singleton(spQueue.getID()));</span>
				}

<span class="nc bnc" id="L577" title="All 2 branches missed.">				for (ForecastProfileProject profileProject : projectsForSpQueue) {</span>
<span class="nc" id="L578">					Project fteProject = new Project(profileProject.getStartTime(), profileProject.getEndTime(), profileProject.getTotalDuration() / 100.0f);</span>
<span class="nc" id="L579">					int[] projectRequirements = FteUtil.getFteRequirementsProject(</span>
<span class="nc" id="L580">							fteProject, sp.getStartTime(), sp.getEndTime());</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">					if (spqRequirements == null) {</span>
<span class="nc" id="L582">						spqRequirements = Arrays.copyOf(projectRequirements, projectRequirements.length);</span>
					} else {
<span class="nc bnc" id="L584" title="All 2 branches missed.">						for (int index = 0; index &lt; spqRequirements.length; ++index) {</span>
<span class="nc" id="L585">							spqRequirements[index] += projectRequirements[index];</span>
						}
					}
<span class="nc" id="L588">				}</span>

<span class="nc bnc" id="L590" title="All 2 branches missed.">				if (spqRequirements == null) {</span>
<span class="nc" id="L591">					spqRequirements = new int[FteUtil.getSizeOfFteArray(sp.getStartTime(), sp.getEndTime())];</span>
<span class="nc" id="L592">					Arrays.fill(spqRequirements, 0, spqRequirements.length - 1, 0);</span>
				} else {
<span class="nc" id="L594">                    spqRequirements = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(spqRequirements, 0,</span>
<span class="nc" id="L595">                            sp.getStartTime(), Duration.fromMinutes(15), tc);</span>
                }

				// Once FTE requirements have been calculated, create a RequiredTimeSeries for each day in the 
				// interval and initialize them with the calculated FTE requirements for that day
<span class="nc" id="L600">				Calendar currentDate = Calendar.getInstance(campaign.getTimeZone());</span>
<span class="nc" id="L601">				currentDate.setTime(sp.getStartTime());</span>
<span class="nc" id="L602">				int dayIndex = 0;</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">				while (currentDate.getTime().before(sp.getEndTime())) {</span>
<span class="nc" id="L604">					int[] dayRequirements = Arrays.copyOfRange(spqRequirements, dayIndex * 96, (dayIndex + 1) * 96);</span>
<span class="nc" id="L605">					retVal.add(new RequiredTimeSeries(spQueue, currentDate.getTime(), dayRequirements));</span>
<span class="nc" id="L606">					currentDate.add(Calendar.DAY_OF_YEAR, 1);</span>
<span class="nc" id="L607">					dayIndex++;</span>
<span class="nc" id="L608">				}</span>
<span class="nc" id="L609">			}</span>

<span class="nc" id="L611">			return retVal;</span>
		} finally {
<span class="nc" id="L613">			dao.cleanUp();</span>
		}
	}

	/**
	 * Saves a set of required time series objects to the DB.  If any time series already exists for any
	 * SP queue in the set, all of the entries for that SP queue will be removed before saving.
	 */
	public Collection&lt;ID&gt; createAndUpdateRequiredTimeSeries(Collection&lt;RequiredTimeSeries&gt; requiredTimeSeries)
	throws BbmCreateException {
<span class="fc" id="L623">		methodStart(&quot;createAndUpdateRequiredTimeSeries&quot;, requiredTimeSeries);</span>

<span class="pc bpc" id="L625" title="2 of 4 branches missed.">		if (requiredTimeSeries == null || requiredTimeSeries.isEmpty()) {</span>
<span class="nc" id="L626">			return Collections.emptyList();</span>
		}

<span class="fc" id="L629">		RequiredTimeSeriesDAO dao = new RequiredTimeSeriesDAO();</span>
		try {
			//First we need to delete the required time series that already exist			
<span class="fc" id="L632">			HashSet&lt;ID&gt; spQueueIDs = new HashSet&lt;ID&gt;(ValueObjectUtil.getFieldObjectCol(</span>
<span class="fc" id="L633">					RequiredTimeSeriesFieldInfo.RequiredTimeSeriesColumn.SPQueueID.getIndex(), requiredTimeSeries));</span>
<span class="fc" id="L634">			StringBuffer query = new StringBuffer(spQueueIDs.size() * 25);</span>
<span class="fc" id="L635">			query.append(&quot;DELETE REQUIREDTIMESERIES WHERE SPQUEUEID IN (SELECT ID FROM SPQUEUE WHERE ID IN &quot; +</span>
<span class="fc" id="L636">					dao.getDMO().createInClause(spQueueIDs) + &quot;)&quot;);</span>
<span class="fc" id="L637">			dao.getDMO().executeCommand(query.toString());</span>

			//Create new required time series objects
<span class="fc bfc" id="L640" title="All 2 branches covered.">			for (RequiredTimeSeries rts : requiredTimeSeries) {</span>
<span class="fc" id="L641">				rts.setCreated(new Date(System.currentTimeMillis()));</span>
<span class="fc" id="L642">				rts.setCreatedBy(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="fc" id="L643">			}</span>
<span class="fc" id="L644">			return dao.createObjects(requiredTimeSeries);</span>
<span class="nc" id="L645">		} catch (JdmoException e) {</span>
<span class="nc" id="L646">			handleException(e);</span>
<span class="nc" id="L647">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L649">			dao.cleanUp();</span>
<span class="pc" id="L650">			methodFinish();</span>
		}
	}

	/**
	 * Converts the RequireTraceCube into a collection of RequiredTimeSeries (1 for each day) and saves
	 * it to the database.
	 */
	public void saveRequireTraceCube(RequireTraceCube fteRequirements, SchedulingPeriod sp, SPQueue spQueue)
			throws BbmException {
<span class="nc" id="L660">		methodStart(&quot;saveRequireTraceCube&quot;, fteRequirements, sp, spQueue);</span>

<span class="nc" id="L662">		CampaignDAO cDAO = new CampaignDAO();</span>

		try {
<span class="nc" id="L665">			Campaign c = cDAO.getCampaign(Collections.singleton(sp.getCampaignID()), false).iterator().next();</span>
<span class="nc" id="L666">			Collection&lt;RequiredTimeSeries&gt; timeSeriesCol =</span>
<span class="nc" id="L667">				FteRequirementsTimeSeriesUtil.getFteRequirementsTimeSeriesCol(fteRequirements, spQueue,</span>
<span class="nc" id="L668">						TimeContextFactory.getTimeContext(c));</span>
<span class="nc" id="L669">			createAndUpdateRequiredTimeSeries(timeSeriesCol);</span>
<span class="nc" id="L670">		} catch (BbmException e) {</span>
<span class="nc" id="L671">			handleException(e);</span>
<span class="nc" id="L672">			throw e;</span>
		} finally {
<span class="nc" id="L674">			cDAO.cleanUp();</span>
<span class="nc" id="L675">			methodFinish();</span>
<span class="nc" id="L676">		}</span>
<span class="nc" id="L677">	}</span>

	/**
	 * Saves the RequireTraceCube for the given SPQueue to the database, as well as updates the given SchedulingPeriod.
	 * The scheduling period is updated because when we edit FTE Requirements, two flags on the sp can be changed
	 * (whether or not FTE requirements were manually edited, and whether they are able to be edited).
	 */
	public void saveFteRequirementsForSpQueue(RequireTraceCube fteRequirements, SchedulingPeriod sp, SPQueue spQueue)
			throws BbmException {
<span class="nc" id="L686">		methodStart(&quot;saveRequireTraceCube&quot;, fteRequirements, sp, spQueue);</span>

<span class="nc" id="L688">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>

		try {
			// First we save the FTE requirements trace cube
<span class="nc" id="L692">			saveRequireTraceCube(fteRequirements, sp, spQueue);</span>
			// Then, we need to update the SP as there are two flags (were fte requirements manually edited and
			// is editing of FTE requirements enabled on the SP)
<span class="nc" id="L695">			spDAO.updateSchedulingPeriodsWithCampaignSIDs(Collections.singleton(sp));</span>
<span class="nc" id="L696">		} catch (BbmException e) {</span>
<span class="nc" id="L697">			handleException(e);</span>
<span class="nc" id="L698">			throw e;</span>
		} finally {
<span class="nc" id="L700">			spDAO.cleanUp();</span>
<span class="nc" id="L701">			methodFinish();</span>
<span class="nc" id="L702">		}</span>
<span class="nc" id="L703">	}</span>

	/**
	 * Calculates FTE Requirements for a single SP queue based on the forecast/service goals for that SP Queue.  Returns
	 * a RequireTraceCube containing the calculated FTE Requirements for that SPQueue which may differ from the stored
	 * FTE Requirements for the SPQueue if that SPQueue has had its FTE Requirements manually modified.
	 */
	public RequireTraceCube calculateUnmodifiedFteRequirementsForSPQueue(SchedulingPeriod sp, SPQueue spQueue) throws BbmException {
<span class="nc" id="L711">		methodStart(&quot;calculateUnmodifiedFteRequirementsForSPQueue&quot;, sp, spQueue);</span>

		try {
<span class="nc" id="L714">			return FteRequirementsTimeSeriesUtil.convertRequiredTimeSeriesToTraceCube(</span>
<span class="nc" id="L715">					calculateFteRequirementsForSPQueues(Collections.singleton(spQueue.getID()), null, true, true, true),</span>
<span class="nc" id="L716">					spQueue.getQueueID(), sp.getStartTime(), sp.getEndTime());</span>
<span class="nc" id="L717">		} catch (BbmException e) {</span>
<span class="nc" id="L718">			handleException(e);</span>
<span class="nc" id="L719">			throw e;</span>
		} finally {
<span class="nc" id="L721">			methodFinish();</span>
		}
	}

	/**
	 * Returns the FTE Requirements in a RequireTraceCube for the given campaign, queue,
	 * and media type within the start and end dates.
	 */
	public RequireTraceCube getFteRequirementsTraceCube(
			ID campaignId,
			ID queueId,
			ID mediaId,
			Date start,
			Date end) throws BbmFinderException, RemoteException, BbmTimeSeriesException {
<span class="fc" id="L735">		RequireTraceCube metaFteRequirements = new RequireTraceCube();</span>
<span class="fc" id="L736">    	RequireTraceCube result = null;</span>

    	Collection&lt;TraceCube&gt; fteRequirementsTimeSeries;

    	//If queueId == null, then a combined queue has been selected
<span class="fc bfc" id="L741" title="All 2 branches covered.">    	if (queueId != null) {</span>
<span class="fc" id="L742">    		fteRequirementsTimeSeries = timeSeriesManager.getRawMultipleQueuesTimeSeries(metaFteRequirements, campaignId,</span>
<span class="fc" id="L743">    			Collections.singletonList(queueId), start, end);</span>
    	} else {
<span class="fc" id="L745">    		fteRequirementsTimeSeries = timeSeriesManager.getRawCombinedQueuesTimeSeries(metaFteRequirements, campaignId,</span>
        		mediaId, start, end);
    	}

<span class="pc bpc" id="L749" title="1 of 2 branches missed.">    	if (fteRequirementsTimeSeries.size() == 0) {</span>
<span class="nc" id="L750">    		return createZeroFteRequirementsTraceCube(queueId, start, end);</span>
<span class="pc bpc" id="L751" title="1 of 2 branches missed.">    	} else if (fteRequirementsTimeSeries.size() &gt; 1) {</span>
<span class="nc" id="L752">    		RequireTraceCube[] fteReqArray = new RequireTraceCube[fteRequirementsTimeSeries.size()];</span>
<span class="nc" id="L753">    		fteRequirementsTimeSeries.toArray(fteReqArray);</span>
<span class="nc" id="L754">    		result = (RequireTraceCube)TraceOperator.combineQueue(fteReqArray, true,</span>
<span class="nc" id="L755">    				TraceOperatorAdapter.getQueueMediaMap(fteRequirementsTimeSeries));</span>
<span class="nc" id="L756">    	} else {</span>
<span class="fc" id="L757">        	RequireTraceCube[] results = new RequireTraceCube[1];</span>
<span class="fc" id="L758">        	fteRequirementsTimeSeries.toArray(results);</span>
<span class="fc" id="L759">        	result = results[0];</span>
    	}
<span class="fc" id="L761">    	TraceUtil.setUndefinedValuesToZero(result);</span>
<span class="fc" id="L762">    	return result;</span>
	}

    private static RequireTraceCube createZeroFteRequirementsTraceCube(ID queueId, Date start, Date end) throws BbmTimeSeriesException {
<span class="nc" id="L766">    	RequireTraceCube cube = new RequireTraceCube(queueId, start, end, RequireTraceCube.TYPES);</span>
<span class="nc" id="L767">    	TraceUtil.zeroOutTraceCubeValues(cube, RequireTraceCube.TYPES);</span>
<span class="nc" id="L768">    	return cube;</span>
    }

	/**
	 * Creates and returns a collection of RequiredTimeSeries objects, one for each day in the scheduling period.  The RequiredTimeSeries
	 * objects are populated from the data contained in the periodRequirements array.
	 * @param spShrinkage - A collection of SPShrinkage objects, one for each day in the Scheduling Period
	 * @param sp - The scheduling period for which we are calculating FTE Requirements
	 * @param timeZone - The time zone of the scheduling period
	 * @param spQueue - The spQueue of the scheduling period for which we are calculating FTE Requirements
	 * @param periodRequirements - Integer array of fte requirements data.  Each value in the array represents a 15-minute
	 * time interval of newly calculated FTE Requirements data for the SPQueue.  It contains FTE Requirements data for the entire Scheduling Period
	 * and is stored sequentially starting at the beginning of the scheduling period.
	 */
	private Collection&lt;RequiredTimeSeries&gt; createRequiredTimeSeries(Collection&lt;SPShrinkage&gt; spShrinkage, SchedulingPeriod sp,
			TimeZone timeZone, SPQueue spQueue, int[] periodRequirements) throws BbmCreateException {

<span class="fc" id="L785">		Collection&lt;RequiredTimeSeries&gt; retVal = new ArrayList&lt;RequiredTimeSeries&gt;();</span>

		//Once fte requirements have been calculated, create a RequiredTimeSeries for each day in the 
		//interval and initialize them with the calculated fte requirements for that day
<span class="fc" id="L789">		Calendar shrinkageStartDate = Calendar.getInstance(timeZone);</span>
<span class="fc" id="L790">		shrinkageStartDate.setTime(sp.getStartTime());</span>
<span class="fc" id="L791">		int dayIndex = 0;</span>
		//FIXME: this is a little hackish.  It is assumed that each SPShrinkage object in
		//the collection is associated to one day's worth of FTE Requirements data that needs
		//to be translated.
<span class="fc bfc" id="L795" title="All 2 branches covered.">		for (SPShrinkage sps : spShrinkage) {</span>
<span class="fc" id="L796">			Calendar shrinkageEndDate = Calendar.getInstance(timeZone);</span>
<span class="fc" id="L797">			shrinkageEndDate.setTime(shrinkageStartDate.getTime());</span>
<span class="fc" id="L798">			shrinkageEndDate.add(Calendar.DAY_OF_YEAR, 1);</span>
<span class="fc" id="L799">			int[] dayRequirements = Arrays.copyOfRange(periodRequirements, dayIndex * 96, (dayIndex + 1) * 96);</span>
<span class="fc" id="L800">			retVal.add(new RequiredTimeSeries(spQueue, shrinkageStartDate.getTime(), dayRequirements));</span>
<span class="fc" id="L801">			shrinkageStartDate = shrinkageEndDate;</span>
<span class="fc" id="L802">			dayIndex++;</span>
<span class="fc" id="L803">		}</span>

<span class="fc" id="L805">		return retVal;</span>
	}

	/**
	 * Returns a meta trace cube for the specified media type so that calls to get
	 * getRawMultipleQueuesTimeSeries or getRawCombinedQueuesTimeSeries will return the
	 * correct traces for the given media type.
	 */
	private ForecastTraceCube getForecastMetaTraceCubeForMediaType(MediaType mediaType) {
<span class="pc bpc" id="L814" title="3 of 6 branches missed.">			switch (mediaType) {</span>
			case IMMEDIATE:
<span class="fc" id="L816">				return new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
			case DEFERRED:
<span class="fc" id="L818">				return new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
			case OUTBOUND:
<span class="fc" id="L820">				return new ForecastTraceCube(new short[] {Trace.CRATE, Trace.RPCRATE, Trace.AHT});</span>
			case PROJECT:
<span class="nc" id="L822">				throw new UnsupportedOperationException(&quot;FteRequirementsManagerEJB.getForecastMetaTraceCubeForMediaType - Forecast data does not apply for FTE Requirements of Project media.&quot;);</span>
			case UNKNOWN:
<span class="nc" id="L824">				throw new UnsupportedOperationException(&quot;FteRequirementsManagerEJB.getForecastMetaTraceCubeForMediaType - Could not determine media type.&quot;);</span>
			default:
<span class="nc" id="L826">				throw new UnsupportedOperationException(&quot;FteRequirementsManagerEJB.getForecastMetaTraceCubeForMediaType - Could not determine media type.&quot;);</span>
		}
	}

	/**
	 * Returns the FTE Requirements in a set of RequireTraceCubes for the given SP, optionally only returning data for
	 * specific sp queues
	 *
	 * @param spID - a valid spID
	 * @param queueIDs - optional, used only if !isCombined, give list of queues to get data for; if not specified, uses all queues associated with sp
	 * @param startDate - optional, defaults to sp start date
	 * @param endDate - optional, defaults to sp end date
	 */
	public Collection&lt;RequireTraceCube&gt; getFteRequirementsTraceCubesForSP(ID spID, Collection&lt;ID&gt; queueIDs, Date startDate, Date endDate)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException {

<span class="fc" id="L842">		SchedulingPeriod sp = getSchedulingPeriod(spID);</span>
<span class="fc" id="L843">		ID campaignID = sp.getCampaignID();</span>
<span class="fc" id="L844">		Date startDt = startDate;</span>
<span class="fc" id="L845">		Date endDt = endDate;</span>
		
<span class="pc bpc" id="L847" title="1 of 2 branches missed.">		if (startDate == null) {</span>
<span class="fc" id="L848">			startDt = sp.getStartTime();</span>
		}
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">		if (endDate == null) {</span>
<span class="fc" id="L851">			endDt = sp.getEndTime();</span>
		}

<span class="fc" id="L854">		return getPerQueueRequireTraceCubes(sp, queueIDs, startDt, endDt, campaignID);</span>
	}

	/**
	 * Returns the combined FTE Requirements, per media, for the given SP, in a set of RequireTraceCubes
	 *
	 * @param spID - a valid sp SID
	 * @param mediaIDs - give list of medias to get data for
	 * @param startDate - optional, defaults to sp start date
	 * @param endDate - optional, defaults to sp end date
	 */
	public Collection&lt;RequireTraceCube&gt; getCombinedFteRequirementsTraceCubesForSP(ID spID, Collection&lt;ID&gt; mediaIDs, Date startDate, Date endDate)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException {

<span class="fc" id="L868">		SchedulingPeriod sp = getSchedulingPeriod(spID);</span>
<span class="fc" id="L869">		ID campaignID = sp.getCampaignID();</span>
<span class="fc" id="L870">		Date startDt = startDate;</span>
<span class="fc" id="L871">		Date endDt = endDate;</span>
		
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">		if (startDate == null) {</span>
<span class="fc" id="L874">			startDt = sp.getStartTime();</span>
		}
<span class="pc bpc" id="L876" title="1 of 2 branches missed.">		if (endDate == null) {</span>
<span class="fc" id="L877">			endDt = sp.getEndTime();</span>
		}

<span class="fc" id="L880">		return getCombinedSPRequireTraceCubes(campaignID, mediaIDs, startDt, endDt);</span>
	}

	/**
	 * Get the secheduling period for a given sp SID, if it is not null and is valid
	 */
	private SchedulingPeriod getSchedulingPeriod(ID spID) throws BbmFinderException, RemoteException {
<span class="pc bpc" id="L887" title="1 of 2 branches missed.">		if (spID == null) {</span>
<span class="nc" id="L888">			throw new UnsupportedOperationException(&quot;getFteRequirementsTraceCubesForSP - Must provide a valid SP ID&quot;);</span>
		}

<span class="fc" id="L891">		SchedulingPeriod sp = campaignManager.getSchedulingPeriodByID(spID);</span>
<span class="pc bpc" id="L892" title="1 of 2 branches missed.">		if (sp == null) {</span>
<span class="nc" id="L893">			throw new UnsupportedOperationException(&quot;getFteRequirementsTraceCubesForSP - Must provide a valid SP ID&quot;);</span>
		}

<span class="fc" id="L896">		return sp;</span>
	}

	/**
	 * Get a trace cube for each sp queue in sp (or the specified collection, if not null)
	 */
	private Collection&lt;RequireTraceCube&gt; getPerQueueRequireTraceCubes(SchedulingPeriod sp, Collection&lt;ID&gt; queueIDs, Date startDate, Date endDate, ID campaignID)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException {

<span class="fc" id="L905">		List&lt;RequireTraceCube&gt; retVal = new ArrayList&lt;RequireTraceCube&gt;();</span>
<span class="fc bfc" id="L906" title="All 2 branches covered.">		for (SPQueue spqueue : campaignManager.getSPQueuesBySPID(sp.getID())) {</span>
<span class="pc bpc" id="L907" title="4 of 6 branches missed.">			if (queueIDs == null || queueIDs.isEmpty() || queueIDs.contains(spqueue.getQueueID())) {</span>
<span class="fc" id="L908">				RequireTraceCube cube = getFteRequirementsTraceCube(campaignID, spqueue.getQueueID(), null, startDate, endDate);</span>
<span class="fc" id="L909">				retVal.add(cube);</span>
			}
<span class="fc" id="L911">		}</span>
<span class="fc" id="L912">		return retVal;</span>
	}

	/**
	 * Get a trace cube for the combined queue data for the specified sp, per media
	 */
	private Collection&lt;RequireTraceCube&gt; getCombinedSPRequireTraceCubes(ID campaignID, Collection&lt;ID&gt; mediaIDs, Date startDate, Date endDate)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException {

<span class="fc" id="L921">		List&lt;RequireTraceCube&gt; retVal = new ArrayList&lt;RequireTraceCube&gt;();</span>
<span class="pc bpc" id="L922" title="2 of 4 branches missed.">		if (mediaIDs == null || mediaIDs.isEmpty()) {</span>
<span class="nc" id="L923">			return retVal;</span>
		}

<span class="fc bfc" id="L926" title="All 2 branches covered.">		for (ID mediaID : mediaIDs) {</span>
<span class="fc" id="L927">			RequireTraceCube cube = getFteRequirementsTraceCube(campaignID, null, mediaID, startDate, endDate);</span>
<span class="fc" id="L928">			retVal.add(cube);</span>
<span class="fc" id="L929">		}</span>
<span class="fc" id="L930">		return retVal;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>