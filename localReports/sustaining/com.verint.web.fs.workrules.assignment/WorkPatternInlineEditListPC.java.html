<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkPatternInlineEditListPC.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.web.fs.workrules.assignment</a> &gt; <span class="el_source">WorkPatternInlineEditListPC.java</span></div><h1>WorkPatternInlineEditListPC.java</h1><pre class="source lang-java linenums">package com.verint.web.fs.workrules.assignment;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import javax.servlet.http.HttpServletRequest;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPatternFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.web.bbm.l10n.BbmWebBundleKey;
import com.bluepumpkin.web.bbm.people.profile.ProfileAdminPC;
import com.bluepumpkin.web.bbm.people.profile.ProfilePageModel;
import com.bluepumpkin.web.core.l10n.CoreWebBundleKey;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.verint.web.fs.widgets.IntegerDropDownSelection;
import com.verint.web.fs.workrules.OTExtensionListPopupPM;
import com.verint.web.fs.workrules.WorkRulesJSFileID;
import com.verint.web.fs.workrules.WorkRulesModelHandler;
import com.witness.web.uif.data.popup.PopupArgument;
import com.witness.web.uif.data.popup.PopupUtil;
import com.witness.web.uif.keys.ImageFileID;
import com.witness.web.uif.pagecomponent.DefaultMultiColumnNodeData;
import com.witness.web.uif.pagecomponent.MultiColumnNodeData;
import com.witness.web.uif.pagecomponent.list.InsertableMultiColListPC;
import com.witness.web.uif.pagecomponent.picker.date.DateRangePickerPC;
import com.witness.web.uif.pagecomponent.table.DefaultHeaderData;
import com.witness.web.uif.pagecomponent.table.TableHeaderPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarTextButton;
import com.witness.web.uif.pagemodel.WorkpaneMultiColPM;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.HtmlUtil;
import com.witness.web.uif.util.SortUtil;
import com.witness.web.uif.util.html.CSSUtil;
import com.witness.web.uif.util.js.JSUtil;
//TODO: Because of the similarity between this class and SkillsInlineEditListPC, it is desirable to move a good portion of
//  the logic into a base class.  Due to time constraints, this was not possible at time of creation.
public class WorkPatternInlineEditListPC extends EffectivityMultiColListPC {
	private static final long serialVersionUID = 1L;
	
	//key = employee ID, value = collection of work pattern assignments assigned to the employee in the view period
<span class="fc" id="L64">	private Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; assignmentMap = new HashMap&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt;();</span>
	//This is a collection of the assignments that are to be displayed in the list
	private Collection&lt;WorkResourceWorkPattern&gt; displayedAssignments;
	//key = workresourceworkpattern ID, value = associated workresourcecomplexworkrule
<span class="fc" id="L68">	private HashMap&lt;ID, WorkResourceWorkPattern&gt; modifiedAssignments =</span>
		new HashMap&lt;ID, WorkResourceWorkPattern&gt;();
	private Date viewStartDate;
	private Date viewEndDate;
	private SchedulingPeriod schedulingPeriod;
	private Campaign campaign;
	private boolean didTimePeriodChange;
<span class="fc" id="L75">	private StringBuffer jsInitCode = new StringBuffer();</span>
	private Collection&lt;ID&gt; selectedEmployeeIDs;
	private TimeZone optimizationTargetTimeZone;
	private Date timeZoneEffectiveDate;

	/**
	 * Constructs a list which contains work pattern name, effective dates (rendered as start / end date pickers with a popup button
	 * for changing the dates), and preferences drop down.  Intended to be used to assign work patterns to employees and to
	 * modify previous assignments.
	 * @param context - the request context
	 * @param name - name of this component
	 * @param assignmentMap - key = employee ID, value = collection of work pattern assignments associated to the employee
	 * @param viewStartDate - Start date of the view period.  Assumes that the time component of the start date is adjusted to the
	 * day boundary of the campaign, if in campaign mode, otherwise it is at midnight GMT. FIXME: should be a local date
	 * @param viewEndDate - End date of the view period.  Assumes that the time component of the end date is adjusted to the
	 * day boundary of the campaign, if in campaign mode, otherwise it is at midnight GMT. FIXME: should be a local date
	 * @param schedulingPeriod - Selected scheduling period value object, if in campaign mode (can be null otherwise).
	 * @param campaign - Selected campaign value object, if in campaign mode (can be null otherwise).
	 * @param didTimePeriodChange - If the viewing time period changed (and hence we have a postback) we need to indicate this
	 * to the component so that it will avoid processing the updated skills information.
	 * @param selectedEmployeeIDs - The list of employees that we are currently editing skill assignments for.
	 * @param optimizationTargetTimeZone - The time zone of the either the selected org or campaign
	 * @param timeZoneEffectiveDate - The date for which the optimizationTargetTimeZone applies to the selected org/campaign
	 */
	public WorkPatternInlineEditListPC(RequestContext context, String name, Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; assignmentMap, 
			Date viewStartDate, Date viewEndDate, SchedulingPeriod schedulingPeriod, Campaign campaign, boolean didTimePeriodChange,
			Collection&lt;ID&gt; selectedEmployeeIDs, TimeZone optimizationTargetTimeZone, Date timeZoneEffectiveDate) {
<span class="fc" id="L102">		super(context);</span>
		
<span class="fc" id="L104">		setName(name);</span>
<span class="fc" id="L105">		this.assignmentMap = assignmentMap;</span>
<span class="fc" id="L106">		this.viewStartDate = viewStartDate;</span>
<span class="fc" id="L107">		this.viewEndDate = viewEndDate;</span>
<span class="fc" id="L108">		this.schedulingPeriod = schedulingPeriod;</span>
<span class="fc" id="L109">		this.campaign = campaign;</span>
<span class="fc" id="L110">		this.didTimePeriodChange = didTimePeriodChange;</span>
<span class="fc" id="L111">		this.selectedEmployeeIDs = selectedEmployeeIDs;</span>
<span class="fc" id="L112">		this.optimizationTargetTimeZone = optimizationTargetTimeZone;</span>
<span class="fc" id="L113">		this.timeZoneEffectiveDate = timeZoneEffectiveDate;</span>
		
<span class="fc" id="L115">		ToolbarPC toolbar = new ToolbarPC(m_context);</span>
<span class="fc" id="L116">		toolbar.setName(&quot;workPatternToolbar&quot;);</span>
<span class="fc" id="L117">		ToolbarTextButton addButton = toolbar.createPopupWindowButton(WorkPatternListPopupPM.POPUP_ID,</span>
<span class="fc" id="L118">				m_localizer.i18n(CoreWebBundleKey.BUNDLE_NAME, CoreWebBundleKey.TOOLBAR_ADD), true);</span>
<span class="fc" id="L119">		addButton.setAttribute(&quot;viewStartDate&quot;, Long.toString(viewStartDate.getTime()));</span>
<span class="fc" id="L120">		addButton.setAttribute(&quot;viewEndDate&quot;, Long.toString(viewEndDate.getTime()));</span>
<span class="pc bpc" id="L121" title="1 of 2 branches missed.">		if (schedulingPeriod != null) {</span>
<span class="nc" id="L122">			addButton.setAttribute(&quot;schedulingPeriodID&quot;, schedulingPeriod.getID().toString());</span>
		}
<span class="fc" id="L124">		addButton.setAttribute(&quot;onClick&quot;, getFilterJSForAddButton(getName(), toolbar.getName(),</span>
				WorkPatternListPopupPM.POPUP_ID));
<span class="fc" id="L126">		toolbar.addToolbarElement(addButton);</span>
<span class="fc" id="L127">		ToolbarTextButton removeButton = new ToolbarTextButton(toolbar, &quot;removeWorkPattern&quot;,</span>
<span class="fc" id="L128">				m_localizer.i18n(CoreWebBundleKey.BUNDLE_NAME, CoreWebBundleKey.TOOLBAR_REMOVE),</span>
				InsertableMultiColListPC.REMOVE_ROW_BUTTON_ACTION, ToolbarTextButton.BLUE_BUTTON, false);
<span class="fc" id="L130">		toolbar.addToolbarElement(removeButton);</span>

<span class="fc" id="L132">		setIsBorderEnabled(true);</span>
<span class="fc" id="L133">		setToolbar(toolbar);</span>
		
<span class="fc" id="L135">		addPopupArgs(WorkPatternListPopupPM.POPUP_ID, WorkPatternListPopupPM.FORM_ACTION, &quot;&quot;,</span>
				WorkPatternListPopupPM.POPUP_ARGS, &quot;1000,600,ctr,ctr&quot;, true, 1);

		//If we don't have any rows for the list on initial load, we still need to get the required
		// js files from the inline components that may be added dynamically
<span class="fc" id="L140">		IntegerDropDownSelection dummyIntegerSelectionPC = new IntegerDropDownSelection(getRequestContext(),</span>
<span class="fc" id="L141">			getName() + &quot;_dummyIntegerSelectionPC&quot;, 0, 0);</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">		for (String js : dummyIntegerSelectionPC.getRequireJavaScriptFiles()) {</span>
<span class="fc" id="L143">			addRequiredJavaScriptFile(js);</span>
<span class="fc" id="L144">		}</span>

<span class="fc" id="L146">		displayedAssignments = getWorkPatternAssignmentsToDisplay();</span>

<span class="fc" id="L148">		extractParameters(m_context.getRequest());</span>
<span class="fc" id="L149">		addRequiredJavaScriptFile(WorkRulesJSFileID.WORK_RULES_UTIL);</span>
<span class="fc" id="L150">	}</span>

	public String getJavaScriptInitCode() {
<span class="fc" id="L153">		StringBuffer js = new StringBuffer(super.getJavaScriptInitCode());</span>
<span class="pc bpc" id="L154" title="1 of 2 branches missed.">		if (getToolbar() != null) {</span>
<span class="fc" id="L155">			js.append(&quot;\n&quot;).append(getName()).append(&quot;.setToolbar(&quot;).append(getToolbar().getName()).append(&quot;);&quot;);</span>
<span class="fc" id="L156">			js.append(&quot;\n&quot;).append(getName()).append(&quot;.addButtonEnableAttribute('isDeleteable', 'removeWorkPattern');\n&quot;);</span>
		}
<span class="pc bpc" id="L158" title="1 of 2 branches missed.">		if (schedulingPeriod != null) js.append(getDateSnapOnValueChangeJS());</span>
<span class="fc" id="L159">		return js.toString();</span>
	}
	
<span class="fc" id="L162">	private boolean isHeaderInited = false;</span>
	private void initHeader() {
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">		if (isHeaderInited) return;</span>
<span class="fc" id="L165">		isHeaderInited = true;</span>
		
<span class="fc" id="L167">		TableHeaderPC header = getHeader();</span>
<span class="fc" id="L168">		Localizer localizer = m_context.getLocalizer();</span>

<span class="fc" id="L170">		DefaultHeaderData dhd = new DefaultHeaderData(FsWebBundleKey.FS_WORK_PATTERN,</span>
<span class="fc" id="L171">				localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.FS_WORK_PATTERN));</span>
<span class="fc" id="L172">		dhd.addImageButton(getInfoButtonPopupImage(), getInfoButtonPopupCaption(), getInfoButtonPopupJS());</span>
<span class="fc" id="L173">		dhd.setSortable(false);</span>
<span class="fc" id="L174">		header.addColumnHeaderData(dhd);</span>
<span class="fc" id="L175">		header.addColumnHeaderData(FsWebBundleKey.FS_START_DATE_END_DATE, localizer.i18n(FsWebBundleKey.BUNDLE_NAME,</span>
				FsWebBundleKey.FS_START_DATE_END_DATE));
<span class="fc" id="L177">		header.addColumnHeaderData(FsWebBundleKey.FS_WORK_PATTERN_PREFERENCES, localizer.i18n(FsWebBundleKey.BUNDLE_NAME,</span>
				FsWebBundleKey.FS_WORK_PATTERN_PREFERENCES));
<span class="fc" id="L179">	}</span>
	
	private String getInfoButtonPopupImage() {
<span class="fc" id="L182">		return ImageFileID.TOOLTIP_BUTTON;</span>
	}
	
	private String getInfoButtonPopupCaption() {
<span class="fc" id="L186">		return m_localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.FS_VIEW_WORK_PATTERN_DETAILS);</span>
	}
	
	private String getInfoButtonPopupJS() {
<span class="pc bpc" id="L190" title="1 of 2 branches missed.">		String optimizationTargetTimeZoneStr = optimizationTargetTimeZone != null ? optimizationTargetTimeZone.getID() : &quot;&quot;;</span>
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">		long tzDateMillis = timeZoneEffectiveDate != null ? timeZoneEffectiveDate.getTime() : new Date().getTime();</span>
<span class="fc" id="L192">		return &quot;WorkRulesUtil.handleInfoPopup(this, &quot; + getName() + &quot;,&quot; + getHeader().getName() + &quot;,'&quot; +</span>
			WorkPatternListPopupPM.POPUP_ID + &quot;','&quot; + WorkPatternListPopupPM.POPUP_ARG_WORK_PATTERN_ID + &quot;','&quot; +
			WorkPatternListPopupPM.POPUP_ARG_SELECTED_IDS + &quot;','&quot; + WorkPatternListPopupPM.POPUP_ARG_IS_INFO_POPUP + &quot;,&quot; +
			OTExtensionListPopupPM.ARG_TIME_ZONE + &quot;,&quot; +
			OTExtensionListPopupPM.ARG_TIME_ZONE_DATE + &quot;','true,&quot; +
			optimizationTargetTimeZoneStr + &quot;,&quot; + tzDateMillis + &quot;');&quot;;
	}
	
<span class="fc" id="L200">	private boolean isRowsInited = false;</span>
	private void initRows(boolean rebuildDisplayedAssignmentList) {
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">		if (isRowsInited &amp;&amp; !rebuildDisplayedAssignmentList) return;</span>
<span class="fc" id="L203">		isRowsInited = true;</span>
		
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (rebuildDisplayedAssignmentList) {</span>
<span class="fc" id="L206">			super.getListModel().clear();</span>
<span class="fc" id="L207">			displayedAssignments = getWorkPatternAssignmentsToDisplay();</span>
		}
		
<span class="fc" id="L210">		List&lt;MultiColumnNodeData&gt; rows = super.getListModel();</span>

<span class="fc" id="L212">		ArrayList&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L213" title="All 2 branches covered.">		for (WorkResourceWorkPattern wrwp : displayedAssignments) {		</span>
<span class="fc" id="L214">			rows.add(getNodeData(wrwp, false));</span>
<span class="fc" id="L215">			ids.add(wrwp.getWorkPatternSID());</span>
<span class="fc" id="L216">		}</span>
		
		//Sort the rows by item name
<span class="fc" id="L219">		SortUtil.sort(rows, getHeader().getColumnIndexByName(FsWebBundleKey.FS_WORK_PATTERN), true, m_context.getLocalizer());</span>
		
<span class="fc" id="L221">		this.setRowIDs(StringUtil.createDelimitedString(ids.toArray(new ID[ids.size()])));</span>
<span class="fc" id="L222">	}</span>
	
	public String getRowHtml(WorkResourceWorkPattern wrwp) {
<span class="fc" id="L225">		StringBuffer html = new StringBuffer();</span>
<span class="fc" id="L226">		super.appendHtmlRowData(html, getNodeData(wrwp, true), 0, 0);</span>
<span class="fc" id="L227">		html.append(HtmlUtil.makeHiddenInput(getPopupRadioOptionFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
<span class="fc" id="L228">		html.append(HtmlUtil.makeHiddenInput(getEditedStartDateFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
<span class="fc" id="L229">		html.append(HtmlUtil.makeHiddenInput(getEditedEndDateFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
		
		//Create the javascript to instantiate the objects for the inline controls
<span class="fc" id="L232">		html.append(HtmlUtil.jsTag(jsInitCode.toString(), false));</span>
<span class="fc" id="L233">		jsInitCode.setLength(0);</span>
		
<span class="fc" id="L235">		return html.toString();</span>
	}
	
	protected DefaultMultiColumnNodeData getNodeData(WorkResourceWorkPattern wrwp, boolean isAjaxRequest) {
<span class="fc" id="L239">		DefaultMultiColumnNodeData nodeData = new DefaultMultiColumnNodeData(</span>
<span class="fc" id="L240">				wrwp.getWorkPatternSID().toString());</span>
		
		//Name
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">		if (wrwp.isMultiEditCommon()) {</span>
<span class="fc" id="L244">			nodeData.add(wrwp.getWorkPattern().getName());</span>
		} else {
<span class="nc" id="L246">			nodeData.add(MULTI_VALUE_DATA + wrwp.getWorkPattern().getName());</span>
		}
		
		//Preferences
<span class="fc" id="L250">		IntegerDropDownSelection preferencesDDPC = getPreferencesDDPC(wrwp);</span>
<span class="fc bfc" id="L251" title="All 2 branches covered.">		if (isAjaxRequest) jsInitCode.append(preferencesDDPC.getJavaScriptInitCode());</span>
<span class="fc" id="L252">		addChildComponent(preferencesDDPC);</span>
		
		//Start / End Date control
<span class="fc" id="L255">		nodeData.add(getEffectiveDateControl(wrwp, preferencesDDPC));</span>
<span class="fc" id="L256">		nodeData.add(preferencesDDPC);</span>
		
<span class="fc" id="L258">		setRowAttributes(nodeData, wrwp);</span>
<span class="fc" id="L259">		return nodeData;</span>
	}
	
	protected void setRowAttributes(DefaultMultiColumnNodeData mcnd, WorkResourceWorkPattern wrwp) {
<span class="pc bpc" id="L263" title="1 of 2 branches missed.">		if (!wrwp.isMultiEditCommon()) mcnd.setNodeAttribute(ROW_ATTRIBUTE_MULTI_EDIT_NOT_COMMON, String.valueOf(true));</span>
<span class="fc" id="L264">		mcnd.setNodeAttribute(WorkpaneMultiColPM.IS_DELETEABLE, String.valueOf(true));</span>
<span class="fc" id="L265">		mcnd.setNodeAttribute(WorkPatternListPopupPM.POPUP_ARG_WORK_PATTERN_ID, wrwp.getWorkPattern().getID().toString());</span>
<span class="fc" id="L266">	}</span>
	
	/**
	 * Returns the preferences drop down control as well as extracts the params from it if this happens to be a postback
	 */
	private IntegerDropDownSelection getPreferencesDDPC(WorkResourceWorkPattern wrwp) {
<span class="fc" id="L272">		IntegerDropDownSelection preferencesDDPC = new IntegerDropDownSelection(</span>
<span class="fc" id="L273">				getRequestContext(), getPreferenceDDPCName(getName(), wrwp.getWorkPatternSID()),</span>
				1, 100);

<span class="pc bpc" id="L276" title="1 of 2 branches missed.">		if (isPreferenceMultiEdit(wrwp)) {</span>
<span class="nc" id="L277">			preferencesDDPC.setMultiEdit(true);</span>
		}
		
<span class="fc" id="L280">		preferencesDDPC.extractParameters(getRequestContext().getRequest());</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		if (preferencesDDPC.isEdited()) {</span>
<span class="fc" id="L282">			wrwp.setPreferenceModified(true);</span>
<span class="fc" id="L283">			preferencesDDPC.setMultiEdit(false);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">			if (modifiedAssignments.containsKey(wrwp.getID())) {</span>
<span class="nc" id="L285">				modifiedAssignments.get(wrwp.getID()).setPreference(</span>
<span class="nc" id="L286">						preferencesDDPC.getSelections().iterator().next());</span>
			} else {
<span class="fc" id="L288">				wrwp.setPreference(preferencesDDPC.getSelections().iterator().next());</span>
				//Only add to modified assignments if this is not a newly added assignment
<span class="fc bfc" id="L290" title="All 2 branches covered.">				if (wrwp.getID() != null) {</span>
<span class="fc" id="L291">					modifiedAssignments.put(wrwp.getID(), wrwp);</span>
				}
			}
		} else {
<span class="fc" id="L295">			preferencesDDPC.setSelectedIDs(Collections.singleton(Integer.toString(wrwp.getPreference())));			</span>
		}
		
		//If we are in campaign mode (i.e. have a scheduling period), then we need to force the
		//effective dates to snap to the SP view period when the drop down is changed.
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">		if (schedulingPeriod != null) {</span>
			//Check that the function exists before calling it.  The snapWorkPatternEffectiveDatesToViewPeriod
			//function will not be in scope for newly added work patterns, but in this case they will already
			//be snapped to the view date range so we won't need to call it for these ones.
<span class="nc" id="L304">			preferencesDDPC.setOnChangeJS(&quot;if(typeof snapWorkPatternEffectiveDatesToViewPeriod == 'function') {&quot; +</span>
					&quot;snapWorkPatternEffectiveDatesToViewPeriod('&quot; +
<span class="nc" id="L306">					getStartDatePCName(getName(), wrwp.getWorkPatternSID()) + &quot;','&quot; +</span>
<span class="nc" id="L307">					getEndDatePCName(getName(), wrwp.getWorkPatternSID()) + &quot;'); }&quot;);</span>
		}
<span class="fc" id="L309">		return preferencesDDPC;</span>
	}
	
	/**
	 * Returns the effective date control as well as extracts the params from it if this happens to be a postback
	 */
	private String getEffectiveDateControl(WorkResourceWorkPattern wrwp, IntegerDropDownSelection preferenceDDPC) {
<span class="fc" id="L316">		StringBuffer sb = new StringBuffer();</span>
<span class="fc" id="L317">		DateRangePickerPC dateRangePC = new DateRangePickerPC(getRequestContext(),</span>
<span class="fc" id="L318">				getDateRangePCName(getName(), wrwp.getWorkPatternSID()));</span>
<span class="fc" id="L319">		dateRangePC.setTimeZone(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L320">		dateRangePC.setIsMultiValueSupported(true);</span>
<span class="fc" id="L321">		dateRangePC.setIsControlEnabled(false);</span>
<span class="fc" id="L322">		dateRangePC.getEndDatePickerPC().setIsDateValueInclusive(false);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">		if (isStartDateMultiEdit(wrwp)) {</span>
<span class="fc" id="L324">			dateRangePC.getStartDatePickerPC().setIsMultiValue(true);</span>
		} else {
<span class="fc" id="L326">			dateRangePC.getStartDatePickerPC().setDate(wrwp.getLocalStartTime());</span>
		}
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">		if (isEndDateMultiEdit(wrwp)) {</span>
<span class="nc" id="L329">			dateRangePC.getEndDatePickerPC().setIsMultiValue(true);</span>
		} else {
<span class="fc bfc" id="L331" title="All 2 branches covered.">			if (wrwp.getLocalEndTime() != null) {</span>
<span class="fc" id="L332">				LocalDate endDateDisplay = new LocalDate(wrwp.getLocalEndTime());</span>
<span class="fc" id="L333">				adjustEndDateForDisplay(endDateDisplay);</span>
<span class="fc" id="L334">				dateRangePC.getEndDatePickerPC().setDate(endDateDisplay);</span>
			}
		}
<span class="fc" id="L337">		dateRangePC.getEndDatePickerPC().setIsDateValueOptional(true);</span>
		
<span class="fc bfc" id="L339" title="All 4 branches covered.">		if (preferenceDDPC.isEdited() || wrwp.getLocalStartTime() == null) {</span>
<span class="fc" id="L340">			dateRangePC.extractParameters(getRequestContext().getRequest());</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">			if (dateRangePC.getStartDatePickerPC().getLocalDate() != null) {</span>
<span class="nc" id="L342">				wrwp.setLocalStartTime(dateRangePC.getStartDatePickerPC().getLocalDate());</span>
				//If after extracting the params the date is not null, this means a date has been input and it is no longer multi-value.
				//This should probably be done in the date picker itself but I don't know what the ramifications would be of changing it there.
<span class="nc" id="L345">				dateRangePC.getStartDatePickerPC().setIsMultiValue(false);</span>
			}
<span class="pc bpc" id="L347" title="1 of 2 branches missed.">			if (dateRangePC.getEndDatePickerPC().getLocalDate() != null) {</span>
<span class="nc" id="L348">				wrwp.setLocalEndTime(dateRangePC.getEndDatePickerPC().getLocalDate());</span>
<span class="nc" id="L349">				dateRangePC.getEndDatePickerPC().setIsMultiValue(false);</span>
			} else {
<span class="fc" id="L351">				wrwp.setLocalEndTime(null);</span>
			}
<span class="pc bpc" id="L353" title="1 of 2 branches missed.">			if (dateRangePC.getEndDatePickerPC().isMultiValue()) {</span>
<span class="nc" id="L354">				wrwp.setFieldMultiValue(WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_ENDTIME);</span>
			}
<span class="fc" id="L356">			preferenceDDPC.setIsEdited(false);</span>
		}
<span class="fc" id="L358">		sb.append(makePopupEffDateBtn(wrwp, preferenceDDPC));</span>
<span class="fc" id="L359">		sb.append(dateRangePC.getHtmlDisplay());</span>
<span class="fc" id="L360">		return sb.toString();</span>
	}
	
	public String getHtmlDisplay() {
<span class="fc" id="L364">		StringBuffer html = new StringBuffer();</span>
<span class="fc" id="L365">		html.append(super.getHtmlDisplay());</span>
<span class="fc bfc" id="L366" title="All 2 branches covered.">		for (WorkResourceWorkPattern wrwp : displayedAssignments) {</span>
<span class="fc" id="L367">			html.append(HtmlUtil.makeHiddenInput(getPopupRadioOptionFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
<span class="fc" id="L368">			html.append(HtmlUtil.makeHiddenInput(getEditedStartDateFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
<span class="fc" id="L369">			html.append(HtmlUtil.makeHiddenInput(getEditedEndDateFN(getName(), wrwp.getWorkPatternSID()), &quot;&quot;));</span>
<span class="fc" id="L370">		}</span>
<span class="fc" id="L371">		return html.toString();</span>
	}
	
<span class="fc" id="L374">	private boolean isExtracted = false;</span>
	@Override
	public boolean extractParameters(HttpServletRequest request) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">		if (isExtracted) return true;</span>
<span class="fc" id="L378">		isExtracted = true;</span>
<span class="fc" id="L379">		boolean retVal = true;</span>
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">		if (didTimePeriodChange == false) {</span>
<span class="fc" id="L381">			retVal = super.extractParameters(request);</span>
		}

<span class="pc bpc" id="L384" title="1 of 2 branches missed.">		for (ID removedID : getRemovedRowIDCollection()) {</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			for (WorkResourceWorkPattern wrwp : displayedAssignments) {</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">				if (removedID.equals(wrwp.getWorkPatternSID())) {</span>
<span class="nc" id="L387">					displayedAssignments.remove(wrwp);</span>
<span class="nc" id="L388">					break;</span>
				}
<span class="nc" id="L390">			}</span>
<span class="nc" id="L391">		}</span>

		// added
		try {
<span class="fc" id="L395">			Collection&lt;ID&gt; addedIDs = getAddedRowIDCollection();</span>
			Collection&lt;ShiftPattern&gt; addedShiftPatterns;
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">			if (addedIDs != null &amp;&amp; addedIDs.size() &gt; 0) {</span>
<span class="fc" id="L398">				addedShiftPatterns = WorkRulesModelHandler.getShiftPatterns(m_context, addedIDs);</span>
<span class="fc bfc" id="L399" title="All 2 branches covered.">				for (ShiftPattern shiftPattern : addedShiftPatterns) {</span>
<span class="fc" id="L400">					removeAssignmentFromList(shiftPattern.getID());		//we want to remove any existing assignments with the same ID as the newly added ones will trump these</span>
<span class="fc" id="L401">					WorkResourceWorkPattern wrwp = new WorkResourceWorkPattern();</span>
					//Set the selected employees here because we will eventually be sending these IDs to the
					//  effectivity popup window so we can view employee history
<span class="fc" id="L404">					wrwp.setMultiEditIDs(selectedEmployeeIDs);</span>
<span class="fc" id="L405">					wrwp.setMultiEditCommon(true);</span>
<span class="fc" id="L406">					wrwp.setWorkPatternSID(shiftPattern.getID());</span>
<span class="fc" id="L407">					wrwp.setWorkPatternID(shiftPattern.getDEID());</span>
<span class="fc" id="L408">					wrwp.setWorkPattern(shiftPattern);</span>

<span class="fc" id="L410">					wrwp.setPreference(1);</span>
<span class="fc" id="L411">					displayedAssignments.add(wrwp); // This will be updated in the initRows method call below</span>
<span class="fc" id="L412">				}</span>
			}
<span class="nc" id="L414">		} catch (Exception ex) {</span>
<span class="nc" id="L415">			handleUnableToLoadDataError(log, ex);</span>
<span class="fc" id="L416">		}</span>

<span class="fc" id="L418">		initHeader();</span>
<span class="fc" id="L419">		initRows(false);</span>
		
<span class="fc" id="L421">		return retVal;</span>
	}
	
	/**
	 * Removes a work resource work pattern from the list of assignments with the given work pattern id
	 */
	private void removeAssignmentFromList(ID workPatternID) {
<span class="fc bfc" id="L428" title="All 2 branches covered.">		for (Iterator&lt;WorkResourceWorkPattern&gt; iter = displayedAssignments.iterator(); iter.hasNext();) {</span>
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">			if (iter.next().getWorkPatternSID().equals(workPatternID)) {</span>
<span class="nc" id="L430">				iter.remove();</span>
<span class="nc" id="L431">				break;</span>
			}
		}
<span class="fc" id="L434">	}</span>
	
	private String makePopupEffDateBtn(WorkResourceWorkPattern wrwp, IntegerDropDownSelection preferenceDDPC) {
<span class="fc" id="L437">		StringBuffer sb = new StringBuffer();</span>
		
<span class="fc" id="L439">		sb.append(HtmlUtil.imageTag(ImageFileID.EDIT, ImageFileID.EDIT_WIDTH,</span>
<span class="fc" id="L440">				ImageFileID.EDIT_HEIGHT, getLocalizer().i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.EDIT),</span>
				false))
<span class="fc" id="L442">		.append(&quot; onClick=\&quot;&quot;).append(getToolbar().getName()).append(&quot;.onSelect('&quot;)</span>
<span class="fc" id="L443">		.append(getEffectivityPopupID(getName(), wrwp.getWorkPatternSID())).append(&quot;',this)\&quot; &quot;).append(&quot;actionType=\&quot;POPUP_WINDOW_TYPE\&quot;&quot;);</span>

<span class="fc" id="L445">		sb.append(WorkPatternEffectivityPopupPM.ARG_EMPLOYEE_IDS).append(&quot;=\&quot;&quot;).append(</span>
<span class="fc" id="L446">				wrwp.getMultiEditIDsInString()).append(&quot;\&quot; &quot;);		</span>
<span class="fc" id="L447">		sb.append(WorkPatternEffectivityPopupPM.ARG_PREFERENCE_DD_FN).append(&quot;=\&quot;&quot;).append(</span>
<span class="fc" id="L448">				preferenceDDPC.getInputName()).append(&quot;\&quot; &quot;);</span>
<span class="fc" id="L449">		sb.append(WorkPatternEffectivityPopupPM.ARG_WORK_PATTERN_ID).append(&quot;=\&quot;&quot;).append(</span>
<span class="fc" id="L450">				wrwp.getWorkPatternSID()).append(&quot;\&quot; &quot;);</span>
<span class="pc bpc" id="L451" title="1 of 2 branches missed.">		if (schedulingPeriod != null) {</span>
<span class="nc" id="L452">			sb.append(WorkPatternEffectivityPopupPM.ARG_SCHEDULING_PERIOD_ID).append(&quot;=\&quot;&quot;).append(</span>
<span class="nc" id="L453">					schedulingPeriod.getID()).append(&quot;\&quot; &quot;);</span>
		}
		
		//Dates
<span class="fc" id="L457">		LocalDate viewEndLocalDate = new LocalDate(viewEndDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L458">		viewEndLocalDate.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="fc" id="L459">		sb.append(WorkPatternEffectivityPopupPM.ARG_VIEW_END_DATE).append(&quot;=\&quot;&quot;).append(viewEndLocalDate.getTime(TimeZoneUtil.GMT_TIMEZONE).getTime()).append(&quot;\&quot; &quot;);</span>
		//Use the wrwp start date if it isn't null.  In multi-edit scenarios it will be null,
		//  so we will use the viewStartDate in those cases.
<span class="fc bfc" id="L462" title="All 2 branches covered.">		if (wrwp.getLocalStartTime() != null) {</span>
<span class="fc" id="L463">			sb.append(WorkPatternEffectivityPopupPM.ARG_CUR_PERIOD_START_DATE).append(&quot;=\&quot;&quot;).append(</span>
<span class="fc" id="L464">					wrwp.getLocalStartTime().getTime(TimeZoneUtil.GMT_TIMEZONE).getTime()).append(&quot;\&quot; &quot;);</span>
		} else {
<span class="fc" id="L466">			sb.append(WorkPatternEffectivityPopupPM.ARG_CUR_PERIOD_START_DATE).append(&quot;=\&quot;&quot;).append(viewStartDate.getTime()).append(&quot;\&quot; &quot;);</span>
		}
<span class="fc bfc" id="L468" title="All 2 branches covered.">		if (wrwp.getLocalEndTime() != null) {</span>
<span class="fc" id="L469">			LocalDate curPeriodEndLocalDate = new LocalDate(wrwp.getLocalEndTime());</span>
<span class="fc" id="L470">			curPeriodEndLocalDate.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="fc" id="L471">			sb.append(WorkPatternEffectivityPopupPM.ARG_CUR_PERIOD_END_DATE).append(&quot;=\&quot;&quot;).append(</span>
<span class="fc" id="L472">					curPeriodEndLocalDate.getTime(TimeZoneUtil.GMT_TIMEZONE).getTime()).append(&quot;\&quot; &quot;);</span>
		}
<span class="fc" id="L474">		SimpleDateFormat sdf = new SimpleDateFormat(m_context.getLocalizer().getDateInputFormat(), m_context.getLocalizer().getLocaleContext().getRegionalFormatLocale());</span>
<span class="fc" id="L475">		sb.append(ProfilePageModel.SHOW_AS_DATE_FN).append(&quot;=\&quot;&quot;).append(sdf.format(viewStartDate)).append(&quot;\&quot; &quot;);</span>
<span class="fc bfc" id="L476" title="All 2 branches covered.">		if (wrwp.getLocalStartTime() != null) {</span>
<span class="fc" id="L477">			sb.append(ProfileAdminPC.EFF_START_DATE_FN).append(&quot;=\&quot;&quot;).append(wrwp.getLocalStartTime().getTime(</span>
<span class="fc" id="L478">					TimeZoneUtil.GMT_TIMEZONE).getTime()).append(&quot;\&quot; &quot;);</span>
		} else {
<span class="fc" id="L480">			sb.append(ProfileAdminPC.EFF_START_DATE_FN).append(&quot;=\&quot;&quot;).append(viewStartDate.getTime()).append(&quot;\&quot; &quot;);</span>
		}
		
<span class="fc" id="L483">		sb.append(WorkPatternEffectivityPopupPM.ARG_PARENT_TABLE_NAME).append(&quot;=\&quot;&quot;).append(getName()).append(&quot;\&quot; &quot;);</span>
			
<span class="fc" id="L485">		sb.append(&quot;border=\&quot;0\&quot; align=\&quot;absmiddle\&quot; style=\&quot;&quot;).append(</span>
<span class="fc" id="L486">				CSSUtil.STYLE_CLICKABLE).append(&quot;\&quot;&gt;&quot;);</span>
		
<span class="fc" id="L488">		PopupArgument popupArg = addPopupArgs(getEffectivityPopupID(getName(), wrwp.getWorkPatternSID()), WorkPatternEffectivityPopupPM.FORM_ACTION,</span>
<span class="fc" id="L489">				getPopupRadioOptionFN(getName(), wrwp.getWorkPatternSID()) + &quot;,&quot; +</span>
<span class="fc" id="L490">				getEditedStartDateFN(getName(), wrwp.getWorkPatternSID()) + &quot;,&quot; +</span>
<span class="fc" id="L491">				getEditedEndDateFN(getName(), wrwp.getWorkPatternSID()) + &quot;,&quot; +</span>
<span class="fc" id="L492">				preferenceDDPC.getInputName(),</span>
				WorkPatternEffectivityPopupPM.POPUP_ARGS + &quot;,&quot; + ProfilePageModel.SHOW_AS_DATE_FN + &quot;,&quot; +
				ProfileAdminPC.EFF_START_DATE_FN + &quot;,&quot; + ProfileAdminPC.EFF_END_DATE_FN,
				&quot;650,500,ctr,ctr&quot;, true, 1);
<span class="fc" id="L496">		jsInitCode.append(PopupUtil.getJSForPopupArg(popupArg));</span>
		
<span class="fc" id="L498">		return sb.toString();</span>
	}
	
	private static String getPCNamePrefix(String listName, ID workPatternID) {
<span class="fc" id="L502">		return listName + workPatternID.toString();</span>
	}
	
	private static String getDateRangePCName(String listName, ID workPatternID) {
<span class="fc" id="L506">		return JSUtil.getJSSuffix(getPCNamePrefix(listName, workPatternID) + &quot;_dateRangePC&quot;);</span>
	}
	
	public static String getPreferenceDDPCName(String listName, ID workPatternID) {
<span class="fc" id="L510">		return JSUtil.getJSSuffix(getPCNamePrefix(listName, workPatternID) + &quot;_preferencesDDPC&quot;);</span>
	}
	
	public static String getStartDatePCName(String listName, ID workPatternID) {
<span class="nc" id="L514">		return DateRangePickerPC.createStartDateFN(getDateRangePCName(listName, workPatternID));</span>
	}
	
	public static String getEndDatePCName(String listName, ID workPatternID) {
<span class="nc" id="L518">		return DateRangePickerPC.createEndDateFN(getDateRangePCName(listName, workPatternID));</span>
	}
	
	public static String getPopupRadioOptionFN(String listName, ID workPatternID) {
<span class="fc" id="L522">		return listName + workPatternID.toString() + &quot;_radioOption&quot;;</span>
	}
	
	public static String getEditedStartDateFN(String listName, ID workPatternID) {
<span class="fc" id="L526">		return listName + workPatternID.toString() + &quot;_editedStartDateFN&quot;;</span>
	}
	
	public static String getEditedEndDateFN(String listName, ID workPatternID) {
<span class="fc" id="L530">		return listName + workPatternID.toString() + &quot;_editedEndDateFN&quot;;</span>
	}
	
	private String getEffectivityPopupID(String listName, ID workPatternID) {
<span class="fc" id="L534">		return WorkPatternEffectivityPopupPM.POPUP_ID + &quot;_&quot; + listName + &quot;_&quot; + workPatternID.toString();</span>
	}
	
	private boolean isStartDateMultiEdit(WorkResourceWorkPattern wrwp) {
<span class="fc" id="L538">		return wrwp.isFieldMultiValue(</span>
				WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_STARTTIME);
	}
	
	private boolean isEndDateMultiEdit(WorkResourceWorkPattern wrwp) {
<span class="fc" id="L543">		return wrwp.isFieldMultiValue(</span>
				WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_ENDTIME);
	}
	
	private boolean isPreferenceMultiEdit(WorkResourceWorkPattern wrwp) {
<span class="fc" id="L548">		return wrwp.isFieldMultiValue(</span>
				WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_PREFERENCE);
	}
	
	/**
	 * Saves the changes made to the assignments in the list.
	 */
	public boolean save(Map&lt;ID, Employee&gt; employeeMap)
			throws BbmException {
		try {		
			//This map will contain the ids of the work patterns that have been removed from the list (in the keyset).
			//The value collection contains a pair of local dates representing the dates representing when the effective
			//  assignment was removed
<span class="fc" id="L561">			Map&lt;ID, Pair&lt;LocalDate, LocalDate&gt;&gt; removedAssignmentDates = getRemovedRowMetadata();</span>
			//The collection of assignments that are to be removed
<span class="fc" id="L563">			Collection&lt;WorkResourceWorkPattern&gt; assignmentsToRemove = new ArrayList&lt;WorkResourceWorkPattern&gt;();</span>
			//The collection of assignments that are to be added
<span class="fc" id="L565">			Collection&lt;WorkResourceWorkPattern&gt; assignmentsToAdd = new ArrayList&lt;WorkResourceWorkPattern&gt;();</span>
			
<span class="fc bfc" id="L567" title="All 2 branches covered.">			for (ID employeeID : assignmentMap.keySet()) {</span>
<span class="pc bpc" id="L568" title="1 of 2 branches missed.">				for (WorkResourceWorkPattern wrwp : assignmentMap.get(employeeID)) {</span>
<span class="nc bnc" id="L569" title="All 2 branches missed.">					if (removedAssignmentDates.keySet().contains(wrwp.getWorkPatternSID())) {</span>
<span class="nc" id="L570">						Pair&lt;LocalDate, LocalDate&gt; assignmentGapDates = removedAssignmentDates.get(wrwp.getWorkPatternSID());</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">						if (assignmentGapDates == null) {	//First radio option (or remove button), remove assignment</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">							if (schedulingPeriod == null) {</span>
<span class="nc" id="L573">								assignmentsToRemove.add(wrwp);</span>
							} else {
								// If in campaign mode, we need to remove this window and not the visible record.
<span class="nc" id="L576">								Employee emp = employeeMap.get(wrwp.getWorkResourceID());</span>
								//Adjust the view dates by subtracting the campaign's day boundary.  The view dates
								//start/end at the time specified by the campaign's day boundary, but the skill assignments
								//are stored at midnight of the user org's time zone.
<span class="nc" id="L580">								LocalDate endDate = new LocalDate(viewEndDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L581">								endDate.add(Calendar.MINUTE, -campaign.getDayBoundaryOffset());</span>
<span class="nc" id="L582">								LocalDate startDate = new LocalDate(viewStartDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L583">								startDate.add(Calendar.MINUTE, -campaign.getDayBoundaryOffset());</span>
<span class="nc" id="L584">								WorkResourceWorkPattern wrwpToSubtract = (WorkResourceWorkPattern)wrwp.clone();</span>
<span class="nc" id="L585">								wrwpToSubtract.setStartTime(startDate.getTime(emp.getTimeZone(viewStartDate)));</span>
<span class="nc" id="L586">								wrwpToSubtract.setEndTime(endDate.getTime(emp.getTimeZone(viewEndDate)));</span>
<span class="nc" id="L587">								adjustStartDateOfAssignmentToCoverStartOfViewPeriod(wrwpToSubtract);</span>
<span class="nc" id="L588">								adjustEndDateOfAssignmentToLieInsideViewPeriod(wrwpToSubtract);</span>
<span class="nc" id="L589">								assignmentsToRemove.add(wrwpToSubtract);</span>
<span class="nc" id="L590">							}</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">						} else if (assignmentGapDates.getSecond() == null) {	</span>
							//3rd radio option, assignment ends at current date.  Create a new assignment with start date
							//  and null end date to &quot;subtract&quot; from user's assignments
<span class="nc" id="L594">							WorkResourceWorkPattern assignmentToSubtract = (WorkResourceWorkPattern)wrwp.clone();</span>
<span class="nc" id="L595">							assignmentToSubtract.setStartTime(assignmentGapDates.getFirst().getTime(</span>
<span class="nc" id="L596">								employeeMap.get(wrwp.getWorkResourceID()).getTimeZone(assignmentGapDates.getFirst())));</span>
<span class="nc" id="L597">							assignmentToSubtract.setEndTime(null);</span>
<span class="nc" id="L598">							assignmentsToRemove.add(assignmentToSubtract);</span>
<span class="nc" id="L599">						} else {	//2nd radio option, we need to create a new assignment with start/end dates that we will be &quot;subtracting&quot;</span>
<span class="nc" id="L600">							Employee emp = employeeMap.get(wrwp.getWorkResourceID());</span>
<span class="nc" id="L601">							LocalDate subtractEndLocalDate = new LocalDate(assignmentGapDates.getSecond());</span>
							//Display end date, so effective assignment in DB is actually 1 day forward
<span class="nc" id="L603">							subtractEndLocalDate.add(Calendar.DATE, 1);</span>
<span class="nc" id="L604">							Date subtractEndDate = subtractEndLocalDate.getTime(emp.getTimeZone(assignmentGapDates.getSecond()));</span>
<span class="nc" id="L605">							WorkResourceWorkPattern assignmentToSubtract = (WorkResourceWorkPattern)wrwp.clone();</span>
<span class="nc" id="L606">							assignmentToSubtract.setStartTime(assignmentGapDates.getFirst().getTime(</span>
<span class="nc" id="L607">									employeeMap.get(wrwp.getWorkResourceID()).getTimeZone(assignmentGapDates.getFirst())));</span>
<span class="nc" id="L608">							assignmentToSubtract.setEndTime(subtractEndDate);</span>
<span class="nc" id="L609">							adjustStartDateOfAssignmentToCoverStartOfViewPeriod(assignmentToSubtract);</span>
<span class="nc" id="L610">							adjustEndDateOfAssignmentToLieInsideViewPeriod(assignmentToSubtract);</span>
<span class="nc" id="L611">							assignmentsToRemove.add(assignmentToSubtract);</span>
						}
					}
<span class="nc" id="L614">				}</span>
<span class="fc" id="L615">			}</span>
			
<span class="fc" id="L617">			assignmentsToAdd.addAll(getModifiedWorkPatternAssignments(assignmentMap, employeeMap));</span>
<span class="fc" id="L618">			assignmentsToAdd.addAll(getAddedWorkPatternAssignments(assignmentMap, employeeMap));</span>
			
<span class="fc" id="L620">			WorkRulesModelHandler.saveWorkPatternAssignments(m_context, assignmentsToRemove, assignmentsToAdd);</span>
<span class="nc" id="L621">		} catch (Exception ex) {</span>
<span class="nc" id="L622">			throw new BbmException(ex);</span>
<span class="fc" id="L623">		}</span>
		
		//Clear out the removed/added IDs when finished to avoid saving/deleting duplicates
<span class="fc" id="L626">		setAddedRowIDs(&quot;&quot;);</span>
<span class="fc" id="L627">		setRemovedRowIDs(&quot;&quot;);</span>
		
<span class="fc" id="L629">		return true;</span>
	}
	
	private Collection&lt;WorkResourceWorkPattern&gt; getAddedWorkPatternAssignments(
			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; workPatternAssignmentMap,
			Map&lt;ID, Employee&gt; employeeMap) throws BbmException {
		//Only one copy of each assignment is stored on the page (even if multiple employees are selected), so
		// we need to add the other assignments that will belong to every selected employee
<span class="fc" id="L637">		Collection&lt;WorkResourceWorkPattern&gt; addedAssignments = getAddedWorkPatternAssignments();</span>
<span class="fc" id="L638">		ArrayList&lt;WorkResourceWorkPattern&gt; newAddedAssignments = new ArrayList&lt;WorkResourceWorkPattern&gt;();</span>
		
		//We need to pull the work pattern assignments for the selected employees to see if any of these
		// newly assigned work patterns were previously assigned in the past.  If so, we set the start date
		// of this new assignment to the end date of the previous assignment.
<span class="fc" id="L643">		HashMap&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; pastWorkPatternAssignments = </span>
<span class="fc" id="L644">			WorkRulesModelHandler.getWorkPatternAssignmentsForEmployees(m_context,</span>
<span class="fc" id="L645">				new ArrayList&lt;ID&gt;(employeeMap.keySet()), null, viewEndDate);</span>
		
<span class="fc bfc" id="L647" title="All 2 branches covered.">		for (ID employeeID : workPatternAssignmentMap.keySet()) {</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">			for (WorkResourceWorkPattern addedAssignment : addedAssignments) {</span>
<span class="fc" id="L649">				WorkResourceWorkPattern wrwp = new WorkResourceWorkPattern();</span>
<span class="fc" id="L650">				wrwp.setWorkPatternSID(addedAssignment.getWorkPatternSID());</span>
<span class="fc" id="L651">				wrwp.setWorkPatternID(addedAssignment.getWorkPatternID());</span>
<span class="fc" id="L652">				wrwp.setWorkResourceID(employeeID);</span>
<span class="fc" id="L653">				wrwp.setPreference(addedAssignment.getPreference());</span>
<span class="fc" id="L654">				setDatesForWorkPatternAssignment(wrwp, addedAssignment,</span>
<span class="fc" id="L655">						pastWorkPatternAssignments.get(employeeID), employeeMap.get(employeeID), viewStartDate);				</span>
<span class="fc" id="L656">				newAddedAssignments.add(wrwp);</span>
<span class="fc" id="L657">			}</span>
<span class="fc" id="L658">		}</span>

<span class="fc" id="L660">		return newAddedAssignments;</span>
	}

	private ArrayList&lt;WorkResourceWorkPattern&gt; getAddedWorkPatternAssignments() {
<span class="fc" id="L664">		ArrayList&lt;WorkResourceWorkPattern&gt; retVal = new ArrayList&lt;WorkResourceWorkPattern&gt;();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">		for (ID id : getAddedRowIDCollection()) {</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">			for (WorkResourceWorkPattern wrwp : displayedAssignments) {</span>
<span class="fc bfc" id="L667" title="All 2 branches covered.">				if (id.equals(wrwp.getWorkPatternSID())) {</span>
<span class="fc" id="L668">					retVal.add(wrwp);</span>
<span class="fc" id="L669">					break;</span>
				}
<span class="fc" id="L671">			}</span>
<span class="fc" id="L672">		}</span>
<span class="fc" id="L673">		return retVal;</span>
	}
	
	private Collection&lt;WorkResourceWorkPattern&gt; getModifiedWorkPatternAssignments(
			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; workPatternAssignmentMap,
			Map&lt;ID, Employee&gt; employeeMap) {
		//Only one copy of each assignment is stored on the page (even if multiple employees are selected), so
		// we need to modify the other assignments that belong to every selected employee
<span class="fc" id="L681">		Collection&lt;WorkResourceWorkPattern&gt; modifiedAssignments = getModifiedWorkPatternAssignments();</span>
<span class="fc" id="L682">		ArrayList&lt;WorkResourceWorkPattern&gt; newModifiedAssignments = new ArrayList&lt;WorkResourceWorkPattern&gt;();</span>
<span class="pc bpc" id="L683" title="1 of 2 branches missed.">		for (WorkResourceWorkPattern modifiedAssignment : modifiedAssignments) {</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">			for (ID employeeID : workPatternAssignmentMap.keySet()) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">				for (WorkResourceWorkPattern existingAssignment : workPatternAssignmentMap.get(employeeID)) {</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">					if (modifiedAssignment.getWorkPatternSID().equals(existingAssignment.getWorkPatternSID())) {</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">						if (modifiedAssignment.isPreferenceModified()) {</span>
<span class="nc" id="L688">							existingAssignment.setPreference(modifiedAssignment.getPreference());</span>
<span class="nc" id="L689">							Employee emp = employeeMap.get(employeeID);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">							if (emp.getStartTimeLocal().after(modifiedAssignment.getLocalStartTime())) {</span>
<span class="nc" id="L691">								TimeZone empTimeZone = emp.getTimeZone(emp.getStartTime());</span>
<span class="nc" id="L692">								existingAssignment.setStartTime(emp.getStartTimeLocal().getTime(empTimeZone));								</span>
<span class="nc" id="L693">							} else {</span>
<span class="nc" id="L694">								TimeZone empTimeZone = emp.getTimeZone(modifiedAssignment.getLocalStartTime());</span>
<span class="nc" id="L695">								existingAssignment.setStartTime(modifiedAssignment.getLocalStartTime().getTime(empTimeZone));</span>
							}
<span class="nc bnc" id="L697" title="All 2 branches missed.">							if (modifiedAssignment.getLocalEndTime() != null) {</span>
<span class="nc" id="L698">								LocalDate adjustedEndDate = new LocalDate(modifiedAssignment.getLocalEndTime());</span>
<span class="nc" id="L699">								adjustedEndDate.add(Calendar.DAY_OF_YEAR, 1);</span>
								TimeZone empTimeZone;
<span class="nc bnc" id="L701" title="All 2 branches missed.">								if (emp.getEndTimeLocal() == null ||</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">										emp.getEndTimeLocal().after(modifiedAssignment.getLocalEndTime())) {</span>
<span class="nc" id="L703">									empTimeZone = emp.getTimeZone(modifiedAssignment.getLocalEndTime());</span>
								} else {
<span class="nc" id="L705">									empTimeZone = emp.getTimeZone(emp.getEndTime());</span>
								}
<span class="nc" id="L707">								existingAssignment.setEndTime(adjustedEndDate.getTime(empTimeZone));</span>
<span class="nc" id="L708">							} else {</span>
<span class="nc" id="L709">								existingAssignment.setEndTime(null);</span>
							}
							
							//If the employee's assignment start lies after the SP's start, we need to adjust the assignment back
							//one day (unless the employee's hire date is after the SP start date).
<span class="nc bnc" id="L714" title="All 4 branches missed.">							if (schedulingPeriod != null &amp;&amp; emp.getStartTime().after(schedulingPeriod.getStartTime()) == false) {</span>
<span class="nc" id="L715">								adjustStartDateOfAssignmentToCoverStartOfViewPeriod(existingAssignment);</span>
							}
<span class="nc" id="L717">							adjustEndDateOfAssignmentToLieInsideViewPeriod(existingAssignment);</span>
						}
<span class="nc" id="L719">						newModifiedAssignments.add(existingAssignment);</span>
<span class="nc" id="L720">						break;</span>
					}
<span class="nc" id="L722">				}</span>
<span class="nc" id="L723">			}</span>
<span class="nc" id="L724">		}</span>
<span class="fc" id="L725">		return newModifiedAssignments;</span>
	}
	
	private Collection&lt;WorkResourceWorkPattern&gt; getModifiedWorkPatternAssignments() {
<span class="fc" id="L729">		return new ArrayList&lt;WorkResourceWorkPattern&gt;(modifiedAssignments.values());</span>
	}

	/**
	 * This method looks at the past assignments of work patterns and then sets the appropriate date of the
	 * newly assigned work pattern based on this information.
	 *
	 * @param newEmployeeAssignment	- The actual WorkResourceWorkPattern that will be persisted for the employee.
	 * @param addedAssignment - This is the work pattern assignment that is returned from the page.  In a multi-edit
	 * scenario, it could represent different values for different employees so this is not the actual assignment
	 * that is persisted.  We do use it to determine which values / dates were edited and will update newEmployeeAssignment
	 * accordingly.
	 * @param pastAssignments - The past work pattern assignments for this employee.  Used to determine the correct start/end date
	 * for newEmployeeAssignment if the same work pattern has already been assigned in the past/future.
	 * @param employee - The employee for which this assignment will be persisted.
	 * @param viewStartDate - the current start date of the view period (either the start of the SP in campaign mode
	 * or an arbitrary start window in org mode).
	 */
	private void setDatesForWorkPatternAssignment(WorkResourceWorkPattern newEmployeeAssignment, WorkResourceWorkPattern addedAssignment,
			Collection&lt;WorkResourceWorkPattern&gt; pastAssignments, Employee employee, Date viewStartDate) {
		
		//We need to check to see if the assignment start time is explicitly set ahead of the view start time.
		//This will happen if the user's hire date is after the view/SP start date.
		//After determining the start times, we check this flag and if the assignment start is still
		//ahead of the SP (due to a difference in time zone between the employee's org and the SP) then
		//we may need to make further adjustments to the assignment start.
<span class="fc" id="L755">		boolean assignmentStartExplicitlySetAfterViewStart = false;</span>
		
		//Find the correct start date of the new assignment for the given employee
<span class="pc bpc" id="L758" title="1 of 2 branches missed.">		if (addedAssignment.getLocalStartTime() != null) {</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">			if (employee.getStartTimeLocal().after(addedAssignment.getLocalStartTime())) {</span>
<span class="nc" id="L760">				TimeZone empTimeZone = employee.getTimeZone(employee.getStartTime());</span>
<span class="nc" id="L761">				newEmployeeAssignment.setStartTime(employee.getStartTimeLocal().getTime(empTimeZone));</span>
<span class="nc" id="L762">				assignmentStartExplicitlySetAfterViewStart = true;</span>
<span class="nc" id="L763">			} else {</span>
<span class="nc" id="L764">				TimeZone empTimeZone = employee.getTimeZone(addedAssignment.getLocalStartTime());</span>
<span class="nc" id="L765">				newEmployeeAssignment.setStartTime(addedAssignment.getLocalStartTime().getTime(empTimeZone));</span>
<span class="nc" id="L766">			}</span>
		} else {	//If we are adding new work patterns in a multi-edit scenario, the addedAssignment object
					//will have a null start time.  In this case, we need to determine the appropriate start time based on
					//any previous assignments of the same work pattern that the employee may have had.
<span class="pc bpc" id="L770" title="3 of 4 branches missed.">			if (pastAssignments != null &amp;&amp; pastAssignments.size() &gt; 0) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">				for (WorkResourceWorkPattern pastAssignment : pastAssignments) {</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">					if (pastAssignment.getWorkPatternSID().equals(newEmployeeAssignment.getWorkPatternSID())) {</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">						if (pastAssignment.getEndTime() == null) {		//This means this new assignment is simply a continuation of a past assignment</span>
<span class="nc" id="L774">							newEmployeeAssignment.setStartTime(pastAssignment.getStartTime());</span>
<span class="nc" id="L775">							newEmployeeAssignment.setLocalStartTime(new LocalDate(pastAssignment.getStartTime(),</span>
<span class="nc" id="L776">									employee.getTimeZone(pastAssignment.getStartTime())));</span>
						} else {	//The new assignment is separate (non-continuous) from any past assignment
<span class="nc" id="L778">							newEmployeeAssignment.setStartTime(pastAssignment.getEndTime());</span>
<span class="nc" id="L779">							newEmployeeAssignment.setLocalStartTime(new LocalDate(pastAssignment.getEndTime(),</span>
<span class="nc" id="L780">									employee.getTimeZone(pastAssignment.getStartTime())));							</span>
						}
					}
<span class="nc bnc" id="L783" title="All 2 branches missed.">					if (newEmployeeAssignment.getStartTime() == null) {	//If there were no previous assignments for this work pattern, set start date of assignment to the employee start date.</span>
																		//(We technically should never have an hours assignment without a start date, this is just here as a safety check).
<span class="nc" id="L785">						newEmployeeAssignment.setStartTime(employee.getStartTime());</span>
					}
<span class="nc" id="L787">				}</span>
			} else {	//If there were no previous assignments for this work pattern, set start date of assignment to the employee start date 
<span class="fc" id="L789">				newEmployeeAssignment.setStartTime(employee.getStartTime());			</span>
			}
		}
		
		//Find the correct end date of the new assignment for the given employee
<span class="fc" id="L794">		LocalDate viewStartDateLocal = new LocalDate(viewStartDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">		if (addedAssignment.getLocalEndTime() != null) {</span>
<span class="nc" id="L796">			LocalDate adjustedEndDate = new LocalDate(addedAssignment.getLocalEndTime());</span>
<span class="nc" id="L797">			adjustedEndDate.add(Calendar.DAY_OF_YEAR, 1);</span>
<span class="nc bnc" id="L798" title="All 2 branches missed.">			if (employee.getEndTimeLocal() != null &amp;&amp;</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">					employee.getEndTimeLocal().before(adjustedEndDate)) {</span>
<span class="nc" id="L800">				newEmployeeAssignment.setEndTime(employee.getEndTime());</span>
			} else {
<span class="nc" id="L802">				TimeZone empTimeZone = employee.getTimeZone(addedAssignment.getLocalEndTime());</span>
<span class="nc" id="L803">				newEmployeeAssignment.setEndTime(adjustedEndDate.getTime(empTimeZone));	</span>
			}
<span class="pc bpc" id="L805" title="5 of 6 branches missed.">		} else if (pastAssignments != null &amp;&amp; !pastAssignments.isEmpty() &amp;&amp; isEndDateMultiEdit(addedAssignment)) {</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">			for (WorkResourceWorkPattern pastAssignment : pastAssignments) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">				if (pastAssignment.getWorkPatternSID().equals(newEmployeeAssignment.getWorkPatternSID())) {</span>
<span class="nc bnc" id="L808" title="All 4 branches missed.">					if (pastAssignment.getStartTime() != null &amp;&amp; pastAssignment.getStartTime().after(viewStartDateLocal.getTime(employee.getTimeZone(viewStartDate)))) {</span>
<span class="nc bnc" id="L809" title="All 4 branches missed.">						if (newEmployeeAssignment.getEndTime() == null || newEmployeeAssignment.getEndTime().after(pastAssignment.getStartTime())) {</span>
<span class="nc" id="L810">							newEmployeeAssignment.setEndTime(pastAssignment.getStartTime());</span>
						}
					}
				}
<span class="nc" id="L814">			}			</span>
		} else {	//No end date for assignment, set it to the employee termination date if there is one
<span class="fc bfc" id="L816" title="All 2 branches covered.">			if (employee.getEndTime() != null) newEmployeeAssignment.setEndTime(employee.getEndTime());</span>
		}
		
		/**
		 * The assignment's absolute start time can land after the SP's absolute start time due to one of
		 * a couple reasons:
		 * 1 - The employee's hire date is after the SP's start date (which we are not concerned about here).
		 * 2 - The employee org is in a time zone that is behind the SP's time zone (e.g. the SP time zone
		 * is +5:00 GMT, and the employee org's timezone is -8:00 GMT).  Because assignments are stored with
		 * a start date that is midnight at the employee org's timezone, in this scenario the absolute time of
		 * the assignment's start date will be after the absolute time of the SP's start date.  This causes an issue
		 * with the scheduler and the scheduler will not pick up the assignment unless the assignment covers the
		 * start of the SP.  We need to adjust the start date back one day in this case to ensure that the assignment
		 * covers the start.  Similarly, we do the same thing to the end date to avoid the assignment being applied to
		 * a future SP.
		 */
<span class="pc bpc" id="L832" title="3 of 4 branches missed.">		if (schedulingPeriod != null &amp;&amp; assignmentStartExplicitlySetAfterViewStart == false) {</span>
<span class="nc" id="L833">			adjustStartDateOfAssignmentToCoverStartOfViewPeriod(newEmployeeAssignment);</span>
		}
<span class="pc bpc" id="L835" title="1 of 2 branches missed.">		if (schedulingPeriod != null) {</span>
<span class="nc" id="L836">			adjustEndDateOfAssignmentToLieInsideViewPeriod(newEmployeeAssignment);</span>
		}
<span class="fc" id="L838">	}</span>
	
	/**
	 * Adjusts the start date of the assignment assignmentToAdjust so that it ensures that it will cover the start date of the
	 * SP week.
	 * 
	 * Because assignments are stored with a start date that is midnight at the employee org's timezone,
	 * in this scenario the absolute time of the assignment's start date will be after the absolute time of the SP week's start date.
	 * This causes an issue with the scheduler and the scheduler will not pick up the assignment unless the assignment covers the
	 * start of the SP week.  We need to adjust the start date back one day in this case to ensure that the assignment
	 * covers the start.  Similarly, we do the same thing to the end date to avoid the assignment being applied to
	 * a future SP week.
	 */
	private void adjustStartDateOfAssignmentToCoverStartOfViewPeriod(WorkResourceWorkPattern assignmentToAdjust) {
<span class="nc bnc" id="L852" title="All 4 branches missed.">		if (viewStartDate != null &amp;&amp; campaign != null) {</span>
<span class="nc" id="L853">			LocalDate localViewStartDate = new LocalDate(viewStartDate, TimeZoneUtil.GMT_TIMEZONE);</span>
			
<span class="nc bnc" id="L855" title="All 2 branches missed.">			if (assignmentToAdjust.getStartTime() != null &amp;&amp;</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">					assignmentToAdjust.getStartTime().after(localViewStartDate.getTime(campaign.getTimeZone()))) {</span>
<span class="nc" id="L857">				Calendar startCal = Calendar.getInstance();</span>
<span class="nc" id="L858">				startCal.setTime(assignmentToAdjust.getStartTime());</span>
<span class="nc" id="L859">				startCal.add(Calendar.DATE, -1);</span>
<span class="nc" id="L860">				assignmentToAdjust.setStartTime(startCal.getTime());</span>
			}
		}
<span class="nc" id="L863">	}</span>
	
	/**
	 * Adjusts the end date of the assignment assignmentToAdjust so that it ensures that it will lie before the end
	 * of the view period.
	 * 
	 * Because assignments are stored with a start date that is midnight at the employee org's timezone,
	 * in this scenario the absolute time of the assignment's start date will be after the absolute time of the SP week's start date.
	 * This causes an issue with the scheduler and the scheduler will not pick up the assignment unless the assignment covers the
	 * start of the SP week.  We need to adjust the start date back one day in this case to ensure that the assignment
	 * covers the start.  Similarly, we do the same thing to the end date to avoid the assignment being applied to
	 * a future SP week.
	 */
	private void adjustEndDateOfAssignmentToLieInsideViewPeriod(WorkResourceWorkPattern assignmentToAdjust) {
<span class="nc bnc" id="L877" title="All 4 branches missed.">		if (viewEndDate != null &amp;&amp; campaign != null) {</span>
<span class="nc" id="L878">			LocalDate localViewEndDate = new LocalDate(viewEndDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc bnc" id="L879" title="All 2 branches missed.">			if (assignmentToAdjust.getEndTime() != null &amp;&amp; </span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">					assignmentToAdjust.getEndTime().after(localViewEndDate.getTime(campaign.getTimeZone()))) {</span>
<span class="nc" id="L881">				Calendar endCal = Calendar.getInstance();</span>
<span class="nc" id="L882">				endCal.setTime(assignmentToAdjust.getEndTime());</span>
<span class="nc" id="L883">				endCal.add(Calendar.DATE, -1);</span>
<span class="nc" id="L884">				assignmentToAdjust.setEndTime(endCal.getTime());</span>
			}
		}
<span class="nc" id="L887">	}</span>
	
	/**
	 * This JS is used to force the effective dates to snap to the view period if a preference drop down is changed
	 * when in campaign mode (essentially it will match the view period of the currently selected SP).
	 */
	private String getDateSnapOnValueChangeJS() {
<span class="nc bnc" id="L894" title="All 2 branches missed.">		String startDateDisplay = viewStartDate == null ? &quot;&quot; :</span>
<span class="nc" id="L895">			m_localizer.formatDate(viewStartDate, TimeZoneUtil.GMT_TIMEZONE, RegionalFormatBundleKey.DATE_FORMAT);</span>
<span class="nc" id="L896">		String endDateDisplay = &quot;&quot;;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">		if (viewEndDate != null) {</span>
<span class="nc" id="L898">			LocalDate viewPeriodEndDisplay = new LocalDate(viewEndDate, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L899">			viewPeriodEndDisplay.add(Calendar.DATE, -1);</span>
<span class="nc" id="L900">			endDateDisplay = m_localizer.formatDate(viewPeriodEndDisplay, RegionalFormatBundleKey.DATE_FORMAT);</span>
		}
<span class="nc" id="L902">		StringBuffer js = new StringBuffer();</span>
<span class="nc" id="L903">		js.append(&quot;function snapWorkPatternEffectiveDatesToViewPeriod(startDateInputField, endDateInputField) {\n&quot;)</span>
<span class="nc" id="L904">			.append(&quot;\t var startElements = document.getElementsByName(startDateInputField);\n&quot;)</span>
<span class="nc" id="L905">			.append(&quot;\t if (startElements.length == 1) startElements[0].value = '&quot;).append(startDateDisplay).append(&quot;';\n&quot;)</span>
<span class="nc" id="L906">			.append(&quot;\t var endElements = document.getElementsByName(endDateInputField);\n&quot;)</span>
<span class="nc" id="L907">			.append(&quot;\t if (endElements.length == 1) endElements[0].value = '&quot;).append(endDateDisplay).append(&quot;';\n&quot;)</span>
<span class="nc" id="L908">		.append(&quot;}\n&quot;);</span>
		
<span class="nc" id="L910">		return js.toString();</span>
	}
	
	/**
	 * This is just to adjust for the way the effectivity end date is stored in DB and how 
	 * it needs to be displayed to the user. 
	 * Ex: Say an effectivity period set from 03/20/2007 to 03/22/2007. End date is stored as
	 * 03/23/2007 00:00:00. To display it to user need to subtract one day to make it 03/22/2007. 
	 * @param endDate
	 */
	private static void adjustEndDateForDisplay(LocalDate endDate) {
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">		if (endDate!=null) {</span>
<span class="pc bpc" id="L922" title="1 of 2 branches missed.">			if (endDate.get(Calendar.MINUTE)==59) {</span>
				// Need to compensate for last effetive assignment end date 
				// which is stored at the last minute of the date
<span class="fc" id="L925">				endDate.add(Calendar.MINUTE, 1);</span>
			}
			
			// Need to subtract a day on end date to show to the user correctly
<span class="fc" id="L929">			endDate.add(Calendar.DATE, -1);</span>
		}		
<span class="fc" id="L931">	}</span>
	
	/**
	 * Determines which assignments will be displayed in the list.  It differs from the assignments in assignmentMap
	 *  for a few reasons: assignmentMap contains all assignments for a given employee in the view range, whereas we only want to display
	 *  one assignment for a particular work pattern.  Also, if multiple employees have the same assignment, we will still only show one
	 *  assignment in the list (though it will have an indicator if only a subset of the selected employees has this assignment).
	 */
	private Collection&lt;WorkResourceWorkPattern&gt; getWorkPatternAssignmentsToDisplay() {
		//key = ID of corresponding work pattern belonging to the assignment (not the assignment itself)
		//  We only want to display one of each work pattern in the work pattern list
<span class="fc" id="L942">		HashMap&lt;ID, WorkResourceWorkPattern&gt; workPatternAssignments = </span>
			new HashMap&lt;ID, WorkResourceWorkPattern&gt;();
<span class="fc" id="L944">		HashMap&lt;ShiftPattern, HashSet&lt;ID&gt;&gt; workPatternEmployeeMap = new HashMap&lt;ShiftPattern, HashSet&lt;ID&gt;&gt;();</span>

<span class="fc bfc" id="L946" title="All 2 branches covered.">		for (ID employeeID : assignmentMap.keySet()) {</span>
<span class="fc bfc" id="L947" title="All 2 branches covered.">			for (WorkResourceWorkPattern wrwp : assignmentMap.get(employeeID)) {</span>
<span class="fc bfc" id="L948" title="All 2 branches covered.">				if (workPatternAssignments.keySet().contains(wrwp.getWorkPatternSID())) {</span>
<span class="fc" id="L949">					WorkResourceWorkPattern existingWrwp = workPatternAssignments.get(wrwp.getWorkPatternSID());		</span>
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">					if (existingWrwp.getWorkResourceID().equals(employeeID) == false) {</span>
<span class="pc bpc" id="L951" title="1 of 2 branches missed.">						if (existingWrwp.getPreference() != wrwp.getPreference()) {</span>
<span class="nc" id="L952">							existingWrwp.setFieldMultiValue(</span>
								WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_PREFERENCE);
						}
<span class="fc bfc" id="L955" title="All 2 branches covered.">						if (existingWrwp.getLocalStartTime().equals(wrwp.getLocalStartTime()) == false) {</span>
<span class="fc" id="L956">							existingWrwp.setFieldMultiValue(</span>
								WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_STARTTIME);
						}
<span class="pc bpc" id="L959" title="1 of 2 branches missed.">						if (existingWrwp.getLocalEndTime() != null &amp;&amp; </span>
<span class="nc bnc" id="L960" title="All 2 branches missed.">								existingWrwp.getLocalEndTime().equals(wrwp.getLocalEndTime()) == false) {</span>
<span class="nc" id="L961">							existingWrwp.setFieldMultiValue(</span>
								WorkResourceWorkPatternFieldInfo.WRKRESWORKPATTERN_ENDTIME);
						}
					}
<span class="fc" id="L965">				} else {</span>
					try {
<span class="fc" id="L967">						workPatternAssignments.put(wrwp.getWorkPatternSID(), (WorkResourceWorkPattern)wrwp.clone());</span>
<span class="nc" id="L968">					} catch (CloneNotSupportedException e) {</span>
						//This should never happen since we know WorkResourceWorkPatterns are Cloneable.
<span class="nc" id="L970">						e.printStackTrace();</span>
<span class="fc" id="L971">					}</span>
				}
				
<span class="fc" id="L974">				HashSet&lt;ID&gt; associatedEmployeeIDs = workPatternEmployeeMap.get(wrwp.getWorkPattern());</span>
<span class="fc bfc" id="L975" title="All 2 branches covered.">				if (associatedEmployeeIDs == null) {</span>
<span class="fc" id="L976">					associatedEmployeeIDs = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L977">					workPatternEmployeeMap.put(wrwp.getWorkPattern(), associatedEmployeeIDs);</span>
				}
<span class="fc" id="L979">				associatedEmployeeIDs.add(employeeID);</span>
<span class="fc" id="L980">			}</span>
<span class="fc" id="L981">		}</span>
<span class="fc bfc" id="L982" title="All 2 branches covered.">		for (WorkResourceWorkPattern wrwp : workPatternAssignments.values()) {</span>
			//Indicate if multiple employees have this work pattern assigned.  This is
			// different from setting multi edit common, which identifies that ALL selected
			// employees have this work pattern assigned.  SetMultiEditIDs will indicate to the
			// effectivity popup that more than one employee is assigned and to therefore disable
			// the history control.
<span class="fc" id="L988">			wrwp.setMultiEditIDs(workPatternEmployeeMap.get(wrwp.getWorkPattern()));</span>
			//Set multieditcommon to indicate that all selected employees have this work pattern assigned
<span class="fc" id="L990">			wrwp.setMultiEditCommon(</span>
<span class="fc" id="L991">				workPatternEmployeeMap.get(wrwp.getWorkPattern()).containsAll(selectedEmployeeIDs));</span>
<span class="fc" id="L992">		}</span>

<span class="fc" id="L994">		return new ArrayList&lt;WorkResourceWorkPattern&gt;(workPatternAssignments.values());</span>
	}

	/**
	 * Updates the map of work pattern assignments for this component.
	 * This is required after a save operation because some of the assignments may have changed
	 * during the save operation.
	 */
	public void refreshWorkPatternMap(HashMap&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; workPatternAssignmentMap) {
<span class="fc" id="L1003">		assignmentMap = workPatternAssignmentMap;</span>
<span class="fc" id="L1004">		initRows(true);</span>
<span class="fc" id="L1005">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>