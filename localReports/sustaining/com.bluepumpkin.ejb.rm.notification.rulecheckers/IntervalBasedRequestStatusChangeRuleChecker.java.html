<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>IntervalBasedRequestStatusChangeRuleChecker.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.notification.rulecheckers</a> &gt; <span class="el_source">IntervalBasedRequestStatusChangeRuleChecker.java</span></div><h1>IntervalBasedRequestStatusChangeRuleChecker.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.notification.rulecheckers;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import org.w3c.dom.Document;
import org.w3c.dom.Element;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.localization.LocaleContext;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.notifyrules.model.ActionDetail;
import com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRule;
import com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleParameter;
import com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleTemplate;
import com.bluepumpkin.ejb.bbm.notifyrules.rulecheckers.AbstractRuleChecker;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.notification.notifyrules.RequestTypeSelector;
import com.bluepumpkin.ejb.rm.notification.util.NotificationUtil;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;
import com.bluepumpkin.ejb.rm.requests.swap.withdraw.model.ShiftSwapWithdraw;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.model.TOWithdraw;

<span class="nc" id="L40">public class IntervalBasedRequestStatusChangeRuleChecker extends AbstractRuleChecker {</span>
<span class="nc" id="L41">	private static final String m_className = IntervalBasedRequestStatusChangeRuleChecker.class.getName();</span>

<span class="nc" id="L43">	private static final Category m_cat = Log.initCategory(m_className);</span>

	/**
	 * These are the parameters defined for the
	 * &quot;RequestStatusChange notification rule template&quot;. Each instance of this
	 * rule template has values assigned to these parameters.
	 *
	 * This rule checker checks the rule's (passed as an argument) parameters
	 * against the request status change details (passed as an argument) to
	 * determine if the rule must fire or not.
	 */
	public static final String RULE_PARAMNAME_REQUEST_TYPE = &quot;rulerequesttype&quot;;

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleChecker#testRule(
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRule, java.lang.Object)
	 */
	@Override
	public ActionDetail testRule(NotifyRule notifyRule, Object notifDetail) throws Exception {
		// get rule's orgID
<span class="nc bnc" id="L66" title="All 2 branches missed.">		if (notifyRule.getScopeType() != notifyRule.ORG_SCOPE) {</span>
			// should throw exception here ?????
<span class="nc" id="L68">			return null;</span>
		}
<span class="nc" id="L70">		ID ruleOrgID = notifyRule.getScopeID();</span>

		// Fetch the rule parameters to find the ruleSubtype and
		// requestStatusChangeType.
		// Rule parameters are passed to this method as String representation of
		// integers.

<span class="nc" id="L77">		Integer ruleReqTypeInt = null;</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">		for (Iterator itRuleParameter = notifyRule.getRuleParameters().iterator(); itRuleParameter.hasNext();) {</span>
<span class="nc" id="L79">			NotifyRuleParameter notifyRuleParameter = (NotifyRuleParameter) itRuleParameter.next();</span>
<span class="nc bnc" id="L80" title="All 2 branches missed.">			if (notifyRuleParameter.getName().toLowerCase().equals(RULE_PARAMNAME_REQUEST_TYPE)) {</span>
<span class="nc" id="L81">				ruleReqTypeInt = (Integer) notifyRuleParameter.getValue();</span>
			}
<span class="nc" id="L83">		}</span>

		// if rule request type was not specified, then raise an exception.
<span class="nc" id="L86">		Map&lt;Integer, String&gt; requestTypeMap = RequestTypeSelector.getRequestTypeMap();</span>
<span class="nc bnc" id="L87" title="All 4 branches missed.">		if (ruleReqTypeInt == null || !(requestTypeMap.containsKey(ruleReqTypeInt))) {</span>
<span class="nc" id="L88">			throw RequestUtil.createIllegalArgumentException(&quot;&quot; + notifyRule.getID() + ','</span>
					+ RULE_PARAMNAME_REQUEST_TYPE + ',' + ruleReqTypeInt, m_cat);
		}

<span class="nc" id="L92">		String ruleReqTypeStr = requestTypeMap.get(ruleReqTypeInt);</span>

		// get the collection of requests satisfying this change
<span class="nc" id="L95">		RmManagerFactory factory = RmManagerFactory.getInstance();</span>

		// get time from which changes are required
<span class="nc" id="L98">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L99">		cal.add(Calendar.SECOND, -notifyRule.getRuleCheckingInterval());</span>

<span class="nc" id="L101">		Collection requestIDs = factory.getCommonRequestManager().getRequestIDsByStatusChange(cal.getTime());</span>
<span class="nc" id="L102">		Collection requestCollTemp = factory.getCommonRequestManager().getRequestsByID(requestIDs, ruleReqTypeStr, true,</span>
				false, Request.DL_BASIC);
		// Because the Flex and Time Off are saved into TO Request,
		// the above call returns both TO and FLex requests irrespective of the ruleReqTypeStr
		// So iterating through the list to delete the requests that doesn't belong to the request type of the rule
<span class="nc" id="L107">		Collection&lt;RequestAggregate&gt; requestColl = filterFlexAndTOListBasedOnRuleRequestType(ruleReqTypeStr, requestCollTemp);</span>
<span class="nc" id="L108">		IntervalBasedRequestStatusChangeActionDetail customActionDetail = null;</span>
<span class="nc" id="L109">		ActionDetail actionDetail = new ActionDetail();</span>
<span class="nc bnc" id="L110" title="All 4 branches missed.">		if (requestColl != null &amp;&amp; !requestColl.isEmpty()) {</span>
<span class="nc" id="L111">			HashMap mapCustomizedEmailMsg = new HashMap();</span>
<span class="nc" id="L112">			HashMap mapCustomizedPopupMsg = new HashMap();</span>
<span class="nc" id="L113">			ActionDetail emptyActionDetail = new ActionDetail();</span>
			// iterate thru each request to get the message
<span class="nc bnc" id="L115" title="All 2 branches missed.">			for (Iterator it = requestColl.iterator(); it.hasNext();) {</span>
<span class="nc" id="L116">				Collection&lt;ActionDetail&gt; actionDetails = new ArrayList&lt;ActionDetail&gt;();</span>
<span class="nc" id="L117">				RequestAggregate reqAgg = (RequestAggregate) it.next();</span>
				// check rule's request type to see if it applies to this status
				// change notification
<span class="nc" id="L120">				String givenRequestType = reqAgg.getRequestType();</span>
<span class="nc" id="L121">				String newReqStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_NEGOTIATION)) {</span>
<span class="nc" id="L123">					continue;</span>
				}

				// fix for Bug#90276, notification not reqd for withdrawl of
				// requests.
				// Made consistent with the Notification rule checker.

<span class="nc bnc" id="L130" title="All 4 branches missed.">				if (!Request.REQUESTTYPE_TIMEOFF.equals(givenRequestType) &amp;&amp; !Request.REQUESTTYPE_SHIFTSWAP.equals(givenRequestType)</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">						&amp;&amp; reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WITHDRAWN)) {</span>
<span class="nc" id="L132">					continue;</span>
				}
<span class="nc bnc" id="L134" title="All 2 branches missed.">				if (Request.REQUESTTYPE_TIMEOFF.equals(givenRequestType)) {</span>
<span class="nc" id="L135">					TORequest toReq = (TORequest) reqAgg;</span>
<span class="nc" id="L136">					TOWithdraw withdrawReq = toReq.getWithdrawInfo();</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">					if (withdrawReq == null &amp;&amp; reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WITHDRAWN)) {</span>
<span class="nc" id="L138">						continue;// we are not interested in this status since</span>
									// withdrawal is not related to approved TO
									// request
<span class="nc bnc" id="L141" title="All 2 branches missed.">					} else if (withdrawReq != null) {</span>
<span class="nc" id="L142">						newReqStatus = toReq.getWithdrawInfo().getRequestStatus();</span>
					}

<span class="nc bnc" id="L145" title="All 2 branches missed.">				} else if (Request.REQUESTTYPE_SHIFTSWAP.equals(givenRequestType)) {</span>
					// making the Shift Swap logic similar to TO for easy maintenance
<span class="nc" id="L147">					ShiftSwapRequest ssReq = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L148">					ShiftSwapWithdraw withdrawReq = ssReq.getWithdrawInfo();</span>
					// adding this condition to compensate the exclusion of shift swap above
<span class="nc bnc" id="L150" title="All 4 branches missed.">					if (withdrawReq == null &amp;&amp; reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WITHDRAWN)) {</span>
<span class="nc" id="L151">						continue;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">					} else if (withdrawReq != null) {</span>
<span class="nc" id="L153">						newReqStatus = ssReq.getWithdrawInfo().getRequestStatus();</span>
					}

				}


				// Now determine which employees, associated with the request,
				// the rule applies
				// to. Consider this scenario: emp1 is associated with org1;
				// emp2 is assoc with org2;
				// shift swap request between emp1 and emp2; notification rule
				// defined in org1;. In
				// this scenario, notification must be sent to emp1 but not
				// emp2.

<span class="nc" id="L168">				List reqEmpIDs = null;</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				if (Request.REQUESTTYPE_SHIFTSWAP.equals(givenRequestType)) {</span>
<span class="nc" id="L170">					ShiftSwapRequest ssr = (ShiftSwapRequest) reqAgg;</span>

					// method is not named correctly. Returns a collection of
					// employee IDs and not employees.
<span class="nc" id="L174">					reqEmpIDs = ssr.getEmployees();</span>
<span class="nc" id="L175">				} else {</span>
<span class="nc" id="L176">					reqEmpIDs = Collections.singletonList(reqAgg.getEmployeeID());</span>
				}

				// For employee's associated with the request, get the empID to
				// orgID mapping
<span class="nc" id="L181">				WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L182">				Map reqEmpIDtoWRAssnWithTZMap = RequestStatusChangeRuleChecker.getWRAssnsWithTimeZone(</span>
<span class="nc" id="L183">						reqAgg.getEmpIDTimeRangePairs(), wrm);</span>

				// Verify if the rule is defined in the employee's orgID or one
				// of its parent orgIDs
				//
				// For each empID, verify if the emp's orgID or its parent
				// orgIDs match the rule's orgID.
				// If match found, then save the matching employee ID(s).
<span class="nc" id="L191">				List empIDsInRuleOrgIDOrItsChildren = null;</span>
<span class="nc" id="L192">				Map empIDToTZMap = new HashMap(reqEmpIDtoWRAssnWithTZMap.size() * 2);</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">				for (Iterator mapEntryIter = reqEmpIDtoWRAssnWithTZMap.entrySet().iterator(); mapEntryIter.hasNext();) {</span>
<span class="nc" id="L194">					Map.Entry mapEntry = (Map.Entry) mapEntryIter.next();</span>

<span class="nc" id="L196">					ID reqEmpID = (ID) mapEntry.getKey();</span>
<span class="nc" id="L197">					WorkResourceAssignment wrAssn = (WorkResourceAssignment) mapEntry.getValue();</span>

					// add the TZ for the workresource to the map
<span class="nc" id="L200">					empIDToTZMap.put(reqEmpID, wrAssn.getStartTimeZone());</span>

					// get the org ID and its parents for the employee's org.
<span class="nc" id="L203">					ID empOrgID = wrAssn.getOrganizationID();</span>
<span class="nc" id="L204">					Collection empOrgParentIDs = CacheUtilBBM.getParentOrgIDs(empOrgID, null);</span>

					// if ruleOrgID != empOrgID and ruleOrgID != any of emp's
					// parent orgID
<span class="nc bnc" id="L208" title="All 4 branches missed.">					if (!ruleOrgID.equals(empOrgID) &amp;&amp; !empOrgParentIDs.contains(ruleOrgID))</span>
<span class="nc" id="L209">						continue;</span>

					// allocate list if necessary.
<span class="nc bnc" id="L212" title="All 2 branches missed.">					empIDsInRuleOrgIDOrItsChildren = (empIDsInRuleOrgIDOrItsChildren == null) ? new ArrayList(2)</span>
							: empIDsInRuleOrgIDOrItsChildren;

					// add employee ID to collection.
<span class="nc" id="L216">					empIDsInRuleOrgIDOrItsChildren.add(reqEmpID);</span>
<span class="nc" id="L217">				}</span>

<span class="nc" id="L219">				Element rootElem = null;</span>
<span class="nc" id="L220">				Document doc = m_parser.newDocument();</span>
				// we have determined that the rule's requestType and
				// statusChangeType match the request and
				// the request's employees belong to the rule's org. Now format
				// the notification message
<span class="nc bnc" id="L225" title="All 4 branches missed.">				if (empIDsInRuleOrgIDOrItsChildren != null &amp;&amp; !empIDsInRuleOrgIDOrItsChildren.isEmpty()) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">					for (Iterator iter = empIDsInRuleOrgIDOrItsChildren.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L227">						ID empIDInRuleOrgOrItsChildren = (ID) iter.next();</span>
						// append the necessary elements to describe the request
						// change.
<span class="nc" id="L230">						rootElem = NotificationUtil.getXMLLocalizedFrag(null, reqAgg, doc, m_localizer, empIDToTZMap,</span>
								newReqStatus);
<span class="nc" id="L232">						actionDetail = new ActionDetail();</span>
						//moved this statement down after creating the object so as to set value in each new object
<span class="nc" id="L234">						actionDetail.setObjectType(ActionDetail.WORKRESOUCEID);</span>
<span class="nc" id="L235">						actionDetail.setDetails(empIDInRuleOrgOrItsChildren, rootElem);</span>
<span class="nc" id="L236">						actionDetails.add(actionDetail);</span>
<span class="nc" id="L237">						m_cat.debug(&quot;Sending notification: &quot;</span>
<span class="nc" id="L238">								+ RequestUtil.getXMLStringForElemOrDoc(null, rootElem.getOwnerDocument()));</span>
<span class="nc" id="L239">					}</span>
				} else {
<span class="nc" id="L241">					actionDetail = emptyActionDetail; // clean up the previous</span>
														// action detail for
														// previous employee fix
														// bug 48973
<span class="nc" id="L245">					actionDetails.add(actionDetail);</span>
				}

				// Fixing the notification to be sent for both employees involved in shift swap and shift swap withdrawal
<span class="nc bnc" id="L249" title="All 2 branches missed.">				for (ActionDetail eachActionDetail : actionDetails) {</span>
<span class="nc" id="L250">					mapCustomizedEmailMsg = NotificationUtil.getCustomizedMessagesMap(notifyRule, eachActionDetail, wrm,</span>
							reqAgg, rootElem, m_parser, mapCustomizedEmailMsg, m_localizer, empIDToTZMap, newReqStatus,
							true);

<span class="nc" id="L254">					mapCustomizedPopupMsg = NotificationUtil.getCustomizedMessagesMap(notifyRule, eachActionDetail, wrm,</span>
							reqAgg, rootElem, m_parser, mapCustomizedPopupMsg, m_localizer, empIDToTZMap, newReqStatus,
							false);
<span class="nc" id="L257">				}</span>
<span class="nc" id="L258">			}</span>
<span class="nc" id="L259">			customActionDetail = new IntervalBasedRequestStatusChangeActionDetail(mapCustomizedEmailMsg,</span>
					mapCustomizedPopupMsg);
<span class="nc" id="L261">			customActionDetail.setIsAllMessageCustomized(true);</span>
<span class="nc" id="L262">			customActionDetail.setObjectType(ActionDetail.WORKRESOUCEID);</span>
		}
<span class="nc" id="L264">		return customActionDetail;</span>
	}


	/**
	 * @param ruleReqTypeStr
	 * @param requestColl
	 * @return Collection
	 * This method would return the list as is if the request type of rule is other than TO or Flex
	 * For flex requests, it would remove the TO requests from list and vice-versa
	 */
	private Collection&lt;RequestAggregate&gt; filterFlexAndTOListBasedOnRuleRequestType(String ruleReqTypeStr,
			Collection&lt;RequestAggregate&gt; requestColl) {
<span class="nc" id="L277">		Collection&lt;RequestAggregate&gt; requestCollFinal = new ArrayList&lt;RequestAggregate&gt;(requestColl);</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">		for (Iterator&lt;RequestAggregate&gt; it = requestCollFinal.iterator(); it.hasNext();) {</span>
<span class="nc" id="L279">			RequestAggregate reqAgg = it.next();</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">			if ((Request.REQUESTTYPE_FLEXTIME.equals(ruleReqTypeStr) &amp;&amp; !reqAgg.isFlexTimeRequest()) ||</span>
<span class="nc bnc" id="L281" title="All 4 branches missed.">					(Request.REQUESTTYPE_TIMEOFF.equals(ruleReqTypeStr) &amp;&amp; reqAgg.isFlexTimeRequest())) {</span>
<span class="nc" id="L282">				it.remove();</span>
			}
<span class="nc" id="L284">		}</span>
<span class="nc" id="L285">		return requestCollFinal;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleChecker#isRuleValid
	 * (com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRule,
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleTemplate)
	 */
	@Override
	public boolean isRuleValid(NotifyRule rule, NotifyRuleTemplate template) {
<span class="nc" id="L298">		return true;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleChecker#getRuleViolation
	 * (com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRule,
	 * com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleTemplate,
	 * com.bluepumpkin.common.localization.LocaleContext)
	 */
	@Override
	public String getRuleViolation(NotifyRule rule, NotifyRuleTemplate template, LocaleContext context) {
<span class="nc" id="L312">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>