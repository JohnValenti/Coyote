<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CustShiftReqMgrEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.custshift.ejb</a> &gt; <span class="el_source">CustShiftReqMgrEJB.java</span></div><h1>CustShiftReqMgrEJB.java</h1><pre class="source lang-java linenums">/*
 * CustShiftReqMgrEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.custshift.ejb;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.AgentsGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.CustShiftValidationCache;
import com.bluepumpkin.ejb.rm.requests.custshift.validation.ShiftExistValidationRule;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;


/**
 * EJB for CustShiftReq
 * &lt;p/&gt;
 * Caveats:
 * &lt;p&gt; If a series of interface methods are invoked, then any method that accepts a request,
 * instead of a request ID, needs to be used with caution.  For instance if after calling createRequest(),
 * the same request is passed to ApproveRequest(), it will still have the deleteAllChildren flag set.
 * Although this flag was reset during
 * the backend processing of the request during createRequest(), the updated request is not marshalled
 * back to the webtier and hence the request in the webtier still retains it.
 */
<span class="fc" id="L73">public class CustShiftReqMgrEJB extends RequestAggregateManager //OUTSIDE_CONTAINER</span>
//public class CustShiftReqMgrEJB extends RequestAggregateManager implements CustShiftReqMgr  //OUTSIDE_CONTAINER
{
<span class="fc" id="L76">    private static final String m_className = CustShiftReqMgrEJB.class.getName();</span>
<span class="fc" id="L77">    private static final Category m_cat = Log.initCategory(m_className);</span>

    /**
     * Array of hard validation classes
     */
<span class="fc" id="L82">    protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
<span class="fc" id="L83">            new ValidatorDescriptor(AgentsGoodStandingValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, CustShiftReq.DL_BASIC),</span>
<span class="fc" id="L84">            new ValidatorDescriptor(ShiftExistValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null, CustShiftReq.DL_BASIC)</span>
    };

<span class="fc" id="L87">    private final static ValidatorDescriptor[] m_softValidatorDescMandArr = {};</span>

    {
<span class="fc" id="L90">        super.init(CustShiftReqMgrEJB.class.getName());</span>
<span class="fc" id="L91">    }</span>

    /**
     * override the base class to provide the appropriate logging category
     */
    protected Category getCategory() {
<span class="fc" id="L97">        return m_cat;</span>
    }

    /**
     * Return the possible states for a request of this type.
     *
     * @return a List of the possible states for requests of this type.
     */
    public List getPossibleStates() {
<span class="nc" id="L106">        return RequestAuditTrail.CS_POSSIBLE_STATES;</span>
    }

    protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L110">        return m_hardValidatorDescriptorArr;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
      */
    protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L117">        return m_softValidatorDescMandArr;</span>
    }

    protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="fc" id="L121">        return new CustShiftReqDAO(detailLevel);</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
      */
    protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L128">        return RequestUtil.getRmManagerFactory().getCustShiftReqMgr();</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
      */
    protected String getRequestType() {
<span class="fc" id="L135">        return Request.REQUESTTYPE_CUSTSHIFT;</span>
    }

    /**
     * /* (non-Javadoc)
     *
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#createRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L144">        updateExpiryDate((CustShiftReq) reqAgg);</span>
<span class="nc" id="L145">        super.createRequestPreProcess(reqAgg, reqAggDAO);</span>
<span class="nc" id="L146">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
      */
    protected void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception {
        // Note: If this method is implemented, use the following code snippet to determine if
        // postProcessing must be done or not.
<span class="fc" id="L154">    }</span>

    //TODO: use the parameter loadedFromDB.
    protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
                                                       boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L159" title="All 2 branches missed.">        boolean needToAllocDAO = (reqAggDAO == null);</span>
        try {
<span class="nc" id="L161">            CustShiftReq custShiftReq = (CustShiftReq) reqAgg;</span>

            // ID must be set in objValue
<span class="nc bnc" id="L164" title="All 2 branches missed.">            if (custShiftReq.getID() == null) {</span>
<span class="nc" id="L165">                throw new IllegalArgumentException();</span>
            }

            // obtain old request
<span class="nc" id="L169">            long detailLevel = CustShiftReq.DL_BASIC;</span>
<span class="nc" id="L170">            CustShiftReq ssrFromDB = null;</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevel) : reqAggDAO;</span>
<span class="nc" id="L172">            ssrFromDB = (CustShiftReq) reqAggDAO.getRequestByID(custShiftReq.getID(), detailLevel);</span>

            // Validate that the request is not changing EmployeeFor
<span class="nc bnc" id="L175" title="All 2 branches missed.">            if (!custShiftReq.getEmployeeID().equals(ssrFromDB.getEmployeeID())) {</span>
<span class="nc" id="L176">                throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_CHANGE_EMPLOYEEID,</span>
<span class="nc" id="L177">                        custShiftReq.getID(), custShiftReq.getEmployeeID(), ssrFromDB.getEmployeeID(), m_cat);</span>
            }

            // Cannot modify approved requests
<span class="nc bnc" id="L181" title="All 2 branches missed.">            if (ssrFromDB.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L182">                throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_UPDATE_APPROVED_REQUESTS,</span>
<span class="nc" id="L183">                        custShiftReq.getID(), m_cat);</span>
            }

<span class="nc" id="L186">            updateExpiryDate(custShiftReq);</span>

            // If status is not set or empty, it is an error
<span class="nc" id="L189">            String status = custShiftReq.getRequestStatus();</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">            if (!StringUtil.isEmpty(status) &amp;&amp; !RequestAuditTrail.CS_POSSIBLE_STATES.contains(status)) {</span>
<span class="nc" id="L191">                throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_REQUEST_STATUS, new Object[]{status}, m_cat);</span>
            }
<span class="nc" id="L193">            return custShiftReq;</span>
        } finally {
<span class="nc bnc" id="L195" title="All 8 branches missed.">            if (needToAllocDAO &amp;&amp; reqAggDAO != null) reqAggDAO.cleanUp();</span>
        }
    }

    /**
     * Note: This overrides RequestAggregateManager.changeRequestStateByID() and does not call
     * the overridden method.  Instead it calls _changeRequestStateByID() directly (which is also
     * called by ReqAggMgr.changeRequestStateByID()).
     * &lt;p/&gt;
     * Runs the request status modification and autoprocess in separate transactions.
     * TODO: change transaction attribute to Required (currently NotRequired).
     * &lt;p/&gt;
     * {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(ID, String, String, String) changeRequestStateByID}
     */
    public void changeRequestStateByID(ID reqID, String newState, String objVerNum, String comment)
            throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L211">        String _method_ = &quot;changeRequestStateByID&quot;;</span>
<span class="nc" id="L212">        methodStart(_method_, reqID, newState, objVerNum, comment);</span>

<span class="nc" id="L214">        CustShiftReqDAO csDao = null;</span>
<span class="nc" id="L215">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L216">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L218">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L220">            CustShiftReqMgr custShiftMgr = RequestUtil.getRmManagerFactory().getCustShiftReqMgr();</span>

            // call ReqAggMgr._changeRequestByID instead of ReqAggMgr.changeRequestByID().
            // ReqAggMgr.changeRequestByID() internally calls ReqAggMgr._changeRequestByID().
            // In effect this is the same as this overriding method calling the overridden method for
            // code reuse.
            // ********** Note: bracketed by its own transaction. *************
            // ********* Note: This takes care of notifications as well **********
<span class="nc" id="L228">            custShiftMgr._changeRequestStateByID(reqID, newState, objVerNum, comment);</span>

            // if new state is pending, do auto processing.
<span class="nc bnc" id="L231" title="All 4 branches missed.">            if ((newState != null) &amp;&amp; newState.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
                // After creation, refetch to refresh ValueObjectRoot.objectVersionNumber.  Otherwise
                // a MultiUserException will be thrown during auto processing approve or deny.
                //TODO: this runs bare without a transaction
<span class="nc" id="L235">                long detailLevel = getDetailLevelForValidation();</span>
<span class="nc" id="L236">                csDao = new CustShiftReqDAO(detailLevel);</span>
<span class="nc" id="L237">                CustShiftReq custShiftReq = (CustShiftReq) csDao.getRequestByID(reqID, detailLevel);</span>

                //verify again, in case request marked invalid by _changeRequestStateByID() above.
<span class="nc bnc" id="L240" title="All 2 branches missed.">                if (custShiftReq.isPending()) {</span>
                    // this is bracketed by its own transaction.
<span class="nc" id="L242">                    custShiftMgr._autoProcess(custShiftReq, comment, true);</span>
                }
            }
<span class="nc" id="L245">        } catch (RmHardValidationException e) {</span>

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L250">            handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L251">            throw e;</span>
<span class="nc" id="L252">        } catch (MultiUserException e) {</span>
<span class="nc" id="L253">            handleException(e);</span>
<span class="nc" id="L254">            throw e;</span>
<span class="nc" id="L255">        } catch (Exception e) {</span>
<span class="nc" id="L256">            handleException(e, false); //not a transaction participant</span>
<span class="nc" id="L257">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L259" title="All 4 branches missed.">            if (cacheEnabled) ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc bnc" id="L260" title="All 4 branches missed.">            if (csDao != null) csDao.cleanUp();</span>
<span class="nc" id="L261">            methodFinish();</span>
<span class="nc" id="L262">        }</span>
<span class="nc" id="L263">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO, Object[] optUndoData) throws Exception {
<span class="nc" id="L269">    }</span>

    /**
     * Approve a custom shift request. This entails deleting any old shift, scheduling the new shift (including any OT),
     * publishing, updating Adjusted FTE and Adjusted Staffing, and updating the request as approved.
     * @param reqAgg
     * @param choiceID
     * @param comment
     * @param suppressPrivChk
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _approveRequest(RequestAggregate reqAgg, ID choiceID, String comment, boolean suppressPrivChk, boolean loadedFromDB) throws Exception {
<span class="nc" id="L282">        String methodName = &quot;_approveRequest&quot;;</span>
<span class="nc" id="L283">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, choiceID, comment, new Boolean(suppressPrivChk)));</span>

<span class="nc" id="L285">		CustShiftReq custShiftReq = (CustShiftReq) reqAgg;</span>
<span class="nc" id="L286">        _doApproveRequest(custShiftReq);</span>
<span class="nc" id="L287">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED, true, true, loadedFromDB);</span>
<span class="nc" id="L288">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L289">    }</span>

	public static ID _doApproveRequest(CustShiftReq custShiftReq) throws Exception {
        // perform status transistion validation, privilege checking, hard validations and then
        // update request status to approved.

        //_updateRequest(custShiftReq, RequestAuditTrail.STATUS_APPROVED, comment, RequestAuditTrail.STATUS_APPROVED, suppressPrivChk, loadedFromDB);
        /*start of cust shift creation*/
<span class="nc" id="L297">        CustShiftValidationCache cache = (CustShiftValidationCache) custShiftReq.getValidationCache();</span>
<span class="nc" id="L298">        TimeSeriesManager tsm = cache.getTimeSeriesManager();</span>
<span class="nc" id="L299">        ScheduleAccessManager sam = cache.getScheduleAccessManager();</span>

<span class="nc" id="L301">        ShiftAssignment shifttoDelete = cache.getExistingShiftAssignToBeDeleted(custShiftReq, sam);</span>
<span class="nc" id="L302">        ShiftAssignment shiftAssn = cache.getNewShiftAssignToBeCreated(custShiftReq, sam);</span>

<span class="nc" id="L304">        HashMap recalAfterCreate = null;</span>
<span class="nc" id="L305">        boolean staffingExists = cache.doesStaffingExistForPeriod(custShiftReq);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">        if (staffingExists) {    // get the trace cubes only if staffingExists is true for the given period</span>
<span class="nc" id="L307">            NetStaffingCube nsCube = cache.getPostCSApprovalNetStaffingCube(custShiftReq);</span>
<span class="nc" id="L308">            recalAfterCreate = cache.getPostCustShiftReqTraceCube(custShiftReq, sam, tsm, nsCube.getTimeRange());</span>
        }

<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (shifttoDelete != null) {</span>
            // before deleting shift, get published schedule to recalc
            //note: the shift in unpub and pub must be in-sync
            //Collection events = sam.getPublishedEventsForWorkResource(custShiftReq.getEmployeeID(), timeSeriesRangeStart, timeSeriesRangeEnd);
            //recalcAfterDelete = tsm.reCalcAdjustedFTEAndStaffing(null, tmRange, events, shifttoDelete, true);
<span class="nc" id="L316">            ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L317">            list.add(shifttoDelete.getID());</span>
<span class="nc" id="L318">            sam.deleteShiftAssignments(list);</span>
            //sam.publishSchedule(shifttoDelete.getWorkResourceIDs(), shifttoDelete.getStartTime(), shifttoDelete.getEndTime());

        }

        //before creating shift, we have to clean up the overlapped unavailability if there is any, otherwise, creating shift will fail
<span class="nc" id="L324">        ShiftSwapRequestUtil.deleteUnderlyingUnavailabilities(custShiftReq.getEmployeeID(), shiftAssn.getStartTime(), shiftAssn.getEndTime(), sam);</span>
<span class="nc" id="L325">        ID shiftAssignmentID = sam.createShiftAssignment(shiftAssn);</span>
        /*end of creation */

        // publish the changes
<span class="nc" id="L329">        sam.publishSchedule(shiftAssn.getWorkResourceIDs(), shiftAssn.getStartTime(), shiftAssn.getEndTime());</span>

        // QC138233, unPublish the shift assignment if the whole new time period is outside of the old new time period ( before the old start date or after the old endate)
<span class="nc bnc" id="L332" title="All 2 branches missed.">        if (shifttoDelete != null) {</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">        	 boolean isNewEndTimeSmallerEqualOldStartTime= DateTimeUtil.compareDate(shiftAssn.getEndTime(), shifttoDelete.getStartTime(), false) &lt;= 0; //  before the old startdate</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">             boolean isNewStartimeGreaterEqualOldEndTime= DateTimeUtil.compareDate(shiftAssn.getStartTime(), shifttoDelete.getEndTime(), false) &gt;= 0; //  after the old enddate</span>
<span class="nc bnc" id="L335" title="All 6 branches missed.">        	if ( custShiftReq.getSubType()== CustShiftReq.REQUEST_SUB_TYPE_REG_SHIFT_CHANGE.toInt() &amp;&amp; (isNewEndTimeSmallerEqualOldStartTime||isNewStartimeGreaterEqualOldEndTime)</span>
        		) {// Shift Change
<span class="nc" id="L337">        			sam.unPublishSchedule(shifttoDelete.getWorkResourceIDs(), shifttoDelete.getStartTime(), shifttoDelete.getEndTime());</span>
        		}
        }
        //recalc after publish the approval
        //Collection events = sam.getPublishedEventsForWorkResource(custShiftReq.getEmployeeID(), timeSeriesRangeStart, timeSeriesRangeEnd);
        //Collection recalAfterCreate = tsm.reCalcAdjustedFTEAndStaffing(recalcAfterDelete, tmRange, events, sam.getShiftAssignmentByID(shiftAssignmentID), false);
<span class="nc bnc" id="L343" title="All 2 branches missed.">        if (staffingExists) {// update the trace cubes only if staffingExists is true for the given period</span>
<span class="nc" id="L344">            tsm.updateAdjustedFTEAndStaffing(recalAfterCreate);</span>
        }
        // returning this Id to update the flexmakeuprequest table with latest shift assignment details
        // so that it can be used later to pull the approved flex requests through a filter
<span class="nc" id="L348">        return shiftAssignmentID;</span>
	}

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
      */
    protected void _approveRequestPostProcess(RequestAggregate reqAgg, ID choiceID, String comment) {
<span class="nc" id="L355">    }</span>

    protected void _approveRequestTentatively(RequestAggregate reqAgg, ID choiceID, String comment, boolean loadedFromDB) throws Exception {
<span class="nc" id="L358">        throw new UnsupportedOperationException(m_tentativeNotImplemented + reqAgg);</span>
    }

    protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L362">        String methodName = &quot;_denyRequest&quot;;</span>
<span class="nc" id="L363">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment, new Boolean(suppressPrivilegeChecking)));</span>
        // update status to denied (after status transistion validation, privilege checking and hard validations).
<span class="nc" id="L365">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L366">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L367">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
      */
    protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
<span class="nc" id="L373">    }</span>

    protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment) throws Exception {
<span class="nc" id="L376">        throw new UnsupportedOperationException(m_tentativeNotImplemented);</span>
    }

    /**
     * Compute the expiration date, The expiration is equal to start date.
     */
    protected static void updateExpiryDate(CustShiftReq custShiftReq) {
<span class="nc bnc" id="L383" title="All 4 branches missed.">    	if(LicenseUtil.isAdvancedRMLicense() &amp;&amp; custShiftReq.isInPastDate()) {</span>
<span class="nc" id="L384">            custShiftReq.setExpirationDate(new Date(RequestUtil.MAX_DATE.getTime()));</span>
    	} else {
<span class="nc" id="L386">            custShiftReq.setExpirationDate(custShiftReq.getStartTime());</span>
    	}
<span class="nc" id="L388">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#checkApproveDenyTransPriv(com.bluepumpkin.ejb.bbm.security.model.User, com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String, java.lang.String, com.bluepumpkin.common.datatypes.ID)
      */
    protected void checkApproveDenyTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
                                             String newState, ID orgID) throws Exception {

<span class="nc" id="L396">        CustShiftReq ssr = (CustShiftReq) reqAgg;</span>
<span class="nc" id="L397">        Collection orgIDs = ssr.getCache().getOrgIDs();</span>
<span class="nc" id="L398">        ID reqID = reqAgg.getID();</span>

<span class="nc" id="L400">        String S_P = RequestAuditTrail.STATUS_PENDING;</span>
<span class="nc" id="L401">        String S_T = RequestAuditTrail.STATUS_TENTATIVE;</span>
<span class="nc" id="L402">        String S_E = RequestAuditTrail.STATUS_ESCALATED;</span>

<span class="nc" id="L404">        String userName = userBasic.getUserName();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        for (Iterator itr = orgIDs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L406">            orgID = (ID) itr.next();</span>

            // If current state is pending or tentative, is user authorized to approve for this organization?
<span class="nc bnc" id="L409" title="All 4 branches missed.">            if (oldState.equals(S_P) || oldState.equals(S_T)) {</span>
<span class="nc" id="L410">                ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID),</span>
<span class="nc" id="L411">                        getPrivIDApprovePending());</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                if (privFailedOrgID == null) {</span>
<span class="nc" id="L413">                    continue;</span>
                }

<span class="nc" id="L416">                throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_PENDING_APPROVE,</span>
                        RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_PENDING_APPROVE,
                        new Object[]{userName, reqID, oldState, newState},
                        m_cat);
            } // If current state is Escalated, is user authorized to approve escalated requests?
<span class="nc bnc" id="L421" title="All 2 branches missed.">            else if (oldState.equals(S_E)) {</span>
<span class="nc" id="L422">                ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID),</span>
<span class="nc" id="L423">                        getPrivIDApproveEscalated());</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">                if (privFailedOrgID == null) {</span>
<span class="nc" id="L425">                    continue;</span>
                }

<span class="nc" id="L428">                throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,</span>
                        RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,
                        new Object[]{userName, reqID, oldState, newState},
                        m_cat);
            } // state transition check is done separately from privilege check
        }
<span class="nc" id="L434">    }</span>


    protected void checkEscalateTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
                                          String newState, ID orgID) throws Exception {

<span class="nc" id="L440">        CustShiftReq ssr = (CustShiftReq) reqAgg;</span>
<span class="nc" id="L441">        Collection orgIDs = ssr.getCache().getOrgIDs();</span>
<span class="nc" id="L442">        ID reqID = reqAgg.getID();</span>
<span class="nc" id="L443">        String userName = userBasic.getUserName();</span>
<span class="nc" id="L444">        boolean foundPriv = false;</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">        for (Iterator itr = orgIDs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L446">            orgID = (ID) itr.next();</span>
<span class="nc" id="L447">            ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID), getPrivIDEscalate());</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">            if (privFailedOrgID == null) {</span>
<span class="nc" id="L449">                foundPriv = true;</span>
<span class="nc" id="L450">                break;</span>
            }
<span class="nc" id="L452">        }</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">        if (!foundPriv) {//If no privilege found set the error message and return</span>
<span class="nc" id="L454">            throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,</span>
                    RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,
                    new Object[]{userName, reqID, oldState, newState},
                    m_cat);
        }
<span class="nc" id="L459">    }</span>

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDApproveEscalated()
      */
    protected ID getPrivIDApproveEscalated() {
<span class="nc" id="L465">        return PrivilegeKeys.CS_APPROVEESCALATEDREQUESTS_ID;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDApprovePending()
      */
    protected ID getPrivIDApprovePending() {
<span class="nc" id="L472">        return PrivilegeKeys.CS_APPROVEPENDINGREQUESTS_ID;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDEscalate()
      */
    protected ID getPrivIDEscalate() {
<span class="nc" id="L479">        return PrivilegeKeys.CS_ESCALATEDENIEDREQUESTS_ID;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDModifyPersonalReqs()
      */
    protected ID getPrivIDModifyPersonalReqs() {
<span class="nc" id="L486">        return PrivilegeKeys.CS_MODIFYPERSONALREQUESTS_ID;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDModifyReqsForEmp()
      */
    protected ID getPrivIDModifyReqsForEmp() {
<span class="nc" id="L493">        return PrivilegeKeys.CS_MODIFYREQUESTSFOREMPLOYEE_ID;</span>
    }

    /* (non-Javadoc)
      * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
      */
    protected ID getPrivIDPurge() {
<span class="nc" id="L500">        return PrivilegeKeys.CS_PURGEREQUESTS_ID;</span>
    }

    /**
     * Add columns necessary to process a query governed by the given filter.  The caller has already
     * added columns from the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.  Columns from
     * new tables should start with D as a column synonym.  See
     * {@link #addToFromClause addToFromClause} for how the from clause is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Columns added by this
     * method should insert a leading comma.
     *
     * @param selectClause  the string buffer being constructed, the generic columns have already been
     *                      added, this method should append its columns.
     * @param requestFilter the request filter
     */
    public void addToSelectColumns(StringBuffer query, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L519">        query.append(&quot;, CSR.STARTTIME, CSR.ENDTIME &quot;);</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN) {</span>
<span class="nc" id="L521">            query.append(&quot;, CAMP.NAME &quot;);</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L523">            query.append(&quot;, SHIFT.NAME &quot;);</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L525">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L527">            query.append(&quot;, CSR.STARTTIME &quot;);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L529">            query.append(&quot;, CSR.ENDTIME &quot;);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ISOT) {</span>
<span class="nc" id="L531">            query.append(&quot;, CSR.ISOT, CSR.SHIFTID &quot;);</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREID) {</span>
<span class="nc" id="L533">            query.append(&quot;, EXTS.NAME &quot;);</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L535">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREISOT) {</span>
<span class="nc" id="L537">            query.append(&quot;, CSR.EXTBEFOREISOT, CSR.EXTBEFOREID  &quot;);</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERID) {</span>
<span class="nc" id="L539">            query.append(&quot;, EXTS.NAME &quot;);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L541">            query.append(&quot;, ACTS.NAME &quot;);</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERISOT) {</span>
<span class="nc" id="L543">            query.append(&quot;, CSR.EXTAFTERISOT, CSR.EXTAFTERID  &quot;);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SUBTYPE) {</span>
<span class="nc" id="L545">            query.append(&quot;, CSR.SUBTYPE &quot;);</span>
        }
<span class="nc" id="L547">    }</span>

    /**
     * Add tables necessary to process a query governed by the given filter.  The caller has already
     * added the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.
     * New tables should start with D as a column synonym.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Tables added by this
     * method should insert a leading comma.
     *
     * @param fromClause    the string buffer being constructed, the generic tables have already been
     *                      added, this method should append its tables with a leading comma and start with D as a synonym.
     * @param requestFilter the request filter
     */
    public void addToFromClause(StringBuffer fromClause, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L565">        fromClause.append(&quot;, CUSTSHIFTREQ CSR &quot;);</span>
        //joins for sorts &amp; filter
<span class="nc bnc" id="L567" title="All 4 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN || requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L568">            fromClause.append(&quot; LEFT JOIN (SP INNER JOIN CAMPAIGN CAMP on CAMP.ID= CAMPAIGNID) on CSR.SPID=SP.SID &quot;);</span>
        }
<span class="nc bnc" id="L570" title="All 4 branches missed.">        if (sortColumn == Request.SORT_CS_SHIFTID || requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L571">            fromClause.append(&quot; LEFT JOIN SHIFT on SHIFT.SID = CSR.SHIFTID &quot;);</span>
        }

        //Joins for Sorts only
<span class="nc bnc" id="L575" title="All 6 branches missed.">        if (sortColumn == Request.SORT_CS_ACTIVITYID || sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID || sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L576">            fromClause.append(&quot; LEFT JOIN ACTIVITY ACTS on ACTS.ID = &quot;);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">            if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L578">                fromClause.append(&quot; ACTIVITYID &quot;);</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">            } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L580">                fromClause.append(&quot; EXTBEFOREACTIVITYID &quot;);</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">            } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L582">                fromClause.append(&quot; EXTAFTERACTIVITYID &quot;);</span>
            }
        }
<span class="nc bnc" id="L585" title="All 4 branches missed.">        if (sortColumn == Request.SORT_CS_EXTBEFOREID || sortColumn == Request.SORT_CS_EXTAFTERID) {</span>
            //fromClause.append(&quot;,SHIFTOTEXTENSION EXTS &quot;);
<span class="nc" id="L587">            fromClause.append(&quot; LEFT JOIN SHIFTOTEXTENSION EXTS on EXTS.SID = &quot;);</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">            fromClause.append((sortColumn == Request.SORT_CS_EXTBEFOREID ? &quot; EXTBEFOREID &quot; : &quot; EXTAFTERID &quot;));</span>
        }
        //joins for Filters only
<span class="nc bnc" id="L591" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L592">            fromClause.append(&quot;, ACTIVITY ACT &quot;);</span>
        }
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_EXTID_KEY)) {</span>
<span class="nc" id="L595">            fromClause.append(&quot;,SHIFTOTEXTENSION EXT &quot;);</span>
        }
<span class="nc" id="L597">    }</span>

    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added the generic where conditions.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     *
     * @param whereClause   the string buffer being constructed, the generic where clauses have already been
     *                      added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     */
    public void addToWhereClause(StringBuffer whereClause, RequestFilter requestFilter, int sortColumn) {
<span class="nc" id="L614">        whereClause.append(&quot; AND CSR.ID=REQ.ID &quot;);// join to REQUEST</span>
        //Filter by date range
<span class="nc bnc" id="L616" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)) {</span>
<span class="nc" id="L617">            StringsPair dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L618">            String rangeStart = dates.getKey();</span>
<span class="nc" id="L619">            String rangeEnd = dates.getValue();</span>
<span class="nc" id="L620">            Date dtNow = new Date();</span>
<span class="nc" id="L621">            String strDtNow = JdmoUtil.formatDBString(dtNow);</span>
<span class="nc" id="L622">            whereClause.append(&quot;AND &quot;);</span>
<span class="nc" id="L623">            RmUtil.appendRequestDateRangeClauses(whereClause, &quot;&quot;, &quot;CSR&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L624">            whereClause.append(&quot; &quot;);</span>
        }
        // Filter by Campaign Name
<span class="nc bnc" id="L627" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L628">            whereClause.append(&quot; AND CAMP.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_CAMPAIGNID_KEY));</span>
        }
        //Filter by shift Name
<span class="nc bnc" id="L631" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_SHIFTID_KEY)) {</span>
<span class="nc" id="L632">            whereClause.append(&quot; AND SHIFT.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_SHIFTID_KEY));</span>
        }
        //FILTER BY ACTIVITY NAME
<span class="nc bnc" id="L635" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_ACTIVITYID_KEY)) {</span>
<span class="nc" id="L636">            whereClause.append(&quot; AND ACT.ID  IN (CSR.EXTBEFOREACTIVITYID, CSR.EXTAFTERACTIVITYID, CSR.ACTIVITYID) &quot;);</span>
<span class="nc" id="L637">            whereClause.append(&quot; AND ACT.ID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_ACTIVITYID_KEY));</span>
        }
        //Filter by Extn name
<span class="nc bnc" id="L640" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_EXTID_KEY)) {</span>
<span class="nc" id="L641">            whereClause.append(&quot; AND EXT.SID in (EXTAFTERID, EXTBEFOREID) &quot;);</span>
<span class="nc" id="L642">            whereClause.append(&quot; AND EXT.SID =&quot;).append(requestFilter.getValueForKey(RequestFilter.CS_EXTID_KEY));</span>
        }
        //Filter by ISOT
<span class="nc bnc" id="L645" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_ISOT_KEY)) {</span>
<span class="nc" id="L646">            whereClause.append(&quot; AND &quot;).append(requestFilter.getValueForKey(RequestFilter.CS_ISOT_KEY)).append(&quot; IN (EXTAFTERISOT, EXTBEFOREISOT,ISOT) &quot;);</span>
        }
<span class="nc bnc" id="L648" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.CS_SUBTYPE_KEY)) {</span>
<span class="nc" id="L649">            String key = requestFilter.getValueForKey(RequestFilter.CS_SUBTYPE_KEY).toString();</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">            whereClause.append(&quot; AND SUBTYPE in (&quot;).append((CustShiftReq.CS_SUBTYPE_NEW_SHIFT.equals(key) ? &quot;1,2&quot; : &quot;4,8&quot;)).append(&quot;) &quot;);</span>
        }
<span class="nc" id="L652">    }</span>

    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added everthing but the order by clause.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     *
     * @param query         the string buffer being constructed, the generic where clauses have already been
     *                      added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     * @param sortColumn    identifies the column to use to sort the requests.
     *                      The constants that define the expected values are in
     *                      {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
     * @param sortDir       This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the
     *                      sort is ascending or descending.  (Note spaces around values for convenience.)
     */
    public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn, String sortDir) {
<span class="nc bnc" id="L674" title="All 2 branches missed.">        if (sortColumn == Request.SORT_CS_CAMPAIGN) {</span>
<span class="nc" id="L675">            query.append(&quot; ORDER BY CAMP.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SHIFTID) {</span>
<span class="nc" id="L677">            query.append(&quot; ORDER BY SHIFT.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ACTIVITYID) {</span>
<span class="nc" id="L679">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_STARTTIME) {</span>
<span class="nc" id="L681">            query.append(&quot; ORDER BY CSR.STARTTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L682" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ENDTIME) {</span>
<span class="nc" id="L683">            query.append(&quot; ORDER BY CSR.ENDTIME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_ISOT) {</span>
<span class="nc" id="L685">            query.append(&quot; ORDER BY CSR.ISOT &quot;).append(sortDir).append(&quot; , CSR.SHIFTID &quot;).append(sortDir);;</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREID) {</span>
<span class="nc" id="L687">            query.append(&quot; ORDER BY EXTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L688" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREACTIVITYID) {</span>
<span class="nc" id="L689">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTBEFOREISOT) {</span>
<span class="nc" id="L691">            query.append(&quot; ORDER BY CSR.EXTBEFOREISOT &quot;).append(sortDir).append(&quot; , CSR.EXTBEFOREID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L692" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERID) {</span>
<span class="nc" id="L693">            query.append(&quot; ORDER BY EXTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERACTIVITYID) {</span>
<span class="nc" id="L695">            query.append(&quot; ORDER BY ACTS.NAME &quot;).append(sortDir);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_EXTAFTERISOT) {</span>
<span class="nc" id="L697">            query.append(&quot; ORDER BY CSR.EXTAFTERISOT &quot;).append(sortDir).append(&quot; , CSR.EXTAFTERID &quot;).append(sortDir);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">        } else if (sortColumn == Request.SORT_CS_SUBTYPE) {</span>
<span class="nc" id="L699">            query.append(&quot; ORDER BY CSR.SUBTYPE &quot;).append(sortDir);</span>
        }
<span class="nc" id="L701">    }</span>

    public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L705">        String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L706">        methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L708">        CustShiftReqDAO toReqDao = null;</span>
<span class="nc" id="L709">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L710">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L712">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L714">            String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L716">            ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">            if (privFailedOrgID != null) {</span>
<span class="nc" id="L718">                throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
            }

<span class="nc" id="L721">            toReqDao = new CustShiftReqDAO(CustShiftReq.DL_BASIC);</span>
<span class="nc" id="L722">            toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
<span class="nc" id="L723">        } catch (RmHardValidationException e) {</span>
            //RM exceptions are always logged at the point where they are thrown.
            //m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L730">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L731">            throw e;</span>
<span class="nc" id="L732">        } catch (BbmRemoveException e) {</span>
<span class="nc" id="L733">            m_cat.error(e, e);</span>
<span class="nc" id="L734">            handleException(e);</span>
<span class="nc" id="L735">            throw e;</span>
<span class="nc" id="L736">        } catch (Exception e) {</span>
<span class="nc" id="L737">            handleException(e);</span>
<span class="nc" id="L738">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L740" title="All 4 branches missed.">            if (cacheEnabled) ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc bnc" id="L741" title="All 4 branches missed.">            if (toReqDao != null) toReqDao.cleanUp();</span>
<span class="nc" id="L742">            methodFinish();</span>
<span class="nc" id="L743">        }</span>
<span class="nc" id="L744">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>