<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestAggregate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.model</a> &gt; <span class="el_source">RequestAggregate.java</span></div><h1>RequestAggregate.java</h1><pre class="source lang-java linenums">/*
 * RequestAggregate.java
 *
 * Created on February 2, 2003, 3:23 PM
 */

package com.bluepumpkin.ejb.rm.requests.common.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectNode;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;

/**
 * ValueObject class to represent the 1 to 1 relationship (inheritance) between a
 * base (REQUEST) and derived table (such as SHIFTSWAP and TIMEOFF) in the database schema.
 * These tables are linked by &quot;propogated keys&quot;, keys that share the same value in the
 * base and derived table.
 *
 * A derived valueobject (ShiftSwapRequest or TORequest) inherits from this class to aggreagate
 * the base valueobject (Request) and provides access to the fields of the aggregated base
 * valueobject.
 */
public abstract class RequestAggregate extends ValueObjectNode implements Validatable
{
	//private static final long serialVersionUID = -6336594865856381455L;

<span class="fc" id="L42">    private static final String m_className = RequestAggregate.class.getName();</span>

<span class="fc" id="L44">	private static final Category m_cat = Log.initCategory(m_className);</span>

    public static final long DL_BASIC = RequestDetailLevel.DL_BASIC;
    public static final long DL_AUDIT_TRAIL = RequestDetailLevel.DL_AUDIT_TRAIL;

    //aggregated base object (Request)
<span class="fc" id="L50">    private Request m_aggdRequest = null;</span>

    // declared private and not protected,  to force access thru' getDetailLevel() and setDetailLevel()
    // and not directly.
<span class="fc" id="L54">    private long m_detailLevel = RequestDetailLevel.DL_BASIC;</span>

    //Only needed by the backend when objects are loaded from db. So marked as transient
    //private transient Class m_parentDAO;

        // ValidationCache stores objects which may be needed by multiple
    // Validatable objects. It's transient, so it's not serialized with the
    // Request.
<span class="fc" id="L62">    protected transient ValidationCache m_validationCache = null;</span>

    // As validations are run against a request, any failing add a validation
    // result to this collection
<span class="fc" id="L66">	private final Collection&lt;ValidationResult&gt; m_validationResults = new ArrayList&lt;ValidationResult&gt;(10);</span>

    /**
     * @see #setForceRequestReload(boolean)
     */
//    private boolean m_forceReload = false;

    /** Get the cache of saved data items that can be used by validators
     * while validating this object.
     * @return the ValidationCache object
     *
     */
    @Override
	public abstract ValidationCache getValidationCache();

    /** Creates a new instance of RequestAggregate */
<span class="fc" id="L82">    protected RequestAggregate(String pReqType, /*Class parentDAO, */ long detailLevel) {</span>
<span class="fc" id="L83">        m_aggdRequest = new Request(pReqType, detailLevel);</span>
        //m_parentDAO = parentDAO;
<span class="fc" id="L85">        setDetailLevel(detailLevel);</span>
<span class="fc" id="L86">    }</span>

    // return the base object.
//    public Request getAggregtedRequest() {
//        return m_aggdRequest;
//    }

    // getters
    /*public ID getCreatorID() {
        return m_aggdRequest.getCreatorID();
    }*/

    public String getRequestType() {
<span class="fc" id="L99">        return m_aggdRequest.getRequestType();</span>
    }

    /**
     * Returns the request's subType.  SubTypes apply only for some request
     * types.  For instance, for TORequests, the subType is the activityID.
     *
     * @return
     */
    public abstract ID getRequestSubType();

    public String getRequestStatus() {
<span class="fc" id="L111">        return m_aggdRequest.getRequestStatus();</span>
    }

    public Date getSubmittedOn() {
<span class="fc" id="L115">        return m_aggdRequest.getSubmittedOn();</span>
    }

    /**
     * Get the last modified date
     */
    public Date getLastModifiedAt() {
<span class="fc" id="L122">        return m_aggdRequest.getLastModifiedAt();</span>
    }

    /**
     * Get the expiration date
     */
    public Date getExpirationDate() {
<span class="fc" id="L129">        return m_aggdRequest.getExpirationDate();</span>
    }

    /**
     * Get the employee ID
     */
    public ID getEmployeeID() {
<span class="fc" id="L136">        return m_aggdRequest.getEmployeeID();</span>
    }

    public Request getAggregatedRequest() {
<span class="fc" id="L140">        return m_aggdRequest;</span>
    }

    public String getObjectVersionNumber() {
<span class="fc" id="L144">        return m_aggdRequest.getObjectVersionNumber();</span>
    }

    public Collection getAuditTrail()
    {
<span class="fc" id="L149">        return m_aggdRequest.getAuditTrail();</span>
    }

    public long getDetailLevel()  {
<span class="fc" id="L153">        return m_detailLevel;</span>
    }

//    /**
//     * @see #setForceRequestReload(boolean)
//     */
//    public boolean getForceRequestReload() {
//        return m_forceReload;
//    }

    /**
     * Used by autoprocessing.  Returns a collection of empID and TimeRange pairs,
     * representing the employees and time Ranges associated with this request.
     *
     * &lt;p&gt; Note:
     * &lt;li&gt; For TimeOff and ShiftBid requests, this collection has one element.
     * For ShiftSwap, it has two.
     * &lt;li&gt; For TimeOff and ShiftBid requests, Request.getEmployeeID() method returns
     * the same ID as this method.  For ShiftSwap requests, Request.getEmployeeID() only
     * returns one ID while this method returns two.
     *
     * @return
     */
    public abstract Collection getEmpIDTimeRangePairs();

    /*
     * static methods cannot be abstract.
     */
    //public static abstract long getDetailLevelForValidation();

    public static long getDetailLevelForValidation(String reqType) {
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (reqType.equals(Request.REQUESTTYPE_SHIFTBID)) {</span>
<span class="fc" id="L185">            return ShiftBidRequest.getDetailLevelForValidation();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">        } else if (reqType.equals(Request.REQUESTTYPE_SHIFTSWAP)) {</span>
<span class="fc" id="L187">            return ShiftSwapRequest.getDetailLevelForValidation();</span>
<span class="fc bfc" id="L188" title="All 2 branches covered.">        } else if (reqType.equals(Request.REQUESTTYPE_TIMEOFF)) {</span>
<span class="fc" id="L189">            return TORequest.getDetailLevelForValidation();</span>
<span class="fc bfc" id="L190" title="All 2 branches covered.">        } else if (reqType.equals(Request.REQUESTTYPE_FLEXTIME)) {</span>
<span class="fc" id="L191">            return TORequest.getDetailLevelForValidation() | TORequest.DL_TIMEOFF_FLEXMAKEUP;</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        } else if (reqType.equals(Request.REQUESTTYPE_CUSTSHIFT)) {</span>
<span class="fc" id="L193">            return CustShiftReq.getDetailLevelForValidation();</span>
        }

<span class="nc" id="L196">        throw new IllegalArgumentException(&quot;reqType = &quot; + reqType);</span>
    }

    public void setRequestStatus(String status) {
<span class="fc" id="L200">        m_aggdRequest.setRequestStatus(status);</span>
<span class="fc" id="L201">    }</span>

    public void setSubmittedOn(Date submittedOn) {
<span class="nc" id="L204">        m_aggdRequest.setSubmittedOn(submittedOn);</span>
<span class="nc" id="L205">    }</span>

    /**
     * Set the last modified date
     */
    public void setLastModifiedAt(Date lastModifiedAt) {
<span class="nc" id="L211">        m_aggdRequest.setLastModifiedAt(lastModifiedAt);</span>
<span class="nc" id="L212">    }</span>

    /**
     * Set the expiration date
     */
    public void setExpirationDate(Date expirationDate) {
<span class="fc" id="L218">        m_aggdRequest.setExpirationDate(expirationDate);</span>
<span class="fc" id="L219">    }</span>

    /**
     * Set the employee ID
     */
    public void setEmployeeID(ID id) {
<span class="fc" id="L225">        m_aggdRequest.setEmployeeID(id);</span>
<span class="fc" id="L226">    }</span>

    //todo: make visibility restricted. must only be visible to RequestAggregateDAO.
    public void setAggregatedRequest(Request request) {
<span class="fc" id="L230">        m_aggdRequest = request;</span>
<span class="fc" id="L231">    }</span>

	public void setAuditTrailList(Collection pAuditTrails)
	{
<span class="nc" id="L235">		m_aggdRequest.setAuditTrailList(pAuditTrails);</span>
<span class="nc" id="L236">	}</span>

    public void setObjectVersionNumber(String strValue)
    {
<span class="fc" id="L240">        m_aggdRequest.setObjectVersionNumber(strValue);</span>
<span class="fc" id="L241">    }</span>

//    /**
//     * Used by the validation rule to notify the caller to reload the request as the request was modified
//     * during validation. Presently used by the {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.RequestBiddableSchedulesAreValidHV RequestBiddableSchedulesAreValidHV}
//     * hard validation rule.
//     *
//     * @param b
//     */
//    public void setForceRequestReload(boolean forceReload) {
//        m_forceReload = forceReload;
//    }

    public void setDetailLevel(long detailLevel) {
<span class="fc" id="L255">        m_detailLevel = detailLevel | RequestDetailLevel.DL_BASIC; //for consistency, DL_BASIC must always be set.</span>
<span class="fc" id="L256">    }</span>

    public void addDetailLevel(long detailLevel) {
<span class="fc" id="L259">        m_detailLevel |= detailLevel;</span>
<span class="fc" id="L260">    }</span>

    /**
     * @param detailLevel
     */
    public boolean isDetailLevelSet(long detailLevel) {
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">        return (getDetailLevel() &amp; detailLevel) != 0;</span>
    }

    @Override
	public abstract FieldInfo getFieldInfo();

     /** Return the collection of validation results stored in this
     * validatable object.
     * @return collection of ValidationResults
     * @see ValidationResult
     */
	@Override
	public Collection&lt;ValidationResult&gt; getValidationResults(boolean entireBranch) {
<span class="fc" id="L279">        return m_validationResults;</span>
    }

   /** Add a validation result to the list maintained in this object
     * @param result result to add
     */
    @Override
	public void addValidationResult(ValidationResult result) {
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (result != null)  { // ignore null results</span>
<span class="nc" id="L288">            m_validationResults.add(result);</span>
        }
<span class="nc" id="L290">    }</span>

    /**
     * Clear the validation results in the object.
     */
    @Override
	public void clearValidationResults(boolean entireBranch) {
<span class="fc" id="L297">            m_validationResults.clear();</span>
<span class="fc" id="L298">    }</span>

    /** Get a collection of TimeRange objects for this object. For instance:
     * for time off a TimeRange object for each choice.
     * for shift swap a TimeRange object for each shiftswapitem.
     * @return a Collection of TimeRange objects
     *
     */
    @Override
	public abstract Collection getValidationTimeRanges() ;

    protected ValidationResult hardValidationErrorExists(Collection valResults) {
        // if no validation results, return false
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">        if (valResults.size() == 0)</span>
<span class="fc" id="L312">            return null;</span>

        // check results to see if there are any hard validations
<span class="nc bnc" id="L315" title="All 2 branches missed.">        for ( Iterator itr = valResults.iterator(); itr.hasNext(); )  {</span>
<span class="nc" id="L316">        	ValidationResult result = (ValidationResult)itr.next();</span>

<span class="nc bnc" id="L318" title="All 2 branches missed.">        	if (result == null) {</span>
        		// create exception to get stack trace.
<span class="nc" id="L320">        		Exception e = new Exception(&quot;Detected ValidatoinResult == null&quot;);</span>
        		// log exception, don't throw.
<span class="nc" id="L322">        		m_cat.error(e, e);</span>
<span class="nc" id="L323">        	} else {</span>
        		// return hard validation error if found.
<span class="nc bnc" id="L325" title="All 2 branches missed.">        		if ( !result.isSoft() )</span>
<span class="nc" id="L326">					return result;</span>
        	}
<span class="nc" id="L328">        }</span>

<span class="nc" id="L330">        return null;</span>
    }

    /**
     * This method determines if this request passed hard validations or not.
     *
     * For SS Requests, checking for entries in ValidationResults collection of the
     * request, after running hard validations is enough.  But for TO Requests, the
     * validtion results are in the TO choices and the request and so need a different logic to determine
     * if the request passed or not.
     */
    public ValidationResult hardValidationFailed() {
<span class="fc" id="L342">        return hardValidationErrorExists(m_validationResults);</span>
    }

    public boolean hasExpired() {
<span class="fc" id="L346">        return m_aggdRequest.hasExpired();</span>
    }

	public boolean isApproved() {
<span class="fc" id="L350">        return m_aggdRequest.isApproved();</span>
	}

    public boolean isTentative() {
<span class="fc" id="L354">        return m_aggdRequest.isTentative();</span>
    }

	public boolean isInvalid() {
<span class="fc" id="L358">        return m_aggdRequest.isInvalid();</span>
	}

	public boolean isPending() {
<span class="fc" id="L362">        return m_aggdRequest.isPending();</span>
	}
	public boolean isWaitlisted() {
<span class="fc" id="L365">        return m_aggdRequest.isWaitlisted();</span>
	}
	public boolean isNegotiation() {
<span class="nc" id="L368">        return m_aggdRequest.isNegotiation();</span>
	}

	public boolean isEscalated() {
<span class="nc" id="L372">        return m_aggdRequest.isEscalated();</span>
	}

	public boolean isWithdrawn() {
<span class="nc" id="L376">        return m_aggdRequest.isWithdrawn();</span>
	}

    public boolean isDenied() {
<span class="nc" id="L380">        return m_aggdRequest.isDenied();</span>
    }

    public boolean isTimeOffRequest() {
<span class="fc" id="L384">        return m_aggdRequest.isTimeOffRequest();</span>
    }

    public boolean isFlexTimeRequest() {
<span class="pc bpc" id="L388" title="3 of 6 branches missed.">        return Request.REQUESTTYPE_FLEXTIME.equals(m_aggdRequest.getRequestType()) || m_aggdRequest.isTimeOffRequest() &amp;&amp; (((TORequest) this).getFlexType() == TORequest.FLEXTYPE_FLEXWITHMAKEUP);</span>
    }

    public boolean isShiftSwapRequest() {
<span class="fc" id="L392">        return m_aggdRequest.isShiftSwapRequest();</span>
    }

	/**
	 * @return
	 */
	public boolean isShiftBidRequest() {
<span class="nc" id="L399">		return m_aggdRequest.isShiftBidRequest();</span>
	}

	/**
	 * @return
	 */
	public boolean isCustShiftRequest() {
<span class="nc" id="L406">		return m_aggdRequest.isCustShiftRequest();</span>
	}

	/**
	 * @return
	 */
	public boolean checkForValidState() {
<span class="pc bpc" id="L413" title="1 of 2 branches missed.">		return !(m_aggdRequest.isShiftBidRequest()</span>
<span class="pc bnc" id="L414" title="All 2 branches missed.">			&amp;&amp; m_aggdRequest.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED));</span>
	}

    /**
     * Is 'GetRequestPostProcessing' (processing request after it has been fetched
     * with one of the getRequestByXXXX() methods in the request manager) necessary.  Currently
     * this is decided based on the request's status
     *
     * TODO: Note: 2 other methods, isHardValidationNeeded() and isSoftValidationNeeded(), are implemented
     * in ReqAggMgr.  Refactor and move them to this class.
     *
	 * @return
	 */
	public boolean isGetRequestPostProcNeeded() {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">    	return !RequestAuditTrail.STATUS_INVALID.equals(getRequestStatus()) &amp;&amp;</span>
<span class="fc bfc" id="L429" title="All 2 branches covered.">			!RequestAuditTrail.STATUS_WITHDRAWN.equals(getRequestStatus());</span>
    }

	public boolean isSoftValidationNeeded() {
<span class="fc" id="L433">		String reqStatus = getRequestStatus();</span>

		// do not soft validatate if 'request status' is not in soft vaidation list or
		// request is invalid or request has expired.
<span class="pc bpc" id="L437" title="2 of 6 branches missed.">		if ( !getSoftValidationStates().contains(reqStatus) || hasExpired() || isInvalid() )</span>
<span class="fc" id="L438">			return false;</span>

<span class="fc" id="L440">		return true;</span>
	}
	public boolean isElgibleForWaitlist() {
<span class="fc" id="L443">		String reqStatus = getRequestStatus();</span>
        
		// do not Waitlist if 'request status' is not in Waitlist'ble states list or 
		// request is invalid or request has expired. 
<span class="pc bpc" id="L447" title="2 of 6 branches missed.">		if ( !getWaitlistElgibleStates().contains(reqStatus) || hasExpired() || isInvalid()) </span>
<span class="fc" id="L448">			return false;</span>
            
<span class="fc" id="L450">		return true;</span>
	}

	/**
	 * @return
	 */
	public boolean isHardValidationNeeded(int methodType) {
<span class="nc" id="L457">		String reqStatus = getRequestStatus();</span>

		// We might want to implement this: don't validate final states except invalid.  'invalid' requests
		// are revalidated as the reason for invalidation is not persisted in the audit trail when
		// the request first became invalid.
<span class="nc bnc" id="L462" title="All 2 branches missed.">		if ( getHardValidationStatesToBeSkipped().contains(reqStatus) ) //&amp;&amp; !reqAgg.isInvalid() )</span>
<span class="nc" id="L463">			return false;</span>

		// Has request expired?
		// For a ShiftBidRequest being created, expiration date will be null as the hard
		// validation rule 'AuctionIsValidHV.java' sets it later (using the shiftBidAuction.getEndTime()).
		//
        // Allow requests expired on 'create' to be validated.  This permits the 'expiration detection'
        // hard validator to run which catches this condition and generates the appropriate validation
        // result.
        //
		// check if req has expired only if not (methodType == CREATE and expirationDate == null)
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if ( methodType != RequestUtil.METHODTYPE_CREATOR &amp;&amp;</span>
<span class="nc bnc" id="L475" title="All 4 branches missed.">            getExpirationDate() != null &amp;&amp; hasExpired() ) {</span>
<span class="nc" id="L476">			return false;</span>
        }

<span class="nc" id="L479">		return true;</span>
	}
	protected Collection getHardValidationStatesToBeSkipped(){
<span class="fc" id="L482">		return RequestAuditTrail.SKIP_HARD_VALIDATION_STATES;</span>
	}
	//should be overriden for each request type if diff validation states are reqd (TOREquest has more soft validation states)
	protected Collection getSoftValidationStates() {
<span class="nc" id="L486">		return RequestAuditTrail.SOFT_VALIDATION_STATES;</span>
	}
	protected Collection getWaitlistElgibleStates(){
<span class="fc" id="L489">		return RequestAuditTrail.WAITLIST_ELIGIBLE_STATES;</span>
	}

    public void setAuditTrail(RequestAuditTrail pAuditTrail) {
<span class="fc" id="L493">        m_aggdRequest.setAuditTrail(pAuditTrail);</span>
<span class="fc" id="L494">    }</span>

    public void setAuditTrailSet(boolean auditTrailSet) {
<span class="fc" id="L497">        m_aggdRequest.setAuditTrailSet(auditTrailSet);</span>
<span class="fc" id="L498">    }</span>

    
    public void logException(Exception e){
<span class="nc" id="L502">    	m_cat.error(e.getMessage(), e);</span>
<span class="nc" id="L503">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>