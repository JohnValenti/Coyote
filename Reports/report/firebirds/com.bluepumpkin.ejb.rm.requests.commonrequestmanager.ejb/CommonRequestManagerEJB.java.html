<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CommonRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb</a> &gt; <span class="el_source">CommonRequestManagerEJB.java</span></div><h1>CommonRequestManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * CommonRequestManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDStringPair;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.core.filterconfig.ejb.FilterConfigManager;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAuditTrailDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestCollection;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.custshift.ejb.CustShiftReqMgr;
import com.bluepumpkin.ejb.rm.requests.flextime.ejb.FlexTimeRequestManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.ejb.ShiftSwapRequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBidDAO;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.model.TimeOffBid;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;

/**
 * EJB implementation for CommonRequestManager. This ejb provides common methods for managaging collections of requests.
 */
<span class="pc bpc" id="L84" title="1 of 2 branches missed.">public class CommonRequestManagerEJB extends SessionEJBBase implements ICommonRequestManager { // OUTSIDE_CONTAINER</span>
// public class CommonRequestManagerEJB extends SessionEjbBaseForTest implements CommonRequestManager { //OUTSIDE_CONTAINER
<span class="fc" id="L86">	private static Category m_cat = Log.initCategory(CommonRequestManagerEJB.class.getName());</span>

<span class="fc" id="L88">	private static String m_className = CommonRequestManagerEJB.class.getName();</span>

	public static final String TABLE_EMPLOYEEAM_ALIAS = RequestUtil.TABLE_EMPLOYEEAM_ALIAS;

	/*
	 * This array and m_requestEJBManagersArr are linked. ie corresponding elements of both the list have the same request type.
	 */
<span class="fc" id="L95">	private final static String[] m_requestTypesArr = { Request.REQUESTTYPE_SHIFTSWAP, Request.REQUESTTYPE_TIMEOFF,</span>
			Request.REQUESTTYPE_FLEXTIME, Request.REQUESTTYPE_SHIFTBID, Request.REQUESTTYPE_CUSTSHIFT };

	// ====================================================================
	/**
	 * Each of the request type remote interfaces implement IRequestType. This
	 */
<span class="fc" id="L102">	private IRequestType[] m_requestEJBManagersArr = null;</span>

<span class="fc" id="L104">	private HashMap m_requestEJBManagersMap = null;</span>

<span class="fc" id="L106">	private final RmManagerFactory m_managerFactory = RmManagerFactory.getInstance(true);</span>

<span class="fc" id="L108">	public CommonRequestManagerEJB() throws Exception {</span>
<span class="fc" id="L109">		super.init(m_className);</span>

<span class="fc" id="L111">		m_requestEJBManagersArr = new IRequestType[m_requestTypesArr.length];</span>

<span class="fc" id="L113">		m_requestEJBManagersMap = new HashMap(m_requestTypesArr.length);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">		for (int i = 0; i &lt; m_requestTypesArr.length; i++) {</span>
<span class="fc" id="L116">			m_requestEJBManagersArr[i] = m_managerFactory.getRequestManagerByType(m_requestTypesArr[i], null, null);</span>

<span class="fc" id="L118">			m_requestEJBManagersMap.put(m_requestTypesArr[i], m_requestEJBManagersArr[i]);</span>
		}
<span class="fc" id="L120">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L125">		return m_cat;</span>
	}

	// General methods:
	// returns a Request
	@Override
	public RequestAggregate getRequestByID(ID requestId, String requestType, boolean incExpired, boolean runSoftValids,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L133">		String _method_ = &quot;getRequestByID&quot;; // necessary for logging</span>
<span class="fc" id="L134">		methodStart(_method_, requestId, requestType);</span>

<span class="pc bpc" id="L136" title="1 of 2 branches missed.">		if (requestId == null) {</span>
<span class="nc" id="L137">			throw new IllegalArgumentException(&quot;requestId&quot;);</span>
		}

<span class="pc bpc" id="L140" title="1 of 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L141">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="fc" id="L144">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L145">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L147">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="fc" id="L148">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="pc bpc" id="L150" title="1 of 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L151">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="fc" id="L154">			return manager.getRequestByID(requestId, incExpired, runSoftValids, detailLevel);</span>
<span class="nc" id="L155">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L156">			m_cat.error(e, e);</span>
<span class="nc" id="L157">			handleException(e);</span>
<span class="nc" id="L158">			throw e;</span>
<span class="nc" id="L159">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L166">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L167">			throw e;</span>
<span class="nc" id="L168">		} catch (Exception e) {</span>
<span class="nc" id="L169">			this.handleException(e);</span>
<span class="nc" id="L170">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L172" title="3 of 4 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L173">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc" id="L174">			methodFinish();</span>
		}
	}

	// returns a Collection of non-validated common portion of Requests given a Collection of requestIds

	/*
	 * public Collection getRequestsByID (Collection requestIds ) throws BbmFinderException, RemoteException { String _method_ =
	 * &quot;getRequestsByID/1&quot;; methodStart(_method_, requestIds); if (requestIds == null) { throw RequestUtil.createBbmFinderException(
	 * RmEjbBundleKey.BUNDLE, RmEjbBundleKey.INVALID_VALUE, new Object[] {_method_, m_className, &quot;requestIds&quot;, requestIds}); }
	 *
	 * RequestManager manager = m_managerFactory.getRequestManager(); try { return manager.findRequestsByIds(requestIds); } catch
	 * (BbmFinderException e) { this.handleException(_method_, e, false); throw e; } finally { methodFinish(); } }
	 */

	// returns a Collection of validated specific Requests (e.g. TO, SS, SB)
	@Override
	public Collection getRequestsByID(Collection requestIds, String reqType, boolean incExpired, boolean runSoftValids,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L193">		String _method_ = &quot;getRequestsByID&quot;; // necessary for logging.</span>
<span class="nc" id="L194">		methodStart(_method_, requestIds, reqType, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="nc bnc" id="L196" title="All 2 branches missed.">		if (requestIds == null) {</span>
<span class="nc" id="L197">			throw new IllegalArgumentException(&quot;requestIds&quot;);</span>
		}

<span class="nc bnc" id="L200" title="All 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L201">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

<span class="nc" id="L204">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L205">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L207">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L208">			IRequestType manager = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L210" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L211">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L214">			return manager.getRequestsById(requestIds, incExpired, runSoftValids, true, detailLevel);</span>
<span class="nc" id="L215">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L216">			m_cat.error(e, e);</span>
<span class="nc" id="L217">			handleException(e);</span>
<span class="nc" id="L218">			throw e;</span>
<span class="nc" id="L219">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L226">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L227">			throw e;</span>
<span class="nc" id="L228">		} catch (Exception e) {</span>
<span class="nc" id="L229">			handleException(e);</span>
<span class="nc" id="L230">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L232" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L233">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L234">			methodFinish();</span>
		}
	}

	// returns a count of the Requests of type requestType for an employee
	@Override
	public int getRequestsCountForEmployee(ID employeeId, String requestType) throws BbmFinderException, RmException,
			RmHardValidationException {
<span class="nc" id="L242">		String _method_ = &quot;getRequestsCountForEmployee&quot;; // necessary for logging</span>
<span class="nc" id="L243">		methodStart(_method_, employeeId, requestType);</span>

<span class="nc bnc" id="L245" title="All 2 branches missed.">		if (employeeId == null) {</span>
<span class="nc" id="L246">			throw new IllegalArgumentException(&quot;employeeId&quot;);</span>
		}

<span class="nc bnc" id="L249" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L250">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

		IRequestType manager;
<span class="nc" id="L254">		Collection requests = new ArrayList(21);</span>

<span class="nc" id="L256">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L257">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L259">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L261" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(requestType)) {</span>
<span class="nc" id="L262">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L264" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L265">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L268">				requests = manager.getRequestIdsByEmployee(employeeId, false);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">				if (requests == null) {</span>
<span class="nc" id="L270">					throw RequestUtil.createRmException(RmEjbLogBundleKey.NO_OBJECTS, null, m_cat);</span>
				}

<span class="nc" id="L273">				return requests.size();</span>
			} else {
<span class="nc bnc" id="L275" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L276">					manager = m_requestEJBManagersArr[i];</span>
<span class="nc" id="L277">					requests.addAll(manager.getRequestIdsByEmployee(employeeId, false));</span>
				}

<span class="nc" id="L280">				return requests.size();</span>
			}
<span class="nc" id="L282">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L283">			m_cat.error(e, e);</span>
<span class="nc" id="L284">			handleException(e);</span>
<span class="nc" id="L285">			throw e;</span>
<span class="nc" id="L286">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L293">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L294">			throw e;</span>
<span class="nc" id="L295">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L298">			handleException(e);</span>
<span class="nc" id="L299">			throw e;</span>
<span class="nc" id="L300">		} catch (Exception e) {</span>
<span class="nc" id="L301">			handleException(e);</span>
<span class="nc" id="L302">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L304" title="All 6 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L305">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L306">			methodFinish();</span>
		}
	}

	/**
	 * returns a Collection of Requests (agent view).
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are &lt;li&gt;Each 'request manager' (which handles a
	 * specific type of request) delegated to by this method manages its own transaction. Thus any error, when fetching requests
	 * within a request manager, only rolls back the transaction it started. If transaction support == 'requires' for this method
	 * instead of 'NotSupported, then the transaction started by this method will be rolledback.
	 *
	 * @param employeeId
	 * @param reqType 'all', 'shift-swap','time-off', 'flex-time', 'shift-bid'
	 * @param incExpired
	 * @param runSoftValids
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	@Override
	public Collection getRequestsByEmployee(ID empID, String reqType, boolean incExpired, boolean runSoftValids, long detailLevel)
			throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L329">		String _method_ = &quot;getRequestsByEmployee&quot;; // necessary for logging.</span>
<span class="fc" id="L330">		methodStart(_method_, empID, reqType, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="pc bpc" id="L332" title="1 of 2 branches missed.">		if (empID == null) {</span>
<span class="nc" id="L333">			throw new IllegalArgumentException(&quot;empID&quot;);</span>
		}

<span class="pc bpc" id="L336" title="1 of 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L337">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

<span class="fc" id="L340">		ArrayList requests = new ArrayList(10);</span>

<span class="fc" id="L342">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L343">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L345">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// if a specific request type is requested.
<span class="pc bpc" id="L348" title="1 of 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(reqType)) {</span>
				// 'activate agent TO workflow' setting is enforced by webtier
				// when requestType != all (eg: if reqType == 'timeoff', then webtier does not fetch
				// requests if this setting is off).
<span class="nc" id="L352">				IRequestType reqMgr = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">				if (reqMgr == null) {</span>
<span class="nc" id="L355">					throw new IllegalArgumentException(&quot;reqMgr&quot;);</span>
				}

<span class="nc" id="L358">				return reqMgr.getRequestsByEmployee(empID, incExpired, runSoftValids, detailLevel);</span>
			} else { // if reqType == 'all'
				// get 'activate agent TO workflow' setting for employee's organization. This
				// setting is processed only for reqType == 'all'. For specific request types, this
				// processing is done by webtier (if reqType == 'timeoff', then webtier does not fetch
				// requests if this setting is off).
<span class="fc" id="L364">				ID empOrgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>
<span class="fc" id="L365">				OrganizationSetting empOrgSetting = CacheUtilRM.getOrgSetting(empOrgID);</span>
<span class="fc" id="L366">				boolean AGTOWFlowActive = empOrgSetting.getAgentTimeOffWorkflowActive();</span>

<span class="fc bfc" id="L368" title="All 2 branches covered.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="fc" id="L369">					IRequestType reqMgr = m_requestEJBManagersArr[i];</span>

					// get type of request manager.
<span class="fc" id="L372">					String reqTypeForReqMgr = m_requestTypesArr[i];</span>

					// if type == 'timeoff' and 'activate agent TO workflow' == false, skip fetching TO requets.
<span class="pc bpc" id="L375" title="1 of 4 branches missed.">					if (reqTypeForReqMgr.equals(Request.REQUESTTYPE_TIMEOFF) &amp;&amp; !AGTOWFlowActive)</span>
<span class="nc" id="L376">						continue;</span>

					// if an exception is thrown when fetching a request type, continue with the other
					// request types.
					try {
<span class="fc" id="L381">						Collection reqsForEmp = reqMgr.getRequestsByEmployee(empID, incExpired, runSoftValids, detailLevel);</span>

<span class="fc" id="L383">						requests.addAll(reqsForEmp);</span>
<span class="nc" id="L384">					} catch (Exception e) {</span>
<span class="nc" id="L385">						m_cat.error(&quot;Not propogating caught exception: &quot; + e.getMessage(), e);</span>
<span class="nc" id="L386">						continue;</span>
<span class="fc" id="L387">					}</span>
					// if code added below, note 'continue' within 'try' block above.
				}

<span class="fc" id="L391">				return requests;</span>
			}
<span class="nc" id="L393">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L394">			m_cat.error(e, e);</span>
<span class="nc" id="L395">			handleException(e);</span>
<span class="nc" id="L396">			throw e;</span>
<span class="nc" id="L397">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L404">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L405">			throw e;</span>
<span class="nc" id="L406">		} catch (Exception e) {</span>
<span class="nc" id="L407">			handleException(e);</span>
<span class="nc" id="L408">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L410" title="5 of 6 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L411">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc" id="L412">			methodFinish();</span>
		}
	}

	/**
	 * Find all the requests in manager's view.
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are &lt;li&gt;If all requests are retrieved without
	 * pagination, then a transaction timeout will occur since it may take a few minutes to retrieve all transactions. &lt;li&gt;Each
	 * 'request manager' (which handles a specific type of request) delegated to by this method manages its own transaction. Thus
	 * any error, when fetching requests within a request manager, only rolls back the transaction it started. If transaction
	 * support == 'requires' for this method instead of 'NotSupported, then the transaction started by this method will be
	 * rolledback.
	 *
	 *
	 * @param empID the employee ID of the manager
	 * @param filterID the id of the request filter controlling the scope of requests returned. This input can be null. If null,
	 *            then all by all employees in organizations for which the manager is able to view requests are returned.
	 * @param findName an additional filter that is applied to the set of employees. Only employees whose names contain the the
	 *            findName as a substring will be returned. This input may be null. If not null, then findName is checked agains the
	 *            string FIRST_NAME||&quot; &quot;||LAST_NAME for the CONTAINS relation. The comparison is case sensitive.
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDirection this controls whether or not the sort is ascending or descending. The constants that define this input
	 *            are defined in {@link com.bluepumpkin.ejb.core.base.SupportNavigation SupportNavigation}
	 * @param chunkSize the maximum number of request value objects to return. The resulting RequestCollection will have at most
	 *            this many request objects in it. Webtier specifies Integer.MAX_VALUE to mean CHUNKSIZE_ALL. to return all the
	 *            requests objects matching the filter at once.
	 * @return a request collection that contains a list of requests as well as a map of employeeIds to EmployeeName objects
	 */
	@Override
	public RequestCollection getRequestsForManager(ID empID, ID filterID, String findName, int sortColumn, int sortDirection,
			int chunkSize, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel)
			throws BbmFinderException, RmHardValidationException {

<span class="nc" id="L447">		String methodName = &quot;getRequestsForManager&quot;;</span>
<span class="nc" id="L448">		methodStart(methodName, new Object[] { empID, filterID, findName, new Integer(sortColumn), new Integer(sortDirection),</span>
				new Integer(chunkSize), new Boolean(incExpired), new Boolean(runSoftValids) });

<span class="nc" id="L451">		String setterID = m_className + '.' + methodName + '_' + &quot;filterID&quot;;</span>
<span class="nc" id="L452">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L454">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// Get the request filter if specified
<span class="nc" id="L457">			RequestFilter requestFilter = null;</span>

<span class="nc bnc" id="L459" title="All 2 branches missed.">			if (filterID != null) {</span>
				try {
<span class="nc" id="L461">					requestFilter = getRequestFilterById(filterID);</span>
<span class="nc" id="L462">				} catch (Exception e) {</span>
<span class="nc" id="L463">					m_cat.error(&quot;Error getting request filter&quot;, e);</span>
<span class="nc" id="L464">				}</span>

				// If unable to read filter for id, then t_hrow a BbmFinderException
<span class="nc bnc" id="L467" title="All 2 branches missed.">				if (requestFilter == null) {</span>
<span class="nc" id="L468">					throw new NullPointerException(&quot;requestFilter&quot;);</span>
				}
			}

			// Invoke the adhoc version now that we have the filter object, if specified
<span class="nc" id="L473">			return getRequestsForManager(empID, requestFilter, findName, sortColumn, sortDirection, chunkSize, incExpired,</span>
					runSoftValids, runNetStaffingSoftVal, detailLevel);
<span class="nc" id="L475">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L476">			m_cat.error(e, e);</span>
<span class="nc" id="L477">			handleException(e, false);</span>
<span class="nc" id="L478">			throw e;</span>
<span class="nc" id="L479">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L486">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L487">			throw e;</span>
<span class="nc" id="L488">		} catch (Exception e) { // TODO: ensure that no exception leaves any remote interface method without rolling back the</span>
								// exception.
<span class="nc" id="L490">			handleException(e, false);</span>
<span class="nc" id="L491">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L493" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L494">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L495">			methodFinish();</span>
		}
	}

	/**
	 * Find all the requests a manager's view.
	 *
	 * &lt;p&gt;
	 * Note that:
	 * &lt;li&gt;if Filter.STATUS_KEY is not set, then all reqs with status 'invalid', 'withdrawn' or 'negotiation' is filtered.
	 *
	 * Note: transaaction attribute == NotSupported. Primary motivations for this are
	 * &lt;li&gt;If all requests are retrieved without pagination, then a transaction timeout will occur since it may take a few minutes
	 * to retrieve all transactions.
	 * &lt;li&gt;Each 'request manager' (which handles a specific type of request) delegated to by this method manages its own
	 * transaction. Thus any error, when fetching requests within a request manager, only rolls back the transaction it started. If
	 * transaction support == 'requires' for this method instead of 'NotSupported, then the transaction started by this method will
	 * be rolledback.
	 *
	 * @param empID the employee ID of the manager
	 * @param filterID the id of the request filter controlling the scope of requests returned. This input can be null. If null,
	 *            then all by all employees in organizations for which the manager is able to view requests are returned.
	 * @param findName an additional filter that is applied to the set of employees. Only employees whose names contain the the
	 *            findName as a substring will be returned. This input may be null. If not null, then findName is checked agains the
	 *            string FIRST_NAME||&quot; &quot;||LAST_NAME for the CONTAINS relation. The comparison is case sensitive.
	 * @param sortColumn identifies the column to use to sort the requests. The constants that define the expected values are in
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
	 * @param sortDirection this controls whether or not the sort is ascending or descending. The constants that define this input
	 *            are defined in {@link com.bluepumpkin.ejb.core.base.SupportNavigation SupportNavigation}
	 * @param chunkSize the maximum number of request value objects to return. The resulting RequestCollection will have at most
	 *            this many request objects in it. Webtier specified Integer.MAX_VALUE to mean CHUNKSIZE_ALL to return all the
	 *            requests objects matching the filter at once.
	 * @return a request collection that contains a list of requests as well as a map of employeeIds to EmployeeName objects
	 */
	@Override
	public RequestCollection getRequestsForManager(ID mgrEmpID, RequestFilter reqFilter, String findName, int sortColumn,
			int sortDirection, int chunkSize, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal,
			long detailLevel) throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L533">		String _method_ = &quot;getRequestsForManager&quot;;</span>
<span class="fc" id="L534">		methodStart(_method_, new Object[] { mgrEmpID, reqFilter, findName, new Integer(sortColumn), new Integer(sortDirection),</span>
				new Integer(chunkSize), new Boolean(incExpired), new Boolean(runSoftValids) });

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">		if (mgrEmpID == null) {</span>
<span class="nc" id="L538">			throw new IllegalArgumentException(&quot;mgrEmpID&quot;);</span>
		}
<span class="fc" id="L540">		String setterID = m_className + '.' + _method_ + '_' + &quot;filter&quot;;</span>
<span class="fc" id="L541">		boolean cacheEnabled = false;</span>
<span class="fc" id="L542">		boolean threadCacheEnabled = false;</span>
		try {
<span class="fc" id="L544">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="fc" id="L545">			threadCacheEnabled = ThreadLocalCache.enable();</span>

			// if reqFilter == null, then create a default filter.
<span class="pc bpc" id="L548" title="1 of 2 branches missed.">			if (reqFilter == null) {</span>
<span class="nc" id="L549">				reqFilter = new RequestFilter(mgrEmpID, &quot;default filter&quot;);</span>
<span class="nc" id="L550">				reqFilter.setKey(RequestFilter.REQUEST_TYPE_KEY, Request.REQUESTTYPE_ALL);</span>
			}

<span class="fc" id="L553">			String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

			// This collection empIDsFiltered is used to filter requests by a given employee collection.
<span class="fc" id="L556">			Collection empIDsFiltered = null;</span>
			// EMPLOYEE_KEY is only used for the timeoff rest service
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">			if (reqFilter.isKeySet(RequestFilter.EMPLOYEE_KEY)) {</span>
<span class="nc" id="L559">				ID empId = (ID) reqFilter.getValueForKey(RequestFilter.EMPLOYEE_KEY);</span>
<span class="nc" id="L560">				empIDsFiltered = new ArrayList();</span>
<span class="nc" id="L561">				empIDsFiltered.add(empId);</span>
<span class="nc" id="L562">			}</span>
			// if EMPLOYEE_KEY is set, SUPERVISOR_KEY will not be effective
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">			else if (reqFilter.isKeySet(RequestFilter.SUPERVISOR_KEY)) {</span>
<span class="nc" id="L565">				empIDsFiltered = getEmpIDsForMgrUsingReqFilter(mgrEmpID, reqFilter);</span>
<span class="nc bnc" id="L566" title="All 4 branches missed.">				if (empIDsFiltered == null || empIDsFiltered.isEmpty()) {</span>
					// SUPERVISOR Key is set but no employees found for gievn SUPERVISOR; hence abort search and return
<span class="nc" id="L568">					return new RequestCollection(Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_MAP);</span>
				}
			}

<span class="fc" id="L572">			Collection mgrViewPrivOrgs = getOrgIDsForMgrUsingReqFilter(mgrEmpID, reqFilter);</span>
			// END QA 95168
			// Added by Sameet Apr 2008 to Support filtering by TO Pool
<span class="fc" id="L575">			Pair empIDSetPair = getEmpIDsForTOPool(reqFilter);</span>
<span class="pc bpc" id="L576" title="2 of 4 branches missed.">			if (empIDSetPair != null &amp;&amp; ((Boolean) empIDSetPair.getFirst()).booleanValue()) {</span>
<span class="nc" id="L577">				Collection empIDs = (Collection) empIDSetPair.getSecond();</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">				if (empIDs != null) {</span>
<span class="nc bnc" id="L579" title="All 2 branches missed.">					if (empIDsFiltered != null) {</span>
<span class="nc" id="L580">						empIDsFiltered.retainAll(empIDs);// make interesection of the two collections</span>
					} else {
<span class="nc" id="L582">						empIDsFiltered = empIDs;</span>
					}
				} else {
<span class="nc" id="L585">					empIDsFiltered = null;</span>
				}
				// We are interested only if the intersection of two collections is not empty
<span class="nc bnc" id="L588" title="All 4 branches missed.">				if (empIDsFiltered == null || empIDsFiltered.isEmpty()) {</span>
					// TOPOOL Key is set but no employees found in TOPOOL; hence abort search and return
<span class="nc" id="L590">					return new RequestCollection(Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_MAP);</span>
				}
			}
<span class="fc" id="L593">			Object[] fourElemArr = getRequestIDsSortedUsingReqFilter(empIDsFiltered, mgrViewPrivOrgs, reqFilter, findName,</span>
					incExpired, sortColumn, sortDirection);
<span class="fc" id="L595">			List reqIDsAfterFilter = (List) fourElemArr[0];</span>
<span class="fc" id="L596">			Map reqIDToReqTypeMap = (Map) fourElemArr[4];</span>
			// Map reqIDToReqTypeMap = RequestUtil.getReqIDToReqTypeMap(reqIDsAfterFilter, (List) fourElemArr[1]);

<span class="fc" id="L599">			List reqEmpIDsForReqIDs = (List) fourElemArr[2];</span>
<span class="fc" id="L600">			List reqEmpOrgIDForReqIDs = (List) fourElemArr[3];</span>

			// process requestIDs for org level setting: 'TimeOff Management' &gt; 'Activiate manager workflow'
			// Note: this method modifies the lists passed as parameters.
<span class="fc" id="L604">			processActivateManagerTOWorkflowSetting(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// process requestIDs for org level setting: 'Shift Swap' &gt; 'Enable Shift Swap'
			// Note: this method modifies the lists passed as parameters.
<span class="fc" id="L608">			processEnableShiftSwapSetting(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// QC 42221: If an employee creates a future request, and that employee will change orgs
			// before the effective date of the request, AND if a manager has privileges to view requests
			// for both the employee's current and future org, then the request will be duplicated.
			// Note: this method may modify the lists passed as parameters.
<span class="fc" id="L614">			removeDuplicateRequests(reqIDsAfterFilter, reqIDToReqTypeMap, reqEmpIDsForReqIDs, reqEmpOrgIDForReqIDs);</span>

			// Now process 'sort' criteria and 'filter' conditions which cannot be done at the SQL level.
			// Note: this filtering cannot be done for 'REQUEST_TYPE == all'. It can only be done for a
			// single request type.
<span class="fc" id="L619">			Collection reqs = null;</span>
			// This will hold the requests that are already queried if REquestType != All . Specially for
			// ShiftBIDs &amp; TimeOFF
<span class="pc bpc" id="L622" title="1 of 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
				// returns a Pair of RequestIds &lt;-&gt; Requests. The Collection of Request may be null based on implementation
<span class="nc" id="L624">				Pair reqsEmpIDsPairAfterFilter = applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsAfterFilter, reqFilter,</span>
						sortColumn, sortDirection, incExpired, detailLevel, runSoftValids, runNetStaffingSoftVal);
<span class="nc" id="L626">				reqIDsAfterFilter = (List) reqsEmpIDsPairAfterFilter.getFirst();</span>
<span class="nc" id="L627">				reqs = (Collection) reqsEmpIDsPairAfterFilter.getSecond();</span>
			}

			// if no reqIDs found after applying filter, return.
<span class="pc bpc" id="L631" title="1 of 4 branches missed.">			if (reqIDsAfterFilter == null || reqIDsAfterFilter.isEmpty()) {</span>
<span class="fc" id="L632">				return new RequestCollection(Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_MAP);</span>
			}

			// use min of returned size and chunk size to get request objects
<span class="pc bpc" id="L636" title="1 of 2 branches missed.">			int adjChunkSize = (chunkSize == Integer.MAX_VALUE) ? reqIDsAfterFilter.size() : chunkSize;</span>
			// limit to 4096 requests. Earlier bug at this point caused (#23290) caused an OutOfMemoryException when
			// marshalling results back to the caller.
<span class="fc" id="L639">			adjChunkSize = Math.min(adjChunkSize, 4096);</span>

			// use the reqIDs and reqTypes to invoke the appropriate request manager to load the actual requests
<span class="fc" id="L642">			Pair reqsEmpIDsPair = getReqsFromEJBManagersOrdered(reqIDsAfterFilter, reqIDToReqTypeMap,</span>
<span class="fc" id="L643">					Request.REQUESTTYPE_ALL.equals(filterReqType), incExpired, runSoftValids, runNetStaffingSoftVal, 0,</span>
					adjChunkSize, detailLevel, reqs);

			// filter expired requests; we expect the returned req list to be of type linkedList
			// since 'invalid' requests may be removed from the middle of the list.
<span class="fc" id="L648">			LinkedList sortedReqs = (LinkedList) reqsEmpIDsPair.getFirst();</span>
			// filterInvalidRequests(sortedReqs);

			// Use set of employee ids to get name map
<span class="fc" id="L652">			Set reqEmpIDs = (Set) reqsEmpIDsPair.getSecond();</span>
<span class="fc" id="L653">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="fc" id="L654">			Map nameMap = wrm.getEmployeeNamesByIDs(reqEmpIDs);</span>
			// build rquest collection and return to caller
<span class="fc" id="L656">			return new RequestCollection(reqIDsAfterFilter, sortedReqs, nameMap);</span>
<span class="nc" id="L657">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L658">			m_cat.error(e, e);</span>
<span class="nc" id="L659">			handleException(e, false);</span>
<span class="nc" id="L660">			throw e;</span>
<span class="nc" id="L661">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L668">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L669">			throw e;</span>
<span class="nc" id="L670">		} catch (Exception e) {</span>
<span class="nc" id="L671">			handleException(e, false);</span>
<span class="nc" id="L672">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L674" title="8 of 10 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L675">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc" id="L676">			ThreadLocalCache.clear(threadCacheEnabled);</span>
<span class="pc" id="L677">			methodFinish();</span>
		}
	}

	/**
	 * returns a Pair of RequestIds &lt;-&gt; Requests. The Collection of Request may be null based on implementation of each
	 * RequestManager
	 *
	 * @param reqIDsAfterFilter
	 * @param reqFilter
	 * @param sortColumn
	 * @param sortDirection
	 * @param inclExpired
	 * @param detailLevel
	 */
	@Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDsAfterFilter, RequestFilter reqFilter, int sortColumn,
			int sortDirection, boolean inclExpired, long detailLevel, boolean runSoftValids, boolean runNetStaffingSoftVal)
			throws BbmFinderException {

		// filtering at the 'java' level is presently supported only for a single request type and not
		// for request type == all.
<span class="nc" id="L699">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">		if (Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
<span class="nc" id="L701">			throw new IllegalArgumentException(&quot;RequestFilter.requestType cannot be ALL&quot;);</span>
		}
<span class="nc" id="L703">		IRequestType reqMgr = (IRequestType) m_requestEJBManagersMap.get(filterReqType);</span>
		try {
<span class="nc" id="L705">			return reqMgr.applyFilterAndSortCriteriaForReqIDs(mgrEmpID, reqIDsAfterFilter, reqFilter, sortColumn, sortDirection,</span>
					inclExpired, detailLevel, runSoftValids, runNetStaffingSoftVal);
<span class="nc" id="L707">		} catch (Exception e) {</span>
<span class="nc" id="L708">			handleException(e);</span>
<span class="nc" id="L709">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Get the next chunk of requests for display in a manager view. This interface is designed to be called when paging through a
	 * set of results returned by {@link #getRequestsForManager getRequestsForManager}. The caller must preserve the complete lists
	 * of ids and their associated types from a previous call to {@link #getRequestsForManager getRequestsForManager}.
	 *
	 * @param empID the employee ID of the manager
	 * @param ids this is a sublist of the complete list of ids. The caller selects this list of ids to display.
	 * @param types this is the list of request types that correspond to the list or request ids being passed in
	 * @return a request collection that contains
	 *         &lt;ul&gt;
	 *         &lt;li&gt;the same list of request ids passed in. This list isn't terribly useful for the caller. The original list
	 *         returned by {@link #getRequestsForManager getRequestsForManager} must be preserved,&lt;/li&gt;
	 *         &lt;li&gt;the same list of types passed in,&lt;/li&gt;
	 *         &lt;li&gt;a list of the requested request objects,&lt;/li&gt;
	 *         &lt;li&gt;map of employeeId-&gt;EmployeeName objects. The set of employees is the complete set of employees referenced in the
	 *         returned set of request objects.&lt;/li&gt;
	 *         &lt;/ul&gt;
	 */
	@Override
	public RequestCollection getNextRequestsForManager(ID mgrEmpID, List givenIDs, RequestFilter reqFilter, boolean incExpired,
			boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel) throws BbmFinderException,
			RmHardValidationException {
<span class="fc" id="L735">		String _method_ = &quot;getNextRequestsForManager&quot;;</span>
<span class="fc" id="L736">		methodStart(_method_, mgrEmpID, givenIDs, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="fc" id="L738">		Jdmo dmo = null;</span>

<span class="fc" id="L740">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L741">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L743">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// Need to get a map of IDs to types
			// TODO: this is only necessary for reqtype == ALL. modify method args to accept filter ID.
<span class="fc" id="L747">			JdmoRowset rs = null;</span>
<span class="fc" id="L748">			Map reqIDToType = null;</span>
			try {
<span class="fc" id="L750">				dmo = new Jdmo(false);</span>

				// TODO: move this to RequestDAO. Same for similar code from earlier method.
<span class="fc" id="L753">				String query = &quot;SELECT A.ID, A.REQUESTTYPE FROM REQUEST A  WHERE A.ID IN &quot; + dmo.createInClause(givenIDs);</span>
<span class="fc" id="L754">				final DAOUtil.ColumnMetaData[] reqIDReqTypeColMetaData = new DAOUtil.ColumnMetaData[] {</span>
						new DAOUtil.ColumnMetaData(DAOUtil.ColumnMetaData.COLUMNTYPE_ID, 1),
						new DAOUtil.ColumnMetaData(DAOUtil.ColumnMetaData.COLUMNTYPE_STRING, 2) };
<span class="fc" id="L757">				reqIDToType = DAOUtil.getFromSQLQueryColMap(dmo, query, reqIDReqTypeColMetaData, givenIDs.size());</span>
			} finally {
<span class="pc bpc" id="L759" title="3 of 4 branches missed.">				if (rs != null)</span>
<span class="nc" id="L760">					rs.close();</span>
			}

			// TODO: optimize: isReqTypeAll == true|false.
<span class="fc" id="L764">			Pair reqsEmpIDsPair = getReqsFromEJBManagersOrdered(givenIDs, reqIDToType, true, incExpired, runSoftValids,</span>
<span class="fc" id="L765">					runNetStaffingSoftVal, 0, givenIDs.size(), detailLevel, null);</span>

			// filter expired requests; we expect the returned req list to be of type linkedList
			// since 'invalid' requests may be removed from the middle of the list.
<span class="fc" id="L769">			LinkedList orderedReqs = (LinkedList) reqsEmpIDsPair.getFirst();</span>
			// filterInvalidRequests(orderedReqs);

			// get map of empID to empName
<span class="fc" id="L773">			Collection reqEmpIDs = (Collection) reqsEmpIDsPair.getSecond();</span>
<span class="fc" id="L774">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="fc" id="L775">			Map empIDToEmpNameMap = wrm.getEmployeeNamesByIDs(reqEmpIDs);</span>
			// build rquest collection and return to caller
<span class="fc" id="L777">			return new RequestCollection(givenIDs, orderedReqs, empIDToEmpNameMap);</span>
<span class="nc" id="L778">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L779">			m_cat.error(e, e);</span>
<span class="nc" id="L780">			handleException(e);</span>
<span class="nc" id="L781">			throw e;</span>
<span class="nc" id="L782">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L789">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L790">			throw e;</span>
<span class="nc" id="L791">		} catch (Exception e) {</span>
<span class="nc" id="L792">			handleException(e);</span>
<span class="nc" id="L793">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L795" title="3 of 4 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L796">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc bpc" id="L797" title="3 of 4 branches missed.">			if (dmo != null)</span>
<span class="pc" id="L798">				dmo.cleanUp();</span>
<span class="pc" id="L799">			methodFinish();</span>
		}
	}

	private void filterInvalidRequests(LinkedList sortedReqs) {
<span class="nc bnc" id="L804" title="All 2 branches missed.">		for (Iterator iter = sortedReqs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L805">			RequestAggregate reqAgg = (RequestAggregate) iter.next();</span>
			// if request is invalid, remove from collection.
<span class="nc bnc" id="L807" title="All 2 branches missed.">			if (RequestAuditTrail.STATUS_INVALID.equals(reqAgg.getRequestStatus())) {</span>
<span class="nc" id="L808">				iter.remove();</span>
			}
<span class="nc" id="L810">		}</span>
<span class="nc" id="L811">	}</span>

	// creates a Request
	@Override
	public ID createRequest(RequestAggregate request, String comment) throws BbmCreateException, RmHardValidationException {
<span class="nc" id="L816">		String _method_ = &quot;createRequest&quot;; // used elsewhere as well</span>
<span class="nc" id="L817">		methodStart(&quot;createRequest&quot;, request, comment);</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">		if (request == null) {</span>
<span class="nc" id="L820">			throw new IllegalArgumentException(&quot;request&quot;);</span>
		}

<span class="nc" id="L823">		String requestType = request.getRequestType();</span>
<span class="nc" id="L824">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L825">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L827">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L829">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L831" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L832">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L835">			return manager.createRequest(request, comment);</span>
<span class="nc" id="L836">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L837">			m_cat.error(e, e);</span>
<span class="nc" id="L838">			handleException(e);</span>
<span class="nc" id="L839">			throw e;</span>
<span class="nc" id="L840">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L847">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L848">			throw e;</span>
<span class="nc" id="L849">		} catch (Exception e) {</span>
<span class="nc" id="L850">			handleException(e);</span>
<span class="nc" id="L851">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L853" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L854">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L855">			methodFinish();</span>
		}
	}

	// updates a Request
	@Override
	public void updateRequest(RequestAggregate request, String comment) throws BbmUpdateException, MultiUserException,
			RmHardValidationException {
<span class="nc" id="L863">		String _method_ = &quot;updateRequest&quot;; // used elsewhere as well.</span>
<span class="nc" id="L864">		methodStart(_method_, request, comment);</span>

<span class="nc bnc" id="L866" title="All 2 branches missed.">		if (request == null) {</span>
<span class="nc" id="L867">			throw new IllegalArgumentException(&quot;request&quot;);</span>
		}

<span class="nc" id="L870">		String requestType = request.getRequestType();</span>
<span class="nc" id="L871">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L872">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L874">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L876">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L878" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L879">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L882">			manager.updateRequest(request, comment);</span>
<span class="nc" id="L883">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L884">			m_cat.error(e, e);</span>
<span class="nc" id="L885">			handleException(e);</span>
<span class="nc" id="L886">			throw e;</span>
<span class="nc" id="L887">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L894">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L895">			throw e;</span>
<span class="nc" id="L896">		} catch (MultiUserException e) {</span>
<span class="nc" id="L897">			m_cat.error(e, e);</span>
<span class="nc" id="L898">			handleException(e);</span>
<span class="nc" id="L899">			throw e;</span>
<span class="nc" id="L900">		} catch (Exception e) {</span>
<span class="nc" id="L901">			handleException(e);</span>
<span class="nc" id="L902">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L904" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L905">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L906">			methodFinish();</span>
<span class="nc" id="L907">		}</span>
<span class="nc" id="L908">	}</span>

	// change the state of a Request (specific processing to be handled by back-end)
	@Override
	public void changeRequestState(ID requestId, String state, String objectVersionNumber, String comment, String requestType)
			throws RmException, RmHardValidationException {
<span class="fc" id="L914">		String _method_ = &quot;changeRequestState&quot;;</span>
<span class="fc" id="L915">		methodStart(_method_, requestId, state, comment, requestType);</span>

<span class="fc" id="L917">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L918">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L920">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L922">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>
<span class="pc bpc" id="L923" title="1 of 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L924">				throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_REQUEST_TYPE, new Object[] { requestType }, m_cat);</span>
			}

<span class="fc" id="L927">			manager.changeRequestStateByID(requestId, state, objectVersionNumber, comment);</span>
<span class="nc" id="L928">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L935">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L936">			throw e;</span>
<span class="nc" id="L937">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L940">			handleException(e);</span>
<span class="nc" id="L941">			throw e;</span>
<span class="nc" id="L942">		} catch (Exception e) {</span>
<span class="nc" id="L943">			handleException(e);</span>
<span class="nc" id="L944">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L946" title="3 of 4 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L947">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc" id="L948">			methodFinish();</span>
<span class="fc" id="L949">		}</span>
<span class="fc" id="L950">	}</span>

	/**
	 * Process a group of requests for one of the following actions: &lt;li&gt;@see CommonRequestManager#GA_APPROVE_ALL_WITHOUT_VIOL &lt;li&gt;@see
	 * CommonRequestManager#GA_TENT_APPROVE_ALL_WITHOUT_VIOL &lt;li&gt;@see CommonRequestManager#GA_DENY_ALL_WITH_VIOLATIONS &lt;li&gt;@see
	 * CommonRequestManager#GA_CONFIRM_ALL_TENT_APPROVALS &lt;li&gt;@see CommonRequestManager#GA_REMOVE_ALL_TENT_APPROVALS
	 *
	 * Note: transaction attribute == 'Not supported'.
	 *
	 * @see CommonRequestManager#processRequests(Collection, Collection, String)
	 *
	 */
	@Override
	public void processRequests(Collection reqIDs, Collection objVerNums, String reqAction) throws RmException,
			RmHardValidationException {
<span class="nc" id="L965">		String _method_ = &quot;processRequests&quot;;</span>
<span class="nc" id="L966">		methodStart(_method_, reqIDs, objVerNums, reqAction);</span>

<span class="nc" id="L968">		RequestDAO reqDAO = null;</span>
<span class="nc" id="L969">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L970">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L972">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// load the request objects (without their children) to identify the request type.
<span class="nc" id="L975">			reqDAO = new RequestDAO(Request.REQUESTTYPE_ALL, Request.DL_BASIC);</span>
<span class="nc" id="L976">			Collection requests = reqDAO.getRequestsByIDs(reqIDs, Request.DL_BASIC);</span>
			// build a map or request ID to request.
<span class="nc" id="L978">			Map reqIDToReqMap = RequestUtil.getMapOfIDsForVOBases(requests);</span>

<span class="nc" id="L980">			ShiftSwapRequestManager ssMgr = (ShiftSwapRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_SHIFTSWAP);</span>
<span class="nc" id="L981">			TORequestManager toMgr = (TORequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_TIMEOFF);</span>
<span class="nc" id="L982">			FlexTimeRequestManager ftMgr = (FlexTimeRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_FLEXTIME);</span>
<span class="nc" id="L983">			ShiftBidRequestManager sbReqMgr = (ShiftBidRequestManager) m_requestEJBManagersMap.get(Request.REQUESTTYPE_SHIFTBID);</span>
<span class="nc" id="L984">			CustShiftReqMgr csReqMgr = (CustShiftReqMgr) m_requestEJBManagersMap.get(Request.REQUESTTYPE_CUSTSHIFT);</span>

<span class="nc" id="L986">			Map&lt;ID, RequestAggregate&gt; toRequestMap = ftMgr.getRequestMapByIDs(reqIDs, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP);</span>

			// identify the type of request (using the IDs)
<span class="nc" id="L989">			Iterator verNumItr = objVerNums.iterator();</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">			for (Iterator reqIDsItr = reqIDs.iterator(); reqIDsItr.hasNext();) {</span>
				// get the request's ID
<span class="nc" id="L992">				ID reqID = (ID) reqIDsItr.next();</span>
				// get the version number
<span class="nc bnc" id="L994" title="All 2 branches missed.">				if (!verNumItr.hasNext())</span>
<span class="nc" id="L995">					throw new RuntimeException(&quot;Error: Cannot find version number for request with ID: &quot; + reqID);</span>
<span class="nc" id="L996">				String reqVerNum = (String) verNumItr.next();</span>

				// look up the request in the map by its ID.
<span class="nc" id="L999">				Request req = (Request) reqIDToReqMap.get(reqID);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">				if (req == null)</span>
<span class="nc" id="L1001">					throw new RuntimeException(&quot;Error: Cannot find request with ID in map: &quot; + reqID);</span>

				// set the object version number passed from the UI.
<span class="nc" id="L1004">				req.setObjectVersionNumber(reqVerNum);</span>

				// in the next catch handler, exception will be eaten or propogated based on this flag.
<span class="nc" id="L1007">				boolean propogateException = false;</span>
				try {
					// process based on request's type.
<span class="nc bnc" id="L1010" title="All 2 branches missed.">					if (req.isTimeOffRequest()) {</span>
<span class="nc" id="L1011">						RequestAggregate reqAggr = toRequestMap.get(reqID);</span>
<span class="nc bnc" id="L1012" title="All 4 branches missed.">						if(reqAggr != null &amp;&amp; reqAggr.isFlexTimeRequest()) {</span>
							//process single Flex Time Request
<span class="nc" id="L1014">							ftMgr.processSingleRequest(req, reqAction);</span>
						}
						else {
							//process single TO Request
<span class="nc" id="L1018">							toMgr.processSingleRequest(req, reqAction);</span>
						}
<span class="nc bnc" id="L1020" title="All 2 branches missed.">					} else if (req.isShiftSwapRequest()) {</span>
<span class="nc" id="L1021">						ssMgr.processSingleRequest(req, reqAction);</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">					} else if (req.isShiftBidRequest()) {</span>
<span class="nc" id="L1023">						sbReqMgr.processSingleRequest(req, reqAction);</span>
<span class="nc bnc" id="L1024" title="All 2 branches missed.">					} else if (req.isCustShiftRequest()) {</span>
<span class="nc" id="L1025">						csReqMgr.processSingleRequest(req, reqAction);</span>
					} else {
						// Normally, exceptions are not propogated to the caller by the catch handler. In this case, it should.
<span class="nc" id="L1028">						propogateException = true;</span>
<span class="nc" id="L1029">						throw new IllegalArgumentException(req.getRequestType());</span>
					}
<span class="nc" id="L1031">				} catch (Exception e) {</span>
<span class="nc" id="L1032">					m_cat.l7dError(RmEjbLogBundleKey.GROUP_ACTION_EXCEPTION, new Object[] { e.getLocalizedMessage() }, e);</span>

<span class="nc bnc" id="L1034" title="All 2 branches missed.">					if (propogateException) // if flag set to propogate, then rethrow.</span>
<span class="nc" id="L1035">						throw e;</span>
<span class="nc" id="L1036">				}</span>
<span class="nc" id="L1037">			}</span>
<span class="nc" id="L1038">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1045">			handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L1046">			throw e;</span>
<span class="nc" id="L1047">		} catch (RmException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1050">			handleException(e, false);</span>
<span class="nc" id="L1051">			throw e;</span>
<span class="nc" id="L1052">		} catch (Exception e) {</span>
<span class="nc" id="L1053">			handleException(e, false);</span>
<span class="nc" id="L1054">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1056" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1057">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc bnc" id="L1058" title="All 4 branches missed.">			if (reqDAO != null)</span>
<span class="nc" id="L1059">				reqDAO.cleanUp();</span>
<span class="nc" id="L1060">			methodFinish();</span>
<span class="nc" id="L1061">		}</span>
<span class="nc" id="L1062">	}</span>

	// deletes a Request
	@Override
	public void deleteRequest(ID requestId, String requestType, String comment) throws BbmRemoveException,
			RmHardValidationException {
<span class="nc" id="L1068">		String _method_ = &quot;deleteRequest&quot;;</span>
<span class="nc" id="L1069">		methodStart(_method_, requestId, requestType, comment);</span>

<span class="nc bnc" id="L1071" title="All 2 branches missed.">		if (requestId == null) {</span>
<span class="nc" id="L1072">			throw new IllegalArgumentException(&quot;requestId&quot;);</span>
		}

<span class="nc bnc" id="L1075" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1076">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1079">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1080">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1082">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1084">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1086" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L1087">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L1090">			manager.deleteRequest(requestId, comment);</span>
<span class="nc" id="L1091">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1098">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1099">			throw e;</span>
<span class="nc" id="L1100">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1101">			m_cat.error(e, e);</span>
<span class="nc" id="L1102">			handleException(e);</span>
<span class="nc" id="L1103">			throw e;</span>
<span class="nc" id="L1104">		} catch (Exception e) {</span>
<span class="nc" id="L1105">			handleException(e);</span>
<span class="nc" id="L1106">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1108" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1109">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L1110">			methodFinish();</span>
<span class="nc" id="L1111">		}</span>
<span class="nc" id="L1112">	}</span>

	// deletes a Collection of Requests
	@Override
	public void deleteRequests(Collection ids, String requestType, String comment) throws BbmRemoveException,
			RmHardValidationException {
<span class="nc" id="L1118">		String _method_ = &quot;deleteRequests&quot;;</span>
<span class="nc" id="L1119">		methodStart(_method_, ids, comment);</span>

<span class="nc bnc" id="L1121" title="All 2 branches missed.">		if (ids == null) {</span>
<span class="nc" id="L1122">			throw new IllegalArgumentException(&quot;ids&quot;);</span>
		}

<span class="nc bnc" id="L1125" title="All 2 branches missed.">		if (requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1126">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1129">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1130">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1132">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1134">			IRequestType manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1136" title="All 2 branches missed.">			if (manager == null) {</span>
<span class="nc" id="L1137">				throw new IllegalArgumentException(&quot;manager&quot;);</span>
			}

<span class="nc" id="L1140">			manager.deleteRequests(ids, comment);</span>
<span class="nc" id="L1141">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1142">			m_cat.error(e, e);</span>
<span class="nc" id="L1143">			handleException(e);</span>
<span class="nc" id="L1144">			throw e;</span>
<span class="nc" id="L1145">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1152">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1153">			throw e;</span>
<span class="nc" id="L1154">		} catch (Exception e) {</span>
<span class="nc" id="L1155">			handleException(e);</span>
<span class="nc" id="L1156">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1158" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1159">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L1160">			methodFinish();</span>
<span class="nc" id="L1161">		}</span>
<span class="nc" id="L1162">	}</span>

	/**
	 * Delete all the requests of the given type and subtype.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: All requests of this type
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByType(ID organizationId, boolean isForBranch, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="fc" id="L1183">		String _method_ = &quot;deleteRequestsByType&quot;;</span>
<span class="fc" id="L1184">		methodStart(_method_, organizationId, new Boolean(isForBranch), requestType, subType);</span>

<span class="pc bpc" id="L1186" title="1 of 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1187">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="pc bpc" id="L1190" title="1 of 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1191">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="fc" id="L1194">		IRequestType manager = null;</span>

<span class="fc" id="L1196">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L1197">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L1199">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="pc bpc" id="L1201" title="1 of 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="fc" id="L1202">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="pc bpc" id="L1204" title="1 of 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1205">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="fc" id="L1208">				manager.deleteRequests(organizationId, isForBranch, subType);</span>
			} else {
<span class="nc bnc" id="L1210" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1211">					manager = m_requestEJBManagersArr[i];</span>

					// Subtype does not make sense for ALL requests, ignore anything passed
					// and call the manager
<span class="nc" id="L1215">					manager.deleteRequests(organizationId, isForBranch, null);</span>
				}
			}
<span class="nc" id="L1218">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1219">			m_cat.error(e, e);</span>
<span class="nc" id="L1220">			handleException(e);</span>
<span class="nc" id="L1221">			throw e;</span>
<span class="nc" id="L1222">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1229">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1230">			throw e;</span>
<span class="nc" id="L1231">		} catch (Exception e) {</span>
<span class="nc" id="L1232">			handleException(e);</span>
<span class="nc" id="L1233">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L1235" title="3 of 4 branches missed.">			if (cacheEnabled)</span>
<span class="pc" id="L1236">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="pc" id="L1237">			methodFinish();</span>
<span class="fc" id="L1238">		}</span>
<span class="fc" id="L1239">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that concern dates that are older than the given date.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For the dates more than 'n' days
	 * in the past
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param date purge the requests that concern dates older than this date
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByDate(ID organizationId, boolean isForBranch, Date date, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1262">		String _method_ = &quot;deleteRequestsByDate&quot;;</span>
<span class="nc" id="L1263">		methodStart(_method_, organizationId, new Boolean(isForBranch), date, subType);</span>

<span class="nc bnc" id="L1265" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1266">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1269" title="All 2 branches missed.">		if (date == null) {</span>
<span class="nc" id="L1270">			throw new IllegalArgumentException(&quot;date&quot;);</span>
		}

<span class="nc bnc" id="L1273" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1274">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1277">		IRequestType manager = null;</span>

<span class="nc" id="L1279">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1280">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1282">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1284" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1285">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1287" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1288">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1291">				manager.deleteRequestsByDate(organizationId, isForBranch, date, subType);</span>
			} else {
<span class="nc bnc" id="L1293" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1294">					manager = m_requestEJBManagersArr[i];</span>

					// Subtype does not make sense for ALL requests, ignore anything passed
					// and call the manager
<span class="nc" id="L1298">					manager.deleteRequestsByDate(organizationId, isForBranch, date, null);</span>
				}
			}
<span class="nc" id="L1301">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1302">			m_cat.error(e, e);</span>
<span class="nc" id="L1303">			handleException(e);</span>
<span class="nc" id="L1304">			throw e;</span>
<span class="nc" id="L1305">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1312">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1313">			throw e;</span>
<span class="nc" id="L1314">		} catch (Exception e) {</span>
<span class="nc" id="L1315">			handleException(e);</span>
<span class="nc" id="L1316">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1318" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1319">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L1320">			methodFinish();</span>
<span class="nc" id="L1321">		}</span>
<span class="nc" id="L1322">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that were created in the given date range.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For requests created 'fromdate'
	 * to 'todate'
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param range the range to use when purging requests. All subject requests that were created within this time range will be
	 *            purged.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByDateRange(ID organizationId, boolean isForBranch, TimeRange range, String requestType, ID subType)
			throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1346">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L1347">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, requestType);</span>

<span class="nc bnc" id="L1349" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1350">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1353" title="All 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L1354">			throw new IllegalArgumentException(&quot;range&quot;);</span>
		}

<span class="nc bnc" id="L1357" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1358">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1361">		IRequestType manager = null;</span>

<span class="nc" id="L1363">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1364">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1366">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1368" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1369">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1371" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1372">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1375">				manager.deleteRequestsByDateRange(organizationId, isForBranch, range, subType);</span>
			} else {
<span class="nc bnc" id="L1377" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1378">					manager = m_requestEJBManagersArr[i];</span>

					// Ignore subtype parameter for type=ALL request
<span class="nc" id="L1381">					manager.deleteRequestsByDateRange(organizationId, isForBranch, range, null);</span>
				}
			}
<span class="nc" id="L1384">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1385">			m_cat.error(e, e);</span>
<span class="nc" id="L1386">			handleException(e);</span>
<span class="nc" id="L1387">			throw e;</span>
<span class="nc" id="L1388">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1395">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1396">			throw e;</span>
<span class="nc" id="L1397">		} catch (Exception e) {</span>
<span class="nc" id="L1398">			handleException(e);</span>
<span class="nc" id="L1399">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1401" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1402">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L1403">			methodFinish();</span>
<span class="nc" id="L1404">		}</span>
<span class="nc" id="L1405">	}</span>

	/**
	 * Delete all the requests of the given type and subtype that start in the given date range.
	 *
	 * This method is invoked when the following option is chosen in the purging screen of the UI: For requests starting during
	 * 'fromdate' to 'todate'
	 *
	 * @param organizationId the organization id for which to purge the requests
	 * @param isForBranch true=&gt; the purge request affects the given organization and all suborganizations, i.e. the whole &quot;branch&quot;.
	 *            false=&gt; the purge request affects only the given organization and not any organizations under it.
	 * @param range the range to use when purging requests. All subject requests that were created within this time range will be
	 *            purged.
	 * @param requestType the type of request to purge. This can be all or a specific type like time off or shift swap. The
	 *            constants to use for this parameter are defined in the
	 *            {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
	 * @param subType this ID parameter defines the subtype of the request type to purge. It can be null (and indeed should be for
	 *            requestType=ALL requests). Its meaning is request type dependent.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents the purge operation from completing
	 * @throws java.rmi.RemoteException when there was an RMI communication failure
	 */
	@Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, String requestType,
			ID subType) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1429">		String _method_ = &quot;deleteRequestsByStartDateRange&quot;;</span>
<span class="nc" id="L1430">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, requestType);</span>

<span class="nc bnc" id="L1432" title="All 2 branches missed.">		if (organizationId == null) {</span>
<span class="nc" id="L1433">			throw new IllegalArgumentException(&quot;organizationId&quot;);</span>
		}

<span class="nc bnc" id="L1436" title="All 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L1437">			throw new IllegalArgumentException(&quot;range&quot;);</span>
		}

<span class="nc bnc" id="L1440" title="All 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L1441">			throw new IllegalArgumentException(&quot;requestType&quot;);</span>
		}

<span class="nc" id="L1444">		IRequestType manager = null;</span>

<span class="nc" id="L1446">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1447">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1449">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc bnc" id="L1451" title="All 2 branches missed.">			if (!requestType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1452">				manager = m_managerFactory.getRequestManagerByType(requestType);</span>

<span class="nc bnc" id="L1454" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1455">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1458">				manager.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
			} else {
<span class="nc bnc" id="L1460" title="All 2 branches missed.">				for (int i = 0; i &lt; m_requestEJBManagersArr.length; i++) {</span>
<span class="nc" id="L1461">					manager = m_requestEJBManagersArr[i];</span>

					// Ignore subtype parameter for type=ALL request
<span class="nc" id="L1464">					manager.deleteRequestsByStartDateRange(organizationId, isForBranch, range, null);</span>
				}
			}
<span class="nc" id="L1467">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1468">			m_cat.error(e, e);</span>
<span class="nc" id="L1469">			handleException(e);</span>
<span class="nc" id="L1470">			throw e;</span>
<span class="nc" id="L1471">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged at the point where they are thrown.
			// m_cat.error(e, e);

			// Logged with priority 'debug' since this exception is generated by RM during validations or
			// workflow processing and happens often during normal operation. If logged with a different
			// priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1478">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1479">			throw e;</span>
<span class="nc" id="L1480">		} catch (Exception e) {</span>
<span class="nc" id="L1481">			handleException(e);</span>
<span class="nc" id="L1482">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1484" title="All 4 branches missed.">			if (cacheEnabled)</span>
<span class="nc" id="L1485">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
<span class="nc" id="L1486">			methodFinish();</span>
<span class="nc" id="L1487">		}</span>
<span class="nc" id="L1488">	}</span>

	/**
	 * Get list of possible states for a given request type
	 *
	 * @param reqType one of the strings defined in {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}, the type
	 *            may be ALL in which case the states that are common to all request types are returned
	 * @return a List of possible states for the specified type or the list of the common states if ALL is specified.
	 */
	@Override
	public List getPossibleStatesForRequestType(String reqType) throws BbmFinderException {
<span class="nc" id="L1499">		String _method_ = &quot;getPossibleStatesForRequestType&quot;;</span>
<span class="nc" id="L1500">		methodStart(_method_);</span>

<span class="nc" id="L1502">		List result = null;</span>

<span class="nc bnc" id="L1504" title="All 2 branches missed.">		if (reqType == null) {</span>
<span class="nc" id="L1505">			throw new IllegalArgumentException(&quot;reqType&quot;);</span>
		}

		try {
<span class="nc bnc" id="L1509" title="All 2 branches missed.">			if (!Request.REQUESTTYPE_ALL.equals(reqType)) {</span>
<span class="nc" id="L1510">				IRequestType manager = m_managerFactory.getRequestManagerByType(reqType);</span>

<span class="nc bnc" id="L1512" title="All 2 branches missed.">				if (manager == null) {</span>
<span class="nc" id="L1513">					throw new IllegalArgumentException(&quot;manager&quot;);</span>
				}

<span class="nc" id="L1516">				result = manager.getPossibleStates();</span>
<span class="nc" id="L1517">			} else {</span>
				// Want all common states
<span class="nc" id="L1519">				result = RequestAuditTrail.COMMON_STATES;</span>
			}

			// Add expired to the list we have so far
<span class="nc" id="L1523">			List returnValue = new ArrayList();</span>

<span class="nc bnc" id="L1525" title="All 2 branches missed.">			if (result != null) {</span>
<span class="nc" id="L1526">				returnValue.addAll(result);</span>
			}

<span class="nc" id="L1529">			returnValue.add(RequestFilter.EXPIRED_STATUS);</span>

<span class="nc" id="L1531">			return returnValue;</span>
			// } catch (BbmFinderException e) {
			// m_cat.error(e, e);
			// handleException(e);
			// throw e;
<span class="nc" id="L1536">		} catch (Exception e) {</span>
<span class="nc" id="L1537">			this.handleException(e, false);</span>
<span class="nc" id="L1538">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1540">			methodFinish();</span>
		}
	}

	/**
	 * Gets orgs for which given manager has VIEWREQUEST privilege
	 *
	 * @param mgrEmpID
	 * @param requestFilter
	 * @return A Set of Organizations
	 * @throws Exception
	 */
	protected Collection getOrgIDsForMgrUsingReqFilter(ID mgrEmpID, RequestFilter requestFilter) throws Exception {
<span class="fc" id="L1553">		Set orgsWithViewPrivForMgr = RequestUtil.getOrgIDsWithViewReqPrivilegesForEmpID(mgrEmpID);</span>

		// Check, if the user does not have the request viewing privilege
		// in any organization, then log that and return a null result
<span class="pc bpc" id="L1557" title="1 of 2 branches missed.">		if (orgsWithViewPrivForMgr.size() == 0) {</span>
<span class="nc" id="L1558">			m_cat.debug(&quot;mgrEmpID &quot; + mgrEmpID + &quot; does not have the privilege to view reqeusts in any organization.&quot;);</span>
<span class="nc" id="L1559">			return Collections.EMPTY_LIST;</span>
		}
<span class="fc" id="L1561">		m_cat.debug(&quot;&gt;&gt;&gt; checking for requests in: &quot; + orgsWithViewPrivForMgr);</span>

		// Process the organizations in the filter
<span class="pc bpc" id="L1564" title="1 of 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L1565">			TimeOffBidDAO dao = new TimeOffBidDAO();</span>
			try {
<span class="nc" id="L1567">				WorkResourceManager wkrManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1568">				Collection&lt;ID&gt; bidOrgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1569">				ID bidID = new ID(requestFilter.getValueForKey(RequestFilter.TOBID_KEY).toString());</span>
<span class="nc" id="L1570">				TimeOffBid bid = dao.getObjectByID(bidID);</span>

<span class="nc" id="L1572">				bidOrgIDs.add(bid.getOrganizationId());</span>
<span class="nc" id="L1573">				bidOrgIDs = wkrManager.getOrganizationsChildrenByIDs(bidOrgIDs);</span>
<span class="nc" id="L1574">				bidOrgIDs.add(bid.getOrganizationId());</span>
<span class="nc" id="L1575">				orgsWithViewPrivForMgr.retainAll(bidOrgIDs);</span>
<span class="nc" id="L1576">			} catch (Exception e) {</span>
				// restrict the set of organizations by the tree in the filter.
				// Fall Back if there is an exception
<span class="nc" id="L1579">				orgsWithViewPrivForMgr.retainAll((Collection) requestFilter.getValueForKey(RequestFilter.ORGANIZATION_KEY));</span>
			} finally {
<span class="nc bnc" id="L1581" title="All 6 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L1582">					dao.cleanUp();</span>
				}
			}
<span class="pc bpc" id="L1585" title="1 of 2 branches missed.">		} else if (requestFilter.isKeySet(RequestFilter.ORGANIZATION_KEY)) {</span>
			// restrict the set of organizations by the tree in the filter.
<span class="nc" id="L1587">			orgsWithViewPrivForMgr.retainAll((Collection) requestFilter.getValueForKey(RequestFilter.ORGANIZATION_KEY)); // performs</span>
																															// intersection
		}

<span class="fc" id="L1591">		return orgsWithViewPrivForMgr;</span>
	}

	/**
	 * &lt;li&gt;get orgs with 'VIEWREQSFOREMP' privilege for the given mgr &lt;li&gt;get empIDs for these orgs. Restrict empIDs further based
	 * on reqFilter criteria (seniority, supervisor etc).
	 *
	 * @param mgrEmpID
	 * @param requestFilter
	 * @return
	 * @throws Exception
	 */
	protected Collection getEmpIDsForMgrUsingReqFilter(ID mgrEmpID, RequestFilter requestFilter) throws Exception {
		// Get the User object for manager
<span class="nc" id="L1605">		Set orgsWithViewPrivForMgr = RequestUtil.getOrgIDsWithViewReqPrivilegesForEmpID(mgrEmpID);</span>

		// Check, if the user does not have the request viewing privilege
		// in any organization, then log that and return a null result
<span class="nc bnc" id="L1609" title="All 2 branches missed.">		if (orgsWithViewPrivForMgr.size() == 0) {</span>
<span class="nc" id="L1610">			m_cat.debug(&quot;mgrEmpID &quot; + mgrEmpID + &quot; does not have the privilege to view reqeusts in any organization.&quot;);</span>
<span class="nc" id="L1611">			return Collections.EMPTY_LIST;</span>
		}
<span class="nc" id="L1613">		m_cat.debug(&quot;&gt;&gt;&gt; checking for requests in: &quot; + orgsWithViewPrivForMgr);</span>

		// Process the organizations in the filter
<span class="nc bnc" id="L1616" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.ORGANIZATION_KEY)) {</span>
			// restrict the set of organizations by the tree in the filter.
<span class="nc" id="L1618">			orgsWithViewPrivForMgr.retainAll((Collection) requestFilter.getValueForKey(RequestFilter.ORGANIZATION_KEY)); // performs</span>
																															// intersection
		}

		// Build an employee filter using what we know to get a collection
		// of employee ids. The filter is made of compounding sub filter
		// objects. I'm using the fully qualified class names to avoid
		// confusion since there are a few different kinds of filters.
<span class="nc" id="L1626">		ArrayList empFilters = new ArrayList();</span>
<span class="nc" id="L1627">		List requestTimeRange = null;</span>
<span class="nc" id="L1628">		List dateRange = (List) requestFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L1629">		Date start = null;</span>
<span class="nc" id="L1630">		Date end = null;</span>
<span class="nc bnc" id="L1631" title="All 2 branches missed.">		if (dateRange != null) {</span>
<span class="nc" id="L1632">			start = (Date) dateRange.get(0);</span>
<span class="nc" id="L1633">			end = (Date) dateRange.get(1);</span>
		}
<span class="nc bnc" id="L1635" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1636">			requestTimeRange = new ArrayList();</span>
<span class="nc" id="L1637">			requestTimeRange.add(start);</span>
<span class="nc" id="L1638">			requestTimeRange.add(end);</span>
		}
<span class="nc" id="L1640">		addOrganizationToEmpFilter(empFilters, orgsWithViewPrivForMgr, requestTimeRange);</span>
<span class="nc" id="L1641">		addSupervisorToEmpFilter(empFilters, requestFilter, requestTimeRange);</span>
<span class="nc" id="L1642">		addCampaignToEmpFilter(empFilters, requestFilter, requestTimeRange);</span>
<span class="nc" id="L1643">		Collection empIds = getEmpIDsUsingEmpFilter(new SuperUserFacade(), empFilters, requestTimeRange);</span>
		// The employee ids cannot be an empty set, or else we'll find nothing.
<span class="nc bnc" id="L1645" title="All 4 branches missed.">		if ((empIds == null) || (empIds.isEmpty())) {</span>
<span class="nc" id="L1646">			m_cat.debug(&quot;&gt;&gt;&gt;No users in organizations!.&quot;);</span>
		}
<span class="nc" id="L1648">		return empIds;</span>
	}

	protected Object getFilterKey(RequestFilter reqFilter, String keyName) {
<span class="nc bnc" id="L1652" title="All 2 branches missed.">		if (reqFilter.isKeySet(keyName))</span>
<span class="nc" id="L1653">			return reqFilter.getValueForKey(keyName);</span>

<span class="nc" id="L1655">		return null;</span>
	}

	static class Quad {

		private Object m_first;
		private Object m_second;
		private Object m_third;
		private Object m_fourth;

<span class="fc" id="L1665">		Quad() {</span>
<span class="fc" id="L1666">		}</span>

<span class="fc" id="L1668">		Quad(Object first, Object second, Object third, Object fourth) {</span>
<span class="fc" id="L1669">			m_first = first;</span>
<span class="fc" id="L1670">			m_second = second;</span>
<span class="fc" id="L1671">			m_third = third;</span>
<span class="fc" id="L1672">			m_fourth = fourth;</span>
<span class="fc" id="L1673">		}</span>

		/**
		 * @return Object
		 */
		public Object getFirst() {
<span class="fc" id="L1679">			return m_first;</span>
		}

		/**
		 * @return Object
		 */
		public Object getSecond() {
<span class="fc" id="L1686">			return m_second;</span>
		}

		/**
		 * @return Object
		 */
		public Object getThird() {
<span class="fc" id="L1693">			return m_third;</span>
		}

		/**
		 * @return Object
		 */
		public Object getFourth() {
<span class="fc" id="L1700">			return m_fourth;</span>
		}

	}

	/**
	 * get a sorted list of request IDs by transforming the given request filter and sort criteria into SQL and executing it.
	 *
	 * &lt;li&gt;get the SQL statement clauses (select, from, where and order by) from the specific request manager if requestType !=
	 * REQUESTTYPE_ALL &lt;li&gt;get the SQL statement clauses (select, from, where and order by) common to all request types. &lt;li&gt;Use dmo
	 * to execute the query built using the clauses retrieved above.
	 *
	 * @param mgrViewPrivOrgs a Set of organizations for which the querying mgr has view privileges
	 * @param reqFilter
	 * @param findName
	 * @param sortColumn
	 * @param sortDirection
	 * @return an array of arrays: reqIDs, reqTypes, reqEmpIDs, reqEmpOrgIDs.
	 * @throws Exception
	 */
	// QA 95168: refactor query to use list of orgs rather than list of employees
	// public Object[] getRequestIDsSortedUsingReqFilter(Collection empIDsFiltered, RequestFilter reqFilter,
	@Override
	public Object[] getRequestIDsSortedUsingReqFilter(Collection empIDsFiltered, Collection mgrViewPrivOrgs,
			RequestFilter reqFilter, String findName, boolean includeExpired, int sortColumn, int sortDirection) throws Exception {
		// validate 'sortColumn' parameter
<span class="pc bpc" id="L1726" title="2 of 4 branches missed.">		sortColumn = (sortColumn &lt; Request.SORT_MINVALUE || sortColumn &gt; Request.SORT_MAXVALUE) ? Request.SORT_LAST_NAME_FIRST</span>
				: sortColumn;

		// get request type from filter
<span class="fc" id="L1730">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

		// The query generation process has call outs to places for
		// a specific request type to customize the query. These callouts
		// are triggered with the reqeust filter specifies a specific
		// request type. We record that choice by setting the reqMgr here.
		// Later, if this is null, we know no callouts are necessary.
<span class="fc" id="L1737">		IRequestType reqMgr = null;</span>
<span class="fc" id="L1738">		Quad reqTypeSpecificSQLComps = new Quad();</span>
<span class="pc bpc" id="L1739" title="1 of 2 branches missed.">		if (!filterReqType.equals(Request.REQUESTTYPE_ALL)) {</span>
<span class="nc" id="L1740">			reqMgr = (IRequestType) m_requestEJBManagersMap.get(filterReqType);</span>

			// Now that we have the employee ids, we need to see if the set of employeeIds
			// needs to be further restricted.
			// call the request manager for the specific request type and
			// let them further restrict the set of employees based on
			// other data in the filter.
			/*
			 * QA 95168: refactor query to remove IN (employeeList) clause empIDsFiltered =
			 * reqMgr.restrictEmployeesByFilter(empIDsFiltered, reqFilter);
			 *
			 * if ((empIDsFiltered == null) || (empIDsFiltered.size() == 0)) {
			 * m_cat.error(&quot;&gt;&gt;&gt;No users found after applying requestFilter!.&quot;); return new Object[] { Collections.EMPTY_LIST,
			 * Collections.EMPTY_LIST, Collections.EMPTY_LIST, Collections.EMPTY_LIST }; } END QA 95168
			 */

			// obtain request type specific SQL query components
<span class="nc" id="L1757">			reqTypeSpecificSQLComps = getSelectFromWhereOrderClausesForReqType(reqMgr, reqFilter, sortColumn, sortDirection);</span>
		}

		// Using linked lists instead of ArrayLists since caller may remove elements
		// from the middle of the list (for manager workflow setting).
<span class="fc" id="L1762">		List reqIDs = new LinkedList();</span>
<span class="fc" id="L1763">		List reqTypes = new LinkedList();</span>
<span class="fc" id="L1764">		List reqEmpIDs = new LinkedList();</span>
<span class="fc" id="L1765">		List reqEmpOrgIDs = new LinkedList();</span>

		// Get DMO object to work with database
<span class="fc" id="L1768">		Jdmo dmo = new Jdmo(false);</span>
<span class="fc" id="L1769">		JdmoRowset rs = null;</span>
<span class="fc" id="L1770">		Map reqIDToReqTypeMap = new HashMap();</span>
		try {
			// obtain SQL query components common across all query types.
			// QA 95168: refactor query to remove IN (employeeList) clause
			// Quad allReqTypesSQLComps = getSelectFromWhereOrderByClausesForAllReqs(reqFilter, empIDsFiltered, findName,
<span class="fc" id="L1775">			Quad allReqTypesSQLComps = getSelectFromWhereOrderByClausesForAllReqs(reqFilter, empIDsFiltered, mgrViewPrivOrgs,</span>
					findName, includeExpired, sortColumn, sortDirection, reqMgr, dmo);

			// build SQL query using 2 sets of query components: one set common to all request type and the second
			// specific to ther requestType
<span class="fc" id="L1780">			StringBuffer emptyStrBuf = new StringBuffer(&quot;&quot;);</span>
<span class="fc" id="L1781">			StringBuffer query = new StringBuffer();</span>
<span class="fc" id="L1782">			query.append((StringBuffer) allReqTypesSQLComps.getFirst())</span>
<span class="pc bpc" id="L1783" title="1 of 2 branches missed.">					.append((reqTypeSpecificSQLComps.getFirst() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getFirst()</span>
							: emptyStrBuf)
<span class="fc" id="L1785">					.append((StringBuffer) allReqTypesSQLComps.getSecond())</span>
<span class="pc bpc" id="L1786" title="1 of 2 branches missed.">					.append((reqTypeSpecificSQLComps.getSecond() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getSecond()</span>
							: emptyStrBuf)
<span class="fc" id="L1788">					.append((StringBuffer) allReqTypesSQLComps.getThird())</span>
<span class="pc bpc" id="L1789" title="1 of 2 branches missed.">					.append((reqTypeSpecificSQLComps.getThird() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getThird()</span>
							: emptyStrBuf)
<span class="fc" id="L1791">					.append((StringBuffer) allReqTypesSQLComps.getFourth())</span>
<span class="pc bpc" id="L1792" title="1 of 2 branches missed.">					.append((reqTypeSpecificSQLComps.getFourth() != null) ? (StringBuffer) reqTypeSpecificSQLComps.getFourth()</span>
							: emptyStrBuf);

			// Generate row set for request ids, types and empIDs.

<span class="fc" id="L1797">			String queryStr = query.toString();</span>
<span class="pc bpc" id="L1798" title="1 of 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L1799">				m_cat.debug(&quot;&gt;&gt;&gt; getRequestsForManager query string: &quot; + queryStr);</span>
			}
<span class="fc" id="L1801">			rs = dmo.createRowset(queryStr);</span>
<span class="fc" id="L1802">			boolean isFlexTypeCol = queryStr.contains(&quot;FLEXTYPE&quot;);</span>

			// Get the id and type lists from the query
<span class="fc bfc" id="L1805" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L1806">				reqIDs.add(rs.getID(1)); // first column: request ID</span>

<span class="pc bpc" id="L1808" title="2 of 4 branches missed.">				if (isFlexTypeCol &amp;&amp; rs.getInt(&quot;FLEXTYPE&quot;)==1){</span>
					// some of 'time-off' requests are actually 'flex-time' requests, we need to 'fix' them by checking which IDs are
					// 'flex-time' requests and update					
<span class="nc" id="L1811">					reqTypes.add(Request.REQUESTTYPE_FLEXTIME);</span>
<span class="nc" id="L1812">					reqIDToReqTypeMap.put(rs.getID(1), Request.REQUESTTYPE_FLEXTIME);</span>
				} else {
<span class="fc" id="L1814">					reqTypes.add(rs.getString(2)); // 2nd column: request type</span>
<span class="fc" id="L1815">					reqIDToReqTypeMap.put(rs.getID(1), rs.getString(2));</span>
				}
			
<span class="fc" id="L1818">				reqEmpIDs.add(rs.getID(3)); // 3rd column: request's employee id.</span>

<span class="fc" id="L1820">				reqEmpOrgIDs.add(rs.getID(4)); // 4th column: request employee's organization ID.</span>
			}
		} finally {
<span class="pc bpc" id="L1823" title="3 of 4 branches missed.">			if (rs != null)</span>
<span class="pc" id="L1824">				rs.close();</span>
<span class="pc bpc" id="L1825" title="3 of 4 branches missed.">			if (dmo != null)</span>
<span class="pc" id="L1826">				dmo.cleanUp();</span>
		}

<span class="fc" id="L1829">		m_cat.debug(&quot;&gt;&gt;&gt; getRequestsForManager returned  &quot; + reqIDs.size() + &quot; rows.&quot;);</span>
<span class="fc" id="L1830">		return new Object[] { reqIDs, reqTypes, reqEmpIDs, reqEmpOrgIDs, reqIDToReqTypeMap };</span>
	}

	/**
	 * Process 'Activate Manager TimeOff Workflow' Setting.
	 *
	 * Processes each reqID to check if it is a 'timeoff' request and if 'Activate Manager time off workflow' setting applies to it
	 * or not. If setting is disabled for the organization that the request is associated with, then the request ID is filtered out
	 * (removed). Organization associated with a request is found as follows: request --&gt; request's employee --&gt; request's
	 * employee's organization.
	 *
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 */
	@Override
	public void processActivateManagerTOWorkflowSetting(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws BbmFinderException {
		// if (reqType == timeoff) {
		// if ( !empIDToAMWFlowMap.keyExists(empID) ) {
		// identify org association for employee
		// retrieve org setting for org (use cache if necessary).
		// empIDToAMWFlowMap.put(empID, AMWFlowSetting);
		// }
		//
		// if (empIDToAMWFlowMap.get(empID) == false) {
		// remove reqID from list.
		// }
		// }

		// caches to improve performance.
<span class="fc" id="L1863">		Map empIDToAMWFlowMap = new HashMap(); // empIDToActivateAgentWorkflowMap</span>

<span class="fc" id="L1865">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="fc" id="L1866">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="fc bfc" id="L1867" title="All 2 branches covered.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="fc" id="L1869">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>

			// get reqType
<span class="fc" id="L1872">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
			// get reqEmpID
<span class="fc" id="L1874">			ID reqEmpID = (ID) reqEmpIDsForReqIDsIter.next();</span>
			// get request employee's org ID
<span class="fc" id="L1876">			ID reqEmpOrgID = (ID) reqEmpOrgIDForReqIDsIter.next();</span>

			// if not a time off request, simply continue
<span class="pc bpc" id="L1879" title="2 of 4 branches missed.">			if (reqType == null || !reqType.equals(Request.REQUESTTYPE_TIMEOFF))</span>
<span class="nc" id="L1880">				continue;</span>

			// retrieve org setting.
<span class="fc" id="L1883">			OrganizationSetting reqEmpOrgSetting = null;</span>
			try {
<span class="fc" id="L1885">				reqEmpOrgSetting = CacheUtilRM.getOrgSetting(reqEmpOrgID);</span>
<span class="nc" id="L1886">			} catch (Exception e) {</span>
<span class="nc" id="L1887">				handleException(e);</span>
<span class="nc" id="L1888">				throw new BbmFinderException(e);</span>
<span class="fc" id="L1889">			}</span>

<span class="pc bpc" id="L1891" title="1 of 2 branches missed.">			Boolean AMWFlowSetting = reqEmpOrgSetting.getManagerTimeOffWorkflowActive() ? Boolean.TRUE : Boolean.FALSE;</span>

			// if AMWFlowSetting is false, then remove reqID
<span class="pc bpc" id="L1894" title="1 of 2 branches missed.">			if (AMWFlowSetting.equals(Boolean.FALSE)) {</span>
<span class="nc" id="L1895">				reqIDsAfterFilterIter.remove();</span>
<span class="nc" id="L1896">				reqIDToReqTypeMap.remove(reqID);</span>
<span class="nc" id="L1897">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L1898">				reqEmpOrgIDForReqIDsIter.remove();</span>
			}
<span class="fc" id="L1900">		}</span>
<span class="fc" id="L1901">	}</span>

	/**
	 * Process 'Enable Shift Swap' Setting.
	 *
	 * Processes each reqID to check if it is a 'shiftswap' request and if 'Enable Shift Swap' setting applies to it or not. If
	 * setting is disabled for the organization that the request is associated with, then the request ID is filtered out (removed).
	 * Organization associated with a request is found as follows: request --&gt; request's employee --&gt; request's employee's
	 * organization.
	 *
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 */
	private void processEnableShiftSwapSetting(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws Exception {

<span class="fc" id="L1920">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="fc" id="L1921">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="fc bfc" id="L1922" title="All 2 branches covered.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="fc" id="L1924">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>

			// get reqType
<span class="fc" id="L1927">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
			// get reqEmpID
<span class="fc" id="L1929">			ID reqEmpID = (ID) reqEmpIDsForReqIDsIter.next();</span>
			// get request employee's org ID
<span class="fc" id="L1931">			ID reqEmpOrgID = (ID) reqEmpOrgIDForReqIDsIter.next();</span>

			// if not a shift swap request, simply continue
<span class="pc bpc" id="L1934" title="2 of 4 branches missed.">			if (reqType == null || !reqType.equals(Request.REQUESTTYPE_SHIFTSWAP))</span>
<span class="fc" id="L1935">				continue;</span>

			// retrieve org setting.
<span class="nc" id="L1938">			OrganizationSetting reqEmpOrgSetting = CacheUtilRM.getOrgSetting(reqEmpOrgID);</span>

<span class="nc bnc" id="L1940" title="All 2 branches missed.">			Boolean enableShiftSwapSetting = reqEmpOrgSetting.getEnableShiftSwap() ? Boolean.TRUE : Boolean.FALSE;</span>

			// if AMWFlowSetting is false, then remove reqID
<span class="nc bnc" id="L1943" title="All 2 branches missed.">			if (enableShiftSwapSetting.equals(Boolean.FALSE)) {</span>
<span class="nc" id="L1944">				reqIDsAfterFilterIter.remove();</span>
<span class="nc" id="L1945">				reqIDToReqTypeMap.remove(reqID);</span>
<span class="nc" id="L1946">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L1947">				reqEmpOrgIDForReqIDsIter.remove();</span>
			}
<span class="nc" id="L1949">		}</span>
<span class="fc" id="L1950">	}</span>

	/**
	 * Remove duplicate requests. Requests can be duplicated in this situation: An employee creates a request for some future time
	 * (the request effective date). The employee is configured to move to another organization between now and the request
	 * effective date. The employee's current manager has view request privileges for both the current and future organization.
	 *
	 * @param reqIDsAfterFilter
	 * @param reqIDToReqTypeMap
	 * @param reqEmpIDsForReqIDs
	 * @param reqEmpOrgIDForReqIDs
	 * @throws BbmFinderException
	 */
	private void removeDuplicateRequests(List reqIDsAfterFilter, Map reqIDToReqTypeMap, List reqEmpIDsForReqIDs,
			List reqEmpOrgIDForReqIDs) throws BbmFinderException {
<span class="fc" id="L1965">		Set requestIDs = new HashSet(reqIDsAfterFilter.size()); // empIDToActivateAgentWorkflowMap</span>

<span class="fc" id="L1967">		Iterator reqEmpIDsForReqIDsIter = reqEmpIDsForReqIDs.iterator();</span>
<span class="fc" id="L1968">		Iterator reqEmpOrgIDForReqIDsIter = reqEmpOrgIDForReqIDs.iterator();</span>
<span class="fc bfc" id="L1969" title="All 2 branches covered.">		for (Iterator reqIDsAfterFilterIter = reqIDsAfterFilter.iterator(); reqIDsAfterFilterIter.hasNext();) {</span>
			// get request ID
<span class="fc" id="L1971">			ID reqID = (ID) reqIDsAfterFilterIter.next();</span>
<span class="fc" id="L1972">			reqEmpIDsForReqIDsIter.next();</span>
<span class="fc" id="L1973">			reqEmpOrgIDForReqIDsIter.next();</span>
<span class="pc bpc" id="L1974" title="1 of 2 branches missed.">			if (requestIDs.contains(reqID)) {</span>
<span class="nc" id="L1975">				reqIDsAfterFilterIter.remove();</span>
				// reqIDToReqTypeMap.remove(reqID); // don't remove entry from map
<span class="nc" id="L1977">				reqEmpIDsForReqIDsIter.remove();</span>
<span class="nc" id="L1978">				reqEmpOrgIDForReqIDsIter.remove();</span>
			} else {
<span class="fc" id="L1980">				requestIDs.add(reqID);</span>
			}
<span class="fc" id="L1982">		}</span>
<span class="fc" id="L1983">	}</span>

	protected StringBuffer getSQLDateBetweenClause(String givenDate, String rangeStart, String rangeEnd) {
		// return new StringBuffer( '(' + givenDate + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;')&quot;);
<span class="nc" id="L1987">		return new StringBuffer(givenDate + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;'&quot;);</span>
	}

	protected StringBuffer getSQLDateRangeBetweenClause(String givenDateStart, String givenDateEnd, String rangeStart,
			String rangeEnd) {
<span class="nc" id="L1992">		return new StringBuffer('(' + givenDateStart + &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;' AND &quot; + givenDateEnd</span>
				+ &quot; BETWEEN '&quot; + rangeStart + &quot;' AND '&quot; + rangeEnd + &quot;')&quot;);
	}

	/*
	 * given, say columName = &quot;A.FIRSTNAME&quot; and personName = &quot;FIRST LAST&quot;, returns &quot;A.FIRSTNAME LIKE '%FIRST%' OR A.FIRSTNAME LIKE
	 * '%LAST%'
	 */
	protected String getSQLLikeClause(String columName, String personName, Jdmo dmo) {
		// replace ','s in personName
<span class="nc" id="L2002">		personName = personName.replace(',', ' ');</span>

		// format the 'LIKE' clause.
<span class="nc" id="L2005">		StringBuffer likeClause = new StringBuffer(40);</span>

<span class="nc" id="L2007">		boolean firstItr = true;</span>

<span class="nc bnc" id="L2009" title="All 2 branches missed.">		for (StringTokenizer tokenizer = new StringTokenizer(personName); tokenizer.hasMoreTokens();) {</span>
<span class="nc bnc" id="L2010" title="All 2 branches missed.">			if (!firstItr) {</span>
<span class="nc" id="L2011">				likeClause.append(&quot; OR &quot;);</span>
			}

<span class="nc" id="L2014">			likeClause.append(columName).append(&quot; LIKE '%&quot;).append(JdmoUtil.formatDBString(tokenizer.nextToken())).append(&quot;%' &quot;);</span>

<span class="nc" id="L2016">			firstItr = false;</span>
		}

<span class="nc" id="L2019">		return likeClause.toString();</span>
	}

	/**
	 * Get SQL query components, for request filtering, which apply to all request types.
	 *
	 * If request type == 'all', and a date range is specified, a query based on the following is used. &lt;code&gt;
	 * -- If the inner joins are done first before the left joins, it will result
	 *  -- in a large result set.  Better optimization, if this is the case, is to
	 *  -- split this into 2 queries or force the inner joins to use the restrictive
	 *  -- predicates applied to the Request table.
	 *
	 *  select
	 *     req.id, req.employeeid, req.requesttype, req.requeststatus, req.expirationdate,
	 *     ssr.swaptype,
	 *     tor.debittype
	 *     ,ssri.*
	 *     , toc.*
	 *  from
	 *     request req left join (shiftswaprequest ssr inner join shiftswaprequestitem ssri on ssr.id = ssri.shiftswaprequestid and ssri.itemorder=0 inner join shiftswapitem ssi on ssri.shiftswapitemid=ssi.id) on req.id=ssr.id
	 *     left join (timeoffrequest tor inner join timeoffrequestchoice toc on tor.id=toc.timeoffrequestid) on req.id=tor.id
	 *  where
	 *     ( &lt;given daterange&gt; falls within first tochoice daterange ) or
	 *     ( &lt;given daterange&gt; falls within first shiftswap daterange )
	 * &lt;/code&gt;
	 *
	 * &lt;p&gt;
	 * If request type == 'all'|SS|TO, and a date range is not specified, then a query based on the follwoing is used. &lt;code&gt;
	 *    SELECT REQ.ID, REQ.REQUESTTYPE, REQ.REQUESTSTATUS, REQ.SUBMITTEDON, REQ.LASTMODIFIEDAT, PER.FIRSTNAME,
	 *       PER.MIDDLEINITIAL, PER.LASTNAME, PER.PFIRSTNAME, PER.PLASTNAME
	 *    FROM REQUEST A, EMPLOYEE B, PERSON C
	 *    WHERE REQ.EMPLOYEEID IN  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29) AND
	 *       REQ.EMPLOYEEID=EMP.ID AND
	 *       EMP.PERSONID=PER.ID  AND
	 *       REQ.REQUESTSTATUS NOT IN ('invalid','negotiation','withdrawn')  AND
	 *       (REQ.EXPIRATIONDATE&gt;'2003-02-17 11:25:51'  OR REQ.REQUESTSTATUS IN ( 'approved','denied','invalid','withdrawn'))  AND
	 *       PER.FIRSTNAME+' '+PER.LASTNAME LIKE '%west%'
	 *    ORDER BY PER.LASTNAME ASC , PER.FIRSTNAME ASC , PER.MIDDLEINITIAL ASC '
	 * &lt;/code&gt;
	 *
	 * @param reqFilter
	 * @param empIDs
	 * @param findName
	 * @param sortColumn
	 * @param sortDirection
	 * @param reqMgr
	 * @param dmo
	 * @return
	 * @throws RemoteException
	 * @throws JdmoException
	 */
	protected Quad getSelectFromWhereOrderByClausesForAllReqs(RequestFilter reqFilter, Collection empIDsFiltered,
			Collection mgrViewPrivOrgs, String findName, boolean incExpired, int sortColumn, int sortDirection,
			IRequestType reqMgr, Jdmo dmo) throws RemoteException, JdmoException {
<span class="fc" id="L2073">		String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>

<span class="pc bpc" id="L2075" title="1 of 2 branches missed.">		boolean isAllAndDateRangeSpecified = reqFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)</span>
<span class="pc bpc" id="L2076" title="1 of 2 branches missed.">				&amp;&amp; filterReqType.equals(Request.REQUESTTYPE_ALL);</span>

		// Now we're ready to start building the query
<span class="fc" id="L2079">		StringBuffer selectClause = new StringBuffer();</span>
<span class="fc" id="L2080">		StringBuffer fromClause = new StringBuffer();</span>
<span class="fc" id="L2081">		StringBuffer orderByClause = new StringBuffer();</span>
<span class="fc" id="L2082">		StringBuffer whereClause = new StringBuffer();</span>

		// Note: The 'DISTINCT' qualifier forces all columns that may appear in 'ORDER BY' clause to be specified in
		// the SELECT clause, though only REQ.ID, REQ.REQUESTTYPE, REQ.EMPLOYEEID and WRO.ORGANIZATIONID
		// are actually used by the application logic.
<span class="fc" id="L2087">		boolean addSortColsToSelectClause = false;</span>

		// Note: fields REQ.EMPLOYEEID and WRO.ORGANIZATIONID are fetched to identify the org
		// association of time off requests for processing 'Activate manager time off work flow' setting.
<span class="fc" id="L2091">		String SELECT_COLS_MANDATORY = &quot; &quot;;</span>
		// Makeup start date should always consider the min start date of all makeup's for each request and vice-versa for makeup end date
		// So modifying query to append an aggregate function for all select fields to include a group by on the request id
		// added in the addOrderByClause() method of FlexTimeRequestManagerEJB
<span class="pc bpc" id="L2095" title="5 of 6 branches missed.">		if(filterReqType.equals(Request.REQUESTTYPE_FLEXTIME) &amp;&amp;</span>
				(Request.SORT_CS_STARTTIME == sortColumn || Request.SORT_CS_ENDTIME == sortColumn)) {
<span class="nc" id="L2097">			SELECT_COLS_MANDATORY+= &quot;max(REQ.ID), max(REQ.REQUESTTYPE), max(REQ.EMPLOYEEID), max(WRO.ORGANIZATIONID) &quot;;</span>
		}else{
<span class="fc" id="L2099">			SELECT_COLS_MANDATORY+= &quot;REQ.ID, REQ.REQUESTTYPE, REQ.EMPLOYEEID, WRO.ORGANIZATIONID &quot;;</span>
		}

<span class="pc bpc" id="L2102" title="2 of 4 branches missed.">		if (reqMgr == null &amp;&amp; !isAllAndDateRangeSpecified) {</span>
			// We can optimize the query if we know that we wont be joining with child tables. The generic query will be unique.
<span class="nc" id="L2104">			selectClause.append(&quot;SELECT &quot;).append(SELECT_COLS_MANDATORY);</span>
		} else {
			// Since we might be joining with child tables, we need to add the DISTINCT modifier.
			// This increases the overhead of the query, but it can't be avoided.
<span class="fc" id="L2108">			selectClause.append(&quot;SELECT DISTINCT &quot;).append(SELECT_COLS_MANDATORY);</span>
			// this adds any column that may appear in the ORDER BY clause to be added to the select clause.
<span class="fc" id="L2110">			addSortColsToSelectClause = true;</span>
		}
<span class="fc" id="L2112">		fromClause.append(&quot; FROM REQUEST REQ &quot;);</span>
<span class="pc bpc" id="L2113" title="2 of 4 branches missed.">		if (sortColumn == Request.SORT_EMP_RANK || reqFilter.isKeySet(RequestFilter.EMP_RANK_OPERATOR_KEY)) {</span>
<span class="nc" id="L2114">			fromClause.append(&quot; LEFT JOIN (SELECT EMPLOYEEID, RANK FROM EMPLOYEERANK &quot;);</span>
<span class="nc" id="L2115">			fromClause.append(&quot; WHERE STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;'&quot;);</span>
<span class="nc" id="L2116">			fromClause.append(&quot; AND (ENDTIME&gt;'&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;'&quot;)</span>
<span class="nc" id="L2117">					.append(&quot; OR ENDTIME IS NULL)) EMPRANK&quot;);</span>
<span class="nc" id="L2118">			fromClause.append(&quot; ON EMPRANK.EMPLOYEEID=REQ.EMPLOYEEID&quot;);</span>
		}
		// Now we add the FROM clause
<span class="pc bpc" id="L2121" title="1 of 2 branches missed.">		if (isAllAndDateRangeSpecified) {</span>
<span class="fc" id="L2122">			fromClause</span>
<span class="fc" id="L2123">					.append(&quot; LEFT JOIN (ShiftSwapRequest ssr INNER JOIN ShiftSwapRequestItem ssri ON ssr.ID = ssri.ShiftSwapRequestID &quot;</span>
							+ &quot;INNER JOIN ShiftSwapItem ssi ON ssri.ShiftSwapItemID=ssi.ID) &quot;
							+ &quot;on req.ID=ssr.ID &quot;);
<span class="fc" id="L2126">			fromClause</span>
<span class="fc" id="L2127">					.append(&quot; LEFT JOIN (TimeOffRequest tor INNER JOIN TimeOffRequestChoice toc on tor.ID=toc.TimeOffRequestID) on req.ID=tor.ID &quot;);</span>
<span class="fc" id="L2128">			selectClause.append(&quot;,tor.FLEXTYPE &quot;);</span>
			// Shift bid requests will always be queried based on the shift bid auction start-end dates. having more granualrity is
			// not efficient or required for now
			// Sameet Apr 2007 SILK # 92886
<span class="fc" id="L2132">			fromClause</span>
<span class="fc" id="L2133">					.append(&quot; LEFT JOIN (SHIFTBIDREQUEST  SBR INNER JOIN SHIFTBIDAUCTION SBA ON SBR.SHIFTBIDAUCTIONID=SBA.ID)  ON REQ.ID=SBR.ID &quot;);</span>
<span class="fc" id="L2134">			fromClause.append(&quot; LEFT JOIN CUSTSHIFTREQ CSR ON REQ.ID = CSR.ID &quot;);</span>
		}
		// use the WORKRESOURCEORGANIZATION association for today to prevent duplicate requests
<span class="fc" id="L2137">		fromClause.append(&quot;, EMPLOYEEAM &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;, PERSON PER, WORKRESOURCEORGANIZATION WRO &quot;);</span>

<span class="fc" id="L2139">		StringsPair datesPair = RmFilterUtil.getStartAndEndDates(reqFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="fc" id="L2140">		String rangeStart = datesPair.getKey();</span>
<span class="fc" id="L2141">		String rangeEnd = datesPair.getValue();</span>
<span class="fc" id="L2142">		Date dtNow = new Date();</span>
<span class="fc" id="L2143">		String strDtNow = JdmoUtil.formatDBString(dtNow);</span>

<span class="fc" id="L2145">		whereClause.append(&quot; WHERE WRO.ORGANIZATIONID IN &quot;).append(dmo.createInClause(mgrViewPrivOrgs));</span>
<span class="pc bpc" id="L2146" title="3 of 4 branches missed.">		if (empIDsFiltered != null &amp;&amp; !empIDsFiltered.isEmpty()) {</span>
<span class="nc" id="L2147">			whereClause.append(&quot; AND REQ.EMPLOYEEID IN &quot;).append(dmo.createInClause(empIDsFiltered));</span>
		}
<span class="fc" id="L2149">		whereClause.append(&quot; AND REQ.EMPLOYEEID=&quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.ID&quot;);</span>
<span class="fc" id="L2150">		whereClause.append(&quot; AND &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.PERSONID=PER.ID &quot;);</span>
<span class="fc" id="L2151">		whereClause.append(&quot; AND REQ.EMPLOYEEID = WRO.WORKRESOURCEID &quot;);</span>

		// check for expiration
		// Special case: if request type == all and the date range is specified.
<span class="pc bpc" id="L2155" title="1 of 2 branches missed.">		if (isAllAndDateRangeSpecified) {</span>
<span class="fc" id="L2156">			whereClause.append(&quot;AND (&quot;);</span>
<span class="fc" id="L2157">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot;( &quot;, &quot;toc&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="fc" id="L2158">			whereClause.append(&quot;)&quot;);</span>
<span class="fc" id="L2159">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;ssi&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="fc" id="L2160">			whereClause.append(&quot;)&quot;);</span>
<span class="fc" id="L2161">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;SBA&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="fc" id="L2162">			whereClause.append(&quot;)&quot;);</span>
<span class="fc" id="L2163">			RmUtil.appendRequestDateRangeClauses(whereClause, &quot; OR (&quot;, &quot;CSR&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="fc" id="L2164">			whereClause.append(&quot;))&quot;);</span>
		}

		// Process the generic portions of the WHERE clause that come from the filter.
		// Some of the selections have defaults, so process each separately

		/*
		 * QC 39692 (QA 94619): Rewrite the status section. Create WHERE restrictions for STATUS conditions. There are various types
		 * of conditions: 1) The name of the filter. The built-in 'All active' filter is treated specially. 2) Explicitly set
		 * conditions corresponding to persistent Request object fields. For instance, status set to 'pending' translates directly
		 * to &quot;AND REQ.REQUESTSTATUS='pending'&quot; 3) Implicit conditions. For instance, the built-in filter whose name is 'All active'
		 * implicitly excludes Requests whose Status are 'invalid' or 'withdrawn'.
		 */

<span class="fc" id="L2178">		String filterName = reqFilter.getName();</span>
<span class="fc" id="L2179">		boolean isAllActiveFilter = filterName.equals(RequestUtil.DEFAULT_FILTER);</span>
<span class="fc" id="L2180">		StringBuffer statusNotInRestriction = new StringBuffer();</span>
<span class="fc" id="L2181">		statusNotInRestriction.append(&quot; AND REQ.REQUESTSTATUS NOT IN ('&quot;).append(RequestAuditTrail.STATUS_NEGOTIATION).append(&quot;'&quot;);</span>
<span class="fc" id="L2182">		StringBuffer expDateRestriction = new StringBuffer();</span>
<span class="fc" id="L2183">		expDateRestriction.append(&quot; AND REQ.EXPIRATIONDATE&quot;);</span>

		// All Active filter is a special case
<span class="fc bfc" id="L2186" title="All 2 branches covered.">		if (isAllActiveFilter) {</span>
<span class="fc" id="L2187">			expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="fc" id="L2188">			statusNotInRestriction.append(&quot;,&quot;).append(RequestAuditTrail.inClauseForFinalStates()).append(&quot;)&quot;);</span>
<span class="fc" id="L2189">			whereClause.append(expDateRestriction).append(statusNotInRestriction);</span>
		} else {
			// No Filter
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.STATUS_KEY)) {</span>
<span class="fc" id="L2193">				statusNotInRestriction.append(&quot;)&quot;);</span>
<span class="fc" id="L2194">				whereClause.append(statusNotInRestriction);</span>
			} else {
				// Include request status only if it is not for withdrawal states of TO Request
				// these withdrawal states are in seperate table so cannot include it in the REQUEST Clause
				// QC 45878 ;Filter for TO Withdraw Request and TO Withdraw Reject do not work.
				// Sameet Sept 2009
<span class="nc" id="L2200">				String reqStatus = (String) reqFilter.getValueForKey(RequestFilter.STATUS_KEY);</span>
<span class="nc bnc" id="L2201" title="All 2 branches missed.">				if (!RequestAuditTrail.isRequestForWithdrawalStates(reqStatus)) {</span>
<span class="nc" id="L2202">					StringBuffer statusInRestriction = new StringBuffer();</span>
<span class="nc" id="L2203">					statusInRestriction.append(&quot; AND REQ.REQUESTSTATUS&quot;);</span>
<span class="nc bnc" id="L2204" title="All 2 branches missed.">					if (reqStatus.equals(RequestFilter.EXPIRED_STATUS)) {</span>
<span class="nc" id="L2205">						expDateRestriction.append(&quot;&lt;='&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2206">						statusInRestriction.append(&quot; IN &quot;).append(RequestAuditTrail.inClauseForExpiredStates()).append(&quot; &quot;);</span>
<span class="nc" id="L2207">						statusNotInRestriction.append(&quot;) &quot;);</span>
<span class="nc" id="L2208">						whereClause.append(expDateRestriction).append(statusNotInRestriction).append(statusInRestriction);</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">					} else if (reqStatus.equals(RequestAuditTrail.STATUS_ALL_PENDING_STATES)) {</span>
<span class="nc" id="L2210">						statusInRestriction.append(&quot; IN &quot;).append(RequestAuditTrail.inClauseForExpiredStates()).append(&quot; &quot;);</span>
<span class="nc" id="L2211">						expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2212">						whereClause.append(expDateRestriction);</span>
<span class="nc" id="L2213">						whereClause.append(statusInRestriction);</span>
					} else { // a specific Status selected that's separate from Expired
<span class="nc" id="L2215">						statusInRestriction.append(&quot;='&quot;).append(reqStatus).append(&quot;'&quot;);</span>
						// if status is waitlist or pending, expiration date &gt; dtNow
<span class="nc bnc" id="L2217" title="All 2 branches missed.">						if (reqStatus.equals(RequestAuditTrail.STATUS_WAITLIST)</span>
<span class="nc bnc" id="L2218" title="All 2 branches missed.">								|| reqStatus.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2219">							expDateRestriction.append(&quot;&gt;'&quot;).append(strDtNow).append(&quot;' &quot;);</span>
<span class="nc" id="L2220">							whereClause.append(expDateRestriction);</span>
						}

<span class="nc" id="L2223">						whereClause.append(statusInRestriction);</span>
					}
				}
			}

		}

		// Status:
		// if Filter.STATUS_KEY is not set, then show all reqs except 'invalid', 'negotiation' and 'withdrawn'
		// if Filter.STATUS_KEY is set and Filter.STATUS_KEY != 'EXPIRED', show only requests of that type.
		// if Filter.STATUS_KEY is set and Filter.STATUS_KEY == 'EXPIRED', show all requests except 'invalid' and 'withdrawn'.
		// submitted
<span class="pc bpc" id="L2235" title="3 of 4 branches missed.">		if (reqFilter.isKeySet(RequestFilter.SUBMITTED_KEY) &amp;&amp; !reqFilter.isKeySet(RequestFilter.TOBID_KEY)) {</span>
<span class="nc" id="L2236">			List dates = (List) reqFilter.getValueForKey(RequestFilter.SUBMITTED_KEY);</span>
<span class="nc" id="L2237">			String begDate = JdmoUtil.formatDBString((Date) dates.get(0));</span>
<span class="nc" id="L2238">			String endDate = JdmoUtil.formatDBString((Date) dates.get(1));</span>

			// add status condition from filter to query
<span class="nc" id="L2241">			whereClause.append(&quot; AND REQ.SUBMITTEDON &gt;='&quot;).append(begDate).append(&quot;' AND REQ.SUBMITTEDON &lt;='&quot;).append(endDate)</span>
<span class="nc" id="L2242">					.append(&quot;' &quot;);</span>
		}
<span class="pc bpc" id="L2244" title="1 of 2 branches missed.">		if (reqFilter.isKeySet(RequestFilter.SENIORITY_KEY)) {</span>
			// add seniority subfilter to filters
<span class="nc" id="L2246">			List dates = (List) reqFilter.getValueForKey(RequestFilter.SENIORITY_KEY);</span>
<span class="nc" id="L2247">			String begDate = JdmoUtil.formatDBString((Date) dates.get(0));</span>
<span class="nc" id="L2248">			String endDate = JdmoUtil.formatDBString((Date) dates.get(1));</span>

<span class="nc" id="L2250">			whereClause.append(&quot; AND &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME BETWEEN '&quot;).append(begDate)</span>
<span class="nc" id="L2251">					.append(&quot;' AND '&quot;).append(endDate).append(&quot;' &quot;);</span>
		}

		// Add find name filter
<span class="pc bpc" id="L2255" title="3 of 4 branches missed.">		if ((findName != null) &amp;&amp; (findName.trim().length() &gt; 0)) {</span>
<span class="nc" id="L2256">			whereClause.append(&quot; AND &quot;).append(&quot;( &quot;).append(getSQLLikeClause(&quot;PER.FIRSTNAME&quot;, findName, dmo)).append(&quot; OR &quot;)</span>
<span class="nc" id="L2257">					.append(getSQLLikeClause(&quot;PER.LASTNAME&quot;, findName, dmo)).append(&quot; ) &quot;);</span>
		}

		// Finally, we add the order by clause for the sort order.
<span class="fc" id="L2261">		String sqlSortDir = DAOUtil.getSortDirection(sortDirection);</span>

		// append the &quot;ORDER BY&quot; clause for the query. Based on the sort column, add the sort condition
<span class="fc" id="L2264">		appendToOrderByAndSelectClause(orderByClause, selectClause, addSortColsToSelectClause, sortColumn, sqlSortDir);</span>

<span class="fc" id="L2266">		return new Quad(selectClause, fromClause, whereClause, orderByClause);</span>
	}

	private void appendToOrderByAndSelectClause(StringBuffer orderByClause, StringBuffer selectClause,
			boolean addSortColsToSelectClause, int sortColumn, String sqlSortDir) {

		// append the &quot;ORDER BY&quot; clause for the query.
		// Based on the sort column, add the sort condition
<span class="pc bpc" id="L2274" title="10 of 11 branches missed.">		switch (sortColumn) {</span>
			case Request.SORT_LAST_NAME_FIRST:
<span class="fc" id="L2276">				orderByClause.append(&quot; ORDER BY PER.LASTNAME&quot;).append(sqlSortDir).append(&quot;, PER.FIRSTNAME&quot;).append(sqlSortDir)</span>
<span class="fc" id="L2277">						.append(&quot;, PER.MIDDLEINITIAL&quot;).append(sqlSortDir);</span>

<span class="pc bpc" id="L2279" title="1 of 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="fc" id="L2280">					selectClause.append(&quot;, PER.LASTNAME, PER.FIRSTNAME, PER.MIDDLEINITIAL &quot;);</span>
				}
				break;

			case Request.SORT_FIRST_NAME_FIRST:
<span class="nc" id="L2285">				orderByClause.append(&quot; ORDER BY PER.FIRSTNAME&quot;).append(sqlSortDir).append(&quot;, PER.MIDDLEINITIAL&quot;).append(sqlSortDir)</span>
<span class="nc" id="L2286">						.append(&quot;, PER.LASTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2288" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2289">					selectClause.append(&quot;, PER.LASTNAME, PER.FIRSTNAME, PER.MIDDLEINITIAL &quot;);</span>
				}
				break;

			case Request.SORT_PLAST_NAME_FIRST:
<span class="nc" id="L2294">				orderByClause.append(&quot; ORDER BY PER.PLASTNAME&quot;).append(sqlSortDir).append(&quot;, PER.PFIRSTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2296" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2297">					selectClause.append(&quot;, PER.PFIRSTNAME, PER.PLASTNAME &quot;);</span>
				}
				break;

			case Request.SORT_PFIRST_NAME_FIRST:
<span class="nc" id="L2302">				orderByClause.append(&quot; ORDER BY PER.PFIRSTNAME&quot;).append(sqlSortDir).append(&quot;, PER.PLASTNAME&quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2304" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2305">					selectClause.append(&quot;, PER.PFIRSTNAME, PER.PLASTNAME &quot;);</span>
				}
				break;

			case Request.SORT_STATUS:
<span class="nc" id="L2310">				orderByClause.append(&quot; ORDER BY REQ.REQUESTSTATUS &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2312" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2313">					selectClause.append(&quot;, REQ.REQUESTSTATUS &quot;);</span>
				}
				break;

			case Request.SORT_TYPE:
<span class="nc" id="L2318">				orderByClause.append(&quot; ORDER BY REQ.REQUESTTYPE &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2320" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2321">					selectClause.append(&quot;, REQ.REQUESTTYPE &quot;);</span>
				}
				break;

			case Request.SORT_MODIFIED:
<span class="nc" id="L2326">				orderByClause.append(&quot; ORDER BY REQ.LASTMODIFIEDAT &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2328" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2329">					selectClause.append(&quot;, REQ.LASTMODIFIEDAT &quot;);</span>
				}
				break;

			case Request.SORT_CREATED:
<span class="nc" id="L2334">				orderByClause.append(&quot; ORDER BY REQ.SUBMITTEDON &quot;).append(sqlSortDir);</span>

<span class="nc bnc" id="L2336" title="All 2 branches missed.">				if (addSortColsToSelectClause) {</span>
<span class="nc" id="L2337">					selectClause.append(&quot;, REQ.SUBMITTEDON &quot;);</span>
				}
				break;
			case Request.SORT_EMP_RANK:
<span class="nc" id="L2341">				orderByClause.append(&quot; ORDER BY EMPRANK.RANK &quot;).append(sqlSortDir);</span>
<span class="nc" id="L2342">				selectClause.append(&quot;, EMPRANK.RANK &quot;);</span>
<span class="nc" id="L2343">				break;</span>
			case Request.SORT_TO_SENIORITY:
<span class="nc" id="L2345">				orderByClause.append(&quot; ORDER BY &quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME &quot;).append(sqlSortDir);</span>
<span class="nc" id="L2346">				selectClause.append(&quot;,&quot;).append(TABLE_EMPLOYEEAM_ALIAS).append(&quot;.STARTTIME &quot;);</span>
<span class="nc" id="L2347">				break;</span>
			default:
				break;
		}
<span class="fc" id="L2351">	}</span>

	protected Quad getSelectFromWhereOrderClausesForReqType(IRequestType reqMgr, RequestFilter reqFilter, int sortColumn,
			int sortDirection) throws Exception {
<span class="nc" id="L2355">		String sortDirStr = RequestUtil.SORTDIR_ASC;</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">		if (sortDirection == SupportNavigation.SORT_DESCENDING) {</span>
<span class="nc" id="L2357">			sortDirStr = RequestUtil.SORTDIR_DESC;</span>
		}

		// Because the sort by clause may be added by a call back
		// it may need to add additional columns here
		// call the request manager for the specific request type to
		// add any addition columns. The only ones that need be
		// added are ones that might show up in a ORDER BY clause
<span class="nc" id="L2365">		StringBuffer selectClause = new StringBuffer();</span>
<span class="nc" id="L2366">		reqMgr.addToSelectColumns(selectClause, reqFilter, sortColumn);</span>

		// Call the type-specific request manager to add additional
		// tables as necessary
		// call the request manager for the specific request type to
		// add any addition tables.
<span class="nc" id="L2372">		StringBuffer fromClause = new StringBuffer();</span>
<span class="nc" id="L2373">		reqMgr.addToFromClause(fromClause, reqFilter, sortColumn);</span>

		// We have to let the reqMgr add their join and filter conditions
		// call the request manager for the specific request type to
		// add any addition conditions
<span class="nc" id="L2378">		StringBuffer whereClause = new StringBuffer();</span>
<span class="nc" id="L2379">		reqMgr.addToWhereClause(whereClause, reqFilter, sortColumn);</span>

		// Assume that the sort order is one understood by the
		// type specific request mgr, if any
		// call the request mgr call back to add the sort
		// condition
<span class="nc" id="L2385">		StringBuffer orderByClause = new StringBuffer();</span>
<span class="nc" id="L2386">		reqMgr.addOrderByClause(orderByClause, reqFilter, sortColumn, sortDirStr);</span>

<span class="nc" id="L2388">		return new Quad(selectClause, fromClause, whereClause, orderByClause);</span>
	}

	/**
	 * Note: returned requests may be fewer than the requested number of reqs. This will be the case if one or more of the given
	 * request IDs cannot be loaded. As result, the returned list of requests will not correspond to the elements in the reqID list
	 * or reqTypes list (the elements in the reqID list and reqTypes list correspond to each other for reqType == 'all').
	 *
	 * @param isReqTypeAll
	 * @param incExpired
	 * @param runSoftValids
	 * @param reqs
	 * @return
	 * @throws RemoteException
	 */
	protected Pair getReqsFromEJBManagersOrdered(List givenReqIDs, Map reqIDToReqTypeMap, boolean isReqTypeAll, boolean incExpired,
			boolean runSoftValids, boolean runNetStaffingSoftVal, int fromIndex, int chunkSize, long detailLevel, Collection reqs)
			throws Exception {

		// get the subset of requestIDs to be loaded using the given chunkSize and fromIndex.
<span class="fc" id="L2408">		int toIndexExcl = Math.min(fromIndex + chunkSize, givenReqIDs.size());</span>
<span class="pc bpc" id="L2409" title="1 of 2 branches missed.">		List reqIDsToBeLoaded = (toIndexExcl == givenReqIDs.size()) ? givenReqIDs : givenReqIDs.subList(fromIndex, toIndexExcl);</span>

<span class="pc bpc" id="L2411" title="1 of 2 branches missed.">		if (reqIDsToBeLoaded.isEmpty()) {</span>
<span class="nc" id="L2412">			return new Pair(Collections.EMPTY_LIST, Collections.EMPTY_SET);</span>
		}

<span class="fc" id="L2415">		Set reqEmpIDSet = new HashSet(3 * chunkSize);</span>
<span class="fc" id="L2416">		Collection unsortedReqs = new ArrayList(chunkSize);</span>
<span class="pc bpc" id="L2417" title="1 of 2 branches missed.">		if (isReqTypeAll) { // reqType == all.</span>
			// if requestType == 'all', group the IDs in the reqIDsToBeLoaded collection by requestType for bulk loading.
<span class="fc" id="L2419">			Map reqTypeToReqIDsMap = groupReqIDsByReqType(reqIDsToBeLoaded, reqIDToReqTypeMap);</span>

<span class="fc bfc" id="L2421" title="All 2 branches covered.">			for (int i = 0; i &lt; m_requestTypesArr.length; i++) {</span>
				// get request IDs for a specific request type.
<span class="fc" id="L2423">				String reqType = m_requestTypesArr[i];</span>
<span class="fc" id="L2424">				Collection reqIDsCollForSingleReqType = (Collection) reqTypeToReqIDsMap.get(reqType);</span>
				// if ID collection is empty, continue.
<span class="fc bfc" id="L2426" title="All 2 branches covered.">				if (reqIDsCollForSingleReqType == null)</span>
<span class="fc" id="L2427">					continue;</span>

<span class="fc" id="L2429">				IRequestType reqMgr = m_requestEJBManagersArr[i];</span>

				// load the requests
<span class="fc" id="L2432">				reqs = getRequestsByIDsEatExceptions(reqIDsCollForSingleReqType, reqMgr, incExpired, runSoftValids,</span>
						runNetStaffingSoftVal, detailLevel);
<span class="fc" id="L2434">				unsortedReqs.addAll(reqs);</span>

				// build set of employeeIDs from the reqs
<span class="fc" id="L2437">				addReqEmpIDsToSet(reqEmpIDSet, reqs, reqMgr);</span>
			}
<span class="fc" id="L2439">		} else { // all requests are of a single type</span>
<span class="nc" id="L2440">			String reqType = (String) reqIDToReqTypeMap.get(reqIDsToBeLoaded.get(0));</span>
<span class="nc" id="L2441">			IRequestType reqMgr = (IRequestType) m_requestEJBManagersMap.get(reqType);</span>
			// load the requests
<span class="nc bnc" id="L2443" title="All 2 branches missed.">			if (reqs == null) {</span>
<span class="nc" id="L2444">				reqs = getRequestsByIDsEatExceptions(reqIDsToBeLoaded, reqMgr, incExpired, runSoftValids, runNetStaffingSoftVal,</span>
						detailLevel);
			}
<span class="nc" id="L2447">			unsortedReqs.addAll(reqs);</span>

			// build set of employeeIDs from the reqs
<span class="nc" id="L2450">			addReqEmpIDsToSet(reqEmpIDSet, reqs, reqMgr);</span>
		}

		// Map for fast lookup of requests by their IDs.
<span class="fc" id="L2454">		Map reqIDToReqMap = RequestUtil.getMapOfIDsForVOBases(unsortedReqs);</span>

		// Sort loaded requests in the same order as the given reqIDs
<span class="fc" id="L2457">		List sortedReqs = new LinkedList();</span>
<span class="fc bfc" id="L2458" title="All 2 branches covered.">		for (Iterator iter = reqIDsToBeLoaded.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2459">			Object req = reqIDToReqMap.get(iter.next());</span>
<span class="pc bpc" id="L2460" title="1 of 2 branches missed.">			if (req != null)</span>
<span class="fc" id="L2461">				sortedReqs.add(req);</span>
<span class="fc" id="L2462">		}</span>

<span class="fc" id="L2464">		return new Pair(sortedReqs, reqEmpIDSet);</span>
	}

	/**
	 * Attempts bulk loading of requests first. If that fails, falls back to loading requests one by one.
	 *
	 * @param reqIDsCollForSingleReqType
	 * @param reqMgr
	 * @param incExpired
	 * @param runSoftValids
	 * @param detLevelForReqType
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Collection getRequestsByIDsEatExceptions(Collection reqIDsCollForSingleReqType, IRequestType reqMgr,
			boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detLevelForReqType) {

<span class="fc" id="L2482">		Collection reqs = null;</span>
		try {
<span class="fc" id="L2484">			reqs = reqMgr.getRequestsById(reqIDsCollForSingleReqType, incExpired, runSoftValids, runNetStaffingSoftVal,</span>
					detLevelForReqType);
<span class="nc" id="L2486">		} catch (Exception e) {</span>
<span class="nc" id="L2487">			m_cat.error(</span>
					&quot;Bulk loading of requests failed.  Trying loading reqs one by one: &quot;
<span class="nc" id="L2489">							+ RmUtil.dumpCollection(reqIDsCollForSingleReqType), e);</span>
<span class="fc" id="L2490">		}</span>

		// bulk load succeeded, so return.
<span class="pc bpc" id="L2493" title="1 of 2 branches missed.">		if (reqs != null)</span>
<span class="fc" id="L2494">			return reqs;</span>

		// bulk load failed. try loading reqs one by one.
<span class="nc" id="L2497">		reqs = new ArrayList(reqIDsCollForSingleReqType.size());</span>
<span class="nc bnc" id="L2498" title="All 2 branches missed.">		for (Iterator reqIDIter = reqIDsCollForSingleReqType.iterator(); reqIDIter.hasNext();) {</span>
<span class="nc" id="L2499">			ID reqID = (ID) reqIDIter.next();</span>

			try {
				// fetch the request
<span class="nc" id="L2503">				RequestAggregate reqAgg = reqMgr.getRequestByID(reqID, incExpired, runSoftValids, detLevelForReqType);</span>
<span class="nc bnc" id="L2504" title="All 2 branches missed.">				if (reqAgg != null) { // will return 'null' if request does not exist.</span>
<span class="nc" id="L2505">					reqs.add(reqAgg);</span>
				}
<span class="nc" id="L2507">			} catch (Exception e) {</span>
<span class="nc" id="L2508">				m_cat.error(&quot;Could not get request id: &quot; + reqID + &quot;. Ignoring exception and resuming with next. &quot;, e);</span>
<span class="nc" id="L2509">			}</span>
<span class="nc" id="L2510">		}</span>

<span class="nc" id="L2512">		return reqs;</span>
	}

	/**
	 * Splits the given reqID collection into three collections, one each for each request type. Returns a map of reqType to reqIDs
	 * collection.
	 *
	 * @param reqIDs
	 * @param reqTypesList list of request types. Can be 'null' if parameter reqIDToReqTypeMap is non-null.
	 * @param reqIDToReqTypeMap. Can be 'null' if parameter reqTypesList is non-null.
	 * @param reqsNeeded
	 * @return
	 */
	private Map groupReqIDsByReqType(List reqIDs, Map reqIDToReqTypeMap) {

<span class="fc" id="L2527">		Map reqTypeToreqIDsCollMap = new HashMap(m_requestTypesArr.length);</span>
		// for each request ID
<span class="fc bfc" id="L2529" title="All 2 branches covered.">		for (int i = 0; i &lt; reqIDs.size(); i++) {</span>
<span class="fc" id="L2530">			ID reqID = (ID) reqIDs.get(i);</span>

			// fetch the reqType from reqTypesList or reqIDToReqTypeMap parameter.
<span class="fc" id="L2533">			String reqType = (String) reqIDToReqTypeMap.get(reqID);</span>
<span class="pc bpc" id="L2534" title="3 of 4 branches missed.">			assert reqType != null : &quot;reqType != null&quot;;</span>

			// get reqID collection for request type.
<span class="fc" id="L2537">			Collection reqIDsForReqType = (Collection) reqTypeToreqIDsCollMap.get(reqType);</span>
			// if collection not found in map
<span class="fc bfc" id="L2539" title="All 2 branches covered.">			if (reqIDsForReqType == null) {</span>
				// create collection
<span class="fc" id="L2541">				reqIDsForReqType = new ArrayList(reqIDs.size());</span>
				// store in map.
<span class="fc" id="L2543">				reqTypeToreqIDsCollMap.put(reqType, reqIDsForReqType);</span>
			}

<span class="fc" id="L2546">			reqIDsForReqType.add(reqID);</span>
		}

<span class="fc" id="L2549">		return reqTypeToreqIDsCollMap;</span>
	}

	private void addReqEmpIDsToSet(Set reqEmpIDs, Collection reqs, IRequestType reqMgr) throws RemoteException {
<span class="fc bfc" id="L2553" title="All 2 branches covered.">		for (Iterator reqsIter = reqs.iterator(); reqsIter.hasNext();) {</span>
<span class="fc" id="L2554">			RequestAggregate reqAgg = (RequestAggregate) reqsIter.next();</span>
<span class="fc" id="L2555">			reqMgr.addEmployeeIDsToSet(reqAgg, reqEmpIDs);</span>
<span class="fc" id="L2556">		}</span>
<span class="fc" id="L2557">	}</span>

	// /**
	// * Obtain the detailLevels from the requesFilter and store it in map. If no detail maps
	// * are specified, map retured will be null.
	// *
	// * @param reqFilter
	// * @return
	// */
	// private Map getReqTypeToDetLevelMap(RequestFilter reqFilter) {
	//
	// Map reqTypeToDetLevelMap = null; // Map of requestType to detailLevel.
	//
	// boolean isSetBidReqDetLevel = ( (reqFilter != null) &amp;&amp;
	// reqFilter.isKeySet(RequestFilter.BIDREQ_DETAILLEVEL_KEY) );
	// if (isSetBidReqDetLevel) {
	// reqTypeToDetLevelMap = (reqTypeToDetLevelMap == null)?new HashMap():reqTypeToDetLevelMap;
	// // obtain the detail level.
	// Long bidReqDetLevel = (Long) reqFilter.getValueForKey(RequestFilter.BIDREQ_DETAILLEVEL_KEY);
	// // store it in the map.
	// reqTypeToDetLevelMap.put(Request.REQUESTTYPE_SHIFTBID, bidReqDetLevel);
	// }
	// return reqTypeToDetLevelMap;
	// }
	//
	/**
	 * @param i
	 */
	private void removeFromListsAndMap(int i, List reqIDs, List reqTypesList, Map IDToReqTypesMap) {
<span class="nc" id="L2586">		ID idToBeRemoved = (ID) reqIDs.get(i);</span>

<span class="nc" id="L2588">		reqIDs.remove(i);</span>
<span class="nc bnc" id="L2589" title="All 2 branches missed.">		if (reqTypesList != null)</span>
<span class="nc" id="L2590">			reqTypesList.remove(i);</span>

<span class="nc bnc" id="L2592" title="All 2 branches missed.">		if (IDToReqTypesMap != null)</span>
<span class="nc" id="L2593">			IDToReqTypesMap.remove(idToBeRemoved);</span>
<span class="nc" id="L2594">	}</span>

	protected Collection getEmpIDsUsingEmpFilter(User mgr, ArrayList empFilters) // , List seniorityTimeRange)
			throws BbmEJBCreateException, RemoteException, BbmFinderException {
<span class="nc" id="L2598">		return getEmpIDsUsingEmpFilter(mgr,empFilters, null);</span>
	}
	
	
	protected Collection getEmpIDsUsingEmpFilter(User mgr, ArrayList empFilters, List requestTimeRange) // , List seniorityTimeRange)
			throws BbmEJBCreateException, RemoteException, BbmFinderException {
		// Now make the compound filter we'll use to get the list of
		// employee ids
<span class="nc" id="L2606">		Filter cmpFltr = new Filter(0, // not used for AND filters</span>
				Filter.OPERATOR_AND, empFilters);

		// if (seniorityTimeRange != null) {
		// cmpFltr.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);
		// cmpFltr.setStartTime((Date) seniorityTimeRange.get(0));
		// cmpFltr.setEndTime((Date) seniorityTimeRange.get(1));
		// }

<span class="nc" id="L2615">		com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter empFltr = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L2616">		Collection empIds = empFltr.getEmployeeIDs(cmpFltr, // Filter</span>
				mgr, // User
				Collections.EMPTY_LIST, // sort fields
				false, // is ascending, don't care about order
				0, // offset
				Integer.MAX_VALUE); // max number of ids

<span class="nc" id="L2623">		return empIds;</span>
	}

	/**
	 * get filter for Campaign ID
	 */
	private void addCampaignToEmpFilter(ArrayList empFilters, RequestFilter requestFilter, List requestTimeRange) {
<span class="nc bnc" id="L2630" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.CS_CAMPAIGNID_KEY)) {</span>
<span class="nc" id="L2631">			ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2632">			list.add(requestFilter.getValueForKey(RequestFilter.SUPERVISOR_KEY));</span>
<span class="nc" id="L2633">			Filter f = new Filter(Filter.CAMPAIGNID, Filter.OPERATOR_EQUALS, list);</span>
<span class="nc bnc" id="L2634" title="All 2 branches missed.">			if (requestTimeRange != null) {</span>
<span class="nc" id="L2635">				f.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2636">				f.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2637">				f.setEndTime((Date) requestTimeRange.get(1));</span>
			}
<span class="nc" id="L2639">			empFilters.add(f);</span>
		}
<span class="nc" id="L2641">	}// getFilterForCampaign</span>

	protected void addSupervisorToEmpFilter(ArrayList empFilters, RequestFilter requestFilter, List requestTimeRange) {
		// Was supervisor filter condition set?
<span class="nc bnc" id="L2645" title="All 2 branches missed.">		if (requestFilter.isKeySet(RequestFilter.SUPERVISOR_KEY)) {</span>
<span class="nc" id="L2646">			ArrayList sups = new ArrayList(1);</span>
<span class="nc" id="L2647">			sups.add(requestFilter.getValueForKey(RequestFilter.SUPERVISOR_KEY));</span>
			// add supervisor subfilter to filters
<span class="nc" id="L2649">			Filter fsup = new Filter(Filter.MANAGERID, Filter.OPERATOR_IN, sups);</span>
<span class="nc bnc" id="L2650" title="All 2 branches missed.">			if (requestTimeRange != null) {</span>
<span class="nc" id="L2651">				fsup.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2652">				fsup.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2653">				fsup.setEndTime((Date) requestTimeRange.get(1));</span>
			}
			
<span class="nc" id="L2656">			empFilters.add(fsup);</span>
		}
<span class="nc" id="L2658">	}</span>

	protected void addOrganizationToEmpFilter(ArrayList empFilters, Set orgs) {
<span class="nc" id="L2661">		addOrganizationToEmpFilter(empFilters, orgs, null);</span>
<span class="nc" id="L2662">	}</span>

	protected void addOrganizationToEmpFilter(ArrayList empFilters, Set orgs, List requestTimeRange) {
		// Build the organization subfilter
<span class="nc" id="L2666">		ArrayList parms = new ArrayList(1);</span>
<span class="nc" id="L2667">		parms.add(orgs);</span>
<span class="nc" id="L2668">		Filter f = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, parms);</span>

		// QA 93028 - Time Off Request does not show if agent starts in future
		// Should get all employees during the requested time range instead of current time
<span class="nc bnc" id="L2672" title="All 2 branches missed.">		if (requestTimeRange != null) {</span>
<span class="nc" id="L2673">			f.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
<span class="nc" id="L2674">			f.setStartTime((Date) requestTimeRange.get(0));</span>
<span class="nc" id="L2675">			f.setEndTime((Date) requestTimeRange.get(1));</span>
		}
		// End 93028

<span class="nc" id="L2679">		empFilters.add(f);</span>
<span class="nc" id="L2680">	}</span>

	@Override
	public RequestFilter getRequestFilterById(ID id) throws BbmFinderException {
<span class="nc" id="L2684">		String _method_ = &quot;getRequestFilterById&quot;;</span>
<span class="nc" id="L2685">		methodStart(_method_, id);</span>

<span class="nc" id="L2687">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2690">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2692">			return new RequestFilter(fcm.findFilter(id));</span>
<span class="nc" id="L2693">		} catch (Exception e) {</span>
<span class="nc" id="L2694">			handleException(e, false);</span>
<span class="nc" id="L2695">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2697">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2698">			methodFinish();</span>
		}
	}

	@Override
	public RequestFilter getRequestFilterByName(ID idUser, String name) throws BbmFinderException {
<span class="nc" id="L2704">		String _method_ = &quot;getRequestFilterByName&quot;;</span>
<span class="nc" id="L2705">		methodStart(_method_, idUser, name);</span>

<span class="nc" id="L2707">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2710">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2712">			return new RequestFilter(fcm.findFilter(idUser, RequestFilter.REQUEST_FILTER_COMPONENT_CLASS, name));</span>
<span class="nc" id="L2713">		} catch (Exception e) {</span>
<span class="nc" id="L2714">			handleException(e, false);</span>
<span class="nc" id="L2715">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2717">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2718">			methodFinish();</span>
		}
	}

	@Override
	public IDStringPair[] getRequestFilterNamesByUserID(ID idUser) throws BbmFinderException {
<span class="fc" id="L2724">		String _method_ = &quot;getRequestFilterNamesByUserID&quot;;</span>
<span class="fc" id="L2725">		methodStart(_method_, idUser);</span>

<span class="fc" id="L2727">		FilterConfigManager fcm = null;</span>

		try {
<span class="fc" id="L2730">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="fc" id="L2732">			return fcm.getFilterNames(idUser, RequestFilter.REQUEST_FILTER_COMPONENT_CLASS);</span>
<span class="nc" id="L2733">		} catch (Exception e) {</span>
<span class="nc" id="L2734">			handleException(e, false);</span>
<span class="nc" id="L2735">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc" id="L2737">			removeFcmFinally(fcm);</span>
<span class="pc" id="L2738">			methodFinish();</span>
		}
	}

	// filters
	@Override
	public ID createRequestFilter(RequestFilter filter) throws BbmCreateException {
<span class="nc" id="L2745">		String _method_ = &quot;createRequestFilter&quot;;</span>
<span class="nc" id="L2746">		methodStart(_method_, filter);</span>

<span class="nc" id="L2748">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2751">			fcm = CoreManagerFactory.getFilterConfigManager();</span>

<span class="nc" id="L2753">			return fcm.insertFilter(filter.asFilterConfigVO());</span>
<span class="nc" id="L2754">		} catch (Exception e) {</span>
<span class="nc" id="L2755">			handleException(e);</span>
<span class="nc" id="L2756">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2758">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2759">			methodFinish();</span>
		}
	}

	@Override
	public void deleteRequestFilterByID(ID id) throws BbmRemoveException {
<span class="nc" id="L2765">		String _method_ = &quot;deleteRequestFilterByID&quot;;</span>
<span class="nc" id="L2766">		methodStart(_method_, id);</span>

<span class="nc" id="L2768">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2771">			fcm = CoreManagerFactory.getFilterConfigManager();</span>
<span class="nc" id="L2772">			fcm.deleteFilter(id);</span>
<span class="nc" id="L2773">		} catch (Exception e) {</span>
<span class="nc" id="L2774">			handleException(e);</span>
<span class="nc" id="L2775">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2777">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2778">			methodFinish();</span>
<span class="nc" id="L2779">		}</span>
<span class="nc" id="L2780">	}</span>

	/*
	 * update the given request filter in the database
	 */
	@Override
	public void updateRequestFilter(RequestFilter filter) throws BbmUpdateException {
<span class="nc" id="L2787">		String _method_ = &quot;updateRequestFilter&quot;;</span>
<span class="nc" id="L2788">		methodStart(_method_, filter);</span>

<span class="nc" id="L2790">		FilterConfigManager fcm = null;</span>

		try {
<span class="nc" id="L2793">			fcm = CoreManagerFactory.getFilterConfigManager();</span>
<span class="nc" id="L2794">			fcm.updateFilter(filter.asFilterConfigVO());</span>
<span class="nc" id="L2795">		} catch (Exception e) {</span>
<span class="nc" id="L2796">			handleException(e);</span>
<span class="nc" id="L2797">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2799">			removeFcmFinally(fcm);</span>
<span class="nc" id="L2800">			methodFinish();</span>
<span class="nc" id="L2801">		}</span>
<span class="nc" id="L2802">	}</span>

	/**
	 * Gets the list of requests ids for which the status has been updated since given date
	 *
	 * @param date
	 * @throws BbmFinderException
	 */
	@Override
	public Collection getRequestIDsByStatusChange(Date date) throws BbmFinderException {
<span class="nc" id="L2812">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L2814">			dmo = new Jdmo(false);</span>
			// load the request objects (without their children) to identify the request type.
<span class="nc" id="L2816">			RequestAuditTrailDAO reqDAO = new RequestAuditTrailDAO(dmo);</span>
<span class="nc" id="L2817">			return reqDAO.getRequestIDsByStatusChangeAndType(date);</span>
<span class="nc" id="L2818">		} catch (Exception e) {</span>
<span class="nc" id="L2819">			handleException(e, false);</span>
<span class="nc" id="L2820">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2822" title="All 4 branches missed.">			if (dmo != null)</span>
<span class="nc" id="L2823">				dmo.cleanUp();</span>
<span class="nc" id="L2824">			methodFinish();</span>
		}
	}

	private void removeFcmFinally(FilterConfigManager fcm) {
<span class="pc bpc" id="L2829" title="1 of 2 branches missed.">		if (fcm != null) {</span>
			try {
<span class="fc" id="L2831">				fcm.remove();</span>
<span class="nc" id="L2832">			} catch (Exception e) {</span>
<span class="nc" id="L2833">				m_cat.error(&quot;Exception in finally clause: &quot; + e, e);</span>
<span class="fc" id="L2834">			}</span>
		}

<span class="fc" id="L2837">	}</span>

	/**
	 * get a given work resource's skill assignment
	 *
	 * @idWorkResource work resource id
	 * @dtStart, @dtEnd: the time period, null date means a open period
	 *
	 * @return a collection DoubleStringPair objects which pairs of {String skillName, double proficiency}
	 */

	/*
	 * public Collection getSkillProficiencies(ID idWorkResource, Date dtStart, Date dtEnd) throws BbmFinderException,
	 * RemoteException { String _method_ = &quot;getSkillProficiencies&quot;; methodStart(_method_, idWorkResource, dtStart, dtEnd);
	 *
	 * try { // get the Collection of GenericSkillAssignments for the workresource. SkillManager manager =
	 * BbmManagerFactory.getSkillManager(); Collection skillAssignments = manager.getSkillAssignments(idWorkResource, dtStart,
	 * dtEnd);
	 *
	 * // extract pairs of {proficiency, skillName} ArrayList skillProficiencies = new ArrayList(skillAssignments.size());
	 * SkillAssignment skillAssignment; ID skillId; Skill skill; for (Iterator itr = skillAssignments.iterator(); itr.hasNext(); ) {
	 * skillAssignment = (SkillAssignment)itr.next(); skillId = skillAssignment.getSkillID(); skill = manager.getSkillByID(skillId);
	 * if (skill == null) { m_cat.l7dError(RmEjbBundleKey.INVALID_SKILL_ID, new ID[] {skillId}); continue; } DoubleStringPair pair =
	 * new DoubleStringPair( skillAssignment.getProficiency(), skill.getName()); skillProficiencies.add(pair); }
	 *
	 * return skillProficiencies; } catch (BbmEJBCreateException e) { handleException(e); throw
	 * RequestUtil.createBbmFinderException(e); } catch (BbmFinderException e) { handleException(e); throw e; } finally {
	 * methodFinish(); } }
	 *
	 * // returns a Collection of Skills public Collection getAvailableSkillsInOrg(ID orgId) throws BbmFinderException,
	 * RemoteException { String _method_ = &quot;getAvailableSkillsInOrg&quot;; methodStart(_method_, orgId);
	 *
	 * try { SkillManager manager = BbmManagerFactory.getSkillManager(); return manager.getSkillsInOrg(orgId); } catch
	 * (BbmEJBCreateException e) { handleException(e); throw RequestUtil.createBbmFinderException(e); } catch (BbmFinderException e)
	 * { handleException(e); throw e; } finally { methodFinish(); } }
	 *
	 * // returns a Collection of Campaigns public Collection getCampaigns() throws BbmFinderException, RemoteException { String
	 * _method_ = &quot;getCampaigns&quot;; methodStart(_method_);
	 *
	 * try { CampaignManager manager = BbmManagerFactory.getCampaignManager(); return manager.getCampaigns(); i } catch
	 * (BbmEJBCreateException e) { handleException(e); throw RequestUtil.createBbmFinderException(e); } catch (BbmFinderException e)
	 * { handleException(e); throw e; } finally { methodFinish(); } }
	 */
	/**
	 * &lt;li&gt;get empIDs for these orgs based on reqFilter criteria (seniority, supervisor etc).
	 *
	 * @param reqFilter
	 * @return Pair first element is boolean and second is a Collection of empIds. the first value is set to true if TOPOOL Key and
	 *         date range key is set and to false if either or both key are not set. Caller should return empty list if the value is
	 *         true and collection is empty or null. Collection can be empty or null or have employeeids
	 * @throws Exception
	 */
	@Override
	public Pair getEmpIDsForTOPool(RequestFilter reqFilter) throws BbmFinderException {
		try {
<span class="fc" id="L2892">			Collection empIds = null;</span>
<span class="pc bpc" id="L2893" title="3 of 4 branches missed.">			if (!reqFilter.isKeySet(RequestFilter.TOPOOL_KEY) || !reqFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)) {</span>
<span class="fc" id="L2894">				return new Pair(new Boolean(false), empIds); // false if TOPool Key or date range is not set</span>
			}
<span class="nc" id="L2896">			ID pTOPoolID = (ID) reqFilter.getValueForKey(RequestFilter.TOPOOL_KEY);</span>
<span class="nc" id="L2897">			List dateRange = (List) reqFilter.getValueForKey(RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc bnc" id="L2898" title="All 2 branches missed.">			Date start = (dateRange != null) ? (Date) dateRange.get(0) : null;</span>
<span class="nc bnc" id="L2899" title="All 2 branches missed.">			Date end = (dateRange != null) ? (Date) dateRange.get(1) : null;</span>
<span class="nc bnc" id="L2900" title="All 6 branches missed.">			if (pTOPoolID != null &amp;&amp; start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L2901">				CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L2902">				empIds = toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, start, end);</span>
			}
<span class="nc bnc" id="L2904" title="All 4 branches missed.">			if ((empIds == null) || (empIds.isEmpty())) {</span>
<span class="nc" id="L2905">				m_cat.error(&quot;&gt;&gt;&gt;No users in TOPool!, TOPOOLID=&quot; + pTOPoolID + &quot;: start=&quot; + start + &quot;:end=&quot; + end);</span>
			}
<span class="nc" id="L2907">			return new Pair(new Boolean(true), empIds); // true if TOPOOL Key and date range is set</span>

<span class="nc" id="L2909">		} catch (Exception e) {</span>
<span class="nc" id="L2910">			handleException(e);</span>
<span class="nc" id="L2911">			throw new BbmFinderException(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>