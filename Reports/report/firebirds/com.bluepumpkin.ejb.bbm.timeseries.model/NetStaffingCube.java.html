<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NetStaffingCube.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">NetStaffingCube.java</span></div><h1>NetStaffingCube.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.model;

import java.io.Serializable;
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;

/**
 * Title: Verint Software Basic Business Model Description: NetStaffingCube
 * object, mainly used by UI to load NET-STAFFING &amp; OVER/UNDER Staffing of Trace
 * Data for a given period for a set a queues for a givwn employee. the Queues
 * are filtered based on employee skills. the Queues can have a LTI of 15 mins,
 * hourly, daily or weekly interval. Copyright: Copyright (c) 2011 Company:
 * Verint, inc
 *
 * @author Sameet Joshi
 * @version 2.0
 */
public class NetStaffingCube implements Serializable, INetStaffingCube {

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
	// All the HashMaps are store with reference to SPQID; that is the least
	// commmon denominator between the collections.
<span class="fc" id="L35">	private HashMap&lt;ID, PredictTraceCube&gt; m_PTCMap = new HashMap&lt;ID, PredictTraceCube&gt;();</span>
<span class="fc" id="L36">	private HashMap&lt;ID, RequireTraceCube&gt; m_RTCMap = new HashMap&lt;ID, RequireTraceCube&gt;();</span>

<span class="fc" id="L38">	private HashMap&lt;ID, SPQueue&gt; m_SPQueueMap = new HashMap&lt;ID, SPQueue&gt;();</span>
<span class="fc" id="L39">	private HashMap&lt;ID, Campaign&gt; m_CampaignMap = new HashMap&lt;ID, Campaign&gt;();</span>

<span class="fc" id="L41">	private TimeRange tr = null;</span>

<span class="fc" id="L43">	public NetStaffingCube() {</span>

<span class="fc" id="L45">	}</span>

	public HashMap&lt;ID, PredictTraceCube&gt; getPredictTraceCubeMap() {
<span class="fc" id="L48">		return m_PTCMap;</span>
	}

	public HashMap&lt;ID, RequireTraceCube&gt; getRequireTraceCubeMap() {
<span class="fc" id="L52">		return m_RTCMap;</span>
	}

	public HashMap&lt;ID, SPQueue&gt; getSPQueueMap() {
<span class="nc" id="L56">		return m_SPQueueMap;</span>
	}

	public HashMap&lt;ID, Campaign&gt; getCampaignMap() {
<span class="nc" id="L60">		return m_CampaignMap;</span>
	}

	/* Adds NetStaffing Data for relevant Campaign -Queue combination */
	public void addNetStaffing(Campaign camp, PredictTraceCube pCube, RequireTraceCube rCube, SPQueue spQueue) {
<span class="fc" id="L65">		m_PTCMap.put(spQueue.getID(), pCube);</span>
<span class="fc" id="L66">		m_RTCMap.put(spQueue.getID(), rCube);</span>
<span class="fc" id="L67">		m_SPQueueMap.put(spQueue.getID(), spQueue);</span>
<span class="fc" id="L68">		m_CampaignMap.put(spQueue.getID(), camp);</span>
<span class="fc" id="L69">	}</span>

	/**
	 * Returns Over / Under Numbers for a given datetime instant.
	 *
	 * @param eventActivity - The activity that the agent is currently scheduled to work
	 *                      on at this time, or null if none.
	 * @param mediaIDs      - The media IDs linked to the scheduled activity.
	 * @param qIDs          - the queue IDs linked to the activity (for queue-hopping
	 *                      activities only).
	 */
	public int getOverUnder(Date date, Activity eventActivity, Collection&lt;ID&gt; mediaIDs, Collection&lt;ID&gt; qIDs) {
<span class="nc" id="L81">		boolean foundOver = false;</span>
<span class="nc" id="L82">		boolean foundNotOverUnder = false;</span>
<span class="nc" id="L83">		int retOverUnder = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>

<span class="nc" id="L85">		Collection&lt;ID&gt; spQueueIDsForActivity = getSPQueueIDsForActivity(eventActivity, mediaIDs, qIDs);</span>

<span class="nc bnc" id="L87" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L88">			ID spQID = iterator.next();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">			if (spQueueIDsForActivity.contains(spQID)) {</span>
<span class="nc" id="L90">				PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">				if (!pCube.fallsIn(date)) {</span>
<span class="nc" id="L92">					continue;</span>
				}
<span class="nc" id="L94">				RequireTraceCube rCube = m_RTCMap.get(spQID);</span>
<span class="nc" id="L95">				Campaign camp = m_CampaignMap.get(spQID);</span>
<span class="nc" id="L96">				SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L97">				TimeRange range = snapDate(camp, pCube, spQueue, date);</span>
<span class="nc" id="L98">				int startAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L99">				int endAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L100">				double cForFTE = TraceOperator.aggregatePeriodD(pCube, Trace.AFTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L101">				double cReqFTE = TraceOperator.aggregatePeriodD(rCube, Trace.FTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L102">				int over_under = getOverUnder(cForFTE, cReqFTE, spQueue);</span>
<span class="nc bnc" id="L103" title="All 4 branches missed.">				switch (over_under) {</span>
					case Trace.NETSTAFF_NOT_OVER_OR_UNDER:
<span class="nc" id="L105">						foundNotOverUnder = true;</span>
<span class="nc" id="L106">						continue;</span>
					case Trace.NETSTAFF_UNDER:
<span class="nc" id="L108">						return Trace.NETSTAFF_UNDER; // as soon as under is found</span>
					// just stop here
					case Trace.NETSTAFF_OVER:
<span class="nc" id="L111">						foundOver = true;</span>
<span class="nc" id="L112">						continue;</span>
				}
			}
<span class="nc" id="L115">		}</span>

<span class="nc bnc" id="L117" title="All 2 branches missed.">		if (foundNotOverUnder) {</span>
<span class="nc" id="L118">			return Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
		} else {
<span class="nc bnc" id="L120" title="All 2 branches missed.">			if (foundOver)</span>
<span class="nc" id="L121">				return Trace.NETSTAFF_OVER;</span>
		}
<span class="nc" id="L123">		return retOverUnder;</span>
	}

	/**
	 * Returns the SPQueues in this cube that are linked to the specified
	 * activity (either through queue hopping, or through media).
	 *
	 * @param activity - The activity.
	 * @param mediaIDs - The media IDs linked to the scheduled activity.
	 * @param qIDs     - the queue IDs linked to the activity (for queue-hopping
	 *                 activities only).
	 * @return A subset of the SPQueues in this cube.
	 */
	private Collection&lt;ID&gt; getSPQueueIDsForActivity(Activity activity, Collection&lt;ID&gt; mediaIDs, Collection&lt;ID&gt; qIDs) {
<span class="nc bnc" id="L137" title="All 2 branches missed.">		if (activity == null) {</span>
			// The agent is not scheduled, so we need to consider all queues.
<span class="nc" id="L139">			return m_PTCMap.keySet();</span>
		}

<span class="nc" id="L142">		HashSet&lt;ID&gt; spQueueIDs = new HashSet(m_SPQueueMap.size());</span>

<span class="nc" id="L144">		boolean hasIndividualQueue = false;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		for (ID spQID : m_PTCMap.keySet()) {</span>
<span class="nc" id="L146">			SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (spQueue.getQueueID() != null)</span>
<span class="nc" id="L148">				hasIndividualQueue = true;</span>
<span class="nc" id="L149">		}</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if (!hasIndividualQueue) {</span>
			// non-skilled SP's will only contain the Combined-Phone SPQueues
			// (there can be &gt;1 for consecutive SP's).
			// Any activity will be for those Combined-Phone SPQueues.
<span class="nc" id="L154">			return m_PTCMap.keySet();</span>
		}

<span class="nc bnc" id="L157" title="All 2 branches missed.">		if (activity.isQueueHopping()) {</span>
			// find the queues linked to this activity
<span class="nc bnc" id="L159" title="All 4 branches missed.">			if (qIDs != null &amp;&amp; !qIDs.isEmpty()) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">				for (ID queueID : qIDs) {</span>
					// find the spq (if any) for this queue
					// TBD GQ: Will we need to consider the combined queues of
					// this queue's media as well? Probably not.
<span class="nc" id="L164">					Collection&lt;SPQueue&gt; curQueueHopSPQColl = getSPQueuesByQueueID(m_SPQueueMap, queueID);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">					if (!curQueueHopSPQColl.isEmpty()) {</span>
<span class="nc" id="L166">						spQueueIDs.addAll(ValueObjectUtil.getIDFromObjects(curQueueHopSPQColl));</span>
					}
<span class="nc" id="L168">				}</span>
			}
		} else {
			// find the medias linked to this activity, then find all spQueues
			// linked to those medias. We can probably eliminate the combined
			// spQueues.
<span class="nc" id="L174">			spQueueIDs = getSPQueuesForMedias(mediaIDs);</span>
		}

<span class="nc" id="L177">		return spQueueIDs;</span>
	}

	/**
	 * Returns the collection of SPQueues linked to the given QueueID in this NetStaffingCube.
	 */
	static Collection&lt;SPQueue&gt; getSPQueuesByQueueID(Map&lt;ID, SPQueue&gt; spQueueMap, ID queueID) {
<span class="nc" id="L184">		Collection&lt;SPQueue&gt; retVal = new ArrayList&lt;SPQueue&gt;();</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">		for (ID spQueueID : spQueueMap.keySet()) {</span>
<span class="nc" id="L186">			SPQueue spQueue = spQueueMap.get(spQueueID);</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">			if (spQueue.getQueueID().equals(queueID)) {</span>
<span class="nc" id="L188">				retVal.add(spQueue);</span>
			}
<span class="nc" id="L190">		}</span>
<span class="nc" id="L191">		return retVal;</span>
	}

	/**
	 * Get all non-combined SPQ's of the given media types.
	 */
	private HashSet&lt;ID&gt; getSPQueuesForMedias(Collection&lt;ID&gt; mediaIDs) {
<span class="nc" id="L198">		HashSet&lt;ID&gt; spQueueIDs = new HashSet(m_SPQueueMap.size());</span>
<span class="nc bnc" id="L199" title="All 4 branches missed.">		if (mediaIDs != null &amp;&amp; !mediaIDs.isEmpty()) {</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">			for (ID spQueueID : m_SPQueueMap.keySet()) {</span>
<span class="nc" id="L201">				SPQueue spQueue = m_SPQueueMap.get(spQueueID);</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">				if (spQueue.getQueueID() != null) // make sure it's not a</span>
													// combined queue
				{
<span class="nc" id="L205">					ID mediaID = spQueue.getMediaID();</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">					if (mediaIDs.contains(mediaID)) {</span>
<span class="nc" id="L207">						spQueueIDs.add(spQueue.getID());</span>
					}
				}
<span class="nc" id="L210">			}</span>
		}
<span class="nc" id="L212">		return spQueueIDs;</span>
	}

	/*
	 * Returns NetStaff Numbers for a given date range, for each queue.
	 */
	public HashMap&lt;SPQueue, Double&gt; getNetStaffingForDateRange(Date start, Date end) {
<span class="nc" id="L219">		HashMap&lt;SPQueue, Double&gt; m_SPQueueRetMap = new HashMap&lt;SPQueue, Double&gt;();</span>

<span class="nc bnc" id="L221" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L222">			ID spQID = iterator.next();</span>
<span class="nc" id="L223">			PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L224" title="All 4 branches missed.">			if (start.after(pCube.getRawEndDate()) || end.before(pCube.getRawStartDate())) {</span>
<span class="nc" id="L225">				continue;</span>
			}
<span class="nc bnc" id="L227" title="All 2 branches missed.">			Date stDate = start.before(pCube.getRawStartDate()) ? pCube.getRawStartDate() : start;</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">			Date enDate = end.after(pCube.getRawEndDate()) ? pCube.getRawEndDate() : end;</span>
<span class="nc" id="L229">			SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L230">			Campaign camp = m_CampaignMap.get(spQID);</span>

<span class="nc" id="L232">			TimeRange rangeSt = snapDate(camp, pCube, spQueue, stDate);</span>
<span class="nc" id="L233">			TimeRange rangeEnd = snapDate(camp, pCube, spQueue, enDate);</span>
<span class="nc" id="L234">			int startAbsOffset = pCube.getTimeOffset(rangeSt.getStartDate());</span>
<span class="nc" id="L235">			int endAbsOffset = pCube.getTimeOffset(rangeEnd.getEndDate());</span>
<span class="nc" id="L236">			double origVal = TraceOperator.aggregatePeriod(pCube, Trace.NETSTAFFING, startAbsOffset, endAbsOffset);</span>

<span class="nc" id="L238">			m_SPQueueRetMap.put(spQueue, origVal);</span>
<span class="nc" id="L239">		}</span>
<span class="nc" id="L240">		return m_SPQueueRetMap;</span>
	}

	public int getOverUnder(double cForFTE, double cReqFTE, SPQueue spQueue) {
<span class="nc" id="L244">		int retVal = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">		if (Trace.isValidValue(cForFTE) &amp;&amp; Trace.isValidValue(cReqFTE)) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">			double fteRatio = cForFTE == 0 ? Double.MAX_VALUE : ((double) cReqFTE * 100d / (double) cForFTE);</span>

<span class="nc bnc" id="L248" title="All 2 branches missed.">			if (cReqFTE &gt; cForFTE) { // UNDER</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdUnderPercentage()) {</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">					if ((cReqFTE - cForFTE) &gt; spQueue.getFTEThresholdUnder()) {</span>
<span class="nc" id="L251">						retVal = Trace.NETSTAFF_UNDER;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L255" title="All 2 branches missed.">					if ((fteRatio - 100.0d) &gt; spQueue.getFTEThresholdUnder()) {</span>
<span class="nc" id="L256">						retVal = Trace.NETSTAFF_UNDER;</span>
					}
				}
<span class="nc bnc" id="L259" title="All 2 branches missed.">			} else if (cReqFTE &lt; cForFTE) { // OVER</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdOverPercentage()) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">					if ((cForFTE - cReqFTE) &gt; spQueue.getFTEThresholdOver()) {</span>
<span class="nc" id="L262">						retVal = Trace.NETSTAFF_OVER;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L266" title="All 2 branches missed.">					if ((100.0d - fteRatio) &gt; spQueue.getFTEThresholdOver()) {</span>
<span class="nc" id="L267">						retVal = Trace.NETSTAFF_OVER;</span>
					}
				}
			} else {
<span class="nc" id="L271">				retVal = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
			}
		}
<span class="nc" id="L274">		return retVal;</span>
	}

	/**
	 * If the FTE Differential value falls under the spQueue's net staffing
	 * threshold, returns 0. Otherwise, returns the FTE Differential value.
	 * Note: FTE Differential = (Forecasted FTE - Required FTE) The purpose of
	 * threshold is to allow queue to have a &quot;buffer zone&quot; in case the forecast
	 * is not accurate. For example, if they're not completely sure that their
	 * forecast is accurate, they might set the threshold to 5, meaning that
	 * they don't want to let agents take a time off unless they're absolutely
	 * sure that they will have overstaffing. So, a threshold of 5 would mean
	 * that they have a confidence in their forecast values of +/- 5 staffed
	 * agents. Conversely, they don't want to let the agents request a shift
	 * unless they are certain that they are understaffed, lest they become
	 * overstaffed in the event of the forecast having been a bit too high.
	 */
	public double getFTEDPastThreshold(double cForFTE, double cReqFTE, SPQueue spQueue) {
<span class="nc" id="L292">		double retVal = 0;</span>

<span class="nc bnc" id="L294" title="All 4 branches missed.">		if (Trace.isValidValue(cForFTE) &amp;&amp; Trace.isValidValue(cReqFTE)) {</span>
<span class="nc" id="L295">			retVal = cForFTE - cReqFTE;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			double fteRatio = (cForFTE == 0) ? Double.MAX_VALUE : ((double) cReqFTE * 100d / (double) cForFTE);</span>

<span class="nc bnc" id="L298" title="All 2 branches missed.">			if (retVal &lt; 0.0d) { // UNDER</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdUnderPercentage()) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">					if (Math.abs(retVal) &lt;= (double) (spQueue.getFTEThresholdUnder())) {</span>
<span class="nc" id="L301">						retVal = 0.0d;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L305" title="All 2 branches missed.">					if ((fteRatio - 100.0d) &lt;= (double) (spQueue.getFTEThresholdUnder())) {</span>
<span class="nc" id="L306">						retVal = 0.0d; // Trace.NETSTAFF_UNDER;</span>
					}
				}
<span class="nc bnc" id="L309" title="All 2 branches missed.">			} else if (retVal &gt; 0.0d) { // OVER</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdOverPercentage()) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">					if (retVal &lt;= (double) (spQueue.getFTEThresholdOver())) {</span>
<span class="nc" id="L312">						retVal = 0.0d;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L316" title="All 2 branches missed.">					if ((100.0d - fteRatio) &lt;= (double) (spQueue.getFTEThresholdOver())) {</span>
<span class="nc" id="L317">						retVal = 0.0d; // Trace.NETSTAFF_OVER;</span>
					}
				}
			} else {
			}
		}
<span class="nc" id="L323">		return retVal;</span>
	}

	// cst cen
	// ----------|------|----
	// st--end
	// st---------------------en
	// st---en
	// st-----------en
	// st---------en
	// st-en
	/*
	 * Snaps Date to start of period based on the LTI. //LTI= 15 Mins******
	 * //Just return the date as is ( snap date is internal to TRACECUBE
	 * implementation.
	 * 
	 * //LTI= Hourly****** //snaps the date on the hour by actual time based on
	 * GMT TZ, if the campaign does not start at the hour and the passd date is
	 * within camp start time and the first turn of hour then it returns the
	 * campaign start time.
	 * 
	 * //LTI= Daily ****** //snaps the date on the start of the day i.e. 12:00
	 * AM by actual time based on GMT TZ, if the campaign does not start at
	 * 12:00 AM and starts at a day boundary &amp; the passd date falls within
	 * campaign start time and the end of the first day then it returns the
	 * campaign start time.
	 * 
	 * //LTI= weekly****** // Weekly Ranges are created based on the actual
	 * campaign start times. // Find if the date falls in weekly range and
	 * returns start date of the weekly range.
	 */
	public TimeRange snapDate(Campaign camp, TraceCube pCube, SPQueue spQueue, Date date) {
<span class="nc" id="L355">		return snapDate(camp, pCube.getRawStartDate(), pCube.getRawEndDate(), spQueue.getLeastTimeInterval(), date);</span>
	}

	public static TimeRange getDateRangeForNetstaffing(Campaign camp, Collection&lt;SPQueue&gt; spQueues,
			CampaignWorkResource ass, Date start, Date end) throws Exception {
<span class="fc" id="L360">		int lti = getMaxLeastTimeInterval(spQueues);</span>
		// we need the max LTI in following precedence weekly &gt; daily -&gt; hourly
		// -&gt; 15mins
<span class="fc" id="L363">		TimeRange tr = new TimeRange(ass.getStartTime(), ass.getEndTime());</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">		if (start.after(ass.getStartTime())) {</span>
<span class="fc" id="L365">			TimeRange trStart = snapDate(camp, ass.getStartTime(), ass.getEndTime(), lti, start);</span>
<span class="fc" id="L366">			tr.setStartDate(trStart.getStartDate());</span>
		}
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">		if (end.before(ass.getEndTime())) {</span>
<span class="fc" id="L369">			TimeRange trEnd = snapDate(camp, ass.getStartTime(), ass.getEndTime(), lti, end);</span>
<span class="fc" id="L370">			tr.setEndDate(trEnd.getEndDate());</span>
		}
<span class="fc" id="L372">		return tr;</span>
	}

	public static TimeRange snapDate(Campaign camp, Date spStartDate, Date spEndDate, int leastTimeItvl, Date date) {
<span class="fc" id="L376">		Calendar cal = Calendar.getInstance(camp.getTimeZone());</span>
<span class="fc" id="L377">		cal.setTime(date);</span>
		//DST issue due to Java quirk. We must use cal.add instead of cal.set. (See bug JDK-6615045).
<span class="fc" id="L379">		cal.add(Calendar.SECOND, -cal.get(Calendar.SECOND));</span>
<span class="fc" id="L380">		cal.add(Calendar.MILLISECOND, -cal.get(Calendar.MILLISECOND));</span>
		
<span class="pc bpc" id="L382" title="4 of 5 branches missed.">		switch (leastTimeItvl) {</span>
			case SPQueue.LEAST_TIME_INTERVAL_15MINS: {
<span class="fc" id="L384">				snapCalTo15Minutes(cal);</span>
<span class="fc" id="L385">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_HOURLY: {
<span class="nc" id="L388">				cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="nc" id="L389">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_DAILY: {
<span class="nc" id="L392">				cal.add(Calendar.HOUR_OF_DAY, -cal.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L393">				cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">				if (camp.getDayBoundaryOffset() &gt; 0) {</span>
					//possible DST bug: may need to call TOCalcUtil.setCalMinsOffsetFromMidnight() below, instead of cal.add.
<span class="nc" id="L396">					cal.add(Calendar.MINUTE, camp.getDayBoundaryOffset());</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">					if (!cal.getTime().before(date)) {</span>
<span class="nc" id="L398">						cal.add(Calendar.DAY_OF_MONTH, -1);</span>
						// go back one day because of stupid day boundary logic
					}
				}
				break;
			}
			case SPQueue.LEAST_TIME_INTERVAL_WEEKLY: {
<span class="nc" id="L405">				TimeRange[] weekRanges = TraceOperator.getWeeklyRanges(camp.getTimeZone(), spStartDate, spEndDate);</span>
<span class="nc bnc" id="L406" title="All 2 branches missed.">				if (weekRanges != null) {</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">					for (int weekOffset = 0; weekOffset &lt; weekRanges.length; weekOffset++) {</span>
<span class="nc" id="L408">						TimeRange curWeek = weekRanges[weekOffset];</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">						if (curWeek.includes(date)) {</span>
<span class="nc" id="L410">							cal.setTime(curWeek.getStartDate());</span>
<span class="nc" id="L411">							break;</span>
						}
					}
				}
				break;
			}
		}
		// snap to startdate if campaign does not start on the hour or on start
		// of the day and derived date is before SP start.
<span class="pc bpc" id="L420" title="1 of 2 branches missed.">		if (cal.getTime().before(spStartDate)) {</span>
<span class="nc" id="L421">			cal.setTime(spStartDate);</span>
		}
<span class="fc" id="L423">		Date st = cal.getTime();</span>

<span class="pc bpc" id="L425" title="4 of 5 branches missed.">		switch (leastTimeItvl) {</span>
			case SPQueue.LEAST_TIME_INTERVAL_15MINS: {
<span class="fc" id="L427">				cal.add(Calendar.MINUTE, Trace.INTERVAL);</span>
<span class="fc" id="L428">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_HOURLY: {
<span class="nc" id="L431">				cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L432">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_DAILY: {
<span class="nc" id="L435">				cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L436">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_WEEKLY: {
<span class="nc" id="L439">				cal.add(Calendar.DATE, 7);</span>
				break;
			}
		}
		// snap to startdate if campaign does not start on the hour or on start
		// of the day and derived date is before SP start.
		
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		if (cal.getTime().after(spEndDate)) {</span>
<span class="nc" id="L447">			cal.setTime(spEndDate);</span>
		}
<span class="pc bpc" id="L449" title="1 of 2 branches missed.">		if (cal.getTime().after(st)) {</span>
<span class="fc" id="L450">			return new TimeRange(st, new Date(cal.getTime().getTime() - 1));</span>
		} else {
<span class="nc" id="L452">			return new TimeRange(st, st);</span>
		}
	}

	/**
	 * Snap the minutes part of a Calendar date to the 15-minute interval it falls under.
	 * Seconds and milliseconds will not be altered. For example:
	 * 11/11/2015 8:44:00 PM will be snapped to 11/11/2015 8:30:00 PM.
	 * 11/11/2015 8:45:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 * 11/11/2015 8:46:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 * 11/11/2015 8:59:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 */
	public static void snapCalTo15Minutes(Calendar cal) {
<span class="fc" id="L465">		int minute = cal.get(Calendar.MINUTE) / Trace.INTERVAL;</span>
		//DST issue due to Java quirk. We must use cal.add instead of cal.set. (See bug JDK-6615045).
<span class="fc" id="L467">		cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="fc" id="L468">		cal.add(Calendar.MINUTE, Trace.INTERVAL * minute);</span>
<span class="fc" id="L469">	}</span>

	public HashMap getOverUnder(Date fromDate, Date toDate) {
<span class="nc" id="L472">		HashMap&lt;Integer, HashMap&gt; overUnderMap = new HashMap&lt;Integer, HashMap&gt;();</span>
<span class="nc" id="L473">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L474">		cal.setTime(fromDate);</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">		while (toDate.after(cal.getTime())) {</span>
<span class="nc" id="L476">			int totalOverUnder = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc" id="L477">			boolean foundNotOverUnder = false;</span>
<span class="nc" id="L478">			boolean foundOver = false;</span>
<span class="nc" id="L479">			TreeSet spQUnderSet = new TreeSet();</span>
<span class="nc" id="L480">			TreeSet spQNotOverOrUnderSet = new TreeSet();</span>

<span class="nc bnc" id="L482" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L483">				ID spQID = iterator.next();</span>
<span class="nc" id="L484">				PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L485" title="All 2 branches missed.">				if (!pCube.fallsIn(cal.getTime())) {</span>
<span class="nc" id="L486">					continue;</span>
				}
<span class="nc" id="L488">				RequireTraceCube rCube = m_RTCMap.get(spQID);</span>
<span class="nc" id="L489">				SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L490">				Campaign camp = m_CampaignMap.get(spQID);</span>
<span class="nc" id="L491">				TimeRange range = snapDate(camp, pCube, spQueue, cal.getTime());</span>
<span class="nc" id="L492">				int startAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L493">				int endAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L494">				double cForFTE = TraceOperator.aggregatePeriod(pCube, Trace.AFTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L495">				double cReqFTE = TraceOperator.aggregatePeriod(rCube, Trace.FTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L496">				int over_under = getOverUnder(cForFTE, cReqFTE, spQueue);</span>

<span class="nc bnc" id="L498" title="All 2 branches missed.">				if (over_under == Trace.NETSTAFF_UNDER) {</span>
<span class="nc" id="L499">					spQUnderSet.add(spQID);</span>
				}
<span class="nc bnc" id="L501" title="All 2 branches missed.">				if (over_under == Trace.NETSTAFF_NOT_OVER_OR_UNDER) {</span>
<span class="nc" id="L502">					spQNotOverOrUnderSet.add(spQID);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">				} else if (over_under == Trace.NETSTAFF_OVER) {</span>
<span class="nc" id="L504">					foundOver = true;</span>
				}
<span class="nc" id="L506">			}</span>

<span class="nc" id="L508">			Date stDate = cal.getTime();</span>
<span class="nc" id="L509">			cal.add(Calendar.MINUTE, Trace.INTERVAL); // add 15 minutes every</span>
														// time regardless of
														// LTI
			// cal.add(Calendar.MILLISECOND, -1);
<span class="nc" id="L513">			Date enDate = cal.getTime();</span>
			// cal.add(Calendar.MILLISECOND, 1);
<span class="nc" id="L515">			TimeRange range = new TimeRange(stDate, enDate);</span>
			// Over / under , time range, spQueue
<span class="nc bnc" id="L517" title="All 2 branches missed.">			if (!spQUnderSet.isEmpty()) {</span>
<span class="nc" id="L518">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_UNDER, spQUnderSet);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			} else if (!spQNotOverOrUnderSet.isEmpty()) {</span>
<span class="nc" id="L520">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_NOT_OVER_OR_UNDER, spQNotOverOrUnderSet);</span>
			} else {
<span class="nc" id="L522">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_OVER, m_PTCMap.keySet());</span>
			}
<span class="nc" id="L524">		}</span>
		/*
		 * Return a HASHMAP of OVER /UNDER / NEUTRAL &lt;-&gt; HASHMAP of Time
		 * Ranges&lt;-&gt; SPQueues
		 */
<span class="nc" id="L529">		return overUnderMap;</span>
	}

	private void setSPQAndTimeRange(Map overUnderMap, TimeRange range, int over_under, Set spQSet) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (!overUnderMap.containsKey(over_under)) {</span>
<span class="nc" id="L534">			overUnderMap.put(over_under, new HashMap());</span>
		}
<span class="nc" id="L536">		HashMap timeRangeSPQMap = (HashMap) overUnderMap.get(over_under);</span>
<span class="nc" id="L537">		timeRangeSPQMap.put(range, spQSet);</span>
<span class="nc" id="L538">	}</span>

	public HashMap getOverUnder(Collection&lt;TimeRange&gt; trCol) {
<span class="nc" id="L541">		HashMap&lt;Integer, HashMap&gt; overUnderSPQMap = new HashMap();</span>
<span class="nc bnc" id="L542" title="All 4 branches missed.">		if (trCol == null || trCol.isEmpty())</span>
<span class="nc" id="L543">			return overUnderSPQMap;</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">		for (Iterator iterator = trCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L545">			TimeRange range = (TimeRange) iterator.next();</span>
<span class="nc" id="L546">			mergeMap(overUnderSPQMap, getOverUnder(range.getStartDate(), range.getEndDate()));</span>
<span class="nc" id="L547">		}</span>
<span class="nc" id="L548">		return overUnderSPQMap;</span>
	}

	private void mergeMap(HashMap destMap, HashMap srcMap) {
<span class="nc bnc" id="L552" title="All 4 branches missed.">		if (srcMap == null || srcMap.isEmpty())</span>
<span class="nc" id="L553">			return;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">		for (Iterator iterator = srcMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L555">			Object key = iterator.next();</span>
<span class="nc" id="L556">			HashMap over_underMap = (HashMap) srcMap.get(key);</span>
<span class="nc bnc" id="L557" title="All 6 branches missed.">			if (over_underMap == null || (over_underMap != null &amp;&amp; over_underMap.isEmpty())) {</span>
<span class="nc" id="L558">				continue; // Src Map does not have this value no point in trying</span>
							// to merge. skip this
			}
<span class="nc bnc" id="L561" title="All 2 branches missed.">			if (!destMap.containsKey(key)) {</span>
<span class="nc" id="L562">				destMap.put(key, new HashMap());</span>
			}
<span class="nc" id="L564">			HashMap over_underMapDest = (HashMap) destMap.get(key);</span>
<span class="nc" id="L565">			over_underMapDest.putAll(over_underMap);</span>
<span class="nc" id="L566">		}</span>
<span class="nc" id="L567">	}</span>

	public int getMaxLeastTimeInterval() {
<span class="nc" id="L570">		return getMaxLeastTimeInterval(m_SPQueueMap.values());</span>
	}

	private static int getMaxLeastTimeInterval(Collection&lt;SPQueue&gt; spQueues) {
<span class="fc" id="L574">		int lti = SPQueue.LEAST_TIME_INTERVAL_15MINS;</span>
		// we need the max LTI in following precedence weekly &gt; daily -&gt; hourly
		// -&gt; 15mins
<span class="fc bfc" id="L577" title="All 2 branches covered.">		for (SPQueue spQueue : spQueues) {</span>
<span class="pc bpc" id="L578" title="1 of 2 branches missed.">			if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_WEEKLY) {</span>
<span class="nc" id="L579">				lti = SPQueue.LEAST_TIME_INTERVAL_WEEKLY;</span>
<span class="nc" id="L580">				break;</span>
<span class="pc bpc" id="L581" title="1 of 2 branches missed.">			} else if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_DAILY) {</span>
<span class="nc" id="L582">				lti = SPQueue.LEAST_TIME_INTERVAL_DAILY;</span>
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">			} else if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_HOURLY) {</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">				if (lti != SPQueue.LEAST_TIME_INTERVAL_DAILY)</span>
<span class="nc" id="L585">					lti = SPQueue.LEAST_TIME_INTERVAL_HOURLY;</span>
			}
<span class="fc" id="L587">		}</span>
<span class="fc" id="L588">		return lti;</span>
	}

	public TimeRange getTimeRange() {
<span class="fc bfc" id="L592" title="All 2 branches covered.">		if (tr == null) {</span>
<span class="fc bfc" id="L593" title="All 2 branches covered.">			for (Iterator&lt;PredictTraceCube&gt; iterator = m_PTCMap.values().iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L594">				PredictTraceCube pCube = iterator.next();</span>
<span class="pc bpc" id="L595" title="1 of 2 branches missed.">				if (tr == null) {</span>
<span class="fc" id="L596">					tr = new TimeRange(pCube.getRawStartDate(), pCube.getRawEndDate());</span>
				} else {
<span class="nc bnc" id="L598" title="All 2 branches missed.">					if (tr.getStartDate().after(pCube.getRawStartDate())) {</span>
<span class="nc" id="L599">						tr.setStartDate(pCube.getRawStartDate());</span>
					}
<span class="nc bnc" id="L601" title="All 2 branches missed.">					if (tr.getEndDate().before(pCube.getRawEndDate())) {</span>
<span class="nc" id="L602">						tr.setEndDate(pCube.getRawEndDate());</span>
					}
				}
<span class="fc" id="L605">			}</span>
		}
<span class="fc" id="L607">		return tr;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>