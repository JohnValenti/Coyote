<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestFilter.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model</a> &gt; <span class="el_source">RequestFilter.java</span></div><h1>RequestFilter.java</h1><pre class="source lang-java linenums">/*
 * RequestFilter.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.core.filterconfig.model.Clause;
import com.bluepumpkin.ejb.core.filterconfig.model.Condition;
import com.bluepumpkin.ejb.core.filterconfig.model.Filter;
import com.bluepumpkin.ejb.core.filterconfig.model.FilterConfigVO;
import com.bluepumpkin.ejb.core.filterconfig.model.Value;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;

/**
 * A request filter is a construct that can be applied to a set of requests to limit the view presented to a user.
 * 
 * &lt;p&gt;
 * The key for a filter implicitly defines the operator as well. See the 'static' initializer for the operators used for each key
 * defined for this filter.
 * 
 */
public class RequestFilter implements Serializable {

	// The filter keys. The choice of operator and the type of the value is
	// dictated by the key used. The javadoc for each key explains what it means.

	/**
	 * A single employee to filter by. The operator used is EQUALS and the value is the ID of the employee.
	 */
	public final static String EMPLOYEE_KEY = &quot;employee&quot;;
	/**
	 * A set of organizations to filter by. The operator used is IN and the value is a Collection of organization IDs. If this key
	 * is missing from a filter than ALL organizations are used.
	 */
	public final static String ORGANIZATION_KEY = &quot;org&quot;;
	/**
	 * The approving supervisor to filter by. The operator used is EQUALS and the value is the employee ID of the supervisor. If
	 * this key is missing from a filter than ALL supervisors are used.
	 */
	public final static String SUPERVISOR_KEY = &quot;supervisor&quot;;

	/**
	 * The seniority of requesting employees. This is expressed as a date range. The operator used is IN_RANGE and the value is a
	 * List of two java.util.Date objects. The first is the beginning of the range and the second is the end point of the range of
	 * seniorities desired.
	 */
	public final static String SENIORITY_KEY = &quot;seniority&quot;;

	/**
	 * The request type of the desired requests. The choice is one of ALL, TIME_OFF or SHIFT_SWAP or SHIFT_BID. The operator used is
	 * EQUALS and the value is one of the requesttype string constants defined in
	 * {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}. If this key is omitted, then ALL is assumed.
	 */
	public final static String REQUEST_TYPE_KEY = &quot;request-type&quot;;

	/**
	 * The start-end dates. This filter applies to all request types (all or ShiftSwap or TimeOff). The operator used is IN_RANGE
	 * and the value is a List of two java.util.Date objects.
	 * &lt;p&gt;
	 * The first is the beginning of the range and the second is the end point of the range.
	 * &lt;p&gt;
	 * Time off requests with at least one choice with start and end dates that fall within the given range are returned.
	 * &lt;p&gt;
	 * Shift swap requests involving an item with a starttime in the range are returned.
	 */
	public final static String REQUEST_DATE_RANGE_KEY = &quot;request_date_range&quot;;

	/**
	 * The Flex Makeup start-end dates. This filter applies to Flex Time requests. The operator used is IN_RANGE and the value is a
	 * List of two java.util.Date objects.
	 * &lt;p&gt;
	 * The first is the beginning of the range and the second is the end point of the range.
	 * &lt;p&gt;
	 * Flex Time requests with at least one makeup with start and end dates that fall within the given range are returned.
	 */
	public final static String REQUEST_FLEX_MAKEUP_DATE_RANGE_KEY = &quot;request_flex_makeup_date_range&quot;;

	/**
	 * The date range when the request was submitted. This is expressed as a date range. The operator used is IN_RANGE and the value
	 * is a List of two java.util.Date objects. The first is the beginning of the range and the second is the end point of the range
	 * of submission dates desired.
	 */
	public final static String SUBMITTED_KEY = &quot;submitted&quot;;

	/**
	 * The current request status. The choice is one of the status constants defined in
	 * {@link com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail RequestAuditTrail}. The operator used is EQUALS. If
	 * this key is omitted from the filter, then all except INVALID, WITHDRAWN or EXPIRED are returned.
	 */
	public final static String STATUS_KEY = &quot;status&quot;;
	/**
	 * Expired status can be specified on the filter, but it is not explicitly stored in the request object, instead it is inferred
	 * when the expiration date of the request is in the past. Since it is not stored in an audit trail record, it is not defined
	 * with the rest of the audit trail status constants, but defined here on the filter.
	 */
	public final static String EXPIRED_STATUS = &quot;expired&quot;;

	// /**
	// * The start-end dates. This filter restricts TIME_OFF requests only and is used only
	// * when the the the REQUEST_TYPE_KEY specifies TIME_OFF requests. The operator
	// * used is IN_RANGE and the value is a List of two
	// * java.util.Date objects. The first is the beginning of the range and
	// * the second is the end point of the range. Only time off requests that have
	// * at least one choice with start or end dates that fall within the given range
	// * are returned.
	// */
	// public final static String TO_START_END_DATES_KEY = &quot;to-start-end&quot;;

	/**
	 * Used to select time off requests for partial day or full day. This filter restricts TIME_OFF requests only and is used only
	 * when the the the REQUEST_TYPE_KEY specifies TIME_OFF requests. The operator used is EQUALS and the value is either FULL_DAY
	 * or PARTIAL_DAY. The string constants for these values are defined in this class. FULL_DAY will select requests that contain
	 * at least one choice that specifies at least the maximum number of hours the employee is allowed to take for a particular time
	 * off activity (irregardless of day boundaries and holidays or non-working days). PARTIAL_DAY is anything less.
	 */
	public final static String TO_FULL_OR_PARTIAL_DAY_KEY = &quot;to-full-or-partial-day&quot;;
	public final static String TO_FULL_DAY = &quot;full-day&quot;;
	public final static String TO_PARTIAL_DAY = &quot;partial-day&quot;;

	/**
	 * The number of choices considered in a time-off request. This filter restricts TIME_OFF requests only and is used only when
	 * the the the REQUEST_TYPE_KEY specifies TIME_OFF requests. This filter key controls the number of choices considered in other
	 * time-off filter calculations and the number of choices returned for display. The operator used is EQUALS and the value is
	 * either ALL or FIRST_ONLY. The string constants for these values are defined in this class.
	 */
	public final static String TO_NUMBER_OF_CHOICES_KEY = &quot;to-number-of-choices&quot;;
	public final static String ALL_TO_CHOICES = &quot;all-to-choices&quot;;
	public final static String FIRST_ONLY_TO_CHOICE = &quot;first-only-to-choice&quot;;

	/**
	 * filter constraint for filtering time-off requests by activity ID. This filter restricts TIME_OFF requests only and is used
	 * only when the the the REQUEST_TYPE_KEY specifies TIME_OFF requests. The operator used is EQUALS.
	 */
	public final static String TO_ACTIVITY_ID_KEY = &quot;to-activity-id&quot;;

	/**
	 * The Time Off Pool to filter by. The operator used is EQUALS and the value is the TOPool ID of the agent at the atart of the
	 * time off request. If this key is missing from a filter then ALL Time Off Pools are used.
	 */
	public final static String TOPOOL_KEY = &quot;topool&quot;;

	/**
	 * The Time Off Bid to filter by. The filter will find request for Employees Request in the Bid. The operator used is EQUALS and
	 * the value is the TOBID ID of the Time Of Bid selected.
	 */
	public final static String TOBID_KEY = &quot;tobid&quot;;

	/**
	 * The type of shift swap request. This key filters the type of shift-swap request returned. This filter restricts SHIFT_SWAP
	 * requests only and is used only when the the the REQUEST_TYPE_KEY specifies SHIFT_SWAP requests. The operator used is EQUALS
	 * and the value is one of the shift-swap type constants defined in
	 * {@link com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest ShiftSwapRequest}.
	 */
	public final static String SWAP_TYPE_KEY = &quot;swap-type&quot;;

	/**
	 * The skill type involved in the the request. This key filters the type of shift-swap request returned. This filter restricts
	 * SHIFT_SWAP requests only and is used only when the the the REQUEST_TYPE_KEY specifies SHIFT_SWAP requests. The operator used
	 * is IN and the value is a collection of SKILL ids.
	 */
	public final static String SWAP_SKILLS_KEY = &quot;swap-skills&quot;;

	/**
	 * Shift Bid preference. Integer value.
	 */
	public final static String BID_PREF_KEY = &quot;big-pref&quot;;

	/**
	 * Shift bid request can have preferences from 1 to a possibly large number. To simply filtering by preference, this special
	 * constant is introduced which means 'preferences five and above'.
	 */
	public final static int BID_PREF_VALUE_FIVEANDABOVE = -1;

	/**
	 * Shift Bid Deadline. Date value. This deadline refers to the
	 * {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder shiftBidder} deadline. Must be used in
	 * conjuction with {@link #BID_DEADLINE_OPERATOR_KEY BID_DEADLINE_OPERATOR_KEY} key as well.
	 */
	public final static String BID_DEADLINE_KEY = &quot;bid-deadline&quot;;

	/**
	 * Opeartor to be used with the key {@link #BID_DEADLINE_KEY BID_DEADLINE_KEY}. Key value can be either less than, greater than
	 * or equals as defined in {@link Filter Filter}.
	 */
<span class="fc" id="L200">	public static String BID_DEADLINE_OPERATOR_KEY = &quot;bid-deadline-operator&quot;;</span>

	/**
	 * Shift Bid Requested Day. Integer value using Calendar class's {@link java.util.Calendar#SUNDAY dayOfWeek}
	 */
	public final static String BID_REQUESTED_DAY_KEY = &quot;bid-requested-day&quot;;

	/**
	 * filter by the rank of the employee associated with the shift bid request. Must be used in conjunction with
	 * {@link #EMP_RANK_OPERATOR_KEY EMP_RANK_OPERATOR_KEY}
	 */
	public final static String EMP_RANK_KEY = &quot;bid-rank&quot;;

	/**
	 * Opeartor to be used with the key {@link #EMP_RANK_KEY EMP_RANK_KEY}. Key value can be either less than, greater than or
	 * equals as defined in {@link Filter Filter}.
	 */
	public final static String EMP_RANK_OPERATOR_KEY = &quot;bid-rank-operator&quot;;

	/**
	 * filter by the accumulated points assigned to the employee associated with the shift bid request. Must be used in conjunction
	 * with {@link #BID_POINTS_OPERATOR_KEY BID_POINTS_OPERATOR_KEY}
	 */
	public final static String BID_POINTS_KEY = &quot;bid-points&quot;;

	/**
	 * Opeartor to be used with the key {@link #BID_POINTS_KEY BID_POINTS_KEY}. Key value can be either less than, greater than or
	 * equals as defined in {@link Filter Filter}.
	 */
	public final static String BID_POINTS_OPERATOR_KEY = &quot;bid-points-operator&quot;;

	/**
	 * filter by the bonus assigned to the shift bidder assocaited with the request. Must be used in conjunction with
	 * {@link #BID_BONUS_OPERATOR_KEY BID_BONUS_OPERATOR_KEY}
	 */
	public final static String BID_BONUS_KEY = &quot;bid-bonus&quot;;

	/**
	 * Opeartor to be used with the key {@link #BID_BONUS_KEY BID_BONUS_KEY}. Key value can be either less than, greater than or
	 * equals as defined in {@link Filter Filter}.
	 */
	public final static String BID_BONUS_OPERATOR_KEY = &quot;bid-bonus-operator&quot;;

	/**
	 * filter by the score assigned to the shift bidder assocaited with the request. Must be used in conjunction with
	 * {@link #BID_SCORE_OPERATOR_KEY BID_SCORE_OPERATOR_KEY}
	 */
	public final static String BID_SCORE_KEY = &quot;bid-score&quot;;

	/**
	 * Operator to be used with the key {@link #BID_SCORE_KEY BID_SCORE_KEY}. Key value can be either less than, greater than or
	 * equals as defined in {@link Filter Filter}.
	 */
	public final static String BID_SCORE_OPERATOR_KEY = &quot;bid-score-operator&quot;;

	/**
	 * DetailLevel to be used for fetching shiftBidRequests while using this filter.
	 * 
	 * &lt;li&gt;For possible detailLevels see {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest
	 * ShiftBidRequest}.
	 * 
	 * &lt;li&gt;The value of the key must be an instance of {@link Long Long}.
	 * 
	 * &lt;li&gt;If this key is not set, then the detail level defined in
	 * {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest#getDetailLevelForValidation()
	 * getDetailLevelForValidation()} will be used.
	 */
	public final static String BIDREQ_DETAILLEVEL_KEY = &quot;bidreq-detaillevel-key&quot;;

	/**
	 * DetailLevels to be used for fetching cust-shift Requests while using the request filter.
	 */
	public final static String CS_ACTIVITYID_KEY = &quot;CS_ACTIVITYID_KEY&quot;; // activity name
	public final static String CS_CAMPAIGNID_KEY = &quot;CS_CAMPAIGNID_KEY&quot;; // campaign name
	public final static String CS_SHIFTID_KEY = &quot;CS_SHIFTID_KEY&quot;; // Shift Name
	public final static String CS_EXTID_KEY = &quot;CS_EXTID_KEY&quot;; // Extn Name applicable to both before and after extn
	public final static String CS_SUBTYPE_KEY = &quot;CS_SUBTYPE_KEY&quot;; // Request sub type new shift /shift change
	public final static String CS_ISOT_KEY = &quot;CS_ISOT_KEY&quot;; // OT /Regular shift

	/**
	 * The shift date involved in the the request. This key filters on the date of the subject shift. This filter restricts
	 * SHIFT_SWAP requests only and is used only when the the the REQUEST_TYPE_KEY specifies SHIFT_SWAP requests. The operator used
	 * is IN_RANGE and the value is a List of two java.util.Date objects. The first is the beginning of the range and the second is
	 * the end point of the range. Only shift swap requests involving an item with a starttime in the range are returned.
	 */
	// public final static String SWAP_SHIFT_DATE_KEY = &quot;swap-shift-date&quot;;

	// This table maps each key to a TypeMapEntry to encode the allowable types
	// for the key. This information is used later to validate values set with
	// the keys
<span class="fc" id="L290">	private static Map _validationMap = new HashMap();</span>
	static {
<span class="fc" id="L292">		_validationMap.put(CS_ACTIVITYID_KEY, new TypeMapEntry(ID.class));</span>
<span class="fc" id="L293">		_validationMap.put(CS_CAMPAIGNID_KEY, new TypeMapEntry(ID.class));</span>
<span class="fc" id="L294">		_validationMap.put(CS_SHIFTID_KEY, new TypeMapEntry(ID.class));</span>
<span class="fc" id="L295">		_validationMap.put(CS_EXTID_KEY, new TypeMapEntry(ID.class));</span>

<span class="fc" id="L297">		_validationMap.put(CS_SUBTYPE_KEY, new TypeMapEntry(String.class, new Object[] { CustShiftReq.CS_SUBTYPE_NEW_SHIFT,</span>
				CustShiftReq.CS_SUBTYPE_SHIFT_CHANGE }));

<span class="fc" id="L300">		_validationMap.put(CS_ISOT_KEY, new TypeMapEntry(String.class, new Object[] { CustShiftReq.CS_OVERTIME_YES,</span>
				CustShiftReq.CS_OVERTIME_NO }));

<span class="fc" id="L303">		_validationMap.put(EMPLOYEE_KEY, new TypeMapEntry(ID.class));</span>
<span class="fc" id="L304">		_validationMap.put(ORGANIZATION_KEY, new TypeMapEntry(Filter.IN_OPERATION, Collection.class, 1, ID.class));</span>
<span class="fc" id="L305">		_validationMap.put(TOPOOL_KEY, new TypeMapEntry(ID.class));</span>
<span class="fc" id="L306">		_validationMap.put(TOBID_KEY, new TypeMapEntry(ID.class));</span>

<span class="fc" id="L308">		_validationMap.put(SUPERVISOR_KEY, new TypeMapEntry(Filter.IN_OPERATION, Collection.class, 1, ID.class));</span>

<span class="fc" id="L310">		_validationMap.put(SENIORITY_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION, List.class, 2, 2, Date.class, true));</span>

<span class="fc" id="L312">		_validationMap.put(REQUEST_TYPE_KEY, new TypeMapEntry(String.class, new Object[] { Request.REQUESTTYPE_TIMEOFF,</span>
				Request.REQUESTTYPE_FLEXTIME, Request.REQUESTTYPE_SHIFTSWAP, Request.REQUESTTYPE_SHIFTBID,
				Request.REQUESTTYPE_CUSTSHIFT, Request.REQUESTTYPE_ALL }));

<span class="fc" id="L316">		_validationMap.put(REQUEST_DATE_RANGE_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION, List.class, 2, 2, Date.class, true));</span>

<span class="fc" id="L318">		_validationMap.put(REQUEST_FLEX_MAKEUP_DATE_RANGE_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION, List.class, 2, 2,</span>
				Date.class, true));

<span class="fc" id="L321">		_validationMap.put(SUBMITTED_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION, List.class, 2, 2, Date.class, true));</span>

<span class="fc" id="L323">		_validationMap.put(STATUS_KEY, new TypeMapEntry(String.class, new Object[] {</span>
				RequestAuditTrail.STATUS_PENDING,
				RequestAuditTrail.STATUS_APPROVED,
				RequestAuditTrail.STATUS_DENIED,
				RequestAuditTrail.STATUS_ESCALATED,
				// a manager's inbox must not include reqs in 'negotiation' status
				// RequestAuditTrail.STATUS_NEGOTIATION,
				EXPIRED_STATUS, RequestAuditTrail.STATUS_TENTATIVE, RequestAuditTrail.STATUS_WITHDRAWN,
				RequestAuditTrail.STATUS_INVALID, RequestAuditTrail.STATUS_WAITLIST, RequestAuditTrail.STATUS_WITHDRAW_REQUEST,
				RequestAuditTrail.STATUS_WITHDRAW_REJECT, RequestAuditTrail.STATUS_WITHDRAW_ACCEPT,
				RequestAuditTrail.STATUS_ALL_PENDING_STATES }));

		// _validationMap.put( TO_START_END_DATES_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION,List.class,2,2,Date.class,true) );

<span class="fc" id="L337">		_validationMap</span>
<span class="fc" id="L338">				.put(TO_FULL_OR_PARTIAL_DAY_KEY, new TypeMapEntry(String.class, new Object[] { TO_FULL_DAY, TO_PARTIAL_DAY }));</span>

<span class="fc" id="L340">		_validationMap.put(TO_NUMBER_OF_CHOICES_KEY, new TypeMapEntry(String.class, new Object[] { ALL_TO_CHOICES,</span>
				FIRST_ONLY_TO_CHOICE }));

<span class="fc" id="L343">		_validationMap.put(TO_ACTIVITY_ID_KEY, new TypeMapEntry(ID.class));</span>

<span class="fc" id="L345">		_validationMap.put(SWAP_TYPE_KEY, new TypeMapEntry(String.class, new Object[] { ShiftSwapRequest.SHIFTSWAP_TYPE_ONEWAY,</span>
				ShiftSwapRequest.SHIFTSWAP_TYPE_TWOWAY }));

<span class="fc" id="L348">		_validationMap.put(SWAP_SKILLS_KEY, new TypeMapEntry(Filter.IN_OPERATION, Collection.class, 1, ID.class));</span>

		// _validationMap.put( SWAP_SHIFT_DATE_KEY, new TypeMapEntry(Filter.IN_RANGE_OPERATION,List.class,2,2,Date.class,true) );

<span class="fc" id="L352">		_validationMap.put(BID_PREF_KEY, new TypeMapEntry(Integer.class, new Integer[] { new Integer(1), new Integer(2),</span>
				new Integer(3), new Integer(4), new Integer(BID_PREF_VALUE_FIVEANDABOVE) }));

		// The operator defined by BID_DEADLINE_OPERATOR_KEY is used in conjunctino with this key.
<span class="fc" id="L356">		_validationMap.put(BID_DEADLINE_KEY, new TypeMapEntry(Date.class));</span>

		// used in conjuction with BID_DEADLINE_KEY
<span class="fc" id="L359">		_validationMap.put(BID_DEADLINE_OPERATOR_KEY, new TypeMapEntry(String.class, new Object[] { Filter.EQUAL_OPERATION,</span>
				Filter.LESS_THAN_OPERATION, Filter.GREATER_THAN_OPERATION }));

<span class="fc" id="L362">		_validationMap.put(BID_REQUESTED_DAY_KEY, new TypeMapEntry(Integer.class, new Integer[] { new Integer(1), new Integer(2),</span>
				new Integer(3), new Integer(4), new Integer(5), new Integer(6), new Integer(7) }));

<span class="fc" id="L365">		_validationMap.put(BIDREQ_DETAILLEVEL_KEY, new TypeMapEntry(Long.class));</span>

		// The operator defined by EMP_RANK_OPERATOR_KEY is used in conjunctino with this key.
<span class="fc" id="L368">		_validationMap.put(EMP_RANK_KEY, new TypeMapEntry(Integer.class));</span>

		// used in conjuction with EMP_RANK_KEY
<span class="fc" id="L371">		_validationMap.put(EMP_RANK_OPERATOR_KEY, new TypeMapEntry(String.class, new Object[] { Filter.EQUAL_OPERATION,</span>
				Filter.LESS_THAN_OPERATION, Filter.GREATER_THAN_OPERATION }));

		// The operator defined by BID_POINTS_OPERATOR_KEY is used in conjunctino with this key.
<span class="fc" id="L375">		_validationMap.put(BID_POINTS_KEY, new TypeMapEntry(Integer.class));</span>

		// used in conjuction with BID_POINTS_KEY
<span class="fc" id="L378">		_validationMap.put(BID_POINTS_OPERATOR_KEY, new TypeMapEntry(String.class, new Object[] { Filter.EQUAL_OPERATION,</span>
				Filter.LESS_THAN_OPERATION, Filter.GREATER_THAN_OPERATION }));

		// The operator defined by BID_BONUS_OPERATOR_KEY is used in conjunctino with this key.
<span class="fc" id="L382">		_validationMap.put(BID_BONUS_KEY, new TypeMapEntry(Integer.class));</span>

		// used in conjuction with BID_BONUS_KEY
<span class="fc" id="L385">		_validationMap.put(BID_BONUS_OPERATOR_KEY, new TypeMapEntry(String.class, new Object[] { Filter.EQUAL_OPERATION,</span>
				Filter.LESS_THAN_OPERATION, Filter.GREATER_THAN_OPERATION }));

		// The operator defined by BID_SCORE_OPERATOR_KEY is used in conjunctino with this key.
<span class="fc" id="L389">		_validationMap.put(BID_SCORE_KEY, new TypeMapEntry(Integer.class));</span>

		// used in conjuction with BID_SCORE_KEY
<span class="fc" id="L392">		_validationMap.put(BID_SCORE_OPERATOR_KEY, new TypeMapEntry(String.class, new Object[] { Filter.EQUAL_OPERATION,</span>
				Filter.LESS_THAN_OPERATION, Filter.GREATER_THAN_OPERATION }));
	}

	/**
	 * This inner class is used in a static table to record the allowable values for each key in the filter as well as the operator
	 * to use for each key.
	 */
	private static class TypeMapEntry {
<span class="fc" id="L401">		Class _valueType = null; // type of value</span>
<span class="fc" id="L402">		int _minElements = 0, _maxElements = Integer.MAX_VALUE; // size of collection, if applicable</span>
<span class="fc" id="L403">		Class _elementType = null; // type of element in collection, if applicable</span>
<span class="fc" id="L404">		List _allowableChoices = null; // choices for enumerations (optional)</span>
<span class="fc" id="L405">		boolean _isSequence = false; // collection elements must be non decreasing</span>
<span class="fc" id="L406">		String _op = null;</span>

		TypeMapEntry(Class scalarType) {
<span class="fc" id="L409">			this(Filter.EQUAL_OPERATION, scalarType, 1, 1, null, null, false);</span>
<span class="fc" id="L410">		}</span>

		TypeMapEntry(Class scalarType, Object[] scalarValueSet) {
<span class="fc" id="L413">			this(Filter.EQUAL_OPERATION, scalarType, 1, 1, null, scalarValueSet, false);</span>
<span class="fc" id="L414">		}</span>

		TypeMapEntry(String op, Class vectorType, int minElements, Class elementType) {
<span class="fc" id="L417">			this(op, vectorType, minElements, Integer.MAX_VALUE, elementType, null, false);</span>
<span class="fc" id="L418">		}</span>

		TypeMapEntry(String op, Class vectorType, int minElements, Class elementType, Object[] elementValueSet) {
<span class="nc" id="L421">			this(op, vectorType, minElements, Integer.MAX_VALUE, elementType, elementValueSet, false);</span>
<span class="nc" id="L422">		}</span>

		TypeMapEntry(String op, Class vectorType, int minElements, Class elementType, boolean seq) {
<span class="nc" id="L425">			this(op, vectorType, minElements, Integer.MAX_VALUE, elementType, null, seq);</span>
<span class="nc" id="L426">		}</span>

		TypeMapEntry(String op, Class vectorType, int minElements, int maxElements, Class elementType) {
<span class="nc" id="L429">			this(op, vectorType, minElements, maxElements, elementType, null, false);</span>
<span class="nc" id="L430">		}</span>

		TypeMapEntry(String op, Class vectorType, int minElements, int maxElements, Class elementType, boolean seq) {
<span class="fc" id="L433">			this(op, vectorType, minElements, maxElements, elementType, null, seq);</span>
<span class="fc" id="L434">		}</span>

		/**
		 * A TypeMap represents the validation to be used for filter expressions.
		 * 
		 * A filter expression represents: &amp;lt;LHS&amp;gt; &amp;lt;opeartor&amp;gt; &amp;lt;RHS&amp;gt;&lt;br&gt;
		 * 
		 * The &lt;b&gt;operator&lt;/b&gt; is defined in {@link Filter Filter} class.&lt;br&gt;
		 * 
		 * The &lt;b&gt;LHS&lt;/b&gt; is one of the possible filter keys defined above. For example see {@link RequestFilter#BID_PREF_KEY
		 * BID_PREF_KEY}.
		 * 
		 * Typemap is used to validate the RHS of the filter expression. &lt;li&gt;For a scalar RHS, verifies the data type of the scalar
		 * and if the scalar belongs to a set of possible values. The dataType and set of possible values are expressed by the
		 * parameters &lt;b&gt;scalarOrVectorType&lt;/b&gt; and &lt;b&gt;scalarValueSet&lt;/b&gt; respectively. &lt;li&gt;For a vector RHS, verifies the data type
		 * of the vector, data type of each element in the vector and the range for # of elements in the vector (minimum and maximum
		 * # of elements). These are expressed by the parameters &lt;b&gt;scalarOrVectorType&lt;/b&gt;, &lt;b&gt;vectorElementType&lt;/b&gt;, &lt;b&gt;minElements
		 * &lt;/b&gt;and &lt;b&gt;maxElements &lt;/b&gt; respectively.
		 * 
		 * @param op
		 * @param scalarOrVectorType
		 * @param minElements
		 * @param maxElements
		 * @param vectorElementType
		 * @param scalarValueSet
		 * @param seq
		 */
		TypeMapEntry(String op, Class scalarOrVectorType, int minElements, int maxElements, Class vectorElementType,
<span class="fc" id="L462">				Object[] scalarValueSet, boolean seq) {</span>
			// valueType cannot be null
<span class="pc bpc" id="L464" title="1 of 2 branches missed.">			if (scalarOrVectorType == null) {</span>
<span class="nc" id="L465">				throw new IllegalArgumentException();</span>
			}

			// operator cannot be null
<span class="pc bpc" id="L469" title="1 of 2 branches missed.">			if (op == null) {</span>
<span class="nc" id="L470">				throw new IllegalArgumentException();</span>
			}
			
			// the operator must be one that is allowable on a Condition
<span class="pc bpc" id="L474" title="1 of 2 branches missed.">			if (!Condition.ALLOWABLE_OPERATIONS.contains(op)) {</span>
<span class="nc" id="L475">				throw new IllegalArgumentException();</span>
			}
<span class="fc" id="L477">			_op = op;</span>

			// min must be &gt;= 0 and &lt;= max
<span class="pc bpc" id="L480" title="2 of 4 branches missed.">			if (minElements &lt; 0 || minElements &gt; maxElements)</span>
<span class="nc" id="L481">				throw new IllegalArgumentException();</span>

			// Element type cannot be null if valueType is a collection
<span class="pc bpc" id="L484" title="1 of 4 branches missed.">			if (Collection.class.isAssignableFrom(scalarOrVectorType) &amp;&amp; vectorElementType == null) {</span>
<span class="nc" id="L485">				throw new IllegalArgumentException();</span>
			}

<span class="fc" id="L488">			_valueType = scalarOrVectorType;</span>
<span class="fc" id="L489">			_minElements = minElements;</span>
<span class="fc" id="L490">			_maxElements = maxElements;</span>
<span class="fc" id="L491">			_elementType = vectorElementType;</span>
<span class="fc bfc" id="L492" title="All 2 branches covered.">			if (scalarValueSet != null) {</span>
<span class="fc" id="L493">				_allowableChoices = Arrays.asList(scalarValueSet);</span>
			}
<span class="fc" id="L495">			_isSequence = seq;</span>
<span class="fc" id="L496">		}</span>

		/**
		 * Test whether or not the given argument matches the type specified in this map entry.
		 */
		boolean testObject(Serializable obj) {
<span class="fc" id="L502">			boolean result = true;</span>

			// check if the passed value is the right type.
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">			if (!_valueType.isInstance(obj)) {</span>
<span class="nc" id="L506">				return false;</span>
			}

			// If a collection, then check each element
<span class="fc bfc" id="L510" title="All 2 branches covered.">			if (obj instanceof Collection) {</span>
<span class="fc" id="L511">				Collection coll = (Collection) obj;</span>
				// check the size of the collection
<span class="pc bpc" id="L513" title="2 of 4 branches missed.">				if (coll.size() &lt; _minElements || coll.size() &gt; _maxElements) {</span>
<span class="nc" id="L514">					return false;</span>
				}
<span class="fc" id="L516">				Comparable prior = null;</span>
				// check that each element is an allowable type
<span class="fc bfc" id="L518" title="All 2 branches covered.">				for (Iterator it = coll.iterator(); it.hasNext();) {</span>
<span class="fc" id="L519">					Object o = it.next();</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">					if (!_elementType.isInstance(o)) {</span>
<span class="nc" id="L521">						return false;</span>
					}
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">					if (_isSequence) {</span>
						// check order constraint
<span class="pc bpc" id="L525" title="1 of 4 branches missed.">						if (prior != null &amp;&amp; prior.compareTo(o) &gt; 0) {</span>
<span class="nc" id="L526">							return false;</span>
						}
<span class="fc" id="L528">						prior = (Comparable) o;</span>
					}
<span class="fc" id="L530">				}</span>
				// if we were given a fixed set of choices, check that
				// all of the values are allowed
<span class="pc bpc" id="L533" title="3 of 4 branches missed.">				if (_allowableChoices != null &amp;&amp; !_allowableChoices.containsAll(coll)) {</span>
<span class="nc" id="L534">					return false;</span>
				}
<span class="fc" id="L536">			} else { // object is not a collection but a scalar.</span>
				// if we were given a fixed set of choices, check that value
				// is one of them.
<span class="pc bpc" id="L539" title="2 of 4 branches missed.">				if (_allowableChoices != null &amp;&amp; !_allowableChoices.contains(obj)) {</span>
<span class="nc" id="L540">					return false;</span>
				}
			}

<span class="fc" id="L544">			return result;</span>
		}

		/**
		 * Return the operation associated with this type map entry
		 */
		public String getOperation() {
<span class="nc" id="L551">			return _op;</span>
		}
	}

	/**
	 * Scaler operations, i.e. operations that only have a single operand.
	 */
<span class="fc" id="L558">	private static String[] _scalerOps = { Filter.EQUAL_OPERATION, Filter.GREATER_THAN_OPERATION,</span>
			Filter.GREATER_THAN_OR_EQUAL_OPERATION, Filter.LESS_THAN_OPERATION, Filter.LESS_THAN_OR_EQUAL_OPERATION,
			Filter.NOT_EQUAL_OPERATION, Filter.CONTAINS_OPERATION, Filter.NOT_CONTAINS_OPERATION, };
<span class="fc" id="L561">	public static final Collection SCALER_OPS = Arrays.asList(_scalerOps);</span>

<span class="fc" id="L563">	public static final String REQUEST_FILTER_COMPONENT_CLASS = RequestFilter.class.getName();</span>

	/**
	 * The userid of the owner of this filter.
	 */
<span class="fc" id="L568">	private ID m_userid = null;</span>

	/**
	 * The name of this filter
	 */
<span class="fc" id="L573">	private String m_name = null;</span>

	/**
	 * The map of key to value used to specify the filter
	 */
<span class="fc" id="L578">	private Map m_map = null;</span>

	/**
	 * The ID of this filter as it is stored in the database. This field is not set unless the RequestFilter is build from a
	 * FilterConfigVO or explicitly set by the user.
	 */
<span class="fc" id="L584">	private ID m_id = null;</span>

	private static final long serialVersionUID = -3459036454570567467L;

	/**
	 * Creates a new request filter for the given owning userid with the given name. Initially, no keys are set in the filter.
	 */
<span class="fc" id="L591">	public RequestFilter(ID ownerUserID, String name) {</span>
<span class="fc" id="L592">		m_name = name;</span>
<span class="fc" id="L593">		m_userid = ownerUserID;</span>
<span class="fc" id="L594">		m_map = new HashMap();</span>
<span class="fc" id="L595">	}</span>

	public RequestFilter(FilterConfigVO vo) {
<span class="nc" id="L598">		this(vo.getUserid(), vo.getName());</span>
<span class="nc" id="L599">		m_id = vo.getID();</span>

		// The filter should be either a single condition or
		// a single AND clause with a list of conditions.
<span class="nc" id="L603">		Filter fltr = vo.getFilter();</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">		if (fltr != null) {</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">			if (fltr instanceof Condition) {</span>
<span class="nc" id="L606">				processCondition((Condition) fltr);</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">			} else if (fltr instanceof Clause) {</span>
				// Check that the clause is an AND clause that only has conditions
<span class="nc" id="L609">				Clause c = (Clause) fltr;</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				if (!c.getOperation().equals(Filter.AND_OPERATION)) {</span>
<span class="nc" id="L611">					throw new IllegalArgumentException();</span>
				}
<span class="nc bnc" id="L613" title="All 2 branches missed.">				for (Iterator it = c.getFilters().iterator(); it.hasNext();) {</span>
<span class="nc" id="L614">					Condition cd = (Condition) it.next();</span>
<span class="nc" id="L615">					processCondition(cd);</span>
<span class="nc" id="L616">				}</span>
<span class="nc" id="L617">			} else {</span>
				// don't know what this is...
<span class="nc" id="L619">				throw new IllegalArgumentException(fltr.toString());</span>
			}
		}

<span class="nc" id="L623">	}</span>

	/**
	 * Add the filter information from a single condition element to this filter
	 */
	private void processCondition(Condition cond) {
<span class="nc" id="L629">		String key = cond.getProperty();</span>
<span class="nc" id="L630">		String op = cond.getOperation();</span>
		// collect all the values as a list
<span class="nc" id="L632">		List values = new ArrayList(cond.getValues());</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">		if (values.size() &lt; 1) {</span>
<span class="nc" id="L634">			throw new IllegalArgumentException();</span>
		}

		// Check that key is valid
<span class="nc bnc" id="L638" title="All 2 branches missed.">		if (key == null) {</span>
<span class="nc" id="L639">			throw new IllegalArgumentException();</span>
		}

		// Get the type map entry
<span class="nc" id="L643">		TypeMapEntry tme = (TypeMapEntry) _validationMap.get(key);</span>
		// check that key is known
<span class="nc bnc" id="L645" title="All 2 branches missed.">		if (tme == null) {</span>
<span class="nc" id="L646">			throw new IllegalArgumentException(key);</span>
		}

		// Check the the operation matches the key
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (!tme.getOperation().equals(op)) {</span>
<span class="nc" id="L651">			throw new IllegalArgumentException(op);</span>
		}

		// If the operation is a scaler op, then we use a single operand.
<span class="nc bnc" id="L655" title="All 2 branches missed.">		if (SCALER_OPS.contains(op)) {</span>
			// Use just the first operand...make sure there is only one
<span class="nc bnc" id="L657" title="All 2 branches missed.">			if (values.size() != 1)</span>
<span class="nc" id="L658">				throw new IllegalArgumentException(values.toString());</span>
<span class="nc" id="L659">			Value val = (Value) values.get(0);</span>
<span class="nc" id="L660">			setKey(key, tme, val.getValue());</span>
<span class="nc" id="L661">		} else {</span>
			// we use the whole list of operands, unpack them from the Value object
<span class="nc" id="L663">			List operands = new ArrayList();</span>
<span class="nc bnc" id="L664" title="All 2 branches missed.">			for (Iterator it = values.iterator(); it.hasNext();) {</span>
<span class="nc" id="L665">				operands.add(((Value) it.next()).getValue());</span>
			}
<span class="nc" id="L667">			setKey(key, tme, (Serializable) operands);</span>
		}

<span class="nc" id="L670">	}</span>

	/**
	 * This method constructs a filter subexpression. The expression is of the form &amp;lt;FilterKey&amp;gt; &amp;lt;operator&amp;gt; &amp;lt;RHS&amp;gt;
	 * 
	 * &lt;p&gt;
	 * Note: The operator is implicitly defined by the filter key.
	 * 
	 * &lt;p&gt;
	 * The RHS is represented by the parameter &lt;b&gt;value&lt;/b&gt;. RHS can either be a scalar or vector. When the RHS is set it is
	 * validated for the proper dataType and value.
	 * 
	 * @param key One of the possible key values defined in this class.
	 * @param value Either a scalar or vector value.
	 */
	public void setKey(String key, Serializable value) {
		// Check that key is valid
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">		if (key == null)</span>
<span class="nc" id="L688">			throw new IllegalArgumentException();</span>

		// Get the type map entry
<span class="fc" id="L691">		TypeMapEntry tme = (TypeMapEntry) _validationMap.get(key);</span>
		// check that key is recognized
<span class="pc bpc" id="L693" title="1 of 2 branches missed.">		if (tme == null)</span>
<span class="nc" id="L694">			throw new IllegalArgumentException(key);</span>

		// Call internal version
<span class="fc" id="L697">		setKey(key, tme, value);</span>
<span class="fc" id="L698">	}</span>

	/**
	 * Internal version that already has TypeMapEntry
	 */
	private void setKey(String key, TypeMapEntry tme, Serializable value) {
		// Check the value
<span class="pc bpc" id="L705" title="1 of 2 branches missed.">		if (!tme.testObject(value))</span>
<span class="nc" id="L706">			throw new IllegalArgumentException(value.toString());</span>

		// Must be OK
<span class="fc" id="L709">		m_map.put(key, value);</span>
<span class="fc" id="L710">	}</span>

	/**
	 * Return the value stored in the map for a key.
	 */
	public Serializable getValueForKey(String key) {
<span class="fc" id="L716">		return (Serializable) m_map.get(key);</span>
	}

	/**
	 * Remove a key from the map.
	 */
	public void removeKey(String key) {
<span class="nc" id="L723">		m_map.remove(key);</span>
<span class="nc" id="L724">	}</span>

	/**
	 * Test whether or not a key is set in the map.
	 */
	public boolean isKeySet(String key) {
<span class="fc" id="L730">		return m_map.containsKey(key);</span>
	}

	/**
	 * Get the name of this filter.
	 */
	public String getName() {
<span class="fc" id="L737">		return m_name;</span>
	}

	/**
	 * Set the name of this filter.
	 */
	public void setName(String name) {
<span class="fc" id="L744">		this.m_name = name;</span>
<span class="fc" id="L745">	}</span>

	/**
	 * Get the userid of the owner of this filter.
	 * 
	 */
	public ID getUserid() {
<span class="nc" id="L752">		return m_userid;</span>
	}

	/**
	 * Set the userid of the owner of this filter.
	 */
	public void setUserid(ID userid) {
<span class="nc" id="L759">		this.m_userid = userid;</span>
<span class="nc" id="L760">	}</span>

	/**
	 * Create a FilterConfig object which represents the contents of this filter. The FilterConfig object is suitable for storing in
	 * the database through the FilterConfigEJB interface.
	 */
	public FilterConfigVO asFilterConfigVO() {
<span class="nc" id="L767">		FilterConfigVO result = new FilterConfigVO(m_userid, REQUEST_FILTER_COMPONENT_CLASS);</span>
<span class="nc" id="L768">		result.setName(m_name);</span>
<span class="nc" id="L769">		result.setID(m_id);</span>

		// Build up list of conditions
<span class="nc" id="L772">		List conds = new ArrayList();</span>

		// Process all conditions in filter
<span class="nc bnc" id="L775" title="All 2 branches missed.">		for (Iterator it = m_map.entrySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L776">			Map.Entry entry = (Map.Entry) it.next();</span>
<span class="nc" id="L777">			String key = (String) entry.getKey();</span>
<span class="nc" id="L778">			Condition c = new Condition(key, ((TypeMapEntry) _validationMap.get(key)).getOperation());</span>

			// Assume that if the value is a collection, then we build a list of Value
			// objects, otherwise, we make a single one
<span class="nc" id="L782">			Serializable o = (Serializable) entry.getValue();</span>
<span class="nc bnc" id="L783" title="All 2 branches missed.">			if (o instanceof Collection) {</span>
				// Loop through the Collection and build up a collection of Value objects
<span class="nc bnc" id="L785" title="All 2 branches missed.">				for (Iterator iit = ((Collection) o).iterator(); iit.hasNext();) {</span>
<span class="nc" id="L786">					c.addValue(new Value((Serializable) iit.next()));</span>
				}
			} else {
				// Add the object as the one and only value for the condition
<span class="nc" id="L790">				c.addValue(new Value(o));</span>
			}
			// Save this condition in the list we're building
<span class="nc" id="L793">			conds.add(c);</span>
<span class="nc" id="L794">		}</span>

		// Were any conditions built
<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (conds.size() == 0) {</span>
			// No conditions, then we leave the filter as null.
<span class="nc bnc" id="L799" title="All 2 branches missed.">		} else if (conds.size() == 1) {</span>
			// If there's just one condition, use it
<span class="nc" id="L801">			result.setFilter((Filter) conds.get(0));</span>
		} else {
			// More than one, build an AND clause to join them togeter
<span class="nc" id="L804">			Clause fltr = new Clause(Filter.AND_OPERATION);</span>
<span class="nc" id="L805">			fltr.setFilters(conds);</span>
<span class="nc" id="L806">			result.setFilter(fltr);</span>
		}

<span class="nc" id="L809">		return result;</span>
	}

	/**
	 * Get the ID for this filter.
	 */
	public ID getId() {
<span class="nc" id="L816">		return m_id;</span>
	}

	/**
	 * Set the ID for this filter.
	 * 
	 * @param id id for filter.
	 * 
	 */
	public void setId(ID id) {
<span class="nc" id="L826">		this.m_id = id;</span>
<span class="nc" id="L827">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>