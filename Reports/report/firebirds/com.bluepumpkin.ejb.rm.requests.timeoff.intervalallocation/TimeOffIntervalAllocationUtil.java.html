<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeOffIntervalAllocationUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation</a> &gt; <span class="el_source">TimeOffIntervalAllocationUtil.java</span></div><h1>TimeOffIntervalAllocationUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.EmployeeDate;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.IdDateRange;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.PublishingPeriodStatus;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.PublishingPeriodStatus.Status;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffIntervalAllocationManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffRequestChoiceSegment;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.model.TimeOffIntervalPaidSegment;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.verint.ejb.wfm.WfmManagerFactory;


public class  TimeOffIntervalAllocationUtil {
<span class="fc" id="L47">	private static final Category LOG = Log.initCategory(TimeOffIntervalAllocationUtil.class.getName());</span>

<span class="fc" id="L49">	protected static RmManagerFactory rmMgrFactory = null;</span>
	
<span class="nc" id="L51">	private TimeOffIntervalAllocationUtil(){</span>
		
<span class="nc" id="L53">	}</span>
	
	public static TimeOffIntervalPaidSegment getTimeOffIntervalPaidSegment(ID id) throws BbmFinderException {
		
		try {
<span class="nc" id="L58">			return  TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L59">					.getTimeOffIntervalPaidSegment(id);</span>
							
<span class="nc" id="L61">		} catch (Exception e) {</span>
<span class="nc" id="L62">			throw new BbmFinderException(e);</span>
		}
	}
	
	
	
	

	public static void updateTimeOffIntervalPaidSegment(
			TimeOffIntervalPaidSegment segment) throws BbmUpdateException {
		try {
<span class="nc" id="L73">			TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L74">					.updateTimeOffIntervalPaidSegment(segment);</span>
<span class="nc" id="L75">		} catch (Exception e) {</span>
<span class="nc" id="L76">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L77">		}</span>

<span class="nc" id="L79">	}</span>
	
	public static List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsForTimeOffChoice(TOChoice toChoice) throws BbmFinderException {
		
		
		try {
<span class="nc" id="L85">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L86">					.findTimeOffIntervalPaidSegmentsForTimeOffChoice(toChoice);</span>

<span class="nc" id="L88">		} catch (Exception e) {</span>
<span class="nc" id="L89">			throw new BbmFinderException(e);</span>
		}

	}
	
	public static List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsIntersectTimeRange(
			TimeRange timeRange) throws BbmFinderException {

		
		try {
<span class="nc" id="L99">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L100">					.findTimeOffIntervalPaidSegmentsIntersectTimeRange(timeRange);</span>

<span class="nc" id="L102">		} catch (Exception e) {</span>
<span class="nc" id="L103">			throw new BbmFinderException(e);</span>
		}

	
	}
	
	public static void deleteTimeOffIntervalPaidSegmentsForTimeOffChoice(
			TOChoice toChoice) throws BbmRemoveException {

		try {
<span class="nc" id="L113">			TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L114">					.deleteTimeOffIntervalPaidSegmentsForTimeOffChoice(toChoice);</span>

<span class="nc" id="L116">		} catch (Exception e) {</span>
<span class="nc" id="L117">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L118">		}</span>
		
<span class="nc" id="L120">	}</span>
	
	
	public static List&lt;ID&gt; updateTimeOffIntervalPaidSegmentsForTimeoffChoices(
			 List&lt;ID&gt; timeOffChoiceIDs) throws BbmUpdateException {
		
		
		try {
			
<span class="fc" id="L129">			Collection&lt;TORequest&gt; listOfRequests = TimeOffIntervalAllocationUtil.getMgr().getTORequestsFromChoiceIDs(timeOffChoiceIDs);</span>
<span class="pc bpc" id="L130" title="2 of 4 branches missed.">			if(listOfRequests==null || listOfRequests.isEmpty()){</span>
<span class="nc" id="L131">				return Collections.emptyList();</span>
			}
			
<span class="fc" id="L134">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="fc" id="L135">					.updateTimeOffIntervalsForTimeOffChoices(listOfRequests, timeOffChoiceIDs);</span>

<span class="nc" id="L137">		} catch (Exception e) {</span>
<span class="nc" id="L138">			throw new BbmUpdateException(e);</span>
		}
		
	}

	
	
		
		
		@SuppressWarnings(&quot;rawtypes&quot;)
	static Organization getEmpOrgForDate(Map empOrgAssignments, ID empID, Date date) throws Exception{ // NOSONAR
				
<span class="fc" id="L150">		return TOCalendarUtil.getOrgforDate(date,</span>
<span class="fc" id="L151">				(Collection) empOrgAssignments.get(empID));</span>
				
		}
			
		
	



	public static boolean isDayPublished(
			List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsByEmp, Date current) {

<span class="nc bnc" id="L163" title="All 2 branches missed.">		for (Collection&lt;PublishingPeriod&gt; pubPeriods : pubPeriodsByEmp) {</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">			if (pubPeriods == null || pubPeriods.isEmpty()) {</span>
<span class="nc" id="L165">				continue;</span>
			}
<span class="nc bnc" id="L167" title="All 2 branches missed.">			for (PublishingPeriod period : pubPeriods) {</span>
				//A partially published period is one with no published shifts, but only approved Timeoff Requests.
				//As far as we are concerned, it is unpublished
<span class="nc bnc" id="L170" title="All 4 branches missed.">				if (period == null || period.isPartialPublish()) {</span>
<span class="nc" id="L171">					continue;</span>
				}
<span class="nc" id="L173">				TimeRange pubRange = new TimeRange(period.getStartTime(),</span>
<span class="nc" id="L174">						period.getEndTime());</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">				if (pubRange.includes(current)) {</span>
<span class="nc" id="L177">					return true;</span>
				}
<span class="nc" id="L179">			}</span>
<span class="nc" id="L180">		}</span>

<span class="nc" id="L182">		return false;</span>
	}




		
	@SuppressWarnings(&quot;rawtypes&quot;)
	public static Map getEmpOrgAssignments(Collection&lt;ID&gt; empIDs, Date startDate, Date endDate) throws Exception {

<span class="fc" id="L192">		Map empOrgAssignments = new HashMap(1);</span>

<span class="fc" id="L194">		empOrgAssignments = BbmManagerFactory.getWorkResourceManager().getValidWorkResourceAssignments(</span>
				empIDs,
<span class="fc" id="L196">				new LocalDate(startDate, TimeZone.getTimeZone(&quot;GMT&quot;)), </span>
<span class="fc" id="L197">				new LocalDate(endDate, TimeZone.getTimeZone(&quot;GMT&quot;)), </span>
				false);


<span class="fc" id="L201">		return empOrgAssignments;</span>

	}


	public static TimeOffIntervalPaidSegment createTimeOffIntervalPaidSegmentFromSimpleEvent(
			TOChoice toChoice, SimpleEvent simpleEvent) {
<span class="fc" id="L208">		return new TimeOffIntervalPaidSegment(toChoice.getID(), simpleEvent.getStartTime(), simpleEvent.getEndTime());</span>
		
	}
	

	
	
	/*
	 *  checkAllocation
	 *  Return list of choices that fail allocation check. 
	 */
	public static Map&lt;Integer, TimeOffRequestChoiceSegment&gt; checkAllocation(TORequest toRequest) throws BbmFinderException  { 
	
<span class="nc" id="L221">		Map&lt;Integer, TimeOffRequestChoiceSegment&gt; map = null;</span>
		try {
<span class="nc" id="L223">			map = TimeOffIntervalAllocationUtil.getMgr().checkAllocation(</span>
<span class="nc" id="L224">					Collections.singletonList(toRequest.getID()));</span>
<span class="nc" id="L225">		} catch (Exception e) {</span>
<span class="nc" id="L226">			throw new BbmFinderException(e);</span>
<span class="nc" id="L227">		}</span>

<span class="nc" id="L229">		return map;</span>
		
	}
	
	
	
	
	public static List&lt;ShiftAssignment&gt; getReferenceSchedules(Organization organization,
			ID employeeID, Date start, Date end) throws BbmFinderException {
		
<span class="fc" id="L239">		List&lt;ShiftAssignment&gt; referencedShiftEvents = null; </span>
		try {
<span class="fc" id="L241">			referencedShiftEvents = TimeOffIntervalAllocationUtil.getMgr().getReferenceSchedules(</span>
					organization, employeeID, start,end);
<span class="nc" id="L243">		} catch (Exception e) {</span>
<span class="nc" id="L244">			throw new BbmFinderException(e);</span>
<span class="fc" id="L245">		}</span>
<span class="fc" id="L246">		return referencedShiftEvents;</span>
	}
	
	
	
	
	/*
	 *  validateReferenceScheduleGood
	 *  Hard validation check
	 *  Called by com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule.validate(Validatable)
	 *  For the request, for activities solely designated as &quot;interval allocation&quot; types, validate that a reference schedule exists for the 
	 *  employee.
	 *  If none exists, return false as a hard-validation error.
	 *  
	 */
	public static boolean validateReferenceScheduleGood(TORequest toRequest) throws Exception{ // NOSONAR
		
<span class="nc" id="L263">		List&lt;EmployeeDate&gt; employeeDates = new ArrayList&lt;EmployeeDate&gt;();</span>
<span class="nc" id="L264">		ID empId = toRequest.getEmployeeID();</span>
		
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L267">		List&lt;TOChoice&gt; choiceList = toRequest.getRequestChoiceList();</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		for (TOChoice toChoice : choiceList) {</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">			if(toChoice==null){</span>
<span class="nc" id="L271">				continue;</span>
			}
<span class="nc" id="L273">			EmployeeDate employeeDate = new EmployeeDate(empId,toChoice.getStartDate());</span>
<span class="nc" id="L274">			employeeDates.add(employeeDate);</span>
<span class="nc" id="L275">		}</span>
		
<span class="nc" id="L277">		Map&lt;EmployeeDate, ID&gt; map = getMgr().getReferenceScheduleSPDEID(employeeDates);</span>
<span class="nc bnc" id="L278" title="All 4 branches missed.">		if( map == null || map.isEmpty()){</span>
<span class="nc" id="L279">			return false;</span>
		}
		
		// see if each choice is in the map (i.e., has a reference schedule)
<span class="nc bnc" id="L283" title="All 2 branches missed.">		for( EmployeeDate empDate : employeeDates ){</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">			if( !map.containsKey(empDate) )</span>
<span class="nc" id="L285">				return false;</span>
<span class="nc" id="L286">		}</span>
		
		
<span class="nc" id="L289">		return true;</span>
	}
	
	/*
	 *  validatePublishedStatusGood
	 *  Hard validation check
	 *  Called by com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationPublishedStatusRule.validate(Validatable) // NOSONAR
	 *  For each time off choice, validate that the range is fully published or fully unpublished
	 *  If not fully published or fully unpublished, then return false as a hard-validation error.
	 *  
	 */
	public static boolean validatePublishedStatusGood(PublishingPeriodStatus publishingPeriodStatus, ID empID,
			TOChoice toChoice){
<span class="nc" id="L302">		IdDateRange idDateRange = new IdDateRange(empID,</span>
<span class="nc" id="L303">				toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">		return publishingPeriodStatus.getPeriodStatus(idDateRange) != Status.HAS_GAPS_IN_PUBLISHING;</span>
	}
	
	/*
	 * getPublishedPeriodStatusForTimeoffChoice Returns the status of a choice's
	 * date range published period: either wholly, un-wholly, or partly
	 * published. 
	 * Partly published periods are a hard-validation error.
	 * Unwholly published will require us to use Reference schedules
	 */

	static Status getPublishedPeriodStatusForTimeoffChoice(ID empId,
			TOChoice toChoice) throws BbmFinderException {
	
<span class="nc" id="L318">		PublishingPeriodStatus publishingPeriodStatus = new PublishingPeriodStatus();</span>
<span class="nc" id="L319">		IdDateRange idDateRange = new IdDateRange(empId,</span>
<span class="nc" id="L320">				toChoice.getStartDate(), toChoice.getEndDate());</span>

<span class="nc" id="L322">		publishingPeriodStatus.initialize(Collections.singleton(idDateRange),</span>
<span class="nc" id="L323">				getMgr());</span>

<span class="nc" id="L325">		return publishingPeriodStatus.getPeriodStatus(idDateRange);</span>
		
		} 
	
	static Status getPublishedPeriodStatusForTimeoffChoice(PublishingPeriodStatus publishingPeriodStatus, ID empID,
			TOChoice toChoice){
<span class="fc" id="L331">		IdDateRange idDateRange = new IdDateRange(empID,</span>
<span class="fc" id="L332">				toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="fc" id="L333">		return publishingPeriodStatus.getPeriodStatus(idDateRange);</span>
		
	}
	

	/*
	 * Initialize a PublishingPeriodStatus object, which will check the published period status
	 * for each Timeoff Choice in the request.
	 * Calling publishingPeriodStatus.getPeriodStatus(idDateRange) for the choice range will return if 
	 * a publishing period is wholly, not-wholly, or partly published.
	 * Partly published periods are a hard-validation error
	 * Unwholly published will require us to use Reference schedules
	 */
	public static PublishingPeriodStatus initPublishedPeriodStatusForTimeoffRequest(TORequest toRequest) throws BbmFinderException {
		
<span class="fc" id="L348">		PublishingPeriodStatus publishingPeriodStatus = new PublishingPeriodStatus();</span>
<span class="fc" id="L349">		ID empID = toRequest.getEmployeeID();</span>
		
<span class="fc" id="L351">		List&lt;IdDateRange&gt; listOfIdDateRanges = new ArrayList&lt;IdDateRange&gt;();</span>
		
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L354">		List&lt;TOChoice&gt; choiceList = toRequest.getRequestChoiceList();</span>

<span class="fc bfc" id="L356" title="All 2 branches covered.">		for (TOChoice toChoice : choiceList) {</span>
<span class="pc bpc" id="L357" title="1 of 2 branches missed.">			if(toChoice==null){</span>
<span class="nc" id="L358">				continue;</span>
			}
			
<span class="fc" id="L361">			IdDateRange idDateRange = new IdDateRange(empID, toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="fc" id="L362">			listOfIdDateRanges.add(idDateRange);</span>
<span class="fc" id="L363">		}</span>
		
		
<span class="fc" id="L366">		publishingPeriodStatus.initialize(listOfIdDateRanges, getMgr());</span>
<span class="fc" id="L367">		return publishingPeriodStatus;</span>
	}

	
	
	
	public static TimeOffIntervalAllocationManager getMgr() throws BbmFinderException{
<span class="fc" id="L374">		return TimeOffIntervalAllocationUtil.getTimeOffIntervalAllocationManager(null, null);</span>
	}
			
	public static TimeOffIntervalAllocationManager getTimeOffIntervalAllocationManager(
			String userName, String password) throws BbmFinderException {

<span class="fc" id="L380">		TimeOffIntervalAllocationManager manager = null;</span>
		try {
<span class="pc bpc" id="L382" title="2 of 4 branches missed.">			if (userName == null &amp;&amp; password == null) {</span>
<span class="fc" id="L383">				manager = getRmManagerFactory()</span>
<span class="fc" id="L384">						.getTimeOffIntervalAllocationManager();</span>
			} else {
<span class="nc" id="L386">				manager = getRmManagerFactory()</span>
<span class="nc" id="L387">						.getTimeOffIntervalAllocationManager(userName, password);</span>
			}
<span class="nc" id="L389">		} catch (Exception e) {</span>
<span class="nc" id="L390">			throw new BbmFinderException(e);</span>
<span class="fc" id="L391">		}</span>
<span class="fc" id="L392">		return manager;</span>

	}

	

	private static synchronized RmManagerFactory getRmManagerFactory() {
<span class="fc bfc" id="L399" title="All 2 branches covered.">		if (rmMgrFactory == null) {</span>
<span class="fc" id="L400">			rmMgrFactory = RmManagerFactory.getInstance(true);</span>
		}
<span class="fc" id="L402">		return rmMgrFactory;</span>
	}
	
	
	public static ScheduleAccessManager getScheduleAccessManager() throws BbmEJBCreateException {
		
<span class="nc" id="L408">		return  WfmManagerFactory.getScheduleAccessManager();</span>

	}
	
	
	public static List&lt;Collection&lt;PublishingPeriod&gt;&gt; getPublishedPeriods(
			ID empId, TimeRange range) throws BbmFinderException {
<span class="nc" id="L415">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsByEmp = null;</span>
		try {
<span class="nc" id="L417">			pubPeriodsByEmp = getScheduleAccessManager().getPublishedPeriods(</span>
<span class="nc" id="L418">					Collections.singletonList(empId), range.getStartDate(),</span>
<span class="nc" id="L419">					range.getEndDate());</span>
<span class="nc" id="L420">		} catch (Exception e) {</span>
<span class="nc" id="L421">			throw new BbmFinderException(e);</span>
<span class="nc" id="L422">		}</span>
<span class="nc" id="L423">		return pubPeriodsByEmp;</span>
	}

	public static TimeRange getFullDayTimeRangeInclusive(Date date) {
<span class="nc" id="L427">		Date start = RequestUtil.getDateForDayStart(date,</span>
<span class="nc" id="L428">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L429">		Date end = RequestUtil.getDateForDayEnd(start,</span>
<span class="nc" id="L430">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L431">		return new TimeRange(start, end);</span>
		
	}
	public static TimeRange getFullDayTimeRangeExclusive(Date date) {
<span class="nc" id="L435">		Date start = RequestUtil.getDateForDayStart(date,</span>
<span class="nc" id="L436">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L437">		Date end = DateUtil.addDays(start, 1);</span>
<span class="nc" id="L438">		return new TimeRange(start, end);</span>
	}
	
	public static Date getDayForwardOneDay(Date currentDate) {

<span class="nc" id="L443">		return TOCalcUtil.getDateForwardOneDay(currentDate,</span>
<span class="nc" id="L444">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
	}

	

	

	


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>