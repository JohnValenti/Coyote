<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidAuctionManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb</a> &gt; <span class="el_source">ShiftBidAuctionManagerEJB.java</span></div><h1>ShiftBidAuctionManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignOrgFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResourceFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.BiddableScheduleComparator;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuctionFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableScheduleDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableScheduleInstanceDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidderDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.UnsubmittedSchedulePreferenceDao;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleInstance;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidderFieldInfo;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterChain;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;

/**
 * &lt;b&gt;Serialized Auctions&lt;/b&gt;
 * &lt;p&gt;
 * Serialization Events:
 * &lt;li&gt;start or stop serialzation (from UI)
 * &lt;li&gt;current shift bidder deadline has expired (periodic poller thread)
 * &lt;li&gt;current shift bidder request approved/denied (on request submission &amp;
 * auto processing).
 *
 * &lt;p&gt;
 * Serialization implementation: &lt;br&gt;
 *
 * &lt;p&gt;
 * start serialization: &lt;br&gt;
 * 1. Rank unadded bidders.&lt;br&gt;
 * 2. Add first bidder as current bidder.&lt;br&gt;
 * 3. Notify current bidder.&lt;br&gt;
 * 4. Note current bidder in DB and set bidder's deadline.&lt;br&gt;
 *
 * &lt;p&gt;
 * current ShiftBidder's Deadline expires: &lt;br&gt;
 * Same as 'start serialization'.
 *
 * &lt;p&gt;
 * current ShiftBidder's request is submitted and processed (approved/denied).
 * &lt;br&gt;
 * Same as 'start serialization'
 *
 * &lt;p&gt;
 * DB Table: AuctionSerialization
 * &lt;li&gt;ID
 * &lt;li&gt;auctionID
 * &lt;li&gt;currentBidderID
 * &lt;li&gt;isEnabled.
 *
 * &lt;p&gt;
 * &lt;b&gt;Bonus and Score in auctions:&lt;/b&gt;
 * &lt;p&gt;
 * An auction has several bonuses specified. Following is a list of these:
 * &lt;li&gt;&quot;Accumulated bonus&quot; associated with an employee (and hence a shift
 * bidder). Used to compute the score for the bidder's shift bid request. see
 * below.
 * &lt;li&gt;&quot;No Bid bonus&quot; specified when the auction is created. This bonus is added
 * to the bidder's &quot;accumulated bonus&quot;, when the auction is closed, if the
 * bidder was unsuccessful in getting any of his bid approved.
 * &lt;li&gt;&quot;BiddableSchedule bonus&quot; assigned to biddable schedules. This bonus is
 * added to the &quot;accumulated bonus&quot; when the bidder's shift bid request is
 * approved. Bonuses from the biddable schedules for the shift bid request are
 * added to the &quot;accumulated bonus&quot;.
 * &lt;li&gt;&quot;ShiftBidder bonus&quot; assigned to shift bidders. Used in computing the
 * score for a shift bid request. This bonus is not added to the &quot;accumulated&quot;
 * bonus. See below.
 *
 * &lt;p&gt;
 * Score is a weighted sum computed using the bonus, rank and seniority of an
 * employee. The bonus used in this computation is the sum of the accumulated
 * bonus and shift bidder bonus. The score is used to compute the rank of a
 * shift bid request among the requests submitted for the same biddable
 * schedule(s) as this request.
 *
 * &lt;p&gt;
 * &quot;Auction uses scoring&quot; flag: If flag is disabled then:
 * &lt;li&gt;Shift bid requests created for the auction cannot specify &quot;use bonus&quot; for
 * score and rank computation of request
 * &lt;li&gt;Shift bid requests do have an assigned &quot;rank&quot; and &quot;score&quot;.
 * &lt;li&gt;Serialized Auctions cannot use the score to serialize shift bidders.
 *
 * &lt;p&gt;
 * Note that if &quot;Auction uses scoring&quot; flag is false for an auction does not
 * mean the auction does not use 'bonus' points. Bonuses may be used for the
 * following cases:
 * &lt;li&gt;adding bidders to serialized auctions by ranking them using their bonus.
 * This means that even for an auction with &quot;does not use scoring&quot;, &quot;bonus&quot; can
 * be used as a ranking criteria for adding bidders to the auction serially.
 * &lt;li&gt;bonuses can be assigned to shift bidders and biddable schedules. See
 * above for how these bonuses are used.
 *
 * &lt;p&gt;
 * &quot;ShiftBid Request uses bonus&quot; flag: If enabled, then the bidder's
 * &quot;accumulated bonus&quot; is used in computing the score and rank for the request.
 * If &quot;auction uses scoring&quot; is off, then this will also be automatically turned
 * off.
 *
 * &lt;p&gt;
 * &lt;b&gt;ShiftBidders in auction:&lt;/b&gt;
 * &lt;p&gt;
 * A shift bidder can participate in an auction only if he does not have any
 * shifts during the auction period. Corollaries of this rule are:
 * &lt;li&gt;ShiftBidRequest hard validation rule must check if the bidder has any
 * shifts during the auction period.
 * &lt;li&gt;On approval of a shift bid request, all other shift bid requests for the
 * same employee must be marked invalid.
 * &lt;li&gt;On approval of a shift bid request, bidder must be marked 'scheduled'. A
 * 'scheduled' bidder cannot be added to the auction.
 *
 * &lt;p&gt;
 * &lt;b&gt;ShiftBidder Status&lt;/b&gt;
 * &lt;li&gt;ADDED
 * &lt;li&gt;NOT_ADDED
 * &lt;li&gt;SCHEDULED
 * &lt;li&gt;SUBMITTED When a new shift bid request is created, state switched from
 * Added -&gt; Submitted.&lt;br&gt;
 * When shift bid request is approved, moves from submitted -&gt; scheduled.&lt;br&gt;
 * when shift bid request is denied, invalidated, withdrawn or expires, and
 * bidder state == 'submitted', then bidder state transistions from Submitted -&gt;
 * Added. If bidder state == 'unadded' or 'scheduled', then status transition is
 * not allowed.&lt;br&gt;
 *
 * &lt;p&gt;
 * Status transition validation must happen when:
 * &lt;li&gt;shiftBidder is updated from UI.
 * &lt;li&gt;shiftBidder added to auction when serializedAuction is in progress.
 *
 * Title: ShiftBidAuctionManagerEJB Description: EJB for ShiftBidAuction
 * Copyright: Copyright (c) 2002 Company: Blue Pumpkin Software, Inc.
 *
 * @author Jagdish Seelam
 * @version 1.0
 */
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">public class ShiftBidAuctionManagerEJB extends SessionEJBBase implements IShiftBidAuctionManager { // OUTSIDE_CONTAINER</span>
	// public class ShiftBidAuctionManagerEJB extends SessionEjbBaseForTest
	// implements ShiftBidAuctionManager { //OUTSIDE_CONTAINER

<span class="fc" id="L199">	private static final String m_className = ShiftBidAuctionManagerEJB.class.getName();</span>

<span class="fc" id="L201">	private static final Category m_cat = Log.initCategory(m_className);</span>

<span class="fc" id="L203">	private static final Pair m_emptyCollsPair = new Pair(Collections.EMPTY_LIST, Collections.EMPTY_LIST);</span>

	/**
	 * Do not access this member variable directly. Use the synchronized methods
	 * below.
	 * &lt;p&gt;
	 * Maintains a map of auction ID to last time the auction was synchronized
	 * to SP (for phantom schedule changes) using the schedule change audit
	 * trail in BBM.
	 */
<span class="fc" id="L213">	private static Map m_aucIDToLastSynchTimeUsingAuditTrailMap = new HashMap(32);</span>

	private static final short CPG_SCOPE = (short) 3;

	private static synchronized Date getLastSynchTimeUsingAuditTrail(ID aucID) {
<span class="nc" id="L218">		return (Date) m_aucIDToLastSynchTimeUsingAuditTrailMap.get(aucID);</span>
	}

	private static synchronized void setLastSynchTimeUsingAuditTrail(ID aucID, Date date) {
<span class="nc" id="L222">		m_aucIDToLastSynchTimeUsingAuditTrailMap.put(aucID, date);</span>
<span class="nc" id="L223">	}</span>

	{ // instance initializer
<span class="fc" id="L226">		super.init(m_className);</span>
	}

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L232">		return m_cat;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#createAuction(com.bluepumpkin.ejb.rm.requests.
	 * shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	@Override
	public ID createAuction(ShiftBidAuction sbAuctionVO) throws BbmCreateException, RmHardValidationException {
<span class="nc" id="L244">		String _method_ = &quot;createAuction&quot;;</span>
<span class="nc" id="L245">		methodStart(_method_, sbAuctionVO);</span>

<span class="nc" id="L247">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L248">		BiddableScheduleDAO biddableSchedDao = null;</span>
<span class="nc" id="L249">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L250">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L251">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L253">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// get SP associated with auction
<span class="nc" id="L256">			ID spID = sbAuctionVO.getSPID();</span>
<span class="nc" id="L257">			CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L258">			SchedulingPeriod schedPeriod = campMgr.getSchedulingPeriodByID(spID);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">			if (schedPeriod == null) {</span>
<span class="nc" id="L260">				throw RequestUtil.createRmException(RmEjbLogBundleKey.SPID_INVALID, spID, m_cat);</span>
			}

			// cache the scheduling period's start and end time in the shiftbid
			// auction VO.
<span class="nc" id="L265">			sbAuctionVO.getSetters().setSchedulingPeriodStartTime(schedPeriod.getStartTime());</span>
<span class="nc" id="L266">			sbAuctionVO.getSetters().setSchedulingPeriodEndTime(schedPeriod.getEndTime());</span>
<span class="nc" id="L267">			sbAuctionVO.getSetters().setCampaignID(schedPeriod.getCampaignID());</span>

<span class="nc" id="L269">			assignDefaultsForAuctionVO(sbAuctionVO);</span>

			// validate the auction
<span class="nc" id="L272">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L273">			bidderDAO = new ShiftBidderDAO(auctionDao.getDMO(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L274">			validateAuction(sbAuctionVO, null, RequestUtil.ACTION_CREATE, auctionDao, bidderDAO);</span>

			// create the auction
<span class="nc" id="L277">			ID auctionID = auctionDao.createAuction(sbAuctionVO);</span>

			// create the biddableSchedule
			// TODO: cascaded create to create the auction, biddable schedule
			// and
			// the shiftbidders would be nice. implement when refactoring time
			// available.
<span class="nc" id="L284">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L285">			Collection biddableScheds = ShiftBidAuctionUtil.compileBiddableSchedsForAuction(sbAuctionVO, null, wrm);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L287">				m_cat.debug(</span>
<span class="nc" id="L288">						&quot;Following BiddableSchedules identified for auction: &quot; + RmUtil.dumpCollection(biddableScheds));</span>
			}

			// BiddableSchedule.firstAvailBiddableScheduleInstanceID not set in
			// the created BiddableSchedule
			// since the ID will only be available after the create.
<span class="nc" id="L294">			biddableSchedDao = new BiddableScheduleDAO(auctionDao.getDMO(), BiddableSchedule.DL_BASIC);</span>
<span class="nc" id="L295">			biddableSchedDao.createBiddableSchedules(biddableScheds);</span>
<span class="nc" id="L296">			m_cat.debug(&quot;Created biddable schedules: &quot; + biddableScheds.size());</span>

			// update each biddable schedule with its first avaialable biddable
			// schedule instance ID.
			// Use the biddable schedule instance IDs generated by
			// createBiddableSchedules() method call above.
<span class="nc" id="L302">			ShiftBidAuctionUtil.updateBiddableSchedsWithFirstAvailInstanceID(biddableSchedDao, biddableScheds);</span>

			// create the shiftBidders
<span class="nc" id="L305">			Collection bidders = compileShiftBiddersForAuction(sbAuctionVO, schedPeriod, campMgr, bidderDAO);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L307">				m_cat.debug(&quot;Following Bidders identified for auction: &quot; + RmUtil.dumpCollection(bidders));</span>
			}
<span class="nc" id="L309">			bidderDAO.createShiftBidders(bidders);</span>
<span class="nc" id="L310">			m_cat.debug(&quot;Created shiftBidders: &quot; + bidders.size());</span>

<span class="nc" id="L312">			return auctionID;</span>
<span class="nc" id="L313">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L314">			m_cat.error(e, e);</span>
<span class="nc" id="L315">			handleException(e);</span>
<span class="nc" id="L316">			throw e;</span>
<span class="nc" id="L317">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L328">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L329">			throw e;</span>
<span class="nc" id="L330">		} catch (Exception e) {</span>
<span class="nc" id="L331">			handleException(e);</span>
<span class="nc" id="L332">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L334" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L335">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L337" title="All 4 branches missed.">			if (biddableSchedDao != null) {</span>
<span class="nc" id="L338">				biddableSchedDao.cleanUp();</span>
			}
<span class="nc bnc" id="L340" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L341">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L343" title="All 4 branches missed.">			if (auctionDao != null) {</span>
<span class="nc" id="L344">				auctionDao.cleanUp();</span>
			}

<span class="nc" id="L347">			methodFinish();</span>
		}
	}

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateAuction(com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	@Override
	public void updateAuction(ShiftBidAuction auction)
			throws MultiUserException, BbmUpdateException, RmHardValidationException {

<span class="nc" id="L358">		String _method_ = &quot;updateAuction&quot;;</span>
<span class="nc" id="L359">		methodStart(_method_, auction);</span>
<span class="nc" id="L360">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L361">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L363">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L365">			_updateAuction(auction, null, null);</span>
<span class="nc" id="L366">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L367">			m_cat.error(e, e);</span>
<span class="nc" id="L368">			handleException(e);</span>
<span class="nc" id="L369">			throw e;</span>
<span class="nc" id="L370">		} catch (MultiUserException e) {</span>
<span class="nc" id="L371">			m_cat.error(e, e);</span>
<span class="nc" id="L372">			handleException(e);</span>
<span class="nc" id="L373">			throw e;</span>
<span class="nc" id="L374">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L385">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L386">			throw e;</span>
<span class="nc" id="L387">		} catch (Exception e) {</span>
<span class="nc" id="L388">			handleException(e);</span>
<span class="nc" id="L389">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L391" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L392">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L394">			methodFinish();</span>
<span class="nc" id="L395">		}</span>
<span class="nc" id="L396">	}</span>

	protected static class BiddableScheduleInstanceKey {
		protected String m_md5Hash;
		protected ID m_phantomEmpID;

		/**
		 * @param md5Hash
		 * @param phantomEmpID
		 */
<span class="nc" id="L406">		public BiddableScheduleInstanceKey(String md5Hash, ID phantomEmpID) {</span>
<span class="nc" id="L407">			m_md5Hash = md5Hash;</span>
<span class="nc" id="L408">			m_phantomEmpID = phantomEmpID;</span>
<span class="nc" id="L409">		}</span>

		/**
		 * define equals operation for instances of this class. Without this
		 * definition, using an instance of this class as a 'key' in a 'Map'
		 * will not work.
		 *
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L420" title="All 2 branches missed.">			if (!(obj instanceof BiddableScheduleInstanceKey)) {</span>
<span class="nc" id="L421">				return false;</span>
			}

<span class="nc" id="L424">			BiddableScheduleInstanceKey other = (BiddableScheduleInstanceKey) obj;</span>
<span class="nc bnc" id="L425" title="All 4 branches missed.">			return (m_phantomEmpID.equals(other.m_phantomEmpID) &amp;&amp; (m_md5Hash.equals(other.m_md5Hash)));</span>
		}

		/**
		 * hashCode is redefined to satisfy the following rule (see javadoc for
		 * Object.hashCode()):
		 * &lt;li&gt;If two objects are equal according to the equals(Object) method,
		 * then calling the hashCode method on each of the two objects must
		 * produce the same integer result
		 *
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode() {
			// m_md5Hash member of this instance is ignored when computing the
			// hashCode for simplicity.
			// This will result in the same hashCode for all instances with same
			// m_phantomID but different
			// 'm_md5Hash' values . As a result, the map performance might be
			// slightly slower.
<span class="nc" id="L445">			return m_phantomEmpID.hashCode();</span>
		}

		/*
		 * (non-Javadoc)
		 *
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
<span class="nc" id="L455">			return &quot;m_md5Hash = &quot; + m_md5Hash + &quot; m_phantomEmpID = &quot; + m_phantomEmpID;</span>
		}
	}

	/*
	 * protected static class BiddableScheduleInstanceValue { protected
	 * BiddableSchedule m_bidSched; protected BiddableScheduleInstance
	 * m_bidSchedInst;
	 *
	 * protected final static int STATUS_UNCHANGED = 1; protected final static
	 * int STATUS_DELETED = 2; protected final static int STATUS_ADDED = 3;
	 * protected int m_status;
	 *
	 * /**
	 *
	 * @param bidSched
	 *
	 * @param bidSchedInst
	 *
	 * @param i / public BiddableScheduleInstanceValue(BiddableSchedule
	 * bidSched, BiddableScheduleInstance bidSchedInst, int status) { m_bidSched
	 * = bidSched; m_bidSchedInst = bidSchedInst; m_status = status; } }
	 */

	/**
	 * Get BiddableScheduleInstanceKey to BiddableScheduleInstance map.
	 *
	 *
	 * @param bidScheds
	 * @param phanIDs
	 *            if not-null, restrict the map to only contain
	 *            biddableScheduleInstances which belong to these phantom
	 *            employee IDs.
	 * @return a map of
	 *         {@link ShiftBidAuctionManagerEJB.BiddableScheduleInstanceKey
	 *         BiddableScheduleInstanceKey} to {@link BiddableScheduleInstance
	 *         BiddableScheduleInstance}
	 */
	private Map getBSIKeyToBSIMap(Collection bidScheds, Set phanIDsSet) {
		// biddableScheduleInstanceKey to BiddableScheduleInstanceMap
<span class="nc" id="L495">		Map bsiKeyToBSIMap = new HashMap(bidScheds.size() * 2);</span>

		// for each bidSched
<span class="nc bnc" id="L498" title="All 2 branches missed.">		for (Iterator bidSchedsIter = bidScheds.iterator(); bidSchedsIter.hasNext();) {</span>
<span class="nc" id="L499">			BiddableSchedule bidSched = (BiddableSchedule) bidSchedsIter.next();</span>

<span class="nc" id="L501">			List bidSchedInsts = bidSched.getOptMethods().getBiddableScheduleInstances();</span>
			// for each bidSched instance
<span class="nc bnc" id="L503" title="All 2 branches missed.">			for (Iterator bidSchedInstsIter = bidSchedInsts.iterator(); bidSchedInstsIter.hasNext();) {</span>
<span class="nc" id="L504">				BiddableScheduleInstance bidSchedInst = (BiddableScheduleInstance) bidSchedInstsIter.next();</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">				if (bidSchedInst.getStatus() != BiddableScheduleInstance.STATUS_ASSIGNED) {// don't</span>
																							// do
																							// anything
																							// with
																							// the
																							// assigned
																							// sched
																							// instances
					// if phantom empIDs set is non-null and bidSchedInstance
					// does not belong to one of
					// the phantoms in the set, continue.
<span class="nc bnc" id="L516" title="All 4 branches missed.">					if (phanIDsSet != null &amp;&amp; !phanIDsSet.contains(bidSchedInst.getPhantomEmployeeID())) {</span>
<span class="nc" id="L517">						continue;</span>
					}

					// copy the md5 checksum from bidSched to bidSchedInstance.
<span class="nc" id="L521">					bidSchedInst.getSetters().setBiddableScheduleCheckSum(bidSched.getBiddableScheduleCheckSum());</span>

					// add bidSchedInstance to map.
<span class="nc" id="L524">					bsiKeyToBSIMap.put(new BiddableScheduleInstanceKey(bidSched.getBiddableScheduleCheckSum(),</span>
<span class="nc" id="L525">							bidSchedInst.getPhantomEmployeeID()), bidSchedInst);</span>
				}
<span class="nc" id="L527">			}</span>
<span class="nc" id="L528">		}</span>

<span class="nc" id="L530">		return bsiKeyToBSIMap;</span>
	}

<span class="nc" id="L533">	static class DAOCache {</span>
		private ShiftBidAuctionDAO m_shiftBidAuctionDAO;
		private BiddableScheduleDAO m_biddableScheduleDAO;
		private BiddableScheduleInstanceDAO m_biddableScheduleInstanceDAO;

		/**
		 * @return
		 */
		public BiddableScheduleDAO getBiddableScheduleDAO() {
<span class="nc bnc" id="L542" title="All 2 branches missed.">			m_biddableScheduleDAO = (m_biddableScheduleDAO == null) ? new BiddableScheduleDAO(BiddableSchedule.DL_BASIC)</span>
					: m_biddableScheduleDAO;

<span class="nc" id="L545">			return m_biddableScheduleDAO;</span>
		}

		/**
		 * @return
		 */
		public BiddableScheduleInstanceDAO getBiddableScheduleInstanceDAO() {
<span class="nc bnc" id="L552" title="All 2 branches missed.">			m_biddableScheduleInstanceDAO = (m_biddableScheduleInstanceDAO == null)</span>
					? new BiddableScheduleInstanceDAO(BiddableScheduleInstance.DL_BASIC)
					: m_biddableScheduleInstanceDAO;

<span class="nc" id="L556">			return m_biddableScheduleInstanceDAO;</span>
		}

		/**
		 * @return
		 */
		public ShiftBidAuctionDAO getShiftBidAuctionDAO() {
<span class="nc bnc" id="L563" title="All 2 branches missed.">			m_shiftBidAuctionDAO = (m_shiftBidAuctionDAO == null) ? new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC)</span>
					: m_shiftBidAuctionDAO;

<span class="nc" id="L566">			return m_shiftBidAuctionDAO;</span>
		}

		public void cleanUp() {
<span class="nc bnc" id="L570" title="All 2 branches missed.">			if (m_shiftBidAuctionDAO != null) {</span>
<span class="nc" id="L571">				m_shiftBidAuctionDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L573" title="All 2 branches missed.">			if (m_biddableScheduleDAO != null) {</span>
<span class="nc" id="L574">				m_biddableScheduleDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L576" title="All 2 branches missed.">			if (m_biddableScheduleInstanceDAO != null) {</span>
<span class="nc" id="L577">				m_biddableScheduleInstanceDAO.cleanUp();</span>
			}
<span class="nc" id="L579">		}</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#
	 * scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(com.bluepumpkin.
	 * common.datatypes.ID)
	 */
	@Override
	public void scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(ID auctionID)
			throws RmHardValidationException, RmException {

<span class="nc" id="L594">		String _method_ = &quot;scanAuditTrailForPhantomSchedChangesAndSynchWithAuction&quot;;</span>
<span class="nc" id="L595">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L597">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L598">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L600">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L602">			_scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(auctionID);</span>
<span class="nc" id="L603">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L614">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L615">			throw e;</span>
<span class="nc" id="L616">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });
<span class="nc" id="L620">			handleException(e);</span>
<span class="nc" id="L621">			throw e;</span>
<span class="nc" id="L622">		} catch (Exception e) {</span>
<span class="nc" id="L623">			handleException(e);</span>
<span class="nc" id="L624">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L626" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L627">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}

<span class="nc" id="L630">			methodFinish();</span>
<span class="nc" id="L631">		}</span>
<span class="nc" id="L632">	}</span>

	/**
	 * The logic in this method handles the following cases when the phantom's
	 * shift assignments in the current schedule becomes &quot;out of synch&quot; with the
	 * auction's bidSchedInstances:
	 *
	 * &lt;li&gt;Can detect a new phantom added to the SP and moves the changes to the
	 * auction's biddable schedules.
	 * &lt;li&gt;Can detect any schedule changes done to an existing phantom in DE and
	 * moves the changes to the auction's biddable schedules.
	 * &lt;li&gt;Detects schedule changes made to a phantom within the RM subsystem
	 * itself, for instance deletion of phantom shift assignments when a shift
	 * bid request is approved. Though this change is detected, no changes are
	 * made to the biddable schedules of the auction (since there is nothing to
	 * be added, deleted or updated in the auction).
	 * &lt;li&gt;Does not detect a phantom deletion (and its associated shift assns).
	 * This is because the audit trail lookup method in BBM expects a list of
	 * phantomIDs in the SP and the deleted phantom's ID is removed from the
	 * system. But this scenario is handled by the biddableSchedule validation
	 * logic (which is triggered by
	 * {@link #getBiddableSchedulesForAuction(ID, ID, ID, int, int, int, long)
	 * getBiddableSchedulesForAuction()} or similar methods.
	 *
	 * &lt;p&gt;
	 * This logic was extracted from the EJB remote interface method
	 * {@link #scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(ID)
	 * scanAuditTrailForPhantomSchedChangesAndSynchWithAuction()} and placed
	 * here since it can be called internally by other methods (other remote
	 * interface methods defined in the bean class) besides the above.
	 *
	 * If other methods called the above remote interface method directly,
	 * instead of this, then a transaction can be marked for rollback more than
	 * once which results in a 'transaction already rolledback' exception. For
	 * instance if an exception is thrown in the above remote method, it marks
	 * the transaction for rollback and rethrows the exception. This rethrown
	 * exception might trigger another attempt to mark the transaction as
	 * rolledback in the calling method which will result in 'transaction
	 * already rolledback' exception.
	 *
	 * @param auctionID
	 * @throws Exception
	 */
	private void _scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(ID auctionID) throws Exception {

<span class="nc" id="L677">		DAOCache daoCache = null;</span>
<span class="nc" id="L678">		Collection auctions = null;</span>
<span class="nc" id="L679">		boolean tryBlockSuccessful = false;</span>
<span class="nc" id="L680">		Date thisSynchTime = new Date();</span>

<span class="nc" id="L682">		EventAuditTrailManager auditTrailMgr = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L683">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

		try {
<span class="nc" id="L686">			daoCache = new DAOCache();</span>
<span class="nc" id="L687">			long aucDetLevel = ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_EXCLUDE_EXPIRED_AUCTION;</span>
<span class="nc" id="L688">			auctions = getAuctionsForID(auctionID, daoCache, aucDetLevel);</span>

			// now iterate thru the auctions
<span class="nc bnc" id="L691" title="All 2 branches missed.">			for (Iterator aucIter = auctions.iterator(); aucIter.hasNext();) {</span>
<span class="nc" id="L692">				ShiftBidAuction auction = (ShiftBidAuction) aucIter.next();</span>

				// get the last synch time for this auction.
<span class="nc" id="L695">				Date lastSynchTime = getLastSynchTimeUsingAuditTrail(auction.getID());</span>
				// if no last sych time found, default to the beginning of the
				// java universe.
<span class="nc bnc" id="L698" title="All 2 branches missed.">				lastSynchTime = (lastSynchTime == null) ? new Date(0) : lastSynchTime;</span>

				// get phantomIDs for auction.
<span class="nc" id="L701">				Collection phantoms = sam.getPhantoms(auction.getSPID());</span>
<span class="nc" id="L702">				Collection phanIDsInSP = RequestUtil.getListOfIDsFromVOBases(phantoms);</span>

				// check audit trail for schedule changes for phantoms in SP.
				//
				// see javadoc above for cases handled by this 'audit trail
				// scan'.
				// retrive all the change from db, not only shift, but for
				// phantom, most of them are shifts.
<span class="nc" id="L710">				Map wrIDToTimeRangeMap = auditTrailMgr.getChangedIntervalsForWorkResource(phanIDsInSP,</span>
						com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry.MODULE_SCHEDULING, 0,
<span class="nc" id="L712">						auction.getStartTime(), auction.getEndTime(), lastSynchTime, null);</span>
<span class="nc" id="L713">				Collection phanIDsInSPWithSchedChange = wrIDToTimeRangeMap.keySet();</span>

				// synchronize schedules from SP to the auction for phantoms
				// with schedule changes
<span class="nc bnc" id="L717" title="All 2 branches missed.">				if (!phanIDsInSPWithSchedChange.isEmpty()) {</span>
<span class="nc" id="L718">					m_cat.debug(&quot;Detected &quot; + phanIDsInSPWithSchedChange.size() + &quot; phantoms with schedule changes &quot;);</span>

					// synchronize the specified phantoms's schedules in the SP
					// with the auction's biddable schedules
<span class="nc" id="L722">					synchBidSchedsInSPWithAuctionForPhantomIDs(auction, phanIDsInSPWithSchedChange, daoCache);</span>
				} else {
<span class="nc" id="L724">					m_cat.debug(&quot;No changes to phantom schedules detected for auctionID = &quot; + auction.getID());</span>
				}
<span class="nc" id="L726">			}</span>

			// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
			// this must be the last statement in the 'try' block. See below.
<span class="nc" id="L730">			tryBlockSuccessful = true;</span>
			// xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
		} finally {
<span class="nc bnc" id="L733" title="All 4 branches missed.">			if (daoCache != null) {</span>
<span class="nc" id="L734">				daoCache.cleanUp();</span>
			}

			// Note: this code is not at the end of the 'try' block to handle
			// the case
			// where an exception is thrown in the 'finaly' block. If this was
			// at the end
			// of the 'try' block and an exception is thrown in the finally
			// block, then
			// changes made during 'synching' will be rolledback (DB transaction
			// rollback)
			// but the updates to the last synch time for the auctions will not
			// be. Placing it
			// here (and ensuring that an exception cannot be thrown in the
			// 'finally' clasue after
			// this point) ensures that the lastSynchTimes are updated only if
			// the 'synch' changes
			// are committed (ie. no exceptions are thrown)
			//
			// if executed the entire 'try' block sucessfully
<span class="nc bnc" id="L754" title="All 4 branches missed.">			if (tryBlockSuccessful) {</span>
				// update the 'lastSynchTime' for the auctions.
<span class="nc bnc" id="L756" title="All 4 branches missed.">				for (Iterator iter = auctions.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L757">					ShiftBidAuction auction = (ShiftBidAuction) iter.next();</span>

					// set the time the synch was done for the auction.
<span class="nc" id="L760">					setLastSynchTimeUsingAuditTrail(auction.getID(), thisSynchTime);</span>
<span class="nc" id="L761">				}</span>
			}
		}
<span class="nc" id="L764">	}</span>

	/**
	 * @param sbAuction
	 * @param phanIDsInAucWithSchedChange
	 * @param phanIDsAddedToSP
	 */
	private void synchBidSchedsInSPWithAuctionForPhantomIDs(ShiftBidAuction sbAuction,
			Collection phanIDsInAucWithSchedChange, DAOCache daoCache) throws Exception {

		// combine the 2 collections
<span class="nc" id="L775">		Set phanIDsWithSchedChangeSet = new HashSet(phanIDsInAucWithSchedChange);</span>

		// get auction biddable schedules for the specified phantomIDs. This is
		// a subset of
		// the entire set of biddableSchedules associated with the auction.
<span class="nc" id="L780">		BiddableScheduleDAO bidSchedDAO = daoCache.getBiddableScheduleDAO();</span>
<span class="nc" id="L781">		Collection bidSchedsInAucForPhanIDs = bidSchedDAO.getBiddableSchedulesForPhantomIDs(sbAuction.getID(),</span>
				phanIDsWithSchedChangeSet, BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES,
<span class="nc" id="L783">				daoCache.getBiddableScheduleInstanceDAO());</span>

		// map of md5 to BiddableSchedule for auction
<span class="nc" id="L786">		Map md5ToBSMapInAucForPhanIDs = RequestUtil.getMapOfFieldToVOBase(bidSchedsInAucForPhanIDs,</span>
				BiddableScheduleFieldInfo.BIDDABLESCHEDULE_S_BIDDABLESCHEDCHECKSUM);
		// Map of BidSchedInst key to BidSchedInst for auction restricted to
		// phantom IDs in the specified set.
<span class="nc" id="L790">		Map bsiKeyToBSIMapInAucForPhanIDs = getBSIKeyToBSIMap(bidSchedsInAucForPhanIDs, phanIDsWithSchedChangeSet);</span>

<span class="nc" id="L792">		m_cat.debug(&quot;Loaded &quot; + bidSchedsInAucForPhanIDs.size() + &quot; biddable schedules for auction&quot;);</span>
<span class="nc" id="L793">		m_cat.debug(&quot;Loaded &quot; + bsiKeyToBSIMapInAucForPhanIDs.size() + &quot; biddable schedule instances for auction&quot;);</span>

		// Now load the bidSchedInstances for the phantom IDs from the current
		// schedule.
		// The bidScheds are incomplete since they contain bidSchedInstances
		// only for the specified
		// list of phantom employees (if another bidSchedInstance exists, for a
		// given bidSched, which
		// belongs to a phantom not in the specified phantom list, this instance
		// is not compiled as
		// a child of the given bidSched). It is a subset because not all
		// bidScheds from the current
		// schedule are compiled. Only bidScheds for the specified phantoms are
		// compiled.
		//
		// InComp == InComplete
<span class="nc" id="L809">		Collection bidSchedsInCompInCurrSchedForPhanIDs = ShiftBidAuctionUtil.compileBiddableSchedsForAuction(sbAuction,</span>
<span class="nc" id="L810">				phanIDsWithSchedChangeSet, BbmManagerFactory.getWorkResourceManager());</span>
<span class="nc" id="L811">		Map md5ToBSInCompMapInCurrSchedForPhanIDs = RequestUtil.getMapOfFieldToVOBase(</span>
				bidSchedsInCompInCurrSchedForPhanIDs,
				BiddableScheduleFieldInfo.BIDDABLESCHEDULE_S_BIDDABLESCHEDCHECKSUM);
<span class="nc" id="L814">		Map bsiKeyToBSIMapInCurrSchedForPhanIDs = getBSIKeyToBSIMap(bidSchedsInCompInCurrSchedForPhanIDs, null);</span>

<span class="nc" id="L816">		m_cat.debug(</span>
<span class="nc" id="L817">				&quot;Loaded &quot; + bidSchedsInCompInCurrSchedForPhanIDs.size() + &quot; biddable schedules for current schedule&quot;);</span>
<span class="nc" id="L818">		m_cat.debug(&quot;Loaded &quot; + bsiKeyToBSIMapInCurrSchedForPhanIDs.size()</span>
				+ &quot; biddable schedule instances for current schedule&quot;);

		// passing false for parameter 'isComprehensive'. see javadoc for called
		// method for details.
<span class="nc" id="L823">		synchBidSchedsInSPWithAuctionAndPostToDB(md5ToBSInCompMapInCurrSchedForPhanIDs,</span>
				bsiKeyToBSIMapInCurrSchedForPhanIDs, md5ToBSMapInAucForPhanIDs, bsiKeyToBSIMapInAucForPhanIDs, false,
				bidSchedDAO);
<span class="nc" id="L826">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#scanForPhantomSchedChangesAndSynchWithAuction(com
	 * .bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void scanForPhantomSchedChangesAndSynchWithAuction(ID givenAuctionID, ID emplID, boolean byEmplType)
			throws RmHardValidationException, RmException {

<span class="nc" id="L839">		String _method_ = &quot;scanForPhantomSchedChangesAndSynchWithAuction&quot;;</span>
<span class="nc" id="L840">		String methodName = _method_;</span>
<span class="nc" id="L841">		methodStart(methodName, givenAuctionID);</span>

<span class="nc" id="L843">		DAOCache daoCache = null;</span>

<span class="nc" id="L845">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L846">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L848">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L850">			daoCache = new DAOCache();</span>

<span class="nc" id="L852">			long aucDetLevel = ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_EXCLUDE_EXPIRED_AUCTION;</span>
<span class="nc" id="L853">			Collection auctions = getAuctionsForID(givenAuctionID, daoCache, aucDetLevel);</span>

			// now iterate thru the auctions
<span class="nc bnc" id="L856" title="All 2 branches missed.">			for (Iterator aucIter = auctions.iterator(); aucIter.hasNext();) {</span>
<span class="nc" id="L857">				ShiftBidAuction auction = (ShiftBidAuction) aucIter.next();</span>
<span class="nc" id="L858">				_scanForPhantomSchedChangesAndSynchWithAuction(auction, daoCache, emplID, byEmplType);</span>
<span class="nc" id="L859">			}</span>
<span class="nc" id="L860">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L871">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L872">			throw e;</span>
<span class="nc" id="L873">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });
<span class="nc" id="L877">			handleException(e);</span>
<span class="nc" id="L878">			throw e;</span>
<span class="nc" id="L879">		} catch (Exception e) {</span>
<span class="nc" id="L880">			handleException(e);</span>
<span class="nc" id="L881">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L883" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L884">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}

<span class="nc bnc" id="L887" title="All 4 branches missed.">			if (daoCache != null) {</span>
<span class="nc" id="L888">				daoCache.cleanUp();</span>
			}

<span class="nc" id="L891">			methodFinish();</span>
<span class="nc" id="L892">		}</span>

<span class="nc" id="L894">	}</span>

	/**
	 * Get auctions for the specified autcionID.
	 *
	 * @param givenAuctionID
	 *            If null, then all auctions are returned.
	 * @param DAOCacheArr
	 *            ignored if null. if non-null, then first entry contains the
	 *            created {@link ShiftBidAuctionDAO ShiftBidAuctionDAO}.
	 * @param aucDetLevel
	 * @return
	 * @throws Exception
	 * @throws BbmFinderException
	 */
	private Collection getAuctionsForID(ID givenAuctionID, DAOCache daoCache, long aucDetLevel)
			throws Exception, BbmFinderException {

<span class="nc" id="L912">		ShiftBidAuctionDAO sbAucDAO = daoCache.getShiftBidAuctionDAO();</span>

<span class="nc" id="L914">		Collection auctions = null;</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">		if (givenAuctionID == null) { // retrieve all aucitons in the system.</span>
<span class="nc" id="L916">			auctions = sbAucDAO.getAuctionsAll(aucDetLevel);</span>
		} else {
<span class="nc" id="L918">			ShiftBidAuction auction = sbAucDAO.getAuctionByID(givenAuctionID, aucDetLevel);</span>
<span class="nc" id="L919">			auctions = Collections.singletonList(auction);</span>
		}

<span class="nc" id="L922">		return auctions;</span>
	}

	/**
	 * &lt;li&gt;auctionBidSchedInstances: get biddable schedule instances presently
	 * part of the auction (using the RM tables: biddableSchedule,
	 * biddableScheduleInst etc).
	 * &lt;li&gt;schedBidSchedInstances: get biddable schedule instances from the
	 * current schedule (by compiling a list of phantoms for this auction, their
	 * shift assignments and grouping the shift assns together).
	 * &lt;li&gt;compare and reconcile the difference between auctionBidSchedInstances
	 * and schedBidSchedInstances &lt;br&gt;
	 * 1. if same bid sched instance exists in both, no changes.&lt;br&gt;
	 * 2. if bid sched instance exists in auctionBidSchedInstances but not
	 * schedBidSchedInstances collection, then this bidSchedInst was deleted
	 * from the schedule.&lt;br&gt;
	 * 3. if bid sched instance exists in schedBidSchedInstances but not in
	 * auctionBidSchedInstances collection, then this bidSchedInst was added to
	 * the schedule.&lt;br&gt;
	 * &lt;li&gt;If the biddable schedule instance for a phantom is updated in the
	 * schedule, then conditions 2 and 3 above will be triggered.
	 * &lt;li&gt;If the biddable schedule instance for a phantom is deleted, then
	 * condition 2 applies.
	 * &lt;li&gt;If a new phantom is added with schedule, then condition 3 applies.
	 *
	 * @param sbAuction
	 */
	private void _scanForPhantomSchedChangesAndSynchWithAuction(ShiftBidAuction sbAuction, DAOCache daoCache, ID emplID, boolean byEmplType)
			throws Exception {

<span class="nc" id="L952">		String methodName = &quot;scanForPhantomSchedChangesAndSynchWithAuction&quot;;</span>

		// get biddableSchedules by rescanning the current schedule associated
		// with the SP for the
		// given auctionID.
<span class="nc" id="L957">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L958">		Collection bidSchedsCurSched = ShiftBidAuctionUtil.compileBiddableSchedsForAuction(sbAuction, null, wrm);</span>
<span class="nc" id="L959">		m_cat.debug(&quot;Number of bidScheds in current schedule: &quot; + bidSchedsCurSched.size());</span>

		// get map of md5Hash to bidScheds in current schedule.
<span class="nc" id="L962">		Map md5ToBSMapForCurrSched = RequestUtil.getMapOfFieldToVOBase(bidSchedsCurSched,</span>
				BiddableScheduleFieldInfo.BIDDABLESCHEDULE_S_BIDDABLESCHEDCHECKSUM);

		// map of biddablesScheduleInstKey to biddableScheduleInstance
<span class="nc" id="L966">		Map bsiKeyToBSIMapForCurrSched = getBSIKeyToBSIMap(bidSchedsCurSched, null);</span>
<span class="nc" id="L967">		m_cat.debug(&quot;Number of bidSchedInstances in current schedule: &quot; + bsiKeyToBSIMapForCurrSched.size());</span>

		// get biddable schedule instances for this auction.
<span class="nc" id="L970">		BiddableScheduleDAO bidSchedDAO = daoCache.getBiddableScheduleDAO();</span>

		// If DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES is not specified, then an
		// existing bidSched
		// with numOfAvailInstances == 0, for the md5 being searched for, will
		// not be udpated.
		// Instead a new bidSched for the same md5 will be created.
<span class="nc" id="L977">		Collection bidSchedsForAuc = bidSchedDAO.getBiddableSchedulesForAuction(sbAuction.getID(), null, emplID, byEmplType,</span>
				BiddableSchedule.SORTBY_NONE, SupportNavigation.SORT_ASCENDING,
				BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES
						| BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES);
<span class="nc" id="L981">		m_cat.debug(&quot;Number of bidScheds from auction data in DB: &quot; + bidSchedsForAuc.size());</span>

		// Map of BidSched checksum to BidSched.
<span class="nc" id="L984">		Map md5ToBSMapForAuc = RequestUtil.getMapOfFieldToVOBase(bidSchedsForAuc,</span>
				BiddableScheduleFieldInfo.BIDDABLESCHEDULE_S_BIDDABLESCHEDCHECKSUM);

		// translate biddables schedules to biddable schedule instances for
		// faster lookup.
<span class="nc" id="L989">		Map bsiKeyToBSIMapForAuc = getBSIKeyToBSIMap(bidSchedsForAuc, null);</span>
<span class="nc" id="L990">		m_cat.debug(&quot;Number of bidSchedInsts from auction data in DB: &quot; + bsiKeyToBSIMapForAuc.size());</span>

<span class="nc" id="L992">		synchBidSchedsInSPWithAuctionAndPostToDB(md5ToBSMapForCurrSched, bsiKeyToBSIMapForCurrSched, md5ToBSMapForAuc,</span>
				bsiKeyToBSIMapForAuc, true, bidSchedDAO);
<span class="nc" id="L994">	}</span>

	/**
	 * Compares and reconciles the differences between the biddableSchedules in
	 * the auction and SP. See
	 * {@link #_scanForPhantomSchedChangesAndSynchWithAuction(ShiftBidAuction, DAOBase[])
	 * scanForPhantomSchedChangesAndSynchWithAuction()} for more information
	 *
	 * @param md5ToBSMaybeICMapForCurrSched
	 *            (MaybeIC == Maybe Incomplete) If 'isComprehensive' parameter
	 *            is 'false', then this bidSched is incomplete, ie. does not
	 *            contain all bidSchedInstances for the bidSched.
	 * @param bsiKeyToBSIMapForCurrSched
	 * @param md5ToBSMapForAuc
	 * @param bsiKeyToBSIMapForAuc
	 * @param isComprehensive
	 *            true if the bidScheds and bidSchedInstances passed as
	 *            parameters to this method (for the auction and SP) were
	 *            compiled with the shift assignments for all phantom employees
	 *            in the auction. False if the bidScheds and bidSchedInstances
	 *            were compiled using the shift assignments for a subset of
	 *            phantoms for the auction. The subset mode is used when
	 *            synching the SP with the auction using the schedule change
	 *            audit trail in BBM
	 * @param bidSchedDAO
	 * @throws Exception
	 */
	private void synchBidSchedsInSPWithAuctionAndPostToDB(Map md5ToBSMaybeICMapForCurrSched,
			Map bsiKeyToBSIMapForCurrSched, Map md5ToBSMapForAuc, Map bsiKeyToBSIMapForAuc, boolean isComprehensive,
			BiddableScheduleDAO bidSchedDAO) throws Exception {

		// stores the bidScheds which were updated.
		// changes made to the bidScheds by each of
		// the methods below must be accumulated and not overwritten. For this
		// reason, strictly, each method
		// below must first check to see if the bidSched is in the update map if
		// an update is required.
		// But this is not done since both the udpated bidsched map and auction
		// bidsched map point
		// to the same bidsched entries (loaded from the auction).
<span class="nc" id="L1034">		Map updatedBSIDToBSMap = new HashMap(md5ToBSMaybeICMapForCurrSched.size() * 2);</span>
<span class="nc" id="L1035">		fixNumOfAvailInstsAndFirstAvailBSIIDIfNecessForBSes(md5ToBSMapForAuc, updatedBSIDToBSMap);</span>

<span class="nc" id="L1037">		markDeletedBSIsForRemovalInAucAndRemoveSameBSIsFromCurrSchedMap(bsiKeyToBSIMapForCurrSched, md5ToBSMapForAuc,</span>
				bsiKeyToBSIMapForAuc, updatedBSIDToBSMap);

		// Note: at this point, bsiKeyToBSIMapForCurrSched only contains
		// bidSchedInsts which exist
		// in the current schedule but not in the auction (ie newly created
		// bidScheds). The above
		// method may have deleted entries in bsiKeyToBSIMapForCurrSched.
<span class="nc" id="L1045">		Map md5ToBSMapforCreatedBSes = createNewBSsOrUpdateExistingBSsForNewBSIsInCurrSched(</span>
				md5ToBSMaybeICMapForCurrSched, bsiKeyToBSIMapForCurrSched, md5ToBSMapForAuc, isComprehensive,
				updatedBSIDToBSMap, bidSchedDAO);

		// post updatedBidSchedsMap to database.
<span class="nc bnc" id="L1050" title="All 4 branches missed.">		if (updatedBSIDToBSMap != null &amp;&amp; !updatedBSIDToBSMap.isEmpty()) {</span>
<span class="nc" id="L1051">			m_cat.debug(&quot;Number of bidScheds being updated in DB: &quot; + updatedBSIDToBSMap.values().size());</span>
<span class="nc" id="L1052">			bidSchedDAO.updateBiddableSchedulesForAuction(updatedBSIDToBSMap.values());</span>

			// If a new bidSchedInst is added to a bidSched with
			// bidSched.numOfAvailInstances == 0, then
			// bidSched.firstAvailInstance will still be 'null'. It must be set
			// to the ID of one of the
			// bidSchedInstances.
			//
			// get bidScheds with 'null' firstAvailBidSchedInstID.
<span class="nc" id="L1061">			Collection updatedBidSchedsWithNullFABSI_ID = getBidSchedsWithNullFABSI_ID(updatedBSIDToBSMap.values());</span>

			// if any bidScheds with 'null' firstAvailBidSchedInst were found
<span class="nc bnc" id="L1064" title="All 2 branches missed.">			if (!updatedBidSchedsWithNullFABSI_ID.isEmpty()) {</span>
				// move children from 'created' to 'persisted'. We do not want
				// them to be reinserted.
<span class="nc" id="L1067">				RequestUtil.moveChildrenFromCreatedToPersisted(updatedBidSchedsWithNullFABSI_ID);</span>

				// update each biddable schedule with its first avaialable
				// biddable schedule instance ID.
				// Use the biddable schedule instance IDs generated by
				// updateBiddableSchedulesForAuction() method call above.
<span class="nc" id="L1073">				ShiftBidAuctionUtil.updateBiddableSchedsWithFirstAvailInstanceID(bidSchedDAO,</span>
						updatedBidSchedsWithNullFABSI_ID);
			}
		}

		// post createdBidSchedsMap to database.
<span class="nc bnc" id="L1079" title="All 4 branches missed.">		if (md5ToBSMapforCreatedBSes != null &amp;&amp; !md5ToBSMapforCreatedBSes.isEmpty()) {</span>
<span class="nc" id="L1080">			Collection createdBidScheds = md5ToBSMapforCreatedBSes.values();</span>

			// persist the new bidScheds and its children in the database.
<span class="nc" id="L1083">			m_cat.debug(&quot;Number of bidScheds being created in DB: &quot; + createdBidScheds.size());</span>

<span class="nc" id="L1085">			bidSchedDAO.createBiddableSchedules(createdBidScheds);</span>

			// update each biddable schedule with its first avaialable biddable
			// schedule instance ID.
			// Use the biddable schedule instance IDs generated by
			// createBiddableSchedules() method call above.
<span class="nc" id="L1091">			ShiftBidAuctionUtil.updateBiddableSchedsWithFirstAvailInstanceID(bidSchedDAO, createdBidScheds);</span>
		}
<span class="nc" id="L1093">	}</span>

	/**
	 * Check for bidScheds with 'firstAvailBidSchedInstID' == null but
	 * 'numberOfAvailInstances &gt; 0. Return a collection of such bidScheds with
	 * their children moved from the 'created' to the 'persisted' map.
	 *
	 * @param updatedBSIDToBSMap
	 * @return
	 */
	private Collection getBidSchedsWithNullFABSI_ID(Collection updatedBidScheds) {

<span class="nc" id="L1105">		Collection updatedBidSchedsWithNullFABSI_ID = null;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">		for (Iterator iter = updatedBidScheds.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1107">			BiddableSchedule bidSched = (BiddableSchedule) iter.next();</span>

			// is the bidSched.firstAvailInstance == null but
			// bidSched.numOfAvailInstances &gt; 0
<span class="nc bnc" id="L1111" title="All 4 branches missed.">			if (bidSched.getFirstAvailBiddableSchedInstanceID() == null &amp;&amp; bidSched.getNumOfAvailableInstances() &gt; 0) {</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">				updatedBidSchedsWithNullFABSI_ID = (updatedBidSchedsWithNullFABSI_ID == null) ? new ArrayList()</span>
						: updatedBidSchedsWithNullFABSI_ID;

				// add to updated list
<span class="nc" id="L1116">				updatedBidSchedsWithNullFABSI_ID.add(bidSched);</span>
			}
<span class="nc" id="L1118">		}</span>

<span class="nc bnc" id="L1120" title="All 2 branches missed.">		return (updatedBidSchedsWithNullFABSI_ID == null) ? Collections.EMPTY_LIST : updatedBidSchedsWithNullFABSI_ID;</span>
	}

	/**
	 * For BSIs which exist in the current schedule but not in the auction,
	 * create either a new BiddableSchedule or udpate an existing
	 * BiddablSchedule in the auction.
	 *
	 * @param md5ToBSMapForCurrSched
	 * @param bsiKeyToBSIMapForCurrSched
	 * @param md5ToBSMapForAuc
	 * @param isComprehensive
	 *            see javadoc for
	 *            {@link #synchBidSchedsInSPWithAuctionAndPostToDB(Map, Map, Map, Map, boolean, BiddableScheduleDAO)
	 *            synchBidSchedsInSPWithAuctionAndPostToDB()}
	 * @return
	 */
	private Map createNewBSsOrUpdateExistingBSsForNewBSIsInCurrSched(Map md5ToBSMapForCurrSched,
			Map bsiKeyToBSIMapForCurrSched, Map md5ToBSMapForAuc, boolean isComprehensive, Map updatedBSIDToBSMap,
			BiddableScheduleDAO bidSchedDAO) throws Exception {

		// Map of md5Hash to newly created bidScheds.
<span class="nc" id="L1142">		Map md5ToBSMapForBSesToBeCreated = null;</span>

		// After removing the unmodified bidSchedInstances (in the current
		// schedule) from the list (see above),
		// the ones left are the newly created biddable schedule instances.
<span class="nc bnc" id="L1147" title="All 2 branches missed.">		for (Iterator iter = bsiKeyToBSIMapForCurrSched.entrySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1148">			Map.Entry bsiKeyToBSIMapEntryForCurrSched = (Map.Entry) iter.next();</span>

<span class="nc" id="L1150">			BiddableScheduleInstanceKey bsiKeyForCurrSched = (BiddableScheduleInstanceKey) bsiKeyToBSIMapEntryForCurrSched</span>
<span class="nc" id="L1151">					.getKey();</span>
<span class="nc" id="L1152">			BiddableScheduleInstance bsiForCurrSched = (BiddableScheduleInstance) bsiKeyToBSIMapEntryForCurrSched</span>
<span class="nc" id="L1153">					.getValue();</span>

			// Note: The correct logic is to first check the updated bidSched
			// map and then the bidSChed
			// map from the auction. But since the updated map and auction map
			// point to the same
			// bidScheds, it is sufficient if we just check the auction map.
			//
			// check if a biddableSchedule already exists with this instances
			// md5Hash value.
<span class="nc" id="L1163">			BiddableSchedule bidSchedAlreadyExists = getBidSchedForBidSchedInst(bsiForCurrSched, md5ToBSMapForAuc,</span>
					isComprehensive, bidSchedDAO);
<span class="nc bnc" id="L1165" title="All 2 branches missed.">			if (bsiForCurrSched.getStatus() != BiddableScheduleInstance.STATUS_ASSIGNED) {</span>
<span class="nc bnc" id="L1166" title="All 2 branches missed.">				if (bidSchedAlreadyExists != null) {</span>

<span class="nc" id="L1168">					m_cat.debug(&quot;bidSchedInst exists in schedule but not the auction. Adding it to &quot;</span>
<span class="nc" id="L1169">							+ &quot;existing bidSched for auction: bidSchedID = &quot; + bidSchedAlreadyExists.getID());</span>

<span class="nc" id="L1171">					bidSchedAlreadyExists.getSetters().addBiddableScheduleInstance(bsiForCurrSched);</span>
					// updatedBidSched.getSetters().setNumOfAvailInstances(updatedBidSched.getNumOfAvailableInstances()
					// + 1);

					// Note: if this biddableSchedule already exists in the
					// update list, the existing entry is
					// replaced. Otherwise, it is added to the update list.
					// Note: biddableSchedule was looked up in md5ToBSMapForAuc
					// earlier and is now stored in
					// updatedBSIDToBSMap. Both maps point to the same
					// biddableSchedule object.
<span class="nc" id="L1182">					updatedBSIDToBSMap.put(bidSchedAlreadyExists.getID(), bidSchedAlreadyExists);</span>
				} else { // need to create a new biddable schedule.
<span class="nc" id="L1184">					String md5Hash = bsiForCurrSched.getOptMethods().getBiddableScheduleCheckSum();</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">					if (md5Hash != null) {</span>
<span class="nc" id="L1186">						m_cat.debug(&quot;bidSchedInst exists in schedule but not the auction. Adding it to &quot;</span>
								+ &quot;a newly created biddable schedule&quot;);

						// create map if necessary.
<span class="nc bnc" id="L1190" title="All 2 branches missed.">						md5ToBSMapForBSesToBeCreated = (md5ToBSMapForBSesToBeCreated == null)</span>
<span class="nc" id="L1191">								? new HashMap(md5ToBSMapForCurrSched.size() * 2) : md5ToBSMapForBSesToBeCreated;</span>

						// fetch the matching biddableSchedule for the biddable
						// schedule instance to be created.
<span class="nc" id="L1195">						BiddableSchedule bidSchedCurrent = (BiddableSchedule) md5ToBSMapForCurrSched.get(md5Hash);</span>

						// add biddableSchedule to the create list. Note that
						// this biddableSchedule may have
						// other instances besides this instance. All these
						// instances will be created.
						// Note: if this biddableSchedule already exists in the
						// create map, the existing entry is
						// replaced. Otherwise, it is added to the create list.
						// Note: biddableSchedule was looked up in
						// bidSchedsCurrentMap earlier and is now stored in
						// createdBidSchedsMap. Both maps point to the same
						// biddableSchedule object.
<span class="nc" id="L1208">						md5ToBSMapForBSesToBeCreated.put(bidSchedCurrent.getBiddableScheduleCheckSum(),</span>
								bidSchedCurrent);
					}
				}
			}
<span class="nc" id="L1213">		}</span>

<span class="nc" id="L1215">		return md5ToBSMapForBSesToBeCreated;</span>
	}

	/**
	 * fetch the bidSched for the passed bidSchedInst either from the passed
	 * bidSchedMap or the database.
	 * &lt;li&gt;If isComprehensive is 'true', then the bidSched is fetched from the
	 * Map.
	 * &lt;li&gt;If isComprehensive is 'false', then the bidSched is fetched from the
	 * map or the database in that order.
	 *
	 * @param bidSchedInst
	 * @param md5ToBidSchedMap
	 * @param isComprehensive
	 * @param bidSchedDAO
	 * @return
	 * @throws Exception
	 */
	private BiddableSchedule getBidSchedForBidSchedInst(BiddableScheduleInstance bidSchedInst, Map md5ToBidSchedMap,
			boolean isComprehensive, BiddableScheduleDAO bidSchedDAO) throws Exception {

<span class="nc" id="L1236">		String md5Hash = bidSchedInst.getOptMethods().getBiddableScheduleCheckSum();</span>

<span class="nc" id="L1238">		BiddableSchedule bidSched = null;</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">		if (isComprehensive) {</span>
<span class="nc" id="L1240">			bidSched = (BiddableSchedule) md5ToBidSchedMap.get(md5Hash);</span>
		} else {
			// first check the map. The primary reason for this is that if the
			// bidSched was
			// udpated by earlier logic, then it should be used and not loaded
			// from the DB.
<span class="nc bnc" id="L1246" title="All 2 branches missed.">			if (md5ToBidSchedMap != null) {</span>
<span class="nc" id="L1247">				bidSched = (BiddableSchedule) md5ToBidSchedMap.get(md5Hash);</span>
			}

			// now fetch from DB
<span class="nc bnc" id="L1251" title="All 2 branches missed.">			if (bidSched == null) {</span>
				// If DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES is not specified,
				// then an existing bidSched
				// with numOfAvailInstances == 0, for the md5 being searched
				// for, will not be udpated.
				// Instead a new bidSched for the same md5 will be created.
<span class="nc" id="L1257">				bidSched = bidSchedDAO.getBiddableScheduleForMD5(md5Hash, bidSchedInst.getShiftBidAuctionID(),</span>
						BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES
								| BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES);
			}
		}

<span class="nc" id="L1263">		return bidSched;</span>
	}

	/**
	 * &lt;li&gt;Mark for deletion BiddableScheduleIntances found in the auction but
	 * not in the current schedule
	 * &lt;li&gt;Remove (from map) BiddableScheduleInstances, from the specified
	 * BidSchedInstMapForCurrSchedule, which exist in both the auction and the
	 * current schedule.
	 *
	 * @param bsiKeyToBSIMapForCurrSched
	 *            This is an in/out parameter. Modified by this method
	 * @param md5ToBSMapForAuc
	 * @param bsiKeyToBSIMapForAuc
	 * @param BSIDToUpdatedBSMap
	 *            This is an in/out parameter. Modified by this method
	 * @return
	 */
	private void markDeletedBSIsForRemovalInAucAndRemoveSameBSIsFromCurrSchedMap(Map bsiKeyToBSIMapForCurrSched,
			Map md5ToBSMapForAuc, Map bsiKeyToBSIMapForAuc, Map updatedBSIDToBSMap) {

<span class="nc" id="L1284">		Set bsiKeyToBSIMapEntrySetForAuc = bsiKeyToBSIMapForAuc.entrySet();</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">		for (Iterator iter = bsiKeyToBSIMapEntrySetForAuc.iterator(); iter.hasNext();) {</span>
			// get the map entry.
<span class="nc" id="L1287">			Map.Entry bsiKeyToBSIMapEntryForAuc = (Map.Entry) iter.next();</span>

			// get the key and value for this entry.
<span class="nc" id="L1290">			BiddableScheduleInstanceKey bidSchedInstForAucKey = (BiddableScheduleInstanceKey) bsiKeyToBSIMapEntryForAuc</span>
<span class="nc" id="L1291">					.getKey();</span>
			// map value is the bidSchedInst.
<span class="nc" id="L1293">			BiddableScheduleInstance bidSchedInstForAuc = (BiddableScheduleInstance) bsiKeyToBSIMapEntryForAuc</span>
<span class="nc" id="L1294">					.getValue();</span>

<span class="nc" id="L1296">			m_cat.debug(&quot;Processing bidSchedInst in auction. ID, bidSchedInstKey: &quot;</span>
<span class="nc" id="L1297">					+ RmUtil.dumpCommaSeparated(bidSchedInstForAuc.getID(), bidSchedInstForAucKey));</span>

			// if this biddableScheduleInstance does not exist in the
			// biddableScheduleInstance
			// collection compiled from the schedule, delete this biddable
			// schedule instance from the auction.
<span class="nc bnc" id="L1303" title="All 2 branches missed.">			if (!bsiKeyToBSIMapForCurrSched.containsKey(bidSchedInstForAucKey)</span>
<span class="nc bnc" id="L1304" title="All 2 branches missed.">					&amp;&amp; bidSchedInstForAuc.getStatus() != BiddableScheduleInstance.STATUS_ASSIGNED) {</span>
<span class="nc" id="L1305">				m_cat.debug(&quot;bidSchedInst exists in auction but not the current schedule. &quot;</span>
<span class="nc" id="L1306">						+ &quot;deleting it from auction: ID = &quot; + bidSchedInstForAuc.getID());</span>

				// Note: The correct logic is to first check the updated
				// bidSched map and then the bidSChed
				// map from the auction. But since the updated map and auction
				// map point to the same
				// bidScheds, it is sufficient if we just check the auction map.
				//
				// look up in bidSchedsFromAucMap using md5Hash.
<span class="nc" id="L1315">				BiddableSchedule updatedBidSched = (BiddableSchedule) md5ToBSMapForAuc</span>
<span class="nc" id="L1316">						.get(bidSchedInstForAuc.getOptMethods().getBiddableScheduleCheckSum());</span>

				// delete the biddable schedule instance from the biddable
				// schedule. Also updates the
				// BidSched.NumOfAVailInstances and BidSChed.firstAvailInst
				// field.
<span class="nc" id="L1322">				updatedBidSched.getSetters().deleteBiddableScheduleInstance(bidSchedInstForAuc.getID());</span>
				// // update the biddable schedule instance count.
				// updatedBidSched.getSetters().setNumOfAvailInstances(updatedBidSched.getNumOfAvailableInstances()
				// - 1);

				// add biddable schedule to updated map.
<span class="nc" id="L1328">				updatedBSIDToBSMap.put(updatedBidSched.getID(), updatedBidSched);</span>
<span class="nc" id="L1329">			} else {</span>
<span class="nc" id="L1330">				m_cat.debug(&quot;bidSchedInst exists in auction and schedule. No action taken: ID = &quot;</span>
<span class="nc" id="L1331">						+ bidSchedInstForAuc.getID());</span>

				// biddable schedule instance unchanged. So remove from
				// bidSchedInstsCurrentMap.
<span class="nc" id="L1335">				bsiKeyToBSIMapForCurrSched.remove(bidSchedInstForAucKey);</span>
			}
<span class="nc" id="L1337">		} // for bidSchedInstances in the auction.</span>
<span class="nc" id="L1338">	}</span>

	/**
	 * Fix &quot;number of available instances&quot; and
	 * &quot;first available biddableScheduleInstanceID&quot; if necessary for
	 * BiddableSchedules.
	 *
	 * @param md5ToBSMapForAuc
	 * @param updatedBSIDToBSMap
	 *            this is an in/out parm. Modified by this method.
	 * @return
	 */
	private void fixNumOfAvailInstsAndFirstAvailBSIIDIfNecessForBSes(Map md5ToBSMapForAuc, Map updatedBSIDToBSMap) {
		// verify if bidSched.numOfAvailBidSchedInsts != actual number of
		// bidSchedInsts assoc
		// with the biddable schedule. This can happen if the phantom is deleted
		// outside RM (when phantom is deleted from DE, the associaetd
		// bidSchedInst
		// with the phantom is deleted as well.
<span class="nc bnc" id="L1357" title="All 2 branches missed.">		for (Iterator iter = md5ToBSMapForAuc.values().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1358">			BiddableSchedule bidSchedForAuc = (BiddableSchedule) iter.next();</span>
			// Fix for Bug #91377; Number of avaialble templates are not
			// subtracted correctly;
			// Sameet ; Feb 2006
			// We need only the Unassigned Biddable instances that can be used.
<span class="nc" id="L1363">			List bidSchedInstList = bidSchedForAuc.getOptMethods().getBiddableScheduleInstances();</span>
<span class="nc" id="L1364">			int availableInstances = 0;</span>
<span class="nc bnc" id="L1365" title="All 4 branches missed.">			if (bidSchedInstList != null &amp;&amp; !bidSchedInstList.isEmpty()) {</span>

<span class="nc bnc" id="L1367" title="All 2 branches missed.">				for (Iterator iterator = bidSchedInstList.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1368">					BiddableScheduleInstance biddableInstance = (BiddableScheduleInstance) iterator.next();</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">					if (biddableInstance.getStatus() == BiddableScheduleInstance.STATUS_UNASSIGNED) {</span>
<span class="nc" id="L1370">						availableInstances++;</span>
					}
<span class="nc" id="L1372">				}</span>
			}
			// This is no good since it return the total number of Available
			// instances.
			// int bidSchedInstCollSize =
			// bidSchedForAuc.getOptMethods().getBiddableScheduleInstances().size();

<span class="nc" id="L1379">			int numOfAvailBidSchedInsts = bidSchedForAuc.getNumOfAvailableInstances();</span>

<span class="nc" id="L1381">			boolean bidSchedUpdated = bidSchedForAuc.getSetters()</span>
<span class="nc" id="L1382">					.fixNumOfAvailInstsAndFirstAvailBSIIDIfNecess(availableInstances);</span>

<span class="nc bnc" id="L1384" title="All 2 branches missed.">			if (bidSchedUpdated) {</span>
<span class="nc" id="L1385">				m_cat.debug(&quot;NumOfAVailInstances and/or firstAvailBidSchedInstID was updated: ID = &quot;</span>
<span class="nc" id="L1386">						+ bidSchedForAuc.getID());</span>

				// add biddable schedule to updated map.
<span class="nc" id="L1389">				updatedBSIDToBSMap.put(bidSchedForAuc.getID(), bidSchedForAuc);</span>
			}
<span class="nc" id="L1391">		}</span>
<span class="nc" id="L1392">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#openAuction(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void openAuction(ID auctionID) throws BbmUpdateException, RmHardValidationException {

<span class="nc" id="L1403">		String _method_ = &quot;openAuction&quot;;</span>
<span class="nc" id="L1404">		methodStart(_method_, auctionID);</span>
<span class="nc" id="L1405">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1406">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1408">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1410">			_updateAuctionByID(auctionID, ShiftBidAuctionFieldInfo.SHIFTBIDAUCTION_N_STATUS,</span>
					new Integer(ShiftBidAuction.STATUS_OPEN_FOR_BIDDING), null);
<span class="nc" id="L1412">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1413">			m_cat.error(e, e);</span>
<span class="nc" id="L1414">			handleException(e);</span>
<span class="nc" id="L1415">			throw e;</span>
<span class="nc" id="L1416">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1427">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1428">			throw e;</span>
<span class="nc" id="L1429">		} catch (Exception e) {</span>
<span class="nc" id="L1430">			handleException(e);</span>
<span class="nc" id="L1431">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1433" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1434">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1436">			methodFinish();</span>
<span class="nc" id="L1437">		}</span>
<span class="nc" id="L1438">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#closeAuction(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void closeAuction(ID auctionID, boolean addNoneApprBonus)
			throws BbmUpdateException, RmHardValidationException {

<span class="nc" id="L1450">		String _method_ = &quot;closeAuction&quot;;</span>
<span class="nc" id="L1451">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L1453">		ShiftBidAuctionDAO sbAucDAO = null;</span>
<span class="nc" id="L1454">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1455">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1456">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1458">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// now update the auction status to 'closed'.
<span class="nc bnc" id="L1461" title="All 2 branches missed.">			sbAucDAO = (sbAucDAO == null) ? new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC) : sbAucDAO;</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">			if (addNoneApprBonus) {</span>
				// get IDs for bidders who submitted a bid but did not get it
				// approved.
<span class="nc bnc" id="L1465" title="All 2 branches missed.">				bidderDAO = (bidderDAO == null) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>
<span class="nc" id="L1466">				addNoneApprovedBonus(auctionID, sbAucDAO, bidderDAO);</span>
			}

<span class="nc" id="L1469">			_updateAuctionByID(auctionID, ShiftBidAuctionFieldInfo.SHIFTBIDAUCTION_N_STATUS,</span>
					new Integer(ShiftBidAuction.STATUS_CLOSED_FOR_BIDDING), sbAucDAO);
<span class="nc" id="L1471">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1472">			m_cat.error(e, e);</span>
<span class="nc" id="L1473">			handleException(e);</span>
<span class="nc" id="L1474">			throw e;</span>
<span class="nc" id="L1475">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1486">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1487">			throw e;</span>
<span class="nc" id="L1488">		} catch (Exception e) {</span>
<span class="nc" id="L1489">			handleException(e);</span>
<span class="nc" id="L1490">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1492" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1493">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1495" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L1496">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L1498" title="All 4 branches missed.">			if (sbAucDAO != null) {</span>
<span class="nc" id="L1499">				sbAucDAO.cleanUp();</span>
			}

<span class="nc" id="L1502">			methodFinish();</span>
<span class="nc" id="L1503">		}</span>
<span class="nc" id="L1504">	}</span>

	private void addNoneApprovedBonus(ID auctionID, ShiftBidAuctionDAO sbAucDAO, ShiftBidderDAO bidderDAO)
			throws Exception {

		// get all bidders who made a bid but none of it was approved.
<span class="nc" id="L1510">		List noneApprBidderIDs = bidderDAO.getShiftBidderIDsWithNoApprovedBids(auctionID);</span>

		// if we found any 'none approved' bidders
<span class="nc bnc" id="L1513" title="All 2 branches missed.">		if (!noneApprBidderIDs.isEmpty()) {</span>
			// fetch the 'none approved bonus' from the auction.
<span class="nc" id="L1515">			ShiftBidAuction sbAuc = sbAucDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1516">			int noneApprBonus = sbAuc.getBonusForNoBidsAccepted();</span>

			// fetch the bidder objects.
<span class="nc" id="L1519">			Collection noneApprBidders = bidderDAO.getShiftBiddersByIDs(noneApprBidderIDs, false,</span>
					ShiftBidder.DL_BASIC | ShiftBidder.DL_EMPLOYEE);

			// iterate and apply 'none approved bonus'
<span class="nc bnc" id="L1523" title="All 2 branches missed.">			for (Iterator noneApprBiddersIter = noneApprBidders.iterator(); noneApprBiddersIter.hasNext();) {</span>
<span class="nc" id="L1524">				ShiftBidder noneApprBidder = (ShiftBidder) noneApprBiddersIter.next();</span>

<span class="nc" id="L1526">				Employee bidderEmp = noneApprBidder.getOptMethods().getEmployee();</span>
<span class="nc" id="L1527">				bidderEmp.setAssignedPoints(bidderEmp.getAssignedPoints() + noneApprBonus);</span>

<span class="nc" id="L1529">				noneApprBidder.getSetters().updateEmployee(bidderEmp);</span>
<span class="nc" id="L1530">			}</span>

			// Note: we update directly using the DAO instead of using
			// ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate()
			// since only the employee object is updated and validation of
			// shiftBidder is not necessary.
<span class="nc" id="L1536">			bidderDAO.updateShiftBidders(noneApprBidders);</span>
		}
<span class="nc" id="L1538">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#deleteAuctions(java.util.Collection)
	 */
	@Override
	public void deleteAuctions(Collection idsToDelete) throws BbmRemoveException, RmHardValidationException {

<span class="nc" id="L1549">		String _method_ = &quot;deleteAuctions&quot;;</span>
<span class="nc" id="L1550">		methodStart(_method_, idsToDelete);</span>
<span class="nc" id="L1551">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L1552">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1553">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1555">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1557">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1558">			auctionDao.deleteAuctions(idsToDelete);</span>
<span class="nc" id="L1559">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1560">			m_cat.error(e, e);</span>
<span class="nc" id="L1561">			handleException(e);</span>
<span class="nc" id="L1562">			throw e;</span>
<span class="nc" id="L1563">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1574">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1575">			throw e;</span>
<span class="nc" id="L1576">		} catch (Exception e) {</span>
<span class="nc" id="L1577">			handleException(e);</span>
<span class="nc" id="L1578">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1580" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1581">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1583" title="All 4 branches missed.">			if (auctionDao != null) {</span>
<span class="nc" id="L1584">				auctionDao.cleanUp();</span>
			}
<span class="nc" id="L1586">			methodFinish();</span>
<span class="nc" id="L1587">		}</span>
<span class="nc" id="L1588">	}</span>

	/**
	 * @param detailLevel
	 *            see {@link ShiftBidAuction ShiftBidAuction} for detailLevel
	 *            constants.
	 */
	@Override
	public ShiftBidAuction getAuctionByID(ID auctionID, long detailLevel)
			throws BbmFinderException, RmHardValidationException {

<span class="nc" id="L1599">		String _method_ = &quot;getAuctionByID&quot;;</span>
<span class="nc" id="L1600">		methodStart(_method_, auctionID, new Long(detailLevel));</span>
<span class="nc" id="L1601">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1602">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1604">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1606">			return ShiftBidAuctionUtil._getAuctionByID(auctionID, detailLevel);</span>
<span class="nc" id="L1607">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1608">			m_cat.error(e, e);</span>
<span class="nc" id="L1609">			handleException(e);</span>
<span class="nc" id="L1610">			throw e;</span>
<span class="nc" id="L1611">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1622">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1623">			throw e;</span>
<span class="nc" id="L1624">		} catch (Exception e) {</span>
<span class="nc" id="L1625">			handleException(e); // TODO: is transaction supported</span>
<span class="nc" id="L1626">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1628" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1629">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1631">			methodFinish();</span>
		}
	}

	/**
	 * @param detailLevel
	 *            see {@link ShiftBidAuction ShiftBidAuction} for detailLevel
	 *            constants.
	 */
	@Override
	public Collection getAuctionsByIDs(Collection auctionIDs, long detailLevel) throws BbmFinderException {

<span class="nc" id="L1643">		String _method_ = &quot;getAuctionByID&quot;;</span>
<span class="nc" id="L1644">		methodStart(_method_, auctionIDs, new Long(detailLevel));</span>
<span class="nc" id="L1645">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L1646">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1647">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1649">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1651">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1652">			return auctionDao.getAuctionsByIDs(auctionIDs, detailLevel);</span>
<span class="nc" id="L1653">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1654">			m_cat.error(e, e);</span>
<span class="nc" id="L1655">			handleException(e);</span>
<span class="nc" id="L1656">			throw e;</span>
<span class="nc" id="L1657">		} catch (Exception e) {</span>
<span class="nc" id="L1658">			handleException(e);</span>
<span class="nc" id="L1659">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1661" title="All 4 branches missed.">			if (auctionDao != null) {</span>
<span class="nc" id="L1662">				auctionDao.cleanUp();</span>
			}
<span class="nc bnc" id="L1664" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1665">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1667">			methodFinish();</span>
		}
	}

	/**
	 * Returns the list of auctions associated with campaigns for which employee
	 * has FS_VIEWCAMPAIGN privilege. Used by the webtier to retrieve a list of
	 * auctions for a manager.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getAuctionsForEmployee(com.bluepumpkin.common.datatypes.ID,
	 *      long)
	 */
	@Override
	public Collection getAuctionsForManagerEmpID(ID empID, long detailLevel)
			throws RmException, RmHardValidationException {
<span class="nc" id="L1682">		String _method_ = &quot;getAuctionsForEmployee&quot;;</span>
<span class="nc" id="L1683">		methodStart(_method_, empID, new Long(detailLevel));</span>
<span class="nc" id="L1684">		ShiftBidAuctionDAO auctionDao = null;</span>

<span class="nc" id="L1686">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1687">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1689">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1691">			Collection viewCampIDs = getCampaignsWithPrivilege(empID, PrivilegeKeys.FS_VIEWCAMPAIGN);</span>

			// if agent, then we filter by both employee ID (translated to
			// collection of SPIDs) and campaignIDs
			// if manager, we only filter by collection of campaignIDs.
<span class="nc" id="L1696">			auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L1697">			return auctionDao.getAuctionsForCampaignIDs(viewCampIDs, detailLevel);</span>
<span class="nc" id="L1698">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1701">			handleException(e);</span>
<span class="nc" id="L1702">			throw e;</span>
<span class="nc" id="L1703">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1714">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1715">			throw e;</span>
<span class="nc" id="L1716">		} catch (Exception e) {</span>
<span class="nc" id="L1717">			handleException(e); // TODO: is transaction supported</span>
<span class="nc" id="L1718">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1720" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1721">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1723" title="All 4 branches missed.">			if (auctionDao != null) {</span>
<span class="nc" id="L1724">				auctionDao.cleanUp();</span>
			}
<span class="nc" id="L1726">			methodFinish();</span>
		}
	}

	/**
	 * Return auctions for which the given employee ID is an **active** bidder
	 * (bidder added to auction).
	 *
	 * @param empID
	 * @param detailLevel
	 * @return
	 * @throws RmException
	 */
	@Override
	public Collection getAuctionsForBidderEmpID(ID empID, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L1743">		String _method_ = &quot;getAuctionsForBidder&quot;;</span>
<span class="nc" id="L1744">		methodStart(_method_, empID, new Long(detailLevel));</span>
<span class="nc" id="L1745">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L1746">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1747">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1749">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1751">			auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L1752">			return auctionDao.getAuctionsForBidderEmpID(empID, detailLevel);</span>
<span class="nc" id="L1753">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1764">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1765">			throw e;</span>
<span class="nc" id="L1766">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1769">			handleException(e);</span>
<span class="nc" id="L1770">			throw e;</span>
<span class="nc" id="L1771">		} catch (Exception e) {</span>
<span class="nc" id="L1772">			handleException(e); // TODO: is transaction supported</span>
<span class="nc" id="L1773">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1775" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1776">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1778" title="All 4 branches missed.">			if (auctionDao != null) {</span>
<span class="nc" id="L1779">				auctionDao.cleanUp();</span>
			}
<span class="nc" id="L1781">			methodFinish();</span>
		}
	}

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#startAuctionSerialization(com.bluepumpkin.common.datatypes.ID,
	 *      int)
	 *
	 *      &lt;p&gt;
	 *      ShiftBidder's 'isSerializedAuctionBidder' flag:
	 *      &lt;li&gt;When the seriaized auction starts, this flag is set for all
	 *      unadded bidders in the auction or for all unadded bidders in the
	 *      given set of bidder IDs.
	 *      &lt;li&gt;When the serialized auction ends, this flag is reset for all
	 *      shiftBidders (ir-respective of bidder state == 'added' or 'not
	 *      added').
	 *
	 * @param rankBy
	 *            One of the possible constants defined in {@link ShiftBidder
	 *            ShiftBidder} similar to {@link ShiftBidder#RANKBY_SCORE
	 *            RANKBY_SCORE}
	 */
	// * possible state changes:&lt;br&gt;
	// * isSerAucBidder, UnAdded -&gt; isSerAucBidder, UnAdded.
	// * isSerAucBidder, UnAdded -&gt; isSerAucBidder, Added.
	// * isSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, UnAdded.
	// * isSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, Added.
	// *
	// * isSerAucBidder, Added -&gt; isSerAucBidder, UnAdded.
	// * isSerAucBidder, Added -&gt; isSerAucBidder, Added.
	// * isSerAucBidder, Added -&gt; NotIsSerAucBidder, UnAdded.
	// * isSerAucBidder, Added -&gt; NotIsSerAucBidder, Added.
	// *
	// * NotIsSerAucBidder, UnAdded -&gt; isSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, UnAdded -&gt; isSerAucBidder, Added.
	// * NotIsSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, Added.
	// *
	// * NotIsSerAucBidder, Added -&gt; isSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, Added -&gt; isSerAucBidder, Added.
	// * NotIsSerAucBidder, Added -&gt; NotIsSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, Added -&gt; NotIsSerAucBidder, Added.
	// */
	@Override
	public void startAuctionSerialization(ID auctionID, Collection bidderIDs, int bidderTimeLimit, int rankBy)
			throws RmException, RmHardValidationException {

<span class="nc" id="L1828">		String _method_ = &quot;startAuctionSerialization&quot;;</span>
<span class="nc" id="L1829">		methodStart(_method_, auctionID, bidderIDs, new Integer(bidderTimeLimit), new Integer(rankBy));</span>

<span class="nc" id="L1831">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="nc" id="L1832">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1833">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1834">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1836">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1838">			m_cat.debug(&quot;Starting serialized auction for ID = &quot; + auctionID);</span>

			// check if auction does exist and is open.
<span class="nc" id="L1841">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc bnc" id="L1842" title="All 4 branches missed.">			if (sbAuction == null || !sbAuction.getIsAuctionOpen()) {</span>
<span class="nc" id="L1843">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_NOT_OPEN_YET,</span>
						RmEjbLogBundleKey.AUC_NOT_OPEN_YET, new Object[] { auctionID }, m_cat);
			}

<span class="nc" id="L1847">			serAucDAO = new SerializedAuctionDAO();</span>
<span class="nc" id="L1848">			SerializedAuction serAuc = serAucDAO.getSerializedAuctionForAuctionID(auctionID);</span>
<span class="nc bnc" id="L1849" title="All 4 branches missed.">			if (serAuc != null &amp;&amp; serAuc.getIsEnabled()) {</span>
<span class="nc" id="L1850">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_SERIALIZED,</span>
						RmEjbLogBundleKey.AUC_ALREADY_SERIALIZED, new Object[] { auctionID }, m_cat);
			}

			// set flag for given bidderIDs which are yet un-added to the
			// auction(as eligible for
			// participating in the serialized auction). If null, then all
			// un-added shift bidders
			// are marked eligible.
<span class="nc" id="L1859">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_EMPLOYEE);</span>
<span class="nc" id="L1860">			bidderDAO.updateIsSerializedAuctionForBidderIDs(auctionID, bidderIDs, true);</span>

			// if serialized auction fetched from DB, update fetched object.
			// addNextBidderToSerAucAndNotify()
			// below will persist this object's updates in DB.
<span class="nc bnc" id="L1865" title="All 2 branches missed.">			if (serAuc != null) {</span>
<span class="nc" id="L1866">				serAuc.setBidderTimelimit(bidderTimeLimit);</span>
<span class="nc" id="L1867">				serAuc.setRankMethod(rankBy);</span>
			} else {
				// create new serializedAuction. This object will be saved in DB
				// by
				// addNextBidderToSerAucAndNotify() method below.
<span class="nc" id="L1872">				serAuc = new SerializedAuction(auctionID, bidderTimeLimit, rankBy, true);</span>
			}

<span class="nc" id="L1875">			ShiftBidder addedBidder = ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(serAuc, serAucDAO, null);</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">			if (addedBidder == null) {</span>
<span class="nc" id="L1877">				_stopSerializedAuction(serAuc, serAucDAO, null);</span>
			}
<span class="nc" id="L1879">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1882">			handleException(e);</span>
<span class="nc" id="L1883">			throw e;</span>
<span class="nc" id="L1884">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1895">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1896">			throw e;</span>
<span class="nc" id="L1897">		} catch (Exception e) {</span>
<span class="nc" id="L1898">			handleException(e);</span>
<span class="nc" id="L1899">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1901" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1902">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1904" title="All 4 branches missed.">			if (serAucDAO != null) {</span>
<span class="nc" id="L1905">				serAucDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L1907" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L1908">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L1910">			methodFinish();</span>
<span class="nc" id="L1911">		}</span>
<span class="nc" id="L1912">	}</span>

	/**
	 * Stops an auction in progress.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#stopAuctionSerialization(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void stopAuctionSerialization(ID auctionID) throws RmException, RmHardValidationException {

<span class="nc" id="L1922">		String _method_ = &quot;stopAuctionSerialization&quot;;</span>
<span class="nc" id="L1923">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L1925">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1926">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1928">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1930">			m_cat.debug(&quot;Stopping auction serialization: auctionID = &quot; + auctionID);</span>
<span class="nc" id="L1931">			_stopSerializedAuction(new SerializedAuction(auctionID, 0, 0, false), null, null);</span>
<span class="nc" id="L1932">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1935">			handleException(e);</span>
<span class="nc" id="L1936">			throw e;</span>
<span class="nc" id="L1937">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1948">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1949">			throw e;</span>
<span class="nc" id="L1950">		} catch (Exception e) {</span>
<span class="nc" id="L1951">			handleException(e);</span>
<span class="nc" id="L1952">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1954" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L1955">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1957">			methodFinish();</span>
<span class="nc" id="L1958">		}</span>
<span class="nc" id="L1959">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getSerializedAuction(com.bluepumpkin.common.
	 * datatypes.ID)
	 */
	@Override
	public SerializedAuction getSerializedAuction(ID auctionID) throws RmException, RmHardValidationException {

<span class="nc" id="L1971">		String _method_ = &quot;getSerializedAuction&quot;;</span>
<span class="nc" id="L1972">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L1974">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="nc" id="L1975">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1976">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1978">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1980">			serAucDAO = new SerializedAuctionDAO();</span>
<span class="nc" id="L1981">			return serAucDAO.getSerializedAuctionForAuctionID(auctionID);</span>
<span class="nc" id="L1982">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L1985">			handleException(e);</span>
<span class="nc" id="L1986">			throw e;</span>
<span class="nc" id="L1987">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1998">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1999">			throw e;</span>
<span class="nc" id="L2000">		} catch (Exception e) {</span>
<span class="nc" id="L2001">			handleException(e);</span>
<span class="nc" id="L2002">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2004" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2005">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2007" title="All 4 branches missed.">			if (serAucDAO != null) {</span>
<span class="nc" id="L2008">				serAucDAO.cleanUp();</span>
			}
<span class="nc" id="L2010">			methodFinish();</span>
		}
	}

	/**
	 * Return Map with Auction ID and Auction ValueObject for the specified
	 * SerializedAuctions
	 */
	private Map getAuctionMapForSerializedAuctions(Collection serAucs) throws BbmFinderException {
<span class="fc" id="L2019">		methodStart(&quot;getAuctionMapForSerializedAuctions&quot;);</span>

<span class="fc" id="L2021">		ShiftBidAuctionDAO auctionDAO = null;</span>
		try {
<span class="pc bpc" id="L2023" title="2 of 4 branches missed.">			if (serAucs == null || serAucs.isEmpty()) {</span>
<span class="fc" id="L2024">				return Collections.EMPTY_MAP;</span>
			}

			// Create List of AuctionIDs
<span class="nc" id="L2028">			List aucIDs = new ArrayList(serAucs.size());</span>
<span class="nc bnc" id="L2029" title="All 2 branches missed.">			for (Iterator it = serAucs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2030">				SerializedAuction serAuc = (SerializedAuction) it.next();</span>
<span class="nc" id="L2031">				aucIDs.add(serAuc.getAuctionID());</span>
<span class="nc" id="L2032">			}</span>

			// Fetch collection of Auctions and create Map
<span class="nc" id="L2035">			Map result = new HashMap();</span>
<span class="nc" id="L2036">			long detailLevel = ShiftBidAuction.DL_BASIC;</span>
<span class="nc" id="L2037">			auctionDAO = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L2038">			Collection auctions = auctionDAO.getAuctionsByIDs(aucIDs, detailLevel);</span>
<span class="nc bnc" id="L2039" title="All 2 branches missed.">			for (Iterator it = auctions.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2040">				ShiftBidAuction sbAuc = (ShiftBidAuction) it.next();</span>
<span class="nc" id="L2041">				result.put(sbAuc.getID(), sbAuc);</span>
<span class="nc" id="L2042">			}</span>

<span class="nc" id="L2044">			return result;</span>
		} finally {
<span class="pc bpc" id="L2046" title="5 of 6 branches missed.">			if (auctionDAO != null) {</span>
<span class="nc" id="L2047">				auctionDAO.cleanUp();</span>
			}
<span class="pc" id="L2049">			methodFinish();</span>
		}
	}

	@Override
	public void pollSerializedAuctions() throws RmException, RmHardValidationException {

<span class="fc" id="L2056">		String _method_ = &quot;pollSerializedAuctions&quot;;</span>
<span class="fc" id="L2057">		methodStart(_method_);</span>

<span class="fc" id="L2059">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="fc" id="L2060">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L2061">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L2063">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L2065">			m_cat.debug(&quot;Entering pollSerializedAuctions&quot;);</span>
<span class="fc" id="L2066">			serAucDAO = new SerializedAuctionDAO();</span>
			// find enabled auctions with &quot;deadline for submission&quot; &lt; curr time
<span class="fc" id="L2068">			Collection expiredserAucs = serAucDAO.getSerializedAuctionsPastDeadline(new Date());</span>
<span class="fc" id="L2069">			Map aucIDToAuctionMap = getAuctionMapForSerializedAuctions(expiredserAucs);</span>

			// add next bidder for each such auction.
<span class="pc bpc" id="L2072" title="1 of 2 branches missed.">			for (Iterator expiredserAucIter = expiredserAucs.iterator(); expiredserAucIter.hasNext();) {</span>
<span class="nc" id="L2073">				SerializedAuction serAuc = (SerializedAuction) expiredserAucIter.next();</span>

				// skip closed auctions
<span class="nc" id="L2076">				ShiftBidAuction auction = (ShiftBidAuction) aucIDToAuctionMap.get(serAuc.getAuctionID());</span>
<span class="nc bnc" id="L2077" title="All 4 branches missed.">				if (auction != null &amp;&amp; auction.isStatusClosed()) {</span>
<span class="nc bnc" id="L2078" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2079">						m_cat.debug(&quot;Auction is closed so skip it. SerializedAuction ID=&quot; + serAuc.getID());</span>
					}
					continue;
				}

				// get next bidder
<span class="nc" id="L2085">				ShiftBidder nextBidder = ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(serAuc, serAucDAO,</span>
						null);

				// if no more bidders stop auction serialization.
<span class="nc bnc" id="L2089" title="All 2 branches missed.">				if (nextBidder == null) {</span>
<span class="nc" id="L2090">					_stopSerializedAuction(serAuc, serAucDAO, null);</span>
				}
<span class="nc" id="L2092">			}</span>
<span class="nc" id="L2093">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L2096">			handleException(e);</span>
<span class="nc" id="L2097">			throw e;</span>
<span class="nc" id="L2098">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2109">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2110">			throw e;</span>
<span class="nc" id="L2111">		} catch (Exception e) {</span>
<span class="nc" id="L2112">			handleException(e);</span>
<span class="nc" id="L2113">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L2115" title="3 of 4 branches missed.">			if (cacheEnabled) {</span>
<span class="pc" id="L2116">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L2118" title="3 of 4 branches missed.">			if (serAucDAO != null) {</span>
<span class="pc" id="L2119">				serAucDAO.cleanUp();</span>
			}
<span class="pc" id="L2121">			methodFinish();</span>
<span class="fc" id="L2122">		}</span>
<span class="fc" id="L2123">	}</span>

	/**
	 * @param empID
	 * @param privName
	 * @return
	 */
	private Collection getCampaignsWithPrivilege(ID empID, String privName) throws Exception {
<span class="nc" id="L2131">		User user = RequestUtil.getUserByEmpIDCached(empID);</span>
<span class="nc" id="L2132">		return user.getAuthorizedScopes(privName, CPG_SCOPE);</span>
	}

	protected void _stopSerializedAuction(SerializedAuction serAuc, SerializedAuctionDAO serAucDAO,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc bnc" id="L2138" title="All 2 branches missed.">		boolean serAucDAOCreateNeeded = serAucDAO == null;</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">		boolean bidderDAOCreateNeeded = bidderDAO == null;</span>

		try {
<span class="nc bnc" id="L2142" title="All 2 branches missed.">			serAucDAO = (serAucDAOCreateNeeded) ? new SerializedAuctionDAO() : serAucDAO;</span>

<span class="nc" id="L2144">			ID auctionID = serAuc.getAuctionID();</span>

<span class="nc bnc" id="L2146" title="All 2 branches missed.">			if (serAuc.getID() == null) { // if passed serialized Auction was</span>
											// not loaded from DB by caller.
<span class="nc" id="L2148">				serAuc = serAucDAO.getSerializedAuctionForAuctionID(auctionID); // load</span>
																				// from
																				// DB
			}

<span class="nc bnc" id="L2153" title="All 4 branches missed.">			if (serAuc == null || !serAuc.getIsEnabled()) {</span>
<span class="nc" id="L2154">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_SERIALIZATION_NOT_STARTED,</span>
						RmEjbLogBundleKey.AUC_SERIALIZATION_NOT_STARTED, new Object[] { auctionID }, m_cat);
			}

			// stop auction serialization
<span class="nc" id="L2159">			serAuc.setIsEnabled(false);</span>
<span class="nc" id="L2160">			serAucDAO.updateSerializedAuction(serAuc);</span>

			// reset flag 'isSerializedAuctionBidder' for all shiftBidders in
			// the auction.
<span class="nc bnc" id="L2164" title="All 2 branches missed.">			bidderDAO = (bidderDAOCreateNeeded) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>
<span class="nc" id="L2165">			bidderDAO.updateIsSerializedAuctionForBidderIDs(auctionID, null, false);</span>
		} finally {
<span class="nc bnc" id="L2167" title="All 8 branches missed.">			if (serAucDAOCreateNeeded &amp;&amp; serAucDAO != null) {</span>
<span class="nc" id="L2168">				serAucDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L2170" title="All 8 branches missed.">			if (bidderDAOCreateNeeded &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L2171">				bidderDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L2174">	}</span>

	/**
	 * @param sbAuction
	 */
	private void assignDefaultsForAuctionVO(ShiftBidAuction sbAuction) throws Exception {
<span class="nc bnc" id="L2180" title="All 4 branches missed.">		assert sbAuction.getSPID() != null : &quot;sbAuction.getSPID() != null&quot;;</span>
<span class="nc bnc" id="L2181" title="All 2 branches missed.">		if (sbAuction.getCreationTime() == null) {</span>
<span class="nc" id="L2182">			sbAuction.setCreationTime(new Date());</span>
		}
<span class="nc bnc" id="L2184" title="All 2 branches missed.">		if (sbAuction.getAuctionDeadLine() == null) {</span>
<span class="nc" id="L2185">			sbAuction.setDeadlineDate(sbAuction.getStartTime());</span>
		}
<span class="nc bnc" id="L2187" title="All 4 branches missed.">		assert sbAuction.getName() != null : &quot;sbAuction.getName() != null;&quot;;</span>
		// isForSingleShifts: boolean
<span class="nc bnc" id="L2189" title="All 2 branches missed.">		if (sbAuction.getCreatorID() == null) {</span>
<span class="nc" id="L2190">			sbAuction.setCreatorID(RequestUtil.getLoginUserID(m_sessionContext));</span>
		}
		// isNativeOrganization: boolean
		// isScored: boolean
		// can't distinguish between null and 0. In either case reset it to 0.
<span class="nc bnc" id="L2195" title="All 2 branches missed.">		if (sbAuction.getBonusForNoBidsAccepted() == 0) {</span>
<span class="nc" id="L2196">			sbAuction.setBonusForNoBidsAccepted(0);</span>
		}
<span class="nc" id="L2198">		sbAuction.getSetters().setNumOfBiddableScheduleInstances(0);</span>
<span class="nc" id="L2199">		sbAuction.getSetters().setNumBidders(0);</span>
<span class="nc" id="L2200">		sbAuction.setStatus(ShiftBidAuction.STATUS_OPEN_FOR_BIDDING);</span>
<span class="nc bnc" id="L2201" title="All 4 branches missed.">		assert sbAuction.getStartTime() != null : &quot;sbAuction.getStartTime() != null&quot;;</span>
<span class="nc bnc" id="L2202" title="All 4 branches missed.">		assert sbAuction.getEndTime() != null : &quot;sbAuction.getEndTime() != null&quot;;</span>
<span class="nc bnc" id="L2203" title="All 4 branches missed.">		assert sbAuction.getOptMethods().getCampaignID() != null : &quot;sbAuction.getOptMethods().getCampaignID() != null&quot;;</span>
<span class="nc" id="L2204">	}</span>

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 * @param sbAuctionDAO
	 * @param bidderDAO
	 * @throws Exception
	 */
	private void validateAuction(ShiftBidAuction givenSBAuctionVO, ShiftBidAuction origSBAuctionFromDB, int actionType,
			ShiftBidAuctionDAO sbAuctionDAO, ShiftBidderDAO bidderDAO) throws Exception {
<span class="nc bnc" id="L2215" title="All 2 branches missed.">		boolean daoCreateNeeded = (sbAuctionDAO == null);</span>
<span class="nc bnc" id="L2216" title="All 2 branches missed.">		boolean daoCreateNeeded2 = (bidderDAO == null);</span>

		try {
			// common validations
			// current time not past the auction deadline
			// TODO: BiddableSchedlues associated with auction are valid (done
			// if detail level is sufficent to validate)
			// TODO: validate cached columns such as NumOfBiddableSchedules etc,
			// SP start and SP end time
<span class="nc" id="L2225">			validateAuctionPrivilege(givenSBAuctionVO, actionType);</span>
<span class="nc" id="L2226">			validateAuctionNotExpired(givenSBAuctionVO, actionType);</span>

			// validations for create
			// an auction does not already exist for same SPID
			// an auction with same name does not already exist.
			// auction deadline must be earlier than SP start.
<span class="nc bnc" id="L2232" title="All 2 branches missed.">			if (actionType == RequestUtil.ACTION_CREATE) {</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">				if (sbAuctionDAO == null) {</span>
<span class="nc" id="L2234">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L2236" title="All 2 branches missed.">				if (bidderDAO == null) {</span>
<span class="nc" id="L2237">					bidderDAO = new ShiftBidderDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc" id="L2239">				Collection&lt;ShiftBidAuction&gt; sbAuctions = sbAuctionDAO.getAuctionsForSPID(givenSBAuctionVO.getSPID(), ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L2241">				validateAuctionNoOtherAuctionForSP(sbAuctions, givenSBAuctionVO, actionType);</span>
<span class="nc" id="L2242">				validateAuctionNotDuplicateName(givenSBAuctionVO, actionType, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>
<span class="nc" id="L2243">				validateAuctionDeadlineBeforeSPStart(sbAuctionDAO, givenSBAuctionVO, null, actionType);</span>
<span class="nc" id="L2244">				validateAuctionNoOpenRequestsForSP(bidderDAO, sbAuctions, givenSBAuctionVO, actionType, LicenseUtil.isAdvancedRMLicense());</span>
			}

			// validations on updates
			// same name auction does not exist
			// validate status transitions
			// udpated deadline must be earlier than SP start.
<span class="nc bnc" id="L2251" title="All 2 branches missed.">			if (actionType == RequestUtil.ACTION_UPDATE) {</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">				if (sbAuctionDAO == null) {</span>
<span class="nc" id="L2253">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L2255" title="All 2 branches missed.">				if (bidderDAO == null) {</span>
<span class="nc" id="L2256">					bidderDAO = new ShiftBidderDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L2258" title="All 2 branches missed.">				if (origSBAuctionFromDB == null) {</span>
<span class="nc" id="L2259">					origSBAuctionFromDB = sbAuctionDAO.getAuctionByID(givenSBAuctionVO.getID(),</span>
							ShiftBidAuction.DL_BASIC);
				}
<span class="nc" id="L2262">				Collection&lt;ShiftBidAuction&gt; sbAuctions = sbAuctionDAO.getAuctionsForSPID(givenSBAuctionVO.getSPID(), ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L2264">				validateAuctionNotDuplicateName(givenSBAuctionVO, actionType, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>
<span class="nc" id="L2265">				validateAuctionStateTransition(sbAuctionDAO, givenSBAuctionVO, origSBAuctionFromDB, actionType);</span>
<span class="nc" id="L2266">				validateAuctionDeadlineBeforeSPStart(sbAuctionDAO, givenSBAuctionVO, origSBAuctionFromDB, actionType);</span>
<span class="nc" id="L2267">				validateAuctionNoOpenRequestsForSP(bidderDAO, sbAuctions, givenSBAuctionVO, actionType, LicenseUtil.isAdvancedRMLicense());</span>
			}

			// validations on fetches

			// validations on deletes
		} finally {
<span class="nc bnc" id="L2274" title="All 8 branches missed.">			if (daoCreateNeeded2 &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L2275">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L2277" title="All 8 branches missed.">			if (daoCreateNeeded &amp;&amp; sbAuctionDAO != null) {</span>
<span class="nc" id="L2278">				sbAuctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L2281">	}</span>


	private void validateAuctionNoOtherAuctionForSP(Collection&lt;ShiftBidAuction&gt; sbAuctions, ShiftBidAuction sbAuction,
			int actionType) throws Exception {
<span class="nc bnc" id="L2286" title="All 2 branches missed.">		if (actionType != RequestUtil.ACTION_CREATE) {</span>
<span class="nc" id="L2287">			return;</span>
		}

<span class="nc" id="L2290">		ID spID = sbAuction.getSPID();</span>

<span class="nc" id="L2292">		boolean canCreate = canCreateNewAuctionForSameSP(sbAuction, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>

<span class="nc bnc" id="L2294" title="All 2 branches missed.">		if (!canCreate) {</span>
<span class="nc" id="L2295">			throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_EXISTS_FOR_SP,</span>
					RmEjbLogBundleKey.AUC_ALREADY_EXISTS_FOR_SP, new Object[] { spID }, m_cat);
		}
<span class="nc" id="L2298">	}</span>

	private boolean canCreateNewAuctionForSameSP(ShiftBidAuction newAuction, Collection&lt;ShiftBidAuction&gt; existingAuctionsOnSameSP, boolean hasAdvancedRMLicense) {
		boolean canCreateNewAuction;

<span class="nc bnc" id="L2303" title="All 2 branches missed.">		if (!hasAdvancedRMLicense) {</span>
<span class="nc" id="L2304">			canCreateNewAuction = existingAuctionsOnSameSP.isEmpty();</span>
<span class="nc bnc" id="L2305" title="All 2 branches missed.">		} else if (newAuction.getIsAuctionOpen()) {</span>
<span class="nc" id="L2306">			canCreateNewAuction = true;</span>
<span class="nc bnc" id="L2307" title="All 2 branches missed.">			for (ShiftBidAuction auction : existingAuctionsOnSameSP) {</span>
<span class="nc bnc" id="L2308" title="All 2 branches missed.">				if (!auction.isStatusClosed()) {</span>
<span class="nc" id="L2309">					canCreateNewAuction = false;</span>
<span class="nc" id="L2310">					break;</span>
				}
<span class="nc" id="L2312">			}</span>
		} else {
<span class="nc" id="L2314">			canCreateNewAuction = true;</span>
		}

<span class="nc" id="L2317">		return canCreateNewAuction;</span>
	}

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 */
	private void validateAuctionNotExpired(ShiftBidAuction givenSBAuctionVO, int actionType) throws Exception {
		// if action != 'update' and given auction's deadline has expired.
		// Updates to expired
		// auctions are allowed so that the 'expiration date' can be updated.
<span class="nc bnc" id="L2328" title="All 4 branches missed.">		if (actionType != RequestUtil.ACTION_UPDATE &amp;&amp; givenSBAuctionVO.getAuctionDeadLine().before(new Date())) {</span>
<span class="nc" id="L2329">			throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_HAS_EXPIRED,</span>
					RmEjbLogBundleKey.AUC_HAS_EXPIRED,
<span class="nc" id="L2331">					new Object[] { givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
		}
<span class="nc" id="L2333">	}</span>

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 */
	private void validateAuctionPrivilege(ShiftBidAuction givenSBAuctionVO, int actionType) {
		// TODO Auto-generated method stub

<span class="nc" id="L2342">	}</span>

	/**
	 * @param sbAuctionDAO
	 * @param givenSBAuctionVO
	 * @param auctionVOBeforeUpdate
	 * @param actionType
	 */
	private void validateAuctionStateTransition(ShiftBidAuctionDAO sbAuctionDAO, ShiftBidAuction givenSBAuctionVO,
			ShiftBidAuction auctionVOBeforeUpdate, int actionType) {
		// TODO Auto-generated method stub

<span class="nc" id="L2354">	}</span>

	/**
	 * @param sbAuctionDAO
	 * @param givenSBAuctionVO
	 * @param auctionVOBeforeUpdate
	 * @param actionType
	 */
	private void validateAuctionDeadlineBeforeSPStart(ShiftBidAuctionDAO sbAuctionDAO, ShiftBidAuction givenSBAuctionVO,
			ShiftBidAuction auctionVOBeforeUpdate, int actionType) throws Exception {
<span class="nc" id="L2364">		Date givenSBAuctionDeadline = givenSBAuctionVO.getAuctionDeadLine();</span>
<span class="nc bnc" id="L2365" title="All 2 branches missed.">		if (actionType == RequestUtil.ACTION_UPDATE) {</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">			if (givenSBAuctionDeadline.after(auctionVOBeforeUpdate.getStartTime())) {</span>
<span class="nc" id="L2367">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_DEADLINE_AFTER_SP_START,</span>
						RmEjbLogBundleKey.AUC_DEADLINE_AFTER_SP_START,
<span class="nc" id="L2369">						new Object[] { givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
			}
<span class="nc bnc" id="L2371" title="All 2 branches missed.">		} else if (actionType == RequestUtil.ACTION_CREATE) {</span>
<span class="nc bnc" id="L2372" title="All 2 branches missed.">			if (givenSBAuctionDeadline.after(givenSBAuctionVO.getStartTime())) {</span>
<span class="nc" id="L2373">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_DEADLINE_AFTER_SP_START,</span>
						RmEjbLogBundleKey.AUC_DEADLINE_AFTER_SP_START,
<span class="nc" id="L2375">						new Object[] { givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
			}
		}
<span class="nc" id="L2378">	}</span>

	private void validateAuctionNotDuplicateName(ShiftBidAuction givenSBAuctionVO, int actionType,
			Collection&lt;ShiftBidAuction&gt; sbAuctions, boolean hasAdvancedRMLicense) throws RmHardValidationException {
<span class="nc bnc" id="L2382" title="All 2 branches missed.">		if (!hasAdvancedRMLicense) {</span>
<span class="nc" id="L2383">			ShiftBidAuction auctionFromDB = null;</span>
<span class="nc bnc" id="L2384" title="All 2 branches missed.">			if (!sbAuctions.isEmpty()) {</span>
<span class="nc" id="L2385">				auctionFromDB = sbAuctions.iterator().next();</span>
			}

<span class="nc bnc" id="L2388" title="All 6 branches missed.">			if (!sbAuctions.isEmpty()</span>
					&amp;&amp; ((actionType == RequestUtil.ACTION_CREATE) || (actionType == RequestUtil.ACTION_UPDATE
<span class="nc bnc" id="L2390" title="All 2 branches missed.">							&amp;&amp; !auctionFromDB.getID().equals(givenSBAuctionVO.getID())))) {</span>
<span class="nc" id="L2391">				throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.AUC_WITH_SAME_NAME_EXISTS,</span>
<span class="nc" id="L2392">						givenSBAuctionVO.getName(), m_cat);</span>
			}
<span class="nc bnc" id="L2394" title="All 2 branches missed.">		} else if (givenSBAuctionVO.isStatusOpen()) {</span>
			// has Advanced RM license

			// other auctions must be closed
<span class="nc bnc" id="L2398" title="All 2 branches missed.">			for (ShiftBidAuction auction : sbAuctions) {</span>
<span class="nc bnc" id="L2399" title="All 4 branches missed.">				if (auction.isStatusOpen() &amp;&amp; !auction.getID().equals(givenSBAuctionVO.getID())) {</span>
<span class="nc" id="L2400">					throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_EXISTS_FOR_SP, m_cat);</span>
				}
<span class="nc" id="L2402">			}</span>
		}
<span class="nc" id="L2404">	}</span>

	/**
	 * Throws exception if there are any pending or escalated requests belong to other auctions (which are for the same SP)
	 */
	private void validateAuctionNoOpenRequestsForSP(ShiftBidderDAO bidderDAO, Collection&lt;ShiftBidAuction&gt; sbAuctions, ShiftBidAuction givenSBAuctionVO, int actionType, boolean hasAdvancedRMLicense)
			throws Exception {

<span class="nc bnc" id="L2412" title="All 4 branches missed.">		if (hasAdvancedRMLicense &amp;&amp; givenSBAuctionVO.isStatusOpen()) {</span>
			// Find original auction and other auction IDs from database
<span class="nc" id="L2414">			ShiftBidAuction originalAuction = null;</span>
<span class="nc" id="L2415">			Collection&lt;ID&gt; otherAuctionIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">			for (ShiftBidAuction auction : sbAuctions) {</span>
<span class="nc bnc" id="L2417" title="All 2 branches missed.">				if (!auction.getID().equals(givenSBAuctionVO.getID())) {</span>
<span class="nc" id="L2418">					otherAuctionIDs.add(auction.getID());</span>
				} else {
<span class="nc" id="L2420">					originalAuction = auction;</span>
				}
<span class="nc" id="L2422">			}</span>
<span class="nc bnc" id="L2423" title="All 4 branches missed.">			if (originalAuction == null || !originalAuction.isStatusOpen()) {</span>
				// We check for pending requests when creating a new auction
				// or when an existing auction status is being updated from closed to open
<span class="nc" id="L2426">				Collection&lt;ID&gt; employeeIDs = bidderDAO.getEmployeeIDsByAuctionAndRequestStatus(otherAuctionIDs,</span>
						new String[] {RequestAuditTrail.STATUS_PENDING, RequestAuditTrail.STATUS_ESCALATED});

<span class="nc bnc" id="L2429" title="All 2 branches missed.">				if (!employeeIDs.isEmpty()) {</span>
<span class="nc" id="L2430">					throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_PENDING_REQUESTS_FOR_SP,</span>
<span class="nc" id="L2431">							RmEjbLogBundleKey.AUC_PENDING_REQUESTS_FOR_SP, new Object[] { givenSBAuctionVO.getSPID() }, m_cat);</span>
				}
			}
		}
<span class="nc" id="L2435">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateAuction(com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	protected void _updateAuction(ShiftBidAuction updatedAuctionVO, ShiftBidAuction origAuctionVO,
			ShiftBidAuctionDAO auctionDAO) throws Exception {
<span class="nc bnc" id="L2442" title="All 2 branches missed.">		boolean DAOCreateNeeded = auctionDAO == null;</span>
<span class="nc" id="L2443">		ShiftBidderDAO bidderDAO = null;</span>
		try {
<span class="nc bnc" id="L2445" title="All 2 branches missed.">			if (auctionDAO == null) {</span>
<span class="nc" id="L2446">				auctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
			}
<span class="nc" id="L2448">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L2450">			validateAuction(updatedAuctionVO, origAuctionVO, RequestUtil.ACTION_UPDATE, auctionDAO, bidderDAO);</span>

<span class="nc" id="L2452">			auctionDAO.updateAuctions(Collections.singletonList(updatedAuctionVO));</span>
		} finally {
<span class="nc bnc" id="L2454" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L2455">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L2457" title="All 8 branches missed.">			if (auctionDAO != null &amp;&amp; DAOCreateNeeded) {</span>
<span class="nc" id="L2458">				auctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L2461">	}</span>

	protected void _updateAuctionByID(ID auctionID, int fieldIndex, Object fieldValue, ShiftBidAuctionDAO auctionDAO)
			throws Exception {
<span class="nc" id="L2465">		boolean auctionDAOAllocated = false;</span>
<span class="nc" id="L2466">		ShiftBidderDAO bidderDAO = null;</span>
		try {
<span class="nc bnc" id="L2468" title="All 2 branches missed.">			if (auctionDAO == null) {</span>
<span class="nc" id="L2469">				auctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2470">				auctionDAOAllocated = true;</span>
			}
<span class="nc" id="L2472">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L2474">			ShiftBidAuction origAuctionFromDB = auctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L2476">			ShiftBidAuction updatedAuction = (ShiftBidAuction) origAuctionFromDB.clone();</span>
<span class="nc bnc" id="L2477" title="All 2 branches missed.">			if (updatedAuction == null) {</span>
<span class="nc" id="L2478">				throw RequestUtil.createRmException(RmEjbLogBundleKey.AUC_NOT_FOUND, auctionID, m_cat);</span>
			}

			// setAuctionField(auction, updateFieldDesc);
<span class="nc" id="L2482">			updatedAuction.setFieldValue(fieldIndex, fieldValue);</span>

<span class="nc" id="L2484">			validateAuction(updatedAuction, origAuctionFromDB, RequestUtil.ACTION_UPDATE, auctionDAO, bidderDAO);</span>

<span class="nc" id="L2486">			auctionDAO.updateAuctions(Collections.singletonList(updatedAuction));</span>
		} finally {
<span class="nc bnc" id="L2488" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L2489">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L2491" title="All 8 branches missed.">			if (auctionDAO != null &amp;&amp; auctionDAOAllocated) {</span>
<span class="nc" id="L2492">				auctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L2495">	}</span>

	/**
	 * @param auction
	 * @return
	 */
	private Collection compileShiftBiddersForAuction(ShiftBidAuction auction, SchedulingPeriod schedPeriod,
			CampaignManager campMgr, ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc" id="L2504">		Collection empIDs = getEmpIDsForSP(schedPeriod.getCampaignID(), schedPeriod.getStartTime(),</span>
<span class="nc" id="L2505">				schedPeriod.getEndTime(), schedPeriod.getID(), campMgr);</span>

<span class="nc" id="L2507">		return compileShiftBiddersForAuction(empIDs, auction, bidderDAO);</span>
	}

	private Collection compileShiftBiddersForAuction(Collection empIDs, ShiftBidAuction auction,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc" id="L2513">		ID auctionID = auction.getID();</span>

<span class="nc" id="L2515">		Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(empIDs, auction, bidderDAO);</span>

<span class="nc" id="L2517">		Collection shiftBidders = new ArrayList(empIDs.size());</span>
<span class="nc" id="L2518">		Collection&lt;ID&gt; addedBidders = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2519" title="All 2 branches missed.">		for (Iterator iter = empIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2520">			ID bidderEmpID = (ID) iter.next();</span>

<span class="nc" id="L2522">			ShiftBidder shiftBidder = new ShiftBidder(ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L2523">			shiftBidder.getSetters().setShiftBidAuctionID(auctionID);</span>
<span class="nc" id="L2524">			shiftBidder.setBonusThisAuction(0);</span>

<span class="nc bnc" id="L2526" title="All 2 branches missed.">			shiftBidder.getSetters().setStatus(unavailableEmpIDs.contains(bidderEmpID)</span>
					? ShiftBidder.STATUS_UNAVAILABLE : ShiftBidder.STATUS_NOT_ADDED);
<span class="nc" id="L2528">			shiftBidder.getSetters().setEmployeeID(bidderEmpID);</span>

<span class="nc" id="L2530">			shiftBidder.setDeadlineDate(auction.getAuctionDeadLine());</span>
<span class="nc" id="L2531">			shiftBidder.getSetters().setIsSerializedAuctionBidder(false);</span>

<span class="nc bnc" id="L2533" title="All 2 branches missed.">			if (!addedBidders.contains(bidderEmpID)) {</span>
<span class="nc" id="L2534">				shiftBidders.add(shiftBidder);</span>
<span class="nc" id="L2535">				addedBidders.add(bidderEmpID);</span>
			}
<span class="nc" id="L2537">		}</span>

<span class="nc" id="L2539">		return shiftBidders;</span>
	}

	private Collection getEmpIDsForSP(ID aucCampID, Date aucStartTime, Date aucEndTime, ID spID,
			CampaignManager campMgr) throws BbmFinderException, RemoteException, BbmEJBCreateException {

		// get employees for the given SchedulingProfile (SP)
<span class="nc bnc" id="L2546" title="All 2 branches missed.">		campMgr = (campMgr == null) ? WfmManagerFactory.getCampaignManager() : campMgr;</span>

<span class="nc" id="L2548">		Collection campWorkResources = campMgr.getCampaignWorkResourceAssignments(aucCampID, aucStartTime, aucEndTime);</span>
<span class="nc" id="L2549">		m_cat.debug(&quot;# of workresources in SP: SPID, #: &quot; + spID + ',' + campWorkResources.size());</span>

		// get list of employee IDs from CampaignWorkResource collection
<span class="nc" id="L2552">		Collection empIDs = RequestUtil.getListOfFieldValuesFromVOBases(campWorkResources,</span>
				CampaignWorkResourceFieldInfo.CAMPAIGNWORKRESOURCE_WORKRESOURCEID);

<span class="nc" id="L2555">		return empIDs;</span>
	}

	// private Set getEmpIDsForAuctionID(ID aucID, ShiftBidderDAO bidderDAO)
	// throws Exception {
	// boolean bidderDAONeedsCreate = (bidderDAO == null);
	//
	// try {
	// bidderDAO = (bidderDAONeedsCreate)?new
	// ShiftBidderDAO(ShiftBidder.DL_BASIC):bidderDAO;
	//
	// Collection empIDs = bidderDAO.getEmpIDsForAuctionID(aucID);
	//
	// Set empIDsSet = new HashSet(empIDs.size() * 2);
	// empIDsSet.addAll(empIDs);
	//
	// return empIDsSet;
	// } finally {
	// if (bidderDAONeedsCreate) bidderDAO.cleanUp();
	// }
	// }
	//
	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getBiddableSchedulesByIDs(java.util.Collection,
	 * long)
	 */
	@Override
	public Collection getBiddableSchedulesByIDs(Collection biddableSchedIDs, ID bidderID, boolean preserveOrder,
			long detailLevel) throws RmException, RmHardValidationException {

<span class="nc" id="L2588">		String _method_ = &quot;getBiddableSchedulesByIDs&quot;;</span>
<span class="nc" id="L2589">		methodStart(_method_, biddableSchedIDs, new Long(detailLevel));</span>

<span class="nc" id="L2591">		BiddableScheduleDAO bidSchedDAO = null;</span>
<span class="nc" id="L2592">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2593">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2595">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2597">			bidSchedDAO = new BiddableScheduleDAO(detailLevel);</span>

<span class="nc" id="L2599">			Collection bidScheds = bidSchedDAO.getBiddableSchedulesByIDs(biddableSchedIDs, preserveOrder, detailLevel);</span>

			// elements in bidScheds will be replaced with their updated
			// versions (updated during validation).
			// TODO: VBS: can this change the order of the passed bidScheds
			// (since it updates the passed collection if changes where made
			// during validation).
<span class="nc" id="L2606">			ShiftBidAuctionUtil.validateBiddableScheds(bidSchedDAO, bidScheds, detailLevel, RequestUtil.ACTION_FETCH,</span>
					true, false);

			// processDetailLevel for all shiftBidScheds.
<span class="nc" id="L2610">			processDetailLevelForBidScheds(bidScheds, bidderID, bidSchedDAO, detailLevel);</span>

<span class="nc" id="L2612">			return bidScheds;</span>
<span class="nc" id="L2613">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L2616">			handleException(e);</span>
<span class="nc" id="L2617">			throw e;</span>
<span class="nc" id="L2618">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2629">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2630">			throw e;</span>
<span class="nc" id="L2631">		} catch (Exception e) {</span>
<span class="nc" id="L2632">			handleException(e); // TODO: is transaction supported?</span>
<span class="nc" id="L2633">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2635" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2636">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2638" title="All 4 branches missed.">			if (bidSchedDAO != null) {</span>
<span class="nc" id="L2639">				bidSchedDAO.cleanUp();</span>
			}
<span class="nc" id="L2641">			methodFinish();</span>
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getBiddableSchedulesForAuction(com.bluepumpkin.
	 * common.datatypes.ID, com.bluepumpkin.common.datatypes.ID,
	 * com.bluepumpkin.common.datatypes.ID, int, int, int, long)
	 *
	 * @param weekRanges An array holding the date ranges for each week in the
	 * Scheduling Period.
	 */
	@Override
	public Pair getBiddableSchedulesForAuction(ID auctionID, ID orgID, ID bidderID, ID emplID, boolean byEmplType, int sortBy, int sortDirection,
			int chunkSize, long detailLevel, TimeRange[] weekRanges) throws RmException, RmHardValidationException {

<span class="nc" id="L2660">		String _method_ = &quot;getBiddableSchedulesForAuction&quot;;</span>
<span class="nc" id="L2661">		methodStart(_method_, auctionID, orgID, bidderID, new Long(detailLevel));</span>
<span class="nc" id="L2662">		BiddableScheduleDAO bidSchedDAO = null;</span>
<span class="nc" id="L2663">		ShiftBidderDAO shiftBidderDAO = null;</span>
<span class="nc" id="L2664">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2665">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2667">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// synchronize the auction with SP using the audit trail in BBM.
<span class="nc" id="L2670">			_scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(auctionID);</span>

<span class="nc" id="L2672">			detailLevel = adjustDetailLevelForBidSched(detailLevel, sortBy);</span>
<span class="nc" id="L2673">			bidSchedDAO = new BiddableScheduleDAO(detailLevel);</span>

<span class="nc" id="L2675">			List bidSchedsForAuction = null;</span>
<span class="nc" id="L2676">			List bidSchedIDsForAuction = null;</span>
<span class="nc bnc" id="L2677" title="All 6 branches missed.">			boolean inMemorySortNeeded = !(sortBy == BiddableSchedule.SORTBY_BONUSASSIGNED</span>
					|| sortBy == BiddableSchedule.SORTBY_NUMBER_AVAIALBLE || sortBy == BiddableSchedule.SORTBY_NONE);

<span class="nc bnc" id="L2680" title="All 4 branches missed.">			if (chunkSize == Integer.MAX_VALUE || inMemorySortNeeded) {</span>
				// casting to List with the knowledge that the method returns an
				// ArrayList. If violated,
				// the violation can be detected easily and fixed.
				//
				// fetch all biddableScheds (sorted @ SQL level if possible)
<span class="nc" id="L2686">				bidSchedsForAuction = (List) bidSchedDAO.getBiddableSchedulesForAuction(auctionID, orgID, emplID, byEmplType, sortBy,</span>
						sortDirection, detailLevel);

				// validate fetched bidScheds.
				// elements in bidScheds will be replaced with their updated
				// versions (updated during validation).
				// TODO: VBS: can this change the order of the passed bidScheds
				// (since it updates the passed collection if changes where made
				// during validation).
<span class="nc" id="L2695">				ShiftBidAuctionUtil.validateBiddableScheds(bidSchedDAO, bidSchedsForAuction, detailLevel,</span>
						RequestUtil.ACTION_FETCH, true, true);

				// processDetailLevel for all shiftBidScheds.
<span class="nc" id="L2699">				processDetailLevelForBidScheds(bidSchedsForAuction, bidderID, bidSchedDAO, detailLevel);</span>

<span class="nc bnc" id="L2701" title="All 2 branches missed.">				if (inMemorySortNeeded) {</span>
<span class="nc" id="L2702">					sortBidScheds(bidSchedsForAuction, sortBy, sortDirection, weekRanges);</span>
				}

				// construct collection pair
<span class="nc" id="L2706">				bidSchedIDsForAuction = RequestUtil.getListOfIDsFromVOBases(bidSchedsForAuction);</span>
<span class="nc bnc" id="L2707" title="All 2 branches missed.">				if (chunkSize != Integer.MAX_VALUE) {</span>
<span class="nc" id="L2708">					int numOfBidSchedsNeeded = Math.min(chunkSize, bidSchedsForAuction.size());</span>
					// Note: the subList is backed by the original list. Which
					// means marshalling
					// the sublist back to the caller (as a return value) will
					// marshall the entire
					// original list back.
					// bidSchedsForAuction = bidSchedsForAuction.subList(0,
					// numOfBidSchedsNeeded);
<span class="nc" id="L2716">					bidSchedsForAuction = new ArrayList(bidSchedsForAuction.subList(0, numOfBidSchedsNeeded));</span>
<span class="nc" id="L2717">				}</span>
				// } else { chunkSize != all &amp;&amp; !inMemorySortNeeded
			} else {
				// fetch all bidSched IDs (sorted @ SQL level)
<span class="nc" id="L2721">				bidSchedIDsForAuction = (List) bidSchedDAO.getBiddableScheduleIDsForAuction(auctionID, orgID, bidderID, byEmplType, sortBy,</span>
						sortDirection);

<span class="nc" id="L2724">				int numOfBidScheds = Math.min(chunkSize, bidSchedIDsForAuction.size());</span>
<span class="nc" id="L2725">				bidSchedsForAuction = (List) bidSchedDAO</span>
<span class="nc" id="L2726">						.getBiddableSchedulesByIDs(bidSchedIDsForAuction.subList(0, numOfBidScheds), true, detailLevel);</span>

				// validateBidScheds for returned bidScheds
				// elements in bidScheds will be replaced with their updated
				// versions (updated during validation).
				// TODO: VBS: can this change the order of the passed bidScheds
				// (since it updates the passed collection if changes where made
				// during validation).
<span class="nc" id="L2734">				ShiftBidAuctionUtil.validateBiddableScheds(bidSchedDAO, bidSchedsForAuction, detailLevel,</span>
						RequestUtil.ACTION_FETCH, true, true);

				// process detail level for returned bidScheds.
<span class="nc" id="L2738">				processDetailLevelForBidScheds(bidSchedsForAuction, bidderID, bidSchedDAO, detailLevel);</span>

				// construct collection pair
			}

<span class="nc" id="L2743">			return new Pair(bidSchedIDsForAuction, bidSchedsForAuction);</span>
<span class="nc" id="L2744">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L2747">			handleException(e);</span>
<span class="nc" id="L2748">			throw e;</span>
<span class="nc" id="L2749">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2760">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2761">			throw e;</span>
<span class="nc" id="L2762">		} catch (Exception e) {</span>
<span class="nc" id="L2763">			handleException(e); // TODO: is transaction supported?</span>
<span class="nc" id="L2764">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2766" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2767">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2769" title="All 4 branches missed.">			if (bidSchedDAO != null) {</span>
<span class="nc" id="L2770">				bidSchedDAO.cleanUp();</span>
			}
<span class="nc" id="L2772">			methodFinish();</span>
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getBiddableSchedulesForAuction(com.bluepumpkin.
	 * common.datatypes.ID, com.bluepumpkin.common.datatypes.ID,
	 * com.bluepumpkin.common.datatypes.ID, int, int, int, long)
	 *
	 * @param weekRanges An array holding the date ranges for each week in the
	 * Scheduling Period.
	 */
	@Override
	public Pair getBiddableSchedulesForAuction(ID auctionID, ID orgID, ID bidderID, ID emplID, boolean byEmplType, int[] sortByList,
			int[] sortDirectionList, int chunkSize, long detailLevel, TimeRange[] weekRanges, RmFilterChain filter)
			throws RmException, RmHardValidationException {

<span class="nc" id="L2792">		String _method_ = &quot;getBiddableSchedulesForAuction&quot;;</span>
<span class="nc" id="L2793">		methodStart(_method_, auctionID, orgID, bidderID, new Long(detailLevel));</span>
<span class="nc" id="L2794">		BiddableScheduleDAO bidSchedDAO = null;</span>
<span class="nc" id="L2795">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2796">		boolean cacheEnabled = false;</span>
<span class="nc bnc" id="L2797" title="All 2 branches missed.">		if (filter != null) {</span>
<span class="nc" id="L2798">			filter.setAuctionID(auctionID);</span>
<span class="nc" id="L2799">			filter.setBidderID(bidderID);</span>
<span class="nc" id="L2800">			filter.setOrgID(orgID);</span>
		}

		try {
<span class="nc" id="L2804">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// synchronize the auction with SP using the audit trail in BBM.
<span class="nc" id="L2807">			_scanAuditTrailForPhantomSchedChangesAndSynchWithAuction(auctionID);</span>

<span class="nc" id="L2809">			detailLevel = adjustDetailLevelForBidSched(detailLevel, sortByList);</span>
<span class="nc" id="L2810">			bidSchedDAO = new BiddableScheduleDAO(detailLevel);</span>

<span class="nc" id="L2812">			List bidSchedsForAuction = null;</span>
<span class="nc" id="L2813">			List bidSchedIDsForAuction = null;</span>

			// casting to List with the knowledge that the method returns an
			// ArrayList. If violated,
			// the violation can be detected easily and fixed.
			//
			// fetch all biddableScheds (sorted @ SQL level if possible)
<span class="nc" id="L2820">			bidSchedsForAuction = (List) bidSchedDAO.getBiddableSchedulesForAuction(auctionID, orgID, emplID, byEmplType, sortByList,</span>
					sortDirectionList, detailLevel);

			// validate fetched bidScheds.
			// elements in bidScheds will be replaced with their updated
			// versions (updated during validation).
			// TODO: VBS: can this change the order of the passed bidScheds
			// (since it updates the passed collection if changes where made
			// during validation).
<span class="nc" id="L2829">			ShiftBidAuctionUtil.validateBiddableScheds(bidSchedDAO, bidSchedsForAuction, detailLevel,</span>
					RequestUtil.ACTION_FETCH, true, true);

			// processDetailLevel for all shiftBidScheds.
<span class="nc" id="L2833">			processDetailLevelForBidScheds(bidSchedsForAuction, bidderID, bidSchedDAO, detailLevel);</span>

			//load the unsubmitted preference. just so that the GUI sorts correctly
<span class="nc" id="L2836">			loadUnsubmittedPreference(bidSchedsForAuction, auctionID, bidderID);</span>

<span class="nc" id="L2838">			sortBidScheds(bidSchedsForAuction, sortByList, sortDirectionList, weekRanges);</span>

			// construct collection pair
<span class="nc" id="L2841">			bidSchedIDsForAuction = RequestUtil.getListOfIDsFromVOBases(bidSchedsForAuction);</span>

			//Refactor the list of bidSchedules and their IDs based on filter
<span class="nc bnc" id="L2844" title="All 2 branches missed.">			if (filter != null) {</span>
<span class="nc" id="L2845">				Iterator bidIter = bidSchedsForAuction.iterator();</span>
<span class="nc bnc" id="L2846" title="All 2 branches missed.">				while (bidIter.hasNext()) {</span>
<span class="nc" id="L2847">					BiddableSchedule obj = (BiddableSchedule) bidIter.next();</span>
<span class="nc" id="L2848">					ID objId = obj.getID();</span>
<span class="nc bnc" id="L2849" title="All 2 branches missed.">					if (!filter.filterSchedule(obj)) {</span>
<span class="nc" id="L2850">						bidIter.remove();</span>
<span class="nc" id="L2851">						bidSchedIDsForAuction.remove(objId);</span>
					}
<span class="nc" id="L2853">				}</span>
			}
			//Only marshall the list if the chunkSize is smaller the size of bid schedules
<span class="nc bnc" id="L2856" title="All 4 branches missed.">			if (chunkSize != Integer.MAX_VALUE &amp;&amp; bidSchedsForAuction.size()&gt;chunkSize) {</span>
<span class="nc" id="L2857">					int numOfBidSchedsNeeded = Math.min(chunkSize, bidSchedsForAuction.size());</span>
					// Note: the subList is backed by the original list. Which means
					// marshalling
					// the sublist back to the caller (as a return value) will
					// marshall the entire
					// original list back.
					// bidSchedsForAuction = bidSchedsForAuction.subList(0,
					// numOfBidSchedsNeeded);
<span class="nc" id="L2865">					bidSchedsForAuction = new ArrayList(bidSchedsForAuction.subList(0, numOfBidSchedsNeeded));</span>
			}

<span class="nc" id="L2868">			return new Pair(bidSchedIDsForAuction, bidSchedsForAuction);</span>
<span class="nc" id="L2869">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L2872">			handleException(e);</span>
<span class="nc" id="L2873">			throw e;</span>
<span class="nc" id="L2874">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2885">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2886">			throw e;</span>
<span class="nc" id="L2887">		} catch (Exception e) {</span>
<span class="nc" id="L2888">			handleException(e); // TODO: is transaction supported?</span>
<span class="nc" id="L2889">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2891" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L2892">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2894" title="All 4 branches missed.">			if (bidSchedDAO != null) {</span>
<span class="nc" id="L2895">				bidSchedDAO.cleanUp();</span>
			}
<span class="nc" id="L2897">			methodFinish();</span>
		}
	}

	private void loadUnsubmittedPreference(List&lt;BiddableSchedule&gt; biddableSchedules, ID auctionID, ID bidderID) {
<span class="nc bnc" id="L2902" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L2903">			return;</span>
		}

<span class="nc" id="L2906">		UnsubmittedSchedulePreferenceDao dao = new UnsubmittedSchedulePreferenceDao();</span>
		try {
<span class="nc" id="L2908">			Map&lt;ID, Integer&gt; scheduleIDToPref = dao.getUnsubmittedSchedulePreferenceForBidder(auctionID, bidderID);</span>
<span class="nc bnc" id="L2909" title="All 2 branches missed.">			for (BiddableSchedule biddableSch : biddableSchedules) {</span>
<span class="nc" id="L2910">				biddableSch.setUnsubmittedSortPreferenceForEmployee(scheduleIDToPref.get(biddableSch.getID()));</span>
<span class="nc" id="L2911">			}</span>

		} finally {
<span class="nc" id="L2914">			dao.cleanUp();</span>
<span class="nc" id="L2915">		}</span>

<span class="nc" id="L2917">	}</span>

	private BiddableScheduleComparator getComparator(int sortBy, int sortDirection, TimeRange[] weekRanges)
			throws Exception {
<span class="nc bnc" id="L2921" title="All 4 branches missed.">		Localizer appDefLocalizer = (sortBy == BiddableSchedule.SORTBY_PHANTOMNAME || sortBy == BiddableSchedule.SORTBY_DESCRIPTION)</span>
<span class="nc" id="L2922">				? RequestUtil.getLocalizerForAppDefLocale() : null;</span>

<span class="nc" id="L2924">		Calendar calInOrgTZ = null;</span>
<span class="nc bnc" id="L2925" title="All 2 branches missed.">		if (BiddableSchedule.isSortByCriteriaDay(sortBy)) {</span>
<span class="nc" id="L2926">			ID loginEmpID = RequestUtil.getLoginUserEmpID(m_sessionContext);</span>
<span class="nc" id="L2927">			TimeZone orgTZ = RequestUtil.getTimezoneCurrentForEmployeeID(loginEmpID);</span>
<span class="nc" id="L2928">			calInOrgTZ = Calendar.getInstance(orgTZ);</span>
		}

<span class="nc" id="L2931">		return new BiddableScheduleComparator(sortBy, sortDirection, appDefLocalizer, calInOrgTZ, weekRanges);</span>
	}

	/**
	 * @param bidSchedsForAuction
	 * @param sortBy
	 * @param sortDirection
	 * @param weekRanges
	 *            An array holding the date ranges for each week in the
	 *            Scheduling Period.
	 */
	private void sortBidScheds(List bidSchedsForAuction, int sortBy, int sortDirection, TimeRange[] weekRanges)
			throws Exception {
<span class="nc" id="L2944">		Collections.sort(bidSchedsForAuction, this.getComparator(sortBy, sortDirection, weekRanges));</span>
<span class="nc" id="L2945">	}</span>

	/**
	 * @param bidSchedsForAuction
	 * @param sortBy
	 * @param sortDirection
	 * @param weekRanges
	 *            An array holding the date ranges for each week in the
	 *            Scheduling Period.
	 */
	private void sortBidScheds(List bidSchedsForAuction, int[] sortByList, int[] sortDirectionList,
			TimeRange[] weekRanges) throws Exception {
<span class="nc" id="L2957">		BiddableScheduleComparator comp = null;</span>

<span class="nc bnc" id="L2959" title="All 2 branches missed.">		for (int i = 0; i &lt; sortByList.length; ++i) {</span>
<span class="nc" id="L2960">			int sortBy = sortByList[i];</span>
<span class="nc" id="L2961">			int sortDir = sortDirectionList[i];</span>

<span class="nc bnc" id="L2963" title="All 2 branches missed.">			if (sortBy == BiddableSchedule.SORTBY_NONE) {</span>
<span class="nc" id="L2964">				continue;</span>
			}

<span class="nc" id="L2967">			BiddableScheduleComparator newComp = this.getComparator(sortBy, sortDir, weekRanges);</span>

<span class="nc bnc" id="L2969" title="All 2 branches missed.">			if (comp == null) {</span>
<span class="nc" id="L2970">				comp = newComp;</span>
			} else {
<span class="nc" id="L2972">				comp.addComparator(newComp);</span>
			}

		}

<span class="nc bnc" id="L2977" title="All 2 branches missed.">		if (comp == null) {</span>
<span class="nc" id="L2978">			return;</span>
		}

<span class="nc" id="L2981">		Collections.sort(bidSchedsForAuction, comp);</span>
<span class="nc" id="L2982">	}</span>

	/**
	 * Adjusts the detail level to an adequate level for performing a sort by
	 * the specified 'sortBy' criteria.
	 *
	 * @param sortBy
	 * @return
	 */
	private long adjustDetailLevelForBidSched(long detailLevel, int sortBy) {

<span class="nc bnc" id="L2993" title="All 2 branches missed.">		if (sortBy == BiddableSchedule.SORTBY_PHANTOMNAME) {</span>
<span class="nc" id="L2994">			detailLevel = addDLForShiftAssnsIfNecess(detailLevel, BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL);</span>
<span class="nc" id="L2995">			detailLevel |= BiddableScheduleInstance.DL_EMPLOYEE;</span>
		}

<span class="nc bnc" id="L2998" title="All 2 branches missed.">		if (sortBy == BiddableSchedule.SORTBY_PREFERENCE) {</span>
<span class="nc" id="L2999">			detailLevel |= BiddableSchedule.DL_SHIFT_BID_REQUEST_FOR_SHIFT_BIDDER;</span>
		}

<span class="nc bnc" id="L3002" title="All 2 branches missed.">		if (sortBy == BiddableSchedule.SORTBY_NUMBER_SUBMITTED) {</span>
<span class="nc" id="L3003">			detailLevel |= BiddableSchedule.DL_NUMBER_OF_SHIFTBIDREQUESTS;</span>
		}

<span class="nc bnc" id="L3006" title="All 2 branches missed.">		if (sortBy == BiddableSchedule.SORTBY_BIDRANK) {</span>
<span class="nc" id="L3007">			detailLevel |= BiddableSchedule.DL_BIDRANK_FOR_SHIFTBIDREQUEST;</span>
		}

<span class="nc bnc" id="L3010" title="All 2 branches missed.">		if (sortBy == BiddableSchedule.SORTBY_HOURS) {</span>
<span class="nc" id="L3011">			detailLevel = addDLForShiftAssnsIfNecess(detailLevel, BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL);</span>
		}

<span class="nc bnc" id="L3014" title="All 2 branches missed.">		if (BiddableSchedule.isSortByCriteriaDay(sortBy)) {</span>
<span class="nc" id="L3015">			detailLevel = addDLForShiftAssnsIfNecess(detailLevel, BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL);</span>
		}

<span class="nc" id="L3018">		return detailLevel;</span>
	}

	/**
	 * Adjusts the detail level to an adequate level for performing a sort by
	 * the specified 'sortBy' criteria.
	 *
	 * @param sortBy
	 * @return
	 */
	private long adjustDetailLevelForBidSched(long detailLevel, int[] sortByList) {
<span class="nc" id="L3029">		long newDetailLevel = detailLevel;</span>
<span class="nc bnc" id="L3030" title="All 2 branches missed.">		for (int i = 0; i &lt; sortByList.length; ++i) {</span>
<span class="nc" id="L3031">			newDetailLevel |= this.adjustDetailLevelForBidSched(newDetailLevel, sortByList[i]);</span>
		}

<span class="nc" id="L3034">		return newDetailLevel;</span>
	}

	/**
	 * Add detail level to load associated shift assignments if necessary.
	 *
	 * @param detailLevel
	 * @param l
	 * @return
	 */
	private long addDLForShiftAssnsIfNecess(long detailLevel, long detLevelToAdd) {
		// verify that the detLevel to be added is one of the detail levels
		// related to shift assignment loading.
<span class="nc" id="L3047">		long DL_SASC = BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL;</span>
<span class="nc" id="L3048">		long DL_BSIS = BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES;</span>
<span class="nc bnc" id="L3049" title="All 6 branches missed.">		assert ((detLevelToAdd &amp; DL_SASC) != 0 || (detLevelToAdd &amp; DL_BSIS) != 0) : &quot;detLevelToAdd = &quot; + detLevelToAdd;</span>

		// add DL_SHIFT_ASSIGNMENTS_COLL only if DL_BIDDABLESCHEDULEINSTANCES is
		// not already specified.
<span class="nc bnc" id="L3053" title="All 4 branches missed.">		if ((detLevelToAdd &amp; DL_SASC) != 0 &amp;&amp; (detailLevel &amp; DL_BSIS) == 0) {</span>
<span class="nc" id="L3054">			detailLevel |= DL_SASC;</span>
		}

		// add DL_BIDDABLESCHEDULEINSTANCES irrespective of
		// DL_SHIFT_ASSIGNMENTS_COLL in the passed detail level.
<span class="nc bnc" id="L3059" title="All 2 branches missed.">		if ((detLevelToAdd &amp; DL_BSIS) != 0) {</span>
<span class="nc" id="L3060">			detailLevel |= DL_BSIS;</span>
		}

<span class="nc" id="L3063">		return detailLevel;</span>
	}

	/**
	 * @param bidSchedsForAuction
	 * @param detailLevel
	 */
	private void processDetailLevelForBidScheds(Collection bidSchedsForAuction, ID bidderID,
			BiddableScheduleDAO bidSchedDAO, long detailLevel) throws Exception {

<span class="nc bnc" id="L3073" title="All 2 branches missed.">		for (Iterator bidSchedsIter = bidSchedsForAuction.iterator(); bidSchedsIter.hasNext();) {</span>
<span class="nc" id="L3074">			BiddableSchedule bidSched = (BiddableSchedule) bidSchedsIter.next();</span>

			// set the shiftbidder ID if given
<span class="nc bnc" id="L3077" title="All 2 branches missed.">			if (bidderID != null) {</span>
<span class="nc" id="L3078">				bidSched.getSetters().setShiftBidderID(bidderID);</span>
			}

			// compute rank of this biddable schedule, if shiftBidderID != null
			// &amp;&amp; the detail level is specified.
<span class="nc bnc" id="L3083" title="All 4 branches missed.">			if (bidderID != null &amp;&amp; (detailLevel &amp; BiddableSchedule.DL_BIDRANK_FOR_SHIFTBIDREQUEST) != 0) {</span>
				// fetch all shift bid requests associated with each biddable
				// schedule.
				// rank this shift bidder's bid request among this list of bids.
<span class="nc" id="L3087">				ShiftBidAuctionUtil.computeRankForBiddableSched(bidSched, bidderID, bidSchedDAO);</span>
			}
<span class="nc" id="L3089">		}</span>
<span class="nc" id="L3090">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateBiddableSchedulesForAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection)
	 */
	@Override
	public void updateBiddableSchedulesForAuction(ID auctionID, Collection biddableScheds, Collection descriptionIDs)
			throws RmException, MultiUserException, RmHardValidationException {

<span class="nc" id="L3100">		String _method_ = &quot;updateBiddableSchedulesForAuction&quot;;</span>
<span class="nc" id="L3101">		methodStart(_method_, auctionID, biddableScheds);</span>
<span class="nc" id="L3102">		BiddableScheduleDAO biddableSchedDao = null;</span>
<span class="nc" id="L3103">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3104">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3106">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3108">			biddableSchedDao = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC);</span>

<span class="nc" id="L3110">			Collection biddableSchedsFromDB = getBiddableScheduleVOsVerifyAndUpdate(biddableSchedDao, auctionID,</span>
					biddableScheds, descriptionIDs);
<span class="nc" id="L3112">			biddableSchedDao.updateBiddableSchedulesForAuction(biddableSchedsFromDB);</span>
<span class="nc" id="L3113">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3116">			handleException(e);</span>
<span class="nc" id="L3117">			throw e;</span>
<span class="nc" id="L3118">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3129">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3130">			throw e;</span>
<span class="nc" id="L3131">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3132">			m_cat.error(e, e);</span>
<span class="nc" id="L3133">			handleException(e);</span>
<span class="nc" id="L3134">			throw e;</span>
<span class="nc" id="L3135">		} catch (Exception e) {</span>
<span class="nc" id="L3136">			handleException(e);</span>
<span class="nc" id="L3137">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3139" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3140">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3142" title="All 4 branches missed.">			if (biddableSchedDao != null) {</span>
<span class="nc" id="L3143">				biddableSchedDao.cleanUp();</span>
			}
<span class="nc" id="L3145">			methodFinish();</span>
<span class="nc" id="L3146">		}</span>

<span class="nc" id="L3148">	}</span>

	/**
	 * Update the given biddable schedules in the database.
	 *
	 * @param biddableSchedDAO
	 * @param auctionID
	 * @param biddableSchedVOs
	 *            collection of {@link BiddableSchedule BiddableSchedule}. Only
	 *            the bonus field will is processed for update.
	 * @return
	 * @throws Exception
	 */
	protected Collection getBiddableScheduleVOsVerifyAndUpdate(BiddableScheduleDAO biddableSchedDAO, ID auctionID,
			Collection biddableSchedVOs, Collection descriptionIDs) throws Exception {
<span class="nc bnc" id="L3163" title="All 4 branches missed.">		assert auctionID != null : &quot;auctionID != null&quot;;</span>
<span class="nc bnc" id="L3164" title="All 2 branches missed.">		if (biddableSchedVOs.isEmpty()) {</span>
<span class="nc" id="L3165">			return Collections.EMPTY_LIST;</span>
		}

<span class="nc" id="L3168">		Map IDToBiddableSchedMap = RequestUtil.getMapOfIDsForVOBases(biddableSchedVOs);</span>
<span class="nc" id="L3169">		Collection biddableSchedIDs = IDToBiddableSchedMap.keySet();</span>

<span class="nc" id="L3171">		Collection biddableSchedsFromDB = biddableSchedDAO.getBiddableSchedulesByIDs(biddableSchedIDs, false,</span>
				BiddableSchedule.DL_BASIC);

<span class="nc bnc" id="L3174" title="All 2 branches missed.">		for (Iterator biddableSchedIter = biddableSchedsFromDB.iterator(); biddableSchedIter.hasNext();) {</span>
<span class="nc" id="L3175">			BiddableSchedule biddableSchedFromDB = (BiddableSchedule) biddableSchedIter.next();</span>

			// Verify biddable schedule belongs to the given auction.
<span class="nc bnc" id="L3178" title="All 2 branches missed.">			if (!biddableSchedFromDB.getShiftBidAuctionID().equals(auctionID)) {</span>
<span class="nc" id="L3179">				throw RequestUtil.createRmException(RmEjbLogBundleKey.AUC_BIDSCHED_NOT_BELONG_AUC, auctionID, m_cat);</span>
			}

			// locate the passed BiddableSched object that corresponds to this
			// biddable object loaded from DB
<span class="nc" id="L3184">			BiddableSchedule biddableSchedFromArg = (BiddableSchedule) IDToBiddableSchedMap</span>
<span class="nc" id="L3185">					.get(biddableSchedFromDB.getID());</span>

			// update bonus points
<span class="nc" id="L3188">			biddableSchedFromDB.setBonusPoints(biddableSchedFromArg.getBonusPoints());</span>

			// update description
<span class="nc bnc" id="L3191" title="All 4 branches missed.">			if (descriptionIDs != null &amp;&amp; descriptionIDs.contains((biddableSchedFromDB.getID()))) {</span>
<span class="nc" id="L3192">				biddableSchedFromDB.setDescription(biddableSchedFromArg.getDescription());</span>
			}
<span class="nc" id="L3194">		}</span>

<span class="nc" id="L3196">		return biddableSchedsFromDB;</span>
	}

<span class="fc" id="L3199">	protected static class ShiftBidderComparatorByScore implements Comparator {</span>

		int m_sortDir;

<span class="nc" id="L3203">		ShiftBidderComparatorByScore(int sortDirection) {</span>
<span class="nc" id="L3204">			m_sortDir = sortDirection;</span>
<span class="nc" id="L3205">		}</span>

		/*
		 * (non-Javadoc)
		 *
		 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		@Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L3214">			ShiftBidder bidder1 = (ShiftBidder) o1;</span>
<span class="nc" id="L3215">			ShiftBidder bidder2 = (ShiftBidder) o2;</span>

<span class="nc" id="L3217">			int bidder1Score = bidder1.getOptMethods().getScoreWithBonus();</span>
<span class="nc" id="L3218">			int bidder2Score = bidder2.getOptMethods().getScoreWithBonus();</span>

<span class="nc bnc" id="L3220" title="All 2 branches missed.">			return (m_sortDir == SupportNavigation.SORT_ASCENDING) ? (bidder1Score - bidder2Score)</span>
					: (bidder2Score - bidder1Score);
		}

	}




	@Override
	 public Pair getShiftBiddersForAuction(ID auctionID, ID orgID, boolean allBidders, int sortBy, int sortDirection,
				int chunkSize, ID privIDOrgScoped, long detailLevel) throws RmException, RmHardValidationException {

<span class="nc" id="L3233">		 return getShiftBiddersForAuction( auctionID,  orgID,  allBidders,  sortBy,  sortDirection,</span>
					 chunkSize,  privIDOrgScoped,  detailLevel, false);
	 }

	/*
	 * &lt;p&gt; See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getShiftBiddersForAuction(com.bluepumpkin.common.
	 * datatypes.ID, com.bluepumpkin.common.datatypes.ID, int)
	 */
	@Override
	public Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; getShiftBiddersForAuction(ID auctionID, ID orgID, boolean allBidders, int sortBy, int sortDirection,
			int chunkSize, ID privIDOrgScoped, long detailLevel, boolean ignoreOrgsAndPrivileges) throws RmException, RmHardValidationException {

<span class="nc" id="L3249">		String _method_ = &quot;getShiftBiddersForAuction&quot;;</span>
<span class="nc" id="L3250">		methodStart(_method_, auctionID, orgID, new Long(detailLevel));</span>
<span class="nc" id="L3251">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3252">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3253">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3255">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3257">			detailLevel = adjustShiftBidderDetailLevel(detailLevel, sortBy);</span>

			// check for any changes to the employees assocaited with the
			// auction's SP.
<span class="nc" id="L3261">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
			// _checkForAddedOrDeletedShiftBidders(auctionID, bidderDAO, null);

			// get the auction object
<span class="nc" id="L3265">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID,</span>
					ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_CAMPAIGN);


<span class="nc" id="L3269">			Set orgIDsForCampSet = Collections.emptySet();</span>

			// We ignore orgs when we want all orgs and employees in an auction and disregard privileges
			// This is needed to simply show the agent his approval order ranking, so we
			// Are calling this function to sort all bidders.
<span class="nc bnc" id="L3274" title="All 2 branches missed.">			if (!ignoreOrgsAndPrivileges) {</span>
				// get the orgIDs to be used for fetching bidders.
<span class="nc" id="L3276">				orgIDsForCampSet = getOrgIDsForShiftBidderFetch(privIDOrgScoped, orgID, sbAuction);</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">				if (orgIDsForCampSet.isEmpty()) {</span>
<span class="nc" id="L3278">					return m_emptyCollsPair;</span>
				}
			}

<span class="nc bnc" id="L3282" title="All 2 branches missed.">			boolean inMemSortNeeded = sortBy == ShiftBidder.SORTBY_SCORE;</span>
<span class="nc" id="L3283">			List shiftBidders = null;</span>
<span class="nc" id="L3284">			List shiftBidderIDs = null;</span>
<span class="nc bnc" id="L3285" title="All 2 branches missed.">			boolean fetchAllBidders = chunkSize == Integer.MAX_VALUE;</span>


<span class="nc bnc" id="L3288" title="All 6 branches missed.">			if (fetchAllBidders || (!fetchAllBidders &amp;&amp; inMemSortNeeded)) {</span>
				// get all bidders (sort @ SQL level if possible)
				//
				// casting with the knowledge that the returned shiftBidders
				// collection is an ArrayList.
				// A violation of this will be easily detected since this is in
				// the main path of
				// execution.
<span class="nc bnc" id="L3296" title="All 2 branches missed.">				shiftBidders = (List) bidderDAO.getShiftBiddersForAuction(auctionID, orgIDsForCampSet,</span>
						(allBidders) ? -1 : ShiftBidder.STATUS_ADDED, sortBy, sortDirection, detailLevel);

				// process detail level (which may be needed for the in memory
				// sort below).
<span class="nc" id="L3301">				processShiftBidderDetailLevel(sbAuction.getID(), shiftBidders, detailLevel, bidderDAO);</span>

				// apply sorting @ java level if necessary.
<span class="nc bnc" id="L3304" title="All 2 branches missed.">				if (inMemSortNeeded) {</span>
<span class="nc" id="L3305">					sortShiftBidders(shiftBidders, sortBy, sortDirection);</span>
				}

				// get (bidderIDs, bidders) tuple.
<span class="nc" id="L3309">				shiftBidderIDs = RequestUtil.getListOfIDsFromVOBases(shiftBidders);</span>
<span class="nc bnc" id="L3310" title="All 2 branches missed.">				if (!fetchAllBidders) {</span>
<span class="nc" id="L3311">					int numOfBidders = Math.min(shiftBidders.size(), chunkSize);</span>
					// Note: the subList is backed by the original list. Which
					// means marshalling
					// the sublist back to the caller (as a return value) will
					// marshall the entire
					// original list back.
					// shiftBidders = shiftBidders.subList(0, numOfBidders);
<span class="nc" id="L3318">					shiftBidders = new ArrayList(shiftBidders.subList(0, numOfBidders));</span>
<span class="nc" id="L3319">				}</span>
			} else {
				// (chunkSize != all &amp;&amp; inMemorySortNotNeeded)
				// get bidder IDs (sort @ SQL level).
				//
				// casting with the knowledge that the returned shiftBidders
				// collection is an ArrayList.
				// If this is violated, it will be easily detected since this
				// code is in the main path of
				// execution.
<span class="nc bnc" id="L3329" title="All 2 branches missed.">				shiftBidderIDs = (List) bidderDAO.getShiftBidderIDsForAuction(auctionID, orgIDsForCampSet,</span>
						(allBidders) ? -1 : ShiftBidder.STATUS_ADDED, sortBy, sortDirection);

<span class="nc" id="L3332">				int numOfBidderIDs = Math.min(shiftBidderIDs.size(), chunkSize);</span>
				// casting with the knowledge that the returned shiftBidders
				// collection is an ArrayList.
				// A violation of this will be easily detected since this is in
				// the main path of
				// execution.
<span class="nc" id="L3338">				shiftBidders = (List) bidderDAO.getShiftBiddersByIDs(shiftBidderIDs.subList(0, numOfBidderIDs), true,</span>
						detailLevel);

<span class="nc" id="L3341">				processShiftBidderDetailLevel(sbAuction.getID(), shiftBidders, detailLevel, bidderDAO);</span>
			}

<span class="nc" id="L3344">			validateShiftBiddersForFetchActionAndUpdate(shiftBidders, sbAuction, bidderDAO);</span>

			// return the sorted list
<span class="nc" id="L3347">			return new Pair(shiftBidderIDs, shiftBidders);</span>
<span class="nc" id="L3348">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3351">			handleException(e);</span>
<span class="nc" id="L3352">			throw e;</span>
<span class="nc" id="L3353">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3364">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3365">			throw e;</span>
<span class="nc" id="L3366">		} catch (Exception e) {</span>
<span class="nc" id="L3367">			handleException(e); // TODO: transaction supported or not</span>
<span class="nc" id="L3368">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3370" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3371">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3373" title="All 6 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3374">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L3376">			methodFinish();</span>
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getNextShiftBidders(java.util.Collection, long)
	 */
	@Override
	public Collection getNextShiftBidders(ID auctionID, Collection bidderIDs, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L3390">		String _method_ = &quot;getNextShiftBidders&quot;;</span>
<span class="nc" id="L3391">		methodStart(_method_, auctionID, new Integer(bidderIDs.size()), new Long(detailLevel));</span>
<span class="nc" id="L3392">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3393">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3394">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3396">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3398">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>

			// casting with the knowledge that the returned shiftBidders
			// collection is an ArrayList.
			// A violation of this will be easily detected since this is in the
			// main path of
			// execution.
<span class="nc" id="L3405">			Collection shiftBidders = bidderDAO.getShiftBiddersByIDs(bidderIDs, true, detailLevel);</span>

<span class="nc" id="L3407">			processShiftBidderDetailLevel(auctionID, shiftBidders, detailLevel, bidderDAO);</span>

			// get the auction object
<span class="nc" id="L3410">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID,</span>
					ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_CAMPAIGN);

			// validate fetched shiftBidders
<span class="nc" id="L3414">			validateShiftBiddersForFetchActionAndUpdate(shiftBidders, sbAuction, bidderDAO);</span>

<span class="nc" id="L3416">			return shiftBidders;</span>
<span class="nc" id="L3417">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3420">			handleException(e);</span>
<span class="nc" id="L3421">			throw e;</span>
<span class="nc" id="L3422">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3433">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3434">			throw e;</span>
<span class="nc" id="L3435">		} catch (Exception e) {</span>
<span class="nc" id="L3436">			handleException(e); // TODO: transaction supported or not</span>
<span class="nc" id="L3437">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3439" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3440">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3442" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3443">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L3445">			methodFinish();</span>
		}
	}

	/**
	 * &lt;p&gt;
	 * See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getShiftBidderForEmpID(com.bluepumpkin.common.datatypes.ID,
	 *      com.bluepumpkin.common.datatypes.ID, long)
	 */
	@Override
	public ShiftBidder getShiftBidderForEmpID(ID empID, ID auctionID, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L3461">		String _method_ = &quot;getShiftBiddersForEmpID&quot;;</span>
<span class="nc" id="L3462">		methodStart(_method_, empID, auctionID, new Long(detailLevel));</span>
<span class="nc" id="L3463">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3464">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3465">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3467">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// check for any changes to the employees assocaited with the
			// auction's SP.
<span class="nc" id="L3471">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
			// _checkForAddedOrDeletedShiftBidders(auctionID, bidderDAO, null);

<span class="nc" id="L3474">			ShiftBidder shiftBidder = bidderDAO.getShiftBidderForEmpAndAuctionID(empID, auctionID, detailLevel);</span>
<span class="nc bnc" id="L3475" title="All 2 branches missed.">			if (shiftBidder == null) {</span>
<span class="nc" id="L3476">				return shiftBidder;</span>
			}

<span class="nc" id="L3479">			ID bidderID = shiftBidder.getID();</span>

			// get the auction object
<span class="nc" id="L3482">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
<span class="nc" id="L3486">			Collection &lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(Collections.singleton(shiftBidder.getEmployeeID()), sbAuction, bidderDAO);</span>

<span class="nc bnc" id="L3488" title="All 2 branches missed.">			shiftBidder = validateShiftBidderForFetchActionAndUpdate(shiftBidder, bidderDAO, null,</span>
					unavailableEmpIDs) ? shiftBidder : null;

<span class="nc bnc" id="L3491" title="All 2 branches missed.">			if (shiftBidder != null) {</span>
<span class="nc" id="L3492">				processShiftBidderDetailLevel(auctionID, Collections.singletonList(shiftBidder), detailLevel,</span>
						bidderDAO);
			} else {
<span class="nc" id="L3495">				m_cat.debug(&quot;Validtion failed: Removing and not returning shiftBidder: ID = &quot; + bidderID);</span>
			}

<span class="nc" id="L3498">			return shiftBidder;</span>
<span class="nc" id="L3499">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3502">			handleException(e);</span>
<span class="nc" id="L3503">			throw e;</span>
<span class="nc" id="L3504">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3515">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3516">			throw e;</span>
<span class="nc" id="L3517">		} catch (Exception e) {</span>
<span class="nc" id="L3518">			handleException(e);</span>
<span class="nc" id="L3519">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3521" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3522">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3524" title="All 6 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3525">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L3527">			methodFinish();</span>
		}
	}

	/**
	 * Gets the basic ShiftBidder data for the employee and specified auctions.
	 */
	@Override
	@SuppressWarnings(&quot;unchecked&quot;)
	public Collection&lt;ShiftBidder&gt; getBasicShiftBidderForEmpAndAuctions(ID employeeID, Collection&lt;ID&gt; auctionIDs)
			throws RmException {
<span class="nc" id="L3538">		String methodName = &quot;getRawShiftBidderForEmpAndAuctions&quot;;</span>
<span class="nc" id="L3539">		methodStart(methodName, employeeID, auctionIDs);</span>
<span class="nc" id="L3540">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3541">		String setterID = m_className + '.' + methodName;</span>
<span class="nc" id="L3542">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3544">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3546">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L3548">			return bidderDAO.getShiftBidderForEmpAndAuctions(employeeID, auctionIDs, ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L3549">		} catch (Exception e) {</span>
<span class="nc" id="L3550">			handleException(e);</span>
<span class="nc" id="L3551">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3553" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3554">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3556" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3557">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L3559">			methodFinish();</span>
		}
	}

	/**
	 * &lt;p&gt;
	 * See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getShiftBidderByID(com.bluepumpkin.common.datatypes.ID,
	 *      long)
	 */
	@Override
	public ShiftBidder getShiftBidderByID(ID bidderID, long detailLevel) throws RmException, RmHardValidationException {

<span class="nc" id="L3574">		String _method_ = &quot;getShiftBiddersByID&quot;;</span>
<span class="nc" id="L3575">		methodStart(_method_, bidderID, new Long(detailLevel));</span>
<span class="nc" id="L3576">		ShiftBidderDAO bidderDAO = null;</span>

<span class="nc" id="L3578">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3579">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3581">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3583">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
<span class="nc" id="L3584">			ShiftBidder shiftBidder = bidderDAO.getShiftBidderByID(bidderID, detailLevel);</span>

			// get the auction object
<span class="nc" id="L3587">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(shiftBidder.getShiftBidAuctionID(),</span>
					ShiftBidAuction.DL_BASIC);

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
<span class="nc" id="L3592">			Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(Collections.singleton(shiftBidder.getEmployeeID()), sbAuction, bidderDAO);</span>

<span class="nc bnc" id="L3594" title="All 2 branches missed.">			shiftBidder = validateShiftBidderForFetchActionAndUpdate(shiftBidder, bidderDAO, null,</span>
					unavailableEmpIDs) ? shiftBidder : null;

<span class="nc bnc" id="L3597" title="All 2 branches missed.">			if (shiftBidder != null) {</span>
<span class="nc" id="L3598">				processShiftBidderDetailLevel(shiftBidder.getShiftBidAuctionID(),</span>
<span class="nc" id="L3599">						Collections.singletonList(shiftBidder), detailLevel, bidderDAO);</span>
			} else {
<span class="nc" id="L3601">				m_cat.debug(&quot;Validtion failed: Removing and not returning shiftBidder: ID = &quot; + bidderID);</span>
			}

<span class="nc" id="L3604">			return shiftBidder;</span>
<span class="nc" id="L3605">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3608">			handleException(e);</span>
<span class="nc" id="L3609">			throw e;</span>
<span class="nc" id="L3610">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3621">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3622">			throw e;</span>
<span class="nc" id="L3623">		} catch (Exception e) {</span>
<span class="nc" id="L3624">			handleException(e);</span>
<span class="nc" id="L3625">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3627" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3628">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3630" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3631">				bidderDAO.cleanUp();</span>
			}
<span class="nc" id="L3633">			methodFinish();</span>
		}
	}

	/**
	 * Adding shift bidders to an auction involves switching their state from
	 * {@link ShiftBidder#STATUS_NOT_ADDED STATUS_NOT_ADDED} to
	 * {@link ShiftBidder#STATUS_ADDED STATUS_ADDED}
	 *
	 * @param shiftBidderIDs
	 *            ShiftBidders to add to this auction. If 'null', all
	 *            shiftBidders who have not been already added to the auction
	 *            are added.
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#addShiftBiddersToAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection, java.util.Date)
	 */
	@Override
	public void addShiftBiddersToAuction(ID auctionID, Collection shiftBidderIDs, Date deadLine)
			throws RmException, MultiUserException, RmHardValidationException {

<span class="nc" id="L3653">		String _method_ = &quot;addShiftBiddersToAuction&quot;;</span>
<span class="nc" id="L3654">		methodStart(_method_, auctionID, shiftBidderIDs);</span>
<span class="nc" id="L3655">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3656">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
<span class="nc" id="L3657">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3658">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3660">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// fetch the auction object from DB
<span class="nc" id="L3663">			sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L3664">			ShiftBidAuction sbAuc = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

			// // determine if the auction is still open?
			// if (!sbAuc.getIsAuctionOpen()) {
			// throw RequestUtil.createAndLogRmHardValidationException(
			// RmEjbBundleKey.AUC_CANT_ADD_BIDDER_CLOSED_AUC,
			// RmEjbLogBundleKey.AUC_CANT_ADD_BIDDER_CLOSED_AUC,
			// new Object[]{auctionID}, m_cat);
			// }

<span class="nc" id="L3674">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L3676">			Collection updatedBidders = getShiftBidderVOsFromDBUpdateAndValidate(sbAuc, shiftBidderIDs,</span>
					ShiftBidder.STATUS_ADDED, deadLine, bidderDAO);

<span class="nc" id="L3679">			bidderDAO.updateShiftBidders(updatedBidders);</span>
<span class="nc" id="L3680">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3683">			handleException(e);</span>
<span class="nc" id="L3684">			throw e;</span>
<span class="nc" id="L3685">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3696">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3697">			throw e;</span>
<span class="nc" id="L3698">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3699">			m_cat.error(e, e);</span>
<span class="nc" id="L3700">			handleException(e);</span>
<span class="nc" id="L3701">			throw e;</span>
<span class="nc" id="L3702">		} catch (Exception e) {</span>
<span class="nc" id="L3703">			handleException(e);</span>
<span class="nc" id="L3704">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3706" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3707">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3709" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3710">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L3712" title="All 4 branches missed.">			if (sbAuctionDAO != null) {</span>
<span class="nc" id="L3713">				sbAuctionDAO.cleanUp();</span>
			}
<span class="nc" id="L3715">			methodFinish();</span>
<span class="nc" id="L3716">		}</span>
<span class="nc" id="L3717">	}</span>

	/**
	 * Updates the Shift bidder's status from {@link ShiftBidder#STATUS_ADDED
	 * STATUS_ADDED} to {@link ShiftBidder#STATUS_NOT_ADDED STATUS_NOT_ADDED}
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#removeShiftBiddersFromAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection)
	 */
	@Override
	public void removeShiftBiddersFromAuction(ID auctionID, Collection shiftBidderIDs)
			throws RmException, RmHardValidationException, MultiUserException {

<span class="nc" id="L3730">		String _method_ = &quot;removeShiftBiddersFromAuction&quot;;</span>
<span class="nc" id="L3731">		methodStart(_method_, auctionID, shiftBidderIDs);</span>
<span class="nc" id="L3732">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L3733">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
<span class="nc" id="L3734">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3735">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3737">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// fetch the auction object from DB
<span class="nc" id="L3740">			sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L3741">			ShiftBidAuction sbAuc = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

			// // determine if the auction is still open?
			// if (!sbAuc.getIsAuctionOpen()) {
			// throw RequestUtil.createAndLogRmHardValidationException(
			// RmEjbBundleKey.AUC_CANT_REMOVE_BIDDERS_CLOSED_AUC,
			// RmEjbLogBundleKey.AUC_CANT_REMOVE_BIDDERS_CLOSED_AUC,
			// new Object[]{auctionID}, m_cat);
			// }

<span class="nc" id="L3751">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L3753">			Collection updatedBidders = getShiftBidderVOsFromDBUpdateAndValidate(sbAuc, shiftBidderIDs,</span>
					ShiftBidder.STATUS_NOT_ADDED, null, bidderDAO);

<span class="nc" id="L3756">			bidderDAO.updateShiftBidders(updatedBidders);</span>
<span class="nc" id="L3757">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3760">			handleException(e);</span>
<span class="nc" id="L3761">			throw e;</span>
<span class="nc" id="L3762">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3773">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3774">			throw e;</span>
<span class="nc" id="L3775">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3776">			m_cat.error(e, e);</span>
<span class="nc" id="L3777">			handleException(e);</span>
<span class="nc" id="L3778">			throw e;</span>
<span class="nc" id="L3779">		} catch (Exception e) {</span>
<span class="nc" id="L3780">			handleException(e);</span>
<span class="nc" id="L3781">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3783" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3784">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L3786" title="All 4 branches missed.">			if (bidderDAO != null) {</span>
<span class="nc" id="L3787">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L3789" title="All 4 branches missed.">			if (sbAuctionDAO != null) {</span>
<span class="nc" id="L3790">				sbAuctionDAO.cleanUp();</span>
			}
<span class="nc" id="L3792">			methodFinish();</span>
<span class="nc" id="L3793">		}</span>
<span class="nc" id="L3794">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateShiftBiddersForAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection)
	 */
	@Override
	public void updateShiftBiddersForAuction(ID auctionID, Collection givenBidders)
			throws RmException, RmHardValidationException, MultiUserException {

<span class="nc" id="L3804">		String _method_ = &quot;updateShiftBiddersForAuction&quot;;</span>
<span class="nc" id="L3805">		methodStart(_method_, auctionID, givenBidders);</span>
<span class="nc" id="L3806">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3807">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3809">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L3811">			ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(auctionID, givenBidders, null, null);</span>
<span class="nc" id="L3812">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.error(e, e);
<span class="nc" id="L3815">			handleException(e);</span>
<span class="nc" id="L3816">			throw e;</span>
<span class="nc" id="L3817">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			// m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] {
			// &quot;SHIFTSWAPPOSTING&quot; });

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3828">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3829">			throw e;</span>
<span class="nc" id="L3830">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3831">			m_cat.error(e, e);</span>
<span class="nc" id="L3832">			handleException(e);</span>
<span class="nc" id="L3833">			throw e;</span>
<span class="nc" id="L3834">		} catch (Exception e) {</span>
<span class="nc" id="L3835">			handleException(e);</span>
<span class="nc" id="L3836">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3838" title="All 4 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3839">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3841">			methodFinish();</span>
<span class="nc" id="L3842">		}</span>
<span class="nc" id="L3843">	}</span>

	/**
	 * Check to see if a new agent was added or removed from the SP associated
	 * with the auction. If so, make the corr change to the auctin.
	 *
	 * @param givenAucID
	 * @param bidderDAO
	 * @param sbAucDAO
	 * @throws Exception
	 */
	private void _checkForAddedOrDeletedShiftBidders(ID givenAucID, ShiftBidderDAO bidderDAO,
			ShiftBidAuctionDAO sbAucDAO) throws Exception {

<span class="pc bpc" id="L3857" title="1 of 2 branches missed.">		boolean bidderDAOCreateNeeded = (bidderDAO == null);</span>
<span class="pc bpc" id="L3858" title="1 of 2 branches missed.">		boolean sbAucDAOCreateNeeded = (sbAucDAO == null);</span>
		try {
<span class="fc" id="L3860">			long aucDetailLevel = ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_CAMPAIGN</span>
					| ShiftBidAuction.DL_EXCLUDE_EXPIRED_AUCTION;
<span class="pc bpc" id="L3862" title="1 of 2 branches missed.">			sbAucDAO = (sbAucDAOCreateNeeded) ? new ShiftBidAuctionDAO(aucDetailLevel) : sbAucDAO;</span>

<span class="fc" id="L3864">			Collection auctions = null;</span>
<span class="pc bpc" id="L3865" title="1 of 2 branches missed.">			if (givenAucID == null) { // retrieve all aucitons in the system.</span>
<span class="fc" id="L3866">				auctions = sbAucDAO.getAuctionsAll(aucDetailLevel);</span>
			} else {
<span class="nc" id="L3868">				ShiftBidAuction auction = sbAucDAO.getAuctionByID(givenAucID, aucDetailLevel);</span>
<span class="nc" id="L3869">				auctions = Collections.singletonList(auction);</span>
			}

<span class="fc" id="L3872">			CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>

<span class="pc bpc" id="L3874" title="1 of 2 branches missed.">			bidderDAO = bidderDAOCreateNeeded ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>

			// now iterate thru the auctions
<span class="pc bpc" id="L3877" title="1 of 2 branches missed.">			for (Iterator aucIter = auctions.iterator(); aucIter.hasNext();) {</span>
<span class="nc" id="L3878">				ShiftBidAuction sbAuc = (ShiftBidAuction) aucIter.next();</span>
<span class="nc" id="L3879">				ID aucID = sbAuc.getID();</span>

				// get empIDs currently in the auction
<span class="nc" id="L3882">				Collection empIDsForAuc = bidderDAO.getEmpIDsForAuctionID(aucID);</span>

				// get empIDs currently associated with SP
<span class="nc" id="L3885">				Collection empIDsForSP = getEmpIDsForSP(sbAuc.getOptMethods().getCampaign().getID(),</span>
<span class="nc" id="L3886">						sbAuc.getStartTime(), sbAuc.getEndTime(), sbAuc.getSPID(), campMgr);</span>

				// diff the above two sets.
<span class="nc" id="L3889">				Collection[] diffCollecs = RequestUtil.diffObjectLists(empIDsForAuc, empIDsForSP);</span>

				// remove employees from auction if necessary.
<span class="nc" id="L3892">				Collection empIDsToBeRemovedFromAuc = diffCollecs[0];</span>
<span class="nc bnc" id="L3893" title="All 4 branches missed.">				if (empIDsToBeRemovedFromAuc != null &amp;&amp; !empIDsToBeRemovedFromAuc.isEmpty()) {</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3895">						m_cat.debug(&quot;Removing empIDs from auction: : auctinID, IDs = &quot; + aucID + ','</span>
<span class="nc" id="L3896">								+ RmUtil.dumpCollection(empIDsToBeRemovedFromAuc));</span>
					}

<span class="nc" id="L3899">					bidderDAO.deleteShiftBiddersByEmpIDs(aucID, empIDsToBeRemovedFromAuc);</span>
				}

				// add employees to auction if necessary
<span class="nc" id="L3903">				Collection empIDsToBeAddedToAuc = diffCollecs[2];</span>
<span class="nc bnc" id="L3904" title="All 4 branches missed.">				if (empIDsToBeAddedToAuc != null &amp;&amp; !empIDsToBeAddedToAuc.isEmpty()) {</span>
<span class="nc bnc" id="L3905" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3906">						m_cat.debug(&quot;Adding empIDs to auction: auctionID, IDs = &quot; + aucID + ','</span>
<span class="nc" id="L3907">								+ RmUtil.dumpCollection(empIDsToBeAddedToAuc));</span>
					}

<span class="nc" id="L3910">					Collection biddersToBeAdded = compileShiftBiddersForAuction(empIDsToBeAddedToAuc, sbAuc, bidderDAO);</span>
<span class="nc" id="L3911">					bidderDAO.createShiftBidders(biddersToBeAdded);</span>
				}
<span class="nc" id="L3913">			}</span>
		} finally {
<span class="pc bpc" id="L3915" title="6 of 8 branches missed.">			if (bidderDAOCreateNeeded &amp;&amp; bidderDAO != null) {</span>
<span class="pc" id="L3916">				bidderDAO.cleanUp();</span>
			}
<span class="pc bpc" id="L3918" title="6 of 8 branches missed.">			if (sbAucDAOCreateNeeded &amp;&amp; sbAucDAO != null) {</span>
<span class="pc" id="L3919">				sbAucDAO.cleanUp();</span>
			}
		}

<span class="fc" id="L3923">	}</span>

	/**
	 * check if any workresource(s) have been added or deleted to the SP
	 * associated with the auction. If added, the add the employee to auction.
	 * If removed, delete the employee from the auction.
	 */
	@Override
	public void checkForAddedOrDeletedShiftBidders(ID givenAucID) throws RmHardValidationException, RmException {

<span class="fc" id="L3933">		String _method_ = &quot;checkForAddedOrDeletedShiftBidders&quot;;</span>
<span class="fc" id="L3934">		methodStart(_method_, givenAucID);</span>

<span class="fc" id="L3936">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L3937">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L3939">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L3941">			_checkForAddedOrDeletedShiftBidders(givenAucID, null, null);</span>
<span class="nc" id="L3942">		} catch (RmHardValidationException e) {</span>

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L3950">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3951">			throw e;</span>
<span class="nc" id="L3952">		} catch (RmException e) {</span>
<span class="nc" id="L3953">			handleException(e); // rollback transaction.</span>
<span class="nc" id="L3954">			throw e;</span>
<span class="nc" id="L3955">		} catch (Exception e) {</span>
<span class="nc" id="L3956">			handleException(e); // rollback transaction.</span>
<span class="nc" id="L3957">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L3959" title="3 of 4 branches missed.">			if (cacheEnabled) {</span>
<span class="pc" id="L3960">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L3962">			methodFinish();</span>
<span class="fc" id="L3963">		}</span>
<span class="fc" id="L3964">	}</span>

	/**
	 * &lt;li&gt;process {@link ShiftBidder#DL_NUMBER_OF_SHIFTBIDREQUESTS
	 * DL_NUMBER_OF_SHIFTBIDREQUESTS} which determines the # of shift bid
	 * requests for this employee.
	 * &lt;li&gt;compute the bonus and score for the shiftBidders
	 *
	 * @param shiftBidders
	 * @param detailLevel
	 */
	private void processShiftBidderDetailLevel(ID sbAuctionID, Collection shiftBidders, long detailLevel,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc" id="L3978">		ShiftBidRequestDAO sbReqDAO = null;</span>
<span class="nc" id="L3979">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
		try {
<span class="nc bnc" id="L3981" title="All 2 branches missed.">			if (shiftBidders.isEmpty()) {</span>
<span class="nc" id="L3982">				return;</span>
			}

			// for each bidder in the collection.
<span class="nc" id="L3986">			Map bidderIDToNumOfBidReqsMap = null;</span>
<span class="nc" id="L3987">			Map bidderEmpIDToOrgIDMap = null;</span>
<span class="nc" id="L3988">			Map orgIDToOrgSettingCacheMap = null;</span>
<span class="nc" id="L3989">			ShiftBidAuction sbAuction = null;</span>
<span class="nc" id="L3990">			Map methodDataCacheMap = null;</span>
<span class="nc bnc" id="L3991" title="All 2 branches missed.">			for (Iterator shiftBiddersIter = shiftBidders.iterator(); shiftBiddersIter.hasNext();) {</span>
<span class="nc" id="L3992">				ShiftBidder bidder = (ShiftBidder) shiftBiddersIter.next();</span>

<span class="nc" id="L3994">				ID bidderID = bidder.getID();</span>

				// fetch the number of shift bid requests submitted for each
				// shift bidder.
<span class="nc bnc" id="L3998" title="All 2 branches missed.">				if ((detailLevel &amp; ShiftBidder.DL_NUMBER_OF_SHIFTBIDREQUESTS) != 0) {</span>
					// DB fetch is done for all bidders in one shot, during the
					// first execution of this loop.
<span class="nc bnc" id="L4001" title="All 2 branches missed.">					if (bidderIDToNumOfBidReqsMap == null) {</span>
						// get map of shiftBidder ID to shiftBidder object.
<span class="nc" id="L4003">						List bidderIDs = RequestUtil.getListOfIDsFromVOBases(shiftBidders);</span>

<span class="nc" id="L4005">						sbReqDAO = new ShiftBidRequestDAO(ShiftBidRequest.DL_BASIC);</span>
<span class="nc" id="L4006">						bidderIDToNumOfBidReqsMap = sbReqDAO.getNumOfShiftBidRequestsForBidders(bidderIDs);</span>
					}

					// Set the request count for each shift bidder
<span class="nc" id="L4010">					Integer numOfReqs = (Integer) bidderIDToNumOfBidReqsMap.get(bidderID);</span>
<span class="nc bnc" id="L4011" title="All 2 branches missed.">					if (numOfReqs != null) {</span>
<span class="nc" id="L4012">						int numOfReqsInt = numOfReqs.intValue();</span>
<span class="nc" id="L4013">						m_cat.debug(</span>
								&quot;Setting # of bid requests for bidder: ID, number: &quot; + bidderID + ',' + numOfReqsInt);
<span class="nc" id="L4015">						bidder.getSetters().setNumOfShiftBidRequests(numOfReqsInt);</span>
					}
				}

				// compute the accumulted points and score for each shift
				// bidder.
				// currently no separate detailLevel is defined for computing
				// score and bonus for shift bidder.
				// Note: ShiftBidder.DL_EMPLOYEE is also used in
				// getShiftBiddersForAuction() to denote rank shiftBidders by
				// score.
<span class="nc bnc" id="L4026" title="All 2 branches missed.">				if ((detailLevel &amp; ShiftBidder.DL_SHIFTBIDDER_SCORE) != 0) {</span>
					// fetch auction if necessary
<span class="nc bnc" id="L4028" title="All 2 branches missed.">					if (sbAuction == null) {</span>
<span class="nc" id="L4029">						sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L4030">						sbAuction = sbAuctionDAO.getAuctionByID(sbAuctionID, ShiftBidAuction.DL_BASIC);</span>
					}

					// get the bidder employee IDs to orgID map if necessary
<span class="nc bnc" id="L4034" title="All 2 branches missed.">					if (bidderEmpIDToOrgIDMap == null) {</span>
<span class="nc" id="L4035">						List bidderEmpIDs = RequestUtil.getListOfFieldValuesFromVOBases(shiftBidders,</span>
								ShiftBidderFieldInfo.SHIFTBIDDER_I_EMPLOYEEID);

<span class="nc" id="L4038">						bidderEmpIDToOrgIDMap = ValidationUtil.getOrgIDsForEmployeesOnGivenDate(bidderEmpIDs,</span>
<span class="nc" id="L4039">								sbAuction.getStartTime());</span>
					}

					// instantiate cache if necessary. Assume that an SP will
					// not have more 3 orgs.
<span class="nc bnc" id="L4044" title="All 2 branches missed.">					orgIDToOrgSettingCacheMap = (orgIDToOrgSettingCacheMap == null) ? new HashMap(10)</span>
							: orgIDToOrgSettingCacheMap;
<span class="nc bnc" id="L4046" title="All 2 branches missed.">					methodDataCacheMap = (methodDataCacheMap == null) ? new HashMap(10) : methodDataCacheMap;</span>

					// retrieve bidder's org ID from cache.
<span class="nc" id="L4049">					ID bidderEmpID = bidder.getEmployeeID();</span>
<span class="nc" id="L4050">					ID bidderEmpOrgID = (ID) bidderEmpIDToOrgIDMap.get(bidderEmpID);</span>
<span class="nc bnc" id="L4051" title="All 4 branches missed.">					assert bidderEmpOrgID != null : &quot;bidderOrgID != null: bidderEmpID = &quot; + bidderEmpID;</span>

					// compute bonus and score for the shift bidder.
<span class="nc" id="L4054">					ShiftBidAuctionUtil.computeBonusAndScoreWithAndWithoutPoints(null, bidder, sbAuction,</span>
							bidderEmpOrgID, null, orgIDToOrgSettingCacheMap, methodDataCacheMap);
				}
<span class="nc" id="L4057">			}</span>
		} finally {
<span class="nc bnc" id="L4059" title="All 6 branches missed.">			if (sbReqDAO != null) {</span>
<span class="nc" id="L4060">				sbReqDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L4062" title="All 6 branches missed.">			if (sbAuctionDAO != null) {</span>
<span class="nc" id="L4063">				sbAuctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L4066">	}</span>

	/**
	 * &lt;li&gt;Fetch shift bidder VOs for the specified bidder IDs from the DB.
	 * &lt;li&gt;update the specified fields (status and deadline specified as
	 * parameters) for each shift bidder.
	 * &lt;li&gt;validate the updated bidder VO.
	 *
	 * @param sbAuction
	 * @param shiftBidderIDs
	 * @param newStatus
	 * @param newDeadline
	 * @param bidderDao
	 * @return
	 * @throws Exception
	 */
	private List getShiftBidderVOsFromDBUpdateAndValidate(ShiftBidAuction sbAuction, Collection shiftBidderIDs,
			int newStatus, Date newDeadline, ShiftBidderDAO bidderDao) throws Exception {
<span class="nc" id="L4084">		m_cat.debug(&quot;updating shiftBidder collection with: newStatus, newDeadline: &quot; + newStatus + ',' + newDeadline);</span>

<span class="nc" id="L4086">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
		try {
			// load the given shiftBidder IDs from the DB.
<span class="nc" id="L4089">			Collection biddersFromDB = bidderDao.getShiftBiddersByIDs(shiftBidderIDs, false,</span>
<span class="nc" id="L4090">					ShiftBidder.getDetailLevelForValidation());</span>

			// get list of employee IDs for shift Bidder VO.
<span class="nc" id="L4093">			List biddersFromDBEmpIDs = RequestUtil.getListOfFieldValuesFromVOBases(biddersFromDB,</span>
					ShiftBidderFieldInfo.SHIFTBIDDER_I_EMPLOYEEID);

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
			//if the &quot;include schedule employees option is selected in the Auction,
			// then mark the employees which have approved bids in this auction as &quot;Scheduled&quot;
<span class="nc" id="L4100">			Collection &lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(biddersFromDBEmpIDs, sbAuction, bidderDao);</span>


<span class="nc" id="L4103">			List updatedBidders = new ArrayList(biddersFromDB.size());</span>
<span class="nc bnc" id="L4104" title="All 2 branches missed.">			for (Iterator biddersFromDBIter = biddersFromDB.iterator(); biddersFromDBIter.hasNext();) {</span>
<span class="nc" id="L4105">				ShiftBidder bidderFromDB = (ShiftBidder) biddersFromDBIter.next();</span>

				// retrieve the shift bid auction for the given auctionID if
				// necessary. Assuming here that
				// all given shift bidder IDs belong to the same shift bid
				// auction.
<span class="nc bnc" id="L4111" title="All 2 branches missed.">				if (sbAuction == null) {</span>
<span class="nc" id="L4112">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L4113">					sbAuction = sbAuctionDAO.getAuctionByID(bidderFromDB.getShiftBidAuctionID(),</span>
							ShiftBidAuction.DL_BASIC);
				}

				// clone above does a shallow copy except for the
				// ValueObjectBase.m_arrFieldValues. This array
				// is replaced with a newly allocated array and the contents of
				// the orignal array are copied to it.
<span class="nc" id="L4121">				ShiftBidder updatedBidder = (ShiftBidder) bidderFromDB.clone();</span>
				// Note: the Integer object instance to represent 'status' in
				// ValueObjectBase.m_arrFieldValues is shared by updatedBidder
				// and bidderFromDB. The
				// call below replaces this Integer reference in updateBidder.
				// Instead of replacing, if the Integer
				// instance was modified in place, then both updateBidder and
				// bidderFromDB would be
				// referencing the same modified Integer instance which is not
				// what we want.
<span class="nc" id="L4131">				updatedBidder.getSetters().setStatus(newStatus);</span>

<span class="nc" id="L4133">				updatedBidder.setDeadlineDate(newDeadline);</span>

<span class="nc" id="L4135">				ValidationResult hardValResult = ShiftBidAuctionUtil.validateShiftBidderAndUpdate(updatedBidder,</span>
						bidderFromDB, RequestUtil.ACTION_UPDATE, sbAuction, unavailableEmpIDs);

				// TODO: handle better. Must mark the shiftBidder as invalid if
				// failed due to employee expired.
<span class="nc bnc" id="L4140" title="All 2 branches missed.">				if (hardValResult != null) {</span>
<span class="nc bnc" id="L4141" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4142">						String valResMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L4143">								TimeZone.getDefault());</span>

<span class="nc" id="L4145">						m_cat.debug(</span>
<span class="nc" id="L4146">								&quot;Bidder not added to update list: ID, msg: &quot; + updatedBidder.getID() + ',' + valResMsg);</span>
<span class="nc" id="L4147">					}</span>
					// and do not add to the updated list.
				} else {
					// if any soft validation results exist, dump them to the
					// log.
<span class="nc bnc" id="L4152" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4153">						Collection valResults = updatedBidder.getValidationResults(false);</span>
<span class="nc bnc" id="L4154" title="All 2 branches missed.">						for (Iterator valResultsIter = valResults.iterator(); valResultsIter.hasNext();) {</span>
<span class="nc" id="L4155">							ValidationResult softValResult = (ValidationResult) valResultsIter.next();</span>

<span class="nc" id="L4157">							String softValResMsg = softValResult.getLocalizedMessage(</span>
<span class="nc" id="L4158">									RequestUtil.getLocalizerForAppDefLocale(), TimeZone.getDefault());</span>

<span class="nc" id="L4160">							m_cat.debug(&quot;Updated for bidder ID: &quot; + updatedBidder.getID() + ':' + softValResMsg);</span>
<span class="nc" id="L4161">						}</span>
					}

<span class="nc" id="L4164">					updatedBidders.add(updatedBidder);</span>
<span class="nc" id="L4165">					m_cat.debug(&quot;Bidder added to update list: ID: &quot; + updatedBidder.getID());</span>
				}
<span class="nc" id="L4167">			}</span>

<span class="nc" id="L4169">			return updatedBidders;</span>
		} finally {
<span class="nc bnc" id="L4171" title="All 4 branches missed.">			if (sbAuctionDAO != null) {</span>
<span class="nc" id="L4172">				sbAuctionDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * returns true, if validation succeeded. If any updates were made then the
	 * shiftBidder is either updated in the DB or added to the given update
	 * collection (see parameter descriptions). If validation fails, returns
	 * false.
	 *
	 * @param shiftBidder
	 * @param bidderDAO
	 *            if non-null, then the updated shift bidder, after validation,
	 *            will be posted to the DB. If null, ignored.
	 * @param updatedBidders
	 *            if non-null, then the updated shift bidder, after validation,
	 *            will be added to this collection. If null, ignored.
	 * @return if validation succeeds. false otherwise. Also updatedBidders
	 *         collection is modified if non-null. DB udpates are made if
	 *         bidderDAO is non null.
	 * @throws Exception
	 */
	protected boolean validateShiftBidderForFetchActionAndUpdate(ShiftBidder shiftBidder, ShiftBidderDAO bidderDAO,
			Collection updatedBidders, Collection&lt;ID&gt; unavailableEmpIDs) throws Exception {

		// validate the shiftBidder.
<span class="nc" id="L4199">		ValidationResult hardValResult = ShiftBidAuctionUtil.validateShiftBidderAndUpdate(shiftBidder, null,</span>
				RequestUtil.ACTION_FETCH, null, unavailableEmpIDs);

<span class="nc" id="L4202">		boolean isValid = false;</span>
		// if hard validation error.
<span class="nc bnc" id="L4204" title="All 2 branches missed.">		if (hardValResult != null) {</span>
<span class="nc" id="L4205">			String hardValMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L4206">					TimeZone.getDefault());</span>
<span class="nc" id="L4207">			m_cat.debug(&quot;Error when validating shift bidder: &quot; + hardValMsg);</span>

<span class="nc" id="L4209">			isValid = false;</span>
			// No hard validation errors.
<span class="nc" id="L4211">		} else {</span>
			// get soft validation errors
<span class="nc" id="L4213">			Collection valResults = shiftBidder.getValidationResults(false);</span>
			// if any soft validation errors were found (which resulted in a
			// bidder field update)
<span class="nc bnc" id="L4216" title="All 4 branches missed.">			boolean bidderFieldsWereUpdated = (valResults != null &amp;&amp; !valResults.isEmpty());</span>
<span class="nc bnc" id="L4217" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4218">				logBidderValResults(shiftBidder, valResults);</span>
			}

			// post to DB if any updates were done.
<span class="nc bnc" id="L4222" title="All 4 branches missed.">			if (bidderDAO != null &amp;&amp; bidderFieldsWereUpdated) {</span>
<span class="nc" id="L4223">				bidderDAO.updateShiftBidders(Collections.singletonList(shiftBidder));</span>
			}

			// add to updated list if any updates were done
<span class="nc bnc" id="L4227" title="All 4 branches missed.">			if (updatedBidders != null &amp;&amp; bidderFieldsWereUpdated) {</span>
<span class="nc" id="L4228">				updatedBidders.add(shiftBidder);</span>
			}

<span class="nc" id="L4231">			isValid = true;</span>
		}

		// if no hard or soft validation errors
<span class="nc" id="L4235">		return isValid;</span>
	}

	private void logBidderValResults(ShiftBidder shiftBidder, Collection valResults) {
<span class="nc bnc" id="L4239" title="All 2 branches missed.">		for (Iterator valResultsIter = valResults.iterator(); valResultsIter.hasNext();) {</span>
<span class="nc" id="L4240">			ValidationResult softValResult = (ValidationResult) valResultsIter.next();</span>
<span class="nc" id="L4241">			String softValResMsg = softValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L4242">					TimeZone.getDefault());</span>

<span class="nc" id="L4244">			m_cat.debug(&quot;updating shift bidder = &quot; + shiftBidder.getID() + ':' + softValResMsg);</span>
<span class="nc" id="L4245">		}</span>
<span class="nc" id="L4246">	}</span>

	/**
	 * @param detailLevel
	 * @param sortBy
	 * @return
	 */
	private long adjustShiftBidderDetailLevel(long detailLevel, int sortBy) {
<span class="nc bnc" id="L4254" title="All 8 branches missed.">		if (sortBy == ShiftBidder.SORTBY_POINTS || sortBy == ShiftBidder.SORTBY_RANK</span>
				|| sortBy == ShiftBidder.SORTBY_SCORE || sortBy == ShiftBidder.SORTBY_SENIORITY) {
<span class="nc" id="L4256">			detailLevel |= ShiftBidder.DL_EMPLOYEE;</span>
		}

<span class="nc bnc" id="L4259" title="All 2 branches missed.">		if (sortBy == ShiftBidder.SORTBY_SCORE) {</span>
<span class="nc" id="L4260">			detailLevel |= ShiftBidder.DL_SHIFTBIDDER_SCORE;</span>
		}

<span class="nc" id="L4263">		return detailLevel;</span>
	}

	/**
	 * @param shiftBidders
	 * @param sortBy
	 * @param sortDirection
	 */
	private void sortShiftBidders(List shiftBidders, int sortBy, int sortDirection) {
		// currently no separate detailLevel is defined for computing score and
		// bonus for shift bidder.
		// sort by employee's score if requested.
<span class="nc bnc" id="L4275" title="All 4 branches missed.">		if (sortBy == ShiftBidder.SORTBY_SCORE &amp;&amp; shiftBidders.size() &gt; 1) {</span>
			// Using DAO internal implementation knowledge that the returned
			// collection is an array list.
			// Any change to this fact, within the DAO, will be detected quickly
			// since
			// this is a common path of execution.
			// Casting collection to list is much faster than using the
			// collection to build a list.
<span class="nc" id="L4283">			List shiftBiddersList = shiftBidders;</span>
<span class="nc" id="L4284">			Collections.sort(shiftBiddersList, new ShiftBidderComparatorByScore(sortDirection));</span>
		}
<span class="nc" id="L4286">	}</span>

	/**
	 * update bidder status by scanning schedule.
	 *
	 * @param shiftBidders
	 * @param sbAuction
	 * @param bidderDAO
	 * @throws Exception
	 */
	private void validateShiftBiddersForFetchActionAndUpdate(Collection shiftBidders, ShiftBidAuction sbAuction,
			ShiftBidderDAO bidderDAO) throws Exception {
		// determine which of these bidders are scheduled (ie. have shift
		// assignments in the unpub sched).
<span class="nc" id="L4300">		List bidderEmpIDs = RequestUtil.getListOfFieldValuesFromVOBases(shiftBidders,</span>
				ShiftBidderFieldInfo.SHIFTBIDDER_I_EMPLOYEEID);
<span class="nc" id="L4302">		Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(bidderEmpIDs, sbAuction, bidderDAO);</span>

<span class="nc" id="L4304">		List updatedBidders = new ArrayList(10);</span>
<span class="nc bnc" id="L4305" title="All 2 branches missed.">		for (Iterator shiftBiddersIter = shiftBidders.iterator(); shiftBiddersIter.hasNext();) {</span>
<span class="nc" id="L4306">			ShiftBidder bidder = (ShiftBidder) shiftBiddersIter.next();</span>

			// Note: method below does not post updates to the DB since passed
			// bidderDAO is 'null'
<span class="nc" id="L4310">			boolean valSuccess = validateShiftBidderForFetchActionAndUpdate(bidder, null, updatedBidders,</span>
					unavailableEmpIDs);
<span class="nc bnc" id="L4312" title="All 2 branches missed.">			if (!valSuccess) { // if validation failed, remove bidder.</span>
<span class="nc" id="L4313">				m_cat.debug(&quot;Error: removing invalid bidder from collection: ID = &quot; + bidder.getID());</span>
<span class="nc" id="L4314">				shiftBiddersIter.remove();</span>
			}
<span class="nc" id="L4316">		}</span>

		// if any updates during validation, post to DB.
<span class="nc bnc" id="L4319" title="All 4 branches missed.">		if (updatedBidders != null &amp;&amp; !updatedBidders.isEmpty()) {</span>
<span class="nc" id="L4320">			m_cat.debug(&quot;updating bidders in DB: size = &quot; + updatedBidders.size());</span>
<span class="nc" id="L4321">			bidderDAO.updateShiftBidders(updatedBidders);</span>
		}
<span class="nc" id="L4323">	}</span>

	/**
	 * Determines the orgIDs to be used for fetching the bidders using the
	 * specified orgID and privilege ID.
	 *
	 * @param privIDOrgScoped
	 * @param orgID
	 * @param sbAuction
	 * @return
	 * @throws Exception
	 */
	private Set getOrgIDsForShiftBidderFetch(ID privIDOrgScoped, ID orgID, ShiftBidAuction sbAuction) throws Exception {

<span class="nc" id="L4337">		ID campaignID = sbAuction.getOptMethods().getCampaignID();</span>

		// get orgIDs for which the user has the specified privilege
<span class="nc" id="L4340">		Collection orgIDsWithPriv = RequestUtil</span>
<span class="nc" id="L4341">				.getOrgIDsWithPrivForUserName(RequestUtil.getLoginUserName(m_sessionContext), privIDOrgScoped, null);</span>

		// if no orgIDs with specified priv exist, return.
<span class="nc bnc" id="L4344" title="All 2 branches missed.">		if (orgIDsWithPriv.isEmpty()) {</span>
<span class="nc" id="L4345">			m_cat.debug(&quot;Returning empty collection.  No org IDs with specified &quot; + &quot;privilege exist: privID = &quot;</span>
					+ privIDOrgScoped);
<span class="nc" id="L4347">			return Collections.EMPTY_SET;</span>
		}

		// get org IDs assocaited with this campaign week if no orgID was
		// specified
<span class="nc" id="L4352">		Set orgIDsForCampSet = null;</span>
<span class="nc bnc" id="L4353" title="All 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L4354">			Collection campOrgs = RequestUtil.getCampOrgAssignments(campaignID, sbAuction.getStartTime(),</span>
<span class="nc" id="L4355">					sbAuction.getEndTime(), null);</span>
<span class="nc" id="L4356">			List campOrgIDs = RequestUtil.getListOfFieldValuesFromVOBases(campOrgs,</span>
					CampaignOrgFieldInfo.CAMPAIGNORG_ORGANIZATIONID);
<span class="nc" id="L4358">			orgIDsForCampSet = RequestUtil.getSetFromCollection(campOrgIDs);</span>
			// if an orgID was specified.
<span class="nc" id="L4360">		} else {</span>
			// do not use Collections.singleton() as a mutable set is needed.
<span class="nc" id="L4362">			orgIDsForCampSet = new HashSet();</span>
<span class="nc" id="L4363">			orgIDsForCampSet.add(orgID);</span>
		}

		// restrict campaign orgIDs using the privileged orgIDs.
<span class="nc" id="L4367">		orgIDsForCampSet.retainAll(orgIDsWithPriv);</span>
<span class="nc bnc" id="L4368" title="All 2 branches missed.">		if (orgIDsForCampSet.isEmpty()) {</span>
<span class="nc" id="L4369">			m_cat.debug(&quot;Returning empty collection.  No org IDs for aution with specified &quot;</span>
					+ &quot;privilege exist after apply privilege constraint: privID = &quot; + privIDOrgScoped);
<span class="nc" id="L4371">			return Collections.EMPTY_SET;</span>
		}

<span class="nc" id="L4374">		return orgIDsForCampSet;</span>
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>