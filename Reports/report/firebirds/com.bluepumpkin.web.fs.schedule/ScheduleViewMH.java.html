<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleViewMH.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.fs.schedule</a> &gt; <span class="el_source">ScheduleViewMH.java</span></div><h1>ScheduleViewMH.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.fs.schedule;

import java.rmi.RemoteException;
import java.util.*;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDStringPair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.FacadeException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignHOO;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignOrg;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.EmpPoolingRule;
import com.bluepumpkin.ejb.bbm.people.ejb.PeopleFacade;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.SortEvents;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.core.profile.model.UserProfile;
import com.bluepumpkin.ejb.facade.FacadeManagerFactory;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.ShiftSwapPostingManager;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.web.bbm.activity.ActivityModelHandler;
import com.bluepumpkin.web.bbm.campaign.CampaignModelHandler;
import com.bluepumpkin.web.bbm.employee.EmployeeModelHandler;
import com.bluepumpkin.web.bbm.organization.OrganizationModelHandler;
import com.bluepumpkin.web.bbm.people.PeopleMH;
import com.bluepumpkin.web.bbm.workresource.WorkResourceModelHandler;
import com.bluepumpkin.web.core.base.ModelHandler;
import com.bluepumpkin.web.core.user.profile.UserProfileManager;
import com.bluepumpkin.web.fs.Log;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.bluepumpkin.web.fs.schedule.group.GroupSchedulePM;
import com.bluepumpkin.web.fs.schedule.summary.DailyScheduleSummary;
import com.bluepumpkin.web.fs.user.preferences.UserPrefSchedPC;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;
import com.witness.web.uif.keys.UserPreferenceKeys;
import com.witness.web.uif.l10n.UIFWebBundleKey;
import com.witness.web.uif.system.RequestContext;

/**
 * Title: ScheduleViewMH Description: Handle EJB interaction for Schedule Views data Copyright: Copyright (c) 2002 Company: Blue Pumpkin
 * Software, Inc Created on August 21, 2002, 4:21 PM
 *
 * @author Pavel Bosin
 * @version 1.0
 */
<span class="nc" id="L84">public class ScheduleViewMH extends ModelHandler {</span>

<span class="fc" id="L86">	private static Category log = Log.initCategory(ScheduleViewMH.class.getName());</span>

	//keys for the hash map of page data objects
	public static final String VIEW_TYPE_KEY = &quot;VIEW_TYPE_KEY&quot;;
	public static final String USER_ORG_ID_KEY = &quot;USER_ORG_ID_KEY&quot;;
	public static final String SCHEDULE_ITEMS_KEY = &quot;SCHEDULE_ITEMS_KEY&quot;;
	public static final String DAY_SUMMARIES_KEY = &quot;DAY_SUMMARIES_KEY&quot;;
	public static final String SCHEDULE_SHIFTS_KEY = &quot;SCHEDULE_SHIFTS_KEY&quot;;
	public static final String LEGEND_ITEMS_KEY = &quot;LEGEND_ITEMS_KEY&quot;;
	public static final String PUB_PERIODS_KEY = &quot;PUB_PERIODS_KEY&quot;;
	public static final String EMPLOYEE_ALLIDS_KEY = &quot;EMPLOYEE_ALLIDS_KEY&quot;;
	public static final String EMPLOYEE_IDS_KEY = &quot;EMPLOYEE_IDS_KEY&quot;;
	public static final String EMPLOYEE_NAMES_KEY = &quot;EMPLOYEE_NAMES_KEY&quot;;
	public static final String CAMPAIGN_NAMES_BY_SP_ID_KEY = &quot;CAMPAIGN_NAMES_BY_SP_ID_KEY&quot;;
	public static final String HOLIDAYS_KEY = &quot;HOLIDAYS_KEY&quot;;
	public static final String HOOS_KEY = &quot;HOOS_KEY&quot;;
	public static final String ORGS_KEY = &quot;ORGS_KEY&quot;;
	public static final String CAMPAIGN_KEY = &quot;CAMPAIGN_KEY&quot;;
	public static final String SWAP_FLAG_KEY = &quot;SWAP_FLAG_KEY&quot;;
	public static final String SWAP_BOARD_KEY = &quot;SWAP_BOARD_KEY&quot;;
	public static final String SWAP_REQUESTS_KEY = &quot;SWAP_REQUESTS_KEY&quot;;
	public static final String ACTIVITIES_KEY = &quot;ACTIVITIES_KEY&quot;;
	public static final String ACTIVITY_MEDIAS_KEY = &quot;ACTIVITY_MEDIAS_KEY&quot;;
	public static final String ACTIVITY_QUEUES_KEY = &quot;ACTIVITY_QUEUES_KEY&quot;;
	public static final String SHOW_UNAVAILABLE_KEY = &quot;SHOW_UNAVAILABLE_KEY&quot;;
	public static final String SHOW_MY_SCHEDULE_NOTE_KEY = &quot;SHOW_MY_SCHEDULE_NOTE_KEY&quot;;
	public static final String SHOW_ORG_SCHEDULE_NOTE_KEY = &quot;SHOW_ORG_SCHEDULE_NOTE_KEY&quot;;
	public static final String SELECTED_ORG_ID_KEY = &quot;SELECTED_ORG_ID_KEY&quot;;
	public static final String SELECTED_CAMPAIGN_ID_KEY = &quot;SELECTED_CAMPAIGN_ID_KEY&quot;;
	public static final String PAGE_MESSAGE = &quot;PAGE_MESSAGE&quot;;
	public static final String GROUPVIEW_FLAG_KEY = &quot;GROUPVIEW_FLAG_KEY&quot;;
	public static final String GROUPVIEW_LIMIT_KEY = &quot;GROUPVIEW_LIMIT_KEY&quot;;
	public static final String SHOW_TIMEOFF_KEY = &quot;SHOW_TIMEOFF_KEY&quot;;

	//These constants are used to identify which warning message to show on the page
	public static final String GROUPVIEW_LIMIT_OK = &quot;OK&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_1 = &quot;NOPRIV_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOORG_1 = &quot;NOORG_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOLINK_1 = &quot;NOLINK_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOLINK_2 = &quot;NOLINK_2&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_2 = &quot;NOPRIV_2&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_3 = &quot;NOPRIV_3&quot;;
	public static final String GROUPVIEW_LIMIT_NOORG_2 = &quot;NOORG_2&quot;;
	public static final String GROUPVIEW_LIMIT_SOMEORG = &quot;SOMEORG&quot;;

	public static final int EMP_SORT_NOT_BY_NAME = -1;

	//////////////////////////////////////////////////////////////////////////////
	// Personal View
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns all the data for the Personal Schedule pages
	 *
	 * @param employeeID - The ID of the single employee who's schedule will be viewed
	 * @param myEmpID - The ID of the currently logged-in user
	 */
	public static HashMap&lt;String, Object&gt; getPersonalData(RequestContext context, String viewType, TimeRange theTimeRange,
			ID employeeID, ID myEmpID)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L145">		log.debug(&quot;ENTER MH.getPersonalData; viewType ='&quot; + viewType);</span>

<span class="nc" id="L147">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L148">		theData.put(VIEW_TYPE_KEY, viewType);</span>

<span class="nc" id="L150">		putUserOrgID(context, theData);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L152">			theTimeRange = getTimeRange(context, theData);</span>
		}

<span class="nc" id="L155">		putOrgData(context, theData, theTimeRange, employeeID);</span>
<span class="nc" id="L156">		putPersonalScheduleData(context, theData, theTimeRange, employeeID);</span>
<span class="nc" id="L157">		putActivities(context, theData);</span>
<span class="nc" id="L158">		putSwapData(context, theData);</span>
<span class="nc" id="L159">		putShowUnavailabilities(context, theData);</span>
<span class="nc" id="L160">		putShowTimeoff(context, theData);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">		if (!viewType.equals(ScheduleViewPM.VIEW_TYPE_MY_TEXT)) {</span>
			//uses activities, which are fetched above
<span class="nc" id="L164">			Collection&lt;ID&gt; employeeIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L165">			employeeIDs.add(employeeID);</span>
<span class="nc" id="L166">			boolean hasSecuredTimeOffEvents = hasSecuredTimeOffEvents(context, employeeIDs, myEmpID);</span>
<span class="nc" id="L167">			putLegendData(context, theData, myEmpID, hasSecuredTimeOffEvents);</span>
		}
<span class="nc" id="L169">		log.debug(&quot;EXIT MH.getPersonalData&quot;);</span>
<span class="nc" id="L170">		return theData;</span>
	}

	/**
	 * get schedule data for personal views
	 */
	public static void putPersonalScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			ID employeeID)
			throws RemoteException, BbmException {
		Collection&lt;SimpleEvent&gt; scheduleData;
<span class="nc" id="L180">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		//--- load published periods for the employee, from, to
<span class="nc" id="L183">		ArrayList&lt;ID&gt; eIDs = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L184">		eIDs.add(employeeID);</span>

<span class="nc" id="L186">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = new ArrayList&lt;Collection&lt;TimeRange&gt;&gt;(1);</span>
<span class="nc" id="L187">		Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps = schedAccessManager.getPublishedPeriods(eIDs,</span>
<span class="nc" id="L188">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L189">		ppTimeRanges.add(getTimeRangesForPublishedPeriods(pubPeriodsForEmps, theData, theTimeRange, eIDs));</span>

		//--- get schedule events
<span class="nc" id="L192">		Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = new ArrayList&lt;Collection&lt;? extends Event&gt;&gt;(1);</span>
<span class="nc" id="L193">		Collection&lt;? extends Event&gt; scheduleEvents = getPersonalScheduleEvents(schedAccessManager, employeeID, theTimeRange);</span>
<span class="nc" id="L194">		groupSchedule.add(scheduleEvents);</span>

<span class="nc" id="L196">		Collection&lt;HOOAssignment&gt; hOOAssignments = new ArrayList&lt;HOOAssignment&gt;(1);</span>
<span class="nc" id="L197">		hOOAssignments.add((HOOAssignment) theData.get(HOOS_KEY));</span>

<span class="nc" id="L199">		Map&lt;ID, ID&gt; employeeOrgMap = OrganizationModelHandler.getEmployeeOrgMap(context, eIDs, theTimeRange.getStartDate());</span>

<span class="nc" id="L201">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps,</span>
				eIDs, employeeOrgMap);

		//--- flatten the events on the time line
<span class="nc" id="L205">		Collection&lt;ShiftAssignment&gt; scheduleShifts = selectOnlyShiftAssignments(scheduleEvents);</span>
<span class="nc" id="L206">		theData.put(SCHEDULE_SHIFTS_KEY, scheduleShifts);</span>
<span class="nc" id="L207">		scheduleData = flattenSchedule(scheduleEvents);</span>

<span class="nc" id="L209">		putCampaignNamesBySpId(context, theData, scheduleShifts);</span>

		//--- mark events covered by shift extensions as overtime
<span class="nc" id="L212">		Collection&lt;SimpleEvent&gt; markedSchedule = markOvertimeEvents(scheduleData, scheduleShifts);</span>

<span class="nc" id="L214">		theData.put(SCHEDULE_ITEMS_KEY, markedSchedule);</span>

<span class="nc" id="L216">		debugLogCollection(&quot;getPersonalScheduleData&quot;, &quot;flattend ScheduleData&quot;, scheduleData);</span>
<span class="nc" id="L217">	}</span>

	/**
	 * get collection of schedule events for the current user for the given time range
	 */
	public static Collection&lt;? extends Event&gt; getPersonalScheduleEvents(ScheduleAccessManager scheduleAccessManager,
			ID employeeID, TimeRange theTimeRange) throws RemoteException, BbmException {
		//--- load and put on time line schedule events for the employee, from, to
		//   mask out the imported events, since they are also considered published
<span class="nc" id="L226">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS</span>
				| Event.EVENT_TYPE_SHIFT_ASSIGNMENT
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;
<span class="nc" id="L229">		return getPersonalScheduleEvents(scheduleAccessManager, employeeID, theTimeRange, eventTypeMask);</span>
	}

	/**
	 * get collection of schedule events for the current user for the given time range
	 */
	public static Collection&lt;? extends Event&gt; getPersonalScheduleEvents(ScheduleAccessManager scheduleAccessManager, ID employeeID,
			TimeRange theTimeRange, int eventTypeMask) throws RemoteException, BbmException {
		//--- load and put on time line schedule events for the employee, from, to
<span class="nc" id="L238">		Collection&lt;? extends Event&gt; scheduleEvents = scheduleAccessManager.getPublishedEventsForWorkResourceByType(</span>
<span class="nc" id="L239">				eventTypeMask, employeeID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>

<span class="nc bnc" id="L241" title="All 2 branches missed.">		if (scheduleEvents != null) {</span>
<span class="nc" id="L242">			log.debug(&quot; MH.getPersonalScheduleEvents: result size=&quot; + scheduleEvents.size());</span>
		} else {
<span class="nc" id="L244">			log.debug(&quot; MH.getPersonalScheduleEvents: result is null&quot;);</span>
		}
<span class="nc" id="L246">		return scheduleEvents;</span>
	}

	/**
	 * returns display name af an employee
	 */
	public static String getEmployeeDisplayName(RequestContext context, ID employeeId, Localizer localizer)
			throws RemoteException, BbmException {
<span class="nc bnc" id="L254" title="All 2 branches missed.">		if (employeeId == null) {</span>
<span class="nc" id="L255">			return &quot;&quot;;</span>
		}
<span class="nc" id="L257">		String result = &quot;&quot;;</span>
<span class="nc" id="L258">		EmployeeName eName = EmployeeModelHandler.getEmployeeNameByID(context, employeeId);</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">		if (eName != null) {</span>
<span class="nc" id="L260">			result = localizer.formatFullName(eName);</span>
		}
<span class="nc" id="L262">		return result;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Group View
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns all the data for the Group Schedule pages if the IDs are known usually it works when pagination controls are used.
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; employeeIDs, boolean isSwapDataUsed)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="fc" id="L274">		log.debug(&quot;ENTER MH.getGroupData; viewType ='&quot; + viewType);</span>
<span class="fc" id="L275">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L276">		putUserOrgID(context, theData);</span>
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L278">			theTimeRange = getTimeRange(context, theData); //needs userOrgID</span>
		}
<span class="fc" id="L280">		log.debug(&quot; MH: theTimeRange =&quot; + theTimeRange.getStartDate() + &quot; - &quot; + theTimeRange.getEndDate());</span>

<span class="fc" id="L282">		theData.put(EMPLOYEE_IDS_KEY, employeeIDs);</span>
<span class="fc" id="L283">		theData.put(SELECTED_ORG_ID_KEY, orgID);</span>
<span class="fc" id="L284">		theData.put(SELECTED_CAMPAIGN_ID_KEY, campaignID);</span>
<span class="fc" id="L285">		putGroupData(context, viewType, theTimeRange, theDayRange, theData, isSwapDataUsed);</span>
<span class="fc" id="L286">		log.debug(&quot;EXIT MH.getGroupData&quot;);</span>
<span class="fc" id="L287">		return theData;</span>
	}

	/**
	 * Returns all the data for the Group Schedule pages if IDs are not known; get first page //QC79134
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; empIDs, int pageSize, String sortBy, boolean isSwapDataUsed)
			throws RemoteException, BbmException, FacadeException, RmHardValidationException {
<span class="nc" id="L296">		return getGroupData(context, viewType, theTimeRange, theDayRange, orgID, campaignID, empIDs, pageSize, sortBy, isSwapDataUsed,</span>
				theDayRange);
	}

	/**
	 * Returns all the data for the Group Schedule pages if IDs are not known; get first page //QC79134 added oDayRange as original time
	 * range
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; empIDs, int pageSize, String sortBy, boolean isSwapDataUsed,
			TimeRange oDayRange)
			throws RemoteException, BbmException, FacadeException, RmHardValidationException {
<span class="fc" id="L308">		log.debug(&quot;ENTER MH.getGroupData; viewType ='&quot; + viewType);</span>

<span class="fc" id="L310">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;String, Object&gt;();</span>
<span class="fc" id="L311">		ID userOrgID = putUserOrgID(context, theData);</span>
<span class="fc" id="L312">		theData.put(SELECTED_ORG_ID_KEY, orgID);</span>
<span class="fc" id="L313">		theData.put(SELECTED_CAMPAIGN_ID_KEY, campaignID);</span>

<span class="pc bpc" id="L315" title="1 of 2 branches missed.">		if (userOrgID == null) {</span>
<span class="nc" id="L316">			return null;</span>
		}

<span class="pc bpc" id="L319" title="1 of 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L320">			theTimeRange = getTimeRange(context, theData); //uses userOrgID from theData</span>
		}
<span class="fc" id="L322">		log.debug(&quot; MH: theTimeRange =&quot; + theTimeRange.getStartDate() + &quot; - &quot; + theTimeRange.getEndDate());</span>

		// Fetch Employee IDs based on orgID/campID if not being passed
<span class="fc" id="L325">		int sortField = makeFilterSortField(sortBy);</span>
<span class="pc bpc" id="L326" title="2 of 4 branches missed.">		boolean isEmpIDsProvided = (empIDs != null &amp;&amp; !empIDs.isEmpty());</span>
<span class="fc" id="L327">		Collection&lt;ID&gt; employeeIDs = Collections.emptyList();</span>

<span class="pc bpc" id="L329" title="1 of 2 branches missed.">		if (isEmpIDsProvided) {</span>
<span class="fc" id="L330">			employeeIDs = empIDs; //manager already filtered ids for us. But not sorted yet.</span>
		} else {
			//get ids for agent. If sortField is name, then they're sorted here. Otherwise, sorted later.
<span class="nc" id="L333">			employeeIDs = getEmployeeIDs(context, theData, theTimeRange, theDayRange, orgID, campaignID, userOrgID, sortField);</span>
		}
		// Perform Sorting
<span class="pc bpc" id="L336" title="1 of 2 branches missed.">		if (sortField == EMP_SORT_NOT_BY_NAME) {</span>
			//sort agent or manager view ids by schedule
			// Use Date Range for Sorting if available so Text and Graph sorting works
<span class="nc bnc" id="L339" title="All 2 branches missed.">			oDayRange = oDayRange == null ? theDayRange : oDayRange;//QC79134</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">			TimeRange tr = oDayRange == null ? theTimeRange : oDayRange;//QC79134</span>
<span class="nc" id="L341">			employeeIDs = sortEmpIDsPubEvents(context, employeeIDs, sortBy, tr);</span>
<span class="pc bpc" id="L342" title="1 of 2 branches missed.">		} else if (isEmpIDsProvided) {</span>
<span class="fc" id="L343">			ID userID = context.getUser().getID();</span>
<span class="fc" id="L344">			employeeIDs = sortEmpIDsByName(context, userID, employeeIDs, sortField);</span>
		}
		//At this point, employeeIDs are completely sorted
<span class="fc" id="L347">		theData.put(EMPLOYEE_ALLIDS_KEY, employeeIDs);</span>
		//Tample changed for QA 86309
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">		theData.put(EMPLOYEE_IDS_KEY, ScheduleViewUtil.getTopCollectionPage(employeeIDs,</span>
<span class="pc" id="L350">				Math.min(pageSize &lt; 0 ? employeeIDs.size() : pageSize, employeeIDs.size())));</span>
		// Retrieve Group Data
<span class="fc" id="L352">		putGroupData(context, viewType, theTimeRange, theDayRange, theData, isSwapDataUsed);</span>
<span class="fc" id="L353">		log.debug(&quot;EXIT MH.getGroupData&quot;);</span>
<span class="fc" id="L354">		return theData;</span>
	}

	/**
	 * populates the HashMap with all the data for the Group Schedule pages
	 */
	private static void putGroupData(RequestContext context, String viewType, TimeRange theTimeRange, TimeRange theDayRange, HashMap&lt;String,
			Object&gt; theData, boolean isSwapDataUsed)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="fc" id="L363">		theData.put(VIEW_TYPE_KEY, viewType);</span>

<span class="fc" id="L365">		Collection&lt;ID&gt; employeeIDs = (Collection&lt;ID&gt;) theData.get(EMPLOYEE_IDS_KEY);</span>
<span class="fc" id="L366">		putEmployeeNames(context, theData, employeeIDs);</span>

<span class="fc" id="L368">		ID employeeID = context.getUser().getEmployeeID();</span>
<span class="fc" id="L369">		putOrgData(context, theData, theTimeRange, employeeID);</span>
<span class="fc" id="L370">		putCampaignData(context, theData);</span>

<span class="pc bpc" id="L372" title="1 of 2 branches missed.">		if (viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_MULTI)) {</span>
<span class="fc" id="L373">			putGroupMultidayScheduleData(context, theData, theTimeRange, employeeIDs);</span>
		} else {
<span class="nc" id="L375">			Map&lt;ID, ID&gt; employeeOrgMap = OrganizationModelHandler.getEmployeeOrgMap(context, employeeIDs, theDayRange.getStartDate());</span>
<span class="nc" id="L376">			putGroupScheduleData(context, theData, theTimeRange, theDayRange, employeeIDs, employeeOrgMap);</span>
		}
<span class="fc" id="L378">		putActivities(context, theData);</span>

<span class="pc bpc" id="L380" title="1 of 2 branches missed.">		if (isSwapDataUsed) {</span>
<span class="nc" id="L381">			putSwapData(context, theData);</span>
		}
<span class="fc" id="L383">		putShowUnavailabilities(context, theData);</span>
<span class="fc" id="L384">		putShowTimeoff(context, theData);</span>

<span class="pc bpc" id="L386" title="2 of 4 branches missed.">		if (viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_GRAPH) || viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_PRINT)) {</span>
			//uses activities, which are fetched above
<span class="nc" id="L388">			boolean hasSecuredTimeOffEvents = hasSecuredTimeOffEvents(context, employeeIDs, employeeID);</span>
<span class="nc" id="L389">			putLegendData(context, theData, employeeID, hasSecuredTimeOffEvents);</span>
		}
<span class="fc" id="L391">	}</span>

	/**
	 * Get the first non-null orgID in the collection of DailyScheduleSummary's which intersects the specified day's range.
	 */
	public static ID getOrgID(Collection&lt;DailyScheduleSummary&gt; daySummaries, CalendarRange aDay) {
<span class="nc" id="L397">		TimeRange tr = new TimeRange(aDay.getStartDate(), aDay.getEndDate());</span>

<span class="nc bnc" id="L399" title="All 2 branches missed.">		if (daySummaries != null) {</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">			for (DailyScheduleSummary oneDaySchedule : daySummaries) {</span>
<span class="nc bnc" id="L401" title="All 4 branches missed.">				if ((oneDaySchedule.getDayRange().getOverlapDuration(tr) &gt; 0) &amp;&amp; oneDaySchedule.getOrgID() != null) {</span>
<span class="nc" id="L402">					return oneDaySchedule.getOrgID();</span>
				}
<span class="nc" id="L404">			}</span>
		}
<span class="nc" id="L406">		return null;</span>
	}

	/**
	 * This method will extract the scheduling period IDs from the shift assignments (and their child shift event assignments) and look up
	 * the associated campaign names for these scheduling periods. It will create a map of SPID -&gt; campaign name and will store this map in
	 * theData using the key CAMPAIGN_NAMES_BY_SP_ID_KEY.
	 *
	 * @param context - the request context.
	 * @param theData - The HashMap holding all of the data we could ever need in order to show schedules.
	 * @param shiftAssignments - The shift assignments contained in the schedule for the current view period.
	 */
	public static void putCampaignNamesBySpId(RequestContext context, HashMap&lt;String, Object&gt; theData, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmException, RemoteException {
		//Get the Scheduling Period IDs off of the Shift Event Assignments (which are child objects
		//of the shift assignments), if the SP ID of the shift event does not match the SP ID of the
		//corresponding shift.
<span class="fc" id="L423">		HashSet&lt;ID&gt; spIDs = new HashSet&lt;ID&gt;();</span>
<span class="pc bpc" id="L424" title="2 of 4 branches missed.">		if (shiftAssignments != null &amp;&amp; shiftAssignments.isEmpty() == false) {</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">			for (ShiftAssignment shiftAssignment : shiftAssignments) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">				if (shiftAssignment.getCampaignID() != null) {</span>
<span class="nc" id="L427">					spIDs.add(shiftAssignment.getCampaignID());</span>
<span class="nc" id="L428">					Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = shiftAssignment.getChildren();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">					for (ShiftEventAssignment seAssignment : shiftEventAssignments) {</span>
						//It appears as though we are comparing the shift event's SP ID to the shift's campaign ID,
						//however ShiftAssignment.getCampaignID() returns the SP ID, not campaign ID.
<span class="nc bnc" id="L432" title="All 4 branches missed.">						if (seAssignment.getSPID() != null &amp;&amp; !seAssignment.getSPID().equals(shiftAssignment.getCampaignID())) {</span>
<span class="nc" id="L433">							spIDs.add(seAssignment.getSPID());</span>
						}
<span class="nc" id="L435">					}</span>
				}
<span class="nc" id="L437">			}</span>
		}
<span class="fc" id="L439">		Map&lt;ID, String&gt; retVal = CampaignModelHandler.getCampaignNamesLinkedToSPs(context, spIDs);</span>
<span class="fc" id="L440">		theData.put(CAMPAIGN_NAMES_BY_SP_ID_KEY, retVal);</span>
<span class="fc" id="L441">	}</span>

	/**
	 * get employee IDs and names
	 */
	private static void putEmployeeNames(RequestContext context, HashMap&lt;String, Object&gt; theData, Collection&lt;ID&gt; theEmployeeIDs)
			throws RemoteException, BbmException {
<span class="fc" id="L448">		HashMap&lt;ID, EmployeeName&gt; employeeNames = EmployeeModelHandler.getEmployeeNamesByIDs(context, theEmployeeIDs);</span>
<span class="fc" id="L449">		theData.put(EMPLOYEE_NAMES_KEY, employeeNames);</span>
<span class="fc" id="L450">		debugLogCollection(&quot;getEmployeeNames&quot;, &quot;employeeNames&quot;, employeeNames);</span>
<span class="fc" id="L451">	}</span>

	/**
	 * get campaign data: name and ID and put it into the HashMap theData
	 *
	 * NOTE: theTimeRange is passed for the future needs of campaign data with effectivity
	 */
	private static void putCampaignData(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="fc" id="L460">		ID campaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>
<span class="fc" id="L461">		String name = &quot;&quot;;</span>
<span class="pc bpc" id="L462" title="1 of 2 branches missed.">		if (campaignID != null) {</span>
<span class="nc" id="L463">			Campaign campaign = CampaignModelHandler.getCampaign(context, campaignID);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">			if (campaign != null) {</span>
<span class="nc" id="L465">				name = campaign.getName();</span>
			}
		}
<span class="fc" id="L468">		IDStringPair campaignData = new IDStringPair(campaignID, name);</span>
<span class="fc" id="L469">		theData.put(CAMPAIGN_KEY, campaignData);</span>
<span class="fc" id="L470">		log.debug(&quot; MH.getCampaignData: Campaign name = &quot; + name);</span>
<span class="fc" id="L471">	}</span>

	/**
	 * Return list of orgs allowed for viewing from RM OrganizationSetting for given orgID
	 */
	public static Collection&lt;ID&gt; getGroupViewOrgIDs(ID orgID)
			throws RemoteException, BbmException {
<span class="fc" id="L478">		Collection&lt;ID&gt; orgIdCollection = null;</span>

<span class="fc" id="L480">		RmManagerFactory rmManagerFactory = RmManagerFactory.getInstance();</span>
<span class="fc" id="L481">		OrganizationConfigManager orgConfigManager = rmManagerFactory.getOrganizationConfigManager();</span>
<span class="fc" id="L482">		OrganizationSetting orgSetting = orgConfigManager.getConfiguration(orgID);</span>
<span class="fc" id="L483">		String orgList = orgSetting.getGroupViewOrgList();</span>
<span class="pc bpc" id="L484" title="1 of 2 branches missed.">		if (!StringUtil.isEmpty(orgList)) {</span>
<span class="fc" id="L485">			ID ids[] = StringUtil.parseIDString(orgList);</span>
<span class="pc bpc" id="L486" title="2 of 4 branches missed.">			if (ids != null &amp;&amp; ids.length != 0) {</span>
<span class="fc" id="L487">				orgIdCollection = Arrays.asList(ids);</span>
			}
		}
<span class="fc" id="L490">		return orgIdCollection;</span>
	}

	/**
	 * get schedule data for group multiday view - only shifts
	 *
	 * @param campaignIDs - Set of unique campaign IDs that we need to lookup the Campaign names for.
	 */
	private static void putGroupMultidayScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			Collection&lt;ID&gt; employeeIDs)
			throws RemoteException, BbmException {
<span class="fc" id="L501">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		//--- get schedules
<span class="fc" id="L504">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS</span>
				| Event.EVENT_TYPE_SHIFT_ASSIGNMENT
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;
<span class="fc" id="L507">		List&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = schedAccessManager.getPublishedEventsForWorkResourcesByType(</span>
<span class="fc" id="L508">				eventTypeMask, employeeIDs, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="fc" id="L509">		debugLogCollection(&quot;getGroupMultidayScheduleData&quot;, &quot;groupSchedule&quot;, groupSchedule);</span>

<span class="fc" id="L511">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = selectGroupShifts(groupSchedule);</span>

		//Gather all shift assignments in the schedule and determine the campaign names associated to
		//the scheduling period IDs of the shift/shift event assignments
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">		if (groupShifts != null) {</span>
<span class="fc" id="L516">			Collection&lt;ShiftAssignment&gt; allShiftAssignments = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="fc bfc" id="L517" title="All 2 branches covered.">			for (Collection&lt;ShiftAssignment&gt; shiftAssignments : groupShifts) {</span>
<span class="fc" id="L518">				allShiftAssignments.addAll(shiftAssignments);</span>
<span class="fc" id="L519">			}</span>
<span class="fc" id="L520">			putCampaignNamesBySpId(context, theData, allShiftAssignments);</span>
		}

		//--- get published periods and save to theData
<span class="fc" id="L524">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps = schedAccessManager.getPublishedPeriods(employeeIDs,</span>
<span class="fc" id="L525">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="fc" id="L526">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges =</span>
<span class="fc" id="L527">				getTimeRangesForPublishedPeriodsForGroupView(pubPeriodsForEmps, theData, theTimeRange, employeeIDs);</span>

		//---get org HOO's for each selected employee
<span class="fc" id="L530">		Collection&lt;HOOAssignment&gt; hOOAssignments = getEmployeeHooAssignments(context, theTimeRange, employeeIDs);</span>

<span class="fc" id="L532">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps, employeeIDs, null);</span>
<span class="fc" id="L533">	}</span>

	/**
	 * get schedule data for group views text/graph/print
	 *
	 * @param employeeCampAssMap - map of employeeIDs - &gt; CampaignWorkResource assignments.
	 * @param campaignIDs - Set of unique campaign IDs that we need to lookup the Campaign names for.
	 */
	private static void putGroupScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			TimeRange theDayRange, Collection&lt;ID&gt; employeeIDs, Map&lt;ID, ID&gt; employeeOrgMap)
			throws RemoteException, BbmException {
<span class="nc" id="L544">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		//--- get schedules
<span class="nc" id="L547">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS</span>
				| Event.EVENT_TYPE_SHIFT_ASSIGNMENT
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;
<span class="nc" id="L550">		Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = schedAccessManager.getPublishedEventsForWorkResourcesByType(</span>
<span class="nc" id="L551">				eventTypeMask, employeeIDs, theDayRange.getStartDate(), theDayRange.getEndDate());</span>
<span class="nc" id="L552">		debugLogCollection(&quot;getGroupScheduleData&quot;, &quot;groupSchedule&quot;, groupSchedule);</span>

		//--- save shifts separately
<span class="nc" id="L555">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = selectGroupShifts(groupSchedule);</span>
<span class="nc" id="L556">		theData.put(SCHEDULE_SHIFTS_KEY, groupShifts);</span>

		//--- get published periods and save to theData
<span class="nc" id="L559">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps =</span>
<span class="nc" id="L560">				schedAccessManager.getPublishedPeriods(employeeIDs, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L561">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges =</span>
<span class="nc" id="L562">				getTimeRangesForPublishedPeriodsForGroupView(pubPeriodsForEmps, theData, theTimeRange, employeeIDs);</span>

		//---get org HOO's for each selected employee
<span class="nc" id="L565">		Collection&lt;HOOAssignment&gt; hOOAssignments = getEmployeeHooAssignments(context, theTimeRange, employeeIDs);</span>

<span class="nc" id="L567">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps,</span>
				employeeIDs, employeeOrgMap);

		//--- flatten schedules
<span class="nc" id="L571">		Collection&lt;Collection&lt;SimpleEvent&gt;&gt; flattenedSchedule = flattenGroupSchedule(groupSchedule);</span>

		//Gather all shift assignments in the schedule and determine the campaign names associated to
		//the scheduling period IDs of the shift/shift event assignments
<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (groupShifts != null) {</span>
<span class="nc" id="L576">			Collection&lt;ShiftAssignment&gt; allShiftAssignments = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">			for (Collection&lt;ShiftAssignment&gt; shiftAssignments : groupShifts) {</span>
<span class="nc" id="L578">				allShiftAssignments.addAll(shiftAssignments);</span>
<span class="nc" id="L579">			}</span>
<span class="nc" id="L580">			putCampaignNamesBySpId(context, theData, allShiftAssignments);</span>
		}
		//--- mark events as overlap if they are covered by shift extensions
<span class="nc" id="L583">		Collection&lt;Collection&lt;SimpleEvent&gt;&gt; markedSchedule = markGroupOvertimeEvents(flattenedSchedule, groupShifts);</span>

<span class="nc" id="L585">		theData.put(SCHEDULE_ITEMS_KEY, markedSchedule);</span>
<span class="nc" id="L586">	}</span>

	/**
	 * Creates a collection containing collections of DailyScheduleSummary objects, each representing an employee's schedule for a day. This
	 * collection is stored in the universal hashmap &quot;theData&quot; which is eventually handed to the page model. The key for these objects in
	 * the map is DAY_SUMMARIES_KEY.
	 * 
	 * @param context
	 * @param theData
	 * @param theTimeRange
	 * @param groupSchedule
	 * @param groupTimeRanges
	 * @param groupHOOAssignments a list which contains one HOOAssignment for each employee
	 * @param groupPubPeriods
	 * @param employeeIDs collection of employee IDs
	 * @param employeeOrgMap
	 * @throws RemoteException
	 * @throws BbmException 
	 */
	private static void putDaySummaries(
			RequestContext context,
			HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange,
			Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule,
			Collection&lt;Collection&lt;TimeRange&gt;&gt; groupTimeRanges,
			Collection&lt;HOOAssignment&gt; groupHOOAssignments,
			Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; groupPubPeriods,
			Collection&lt;ID&gt; employeeIDs,
			Map&lt;ID, ID&gt; employeeOrgMap) throws RemoteException, BbmException {
		//Activities data is required to build the daily schedule summaries.
<span class="fc" id="L616">		putActivities(context, theData);</span>

		//--- get day summaries
<span class="fc" id="L619">		Collection&lt;Collection&lt;DailyScheduleSummary&gt;&gt; daySummaries = ScheduleViewUtil.makeGroupDaySummaries(context, theTimeRange,</span>
				groupSchedule, groupTimeRanges, groupHOOAssignments, groupPubPeriods, employeeIDs,
<span class="fc" id="L621">				employeeOrgMap, (Map&lt;ID, Activity&gt;) theData.get(ACTIVITIES_KEY));</span>
<span class="fc" id="L622">		debugLogCollection(&quot;getGroupMultidayScheduleData&quot;, &quot;daySummaries&quot;, daySummaries);</span>

<span class="fc" id="L624">		theData.put(DAY_SUMMARIES_KEY, daySummaries);</span>
<span class="fc" id="L625">	}</span>

	//////////////////////////////////////////////////////////////////////////////
	// Common Schedule Related Code
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Determine whether the logged-in user has the &quot;Use Accessibility Compliance Mode&quot; preference set to true.
	 *
	 * @return the &quot;Use Accessibility Compliance Mode&quot; preference.
	 */
	public static boolean isAccessibilityMode(RequestContext context) {
<span class="nc" id="L636">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L637">		String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_ACCESSIBILITY_COMPLIANCE_MODE, &quot;false&quot;);</span>
<span class="nc" id="L638">		return &quot;true&quot;.equals(strVal);</span>
	}

	/**
	 * Get the boolean flag whether to show unavailabilities for this user and save it in the hashmap
	 */
	private static void putShowUnavailabilities(RequestContext context, HashMap&lt;String, Object&gt; theData) {
<span class="fc" id="L645">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="fc" id="L646">		String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_UNAVAILABLE, &quot;false&quot;);</span>
<span class="pc bpc" id="L647" title="1 of 2 branches missed.">		Boolean boolFlag = !&quot;false&quot;.equals(strVal);</span>
<span class="fc" id="L648">		theData.put(SHOW_UNAVAILABLE_KEY, boolFlag);</span>
<span class="fc" id="L649">		log.debug(&quot; MH.getShowUnavailabilities boolFlag=&quot; + boolFlag);</span>
<span class="fc" id="L650">	}</span>

	/**
	 * Get the boolean flag whether to show time off for this user and save it in the hashmap
	 */
	private static void putShowTimeoff(RequestContext context, HashMap&lt;String, Object&gt; theData) {
<span class="fc" id="L656">		Boolean boolFlag = false;</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">		if (context.getUser().isAuthorized(PrivilegeKeys.FS_CONFIGURETIMEOFFEVENTSDISPLAY_ID)) {</span>
<span class="fc" id="L658">			UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="fc" id="L659">			String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_TIMEOFF, &quot;false&quot;);</span>
<span class="fc" id="L660">			boolFlag = &quot;true&quot;.equals(strVal);</span>
		}
<span class="fc" id="L662">		theData.put(SHOW_TIMEOFF_KEY, boolFlag);</span>
<span class="fc" id="L663">		log.debug(&quot; MH.getShowTimeoff boolFlag=&quot; + boolFlag);</span>
<span class="fc" id="L664">	}</span>

	/**
	 * Get the boolean flag whether to show Net Staffing for this user.
	 */
	public static boolean getShowNetStaffing(RequestContext context) {
<span class="nc" id="L670">		Boolean boolFlag = false;</span>

<span class="nc bnc" id="L672" title="All 2 branches missed.">		if (context.getUser().isAuthorized(PrivilegeKeys.FS_CONFIGURENETSTAFFINGDISPLAY_ID)) {</span>
<span class="nc" id="L673">			UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L674">			String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_NETSTAFFING, &quot;false&quot;);</span>
<span class="nc" id="L675">			boolFlag = &quot;true&quot;.equals(strVal);</span>
		}
<span class="nc" id="L677">		log.debug(&quot; MH.getShowNetStaffing boolFlag=&quot; + boolFlag);</span>
<span class="nc" id="L678">		return boolFlag;</span>
	}

	/**
	 * Get the boolean flag whether to show the half-height or half-height Net Staffing ribbon for this user.
	 */
	public static boolean getNetStaffingHalfHeight(RequestContext context) {
		/*
		Boolean boolFlag = new Boolean(false);

		if (context.getUser().isAuthorized(PrivilegeKeys.FS_CONFIGURENETSTAFFINGDISPLAY_ID)) 
		{
			UserProfile userProfile = UserProfileManager.getUserProfile(context);
			String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_NETSTAFFING_HALF_HEIGHT, &quot;true&quot;);
			boolFlag = new Boolean(&quot;true&quot;.equals(strVal));
		}

		log.debug(&quot; MH.getNetStaffingHalfHeight boolFlag=&quot; + boolFlag);		
		return boolFlag.booleanValue();
		 */
<span class="nc" id="L698">		return true;</span>
	}

	/**
	 * Get the Net Staffing Surplus color for this user.
	 */
	public static String getNetStaffingSurplusColor(RequestContext context) {
<span class="nc" id="L705">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L706">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_SURPLUS_COLOR, UserPrefSchedPC.DEFAULT_NS_SURPLUS_COLOR);</span>
	}

	/**
	 * Get the Net Staffing Shortage color for this user.
	 */
	public static String getNetStaffingShortageColor(RequestContext context) {
<span class="nc" id="L713">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L714">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_SHORTAGE_COLOR, UserPrefSchedPC.DEFAULT_NS_SHORTAGE_COLOR);</span>
	}

	/**
	 * Get the Net Staffing Neutral color for this user.
	 */
	public static String getNetStaffingNeutralColor(RequestContext context) {
<span class="nc" id="L721">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L722">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_NEUTRAL_COLOR, UserPrefSchedPC.DEFAULT_NS_NEUTRAL_COLOR);</span>
	}

	/**
	 * Get the Net Staffing Cell Selection color for this user.
	 */
	public static String getNetStaffingCellSelectionColor(RequestContext context) {
		/*
		UserProfile userProfile = UserProfileManager.getUserProfile(context);
		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_CELL_SELECTION_COLOR, UserPrefSchedPC.DEFAULT_NS_CELL_SELECTION_COLOR);
		 */
<span class="nc" id="L733">		return &quot;#FFFF00&quot;;</span>
	}

	/**
	 * Get the boolean flag whether to show Net Staffing for this user.
	 *
	 * @param isManagerPage - pass true if the is the manager page (Tracking\Schedules). Pass false for the agent page (My Home\My
	 * Schedule).
	 */
	public static boolean getCanCreateCustomShiftRequest(RequestContext context, boolean isManagerPage) {
		boolean returnValue;

<span class="nc bnc" id="L745" title="All 2 branches missed.">		if (isManagerPage) {</span>
<span class="nc" id="L746">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.CS_MODIFYREQUESTSFOREMPLOYEE);</span>
		} else {
<span class="nc" id="L748">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.CS_MODIFYPERSONALREQUESTS);</span>
		}
<span class="nc" id="L750">		log.debug(&quot; getCanCreateCustomShiftRequest boolFlag=&quot; + returnValue);</span>
<span class="nc" id="L751">		return returnValue;</span>
	}

	/**
	 * Determine whether this user has the privilege to create a time off request.
	 *
	 * @param isManagerPage - pass true if the is the manager page (Tracking\Schedules). Pass false for the agent page (My Home\My
	 * Schedule).
	 */
	public static boolean getCanCreateTimeOffRequest(RequestContext context, boolean isManagerPage) {
		boolean returnValue;

<span class="nc bnc" id="L763" title="All 2 branches missed.">		if (isManagerPage) {</span>
<span class="nc" id="L764">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.TOM_MODIFYREQUESTSFOREMPLOYEE);</span>
		} else {
<span class="nc" id="L766">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.TOM_MODIFYPERSONALREQUESTS);</span>
		}
<span class="nc" id="L768">		log.debug(&quot; getCanCreateTimeOffRequest boolFlag=&quot; + returnValue);</span>
<span class="nc" id="L769">		return returnValue;</span>
	}

	/**
	 * get show My Schedule Notes and save in theData map
	 *
	 * @param orgID - the ID of the org that you are viewing the schedule for.
	 */
	public static boolean getShowMyScheduleNote(RequestContext context, ID orgID) {
<span class="nc" id="L778">		boolean canView = ScheduleViewUtil.isPrivWithGenScope(context, PrivilegeKeys.FS_VIEWPERSONALSCHEDULECOMMENTS);</span>

<span class="nc bnc" id="L780" title="All 2 branches missed.">		if (!canView) {</span>
			//allow user to see his own schedule if he can view org schedules for his org
<span class="nc" id="L782">			canView = ScheduleViewUtil.isPrivWithOrgScope(context, PrivilegeKeys.FS_VIEWEMPLOYEESCHEDULECOMMENTS, false, orgID);</span>
		}
<span class="nc" id="L784">		return canView;</span>
	}

	/**
	 * get show Schedule Notes for the group view and save in theData map
	 *
	 * @param orgID - the ID of the org that you are viewing the schedule for.
	 */
	public static boolean getShowOrgScheduleNote(RequestContext context, ID orgID) {
<span class="nc" id="L793">		return ScheduleViewUtil.isPrivWithOrgScope(context, PrivilegeKeys.FS_VIEWEMPLOYEESCHEDULECOMMENTS, false, orgID);</span>
	}

	/**
	 * get swap data for personal schedule views
	 */
	private static void putSwapData(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L801">		ID employeeID = context.getUser().getEmployeeID();</span>

<span class="nc" id="L803">		boolean swapEnabled = ScheduleViewUtil.isPrivWithGenScope(context, theData, PrivilegeKeys.SS_READWRITETOSWAPBOARD, SWAP_FLAG_KEY);</span>
<span class="nc" id="L804">		log.debug(&quot; MH.getSwapData swapEnabled = &quot; + swapEnabled);</span>

		//if swap is enabled then get swap board postings for employees with enabled swap flag
<span class="nc bnc" id="L807" title="All 2 branches missed.">		if (swapEnabled) {</span>
<span class="nc" id="L808">			RmManagerFactory factory = RmManagerFactory.getInstance();</span>
<span class="nc" id="L809">			ShiftSwapPostingManager shiftSwapPostingManager = factory.getShiftSwapPostingManager();</span>
<span class="nc" id="L810">			Collection&lt;ShiftSwapPosting&gt; swapPostings = null;</span>
<span class="nc" id="L811">			String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">			if (!viewType.contains(&quot;GROUP&quot;)) {</span>
				//personal
				//get swap board postings from this employeeID
<span class="nc" id="L815">				swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByEmployee(</span>
<span class="nc" id="L816">						employeeID, ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL, true).getPostings();</span>
			} else {
				//group
<span class="nc" id="L819">				ID selectedOrgID = (ID) theData.get(SELECTED_ORG_ID_KEY);</span>
<span class="nc" id="L820">				ID selectedCampaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>

				// No Organization or Campaign was selected then use View Organization. 
<span class="nc bnc" id="L823" title="All 4 branches missed.">				if (selectedOrgID == null &amp;&amp; selectedCampaignID == null) {</span>
<span class="nc" id="L824">					selectedOrgID = ((IDStringPair) theData.get(ScheduleViewMH.ORGS_KEY)).getID();</span>
				}

<span class="nc bnc" id="L827" title="All 2 branches missed.">				if (selectedOrgID != null) {</span>
<span class="nc" id="L828">					swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByOrg(</span>
<span class="nc" id="L829">							selectedOrgID, ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL).getPostings();</span>
<span class="nc bnc" id="L830" title="All 2 branches missed.">				} else if (selectedCampaignID != null) {</span>
<span class="nc" id="L831">					swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByCampaign(</span>
<span class="nc" id="L832">							selectedCampaignID, ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL).getPostings();</span>
				}
			}
<span class="nc" id="L835">			theData.put(SWAP_BOARD_KEY, swapPostings);</span>
<span class="nc" id="L836">			debugLogCollection(&quot;getSwapData&quot;, &quot;swapPostings&quot;, swapPostings);</span>
		}
<span class="nc" id="L838">	}</span>

	/**
	 * Loads a map of all activities defined in the system (key = activity ID, value = activity) and stores this map into theData (with the
	 * key ScheduleViewMH.ACTIVITIES_KEY).
	 *
	 * If theData already contains this map of activities, then this method will not load any additional data or modify theData.
	 *
	 * We also load the activityMedias and activityQueues if we are viewing the net staffing ribbon.
	 */
	public static void putActivities(RequestContext context, HashMap&lt;String, Object&gt; theData) throws RemoteException, BbmException {
<span class="fc bfc" id="L849" title="All 2 branches covered.">		if (!theData.containsKey(ScheduleViewMH.ACTIVITIES_KEY)</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">				|| theData.get(ScheduleViewMH.ACTIVITIES_KEY) == null</span>
<span class="pc bpc" id="L851" title="1 of 2 branches missed.">				|| ((Map&lt;ID, Activity&gt;) theData.get(ScheduleViewMH.ACTIVITIES_KEY)).isEmpty()) {</span>
<span class="fc" id="L852">			HashMap&lt;ID, Activity&gt; activityMap = ActivityModelHandler.getAllActivitiesMap(context);</span>
<span class="fc" id="L853">			theData.put(ACTIVITIES_KEY, activityMap);</span>
<span class="fc" id="L854">			debugLogCollection(&quot;getActivities&quot;, &quot;activityMap&quot;, activityMap);</span>
			//only the net staffing ribbons in the graph views need the activityMedias and activityQueues to be loaded
<span class="fc" id="L856">			String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="pc bpc" id="L857" title="2 of 4 branches missed.">			if (viewType != null &amp;&amp; (viewType.equals(ScheduleViewPM.VIEW_TYPE_MY_GRAPH)</span>
<span class="pc bpc" id="L858" title="1 of 2 branches missed.">					|| viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_GRAPH))</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">					&amp;&amp; getShowNetStaffing(context)) {</span>
<span class="nc" id="L860">				ActivityManager activityManager = WfmManagerFactory.getActivityManager(context.isInWhatIfMode());</span>

<span class="nc" id="L862">				ArrayList&lt;ID&gt; activityIDs = new ArrayList&lt;ID&gt;(activityMap.keySet().size());</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">				for (ID actID : activityMap.keySet()) {</span>
					//for some reason, passing activityMap.keySet() to findMediaForActivities results in
					//ClassCastException: com.bluepumpkin.common.datatypes.ID
<span class="nc" id="L866">					activityIDs.add(actID);</span>
<span class="nc" id="L867">				}</span>
<span class="nc" id="L868">				Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias = activityManager.findMediaForActivities(activityIDs);</span>
<span class="nc" id="L869">				Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues = activityManager.findQueueForActivities(activityIDs);</span>
<span class="nc" id="L870">				theData.put(ScheduleViewMH.ACTIVITY_MEDIAS_KEY, activityMedias);</span>
<span class="nc" id="L871">				theData.put(ScheduleViewMH.ACTIVITY_QUEUES_KEY, activityQueues);</span>
			}
		}
<span class="fc" id="L874">	}</span>

	/**
	 * put org data: name and HOOs into theData
	 */
	private static void putOrgData(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange, ID employeeID)
			throws RemoteException, BbmException {
		//ID employeeID = context.getUser().getEmployeeID();
<span class="fc" id="L882">		ID selectedCampaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>
<span class="fc" id="L883">		log.debug(&quot; MH: selectedCampaignID = &quot; + selectedCampaignID);</span>
		//===== get and store in theData: org ID and Name =====
<span class="fc" id="L885">		ID selectedOrgID = (ID) theData.get(SELECTED_ORG_ID_KEY);</span>
<span class="fc" id="L886">		log.debug(&quot; MH: selectedOrgID = &quot; + selectedOrgID);</span>
<span class="fc" id="L887">		ID orgID = null;</span>
<span class="fc" id="L888">		String orgName = &quot;&quot;;</span>
<span class="fc" id="L889">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="fc bfc" id="L890" title="All 2 branches covered.">		if (selectedOrgID == null) {</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">			if (selectedCampaignID == null) {</span>
				//get org for the single employee
<span class="fc" id="L893">				Collection&lt;WorkResourceAssignment&gt; assignments = workResourceManager.getWorkResourceAssignments(employeeID,</span>
<span class="fc" id="L894">						theTimeRange.getStartDate(), theTimeRange.getEndDate(), false);</span>
<span class="pc bpc" id="L895" title="1 of 2 branches missed.">				for (WorkResourceAssignment assignment : assignments) {</span>
<span class="pc bpc" id="L896" title="1 of 2 branches missed.">					if (assignment != null) {</span>
<span class="fc" id="L897">						orgID = assignment.getOrganizationID();</span>
<span class="fc" id="L898">						orgName = workResourceManager.getOrganizationName(orgID);</span>
						//take the first of assignments in the time range
<span class="fc" id="L900">						break;</span>
					}
<span class="nc" id="L902">				}</span>
<span class="fc" id="L903">			} else {</span>
				//keep orgID as null and name as empty
			}
		} else {
			//use selected org
<span class="fc" id="L908">			orgID = selectedOrgID;</span>
<span class="fc" id="L909">			orgName = workResourceManager.getOrganizationName(orgID);</span>
		}
<span class="fc" id="L911">		log.debug(&quot; MH: current Org name = &quot; + orgName);</span>
<span class="fc" id="L912">		theData.put(ORGS_KEY, new IDStringPair(orgID, orgName));</span>
		//===== get org hoos or campaign hoos (if only campaign ID is selected) ===
<span class="pc bpc" id="L914" title="1 of 2 branches missed.">		if (orgID != null) {</span>
<span class="fc" id="L915">			HOOAssignment hOOAssignment = getOrgHOOs(context, orgID, theTimeRange);</span>
<span class="fc" id="L916">			theData.put(HOOS_KEY, hOOAssignment);</span>
<span class="pc bnc" id="L917" title="All 2 branches missed.">		} else if (selectedCampaignID != null) {</span>
<span class="nc" id="L918">			putCampaignHOOs(context, theData, orgID, theTimeRange);</span>
		}
<span class="fc" id="L920">	}</span>

	/**
	 * get Org HOOs
	 */
	public static HOOAssignment getOrgHOOs(RequestContext context, ID orgID, TimeRange theTimeRange)
			throws RemoteException, BbmException {
<span class="fc" id="L927">		log.debug(&quot; MH: getOrgHoos&quot;);</span>
<span class="fc" id="L928">		Collection&lt;OrganizationHOO&gt; hooAssignments = OrganizationModelHandler.getOrganizationHOOAssignments(context, orgID,</span>
<span class="fc" id="L929">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">		if (hooAssignments != null) {</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">			for (HOOAssignment hOOAssignment : hooAssignments) {</span>
				//use the first one
<span class="fc" id="L933">				return hOOAssignment;</span>
			}
		}
<span class="nc" id="L936">		return null;</span>
	}

	/**
	 * Get the start day of the week for the employee's organization.
	 *
	 * @return the week start day for the employye's org (ex: Calendar.FRIDAY)
	 */
	public static int getWeekStartDayForEmp(RequestContext context, ID employeeID, Organization org) {
<span class="fc" id="L945">		int weekStartDay = Calendar.SUNDAY;</span>
		try {
			//Organization org = getOrganizationForEmp(context, employeeID);
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">			if (org != null) {</span>
<span class="fc" id="L949">				weekStartDay = org.getWeekStartDate();</span>
			}
<span class="nc" id="L951">		} catch (Exception ex) {</span>
<span class="nc" id="L952">			log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="fc" id="L953">		}</span>
<span class="fc" id="L954">		return weekStartDay;</span>
	}

	/**
	 * Get the employee's organization.
	 *
	 * @return the employye's first org assignment in the current week.
	 */
	public static Organization getOrganizationForEmp(RequestContext context, ID employeeID) {
		//--- get current week start as Sunday 12:00am in the viewing TZ
<span class="fc" id="L964">		Calendar thisWeekStart = Calendar.getInstance(context.getViewingTimeZone(), context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="fc" id="L965">		int weekDay = thisWeekStart.get(Calendar.DAY_OF_WEEK);</span>
<span class="fc" id="L966">		thisWeekStart.add(Calendar.DATE, (-1) * (weekDay - 1));</span>
<span class="fc" id="L967">		thisWeekStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L968">		thisWeekStart.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L969">		thisWeekStart.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L970">		thisWeekStart.set(Calendar.MILLISECOND, 0);</span>

<span class="fc" id="L972">		Calendar thisWeekEnd = Calendar.getInstance(context.getViewingTimeZone(), context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="fc" id="L973">		thisWeekEnd.setTime(thisWeekStart.getTime());</span>
<span class="fc" id="L974">		thisWeekEnd.add(Calendar.DATE, 7);</span>
<span class="fc" id="L975">		thisWeekEnd.add(Calendar.SECOND, -1);</span>

<span class="fc" id="L977">		Organization org = null;</span>
		try {
<span class="fc" id="L979">			WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="fc" id="L980">			Collection&lt;WorkResourceAssignment&gt; assignments = workResourceManager.getWorkResourceAssignments(employeeID,</span>
<span class="fc" id="L981">					thisWeekStart.getTime(), thisWeekEnd.getTime(), false);</span>

<span class="pc bpc" id="L983" title="1 of 2 branches missed.">			for (WorkResourceAssignment assignment : assignments) {</span>
<span class="pc bpc" id="L984" title="1 of 2 branches missed.">				if (assignment != null) {</span>
<span class="fc" id="L985">					ID orgID = assignment.getOrganizationID();</span>
<span class="fc" id="L986">					org = workResourceManager.getOrganizationByID(orgID);</span>
					//take the first of assignments in the time range
<span class="fc" id="L988">					break;</span>
				}
<span class="nc" id="L990">			}</span>
<span class="nc" id="L991">		} catch (Exception ex) {</span>
<span class="nc" id="L992">			log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="fc" id="L993">		}</span>

<span class="fc" id="L995">		return org;</span>
	}

	/**
	 * put Campaign HOOs into theData
	 */
	private static void putCampaignHOOs(RequestContext context, HashMap&lt;String, Object&gt; theData, ID campaignID, TimeRange theTimeRange)
			throws RemoteException, BbmException {
<span class="nc" id="L1003">		log.debug(&quot; MH: getCampaignHOOs&quot;);</span>
<span class="nc" id="L1004">		Collection&lt;CampaignHOO&gt; hooAssignments = CampaignModelHandler.getCampaignHOOAssignments(context, campaignID,</span>
<span class="nc" id="L1005">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc bnc" id="L1006" title="All 2 branches missed.">		if (hooAssignments != null) {</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">			for (HOOAssignment hOOAssignment : hooAssignments) {</span>
<span class="nc" id="L1008">				theData.put(HOOS_KEY, hOOAssignment);</span>
				//use the first one
<span class="nc" id="L1010">				break;</span>
			}
		}
<span class="nc" id="L1013">	}</span>

	/**
	 * Get a list of the org HOOAssignments, one for each employee.
	 *
	 * @param context The context.
	 * @param theTimeRange This range is used to find the org that each employee is assigned to.
	 * @param employeeIDs The list of employees which you need HOOAssignments for.
	 * @return a list of the org HOOAssignments, one for each employee.
	 */
	private static Collection&lt;HOOAssignment&gt; getEmployeeHooAssignments(RequestContext context, TimeRange theTimeRange,
			Collection&lt;ID&gt; employeeIDs)
			throws RemoteException, BbmException {
<span class="fc" id="L1026">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="fc" id="L1027">		Collection&lt;HOOAssignment&gt; hooAssignments = new ArrayList&lt;HOOAssignment&gt;();</span>
		//used so that we only need to look up HOO's once per org
<span class="fc" id="L1029">		HashMap&lt;ID, HOOAssignment&gt; orgIdToHooMap = new HashMap&lt;ID, HOOAssignment&gt;();</span>
<span class="fc bfc" id="L1030" title="All 2 branches covered.">		for (ID employeeID : employeeIDs) {</span>
<span class="fc" id="L1031">			HOOAssignment hooAssignment = null;</span>
<span class="fc" id="L1032">			Collection&lt;WorkResourceAssignment&gt; orgAssignments = workResourceManager.getWorkResourceAssignments(employeeID,</span>
<span class="fc" id="L1033">					theTimeRange.getStartDate(), theTimeRange.getEndDate(), false);</span>
<span class="pc bpc" id="L1034" title="1 of 2 branches missed.">			for (WorkResourceAssignment orgAssignment : orgAssignments) {</span>
<span class="pc bpc" id="L1035" title="1 of 2 branches missed.">				if (orgAssignment != null) {</span>
<span class="fc" id="L1036">					ID orgID = orgAssignment.getOrganizationID();</span>
<span class="fc" id="L1037">					hooAssignment = orgIdToHooMap.get(orgID);</span>
<span class="pc bpc" id="L1038" title="1 of 2 branches missed.">					if (hooAssignment == null) {</span>
<span class="fc" id="L1039">						hooAssignment = getOrgHOOs(context, orgID, theTimeRange);</span>
<span class="fc" id="L1040">						orgIdToHooMap.put(orgID, hooAssignment);</span>
					}
					//take the first org assignment in the time range
					break;
				}
<span class="nc" id="L1045">			}</span>
<span class="fc" id="L1046">			hooAssignments.add(hooAssignment);</span>
<span class="fc" id="L1047">		}</span>
<span class="fc" id="L1048">		return hooAssignments;</span>
	}

	/**
	 * get legend data
	 *
	 * @param myEmpID - The ID of the currently logged-in user
	 * @hasHidenTimeOffEvents: true: Not show real activity name, only show &quot;Time Off&quot;
	 */
	private static void putLegendData(RequestContext context, HashMap&lt;String, Object&gt; theData, ID myEmpID, boolean hasHidenTimeOffEvents) {
<span class="nc" id="L1058">		ArrayList theLegendData = new ArrayList();</span>
		//the schedule may be a simple collection for personal view of collection of collections
<span class="nc" id="L1060">		Collection theScheduleItems = getAllScheduleItemsFromMap(theData);</span>
<span class="nc bnc" id="L1061" title="All 4 branches missed.">		if (theScheduleItems != null &amp;&amp; theScheduleItems.size() &gt; 0) {</span>
			// get collection of activity IDs from the schedule
<span class="nc" id="L1063">			boolean bShowTimeoff = ScheduleViewPM.getBooleanFromMap(theData, ScheduleViewMH.SHOW_TIMEOFF_KEY);</span>
<span class="nc" id="L1064">			Collection activityIDs = ScheduleViewUtil.getScheduledActivityIDs(theScheduleItems, myEmpID, bShowTimeoff);</span>

			// load all activities in the schedule
<span class="nc" id="L1067">			HashMap activities = (HashMap) theData.get(ACTIVITIES_KEY);</span>

			// package activity names and colors
<span class="nc bnc" id="L1070" title="All 4 branches missed.">			if (activityIDs != null &amp;&amp; activityIDs.size() &gt; 0) {</span>

<span class="nc bnc" id="L1072" title="All 2 branches missed.">				for (Iterator it = activityIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1073">					ID activityID = (ID) it.next();</span>
<span class="nc" id="L1074">					Activity activity = (Activity) activities.get(activityID);</span>

					//timeoff activities are pre-filtered from the activities collection, but unavailabilities are not
<span class="nc" id="L1077">					boolean bShowUnavailable = ScheduleViewPM.getBooleanFromMap(theData, ScheduleViewMH.SHOW_UNAVAILABLE_KEY);</span>
<span class="nc" id="L1078">					String generalTimeOffEvent = context.getLocalizer().i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.FS_CUSTOM_TIME_OFF);</span>

<span class="nc bnc" id="L1080" title="All 2 branches missed.">					if (activity != null) {</span>
<span class="nc bnc" id="L1081" title="All 6 branches missed.">						if (activity.isTimeoff() &amp;&amp; hasHidenTimeOffEvents &amp;&amp; bShowTimeoff) {</span>
							//Not show absent reason of time off since it has hidden time off event
							//Default color of shift assignment
<span class="nc" id="L1084">							String eventColor = &quot;0000FF&quot;;</span>
<span class="nc" id="L1085">							theLegendData.add(new StringsPair(eventColor, generalTimeOffEvent));</span>
<span class="nc bnc" id="L1086" title="All 4 branches missed.">						} else if (!(activity.isUnavailability() &amp;&amp; !bShowUnavailable)) {</span>
							//Show absent reason
<span class="nc" id="L1088">							theLegendData.add(new StringsPair(activity.getColor(), activity.getName()));</span>
						}
					}
<span class="nc" id="L1091">				}</span>
			}
			//Overtime item to be added before rendering in the page model
		}
<span class="nc" id="L1095">		theData.put(LEGEND_ITEMS_KEY, theLegendData);</span>
<span class="nc" id="L1096">		debugLogCollection(&quot;putLegendData&quot;, &quot;theLegendData&quot;, theLegendData);</span>
<span class="nc" id="L1097">	}</span>

	/**
	 * get schedule items from the data map in one collection even for the group
	 *
	 * @param theData
	 * @return
	 */
	public static Collection getAllScheduleItemsFromMap(HashMap&lt;String, Object&gt; theData) {
		//the schedule may be a simple collection for personal view of collection of collections
		Collection theScheduleItems;
<span class="nc" id="L1108">		String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="nc bnc" id="L1109" title="All 4 branches missed.">		if (StringUtil.isEmpty(viewType) || viewType.contains(&quot;GROUP&quot;)) {</span>
			// group - package multiple collections into one
<span class="nc" id="L1111">			theScheduleItems = getGroupScheduleItems(theData);</span>
		} else {
			//personal
<span class="nc" id="L1114">			theScheduleItems = (Collection) theData.get(SCHEDULE_ITEMS_KEY);</span>
		}
<span class="nc" id="L1116">		return theScheduleItems;</span>
	}

	/**
	 * make one collection of schedule items from the group schedule - used for the legend
	 */
	public static Collection getGroupScheduleItems(HashMap&lt;String, Object&gt; theData) {
<span class="nc" id="L1123">		ArrayList scheduleItems = new ArrayList();</span>
<span class="nc" id="L1124">		Collection groupItems = (Collection) theData.get(SCHEDULE_ITEMS_KEY);</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">		if (groupItems != null) {</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">			for (Iterator it = groupItems.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1127">				Collection personItems = (Collection) it.next();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">				if (personItems != null) {</span>
<span class="nc bnc" id="L1129" title="All 2 branches missed.">					for (Iterator jt = personItems.iterator(); jt.hasNext();) {</span>
<span class="nc" id="L1130">						scheduleItems.add(jt.next());</span>
					}
				}
<span class="nc" id="L1133">			}</span>
		}
<span class="nc" id="L1135">		return scheduleItems;</span>
	}

	/**
	 * get time range as this week for the user org.
	 */
	private static TimeRange getTimeRange(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="nc" id="L1143">		Calendar startCal = getThisWeekStart(context, theData);</span>
<span class="nc" id="L1144">		Calendar endCal = getThisWeekEnd(context, startCal);</span>
<span class="nc" id="L1145">		TimeRange timeRange = new TimeRange(startCal.getTime(), endCal.getTime());</span>

<span class="nc" id="L1147">		context.setAttribute(RequestContext.SESSION_SCOPE, UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, timeRange);</span>
<span class="nc" id="L1148">		return timeRange;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Shift and Sechedule Helper
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * flatten schedule for each employee in the group schedule collection
	 */
	public static Collection&lt;Collection&lt;SimpleEvent&gt;&gt; flattenGroupSchedule(Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule) {
<span class="nc" id="L1158">		log.debug(&quot; MH.flattenGroupSchedule&quot;);</span>
<span class="nc" id="L1159">		ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; flatSchedule = new ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;();</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">		if (groupSchedule != null) {</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">			for (Iterator&lt;Collection&lt;? extends Event&gt;&gt; i = groupSchedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1162">				flatSchedule.add(flattenSchedule(i.next()));</span>
			}
		}
<span class="nc" id="L1165">		return flatSchedule;</span>
	}

	/**
	 * flatten and merge schedule collection of events
	 */
	private static Collection&lt;SimpleEvent&gt; flattenSchedule(Collection&lt;? extends Event&gt; events) {
<span class="nc" id="L1172">		Collection&lt;SimpleEvent&gt; flatSchedule = EventUtils.convertEventsToTimelineForSingleEmployee(events);</span>
<span class="nc" id="L1173">		debugLogCollection(&quot;flattenSchedule&quot;, &quot;flatSchedule&quot;, flatSchedule);</span>
<span class="nc" id="L1174">		Collection&lt;SimpleEvent&gt; mergedSchedule = EventUtils.mergeSameEvents(flatSchedule);</span>
		//debugLogCollection(&quot;flattenSchedule&quot;, &quot;mergedSchedule&quot;, mergedSchedule);
<span class="nc" id="L1176">		return mergedSchedule;</span>
	}

	/**
	 * flatten schedule for each employee in the group schedule collection
	 */
	public static Collection&lt;Collection&lt;SimpleEvent&gt;&gt; markGroupOvertimeEvents(Collection&lt;Collection&lt;SimpleEvent&gt;&gt; groupSchedule,
			Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts) {
<span class="nc" id="L1184">		log.debug(&quot; MH.markGroupOvertimeEvents&quot;);</span>
<span class="nc" id="L1185">		ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; markedSchedule = new ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;();</span>
<span class="nc bnc" id="L1186" title="All 4 branches missed.">		if (groupSchedule != null &amp;&amp; groupShifts != null) {</span>
			//FIXME: explicit casts to lists here....the method signature was a collection
<span class="nc" id="L1188">			ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; gSched = (ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;) groupSchedule;</span>
<span class="nc" id="L1189">			ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt; gShifts = (ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt;) groupShifts;</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">			for (int i = 0; i &lt; gSched.size(); i++) {</span>
<span class="nc" id="L1191">				markedSchedule.add(markOvertimeEvents(gSched.get(i), gShifts.get(i)));</span>
			}
		}
<span class="nc" id="L1194">		return markedSchedule;</span>
	}

	/**
	 * mark events within shift extensions as overtime
	 *
	 * @param scheduleData - collection of SimpleEvent objects in chronological order
	 * @param scheduleShifts - collection of SimpleEvent shift assignments in chronological order
	 * @return
	 */
	private static Collection&lt;SimpleEvent&gt; markOvertimeEvents(Collection&lt;SimpleEvent&gt; scheduleData,
			Collection&lt;ShiftAssignment&gt; scheduleShifts) {
<span class="nc" id="L1206">		ArrayList&lt;TimeRange&gt; overtimePeriods = (ArrayList&lt;TimeRange&gt;) findOvertimePeriods(scheduleShifts);</span>
		//if no overtime return original collection of flattened events
<span class="nc bnc" id="L1208" title="All 2 branches missed.">		if (overtimePeriods.size() &lt;= 0) {</span>
<span class="nc" id="L1209">			return scheduleData;</span>
		}
		//else repackage scheduleData collection since may have to split some events
<span class="nc" id="L1212">		ArrayList&lt;SimpleEvent&gt; markedEvents = new ArrayList&lt;SimpleEvent&gt;();</span>
		//for each event in scheduleData process event
<span class="nc bnc" id="L1214" title="All 2 branches missed.">		for (Iterator&lt;SimpleEvent&gt; it = scheduleData.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1215">			markEventOvertime(overtimePeriods, it.next(), markedEvents);</span>
		}
<span class="nc" id="L1217">		return markedEvents;</span>
	}

	/**
	 * find shift assignments overitme periods
	 *
	 * @param scheduleShifts
	 * @return collection of overtime TimeRanges or empty
	 */
	private static Collection&lt;TimeRange&gt; findOvertimePeriods(Collection&lt;ShiftAssignment&gt; scheduleShifts) {
<span class="nc" id="L1227">		ArrayList&lt;TimeRange&gt; overtimeRanges = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L1228" title="All 4 branches missed.">		if (scheduleShifts != null &amp;&amp; scheduleShifts.size() &gt; 0) {</span>
<span class="nc" id="L1229">			SortEvents se = new SortEvents();</span>
			//FIXME: explicit casts to lists here....the method signature was a collection
<span class="nc" id="L1231">			Collections.sort((List) scheduleShifts,</span>
<span class="nc" id="L1232">					se.getEventSorter(SortEvents.SORT_BY_START, SupportNavigation.SORT_ASCENDING));</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">			for (ShiftAssignment sa : scheduleShifts) {</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">				if (sa != null) {</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">					if (sa.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L1236">						TimeRange ot = new TimeRange(sa.getStartTime(), sa.getExtensionBefore() * 60000);</span>
<span class="nc" id="L1237">						overtimeRanges.add(ot);</span>
					}
<span class="nc bnc" id="L1239" title="All 2 branches missed.">					if (sa.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L1240">						TimeRange ot = new TimeRange(new Date(sa.getEndTime().getTime() - sa.getExtensionAfter() * 60000), sa.getEndTime());</span>
<span class="nc" id="L1241">						overtimeRanges.add(ot);</span>
					}
				}
<span class="nc" id="L1244">			}</span>
		}
<span class="nc" id="L1246">		return overtimeRanges;</span>
	}

	/**
	 * process one SimpleEvent marking overtime and adding to marked collection
	 */
	private static void markEventOvertime(ArrayList&lt;TimeRange&gt; OTPeriods, SimpleEvent event, Collection&lt;SimpleEvent&gt; markedEvents) {
<span class="nc bnc" id="L1253" title="All 2 branches missed.">		if (OTPeriods.size() &lt;= 0) {</span>
<span class="nc" id="L1254">			markedEvents.add(event);</span>
<span class="nc" id="L1255">			return;</span>
		}
<span class="nc" id="L1257">		TimeRange overtimeRange = OTPeriods.get(0);</span>
<span class="nc" id="L1258">		TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1259">		int overlapType = eventRange.getRelativeLocationTo(overtimeRange);</span>
<span class="nc bnc" id="L1260" title="All 4 branches missed.">		if (overlapType == TimeRange.INTERVAL_IN || overlapType == TimeRange.INTERVAL_EQUALS</span>
<span class="nc bnc" id="L1261" title="All 2 branches missed.">				|| event.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP) == 0) {</span>
			//consider Overtime GAP belongs to Overtime
<span class="nc" id="L1263">			event.setIsOvertime(true);</span>
<span class="nc" id="L1264">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_BEFORE) {</span>
			//keep the same overtime period in the future on the timeline
<span class="nc" id="L1267">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1268" title="All 2 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_AFTER) {</span>
			//try next overtime period recursively
<span class="nc" id="L1270">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
<span class="nc bnc" id="L1271" title="All 4 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_BEFORE_AND_IN</span>
				|| overlapType == TimeRange.INTERVAL_COVERS
<span class="nc bnc" id="L1273" title="All 2 branches missed.">				&amp;&amp; overtimeRange.getEndDate().getTime() == eventRange.getEndDate().getTime()) {</span>
			//split event (eventStart,overtimeStart)(overtimeStart,eventEnd) and mark the second overtime
<span class="nc" id="L1275">			addSplitPartOfEvent(event, null, overtimeRange.getStartDate(), false, markedEvents);</span>
			//second event is adjusted event;
<span class="nc" id="L1277">			event.setStartTime(overtimeRange.getStartDate());</span>
<span class="nc" id="L1278">			event.setIsOvertime(true);</span>
<span class="nc" id="L1279">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1280" title="All 4 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_AFTER_AND_IN</span>
				|| overlapType == TimeRange.INTERVAL_COVERS
<span class="nc bnc" id="L1282" title="All 2 branches missed.">				&amp;&amp; overtimeRange.getStartDate().getTime() == eventRange.getStartDate().getTime()) {</span>
			//split event (eventStart,overlapEnd) (overlapEnd,eventEnd), mark first overtime and add to marked
<span class="nc" id="L1284">			addSplitPartOfEvent(event, null, overtimeRange.getEndDate(), true, markedEvents);</span>
			//try next overtime recursively with second event which is adjusted event
<span class="nc" id="L1286">			event.setStartTime(overtimeRange.getEndDate());</span>
<span class="nc" id="L1287">			event.setIsOvertime(false);</span>
<span class="nc" id="L1288">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
		} else {
			//event covers overtime, and overtime starts after event start and ends before event end
			//split event to three events (eventStart,overtimeStart),(overtimeStart,overtimeEnd),(overtimeEnd,eventEnd)
			//mark second overtime, move two first to marked
<span class="nc" id="L1293">			addSplitPartOfEvent(event, null, overtimeRange.getStartDate(), false, markedEvents);</span>
<span class="nc" id="L1294">			addSplitPartOfEvent(event, overtimeRange.getStartDate(), overtimeRange.getEndDate(), true, markedEvents);</span>
			//try next overtime recursively with third event which is adjusted event
<span class="nc" id="L1296">			event.setStartTime(overtimeRange.getEndDate());</span>
<span class="nc" id="L1297">			event.setIsOvertime(false);</span>
<span class="nc" id="L1298">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
		}
<span class="nc" id="L1300">	}</span>

	/**
	 * process one SimpleEvent marking overtime and adding to marked collection trying with consecutive overtime periods
	 */
	private static void markEventWithNextOvertime(ArrayList&lt;TimeRange&gt; OTPeriods, SimpleEvent event, Collection markedEvents) {
<span class="nc bnc" id="L1306" title="All 2 branches missed.">		if (OTPeriods.size() &gt; 0) {</span>
<span class="nc" id="L1307">			OTPeriods.remove(0);</span>
<span class="nc" id="L1308">			markEventOvertime(OTPeriods, event, markedEvents);</span>
		} else {
			//no overtime left - move second event to marked
<span class="nc" id="L1311">			markedEvents.add(event);</span>
		}
<span class="nc" id="L1313">	}</span>

	/**
	 * @param event
	 * @param startOrNull
	 * @param endOrNull
	 * @param bOvertime
	 */
	private static void addSplitPartOfEvent(SimpleEvent event, Date startOrNull, Date endOrNull, boolean bOvertime,
			Collection markedEvents) {
<span class="nc" id="L1323">		SimpleEvent newEvent = new SimpleEvent(event);</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">		if (startOrNull != null) {</span>
<span class="nc" id="L1325">			newEvent.setStartTime(startOrNull);</span>
		}
<span class="nc bnc" id="L1327" title="All 2 branches missed.">		if (endOrNull != null) {</span>
<span class="nc" id="L1328">			newEvent.setEndTime(endOrNull);</span>
		}
<span class="nc" id="L1330">		newEvent.setIsOvertime(bOvertime);</span>
<span class="nc" id="L1331">		markedEvents.add(newEvent);</span>
<span class="nc" id="L1332">	}</span>

	/**
	 * select only shifts from each of the schedule in the group
	 */
	public static Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; selectGroupShifts(Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule) {
<span class="pc bpc" id="L1338" title="1 of 2 branches missed.">		if (groupSchedule == null) {</span>
<span class="nc" id="L1339">			return null;</span>
		}
<span class="fc" id="L1341">		ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = new ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt;();</span>
<span class="fc bfc" id="L1342" title="All 2 branches covered.">		for (Iterator&lt;Collection&lt;? extends Event&gt;&gt; i = groupSchedule.iterator(); i.hasNext();) {</span>
<span class="fc" id="L1343">			groupShifts.add(selectOnlyShiftAssignments((Collection&lt;? extends Event&gt;) i.next()));</span>
		}
<span class="fc" id="L1345">		return groupShifts;</span>
	}

	/**
	 * select only shift assignments from all schedule events
	 */
	public static Collection&lt;ShiftAssignment&gt; selectOnlyShiftAssignments(Collection&lt;? extends Event&gt; scheduleEvents) {
<span class="fc" id="L1352">		ArrayList&lt;ShiftAssignment&gt; shifts = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="pc bpc" id="L1353" title="1 of 4 branches missed.">		if (scheduleEvents != null &amp;&amp; scheduleEvents.size() &gt; 0) {</span>
<span class="fc bfc" id="L1354" title="All 2 branches covered.">			for (Event event : scheduleEvents) {</span>
<span class="pc bpc" id="L1355" title="1 of 2 branches missed.">				if (event != null) {</span>
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">					if (event.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1357">						shifts.add((ShiftAssignment) event);</span>
					}
				}
<span class="fc" id="L1360">			}</span>
		}
<span class="fc" id="L1362">		debugLogCollection(&quot;selectOnlyShiftAssignments&quot;, &quot;shifts&quot;, shifts);</span>
<span class="fc" id="L1363">		return shifts;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Published Periods
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Get published periods
	 *
	 * @return single collection of TimeRanges
	 *
	 */
	public static Collection&lt;TimeRange&gt; getTimeRangesForPublishedPeriods(
			Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, Collection&lt;ID&gt; eIDs)
			throws RemoteException, BbmException {
<span class="nc" id="L1379">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="nc" id="L1381">		Collection&lt;TimeRange&gt; ppTimeRanges = null;</span>
<span class="nc bnc" id="L1382" title="All 4 branches missed.">		if (pubPeriodsForEmps != null &amp;&amp; !pubPeriodsForEmps.isEmpty()) {</span>
<span class="nc bnc" id="L1383" title="All 2 branches missed.">			for (Collection&lt;PublishingPeriod&gt; personalPeriods : pubPeriodsForEmps) {</span>
<span class="nc" id="L1384">				ppTimeRanges = makeTimeRanges(personalPeriods);</span>
<span class="nc" id="L1385">			}</span>
		}
<span class="nc" id="L1387">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;publishedPeriods&quot;, ppTimeRanges);</span>

<span class="nc" id="L1389">		theData.put(PUB_PERIODS_KEY, ppTimeRanges);</span>
<span class="nc" id="L1390">		return ppTimeRanges;</span>
	}

	/**
	 * Get published periods
	 *
	 * @return Collection of Collections of TimeRanges for each eID
	 *
	 */
	public static Collection&lt;Collection&lt;TimeRange&gt;&gt; getTimeRangesForPublishedPeriodsForGroupView(
			Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			Collection&lt;ID&gt; eIDs)
			throws RemoteException, BbmException {
<span class="fc" id="L1403">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="fc" id="L1405">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = null;</span>
<span class="pc bpc" id="L1406" title="2 of 4 branches missed.">		if (pubPeriodsForEmps != null &amp;&amp; !pubPeriodsForEmps.isEmpty()) {</span>

<span class="fc" id="L1408">			int size = pubPeriodsForEmps.size();</span>
<span class="fc" id="L1409">			ppTimeRanges = new ArrayList&lt;Collection&lt;TimeRange&gt;&gt;(size);</span>

<span class="fc bfc" id="L1411" title="All 2 branches covered.">			for (Collection&lt;PublishingPeriod&gt; personalPeriods : pubPeriodsForEmps) {</span>
<span class="fc" id="L1412">				ppTimeRanges.add(makeTimeRanges(personalPeriods));</span>
<span class="fc" id="L1413">			}</span>
		}
<span class="fc" id="L1415">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;publishedPeriods&quot;, ppTimeRanges);</span>

<span class="fc" id="L1417">		theData.put(PUB_PERIODS_KEY, ppTimeRanges);</span>
<span class="fc" id="L1418">		return ppTimeRanges;</span>
	}

	/**
	 * convert collection of PublishingPeriod objects into collection of TimeRange objects
	 */
	public static Collection&lt;TimeRange&gt; makeTimeRanges(Collection&lt;PublishingPeriod&gt; pubPeriods) {
<span class="fc bfc" id="L1425" title="All 2 branches covered.">		if (pubPeriods == null) {</span>
<span class="fc" id="L1426">			return null;</span>
		}
<span class="fc" id="L1428">		ArrayList&lt;TimeRange&gt; ranges = new ArrayList&lt;TimeRange&gt;();</span>
<span class="fc bfc" id="L1429" title="All 2 branches covered.">		for (PublishingPeriod tp : pubPeriods) {</span>
<span class="fc" id="L1430">			ranges.add(new TimeRange(tp.getStartTime(), tp.getEndTime()));</span>
<span class="fc" id="L1431">		}</span>
<span class="fc" id="L1432">		return ranges;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// User / Organization Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * put user org ID in theData
	 */
	public static ID putUserOrgID(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="fc" id="L1443">		ID userOrgID = (ID) theData.get(USER_ORG_ID_KEY);</span>
<span class="pc bpc" id="L1444" title="1 of 2 branches missed.">		if (userOrgID == null) {</span>
			//try to get from employee
<span class="fc" id="L1446">			ID employeeID = context.getUser().getEmployeeID();</span>
<span class="pc bpc" id="L1447" title="1 of 2 branches missed.">			if (employeeID != null) {</span>
<span class="fc" id="L1448">				userOrgID = OrganizationModelHandler.getEmployeeOrgID(context, employeeID);</span>
			}
<span class="fc" id="L1450">			log.debug(&quot; MH userEmployeeID = &quot; + employeeID + &quot;\t userOrgID = &quot; + userOrgID);</span>
<span class="fc" id="L1451">			theData.put(USER_ORG_ID_KEY, userOrgID);</span>
		}
<span class="fc" id="L1453">		return userOrgID;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Date Time Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * get this week start for the current user/org
	 */
	public static Calendar getThisWeekStart(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
		//--- get current week start as Sunday 12:00am in the viewing TZ
<span class="fc" id="L1465">		Calendar thisWeekStart = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="fc" id="L1466">				context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="fc" id="L1467">		int weekDay = thisWeekStart.get(Calendar.DAY_OF_WEEK);</span>
<span class="fc" id="L1468">		thisWeekStart.add(Calendar.DATE, (-1) * (weekDay - 1));</span>
<span class="fc" id="L1469">		thisWeekStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L1470">		thisWeekStart.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L1471">		thisWeekStart.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L1472">		thisWeekStart.set(Calendar.MILLISECOND, 0);</span>

		//--- get employee ID -&gt; Org ID - &gt; Org week start offset
<span class="fc" id="L1475">		ID userOrgID = (ID) theData.get(ScheduleViewMH.USER_ORG_ID_KEY);</span>
<span class="pc bpc" id="L1476" title="1 of 2 branches missed.">		if (userOrgID != null) {</span>
<span class="fc" id="L1477">			WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="fc" id="L1478">			Organization org = workResourceManager.getOrganizationByID(userOrgID);</span>
<span class="fc" id="L1479">			short weekStartDate = org.getWeekStartDate();</span>
			//--- apply org weekstart offset
<span class="pc bpc" id="L1481" title="1 of 2 branches missed.">			int dayOffset = (weekStartDate &gt; weekDay) ? weekStartDate - 1 - 7 : weekStartDate - 1;</span>
<span class="fc" id="L1482">			thisWeekStart.add(Calendar.DATE, dayOffset);</span>
		}
<span class="fc" id="L1484">		log.debug(&quot; MH.getThisWeekStart: &quot; + thisWeekStart.getTime());</span>
<span class="fc" id="L1485">		return thisWeekStart;</span>
	}

	/**
	 * get this week end for the current user/org based on week start
	 */
	public static Calendar getThisWeekEnd(RequestContext context, Calendar weekStart) {
<span class="fc" id="L1492">		Calendar thisWeekEnd = Calendar.getInstance(context.getViewingTimeZone(), context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="fc" id="L1493">		thisWeekEnd.setTime(weekStart.getTime());</span>
<span class="fc" id="L1494">		thisWeekEnd.add(Calendar.DATE, 7);</span>
<span class="fc" id="L1495">		thisWeekEnd.add(Calendar.SECOND, -1);</span>
<span class="fc" id="L1496">		return thisWeekEnd;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Filter Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Return employe IDS where current user has privilege to view schedule.
	 */
	public static Collection&lt;ID&gt; getEmpIDsForSchedViewing(RequestContext context, ID orgPrivID, Collection&lt;ID&gt; empIDs) throws Exception {
<span class="fc" id="L1506">		User user = context.getUser();</span>
		// Need to return collection in same order
<span class="fc" id="L1508">		Set authorizedEmpIDSet = PeopleMH.isAuthorizedToOrg(context, user, empIDs, orgPrivID);</span>
<span class="fc" id="L1509">		ArrayList&lt;ID&gt; result = new ArrayList&lt;ID&gt;(empIDs.size());</span>
<span class="fc bfc" id="L1510" title="All 2 branches covered.">		for (ID empID : empIDs) {</span>
<span class="pc bpc" id="L1511" title="1 of 2 branches missed.">			if (authorizedEmpIDSet.contains(empID)) {</span>
<span class="fc" id="L1512">				result.add(empID);</span>
			}
<span class="fc" id="L1514">		}</span>
<span class="fc" id="L1515">		return result;</span>
	}

	/**
	 * get employee IDs - the full sorted collection if the sortField is EMP_SORT_NOT_BY_NAME then sorting is done outside
	 */
	private static Collection&lt;ID&gt; getEmployeeIDs(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, ID userOrgID, int sortField)
			throws RemoteException, BbmException {

<span class="nc" id="L1525">		log.debug(&quot;Enter MH.getEmployeeIDs&quot;);</span>
<span class="nc" id="L1526">		Collection&lt;ID&gt; eIDs = null; //to return it</span>
<span class="nc" id="L1527">		Filter filter = null;</span>
<span class="nc" id="L1528">		Filter orgFilter = null;</span>
<span class="nc" id="L1529">		Filter campaignFilter = null;</span>
		//this means that no page message will be displayed
<span class="nc" id="L1531">		String groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_OK;</span>

<span class="nc" id="L1533">		Collection&lt;ID&gt; rmOrgIDs = getGroupViewOrgIDs(userOrgID);</span>
<span class="nc" id="L1534">		debugLogCollection(&quot;getEmployeeIDs&quot;, &quot;orgIDs&quot;, eIDs);</span>

<span class="nc bnc" id="L1536" title="All 2 branches missed.">		if (orgID != null) {</span>
			//check the privs for the selected org
<span class="nc" id="L1538">			boolean groupViewEnabled = ScheduleViewUtil.isPrivWithOrgScope(context, theData,</span>
					PrivilegeKeys.FS_VIEWORGSCHEDULES, GROUPVIEW_FLAG_KEY, false, orgID);

<span class="nc bnc" id="L1541" title="All 6 branches missed.">			boolean isInRmOrgs = (rmOrgIDs != null &amp;&amp; !rmOrgIDs.isEmpty() &amp;&amp; rmOrgIDs.contains(orgID));</span>

<span class="nc bnc" id="L1543" title="All 4 branches missed.">			if (!groupViewEnabled &amp;&amp; !isInRmOrgs) {</span>
<span class="nc" id="L1544">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_1;</span>
			} else {
				//org OK
<span class="nc" id="L1547">				orgFilter = getFilterForOrg(context, theTimeRange, theDayRange, orgID);</span>
<span class="nc" id="L1548">				boolean useFilter = true;</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">				if (campaignID != null) {</span>
					//need dual filter
<span class="nc" id="L1551">					Collection&lt;ID&gt; orgIDsInCampaign = getOrgIDsInCampaign(context, campaignID, theTimeRange);</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">					if (!orgIDsInCampaign.contains(orgID)) {</span>
<span class="nc" id="L1553">						useFilter = false;</span>
<span class="nc" id="L1554">						groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOLINK_1;</span>
					} else {
<span class="nc" id="L1556">						campaignFilter = getFilterForCampaign(context, theTimeRange, theDayRange, campaignID);</span>
					}
				}
<span class="nc bnc" id="L1559" title="All 2 branches missed.">				if (useFilter) {</span>
<span class="nc" id="L1560">					filter = getCombinedFilter(context, orgFilter, campaignFilter);</span>
				}
			}
<span class="nc bnc" id="L1563" title="All 2 branches missed.">		} else if (campaignID != null) {</span>
			//only campaign is selected
			//check if can view all or some orgs in the campaign
<span class="nc" id="L1566">			Collection&lt;ID&gt; orgIDsInCampaign = getOrgIDsInCampaign(context, campaignID, theTimeRange);</span>
<span class="nc bnc" id="L1567" title="All 4 branches missed.">			if (orgIDsInCampaign == null || orgIDsInCampaign.isEmpty()) {</span>
<span class="nc" id="L1568">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOLINK_2;</span>
			} else {
				//Get all the orgs that are in the user's scope.  We need to do this in order to determine/catch
				//the employees that may belong to other organizations in the user's scope but are pooled at organizations
				//linked to this SP.
<span class="nc" id="L1573">				Collection&lt;ID&gt; orgIDsInAccessRights = OrganizationModelHandler.getAllOrgIdsInUserScope(context, context.getUser());</span>

<span class="nc bnc" id="L1575" title="All 2 branches missed.">				if (orgIDsInAccessRights.isEmpty()) {</span>
<span class="nc" id="L1576">					groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_2;</span>
				} else {
<span class="nc bnc" id="L1578" title="All 2 branches missed.">					for (ID campaignOrgID : orgIDsInCampaign) {</span>
<span class="nc bnc" id="L1579" title="All 2 branches missed.">						if (orgIDsInAccessRights.contains(campaignOrgID) == false) {</span>
<span class="nc" id="L1580">							groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_3;</span>
<span class="nc" id="L1581">							break;</span>
						}
<span class="nc" id="L1583">					}</span>
<span class="nc" id="L1584">					orgIDsInCampaign = orgIDsInAccessRights;</span>
<span class="nc" id="L1585">					campaignFilter = getFilterForCampaign(context, theTimeRange, theDayRange, campaignID);</span>
<span class="nc" id="L1586">					orgFilter = getFilterForOrgCollection(context, theTimeRange, theDayRange, orgIDsInCampaign);</span>
<span class="nc" id="L1587">					filter = getCombinedFilter(context, orgFilter, campaignFilter);</span>
				}
			}
<span class="nc" id="L1590">		} else {</span>
			//both org and campaign are null. Check if user can view his own UserOrgID
			//check the privs for the user's org
<span class="nc" id="L1593">			boolean groupViewEnabled = ScheduleViewUtil.isPrivWithOrgScope(context, theData, PrivilegeKeys.FS_VIEWORGSCHEDULES,</span>
					GROUPVIEW_FLAG_KEY, false, userOrgID);
<span class="nc bnc" id="L1595" title="All 6 branches missed.">			boolean isInRmOrgs = (rmOrgIDs != null &amp;&amp; !rmOrgIDs.isEmpty() &amp;&amp; rmOrgIDs.contains(userOrgID));</span>

<span class="nc bnc" id="L1597" title="All 4 branches missed.">			if (!groupViewEnabled &amp;&amp; !isInRmOrgs) {</span>
<span class="nc" id="L1598">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_1;</span>
			} else {
<span class="nc" id="L1600">				filter = getFilterForOrg(context, theTimeRange, theDayRange, userOrgID);</span>
			}
		}

<span class="nc" id="L1604">		theData.put(ScheduleViewMH.GROUPVIEW_LIMIT_KEY, groupViewLimit);</span>
<span class="nc" id="L1605">		log.debug(&quot;MH.getEmployeeIDs groupViewLimit = &quot; + groupViewLimit);</span>

		//get collection of employee IDs
<span class="nc bnc" id="L1608" title="All 2 branches missed.">		if (filter != null) {</span>
			//For QA 53374 -Filters in My Schedule / Group / Campaign do not appear to work correctly
			//filter.setPriviledge(null);
<span class="nc" id="L1611">			resetPrivilege(filter);</span>
<span class="nc" id="L1612">			EmployeeFilter employeeFilter = EmployeeModelHandler.getEmployeeFilter(context);</span>
<span class="nc" id="L1613">			eIDs = employeeFilter.getEmployeeIDs(filter, sortField, true, 0, Integer.MAX_VALUE);</span>
		}
<span class="nc bnc" id="L1615" title="All 2 branches missed.">		if (eIDs == null) {</span>
<span class="nc" id="L1616">			eIDs = new ArrayList&lt;ID&gt;();</span>
		}

		//Retrieve and filter out any pooled employees that do not have a schedule (a published shift or shift
		//event) associated to the SPs belonging to the campaign for the given date range.
<span class="nc bnc" id="L1621" title="All 4 branches missed.">		if (campaignID != null &amp;&amp; !eIDs.isEmpty()) {</span>
			//Find all applicable SPs in the campaign for the given date range
<span class="nc" id="L1623">			Collection&lt;SchedulingPeriod&gt; schedulingPeriods =</span>
<span class="nc" id="L1624">					CampaignModelHandler.getSchedulingPeriods(context, campaignID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
			//Find pooled employees in the SPs.  This is tricky because employees that
			//have been manually added aren't easily distinguishable
<span class="nc" id="L1627">			Collection&lt;ID&gt; pooledEmpIDs =</span>
<span class="nc" id="L1628">					EmployeeModelHandler.getPoolerIDs(context, ValueObjectUtil.getIDFromObjects(schedulingPeriods));</span>
<span class="nc" id="L1629">			Collection&lt;ID&gt; filteredPooledEmpIDs = EmployeeModelHandler.filterEmployeeIDsWithoutScheduledEventsInSP(</span>
<span class="nc" id="L1630">					context, pooledEmpIDs, campaignID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L1631">			pooledEmpIDs.removeAll(filteredPooledEmpIDs);</span>
<span class="nc" id="L1632">			eIDs.removeAll(pooledEmpIDs);</span>
		}
<span class="nc" id="L1634">		debugLogCollection(&quot;getEmployeeIDs&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="nc" id="L1636">		log.debug(&quot;Exit MH.getEmployeeIDs&quot;);</span>
<span class="nc" id="L1637">		return eIDs;</span>
	}

	//For QA 53374 -Filters in My Schedule / Group / Campaign do not appear to work correctly
	/* Iterates through all the sub filters and resets the filter
	 * privilege to null. This is essential because filters by default
	 * have CORE.VIEWPEOPLE privilege.
	 */
	private static void resetPrivilege(Filter filter) {
<span class="nc" id="L1646">		List&lt;String&gt; noPrivileges = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1647">		filter.setPrivileges(noPrivileges);</span>
<span class="nc" id="L1648">		Collection colClauses = filter.getClauses();</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">		if (colClauses == null) {</span>
<span class="nc" id="L1650">			return;</span>
		}
<span class="nc bnc" id="L1652" title="All 2 branches missed.">		for (Iterator i = colClauses.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1653">			Filter filterSub = (Filter) i.next();</span>
<span class="nc" id="L1654">			filterSub.setPrivileges(noPrivileges);</span>
<span class="nc" id="L1655">		}</span>
<span class="nc" id="L1656">	}</span>

	/**
	 * get collection of Org IDs in the campaign
	 *
	 * @param campaignID
	 * @param theTimeRange
	 */
	private static Collection&lt;ID&gt; getOrgIDsInCampaign(RequestContext context, ID campaignID, TimeRange theTimeRange)
			throws RemoteException, BbmException {
<span class="nc" id="L1666">		log.debug(&quot; MH: getOrgsInCampaign&quot;);</span>
		// @TODO: for performance optimization should be moved to the back end.
<span class="nc" id="L1668">		Collection&lt;CampaignOrg&gt; orgAssignments = CampaignModelHandler.getCampaignOrgAssignments(context, campaignID,</span>
<span class="nc" id="L1669">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L1670">		Collection&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">		if (orgAssignments != null) {</span>
<span class="nc bnc" id="L1672" title="All 2 branches missed.">			for (CampaignOrg orgAssignment : orgAssignments) {</span>
<span class="nc" id="L1673">				orgIDs.add(orgAssignment.getOrganizationID());</span>
<span class="nc" id="L1674">			}</span>
		}
<span class="nc" id="L1676">		debugLogCollection(&quot;getOrgIDsInCampaign&quot;, &quot;orgIDs&quot;, orgIDs);</span>
<span class="nc" id="L1677">		return orgIDs;</span>
	}

	/**
	 * make combined employee filter from two filters
	 */
	private static Filter getCombinedFilter(RequestContext context, Filter orgFilter, Filter campaignFilter) {
		Filter filter;
<span class="nc bnc" id="L1685" title="All 2 branches missed.">		if (campaignFilter != null) {</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">			if (orgFilter != null) {</span>
				//make combined filter
<span class="nc" id="L1688">				ArrayList&lt;Filter&gt; clauseList = new ArrayList&lt;Filter&gt;(2);</span>
<span class="nc" id="L1689">				clauseList.add(orgFilter);</span>
<span class="nc" id="L1690">				clauseList.add(campaignFilter);</span>
<span class="nc" id="L1691">				ArrayList&lt;Collection&lt;Filter&gt;&gt; params = new ArrayList&lt;Collection&lt;Filter&gt;&gt;(1);</span>
<span class="nc" id="L1692">				params.add(clauseList);</span>
<span class="nc" id="L1693">				filter = new Filter(EMP_SORT_NOT_BY_NAME, Filter.OPERATOR_AND, params);</span>
<span class="nc" id="L1694">				filter.setFilterID(null);</span>
<span class="nc" id="L1695">				filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1696">			} else {</span>
<span class="nc" id="L1697">				filter = campaignFilter;</span>
			}
		} else {
<span class="nc" id="L1700">			filter = orgFilter;</span>
		}
<span class="nc" id="L1702">		return filter;</span>
	}

	/**
	 * get filter for Campaign ID since Filter is not Unique name we have to use full path
	 */
	private static Filter getFilterForCampaign(RequestContext context, TimeRange theTimeRange, TimeRange theDayRange, ID campaignID) {
<span class="nc" id="L1709">		Filter filter = null;</span>
<span class="nc bnc" id="L1710" title="All 2 branches missed.">		if (campaignID != null) {</span>
<span class="nc" id="L1711">			Collection&lt;ID&gt; colCampaigns = new LinkedList&lt;ID&gt;();</span>
<span class="nc" id="L1712">			colCampaigns.add(campaignID);</span>
<span class="nc" id="L1713">			ArrayList&lt;Collection&gt; params = new ArrayList&lt;Collection&gt;();</span>
			//filter expects nested collections
<span class="nc" id="L1715">			params.add(colCampaigns);</span>
<span class="nc" id="L1716">			filter = new Filter(Filter.CAMPAIGNID, Filter.OPERATOR_IN, params);</span>
<span class="nc" id="L1717">			filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1718">			filter.setStartTime(theTimeRange.getStartDate());</span>
<span class="nc" id="L1719">			filter.setEndTime(theTimeRange.getEndDate());</span>
<span class="nc" id="L1720">			filter.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
		}
<span class="nc" id="L1722">		return filter;</span>
	}

	/**
	 * get filter for Org ID since Filter is not Unique name we have to use full path
	 */
	private static Filter getFilterForOrg(RequestContext context, TimeRange theTimeRange, TimeRange theDayRange, ID orgID) {
<span class="nc" id="L1729">		Collection&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1730">		orgIDs.add(orgID);</span>
<span class="nc" id="L1731">		return getFilterForOrgCollection(context, theTimeRange, theDayRange, orgIDs);</span>
	}

	/**
	 * get filter for Collection of Org IDs since Filter is not Unique name we have to use full path
	 */
	private static Filter getFilterForOrgCollection(RequestContext context, TimeRange theTimeRange, TimeRange theDayRange,
			Collection orgIDs) {
<span class="nc" id="L1739">		ArrayList&lt;Collection&gt; alParameters = new ArrayList&lt;Collection&gt;();</span>
<span class="nc" id="L1740">		alParameters.add(orgIDs);</span>
<span class="nc" id="L1741">		Filter filter = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, alParameters);</span>
<span class="nc" id="L1742">		filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1743">		filter.setStartTime(theTimeRange.getStartDate());</span>
<span class="nc" id="L1744">		filter.setEndTime(theTimeRange.getEndDate());</span>
<span class="nc" id="L1745">		filter.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>

<span class="nc" id="L1747">		return filter;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Employee Sorting
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * convert sortBy parameter into a filter field
	 */
	private static int makeFilterSortField(String sortBy) {
<span class="fc" id="L1757">		int result = Filter.LASTNAME;</span>

<span class="pc bpc" id="L1759" title="1 of 2 branches missed.">		if (!StringUtil.isEmpty(sortBy)) {</span>
<span class="pc bpc" id="L1760" title="1 of 2 branches missed.">			if (sortBy.equals(GroupSchedulePM.SORT_BY_FNAME)) {</span>
<span class="nc" id="L1761">				result = Filter.FIRSTNAME;</span>
<span class="pc bpc" id="L1762" title="1 of 2 branches missed.">			} else if (sortBy.equals(GroupSchedulePM.SORT_BY_LNAME)) {</span>
<span class="fc" id="L1763">				result = Filter.LASTNAME;</span>
			} else {
<span class="nc" id="L1765">				result = EMP_SORT_NOT_BY_NAME;</span>
			}
		}
<span class="fc" id="L1768">		return result;</span>
	}

	/**
	 * translate Sort By parameter from the UI to the Facade string
	 */
	private static String translateSortBy(String sortUI) {
<span class="nc" id="L1775">		String result = &quot;&quot;;</span>
<span class="nc bnc" id="L1776" title="All 2 branches missed.">		if (!StringUtil.isEmpty(sortUI)) {</span>
<span class="nc bnc" id="L1777" title="All 2 branches missed.">			if (sortUI.equals(GroupSchedulePM.SORT_BY_START)) {</span>
<span class="nc" id="L1778">				result = SortEvents.SORT_BY_START;</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">			} else if (sortUI.equals(GroupSchedulePM.SORT_BY_END)) {</span>
<span class="nc" id="L1780">				result = SortEvents.SORT_BY_END;</span>
<span class="nc bnc" id="L1781" title="All 2 branches missed.">			} else if (sortUI.equals(GroupSchedulePM.SORT_BY_LENGTH)) {</span>
<span class="nc" id="L1782">				result = SortEvents.SORT_BY_LENGTH;</span>
			}
		}
<span class="nc" id="L1785">		return result;</span>
	}

	/**
	 * Sort employee IDs based on schedule
	 *
	 * QC# 39636: Sorting schedules looks only at underlying shift and ignores timeoffs. This bug occurs because getting only the
	 * EVENT_TYPE_SHIFT_ASSIGNMENT events prevents the sort from taking time off events into consideration. But simply adding
	 * EVENT_TYPE_TIME_OFF events to the list doesn't work properly because it sorts as if the timeoffs were shifts, so if the entire day is
	 * off, it will show up at the top of the sort order (12:00 AM), rather than at the bottom with the unscheduled, unpubished, and day-off
	 * records. Another problem is that if tje &quot;Show Timeoff Events in Schedules&quot; user preference is unchecked, then the user would have no
	 * idea why these records appear at the beginning of the list, rather than at the end. To the user, the time off days (&quot;Off&quot;) are
	 * indistinguishable from the unsheduled days (&quot;Off&quot;) when the setting is unchecked.
	 *
	 * To fix these problems, it's better to sort only by working hours, and treat timeoff time the same as unscheduled time. The fix is as
	 * follows: Before sorting, we will remove any ShiftAssignments which fall within timeoff periods from the list. If a ShiftAssignment is
	 * only partially covered by a timeoff, then we must reduce the start/end times of the shift accordingly. We must also remove the
	 * TimeOffEvents from the list before sorting.
	 */
	private static List&lt;ID&gt; sortEmpIDsPubEvents(RequestContext context, Collection&lt;ID&gt; empIDs, String sortBy,
			TimeRange theTimeRange) throws FacadeException, RemoteException, BbmException {
		try {
			//sort collection of IDs in place using schedule
<span class="nc bnc" id="L1808" title="All 2 branches missed.">			if (empIDs != null) {</span>
<span class="nc" id="L1809">				PeopleFacade facade = FacadeManagerFactory.getPeopleFacade();</span>
<span class="nc" id="L1810">				ScheduleAccessManager scheduleMgr = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L1811">				List&lt;Collection&lt;? extends Event&gt;&gt; listEvents = scheduleMgr.getPublishedEventsForWorkResourcesByType(</span>
						com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_SHIFT_ASSIGNMENT
						| com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_TIME_OFF,
<span class="nc" id="L1814">						empIDs, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>

<span class="nc bnc" id="L1816" title="All 4 branches missed.">				if (listEvents != null &amp;&amp; listEvents.size() &gt; 0) {</span>
					//the ShiftAssignments and TimeOffEvents to be removed
<span class="nc" id="L1818">					ArrayList&lt;Object&gt; removeEvents = new ArrayList&lt;Object&gt;();</span>

					//BEGIN DAY LOOP
<span class="nc" id="L1821">					Calendar curDayStartCal = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1822">							context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L1823">					curDayStartCal.setTime(theTimeRange.getStartDate());</span>

<span class="nc" id="L1825">					Calendar curDayEndCal = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1826">							context.getLocaleContext().getRegionalFormatLocale());</span>

<span class="nc bnc" id="L1828" title="All 2 branches missed.">					while (curDayStartCal.getTime().before(theTimeRange.getEndDate())) {</span>
<span class="nc" id="L1829">						curDayEndCal.setTime(curDayStartCal.getTime());</span>
<span class="nc" id="L1830">						curDayEndCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1831">						curDayEndCal.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L1832">						CalendarRange dayRange = new CalendarRange(curDayStartCal.getTime(), curDayEndCal.getTime(),</span>
<span class="nc" id="L1833">								context.getViewingTimeZone());</span>
						//we have a collection of collections of events
<span class="nc bnc" id="L1835" title="All 2 branches missed.">						for (Collection listEventsSingleWorkResource : listEvents) {</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">							if (listEventsSingleWorkResource != null) {</span>
								// TBD: Should we consider the second shift?
<span class="nc" id="L1838">								TimeRange reducedRange = ScheduleViewUtil.getPublishedDaySummaryType(dayRange,</span>
										listEventsSingleWorkResource, false);
<span class="nc bnc" id="L1840" title="All 2 branches missed.">								if (reducedRange == null) {</span>
									//There is either no schedule for the day, or it's covered by a timeoff.
									//Remove any ShiftAssignment or TimeOffEvent for this day
<span class="nc bnc" id="L1843" title="All 2 branches missed.">									if (reducedRange == null) {</span>
<span class="nc" id="L1844">										Collection shiftAssignmentEvents = ScheduleViewUtil.findShift(dayRange,</span>
												listEventsSingleWorkResource);
<span class="nc bnc" id="L1846" title="All 4 branches missed.">										if (shiftAssignmentEvents != null &amp;&amp; shiftAssignmentEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L1847" title="All 2 branches missed.">											for (Iterator saeIt = shiftAssignmentEvents.iterator(); saeIt.hasNext();) {</span>
<span class="nc" id="L1848">												Event shiftAssignmentEvent = (Event) saeIt.next();</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">												if (shiftAssignmentEvent != null) {</span>
<span class="nc" id="L1850">													removeEvents.add(shiftAssignmentEvent);</span>
												}
<span class="nc" id="L1852">											}</span>
										}
<span class="nc" id="L1854">										Collection timeOffEvents = ScheduleViewUtil.findTimeOffEventsInRange(dayRange,</span>
												listEventsSingleWorkResource);
<span class="nc bnc" id="L1856" title="All 4 branches missed.">										if (timeOffEvents != null &amp;&amp; timeOffEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L1857" title="All 2 branches missed.">											for (Iterator toeIt = timeOffEvents.iterator(); toeIt.hasNext();) {</span>
<span class="nc" id="L1858">												Event timeOffEvent = (Event) toeIt.next();</span>
<span class="nc bnc" id="L1859" title="All 2 branches missed.">												if (timeOffEvent != null) {</span>
<span class="nc" id="L1860">													removeEvents.add(timeOffEvent);</span>
												}
<span class="nc" id="L1862">											}</span>
										}
<span class="nc" id="L1864">									}</span>
								} else {
									//Iterate through all of the events for the current employee, and find any timeoffs.
									//Also, replace original ShiftAssignments with the reduced ranges
<span class="nc bnc" id="L1868" title="All 2 branches missed.">									for (Iterator eventsIt = listEventsSingleWorkResource.iterator(); eventsIt.hasNext();) {</span>
<span class="nc" id="L1869">										Object event = eventsIt.next();</span>
										// TBD: Do we eed to consider the second shift?
<span class="nc" id="L1871">										boolean foundFirstShift = false;</span>
<span class="nc bnc" id="L1872" title="All 4 branches missed.">										if (event instanceof ShiftAssignment &amp;&amp; !foundFirstShift) {</span>
<span class="nc" id="L1873">											ShiftAssignment saEventOld = (ShiftAssignment) event;</span>
<span class="nc bnc" id="L1874" title="All 2 branches missed.">											if ((!saEventOld.getStartTime().equals(reducedRange.getStartDate())</span>
<span class="nc bnc" id="L1875" title="All 2 branches missed.">													|| !saEventOld.getEndTime().equals(reducedRange.getEndDate()))</span>
<span class="nc bnc" id="L1876" title="All 2 branches missed.">													&amp;&amp; !saEventOld.getStartTime().after(reducedRange.getStartDate())</span>
<span class="nc bnc" id="L1877" title="All 2 branches missed.">													&amp;&amp; !saEventOld.getEndTime().before(reducedRange.getEndDate())) {</span>
												//Reduce the ShiftAssignment's range as necessary
<span class="nc" id="L1879">												saEventOld.setStartTime(reducedRange.getStartDate());</span>
<span class="nc" id="L1880">												saEventOld.setDuration((int) reducedRange.getDurationMin());</span>
											}
<span class="nc" id="L1882">											foundFirstShift = true;</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">										} else if (event instanceof TimeOffEvent) {</span>
											//there only a timeoff on this day. Remove it so we don't consider it in the sort.
<span class="nc" id="L1885">											removeEvents.add(event);</span>
										}
<span class="nc" id="L1887">									}</span>
								}
							}
<span class="nc" id="L1890">						}</span>
<span class="nc" id="L1891">						curDayStartCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1892">					}</span>
					//Remove the TimeOffEvents and underlying ShiftAssignment events from the 
					//inner collection because we don't want to sort them.
<span class="nc bnc" id="L1895" title="All 2 branches missed.">					if (removeEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L1896" title="All 2 branches missed.">						for (Object removeMe : removeEvents) {</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">							for (Collection listEventsSingleWorkResource : listEvents) {</span>
<span class="nc bnc" id="L1898" title="All 4 branches missed.">								if (listEventsSingleWorkResource != null &amp;&amp; listEventsSingleWorkResource.contains(removeMe)) {</span>
<span class="nc" id="L1899">									listEventsSingleWorkResource.remove(removeMe);</span>
<span class="nc" id="L1900">									break;</span>
								}
<span class="nc" id="L1902">							}</span>
<span class="nc" id="L1903">						}</span>
					}
				}
				//Finally, sort the employee IDs corrsponding to all of the remaining schedules.
				//For all of the events that we removed, the sort method will automatically append
				//the employee ID's at the end if needed.
<span class="nc" id="L1909">				List&lt;ID&gt; sortedList = facade.sortEmployeeIdsByPublishedEvents(</span>
						empIDs,
						com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_SHIFT_ASSIGNMENT,
						listEvents,
						theTimeRange,
<span class="nc" id="L1914">						translateSortBy(sortBy),</span>
						com.bluepumpkin.ejb.core.base.SupportNavigation.SORT_ASCENDING);

<span class="nc" id="L1917">				return sortedList;</span>
			} else {
<span class="nc" id="L1919">				return Collections.emptyList();</span>
			}
<span class="nc" id="L1921">		} catch (Exception e) {</span>
<span class="nc" id="L1922">			return null;</span>
		}
	}

	/**
	 * Sort Employee IDs by Name
	 */
	private static Collection&lt;ID&gt; sortEmpIDsByName(RequestContext context, ID userID, Collection&lt;ID&gt; empIDs, int sortField)
			throws RemoteException, BbmException, BbmFinderException {
<span class="fc" id="L1931">		ArrayList&lt;Collection&gt; allParams = new ArrayList&lt;Collection&gt;();</span>
<span class="fc" id="L1932">		allParams.add(empIDs);</span>

<span class="fc" id="L1934">		Filter filter = new Filter(Filter.EMPLOYEEID, Filter.OPERATOR_IN, allParams);</span>
<span class="fc" id="L1935">		filter.setUserID(userID);</span>

<span class="fc" id="L1937">		EmployeeFilter employeeFilter = EmployeeModelHandler.getEmployeeFilter(context);</span>
<span class="fc" id="L1938">		Collection&lt;Integer&gt; colSortFields = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L1939">		colSortFields.add(sortField);</span>
<span class="pc bpc" id="L1940" title="2 of 3 branches missed.">		switch (sortField) {</span>
			case Filter.FIRSTNAME:
<span class="nc" id="L1942">				colSortFields.add(Filter.LASTNAME);</span>
<span class="nc" id="L1943">				break;</span>
			case Filter.LASTNAME:
<span class="fc" id="L1945">				colSortFields.add(Filter.FIRSTNAME);</span>
<span class="fc" id="L1946">				break;</span>
			default:
<span class="nc" id="L1948">				colSortFields.add(Filter.LASTNAME);</span>
<span class="nc" id="L1949">				colSortFields.add(Filter.FIRSTNAME);</span>
				break;
		}
<span class="fc" id="L1952">		Collection&lt;ID&gt; result = employeeFilter.getEmployeeIDs(filter, colSortFields, true, 0, Integer.MAX_VALUE);</span>
<span class="fc" id="L1953">		return result;</span>
	}

	/**
	 * Find the employee's &quot;secondary&quot; SP ID's in the aDay range. Return the SP ID collection. An employee &quot;secondary&quot; SP is one which is
	 * associated with one of the Employee's pooling Orgs, as defined in the User Management\Employees\Work Rules page ('Pooling Rules'
	 * section).
	 *
	 * @param aDay - A date range. Should be a day, but I guess it could be any range.
	 * @param employeeID - The ID of the employee that might be assigned to an SP in the day range.
	 * @return A collection of the agent's &quot;primary&quot; SP ID's for the date range.
	 */
	public static Collection&lt;ID&gt; findAgentSecondarySPIDs(RequestContext context, CalendarRange aDay, ID employeeID)
			throws BbmFinderException {
<span class="nc" id="L1967">		HashSet&lt;ID&gt; secondarySPIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1968">		HashSet&lt;ID&gt; secondaryOrgIDs = new HashSet&lt;ID&gt;();</span>
		EmpWorkRuleManager ewrm;
		CampaignManager cm;
		try {
<span class="nc" id="L1972">			ewrm = WfmManagerFactory.getEmpWorkRuleManager(context.isInWhatIfMode());</span>
<span class="nc" id="L1973">			cm = WfmManagerFactory.getCampaignManager(context.isInWhatIfMode());</span>

<span class="nc bnc" id="L1975" title="All 4 branches missed.">			if (aDay != null &amp;&amp; employeeID != null) {</span>
				//Get the employee's secondary orgs
<span class="nc" id="L1977">				HashMap poolingRuleAssignments =</span>
<span class="nc" id="L1978">						ewrm.getPoolingRuleAssignments(Collections.singletonList(employeeID), aDay.getStartDate(), aDay.getEndDate());</span>
<span class="nc bnc" id="L1979" title="All 2 branches missed.">				if (poolingRuleAssignments != null) {</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">					for (Iterator empPoolRuleIt = poolingRuleAssignments.keySet().iterator(); empPoolRuleIt.hasNext();) {</span>
<span class="nc" id="L1981">						ID empID = (ID) empPoolRuleIt.next();</span>
<span class="nc" id="L1982">						ArrayList poolRules = (ArrayList) (poolingRuleAssignments.get(empID));</span>
<span class="nc bnc" id="L1983" title="All 2 branches missed.">						if (poolRules != null) {</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">							for (Iterator prIt = poolRules.iterator(); prIt.hasNext();) {</span>
<span class="nc" id="L1985">								EmpPoolingRule poolRule = (EmpPoolingRule) prIt.next();</span>
<span class="nc" id="L1986">								secondaryOrgIDs.addAll(poolRule.getSecondaryOgs());</span>
<span class="nc" id="L1987">							}</span>
						}
<span class="nc" id="L1989">					}</span>
					//Get the SPID's for each of the secondary orgs on the day
<span class="nc bnc" id="L1991" title="All 2 branches missed.">					for (ID secondaryOrgID : secondaryOrgIDs) {</span>
<span class="nc" id="L1992">						Collection campaignOrgs = cm.getOrgCampaignAssignments(secondaryOrgID, aDay.getStartDate(), aDay.getEndDate());</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">						for (Iterator campOrgIt = campaignOrgs.iterator(); campOrgIt.hasNext();) {</span>
<span class="nc" id="L1994">							CampaignOrg campaignOrg = (CampaignOrg) campOrgIt.next();</span>
<span class="nc" id="L1995">							ID campaignID = campaignOrg.getCampaignID();</span>
							//Now get the SP ID's for that campaign and date range
<span class="nc" id="L1997">							Collection&lt;SchedulingPeriod&gt; curSpIDs =</span>
<span class="nc" id="L1998">									cm.getSchedulingPeriods(campaignID, null, aDay.getStartDate(), aDay.getEndDate());</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">							for (SchedulingPeriod sp : curSpIDs) {</span>
<span class="nc" id="L2000">								secondarySPIDs.add(sp.getID());</span>
<span class="nc" id="L2001">							}</span>
<span class="nc" id="L2002">						}</span>
<span class="nc" id="L2003">					}</span>
				}
			}
<span class="nc" id="L2006">		} catch (Exception ex) {</span>
<span class="nc bnc" id="L2007" title="All 2 branches missed.">			if (ex instanceof BbmFinderException) {</span>
<span class="nc" id="L2008">				throw (BbmFinderException) ex;</span>
			}
<span class="nc" id="L2010">			throw new BbmFinderException(ex);</span>
<span class="nc" id="L2011">		}</span>
<span class="nc" id="L2012">		return secondarySPIDs;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Debug Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * log debug message about the collection size in a specific method
	 */
	private static void debugLogCollection(String methodName, String colName, Collection col) {
<span class="pc bpc" id="L2022" title="1 of 2 branches missed.">		if (col != null) {</span>
<span class="fc" id="L2023">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result size=&quot; + col.size());</span>
		} else {
<span class="nc" id="L2025">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result is null&quot;);</span>
		}
<span class="fc" id="L2027">	}</span>

	/**
	 * log debug message about the HashMap size in a specific method
	 */
	private static void debugLogCollection(String methodName, String colName, HashMap col) {
<span class="pc bpc" id="L2033" title="1 of 2 branches missed.">		if (col != null) {</span>
<span class="fc" id="L2034">			debugLogCollection(methodName, colName, col.values());</span>
		} else {
<span class="nc" id="L2036">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result is null&quot;);</span>
		}
<span class="fc" id="L2038">	}</span>

	/**
	 * Get the config key to indicate if the Absence reason is showed for employee's Supervisor only- For France Telecom For other customers
	 * who do not have the key, the Absent reason is showed for all people (employee's Supervisor and his colleagues)
	 *
	 * * @return boolean value for the indicator above
	 */
	public static boolean enabledAbsentReasonToOnlySupervisor() {

<span class="nc" id="L2048">		boolean result = false;</span>
		try {
<span class="nc" id="L2050">			String dbVal = BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.FS_ENABLED_SHOW_ABSENT_REASON);</span>
<span class="nc bnc" id="L2051" title="All 2 branches missed.">			if (!StringUtil.isEmpty(dbVal)) {</span>
<span class="nc" id="L2052">				result = Boolean.parseBoolean(dbVal);</span>
			}
<span class="nc" id="L2054">		} catch (Exception ex) {</span>
			//ignoring any exception caught.
<span class="nc" id="L2056">		}</span>
<span class="nc" id="L2057">		return result;</span>
	}

	/**
	 * For Story 34045 -PSR 6104 - Reason for Absence viewable only by Supervisor and Employee See if the currently logged-in user is the
	 * Supervisor of the specified employee ID ..
	 *
	 * @param empID The employee ID to check.
	 * @return true if the currently logged-in user is the Supervisor of the specified employee ID .
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected static boolean isSupervisor(RequestContext context, ID empID, ID loggedInEmpId) {
		try {
<span class="nc" id="L2070">			ID empOrgId = OrganizationModelHandler.getEmployeeOrgID(context, empID);</span>
<span class="nc" id="L2071">			Collection&lt;ID&gt; orgIdsInScope = OrganizationModelHandler.getAllOrgIdsInUserScope(context, context.getUser());</span>
<span class="nc" id="L2072">			Employee employeeLoggIn = EmployeeModelHandler.getEmployeeByID(context, loggedInEmpId);</span>
<span class="nc bnc" id="L2073" title="All 4 branches missed.">			return employeeLoggIn.isSupervisor() &amp;&amp; orgIdsInScope.contains(empOrgId);</span>
<span class="nc" id="L2074">		} catch (Exception ex) {</span>
<span class="nc" id="L2075">			return false;</span>
		}
	}

	/**
	 * For Story 34045 -PSR 6104 - in GraphView, if detail of Time off event is not showed (just showed as Time Off), then the Legend should
	 * not show detail of TimeOff event
	 */
	private static boolean hasSecuredTimeOffEvents(RequestContext context, Collection&lt;ID&gt; employeeIDs, ID loggedInEmpId) {
<span class="nc" id="L2084">		boolean hasSecuredTimeOffEvents = false;</span>
<span class="nc" id="L2085">		boolean bEnabledAbsentReasonToOnlySupervisor = enabledAbsentReasonToOnlySupervisor();</span>
<span class="nc" id="L2086">		boolean isShowAbsentReason = true;</span>
<span class="nc bnc" id="L2087" title="All 2 branches missed.">		if (!employeeIDs.isEmpty()) {</span>
<span class="nc bnc" id="L2088" title="All 2 branches missed.">			for (ID empID : employeeIDs) {</span>
<span class="nc bnc" id="L2089" title="All 6 branches missed.">				if (bEnabledAbsentReasonToOnlySupervisor &amp;&amp; !isSupervisor(context, empID, loggedInEmpId) &amp;&amp; !loggedInEmpId.equals(empID)) {</span>
<span class="nc" id="L2090">					isShowAbsentReason = false;</span>
				}
<span class="nc bnc" id="L2092" title="All 4 branches missed.">				if (!isShowAbsentReason &amp;&amp; !hasSecuredTimeOffEvents) {</span>
<span class="nc" id="L2093">					hasSecuredTimeOffEvents = true;</span>
<span class="nc" id="L2094">					break;</span>
				}
<span class="nc" id="L2096">			}</span>
		}
<span class="nc" id="L2098">		return hasSecuredTimeOffEvents;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>