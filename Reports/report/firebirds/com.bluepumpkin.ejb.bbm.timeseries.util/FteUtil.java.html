<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FteUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">FteUtil.java</span></div><h1>FteUtil.java</h1><pre class="source lang-java linenums">/*
 * 2009-2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import java.util.Collection;
import java.util.Date;
import java.util.LinkedList;

import com.bluepumpkin.common.util.MathUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.workload.model.ServiceGoalsType;
import com.verint.ejb.bbm.forecast.model.ForecastProfileList;

<span class="nc" id="L16">public class FteUtil {</span>
	public static final int DEFAULT_MINIMUM_OCCUPANCY_PERCENT = 50;
	public static final int OVERFLOW_NUMBER_OF_AGENTS = 12000;
	public static final double CENT_PERCENT = 100.;
	
	/**
	 * Returns a series of FTE requirements calculated for the specified volume,
	 * AHT, service goal, shrinkage, and modeling factor profiles.  Calculations assume 
	 * that the queue's media type is Immediate.
	 * &lt;p&gt;
	 * It is assumed that volume, AHT, shrinkage, and modeling factor are specified in 15-minute intervals.
	 * 
	 * @param forecastCube a trace cube containing volume and AHT data
	 * @param volumeTraceType one of the predefined trace type constants, for example Trace.CV, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; volume data is to be obtained
	 * @param ahtTraceType one of the predefined trace type constants, for example Trace.AHT, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; AHT data is to be obtained
	 * @param serviceGoal the service goal to be satisfied by the FTE requirements
	 * @param shrinkageSeries the shrinkage profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param modelingFactorSeries the modeling factor profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param minimumOccupancyPercent minimum occupancy expressed as a percentage; zero indicates no value
	 * has been set.  In this case &lt;code&gt;DEFAULT_MINIMUM_OCCUPANCY_PERCENT&lt;/code&gt; will be used.
	 * Setting the minimum occupancy higher than would be achieved by meeting the service goal
	 * will drive down staffing levels to increase occupancy, at the expense of failing to meet
	 * the service goal.  This parameter is ignored if {@code useMinimumOccupancy} is {@code false}.
	 * @param useMinimumOccupancy if {@code false}, then the {@code minimumOccupancy parameter is
	 * ignored and the returned FTE level does not reflect minimum occupancy; if {@code true} then
	 * minimum occupancy is taken into account.
	 * @param useShrinkage If true, we compute the required FTE using the full formula, which includes reverse-compensating for shrinkage.
	 * @param startTime the start time, inclusive, for which FTE numbers are desired
	 * @param endTime the end time, exclusive, for which FTE numbers are desired
	 * 
	 * @return an array of the appropriate FTE requirements for each 15-minute interval
	 * from startTime (inclusive) to endTime (exclusive).
	 */
	public static int[] getFteRequirementsImmediate(TraceCube forecastCube, short volumeTraceType,
													short ahtTraceType,
													IServiceGoal serviceGoal,
													float[] shrinkageSeries,
													float[] modelingFactorSeries,
													int minimumOccupancyPercent,
													boolean useMinimumOccupancy,
													boolean useShrinkage,
													Date startTime,
													Date endTime) {
		/* [Excerpted from Campain.cpp]
		 Algorithms for calculating agent requirements (according to Ofer): 

		 For each interval
		   1. compute its agent requirement AR according to erlang formula
		   2. if its AHT &gt; 900 secs. (i.e., 15 minutes), spread the agent
			  requirement as:
		        1) compute number of intervals to spread
		              numberOfIntervals = AHT / 900 + (AHT % 900 &gt; 0 ? 1 : 0)
				      partialInterval_length = AHT % 900
		        2) spread the agents in each interval as:
		              AR_spread = AR * 900 / AHT
				      AR_spread_partial_interval = AR * partialInterval_length / AHT

		   3. add AR_spread to agent requirements spread over from 
		      all possible previous intervals.

		   4. set agent requirement to 0.0 if the interval is not in operation.
		   
		 DHM: The actual implementation spreads volume rather than FTE over time,
		 saving a lot of FTE calculations if AHT is particularly large. 
		 ***************************************************************************/
<span class="fc" id="L83">		int dataLength = forecastCube.getTraceValueD(volumeTraceType).length;</span>
<span class="fc" id="L84">		int[] fteData = new int[dataLength];</span>
		// When AHT is greater than intervalSeconds, then the corresponding volume represents
		// work that will be done over more than one interval.  The AHT represents a time 
		// spanning two or more intervals, and the volume is added to the original volume for
		// all those intervals.  The AHT is adjusted for each such interval as well, to reflect
		// the influence of the carried-over transactions.
		// The last interval may be a partial interval, in which case the volume and AHT are
		// pro-rated in that interval.
<span class="fc" id="L92">		int intervalSeconds = Trace.INTERVAL * 60;</span>
<span class="fc" id="L93">		double[] distributedVolume = new double[dataLength];</span>
<span class="fc" id="L94">		double[] distributedAht = new double[dataLength];</span>

		// We maintain a queue of accumulated carried-over volume and AHT.  Each time
		// we need to carry over volume and AHT they are placed on this queue, combining
		// with data already on the queue if necessary.  Each time we go to a new time
		// interval we check to see if there is volume and AHT on the queues.
<span class="fc" id="L100">		LinkedList&lt;Integer&gt; carryOverVolumeQueue = new LinkedList&lt;Integer&gt;();</span>
<span class="fc" id="L101">		LinkedList&lt;Double&gt; carryOverAhtQueue = new LinkedList&lt;Double&gt;();</span>
<span class="fc" id="L102">		int dataIndex = 0;</span>
<span class="fc bfc" id="L103" title="All 2 branches covered.">		for (Date currentTime = startTime; currentTime.before(endTime);</span>
<span class="fc" id="L104">				currentTime = new Date(currentTime.getTime() + Trace.INTERVAL_IN_MILLIS)) {</span>
<span class="fc" id="L105">			int volumeData = forecastCube.getTraceValue(volumeTraceType, currentTime);</span>
<span class="fc" id="L106">			int ahtData = forecastCube.getTraceValue(ahtTraceType, currentTime);</span>
<span class="pc bpc" id="L107" title="1 of 4 branches missed.">			if (volumeData &lt; 0 || ahtData &lt; 0) {</span>
				// Discard carried-over volume and AHT for this interval if the original
				// volume or AHT are unavailable.
<span class="fc" id="L110">				carryOverVolumeQueue.poll();</span>
<span class="fc" id="L111">				carryOverAhtQueue.poll();</span>
<span class="fc" id="L112">				distributedVolume[dataIndex] = Trace.TRACENA;</span>
<span class="fc" id="L113">				distributedAht[dataIndex] = Trace.TRACENA;</span>
			} else {
<span class="fc" id="L115">				int volume = volumeData;</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">				int ahtSeconds = (volume == 0) ? 0 : ahtData;</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">				int carryOverVolumeThisPeriod = carryOverVolumeQueue.isEmpty() ? 0 : carryOverVolumeQueue.remove();</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">				double carryOverAhtThisPeriod = carryOverAhtQueue.isEmpty() ? 0 : carryOverAhtQueue.remove();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">				if (ahtSeconds &gt; intervalSeconds) {</span>
<span class="nc" id="L120">					int carryOverIndex = 0;</span>
<span class="nc" id="L121">					int ahtToCarryOver = ahtSeconds - intervalSeconds;</span>
<span class="nc" id="L122">					ahtSeconds = intervalSeconds;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">					while (ahtToCarryOver &gt; 0) {</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">						if (carryOverIndex &gt;= dataLength) {</span>
<span class="nc" id="L125">							break;</span>
						}
<span class="nc" id="L127">						int ahtForPeriod = Math.min(ahtToCarryOver, intervalSeconds);</span>
<span class="nc" id="L128">						int futureCarryOverVolume = 0;</span>
<span class="nc" id="L129">						double futureCarryOverAht = 0;</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">						if (carryOverIndex &lt; carryOverVolumeQueue.size()) {</span>
<span class="nc" id="L131">							futureCarryOverVolume = carryOverVolumeQueue.get(carryOverIndex);</span>
<span class="nc" id="L132">							futureCarryOverAht = carryOverAhtQueue.get(carryOverIndex);</span>
						}
<span class="nc bnc" id="L134" title="All 2 branches missed.">						if (carryOverIndex &lt; carryOverVolumeQueue.size()) {</span>
<span class="nc" id="L135">							double averageAHT = (volume * ahtForPeriod + futureCarryOverVolume * futureCarryOverAht) / (volume + futureCarryOverVolume);</span>
<span class="nc" id="L136">							carryOverVolumeQueue.set(carryOverIndex, volume + futureCarryOverVolume);</span>
<span class="nc" id="L137">							carryOverAhtQueue.set(carryOverIndex, averageAHT);</span>
<span class="nc" id="L138">						} else {</span>
<span class="nc" id="L139">							carryOverVolumeQueue.add(volume);</span>
<span class="nc" id="L140">							carryOverAhtQueue.add((double)ahtForPeriod);</span>
						}
<span class="nc" id="L142">						carryOverIndex++;</span>
<span class="nc" id="L143">						ahtToCarryOver -= intervalSeconds;</span>
<span class="nc" id="L144">					}</span>
				}
<span class="fc" id="L146">				double averageAht = (volume * ahtSeconds + carryOverVolumeThisPeriod * carryOverAhtThisPeriod) / (volume + carryOverVolumeThisPeriod);</span>
<span class="fc" id="L147">				distributedVolume[dataIndex] = volume + carryOverVolumeThisPeriod;</span>
<span class="fc" id="L148">				distributedAht[dataIndex] = averageAht;</span>
			}
<span class="fc" id="L150">			dataIndex++;</span>
		}
		// Now that transactions have been properly allocated to multiple time intervals
		// as necessary, we do the actual requirements calculations.
<span class="fc" id="L154">		dataIndex = 0;</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">		for (Date currentTime = startTime; currentTime.before(endTime);</span>
<span class="fc" id="L156">				currentTime = new Date(currentTime.getTime() + Trace.INTERVAL_IN_MILLIS)) {</span>
<span class="fc" id="L157">			double volume = distributedVolume[dataIndex];</span>
<span class="fc" id="L158">			double ahtSeconds = distributedAht[dataIndex];</span>
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">			if (volume &lt; 0 || ahtSeconds &lt; 0) {</span>
<span class="fc" id="L160">				fteData[dataIndex] = 0;</span>
			} else {
				double currentFte;
				try {
					// Arrival rate is volume / time
					// The service goal knows the specifics of how FTE requirements should
					// be calculated to satisfy it.
<span class="fc" id="L167">					currentFte = serviceGoal.getFteRequirement(currentTime, volume / intervalSeconds, ahtSeconds);</span>
<span class="nc" id="L168">				} catch (IllegalArgumentException iae) {</span>
<span class="nc" id="L169">					currentFte = OVERFLOW_NUMBER_OF_AGENTS;</span>
<span class="fc" id="L170">				}</span>

<span class="fc bfc" id="L172" title="All 2 branches covered.">				if (useMinimumOccupancy) {</span>
					// For large volumes, FTE requirements approach workload.  At low volumes the
					// Erlang C calculations may overestimate required FTE.  The minimum occupancy
					// setting is intended to mitigate this by limiting the resulting FTE to some
					// multiple of the workload.  &quot;Occupancy&quot; is the percentage of an employee's
					// time that will be spent handling transactions.
<span class="fc" id="L178">					double minimumOccupancy = DEFAULT_MINIMUM_OCCUPANCY_PERCENT / CENT_PERCENT;</span>
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">					if (minimumOccupancyPercent &gt; 0) {</span>
<span class="nc" id="L180">						minimumOccupancy = minimumOccupancyPercent / CENT_PERCENT;</span>
					}
<span class="fc" id="L182">					double fteRequirementForMinOccupancy = Math.ceil((volume * ahtSeconds) /</span>
																	 (minimumOccupancy * intervalSeconds));
<span class="fc" id="L184">					currentFte = Math.min(currentFte, fteRequirementForMinOccupancy);</span>
				}

<span class="fc bfc" id="L187" title="All 2 branches covered.">				if (useShrinkage) {</span>
					// Absenteeism is the degree to which employees who are scheduled to work, don't
					// actually work.  We increase the scheduling requirement so that absenteeism is
					// taken into account.
<span class="fc" id="L191">					double absenteeism = (shrinkageSeries[dataIndex] + modelingFactorSeries[dataIndex]) / CENT_PERCENT;</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">					if (absenteeism &lt; 1) {</span>
<span class="fc" id="L193">						currentFte /= 1. - absenteeism;</span>
					}
				}
<span class="fc" id="L196">				fteData[dataIndex] = MathUtil.roundHalfCeiling(currentFte);</span>
			}
<span class="fc" id="L198">			dataIndex++;</span>
		}

<span class="fc" id="L201">		return fteData;</span>
	}

	/**
	 * Returns a series of FTE requirements calculated for the specified volume,
	 * AHT, shrinkage, and modeling factor profiles and starting backlog.  Calculations assume 
	 * that the queue's media type is Deferred.
	 * &lt;p&gt;
	 * The result of each calculation is rounded and the following result is adjusted by the
	 * roundoff amount.
	 * &lt;p&gt;
	 * It is assumed that volume, AHT, shrinkage, and modeling factor are specified in 15-minute intervals.
	 * 
	 * @param forecastCube a trace cube containing volume and AHT data
	 * @param volumeTraceType one of the predefined trace type constants, for example Trace.CV, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; volume data is to be obtained
	 * @param ahtTraceType one of the predefined trace type constants, for example Trace.AHT, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; AHT data is to be obtained
	 * @param shrinkageSeries the shrinkage profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param modelingFactorSeries the modeling factor profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param startingBacklog the backlog volume at the start of the interval being processed
	 * @param addStartingBacklog indicates whether or not starting backlog is to be taken into account when calculating
	 * FTE requirements
	 * @param startTime the start time, inclusive, for which FTE numbers are desired
	 * @param endTime the end time, exclusive, for which FTE numbers are desired
	 * 
	 * @return an array of the appropriate FTE requirements for each 15-minute interval
	 * from startTime (inclusive) to endTime (exclusive).
	 */
	public static int[] getFteRequirementsDeferred(TraceCube forecastCube,
												   short volumeTraceType,
												   short ahtTraceType,
												   float[] shrinkageSeries,
												   float[] modelingFactorSeries,
												   int startingBacklog,
												   boolean addStartingBacklog,
												   Date startTime,
												   Date endTime) {
		/*
		 * Distilled from the C++ client code:
		 * 
		 * If including starting backlog {
		 * 		Calculate average AHT weighted by CV.
		 * 		Calculate first CV and AHT as {
		 * 			(AHT[0] = (CV * AHT + backlog * averageAHT) / (CV + backlog)
		 * 			CV[0] = CV[0] + backlog
		 * 		}
		 * }
		 * absenteeism = (shrinkage[n] + modeling[n]) / 100.
		 * // CV is calls/15-minute interval, AHT is seconds
		 * AR[n] = CV[n] * AHT[n] / ( (1 - absenteeism) * 15 * 60)  // converts CV to per second instead of per 15 minutes
		 */

<span class="fc" id="L254">		int dataLength = forecastCube.getTraceValueD(volumeTraceType).length;</span>
<span class="fc" id="L255">		int[] fteData = new int[dataLength];</span>
<span class="fc" id="L256">		int intervalSeconds = Trace.INTERVAL * 60;</span>
<span class="fc" id="L257">		int dataIndex = 0;</span>
<span class="fc" id="L258">		double remainder = 0.5;</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">		for (Date currentTime = startTime; currentTime.before(endTime); currentTime = new Date(currentTime.getTime() + </span>
			Trace.INTERVAL_IN_MILLIS)) {
<span class="fc" id="L261">			double volume = forecastCube.getTraceValue(volumeTraceType, currentTime);</span>
<span class="fc" id="L262">			double ahtSeconds = forecastCube.getTraceValue(ahtTraceType, currentTime);</span>
<span class="pc bpc" id="L263" title="2 of 4 branches missed.">			if (volume &lt; 0 || ahtSeconds &lt; 0) {</span>
<span class="nc" id="L264">				fteData[dataIndex] = 0;</span>
			} else {
<span class="pc bpc" id="L266" title="3 of 4 branches missed.">				if (addStartingBacklog &amp;&amp; startingBacklog &gt; 0) {</span>
<span class="nc" id="L267">					int startOffset = forecastCube.getTimeOffsetWithinCubeBounds(startTime);</span>
<span class="nc" id="L268">					int endOffset = forecastCube.getTimeOffsetWithinCubeBounds(new Date(endTime.getTime() - 1000));</span>
<span class="nc" id="L269">					double totalVolume = TraceOperator.aggregatePeriod(forecastCube, volumeTraceType, startOffset, endOffset, null);</span>
<span class="nc" id="L270">					double averageAht = TraceOperator.aggregatePeriod(forecastCube, ahtTraceType, startOffset, endOffset, null);</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">					if (totalVolume &gt;= 0 &amp;&amp;</span>
						averageAht &gt;= 0) {
<span class="nc" id="L273">						ahtSeconds = (volume * ahtSeconds + startingBacklog * averageAht) /</span>
									 (volume + startingBacklog);
<span class="nc" id="L275">						volume += startingBacklog;</span>
					}
<span class="nc" id="L277">					addStartingBacklog = false;</span>
				}
<span class="fc" id="L279">				double currentFte = volume * ahtSeconds / intervalSeconds;</span>

				// Absenteeism is the degree to which employees who are scheduled to work, don't
				// actually work.  We increase the scheduling requirement so that absenteeism is
				// taken into account.
<span class="fc" id="L284">				double absenteeism = (shrinkageSeries[dataIndex] + modelingFactorSeries[dataIndex]) / CENT_PERCENT;</span>
<span class="pc bpc" id="L285" title="1 of 2 branches missed.">				if (absenteeism &lt; 1) {</span>
<span class="fc" id="L286">					currentFte /= 1. - absenteeism;</span>
				}
<span class="fc" id="L288">				currentFte += remainder;</span>
<span class="fc" id="L289">				fteData[dataIndex] = (int)currentFte;</span>
<span class="fc" id="L290">				remainder = currentFte % 1;</span>
			}
<span class="fc" id="L292">			dataIndex++;</span>
		}

<span class="fc" id="L295">		return fteData;</span>
	}
	
	/**
	 * Returns a series of FTE requirements calculated for the specified connect rate (CRATE),
	 * right party connect rate (RPCRATE), AHT, forecasted call lists, connect goal, shrinkage
	 * and modeling factor profiles.  Calculations assume that the queue's media type
	 * is Outbound.
	 * &lt;p&gt;
	 *
	 * The result of each calculation is rounded and the following result is adjusted by the
	 * roundoff amount. TODO: verify that this needs to be done
	 * &lt;p&gt;
	 * It is assumed that CRATE, RPCRATE, AHT, shrinkage, and modeling factors are specified in 15-minute intervals.
	 * 
	 * @param forecastCube a trace cube containing CRATE, RPCRATE and AHT data
	 * @param connectRateTraceType one of the predefined trace type constants, for example Trace.CRATE, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; connect rate data is to be obtained
	 * @param rpcRateTraceType one of the predefined trace type constants, for example Trace.RPCRATE, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; right party connect rate data is to be obtained
	 * @param ahtTraceType one of the predefined trace type constants, for example AHT, indicating
	 * from which trace in &lt;code&gt;historyCube&lt;/code&gt; activity handling time (for connects) data is to be obtained
	 * @param connectGoalPercent The percentage of successful connects required to meet the service goal
	 * @param shrinkageSeries the shrinkage profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param modelingFactorSeries the modeling factor profile, expressed as percentages of FTE, at 15-minute intervals
	 * @param forecastedCallLists a collection of forecasted outbound call lists, the work that is to be performed in this
	 * queue
	 * @param spStartTime the scheduling period start time, inclusive, for which FTE numbers are desired.  Forecasted call
	 * lists that cross over the SP boundary are pro-rated.
	 * @param spEndTime the scheduling end time, exclusive, for which FTE numbers are desired.  Forecasted call
	 * lists that cross over the SP boundary are pro-rated.
	 * @param startTime the start time, inclusive, for which FTE numbers are desired
	 * @param endTime the end time, exclusive, for which FTE numbers are desired
	 * 
	 * @return an array of the appropriate staffing level requirements for each 15-minute interval.
	 */
	public static int[] getFteRequirementsOutbound(	TraceCube forecastCube,
												   	short connectRateTraceType,
												   	short rpcRateTraceType,
												   	short ahtTraceType,
												   	int connectGoalPercent,
													ServiceGoalsType serviceGoalType,
													float[] shrinkageSeries,
													float[] modelingFactorSeries,
													Collection&lt;ForecastProfileList&gt; forecastedCallLists,
													Date spStartTime,
													Date spEndTime,
													Date startTime,
													Date endTime) {
		/*
		 * Distilled from the C++ client code:
		 * 
		if (strMediaID == &quot;ID_PHONE_OUT&quot;) {
			//calculate average aht
			CComPtr&lt;IBPTimeSequence&gt; pCRSeq;
			CComPtr&lt;IBPTimeSequence&gt; pRPCRSeq;
			BPCOM_CALL(pProfile-&gt;GetTrace(_bstr_t(&quot;CONNECTRATE&quot;),&amp;pCRSeq));
			BPCOM_CALL(pProfile-&gt;GetTrace(_bstr_t(&quot;RIGHTPARTYCONNECTRATE&quot;),&amp;pRPCRSeq));
			
			double dConnectGoal = pSVCData-&gt;GetServiceLevelPeriod() / 100.0;
			long lGoalType = pSVCData-&gt;GetActualHour();
			
			int nCount = 0;
			float fTotalAHT =  0.0;
			float fTotalAbsenteeism = 0.0;

			for(i=0;i&lt;NumPoints;i++)
			{
				
				int jDay = (i*15)/(60*24);
				fAbsenteeism = (float)((pVals[i/4] + afModelingFactor[i/4])/100.0);
				DATE dt;
				float fCR,fRPCR, fAHT;
				BPCOM_CALL(pCRSeq-&gt;GetNth(i,&amp;dt,&amp;fCR));
				BPCOM_CALL(pRPCRSeq-&gt;GetNth(i,&amp;dt,&amp;fRPCR));
				BPCOM_CALL(pAHTSeq-&gt;GetNth(i,&amp;dt,&amp;fAHT));

				if (lGoalType == 1) { //RPC Goal
					if (fRPCR &gt; 0)
						fAHT *= fCR / fRPCR;
					fCR = fRPCR;
				}
				if (fCR &gt; 0) {
					nCount++;
					fTotalAHT +=fAHT;
					fTotalAbsenteeism += fAbsenteeism;
				}
				pSeq-&gt;SetPoint(i,dt,0.0);
			}
			float fAverageAHT = 0.0;
			float fAverageAbsenteeism = 0.0;
			if (nCount &gt; 0) {
				fAverageAHT = fTotalAHT / (float)nCount;
				fAverageAbsenteeism = fTotalAbsenteeism / (float) nCount;
			}

			IBPCollection* pLists;
			BPCOM_CALL(pProfile-&gt;get_Lists(&amp;pLists)); 
			long nListCount; 
			pLists-&gt;get_Count(&amp;nListCount);

			for (short i = 1; i &lt;= nListCount; i++) {
				_variant_t var;
				pLists-&gt;get_Item ((_variant_t)i, &amp;var);
				bpsdk::IBPProfileListPtr pList = V_UNKNOWN(&amp;var);

				float fLength = (float)pList-&gt;GetLength();
				
				CBPDateTime dtStart = (CBPDateTime)pList-&gt;GetStartDate();
				CBPDateTime dtEnd = (CBPDateTime)pList-&gt;GetEndDate();

				//prorate list
				if (dtStart &lt; m_dtStart) {
					fLength *= (float)((dtEnd - m_dtStart) / (dtEnd - dtStart)); //pro rate the list
					dtStart = m_dtStart;
				}
				if (dtEnd &gt; m_dtEnd) {
					fLength *= (float)((m_dtEnd - dtStart) / (dtEnd - dtStart)); //pro rate the list
					dtEnd = m_dtEnd;
				}
				
				CBPDateTimeSpan span = dtStart - m_dtStart;
				long iStart = (long)(span.GetTotalMinutes()/15 + 0.5);

				//move overlapping lists to next interval
				float fVal = 0.0;
				pSeq-&gt;GetNth(iStart,&amp;dt,&amp;fVal);
				while(fVal &gt; 0) {
					iStart++;
					pSeq-&gt;GetNth(iStart,&amp;dt,&amp;fVal);
				}

				//setAgentRequirements
				float fAR = (float)floor(fLength * fAverageAHT * (float)dConnectGoal / 900 
					/ (1.0 - fAverageAbsenteeism) + 0.5);
				pSeq-&gt;SetNth(iStart,fAR);

			}
	
		}
		 */

<span class="fc" id="L437">		int dataLength = forecastCube.getTraceValueD(connectRateTraceType).length;</span>
<span class="fc" id="L438">		int[] fteData = new int[dataLength];</span>
<span class="fc" id="L439">		int dataIndex = 0;</span>
<span class="fc" id="L440">		int numberOfIntervalsWithNonZeroConnectRate = 0;</span>
<span class="fc" id="L441">		double totalAHT = 0.0;</span>
<span class="fc" id="L442">		double totalAbsenteeism = 0.0;</span>

<span class="fc bfc" id="L444" title="All 2 branches covered.">		for (Date currentTime = startTime; currentTime.before(endTime); currentTime = new Date(currentTime.getTime() </span>
			+ Trace.INTERVAL_IN_MILLIS)) {
<span class="fc" id="L446">			double connectRate = forecastCube.getTraceValue(connectRateTraceType, currentTime);</span>
<span class="fc" id="L447">			double rightPartyConnectRate = forecastCube.getTraceValue(rpcRateTraceType, currentTime);</span>
<span class="fc" id="L448">			double aht = forecastCube.getTraceValue(ahtTraceType, currentTime);</span>
			// Absenteeism is the degree to which employees who are scheduled to work, don't
			// actually work.  We increase the scheduling requirement so that absenteeism is
			// taken into account.
<span class="fc" id="L452">			double absenteeism = (shrinkageSeries[dataIndex] + modelingFactorSeries[dataIndex]) / CENT_PERCENT;</span>
			
			//If it is an RPC goal, then AHT is increased by the ratio of CR/RPCR first to reflect the fact
			//that some of the connects will be wrong parties.  
<span class="pc bpc" id="L456" title="3 of 4 branches missed.">			if (serviceGoalType.equals(ServiceGoalsType.RIGHT_PARTY_CONNECTS) &amp;&amp; rightPartyConnectRate &gt; 0) {</span>
<span class="nc" id="L457">				aht *= connectRate / rightPartyConnectRate;</span>
			}
			
<span class="fc bfc" id="L460" title="All 2 branches covered.">			if (connectRate &gt; 0) {</span>
<span class="fc" id="L461">				numberOfIntervalsWithNonZeroConnectRate++;</span>
<span class="fc" id="L462">				totalAHT += aht;</span>
<span class="fc" id="L463">				totalAbsenteeism += absenteeism;</span>
			}
			
			//Initialize array of FTE requirements to 0.  In the next step we will calculate FTE requirements
			//based on the forecasted call lists.
<span class="fc" id="L468">			fteData[dataIndex] = 0;</span>
<span class="fc" id="L469">			dataIndex++;</span>
		}
		
<span class="fc" id="L472">		double averageAHT = 0.0;</span>
<span class="fc" id="L473">		double averageAbsenteeism = 0.0;</span>
<span class="fc bfc" id="L474" title="All 2 branches covered.">		if (numberOfIntervalsWithNonZeroConnectRate &gt; 0) {</span>
<span class="fc" id="L475">			averageAHT = totalAHT / numberOfIntervalsWithNonZeroConnectRate;</span>
<span class="fc" id="L476">			averageAbsenteeism = totalAbsenteeism / numberOfIntervalsWithNonZeroConnectRate;</span>
		}
		
<span class="fc bfc" id="L479" title="All 2 branches covered.">		for (ForecastProfileList forecastedCallList : forecastedCallLists) {</span>
<span class="fc" id="L480">			int listLength = forecastedCallList.getLength();</span>
<span class="fc" id="L481">			Date listStartDate = forecastedCallList.getStartTime();</span>
<span class="fc" id="L482">			Date listEndDate = forecastedCallList.getEndTime();</span>
			
			//prorate list
<span class="pc bpc" id="L485" title="1 of 2 branches missed.">			if (listStartDate.before(spStartTime)) {</span>
<span class="nc" id="L486">				listLength *= ((float)(listEndDate.getTime() - spStartTime.getTime()) /</span>
<span class="nc" id="L487">						(float)(listEndDate.getTime() - listStartDate.getTime()));</span>
<span class="nc" id="L488">				listStartDate = spStartTime;</span>
			}
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">			if (listEndDate.after(spEndTime)) {</span>
<span class="nc" id="L491">				listLength *= ((float)(spEndTime.getTime() - listStartDate.getTime()) /</span>
<span class="nc" id="L492">						(float)(listEndDate.getTime() - listStartDate.getTime()));</span>
<span class="nc" id="L493">				listEndDate = spEndTime;</span>
			}

			//Determine the index in the array corresponding to the start of the list
<span class="fc" id="L497">			int dataIndexForList = (int) (((listStartDate.getTime() - spStartTime.getTime()) / (1000 * 60)) / 15);</span>

			//move overlapping lists to next interval
<span class="fc" id="L500">			int fte = fteData[dataIndexForList];</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">			while (fte &gt; 0) {</span>
<span class="nc" id="L502">				dataIndexForList++;</span>
<span class="nc" id="L503">				fte = fteData[dataIndexForList];</span>
			}

			//setAgentRequirements
<span class="fc" id="L507">			fteData[dataIndexForList] = (int) Math.floor(listLength * averageAHT * (connectGoalPercent / CENT_PERCENT) </span>
				/ 900.0 / (1.0 - averageAbsenteeism) + 0.5);
<span class="fc" id="L509">		}</span>

<span class="fc" id="L511">		return fteData;</span>
	}

	/**
	 * Returns a series of FTE requirements calculated for the specified project.
	 * &lt;p&gt;
	 * The entire workload for the project is placed in the first time interval
	 * of the project.
	 * 
	 * @param startTime the start time, inclusive, for which FTE numbers are desired
	 * @param endTime the end time, exclusive, for which FTE numbers are desired
	 * 
	 * @return an array of the appropriate FTE requirements for each 15-minute interval
	 * from startTime (inclusive) to endTime (exclusive).
	 */
	public static int[] getFteRequirementsProject(
			Project project,
			Date startTime,
			Date endTime) {
<span class="nc" id="L530">		int dataLength = getSizeOfFteArray(startTime, endTime);</span>
<span class="nc" id="L531">		int projectStartIndex = getIntervalIndexFromTime(</span>
				startTime,
<span class="nc" id="L533">				project.getStartDate());</span>
<span class="nc" id="L534">		int[] fteData = new int[dataLength];</span>
<span class="nc" id="L535">		fteData[projectStartIndex] = TraceUtil.roundDouble(project.getWorkMinutes() / Trace.INTERVAL);</span>
<span class="nc" id="L536">		return fteData;</span>
	}
	
	/**
	 * Caclulates and returns the size of the array that will be required to hold
	 * FTE data for every interval between startTime and endTime, based on the length
	 * of the interval Trace.INTERVAL_IN_MILLIS.
	 */
	public static int getSizeOfFteArray(Date startTime, Date endTime) {
<span class="nc" id="L545">		return getIntervalIndexFromTime( startTime,</span>
<span class="nc" id="L546">				new Date(endTime.getTime() + Trace.INTERVAL_IN_MILLIS - 1));</span>
	}

	/**
	 * Returns the index of the interval in which {@code targetTime} falls, starting from 
	 * {@code startTime}.
	 * &lt;p&gt;
	 * Intervals are numbered starting with zero at {@code startTime}.
	 * 
	 * @param startTime the start time relative to which the index is to be calculated
	 * @param targetTime the target time for which the index is to be calculated
	 * @return the index of the interval in which {@code targetTime} falls, starting from 
	 * {@code startTime}
	 */
	private static int getIntervalIndexFromTime(
			Date startTime,
			Date targetTime) {
<span class="nc" id="L563">		return (int)Math.floor( (double)(targetTime.getTime() - startTime.getTime()) / Trace.INTERVAL_IN_MILLIS );</span>
	}

	/**
	 * Represents a project within the context of forecasting FTE for projects.
	 */
<span class="nc" id="L569">	public static class Project {</span>
		private final Date m_startDate;
		private final Date m_endDate;
		private final float m_durationMinutes;

		/**
		 * Creates a new {@link Project}.
		 * 
		 * @param startDate the earliest {@code Date} for which work may be scheduled on the project
		 * @param endDate the earliest {@code Date} for which work may no longer be scheduled on the project
		 * @param workMinutes the total work time in minutes that must be scheduled for the project
		 */
<span class="nc" id="L581">		public Project(Date startDate, Date endDate, float workMinutes) {</span>
<span class="nc" id="L582">			m_startDate = startDate;</span>
<span class="nc" id="L583">			m_endDate = endDate;</span>
<span class="nc" id="L584">			m_durationMinutes = workMinutes;</span>
<span class="nc" id="L585">		}</span>

		/**
		 * Returns the project's start date.
		 */
		public Date getStartDate() {
<span class="nc" id="L591">			return m_startDate;</span>
		}

		/**
		 * Returns the project's end date.
		 */
		public Date getEndDate() {
<span class="nc" id="L598">			return m_endDate;</span>
		}

		/**
		 * Returns the required amount of work in minutes to complete the project.
		 */
		public float getWorkMinutes() {
<span class="nc" id="L605">			return m_durationMinutes;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>