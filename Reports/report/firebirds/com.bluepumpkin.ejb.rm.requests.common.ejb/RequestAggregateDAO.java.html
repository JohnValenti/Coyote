<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestAggregateDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.ejb</a> &gt; <span class="el_source">RequestAggregateDAO.java</span></div><h1>RequestAggregateDAO.java</h1><pre class="source lang-java linenums">/*
 * AggregateRequestDAO.java
 *
 * Created on February 2, 2003, 3:05 PM
 */

package com.bluepumpkin.ejb.rm.requests.common.ejb;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.witness.ejb.core.security.model.User;

/**
 * Base DAO class to represent the 1 to 1 relationship (inheritance) between a base (REQUEST) and
 * derived table (such as SHIFTSWAP and TIMEOFF) in the database schema.  These tables
 * are linked by &quot;propogated keys&quot;, keys that share the same value in the
 * base and derived table.
 *
 * A DAO class that manages the derived table inherits from this class to
 * implement common functionality to persist information to the base table.
 *
 */
public abstract class RequestAggregateDAO extends RmDAONode  {

    //todo: lifetime of m_aggdDAO: lifetime of this DAO or just during each method execution.
<span class="pc" id="L49">    private RequestDAO m_aggdDAO = null;</span>

<span class="fc" id="L51">    private static Category m_cat = Log.initCategory(RequestAggregateDAO.class.getName());</span>

    // the validity of this flag is for the duration of a single getXXX method.  After each
    //   method execution, the flag is reset to 'true'.
    //private boolean m_includeExpiredReqs = true;

    // valid state transitions
    //protected static final HashMap m_validTransitions = RequestAuditTrail.VALID_TRANSITION_MAP;

    //protected Class m_parentDAO;

    {
        // getDetailLevel() returns the detailLevel passed to this DAO's constructor during
        // creation.  This will mostly be DL_BASIC.
<span class="pc" id="L65">        m_aggdDAO = new RequestDAO(m_dmo, getRequestType(), getDetailLevel());</span>
    }

    /** Creates a new instance of AggregateRequestDAO */
    /*public RequestAggregateDAO() {
    }*/

    /*public RequestAggregateDAO(Jdmo dmo) {
        super(dmo);
    }*/

    protected void initClass(long detailLevel)  {
<span class="fc" id="L77">        saveAndSetDetailLevel(detailLevel);</span>
<span class="fc" id="L78">    }</span>

    public RequestAggregateDAO(/*Class parentDAO, */long detailLevel)  {
<span class="fc" id="L81">        super();</span>
<span class="fc" id="L82">        initClass(detailLevel);</span>
<span class="fc" id="L83">    }</span>

    public RequestAggregateDAO(Jdmo dmo, /*Class parentDAO, */long detailLevel)  {
<span class="nc" id="L86">        super(dmo);</span>
<span class="nc" id="L87">        initClass(detailLevel);</span>
<span class="nc" id="L88">    }</span>

    protected String getAggregatedTableName() {
<span class="nc" id="L91">        return m_aggdDAO.getFieldInfo().getTableName();</span>
    }

    /**
     * The type of Request this DAO handles.  Returns one of
     * {@link Request#REQUESTTYPE_SHIFTBID REQUESTTYPE_SHIFTBID},
     * {@link Request#REQUESTTYPE_SHIFTSWAP REQUESTTYPE_SHIFTSWAP},
     * {@link Request#REQUESTTYPE_TIMEOFF REQUESTTYPE_TIMEOFF}
     *
     * @return
     */
    protected abstract String getRequestType();

   /**
     *  delete objects given a list of their ids
     *
     * &lt;p&gt; Note: refer to {@link com.bluepumpkin.ejb.bbm.dao.DAOUtil#deleteObjects(Jdmo, String, Collection) deleteObjects}
     * for information about ssItems shared between ssReqs and ssPostings
     *
     */
    public void deleteObjects(Collection objID) throws BbmRemoveException
    {
                /** cascade delete procedure should take care of deleting the records
        * from the linked tables
                */
<span class="nc" id="L116">        m_aggdDAO.deleteObjects(objID);</span>
<span class="nc" id="L117">    }</span>

    /**
     *  delete objects given a list of their ids
     *
     * &lt;p&gt; Note: refer to {@link com.bluepumpkin.ejb.bbm.dao.DAOUtil#deleteObjects(Jdmo, String, Collection) deleteObjects}
     * for information about ssItems shared between ssReqs and ssPostings
     *
     */
    public void deleteObjects(String strSQL) throws BbmRemoveException
    {
       /** cascade delete procedure should take care of deleting the records
        * from the linked tables
        */

        // Cascade delete all the objects from request that match selection.  Note that
        // delete starts from REQUEST table
<span class="fc" id="L134">        m_aggdDAO.deleteObjects(strSQL);</span>
<span class="fc" id="L135">    }</span>

    /**
     *  read object from database given its ID.
     */
    public ValueObjectBase getObjectByID(ID id)
        throws BbmObjectNotFoundException, BbmFinderException
    {
        //
        // Unless set, the used detailLevel will be the one specified during m_aggdDAO's creation (same as
        // the detail level passed to this DAO's constructor, usually DL_BASIC).  Replace this with the
        // detailLevel passed to the getXXXX() call.
        //
        // this statement has to precede the call below since the Request VO associated
        // with the ReqAgg VO must have the detailLevel specified below.  If not, the
        // detailLevel will be DL_BASIC (see above).
<span class="fc" id="L151">        m_aggdDAO.setDetailLevel(getDetailLevel());</span>

        // This retrieves both the dervied and base object (Request).
<span class="fc" id="L154">        RequestAggregate requestAgg =</span>
<span class="fc" id="L155">                (RequestAggregate)super.getObjectByID(id);</span>

        // load only the base object's children as the
        // base object itself was loaded with the dervied object (see above)
<span class="fc" id="L159">        m_aggdDAO.loadChildObjects(requestAgg.getAggregatedRequest());</span>

<span class="fc" id="L161">        return requestAgg;</span>
    }

    /**
     *   get a collection of objects given a filter condition
     */
    public Collection getObjects(String strWhere)
        throws BbmFinderException
    {
        //
        // Unless set, the used detailLevel will be the one specified during m_aggdDAO's creation (same as
        // the detail level passed to this DAO's constructor, usually DL_BASIC).  Replace this with the
        // detailLevel passed to the getXXXX() call.
        //
        // this statement has to precede the call below since the Request VO associated
        // with the ReqAgg VO must have the detailLevel specified below.  If not, the
        // detailLevel will be DL_BASIC (see above).
<span class="fc" id="L178">        m_aggdDAO.setDetailLevel(getDetailLevel());</span>

        // retrieve the collection of  aggregate (and its aggregated object).
<span class="fc" id="L181">        Collection reqAggs = super.getObjects(strWhere);</span>

        // create a collection of RequestAggregates
<span class="fc" id="L184">        ArrayList aggdReqs = new ArrayList(reqAggs.size());</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (Iterator it = reqAggs.iterator(); it.hasNext(); )</span>
        {
<span class="fc" id="L187">            RequestAggregate requestAgg = (RequestAggregate)it.next();</span>
<span class="fc" id="L188">            aggdReqs.add(requestAgg.getAggregatedRequest());</span>
<span class="fc" id="L189">        }</span>

        // load only the aggregated object's children as the aggregated object itself was
        // fetched along with the dervied object (see above)
<span class="fc" id="L193">        m_aggdDAO.loadChildObjects(aggdReqs);</span>

<span class="fc" id="L195">        return reqAggs;</span>
    }

    /**
     * Each getObjectsXXXX() in DAOBase calls this method to obtain the columns
     * to be retrieved from db.  This implementation needs a select clause
     * with columns from the base (REQUEST) and derived table (using a SQL join).
     * so that the base (Request) and derived (ShiftSwapRequest or TORequest)
     * objects can be instantiated using a single SQL query.
     */
    protected StringBuffer getSelectStatement()
    {
<span class="fc" id="L207">        StringBuffer strSQL = new StringBuffer(200);</span>

        /* first append all the fields from the base (REQUEST) table */
<span class="fc" id="L210">        strSQL.append(&quot;SELECT &quot;);</span>
<span class="fc bfc" id="L211" title="All 2 branches covered.">        for (int i = 0; i &lt; m_aggdDAO.getFieldInfo().getFieldCount(); i++)</span>
        {
<span class="fc bfc" id="L213" title="All 2 branches covered.">            if (i != 0) strSQL.append(&quot;, &quot;);</span>

<span class="fc" id="L215">            strSQL.append(&quot;A.&quot;);</span>
<span class="fc" id="L216">            strSQL.append(m_aggdDAO.getFieldInfo().getFieldName(i));</span>
        }
<span class="fc" id="L218">        strSQL.append(&quot;, &quot;);</span>

        /* now append all the fields from the derived table */
<span class="fc bfc" id="L221" title="All 2 branches covered.">        for (int i = 0; i &lt; getFieldInfo().getFieldCount(); i++)</span>
        {
<span class="fc bfc" id="L223" title="All 2 branches covered.">            if (i != 0) strSQL.append(&quot;, &quot;);</span>

<span class="fc" id="L225">            strSQL.append(&quot;B.&quot;);</span>
<span class="fc" id="L226">            strSQL.append(getFieldInfo().getFieldName(i));</span>
        }
<span class="fc" id="L228">        strSQL.append(&quot; &quot;);</span>
<span class="fc" id="L229">        return strSQL;</span>
    }

    // todo: does this belong here?
    protected void appendSystemFieldsToSelect(StringBuffer strSelect)
    {
<span class="fc" id="L235">        strSelect.append(&quot;, A.CHANGECOUNTER, A.MODIFIEDBY &quot;);</span>
<span class="fc" id="L236">    }</span>

    /** @return true means there is a 'where' in the select statement */
    protected boolean appendFromWhereStatement(StringBuffer strSQL)
    {
<span class="fc" id="L241">        strSQL.append(&quot;FROM &quot;);</span>
<span class="fc" id="L242">        strSQL.append(m_aggdDAO.getFieldInfo().getTableName());</span>
<span class="fc" id="L243">        strSQL.append(&quot; A, &quot;);</span>
<span class="fc" id="L244">        strSQL.append(getFieldInfo().getTableName() + &quot; B &quot;);</span>
<span class="fc" id="L245">        strSQL.append(&quot;WHERE A.ID = B.ID &quot;);</span>
        // if expired requests are to be excluded.
<span class="fc bfc" id="L247" title="All 2 branches covered.">        if ( (getDetailLevel() &amp; Request.DL_INCLUDE_EXPIRED) == 0 )  {</span>
<span class="fc" id="L248">            strSQL.append(&quot; AND A.EXPIRATIONDATE &gt;= '&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;' &quot;);</span>
        }

<span class="fc" id="L251">        return true;</span>
    }

    /**
     * Invoked by DAOBase, for each getObjectsXXXX() method,  to store the rowset retrieved
     * from the db into a value object (deserialize from db into valueobject).  The base
     * object (Request) and derived object are constructed from the retrieved row.
     *
     *  @param rs dmoRowset handle from where the object is intialized
     */
    public ValueObjectBase readObjectFromDB(JdmoRowset rs)
        throws Exception
    {
<span class="fc" id="L264">        Request request =</span>
<span class="fc" id="L265">            (Request)m_aggdDAO.readObjectFromDB(rs);</span>

<span class="fc" id="L267">        RequestAggregate requestAgg =</span>
<span class="fc" id="L268">            (RequestAggregate) super.readObjectFromDB(rs);</span>

<span class="fc" id="L270">        requestAgg.setAggregatedRequest(request);</span>

<span class="fc" id="L272">        return requestAgg;</span>
    }

    /** create a child DAO object given the type */
    /*protected DAOBase createChildDAO(int iType) {
       return m_aggdDAO.createChildDAO(iType);
    }*/

    /** Determines if the object to be created can specify its ID
     * instead of using the sequence allocation scheme built into jdmo.
     * In this case, the ID used, say for a timeoff or shiftswap request,
     * must match the ID of the base request (REQUEST table)
     */
    protected boolean allowCreateWithId()
    {
<span class="fc" id="L287">        return true;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.bbm.dao.DAOBase#cleanUp()
     */
    public void cleanUp() {
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">        if (m_aggdDAO != null) m_aggdDAO.cleanUp();</span>
<span class="fc" id="L295">        super.cleanUp();</span>
<span class="fc" id="L296">    }</span>

//    protected void setDetailLevel(long detailLevel)  {
//        m_detailLevel = detailLevel;
//        m_aggdDAO.setDetailLevel(m_detailLevel);
//    }

    public RequestAggregate getRequestByID(ID requestID, long detailLevel)
        throws BbmFinderException,  BbmObjectNotFoundException
    {
<span class="fc" id="L306">        saveAndSetDetailLevel(detailLevel);</span>
        try  {
<span class="fc" id="L308">            return (RequestAggregate) getObjectByID(requestID);</span>
        } finally  {
<span class="pc" id="L310">            resetDetailLevel();</span>
        }
    }

    public Collection getRequestsByIDs(Collection requestIDs, long detailLevel)
        throws BbmFinderException,  BbmObjectNotFoundException
    {
<span class="fc" id="L317">        saveAndSetDetailLevel(detailLevel);</span>
        try   {
<span class="fc" id="L319">            Collection coll = getObjectsByIDs(requestIDs);</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">            return (coll != null)?coll:Collections.EMPTY_LIST;</span>
        } finally  {
<span class="pc" id="L322">            resetDetailLevel();</span>
        }
    }

    /**
     * Find a collection of request ids for a given employee.
     */
    public Collection getRequestIDsByEmployee(ID employeeID, long detailLevel)
        throws Exception
    {
<span class="nc" id="L332">        saveAndSetDetailLevel(detailLevel);</span>
        try  {
            //todo: in-efficient as we retrieve the entire record and not just the ID
<span class="nc" id="L335">            Collection requests = getRequestsByEmployee(employeeID, detailLevel);</span>

<span class="nc" id="L337">            ArrayList IDs = new ArrayList();</span>
<span class="nc" id="L338">            Iterator itr = requests.iterator();</span>

<span class="nc bnc" id="L340" title="All 2 branches missed.">            while (itr.hasNext()) {</span>
<span class="nc" id="L341">                IDs.add(itr.next());</span>
            }

<span class="nc" id="L344">            return IDs;</span>
        } finally  {
<span class="nc" id="L346">            resetDetailLevel();</span>
        }
    }

    /**
     * Find a collection of time off requests for a given employeeID
     * @param employeeID the employee id
     * @return a collection of TORequest objects matching the employeeID
     */
    public Collection getRequestsByEmployee(ID employeeID, long detailLevel)
        throws Exception
    {
<span class="fc" id="L358">        Collection requests = Collections.EMPTY_LIST;</span>

<span class="fc" id="L360">        saveAndSetDetailLevel(detailLevel);</span>
        try {
<span class="fc" id="L362">            requests = getObjects(&quot;A.EMPLOYEEID=&quot; + employeeID);</span>
        } finally  {
<span class="pc" id="L364">            resetDetailLevel();</span>
<span class="fc" id="L365">        }</span>

<span class="fc" id="L367">        return requests;</span>
    }

    /**
     * ShiftSwapRequest inherits from base class Request, but there are
     * separate REQUEST and SHIFTSWAPREQUEST database tables.
     * creatObject() uses the input objValue to write the relevant
     * columns to each of the database tables.
     *
     * @param pObjValue - ShiftSwapRequest Object.
     * @param comments - Comments which are written to the RequestAuditTrail.
     * @return ID - ID object for the created object.
     * @throws BbmCreateException
     * @throws BbmFinderException
     */
    public ID createRequest(RequestAggregate reqAgg, String comment, User createUser)
        throws Exception {

//      ID requestID = createObject(reqAgg, comments);

        // if request status is not set, set it to PENDING.
<span class="fc" id="L388">        String status = reqAgg.getRequestStatus();</span>
<span class="pc bpc" id="L389" title="1 of 2 branches missed.">        if ( status == null) {</span>
<span class="nc" id="L390">            status = RequestAuditTrail.STATUS_PENDING;</span>
<span class="nc" id="L391">            reqAgg.setRequestStatus(status);</span>
        }

        // insert into the base table REQUEST.
<span class="fc" id="L395">        Request request = reqAgg.getAggregatedRequest();   // retrieve the base</span>
<span class="fc" id="L396">        m_cat.debug(&quot;Inserting Request: &quot; + request);</span>
<span class="fc" id="L397">        ID reqID = m_aggdDAO.createRequest(request, comment, createUser);   // create the base request</span>

        // insert into the dervived table
<span class="fc" id="L400">        reqAgg.setID(reqID);</span>
<span class="fc" id="L401">        m_cat.debug(&quot;Inserting RequestAggregate: &quot; + reqAgg);</span>
<span class="fc" id="L402">        super.createObject(reqAgg);</span>

        //reset m_setDeleteAllChildren to prevent the flag from being processed
        //again if the request is reused.
<span class="fc" id="L406">        HashSet deleteAllChildrenSet = reqAgg.getDeleteAllChildrenSet();</span>
<span class="pc bpc" id="L407" title="1 of 2 branches missed.">        if (deleteAllChildrenSet != null ) deleteAllChildrenSet.clear();</span>

<span class="fc" id="L409">        reqAgg.moveChildrenFromCreatedToPersisted();</span>

<span class="fc" id="L411">        return reqID;</span>
    }

    /**
     * updates the given request.
     *
     * @param objValue - the request to be updated
     * @param comments - comments that are written to the RequestAuditTrail table
     * @param checkState - if &lt;tt&gt;true&lt;/tt&gt; check for valid state. for auto-approval
     * this should be set to false
     * @throws BbmUpdateException
     * @throws MultiUserException
     */
    public void updateRequest(RequestAggregate reqAgg, String comment, User updateUser)
        throws Exception {

//        try {
            //TODO: if ssr.deleteAllChildren() was called, then verify that both
            // SSReqItems and SSItems associated are deleted and not just SSReqItems.
//            updateObject(reqAgg, comments);
            // get the new request object.
<span class="fc" id="L432">            Request newRequest = reqAgg.getAggregatedRequest();</span>

            // update base table (REQUEST)
<span class="fc" id="L435">            newRequest.setID(reqAgg.getID());</span>
<span class="fc" id="L436">            m_aggdDAO.updateRequest(newRequest, comment, updateUser);</span>

            // update dervied table
<span class="fc" id="L439">            super.updateObject(reqAgg);</span>
//        } c_atch ( Exception e ) {
//            t_hrow RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);
//        }
<span class="fc" id="L443">    }</span>

    /**
     * @param requestId
     */
    public void deleteRequest(ID requestId) throws Exception {
<span class="nc" id="L449">        deleteObject(requestId);</span>
<span class="nc" id="L450">    }</span>

    /**
     * @param reqIDs
     */
    public void deleteRequests(Collection reqIDs) throws Exception  {
<span class="nc" id="L456">        deleteObjects(reqIDs);</span>
<span class="nc" id="L457">    }</span>

    /**
     * Provides the SQL query used to filter requests to be deleted:  The query is utilized in
     * following methods:
     * &lt;li&gt; RequestAggregateDAO.deleteRequests(orgID...)
     * &lt;li&gt; RequestAggregateDAO.deleteRequestsByDate(orgID..)
     * &lt;li&gt; RequestAggregateDAO.deleteRequestsByDateRange(orgID...)
     *
     * &lt;p&gt; UI options for request purging:&lt;br&gt;
     * &lt;pre&gt;
     * Requests Type  &quot;All | Shift Bidding | Shift Swap | Time Off&quot;.&lt;br&gt;
     *    For requests created from  &quot;Current Organization | Organization Branch&quot;&lt;br&gt;
     *
     *    All requests of this type (startDate == null; endDate == null)&lt;br&gt;
     *    For requests created more than  &quot;n&quot; days in the past (startDate != null; endDate == null) &lt;br&gt;
     *    For requests created from -  &quot;fromDate&quot; to &quot;toDate&quot;  (startDate != null; endDate != null)&lt;br&gt;
     * &lt;/pre&gt;
     *
     * Note: This was an abstract method earlier.  concrete implementations in the subclasses
     * were commented and a common implementation was implemented here.
     *
     * @param organizationID
     * @param isForBranch
     * @param requestType
     * @param subType
     * @param startDate
     * @param endDate
     * @param selectClause
     * @param fromClause
     * @param whereClause
     * @return
     */
    protected void getSQLFilterForRequestDeletion(ID orgID, boolean isForBranch, String requestType, ID subType, Date startDate,
        Date endDate, StringBuffer selectClause, StringBuffer fromClause, StringBuffer whereClause) throws Exception {

    	  // QC53354/QA97533 getEmployeeIDsInOrganization changed to use effectivity
<span class="fc" id="L494">    	  Date dtStart = startDate;</span>
<span class="fc" id="L495">    	  Date dtEnd = endDate;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">    	  if (startDate==null) {</span>
<span class="fc" id="L497">    		  dtStart = new Date();</span>
<span class="fc" id="L498">    		  dtEnd = new Date();</span>
    	  }
<span class="fc" id="L500">          Collection orgEmpIDs = RequestUtil.getEmployeeIDsInOrganization(orgID, isForBranch, dtStart, dtEnd);</span>

<span class="fc" id="L502">          selectClause.append(&quot;SELECT req.id &quot;);</span>
<span class="fc" id="L503">          fromClause.append(&quot;FROM request req &quot;);</span>

          // append where clause conditions
<span class="fc" id="L506">          whereClause.append(&quot; WHERE req.employeeid IN &quot;).append(m_dmo.createInClause(orgEmpIDs));</span>
<span class="fc" id="L507">          whereClause.append(&quot; AND req.requesttype = '&quot;).append(getRequestType()).append('\'');</span>

          // startDate != null and endDate == null: delete requests for the dates more than &lt;n&gt; days in the past.
          // startDate == null and endDate == null: delete all requests
          // startDate != null and endDate != null: delete requests created between the dates.
<span class="pc bpc" id="L512" title="3 of 4 branches missed.">          if (startDate != null &amp;&amp; endDate == null) {</span>
<span class="nc" id="L513">              whereClause.append(&quot; AND req.submittedon  &lt; '&quot;).append(JdmoUtil.formatDBString(startDate)).append('\'');</span>
<span class="pc bpc" id="L514" title="2 of 4 branches missed.">          } else if (startDate == null &amp;&amp; endDate == null) {</span>
              //
<span class="nc bnc" id="L516" title="All 4 branches missed.">          } else if (startDate != null &amp;&amp; endDate != null) {</span>
              // and req.submittedon between startDate and endDate
<span class="nc" id="L518">              whereClause.append(&quot; AND req.submittedon BETWEEN '&quot;).append(JdmoUtil.formatDBString(startDate)).</span>
<span class="nc" id="L519">                append(&quot;' AND '&quot;).append(JdmoUtil.formatDBString(endDate)).append('\'');</span>
          }
<span class="fc" id="L521">    }</span>

    /**
     * Delete time off requests for all employees in an organization
     */
    public void deleteRequests(ID organizationID, boolean isForBranch, String requestType, ID subType)
        throws Exception {
//        try {
<span class="fc" id="L529">            StringBuffer selectClause = new StringBuffer(128);</span>
<span class="fc" id="L530">            StringBuffer fromClause = new StringBuffer(128);</span>
<span class="fc" id="L531">            StringBuffer whereClause = new StringBuffer(128);</span>

<span class="fc" id="L533">            getSQLFilterForRequestDeletion(organizationID, isForBranch, requestType, subType, null, null,</span>
                selectClause, fromClause, whereClause);
<span class="fc" id="L535">            String sql = RequestUtil.concatStrBuffers(selectClause, fromClause, whereClause, &quot; &quot;);</span>

<span class="pc bpc" id="L537" title="1 of 2 branches missed.">            if (!StringUtil.isEmpty(sql)) deleteObjects(sql);</span>
//        } c_atch (Exception e) {
//            t_hrow RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);
//        }
<span class="fc" id="L541">    }</span>

    /**
     * Delete time off requests for all employees in an organization.  We delete all the
     * requests for the given organization and activity (if specified) that have all of
     * their date choices before the given date.  In other words, the end date of the
     * time off request is before the given date.
     */
    public void deleteRequestsByDate(ID organizationID, boolean isForBranch, Date date, String requestType, ID subType)
        throws Exception {
//        try {
<span class="nc" id="L552">            StringBuffer selectClause = new StringBuffer(128);</span>
<span class="nc" id="L553">            StringBuffer fromClause = new StringBuffer(128);</span>
<span class="nc" id="L554">            StringBuffer whereClause = new StringBuffer(128);</span>

            // QC53354/QA97533 change logic to incorporate effectivity
<span class="nc" id="L557">            Date dtEnd = date;</span>
<span class="nc" id="L558">            Date dtStart = new Date(0); // January 1, 1970</span>
<span class="nc" id="L559">            getSQLFilterForRequestDeletion(organizationID, isForBranch, requestType, subType, dtStart, dtEnd,</span>
                selectClause, fromClause, whereClause);
<span class="nc" id="L561">            String sql = RequestUtil.concatStrBuffers(selectClause, fromClause, whereClause, &quot; &quot;);</span>

<span class="nc bnc" id="L563" title="All 2 branches missed.">            if (!StringUtil.isEmpty(sql)) deleteObjects(sql);</span>
//        } c_atch (Exception e) {
//            t_hrow RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);
//        }
<span class="nc" id="L567">    }</span>

    /**
     * Delete all TimeOff requests for employees in the given organization
     * created in the given range.
     */
    public void deleteRequestsByDateRange(ID organizationID, boolean isForBranch, TimeRange range,
        String requestType, ID subType) throws Exception {
//        try {
<span class="nc" id="L576">            StringBuffer selectClause = new StringBuffer(128);</span>
<span class="nc" id="L577">            StringBuffer fromClause = new StringBuffer(128);</span>
<span class="nc" id="L578">            StringBuffer whereClause = new StringBuffer(128);</span>

<span class="nc" id="L580">            getSQLFilterForRequestDeletion(organizationID, isForBranch, requestType, subType, range.getStartDate(),</span>
<span class="nc" id="L581">                range.getEndDate(), selectClause, fromClause, whereClause);</span>
<span class="nc" id="L582">            String sql = RequestUtil.concatStrBuffers(selectClause, fromClause, whereClause, &quot; &quot;);</span>

<span class="nc bnc" id="L584" title="All 2 branches missed.">            if (!StringUtil.isEmpty(sql)) deleteObjects(sql);</span>
//        } c_atch (Exception e) {
//            t_hrow RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);
//        }
<span class="nc" id="L588">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>