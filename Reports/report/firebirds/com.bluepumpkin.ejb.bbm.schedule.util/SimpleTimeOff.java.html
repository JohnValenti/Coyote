<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SimpleTimeOff.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.util</a> &gt; <span class="el_source">SimpleTimeOff.java</span></div><h1>SimpleTimeOff.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.util;

/**
 * Title:        Blue Pumpkin Software BBM
 * Description:
 * Copyright:    Copyright (c) 2001
 * Company:      Blue Pumpkin Software, Inc
 * @author
 * @version 1.0
 */

import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.schedule.model.ImportedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;

public class SimpleTimeOff implements com.bluepumpkin.ejb.bbm.activity.model.Event,
									java.io.Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public static Collection getSimpleTimeOffEvents(Collection cPlannedEvents) {
<span class="nc" id="L33">	LinkedList llEvents = new LinkedList();</span>

<span class="nc bnc" id="L35" title="All 2 branches missed.">	for(Iterator i = cPlannedEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L36">		Event pEvent = (Event)i.next();</span>

<span class="nc bnc" id="L38" title="All 2 branches missed.">		if (pEvent.getEventType() == Event.EVENT_TYPE_IMPORTED) {</span>
<span class="nc" id="L39">		ImportedEvent pImport = (ImportedEvent)pEvent;</span>
<span class="nc bnc" id="L40" title="All 2 branches missed.">		if (pImport.getMinsTowardsMinMax() &gt; 0)</span>
<span class="nc" id="L41">			llEvents.add(new SimpleTimeOff(pImport.getWorkResourceIDs(),pImport.getStartTime(),</span>
<span class="nc" id="L42">								pImport.getEndTime(),pImport.getMinsTowardsMinMax(),pImport.getActivityID(),</span>
<span class="nc" id="L43">								pImport.getDescription()));</span>
<span class="nc" id="L44">		}</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">		else if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L46">		TimeOffEvent pTimeOff = (TimeOffEvent)pEvent;</span>
<span class="nc bnc" id="L47" title="All 2 branches missed.">		if (pTimeOff.getTimeOffRule() == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
<span class="nc" id="L48">			llEvents.add(new SimpleTimeOff(pTimeOff.getWorkResourceIDs(),pTimeOff.getStartTime(),</span>
<span class="nc" id="L49">								pTimeOff.getEndTime(),pTimeOff.getCountsMinutesTowardsRules(),</span>
<span class="nc" id="L50">								pTimeOff.getActivityID(),pTimeOff.getDescription()));</span>


		}
		else {
<span class="nc" id="L55">			int nOverlap = getPaidOverlap(pTimeOff.getStartTime(),pTimeOff.getEndTime(),cPlannedEvents);</span>
<span class="nc bnc" id="L56" title="All 2 branches missed.">			if (nOverlap &gt; 0)</span>
<span class="nc" id="L57">				llEvents.add(new SimpleTimeOff(pTimeOff.getWorkResourceIDs(),pTimeOff.getStartTime(),</span>
<span class="nc" id="L58">								pTimeOff.getEndTime(),nOverlap,</span>
<span class="nc" id="L59">								pTimeOff.getActivityID(),pTimeOff.getDescription()));</span>
		}
		}
<span class="nc" id="L62">	}</span>
<span class="nc" id="L63">	return llEvents;</span>
	}

	private static int getPaidOverlap(Date dtStart, Date dtEnd, Collection cEvents) {
<span class="nc" id="L67">	int nOverlap = 0;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">	for(Iterator i = cEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L69">		Event pEvent = (Event)i.next();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT &amp;&amp;</span>
<span class="nc bnc" id="L71" title="All 4 branches missed.">			pEvent.getStartTime().before(dtEnd) &amp;&amp; pEvent.getEndTime().after(dtStart)) {</span>
			//there is positive overlap, increment the paid overlap
<span class="nc" id="L73">			Date dtOverlapStart = dtStart;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">			if (pEvent.getStartTime().after(dtStart))</span>
<span class="nc" id="L75">				dtOverlapStart = pEvent.getStartTime();</span>
<span class="nc" id="L76">			Date dtOverlapEnd = dtEnd;</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">			if (pEvent.getEndTime().before(dtEnd))</span>
<span class="nc" id="L78">				dtOverlapEnd = pEvent.getEndTime();</span>

<span class="nc" id="L80">			nOverlap += (int) ( (dtOverlapEnd.getTime() - dtOverlapStart.getTime())/ ShiftAssignment.MILLIS_IN_ONE_MIN);</span>
			//subtract unpaid shift events
<span class="nc bnc" id="L82" title="All 2 branches missed.">			for(Iterator j = pEvent.getChildren().iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L83">				Event pChild = (Event)j.next();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">				if (!pChild.getPaid() &amp;&amp;</span>
<span class="nc bnc" id="L85" title="All 4 branches missed.">					pChild.getStartTime().before(dtEnd) &amp;&amp; pChild.getEndTime().after(dtStart)) {</span>
					//there is positive overlap, decrement the unpaid overlap
<span class="nc" id="L87">					dtOverlapStart = dtStart;</span>
<span class="nc bnc" id="L88" title="All 2 branches missed.">					if (pChild.getStartTime().after(dtStart))</span>
<span class="nc" id="L89">						dtOverlapStart = pChild.getStartTime();</span>
<span class="nc" id="L90">					dtOverlapEnd = dtEnd;</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">					if (pChild.getEndTime().before(dtEnd))</span>
<span class="nc" id="L92">						dtOverlapEnd = pChild.getEndTime();</span>

<span class="nc" id="L94">					nOverlap -= (int) ( (dtOverlapEnd.getTime() - dtOverlapStart.getTime())/ ShiftAssignment.MILLIS_IN_ONE_MIN);</span>
				}
<span class="nc" id="L96">			}</span>
		}
<span class="nc" id="L98">	 }</span>
<span class="nc" id="L99">	return nOverlap;</span>
	}

<span class="nc" id="L102">	Collection m_cidWorkResource = null;</span>
<span class="nc" id="L103">	Date m_dtStart = null;</span>
<span class="nc" id="L104">	Date m_dtEnd = null;</span>
<span class="nc" id="L105">	int m_nMinutes = 0;</span>
<span class="nc" id="L106">	ID m_idActivity = null;</span>
<span class="nc" id="L107">	String m_sDescription = &quot;&quot;;</span>

	public SimpleTimeOff(Collection cidWorkResource, Date dtStart,Date dtEnd, int nMinutes,
<span class="nc" id="L110">						ID idActivity, String sDescription) {</span>
<span class="nc" id="L111">	m_dtStart = dtStart;</span>
<span class="nc" id="L112">	m_dtEnd = dtEnd;</span>
<span class="nc" id="L113">	m_cidWorkResource = cidWorkResource;</span>
<span class="nc" id="L114">	m_nMinutes = nMinutes;</span>
<span class="nc" id="L115">	m_idActivity = idActivity;</span>
<span class="nc" id="L116">	m_sDescription = sDescription;</span>
<span class="nc" id="L117">	}</span>

<span class="nc" id="L119">	public int getMinutesTowardsRules() {return m_nMinutes;}</span>

	/**
	 * Returns event type (see enumeration values in Event class). The unique
	 * key that identifies the event object is ID plus event type.
	 */
	public int getEventType()
	{
<span class="nc" id="L127">	return 0;</span>
	}

<span class="nc" id="L130">	public String getDescription() {return m_sDescription;}</span>

<span class="nc" id="L132">	public boolean isLocked() {return false;}</span>

<span class="nc" id="L134">	public Date getStartTime() {return m_dtStart;}</span>

<span class="nc" id="L136">	public Date getEndTime() {return m_dtEnd;}</span>

<span class="nc" id="L138">	public ID getActivityID() {return m_idActivity;}</span>

<span class="nc" id="L140">	public ID getParentID() {return null;}</span>

<span class="nc" id="L142">	public Collection getChildren() {return Collections.EMPTY_LIST;}</span>

	public Collection getWorkResourceIDs() {
<span class="nc" id="L145">	return m_cidWorkResource;</span>
	}

<span class="nc" id="L148">	public int getOverlayPrecedence() {return 0;}</span>

<span class="nc" id="L150">	public ID getID() {return null;}</span>

	public int getDuration() {
<span class="nc" id="L153">		return (int)((m_dtEnd.getTime() - m_dtStart.getTime()) /</span>
			ShiftAssignment.MILLIS_IN_ONE_MIN);
	}

	public boolean getPaid() {
<span class="nc" id="L158">	return true; }</span>

<span class="nc" id="L160">	public void setDescription(String strDescription) {}</span>

<span class="nc" id="L162">	public void setLocked(boolean bLocked) {}</span>

<span class="nc" id="L164">	public void setStartTime(Date startTime) {}</span>

<span class="nc" id="L166">	public void setDuration(int lMinutes) {}</span>

<span class="nc" id="L168">	public void setActivityID(ID activityID) {}</span>

<span class="nc" id="L170">	public void setParentID(ID parentID) {}</span>

<span class="nc" id="L172">	public void setOverlayPrecedence(int precedence) {}</span>

<span class="nc" id="L174">	public void addWorkResourceID(ID workResourceID) {}</span>

<span class="nc" id="L176">	public void removeWorkResourceID(ID workResourceID) {}</span>

	public static void main(String[] args) {
	try {
<span class="nc" id="L180">		Collection cEvents = new LinkedList();</span>
/*
		ImportedEvent pImport = new ImportedEvent();
		pImport.setMinsTowardsMinMax(50);
		pImport.setStartTime(new Date(50,1,10,9,0));
		pImport.setDuration(360);

		cEvents.add(pImport);

		TimeOffEvent pTimeOff = new TimeOffEvent();
		pTimeOff.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES);
		pTimeOff.setCountsMinutesTowardsRules(100);
		pTimeOff.setStartTime(new Date(50,1,12,10,0));
		pTimeOff.setDuration(400);

		cEvents.add(pTimeOff);
		cEvents.add(pTimeOff);

		TimeOffEvent pTimeOff2 = new TimeOffEvent();
		pTimeOff2.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_SHIFT);
		pTimeOff2.setCountsMinutesTowardsRules(100);
		pTimeOff2.setStartTime(new Date(50,1,12,10,0));
		pTimeOff2.setDuration(400);

		cEvents.add(pTimeOff2);

		ShiftAssignment pSA = new ShiftAssignment();
		pSA.setStartTime(new Date(50,1,12,9,0));
		pSA.setDuration(120);

		ShiftEventAssignment pSEA = new ShiftEventAssignment();
		pSEA.setPaid(false);
		pSEA.setStartTime(new Date(50,1,12,9,30));
		pSEA.setDuration(45);

		pSA.addShiftEventAssignment(pSEA);

		cEvents.add(pSA);

		ShiftAssignment pSA2 = new ShiftAssignment();
		pSA2.setStartTime(new Date(50,1,20,9,0));
		pSA2.setDuration(120);

		cEvents.add(pSA2);
*/
<span class="nc" id="L225">		Collection cTimeOffEvents = getSimpleTimeOffEvents(cEvents);</span>

<span class="nc bnc" id="L227" title="All 2 branches missed.">		for (Iterator i = cTimeOffEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L228">			SimpleTimeOff pOff = (SimpleTimeOff) i.next();</span>
<span class="nc" id="L229">			System.out.println(&quot;Start &quot; + pOff.getStartTime() + &quot; End &quot; + pOff.getEndTime() + &quot; Counts &quot; + pOff.getMinutesTowardsRules());</span>
<span class="nc" id="L230">		}</span>

<span class="nc" id="L232">	} catch (Exception e) {</span>
<span class="nc" id="L233">		e.printStackTrace(System.out);</span>
<span class="nc" id="L234">	}</span>
<span class="nc" id="L235">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>