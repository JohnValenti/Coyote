<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOIntervalAllocationDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb</a> &gt; <span class="el_source">TOIntervalAllocationDAO.java</span></div><h1>TOIntervalAllocationDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb;

import java.sql.Timestamp;
import java.sql.Types;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.concurrent.TimeUnit;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalAllocation;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalAllocationFieldInfo;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalApprovedAndPending;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.TimeOffIntervalComparator;

public class TOIntervalAllocationDAO extends DAOBase&lt;TOIntervalAllocation&gt; {

<span class="nc" id="L42">	private static final FieldInfo FIELD_INFO = new TOIntervalAllocationFieldInfo();</span>

	public TOIntervalAllocationDAO(Jdmo dmo) {
<span class="nc" id="L45">		super(dmo);</span>
<span class="nc" id="L46">	}</span>

	@Override
	protected FieldInfo getFieldInfo() {
<span class="nc" id="L50">		return FIELD_INFO;</span>
	}

	@Override
	protected TOIntervalAllocation createValueObject() {
<span class="nc" id="L55">		return new TOIntervalAllocation();</span>
	}

	/**
	 *
	 * @param timeOffPoolID The time off pool ID
	 * @param startDate	Inclusive start time in UTC
	 * @param endDate	Exclusive end time in UTC
	 * @return
	 * 	The list of TimeOffIntervalAllocationCalendar that intersect the range specified by [startDate, endDate)
	 * @throws BbmFinderException
	 */
	protected Collection&lt;TOIntervalAllocation&gt; find(ID timeOffPoolID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L68">		Collection&lt;TOIntervalAllocation&gt; result = new ArrayList&lt;TOIntervalAllocation&gt;();</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (startDate != null) {</span>

			//The minimumStart is one days before the startDate of the range we are interested in.
			//This is used just for performance reasons so that SQL server can use the index on TimeOffIntervalAllocationCalendar.STARTIME
			//This does not play a part in the logic for the intersection
			//We can do this since intervals have a maximum duration of 24 hours, so doing 1 day before the request start will cover all cases
<span class="nc" id="L75">			Date minimumStart = new Date(startDate.getTime() - TimeUnit.DAYS.toMillis(1));</span>

<span class="nc" id="L77">			String where = String.format(&quot; A.TOPOOLID = %d and A.STARTTIME &gt; '%s' and  A.STARTTIME &lt; '%s' and A.ENDTIME &gt; '%s' &quot;,</span>
<span class="nc" id="L78">					timeOffPoolID.toInt(), JdmoUtil.formatDBString(minimumStart), JdmoUtil.formatDBString(endDate),</span>
<span class="nc" id="L79">					JdmoUtil.formatDBString(startDate));</span>
<span class="nc" id="L80">			result = getObjects(where);</span>
		}
<span class="nc" id="L82">		return result;</span>
	}

	/**
	 * Only update the time off interval allocations
	 * Same starttime and endtime but different allocated hours
	 * */
	private Collection&lt;TOIntervalAllocation&gt; getTimeOffIntervalShouldBeUpdated(Collection&lt;TOIntervalAllocation&gt; oldIntervals,
			Collection&lt;TOIntervalAllocation&gt; newIntervals) {
<span class="nc" id="L91">		Collection&lt;TOIntervalAllocation&gt; updateList = new HashSet&lt;TOIntervalAllocation&gt;();</span>
<span class="nc" id="L92">		Collection&lt;TOIntervalAllocation&gt; oldList = new HashSet&lt;TOIntervalAllocation&gt;();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">		for (Iterator&lt;TOIntervalAllocation&gt; it1 = oldIntervals.iterator(); it1.hasNext();) {</span>
<span class="nc" id="L94">			TOIntervalAllocation oldInterval = it1.next();</span>
<span class="nc" id="L95">			long oldStart = oldInterval.getStartTime().getTime();</span>
<span class="nc" id="L96">			long oldEnd = oldInterval.getEndTime().getTime();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			for (Iterator&lt;TOIntervalAllocation&gt; it2 = newIntervals.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L98">				TOIntervalAllocation newInterval = it2.next();</span>
<span class="nc" id="L99">				long newStart = newInterval.getStartTime().getTime();</span>
<span class="nc" id="L100">				long newEnd = newInterval.getEndTime().getTime();</span>
<span class="nc bnc" id="L101" title="All 4 branches missed.">				if (oldStart == newStart &amp;&amp; oldEnd == newEnd) {</span>
<span class="nc" id="L102">					newInterval.setID(oldInterval.getID());</span>
<span class="nc" id="L103">					updateList.add(newInterval);</span>
<span class="nc" id="L104">					oldList.add(oldInterval);</span>
<span class="nc" id="L105">					continue;</span>
				}
<span class="nc" id="L107">			}</span>
<span class="nc" id="L108">		}</span>
<span class="nc" id="L109">		oldIntervals.removeAll(oldList);</span>
<span class="nc" id="L110">		return updateList;</span>
	}

	private Collection&lt;TOIntervalAllocation&gt; getOverlapedIntervals(Collection&lt;TOIntervalAllocation&gt; oldIntervals,
			Collection&lt;TOIntervalAllocation&gt; newIntervals) {
<span class="nc" id="L115">		Collection&lt;TOIntervalAllocation&gt; removeList = new HashSet&lt;TOIntervalAllocation&gt;();</span>
		//Normal Case: Delete all intervals that old interval is inside or overlapped partly with new interval
		//OLD: 0-----------5-------8------------16----------------24
		//NEW: 0-------3------6--7---9--10------16----------------24
		//Result: 0--------5 since  3&lt;5&lt;6
		//        5------8 since 7&lt;8&lt;9
		//        8------16 since 16=16 and 8&lt;10&lt;16
		//Note: 16---24 is not resulted from this one. It is an update case:
		//Special case, it should be an user error
		//OLD: 7--------------12
		//NEW:   8--10---11
		//User should enter intervals: 7-8--10--11--12

<span class="nc bnc" id="L128" title="All 2 branches missed.">		for (Iterator&lt;TOIntervalAllocation&gt; it1 = oldIntervals.iterator(); it1.hasNext();) {</span>
<span class="nc" id="L129">			TOIntervalAllocation oldInterval = it1.next();</span>
<span class="nc" id="L130">			long oldStart = oldInterval.getStartTime().getTime();</span>
<span class="nc" id="L131">			long oldEnd = oldInterval.getEndTime().getTime();</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">			for (Iterator&lt;TOIntervalAllocation&gt; it2 = newIntervals.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L133">				TOIntervalAllocation newInterval = it2.next();</span>
<span class="nc" id="L134">				long newStart = newInterval.getStartTime().getTime();</span>
<span class="nc" id="L135">				long newEnd = newInterval.getEndTime().getTime();</span>
				//normal case:  old interval is inside or overlapped partly
<span class="nc bnc" id="L137" title="All 8 branches missed.">				boolean oldInsideNew = (newStart &lt; oldEnd &amp;&amp; oldEnd &lt; newEnd) ||</span>
								(newStart &lt; oldStart &amp;&amp; oldStart &lt; newEnd);
<span class="nc bnc" id="L139" title="All 4 branches missed.">				boolean oldOverlappedAprt = (oldEnd == newEnd) || (oldStart == newStart);</span>
				//special case:old interval cover new interval
<span class="nc bnc" id="L141" title="All 4 branches missed.">				boolean oldCoverNew = oldStart &lt; newStart &amp;&amp; newEnd &lt; oldEnd;</span>
<span class="nc bnc" id="L142" title="All 6 branches missed.">				if (oldInsideNew || oldOverlappedAprt || oldCoverNew) {</span>
<span class="nc" id="L143">					removeList.add(oldInterval);</span>
				}
<span class="nc" id="L145">			}</span>
<span class="nc" id="L146">		}</span>
<span class="nc" id="L147">		return removeList;</span>
	}

	/*Get overlapped intervals  in a list  
	 * 3/5/2016	0:00	1:15
	   3/5/2016	1:15	2:30
	   3/5/2016	2:30	3:45
	   3/5/2016	0:00	1:30
	   3/5/2016	1:30	3:00
	   3/5/2016	3:00	4:30
	 * Result: 
	   3/5/2016	0:00	1:15
	   3/5/2016	1:30	2:30
	   3/5/2016	3:00	3:45
	 * */
	public Collection&lt;TOIntervalAllocation&gt; getOverlapedIntervals(List&lt;TOIntervalAllocation&gt; intervalList) {
<span class="nc" id="L163">		Set&lt;TOIntervalAllocation&gt; overlapedSet = new HashSet&lt;TOIntervalAllocation&gt;();</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">		if (!intervalList.isEmpty()) {</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			for (int i = 0; i &lt; intervalList.size() - 1; i++) {</span>
<span class="nc" id="L166">				TOIntervalAllocation intervali = intervalList.get(i);</span>
<span class="nc" id="L167">				long iStartTime = intervali.getStartTime().getTime();</span>
<span class="nc" id="L168">				long iEndTime = intervali.getEndTime().getTime();</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				for (int j = i + 1; j &lt; intervalList.size(); j++) {</span>
<span class="nc" id="L170">					TOIntervalAllocation intervalj = intervalList.get(j);</span>
<span class="nc" id="L171">					long jStartTime = intervalj.getStartTime().getTime();</span>
<span class="nc" id="L172">					long jEndTime = intervalj.getEndTime().getTime();</span>
					//intervali has same start time with intervalj but the end time of intervali is before enttime of interval j
<span class="nc bnc" id="L174" title="All 4 branches missed.">					boolean sameStartTime = (jStartTime == iStartTime) &amp;&amp; iEndTime &lt; jEndTime;</span>
					//intervali is inside intervalj
<span class="nc bnc" id="L176" title="All 6 branches missed.">					boolean intervaliInsideIntervalj = iStartTime &lt; jStartTime &amp;&amp; iEndTime &lt; jEndTime &amp;&amp; iEndTime &gt; jStartTime;</span>
<span class="nc bnc" id="L177" title="All 4 branches missed.">					if (sameStartTime || intervaliInsideIntervalj) {</span>
<span class="nc" id="L178">						overlapedSet.add(intervali);</span>
					}
				}
			}
		}
<span class="nc" id="L183">		return overlapedSet;</span>
	}

	/** This servers for saving when importing
	 * @param pTOPoolID - the  TO Pool id of the change
	 * @param hTimeOffIntervals - all time off intervals need to save.
	 * @throws BbmFinderException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws MultiUserException
	 * @throws BbmRemoveException
	 * @throws JdmoException
	 */
	public int[] saveTimeOffIntervals(ID pTOPoolID, Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals, TimeZone tz)
			throws BbmFinderException, BbmCreateException, MultiUserException, BbmUpdateException, BbmRemoveException, JdmoException {

<span class="nc" id="L199">		int[] result = new int[3];</span>
<span class="nc" id="L200">		Collection&lt;TOIntervalAllocation&gt; updateList = new HashSet&lt;TOIntervalAllocation&gt;();</span>
<span class="nc" id="L201">		Collection&lt;TOIntervalAllocation&gt; createList = new HashSet&lt;TOIntervalAllocation&gt;();</span>
<span class="nc" id="L202">		int deletedSize = 0;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">		for (Iterator&lt;LocalDate&gt; itr = hTimeOffIntervals.keySet().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L204">			LocalDate shortDate = itr.next();</span>
<span class="nc" id="L205">			List&lt;TOIntervalAllocation&gt; newTimeOffIntervals = hTimeOffIntervals.get(shortDate);</span>
<span class="nc" id="L206">			Collections.sort(newTimeOffIntervals, new TimeOffIntervalComparator(0));</span>
			LocalDate endShortDate;
			try {
<span class="nc" id="L209">				endShortDate = getEndLocaleDate(shortDate);</span>
<span class="nc" id="L210">			} catch (ParseException e) {</span>
<span class="nc" id="L211">				throw new BbmUpdateException(e);</span>
<span class="nc" id="L212">			}</span>
			//Convert to Date GMT timezone- since DB is saving GMT timezone
<span class="nc" id="L214">			Date startDate = shortDate.getTime(tz, true);</span>
<span class="nc" id="L215">			Date endDate = endShortDate.getTime(tz, true);</span>
			//Get all existing intervals of 1 day
<span class="nc" id="L217">			Collection&lt;TOIntervalAllocation&gt; oldTimeOffIntervals = find(pTOPoolID, startDate, endDate);</span>

<span class="nc bnc" id="L219" title="All 2 branches missed.">			if (oldTimeOffIntervals.isEmpty()) {</span>
				//No existing intervals, Create case
				//Get overlapped intervals and remove them before creating
<span class="nc" id="L222">				Collection&lt;TOIntervalAllocation&gt; overlappedIntervals = getOverlapedIntervals(newTimeOffIntervals);</span>
<span class="nc" id="L223">				createList.addAll(newTimeOffIntervals);</span>
<span class="nc" id="L224">				createList.removeAll(overlappedIntervals);</span>
<span class="nc" id="L225">			} else {</span>
				//If there existing intervals in the date, do 3 steps:
				// STEP1: Get Intervals should be updated- (Intervals have same start date and end date.).
<span class="nc" id="L228">				Collection&lt;TOIntervalAllocation&gt; updatedIntervals = getTimeOffIntervalShouldBeUpdated(oldTimeOffIntervals,</span>
						newTimeOffIntervals);
				//     Put them to the updateList.
<span class="nc" id="L231">				updateList.addAll(updatedIntervals);</span>
				//     At this point, the newIntervals should not have updated intervals so take updatedIntervals out off the newIntervals.
<span class="nc" id="L233">				newTimeOffIntervals.removeAll(updatedIntervals);</span>
				//End STEP1
				//STEP2: Delete all existing intervals  that are overlapped.
<span class="nc bnc" id="L236" title="All 2 branches missed.">				if (!newTimeOffIntervals.isEmpty()) {</span>
<span class="nc" id="L237">					Collection&lt;TOIntervalAllocation&gt; overlappedIntervals = getOverlapedIntervals(oldTimeOffIntervals, newTimeOffIntervals);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">					if (!overlappedIntervals.isEmpty()) {</span>
<span class="nc" id="L239">						deletedSize += overlappedIntervals.size();</span>
<span class="nc" id="L240">						deleteTimeOffInterval(overlappedIntervals);</span>
					}
				}
				//END STEP2
				//The remaining after STEP2 will be put in the createList
<span class="nc" id="L245">				createList.addAll(newTimeOffIntervals);</span>
			}

<span class="nc" id="L248">		} //end for of hashMap</span>
<span class="nc" id="L249">		result[0] = createList.size();</span>
<span class="nc" id="L250">		result[1] = updateList.size();</span>
<span class="nc" id="L251">		result[2] = deletedSize;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">		if (!createList.isEmpty()) {</span>
<span class="nc" id="L253">			createObjects(createList);</span>
		}
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (!updateList.isEmpty()) {</span>
<span class="nc" id="L256">			updateObjects(updateList);</span>
		}

<span class="nc" id="L259">		return result;</span>
	}

	/**
	 * Start date which has 00:00:00, The Full end date has 23:59:59
	 * It serves for searching all intervals of 1 day
	 * */
	private LocalDate getEndLocaleDate(LocalDate shortDate) throws ParseException {
<span class="nc" id="L267">		LocalDate localDate = null;</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">		if (shortDate != null) {</span>
<span class="nc" id="L269">			Calendar cal = shortDate.getCalendar(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L270">			localDate = new LocalDate(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DATE), 23, 59, 59);</span>
		}
<span class="nc" id="L272">		return localDate;</span>
	}

	public void deleteTimeOffInterval(Collection&lt;TOIntervalAllocation&gt; timeOffIntervals) throws BbmRemoveException, JdmoException {
<span class="nc" id="L276">		Collection&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">		for (Iterator&lt;TOIntervalAllocation&gt; it = timeOffIntervals.iterator(); it.hasNext();) {</span>
<span class="nc" id="L278">			TOIntervalAllocation timeoffInterval = it.next();</span>
<span class="nc" id="L279">			ids.add(timeoffInterval.getID());</span>
<span class="nc" id="L280">		}</span>
<span class="nc" id="L281">		deleteObjects(ids);</span>
<span class="nc" id="L282">	}</span>

	/**
	 * Get the intervals for the given entity (Employee or TOP) over the specified date range.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 * 
	 * @param employeeID
	 *            If specified, intervals for the employee will be returned based on the employee's TOP assignments.
	 *            All values will be returned.
	 * @param toPoolID
	 *            If specified, the TOP intervals will be returned with allocated, approved, and pending.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @return
	 * @throws JdmoException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByInterval(ID employeeID, ID toPoolID, Date startTime, Date endTime)
			throws JdmoException {

<span class="nc" id="L303">		JdmoQuery jdmoQuery = m_dmo.createQuery(&quot;RM_ApprovedPendingAllocated_DateRange&quot;, Jdmo.STORPROC_QUERY);</span>

<span class="nc bnc" id="L305" title="All 2 branches missed.">		if (employeeID == null) {</span>
<span class="nc" id="L306">			jdmoQuery.setParNull(1, Types.INTEGER);</span>
		} else {
<span class="nc" id="L308">			jdmoQuery.setParID(1, employeeID);</span>
		}

<span class="nc bnc" id="L311" title="All 2 branches missed.">		if (toPoolID == null) {</span>
<span class="nc" id="L312">			jdmoQuery.setParNull(2, Types.INTEGER);</span>
		} else {
<span class="nc" id="L314">			jdmoQuery.setParID(2, toPoolID);</span>
		}

<span class="nc" id="L317">		jdmoQuery.setParTimestamp(3, new Timestamp(startTime.getTime()));</span>
<span class="nc" id="L318">		jdmoQuery.setParTimestamp(4, new Timestamp(endTime.getTime()));</span>
		//current time for expiration checking
<span class="nc" id="L320">		jdmoQuery.setParTimestamp(5, TimeZoneUtil.toTimestamp(new Date()));</span>

<span class="nc" id="L322">		JdmoRowset res = m_dmo.createRowset(jdmoQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc" id="L324">		List&lt;TOIntervalApprovedAndPending&gt; result = new ArrayList&lt;TOIntervalApprovedAndPending&gt;();</span>

<span class="nc bnc" id="L326" title="All 2 branches missed.">		while (res.next()) {</span>

<span class="nc" id="L328">			TOIntervalApprovedAndPending item = new TOIntervalApprovedAndPending();</span>
<span class="nc" id="L329">			item.setID(res.getID(&quot;TOIntervalAllocationID&quot;));</span>
<span class="nc" id="L330">			item.setTOPoolID(res.getID(&quot;TOPOOLID&quot;));</span>
<span class="nc" id="L331">			item.setStartTime(TimeZoneUtil.toDate(res.getTimestamp(&quot;StartTime&quot;)));</span>
<span class="nc" id="L332">			item.setEndTime(TimeZoneUtil.toDate(res.getTimestamp(&quot;EndTime&quot;)));</span>
<span class="nc" id="L333">			item.setAllocatedHours(DateUtil.getHoursFromMinutes(res.getFloat(&quot;AllocatedMinutes&quot;)));</span>

<span class="nc" id="L335">			item.setApprovedMinutes(res.getInt(&quot;ApprovedMinutesAll&quot;));</span>
<span class="nc" id="L336">			item.setPendingMinutes(res.getInt(&quot;PendingMinutesAll&quot;));</span>

<span class="nc" id="L338">			item.setApprovedMinutesForEmployee(res.getInt(&quot;ApprovedMinutesEmployee&quot;));</span>
<span class="nc" id="L339">			item.setPendingMinutesForEmployee(res.getInt(&quot;PendingMinutesEmployee&quot;));</span>

<span class="nc" id="L341">			result.add(item);</span>
<span class="nc" id="L342">		}</span>

<span class="nc" id="L344">		return result;</span>
	}

	/**
	 * Get the intervals for the Organization over the specified date range with the pending and approved minutes.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 * 
	 * @param organizationID
	 *            The organization's ID.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @return
	 * @throws JdmoException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByIntervalForOrg(ID organizationID, Date startTime, Date endTime)
			throws JdmoException {

<span class="nc" id="L363">		JdmoQuery jdmoQuery = m_dmo.createQuery(&quot;RM_PendingApproved_Organization_DateRange&quot;, Jdmo.STORPROC_QUERY);</span>

<span class="nc bnc" id="L365" title="All 2 branches missed.">		if (organizationID == null) {</span>
<span class="nc" id="L366">			jdmoQuery.setParNull(1, Types.INTEGER);</span>
		} else {
<span class="nc" id="L368">			jdmoQuery.setParID(1, organizationID);</span>
		}

<span class="nc" id="L371">		jdmoQuery.setParTimestamp(2, new Timestamp(startTime.getTime()));</span>
<span class="nc" id="L372">		jdmoQuery.setParTimestamp(3, new Timestamp(endTime.getTime()));</span>
		//current time for expiration checking
<span class="nc" id="L374">		jdmoQuery.setParTimestamp(4, TimeZoneUtil.toTimestamp(new Date()));</span>

<span class="nc" id="L376">		JdmoRowset res = m_dmo.createRowset(jdmoQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc" id="L378">		List&lt;TOIntervalApprovedAndPending&gt; result = new ArrayList&lt;TOIntervalApprovedAndPending&gt;();</span>

<span class="nc bnc" id="L380" title="All 2 branches missed.">		while (res.next()) {</span>

<span class="nc" id="L382">			TOIntervalApprovedAndPending item = new TOIntervalApprovedAndPending();</span>
<span class="nc" id="L383">			item.setStartTime(TimeZoneUtil.toDate(res.getTimestamp(&quot;STARTTIME&quot;)));</span>
<span class="nc" id="L384">			item.setEndTime(TimeZoneUtil.toDate(res.getTimestamp(&quot;ENDTIME&quot;)));</span>

<span class="nc" id="L386">			item.setApprovedMinutes(res.getInt(&quot;ApprovedMinutes&quot;));</span>
<span class="nc" id="L387">			item.setPendingMinutes(res.getInt(&quot;PendingMinutes&quot;));</span>

<span class="nc" id="L389">			result.add(item);</span>
<span class="nc" id="L390">		}</span>

<span class="nc" id="L392">		return result;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>