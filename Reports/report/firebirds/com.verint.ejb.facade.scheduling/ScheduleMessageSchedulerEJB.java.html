<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleMessageSchedulerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.facade.scheduling</a> &gt; <span class="el_source">ScheduleMessageSchedulerEJB.java</span></div><h1>ScheduleMessageSchedulerEJB.java</h1><pre class="source lang-java linenums">package com.verint.ejb.facade.scheduling;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingRequest;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingState;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingWarning;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.facade.FacadeManagerFactory;
import com.bluepumpkin.ejb.facade.corbafacade.ejb.FacadeCorbaFacadeManager;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage.SchedulingAction;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParameters;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersFieldInfo;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageRequestMapping;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequest;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestDAO;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestFieldInfo;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.base.CoreFinderException;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.User;

<span class="fc" id="L52">public class ScheduleMessageSchedulerEJB extends SessionEJBBase {</span>
<span class="fc" id="L53">	private static final Object _CREATE_LOCK = new Object();</span>

	private static final int REQUEST_CONTINUE = SchedulingRequest.CONTINUE_SCHEDULE;
	public static final int DEFAULT_NO_OF_CPU = 5;

	// progress percentage for a completed job
	private static final int COMPLETED_PERCENTAGE_PROGRESS = ScheduleMessageSchedulerUtil.COMPLETED_PERCENTAGE_PROGRESS;
	private static final int DAYS_IN_WEEK = 7;
	private static final int DAYS_IN_THREE_WEEKS = 3 * DAYS_IN_WEEK;

	private static final int MAX_OLD_SCHEDULE_STATUS_MILLIS = 1000 * 60 * 5;
	private static final int DEFAULT_SCHEDULING_ERROR_RETRY_COUNT = 3;
	// if can not schedule after 2 retries, we give up.
	private static final int DEFAULT_SCHEDULING_RETRY_COUNT = 2;
	// 30 seconds
	private static final long DEFAULT_SCHEDULING_RETRY_INTERVAL = 30000;
	// 15 minutes
	private static final int DEFAULT_GIVE_UP_TIME = 900000;

<span class="fc" id="L72">	private static Category m_cat = Log.initCategory(ScheduleMessageSchedulerEJB.class.getName());</span>

<span class="fc" id="L74">	private boolean isWhatIf = false;</span>

	private FacadeCorbaFacadeManager facadeCorbaFacadeManager;

	private CampaignManager campaignManager;

	private DBConfigManager dbConfigManager;

	private UserManager userManager;

	private ScheduleMessageSchedulerUtil schedulerUtil;
	
	{
<span class="fc" id="L87">		super.init(ScheduleMessageSchedulerEJB.class.getName());</span>
<span class="fc" id="L88">	}</span>

	/**
	 * Perform one-time initialization of this EJB instance
	 */
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L96">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L97">			Boolean wif = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L98" title="1 of 2 branches missed.">			if (wif != null) {</span>
<span class="fc" id="L99">				isWhatIf = wif.booleanValue();</span>
			}
<span class="fc" id="L101">			facadeCorbaFacadeManager = FacadeManagerFactory.getFacadeCorbaFacadeManager();</span>
<span class="fc" id="L102">			campaignManager = WfmManagerFactory.getCampaignManager(isWhatIf);</span>
<span class="fc" id="L103">			dbConfigManager = BbmManagerFactory.getDBConfigManager(isWhatIf);</span>
<span class="fc" id="L104">			userManager = CoreManagerFactory.getUserManager(isWhatIf);</span>
<span class="fc" id="L105">			schedulerUtil = new ScheduleMessageSchedulerUtil();</span>

<span class="nc" id="L107">		} catch (Exception e) {</span>
<span class="nc" id="L108">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L109">		}</span>
<span class="fc" id="L110">	}</span>

	protected Category getCategory() {
<span class="fc" id="L113">		return m_cat;</span>
	}

	public ID createMessage(ScheduleRequestsMessage message) throws BbmCreateException {
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">		if (message == null) {</span>
<span class="nc" id="L118">			throw new IllegalArgumentException(&quot;The message to be persisted in empty&quot;);</span>
		}

<span class="fc" id="L121">		ID created = null;</span>
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">		if (schedulerUtil.validateSecondaryParamsAndUpdateInvalidRequests(message)) {</span>
			// insert the scheduling parameters
<span class="fc" id="L124">			created = createDBMessage(message);</span>
			// insert secondary scheduling parameters
<span class="fc" id="L126">			schedulerUtil.createSecondaryParameters(message, created);</span>
			// insert the mappings between message to requests
<span class="fc" id="L128">			schedulerUtil.createRequestMappings(message, created);</span>
		}
<span class="fc" id="L130">		return created;</span>
	}

	/**
	 * Attempts to schedule the Scheduling messages in the ScheduleMessage
	 * table. The messages will be scheduled in the order they have been last
	 * updated. This will ensure that all messages are being processed as
	 * opposed to just processing messages in the order in which they arrive.
	 */
	public void scheduleReadyRequests() {
<span class="fc" id="L140">		methodStart(&quot;scheduleReadyRequests&quot;);</span>
		// get the capacity that we can schedule now
		// get all the messages and try to consume one by one
		// get the request IDs for a message
		try {
<span class="fc" id="L145">			int availableServers = checkServersAndUpdateStatusForNonAvailability();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">			if (availableServers &lt;= 0) {</span>
<span class="fc" id="L147">				m_cat.error(&quot;Scheduling not done due to the non-availability of FS server to schedule.&quot;);</span>
<span class="fc" id="L148">				return;</span>
			}
<span class="fc" id="L150">			scheduleMessages(availableServers);</span>
<span class="nc" id="L151">		} catch (BbmFinderException e1) {</span>
<span class="nc" id="L152">			m_cat.error(&quot;Could not get Request messages&quot;, e1);</span>
<span class="nc" id="L153">		} catch (RemoteException re) {</span>
<span class="nc" id="L154">			m_cat.error(&quot;Error scheduling the requests. They will be re-tried latter&quot;, re);</span>
<span class="nc" id="L155">		} catch (MultiUserException e) {</span>
<span class="nc" id="L156">			m_cat.error(&quot;Error updating the request/message&quot;, e);</span>
<span class="nc" id="L157">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L158">			m_cat.error(&quot;Error updating the request&quot;, e);</span>
<span class="nc" id="L159">		} catch (Exception any) {</span>
<span class="nc" id="L160">			m_cat.error(&quot;Error scheduling the requests. They will be re-tried latter&quot;, any);</span>
		} finally {
<span class="pc" id="L162">			methodFinish();</span>
<span class="pc" id="L163">		}</span>
<span class="fc" id="L164">	}</span>

	/**
	 * Copies the scheduling state for the in-progress requests and clears the
	 * completed requests from state table, ScheduleMEssageRequestMapping tables
	 * and ScheduleMessage tables.
	 */
	public void updateStatusAndClearCompletedRequests() {
<span class="fc" id="L172">		methodStart(&quot;updateStatusAndClearCompletedRequests&quot;);</span>
		// clear schedule state from spShedStatus tables and update the
		// WSAutoScheduleRequest tables
		// get all the requests with status 'P'
		try {
<span class="fc" id="L177">			List&lt;WSAutoScheduleRequest&gt; requests = schedulerUtil.getRequestsByStatus(null,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS);
			
<span class="fc bfc" id="L180" title="All 2 branches covered.">			if (!requests.isEmpty()) {</span>
<span class="fc" id="L181">				List&lt;WSAutoScheduleRequest&gt; requestsToBeUpdated = updateStatus(requests);</span>
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">				if (!requestsToBeUpdated.isEmpty()) {</span>
<span class="fc" id="L183">					schedulerUtil.updateRequests(requestsToBeUpdated);</span>
				}
			}
			// clear message, mappings and parameters tables if there are
			// no more requests to process
<span class="fc" id="L188">			schedulerUtil.clearCompletedMessages();</span>

<span class="nc" id="L190">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L191">			m_cat.error(&quot;Exception while getting/clearing scheduling status from Campaign Manager &quot;, e);</span>
<span class="nc" id="L192">		} catch (RemoteException e) {</span>
<span class="nc" id="L193">			m_cat.error(&quot;Exception while clearing the schedule state&quot;, e);</span>
<span class="nc" id="L194">		} catch (JdmoException e) {</span>
<span class="nc" id="L195">			m_cat.error(&quot;Exception while updating scheduling status &quot;, e);</span>
<span class="nc" id="L196">		} catch (MultiUserException e) {</span>
<span class="nc" id="L197">			m_cat.error(&quot;Error while updating the scheduling status to the requests&quot;, e);</span>
<span class="nc" id="L198">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L199">			m_cat.error(&quot;Error while updating the scheduling status to the requests&quot;, e);</span>
<span class="nc" id="L200">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L201">			m_cat.error(&quot;Could not clear completed messages&quot;, e);</span>
		} finally {
<span class="pc" id="L203">			methodFinish();</span>
<span class="pc" id="L204">		}</span>
<span class="fc" id="L205">	}</span>

	/**
	 * Sets the older requests created when the message was not persisted to DB
	 * as these cannot be processed any longer
	 */
	public void clearOrphanRequests() {
<span class="fc" id="L212">		methodStart(&quot;clearOrphanRequests&quot;);</span>
		// what if these messages get hit before the message is created?
		// Do a timecheck ...clean only those that are more than a week old
<span class="fc" id="L215">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
<span class="fc" id="L216">		Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L217">		cal.add(Calendar.DAY_OF_MONTH, -DAYS_IN_WEEK);</span>
		try {
			// get the requests that are not connected
<span class="fc" id="L220">			String[] statuses = { WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS };
<span class="fc" id="L222">			List&lt;ID&gt; requestIDs = dao.getRequestIDsNotLinkedToMessageByStatus(statuses, cal.getTime());</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">			if (!requestIDs.isEmpty()) {</span>
<span class="nc" id="L224">				m_cat.warn(&quot;Cleared &quot; + requestIDs.size() + &quot; requests not connected to schedule message.&quot;);</span>
<span class="nc" id="L225">				dao.updateScheduleStatus(requestIDs, null, WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,</span>
						&quot;Could not process requests as the schedule message could not be located.&quot;);
			}
<span class="nc" id="L228">		} catch (Exception any) {</span>
<span class="nc" id="L229">			m_cat.error(&quot;Error purging new and in-process requests not connected to schedule message.&quot;, any);</span>
		} finally {
<span class="pc" id="L231">			dao.cleanUp();</span>
<span class="pc" id="L232">			methodFinish();</span>
<span class="pc" id="L233">		}</span>
<span class="fc" id="L234">	}</span>
	
	/**
	 * Schedules messages if there is a free server to schedule.
	 */
	private void scheduleMessages(int availableServers)
			throws BbmFinderException, MultiUserException, BbmUpdateException, RemoteException {
<span class="fc" id="L241">		Collection&lt;ScheduleMessage&gt; allMessages = schedulerUtil.getAllMessages();</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">		for (ScheduleMessage message : allMessages) {</span>
<span class="pc bpc" id="L244" title="1 of 2 branches missed.">			if (doesFreeServerExist(availableServers)) {</span>
<span class="fc" id="L245">				scheduleMessage(message, availableServers);</span>
			} else {
				// cannot schedule any more as there is no free server
				break;
			}
<span class="fc" id="L250">		}</span>
<span class="fc" id="L251">	}</span>

	/**
	 * Schedules the requests of a message (as many as possible) based on the
	 * availability of the server to schedule.
	 */
	private boolean scheduleMessage(ScheduleMessage message, int availableServers)
			throws MultiUserException, BbmUpdateException, RemoteException {

<span class="fc" id="L260">		boolean messageScheduled = false;</span>
<span class="fc" id="L261">		Collection&lt;ScheduleMessageRequestMapping&gt; mappings = schedulerUtil.getMappings(message.getID());</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">		if (mappings == null || mappings.isEmpty()) {</span>
<span class="nc" id="L263">			return false;</span>
		}
		List&lt;WSAutoScheduleRequest&gt; requests;
		try {
<span class="fc" id="L267">			requests = schedulerUtil.getRequestsByStatus(schedulerUtil.getRequestIDs(mappings),</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);
<span class="nc" id="L269">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L270">			m_cat.error(&quot;Could not get requests for message &quot; + message.getID(), e);</span>
<span class="nc" id="L271">			return false;</span>
<span class="fc" id="L272">		}</span>
<span class="fc" id="L273">		messageScheduled = scheduleRequests(requests, message, availableServers);</span>

<span class="fc bfc" id="L275" title="All 2 branches covered.">		if (messageScheduled) {</span>
			// update the message
			// this will help in all messages being treated fairly in a
			// round robin rather than do messages sequentially
<span class="fc" id="L279">			schedulerUtil.updateMessage(message);</span>
		}
<span class="fc" id="L281">		return messageScheduled;</span>
	}

	/**
	 * Schedules the requests (as many as possible) based on the availability of
	 * the server to schedule. Returns true if atleast one request is scheduled.
	 * 
	 * @throws BbmUpdateException
	 * @throws MultiUserException
	 */
	private boolean scheduleRequests(List&lt;WSAutoScheduleRequest&gt; requests, ScheduleMessage message,
			int availableServers) throws RemoteException, MultiUserException, BbmUpdateException {
<span class="fc" id="L293">		boolean requestScheduled = false;</span>
<span class="fc bfc" id="L294" title="All 2 branches covered.">		for (WSAutoScheduleRequest request : requests) {</span>
			// check for retry count
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">			if (checkForErrorsOrMaxRetriesAndUpdate(request)</span>
<span class="pc bpc" id="L297" title="3 of 4 branches missed.">					|| (!message.isOverrideSchedules() &amp;&amp; schedulerUtil.checkIfAlreadyScheduledAndUpdate(request))) {</span>
<span class="nc" id="L298">				continue;</span>
			}
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">			if (!doesFreeServerExist(availableServers)) {</span>
				// when there is no free server, we just return
				// there is no point to go through the whole list.
<span class="nc" id="L303">				return requestScheduled;</span>
			}
<span class="fc bfc" id="L305" title="All 2 branches covered.">			if (canScheduleNow(request.getSPID(), request.getMode(), message.isScheduleInOrder())</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">					&amp;&amp; scheduleRequest(request, message)) {</span>
<span class="fc" id="L307">				requestScheduled = true;</span>
			}
<span class="fc" id="L309">		}</span>
<span class="fc" id="L310">		return requestScheduled;</span>
	}

	/**
	 * Checks if the request has exceeded the max-retries/ max number of errors
	 * and it has exceeded, updated the request as error
	 * 
	 * @param request
	 * @return true if the request has exceeded max-retries for scheduling of
	 *         (in case the sp is not picked up by FS) max-retries after
	 *         integration server errors.
	 */
	private boolean checkForErrorsOrMaxRetriesAndUpdate(WSAutoScheduleRequest request) {
<span class="fc" id="L323">		boolean hasErrorOrMaxRetries = false;</span>
<span class="fc" id="L324">		String message = request.getFormattedFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE);</span>
<span class="fc" id="L325">		String newErrorMessage = null;</span>
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">		if (request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT) &gt; getSchedulingRetryCount()) {</span>
<span class="nc" id="L327">			hasErrorOrMaxRetries = true;</span>
<span class="nc" id="L328">			newErrorMessage = &quot;This could not be scheduled after &quot;</span>
<span class="nc" id="L329">					+ request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT)</span>
					+ &quot; retries. This will not be scheduled.&quot;;
<span class="fc" id="L331">		} else if (request</span>
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">				.getFieldValueInt(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT) &gt; getSchedulingErrorRetryCount()) {</span>
<span class="nc" id="L333">			hasErrorOrMaxRetries = true;</span>
<span class="nc" id="L334">			newErrorMessage = &quot;This could not be scheduled because of the integration server error!&quot;;</span>
		}

<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		if (hasErrorOrMaxRetries) {</span>
			try {
<span class="nc bnc" id="L339" title="All 2 branches missed.">				schedulerUtil.updateScheduleStatusForRequest(request.getID(), WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,
						(message != null) ? message + &quot; &quot; + newErrorMessage : newErrorMessage);
<span class="nc" id="L342">			} catch (Exception e) {</span>
<span class="nc" id="L343">				m_cat.error(&quot;Error updating the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L344">						+ &quot; for the scheduling period &quot; + request.getSPID(), e);</span>
<span class="nc" id="L345">			}</span>
		}
<span class="fc" id="L347">		return hasErrorOrMaxRetries;</span>
	}

	/**
	 * Returns true if the scheduling is successfully initiated for the request
	 * 
	 * @throws BbmUpdateException
	 * @throws MultiUserException
	 */
	private boolean scheduleRequest(WSAutoScheduleRequest request, ScheduleMessage message)
			throws RemoteException, MultiUserException, BbmUpdateException {
<span class="fc" id="L358">		boolean requestScheduled = false;</span>
<span class="fc" id="L359">		int spID = request.getSPID();</span>
		// if able to trigger the auto scheduling for this,
		// update the status to 'P'

		// QC-124839 get the user from the request
<span class="fc" id="L364">		String user = request.getFormattedFieldValue(WSAutoScheduleRequestFieldInfo.MODIFIEDBY);</span>
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">		if (user == null) {</span>
			// user the super user
<span class="nc" id="L367">			user = getSuperUser();</span>
		}
<span class="fc" id="L369">		setSecondarySchedulingParameters(message.getID(), ID.fromInt(spID));</span>

<span class="fc" id="L371">		int status = facadeCorbaFacadeManager.recalcScheduling(user, getUserPassword(user, message.getUserSeal()),</span>
<span class="fc" id="L372">				message.isWhatIfMode(), message.getSchedulingAction().getActionID(), ID.fromInt(request.getSPID()),</span>
<span class="fc" id="L373">				message.isEnableLQF(), message.isRecalcSubCampaigns(), schedulerUtil.extractParamters(message));</span>
		// if status is an invalid code (like absence of
		// adapter, we need to re-attempt to schedule
<span class="pc bpc" id="L376" title="1 of 2 branches missed.">		if (status == 1) {</span>
			// typical success scenario
<span class="fc" id="L378">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS);
<span class="fc" id="L380">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT, 0);</span>
			// Debug log message to indicate that the given
			// sp
			// were processed
<span class="fc" id="L384">			m_cat.debug(&quot;Scheduling Triggered for the Scheduling Request of ID &quot; + request.getID()</span>
<span class="fc" id="L385">					+ &quot; for the scheduling period &quot; + request.getSPID());</span>
<span class="fc" id="L386">			requestScheduled = true;</span>
		} else {
			// remove the set scheduling parameters?
			// need to add to the unscheduled
<span class="nc" id="L390">			m_cat.warn(&quot;An attempt to schedule the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L391">					+ &quot; for the scheduling period &quot; + request.getSPID()</span>
					+ &quot; failed. This will be reattempted at a later time. The error code from the Corba Facade Manager is &quot;
					+ status + &quot;.&quot;);
<span class="nc" id="L394">			int oldCount = request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT);</span>
<span class="nc" id="L395">			oldCount++;</span>
<span class="nc bnc" id="L396" title="All 2 branches missed.">			if (oldCount &gt;= getSchedulingErrorRetryCount()) {</span>
<span class="nc" id="L397">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
			}

<span class="nc bnc" id="L401" title="All 2 branches missed.">			if (status == 3) {</span>
<span class="nc" id="L402">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;There was an error connecting to the Integration Server.  Please verify that the integration server is running.&quot;);
			}
<span class="nc bnc" id="L405" title="All 2 branches missed.">			if (status == 4) {</span>
<span class="nc" id="L406">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;There was an error with the configuration of the Integration Server.&quot;);
			}
<span class="nc" id="L409">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT, oldCount);</span>
		}
<span class="fc" id="L411">		schedulerUtil.updateRequest(request);</span>
<span class="fc" id="L412">		return requestScheduled;</span>
	}

	/**
	 * Updates the status of the requests that need updation and returns the
	 * requests to be updated.
	 * 
	 * @throws RemoteException
	 * @throws BbmFinderException
	 * @throws JdmoException
	 */
	private List&lt;WSAutoScheduleRequest&gt; updateStatus(List&lt;WSAutoScheduleRequest&gt; requests)
			throws BbmFinderException, RemoteException, JdmoException {
<span class="fc" id="L425">		List&lt;WSAutoScheduleRequest&gt; requestsToBeUpdated = new ArrayList&lt;WSAutoScheduleRequest&gt;();</span>
		// get the scheduling action for requests
		// this is needed for continue requests
<span class="fc" id="L428">		Map&lt;ID, SchedulingAction&gt; schedulingActionByRequestID = schedulerUtil.getSchedulingActionForRequests(requests);</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">		for (int i = 0; i &lt; requests.size(); i++) {</span>
<span class="fc" id="L431">			WSAutoScheduleRequest request = requests.get(i);</span>

<span class="fc" id="L433">			int spIDInt = request.getSPID();</span>
<span class="fc" id="L434">			ID spID = ID.fromInt(spIDInt);</span>
<span class="fc" id="L435">			SchedulingAction schedulingAction = schedulingActionByRequestID.get(request.getID());</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">			if (schedulingAction == null) {</span>
				// we can not further process this
				// this is done to handle any left over records from earlier
				// implementation
				// they are to be marked as error
<span class="nc" id="L441">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
<span class="nc" id="L443">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;This request could not be processed as there is no scheduling information&quot;);
<span class="nc" id="L445">				requestsToBeUpdated.add(request);</span>
<span class="nc" id="L446">				continue;</span>
			}
<span class="fc" id="L448">			SchedulingState state = campaignManager.getSchedulingState(spID, schedulingAction.getActionCode());</span>

<span class="pc bpc" id="L450" title="1 of 2 branches missed.">			if (state != null) {</span>
<span class="fc" id="L451">				updateStatus(request, state, spID, schedulingAction);</span>
<span class="fc" id="L452">				requestsToBeUpdated.add(request);</span>
			} else {
<span class="nc bnc" id="L454" title="All 2 branches missed.">				if (updateRequestNotPickedUpByFS(request, spID, schedulingAction)) {</span>
<span class="nc" id="L455">					requestsToBeUpdated.add(request);</span>
				}
			}
		}
<span class="fc" id="L459">		return requestsToBeUpdated;</span>
	}

	/**
	 * Updates the request with the state from the SchedulingState. &lt;b&gt;Note:&lt;/b&gt;
	 * All parameters are required to be non-null. No null checks are performed.
	 */
	private void updateStatus(WSAutoScheduleRequest request, SchedulingState state, ID spID,
			SchedulingAction schedulingAction) {
<span class="fc" id="L468">		boolean isStale = isScheduleStatusOld(state);</span>
<span class="fc" id="L469">		int progress = state.getOverallStatus();</span>
		// copy and update the ws request table and delete the state
		// messages from spschedstatus tables
<span class="fc" id="L472">		boolean hasError = schedulerUtil.copySchedulingStateToRequestAndGetErrorStatus(request, state);</span>
<span class="fc" id="L473">		clearWarningMessages(state);</span>

<span class="pc bpc" id="L475" title="1 of 2 branches missed.">		if (state.hasWarning()</span>
<span class="nc bnc" id="L476" title="All 4 branches missed.">				&amp;&amp; (WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS.equals(request.getSchedulingStatus()))</span>
				&amp;&amp; !isStale) {
			// make a continue request
<span class="nc" id="L479">			makeContinueRequest(spID, schedulingAction);</span>
		}

<span class="pc bpc" id="L482" title="3 of 4 branches missed.">		if (isStale &amp;&amp; progress &lt; COMPLETED_PERCENTAGE_PROGRESS) {</span>
			// update WSAutoScheduleRequest status and error message
<span class="nc" id="L484">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
<span class="nc" id="L486">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
<span class="nc" id="L487">					request.getStatusMessage() + &quot;|&quot; + &quot;Stopped By System due to Non-Progess&quot;);</span>
		}

<span class="pc bpc" id="L490" title="5 of 6 branches missed.">		if (progress == COMPLETED_PERCENTAGE_PROGRESS || hasError || isStale) {</span>
			// if there is a warning, we already put a continue
			// request
			// clear the state
<span class="fc" id="L494">			clearSchedulingSession(spID, schedulingAction);</span>
		}
<span class="fc" id="L496">	}</span>

	/**
	 * Updates the request if necessary. Updates when 1. Last updated time of
	 * the request is null (first attempt to clear) 2. The request has exceeded
	 * the max wait time to be pisked up by FS.
	 */
	private boolean updateRequestNotPickedUpByFS(WSAutoScheduleRequest request, ID spID,
			SchedulingAction schedulingAction) {
		// if it did not get picked up in 15 minutes
<span class="nc" id="L506">		Date lastUpdated = request.getFieldValueDate(WSAutoScheduleRequestFieldInfo.LASTUPDATED);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">		if (lastUpdated == null) {</span>
<span class="nc" id="L508">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.LASTUPDATED, Calendar.getInstance().getTime());</span>
<span class="nc" id="L509">			return true;</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">		} else if (isOld(lastUpdated, getGiveUpForClearing())) {</span>
			// probably never picked up by FS for some reason. we
			// will re try
<span class="nc" id="L513">			clearSchedulingSession(spID, schedulingAction);</span>
			// we should attempt to retrigger
			// set to new status and send a message again
<span class="nc" id="L516">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);
<span class="nc" id="L518">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
					&quot;Re trying the  scheduling due to a prior failure&quot;);
<span class="nc" id="L520">			int retryCount = request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT);</span>
<span class="nc" id="L521">			retryCount++;</span>
<span class="nc" id="L522">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.RETRYCOUNT, retryCount);</span>
<span class="nc" id="L523">			return true;</span>
		}
<span class="nc" id="L525">		return false;</span>
	}

	/**
	 * makes a continue request for the sp.
	 */
	private void makeContinueRequest(ID spID, SchedulingAction schedulingAction) {
		// make a continue request
		try {
<span class="nc" id="L534">			SchedulingRequest schedRequest = new SchedulingRequest();</span>
<span class="nc" id="L535">			schedRequest.setSPSID(spID);</span>
<span class="nc" id="L536">			schedRequest.setRequest(REQUEST_CONTINUE);</span>
<span class="nc" id="L537">			schedRequest.setMode(schedulingAction.getActionCode());</span>
<span class="nc" id="L538">			campaignManager.makeSchedulingRequest(schedRequest);</span>
<span class="nc" id="L539">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L540">			m_cat.error(&quot;Exception while continuing the scheduling for Scheduling Period &quot; + spID, e);</span>
<span class="nc" id="L541">		} catch (RemoteException e) {</span>
<span class="nc" id="L542">			m_cat.error(&quot;Remote exception while continuing the scheduling for Scheduling Period &quot; + spID, e);</span>
<span class="nc" id="L543">		}</span>
<span class="nc" id="L544">	}</span>

	/**
	 * Clears the warning messages of the state
	 */
	private void clearWarningMessages(SchedulingState state) {
<span class="fc" id="L550">		Collection&lt;SchedulingWarning&gt; warnings = state.getWarnings();</span>
<span class="fc" id="L551">		List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="pc bpc" id="L552" title="1 of 2 branches missed.">		for (SchedulingWarning warning : warnings) {</span>
<span class="nc" id="L553">			ids.add(warning.getID());</span>
<span class="nc" id="L554">		}</span>

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">		if (!warnings.isEmpty()) {</span>
			try {
<span class="nc" id="L558">				campaignManager.clearSchedulingStateWarnings(ids);</span>
<span class="nc" id="L559">			} catch (Exception e) {</span>
				// no big deal! the get Scheduling state in the DAO itself
				// clears them sometimes
<span class="nc" id="L562">				m_cat.warn(&quot;Could not find the warnings to clear!&quot;, e);</span>
<span class="nc" id="L563">			}</span>
		}
<span class="fc" id="L565">	}</span>

	/**
	 * Checks to see if there are any currently pending scheduling requests for
	 * the given SP and adjacent SPs. This method will get all SPs that lie in a
	 * range of 3 weeks prior to the given SP's start date and 3 weeks after the
	 * end of the given SP's end date. Using these SPs, this method will: 1)
	 * Check the SchedulingState (SPSCHEDSTATE table) to see if there is a
	 * non-stale record for any of the SPs. If there is, the method will return
	 * false. Schedules of adjacent SPs will have an impact on scheduling of
	 * current SP 2) Check the status of the schedule request coming from the
	 * web service (WSAUTOSCHEDULEREQUEST table) to see if there is a request in
	 * progress (status code of &quot;P&quot;, indicating that the SP is already being
	 * scheduled). If so, this method will return false.
	 */
	private boolean canScheduleNow(int spID, String mode, boolean scheduleInOrder) {
<span class="pc bpc" id="L581" title="1 of 4 branches missed.">		if (scheduleInOrder &amp;&amp; schedulerUtil.isEarlierSchedulingPeriodRequestIncomplete(spID)) {</span>
<span class="fc" id="L582">			return false;</span>
		}
		try {
<span class="pc bpc" id="L585" title="1 of 2 branches missed.">			return !areAdjacentSPsBeingScheduled(ID.fromInt(spID), mode);</span>
<span class="nc" id="L586">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L587">			m_cat.error(&quot;Exception while getting the scheduling period/scheduling state &quot;, e);</span>
<span class="nc" id="L588">			return false;</span>
<span class="nc" id="L589">		} catch (RemoteException e) {</span>
<span class="nc" id="L590">			m_cat.error(&quot;Exception while getting the scheduling periods &quot;, e);</span>
<span class="nc" id="L591">			return false;</span>
		}
	}

	/**
	 * Checks if any SPs within 3 week window of current sp are being scheduled.
	 * Returns true even if one of them is being scheduled
	 */
	private boolean areAdjacentSPsBeingScheduled(ID spID, String mode) throws BbmFinderException, RemoteException {
<span class="fc" id="L600">		Collection&lt;SchedulingPeriod&gt; sps = getAdjacentSPs(campaignManager.getSchedulingPeriodByID(spID));</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		for (SchedulingPeriod sp : sps) {</span>
<span class="fc" id="L602">			ID currentSPID = sp.getID();</span>
<span class="pc bpc" id="L603" title="2 of 4 branches missed.">			if (isSPBeingScheduled(currentSPID, mode) || schedulerUtil.doOpenRequestsExist(currentSPID)) {</span>
<span class="nc" id="L604">				return true;</span>
			}
<span class="fc" id="L606">		}</span>
<span class="fc" id="L607">		return false;</span>
	}

	/**
	 * checks if the given SP is being scheduled by Fns
	 */
	private boolean isSPBeingScheduled(ID spID, String mode) {
		try {
<span class="fc" id="L615">			Date lastUpdatedDate = campaignManager.getSchedulingStateLastUpdatedTime(spID, mode);</span>
<span class="pc bpc" id="L616" title="3 of 4 branches missed.">			if (lastUpdatedDate != null &amp;&amp; !isOld(lastUpdatedDate)) {</span>
<span class="nc" id="L617">				return true;</span>
			}
<span class="nc" id="L619">		} catch (Exception any) {</span>
<span class="nc" id="L620">			m_cat.warn(&quot;Error gettting the last updated time for SP&quot; + spID + &quot;. The error is &quot; + any.getMessage(),</span>
					any);
<span class="fc" id="L622">		}</span>
<span class="fc" id="L623">		return false;</span>
	}

	/**
	 * Returns all the SPs within 3 week window of this SP for the same
	 * campaign.
	 * 
	 * @param sp
	 * @throws RemoteException
	 * @throws BbmFinderException
	 */
	private Collection&lt;SchedulingPeriod&gt; getAdjacentSPs(SchedulingPeriod sp)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L636">		Date startDate = sp.getStartTime();</span>
<span class="fc" id="L637">		Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L638">		cal.clear();</span>
<span class="fc" id="L639">		cal.setTime(startDate);</span>
		// 3 weeks
<span class="fc" id="L641">		cal.add(Calendar.DATE, -DAYS_IN_THREE_WEEKS);</span>
<span class="fc" id="L642">		startDate = cal.getTime();</span>
<span class="fc" id="L643">		Date endDate = sp.getEndTime();</span>
<span class="fc" id="L644">		cal.clear();</span>
<span class="fc" id="L645">		cal.setTime(endDate);</span>
<span class="fc" id="L646">		cal.add(Calendar.DATE, DAYS_IN_THREE_WEEKS);</span>
<span class="fc" id="L647">		endDate = cal.getTime();</span>

<span class="fc" id="L649">		return campaignManager.getSchedulingPeriods(sp.getCampaignID(), startDate, endDate);</span>
	}

	/**
	 * Clears the scheduling session data used by FS thick client.
	 */
	private void clearSchedulingSession(ID spID, SchedulingAction action) {
		// clear any requests
		try {
<span class="fc" id="L658">			SchedulingRequest request = new SchedulingRequest();</span>
<span class="fc" id="L659">			request.setSPSID(spID);</span>
<span class="fc" id="L660">			request.setMode(action.getActionCode());</span>
<span class="fc" id="L661">			campaignManager.clearSchedulingRequest(request);</span>

<span class="nc" id="L663">		} catch (BbmRemoveException e) {</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L665">			m_cat.warn(&quot;Could not clear the scheduling request for sp &quot; + spID, e);</span>
<span class="nc" id="L666">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L669">			m_cat.warn(&quot;Could not clear the scheduling request for sp &quot; + spID, e);</span>
<span class="pc" id="L670">		}</span>
		try {
<span class="fc" id="L672">			campaignManager.clearSPScheduleSession(spID);</span>
<span class="nc" id="L673">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L674">			m_cat.debug(&quot;Could not find SP &quot; + spID + &quot;to clear.&quot;, e);</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L676">		} catch (BbmRemoveException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L679">			m_cat.warn(&quot;Could not clear the scheduling session for sp &quot; + spID, e);</span>
<span class="nc" id="L680">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L683">			m_cat.warn(&quot;Could not clear the scheduling session for sp &quot; + spID, e);</span>
<span class="pc" id="L684">		}</span>
		try {
<span class="fc" id="L686">			campaignManager.clearSchedulingState(spID, action.getActionCode());</span>
<span class="nc" id="L687">		} catch (BbmRemoveException bre) {</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L689">			m_cat.debug(&quot;Could not clear scheduling state for sp &quot; + spID, bre);</span>
<span class="nc" id="L690">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L693">			m_cat.warn(&quot;Could not clear the scheduling state&quot; + spID, e);</span>
<span class="pc" id="L694">		}</span>
<span class="fc" id="L695">	}</span>

	/**
	 * Checks if there is a free server available for scheduling. This method
	 * deducts any in-process SPs from available servers and returns true if
	 * this calculated number is &gt;0
	 */
	private boolean doesFreeServerExist(int availableServers) {
		// get the number of scheduling states (from schedstate table
<span class="fc" id="L704">		List&lt;Integer&gt; inProcessSPs = new ArrayList&lt;Integer&gt;();</span>
		try {
<span class="fc" id="L706">			Map&lt;ID, Date&gt; spIdVsDate = campaignManager.getAllSchedulingStateLastUpdatedTimes();</span>
<span class="fc bfc" id="L707" title="All 2 branches covered.">			for (ID spID : spIdVsDate.keySet()) {</span>
<span class="pc bpc" id="L708" title="1 of 2 branches missed.">				if (!isOld(spIdVsDate.get(spID))) {</span>
<span class="nc" id="L709">					inProcessSPs.add(spID.toInt());</span>
				}
<span class="fc" id="L711">			}</span>
<span class="nc" id="L712">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L713">			m_cat.error(&quot;Could not get the last updated time of scheduling states&quot;, e);</span>
<span class="nc" id="L714">		} catch (Exception e) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L716">			m_cat.warn(&quot;Error getting the last updated time of scheduling states&quot;, e);</span>
<span class="pc" id="L717">		}</span>
		// match their sp ids with wsautoscheduleRequest
		// add any missing sp ids
<span class="fc" id="L720">		WSAutoScheduleRequestDAO requestDAO = new WSAutoScheduleRequestDAO();</span>
<span class="fc" id="L721">		List&lt;WSAutoScheduleRequest&gt; requests = new ArrayList&lt;WSAutoScheduleRequest&gt;();</span>
		try {
<span class="fc" id="L723">			requests.addAll(requestDAO.getRequestsByStatus(WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS));</span>
<span class="fc bfc" id="L724" title="All 2 branches covered.">			for (WSAutoScheduleRequest request : requests) {</span>
<span class="fc" id="L725">				inProcessSPs.remove(new Integer(request.getSPID()));</span>
<span class="fc" id="L726">			}</span>

<span class="nc" id="L728">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L729">			m_cat.error(&quot;Could not get the scheduling requests&quot;, e);</span>
<span class="nc" id="L730">		} catch (Exception any) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L732">			m_cat.warn(&quot;Could not get the scheduling requests&quot;, any);</span>
		} finally {
<span class="pc" id="L734">			requestDAO.cleanUp();</span>
<span class="pc" id="L735">		}</span>

		// deduct from the number of available servers and see if that is &gt;0 and
		// return true, otherwise false
<span class="pc bpc" id="L739" title="1 of 2 branches missed.">		return availableServers - (inProcessSPs.size() + requests.size()) &gt; 0;</span>
	}

	private int checkServersAndUpdateStatusForNonAvailability() {
<span class="fc" id="L743">		int availableServers = getNumberOfAvailableServers();</span>
<span class="fc bfc" id="L744" title="All 2 branches covered.">		if (availableServers &lt;= 0) {</span>
			// issue with integration server or no silent Fns configured!
			// increment all new requests with one error count
			try {
<span class="fc" id="L748">				schedulerUtil.incrementErrorRetryCount(WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);</span>
<span class="nc" id="L749">			} catch (Exception any) {</span>
<span class="nc" id="L750">				m_cat.error(&quot;Could not increment error sttaus as the silent Fns server is unavailable&quot;, any);</span>
<span class="fc" id="L751">			}</span>
		}
<span class="fc" id="L753">		return availableServers;</span>
	}

	/**
	 * Returns the number of available servers for scheduling. This includes the
	 * servers that are already in use
	 */
	private int getNumberOfAvailableServers() {
		// number of server nodes
<span class="fc" id="L762">		int noOfServers = 1;</span>
		try {
<span class="fc" id="L764">			noOfServers = facadeCorbaFacadeManager.getCountOfServers(FacadeCorbaFacadeManager.SILENT_FNS_ADAPTER);</span>
<span class="nc" id="L765">		} catch (RemoteException e) {</span>
<span class="nc" id="L766">			m_cat.warn(&quot;Could not get the number of servers&quot;, e);</span>
<span class="nc" id="L767">			return -1;</span>
<span class="nc" id="L768">		} catch (Exception any) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L770">			m_cat.warn(&quot;Could not get the number of servers&quot;, any);</span>
<span class="nc" id="L771">			return -1;</span>
<span class="fc" id="L772">		}</span>

<span class="fc" id="L774">		return getCPUsPerFSServer() * noOfServers;</span>
	}

	/**
	 * Returns the number of CPUs that are present per FS server. If the config
	 * parameter is not present, returns {@link#DEFAULT_NO_OF_CPU}
	 */
	private int getCPUsPerFSServer() {
		try {
<span class="fc" id="L783">			int noOfCPUs = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_CPU);</span>
<span class="pc bpc" id="L784" title="1 of 2 branches missed.">			if (noOfCPUs &gt; 0) {</span>
<span class="nc" id="L785">				return noOfCPUs;</span>
			}
<span class="nc" id="L787">		} catch (Exception e) {</span>
<span class="nc" id="L788">			m_cat.warn(&quot;Could not get the number of CPUs per FS server&quot;, e);</span>
<span class="fc" id="L789">		}</span>
<span class="fc" id="L790">		return DEFAULT_NO_OF_CPU;</span>
	}

	/**
	 * Returns the superuser
	 */
	private String getSuperUser() {
		try {
<span class="nc" id="L798">			User superuser = userManager.getUserByID(User.SUPER_USERID);</span>
<span class="nc" id="L799">			return superuser.getUserName();</span>
<span class="nc" id="L800">		} catch (CoreFinderException e) {</span>
<span class="nc" id="L801">			m_cat.warn(&quot;Could not find the super user&quot;, e);</span>
<span class="nc" id="L802">		} catch (RemoteException e) {</span>
<span class="nc" id="L803">			m_cat.error(&quot;Error getting the super user&quot;, e);</span>
<span class="nc" id="L804">		}</span>

<span class="nc" id="L806">		return null;</span>
	}

	/**
	 * Returns the password token for the user. If the seal is not null, uses
	 * the seal for generating the password token
	 */
	private String getUserPassword(String username, String seal) {
		try {
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">			if (!StringUtil.isEmpty(seal)) {</span>
<span class="nc" id="L816">				return userManager.generateToken(username, seal);</span>
			}
			// hurry: this token is only valid for 1 minute!
<span class="fc" id="L819">			return userManager.generateSSOTokenWIthNoSeal(username);</span>
<span class="nc" id="L820">		} catch (RemoteException e) {</span>
<span class="nc" id="L821">			m_cat.error(&quot;Error getting the super user credentials&quot;, e);</span>
		}
<span class="nc" id="L823">		return null;</span>
	}

	/**
	 * Returns the time in milli seconds after which again scheduling attempt
	 * should be made
	 */
	private long getSchedulingRetryInterval() {
		try {
<span class="fc" id="L832">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_RETRY_INTERVAL);</span>
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L834">				return retryInterval;</span>
			}
<span class="nc" id="L836">		} catch (Exception e) {</span>
<span class="nc" id="L837">			m_cat.debug(&quot;Could not get scheduling retry interval. The default interval &quot;</span>
					+ DEFAULT_SCHEDULING_RETRY_COUNT + &quot; will be used.&quot;, e);
<span class="fc" id="L839">		}</span>
<span class="fc" id="L840">		return DEFAULT_SCHEDULING_RETRY_INTERVAL;</span>
	}

	/**
	 * Returns the number of times scheduling should be retried before giving up
	 * when there is an error
	 */
	private long getSchedulingErrorRetryCount() {
		try {
<span class="fc" id="L849">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_ERROR_RETRY_COUNT);</span>
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L851">				return retryInterval;</span>
			}
<span class="nc" id="L853">		} catch (Exception e) {</span>
<span class="nc" id="L854">			m_cat.warn(&quot;Could not get the scheduling error retry count&quot;, e);</span>
<span class="fc" id="L855">		}</span>
<span class="fc" id="L856">		return DEFAULT_SCHEDULING_ERROR_RETRY_COUNT;</span>
	}

	/**
	 * Returns the number of times scheduling should be retried before giving up
	 */
	private long getSchedulingRetryCount() {
		try {
<span class="fc" id="L864">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_RETRY_COUNT);</span>
<span class="pc bpc" id="L865" title="1 of 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L866">				return retryInterval;</span>
			}
<span class="nc" id="L868">		} catch (Exception e) {</span>
<span class="nc" id="L869">			m_cat.warn(&quot;Could not get the scheduling retry count&quot;, e);</span>
<span class="fc" id="L870">		}</span>
<span class="fc" id="L871">		return DEFAULT_SCHEDULING_RETRY_COUNT;</span>
	}

	/**
	 * Creates the {@link ScheduleMessage} using the parameters in
	 * {@link ScheduleRequestsMessage}
	 **/
	private ID createDBMessage(ScheduleRequestsMessage message) throws BbmCreateException {
<span class="fc" id="L879">		ScheduleMessageDAO messageDAO = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L881">			synchronized (_CREATE_LOCK) {</span>
<span class="fc" id="L882">				return messageDAO.createObject(schedulerUtil.getDBMessageFromJMSMessage(message));</span>
<span class="nc" id="L883">			}</span>
		} finally {
<span class="pc" id="L885">			messageDAO.cleanUp();</span>
		}
	}

	/**
	 * sets the scheduling parameters for the SP to be used by FS thick client
	 * during scheduling.
	 */
	private void setSecondarySchedulingParameters(ID messageID, ID spID) {
<span class="fc" id="L894">		Map&lt;String, Object&gt; secondaryParams = null;</span>
<span class="fc" id="L895">		ScheduleMessageParametersDAO dao = new ScheduleMessageParametersDAO();</span>
		try {
<span class="fc" id="L897">			Collection&lt;ScheduleMessageParameters&gt; allParameters = dao.getObjectsByParentID(messageID);</span>
<span class="pc bpc" id="L898" title="2 of 4 branches missed.">			if (allParameters != null &amp;&amp; !allParameters.isEmpty()) {</span>
<span class="fc" id="L899">				ScheduleMessageParameters parameters = allParameters.iterator().next();</span>
<span class="fc" id="L900">				secondaryParams = new HashMap&lt;String, Object&gt;();</span>
				//omit id and message id...they are not part of the parameters
<span class="fc" id="L902">				for (int i = ScheduleMessageParametersFieldInfo.DAYS_TO_SCHEDULE; i &lt; dao.getDaoFieldInfo()</span>
<span class="fc bfc" id="L903" title="All 2 branches covered.">						.getFieldCount(); i++) {</span>
<span class="fc bfc" id="L904" title="All 2 branches covered.">					if (parameters.getFieldValue(i) != null) {</span>
<span class="fc" id="L905">						secondaryParams.put(dao.getDaoFieldInfo().getFieldName(i), parameters.getFieldValue(i));</span>
					}
				}
			}
<span class="nc" id="L909">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L910">			m_cat.error(&quot;Could not get the scheduling parameters&quot;, e);</span>
		} finally {
<span class="pc" id="L912">			dao.cleanUp();</span>
<span class="pc" id="L913">		}</span>
<span class="pc bpc" id="L914" title="2 of 4 branches missed.">		if (secondaryParams != null &amp;&amp; secondaryParams.size() &gt; 0) {</span>
			try {
<span class="fc" id="L916">				campaignManager.setSchedulingParameters(spID, secondaryParams, &quot;&quot;);</span>
<span class="nc" id="L917">			} catch (BbmCreateException e) {</span>
<span class="nc" id="L918">				m_cat.error(&quot;Could not set the scheduling parameters&quot;, e);</span>
<span class="nc" id="L919">			} catch (RemoteException e) {</span>
<span class="nc" id="L920">				m_cat.error(&quot;Could not set the scheduling parameters&quot;, e);</span>
<span class="pc" id="L921">			}</span>
		}
<span class="fc" id="L923">	}</span>

	/**
	 * Compares the time with the current system time. If that time difference
	 * is greater than MAX_OLD_SCHEDULE_STATUS_MILLIS milliseconds
	 */
	private boolean isOld(Date date) {
<span class="fc" id="L930">		return isOld(date, MAX_OLD_SCHEDULE_STATUS_MILLIS);</span>
	}

	/**
	 * Compares the time of the SchedulingState with the current system time. If
	 * that time difference is greater than MAX_OLD_SCHEDULE_STATUS_MILLIS
	 * milliseconds, this method will return true. If the
	 * state.getTimeLastUpdated is null, this will return a false.
	 */
	private boolean isScheduleStatusOld(SchedulingState state) {
<span class="fc" id="L940">		return isScheduleStatusOld(state, MAX_OLD_SCHEDULE_STATUS_MILLIS);</span>
	}

	/**
	 * Compares the time of the SchedulingState with the current system time. If
	 * that time difference of current state - last updated is greater than time
	 * in milliseconds, this method will return true.If
	 * thestate.getTimeLastUpdated is null, this will return a false.
	 */
	private boolean isScheduleStatusOld(SchedulingState state, int time) {
<span class="pc bpc" id="L950" title="1 of 2 branches missed.">		if (state == null) {</span>
<span class="nc" id="L951">			throw new IllegalArgumentException(&quot;The state cannot be null&quot;);</span>
		}
<span class="pc bpc" id="L953" title="1 of 2 branches missed.">		if (state.getTimeLastUpdated() == null) {</span>
<span class="nc" id="L954">			return false;</span>
		}
<span class="fc" id="L956">		return isOld(state.getTimeLastUpdated(), time);</span>
	}

	/**
	 * Compares the time with the current system time. If that time difference
	 * is greater than 'time' milliseconds
	 */
	private boolean isOld(Date date, long time) {
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">		if (date == null) {</span>
<span class="nc" id="L965">			throw new IllegalArgumentException(&quot;The date cannot be null&quot;);</span>
		}

		// Determine the current time and compare that to the status's time
		// to see if there is a significant time difference.
<span class="fc bfc" id="L970" title="All 2 branches covered.">		return Math.abs((new Date()).getTime() - date.getTime()) &gt; Math.max(time, getSchedulingRetryInterval());</span>
	}

	/**
	 * Returns the time that needs to elapse for FS to pick up scheduling
	 * request before this request is deemed as not takenup.
	 * 
	 * @return
	 */
	private long getGiveUpForClearing() {
<span class="nc" id="L980">		return Math.max(DEFAULT_GIVE_UP_TIME, getSchedulingRetryInterval() * 20);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>