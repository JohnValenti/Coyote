<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleViewPM.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.fs.schedule</a> &gt; <span class="el_source">ScheduleViewPM.java</span></div><h1>ScheduleViewPM.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.fs.schedule;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.TimeZone;

import javax.servlet.http.HttpServletRequest;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.web.bbm.activity.ActivityModelHandler;
import com.bluepumpkin.web.bbm.employee.EmployeeModelHandler;
import com.bluepumpkin.web.bbm.l10n.BbmWebBundleKey;
import com.bluepumpkin.web.bbm.organization.OrganizationModelHandler;
import com.bluepumpkin.web.bbm.workresource.WorkResourceModelHandler;
import com.bluepumpkin.web.fs.keys.FsImageFileID;
import com.bluepumpkin.web.fs.keys.FsJavaScriptFileID;
import com.bluepumpkin.web.fs.keys.FsKeys;
import com.bluepumpkin.web.fs.keys.FsPageAction;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.bluepumpkin.web.fs.schedule.summary.DailyScheduleSummary;
import com.bluepumpkin.web.fs.schedule.summary.ScheduleSummaryMH;
import com.bluepumpkin.web.fs.shift.ShiftUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.web.uif.base.Message;
import com.witness.web.uif.keys.ImageFileID;
import com.witness.web.uif.keys.JavaScriptFileID;
import com.witness.web.uif.keys.PageAction;
import com.witness.web.uif.keys.UserPreferenceKeys;
import com.witness.web.uif.l10n.UIFWebBundleKey;
import com.witness.web.uif.pagecomponent.DefaultMultiColumnNodeData;
import com.witness.web.uif.pagecomponent.contenttitle.ContentTitlePC;
import com.witness.web.uif.pagecomponent.dialog.DialogLegendPC;
import com.witness.web.uif.pagecomponent.dialog.DialogToolbarMenuPC;
import com.witness.web.uif.pagecomponent.list.DualListPC;
import com.witness.web.uif.pagecomponent.list.MultiColListPC;
import com.witness.web.uif.pagecomponent.picker.date.DatePickerPC;
import com.witness.web.uif.pagecomponent.picker.date.DateRangePickerPC;
import com.witness.web.uif.pagecomponent.selection.SelectableItems;
import com.witness.web.uif.pagecomponent.table.TableHeaderPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarTextButton;
import com.witness.web.uif.pagemodel.PageModel;
import com.witness.web.uif.pagemodel.WorkpaneListPM;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.HtmlUtil;
import com.witness.web.uif.util.html.CSSUtil;
import com.witness.web.uif.util.html.HtmlLinkUtil;
import com.witness.web.uif.util.js.JSUtil;

/**
 * Title:        ScheduleViewPM
 * Description:  Base class for Schedule viewing pages.
 *               Parent class for GroupSchedulePM and PersonalSchedulePM
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Pavel Bosin
 * Created on October 3, 2002, 5:40 PM
 * @version      1.0
 */
@SuppressWarnings(&quot;serial&quot;)
public abstract class ScheduleViewPM  extends WorkpaneListPM {
<span class="fc" id="L102">	protected static String POSTING_IMG = null;</span>
	protected static final String VIEW_TYPE_FN = &quot;viewType&quot;;
	protected static final String DATE_RANGE_FN = &quot;dateRange&quot;;
	protected static final String VIEW_DATE_FN = &quot;viewDate&quot;;

	public static final String VIEW_TYPE_MY_TEXT = &quot;VIEW_TYPE_MY_TEXT&quot;;
	public static final String VIEW_TYPE_MY_GRAPH = &quot;VIEW_TYPE_MY_GRAPH&quot;;
	public static final String VIEW_TYPE_MY_PRINT = &quot;VIEW_TYPE_MY_PRINT&quot;;
	public static final String VIEW_TYPE_GROUP_TEXT = &quot;VIEW_TYPE_GROUP_TEXT&quot;;   //keep &quot;GROUP&quot; as part
	public static final String VIEW_TYPE_GROUP_GRAPH = &quot;VIEW_TYPE_GROUP_GRAPH&quot;; // of all group view
	public static final String VIEW_TYPE_GROUP_PRINT = &quot;VIEW_TYPE_GROUP_PRINT&quot;; // key values !!
	public static final String VIEW_TYPE_GROUP_MULTI = &quot;VIEW_TYPE_GROUP_MULTI&quot;;

	public static final int PREV_DAY_INDEX = -1;
	public static final int NEXT_DAY_INDEX = 1441;

	protected ResourceBundle m_bundle;
	protected ResourceBundle m_bbm_bundle;
	protected String m_formAction;
	protected String m_viewType;
	protected String m_noShiftLabel;
	protected ID m_myEmpID;
<span class="fc" id="L124">	protected Organization m_myOrganization = null;</span>
	protected DialogToolbarMenuPC m_newSwapMenuPC;
	protected DialogToolbarMenuPC m_netStaffingDisambiguationMenuPC;

	protected boolean m_bGroupView;     //this is a group view
	protected boolean m_bGroupSelector; //show group selector
	protected boolean m_bPagination;   //show pagination
	protected boolean m_bDateSelector;  //show dates dropdown instead of the range
	protected boolean m_bLegendButton;  //show buttons...
	protected boolean m_bPrintButton;
<span class="fc" id="L134">	protected boolean m_isPageEnabled=true;</span>
<span class="fc" id="L135">	protected boolean m_isFullPageMode = true; //true=agent view, false=manager view</span>

<span class="fc" id="L137">	protected StringBuffer m_sbJS = new StringBuffer();   // for accumulation of js data</span>

<span class="fc" id="L139">	protected DualListPC m_dualList = null;</span>
	protected DateRangePickerPC m_dateRangePicker;
	protected DatePickerPC m_datePicker;
<span class="fc" id="L142">	protected DialogLegendPC m_legendPC = null;</span>
<span class="fc" id="L143">	protected TimeRange m_timeRange = null;    //period selected for viewing</span>
<span class="fc" id="L144">	protected TimeRange m_dayRange= null;    //current date in the period for group text/graph/print view</span>
	
	//Request Management Settings per organization
<span class="fc" id="L147">	protected static RmManagerFactory m_rmManagerFactory = RmManagerFactory.getInstance();</span>
	protected OrganizationSetting m_orgSetting;
<span class="fc" id="L149">	protected boolean m_allowNewShifts = false;</span>
<span class="fc" id="L150">	protected boolean m_allowShiftChanges = false;</span>
<span class="fc" id="L151">	protected boolean m_csReqEnabled = false;</span>
<span class="fc" id="L152">	protected boolean m_vtoReqEnabled = false;</span>
	
	//User Preferences for Net Staffing ribbons
<span class="fc" id="L155">	protected boolean m_isNetStaffingRibbonEnabled = false;</span>
<span class="fc" id="L156">	protected boolean m_isNetStaffingHalfHeight = true;	</span>
	protected String m_netStaffingShortageColor;
	protected String m_netStaffingSurplusColor;
	protected String m_netStaffingNeutralColor;
	protected String m_netStaffingCellSelectionColor;
	
	//these three members tell us which of the Net Staffing colors should be shown in the legend, if any.
<span class="fc" id="L163">	protected boolean m_hasNetStaffingShortageData = false;</span>
<span class="fc" id="L164">	protected boolean m_hasNetStaffingNeutralData = false;</span>
<span class="fc" id="L165">	protected boolean m_hasNetStaffingSurplusData = false;</span>
	
	//Privileges to create requests
<span class="fc" id="L168">	boolean m_isCSEnabled = false;</span>
<span class="fc" id="L169">	boolean m_isTOEnabled = false;</span>
	
<span class="nc" id="L171">	public static enum dstTransitionMode { NEUTRAL, FALLBACK, SPRINGFORWARD };</span>

	//public static int NET_OVERSTAFFED = 1;
	//public static int NET_UNDERSTAFFED = -1;
	//public static int NET_NEUTRAL = 0;

    /**
     * The horizontal position to scroll to by default when the page loads.
     */
<span class="fc" id="L180">    protected int m_scrollX = 0;</span>
    
	/**
	 * The work resource assignments for the employee whose Net Staffing Ribbon will be displayed.
	 */
<span class="fc" id="L185">	protected Collection&lt;WorkResourceAssignment&gt; m_wrAssignmentsForNetStaffingEmp = null;</span>

	/**
	 * The open HOO periods for the employee whose Net Staffing Ribbon will be displayed.
	 */
<span class="fc" id="L190">	protected Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; m_orgOpenPeriodsForNetStaffingEmp = null;</span>
	
	
	/**
	 * Constructs a schedule view base class.
	 */
	public ScheduleViewPM(RequestContext context, String formAction, String viewType) {
<span class="nc" id="L197">		this(context, formAction, viewType, false);</span>
<span class="nc" id="L198">	}//constructor</span>

	/**
	 * Constructs a schedule view base class.
	 */
	public ScheduleViewPM(RequestContext context, String formAction, String viewType, boolean isDualListUsed){
<span class="fc" id="L204">		super(context, PageModel.BASIC_MODEL);</span>

<span class="fc" id="L206">		m_myEmpID = context.getUser().getEmployeeID();</span>
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">		m_isPageEnabled = (m_myEmpID!=null);</span>
<span class="fc" id="L208">		m_viewType = viewType;</span>
<span class="fc" id="L209">		m_formAction = formAction;</span>
<span class="fc" id="L210">		ScheduleViewUtil.cacheFormAction(context, formAction);</span>
<span class="fc" id="L211">		initFlags(viewType);</span>

<span class="fc" id="L213">		m_timeRange = new TimeRange(new Date(),new Date());</span>
<span class="fc" id="L214">		m_bundle = m_localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>
<span class="fc" id="L215">		m_bbm_bundle = m_localizer.getBundle(BbmWebBundleKey.BUNDLE_NAME);</span>
<span class="fc" id="L216">		m_noShiftLabel = i18n(m_bundle,FsWebBundleKey.SV_NO_SHIFT);</span>

		//=== Component specific required JavaScript Files
<span class="fc" id="L219">		addRequiredJavaScriptFile(JavaScriptFileID.MEDIATOR_WORKPANE_GENERIC);</span>
<span class="fc" id="L220">		setJSMediator(FsJavaScriptFileID.MEDIATOR_SCHEDULE_VIEW);</span>

		// Initialize date range picker
<span class="fc" id="L223">		m_dateRangePicker = new DateRangePickerPC(context,DATE_RANGE_FN);</span>
<span class="fc" id="L224">		m_dateRangePicker.setIsAllDateButtonsEnabled(true);</span>
		
		//Set the first day of week in the picker to the user's org start day
<span class="fc" id="L227">		m_myOrganization = ScheduleViewMH.getOrganizationForEmp(m_context, m_myEmpID);</span>
<span class="fc" id="L228">		int firstDayOfWeek = ScheduleViewMH.getWeekStartDayForEmp(m_context, m_myEmpID, m_myOrganization);</span>
<span class="fc" id="L229">		m_dateRangePicker.setFirstDayOfWeek(firstDayOfWeek); //ex: Calendar.FRIDAY</span>
		
<span class="fc" id="L231">		addChildComponent(m_dateRangePicker);</span>

		// Add legend
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		if (m_bLegendButton) {</span>
<span class="nc" id="L235">			m_legendPC= new DialogLegendPC(context, m_toolbar);</span>
<span class="nc" id="L236">			addChildComponent(m_legendPC);</span>
		}

		// Initialize Dual List
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">		if (isDualListUsed) </span>
        {
<span class="fc" id="L242">			m_dualList = new DualListPC(context);; //isGraphView() ? new GraphDualListPC(context) : new DualListPC(context);</span>
<span class="fc" id="L243">			addChildComponent(m_dualList);</span>
            
<span class="fc" id="L245">            m_dualList.getRightListPC().setHasRowHeaders(false); //508: The row headers are actually in the left list!</span>
		}
		
<span class="fc" id="L248">		m_list.setIsZebra(true); //This will set zebra striping for the non-dualList schedule pages</span>
<span class="fc" id="L249">	}//constructor</span>
	
	public boolean isGraphView()
	{
<span class="pc bpc" id="L253" title="2 of 4 branches missed.">		return m_viewType.equals(VIEW_TYPE_GROUP_GRAPH) ||m_viewType.equals(VIEW_TYPE_MY_GRAPH);</span>
	}
	
	protected static OrganizationConfigManager getOrgConfigManager() throws BbmCreateException {
<span class="fc" id="L257">		return m_rmManagerFactory.getOrganizationConfigManager();</span>
	}

	/**
	 * Return OrganizationSetting for specified Organization ID
	 */
	public static OrganizationSetting getOrgSetting(ID orgID)
			throws RemoteException, BbmFinderException, BbmCreateException {
<span class="fc" id="L265">		return getOrgConfigManager().getConfiguration(orgID);</span>
	}
	
	/** 
	 * Read the user's net staffing user preference, and his organization's net staffing / cust shift request settings.
	 * m_myEmpID , m_myOrganization
	 */
	protected void readNetStaffingSettingsForUserAndOrg() throws Exception
	{
<span class="nc bnc" id="L274" title="All 2 branches missed.">		if (m_myOrganization != null)</span>
		{
			//read the request amanagerment organization settings
<span class="nc" id="L277">			m_orgSetting = getOrgSetting(m_myOrganization.getID());</span>
			//allow new shift requests for employee's org
<span class="nc" id="L279">			m_allowNewShifts = m_orgSetting.getEnableCustomShiftRequests();   </span>
			//allow shift change requests for employee's org
<span class="nc" id="L281">			m_allowShiftChanges = m_orgSetting.getAllowShiftChangeRequests(); </span>
			
<span class="nc bnc" id="L283" title="All 4 branches missed.">			m_csReqEnabled = (m_allowNewShifts || m_allowShiftChanges);			</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">			m_vtoReqEnabled = (m_isFullPageMode ? m_orgSetting.getAgentTimeOffWorkflowActive() : m_orgSetting.getManagerTimeOffWorkflowActive());</span>

			//read the user preferences
<span class="nc bnc" id="L287" title="All 6 branches missed.">			m_isNetStaffingRibbonEnabled = (m_csReqEnabled || m_vtoReqEnabled) &amp;&amp; ScheduleViewMH.getShowNetStaffing(m_context);</span>
<span class="nc" id="L288">			m_isNetStaffingHalfHeight = ScheduleViewMH.getNetStaffingHalfHeight(m_context);</span>
<span class="nc" id="L289">			m_netStaffingShortageColor = removeHash(ScheduleViewMH.getNetStaffingShortageColor(m_context));</span>
<span class="nc" id="L290">			m_netStaffingSurplusColor =  removeHash(ScheduleViewMH.getNetStaffingSurplusColor(m_context));</span>
<span class="nc" id="L291">			m_netStaffingNeutralColor =  removeHash(ScheduleViewMH.getNetStaffingNeutralColor(m_context));	</span>
<span class="nc" id="L292">			m_netStaffingCellSelectionColor = ScheduleViewMH.getNetStaffingCellSelectionColor(m_context);</span>
			
<span class="nc" id="L294">			addJSVariableAsString(&quot;CELL_SELECT_COLOR&quot;, m_netStaffingCellSelectionColor);			</span>
<span class="nc" id="L295">			addJSVariableAsString(&quot;INVALID_SELECTION&quot;, i18n(m_bundle, FsWebBundleKey.NET_STAFFING_INVALID_SELECTION));</span>
			
<span class="nc bnc" id="L297" title="All 2 branches missed.">			m_isCSEnabled = ScheduleViewMH.getCanCreateCustomShiftRequest(m_context, !m_isFullPageMode);</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">			m_isTOEnabled = ScheduleViewMH.getCanCreateTimeOffRequest(m_context, !m_isFullPageMode);</span>
<span class="nc" id="L299">			addJSVariable(&quot;isCSEnabled&quot;, &quot;&quot;+m_isCSEnabled);</span>
<span class="nc" id="L300">			addJSVariable(&quot;isTOEnabled&quot;, &quot;&quot;+m_isTOEnabled);</span>
		}
<span class="nc" id="L302">	}</span>
	
	
	/**
	 * Checks whether the &quot;Voluntary Time Off&quot; activity's isRequestable attribute is true or false.
	 */
	protected boolean isVTOActivityRequestable() throws Exception
	{
<span class="nc" id="L310">		Activity vtoAct = ActivityModelHandler.getActivityByID(m_context, Activity.ACTIVITY_VOLUNTARY_TIMEOFF);		</span>
<span class="nc" id="L311">		return vtoAct.isRequestable();</span>
	}
	
	/**
	 * Given a color string such as &quot;#00FF33&quot;, return the color without the &quot;#&quot; at the beginning.
	 */
	private String removeHash(String color)
	{
<span class="nc bnc" id="L319" title="All 4 branches missed.">		if (color != null &amp;&amp; color.startsWith(&quot;#&quot;))</span>
		{
<span class="nc" id="L321">			color = color.substring(1);</span>
		}
<span class="nc" id="L323">		return color;</span>
	}	
	
	/**
	 * Initialize Component For Display
	 */
	public void initForDisplay() {
<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		if (m_isInitializedForDisplay) return;</span>
		else {
<span class="fc" id="L332">			super.initForDisplay();</span>

<span class="fc" id="L334">			initNewSwapMenu();</span>
<span class="fc" id="L335">			initShiftSwapPopupWindowArgs();</span>
		}
<span class="fc" id="L337">	}</span>

	/**
	 * Initialize Popup Window Arguments for Shift Swap
	 */
	protected void initShiftSwapPopupWindowArgs() {
<span class="fc" id="L343">		addPopupArgs(FsPageAction.POPUP_SWAPBOARD_POSTING_FORM_ACTION, FsKeys.RH_SWAPBOARD_FORM,</span>
				null, &quot;postingID,shiftType,shiftDate&quot;, &quot;550,400,ctr,ctr&quot;, true, 1);

<span class="fc" id="L346">		addPopupArgs(FsPageAction.POPUP_SHIFTSWAP_REQUEST_FORM_ACTION, FsKeys.RH_SHIFTSWAP_FORM,</span>
				null, &quot;postingID,shiftType,requestDate1,requestDate2&quot;, &quot;560,510,ctr,ctr&quot;, true, 1);
<span class="fc" id="L348">	}</span>

	/**
	 * Initialize New Shift Swap Menu
	 */
	protected void initNewSwapMenu() {
<span class="fc" id="L354">		m_newSwapMenuPC = createShiftSwapMenu(m_context, m_toolbar, &quot;NEW_SWAP_MENU&quot;);</span>
<span class="fc" id="L355">		addChildComponent(m_newSwapMenuPC);</span>
<span class="fc" id="L356">	}</span>

	/**
	 * Create Shift Swap Menu PC
	 */
	private DialogToolbarMenuPC createShiftSwapMenu(RequestContext context, ToolbarPC toolbar, String name) {
<span class="fc" id="L362">		DialogToolbarMenuPC newSwapMenuPC = new DialogToolbarMenuPC(context, toolbar);</span>
<span class="fc" id="L363">		newSwapMenuPC.setName(name);</span>

<span class="fc" id="L365">		Localizer localizer = context.getLocalizer();</span>
<span class="fc" id="L366">		ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>

		// Initialize Title
<span class="fc" id="L369">		String title = localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_SHIFT_SWAP);</span>
<span class="fc" id="L370">		newSwapMenuPC.setHeader(title);</span>

		// Initialize Menu Buttons
<span class="fc" id="L373">		newSwapMenuPC.addPopupWindowButton(FsPageAction.POPUP_SWAPBOARD_POSTING_FORM_ACTION,</span>
<span class="fc" id="L374">				localizer.i18n(bundle, FsWebBundleKey.CREATE_NEW_POSTING), true);</span>

<span class="fc" id="L376">		newSwapMenuPC.addPopupWindowButton(FsPageAction.POPUP_SHIFTSWAP_REQUEST_FORM_ACTION,</span>
<span class="fc" id="L377">				localizer.i18n(bundle, FsWebBundleKey.CREATE_NEW_REQUEST), true);</span>

<span class="fc" id="L379">		return newSwapMenuPC;</span>
	}

	/**
	 * Create the Net Staffing Request Type Disambiguation Menu PC.
	 */
	private DialogToolbarMenuPC createNetStaffingDisambiguationMenu(RequestContext context, ToolbarPC toolbar, String name) {
<span class="nc" id="L386">		DialogToolbarMenuPC menuPC = new DialogToolbarMenuPC(context, toolbar);</span>
<span class="nc" id="L387">		menuPC.setName(name);</span>

<span class="nc" id="L389">		Localizer localizer = context.getLocalizer();</span>
<span class="nc" id="L390">		ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>

		// Initialize Title
<span class="nc" id="L393">		String title = localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_LABEL);</span>
<span class="nc" id="L394">		menuPC.setHeader(title);</span>

		// Initialize Menu Buttons
<span class="nc" id="L397">		menuPC.addPopupWindowButton(FsPageAction.POPUP_CUSTSHIFT_REQUEST_FORM_ACTION,</span>
<span class="nc" id="L398">				localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_CUSTOM_SHIFT), true);</span>

<span class="nc" id="L400">		menuPC.addPopupWindowButton(FsPageAction.POPUP_TIMEOFF_REQUEST_FORM_ACTION,</span>
<span class="nc" id="L401">				localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_VTO), true);</span>

<span class="nc" id="L403">		return menuPC;</span>
	}

	/**
	 * Initialize Popup Window Arguments for VTO Request and Custom Shift Request (from Net Staffing ribbon).
	 */
	protected void initNetStaffingPopupWindowArgs() {
<span class="nc" id="L410">		addPopupArgs(FsPageAction.POPUP_TIMEOFF_REQUEST_FORM_ACTION, FsKeys.RH_TIMEOFF_FORM,</span>
				null, &quot;requestedFor,pageMode,ribbonStartDate,ribbonEndDate,isFromNetStaffingRibbon&quot;, &quot;800,655,ctr,ctr&quot;, true, 1);

<span class="nc" id="L413">		addPopupArgs(FsPageAction.POPUP_CUSTSHIFT_REQUEST_FORM_ACTION, FsKeys.RH_CUSTSHIFT_FORM,</span>
				null, &quot;requestedFor,pageMode,ribbonStartDate,ribbonEndDate,reloadAction&quot;, &quot;750,655,ctr,ctr&quot;, true, 1);
<span class="nc" id="L415">	}</span>
	
	/**
	 * Initialize Net Staffing Disambiguation Menu
	 */
	protected void initNetStaffingDisambiguationMenu() {
<span class="nc" id="L421">		m_netStaffingDisambiguationMenuPC = createNetStaffingDisambiguationMenu(m_context, m_toolbar, &quot;NET_STAFFING_DISAMBIGUATION&quot;);</span>
<span class="nc" id="L422">		addChildComponent(m_netStaffingDisambiguationMenuPC);</span>
<span class="nc" id="L423">	}</span>
	
	/**
	 * initialize boolean flags for the view
	 */
	private void initFlags(String viewType){
<span class="pc bpc" id="L429" title="1 of 2 branches missed.">		m_bGroupView = viewType.equals(VIEW_TYPE_GROUP_GRAPH)</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_MULTI)</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_PRINT)</span>
<span class="pc bnc" id="L432" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_TEXT);</span>
<span class="fc" id="L433">		m_bGroupSelector = m_bGroupView;</span>
<span class="fc" id="L434">		m_bPagination = m_bGroupView;</span>
<span class="pc bpc" id="L435" title="2 of 4 branches missed.">		m_bDateSelector = m_bGroupView &amp;&amp; !viewType.equals(VIEW_TYPE_GROUP_MULTI) ;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">		m_bLegendButton = viewType.equals(VIEW_TYPE_GROUP_GRAPH)</span>
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">				|| viewType.equals(VIEW_TYPE_MY_GRAPH);</span>
<span class="fc" id="L438">		m_bPrintButton = false; //TODO 5.x: enable when add print pages; print legend</span>
<span class="fc" id="L439">	}//initFlags</span>

	/**
	 * Initialize Model with Data
	 */
	protected void initializeModel() 
	{
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		if (m_isInitialized) </span>
<span class="nc" id="L447">			return;</span>

		//adjustModelTypeFromScreenDef();
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">		m_isFullPageMode = (BASIC_MODEL == getPageModelType());</span>

<span class="fc" id="L452">		super.initializeModel();</span>
<span class="fc" id="L453">	}</span>
	
	/**
	 * Initialize Selectable Items
	 */
	protected void loadData() throws Exception {
<span class="pc bpc" id="L459" title="1 of 2 branches missed.">		if (m_myEmpID!=null) {</span>
<span class="fc" id="L460">			initDateRange();</span>
<span class="fc" id="L461">			loadAndInitData();</span>
		} else {
<span class="nc" id="L463">			addPageMessage(Message.INFO_TYPE,</span>
					UIFWebBundleKey.SCREEN_DISABLED_FOR_NON_EMP,
					UIFWebBundleKey.BUNDLE_NAME);
		}
<span class="fc" id="L467">	}</span>

	protected void refreshTimeRangeFromSession() {
		//get time interval from the session
<span class="fc" id="L471">		m_timeRange = (TimeRange)m_context.getAttribute(RequestContext.SESSION_SCOPE,</span>
				UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD);
                
        //QC#44831
<span class="fc bfc" id="L475" title="All 2 branches covered.">        if (m_timeRange != null)</span>
        {
            //We must convert the date range to the user timezone, because the user may have just changed it.
<span class="fc" id="L478">            Date startDate = m_timeRange.getStartDate();</span>
<span class="fc" id="L479">            Date endDate = m_timeRange.getEndDate();</span>
<span class="fc" id="L480">            TimeZone tz = m_context.getViewingTimeZone();</span>
            
<span class="fc" id="L482">            TimeRange startRange = DateTimeUtil.makeDayRange(startDate, tz);</span>
<span class="fc" id="L483">            TimeRange endRange = DateTimeUtil.makeDayRange(endDate, tz);</span>
<span class="fc" id="L484">            m_timeRange.setStartDate(startRange.getStartDate());</span>
<span class="fc" id="L485">            m_timeRange.setEndDate(endRange.getEndDate());</span>
            
<span class="fc" id="L487">            m_context.setAttribute(RequestContext.SESSION_SCOPE, UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, m_timeRange);</span>
        }
<span class="fc" id="L489">	}</span>

	/**
	 * Initialize start and end dates
	 */
	protected void initDateRange() throws RemoteException, BbmException 
	{
		//--- get dates from extracted parameters
<span class="fc" id="L497">		Date fromDate  = m_dateRangePicker.getStartDatePickerPC().getDate();</span>
<span class="fc" id="L498">		Date toDate    = m_dateRangePicker.getEndDatePickerPC().getDate();</span>
		
<span class="pc bpc" id="L500" title="1 of 4 branches missed.">		if (fromDate != null &amp;&amp; toDate != null) {</span>
			try {
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">				String configKey = (BASIC_MODEL == getPageModelType()) </span>
					? &quot;bluepumpkin/Schedule/MyGroup/dateRangeLimit&quot; 
					: &quot;bluepumpkin/Schedule/People/dateRangeLimit&quot;;
				
<span class="fc" id="L506">				String limit = BbmManagerFactory.getDBConfigManager().getValue(configKey);</span>
<span class="pc bpc" id="L507" title="1 of 2 branches missed.">				if(limit!=null){</span>
<span class="nc" id="L508">					int dateRangeLimit = Integer.parseInt(limit);</span>
<span class="nc" id="L509">					Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L510">					cal.setTime(fromDate);</span>
<span class="nc" id="L511">					cal.add(Calendar.DAY_OF_MONTH, dateRangeLimit);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">					if(cal.getTime().before(toDate)){</span>
						// set as End Time subtract 1 second
<span class="nc" id="L514">						cal.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L515">						toDate = cal.getTime();</span>
					}
				}
			} 
<span class="nc" id="L519">			catch (Exception e) </span>
			{
<span class="nc" id="L521">				e.printStackTrace();</span>
<span class="fc" id="L522">			}</span>
		}
		
<span class="pc bpc" id="L525" title="2 of 6 branches missed.">		if (fromDate!=null &amp;&amp; toDate!=null &amp;&amp; fromDate.after(toDate)){</span>
<span class="nc" id="L526">			this.addPageMessage(Message.WARNING_TYPE, FsWebBundleKey.SV_WARN_START_AFTER_END,</span>
					FsWebBundleKey.BUNDLE_NAME);
<span class="nc" id="L528">			fromDate = toDate;</span>
		}
		
		//--- if null, then use from the session
<span class="pc bpc" id="L532" title="1 of 4 branches missed.">		if (fromDate == null || toDate == null) </span>
		{
<span class="fc" id="L534">			refreshTimeRangeFromSession();</span>

<span class="fc bfc" id="L536" title="All 2 branches covered.">        	if (m_timeRange == null)</span>
    		{
<span class="fc" id="L538">    			m_timeRange = getThisWeekTimeRange();</span>
    		}
		}
		else 
		{
<span class="fc" id="L543">			m_timeRange = new TimeRange(fromDate,toDate);</span>
		}
		
		//--- save date range in the session
<span class="fc" id="L547">		m_context.setAttribute(RequestContext.SESSION_SCOPE,</span>
				UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, m_timeRange);
<span class="fc" id="L549">	}//initDateRange</span>

    /**
	 * get time range as this week for the user org.
	 */
	public TimeRange getThisWeekTimeRange()
			throws RemoteException, BbmException 
	{		
<span class="fc" id="L557">		HashMap theData = new HashMap();</span>
<span class="fc" id="L558">		theData.put(&quot;VIEW_TYPE_KEY&quot;, m_viewType);</span>
<span class="fc" id="L559">		ScheduleViewMH.putUserOrgID(m_context, theData);</span>
		
<span class="fc" id="L561">		Calendar startCal = ScheduleViewMH.getThisWeekStart(m_context,theData);</span>
<span class="fc" id="L562">		Calendar endCal = ScheduleViewMH.getThisWeekEnd(m_context, startCal);</span>
<span class="fc" id="L563">		TimeRange timeRange = new TimeRange(startCal.getTime(), endCal.getTime());</span>

<span class="fc" id="L565">		return timeRange;</span>
	}

	/**
	 * Initialize Toolbar
	 */
	protected void initToolbar() {
		//Print button
<span class="pc bpc" id="L573" title="1 of 2 branches missed.">		if (m_bPrintButton) {</span>
<span class="nc" id="L574">			m_toolbar.addToolbarElement(new ToolbarTextButton(m_toolbar, &quot;SCHEDULE_PRINT&quot;,</span>
<span class="nc" id="L575">					i18n(m_bundle, FsWebBundleKey.PRINT), ToolbarTextButton.GREEN_BUTTON));</span>
		}

		//Legend button
<span class="pc bpc" id="L579" title="1 of 2 branches missed.">		if (m_bLegendButton) m_toolbar.addToolbarElement( m_legendPC.getLegendButton() );</span>

		//Refresh button
<span class="fc" id="L582">		m_toolbar.addSubmitTextButton(PageAction.REFRESH, i18n(m_bundle, FsWebBundleKey.REFRESH), true);</span>
<span class="fc" id="L583">	}//initToolbar</span>


	/**
	 * Return Collection of View Selector Options
	 */
	protected abstract Collection getViewSelectorOptions();

	/**
	 * Return Selected View Type
	 */
	public static String getViewType(RequestContext context) {
<span class="fc" id="L595">		return context.getRequest().getParameter(VIEW_TYPE_FN);</span>
	}

	/**
	 * make the view selector html string, which is used in the content title
	 */
	protected String makeViewSelector() {
<span class="fc" id="L602">		Collection options = getViewSelectorOptions();</span>
<span class="fc" id="L603">		String onChange = &quot;this.form.action = this.value;&quot; + getDropDownRefreshJS();</span>
<span class="fc" id="L604">		String label = i18n(m_common_bundle, UIFWebBundleKey.VIEW);</span>

<span class="fc" id="L606">		return makeSelector(VIEW_TYPE_FN, label, m_formAction, onChange, options);</span>
	}//makeViewSelector

	/**
	 * return JavaScript for Drop Down Refresh
	 */
	protected String getDropDownRefreshJS() {
<span class="nc" id="L613">		return JSUtil.REFRESH_IGNORE_CHANGES;</span>
	}
 

	/** make selector */
	protected String makeSelector(String fn, String label, String selected,
			String onChange, Collection options){
<span class="fc" id="L620">		StringBuffer sb = new StringBuffer(200);</span>

<span class="fc" id="L622">		String[] selectedValue = {selected};</span>
<span class="fc" id="L623">		String width = null;</span>
<span class="fc" id="L624">		boolean useDefaultOnChange = false;</span>
<span class="fc" id="L625">		boolean isMultiple = false;</span>
<span class="fc" id="L626">		String sDD = HtmlUtil.makeSelectInput(fn, &quot;0&quot;, selectedValue, onChange, options,</span>
				width, useDefaultOnChange, isMultiple);

<span class="fc" id="L629">        label = HtmlUtil.createLabel(label, fn); //508</span>
<span class="fc" id="L630">		sb.append(ContentTitlePC.formatLabel(label)).append(sDD);</span>
<span class="fc" id="L631">		return sb.toString();</span>
	}//makeSelector

	/**
	 * Initialize Legend
	 */
	protected void initLegend(HashMap theData) {
<span class="pc bpc" id="L638" title="1 of 2 branches missed.">		if (m_bLegendButton) {</span>
<span class="nc" id="L639">			m_legendPC.setHeader(i18n(m_bundle, FsWebBundleKey.GRAPH_SCHEDULE_LEGEND_PAGETITLE));</span>
<span class="nc" id="L640">			addOvertimeLegendItem(theData); //if have overtime, add to legend</span>
<span class="nc" id="L641">			addNetStaffingLegendItems(theData); //if has Net Staffing, add to legend</span>
<span class="nc" id="L642">			ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>
<span class="nc" id="L643">			m_legendPC.setItems(legendData);</span>
		}
<span class="fc" id="L645">	}//initLegend</span>

	/**
	 * if any of the schedule items in the collection has overtime, add entry to legend
	 */
	private void addOvertimeLegendItem(HashMap theData){
<span class="nc" id="L651">		Collection theScheduleItems = ScheduleViewMH.getAllScheduleItemsFromMap(theData);</span>
		//iterate through the schedule items and if find overtime add to the legend
<span class="nc bnc" id="L653" title="All 4 branches missed.">		if (theScheduleItems != null &amp;&amp; theScheduleItems.size() &gt; 0) {</span>
<span class="nc" id="L654">			ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			for (Iterator it = theScheduleItems.iterator(); it.hasNext();) {</span>
<span class="nc" id="L656">				SimpleEvent anEvent = (SimpleEvent)it.next();</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">				if(anEvent.isOvertime()){</span>
<span class="nc" id="L658">					legendData.add(new StringsPair(FsImageFileID.OT_PATTERN, </span>
<span class="nc" id="L659">						i18n(m_bundle,FsWebBundleKey.SP_OVERTIME)));	</span>
<span class="nc" id="L660">					return;</span>
				}
<span class="nc" id="L662">			}</span>
		}		
<span class="nc" id="L664">	}//addOvertimeLegendItem</span>
	
	/**
	 * if viewing Net Staffing ribbons, add the Net Staffing colors to the legend.
	 */
	protected void addNetStaffingLegendItems(HashMap theData)
	{
<span class="nc" id="L671">		ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>
		
<span class="nc bnc" id="L673" title="All 2 branches missed.">		if(m_hasNetStaffingShortageData)</span>
<span class="nc" id="L674">			legendData.add(new StringsPair(m_netStaffingShortageColor, i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE)));	</span>

<span class="nc bnc" id="L676" title="All 2 branches missed.">		if(m_hasNetStaffingSurplusData)</span>
<span class="nc" id="L677">			legendData.add(new StringsPair(m_netStaffingSurplusColor, i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS)));	</span>

<span class="nc bnc" id="L679" title="All 2 branches missed.">		if(m_hasNetStaffingNeutralData)</span>
<span class="nc" id="L680">			legendData.add(new StringsPair(m_netStaffingNeutralColor, i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL)));	</span>

<span class="nc" id="L682">	}</span>

	/**
	 * Perform Extract parameters: current day in the group views
	 */
	public boolean extractParameters(HttpServletRequest request) {
<span class="fc" id="L688">		boolean isSuccess = super.extractParameters(request);</span>

<span class="fc" id="L690">		String strViewDate = request.getParameter(VIEW_DATE_FN);</span>
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">		if (!StringUtil.isEmpty(strViewDate)){</span>
			try {
<span class="nc" id="L693">				long timeValue = Long.parseLong(strViewDate);</span>
<span class="nc" id="L694">				this.m_dayRange = DateTimeUtil.makeDayRange(new Date(timeValue),</span>
<span class="nc" id="L695">						m_context.getViewingTimeZone());</span>
<span class="nc" id="L696">				m_context.setAttribute(RequestContext.SESSION_SCOPE,</span>
						UserPreferenceKeys.USER_SCHEDULE_VIEW_DAY, this.m_dayRange);
<span class="nc" id="L698">			} catch (Exception ex) {</span>
<span class="nc" id="L699">				log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="nc" id="L700">				addPageMessage(Message.ERROR_TYPE, UIFWebBundleKey.EXTRACT_PARAM_FAILED,</span>
						UIFWebBundleKey.BUNDLE_NAME);
<span class="nc" id="L702">			}</span>
		}
<span class="fc" id="L704">		return isSuccess;</span>
	}//extractParameters

	/**
	 * Return the Selectable Items
	 */
	public SelectableItems getSelectableItems() {
<span class="fc" id="L711">		SelectableItems aList = null;</span>

<span class="pc bpc" id="L713" title="1 of 2 branches missed.">		if (m_dualList != null) {</span>
<span class="fc" id="L714">			initDualListForDisplay();</span>
<span class="fc" id="L715">			aList = m_dualList;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">		}	else if (m_list != null) {</span>
<span class="nc" id="L717">			aList = m_list;</span>
		}

<span class="fc" id="L720">		return aList;</span>
	}// getSelectableItems

	//================= getters/setters ==================
	/** get date for the beginning of shown period */
	protected Date getFromDate(){
<span class="nc" id="L726">		return m_timeRange.getStartDate();</span>
	}
	/** get date for the end of shown period */
	protected Date getToDate(){
<span class="nc" id="L730">		return m_timeRange.getEndDate();</span>
	}
	/** set date for the beginning of shown period */
	protected void setFromDate(Date fromDate){
<span class="nc" id="L734">		m_timeRange.setStartDate(fromDate);</span>
<span class="nc" id="L735">	}</span>
	/** set date for the end of shown period */
	protected void setToDate(Date toDate){
<span class="nc" id="L738">		m_timeRange.setEndDate(toDate);</span>
<span class="nc" id="L739">	}</span>
	/** get view type */
	public String getViewType(){
<span class="nc" id="L742">		return m_viewType;</span>
	}
	/** set view type not needed: set only in the constructor */

	/**
	 * Return URL for HTML Form Action
	 */
	public String getFormAction() {
<span class="fc" id="L750">		return m_formAction;</span>
	}//getFormAction


	//============= helpers =======================
	/**
	 * get the show unavailabilities flag
	 */
	protected boolean showUnavailable(HashMap theData){
<span class="nc" id="L759">		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_UNAVAILABLE_KEY);</span>
	}//showUnavailable

	/**
	 * get the show timeoff flag
	 */
	protected boolean showTimeoff(HashMap theData){
<span class="fc" id="L766">		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_TIMEOFF_KEY);</span>
	}//showUnavailable

	/**
	 * get the shift swap enabled flag
	 */
	protected boolean isSwapEnabled(HashMap theData) throws Exception {
	
<span class="fc" id="L774">		boolean hasRightsReadOrWriteSwapBoard = getBooleanFromMap(theData, ScheduleViewMH.SWAP_FLAG_KEY) ;</span>
<span class="fc" id="L775">		boolean isEnableSwapFromOrgSetting = false;</span>
<span class="pc bpc" id="L776" title="1 of 2 branches missed.">		if(m_myOrganization!=null){</span>
<span class="fc" id="L777">			isEnableSwapFromOrgSetting = getOrgSetting(m_myOrganization.getID()).getEnableShiftSwap();	</span>
		}
			
<span class="pc bpc" id="L780" title="3 of 4 branches missed.">		return hasRightsReadOrWriteSwapBoard&amp;&amp;isEnableSwapFromOrgSetting;</span>
	}//isSwapEnabled

	/**
	 * get the show my schedule notes flag
	 * @param orgID - the ID of the organization whose schedule you are viewing
	 *
	protected boolean showMyScheduleNote(HashMap theData)
	{
		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_MY_SCHEDULE_NOTE_KEY);
	}

	/**
	 * get the show group schedule notes flag
	 * @param orgID - the ID of the organization whose schedule you are viewing
	 *
	protected boolean showOrgScheduleNote(HashMap theData)
	{
		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_ORG_SCHEDULE_NOTE_KEY);
	}
	*/

	/**
	 * get the boolean flag from the HashMap using the key value
	 * @return boolean or false if can't get the value
	 */
	public static boolean getBooleanFromMap(Map theData, String key){
<span class="fc" id="L807">		Object obj = theData.get(key);</span>
<span class="fc" id="L808">		boolean bVal = false; //default</span>
<span class="fc bfc" id="L809" title="All 2 branches covered.">		if (obj != null)</span>
<span class="fc" id="L810">			bVal = ((Boolean)obj).booleanValue();</span>
<span class="fc" id="L811">		return bVal;</span>
	}//getBooleanForTheUser

	//======= most of the methods below are used in both personal and group views =======
	/**
	 * calculate shown hours as the max range of day hours covering all events limited to HOOs.
	 * Hours are in {0,23} range
	 * m_isNetStaffingRibbonEnabled - if true, we show the entire hoo day. If false, we also consider the scheduled events.
	 */
	protected int[] calculateShownHours(Collection schedule, HOOAssignment hoos, 
					boolean bShowUnavailable, TimeRange scheduleRange)
	{
<span class="nc" id="L823">		int hooHoursRange[] = getMinMaxHooHours(hoos);</span>
		
<span class="nc bnc" id="L825" title="All 2 branches missed.">		if (m_isNetStaffingRibbonEnabled)</span>
<span class="nc" id="L826">			return hooHoursRange;</span>
		
<span class="nc bnc" id="L828" title="All 2 branches missed.">		Collection scheduleEvents = (m_bGroupView)?</span>
<span class="nc" id="L829">				makeSingleEventsCollectionForGroup(schedule):</span>
				schedule;
<span class="nc" id="L831">		int eventHoursRange[] = getMinMaxEventHours(scheduleEvents, bShowUnavailable, scheduleRange);</span>
<span class="nc" id="L832">		int shownHours[] = combineMinMaxHours(eventHoursRange, hooHoursRange);</span>
<span class="nc" id="L833">		return shownHours;</span>
	}//calculateShownHours

	/**
	 * make single collection of events from collection of collections for multiple people
	 */
	protected Collection makeSingleEventsCollectionForGroup(Collection schedule){
<span class="nc bnc" id="L840" title="All 2 branches missed.">		if (schedule== null) return schedule;</span>
<span class="nc" id="L841">		ArrayList scheduleEvents = new ArrayList();</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		for (Iterator i = schedule.iterator(); i.hasNext();){</span>
<span class="nc" id="L843">			Collection personSchedule = (Collection) i.next();</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">			if (personSchedule != null){</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">				for (Iterator j = personSchedule.iterator(); j.hasNext();){</span>
<span class="nc" id="L846">					scheduleEvents.add(j.next());</span>
				}
			}
<span class="nc" id="L849">		}</span>
<span class="nc" id="L850">		return scheduleEvents;</span>
	}//makeSingleEventsCollectionForGroup

    /**
     * calculate min and max day hours, which cover all the shown events
     * @param schedule - Collection or schedule Events
     * @param bShowUnavailable
     * @return int array of two values {minHour,mahHour}
     *
     * NOTE: assuming that viewing period is always in full days
     */
    protected int[] getMinMaxEventHours(Collection schedule, boolean bShowUnavailable, TimeRange scheduleRange){
<span class="nc" id="L862">        return getMinMaxEventHours(schedule, bShowUnavailable, scheduleRange, false);</span>
    }
    
	/**
	 * calculate min and max day hours, which cover all the shown events
	 * @param schedule - Collection or schedule Events
     * @param bShowUnavailable
     * @param bSkipTimeOffEvents If true, then we will not consider timeoff events.
	 * @return int array of two values {minHour,mahHour}
	 *
	 * NOTE: assuming that viewing period is always in full days
	 */
	protected int[] getMinMaxEventHours(Collection schedule, boolean bShowUnavailable, TimeRange scheduleRange,
            boolean bSkipTimeOffEvents){
		// initialize min and max
<span class="nc" id="L877">		int minHour = 23;</span>
<span class="nc" id="L878">		int maxHour = 0;</span>
<span class="nc" id="L879">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc bnc" id="L880" title="All 4 branches missed.">		if (schedule!=null &amp;&amp; schedule.size()&gt;0){</span>
			//--- for each event in the schedule
<span class="nc bnc" id="L882" title="All 2 branches missed.">			for (Iterator i = schedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L883">				Event event = (Event) i.next();</span>
<span class="nc bnc" id="L884" title="All 2 branches missed.">				if (event == null) continue;</span>
<span class="nc bnc" id="L885" title="All 4 branches missed.">                if (!bShowUnavailable &amp;&amp; event.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY ) continue;</span>
<span class="nc bnc" id="L886" title="All 4 branches missed.">                if (bSkipTimeOffEvents &amp;&amp; event.getEventType() == Event.EVENT_TYPE_TIME_OFF ) continue;</span>

<span class="nc" id="L888">				Calendar eventStartCal = Calendar.getInstance(tz, m_locale);</span>
<span class="nc" id="L889">				eventStartCal.setTime(event.getStartTime());</span>
<span class="nc" id="L890">				Calendar eventEndCal = Calendar.getInstance(tz, m_locale);</span>
<span class="nc" id="L891">				eventEndCal.setTime(event.getEndTime());</span>
<span class="nc" id="L892">				int eventStartHour = eventStartCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L893">				int eventEndHour = eventEndCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L894">				TimeRange eventRange = new TimeRange(event.getStartTime(),event.getEndTime());</span>
<span class="nc" id="L895">				int overlapCode = eventRange.getRelativeLocationTo(scheduleRange);</span>

				//   if event crosses day boundary, 
<span class="nc bnc" id="L898" title="All 2 branches missed.">				if (eventStartCal.get(Calendar.DATE) != eventEndCal.get(Calendar.DATE)) {</span>
					//if event is inside the viewing schedule period or covers it
<span class="nc bnc" id="L900" title="All 6 branches missed.">					if (overlapCode == TimeRange.INTERVAL_IN </span>
						|| overlapCode == TimeRange.INTERVAL_EQUALS
						|| overlapCode == TimeRange.INTERVAL_COVERS){
						//set min and max to full day and break from the loop since we can't expand more
<span class="nc" id="L904">						minHour = 0;</span>
<span class="nc" id="L905">						maxHour = 23;</span>
<span class="nc" id="L906">						break;</span>
					} //else - event sticks out of the viewing schedule period
<span class="nc bnc" id="L908" title="All 2 branches missed.">					  else if (overlapCode == TimeRange.INTERVAL_BEFORE_AND_IN){ </span>
						//if start is before then minHour = 0
<span class="nc" id="L910">						minHour = 0;</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">						if (eventEndHour &gt; maxHour)</span>
<span class="nc" id="L912">							maxHour = eventEndHour;</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">					} else if (overlapCode == TimeRange.INTERVAL_AFTER_AND_IN){</span>
						//if end is after then max hour = 23
<span class="nc" id="L915">						maxHour = 23;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">						if (eventStartHour &lt; minHour)</span>
<span class="nc" id="L917">							minHour = eventStartHour;</span>
					}					
				} else { //event is within a day - reset min and max to cover the event
<span class="nc bnc" id="L920" title="All 4 branches missed.">					if (overlapCode != TimeRange.INTERVAL_BEFORE &amp;&amp; overlapCode != TimeRange.INTERVAL_AFTER){</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">						if (eventStartHour &lt; minHour)</span>
<span class="nc" id="L922">							minHour = eventStartHour;</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">						if (eventEndHour &gt; maxHour)</span>
<span class="nc" id="L924">							maxHour = eventEndHour;</span>
					}
				}
<span class="nc" id="L927">			}//for</span>
		} else { //no schedule - no hours
<span class="nc" id="L929">			minHour = 1; //setting min &gt; max will show all hours of the day</span>
		}
<span class="nc" id="L931">		maxHour = adjustMaxHoursForDSTTransition(minHour, maxHour, tz);</span>
		//--- put results in the int array and return
<span class="nc" id="L933">		return getHoursArray(minHour,maxHour);</span>
	}//getMinMaxEventHours


	/**
	 * get hours range as two int using min and max values, which are ignored if invalid
	 */
	protected int[] getHoursArray(int minHour, int maxHour){
<span class="nc" id="L941">		int hours[] = {0,23};</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">		if (minHour &lt;= maxHour) {</span>
<span class="nc" id="L943">			hours[0] = minHour;</span>
<span class="nc" id="L944">			hours[1] = maxHour;</span>
		}
<span class="nc" id="L946">		return hours;</span>
	}//getHoursArray


	/**
	 * calculate min and max day hours for HOOs in the m_timeRange days
	 * If HOO close 7days/week. return [0,0]
	 * Else return [0,23]
	 */
	private int[] getMinMaxHooHours(HOOAssignment hoo){
		// initialize min and max for hoo
<span class="nc" id="L957">		int minHoo = 23;</span>
<span class="nc" id="L958">		int maxHoo = 0;</span>
		//--- for each day in the m_timeRange
<span class="nc" id="L960">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L961">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc" id="L962">		boolean dstAdjustment = false;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange)) {</span>
			//   reset min and max hoo hours
<span class="nc" id="L965">			int[] minMaxHoo = getDayMinMaxHoo(aDay, hoo);</span>
<span class="nc bnc" id="L966" title="All 2 branches missed.">			if (minMaxHoo[0] &lt; minHoo)</span>
<span class="nc" id="L967">				minHoo = minMaxHoo[0];</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">			if (minMaxHoo[1] &gt; maxHoo)</span>
<span class="nc" id="L969">				maxHoo = minMaxHoo[1];</span>
			//QC46598 java bug for Brazil DST transition 10/18/09
<span class="nc" id="L971">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
//			aDay.nextDay();
<span class="nc" id="L973">		}//endwhile</span>

<span class="nc" id="L975">		maxHoo = adjustMaxHoursForDSTTransition(minHoo, maxHoo, tz);</span>
		//--- put results in the int array and return
<span class="nc" id="L977">		return getHoursArray(minHoo,maxHoo);</span>
	}//getMinMaxHooHours

	// On DST transition days, the timeline either includes an extra hour or is missing one hour
	private int adjustMaxHoursForDSTTransition(int min, int max, TimeZone tz) {
//		Calendar startCal = m_timeRange.getStartCalendar(tz, m_locale);
<span class="nc bnc" id="L983" title="All 2 branches missed.">		Calendar startCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartCalendar(tz, m_locale):findDSTTransitionDay(tz);</span>
<span class="nc" id="L984">		startCal.set(Calendar.HOUR_OF_DAY, min);</span>
<span class="nc" id="L985">		boolean startInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc" id="L986">		startCal.set(Calendar.HOUR_OF_DAY, max);</span>
<span class="nc" id="L987">		boolean endInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc bnc" id="L988" title="All 4 branches missed.">		if (startInDST &amp;&amp; !endInDST)  // one hour extra</span>
<span class="nc" id="L989">			return ++max;</span>
		else 
<span class="nc" id="L991">			return max;</span>
	}
	
	/**
	 * get min an max hour for HOO on a given day
	 */
	private int[] getDayMinMaxHoo(CalendarRange aDay, HOOAssignment hoo){
<span class="nc" id="L998">		int minHoo = 23;</span>
<span class="nc" id="L999">		int maxHoo = 0;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">		if (hoo != null) {</span>
			//London: ignore effectivity periods
			/*
			Date hooStart = hoo.getStartTime();
			Date hooEnd = (hoo.getEndTime()!=null)?hoo.getEndTime(): new Date(Long.MAX_VALUE); //open-ended
			TimeRange hooEffectivityRange = new TimeRange(hooStart,hooEnd);
			if (hooEffectivityRange.getOverlapDuration(aDay) &gt; 0) {
			*/
<span class="nc" id="L1008">			int startDayOfWeek = aDay.getStartCalendar().get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L1009">			minHoo = adjustMinHoo(minHoo, hoo, startDayOfWeek);</span>
<span class="nc" id="L1010">			minHoo = adjustMaxHoo(maxHoo, hoo, startDayOfWeek);</span>
<span class="nc" id="L1011">			int endDayOfWeek = aDay.getEndCalendar().get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L1012">			minHoo = adjustMinHoo(minHoo, hoo, endDayOfWeek);</span>
<span class="nc" id="L1013">			minHoo = adjustMaxHoo(maxHoo, hoo, endDayOfWeek);</span>
			//}
		} 
		//--- put results in the int array and return
<span class="nc" id="L1017">		return getHoursArray(minHoo,maxHoo);</span>
	}//getDayMinMaxHoo

	/**
	 * adjust minHoo if hoo starts earler
	 */
	private int adjustMinHoo(int minHoo, HOOAssignment hoo, int weekDay){
<span class="nc" id="L1024">		Integer iTmp = new Integer(weekDay);</span>
<span class="nc" id="L1025">		short tmp = iTmp.shortValue();</span>
<span class="nc" id="L1026">		short hooOpenMinute = hoo.getDayOpen(tmp);</span>
<span class="nc" id="L1027">		int hooOpenHour = hooOpenMinute/60;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">		return (hooOpenHour &lt; minHoo)? hooOpenHour : minHoo;</span>
	}//adjustMinHoo

	/**
	 * adjust maxHoo if hoo ends later
	 */
	private int adjustMaxHoo(int maxHoo, HOOAssignment hoo, int weekDay){
<span class="nc" id="L1035">		Integer iTmp = new Integer(weekDay);</span>
<span class="nc" id="L1036">		short tmp = iTmp.shortValue();</span>
<span class="nc" id="L1037">		short hooCloseMinute = hoo.getDayClose(tmp);</span>
<span class="nc" id="L1038">		int hooCloseHour = hooCloseMinute/60;</span>
<span class="nc bnc" id="L1039" title="All 2 branches missed.">		return (hooCloseHour &gt; maxHoo)? hooCloseHour : maxHoo;</span>
	}//adjustMaxHoo

	/**
	 * combine min/max hours for all events with HOO to determine shown hours
	 */
	private int[] combineMinMaxHours(int[] eventHoursRange, int[] hooHoursRange){

<span class="nc" id="L1047">		int minHour = 0;</span>
<span class="nc" id="L1048">		int maxHour = 0;</span>

<span class="nc bnc" id="L1050" title="All 6 branches missed.">		if (hooHoursRange[0] == 0 &amp;&amp; hooHoursRange[1] == 0</span>
				&amp;&amp; eventHoursRange[0] == 0){
<span class="nc" id="L1052">			minHour = eventHoursRange[0];</span>
<span class="nc" id="L1053">			maxHour = eventHoursRange[1];</span>
		}
		else {
<span class="nc" id="L1056">			minHour = Math.max(eventHoursRange[0], hooHoursRange[0]);</span>
<span class="nc" id="L1057">			maxHour = Math.min(eventHoursRange[1], hooHoursRange[1]);</span>
		}
<span class="nc" id="L1059">		return getHoursArray(minHour, maxHour);</span>
	}//combineMinMaxHours

	/**
	 * make page message if no published schedule available
	 */
	protected boolean messageIfNotPublished(Map theData){
<span class="fc" id="L1066">		boolean havePublished = isPublished(theData);</span>
<span class="fc bfc" id="L1067" title="All 2 branches covered.">		if (!havePublished){</span>
<span class="fc" id="L1068">			addPageMessage(Message.INFO_TYPE, FsWebBundleKey.MSG_SV_NONE_PUBLISHED,</span>
					FsWebBundleKey.BUNDLE_NAME);
		}
<span class="fc" id="L1071">		return havePublished;</span>
	}

	/**
	 * Gets whether the schedule has been published.
	 */
	public static boolean isPublished(Map theData) {
<span class="fc" id="L1078">		boolean havePublished = false;</span>
<span class="fc" id="L1079">		Collection publishedPeriods = (Collection)theData.get(ScheduleViewMH.PUB_PERIODS_KEY);</span>
		//we got either a collection of TimeRanges or
		//  collection of collections of TimeRanges for each employee in the group
		//search for a TimeRange
<span class="pc bpc" id="L1083" title="2 of 4 branches missed.">		if (publishedPeriods != null &amp;&amp; !publishedPeriods.isEmpty()) {</span>
<span class="fc bfc" id="L1084" title="All 2 branches covered.">			for (Iterator i = publishedPeriods.iterator();i.hasNext();){</span>
<span class="fc" id="L1085">				Object obj = i.next();</span>
<span class="fc bfc" id="L1086" title="All 2 branches covered.">				if (obj != null) {</span>
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">					if (obj instanceof Collection){</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">						if ( !((Collection)obj).isEmpty()){</span>
<span class="fc" id="L1089">							havePublished = true;  //assuming that contents are not all null</span>
<span class="fc" id="L1090">							break;</span>
						}
					} else {
<span class="nc" id="L1093">						havePublished = true;</span>
<span class="nc" id="L1094">						break;</span>
					}
				}
<span class="fc" id="L1097">			}</span>
		}
<span class="fc" id="L1099">		return havePublished;</span>
	}

	/**
	 * Add a tooltip to an HTML element
	 */
	public String addTooltip(String html, String tooltip)
	{
<span class="nc" id="L1107">	    return &quot;&lt;span title=\&quot;&quot; + tooltip + &quot;\&quot;&gt;&quot; + html + &quot;&lt;/span&gt;&quot;;</span>
	}

	/**
	 * make the swap link around the event label
	 */
	protected String makeSwappableLink(boolean bSwapEnabled, boolean isMyRow,
			boolean isTimeOff, CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings,
			ScheduleViewShiftDisplayInfo shiftDisplayInfo, ID employeeId){

<span class="pc bpc" id="L1117" title="1 of 2 branches missed.">        if (shiftDisplayInfo ==  null)</span>
<span class="nc" id="L1118">            return &quot;&quot;;</span>
        
<span class="fc" id="L1120">		StringBuffer sb = new StringBuffer(512);</span>

        //--- append the previous day icon if any
<span class="fc" id="L1123">        sb.append(shiftDisplayInfo.getPreviousDayIcon());</span>
        
		//--- swappable only starting tomorrow
<span class="pc bpc" id="L1126" title="3 of 4 branches missed.">		boolean isSwappable = bSwapEnabled &amp;&amp; aDay.getRelativeLocation(new Date())==TimeRange.TIME_BEFORE;</span>
<span class="pc bpc" id="L1127" title="3 of 4 branches missed.">		if (isSwappable &amp;&amp; isMyRow) </span>
		{
<span class="nc bnc" id="L1129" title="All 2 branches missed.">			String shiftType = isTimeOff ? ShiftSwapItem.SWAPITEMTYPE_TIMEOFF : ShiftSwapItem.SWAPITEMTYPE_SHIFT;</span>
<span class="nc" id="L1130">			String dateStr = getDatePickerDateDsp( aDay.getStartDate() );</span>
<span class="nc" id="L1131">			String onClickJS = &quot;pageMediator.handleSwap('&quot; + shiftType  + &quot;', '&quot; + dateStr + &quot;');&quot;;</span>
<span class="nc" id="L1132">            String swapLabel = i18n(m_bundle,FsWebBundleKey.SV_SWAP_MY_SHIFT_LABEL) +  &quot; &quot; + shiftDisplayInfo.getShiftString(); //508</span>
<span class="nc" id="L1133">            sb.append(HtmlLinkUtil.createActiveLink(&quot;&quot;, shiftDisplayInfo.getShiftString(), swapLabel, swapLabel, null, onClickJS)); //508</span>
<span class="nc" id="L1134">		} </span>
        else 
        {
			//--- put shift or day off label with optional times
<span class="fc" id="L1138">			sb.append(shiftDisplayInfo.getShiftString());</span>
		}
        
        //--- append the next day icon if any
<span class="pc bpc" id="L1142" title="1 of 2 branches missed.">		if (!StringUtil.isEmpty(shiftDisplayInfo.getNextDayIcon())) {</span>
<span class="nc" id="L1143">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1144">			sb.append(shiftDisplayInfo.getNextDayIcon());</span>
		}
        
        //append pooling icon if applicable
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getPoolingActivityIcon())) {</span>
<span class="nc" id="L1149">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1150">        	sb.append(shiftDisplayInfo.getPoolingActivityIcon());</span>
        }
        
        //append calendar event icon if applicable
<span class="pc bpc" id="L1154" title="1 of 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getCalendarEventIcon())) {</span>
<span class="nc" id="L1155">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1156">        	sb.append(shiftDisplayInfo.getCalendarEventIcon());</span>
        }
        
        //append overtime icon if applicable
<span class="pc bpc" id="L1160" title="1 of 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getOvertimeIcon())) {</span>
<span class="nc" id="L1161">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1162">        	sb.append(shiftDisplayInfo.getOvertimeIcon());</span>
        }
<span class="pc bpc" id="L1164" title="1 of 2 branches missed.">        if(bSwapEnabled)</span>
		//--- find if there is a posting for this user for this day
<span class="nc" id="L1166">        	appendPostingImg(aDay,postings,employeeId, sb, shiftDisplayInfo.getShiftString());</span>

<span class="fc" id="L1168">		return sb.toString();</span>
	}//makeSwappableLink

	/**
	 * make the swap link around the event label
	 * @param tooltip - The tooltip for the shift (not for the swap link). 
  	 */
	protected String makeSwappableLink(boolean bSwapEnabled, boolean isMyRow,
			boolean isTimeOff, CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings,
			String eventLabel, String tooltip, ID employeeId)
	{
<span class="nc" id="L1179">		StringBuffer sb = new StringBuffer(512);</span>

		//--- swappable only starting tomorrow
<span class="nc bnc" id="L1182" title="All 4 branches missed.">		boolean isSwappable = bSwapEnabled &amp;&amp; aDay.getRelativeLocation(new Date())==TimeRange.TIME_BEFORE;</span>
<span class="nc bnc" id="L1183" title="All 4 branches missed.">		if (isSwappable &amp;&amp; isMyRow) </span>
		{
<span class="nc bnc" id="L1185" title="All 2 branches missed.">			String shiftType = isTimeOff ? ShiftSwapItem.SWAPITEMTYPE_TIMEOFF : ShiftSwapItem.SWAPITEMTYPE_SHIFT;</span>
<span class="nc" id="L1186">			String dateStr = getDatePickerDateDsp( aDay.getStartDate() );</span>
<span class="nc" id="L1187">			String onClickJS = &quot;pageMediator.handleSwap('&quot; + shiftType  + &quot;', '&quot; + dateStr + &quot;');&quot;;</span>
<span class="nc" id="L1188">			sb.append(HtmlLinkUtil.createActiveLink(eventLabel, tooltip, null, onClickJS));</span>
<span class="nc" id="L1189">		} </span>
		else 
		{
			//--- put shift or day off label with optional times
<span class="nc" id="L1193">			sb.append(addTooltip(eventLabel, tooltip));</span>
		}

		//--- find if there is a posting for this user for this day
<span class="nc bnc" id="L1197" title="All 2 branches missed.">		if(bSwapEnabled)</span>
<span class="nc" id="L1198">			appendPostingImg(aDay,postings,employeeId, sb);</span>

<span class="nc" id="L1200">		return sb.toString();</span>
	}//makeSwappableLink
		
	/**
	 * Initialize Posting Image
	 */
	private synchronized static void initPostingIMG() {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">		if (POSTING_IMG==null) {</span>
<span class="nc" id="L1208">			POSTING_IMG = &quot;&lt;img border=\&quot;0\&quot; src=\&quot;&quot; + FsImageFileID.RED_FLAG + &quot;\&quot; hspace=\&quot;3\&quot;&gt;&quot;;</span>
		}
<span class="nc" id="L1210">	}</span>


	/**
	 * Append Posting Images
	 *
	 * @param aDay
	 * @param postings
	 * @param eID
	 * @param sb StringBuffer to append content to
     * @param eventLabel - this event label will be used to construct a label for the posting link.
	 */
	protected void appendPostingImg(CalendarRange aDay, Collection postings, ID eID, StringBuffer sb,
            String eventLabel) {
<span class="nc bnc" id="L1224" title="All 6 branches missed.">		if (aDay != null &amp;&amp; postings != null &amp;&amp; postings.size() &gt; 0) {</span>
<span class="nc" id="L1225">			boolean isMine = eID.equals(m_myEmpID);</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">			if (POSTING_IMG==null) initPostingIMG();</span>

<span class="nc bnc" id="L1228" title="All 2 branches missed.">			for (Iterator it = postings.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1229">				ShiftSwapPosting posting = (ShiftSwapPosting)it.next();</span>
<span class="nc bnc" id="L1230" title="All 4 branches missed.">				if (posting != null &amp;&amp; posting.getShiftSwapItem() != null </span>
<span class="nc bnc" id="L1231" title="All 2 branches missed.">						&amp;&amp; aDay.includes(posting.getStartDate())</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">						&amp;&amp; posting.getExpirationDate().after(new Date())</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">						&amp;&amp; posting.getEmployeeID().equals(eID)){</span>
<span class="nc" id="L1234">					String postingID = posting.getID().toString();</span>
<span class="nc" id="L1235">					String onClickJS=&quot;pageMediator.handlePosting('&quot; + postingID + &quot;', &quot; + isMine + &quot;);&quot;;</span>
                    
                    //For 508 Accessibility, we're creating a label for the posting link
<span class="nc" id="L1238">                    String label = &quot;&quot;;</span>
<span class="nc bnc" id="L1239" title="All 2 branches missed.">                    if (isMine)</span>
<span class="nc" id="L1240">                        label = i18n(m_bundle,FsWebBundleKey.SV_EDIT_POSTING_LABEL) + &quot; &quot; + eventLabel; </span>
                    else
<span class="nc" id="L1242">                        label = i18n(m_bundle,FsWebBundleKey.SV_SWAP_WITH_SHIFT_LABEL) +  &quot; &quot; + eventLabel; </span>

<span class="nc" id="L1244">                    sb.append(HtmlLinkUtil.createActiveLink(&quot;&quot;, POSTING_IMG, label, label, null, onClickJS));</span>
				}
<span class="nc" id="L1246">			}</span>
		}
<span class="nc" id="L1248">	}//appendPostingIcons</span>
    
	protected void appendPostingImg(CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings, ID eID, StringBuffer sb) {
<span class="nc bnc" id="L1251" title="All 6 branches missed.">		if (aDay != null &amp;&amp; postings != null &amp;&amp; postings.size() &gt; 0) {</span>
<span class="nc" id="L1252">			boolean isMine = eID.equals(m_myEmpID);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">			if (POSTING_IMG==null) initPostingIMG();</span>

<span class="nc bnc" id="L1255" title="All 2 branches missed.">			for (Iterator&lt;ShiftSwapPosting&gt; it = postings.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1256">				ShiftSwapPosting posting = it.next();</span>
<span class="nc bnc" id="L1257" title="All 4 branches missed.">				if (posting != null &amp;&amp; posting.getShiftSwapItem() != null </span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">						&amp;&amp; aDay.includes(posting.getStartDate())</span>
<span class="nc bnc" id="L1259" title="All 2 branches missed.">						&amp;&amp; posting.getExpirationDate().after(new Date())</span>
<span class="nc bnc" id="L1260" title="All 2 branches missed.">						&amp;&amp; posting.getEmployeeID().equals(eID)){</span>
<span class="nc" id="L1261">					String postingID = posting.getID().toString();</span>
<span class="nc" id="L1262">					String onClickJS=&quot;pageMediator.handlePosting('&quot; + postingID + &quot;', &quot; + isMine + &quot;);&quot;;</span>
<span class="nc" id="L1263">					sb.append(HtmlLinkUtil.createActiveLink(POSTING_IMG, null, null, onClickJS));</span>
				}
<span class="nc" id="L1265">			}</span>
		}
<span class="nc" id="L1267">	}//appendPostingIcons</span>
		
	/**
	 * Return Date as a String which id Date Picker Compatitle
	 */
	private String getDatePickerDateDsp(Date date) {
<span class="nc bnc" id="L1273" title="All 2 branches missed.">		if (m_datePicker==null) m_datePicker = new DatePickerPC(m_context, &quot;&quot;);</span>
<span class="nc" id="L1274">		m_datePicker.setDate(date);</span>
<span class="nc" id="L1275">		return m_datePicker.getDateDisplay();</span>
	}

	/**
	 * make html string with the shift information and the swap link
     * @param campaignIdNames - Map of campaignID-&gt;campaignName.
     * @return StringsPair - first is the shiftString, second is the campaignName.
	 */
	protected StringsPair makeShiftString(CalendarRange aDay, Collection&lt;ShiftAssignment&gt; shifts, HashMap&lt;ID, Activity&gt; activities,
									 Collection&lt;ShiftSwapPosting&gt; postings, Collection&lt;DailyScheduleSummary&gt; daySummaries, 
									 boolean bSwapEnabled, boolean isMy, ID empID, boolean bShowTimeoff,
									 Map&lt;ID, String&gt; campaignNamesBySpID) 
	{
<span class="nc" id="L1288">		StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L1289">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L1290">		DailyScheduleSummary daySchedule = null;</span>
<span class="nc" id="L1291">		ScheduleViewShiftDisplayInfo shiftLabel = null;</span>
        
<span class="nc" id="L1293">		String tooltip = &quot;&quot;;</span>
<span class="nc" id="L1294">		String campaignName = &quot;&quot;;</span>
		
<span class="nc bnc" id="L1296" title="All 2 branches missed.">		if (shifts != null) {</span>
<span class="nc bnc" id="L1297" title="All 2 branches missed.">			for(Iterator&lt;DailyScheduleSummary&gt; it = daySummaries.iterator(); it.hasNext();) {</span>
				//entries &quot;unpublished&quot; or &quot;no shift&quot; or &quot;hh:mm am - hh:mm pm&quot;
<span class="nc" id="L1299">				DailyScheduleSummary oneDaySchedule = it.next();</span>
<span class="nc" id="L1300">				CalendarRange daySummaryDay = oneDaySchedule.getDayRange();</span>
				
				// NOTE: we really should be comparing the calendar range objects
				// however, the end dates (by 1 second) and the locales are actually different 
<span class="nc" id="L1304">				Calendar startOfDay = DateTimeUtil.getDayStart(aDay.getStartCalendar());</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">				if (!startOfDay.getTime().equals(daySummaryDay.getStartDate())) {</span>
<span class="nc" id="L1306">					continue;</span>
				}
<span class="nc" id="L1308">                campaignName = ScheduleViewUtil.getCampaignName(campaignNamesBySpID, oneDaySchedule);</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">                campaignName = campaignName==null?&quot;&quot;:campaignName;</span>
                
                // Only supply the tool tip if it is associated to a campaign.
<span class="nc bnc" id="L1312" title="All 2 branches missed.">                if (campaignName.length() &gt; 0) {</span>
<span class="nc" id="L1313">                	tooltip = verticalize(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN)  + campaignName;</span>
                }
                //tooltip = i18n(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN) + campaignName;

<span class="nc" id="L1317">                daySchedule = oneDaySchedule;  // save this for making overtime strings.</span>

<span class="nc bnc" id="L1319" title="All 2 branches missed.">				if (!oneDaySchedule.isPublished()) {</span>
<span class="nc" id="L1320">					return new StringsPair(i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_UNPUBLISHED), &quot;&quot;);</span>
				} 
<span class="nc bnc" id="L1322" title="All 2 branches missed.">				else if (oneDaySchedule.isClosed()) {</span>
<span class="nc" id="L1323">					return new StringsPair(i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_CLOSED), campaignName);</span>
				} 
<span class="nc bnc" id="L1325" title="All 6 branches missed.">				else if ((bShowTimeoff || isMy) &amp;&amp; oneDaySchedule.isDayOff()) {</span>
<span class="nc" id="L1326">					String defaultAbsentString= i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_DAY_OFF);</span>
<span class="nc" id="L1327">					String absentStringOverride = ScheduleSummaryMH.getAbsentStringOverride();</span>
<span class="nc bnc" id="L1328" title="All 4 branches missed.">					if(absentStringOverride!=null&amp;&amp; absentStringOverride.equals(FsWebBundleKey.FS_CUSTOM_TIME_OFF)) //The value is specific for France Telecom, Story 34046</span>
<span class="nc" id="L1329">						absentStringOverride = i18n(m_bundle,FsWebBundleKey.FS_CUSTOM_TIME_OFF);</span>
<span class="nc bnc" id="L1330" title="All 2 branches missed.">					String shiftLabel1 = absentStringOverride==null ? defaultAbsentString: absentStringOverride;</span>
<span class="nc" id="L1331">					sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel1,tooltip,empID));</span>
<span class="nc" id="L1332">					return new StringsPair(sb.toString(),campaignName);</span>
				} 
                else {
<span class="nc bnc" id="L1335" title="All 4 branches missed.">                    if (oneDaySchedule.hasShift() &amp;&amp; !oneDaySchedule.isDayOff()) {      </span>
<span class="nc" id="L1336">						shiftLabel =  getShiftDisplayInfo(oneDaySchedule, m_localizer, tz);</span>
					} 
                    else {
<span class="nc" id="L1339">                    	shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1340">						sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID)); //&quot;Off&quot;</span>
<span class="nc" id="L1341">						return new StringsPair(sb.toString(),campaignName);</span>
					}
				}
<span class="nc" id="L1344">			}//for</span>

<span class="nc" id="L1346">			boolean foundShift = false;</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">			for (ShiftAssignment event : shifts) {</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">				if (event!=null) {</span>
<span class="nc" id="L1349">					TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1350">					int overlapType = aDay.getRelativeLocationTo(eventRange);</span>
<span class="nc bnc" id="L1351" title="All 6 branches missed.">					if (overlapType == TimeRange.INTERVAL_COVERS</span>
							|| overlapType == TimeRange.INTERVAL_EQUALS
							|| overlapType == TimeRange.INTERVAL_BEFORE_AND_IN) 
					{
<span class="nc" id="L1355">						foundShift = true;</span>
<span class="nc" id="L1356">						Activity activity = (Activity)activities.get(event.getActivityID());</span>
<span class="nc" id="L1357">						sb.append(addTooltip(ShiftUtil.makeActivityBox(activity),tooltip))</span>
<span class="nc" id="L1358">								.append(&quot; &quot;)</span>
<span class="nc" id="L1359">								.append(makeSwappableLink(bSwapEnabled,isMy,false,aDay,postings,shiftLabel,empID));</span>
                        
<span class="nc" id="L1361">						sb.append(makeShiftOvertimeString(aDay, daySchedule, event, tz, m_localizer, true, false));</span>
<span class="nc" id="L1362">						break;</span>
					}
				}
<span class="nc" id="L1365">			}//for</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">			if (!foundShift) {</span>
<span class="nc" id="L1367">				shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1368">				sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID));</span>
			}            
<span class="nc" id="L1370">		} </span>
		else {
<span class="nc" id="L1372">			shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1373">			sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID));</span>
		}
<span class="nc" id="L1375">		return new StringsPair(sb.toString(), campaignName);</span>
	}//makeShiftString
	
    /**
     * See if the specified employee ID is the ID of the currently logged-in user.
     * @param empID The employee ID to check.
     * @return true if the specified employee ID is the ID of the currently logged-in user.
     */
    protected boolean isMyID(ID empID)
    {
<span class="fc" id="L1385">        return m_myEmpID.equals(empID);</span>
    }
    
	/**
	 * make html string with shift overtime periods or empty string
	 * @param event - shift assignment 
	 * @return - html formatted string starting with &lt;br&gt; (if includeHtmlMarkup is true)
	 */
	public static String makeShiftOvertimeString(CalendarRange aDayRange,
			DailyScheduleSummary daySchedule,
			ShiftAssignment shiftAssignment,
			TimeZone timeZone,
			Localizer localizer,
			boolean includeHtmlMarkup,
			boolean includeActivityNames) {
<span class="nc" id="L1400">		StringBuffer sb = new StringBuffer();</span>
	
<span class="nc" id="L1402">		boolean overtimeDisplayed = false;</span>
<span class="nc" id="L1403">		TimeRange beforeExTimeRange = ScheduleViewUtil.getExtensionBeforeTimeRange(shiftAssignment);</span>
<span class="nc" id="L1404">		TimeRange afterExTimeRange = ScheduleViewUtil.getExtensionAfterTimeRange(shiftAssignment);</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">		if(beforeExTimeRange != null) {</span>
<span class="nc bnc" id="L1406" title="All 2 branches missed.">			if (includeHtmlMarkup) {</span>
<span class="nc" id="L1407">				sb.append(&quot;&lt;br&gt;&quot;);</span>
			}
<span class="nc" id="L1409">			sb.append(localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.OVERTIME_PROMPT)).append(&quot; &quot;);</span>
<span class="nc" id="L1410">			String timeRangeStr = ShiftUtil.makeShiftDatesString(aDayRange,</span>
<span class="nc" id="L1411">					beforeExTimeRange.getStartDate(), beforeExTimeRange.getEndDate(),</span>
					localizer, timeZone);
<span class="nc bnc" id="L1413" title="All 2 branches missed.">			if (includeActivityNames) {</span>
<span class="nc" id="L1414">				Activity activity = daySchedule.getOvertimeActivityForTimeRange(beforeExTimeRange);</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">				if (activity != null) {</span>
<span class="nc" id="L1416">					sb.append(localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.SV_ACTIVITY_NAME_AND_TIME_RANGE,</span>
<span class="nc" id="L1417">							new Object[]{timeRangeStr, activity.getName()}));</span>
				} else {
<span class="nc" id="L1419">					sb.append(timeRangeStr);</span>
				}
<span class="nc" id="L1421">			} else {</span>
<span class="nc" id="L1422">				sb.append(timeRangeStr);</span>
			}
<span class="nc" id="L1424">			overtimeDisplayed = true;</span>
		}
<span class="nc bnc" id="L1426" title="All 2 branches missed.">		if(afterExTimeRange != null) {</span>
<span class="nc bnc" id="L1427" title="All 2 branches missed.">			if (overtimeDisplayed) {</span>
<span class="nc" id="L1428">				sb.append(&quot;, &quot;);</span>
			} else {
<span class="nc bnc" id="L1430" title="All 2 branches missed.">				if (includeHtmlMarkup) {</span>
<span class="nc" id="L1431">					sb.append(&quot;&lt;br&gt;&quot;);</span>
				}
<span class="nc" id="L1433">				sb.append(localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.OVERTIME_PROMPT)).append(&quot; &quot;);</span>
			}
<span class="nc" id="L1435">			String timeRangeStr = ShiftUtil.makeShiftDatesString(aDayRange,</span>
<span class="nc" id="L1436">					afterExTimeRange.getStartDate(), afterExTimeRange.getEndDate(),</span>
					localizer, timeZone);
<span class="nc bnc" id="L1438" title="All 2 branches missed.">			if (includeActivityNames) {</span>
<span class="nc" id="L1439">				Activity activity = daySchedule.getOvertimeActivityForTimeRange(afterExTimeRange);</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">				if (activity != null) {</span>
<span class="nc" id="L1441">					sb.append(localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.SV_ACTIVITY_NAME_AND_TIME_RANGE,</span>
<span class="nc" id="L1442">							new Object[]{timeRangeStr, activity.getName()}));</span>
				} else {
<span class="nc" id="L1444">					sb.append(timeRangeStr);</span>
				}
<span class="nc" id="L1446">			} else {</span>
<span class="nc" id="L1447">				sb.append(timeRangeStr);</span>
			}
		}
<span class="nc" id="L1450">		return sb.toString();</span>
	}//makeShiftOvertimeString
	/**
	 * make html string with the shift and/or calendar events information for the text view
	 */
	protected String makeEventsString(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule, HashMap&lt;ID, Activity&gt; activities,
			boolean bShowUnavailable, boolean bShowTimeoff, boolean bShowNote, boolean isMy){
	
<span class="nc" id="L1458">		return makeEventsString(aDay,schedule,activities,bShowUnavailable,bShowTimeoff,bShowNote,isMy,true);</span>
	}//makeEventsString
	/**
	 * make html string with the shift and/or calendar events information for the text view
	 * @param isShowAbsentReason to indicate if the Absent Reason is displayed or not
	 */
	protected String makeEventsString(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule, HashMap&lt;ID, Activity&gt; activities,
			boolean bShowUnavailable, boolean bShowTimeoff, boolean bShowNote, boolean isMy, boolean isShowAbsentReason){
<span class="nc" id="L1466">		String result = &quot;&quot;;</span>

		//--- make collection of events for this day (need it since the styles for different rows may differ)
<span class="nc" id="L1469">		ArrayList&lt;Event&gt; dayEventList = selectDayEvents(aDay,schedule);</span>
<span class="nc bnc" id="L1470" title="All 4 branches missed.">		if (dayEventList != null &amp;&amp; !dayEventList.isEmpty()) {</span>
<span class="nc bnc" id="L1471" title="All 4 branches missed.">			result = ShiftUtil.makeActivitiesString(aDay, dayEventList,</span>
<span class="nc" id="L1472">					 bShowUnavailable, bShowTimeoff||isMy, bShowNote, activities, m_localizer, m_context.getViewingTimeZone(),isShowAbsentReason);</span>
		}

<span class="nc" id="L1475">		return result;</span>
	}//makeEventsString
	
	/**
	 * Creates and returns a string representing an HTML snippet used
	 * to render the campaign name associated to an activity of a shift.
	 */
	protected String makeCampaignActivityString(CalendarRange aDay, Collection&lt;DailyScheduleSummary&gt; daySummaries,
			Collection&lt;ShiftAssignment&gt; shifts, Collection&lt;SimpleEvent&gt; schedule, Map&lt;ID, Activity&gt; activities,
			Map&lt;ID, String&gt; campaignNamesBySpID, boolean bShowUnavailable, boolean bShowTimeoff) {
		
<span class="nc" id="L1486">		ArrayList&lt;Event&gt; dayEvents = selectDayEvents(aDay, schedule);		</span>
<span class="nc" id="L1487">		DailyScheduleSummary daySummary = selectDayScheduleSummary(aDay, daySummaries);</span>
		
<span class="nc" id="L1489">		return ShiftUtil.makeCampaignActivityString(aDay, daySummary, shifts, dayEvents,</span>
				activities, campaignNamesBySpID, bShowUnavailable, 
                bShowTimeoff);
	}

	/**
	 * select schedule events only for the given day
	 * @param aDay
	 * @param schedule - schedule events
	 * @return ArrayList of schedule events other than shifts overlapping aDay
	 */
	public static ArrayList&lt;Event&gt; selectDayEvents(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule) {
<span class="nc bnc" id="L1501" title="All 4 branches missed.">		if (schedule == null || schedule.size() &lt; 1) {</span>
<span class="nc" id="L1502">			return null;</span>
		}
<span class="nc" id="L1504">		ArrayList&lt;Event&gt; daySchedule = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L1505" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; i = schedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1506">			Event event = i.next();</span>
<span class="nc bnc" id="L1507" title="All 2 branches missed.">			if (event != null){</span>
<span class="nc" id="L1508">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1509">				int overlapType = aDay.getRelativeLocationTo(eventRange);</span>
<span class="nc bnc" id="L1510" title="All 4 branches missed.">				if (overlapType != TimeRange.INTERVAL_AFTER &amp;&amp; overlapType != TimeRange.INTERVAL_BEFORE) {</span>
<span class="nc" id="L1511">					daySchedule.add(event);</span>
				}
			}
<span class="nc" id="L1514">		}//for</span>
<span class="nc" id="L1515">		return daySchedule;</span>
	}//selectDayEvents
	
	/**
	 * 
	 */
	public static DailyScheduleSummary selectDayScheduleSummary(CalendarRange aDay, Collection&lt;DailyScheduleSummary&gt; daySummaries) {
<span class="nc bnc" id="L1522" title="All 2 branches missed.">		for(DailyScheduleSummary oneDaySchedule : daySummaries) </span>
		{
			//entries &quot;unpublished&quot; or &quot;no shift&quot; or &quot;hh:mm am - hh:mm pm&quot;
<span class="nc" id="L1525">			CalendarRange daySummaryDay = oneDaySchedule.getDayRange();</span>
			
			// NOTE: we really should be comparing the calendar range objects
			// however, the end dates (by 1 second) and the locales are actually different 
<span class="nc bnc" id="L1529" title="All 2 branches missed.">			if (aDay.getStartDate().equals(daySummaryDay.getStartDate())) {</span>
<span class="nc" id="L1530">				return oneDaySchedule;</span>
			}
<span class="nc" id="L1532">		}</span>
		
<span class="nc" id="L1534">		return null;</span>
	}

	/**
	 * make a row for the list display of the date
	 */
	protected DefaultMultiColumnNodeData makeLeftRowForGraph(CalendarRange aDay) {
<span class="nc" id="L1541">		String strDate = m_localizer.formatDate(aDay.getStartCalendar().getTime(),</span>
<span class="nc" id="L1542">				m_context.getViewingTimeZone(),</span>
				RegionalFormatBundleKey.DATE_DAYINWEEK_FORMAT);
<span class="nc" id="L1544">		return makeLeftRowStringForGraph(strDate);</span>
	}
	
	/**
	 * make a row in the date column, but instead of a date, you can show any string.
	 */
	protected DefaultMultiColumnNodeData makeLeftRowStringForGraph(String str) {
<span class="nc" id="L1551">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L1552">		rowData.add(str, CSSUtil.STYLE_NOWRAP);</span>
<span class="nc" id="L1553">		rowData.setSelectable(false);</span>
<span class="nc" id="L1554">		return rowData;</span>
	}
	protected DefaultMultiColumnNodeData makeRightRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, int[] shownHours, 
			Collection&lt;SimpleEvent&gt; schedule, HashMap&lt;ID, Activity&gt; activities, boolean bShowUnavailable, 
			boolean bShowTimeoff, int rowIndex, boolean isMy, Collection&lt;DailyScheduleSummary&gt; empDaySummaries, 
			Map&lt;ID, String&gt; campaignNamesBySpID, dstTransitionMode mode, int dstTransitionHour) {
<span class="nc" id="L1561">		return makeRightRowForGraph(context,sbJS,aDay,shownHours,schedule,activities,bShowUnavailable,</span>
				bShowTimeoff,rowIndex,isMy,empDaySummaries,campaignNamesBySpID,mode,dstTransitionHour,true);
	}
	
	/**
	 * make a row for the multicolumn list display of the schedule events in Graph view.
	 * @param empDaySummaries - the collection of DailyScheduleSummary's for the employee
	 */
	protected DefaultMultiColumnNodeData makeRightRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, int[] shownHours, 
			Collection&lt;SimpleEvent&gt; schedule, HashMap&lt;ID, Activity&gt; activities, boolean bShowUnavailable, 
			boolean bShowTimeoff, int rowIndex, boolean isMy, Collection&lt;DailyScheduleSummary&gt; empDaySummaries, 
			Map&lt;ID, String&gt; campaignNamesBySpID, ScheduleViewPM.dstTransitionMode mode, int dstTransitionHour,boolean isShowAbsentReason) 
	{ 
<span class="nc" id="L1575">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L1576">		TimeZone tz = context.getViewingTimeZone();</span>
		
		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L1579">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L1580">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L1581">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>
		
		//--- make the row with one empty cell ---
<span class="nc" id="L1584">		rowData.add(&quot;&amp;nbsp;&quot;);		</span>
<span class="nc" id="L1585">		rowData.setNodeAttribute(&quot;style&quot;, &quot;font-size:0px&quot;);</span>

		//--- generate JS object with the data for the row ---
<span class="nc" id="L1588">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L1589">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,false));&quot;);</span>
		
		//for each event in the flattened schedule for this day
<span class="nc" id="L1592">		int eventStartIndex = -1;</span>
<span class="nc" id="L1593">		int eventEndIndex = -1;</span>
<span class="nc" id="L1594">		int newEventStartIndex = -1;</span>
<span class="nc" id="L1595">		int newEventEndIndex = -1;</span>
<span class="nc" id="L1596">		String eventColor = &quot;&quot;;</span>
<span class="nc" id="L1597">		String eventPattern = &quot;&quot;;</span>
	
<span class="nc" id="L1599">		boolean isDayStartDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L1600">		boolean isDayEndDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L1601" title="All 2 branches missed.">		boolean dayIsDSTDay = isDayStartDST != isDayEndDST;</span>

<span class="nc bnc" id="L1603" title="All 2 branches missed.">		boolean isPeriodIncDST = tz.inDaylightTime(m_timeRange.getStartDate()) != tz.inDaylightTime(m_timeRange.getEndDate());</span>
		
<span class="nc bnc" id="L1605" title="All 2 branches missed.">		for (Iterator&lt;SimpleEvent&gt; i = schedule.iterator(); i.hasNext();)</span>
		{
<span class="nc" id="L1607">			SimpleEvent scheduleEvent = i.next();</span>
<span class="nc bnc" id="L1608" title="All 4 branches missed.">			if (scheduleEvent.getStartTime().after(aDay.getEndDate()) || scheduleEvent.getEndTime().before(aDay.getStartDate()))</span>
<span class="nc" id="L1609">				continue; //not overlap with the day, no painting.</span>

<span class="nc bnc" id="L1611" title="All 4 branches missed.">			if (scheduleEvent != null</span>
<span class="nc bnc" id="L1612" title="All 6 branches missed.">					&amp;&amp; (bShowUnavailable || scheduleEvent.getEventType() != Event.EVENT_TYPE_UNAVAILABILITY)</span>
<span class="nc bnc" id="L1613" title="All 2 branches missed.">					&amp;&amp; (bShowTimeoff || isMy || scheduleEvent.getEventType() != Event.EVENT_TYPE_TIME_OFF)) </span>
			{
<span class="nc" id="L1615">				TimeRange eventRange = ScheduleViewUtil.eventRange(scheduleEvent);</span>
<span class="nc" id="L1616">				Calendar eventStartCal = eventRange.getStartCalendar(tz,null);</span>
<span class="nc" id="L1617">				Calendar eventEndCal = eventRange.getEndCalendar(tz,null);</span>
<span class="nc" id="L1618">				eventStartIndex =  makeMinuteIndex(aDay, eventStartCal, firstShownIndex, lastShownIndex, mode, isDayStartDST, dstTransitionHour);</span>
<span class="nc" id="L1619">				eventEndIndex =  makeMinuteIndex(aDay, eventEndCal, firstShownIndex, lastShownIndex, mode, isDayStartDST, dstTransitionHour);</span>
				
<span class="nc bnc" id="L1621" title="All 2 branches missed.">				if (eventStartIndex == PREV_DAY_INDEX) {</span>
					//event start at previous day, paining cross day event.
<span class="nc" id="L1623">					eventStartIndex =0;</span>
				}
				
<span class="nc bnc" id="L1626" title="All 2 branches missed.">				if (eventEndIndex &gt; gridWidth)  </span>
<span class="nc" id="L1627">				    eventEndIndex = gridWidth;</span>

<span class="nc bnc" id="L1629" title="All 4 branches missed.">				if (eventStartIndex &lt; gridWidth+1 &amp;&amp; eventEndIndex != PREV_DAY_INDEX)</span>
				{
<span class="nc" id="L1631">					boolean eventStartIsDST = tz.inDaylightTime(eventStartCal.getTime());</span>
<span class="nc" id="L1632">					boolean eventEndIsDST = tz.inDaylightTime(eventEndCal.getTime());				</span>
<span class="nc" id="L1633">					int dstSavings = tz.getDSTSavings()/(60*1000);</span>
					
<span class="nc bnc" id="L1635" title="All 4 branches missed.">					switch(mode) {</span>
					case FALLBACK:
<span class="nc bnc" id="L1637" title="All 6 branches missed.">						if (!dayIsDSTDay &amp;&amp; isPeriodIncDST &amp;&amp; getViewType().equals(VIEW_TYPE_MY_GRAPH)) {</span>
							//The Personal Graph view can show multiple days at once, but if one of those days is the
							//Fall DST transition, then all of the days will show two 1AM's. Only the transition day
							//will actually have data in the 2nd 1AM. For the other days, we need to break up any
							//events that start before the 2nd 1AM and end after the 2nd 1AM, so that nothing is 
							//graphed during the 2nd 1AM hour.
<span class="nc bnc" id="L1643" title="All 4 branches missed.">							if ((eventStartIndex &lt; dstTransitionHour*60) &amp;&amp; (eventEndIndex &gt;= dstTransitionHour*60)) {</span>
<span class="nc" id="L1644">								newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L1645">								eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L1646">								newEventStartIndex = eventEndIndex + dstSavings;</span>
							}							
						}						
						
						break;
					case SPRINGFORWARD:
<span class="nc bnc" id="L1652" title="All 6 branches missed.">						if (dayIsDSTDay &amp;&amp; eventEndIsDST &amp;&amp; !eventStartIsDST) {</span>
							//The Personal and Group Graph views will always include 2AM, even if the only day in the view
							//is the Spring DST transition, which is supposed to skip 2AM. The DST transition day
							//will have no data in the 2AM hour, so we need to break up any events that start before 
							//2AM and end after the on or after 3AM, so that nothing is graphed during the 2AM hour.
<span class="nc" id="L1657">							newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L1658">							eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L1659">							newEventStartIndex = eventEndIndex + dstSavings;</span>
						}
					case NEUTRAL:
<span class="nc" id="L1662">						break;</span>
					default:
						break;
					}
					
					//event overlaps with the shown hrs
<span class="nc" id="L1668">					Activity eventActivity = getEventActivity(scheduleEvent,activities);</span>
<span class="nc" id="L1669">					eventColor = eventActivity.getColor();</span>
                    
<span class="nc bnc" id="L1671" title="All 4 branches missed.">                    if (scheduleEvent.isOvertime() &amp;&amp; (scheduleEvent.getEventType()!=Event.EVENT_TYPE_TIME_OFF))</span>
<span class="nc" id="L1672">                        eventPattern = FsImageFileID.OT_PATTERN;</span>
                    else
<span class="nc" id="L1674">                        eventPattern = &quot;null&quot;;</span>
                    
<span class="nc" id="L1676">                    String eventTooltip = getEventTooltip(aDay, scheduleEvent, eventActivity, eventPattern, eventRange, empDaySummaries, campaignNamesBySpID, tz);</span>
<span class="nc" id="L1677">                    String nsValue = &quot;SE&quot;; //tells us the cell type: &quot;SE&quot;=Schedule Event, &lt;0=NS Shortage, 0=NS Neutral, &gt;0=NS Surplus</span>
<span class="nc" id="L1678">                    String nsID = &quot;&quot;; //The cell ID which countains row and column numbers (used for Net Staffing cells only).</span>
                    
                    // do not display the event if it has an unavailability type activity, reset to show just the shift assignment
<span class="nc bnc" id="L1681" title="All 2 branches missed.">    				if (ShiftUtil.isEventUnavailabilityType(eventActivity, scheduleEvent, bShowUnavailable)</span>
    						//Story34045- PSR 6104 - Reason for Absence viewable only by Supervisor
<span class="nc bnc" id="L1683" title="All 4 branches missed.">    						|| (eventActivity.isTimeoff() &amp;&amp;!isShowAbsentReason)) {</span>
    					
<span class="nc" id="L1685">    					eventPattern = &quot;&quot;;</span>
<span class="nc" id="L1686">    					eventColor = &quot;0000FF&quot;;</span>
<span class="nc" id="L1687">    					eventTooltip = &quot;&quot;;</span>
    				}
                    
					// create JS ScheduleEvent object and add it to calendarGrid.rows[rowIndex]
<span class="nc" id="L1691">					sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L1692">							.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L1693">							.append(eventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L1694">							.append(eventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1695">							.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1696">							.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1697">							.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)							</span>
<span class="nc" id="L1698">							.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1699">							.append(eventRange.getStartDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1700">							.append(eventRange.getEndDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1701">							.append(nsValue).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1702">					        .append(nsID).append(&quot;\&quot;)&quot;);</span>
					
<span class="nc bnc" id="L1704" title="All 2 branches missed.">					if (newEventStartIndex != -1) {</span>
<span class="nc" id="L1705">						sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L1706">						.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L1707">						.append(newEventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L1708">						.append(newEventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1709">						.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1710">						.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1711">						.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)							</span>
<span class="nc" id="L1712">						.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1713">						.append(eventRange.getStartDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1714">						.append(eventRange.getEndDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1715">						.append(nsValue).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1716">				        .append(nsID).append(&quot;\&quot;)&quot;);</span>
					}
				}
				
<span class="nc" id="L1720">				newEventStartIndex = -1;</span>
<span class="nc" id="L1721">				newEventEndIndex = -1;</span>
			}
<span class="nc" id="L1723">		}</span>
<span class="nc" id="L1724">		rowData.setSelectable(false);</span>
<span class="nc" id="L1725">		return rowData;</span>
	}

	/**
	 *  A wrapper for what-if mode
	 */
	public static TimeSeriesManager getTimeSeriesManager(RequestContext context) throws Exception {
<span class="nc" id="L1732">		return WfmManagerFactory.getTimeSeriesManager(context.isInWhatIfMode());</span>
	}
	
    /**
	 * Return the date for an absolute offset from the TraceCube. 
	 */	
	protected Date getDateFromTraceCubeOffset(TraceCube tc, int offset)
	{
<span class="nc" id="L1740">		Calendar cal = Calendar.getInstance(m_context.getViewingTimeZone());</span>
<span class="nc" id="L1741">		cal.setTime(tc.getRawStartDate());					</span>
<span class="nc" id="L1742">		cal.add(Calendar.MINUTE, offset*15);				</span>
<span class="nc" id="L1743">		return cal.getTime();</span>
	}
	
    /**
	 * Return the Calendar date for an absolute offset from the TraceCube. 
	 */	
	protected Calendar getCalendarFromTraceCubeOffset(TraceCube tc, int offset)
	{
<span class="nc" id="L1751">		Calendar cal = Calendar.getInstance(m_context.getViewingTimeZone());</span>
<span class="nc" id="L1752">		cal.setTime(tc.getRawStartDate());					</span>
<span class="nc" id="L1753">		cal.add(Calendar.MINUTE, offset*15);				</span>
<span class="nc" id="L1754">		return cal;</span>
	}
	
	/**
	 * Get the personalized Net Staffing values at the given TraceCube offset, taking into account any scheduled Time Off/work 
	 * time/Unavailability event at that interval, and whether or not Custom Shift Requests or VTO Requests are enabled. 
	 * For example, if the Net Staffing at the requested interval is NS_UNDERSTAFFED, and the user is already scheduled to
	 * work at that time, then it doesn't make sense to return NS_UNDERSTAFFED because the user is already working and cannot 
	 * do anything to satisfy that deficiency. So we return NS_NEUTRAL in this case. 
	 * Conversely, if the user is not working at a time when the net staffing is NS_OVERSTAFFED, then we'll return 0 instead.
	 * 
	 * For queues with LTI &gt; 15 minutes, it is possible that an LTI period will partially or completely fall outside of the
	 * employee's organization HOO. If that's the case, we wouldn't want to show a net staffing deficiency for the entire
	 * period. So, we consider the HOO's and only show a deficiency for time intervals that fall within the HOO.
	 * 
	 * @param cube - The Net Staffing TraceCube.
	 * @param offset - an offset from the cube. We will check the net staffing value at this interval, as well as any scheduled event at this time.
	 * @param schedule - The flattened scheduled events for the employee.
	 * @param csReqEnabled - Are Custom Shift Requests enabled?
	 * @param vtoReqEnabled - Are Time Off Requests enabled?
	 * @param isPublished - Is the schedule published?
	 * 
	 * @return the personalized Net Staffing value for the user at the given TraceCube offset. This is a pair of int's (valid values for each are -1,0,+1):
	 * 
	 *   [index 0] = The personalized net staffing value. This is used to determine which color to paint the cell.
	 *               Possible values:                 
	 *               NET_UNDERSTAFFED: This cell will be painted with the Net Staffing Shortage color.
	 *                    
	 *               NET_OVERSTAFFED: This cell will be painted with the Net Staffing Surplus color.
	 *                   
	 *               NET_NEUTRAL: This cell will be painted with the Net Staffing Neutral color.
	 *     
	 *   [index 1] = The &quot;simplified&quot; personalized net staffing value. This value is used by the graphing code to determine which 
	 *               type of request should be associated with &quot;neutral&quot; colored cells (those cells with a 0 value for [index 0]).
	 *               Possible values:                 
	 *               NET_UNDERSTAFFED: Any cell NOT under a Shift, TO, or Unavailability, as long as CS requests are enabled. Indicates that 
	 *                   only CS requests are available for this cell.
	 *                    
	 *               NET_OVERSTAFFED: Any cell under a shift (but NOT under TO or Unavailability), as long as VTO Requests are enabled. 
	 *               	Indicates that only VTO requests are available for this cell.
	 *                   
	 *               NET_NEUTRAL: Any cell in the past, or one that is under a Time Off/Unavailability event, or one for which the appropriate
	 *                   request type is disabled. Indicates that no requests are available for this cell, or any selection that includes this cell.
	 */
	public static int[] getPersonalizedNetStaffingValue(NetStaffingCube nsCube, Calendar eventStartCal, Calendar eventEndCal,
			Collection schedule, boolean csReqEnabled, boolean vtoReqEnabled, boolean isPublished, HashMap activities,
			Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias, Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues,
			Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp,
			Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp)
	{
<span class="nc" id="L1804">		int[] value = new int[2]; </span>
<span class="nc" id="L1805">		value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //initialize to neutral</span>
<span class="nc" id="L1806">		value[1] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //initialize to neutral</span>
		
<span class="nc" id="L1808">		Date startIntervalDate = eventStartCal.getTime();</span>
<span class="nc" id="L1809">		Date endIntervalDate = eventEndCal.getTime();</span>

<span class="nc" id="L1811">		TimeRange intervalRange = new TimeRange(startIntervalDate, endIntervalDate);</span>
<span class="nc" id="L1812">		Date now = new Date();</span>
<span class="nc" id="L1813">		boolean cellIsNotRequestable = false;</span>
<span class="nc" id="L1814">		long totalWorkDurationMS = 0;</span>
<span class="nc" id="L1815">		long totalTimeoffDurationMS = 0;</span>

<span class="nc" id="L1817">		HashMap&lt;Integer, Long&gt; overUnderToDurationMap = new HashMap&lt;Integer, Long&gt;();</span>

<span class="nc bnc" id="L1819" title="All 2 branches missed.">		if (startIntervalDate.after(now))</span>
		{
			//see if there is any scheduled event at that time
<span class="nc bnc" id="L1822" title="All 2 branches missed.">			for (Iterator it = schedule.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L1824">				SimpleEvent curEvent = (SimpleEvent) it.next();</span>
<span class="nc bnc" id="L1825" title="All 4 branches missed.">				if (curEvent != null &amp;&amp; (curEvent.getEventType() != Event.EVENT_TYPE_UNAVAILABILITY))</span>
				{
<span class="nc" id="L1827">					TimeRange eventRange = ScheduleViewUtil.eventRange(curEvent);</span>
<span class="nc" id="L1828">					long overlapDurationMS = eventRange.getOverlapDuration(intervalRange);</span>

<span class="nc bnc" id="L1830" title="All 2 branches missed.">					if (overlapDurationMS &gt; 0) //if this scheduled event is in the current interval</span>
					{
<span class="nc" id="L1832">						int overUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>

<span class="nc bnc" id="L1834" title="All 2 branches missed.">						if (curEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF) // || curEvent.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY</span>
						{
<span class="nc" id="L1836">							totalTimeoffDurationMS += overlapDurationMS;</span>
<span class="nc" id="L1837">							overUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
						}
						else
						{
<span class="nc" id="L1841">							totalWorkDurationMS += overlapDurationMS;</span>
<span class="nc" id="L1842">							Activity eventActivity = getEventActivity(curEvent, activities);</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">							if (eventActivity != null)</span>
							{
<span class="nc" id="L1845">								Collection&lt;ID&gt; mediaIDs = activityMedias.get(eventActivity.getID());</span>
<span class="nc" id="L1846">								Collection&lt;ID&gt; qIDs = activityQueues.get(eventActivity.getID());</span>
<span class="nc" id="L1847">								overUnderType = nsCube.getOverUnder(startIntervalDate, eventActivity, mediaIDs, qIDs);</span>
							}
						}

<span class="nc" id="L1851">						incrementDuration(overUnderToDurationMap, overUnderType, overlapDurationMS);</span>
					}

<span class="nc bnc" id="L1854" title="All 2 branches missed.">					if (endIntervalDate.before(eventRange.getStartDate()))</span>
<span class="nc" id="L1855">						break; //we've already passed the cell</span>
				}
<span class="nc" id="L1857">			}</span>

<span class="nc" id="L1859">			boolean isWorkingForMostOfInterval = false;</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">			if (totalTimeoffDurationMS &gt; 450000) //if cube interval overlaps timeoff event by more than 7.5 minutes (450000 ms)</span>
			{
				//cellIsNotRequestable = true; //we don't care about this anymore. We will let the user make a request and let the validation rules handle it.
<span class="nc" id="L1863">				value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //cell will be requestable for custom shifts, but not advertised as such.</span>
			}
			else
			{
<span class="nc bnc" id="L1867" title="All 2 branches missed.">				isWorkingForMostOfInterval = totalWorkDurationMS &gt; 450000; //if scheduled time overlaps interval by more than 7.5 minutes (450000 ms)</span>

<span class="nc" id="L1869">				long totalOffDurationMS = Trace.INTERVAL_IN_MILLIS - totalTimeoffDurationMS - totalWorkDurationMS;</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">				if (totalOffDurationMS &gt; 0)</span>
				{
<span class="nc" id="L1872">					int overUnderType = nsCube.getOverUnder(startIntervalDate, null, null, null); //get the overUnder value for the interval as if the agent is not scheduled at all</span>
<span class="nc" id="L1873">					incrementDuration(overUnderToDurationMap, overUnderType, totalOffDurationMS);</span>
				}

<span class="nc" id="L1876">				int maxOverUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc" id="L1877">				long maxDuration = 0;</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">				for (int curOverUnderType : overUnderToDurationMap.keySet())</span>
				{
<span class="nc" id="L1880">					long curDuration = overUnderToDurationMap.get(curOverUnderType);</span>
<span class="nc bnc" id="L1881" title="All 2 branches missed.">					if (curDuration &gt; maxDuration)</span>
					{
<span class="nc" id="L1883">						maxDuration = curDuration;</span>
<span class="nc" id="L1884">						maxOverUnderType = curOverUnderType;</span>
					}
<span class="nc" id="L1886">				}</span>
<span class="nc" id="L1887">				value[0] = maxOverUnderType;</span>

<span class="nc bnc" id="L1889" title="All 4 branches missed.">				if ((value[0] == Trace.NETSTAFF_UNDER) &amp;&amp; isWorkingForMostOfInterval)</span>
<span class="nc" id="L1890">					value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
			}

			//System.out.print(value[0] + &quot;, &quot;);
<span class="nc bnc" id="L1894" title="All 2 branches missed.">			if (value[0] == Trace.NETSTAFF_NA)</span>
<span class="nc" id="L1895">				return value; //null means invalid point</span>


<span class="nc bnc" id="L1898" title="All 2 branches missed.">			if (!cellIsNotRequestable)</span>
			{
<span class="nc bnc" id="L1900" title="All 4 branches missed.">				if ((value[0] == Trace.NETSTAFF_OVER) &amp;&amp; !isWorkingForMostOfInterval)</span>
				{
<span class="nc" id="L1902">					value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //User is not scheduled during this interval. Requesting a time off event for this interval would not improve net staffing.</span>
				}				
				
				//Determine the request type for the cell
<span class="nc bnc" id="L1906" title="All 2 branches missed.">				if (isWorkingForMostOfInterval)</span>
				{
<span class="nc bnc" id="L1908" title="All 2 branches missed.">					if (vtoReqEnabled)</span>
<span class="nc" id="L1909">						value[1] = Trace.NETSTAFF_OVER;</span>
					else
<span class="nc" id="L1911">						cellIsNotRequestable = true;</span>
				}
				else
				{
<span class="nc bnc" id="L1915" title="All 2 branches missed.">					if (csReqEnabled)</span>
<span class="nc" id="L1916">						value[1] = Trace.NETSTAFF_UNDER;</span>
					else
<span class="nc" id="L1918">						cellIsNotRequestable = true;</span>
				}
			}
<span class="nc" id="L1921">		}</span>
		else
		{
<span class="nc" id="L1924">			cellIsNotRequestable = true;</span>
		}
		
<span class="nc bnc" id="L1927" title="All 2 branches missed.">		if (cellIsNotRequestable)</span>
		{
<span class="nc" id="L1929">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //any invalid intervals should be neutral in color</span>
<span class="nc" id="L1930">			value[1] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //any invalid intervals should not be requestable</span>
		}
		
<span class="nc bnc" id="L1933" title="All 2 branches missed.">		if (!isPublished)</span>
		{
<span class="nc" id="L1935">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //Unpublished schedules should show grey for net staffing (QC91459)</span>
		}
		
		//We only show a deficiency for time intervals that fall within the HOO.
<span class="nc bnc" id="L1939" title="All 4 branches missed.">		if (value[0] == Trace.NETSTAFF_UNDER &amp;&amp; !isOpenPeriodForNetStaffingEmp(startIntervalDate, wrAssignmentsForNetStaffingEmp,</span>
				orgOpenPeriodsForNetStaffingEmp)) {
<span class="nc" id="L1941">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
		}
		
<span class="nc" id="L1944">		return value;</span>
	}

	private static void incrementDuration(HashMap&lt;Integer, Long&gt; overUnderToDurationMap, int overUnderType, long incrementAmountMS)
	{
<span class="nc" id="L1949">		Long prevDurationMS = (Long)overUnderToDurationMap.get(overUnderType);</span>
<span class="nc bnc" id="L1950" title="All 2 branches missed.">		if (prevDurationMS == null)</span>
<span class="nc" id="L1951">			overUnderToDurationMap.put(overUnderType, incrementAmountMS);</span>
		else
<span class="nc" id="L1953">			overUnderToDurationMap.put(overUnderType, prevDurationMS+incrementAmountMS);</span>
<span class="nc" id="L1954">	}</span>
	
	/**
	 * Append the JavaScript to the stringBuffer for adding a single net staffing event to a row.
	 * @param cube - the Net Staffing TraceCube
	 * @param realVal - The real Net Staffing value for the event.
	 * @param simpleVal - The simple Net Staffing value for the event. Basically, any cell not under a shift 
	 *        will have -1. Any cell under a shift will have +1. It will only be 0 if in the past or the required request type is diabled (invalid request)
	 * @param eventStartCubeIndex - The start index of the event in the net staffing TraceCube
	 * @param eventEndCubeIndex - The end index of the event in the net staffing TraceCube
	 * @param sbJS - The StringBuffer to append the event javaScript to.
	 */
	protected void graphNetStaffingEvent(int realVal, int simpleVal, Calendar eventStartCal, Calendar eventEndCal, int eventStartCubeIndex,
			StringBuffer sbJS, TimeRange aDay, int firstShownIndex, int lastShownIndex, int gridWidth, int rowIndex, boolean isStartCalDST,
			ScheduleViewPM.dstTransitionMode mode, int dstTransitionHour)
	{
<span class="nc" id="L1970">		int eventStartIndex = -1;</span>
<span class="nc" id="L1971">		int eventEndIndex = -1;</span>
<span class="nc" id="L1972">		int newEventStartIndex = -1;</span>
<span class="nc" id="L1973">		int newEventEndIndex = -1;</span>
<span class="nc" id="L1974">		String eventColor = &quot;&quot;;</span>
<span class="nc" id="L1975">		String eventPattern = &quot;null&quot;;</span>
		
<span class="nc" id="L1977">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L1978">		boolean isDayStartDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L1979">		boolean isDayEndDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">		boolean dayIsDSTDay = isDayStartDST != isDayEndDST;</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">		boolean isPeriodIncDST = tz.inDaylightTime(m_timeRange.getStartDate()) != tz.inDaylightTime(m_timeRange.getEndDate()); </span>
<span class="nc" id="L1982">		int dstTransitionIndex = dstTransitionHour*60;</span>

<span class="nc" id="L1984">		eventStartIndex = makeMinuteIndex(aDay, eventStartCal, firstShownIndex, lastShownIndex,mode, isDayStartDST, dstTransitionHour); //isStartCalDST</span>
<span class="nc" id="L1985">		eventEndIndex = makeMinuteIndex(aDay, eventEndCal, firstShownIndex, lastShownIndex,mode, isDayStartDST, dstTransitionHour); //isStartCalDST</span>
		
<span class="nc bnc" id="L1987" title="All 2 branches missed.">		if (eventEndIndex &gt; gridWidth) </span>
<span class="nc" id="L1988">			eventEndIndex = gridWidth;</span>

<span class="nc bnc" id="L1990" title="All 4 branches missed.">		if (eventStartIndex &lt; gridWidth+1 &amp;&amp; eventEndIndex != PREV_DAY_INDEX) {</span>
<span class="nc" id="L1991">			boolean eventStartIsDST = tz.inDaylightTime(eventStartCal.getTime());</span>
<span class="nc" id="L1992">			boolean eventEndIsDST = tz.inDaylightTime(eventEndCal.getTime());				</span>
<span class="nc" id="L1993">			int dstSavings = tz.getDSTSavings()/(60*1000);</span>
			
<span class="nc bnc" id="L1995" title="All 4 branches missed.">			switch(mode) {</span>
			case FALLBACK:
<span class="nc bnc" id="L1997" title="All 6 branches missed.">				if (!dayIsDSTDay &amp;&amp; isPeriodIncDST &amp;&amp; getViewType().equals(VIEW_TYPE_MY_GRAPH)) {</span>
					//The Personal Graph view can show multiple days at once, but if one of those days is the
					//Fall DST transition, then all of the days will show two 1AM's. Only the transition day
					//will actually have data in the 2nd 1AM. For the other days, we need to break up any
					//events that start before the 2nd 1AM and end after the 2nd 1AM, so that nothing is 
					//graphed during the 2nd 1AM hour.
<span class="nc bnc" id="L2003" title="All 4 branches missed.">					if ((eventStartIndex &lt; dstTransitionHour*60) &amp;&amp; (eventEndIndex &gt;= dstTransitionHour*60)) {</span>
<span class="nc" id="L2004">						newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L2005">						eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L2006">						newEventStartIndex = eventEndIndex + dstSavings;</span>
					}							
				}						
				
				break;
			case SPRINGFORWARD:
<span class="nc bnc" id="L2012" title="All 6 branches missed.">				if (dayIsDSTDay &amp;&amp; eventEndIsDST &amp;&amp; !eventStartIsDST) {</span>
					//The Personal and Group Graph views will always include 2AM, even if the only day in the view
					//is the Spring DST transition, which is supposed to skip 2AM. The DST transition day
					//will have no data in the 2AM hour, so we need to break up any events that start before 
					//2AM and end after the on or after 3AM, so that nothing is graphed during the 2AM hour.
<span class="nc" id="L2017">					newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L2018">					eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L2019">					newEventStartIndex = eventEndIndex + dstSavings;</span>
				}
			case NEUTRAL:
<span class="nc" id="L2022">				break;</span>
			default:
				break;
			}			
			
			//event overlaps with the shown hrs			
<span class="nc" id="L2028">			eventColor = getNetStaffingEventColor(realVal);            </span>
<span class="nc" id="L2029">            String eventTooltip = getNetStaffingEventTooltip(realVal, simpleVal);</span>
            
            //The cell ID which countains row and column numbers (used for Net Staffing cells only). Ex: &quot;NS_3_7&quot; = row 3 col 7
<span class="nc" id="L2032">            String nsID = &quot;NS_&quot; + rowIndex + &quot;_&quot; + eventStartCubeIndex; //(simpleVal==0) ? &quot;&quot; :</span>
            
			// create JS ScheduleEvent object and add it to calendarGrid.rows[rowIndex]
<span class="nc" id="L2035">			sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L2036">					.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L2037">					.append(eventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L2038">					.append(eventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2039">					.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2040">					.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2041">					.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2042">					.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2043">					.append(eventStartCal.getTime().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2044">					.append(eventEndCal.getTime().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2045">					.append(simpleVal).append(&quot;\&quot;,\&quot;&quot;) //tells us the cell type: &quot;SE&quot;=Schedule Event, &lt;0=NS Shortage, 0=NS Neutral, &gt;0=NS Surplus</span>
<span class="nc" id="L2046">			        .append(nsID).append(&quot;\&quot;)&quot;);</span>
		}
		
<span class="nc" id="L2049">	}</span>
	
	protected String getNetStaffingEventColor(int curVal)
	{
<span class="nc bnc" id="L2053" title="All 2 branches missed.">		if (curVal == Trace.NETSTAFF_UNDER)</span>
		{
<span class="nc" id="L2055">			m_hasNetStaffingShortageData = true;</span>
<span class="nc" id="L2056">			return m_netStaffingShortageColor;</span>
		}
<span class="nc bnc" id="L2058" title="All 2 branches missed.">		else if (curVal == Trace.NETSTAFF_OVER)</span>
		{
<span class="nc" id="L2060">			m_hasNetStaffingSurplusData = true;</span>
<span class="nc" id="L2061">			return m_netStaffingSurplusColor;</span>
		}
		else //if (curVal == Trace.NETSTAFF_NOT_OVER_OR_UNDER)
		{
<span class="nc" id="L2065">			m_hasNetStaffingNeutralData = true;</span>
<span class="nc" id="L2066">			return m_netStaffingNeutralColor;</span>
		}
	}
	
	/**
	 * @param realVal - The real Net Staffing value for the event.
	 * @param simpleVal - The simple Net Staffing value for the event. Basically, any cell not under a shift 
	 *        will have -1. Any cell under a shift will have +1. It will only be 0 if in the past (invalid request)
	 */
	protected String getNetStaffingEventTooltip(int realVal, int simpleVal)
	{
<span class="nc bnc" id="L2077" title="All 2 branches missed.">		if (realVal &lt; 0)</span>
		{		
<span class="nc bnc" id="L2079" title="All 2 branches missed.">			if (m_isCSEnabled)</span>
<span class="nc" id="L2080">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE_TOOLTIP);</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">			else if (m_isTOEnabled)</span>
<span class="nc" id="L2082">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE_CS_DISABLED_TOOLTIP);</span>
			else
<span class="nc" id="L2084">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE);</span>
		}
<span class="nc bnc" id="L2086" title="All 2 branches missed.">		else if (realVal &gt; 0)</span>
		{
<span class="nc bnc" id="L2088" title="All 2 branches missed.">			if (m_isTOEnabled)</span>
<span class="nc" id="L2089">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS_TOOLTIP);</span>
<span class="nc bnc" id="L2090" title="All 2 branches missed.">			else if (m_isCSEnabled)</span>
<span class="nc" id="L2091">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS_TO_DISABLED_TOOLTIP);</span>
			else
<span class="nc" id="L2093">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS);</span>
		}
		else 
		{
<span class="nc bnc" id="L2097" title="All 2 branches missed.">			if (simpleVal &lt; 0)</span>
			{
<span class="nc bnc" id="L2099" title="All 2 branches missed.">				if (m_isCSEnabled)</span>
<span class="nc" id="L2100">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_CSR_TOOLTIP);</span>
<span class="nc bnc" id="L2101" title="All 2 branches missed.">				else if (m_isTOEnabled)</span>
<span class="nc" id="L2102">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_TOR_TOOLTIP);</span>
				else
<span class="nc" id="L2104">					return &quot;&quot;;</span>
			}
<span class="nc bnc" id="L2106" title="All 2 branches missed.">			else if (simpleVal &gt; 0)</span>
			{
<span class="nc bnc" id="L2108" title="All 2 branches missed.">				if (m_isTOEnabled)</span>
<span class="nc" id="L2109">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_TOR_TOOLTIP);</span>
<span class="nc bnc" id="L2110" title="All 2 branches missed.">				else if (m_isCSEnabled)</span>
<span class="nc" id="L2111">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_CSR_TOOLTIP);</span>
				else
<span class="nc" id="L2113">					return &quot;&quot;;</span>
			}
			else
			{
<span class="nc" id="L2117">				return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_PAST_TOOLTIP);</span>
			}
		}			
	}
	
	/**
	 * Snap the current time to the next 15 minute interval if it is not exactly on one.
	 *
	 * @return
	 */
	public Date getNowSnappedTo15MinuteInterval() {
<span class="nc" id="L2128">		return getNowSnappedTo15MinuteInterval(m_context.getViewingTimeZone());</span>
	}

	/**
	 * Snap the current time to the next 15 minute interval if it is not exactly on one.
	 * @return
	 */
	public static Date getNowSnappedTo15MinuteInterval(TimeZone viewingTimeZone) {
<span class="nc" id="L2136">		Calendar cal = Calendar.getInstance(viewingTimeZone);</span>
<span class="nc" id="L2137">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L2138">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L2139">		int mins = cal.get(Calendar.MINUTE);</span>
		
<span class="nc bnc" id="L2141" title="All 4 branches missed.">		if (mins &gt; 0 &amp;&amp; mins &lt;= 15)</span>
<span class="nc" id="L2142">			cal.set(Calendar.MINUTE, 15);</span>
<span class="nc bnc" id="L2143" title="All 4 branches missed.">		else if (mins &gt; 15 &amp;&amp; mins &lt;= 30)</span>
<span class="nc" id="L2144">			cal.set(Calendar.MINUTE, 30);</span>
<span class="nc bnc" id="L2145" title="All 4 branches missed.">		else if (mins &gt; 30 &amp;&amp; mins &lt;= 45)</span>
<span class="nc" id="L2146">			cal.set(Calendar.MINUTE, 45);</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">		else if (mins &gt; 45)</span>
		{
<span class="nc" id="L2149">			cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L2150">			cal.add(Calendar.HOUR, 1);</span>
		}
		
<span class="nc" id="L2153">		return cal.getTime();</span>
	}

	/**
	 * This method initializes the org HOO data necessary for graphing the Net Staffing Ribbon for a single employee. 
	 * @param context - The request context
	 * @param empID - the employee ID for the employee whose Net Staffing Ribbon will be shown.
	 * @param start - the start of the day for the Net Staffing Ribbon. 
	 * @param end - the end of the day for the Net Staffing Ribbon.
	 * @throws RemoteException
	 * @throws BbmException
	 */
	protected void loadOrgsAndOpenPeriodsForNetStaffingEmp(RequestContext context, ID empID, Date start, Date end) 
			throws RemoteException, BbmException {

<span class="nc" id="L2168">		Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt; pair =</span>
<span class="nc" id="L2169">				getOrgsAndOpenPeriodsForNetStaffingEmp(context, empID, start, end);</span>
<span class="nc" id="L2170">		m_wrAssignmentsForNetStaffingEmp = pair.getFirst();</span>
<span class="nc" id="L2171">		m_orgOpenPeriodsForNetStaffingEmp = pair.getSecond();</span>
<span class="nc" id="L2172">	}</span>

	/**
	 * This method initializes the org HOO data necessary for graphing the Net Staffing Ribbon for a single employee.
	 * @param context - The request context
	 * @param empID - the employee ID for the employee whose Net Staffing Ribbon will be shown.
	 * @param start - the start of the day for the Net Staffing Ribbon.
	 * @param end - the end of the day for the Net Staffing Ribbon.
	 * @throws RemoteException
	 * @throws BbmException
	 */
	public static Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt; getOrgsAndOpenPeriodsForNetStaffingEmp(
			RequestContext context, ID empID, Date start, Date end) throws RemoteException, BbmException {
<span class="nc" id="L2185">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc" id="L2186">		Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp = null;</span>
		//first, load the org assignments for the employee
<span class="nc" id="L2188">		Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp = workResourceManager.getWorkResourceAssignments(empID, start,</span>
				end, false);

		//now load the open periods for each org
<span class="nc bnc" id="L2192" title="All 4 branches missed.">		if (wrAssignmentsForNetStaffingEmp != null &amp;&amp; !wrAssignmentsForNetStaffingEmp.isEmpty()) {</span>
<span class="nc" id="L2193">			List&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;(wrAssignmentsForNetStaffingEmp.size());</span>
<span class="nc bnc" id="L2194" title="All 2 branches missed.">			for (WorkResourceAssignment wra : wrAssignmentsForNetStaffingEmp) {</span>
<span class="nc" id="L2195">				ID orgID = wra.getOrganizationID();</span>
<span class="nc" id="L2196">				orgIDs.add(orgID);</span>
<span class="nc" id="L2197">			}</span>

<span class="nc" id="L2199">			HashMap&lt;ID, OrganizationHOOPeriod&gt; orgIdToHoopMap = workResourceManager.getHOOPeriod(orgIDs, start, end);</span>

<span class="nc bnc" id="L2201" title="All 4 branches missed.">			if (orgIdToHoopMap != null &amp;&amp; !orgIdToHoopMap.isEmpty()) {</span>
<span class="nc" id="L2202">				orgOpenPeriodsForNetStaffingEmp = new HashMap&lt;ID, Collection&lt;TimePeriod&gt;&gt;(orgIdToHoopMap.size());</span>
<span class="nc bnc" id="L2203" title="All 2 branches missed.">				for (ID orgID : orgIdToHoopMap.keySet()) {</span>
<span class="nc" id="L2204">					OrganizationHOOPeriod ohoop = orgIdToHoopMap.get(orgID);</span>
<span class="nc" id="L2205">					Collection&lt;TimePeriod&gt; openPeriods = ohoop.getOpenPeriods(start, end);</span>
<span class="nc" id="L2206">					orgOpenPeriodsForNetStaffingEmp.put(orgID, openPeriods);</span>
<span class="nc" id="L2207">				}</span>
			}
		}
<span class="nc" id="L2210">		return new Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt;(wrAssignmentsForNetStaffingEmp,</span>
				orgOpenPeriodsForNetStaffingEmp);
	}

	/**
	 * Assuming loadOrgsAndOpenPeriodsForNetStaffingEmp() has been run, this method will tell 
	 * you whether or not a particular datetime falls inside of the employee's Hours Of Operation.
	 * This method is intended to be used by Net Staffing Ribbon code in order to determine whether
	 * a net staffing deficiency should show up as such in the ribbon (when the datetime falls in 
	 * the HOO), or should be shown as a neutral cell instead (when it's a non-HOO time). Since the 
	 * Net Staffing ribbon is only shown for one agent, no need to provide the empID to this method;
	 * the m_wrAssignmentsForNetStaffingEmp and m_orgOpenPeriodsForNetStaffingEmp member variables will
	 * have already been populated with the data for that employee.
	 * @param interval - The datetime to be checked to see if it is an open period for the net staffing
	 * employee.
	 * @return - true if the date parameter is within the HOO for the net staffing employee's org at that time.
	 */
	protected static boolean isOpenPeriodForNetStaffingEmp(Date date, Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp,
			Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp) {
<span class="nc bnc" id="L2229" title="All 4 branches missed.">		if (wrAssignmentsForNetStaffingEmp != null &amp;&amp; orgOpenPeriodsForNetStaffingEmp != null) {</span>

			//first, find the user's orgID at that time
<span class="nc" id="L2232">			ID orgID = null;</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">			for (WorkResourceAssignment wra : wrAssignmentsForNetStaffingEmp) {</span>
<span class="nc bnc" id="L2234" title="All 6 branches missed.">				if (!date.before(wra.getStartTime()) &amp;&amp; (wra.getEndTime()==null) || date.before(wra.getEndTime())) {</span>
<span class="nc" id="L2235">					orgID = wra.getOrganizationID();</span>
<span class="nc" id="L2236">					break;</span>
				}
<span class="nc" id="L2238">			}</span>

			//now see if that org is open during that time
<span class="nc bnc" id="L2241" title="All 2 branches missed.">			if (orgID != null) {</span>
<span class="nc" id="L2242">				Collection&lt;TimePeriod&gt; openPeriods = orgOpenPeriodsForNetStaffingEmp.get(orgID);</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">				if (openPeriods != null) {</span>
<span class="nc bnc" id="L2244" title="All 2 branches missed.">					for (TimePeriod tp : openPeriods) {</span>
<span class="nc bnc" id="L2245" title="All 4 branches missed.">						if (!date.before(tp.getStartTime()) &amp;&amp; date.before(tp.getEndTime())) {</span>
<span class="nc" id="L2246">							return true;</span>
						}
<span class="nc" id="L2248">					}</span>
				}
			}
		}
<span class="nc" id="L2252">		return false;</span>
	}

	/**
	 * make a row for the multicolumn list display of the net staffing events in Graph view.
	 * @param empDaySummaries - the collection of DailyScheduleSummary's for the employee
	 * @param cube - The TraceCube of net staffing data (under=NS_UNDERSTAFFED, over=NS_OVERSTAFFED, neither=NS_NEUTRAL) for the entire day.
	 * @param aDay - The full day being graphed (midnight to midnight)
	 * @param graphStart - The beginning of the graph on aDay
	 * @param graphEnd - The end of the graph on aDay
	 */
	public DefaultMultiColumnNodeData makeRightNetStaffingRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, Date graphStart, Date graphEnd, int[] shownHours, Collection schedule, NetStaffingCube nsCube, int rowIndex, boolean isMy, 
			Collection empDaySummaries, boolean isPublished, dstTransitionMode mode, int dstTransitionHour, HashMap activities,
			Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias, Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues)
	{
<span class="nc" id="L2268">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L2269">		TimeZone tz = context.getViewingTimeZone();</span>
		
		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L2272">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L2273">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L2274">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>
		
		//--- make the row with one empty cell ---
<span class="nc" id="L2277">		rowData.add(&quot;&amp;nbsp;&quot;);</span>
<span class="nc" id="L2278">		rowData.setNodeAttribute(&quot;style&quot;, &quot;font-size:0px&quot;);</span>

		//--- generate JS object with the data for the row ---
<span class="nc" id="L2281">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L2282">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,&quot;).append(m_isNetStaffingHalfHeight).append(&quot;));&quot;);</span>
				
<span class="nc bnc" id="L2284" title="All 2 branches missed.">		if (nsCube!=null)</span>
		{
<span class="nc" id="L2286">			Calendar eventStartCal = Calendar.getInstance(tz);</span>
<span class="nc" id="L2287">			eventStartCal.setTime(graphStart);</span>
			
<span class="nc" id="L2289">			boolean isStartCalDST = tz.inDaylightTime(graphStart);</span>
			
<span class="nc" id="L2291">			Calendar eventEndCal = Calendar.getInstance(tz);</span>
<span class="nc" id="L2292">			eventEndCal.setTime(eventStartCal.getTime());</span>
<span class="nc" id="L2293">			eventEndCal.add(Calendar.MINUTE, 15);</span>
			
<span class="nc" id="L2295">			int cubeIndex = 0;</span>
<span class="nc" id="L2296">			Date now = new Date();</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">			while (eventStartCal.getTime().before(graphEnd))</span>
			{
<span class="nc bnc" id="L2299" title="All 2 branches missed.">				if (eventStartCal.getTime().after(now))</span>
				{
<span class="nc" id="L2301">					int[] curVal = getPersonalizedNetStaffingValue(nsCube, eventStartCal, eventEndCal, schedule, m_csReqEnabled,</span>
							m_vtoReqEnabled, isPublished, activities, activityMedias, activityQueues,
							m_wrAssignmentsForNetStaffingEmp, m_orgOpenPeriodsForNetStaffingEmp);

<span class="nc bnc" id="L2305" title="All 2 branches missed.">					if ((curVal[0] != Trace.NETSTAFF_NA))</span>
					{
<span class="nc" id="L2307">						graphNetStaffingEvent(curVal[0], curVal[1], eventStartCal, eventEndCal, cubeIndex++, sbJS, aDay, </span>
							firstShownIndex, lastShownIndex, gridWidth, rowIndex, isStartCalDST, mode, dstTransitionHour);
					}
				}
<span class="nc" id="L2311">				eventStartCal.add(Calendar.MINUTE, 15);</span>
<span class="nc" id="L2312">				eventEndCal.add(Calendar.MINUTE, 15);</span>
			}
			
<span class="nc bnc" id="L2315" title="All 4 branches missed.">			if (m_isCSEnabled || m_isTOEnabled)</span>
<span class="nc" id="L2316">				rowData.setNodeAttribute(&quot;style&quot;, &quot;cursor: pointer; cursor: hand; font-size:0px&quot;);</span>
		}

<span class="nc" id="L2319">		rowData.setSelectable(false);</span>
<span class="nc" id="L2320">		return rowData;</span>
	}

	/**
	 * make a spacer row for the multicolumn list display of the net staffing events in Graph view.
	 */
	public DefaultMultiColumnNodeData makeRightSpacerRowForGraph(StringBuffer sbJS, int[] shownHours,  int rowIndex) 
	{
<span class="nc" id="L2328">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
		
		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L2331">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L2332">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L2333">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>
		
		//--- make the row with one empty cell ---
<span class="nc" id="L2336">		rowData.add(&quot;&amp;nbsp;&quot;);</span>
		
		//--- generate JS object with the data for the row ---
<span class="nc" id="L2339">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L2340">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,false));&quot;);</span>


<span class="nc" id="L2343">		rowData.setSelectable(false);</span>
<span class="nc" id="L2344">		return rowData;</span>
	}//makeRightSpacerRowForGraph

	/**
	 * find if there is published schedule for the given day for the given person
	 */
	public static boolean dayIsPublished(CalendarRange aDay, Collection personalTimeRanges) {
<span class="fc" id="L2351">		boolean result = false;</span>
<span class="pc bpc" id="L2352" title="1 of 4 branches missed.">		if (aDay != null &amp;&amp; personalTimeRanges != null) {</span>
<span class="fc bfc" id="L2353" title="All 2 branches covered.">			for (Iterator i = personalTimeRanges.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2354">				TimeRange tp = (TimeRange) i.next();</span>
<span class="pc bpc" id="L2355" title="1 of 4 branches missed.">				if (tp != null &amp;&amp; tp.getOverlapDuration(aDay) &gt; 0) {</span>
<span class="fc" id="L2356">					result = true;</span>
<span class="fc" id="L2357">					break;</span>
				}
<span class="fc" id="L2359">			}</span>
		}
<span class="fc" id="L2361">		return result;</span>
	}//dayIsPublished

	/**
	 * calculate the index in minutes of the Calendar value from the shown index in the given day
	 * @param theDay - the given day
	 * @param theCal - the time value
	 * @param firstShownIndex - limitation by the grid boundaries
	 * @param lastShownIndex - limitation by the grid boundaries
	 * @return int index - offset in minutes of theCal from the firstShownIndex
	 *         or -1 if theCal is before the shown hours and 1441 if after shown hours
	 */
	public static int makeMinuteIndex(TimeRange theDay, Calendar theCal, int firstShownIndex, int lastShownIndex,  ScheduleViewPM.dstTransitionMode mode, boolean dayStartIsDST, int dstTransitionHour){
		
<span class="nc" id="L2375">		int relLocOfTheCal = theDay.getRelativeLocation(theCal);</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">		if (relLocOfTheCal == TimeRange.TIME_BEFORE) {</span>
<span class="nc" id="L2377">			return PREV_DAY_INDEX;</span>
<span class="nc bnc" id="L2378" title="All 2 branches missed.">		} else if (relLocOfTheCal == TimeRange.TIME_AFTER) {</span>
<span class="nc" id="L2379">			boolean curDateIsDST = theCal.getTimeZone().inDaylightTime(theCal.getTime());</span>
<span class="nc bnc" id="L2380" title="All 2 branches missed.">			if (mode.equals(ScheduleViewPM.dstTransitionMode.FALLBACK) ) { // add an hour</span>
<span class="nc" id="L2381">				return NEXT_DAY_INDEX + 60;</span>
			} else {
<span class="nc" id="L2383">				return NEXT_DAY_INDEX;</span>
			}
		} else {
<span class="nc" id="L2386">			int hourOfDay = theCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L2387">			boolean curDateIsDST = theCal.getTimeZone().inDaylightTime(theCal.getTime());</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">			if (mode.equals(ScheduleViewPM.dstTransitionMode.FALLBACK)) {</span>
					//Add an hour if cur date is &gt;= the 2nd 1AM. We check the fall transition day, 
					//as well as the fall non-transition days, since they also show two 1AM's 
<span class="nc bnc" id="L2391" title="All 8 branches missed.">					if ((dayStartIsDST &amp;&amp; !curDateIsDST) || (dstTransitionHour&gt;=0 &amp;&amp; hourOfDay&gt;=dstTransitionHour))  </span>
<span class="nc" id="L2392">						hourOfDay++;</span>
			}
			
<span class="nc" id="L2395">			int minutesFromDayStart = hourOfDay*60 + theCal.get(Calendar.MINUTE); //DST bug: Can't use HOUR_OF_DAY because there could be two 1AM's.</span>
			//int minutesFromDayStart = (int) ((theCal.getTime().getTime() - theDay.getStartDate().getTime()) / 1000 / 60);
			
<span class="nc bnc" id="L2398" title="All 2 branches missed.">			if (minutesFromDayStart &lt; firstShownIndex) {</span>
<span class="nc" id="L2399">				return PREV_DAY_INDEX;</span>
<span class="nc bnc" id="L2400" title="All 2 branches missed.">			} else if (minutesFromDayStart &gt; lastShownIndex) {</span>
<span class="nc" id="L2401">				return NEXT_DAY_INDEX;</span>
			} else {
<span class="nc" id="L2403">				int mins = minutesFromDayStart - firstShownIndex;</span>
<span class="nc bnc" id="L2404" title="All 2 branches missed.">				if (mins &gt; lastShownIndex) // weird bug where last end index is 1 minute over</span>
<span class="nc" id="L2405">					mins = lastShownIndex;</span>
<span class="nc" id="L2406">				return mins;</span>
			}
		}
	}

	/**
	 * get Event Activity
	 * @param event - scheduleEvent
	 * @param activities
	 * @return the event's Activity
	 */
	public static Activity getEventActivity(Event event, HashMap activities) {
<span class="nc" id="L2418">		Activity activity = null;</span>
<span class="nc bnc" id="L2419" title="All 4 branches missed.">		if (event != null &amp;&amp; activities != null) {</span>
<span class="nc" id="L2420">			activity = (Activity)activities.get(event.getActivityID());</span>
			//if(activity!=null)
			//	color = activity.getColor();
		}
<span class="nc" id="L2424">		return  activity;</span>
	}//getEventActivityColor

    /**
	 * Get the tooltip for an event, such as &quot;Campaign: My Campaign&quot;
	 * @param eventRange - The time range for the event.
	 * @param empDaySummaries - The DailyScheduleSummary collection for the employee.
	 * @return the tooltip for the event, such as &quot;Campaign: My Campaign&quot;
	 */
	public String getEventTooltip(TimeRange dayRange, SimpleEvent event, Activity eventActivity, String eventPattern,
			TimeRange eventRange, Collection&lt;DailyScheduleSummary&gt; empDaySummaries, Map&lt;ID, String&gt; campaignNamesBySpID, TimeZone tz)
	{
<span class="nc" id="L2436">		String lineBreak = &quot; &amp;#13;&quot;; //NOTE: This may only work in Internet Explorer for Windows. Not sure.</span>
		
<span class="nc" id="L2438">	    StringBuilder tooltip = new StringBuilder();</span>
<span class="nc bnc" id="L2439" title="All 2 branches missed.">	    if (eventActivity != null) {</span>
<span class="nc" id="L2440">	    	tooltip.append(eventActivity.getName());</span>

<span class="nc" id="L2442">	    	CalendarRange calRange = DateTimeUtil.makeDayRange(dayRange.getStartDate(), tz);</span>
<span class="nc" id="L2443">	    	tooltip.append(lineBreak).append(ShiftUtil.makeEventPeriodString(calRange, event, false, m_localizer, tz));</span>
	    	
<span class="nc bnc" id="L2445" title="All 2 branches missed.">	    	if (!eventPattern.equals(&quot;null&quot;))</span>
		    {
<span class="nc" id="L2447">		    	tooltip.append(lineBreak).append(i18n(m_bundle, FsWebBundleKey.SP_OVERTIME)); </span>
		    }
	    }
	    
<span class="nc bnc" id="L2451" title="All 4 branches missed.">	    if (eventRange != null &amp;&amp; empDaySummaries != null)</span>
	    {
<span class="nc bnc" id="L2453" title="All 2 branches missed.">	        for (Iterator&lt;DailyScheduleSummary&gt; it=empDaySummaries.iterator(); it.hasNext();)</span>
	        {
<span class="nc" id="L2455">	            DailyScheduleSummary dailyScheduleSummary = it.next();</span>
	            //Determine the campaign name of the campaign associated to the event (if applicable).
	            //Calendar Events do not have campaigns associated to them.
<span class="nc bnc" id="L2458" title="All 2 branches missed.">	            if (!eventRange.getStartDate().before(dailyScheduleSummary.getShiftStartDate()) &amp;&amp;</span>
<span class="nc bnc" id="L2459" title="All 2 branches missed.">	                 eventRange.getStartDate().before(dailyScheduleSummary.getShiftEndDate()) &amp;&amp;</span>
<span class="nc bnc" id="L2460" title="All 2 branches missed.">	                 event.getEventType() != Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT)</span>
	            {
<span class="nc" id="L2462">					String campaignName = ScheduleViewUtil.getCampaignName(campaignNamesBySpID, event);</span>

					//QC 137591: Only display a campaign name if it is available.  
					// 			 Schedules with only TO and unavailability will pass the above test, but not have a match in campaignNamesBySpID.
<span class="nc bnc" id="L2466" title="All 2 branches missed.">					if (!StringUtil.isEmptyOrWhiteSpace(campaignName)) {</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">						if (tooltip.length() &gt; 0)</span>
<span class="nc" id="L2468">							tooltip.append(lineBreak);</span>

						//GMT
<span class="nc" id="L2471">						tooltip.append(verticalize(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN));</span>
<span class="nc" id="L2472">						tooltip.append(campaignName);</span>
<span class="nc" id="L2473">						break;</span>
					}
	            }
<span class="nc" id="L2476">	        }</span>
	    }

<span class="nc" id="L2479">	    return tooltip.toString();</span>
	}
	
	/**
     * make the work period string start - end,
     *  optional &quot;next day&quot; if it ends on the other date;
     *  
     * @return ScheduleViewShiftDisplayInfo object which contains the necessary information to display
     * a shift in a schedule view screen (including icons such as overtime, calendar events, etc. if they
     * apply to the shift).
     */
    public static ScheduleViewShiftDisplayInfo getShiftDisplayInfo(DailyScheduleSummary daySchedule, Localizer localizer, TimeZone tz){
<span class="nc" id="L2491">        CalendarRange aDay = daySchedule.getDayRange();</span>
<span class="nc" id="L2492">        Date firstEventStartDate = daySchedule.getShiftStartDate();</span>
<span class="nc" id="L2493">        Date firstEventEndDate = daySchedule.getShiftEndDate();</span>
        
<span class="nc" id="L2495">        Date secondEventStartDate = firstEventStartDate;</span>
<span class="nc" id="L2496">        Date secondEventEndDate = firstEventEndDate;</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">        if (daySchedule.getSecondShift() != null)</span>
        {
<span class="nc" id="L2499">            secondEventStartDate = daySchedule.getSecondShift().getShiftStartDate();</span>
<span class="nc" id="L2500">            secondEventEndDate = daySchedule.getSecondShift().getShiftEndDate();</span>
        }
        
<span class="nc" id="L2503">        StringBuffer sb = new StringBuffer();</span>
        
<span class="nc" id="L2505">        ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>
        
        //previous day icon
<span class="nc" id="L2508">        String prevIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">        if (!aDay.includes(firstEventStartDate)) {</span>
<span class="nc" id="L2510">            prevIcon = (makeAdjacentDayIcon(aDay, firstEventStartDate, </span>
<span class="nc" id="L2511">                    localizer.i18n(bundle,FsWebBundleKey.SV_PREVIOUS_DAY), localizer.i18n(bundle,FsWebBundleKey.SV_NEXT_DAY)));</span>
        }
        
        //first shift string
<span class="nc" id="L2515">        sb.append(localizer.formatDate(firstEventStartDate,tz,RegionalFormatBundleKey.TIME_FORMAT));  </span>
<span class="nc" id="L2516">        sb.append(&quot; - &quot;);</span>
<span class="nc" id="L2517">        sb.append(localizer.formatDate(firstEventEndDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>
        
<span class="nc bnc" id="L2519" title="All 2 branches missed.">        if (daySchedule.getSecondShift() != null)</span>
        {
            //second shift string
<span class="nc" id="L2522">            sb.append(&quot;, &quot;);</span>
<span class="nc" id="L2523">            sb.append(localizer.formatDate(secondEventStartDate,tz,RegionalFormatBundleKey.TIME_FORMAT));  </span>
<span class="nc" id="L2524">            sb.append(&quot; - &quot;);</span>
<span class="nc" id="L2525">            sb.append(localizer.formatDate(secondEventEndDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>
        }
        
<span class="nc" id="L2528">        String iconHeight = FsImageFileID.OVERTIME_HEIGHT;</span>
        //next day icon
<span class="nc" id="L2530">        String nextIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2531" title="All 2 branches missed.">        if (!aDay.includes(secondEventEndDate)) {</span>
<span class="nc" id="L2532">            nextIcon = (makeAdjacentDayIcon(aDay, secondEventEndDate, </span>
<span class="nc" id="L2533">                    localizer.i18n(bundle,FsWebBundleKey.SV_PREVIOUS_DAY), localizer.i18n(bundle,FsWebBundleKey.SV_NEXT_DAY)));</span>
        }
        
        //pooling icon
<span class="nc" id="L2537">        String poolingIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2538" title="All 2 branches missed.">        if (daySchedule.containsPoolingActivities()) {</span>
<span class="nc" id="L2539">        	poolingIcon = (HtmlUtil.imageTag(ImageFileID.POOLER_ICON, &quot;16&quot;, iconHeight,</span>
<span class="nc" id="L2540">        			localizer.i18n(bundle,FsWebBundleKey.SV_SHIFT_CONTAINS_POOLING_ACTIVITIES)));</span>
        }
        
        //overtime icon
<span class="nc" id="L2544">        String overTimeIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2545" title="All 2 branches missed.">        if (daySchedule.containsOvertime()) {</span>
<span class="nc" id="L2546">        	overTimeIcon = (HtmlUtil.imageTag(FsImageFileID.OVERTIME_ICON, FsImageFileID.OVERTIME_WIDTH,</span>
<span class="nc" id="L2547">        			iconHeight, daySchedule.getOvertimeDescription(localizer)));</span>
        }
        
        //calendar event icon
<span class="nc" id="L2551">        String calendarEventIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2552" title="All 2 branches missed.">        if (daySchedule.containsCalendarEvents()) {</span>
<span class="nc" id="L2553">        	calendarEventIcon = (HtmlUtil.imageTag(FsImageFileID.CALENDAR_EVENT_ICON, FsImageFileID.CALENDAR_EVENT_WIDTH,</span>
<span class="nc" id="L2554">        			iconHeight, localizer.i18n(bundle,</span>
        					FsWebBundleKey.SV_CALENDAR_EVENTS_TOOLTIP,
<span class="nc" id="L2556">        					daySchedule.getCalendarEventsDescription(localizer))));</span>
        }

<span class="nc" id="L2559">        return new ScheduleViewShiftDisplayInfo(prevIcon, sb.toString(), nextIcon, poolingIcon,</span>
        		overTimeIcon, calendarEventIcon);    
    }//makeWorkPeriodString

	/**
	 * add next or previous day icon
     * @param prevLabel For 508 Accessibility, added label for the previous day icon
     * @param nextLabel For 508 Accessibility, added label for the next day icon
	 */
	public static String makeAdjacentDayIcon(TimeRange aDay, Date date, String prevLabel, String nextLabel) {
<span class="nc bnc" id="L2569" title="All 2 branches missed.">		if (aDay.getRelativeLocation(date)==TimeRange.TIME_AFTER)</span>
		//add next day icon with no alt text
<span class="nc" id="L2571">			return HtmlUtil.imageTag(ImageFileID.NEXT_DAY,</span>
					ImageFileID.NEXT_DAY_WIDTH,
					ImageFileID.NEXT_DAY_HEIGHT, nextLabel);
<span class="nc bnc" id="L2574" title="All 2 branches missed.">		else if (aDay.getRelativeLocation(date)==TimeRange.TIME_BEFORE)</span>
		//add previous day icon with no alt text
<span class="nc" id="L2576">			return HtmlUtil.imageTag(ImageFileID.PREV_DAY,</span>
					ImageFileID.PREV_DAY_WIDTH,
					ImageFileID.PREV_DAY_HEIGHT, prevLabel);
<span class="nc" id="L2579">		else return &quot;&quot;;</span>
	}//makeAdjacentDayIcon

	public static String makeAdjacentDayIcon(TimeRange aDay, Date date) {
<span class="nc bnc" id="L2583" title="All 2 branches missed.">		if (aDay.getRelativeLocation(date)==TimeRange.TIME_AFTER)</span>
		//add next day icon with no alt text
<span class="nc" id="L2585">			return HtmlUtil.imageTag(ImageFileID.NEXT_DAY,</span>
					ImageFileID.NEXT_DAY_WIDTH,
					ImageFileID.NEXT_DAY_HEIGHT, &quot;&quot;);
<span class="nc bnc" id="L2588" title="All 2 branches missed.">		else if (aDay.getRelativeLocation(date)==TimeRange.TIME_BEFORE)</span>
		//add previous day icon with no alt text
<span class="nc" id="L2590">			return HtmlUtil.imageTag(ImageFileID.PREV_DAY,</span>
					ImageFileID.PREV_DAY_WIDTH,
					ImageFileID.PREV_DAY_HEIGHT, &quot;&quot;);
<span class="nc" id="L2593">		else return &quot;&quot;;</span>
	}//makeAdjacentDayIcon
		
	/**
	 * initialize generated JS data objects for the Graph views
	 */
	protected void startGenerateJSData(){
<span class="nc" id="L2600">		m_sbJS.append(&quot;\n\n// Graph View Data \n function afterMain(){\n var calendarGrid = new CalendarGrid();&quot;);</span>
<span class="nc" id="L2601">	}</span>

	/**
	 * initialize generated JS data objects for the Graph views
	 */
	protected void finishGenerateJSData(){
<span class="nc" id="L2607">		m_sbJS.append(&quot;\n calendarGrid.writeGrid();\n GraphViewSupport();\n }\n&quot;);</span>
<span class="nc" id="L2608">	}</span>


	/**
	 * limit the DateRange picker to +/- 30 years
	 */
	protected void limitDateRangePicker(){
<span class="fc" id="L2615">		CalendarRange selectableRange = DateTimeUtil.makeTimeRangeAroundNow(Calendar.YEAR,30,30); //+/-30 years</span>
<span class="fc" id="L2616">		m_dateRangePicker.getStartDatePickerPC().setLowerLimit(selectableRange.getStartDate());</span>
<span class="fc" id="L2617">		m_dateRangePicker.getEndDatePickerPC().setUpperLimit(selectableRange.getEndDate());</span>
<span class="fc" id="L2618">	}</span>

	protected ScheduleViewPM.dstTransitionMode getDstTransitionMode(TimeZone tz) {
<span class="nc" id="L2621">		ScheduleViewPM.dstTransitionMode mode = ScheduleViewPM.dstTransitionMode.NEUTRAL;</span>
		
<span class="nc bnc" id="L2623" title="All 2 branches missed.">		Date startDate = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartDate() : m_timeRange.getStartDate();</span>
<span class="nc bnc" id="L2624" title="All 2 branches missed.">		Date endDate = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getEndDate() : m_timeRange.getEndDate();</span>

<span class="nc" id="L2626">		boolean startOfRangeInDST = tz.inDaylightTime(startDate);</span>
<span class="nc" id="L2627">		boolean endOfRangeInDST = tz.inDaylightTime(endDate);</span>
<span class="nc bnc" id="L2628" title="All 4 branches missed.">		if (startOfRangeInDST &amp;&amp; !endOfRangeInDST) {</span>
<span class="nc" id="L2629">			mode = ScheduleViewPM.dstTransitionMode.FALLBACK;</span>
		}
<span class="nc bnc" id="L2631" title="All 4 branches missed.">		else if (!startOfRangeInDST &amp;&amp; endOfRangeInDST) {</span>
<span class="nc" id="L2632">			mode = ScheduleViewPM.dstTransitionMode.SPRINGFORWARD;</span>
		}
		
<span class="nc" id="L2635">		return mode;</span>
	}
	
	protected Calendar findDSTTransitionDay(TimeZone tz) {
<span class="nc" id="L2639">		boolean dstAdjustment = false;</span>
<span class="nc" id="L2640">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc bnc" id="L2641" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange))</span>
		{
<span class="nc" id="L2643">			boolean dayStartInDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L2644">			boolean dayEndInDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L2645" title="All 2 branches missed.">			if (dayStartInDST != dayEndInDST) {</span>
<span class="nc" id="L2646">				return aDay.getStartCalendar();</span>
			}

<span class="nc" id="L2649">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
<span class="nc" id="L2650">		}</span>
        
<span class="nc" id="L2652">		return m_timeRange.getStartCalendar(tz, m_locale);</span>
	}
    
	protected int findDSTTransition(int shownHours[], ScheduleViewPM.dstTransitionMode mode, TimeZone tz) {
<span class="nc bnc" id="L2656" title="All 2 branches missed.">		if (mode==ScheduleViewPM.dstTransitionMode.NEUTRAL)</span>
<span class="nc" id="L2657">			return -1;</span>
		
<span class="nc" id="L2659">		boolean dstAdjustment = false;</span>
<span class="nc" id="L2660">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc" id="L2661">		int prevHour = -1;</span>
<span class="nc bnc" id="L2662" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange))</span>
		{
<span class="nc" id="L2664">			boolean dayStartInDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L2665">			boolean dayEndInDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">			if (dayStartInDST != dayEndInDST) {</span>
<span class="nc" id="L2667">				Calendar cal = aDay.getStartCalendar();</span>
<span class="nc" id="L2668">				cal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2669">				prevHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L2670">				cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L2671">				Date dateTime = cal.getTime();</span>
<span class="nc bnc" id="L2672" title="All 2 branches missed.">				while (dateTime.before(aDay.getEndDate())) {</span>
<span class="nc" id="L2673">					int curHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc bnc" id="L2674" title="All 2 branches missed.">					if (prevHour == curHour) {</span>
						//Fall DST transition occurs when 1AM follows 1AM. Transition occurs on the 2nd 1AM.
<span class="nc" id="L2676">						return prevHour+1;</span>
					}
<span class="nc bnc" id="L2678" title="All 2 branches missed.">					else if (curHour == prevHour + 2) {</span>
						//Spring DST transition occurs when 3AM follows 1AM. Transition occurs at 2AM.
<span class="nc" id="L2680">						return prevHour+1;</span>
					}

<span class="nc" id="L2683">					prevHour = curHour;</span>
<span class="nc" id="L2684">					cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L2685">					dateTime = cal.getTime();</span>
<span class="nc" id="L2686">				}</span>
			}

<span class="nc" id="L2689">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
<span class="nc" id="L2690">		}</span>
		
<span class="nc" id="L2692">		return -1; // didn't find it </span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Dual List Helper Methods
	//////////////////////////////////////////////////////////////////////////////
	private void initDualListForDisplay() {
<span class="fc" id="L2699">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="fc" id="L2700">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="fc" id="L2701">		leftListPC.setRowSelectable(false);</span>
<span class="fc" id="L2702">		rightListPC.setRowSelectable(false);</span>

<span class="fc" id="L2704">		initRightListProperties();</span>

<span class="pc bpc" id="L2706" title="1 of 2 branches missed.">		if (leftListPC.getListModel().isEmpty()) {</span>
<span class="nc" id="L2707">			m_dualList.setIsBorderEnabled(false);</span>
		}
		
<span class="pc bpc" id="L2710" title="1 of 2 branches missed.">		if (!isGraphView())</span>
		{
<span class="fc" id="L2712">			m_dualList.getLeftListPC().setIsZebra(true);</span>
<span class="fc" id="L2713">			m_dualList.getRightListPC().setIsZebra(true);</span>
		}
<span class="fc" id="L2715">	}</span>

	protected void initRightListProperties() {
		//set CSS class to remove margins in the right list
<span class="nc" id="L2719">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2720">		rightListPC.setCellClass(&quot;tblItemNoPaddn&quot;);</span>
<span class="nc" id="L2721">		rightListPC.setTableRowClass(&quot;tblRowNoPaddn&quot;);</span>
<span class="nc" id="L2722">		rightListPC.getHeader().setStyleClass(&quot;tableHeaderNoPaddn&quot;);</span>
<span class="nc" id="L2723">	}</span>
	
	protected void initRightListPropertiesForGraph() 
	{
<span class="nc" id="L2727">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2728">		rightListPC.setTableAttribute(&quot;onselectstart&quot;, &quot;return false;&quot;);</span>
<span class="nc" id="L2729">		rightListPC.setTableAttribute(&quot;ondragstart&quot;, &quot;return false;&quot;);	</span>
		
<span class="nc bnc" id="L2731" title="All 2 branches missed.">		rightListPC.setTableAttribute(&quot;requestedFor&quot;, (m_isFullPageMode ? m_myEmpID.toString() : getSelectedID())); //net staffing can only be shown for one agent at a time</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">		rightListPC.setTableAttribute(&quot;pageMode&quot;, m_isFullPageMode ? FsKeys.RP_MODE_AGENT : FsKeys.RP_MODE_MGR);</span>
		
<span class="nc" id="L2734">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="nc" id="L2735">		leftListPC.setCellClass(&quot;tblRow tblItemNoPaddn&quot;); //tableItem   tblItem  tblItemNoPaddn</span>
<span class="nc" id="L2736">		leftListPC.setTableRowClass(&quot;tblRow&quot;); //tblRow tblRowNoPaddn</span>
<span class="nc" id="L2737">	}</span>

	/**
	 * generate left list header in dual list
	 */
	protected void makeLeftDualLIstHeader(String title){
		//--- left column header ----
<span class="fc" id="L2744">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="fc" id="L2745">		TableHeaderPC leftHeader = leftListPC.getHeader();</span>
<span class="fc" id="L2746">		leftHeader.addColumnHeaderData(null,title);</span>
<span class="fc" id="L2747">	}//makeLeftDualLIstHeader</span>

	/**
	 * generate right list headers with hours for the graph view
	 */
	protected void makeRightDualListHeader(int[] shownHours){
		//--- right headers = times within shown hours ----
<span class="nc" id="L2754">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2755">		TableHeaderPC rightHeader = rightListPC.getHeader();</span>

		
<span class="nc" id="L2758">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc bnc" id="L2759" title="All 2 branches missed.">		Calendar startCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartCalendar(tz, m_locale):m_timeRange.getStartCalendar(tz, m_locale);</span>
<span class="nc" id="L2760">		startCal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2761">		boolean startInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">		Calendar endCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getEndCalendar(tz, m_locale):m_timeRange.getEndCalendar(tz, m_locale);</span>
<span class="nc" id="L2763">		endCal.set(Calendar.HOUR_OF_DAY, shownHours[1]);</span>
<span class="nc" id="L2764">		boolean endInDST = tz.inDaylightTime(endCal.getTime());</span>
		
<span class="nc" id="L2766">        Calendar headerCal = (Calendar)startCal.clone();</span>
		// if the startDate is in DST and the endDate is not, then we'll add an extra hour
		//   in this case, for multiple days, the days which don't include the extra hour will skip the extra hour
		// for the other DST transition case: in the spring,
		//   the day that has one less hour will skip the hour that's missing
<span class="nc bnc" id="L2771" title="All 4 branches missed.">		if (!(startInDST &amp;&amp; !endInDST)) {  // if !(add an hour for DST transition from DST to ST)</span>
<span class="nc" id="L2772">			headerCal.set(Calendar.MONTH,1); //to avoid DST-based formatting on DST-switch date </span>
<span class="nc" id="L2773">			headerCal.set(Calendar.DAY_OF_MONTH,1);</span>
<span class="nc" id="L2774">			headerCal.set(Calendar.MINUTE,0);</span>
<span class="nc" id="L2775">			headerCal.set(Calendar.SECOND,0);</span>
<span class="nc" id="L2776">			headerCal.set(Calendar.MILLISECOND,0);</span>
		} else {
<span class="nc" id="L2778">			headerCal = findDSTTransitionDay(tz);</span>
		}

		//put one string with fixed width spans for each hour
<span class="nc" id="L2782">		headerCal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2783">		StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L2784" title="All 2 branches missed.">		for (int i = shownHours[0]; i &lt;= shownHours[1]; i++) {</span>
<span class="nc" id="L2785">			boolean isDST = tz.inDaylightTime(headerCal.getTime());</span>
<span class="nc" id="L2786">			sb.append(&quot;&lt;span class=\&quot;hour\&quot;&gt;&quot;)</span>
<span class="nc" id="L2787">					.append(m_localizer.formatDate(headerCal.getTime(),tz,</span>
						RegionalFormatBundleKey.TIME_FORMAT))
<span class="nc" id="L2789">					.append(&quot;&lt;/span&gt;&quot;);</span>
<span class="nc" id="L2790">			headerCal.add(Calendar.HOUR_OF_DAY,1);</span>
		}
<span class="nc" id="L2792">		rightHeader.addColumnHeaderData(null,sb.toString());</span>
<span class="nc" id="L2793">	}//makeRightDualListHeader</span>

	/**
	 * Initialize Dual List with Models
	 */
	protected void setDualListModels(List lModel, List rModel) {
<span class="fc" id="L2799">		m_dualList.getLeftListPC().setListModel(lModel);</span>
<span class="fc" id="L2800">		m_dualList.getRightListPC().setListModel(rModel);</span>
<span class="fc" id="L2801">	}</span>

    /**
     * Generate Custom JavaScript Code.
     */
    public String getCustomJavaScript() 
    {
<span class="fc" id="L2808">        String js = &quot;&quot;;</span>
<span class="pc bpc" id="L2809" title="1 of 2 branches missed.">        if (m_dualList!=null) {</span>
<span class="fc" id="L2810">            js = &quot;\nfunction customResize() {&quot; +</span>
<span class="fc" id="L2811">                    m_dualList.getName() + &quot;.onResize(); } \n&quot;;</span>
        }
<span class="fc" id="L2813">        return js;</span>
    }//getCustomJavaScript


	//================ abstract ======================
	/** inheriting classes overwrite content tittle with or without group features */
	protected abstract void initContentTitle();

	/** inheriting classes overwrite data loading with or without group data */
	protected abstract void loadAndInitData();

	//////////////////////////////////////////////////////////////////////////////
	// Empty Impl for WorkpaneListPM - to minimize subclass refactoring
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Initialize Header
	 */
<span class="fc" id="L2830">	protected void initHeader() {}</span>

	/**
	 * Initialize Selectable Items
	 */
<span class="fc" id="L2835">	protected void initSelectableItems() {}</span>

	/**
	 * For Story 34045 -PSR 6104 - Reason for Absence viewable only by Supervisor and Employee
     * See if the currently logged-in user is the Supervisor of the specified employee ID ..
     * @param empID The employee ID to check.
     * @return true if the currently logged-in user is the Supervisor of the specified employee ID .
     */
	protected boolean isSupervisor(ID empID) {
<span class="nc" id="L2844">    	return ScheduleViewMH.isSupervisor(m_context, empID, m_myEmpID);</span>
    }

    protected boolean isEnabledAbsentReasonToOnlySupervisor(){
<span class="nc" id="L2848">    	return ScheduleViewMH.enabledAbsentReasonToOnlySupervisor();</span>
    }

	/**
	 * This inner class is necessary in order to show the borders around the outter left and right graph tables.
	 *
	protected class GraphDualListPC extends DualListPC {

		private String BORDER_CLASS1 = &quot; class=\&quot;&quot; + CSSUtil.CLASS_BORDER_DEFAULT + &quot;\&quot; &quot;;
		private String DEFAULT_LWPR_STYLE1 = &quot;overflow:visible; overflow-x:visible !important; overflow-y:visible; border:1px solid #d2d2d2; height:100% !important;&quot;; //grey:d2d2d2 blue:0C99C9   height:400px; overflow-x:auto; overflow-y:hidden;     overflow:auto; works on modern browsers but not IE8
		private String DEFAULT_LWPR_ATTR1 = &quot; style=\&quot;&quot; + DEFAULT_LWPR_STYLE1 + &quot;\&quot; &quot;;
		
		private String DEFAULT_RWPR_STYLE1 = &quot;overflow:visible; overflow-x:visible !important; overflow-y:visible; border:1px solid #d2d2d2; height:100% !important;&quot;; //height:400px; overflow:auto;    overflow:auto; works on modern browsers but not IE8
		private String DEFAULT_RWPR_ATTR1 =  &quot; style=\&quot;&quot; + DEFAULT_RWPR_STYLE1 + &quot;\&quot; &quot;;
		
		public GraphDualListPC(RequestContext context) {
			super(context);
			//initLists();	    
			//setName(&quot;dualList&quot;);    
			setJSMediator(JavaScriptFileID.MEDIATOR_DUAL_LIST_FOR_GRAPH);//&quot;/webroot/uif/js/modules/DualListMediatorForGraph.js&quot;); //JavaScriptFileID.MEDIATOR_DUAL_LIST_FOR_GRAPH);
			addRequiredJavaScriptFile(JavaScriptFileID.MEDIATOR_DUAL_CONTAINER_FOR_GRAPH);
		}
	
		/**
		 * Return Left Wrapper Attributes As String
		 *
		protected String getLWAttrAsString() {
			if (m_leftWprAttr==null || m_leftWprAttr.isEmpty()) {
				if (isBorderEnabled()) return BORDER_CLASS1 + DEFAULT_LWPR_ATTR1;
				else return DEFAULT_LWPR_ATTR1;
			}

			appendDefaultWprAttr(m_leftWprAttr, DEFAULT_LWPR_STYLE1);
			return getVPfromMap(m_leftWprAttr);
		}

		/**
		 * Return Right Wrapper Attributes As String
		 *
		protected String getRWAttrAsString() {
			if (m_rightWprAttr==null || m_rightWprAttr.isEmpty()) {
				if (isBorderEnabled()) return BORDER_CLASS1 + DEFAULT_RWPR_ATTR1;
				else return DEFAULT_RWPR_ATTR1;
			}

			appendDefaultWprAttr(m_rightWprAttr, DEFAULT_RWPR_STYLE1);
			return getVPfromMap(m_rightWprAttr);
		}
	}
	*/
	
}//class
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>