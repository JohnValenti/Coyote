<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleMessageSchedulerUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.facade.scheduling</a> &gt; <span class="el_source">ScheduleMessageSchedulerUtil.java</span></div><h1>ScheduleMessageSchedulerUtil.java</h1><pre class="source lang-java linenums">package com.verint.ejb.facade.scheduling;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingState;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingWarning;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage.SchedulingAction;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageFieldInfo;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParameters;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersFieldInfo;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageRequestMapping;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageRequestMappingDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageRequestMappingFieldInfo;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequest;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestDAO;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestFieldInfo;
import com.verint.ejb.bbm.schedule.util.SchedulingRequestUtil;

<span class="fc" id="L41">public class ScheduleMessageSchedulerUtil {</span>
	private static final String DELIMITER = &quot;|&quot;;
	private static final int ERROR_TYPE_INDEX = -2;
	public static final int COMPLETED_PERCENTAGE_PROGRESS = 100;
	public static final int SCHEDULING_ALGO_UNTIL_STOPPED = 2;

<span class="fc" id="L47">	private static Category m_cat = Log.initCategory(ScheduleMessageSchedulerUtil.class.getName());</span>

	/**
	 * Returns the array of parameters from the delimited parameters.
	 */
	public String[] extractParamters(ScheduleMessage message) {
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">		if (message == null) {</span>
<span class="nc" id="L54">			throw new IllegalArgumentException(&quot;The scheduling message cannot be null&quot;);</span>
		}
<span class="fc" id="L56">		return StringUtil.parseStringToArray(message.getParameters(), DELIMITER);</span>
	}

	/**
	 * Returns the delimited parameters. These are not saved to DB individually
	 * as they need to be in this order and all parameters need to be present
	 * and these will depend on the scheduling action being used
	 * 
	 * @param message
	 * @return
	 */
	public String getDelimitedParameters(ScheduleRequestsMessage message) {
<span class="fc" id="L68">		validateNull(message);</span>
<span class="fc" id="L69">		String[] params = message.getSchedulingParameters();</span>

<span class="pc bpc" id="L71" title="1 of 2 branches missed.">		if (params != null) {</span>
<span class="fc" id="L72">			return StringUtil.createDelimitedString(params, DELIMITER);</span>
		}
<span class="nc" id="L74">		return null;</span>
	}

	/**
	 * Returns the {@link ScheduleMessageRequestMapping} using the parameters in
	 * {@link ScheduleRequestsMessage}
	 */
	public List&lt;ScheduleMessageRequestMapping&gt; getMessageRequestMappings(ScheduleRequestsMessage message,
			ID messageID) {
<span class="fc" id="L83">		List&lt;ScheduleMessageRequestMapping&gt; statuses = new ArrayList&lt;ScheduleMessageRequestMapping&gt;();</span>
<span class="fc" id="L84">		List&lt;ID&gt; requests = message.getRequestsToSchedule();</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">		for (ID request : requests) {</span>
<span class="fc" id="L86">			ScheduleMessageRequestMapping mapping = new ScheduleMessageRequestMapping();</span>
<span class="fc" id="L87">			mapping.setFieldValue(ScheduleMessageRequestMappingFieldInfo.MESSAGEID, messageID);</span>
<span class="fc" id="L88">			mapping.setFieldValue(ScheduleMessageRequestMappingFieldInfo.REQUESTID, request);</span>
<span class="fc" id="L89">			statuses.add(mapping);</span>
<span class="fc" id="L90">		}</span>
<span class="fc" id="L91">		return statuses;</span>
	}

	/**
	 * Returns the {@link ScheduleMessage} using the parameters in
	 * {@link ScheduleRequestsMessage}
	 */
	public ScheduleMessage getDBMessageFromJMSMessage(ScheduleRequestsMessage message) {
<span class="fc" id="L99">		validateNull(message);</span>
<span class="fc" id="L100">		ScheduleMessage dbMessage = new ScheduleMessage();</span>
<span class="fc" id="L101">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.ACTION, message.getSchedulingAction());</span>
<span class="fc" id="L102">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.ENABLELQF, message.isEnableLQF());</span>
<span class="fc" id="L103">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.ISWHATIFMODE, message.isWhatIfMode());</span>
<span class="fc" id="L104">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.OVERRIDESCHEDULES, message.isOverrideSchedules());</span>
<span class="fc" id="L105">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.RECALCSUBCAMPAIGNS, message.isRecalcSubCampaign());</span>
<span class="fc" id="L106">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.PARAMETERS, getDelimitedParameters(message));</span>
<span class="fc" id="L107">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.SCHEDULEINORDER, message.isScheduleInChronologicalOrder());</span>
<span class="fc" id="L108">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.USERSEAL, message.getUserSeal());</span>
<span class="fc" id="L109">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.DATECREATED, Calendar.getInstance().getTime());</span>
<span class="fc" id="L110">		dbMessage.setFieldValue(ScheduleMessageFieldInfo.LASTUPDATED, Calendar.getInstance().getTime());</span>
<span class="fc" id="L111">		return dbMessage;</span>
	}

	/**
	 * Updates the ScheduleMessage
	 */
	public void updateMessage(ScheduleMessage message) throws MultiUserException, BbmUpdateException {
<span class="fc" id="L118">		message.setFieldValue(ScheduleMessageFieldInfo.LASTUPDATED, Calendar.getInstance().getTime());</span>
<span class="fc" id="L119">		ScheduleMessageDAO messageDAO = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L121">			messageDAO.updateObject(message);</span>

		} finally {
<span class="pc" id="L124">			messageDAO.cleanUp();</span>
<span class="fc" id="L125">		}</span>
<span class="fc" id="L126">	}</span>

	/**
	 * @param message
	 *            throws illegal argument exception if the message is null
	 */
	private void validateNull(ScheduleRequestsMessage message) {
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">		if (message == null) {</span>
<span class="nc" id="L134">			throw new IllegalArgumentException(&quot;The message cannot be null&quot;);</span>
		}
<span class="fc" id="L136">	}</span>

	/**
	 * Creates the mappings between {@link WSAutoScheduleRequest} and
	 * {@link ScheduleMessage}
	 */
	public void createRequestMappings(ScheduleRequestsMessage message, ID messageID) throws BbmCreateException {
<span class="fc" id="L143">		ScheduleMessageRequestMappingDAO dao = new ScheduleMessageRequestMappingDAO();</span>
		try {
<span class="fc" id="L145">			dao.createObjects(getMessageRequestMappings(message, messageID));</span>
		} finally {
<span class="pc" id="L147">			dao.cleanUp();</span>
<span class="fc" id="L148">		}</span>
<span class="fc" id="L149">	}</span>

	/**
	 * Creates {@link ScheduleMessageParameters} for the message.
	 */
	public void createSecondaryParameters(ScheduleRequestsMessage message, ID messageID) throws BbmCreateException {
<span class="fc" id="L155">		Map&lt;String, Object&gt; secondaryParams = message.getScheduleRequestParameters().getSecondarySchedParams();</span>
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">		if (secondaryParams == null) {</span>
<span class="nc" id="L157">			return;</span>
		}
<span class="fc" id="L159">		ScheduleMessageParameters parameters = new ScheduleMessageParameters();</span>
<span class="fc" id="L160">		List&lt;String&gt; allFieldNames = Arrays.asList(parameters.getFieldNames());</span>
<span class="fc" id="L161">		parameters.setFieldValue(ScheduleMessageParametersFieldInfo.MESSAGEID, messageID);</span>
<span class="fc" id="L162">		ScheduleMessageParametersDAO dao = new ScheduleMessageParametersDAO();</span>
		try {
<span class="fc bfc" id="L164" title="All 2 branches covered.">			for (Entry&lt;String, Object&gt; entry : secondaryParams.entrySet()) {</span>
<span class="pc bpc" id="L165" title="1 of 2 branches missed.">				if (allFieldNames.contains(entry.getKey())) {</span>
<span class="fc" id="L166">					int fieldIndex = dao.getDaoFieldInfo().getFieldIndexByName(entry.getKey());</span>
<span class="fc" id="L167">					parameters.setFieldValue(fieldIndex, entry.getValue());</span>
				}
<span class="fc" id="L169">			}</span>
<span class="fc" id="L170">			dao.createObject(parameters);</span>
		} finally {
<span class="pc" id="L172">			dao.cleanUp();</span>
<span class="fc" id="L173">		}</span>
<span class="fc" id="L174">	}</span>

	/**
	 * deletes the parameters for the given messages.
	 */
	public void deleteMessageParametersByMessageID(List&lt;ID&gt; messageIDs) throws BbmRemoveException {
<span class="fc" id="L180">		ScheduleMessageParametersDAO dao = new ScheduleMessageParametersDAO();</span>
		try {
<span class="fc" id="L182">			dao.deleteObjectsWithParentIDs(messageIDs);</span>
		} finally {
<span class="pc" id="L184">			dao.cleanUp();</span>
<span class="fc" id="L185">		}</span>
<span class="fc" id="L186">	}</span>

	/**
	 * Deletes the messages with the given IDs
	 */
	public void deleteMessages(List&lt;ID&gt; messageIDs) throws BbmRemoveException {
<span class="fc" id="L192">		ScheduleMessageDAO dao = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L194">			dao.deleteObjects(messageIDs);</span>
		} finally {
<span class="pc" id="L196">			dao.cleanUp();</span>
<span class="fc" id="L197">		}</span>
<span class="fc" id="L198">	}</span>

	/**
	 * Deletes the request mappings for the given messages.
	 */
	public void deleteMessageRequestMappingsByMessageIDs(List&lt;ID&gt; messageIDs) throws BbmRemoveException {
<span class="fc" id="L204">		ScheduleMessageRequestMappingDAO dao = new ScheduleMessageRequestMappingDAO();</span>
		try {
<span class="fc" id="L206">			dao.deleteObjectsWithParentIDs(messageIDs);</span>
		} finally {
<span class="pc" id="L208">			dao.cleanUp();</span>
<span class="fc" id="L209">		}</span>
<span class="fc" id="L210">	}</span>

	/**
	 * Deletes the SchedulingMessage for which the requests are all processed.
	 */
	public void clearCompletedMessages() throws BbmFinderException, BbmRemoveException {
<span class="fc" id="L216">		Collection&lt;ScheduleMessage&gt; allMessages = getAllMessages();</span>
<span class="fc" id="L217">		List&lt;ID&gt; toDelete = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">		for (ScheduleMessage message : allMessages) {</span>
<span class="fc" id="L219">			Collection&lt;ScheduleMessageRequestMapping&gt; mappings = getMappings(message.getID());</span>
<span class="fc" id="L220">			List&lt;WSAutoScheduleRequest&gt; newRequests = getRequestsByStatus(getRequestIDs(mappings),</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);
<span class="fc" id="L222">			List&lt;WSAutoScheduleRequest&gt; inProcessRequests = getRequestsByStatus(getRequestIDs(mappings),</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS);
<span class="pc bpc" id="L224" title="1 of 4 branches missed.">			if (newRequests.isEmpty() &amp;&amp; inProcessRequests.isEmpty()) {</span>
<span class="fc" id="L225">				toDelete.add(message.getID());</span>
			}
<span class="fc" id="L227">		}</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">		if (!toDelete.isEmpty()) {</span>
<span class="fc" id="L229">			deleteMessageRequestMappingsByMessageIDs(toDelete);</span>
<span class="fc" id="L230">			deleteMessageParametersByMessageID(toDelete);</span>
<span class="fc" id="L231">			deleteMessages(toDelete);</span>
		}
<span class="fc" id="L233">	}</span>

	/**
	 * Copies the current state from schedulingState to request and returns true
	 * if there is an error.
	 */
	public boolean copySchedulingStateToRequestAndGetErrorStatus(WSAutoScheduleRequest request, SchedulingState state) {
<span class="fc" id="L240">		int progress = state.getOverallStatus();</span>
<span class="fc" id="L241">		request.setFieldValue(WSAutoScheduleRequestFieldInfo.PROGRESS, progress);</span>
<span class="pc bpc" id="L242" title="1 of 2 branches missed.">		if (progress == COMPLETED_PERCENTAGE_PROGRESS) {</span>
<span class="fc" id="L243">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_COMPLETED);
<span class="fc" id="L245">			m_cat.info(&quot;Scheduling completed for Scheduling Period &quot; + request.getSPID());</span>
		}
<span class="fc" id="L247">		Collection warnings = state.getWarnings();</span>
<span class="fc" id="L248">		boolean hasError = false;</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">		if (!warnings.isEmpty()) {</span>
<span class="nc" id="L250">			StringBuilder warnCodeBuffer = new StringBuilder();</span>
<span class="nc" id="L251">			StringBuilder warnMessageBuffer = new StringBuilder();</span>
<span class="nc" id="L252">			int i = 0;</span>

<span class="nc bnc" id="L254" title="All 2 branches missed.">			for (Iterator it = warnings.iterator(); it.hasNext();) {</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">				if (i &gt; 0) {</span>
<span class="nc" id="L256">					warnCodeBuffer.append(&quot;|&quot;);</span>
<span class="nc" id="L257">					warnMessageBuffer.append(&quot;|&quot;);</span>
				}
<span class="nc" id="L259">				i++;</span>
<span class="nc" id="L260">				SchedulingWarning warning = (SchedulingWarning) it.next();</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">				if (warning.getTypeIndex() == ERROR_TYPE_INDEX) {</span>
<span class="nc" id="L262">					hasError = true;</span>
				}
<span class="nc" id="L264">				warnCodeBuffer.append(warning.getTypeString());</span>
<span class="nc" id="L265">				warnMessageBuffer.append(warning.getWarning());</span>

<span class="nc" id="L267">			}</span>
<span class="nc" id="L268">			String originalCode = (String) request.getFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGETYPE);</span>
<span class="nc" id="L269">			String originalMessage = request.getStatusMessage();</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGETYPE,</span>
<span class="nc" id="L271">					originalCode == null ? warnCodeBuffer.toString() : originalCode + &quot;|&quot; + warnCodeBuffer.toString());</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE, originalMessage == null</span>
<span class="nc" id="L273">					? warnMessageBuffer.toString() : originalMessage + &quot;|&quot; + warnMessageBuffer.toString());</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">			if (hasError) {</span>
<span class="nc" id="L275">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
<span class="nc" id="L277">				m_cat.error(&quot;Error while scheduling Request &quot; + request.getSPID() + &quot; Status is &quot; + state.toString());</span>
			}
		}
<span class="fc" id="L280">		return hasError;</span>
	}

	/**
	 * Returns true if an there is scheduling pending for SPs ending earlier
	 * that this SP
	 * 
	 * @param spID
	 * @return
	 */
	public boolean isEarlierSchedulingPeriodRequestIncomplete(int spID) {
<span class="fc" id="L291">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>

<span class="fc" id="L293">		String[] status = new String[] { WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
				WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS };
		try {
<span class="fc bfc" id="L296" title="All 2 branches covered.">			return !dao.getRequestsBeforeSPByStatus(spID, status, true).isEmpty();</span>
<span class="nc" id="L297">		} catch (JdmoException e) {</span>
<span class="nc" id="L298">			m_cat.warn(&quot;Error checking if there are requests for scheduling for a period earlier than the SP &quot; + spID,</span>
					e);
		} finally {
<span class="pc" id="L301">			dao.cleanUp();</span>
<span class="nc" id="L302">		}</span>
		// changing the default to false considering the risk it imposes with
		// true.
<span class="nc" id="L305">		return false;</span>
	}

	/**
	 * Returns all the requests that are associated with the scheduling message
	 */
	public List&lt;ID&gt; getRequestIDs(Collection&lt;ScheduleMessageRequestMapping&gt; mappings) throws BbmFinderException {
<span class="fc" id="L312">		List&lt;ID&gt; requestIds = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">		for (Iterator&lt;ScheduleMessageRequestMapping&gt; it = mappings.iterator(); it.hasNext();) {</span>
<span class="fc" id="L314">			requestIds.add(it.next().getRequestID());</span>
		}
<span class="fc" id="L316">		return requestIds;</span>
	}

	/**
	 * Checks if there any open requests for the given sp
	 * 
	 * @return
	 */
	public boolean doOpenRequestsExist(ID spID) {
<span class="fc" id="L325">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
		try {
<span class="fc" id="L327">			return !dao.getObjects(&quot;A.SPID = &quot; + JdmoUtil.asSqlLiteral(spID.toInt()) + &quot; AND A.SCHEDULESTATUS = &quot;</span>
<span class="pc bpc" id="L328" title="1 of 2 branches missed.">					+ JdmoUtil.asSqlLiteral(WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS)).isEmpty();</span>
<span class="nc" id="L329">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L330">			m_cat.error(&quot;Error getting the scheduling requests for Scheduling Period &quot; + spID, e);</span>
		} finally {
<span class="pc" id="L332">			dao.cleanUp();</span>
<span class="nc" id="L333">		}</span>
<span class="nc" id="L334">		return false;</span>
	}

	/**
	 * Increments the error retry count all requests of given status. Does not
	 * handle nulls.
	 */
	public void incrementErrorRetryCount(String status) throws JdmoException {
<span class="fc" id="L342">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
		try {
<span class="fc" id="L344">			dao.incrementErrorRetryCountForRequests(status);</span>
		} finally {
<span class="pc" id="L346">			dao.cleanUp();</span>
<span class="fc" id="L347">		}</span>
<span class="fc" id="L348">	}</span>

	/**
	 * Returns all the messages
	 */
	public Collection&lt;ScheduleMessage&gt; getAllMessages() throws BbmFinderException {
<span class="fc" id="L354">		ScheduleMessageDAO messageDAO = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L356">			return messageDAO.getMessagesByLastUpdated();</span>
		} finally {
<span class="pc" id="L358">			messageDAO.cleanUp();</span>
		}
	}

	/**
	 * Returns all the messagerequestmappings for the message. Returns null if
	 * there is an FinderException getting the mappings for the messge ID
	 * 
	 */
	public Collection&lt;ScheduleMessageRequestMapping&gt; getMappings(ID messageID) {
<span class="fc" id="L368">		ScheduleMessageRequestMappingDAO mappingDAO = new ScheduleMessageRequestMappingDAO();</span>
		try {
			// get all requests
<span class="fc" id="L371">			return mappingDAO.getRequestsForMessage(messageID);</span>
<span class="nc" id="L372">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L373">			m_cat.error(&quot;Could not get requests for message &quot; + messageID, e);</span>
<span class="nc" id="L374">			return Collections.emptyList();</span>
		} finally {
<span class="pc" id="L376">			mappingDAO.cleanUp();</span>
		}
	}

	/**
	 * Returns the requests by the status and the request Ids. If the requests
	 * is empty or null, this method returns the requests by status
	 * 
	 * @throws BbmFinderException
	 */
	public List&lt;WSAutoScheduleRequest&gt; getRequestsByStatus(List&lt;ID&gt; requests, String status) throws BbmFinderException {
<span class="fc" id="L387">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
		try {
<span class="pc bpc" id="L389" title="1 of 4 branches missed.">			if (requests == null || requests.isEmpty()) {</span>
<span class="fc" id="L390">				return dao.getRequestsByStatus(status);</span>
			} else {
<span class="fc" id="L392">				return dao.getRequestsByStatus(status, requests);</span>
			}
		} finally {
<span class="pc" id="L395">			dao.cleanUp();</span>
		}
	}

	/**
	 * Returns the scheduling action for the requests. Does not handle nulls.
	 */
	public Map&lt;ID, SchedulingAction&gt; getSchedulingActionForRequests(List&lt;WSAutoScheduleRequest&gt; requests)
			throws JdmoException {
<span class="fc" id="L404">		List&lt;ID&gt; requestIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">		for (WSAutoScheduleRequest request : requests) {</span>
<span class="fc" id="L406">			requestIDs.add(request.getID());</span>
<span class="fc" id="L407">		}</span>

<span class="fc" id="L409">		ScheduleMessageDAO messageDAO = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L411">			return messageDAO.getSchedulingActionByRequestID(requestIDs);</span>
		} finally {
<span class="pc" id="L413">			messageDAO.cleanUp();</span>
		}
	}

	/**
	 * Updates the scheduling request. &lt;b&gt;Note:&lt;/b&gt; Does not handle null!
	 */
	public void updateRequest(WSAutoScheduleRequest request) throws MultiUserException, BbmUpdateException {
<span class="fc" id="L421">		List&lt;WSAutoScheduleRequest&gt; requests = new ArrayList&lt;WSAutoScheduleRequest&gt;();</span>
<span class="fc" id="L422">		requests.add(request);</span>
<span class="fc" id="L423">		updateRequests(requests);</span>
<span class="fc" id="L424">	}</span>

	/**
	 * Updates the scheduling requests. &lt;b&gt;Note:&lt;/b&gt; Does not handle nulls!
	 */
	public void updateRequests(List&lt;WSAutoScheduleRequest&gt; requests) throws MultiUserException, BbmUpdateException {
<span class="fc bfc" id="L430" title="All 2 branches covered.">		for (WSAutoScheduleRequest request : requests) {</span>
<span class="fc" id="L431">			request.setLastUpdated(Calendar.getInstance().getTime());</span>
<span class="fc" id="L432">		}</span>
<span class="fc" id="L433">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
		try {
<span class="fc" id="L435">			dao.updateObjects(requests);</span>
		} finally {
<span class="pc" id="L437">			dao.cleanUp();</span>
<span class="fc" id="L438">		}</span>
<span class="fc" id="L439">	}</span>

	/**
	 * Updated the status and the status message for request &lt;b&gt;Note:&lt;/b&gt; Does
	 * not handle nulls!
	 */
	public void updateScheduleStatusForRequest(ID request, String oldSttaus, String newStatus, String statusMessage)
			throws JdmoException {
<span class="nc" id="L447">		List&lt;ID&gt; requests = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L448">		requests.add(request);</span>
<span class="nc" id="L449">		updateScheduleStatusForRequests(requests, oldSttaus, newStatus, statusMessage);</span>

<span class="nc" id="L451">	}</span>

	/**
	 * Updated the status and the status message for requests &lt;b&gt;Note:&lt;/b&gt; Does
	 * not handle nulls!
	 */
	private void updateScheduleStatusForRequests(List&lt;ID&gt; requests, String oldSttaus, String newStatus,
			String statusMessage) throws JdmoException {
<span class="nc" id="L459">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
		try {
<span class="nc" id="L461">			dao.updateScheduleStatus(requests, oldSttaus, newStatus, statusMessage);</span>
		} finally {
<span class="nc" id="L463">			dao.cleanUp();</span>
<span class="nc" id="L464">		}</span>
<span class="nc" id="L465">	}</span>

	/**
	 * checks if the SP for the request is already scheduled and updates the
	 * status as already scheduled. Returns true if the SP is already scheduled,
	 * else returns false
	 */
	public boolean checkIfAlreadyScheduledAndUpdate(WSAutoScheduleRequest request) {
		// if we cannot override existing schedules, the request
		// should not be scheduled.
<span class="nc" id="L475">		int spID = request.getSPID();</span>
		// check if this is already scheduled once
<span class="nc" id="L477">		boolean isScheduled = SchedulingRequestUtil.getInstance().doesScheduleExist(spID);</span>
<span class="nc bnc" id="L478" title="All 2 branches missed.">		if (isScheduled) {</span>
			// debug message
<span class="nc" id="L480">			m_cat.debug(&quot;The Scheduling Request of ID &quot; + request.getID() + &quot; for the scheduling period &quot;</span>
<span class="nc" id="L481">					+ request.getSPID()</span>
					+ &quot; will not be scheduled as schedule already exists for the scheduling period&quot;);
			// if it is already scheduled, update request
			// status
			// and
			// continue
			try {
<span class="nc" id="L488">				updateScheduleStatusForRequest(request.getID(), WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_WILL_NOT_SCHEDULED,
						&quot;This SP is already scheduled and will not be scheduled.&quot;);

<span class="nc" id="L492">			} catch (Exception e) {</span>
<span class="nc" id="L493">				m_cat.error(&quot;Error updating the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L494">						+ &quot; for the scheduling period &quot; + request.getSPID(), e);</span>
<span class="nc" id="L495">			}</span>
<span class="nc" id="L496">			return true;</span>
		}
<span class="nc" id="L498">		return false;</span>
	}

	public boolean validateSecondaryParamsAndUpdateInvalidRequests(ScheduleRequestsMessage message) {
		// validate message if time to schedule is schedule until stopped, do
		// not accept such message
<span class="fc" id="L504">		Map&lt;String, Object&gt; secondaryParameters = message.getScheduleRequestParameters().getSecondarySchedParams();</span>
<span class="pc bpc" id="L505" title="1 of 2 branches missed.">		if (secondaryParameters != null</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">				&amp;&amp; secondaryParameters.get(ScheduleMessageParametersFieldInfo.DAYS_TO_SCHEDULE) != null</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">				&amp;&amp; ((Integer) secondaryParameters</span>
<span class="nc" id="L508">						.get(ScheduleMessageParametersFieldInfo.DAYS_TO_SCHEDULE) &gt;= SCHEDULING_ALGO_UNTIL_STOPPED)) {</span>
<span class="nc" id="L509">			m_cat.error(&quot;This message cannot be scheduled as the scheduling action is schedule until stop. &quot;</span>
					+ &quot;This cannot be handled by the scheduling engine as there no option for user intervention.&quot;);
			try {
<span class="nc" id="L512">				updateScheduleStatusForRequests(message.getRequestsToSchedule(),</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_NEW, WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,
						&quot;Could not schedule as the scheduling algorithm used is schedule until stop!&quot;);
<span class="nc" id="L515">			} catch (JdmoException e) {</span>
<span class="nc" id="L516">				m_cat.error(&quot;Error updating the requests&quot;, e);</span>
<span class="nc" id="L517">			}</span>
<span class="nc" id="L518">			return false;</span>
		}
<span class="fc" id="L520">		return true;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>