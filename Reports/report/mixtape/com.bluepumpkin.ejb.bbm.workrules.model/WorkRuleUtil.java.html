<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkRuleUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.model</a> &gt; <span class="el_source">WorkRuleUtil.java</span></div><h1>WorkRuleUtil.java</h1><pre class="source lang-java linenums">/*
 * ï¿½ 2001-2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.workrules.model;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.empworkrule.model.TimePeriodOfDay;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.verint.ejb.wfm.IWorkRuleUtil;

<span class="fc" id="L26">public class WorkRuleUtil implements IWorkRuleUtil {</span>
	
	public static LocalDate ExpandRuleWindowStartDate(ArrayList aWorkRules, LocalDate dtStartDate, LocalDate dtEndDate)
	throws WorkRuleException{
<span class="nc bnc" id="L30" title="All 2 branches missed.">		if (aWorkRules.isEmpty())</span>
<span class="nc" id="L31">			return dtStartDate;</span>
		
<span class="nc" id="L33">		LocalDate dtNewStartDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L34">		LocalDate dtLastDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L35">		int nLastPriority = -1;</span>
		
		//iterate over the rules in reverse priority order, expand the start window for each priority
<span class="nc" id="L38">		ListIterator i = aWorkRules.listIterator(aWorkRules.size() - 1);</span>
<span class="nc" id="L39">		WorkRule pWorkRule = (WorkRule)aWorkRules.get(aWorkRules.size() - 1);</span>
		while(true) {
<span class="nc" id="L41">			int nCurrentPriority = pWorkRule.getPriority();</span>
<span class="nc bnc" id="L42" title="All 2 branches missed.">			if (nCurrentPriority != nLastPriority) {</span>
<span class="nc" id="L43">				dtNewStartDate = new LocalDate(dtLastDate);</span>
<span class="nc" id="L44">				dtLastDate = pWorkRule.expandStartDate(dtNewStartDate,dtEndDate);</span>
			}
			else { //nCurrentPriority == nLastPriority
<span class="nc" id="L47">				LocalDate dtCurrentDate = pWorkRule.expandStartDate(dtNewStartDate,dtEndDate);</span>
<span class="nc bnc" id="L48" title="All 2 branches missed.">				if (dtCurrentDate.getTime().before(dtLastDate.getTime()))</span>
<span class="nc" id="L49">					dtLastDate = new LocalDate(dtCurrentDate);</span>
			}
<span class="nc" id="L51">			nLastPriority = nCurrentPriority;</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">			if (i.hasPrevious())</span>
<span class="nc" id="L53">				pWorkRule = (WorkRule)i.previous();</span>
			else break;
<span class="nc" id="L55">		}</span>
		
<span class="nc" id="L57">		dtNewStartDate = new LocalDate(dtLastDate);</span>
<span class="nc" id="L58">		return dtNewStartDate;</span>
	}
	
	public static Pair&lt;LocalDate, LocalDate&gt; ExpandRuleWindow(ArrayList&lt;WorkRule&gt; aWorkRules, LocalDate dtInitialStart, LocalDate dtInitialEnd)
	throws WorkRuleException{
<span class="nc bnc" id="L63" title="All 2 branches missed.">		if (aWorkRules.isEmpty())</span>
<span class="nc" id="L64">			return new Pair&lt;LocalDate, LocalDate&gt;(dtInitialStart,dtInitialEnd);</span>
		
<span class="nc" id="L66">		LocalDate dtStartDate = new LocalDate(dtInitialStart);</span>
<span class="nc" id="L67">		LocalDate dtEndDate = new LocalDate(dtInitialEnd);</span>
		
<span class="nc" id="L69">		LocalDate dtMinStartDate = new LocalDate(dtStartDate);</span>
<span class="nc" id="L70">		LocalDate dtMaxEndDate = new LocalDate(dtEndDate);</span>
		
<span class="nc" id="L72">		int nLastPriority = -1;</span>
		
		//iterate over the rules in reverse priority order,
		//for each priority group: expand the window to the max window needed
<span class="nc" id="L76">		ListIterator&lt;WorkRule&gt; i = aWorkRules.listIterator(aWorkRules.size() - 1);</span>
<span class="nc" id="L77">		WorkRule pWorkRule = aWorkRules.get(aWorkRules.size() - 1);</span>
		while(true) {
			
<span class="nc bnc" id="L80" title="All 2 branches missed.">			if (pWorkRule.getPriority() != nLastPriority) {</span>
				//found a new priority group
<span class="nc" id="L82">				dtStartDate = new LocalDate(dtMinStartDate);</span>
<span class="nc" id="L83">				dtEndDate = new LocalDate(dtMaxEndDate);</span>
			}
			
<span class="nc" id="L86">			Pair pWindow = pWorkRule.expandWindow(dtStartDate,dtEndDate);</span>
<span class="nc" id="L87">			LocalDate dtRuleStart = (LocalDate)pWindow.getFirst();</span>
<span class="nc" id="L88">			LocalDate dtRuleEnd = (LocalDate)pWindow.getSecond();</span>
			
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (dtRuleStart.getTime().before(dtMinStartDate.getTime()))</span>
<span class="nc" id="L91">				dtMinStartDate = new LocalDate(dtRuleStart);</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">			if (dtRuleEnd.getTime().after(dtMaxEndDate.getTime()))</span>
<span class="nc" id="L93">				dtMaxEndDate = new LocalDate(dtRuleEnd);</span>
			
<span class="nc" id="L95">			nLastPriority = pWorkRule.getPriority();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">			if (i.hasPrevious())</span>
<span class="nc" id="L97">				pWorkRule = i.previous();</span>
			else break;
<span class="nc" id="L99">		}</span>
		
<span class="nc" id="L101">		return new Pair&lt;LocalDate, LocalDate&gt;(dtMinStartDate,dtMaxEndDate);</span>
	}
	
	/**
	 * 
	 * @param dtStartDate
	 * @param dtEndDate
	 * @param idWorkResource
	 * @param pOrganization
	 * @param hWorkRules
	 * @param pEvents
	 * @return
	 * @throws WorkRuleException
	 */
	public Collection&lt;CommonConflict&gt; getConflictsForEmployeeInt(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents)
	throws WorkRuleException {
<span class="nc" id="L119">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L120">				new LocalDate(dtEndDate,pOrganization.getTimeZone()), idWorkResource,</span>
<span class="nc" id="L121">				pOrganization, hWorkRules.values(), pEvents, false);</span>
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L128">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L129">				new LocalDate(dtEndDate,pOrganization.getTimeZone()),</span>
<span class="nc" id="L130">				idWorkResource, pOrganization, hWorkRules.values(), pEvents, isMonthlySP);</span>
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(Date dtStartDate, Date dtEndDate,
			ID idWorkResource, Organization pOrganization,
			Collection&lt;WorkRule&gt; cWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L137">		return getConflictsForEmployee(new LocalDate(dtStartDate, pOrganization.getTimeZone()),</span>
<span class="nc" id="L138">				new LocalDate(dtEndDate,pOrganization.getTimeZone()),</span>
				idWorkResource, pOrganization,
				cWorkRules, pEvents, isMonthlySP);
	}
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(LocalDate dtStartDate, LocalDate dtEndDate,
			ID idWorkResource, Organization pOrganization,
			HashMap hWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
<span class="nc" id="L147">		return getConflictsForEmployee(dtStartDate,	dtEndDate,</span>
				idWorkResource, pOrganization,
<span class="nc" id="L149">				hWorkRules.values(), pEvents, isMonthlySP);</span>
	}
	
	
	public static Collection&lt;CommonConflict&gt; getConflictsForEmployee(LocalDate dtStartDate, LocalDate dtEndDate,
			ID idWorkResource, Organization pOrganization,
			Collection&lt;WorkRule&gt; cWorkRules, Collection&lt;? extends Event&gt; pEvents, boolean isMonthlySP)
	throws WorkRuleException {
		
<span class="nc" id="L158">		LinkedList&lt;CommonConflict&gt; llAllConflicts = new LinkedList&lt;CommonConflict&gt;();</span>
		
		//sort WorkRules to priority order
<span class="nc" id="L161">		ArrayList&lt;WorkRule&gt; pWorkRules = new ArrayList&lt;WorkRule&gt;(cWorkRules);</span>
<span class="nc" id="L162">		Collections.sort(pWorkRules);</span>
		
		//LocalDate dtNewStartDate = WorkRuleUtil.ExpandRuleWindowStartDate(pWorkRules,dtStartDate,dtEndDate);
<span class="nc" id="L165">		int eOverlap = WorkRule.MAJORITYIN;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		for( Iterator&lt;WorkRule&gt; w = pWorkRules.iterator(); w.hasNext(); ) {</span>
<span class="nc" id="L167">			WorkRule pWorkRule = w.next();</span>
<span class="nc" id="L168">			eOverlap = pWorkRule.getOverlap();</span>
<span class="nc" id="L169">			Collection&lt;CommonConflict&gt; pConflicts = pWorkRule.getConflicts(idWorkResource,pOrganization,</span>
					dtStartDate,dtEndDate,pEvents, llAllConflicts, isMonthlySP);
<span class="nc" id="L171">			llAllConflicts.addAll(pConflicts);</span>
<span class="nc" id="L172">		}</span>
		
<span class="nc" id="L174">		Date dtOrgStartDate = TimeZoneUtil.getMidNightDate(dtStartDate.getTime(), pOrganization.getTimeZone());</span>
<span class="nc" id="L175">		Date dtOrgEndDate = TimeZoneUtil.getMidNightDate(dtEndDate.getTime(), pOrganization.getTimeZone());</span>
		
<span class="nc" id="L177">		return getConflictsInWindow(dtOrgStartDate,dtOrgEndDate,llAllConflicts,pEvents,eOverlap);</span>
	}
	
	
	public static Collection&lt;CommonConflict&gt; getConflictsInWindow(Date dtOrgStartDate, Date dtOrgEndDate,
			Collection&lt;CommonConflict&gt; apAllConflicts, Collection&lt;? extends Event&gt; pEvents, int eOverlap) {
		
<span class="nc" id="L184">		LinkedList&lt;CommonConflict&gt; llPeriodConflicts = new LinkedList&lt;CommonConflict&gt;();</span>
		
		//throw away conflicts outside time window, this is pretty inefficient
<span class="nc bnc" id="L187" title="All 2 branches missed.">		for (Iterator&lt;CommonConflict&gt; c = apAllConflicts.iterator(); c.hasNext(); ) {</span>
<span class="nc" id="L188">			CommonConflict pConflict = c.next();</span>
<span class="nc" id="L189">			ID idEvent = pConflict.getEventID();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (idEvent == null) {</span>
				//check to see if the Conflict occurred inside the period
<span class="nc bnc" id="L192" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriod(pConflict.getStartDate(),pConflict.getEndDate(),</span>
						dtOrgStartDate, dtOrgEndDate,eOverlap))
<span class="nc" id="L194">					llPeriodConflicts.add(pConflict);</span>
			}
			else {
				//check to see if the Event occurred within the period
<span class="nc bnc" id="L198" title="All 2 branches missed.">				for (Iterator&lt;? extends Event&gt; e = pEvents.iterator(); e.hasNext(); ) {</span>
<span class="nc" id="L199">					Event pEvent = e.next();</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">					if (pEvent.getID() != null) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">						if (pEvent.getID().equals(idEvent)) {  //XXX what about event type</span>
							//found the event...
<span class="nc bnc" id="L203" title="All 2 branches missed.">							if (WorkRuleUtil.isInPeriod(pEvent.getStartTime(),pEvent.getEndTime(),</span>
									dtOrgStartDate, dtOrgEndDate,eOverlap))
<span class="nc" id="L205">								llPeriodConflicts.add(pConflict);</span>
							break;
						}
					}
<span class="nc" id="L209">				}</span>
			}
<span class="nc" id="L211">		}</span>
<span class="nc" id="L212">		return llPeriodConflicts;</span>
	}
	
	public static Collection&lt;TimeSpan&gt; getOverlap(TimeSpan pEvent, Collection&lt;TimeSpan&gt; pPeriods) {
<span class="nc" id="L216">		LinkedList&lt;TimeSpan&gt; llPeriods = new LinkedList&lt;TimeSpan&gt;();</span>
		
<span class="nc bnc" id="L218" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = pPeriods.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L219">			TimeSpan pPeriod = i.next();</span>
			
			
			//check for overlap
<span class="nc bnc" id="L223" title="All 4 branches missed.">			if (pEvent.dtSpanStart.before(pPeriod.dtSpanEnd) &amp;&amp; pEvent.dtSpanEnd.after(pPeriod.dtSpanStart)) {</span>
				//there is an overlap, add it to the collection
<span class="nc" id="L225">				TimeSpan pOverlap = new TimeSpan();</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">				if (pEvent.dtSpanStart.after(pPeriod.dtSpanStart))</span>
<span class="nc" id="L227">					pOverlap.dtSpanStart = pEvent.dtSpanStart;</span>
				else
<span class="nc" id="L229">					pOverlap.dtSpanStart = pPeriod.dtSpanStart;</span>
				
<span class="nc bnc" id="L231" title="All 2 branches missed.">				if (pEvent.dtSpanEnd.before(pPeriod.dtSpanEnd))</span>
<span class="nc" id="L232">					pOverlap.dtSpanEnd = pEvent.dtSpanEnd;</span>
				else
<span class="nc" id="L234">					pOverlap.dtSpanEnd = pPeriod.dtSpanEnd;</span>
				
<span class="nc" id="L236">				llPeriods.add(pOverlap);</span>
			}
<span class="nc" id="L238">		}</span>
<span class="nc" id="L239">		return llPeriods;</span>
	}
	
	public static boolean isInPeriod(Date dtStart,Date dtEnd,Date dtPeriodStart,
			Date dtPeriodEnd,int eOverlap) {
<span class="nc bnc" id="L244" title="All 2 branches missed.">		if (eOverlap == WorkRule.STARTSIN)</span>
<span class="nc bnc" id="L245" title="All 4 branches missed.">			return (!dtStart.before(dtPeriodStart) &amp;&amp; dtStart.before(dtPeriodEnd));</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">		else if (eOverlap == WorkRule.ENDSIN)</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">			return (!dtEnd.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd));</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">		else if (eOverlap == WorkRule.MAJORITYIN) {</span>
<span class="nc" id="L249">			Date dtMidDate = new Date(dtStart.getTime() + (dtEnd.getTime() - dtStart.getTime())/2);</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">			return (!dtMidDate.before(dtPeriodStart) &amp;&amp; dtMidDate.before(dtPeriodEnd));</span>
		}
		else //eOverlap == WorkRule.PORTIONIN
<span class="nc bnc" id="L253" title="All 4 branches missed.">			return !(dtStart.after(dtPeriodEnd) || dtEnd.before(dtPeriodStart));</span>
	}
	
	public static boolean isInPeriodAndApproved(Event pEvent,Date dtPeriodStart,
			Date dtPeriodEnd,int eOverlap) {
<span class="nc bnc" id="L258" title="All 2 branches missed.">		if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_RECORD &amp;&amp;</span>
<span class="nc bnc" id="L259" title="All 2 branches missed.">				(!((TimeRecord)pEvent).getApprove() ||</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">						((TimeRecord)pEvent).getType() == Event.EVENT_TYPE_TIME_INTERVAL))</span>
<span class="nc" id="L261">			return false;</span>
		
<span class="nc" id="L263">		return isInPeriod(pEvent.getStartTime(),pEvent.getEndTime(),dtPeriodStart,</span>
				dtPeriodEnd,eOverlap);
	}
	
	public static boolean isShiftInPeriod(Event pEvent, Organization pOrg, Date dtPeriodStart,
			Date dtPeriodEnd,TimePeriodOfDay ePartOfDay) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (pEvent.getEventType() != Event.EVENT_TYPE_SHIFT_ASSIGNMENT)</span>
<span class="nc" id="L270">			return false;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if (ePartOfDay != null) {</span>
			//not any time
<span class="nc" id="L273">			Calendar calendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L274">			calendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L275">			int startMinutesFromMidNight = (calendar.get(Calendar.HOUR_OF_DAY) * 60) + calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L276">			int pStart = ePartOfDay.getStartTime().getMinutesSinceMindnight();</span>
<span class="nc" id="L277">			int pEnd = ePartOfDay.getEndTime().getMinutesSinceMindnight();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">			if (pEnd == 0) pEnd = 1440; //bug in TimeOfDay, 1440 will be set to 0 for end time.</span>
<span class="nc bnc" id="L279" title="All 4 branches missed.">			if (!(startMinutesFromMidNight &gt;= pStart &amp;&amp; startMinutesFromMidNight &lt; pEnd)) {</span>
				//not overlap with the specific time period of day
<span class="nc" id="L281">				return false;</span>
			}
			
		}
<span class="nc bnc" id="L285" title="All 4 branches missed.">		return (!pEvent.getStartTime().before(dtPeriodStart) &amp;&amp; pEvent.getStartTime().before(dtPeriodEnd));</span>
	}
	
	public static boolean isShiftInPartOfDay(Event pEvent, Organization pOrg, TimePeriodOfDay ePartOfDay) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">		if (pEvent.getEventType() != Event.EVENT_TYPE_SHIFT_ASSIGNMENT)</span>
<span class="nc" id="L290">			return false;</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (ePartOfDay != null) {</span>
			//not any time
<span class="nc" id="L293">			Calendar calendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L294">			calendar.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L295">			int startMinutesFromMidNight = (calendar.get(Calendar.HOUR_OF_DAY) * 60) + calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L296">			int pStart = ePartOfDay.getStartTime().getMinutesSinceMindnight();</span>
<span class="nc" id="L297">			int pEnd = ePartOfDay.getEndTime().getMinutesSinceMindnight();</span>
<span class="nc bnc" id="L298" title="All 2 branches missed.">			if (pEnd == 0) pEnd = 1440; //bug in TimeOfDay, 1440 will be set to 0 for end time.</span>
<span class="nc bnc" id="L299" title="All 4 branches missed.">			if (!(startMinutesFromMidNight &gt;= pStart &amp;&amp; startMinutesFromMidNight &lt; pEnd)) {</span>
				//not overlap with the specific time period of day
<span class="nc" id="L301">				return false;</span>
			}
		}
<span class="nc" id="L304">		return true;</span>
	}
	
	public static boolean isPreviousDay(Date dtFirst, Date dtSecond,Organization pOrg) {
<span class="nc" id="L308">		Calendar cCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L309">		cCal.setTime(dtFirst);</span>
<span class="nc" id="L310">		cCal.add(Calendar.DAY_OF_YEAR,1);</span>
<span class="nc" id="L311">		int nFirstDay = cCal.get(Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L312">		int nFirstYear = cCal.get(Calendar.YEAR);</span>
<span class="nc" id="L313">		cCal.setTime(dtSecond);</span>
<span class="nc bnc" id="L314" title="All 4 branches missed.">		return (nFirstDay == cCal.get(Calendar.DAY_OF_YEAR) &amp;&amp; nFirstYear == cCal.get(Calendar.YEAR));</span>
	}
	
	public static boolean isPreviousWeekButOne(Date dtFirst, Date dtSecond,Organization pOrg) {
<span class="nc" id="L318">		Calendar cCal = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L319">		cCal.setTime(dtFirst);</span>
<span class="nc" id="L320">		cCal.add(Calendar.DAY_OF_YEAR,6);</span>
<span class="nc" id="L321">		int nFirstDay = cCal.get(Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L322">		int nFirstYear = cCal.get(Calendar.YEAR);</span>
<span class="nc" id="L323">		cCal.setTime(dtSecond);</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">		return (nFirstDay == cCal.get(Calendar.DAY_OF_YEAR) &amp;&amp; nFirstYear == cCal.get(Calendar.YEAR));</span>
	}
	
	/*
	 public static Event splitEvent(Event pEvent, Date dtStart,Date dtEnd) {
	 //eventually this function should split other types of events as well...
	  TimeRecord pTimeRecord = (TimeRecord)pEvent;
	  
	  TimeRecord pNewTimeRecord = new TimeRecord(pTimeRecord.getID(),pTimeRecord.getEmployeeID(),
	  pTimeRecord.getRemarkEmployeeID(),pTimeRecord.getRemarkDate(),
	  &quot;&quot;,pTimeRecord.getApprove(),pTimeRecord.isLocked());
	  for( Iterator i = pTimeRecord.getChildren().iterator(); i.hasNext(); ) {
	  TimeRecordEntry pChild = (TimeRecordEntry)i.next();
	  TimeRecordEntry pChildCopy = new TimeRecordEntry(pChild.getActivityID(),pChild.getStartTime(),
	  pChild.getEndTime(),pChild.getTimeSourceCode(),pChild.getPaid(),&quot;&quot;);
	  
	  if (dtStart.after(pChildCopy.getStartTime()))
	  pChildCopy.setStartTime(dtStart);
	  
	  if (dtEnd.before(pChildCopy.getEndTime()))
	  pChildCopy.setEndTime(dtEnd);
	  
	  if (pChildCopy.getDuration() &gt; 0)
	  pNewTimeRecord.addEntry(pChildCopy);
	  }
	  return (Event)pNewTimeRecord;
	  }
	  */
	public static Event getEventInPeriod(Event pEvent,Date dtPeriodStart,
			Date dtPeriodEnd,int eOverlap) {
<span class="nc" id="L354">		Date dtStart = pEvent.getStartTime();</span>
<span class="nc" id="L355">		Date dtEnd = pEvent.getEndTime();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">		if (eOverlap == WorkRule.STARTSIN)</span>
<span class="nc bnc" id="L357" title="All 4 branches missed.">			if (!dtStart.before(dtPeriodStart) &amp;&amp; dtStart.before(dtPeriodEnd))</span>
<span class="nc" id="L358">				return pEvent;</span>
<span class="nc" id="L359">			else return null;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">		else if (eOverlap == WorkRule.ENDSIN)</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">			if (!dtEnd.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd))</span>
<span class="nc" id="L362">				return pEvent;</span>
<span class="nc" id="L363">			else return null;</span>
		else  { //if (eOverlap == WorkRule.MAJORITYIN) {
<span class="nc" id="L365">			Date dtMidDate = new Date(dtStart.getTime() + (dtEnd.getTime() - dtStart.getTime())/2);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">			if (!dtMidDate.before(dtPeriodStart) &amp;&amp; dtMidDate.before(dtPeriodEnd))</span>
<span class="nc" id="L367">				return pEvent;</span>
<span class="nc" id="L368">			else return null;</span>
		}
//		else { //eOverlap == WorkRule.PORTIONIN
//		if (dtStart.after(dtPeriodEnd) || dtEnd.before(dtPeriodStart))
//		return null;
//		else if (!dtStart.before(dtPeriodStart) &amp;&amp; dtEnd.before(dtPeriodEnd))
//		return pEvent;
//		else
//		return splitEvent(pEvent,dtPeriodStart,dtPeriodEnd);
//		}
	}
	
	private static Collection&lt;TimeSpan&gt; GetUnpaidTimeSpans(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts,
			int nPriority) {
<span class="nc" id="L382">		ArrayList&lt;TimeSpan&gt; aTimeSpans = new ArrayList&lt;TimeSpan&gt;();</span>
		
		//first iterate over the children of the event, add unpaid event to TimeSpan Collection
<span class="nc bnc" id="L385" title="All 2 branches missed.">		for( Iterator&lt;Event&gt; i = pEvent.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L386">			Event pChild = i.next();</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">			if (!pChild.getPaid()) {</span>
<span class="nc" id="L388">				Date dtStart = new Date(pChild.getStartTime().getTime());</span>
<span class="nc" id="L389">				Date dtEnd = new Date(pChild.getEndTime().getTime());</span>
<span class="nc" id="L390">				TimeSpan pTimeSpan = new TimeSpan(dtStart,dtEnd);</span>
<span class="nc" id="L391">				aTimeSpans.add(pTimeSpan);</span>
			}
<span class="nc" id="L393">		}</span>
		
		//next iterate over the entire conflict collection
		//this is somewhat inefficient
<span class="nc bnc" id="L397" title="All 2 branches missed.">		for( Iterator&lt;CommonConflict&gt; i = pConflicts.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L398">			CommonConflict pConflict = i.next();</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">			if (pConflict.getStartDate().before(pEvent.getEndTime()) &amp;&amp;</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">					pConflict.getEndDate().after(pEvent.getStartTime()) &amp;&amp;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">					pConflict.getPriority() &lt; nPriority) {</span>
				
<span class="nc" id="L403">				Date dtStartTime = new Date(pConflict.getStartDate().getTime());</span>
<span class="nc" id="L404">				Date dtEndTime = new Date(pConflict.getEndDate().getTime());</span>
				//truncate conflicts longer then the event
<span class="nc bnc" id="L406" title="All 2 branches missed.">				if (dtStartTime.before(pEvent.getStartTime()))</span>
<span class="nc" id="L407">					dtStartTime = pEvent.getStartTime();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">				if (dtEndTime.after(pEvent.getEndTime()))</span>
<span class="nc" id="L409">					dtEndTime = pEvent.getEndTime();</span>
				
<span class="nc" id="L411">				TimeSpan pTimeSpan = new TimeSpan(dtStartTime,dtEndTime);</span>
<span class="nc" id="L412">				aTimeSpans.add(pTimeSpan);</span>
			}
<span class="nc" id="L414">		}</span>
		
		
		//sort the timespans and remove overlaps
<span class="nc" id="L418">		Collections.sort(aTimeSpans);</span>
<span class="nc" id="L419">		Iterator&lt;TimeSpan&gt; i = aTimeSpans.iterator();</span>
<span class="nc" id="L420">		LinkedList&lt;TimeSpan&gt; llTimeSpans = new LinkedList&lt;TimeSpan&gt;();</span>
		
<span class="nc bnc" id="L422" title="All 2 branches missed.">		if (i.hasNext()) {</span>
<span class="nc" id="L423">			TimeSpan pTimeSpan = i.next();</span>
<span class="nc" id="L424">			Date dtStart = pTimeSpan.dtSpanStart;</span>
<span class="nc" id="L425">			Date dtEnd = pTimeSpan.dtSpanEnd;</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">			while (i.hasNext()) {</span>
<span class="nc" id="L427">				pTimeSpan = i.next();</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.after(dtStart)) {</span>
					//found an overlapping timespan, we may need to extend the start time
<span class="nc bnc" id="L430" title="All 2 branches missed.">					if (pTimeSpan.dtSpanStart.before(dtStart))</span>
<span class="nc" id="L431">						dtStart = pTimeSpan.dtSpanStart;</span>
				}
				else {
					//found a non overlapping timespan, add previous timespan to collection
<span class="nc" id="L435">					llTimeSpans.addLast(new TimeSpan (dtStart,dtEnd));</span>
<span class="nc" id="L436">					dtStart = pTimeSpan.dtSpanStart;</span>
<span class="nc" id="L437">					dtEnd = pTimeSpan.dtSpanEnd;</span>
				}
			}
<span class="nc" id="L440">			llTimeSpans.addLast(new TimeSpan (dtStart,dtEnd));</span>
		}
		
<span class="nc" id="L443">		return llTimeSpans;</span>
	}
	
	public static int GetUnpaidDuration(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts,
			int nPriority) {
		
<span class="nc" id="L449">		Collection&lt;TimeSpan&gt; cTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,nPriority);</span>
		
<span class="nc" id="L451">		int nUnpaid = 0;</span>
		
		//iterate over timespans counting unPaidMinutes
<span class="nc bnc" id="L454" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = cTimeSpans.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L455">			TimeSpan pTimeSpan = i.next();</span>
<span class="nc" id="L456">			nUnpaid += (pTimeSpan.dtSpanEnd.getTime() - pTimeSpan.dtSpanStart.getTime());</span>
<span class="nc" id="L457">		}</span>
		
<span class="nc" id="L459">		nUnpaid /= (60*1000);</span>
<span class="nc" id="L460">		return nUnpaid;</span>
	}
	
	public static int GetUnpaidDuration(Event pEvent) {
		
<span class="nc" id="L465">		int nUnpaid = 0;</span>
		//first iterate over the children of the event, add unpaid event to TimeSpan Collection
<span class="nc bnc" id="L467" title="All 2 branches missed.">		for( Iterator&lt;Event&gt; i = pEvent.getChildren().iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L468">			Event pChild = i.next();</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">			if (!pChild.getPaid()) {</span>
<span class="nc" id="L470">				nUnpaid += pChild.getDuration();</span>
			}
<span class="nc" id="L472">		}</span>
		
<span class="nc" id="L474">		return nUnpaid;</span>
	}
	
	public static Collection&lt;CommonConflict&gt; SplitConflicts(Event pEvent, Collection&lt;CommonConflict&gt; pConflicts, int nPriority,
			Date dtStartDate, Date dtEndDate, boolean bSpread) {
		
		//creates a collection of conflicts which do not overlap any unpaid timespans
		
<span class="nc" id="L482">		Collection&lt;TimeSpan&gt; cTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,nPriority);</span>
		
<span class="nc" id="L484">		Collection&lt;CommonConflict&gt; cNewConflicts = new ArrayList&lt;CommonConflict&gt;();</span>
<span class="nc" id="L485">		Date dtCurrentEndDate = new Date(dtEndDate.getTime());</span>
<span class="nc" id="L486">		Date dtCurrentStartDate = new Date(dtStartDate.getTime());</span>
		
		//iterate over timespans creating conflicts
<span class="nc bnc" id="L489" title="All 2 branches missed.">		for( Iterator&lt;TimeSpan&gt; i = cTimeSpans.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L490">			TimeSpan pTimeSpan = i.next();</span>
			
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (!dtCurrentEndDate.after(pTimeSpan.dtSpanStart))</span>
<span class="nc" id="L493">				continue;</span>
			
<span class="nc bnc" id="L495" title="All 2 branches missed.">			if (bSpread) {</span>
				//check for overlap, then extend start date
<span class="nc bnc" id="L497" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.after(dtCurrentStartDate) &amp;&amp;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">						pTimeSpan.dtSpanStart.before(dtEndDate)) {</span>
<span class="nc" id="L499">					Date dtSpreadEnd = pTimeSpan.dtSpanEnd;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">					if (dtEndDate.before(dtSpreadEnd))</span>
<span class="nc" id="L501">						dtSpreadEnd = dtEndDate;</span>
<span class="nc" id="L502">					dtCurrentStartDate = new Date(dtCurrentStartDate.getTime() -</span>
<span class="nc" id="L503">							(dtSpreadEnd.getTime() - pTimeSpan.dtSpanStart.getTime()));</span>
				}
			}
			
<span class="nc bnc" id="L507" title="All 2 branches missed.">			if (pTimeSpan.dtSpanEnd.before(dtCurrentStartDate))</span>
<span class="nc" id="L508">				break;</span>
			
<span class="nc bnc" id="L510" title="All 2 branches missed.">			if (dtCurrentEndDate.after(pTimeSpan.dtSpanEnd)) {</span>
				//create a conflict from the end of this conflict
<span class="nc bnc" id="L512" title="All 2 branches missed.">				if (pTimeSpan.dtSpanEnd.before(dtCurrentEndDate)) {</span>
<span class="nc" id="L513">					CommonConflict pConflict = new CommonConflict(pTimeSpan.dtSpanEnd,dtCurrentEndDate,pEvent.getID());</span>
<span class="nc" id="L514">					cNewConflicts.add(pConflict);</span>
				}
			}
<span class="nc" id="L517">			dtCurrentEndDate = new Date(pTimeSpan.dtSpanStart.getTime());</span>
<span class="nc" id="L518">		}</span>
		
		//create the last conflict
<span class="nc bnc" id="L521" title="All 2 branches missed.">		if (dtCurrentStartDate.before(dtCurrentEndDate)) {</span>
<span class="nc" id="L522">			CommonConflict pConflict = new CommonConflict(dtCurrentStartDate,dtCurrentEndDate,pEvent.getID());</span>
<span class="nc" id="L523">			cNewConflicts.add(pConflict);</span>
		}
		
<span class="nc" id="L526">		return cNewConflicts;</span>
	}
	
	public static int getPeriodInDays(int ePeriodType, int nPeriodLength) {
<span class="nc bnc" id="L530" title="All 2 branches missed.">		if (ePeriodType == WorkRule.WORKDAY)</span>
<span class="nc" id="L531">			return nPeriodLength;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">		else if (ePeriodType == WorkRule.WORKWEEK)</span>
<span class="nc" id="L533">			return nPeriodLength * 7;</span>
		else //if (ePeriodType == WorkRule.MONTH)
<span class="nc" id="L535">			return nPeriodLength * 31;</span>
	}
/*	
	public static void main(String[] args) {
		try {
			Calendar cCalendar = Calendar.getInstance();
			cCalendar.set(1970,7,10,8,0,0);
			Date dtStart = cCalendar.getTime();
			cCalendar.set(1970,7,10,16,0,0);
			Date dtEnd = cCalendar.getTime();
			
			TestEvent pEvent = new TestEvent(dtStart,dtEnd);
			ArrayList pConflicts = new ArrayList();
			
			cCalendar.set(1970,7,10,12,0,0);
			Date dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,14,0,0);
			Date dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict1 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict1.setPriority(1);
			pConflicts.add(pConflict1);
			
			cCalendar.set(1970,7,10,7,0,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,9,0,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict2 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict2.setPriority(1);
			pConflicts.add(pConflict2);
			
			cCalendar.set(1970,7,10,7,30,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,8,30,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict3 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict2.setPriority(1);
			pConflicts.add(pConflict3);
			
			cCalendar.set(1970,7,10,13,0,0);
			dtStart1 = cCalendar.getTime();
			cCalendar.set(1970,7,10,15,0,0);
			dtEnd1 = cCalendar.getTime();
			
			CommonConflict pConflict4 = new CommonConflict(dtStart1,dtEnd1,null);
			pConflict1.setPriority(1);
			pConflicts.add(pConflict4);
			
			Collection pTimeSpans = GetUnpaidTimeSpans(pEvent,pConflicts,10);
			
			for( Iterator i = pTimeSpans.iterator(); i.hasNext(); ) {
				TimeSpan pPeriod = (TimeSpan)i.next();
				System.out.println(&quot;Unpaid TimeSpan &quot; + pPeriod.dtSpanStart + &quot; &quot; +pPeriod.dtSpanEnd);
			}
			
			int nUnpaid = GetUnpaidDuration(pEvent,pConflicts,10);
			System.out.println(&quot;unpaid minutes &quot; + nUnpaid);
			
			cCalendar.set(1970,7,10,10,0,0);
			dtStart1 = cCalendar.getTime();
			
			Collection pNewConflicts = SplitConflicts(pEvent,pConflicts,10,dtStart1,dtEnd,false);
			for( Iterator i = pNewConflicts.iterator(); i.hasNext(); ) {
				CommonConflict pConflict = (CommonConflict)i.next();
				System.out.println(&quot;Split Conflicts &quot; + pConflict.getStartDate() + &quot; &quot; +pConflict.getEndDate());
			}
			
			pNewConflicts = SplitConflicts(pEvent,pConflicts,10,dtStart1,dtEnd,true);
			for( Iterator i = pNewConflicts.iterator(); i.hasNext(); ) {
				CommonConflict pConflict = (CommonConflict)i.next();
				System.out.println(&quot;Spread Conflicts &quot; + pConflict.getStartDate() + &quot; &quot; +pConflict.getEndDate());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
*/	
	
	public static StringBuffer appendCommaIfPassStringIsNotEmpty(StringBuffer orderByQuery) {
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">		if (!orderByQuery.toString().trim().isEmpty())</span>
<span class="nc" id="L618">			orderByQuery.append(&quot;,&quot;);</span>
<span class="fc" id="L619">		return orderByQuery;</span>
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>