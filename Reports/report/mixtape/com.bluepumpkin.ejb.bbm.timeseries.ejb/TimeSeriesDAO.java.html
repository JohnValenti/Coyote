<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeSeriesDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.ejb</a> &gt; <span class="el_source">TimeSeriesDAO.java</span></div><h1>TimeSeriesDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.ejb;

/**
 * Title:        TimeSeriesDAO.java
 * Description:  DAO of TimeSeries
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Sheng Song
 * @version 2.0
 */

import java.sql.Timestamp;
import java.sql.Types;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.*;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceChunk;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.model.CombinedQueueStaffing;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceInner;
import com.bluepumpkin.ejb.bbm.campaign.ejb.SchedulingPeriodDAO;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignDAO;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;

/**
 * TimeSeriesDAO is not to be accessed by other objects directly It has full
 * knowledge of how to persist Traces for BPDE schema Use default package level
 * restriction
 */
<span class="nc" id="L58">class TimeSeriesDAO {</span>
<span class="fc" id="L59">	private static final Integer NAVALUE = NumberFactory.newInteger(-2);</span>
	private final static String ActualTraceTableName = &quot;QUEUEHISTORYTIMESERIES&quot;;
	private final static String ForecastTraceTableName = &quot;FORECASTTIMESERIES&quot;;
	private final static String PredictTraceTableName = &quot;PREDICTEDTIMESERIES&quot;;
	private final static String RequireTraceTableName = &quot;REQUIREDTIMESERIES&quot;;
	private final static String ServiceGoalTraceTableName = &quot;SPQUEUEGOALSERIES&quot;;
	private final static String PredictNoPhantomTraceTableName = &quot;PREDICTEDNOPHANTOMTIMESERIES&quot;;

	private final static String ReportTableName = &quot;#TRACEREPORT&quot;;
	private final static String ReportTableNameDelete = &quot;TRACEREPORT&quot;;

<span class="fc" id="L70">	private static Category m_cat = Log.initCategory(TimeSeriesDAO.class.getName());</span>
<span class="fc" id="L71">	private final static String[] FIELDNames = new String[] { &quot;ID_T&quot;, &quot;QUEUEID&quot;, &quot;CAMPAIGNID&quot;, &quot;MEDIAID&quot;, &quot;STARTTIME&quot;, &quot;ACV&quot;,</span>
			&quot;AAHT&quot;, &quot;APCA&quot;, &quot;AASA&quot;, &quot;AABANDONMENT&quot;, &quot;ABACKLOG&quot;, &quot;ASTAFFING&quot;, &quot;AOCCUPANCY&quot;, &quot;AFTE&quot;, &quot;ADIALS&quot;, &quot;ACONNECTS&quot;,
			&quot;ACRATE&quot;, &quot;ARPC&quot;, &quot;ARPCRATE&quot;, &quot;ARPCAHT&quot;, &quot;AVH&quot;, &quot;AVAR&quot;, &quot;FCV&quot;, &quot;FAHT&quot;, &quot;FCRATE&quot;, &quot;FRPCAHT&quot;, &quot;FRPCRATE&quot;, &quot;FPCA&quot;,
			&quot;FASA&quot;, &quot;FABANDONMENT&quot;, &quot;FBACKLOG&quot;, &quot;FSTAFFING&quot;, &quot;FOCCUPANCY&quot;, &quot;FFTE&quot;, &quot;FDIALS&quot;, &quot;FCONNECTS&quot;, &quot;FRPC&quot;, &quot;RFTE&quot;,
			&quot;RPCA&quot;, &quot;RASA&quot;, &quot;RABANDONMENT&quot; };

<span class="fc" id="L77">	private final static int[] FIELDTypes = new int[] { Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,</span>
			Types.TIMESTAMP, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER };

	private final static String TimeSeriesAuditTableName = &quot;TRACETRACK&quot;;

<span class="fc" id="L87">	private static boolean m_ignoreFutureData = false;</span>

	public static void setIgnoreFutureData(boolean ignore) {
<span class="fc" id="L90">		m_ignoreFutureData = ignore;</span>
<span class="fc" id="L91">	}</span>

	/**
	 * Create/Update actual trace
	 *
	 * @param traceType
	 * @param queIDCol
	 * @param value
	 * @param start
	 * @throws JdmoException
	 */
	public static void createActualTimeSeries(short traceType, Collection&lt;? extends ID&gt; queIDCol, int value, Date posTime)
			throws JdmoException {
<span class="nc" id="L104">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L106">			Set extQueSet = existingRows(queIDCol, posTime, jdmo);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">			for (Iterator&lt;? extends ID&gt; it = queIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L108">				ID qID = it.next();</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">				if (extQueSet.contains(qID)) {</span>
<span class="nc" id="L110">					updateActualCube(qID, traceType, value, posTime, jdmo);</span>
				} else {
<span class="nc" id="L112">					createActualCube(qID, traceType, value, posTime, jdmo);</span>
				}
<span class="nc" id="L114">			}</span>
<span class="nc" id="L115">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L117">			jdmo.cleanUp();</span>
<span class="nc" id="L118">		}</span>
<span class="nc" id="L119">	} // createTimeSeriesInCube</span>

	/**
	 * To create a chunk of TimeSeries in Actual Trace table If the offSet is 1,
	 * which implies it is a new Trace, try create first Else try update if
	 * update failed, then retry with create, exit. if create failed with
	 * duplicatekey, then retry update, exit.
	 *
	 * @param TraceChunk
	 */
	public static void createTimeSeriesInChunk(TraceChunk chunk) throws JdmoException {
<span class="nc" id="L130">		Jdmo jdmo = new Jdmo();</span>
		try {
			try {
<span class="nc" id="L133">				createChunkForActual(chunk, jdmo);</span>
<span class="nc" id="L134">				jdmo.executeBatch();</span>
<span class="nc" id="L135">			} catch (JdmoException ex) {</span>
<span class="nc" id="L136">				updateTimeSeriesInChunk(chunk, ex);</span>
<span class="nc" id="L137">			}</span>

		} finally {
<span class="nc" id="L140">			jdmo.cleanUp();</span>
<span class="nc" id="L141">		}</span>
<span class="nc" id="L142">	} // createTimeSeriesInChunk</span>

	private static void updateTimeSeriesInChunk(TraceChunk chunk, JdmoException ex) throws JdmoException {
<span class="nc" id="L145">		Jdmo updateDmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (existingRow(chunk.getQueueID(), chunk.getStartDate(), updateDmo)) {</span>
<span class="nc" id="L148">				updateChunkForActual(chunk, updateDmo);</span>
<span class="nc" id="L149">				updateDmo.executeBatch();</span>
			} else {
<span class="nc" id="L151">				throw ex;</span>
			}
		} finally {
<span class="nc" id="L154">			updateDmo.cleanUp();</span>
<span class="nc" id="L155">		}</span>
<span class="nc" id="L156">	}</span>

	/**
	 * To create a chunk of TimeSeries in Actual Trace table If the offSet is 1,
	 * which implies it is a new Trace, try create first Else try update if
	 * update failed, then retry with create, exit. if create failed with
	 * duplicatekey, then retry update, exit.
	 *
	 * @param TraceChunk
	 */
	public static void createTimeSeriesInCube(TraceCube cube) throws JdmoException {
<span class="nc" id="L167">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L169">			Set extSet = existingActualRows(cube.getQueueID(), cube.getRawStartDate(), cube.getRawEndDate(), jdmo);</span>
<span class="nc" id="L170">			Date posTime = TraceUtil.snapDate(cube.getRawStartDate());</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">			while (!posTime.after(cube.getRawEndDate())) {</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">				if (extSet.contains(posTime)) {</span>
<span class="nc" id="L173">					updateCube(cube, posTime, jdmo);</span>
				} else {
<span class="nc" id="L175">					createCube(cube, posTime, jdmo);</span>
				}
<span class="nc" id="L177">				posTime.setTime(posTime.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
<span class="nc" id="L179">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L181">			jdmo.cleanUp();</span>
<span class="nc" id="L182">		}</span>
<span class="nc" id="L183">	} // createTimeSeriesInCube</span>

	/**
	 * @param qID
	 * @param traceType
	 * @param value
	 * @param posTime
	 * @param jdmo
	 * @throws JdmoException
	 */
	private static void createActualCube(ID qID, short traceType, int value, Date posTime, Jdmo jdmo) throws JdmoException {
		// Select Query for Queueid
<span class="nc" id="L195">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		if (!cube.isTraceTypeComputed(traceType)) {</span>
<span class="nc" id="L197">			StringBuffer vStmt = new StringBuffer(200);</span>
<span class="nc" id="L198">			vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L199">			vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(posTime)).append(&quot;',&quot;);</span>
<span class="nc" id="L200">			vStmt.append(value).append(&quot;,&quot;);</span>
<span class="nc" id="L201">			vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L202">			vStmt.append(&quot;' from QUEUE where SID=&quot;).append(qID);</span>
			// Insert Query
<span class="nc" id="L204">			StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L205">			iStmt.append(&quot;insert into &quot;).append(ActualTraceTableName);</span>
<span class="nc" id="L206">			iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L207">			iStmt.append(getDETraceColumn(traceType)).append(&quot;, &quot;);</span>
<span class="nc" id="L208">			iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L209">			iStmt.append(vStmt);</span>
<span class="nc" id="L210">			jdmo.addBatch(iStmt.toString());</span>
		}
<span class="nc" id="L212">	}</span>

	/**
	 * @param qID
	 * @param traceType
	 * @param value
	 * @param posTime
	 * @param jdmo
	 * @throws JdmoException
	 */
	private static void updateActualCube(ID qID, short traceType, int value, Date posTime, Jdmo jdmo) throws JdmoException {

<span class="nc" id="L224">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		if (!cube.isTraceTypeComputed(traceType)) {</span>
<span class="nc" id="L226">			StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L227">			iStmt.append(&quot;update &quot;).append(ActualTraceTableName).append(&quot; set &quot;);</span>
<span class="nc" id="L228">			iStmt.append(getDETraceColumn(traceType)).append(&quot;=&quot;);</span>
<span class="nc" id="L229">			iStmt.append(value).append(&quot;, &quot;);</span>
<span class="nc" id="L230">			iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L231">			iStmt.append(&quot;' where TIME='&quot;).append(JdmoUtil.formatDBString(posTime));</span>
<span class="nc" id="L232">			iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(qID).append(&quot;)&quot;);</span>
<span class="nc" id="L233">			jdmo.addBatch(iStmt.toString());</span>
		}
<span class="nc" id="L235">	}</span>

	/**
	 * Gets volume/AHT from queuehistorytimeseries table that has valid data  within the data range
	 * i.e (volume/AHT &gt; 0 and wolume/AHT not null)
	 *
	 * @param queueID
	 * @param startDate
	 * @param endDate
	 * @return TraceCube
	 * @throws JdmoException, BbmTimeSeriesException
	 */
	public static ActualTraceCube getActualTraceCube(ID queueID, Date startDate, Date endDate) throws JdmoException, BbmTimeSeriesException {
<span class="nc" id="L248">		short[] types = {Trace.CV, Trace.AHT};</span>
<span class="nc" id="L249">		ActualTraceCube actualTC = new ActualTraceCube(queueID, startDate, endDate, types);</span>
<span class="nc" id="L250">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L252">			String sqlString = getSqlQueryToGetActualTimeSeriesData(queueID, startDate, endDate);</span>
<span class="nc" id="L253">			JdmoQuery jQuery = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L254">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L255">			ArrayList&lt;Double&gt; cv = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L256">			ArrayList&lt;Double&gt; aht = new ArrayList&lt;Double&gt;();</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L258">				cv.add(rs.getDouble(&quot;CALLVOLUME&quot;));</span>
<span class="nc" id="L259">				aht.add(rs.getDouble(&quot;AHT&quot;));</span>
			}
<span class="nc" id="L261">			rs.close();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">			if (!cv.isEmpty()) {</span>
<span class="nc" id="L263">				double[] cvArray = new double[cv.size()];</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">				for (int i = 0; i &lt; cv.size(); i++) {</span>
<span class="nc" id="L265">					cvArray[i] = cv.get(i);</span>
				}
<span class="nc" id="L267">				actualTC.setTraceValue(Trace.CV, cvArray);</span>
			}
<span class="nc bnc" id="L269" title="All 2 branches missed.">			if (!aht.isEmpty()) {</span>
<span class="nc" id="L270">				double[] ahtArray = new double[aht.size()];</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">				for (int i = 0; i &lt; aht.size(); i++) {</span>
<span class="nc" id="L272">					ahtArray[i] = aht.get(i);</span>
				}
<span class="nc" id="L274">				actualTC.setTraceValue(Trace.AHT, ahtArray);</span>
			}
<span class="nc" id="L276">			return actualTC;</span>
		} finally {
<span class="nc" id="L278">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param cube
	 * @param posTime
	 * @param jdmo
	 */
	private static void createCube(TraceCube cube, Date posTime, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L288">		StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L289">		iStmt.append(&quot;insert into &quot;).append(ActualTraceTableName);</span>
<span class="nc" id="L290">		iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L291">		StringBuffer vStmt = new StringBuffer(200);</span>
<span class="nc" id="L292">		vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L293">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(posTime)).append(&quot;',&quot;);</span>
<span class="nc" id="L294">		short[] types = cube.getTraceTypes();</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L297">				iStmt.append(getDETraceColumn(types[i])).append(&quot;, &quot;);</span>
<span class="nc" id="L298">				vStmt.append(cube.getTraceValue(types[i], posTime)).append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L301">		iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L302">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L303">		vStmt.append(&quot;' from QUEUE where SID=&quot;).append(cube.getQueueID());</span>
<span class="nc" id="L304">		iStmt.append(vStmt);</span>
<span class="nc" id="L305">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L306">	}</span>

	/**
	 * @param cube
	 * @param posTime
	 * @param jdmo
	 */
	private static void updateCube(TraceCube cube, Date posTime, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L314">		StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L315">		iStmt.append(&quot;update &quot;).append(ActualTraceTableName).append(&quot; set &quot;);</span>
<span class="nc" id="L316">		short[] types = cube.getTraceTypes();</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L319">				iStmt.append(getDETraceColumn(types[i])).append(&quot;=&quot;);</span>
<span class="nc" id="L320">				iStmt.append(cube.getTraceValue(types[i], posTime)).append(&quot;, &quot;);</span>
			}
		}
<span class="nc" id="L323">		iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L324">		iStmt.append(&quot;' where TIME='&quot;).append(JdmoUtil.formatDBString(posTime));</span>
<span class="nc" id="L325">		iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(cube.getQueueID()).append(&quot;)&quot;);</span>
<span class="nc" id="L326">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L327">	}</span>

	private static void createTempReportDumpTable(Jdmo jdmo) throws JdmoException{

		//create temp table to hold TRACEREPORT data
<span class="nc" id="L332">		StringBuffer strSQL = new StringBuffer();</span>
<span class="nc" id="L333">		String strNativeTempName = ReportTableName;</span>
		//jdmo.getNativeTemptableName(ReportTableName);

		try {
			// drop temp table just in case
<span class="nc" id="L338">			jdmo.dropTempTable(ReportTableNameDelete);</span>
<span class="nc" id="L339">		} catch(JdmoException e) {</span>
<span class="nc" id="L340">			m_cat.error(&quot;Exception in dropTempTable() when dropping temp table:&quot;+strNativeTempName+&quot;Message:&quot;+e.getMessage());</span>
<span class="nc" id="L341">		}</span>

<span class="nc" id="L343">		strSQL.append(strNativeTempName);</span>
<span class="nc" id="L344">		strSQL.append(&quot; (ID_T	int,QUEUEID	int,STARTTIME	datetime,CAMPAIGNID	int,MEDIAID	int,ACV	int,AAHT	int,APCA	int,AASA	int,AABANDONMENT	int,ABACKLOG	int,ASTAFFING	int, &quot;);</span>
<span class="nc" id="L345">		strSQL.append(&quot;AOCCUPANCY	int,FCV	int,FAHT	int,FPCA	int,FASA	int,FABANDONMENT	int,FBACKLOG	int,FSTAFFING	int,FOCCUPANCY	int,RFTE	int,RPCA	int,RASA	int, &quot;);</span>
<span class="nc" id="L346">		strSQL.append(&quot;RABANDONMENT	int,AFTE	int,FFTE	int,ADIALS	int,ACONNECTS	int,ACRATE	int,ARPC	int, &quot;);</span>
<span class="nc" id="L347">		strSQL.append(&quot;ARPCRATE	int,ARPCAHT	int,FDIALS	int,FCONNECTS	int,FCRATE	int,FRPC	int,FRPCRATE	int,FRPCAHT	int,AVH	int,AVAR	int,ISUPDATE INT)&quot;);</span>

		try {
<span class="nc" id="L350">			jdmo.createTempTable(strSQL.toString());</span>
<span class="nc" id="L351">		}catch(JdmoException  e){</span>
<span class="nc" id="L352">			m_cat.error(&quot;Exception in createTempReportDumpTable() when dropping temp table:&quot;+strNativeTempName+&quot;Message:&quot;+e.getMessage());</span>
<span class="nc" id="L353">		}</span>
<span class="nc" id="L354">	}</span>
	/*
	 * update Report table based on meta TraceCube information for a queue
	 * TraceChunk Array is 5 elements array, 0 is actual, 1 is forecast, 2 is
	 * predict, 3 is require, 4 is servicegoal
	 */
	public static void dumpTimeSeriesFromLastUpdate(ID queueID, ID campaignID, ID mediaID, Map&lt;Date, TraceChunk[]&gt; chunkMap,
													Map&lt;Date, CombinedQueueStaffing&gt; cmbStfMap, Date start, Date end, Set&lt;Date&gt; removeTimeSet) throws JdmoException {
<span class="nc" id="L362">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L364">			TimeSeriesDAO.createTempReportDumpTable(jdmo);</span>
<span class="nc" id="L365">			Map&lt;Date, ID&gt; existingPoints = new HashMap&lt;Date, ID&gt;();</span>
			//existingRows(queueID, campaignID, mediaID, start, end, jdmo);
<span class="nc" id="L367">			Set&lt;Date&gt; existingTime = existingPoints.keySet();</span>
<span class="nc" id="L368">			ArrayList&lt;Object[]&gt; paramValCol = new ArrayList&lt;Object[]&gt;();</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">			m_cat.info(&quot;dumpTimeSeriesFromLastUpdate Number of Records&quot;+ (chunkMap!=null ?chunkMap.size():0)+ &quot; QueueID :&quot;+queueID+&quot; CampaignID :&quot;+campaignID+&quot; Start:&quot;+start+&quot; End:&quot;+end+&quot; MediaID&quot;+mediaID);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">			for (Date startDate : chunkMap.keySet()) {</span>
<span class="nc" id="L371">				TraceChunk[] chunkArray = chunkMap.get(startDate);</span>
<span class="nc" id="L372">				CombinedQueueStaffing cmbStf = cmbStfMap.remove(startDate);</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">				if (existingTime.contains(startDate)) {</span>
<span class="nc" id="L374">					updateDump(chunkArray, cmbStf, queueID, startDate, campaignID, mediaID, jdmo);</span>
				} else {
					// insert in batch
<span class="nc" id="L377">					paramValCol.add(createDump(chunkArray, cmbStf, queueID, campaignID, mediaID, startDate));</span>
				}
<span class="nc" id="L379">			}</span>
			// update remaining Combined Staffing
<span class="nc bnc" id="L381" title="All 2 branches missed.">			for (Date startDate : cmbStfMap.keySet()) {</span>
				/*
				 * Changed by Sameet 9/22/2005 to fix
				 * ConcurrentModificationException thrown in this loop FIX:
				 * changed from cmbStfMap.remove(startDate) to
				 * cmbStfMap.get(startDate)
				 */
<span class="nc" id="L388">				CombinedQueueStaffing cmbStf = (CombinedQueueStaffing) cmbStfMap.get(startDate);</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">				if (existingTime.contains(startDate)) {</span>
<span class="nc" id="L390">					updateCmbStaffingDump(cmbStf, (ID) existingPoints.get(startDate), jdmo);</span>
				} else {
					// insert in batch
<span class="nc" id="L393">					paramValCol.add(createDump(null, cmbStf, queueID, campaignID, mediaID, startDate));</span>
				}
<span class="nc" id="L395">			}</span>

			// now remove time
<span class="nc" id="L398">			Set&lt;ID&gt; removeIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L399" title="All 4 branches missed.">			if(removeTimeSet != null &amp;&amp; !removeTimeSet.isEmpty()){</span>
<span class="nc" id="L400">				m_cat.info(&quot;Inside removeTimeSet is not Empty&quot;+removeTimeSet.size());</span>
<span class="nc" id="L401">				existingPoints = existingRows(queueID, campaignID, mediaID, start, end, jdmo);</span>
			}
<span class="nc bnc" id="L403" title="All 2 branches missed.">			for (Iterator&lt;Date&gt; it = removeTimeSet.iterator(); it.hasNext();) {</span>
<span class="nc" id="L404">				ID id = existingPoints.get(it.next());</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">				if (id != null) {</span>
<span class="nc" id="L406">					removeIDSet.add(id);</span>
				}
<span class="nc" id="L408">			}</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">			if (!removeIDSet.isEmpty()) {</span>
<span class="nc" id="L410">				StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L411">				sb.append(&quot;delete from &quot;).append(ReportTableNameDelete).append(&quot; where ID in&quot;)</span>
<span class="nc" id="L412">						.append(jdmo.createInClause(removeIDSet));</span>
<span class="nc" id="L413">				jdmo.addBatch(sb.toString());</span>
			}
<span class="nc" id="L415">			jdmo.executeBatch();</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">			if (!paramValCol.isEmpty()) {</span>
<span class="nc" id="L417">				jdmo.insertBatchAndExecute(ReportTableName, FIELDNames, FIELDTypes, paramValCol);</span>
			}
<span class="nc" id="L419">			TimeSeriesDAO.moveDataFromTempTableToMainTable(jdmo);</span>
		} finally {
<span class="nc" id="L421">			jdmo.cleanUp();</span>
<span class="nc" id="L422">		}</span>
<span class="nc" id="L423">	}</span>

	private static void moveDataFromTempTableToMainTable(Jdmo jdmo) throws JdmoException{

		try{
<span class="nc" id="L428">			String pStmt = &quot;BP_TIMESERIES_DUMP&quot;;</span>
<span class="nc" id="L429">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.STORPROC_QUERY_NORS);</span>
<span class="nc" id="L430">			int debugLevel = 0;</span>
<span class="nc" id="L431">			jQuery.setParInt(1, debugLevel);</span>
<span class="nc" id="L432">			jQuery.setParString(2,ReportTableName);</span>
<span class="nc" id="L433">			jdmo.execute(jQuery);</span>
<span class="nc" id="L434">		} catch (JdmoException e) {</span>
<span class="nc" id="L435">			m_cat.error(&quot;Exception in moveDataFromTempTableToMainTable method:&quot;+e.getMessage());</span>
<span class="nc" id="L436">			throw e;</span>
<span class="nc" id="L437">		}</span>
<span class="nc" id="L438">	}</span>

	//No longer relevant data is refreshed into the main table using inserts into #TRACEREPORT(temp table).
	@Deprecated
	private static void updateCmbStaffingDump(CombinedQueueStaffing cmbStf, ID traceID, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L443">		StringBuffer pStmt = new StringBuffer(&quot;update &quot;).append(ReportTableName).append(&quot; set &quot;);</span>
		// if combined queue and no actual, need fix the Actual Occupancy
<span class="nc" id="L445">		pStmt.append(&quot;ASTAFFING=&quot;).append(TraceUtil.roundDouble(cmbStf.getStaffing()));</span>
<span class="nc" id="L446">		pStmt.append(&quot; where &quot;).append(&quot;ID_T=&quot;).append(traceID);</span>
<span class="nc" id="L447">		jdmo.addBatch(pStmt.toString());</span>
<span class="nc" id="L448">	}</span>

	// Used by updating each chunk
	private static void updateDump(TraceChunk[] chunkArray, CombinedQueueStaffing cmbStf, ID queueID,
								   Date startTime, ID campaignID, ID mediaID, Jdmo jdmo) throws JdmoException {

<span class="nc" id="L454">		SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM/dd/yyyy HH:mm:ss&quot;);</span>
<span class="nc" id="L455">		StringBuffer pStmt = new StringBuffer(&quot;update &quot;).append(ReportTableName).append(&quot; set &quot;);</span>
		// if combined queue and no actual, need fix the Actual Occupancy
<span class="nc bnc" id="L457" title="All 4 branches missed.">		if (campaignID != null &amp;&amp; chunkArray[0] == null) {</span>
<span class="nc" id="L458">			pStmt.append(&quot;AOCCUPANCY=&quot;).append(NAVALUE).append(&quot;,&quot;);</span>
		}
<span class="nc bnc" id="L460" title="All 2 branches missed.">		for (int i = 0; i &lt; chunkArray.length; i++) {</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">			if (chunkArray[i] != null) {</span>
<span class="nc" id="L462">				short[] types = getMetaTypes(i);</span>
<span class="nc" id="L463">				char prefix = getPrefixChar(i);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc" id="L465">					int traceVal = TraceUtil.roundDouble(chunkArray[i].getTraceValue(types[j]));</span>
					/*
					 * commenting out setting the value from -1 to 0, since
					 * reports will now show -1 Sameet, Dec 2006, bug# 93519;
					 * Performance Reports show 0's instead of nulls if
					 * (traceVal == Trace.TRACENA) traceVal = 0;
					 */
					// skip update combined Staffing, which is always in a
					// seperate update operation from cmbStf
<span class="nc bnc" id="L474" title="All 6 branches missed.">					if (campaignID != null &amp;&amp; i == 0 &amp;&amp; j == Trace.STAFFING) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">						if (cmbStf != null) {</span>
<span class="nc" id="L476">							traceVal = TraceUtil.roundDouble(cmbStf.getStaffing());</span>
						} else {
							continue; // if no cmbStf is found, it means no
							// change, just skip
						}
					}
<span class="nc" id="L482">					pStmt.append(prefix).append(getTraceColumn(types[j])).append(&quot;=&quot;).append(traceVal).append(&quot;,&quot;);</span>
				}
			}
		}
<span class="nc" id="L486">		pStmt.setCharAt(pStmt.length() - 1, ' ');</span>
<span class="nc" id="L487">		pStmt.append(&quot;where &quot;).append(&quot;QUEUEID=ISNULL(&quot;).append(queueID).append(&quot;,-1)&quot;);</span>
<span class="nc" id="L488">		pStmt.append(&quot; and &quot;).append(&quot;STARTTIME='&quot;).append(sdf.format(startTime)).append(&quot;'&quot;);</span>
<span class="nc" id="L489">		pStmt.append(&quot; and &quot;).append(&quot;CAMPAIGNID=ISNULL(&quot;).append(campaignID).append(&quot;,-1)&quot;);</span>
<span class="nc" id="L490">		pStmt.append(&quot; and &quot;).append(&quot;MEDIAID=ISNULL(&quot;).append(mediaID).append(&quot;,-10)&quot;);</span>
<span class="nc" id="L491">		jdmo.addBatch(pStmt.toString());</span>
<span class="nc" id="L492">	}</span>

	// internal function to return each row's parameter values according to the
	// column name sequence
	private static Object[] createDump(TraceChunk[] chunkArray, CombinedQueueStaffing cmbStf, ID queueID, ID campaignID,
									   ID mediaID, Date startDate) {
		// Trace 22 types + 4ids + 1 time
<span class="nc" id="L499">		Object[] paramArray = new Object[FIELDNames.length];</span>
		// Initialize them to 0 value, coz JDMO doesn't support null object yet
<span class="nc" id="L501">		Arrays.fill(paramArray, NumberFactory.newInteger(0));</span>
<span class="nc" id="L502">		paramArray[0] = null;</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">		paramArray[1] = queueID == null ? new ID(-1) : queueID;</span>
<span class="nc bnc" id="L504" title="All 2 branches missed.">		paramArray[2] = campaignID == null ? new ID(-1) : campaignID;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">		paramArray[3] = mediaID == null ? new ID(-10) : mediaID;</span>
<span class="nc" id="L506">		paramArray[4] = TimeZoneUtil.toTimestamp(startDate);</span>
		/*
		 * Done because the Report dump was not updated for the combined queues
		 * and normal queues FIX: Commenting this whole part as it applies only
		 * to the Combined queues and is taken care in the If block below
		 */
<span class="nc" id="L512">		addToArray(chunkArray, paramArray, 5);</span>
		/*
		 * if (chunkArray == null) { paramArray[5+Trace.STAFFING] =
		 * cmbStf!=null?
		 * NumberFactory.newInteger(TraceUtil.roundDouble(cmbStf.getStaffing
		 * ())):NAVALUE; } else if (campaignID != null &amp;&amp; chunkArray[0] == null)
		 * {
		 */
<span class="nc bnc" id="L520" title="All 2 branches missed.">		if (campaignID != null) {</span>
			/*
			 * for any combined queue, Actual Staffing is available in cmbStf
			 * and Actual Occupancy is never available for combined queues
			 */
<span class="nc bnc" id="L525" title="All 2 branches missed.">			paramArray[5 + Trace.STAFFING] = cmbStf != null ? NumberFactory.newInteger(TraceUtil.roundDouble(cmbStf</span>
<span class="nc" id="L526">					.getStaffing())) : NAVALUE;</span>
<span class="nc" id="L527">			paramArray[5 + Trace.OCCUPANCY] = NAVALUE;</span>
		}
		/* end of Fix Sameet 9/23/2005 */
<span class="nc" id="L530">		return paramArray;</span>
	}

	private static short[] getMetaTypes(int i) {
<span class="nc bnc" id="L534" title="All 6 branches missed.">		switch (i) {</span>
			case 0:
				// TODO not support FTE
<span class="nc" id="L537">				return TraceUtil.META_REPORT_ACTUAL.getTraceTypes();</span>
			case 1:
<span class="nc" id="L539">				return TraceUtil.META_FORECAST.getTraceTypes();</span>
			case 2:
<span class="nc" id="L541">				return TraceUtil.META_REPORT_PREDICT.getTraceTypes();</span>
			case 3:
<span class="nc" id="L543">				return TraceUtil.META_REQUIRE.getTraceTypes();</span>
			case 4:
<span class="nc" id="L545">				return TraceUtil.META_REPORT_SERVICEGOAL.getTraceTypes();</span>
			default:
<span class="nc" id="L547">				return null;</span>
		}
	}

	private static void addToArray(TraceChunk[] chunkArray, Object[] paramArray, int pointer) {

<span class="nc" id="L553">		JdmoParam nullParam = new JdmoParam(null, Types.INTEGER);</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">		for (int i = 0; chunkArray != null &amp;&amp; i &lt; chunkArray.length; i++) {</span>
<span class="nc" id="L555">			TraceChunk chunk = chunkArray[i];</span>
<span class="nc" id="L556">			short[] types = getMetaTypes(i);</span>

			// if (chunk != null) { commenting this check since we need to set
			// -1 when chunk==null
<span class="nc bnc" id="L560" title="All 2 branches missed.">			for (int j = 0; j &lt; types.length; j++) {</span>
				int traceVal;
<span class="nc bnc" id="L562" title="All 2 branches missed.">				if (chunk != null) {</span>
<span class="nc" id="L563">					traceVal = TraceUtil.roundDouble(chunk.getTraceValue(types[j]));</span>
					// If trace value is not greater than 0, just skip the point
				/*
				 * commenting out continue loop for -1 value (null) Sameet, Dec
				 * 2006, bug# 93519; Performance Reports show 0's instead of
				 * nulls if (traceVal == Trace.TRACENA) continue;
				 */
<span class="nc" id="L570">					paramArray[j + pointer] = NumberFactory.newInteger(traceVal);</span>
				}else{
<span class="nc" id="L572">					paramArray[j + pointer] = nullParam;</span>
				}
				// }
			}
<span class="nc" id="L576">			pointer += types.length;</span>
		}
<span class="nc" id="L578">	}</span>

	/**
	 * Return the earliest date for all queues in ActualTrace table
	 */
	public static Date getEarliestDate() throws JdmoException {
<span class="nc" id="L584">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L586">			StringBuffer pStmt = new StringBuffer(100);</span>
<span class="nc" id="L587">			pStmt.append(&quot;select min(TIME)&quot;);</span>
<span class="nc" id="L588">			pStmt.append(&quot; from &quot;).append(ActualTraceTableName);</span>
<span class="nc" id="L589">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L590">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L591">			Date earliestDate = null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L593">				earliestDate = TimeZoneUtil.toDate(rs.getTimestamp(1));</span>
			}
<span class="nc" id="L595">			rs.close();</span>
<span class="nc bnc" id="L596" title="All 2 branches missed.">			if (earliestDate == null) {</span>
<span class="nc" id="L597">				pStmt = new StringBuffer(100);</span>
<span class="nc" id="L598">				pStmt.append(&quot;select min(DATETIME)&quot;);</span>
<span class="nc" id="L599">				pStmt.append(&quot; from &quot;).append(ForecastTraceTableName);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">				if (m_ignoreFutureData) {</span>
<span class="nc" id="L601">					pStmt.append(&quot; where TIME&lt;=?&quot;);</span>
				}
<span class="nc" id="L603">				jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">				if (m_ignoreFutureData) {</span>
<span class="nc" id="L605">					jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(new Date()));</span>
				}
<span class="nc" id="L607">				rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">				if (rs.next()) {</span>
<span class="nc" id="L609">					earliestDate = TimeZoneUtil.toDate(rs.getTimestamp(1));</span>
				}
			}
<span class="nc" id="L612">			return earliestDate;</span>
		} finally {
<span class="nc" id="L614">			jdmo.cleanUp();</span>
		}
	}

	private static char getPrefixChar(int i) {
<span class="nc bnc" id="L619" title="All 4 branches missed.">		switch (i) {</span>
			case 0:
<span class="nc" id="L621">				return 'A';</span>
			case 1:
			case 2:
<span class="nc" id="L624">				return 'F';</span>
			case 3:
			case 4:
<span class="nc" id="L627">				return 'R';</span>
			default:
<span class="nc" id="L629">				return ' ';</span>
		}
	}

	/**
	 * Check if there is point already dumped
	 *
	 * @param queueID
	 * @param start
	 * @param end
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static Map&lt;Date, ID&gt; existingRows(ID queueID, ID campaignID, ID mediaID, Date start, Date end, Jdmo jdmo)
			throws JdmoException {
<span class="nc" id="L645">		Map&lt;Date, ID&gt; points = new HashMap&lt;Date, ID&gt;();</span>
<span class="nc" id="L646">		StringBuffer pStmt = new StringBuffer(&quot;select ID, STARTTIME from &quot;);</span>
<span class="nc" id="L647">		pStmt.append(ReportTableNameDelete).append(&quot; where&quot;);</span>
<span class="nc" id="L648">		int pos = 1;</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L650">			pStmt.append(&quot; STARTTIME&gt;=? and&quot;);</span>
<span class="nc" id="L651">			pos++;</span>
		}
<span class="nc bnc" id="L653" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L654">			pStmt.append(&quot; STARTTIME&lt;=? and&quot;);</span>
<span class="nc" id="L655">			pos++;</span>
		}
<span class="nc bnc" id="L657" title="All 2 branches missed.">		if (queueID != null) {</span>
<span class="nc" id="L658">			pStmt.append(&quot; QUEUEID=?&quot;);</span>
		} else {
<span class="nc" id="L660">			pStmt.append(&quot; CAMPAIGNID=?&quot;);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L662">				pStmt.append(&quot; and MEDIAID=?&quot;);</span>
<span class="nc" id="L663">				pos++;</span>
			} else {
<span class="nc" id="L665">				pStmt.append(&quot; and MEDIAID=-10&quot;);</span>
			}
		}
<span class="nc" id="L668">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">		if (queueID != null) {</span>
<span class="nc" id="L670">			jQuery.setParID(pos, queueID);</span>
		} else {
<span class="nc bnc" id="L672" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L673">				jQuery.setParID(pos--, mediaID);</span>
			}
<span class="nc" id="L675">			jQuery.setParID(pos, campaignID);</span>
		}
<span class="nc bnc" id="L677" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L678">			jQuery.setParTimestamp(pos - 2, TimeZoneUtil.toTimestamp(start));</span>
		}
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L681">			jQuery.setParTimestamp(pos - 1, TimeZoneUtil.toTimestamp(end));</span>
		}
<span class="nc" id="L683">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L685">			points.put(TimeZoneUtil.toDate(rs.getTimestamp(2)), rs.getID(1));</span>
		}
<span class="nc" id="L687">		return points;</span>
	}

	/**
	 * Get combined result for multiple queues
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param includeAllServiceGoalTypes
	 * @return
	 * @throws Exception
	 */
	public static Collection getCombinedQueueTimeSeriesCubesFromLastUpdate(TraceCube metaTC, HashMap spQMap,
																		   HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
																		   Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
		// get all queues associated with changed SPIDs
<span class="fc" id="L709">		HashSet qIDSet = new HashSet();</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">		for (Iterator it = spQMap.keySet().iterator(); it.hasNext();) {</span>
<span class="fc" id="L711">			qIDSet.addAll((Collection) spQMap.get(it.next()));</span>
		}
<span class="fc" id="L713">		return getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate,</span>
				includeAllServiceGoalTypes, spqueuesBySID);
	}

	/**
	 * Get combined result for multiple queues
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param includeAllServiceGoalTypes
	 * @return
	 * @throws Exception
	 */
	public static Collection getCombinedQueueTimeSeriesCubesFromLastUpdate(TraceCube metaTC, Set qIDSet, Map spQMap,
																		   Map spTimeRangeMap, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
																		   Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="fc" id="L735">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L737">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="fc" id="L738">			return convert(rs, metaTC, spQMap, spTimeRangeMap, jdmo, start, end, includeAllServiceGoalTypes, spqueuesBySID);</span>
<span class="nc" id="L739">		} catch (JdmoException e) {</span>
<span class="nc" id="L740">			throw e;</span>
		} finally {
<span class="pc" id="L742">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getMultiQueuesTrace(TraceCube metaTC, Set qIDSet, Map spQMap, Date start, Date end,
												  Date lastUpdate, Jdmo jdmo) throws JdmoException {
		// Prepare the Statement
<span class="fc" id="L761">		StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="fc" id="L762">		pStmt.append(getCombinedQueueDESelectStmt(metaTC, qIDSet, spQMap.keySet(), jdmo, start, end, lastUpdate));</span>
		// SQL Execution
<span class="fc" id="L764">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L765">		int lastUpdatePos = 1;</span>
<span class="fc" id="L766">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="pc bpc" id="L767" title="1 of 2 branches missed.">		if (start != null) {</span>
<span class="fc" id="L768">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceStart(metaTC, start)));</span>
<span class="pc bpc" id="L769" title="1 of 2 branches missed.">			if (end1 != null) {</span>
<span class="fc" id="L770">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end1)));</span>
			}
		} else {
<span class="nc bnc" id="L773" title="All 2 branches missed.">			if (end1 != null) {</span>
<span class="nc" id="L774">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end1)));</span>
			}
		}
<span class="pc bpc" id="L777" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L778">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L779">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L780">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L782">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L783">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
		}
<span class="fc" id="L786">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L787">		return rs;</span>
	}

	public static Collection&lt;TraceChunk&gt; getCombinedQueueForecastTimeSeriesFromLastUpdate(TraceCube metaTC, HashSet qIDSet,
																						  HashMap spQMap, HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate) throws JdmoException {

<span class="nc" id="L793">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc" id="L794">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L798">			int arraySz = 0;</span>
<span class="nc bnc" id="L799" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L800">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L802" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L803">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// get all queues associated with changed SPIDs
<span class="nc" id="L806">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="nc" id="L807">			HashMap chunkDateMap = new HashMap(700);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">			for (Iterator iterator = qIDSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L809">				ID queID = (ID) iterator.next();</span>
<span class="nc" id="L810">				Collection prdCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_PREDICT, queID, start,</span>
						end, lastUpdate, false);
<span class="nc bnc" id="L812" title="All 4 branches missed.">				if (prdCol != null &amp;&amp; !prdCol.isEmpty()) {</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">					for (Iterator iterator1 = prdCol.iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L814">						TraceChunk chunk = (TraceChunk) iterator1.next();</span>
<span class="nc" id="L815">						HashMap queTraceChunkMap = (HashMap) chunkDateMap.get(chunk.getStartDate());</span>
						// System.out.println(&quot;timeNow=&quot;+chunk.getStartDate()
						// +&quot;=queueID=&quot;+ chunk.getQueueID()+&quot;:CONNECTS=&quot;+
						// chunk.getTraceValue(Trace.CONNECTS));
<span class="nc bnc" id="L819" title="All 2 branches missed.">						if (queTraceChunkMap == null) {</span>
<span class="nc" id="L820">							queTraceChunkMap = new HashMap(qIDSet.size());</span>
<span class="nc" id="L821">							chunkDateMap.put(chunk.getStartDate(), queTraceChunkMap);</span>
						}
<span class="nc" id="L823">						queTraceChunkMap.put(queID, chunk);</span>
<span class="nc" id="L824">					}</span>
				}
<span class="nc" id="L826">			}</span>
<span class="nc" id="L827">			convert(rs, metaTC, spQMap, spTimeRangeMap, tcArray, start, end, jdmo, chunkDateMap);</span>
<span class="nc" id="L828">			return tcArray;</span>
<span class="nc" id="L829">		} catch (JdmoException e) {</span>
<span class="nc" id="L830">			throw e;</span>
<span class="nc" id="L831">		} catch (Exception e) {</span>
<span class="nc" id="L832">			return tcArray;</span>
		} finally {
<span class="nc" id="L834">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue
	 *
	 * @param TraceCube
	 *            , metaTC
	 * @param ID
	 *            , CampaignID
	 * @param ID
	 *            , mediaID
	 * @param HashMap
	 *            , (SPID, Queue ID Collection)
	 * @param HashMap
	 *            , (SPID, TimeRange)
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection&lt;TraceChunk&gt; getCombinedQueueTimeSeriesFromLastUpdate(TraceCube metaTC, HashSet qIDSet,
																				  HashMap spQMap, HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L861">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc" id="L862">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L866">			int arraySz = 0;</span>
<span class="nc bnc" id="L867" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L868">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L870" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L871">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// get all queues associated with changed SPIDs
<span class="nc" id="L874">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="nc" id="L875">			convert(rs, metaTC, spQMap, spTimeRangeMap, tcArray, start, end, jdmo, null);</span>
<span class="nc" id="L876">			return tcArray;</span>
<span class="nc" id="L877">		} catch (JdmoException e) {</span>
<span class="nc" id="L878">			throw e;</span>
<span class="nc" id="L879">		} catch (Exception e) {</span>
<span class="nc" id="L880">			return tcArray;</span>
		} finally {
<span class="nc" id="L882">			jdmo.cleanUp();</span>
		}
	} // getCombinedQueueTimeSeriesFromLastUpdate

	private static String getCombinedQueueDESelectStmt(TraceCube metaTC, Set qIDSet, Set spSet, Jdmo jdmo, Date start,
													   Date end, Date lastUpdate) throws JdmoException {
<span class="fc" id="L888">		StringBuffer pStmt = new StringBuffer(15 * metaTC.getTraceTypes().length);</span>
<span class="fc" id="L889">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L890">		pStmt.append(&quot; SELECT &quot;);</span>
<span class="pc bpc" id="L891" title="1 of 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L892">			getCombinedQueueDESelectStmtForActualTC(metaTC, qIDSet, jdmo,</span>
					lastUpdate, pStmt, types);
<span class="fc bfc" id="L894" title="All 2 branches covered.">		} else if (metaTC instanceof ForecastTraceCube) {</span>
<span class="fc" id="L895">			getCombinedQueueDESelectStmtForForecastTC(metaTC, spSet, jdmo,</span>
					lastUpdate, pStmt, types);
<span class="fc bfc" id="L897" title="All 2 branches covered.">		} else if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L898">			getCombinedQueueDESelectStmtForSGTC(metaTC, spSet, jdmo,</span>
					lastUpdate, pStmt);
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">		} else if (metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L901">			getCombinedQueueDESelectStmtForRequireTC(metaTC, spSet, jdmo,</span>
					lastUpdate, pStmt, types);
		} else {
<span class="nc" id="L904">			return null;</span>
		}
<span class="fc" id="L906">		String TIME = getDETimeColumn(metaTC, false, false);</span>
<span class="pc bpc" id="L907" title="1 of 2 branches missed.">		String tableNameAppendStr = (lastUpdate != null ? &quot;E.&quot; : &quot;A.&quot;) + TIME;</span>

<span class="pc bpc" id="L909" title="2 of 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L910">			pStmt.append(&quot; and &quot;).append(tableNameAppendStr).append(&quot;&gt;= ? and &quot;).append(tableNameAppendStr).append(&quot;&lt;= ?&quot;);</span>
<span class="nc bnc" id="L911" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L912">			pStmt.append(&quot; and &quot;).append(tableNameAppendStr).append(&quot;&gt;= ?&quot;);</span>
<span class="nc bnc" id="L913" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L914">			pStmt.append(&quot; and &quot;).append(tableNameAppendStr).append(&quot;&lt;= ?&quot;);</span>
		}

<span class="pc bpc" id="L917" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L918">			pStmt.append(&quot; and ((E.MODIFIED is null and E.CREATED&gt; ? ) or E.MODIFIED &gt; ? &quot;);</span>
<span class="nc bnc" id="L919" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L920">				pStmt.append(&quot;or (G.MODIFIED is null and G.CREATED&gt; ? ) or G.MODIFIED &gt; ?&quot;);</span>
			}
<span class="nc" id="L922">			pStmt.append(&quot;)   ) &quot;);</span>
		}
<span class="fc" id="L924">		pStmt.append(&quot; order by A.&quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="pc bpc" id="L925" title="1 of 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L926">			m_cat.debug(&quot;QUERY=&quot; + pStmt);</span>
		}
<span class="fc" id="L928">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForRequireTC(
			TraceCube metaTC, Set spSet, Jdmo jdmo, Date lastUpdate,
			StringBuffer pStmt, short[] types) throws JdmoException {
		// FTE is from real queue
<span class="fc bfc" id="L944" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L945" title="All 2 branches covered.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="pc bpc" id="L946" title="1 of 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L947">					pStmt.append(getDETraceColumn(types[t])).append(i).append(',');</span>
				}
			}
		}
<span class="fc" id="L951">		pStmt.append(</span>
				&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE ,  V_MEDIA.SID MEDIAID, B.SID SPQUEUESID from  &quot;)
<span class="fc" id="L953">				.append(getTraceTable(metaTC));</span>
<span class="fc" id="L954">		pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN, V_MEDIA where C.CAMPAIGNID=CAMPAIGN.ID  and  V_MEDIA.ID=D.MEDIAID and &quot;);</span>
<span class="fc" id="L955">		pStmt.append(&quot; CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID &quot;);</span>
<span class="fc" id="L956">		pStmt.append(&quot; and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="pc bpc" id="L957" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L958">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L959">			pStmt.append(&quot; E, SPQUEUE F, SP G where E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;).append(</span>
<span class="nc" id="L960">					jdmo.createInClause(spSet));</span>
		}
<span class="fc" id="L962">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForSGTC(TraceCube metaTC,
															Set spSet, Jdmo jdmo, Date lastUpdate, StringBuffer pStmt)
			throws JdmoException {
<span class="fc" id="L975">		pStmt.append(&quot;SLPERCENT, ASA, B.MAXABANDONSPERCENT,&quot;);</span>
		// STARTTIME is needed, there may be skipped lines in the DB
<span class="fc" id="L977">		pStmt.append(&quot; A.DATETIME, D.SID, C.SID, B.SERVICELEVELGOALTYPE ,  V_MEDIA.SID MEDIAID, B.SID SPQUEUESID from &quot;)</span>
<span class="fc" id="L978">				.append(getTraceTable(metaTC));</span>
<span class="fc" id="L979">		pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D, V_MEDIA where A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and  V_MEDIA.ID=D.MEDIAID  and C.SID in &quot;);</span>
<span class="fc" id="L980">		pStmt.append(jdmo.createInClause(spSet));</span>
<span class="pc bpc" id="L981" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L982">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L983">			pStmt.append(&quot; E, SPQUEUE F, SP G where E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;).append(</span>
<span class="nc" id="L984">					jdmo.createInClause(spSet));</span>
		}
<span class="fc" id="L986">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForForecastTC(
			TraceCube metaTC, Set spSet, Jdmo jdmo, Date lastUpdate,
			StringBuffer pStmt, short[] types) throws JdmoException {
<span class="fc bfc" id="L1000" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L1001" title="All 2 branches covered.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="fc bfc" id="L1002" title="All 2 branches covered.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L1003">					pStmt.append(getDETraceColumn(types[t])).append(i).append(',');</span>
				}
			}
		}
		// select TIMEZONEMAP.JAVATZIDENT from
		// TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID
		// and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and
		// TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and
		// SP.ID=SPQUEUE.SPID
		// STARTTIME is needed, there may be skipped lines in the DB
<span class="fc" id="L1013">		pStmt.append(</span>
				&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE,  V_MEDIA.SID MEDIAID, B.SID SPQUEUESID from &quot;)
<span class="fc" id="L1015">				.append(getTraceTable(metaTC));</span>
<span class="fc" id="L1016">		pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN , V_MEDIA where C.CAMPAIGNID=CAMPAIGN.ID and  V_MEDIA.ID=D.MEDIAID &quot;);</span>
<span class="fc" id="L1017">		pStmt.append(&quot; and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME &quot;);</span>
<span class="fc" id="L1018">		pStmt.append(&quot; AND A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;).append(</span>
<span class="fc" id="L1019">				jdmo.createInClause(spSet));</span>
<span class="fc" id="L1020">		appendForecastInstanceID(metaTC, pStmt);</span>
<span class="pc bpc" id="L1021" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1022">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1023">			pStmt.append(&quot; E, SPQUEUE F, SP G where E.FORECASTINSTANCEID is null and E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;);</span>
<span class="nc" id="L1024">			pStmt.append(jdmo.createInClause(spSet));</span>
		}
<span class="fc" id="L1026">	}</span>

	/**
	 * @param metaTC
	 * @param qIDSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForActualTC(
			TraceCube metaTC, Set qIDSet, Jdmo jdmo, Date lastUpdate,
			StringBuffer pStmt, short[] types) throws JdmoException {
		// actual is based on real queue
<span class="nc bnc" id="L1041" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1043">				pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
			}
		}
<span class="nc" id="L1046">		pStmt.append(&quot; A.TIME, B.SID,  V_MEDIA.SID MEDIAID from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1047">		pStmt.append(&quot; A, QUEUE B , V_MEDIA where A.QUEUEID=B.ID and  V_MEDIA.ID=B.MEDIAID AND B.SID in &quot;).append(</span>
<span class="nc" id="L1048">				jdmo.createInClause(qIDSet));</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1050">			pStmt.append(&quot;  AND A.TIME in (select E.TIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1051">			pStmt.append(&quot; E, QUEUE D where E.QUEUEID=D.ID and D.SID in &quot;).append(jdmo.createInClause(qIDSet));</span>
		}
<span class="nc" id="L1053">	}</span>

	private static void appendForecastInstanceID(TraceCube metaTC, StringBuffer pStmt) {
<span class="pc bpc" id="L1056" title="1 of 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="fc" id="L1057">			pStmt.append(&quot; AND FORECASTINSTANCEID &quot;);</span>
<span class="fc" id="L1058">			ForecastTraceCube fCube = (ForecastTraceCube) metaTC;</span>
<span class="pc bpc" id="L1059" title="1 of 2 branches missed.">			if (!StringUtil.isEmptyOrWhiteSpace(fCube.getForecastInstanceID())) {</span>
<span class="nc" id="L1060">				pStmt.append(&quot;= '&quot; + fCube.getForecastInstanceID().trim() + &quot;' &quot;);</span>
			} else {
<span class="fc" id="L1062">				pStmt.append(&quot; IS NULL &quot;);</span>
			}
		}
<span class="fc" id="L1065">	}</span>

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue
	 * directly load
	 *
	 * @param TraceCube
	 *            , metaTC
	 * @param ID
	 *            , CampaignID
	 * @param ID
	 *            , mediaID
	 * @param Set
	 *            , SPID set
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return TraceCube,
	 */
	public static TraceCube getCombinedQueueTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID campaignID, ID mediaID,
																		 Set&lt;? extends ID&gt; spIDSet, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
																		 Map&lt;ID, SPQueue&gt; spqueuesBySID, boolean isNoPhantom) throws Exception {
<span class="fc" id="L1090">		Jdmo jdmo = new Jdmo();</span>
<span class="fc" id="L1091">		TraceCube cube = metaTC.newInstance(null, start, end, metaTC.getTraceTypes());</span>
		try {
<span class="fc" id="L1093">			JdmoRowset rs = getCombinedQueueTimeSeries(metaTC, campaignID, mediaID, spIDSet, start, end, lastUpdate, jdmo, isNoPhantom);</span>
<span class="fc" id="L1094">			cube = convert(rs, metaTC, start, end, mediaID, includeAllServiceGoalTypes, jdmo.isWhatIf(), spqueuesBySID, isNoPhantom);</span>
<span class="fc" id="L1095">			return cube;</span>
<span class="nc" id="L1096">		} catch (Exception e) {</span>
<span class="nc" id="L1097">			throw e;</span>
		} finally {
<span class="pc" id="L1099">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spIDSet
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getCombinedQueueTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID,
														 Set&lt;? extends ID&gt; spIDSet, Date start, Date end, Date lastUpdate, Jdmo jdmo,
														 boolean isNoPhantom) throws JdmoException {

		// Prepare the Statement
<span class="fc" id="L1120">		StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="fc" id="L1121">		pStmt.append(getCombinedQueueDESelectStmt(metaTC, mediaID, spIDSet, jdmo, isNoPhantom));</span>
<span class="fc" id="L1122">		String TIME = getDETimeColumn(metaTC, true, isNoPhantom);</span>
<span class="pc bpc" id="L1123" title="2 of 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L1124">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1125" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1126">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1127" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1128">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
		}
<span class="pc bpc" id="L1130" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1131">			pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1133">				pStmt.append(&quot;or (C.MODIFIED is null and C.CREATED&gt;?) or C.MODIFIED&gt;?&quot;);</span>
			}
<span class="nc" id="L1135">			pStmt.append(&quot;)&quot;);</span>
		}
<span class="fc" id="L1137">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
		// SQL Execution
<span class="fc" id="L1139">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L1140">		int lastUpdatePos = 1;</span>
<span class="fc" id="L1141">		jQuery.setParID(lastUpdatePos++, campaignID);</span>
<span class="fc" id="L1142">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="fc bfc" id="L1143" title="All 2 branches covered.">		if (mediaID != null) {</span>
<span class="fc" id="L1144">			jQuery.setParID(lastUpdatePos++, mediaID);</span>
		}
<span class="pc bpc" id="L1146" title="1 of 2 branches missed.">		if (start != null) {</span>
<span class="fc" id="L1147">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceStart(metaTC, start)));</span>
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">			if (end1 != null) {</span>
<span class="fc" id="L1149">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end1)));</span>
			}
		} else {
<span class="nc bnc" id="L1152" title="All 2 branches missed.">			if (end1 != null) {</span>
<span class="nc" id="L1153">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end1)));</span>
			}
		}
<span class="pc bpc" id="L1156" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1157">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1158">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1159">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1161">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1162">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
		}
<span class="fc" id="L1165">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L1166">		return rs;</span>
	}

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue
	 * directly load
	 *
	 * @param TraceCube
	 *            , metaTC
	 * @param ID
	 *            , CampaignID
	 * @param ID
	 *            , mediaID
	 * @param Set
	 *            , SPID set
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1) this
	 *         method is used by the TRACEREPORT DUMP only
	 */
	public static Collection&lt;TraceChunk&gt; getCombinedQueueTimeSeriesFromLastUpdate(TraceCube metaTC, ID campaignID,
																				  ID mediaID, Set&lt;? extends ID&gt; spIDSet, Date start, Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L1192">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc" id="L1193">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L1197">			int arraySz = 0;</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1199">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1201" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1202">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
<span class="nc" id="L1204">			JdmoRowset rs = getCombinedQueueTimeSeries(metaTC, campaignID, mediaID, spIDSet, start, end, lastUpdate, jdmo, false);</span>
<span class="nc" id="L1205">			convert(rs, metaTC, tcArray, start, end, mediaID);</span>
<span class="nc" id="L1206">			return tcArray;</span>
<span class="nc" id="L1207">		} catch (JdmoException e) {</span>
<span class="nc" id="L1208">			throw e;</span>
<span class="nc" id="L1209">		} catch (Exception e) {</span>
<span class="nc" id="L1210">			e.printStackTrace();</span>
<span class="nc" id="L1211">			return tcArray;</span>
		} finally {
<span class="nc" id="L1213">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueDESelectStmt(TraceCube metaTC, ID mediaID, Set&lt;? extends ID&gt; spSet,
													   Jdmo jdmo, boolean isNoPhantom)
			throws JdmoException {
<span class="fc" id="L1220">		StringBuffer pStmt = new StringBuffer(15 * metaTC.getTraceTypes().length);</span>
<span class="fc" id="L1221">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L1222">		pStmt.append(&quot;select &quot;);</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="fc" id="L1224">			getCombinedQueueDESelectStmtForPredictTC(metaTC, spSet, jdmo,</span>
					isNoPhantom, pStmt, types);
		}
<span class="fc bfc" id="L1227" title="All 2 branches covered.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L1228">			getCombinedQueueDESelectStmtForSGTC(metaTC, spSet, jdmo, pStmt);</span>
		}
<span class="fc bfc" id="L1230" title="All 2 branches covered.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L1231">			getCombinedQueueDESelectStmtForRequireTC(metaTC, spSet, jdmo,</span>
					pStmt, types);
		}
<span class="fc" id="L1234">		pStmt.append(&quot; and QUEUEID is null and CAMPAIGNID=(select ID from CAMPAIGN where SID=?)&quot;);</span>
<span class="fc bfc" id="L1235" title="All 2 branches covered.">		if (mediaID != null) {</span>
<span class="fc" id="L1236">			pStmt.append(&quot; and MEDIAID=(select ID from MEDIA where SID=?)&quot;);</span>
		} else {
<span class="fc" id="L1238">			pStmt.append(&quot; and MEDIAID is null&quot;);</span>
		}
<span class="fc" id="L1240">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForRequireTC(
			TraceCube metaTC, Set&lt;? extends ID&gt; spSet, Jdmo jdmo,
			StringBuffer pStmt, short[] types) throws JdmoException {
<span class="fc bfc" id="L1254" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L1255" title="All 2 branches covered.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="pc bpc" id="L1256" title="1 of 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L1257">					pStmt.append(&quot;FTE&quot;).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
<span class="fc" id="L1261">		pStmt.append(&quot;A.DATETIME, TIMEZONEMAP.JAVATZIDENT, c.FROMDATE, c.TODATE , B.SID SPQUEUESID from &quot;);</span>
<span class="fc" id="L1262">		pStmt.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B, SP C,TIMEZONE,TIMEZONEMAP,CAMPAIGN&quot;);</span>
<span class="fc" id="L1263">		pStmt.append(</span>
				&quot; where C.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;)
<span class="fc" id="L1265">				.append(jdmo.createInClause(spSet));</span>
<span class="fc" id="L1266">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param pStmt
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForSGTC(TraceCube metaTC,
															Set&lt;? extends ID&gt; spSet, Jdmo jdmo, StringBuffer pStmt)
			throws JdmoException {
<span class="fc" id="L1278">		pStmt.append(&quot;SLPERCENT, ASA, B.MAXABANDONSPERCENT, &quot;);</span>
		// STARTTIME is needed, there may be skipped lines in the DB
<span class="fc" id="L1280">		pStmt.append(&quot; A.DATETIME, B.SERVICELEVELGOALTYPE from &quot;).append(getTraceTable(metaTC));</span>
<span class="fc" id="L1281">		pStmt.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;).append(</span>
<span class="fc" id="L1282">				jdmo.createInClause(spSet));</span>
<span class="fc" id="L1283">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param isNoPhantom
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForPredictTC(
			TraceCube metaTC, Set&lt;? extends ID&gt; spSet, Jdmo jdmo,
			boolean isNoPhantom, StringBuffer pStmt, short[] types)
			throws JdmoException {
<span class="fc bfc" id="L1298" title="All 2 branches covered.">		for (int i = 1; i &lt;= 96; i++) {</span>
<span class="fc bfc" id="L1299" title="All 2 branches covered.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="fc bfc" id="L1300" title="All 2 branches covered.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
					// bad hack; done for Netstaffing feature. implemeneted
					// as per Jason's directive for performance reasons.
<span class="fc bfc" id="L1303" title="All 2 branches covered.">					if (types[t] == Trace.ASTAFFING) {</span>
<span class="fc" id="L1304">						pStmt.append(&quot;ISNULL(ASTAFF&quot;).append(i).append(&quot;,STAFFING&quot;).append(i).append(&quot;) ASTAFF&quot;)</span>
<span class="fc" id="L1305">								.append(i).append(&quot;,&quot;);</span>
						// ISNULL(ASTAFF,STAFFING) ASTAFF1
<span class="fc bfc" id="L1307" title="All 2 branches covered.">					} else if (types[t] == Trace.AFTE) {</span>
<span class="fc" id="L1308">						pStmt.append(&quot;ISNULL(AFTE&quot;).append(i).append(&quot;,FTE&quot;).append(i).append(&quot;) AFTE&quot;).append(i)</span>
<span class="fc" id="L1309">								.append(&quot;,&quot;);</span>
					} else {
<span class="fc" id="L1311">						pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
					}
				}
			}
		}
<span class="fc" id="L1316">		pStmt.append(getDETimeColumn(metaTC, true, isNoPhantom));</span>
<span class="fc" id="L1317">		pStmt.append(&quot;, TIMEZONEMAP.JAVATZIDENT, c.FROMDATE, c.TODATE , B.SID SPQUEUESID from &quot;);</span>
<span class="fc" id="L1318">		pStmt.append(getTraceTable(metaTC, isNoPhantom)).append(&quot; A, SPQUEUE B, SP C, TIMEZONE, TIMEZONEMAP, CAMPAIGN &quot;);</span>
<span class="fc" id="L1319">		pStmt.append(</span>
				&quot; where C.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;)
<span class="fc" id="L1321">				.append(jdmo.createInClause(spSet));</span>
<span class="fc" id="L1322">	}</span>

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace
	 * Types with timestamp on it
	 *
	 * @param ID
	 *            , Queue ID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getActualTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
															   Date lastUpdate) throws JdmoException {
<span class="nc" id="L1340">		ArrayList tcArray = new ArrayList();</span>
<span class="nc" id="L1341">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L1345">			int arraySz = 0;</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1347">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1349" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1350">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1353">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1354">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1355">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
			// Prepare the Statement
<span class="nc" id="L1357">			StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="nc" id="L1358">			short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1359">			pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">			for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1362">					pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
				}
			}
<span class="nc" id="L1365">			pStmt.append(&quot; TIME, MODIFIED, CREATED from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1366">			pStmt.append(&quot; A where QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L1367">			String TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="nc bnc" id="L1368" title="All 4 branches missed.">			if (start != null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1369">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1370" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end1 == null) {</span>
<span class="nc" id="L1371">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1372" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1373">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="nc bnc" id="L1375" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1376">				pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc" id="L1377">				pStmt.append(&quot;)&quot;);</span>
			}
<span class="nc" id="L1379">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1381">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1382">			jQuery.setParID(1, queueID);</span>
<span class="nc" id="L1383">			int lastUpdatePos = 2;</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">			if (traceStart != null) {</span>
<span class="nc" id="L1385">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1387">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			} else {
<span class="nc bnc" id="L1390" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1391">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			}
<span class="nc bnc" id="L1394" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1395">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1396">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1397">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
<span class="nc" id="L1399">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc bnc" id="L1401" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1402">				TraceChunk tc = new TraceChunk(queueID, TimeZoneUtil.toDate(rs.getTimestamp(types.length + 1)));</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">				for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L1404">					tc.setTraceValue(types[i], i + 1);</span>
				}
<span class="nc" id="L1406">				Date modifedAt = TimeZoneUtil.toDate(rs.getTimestamp(types.length + 2));</span>
<span class="nc bnc" id="L1407" title="All 2 branches missed.">				if (modifedAt == null) {</span>
<span class="nc" id="L1408">					modifedAt = TimeZoneUtil.toDate(rs.getTimestamp(types.length + 3));</span>
				}
<span class="nc" id="L1410">				tc.setLastModifiedDate(modifedAt);</span>
<span class="nc" id="L1411">				tcArray.add(tc);</span>
<span class="nc" id="L1412">			}</span>
<span class="nc" id="L1413">			return tcArray;</span>
<span class="nc" id="L1414">		} catch (JdmoException e) {</span>
<span class="nc" id="L1415">			throw e;</span>
<span class="nc" id="L1416">		} catch (Exception e) {</span>
<span class="nc" id="L1417">			e.printStackTrace();</span>
<span class="nc" id="L1418">			return tcArray;</span>
		} finally {
<span class="nc" id="L1420">			jdmo.cleanUp();</span>
		}
	} // getTimeSeriesFromLastUpdate

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace
	 * Types with timestamp on it
	 *
	 * @param ID
	 *            , Queue ID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getActualTimeSeriesCubeFromLastUpdate(TraceCube metaTC, Collection queueIDCol, Date start,
																   Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L1440">		ArrayList tcArray = new ArrayList();</span>
<span class="nc" id="L1441">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1443">			String inClause = jdmo.createInClause(queueIDCol);</span>
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L1446">			int arraySz = 0;</span>
<span class="nc bnc" id="L1447" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1448">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1450" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1451">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1454">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1455">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1456">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
			// Prepare the Statement
<span class="nc" id="L1458">			StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="nc" id="L1459">			short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1460">			pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1461" title="All 2 branches missed.">			for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1462" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1463">					pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
				}
			}
<span class="nc" id="L1466">			pStmt.append(&quot; TIME, B.SID from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1467">			pStmt.append(&quot; A, QUEUE B where A.QUEUEID=B.ID and B.SID in &quot;).append(inClause);</span>
<span class="nc" id="L1468">			String TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="nc bnc" id="L1469" title="All 4 branches missed.">			if (start != null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1470">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1471" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end1 == null) {</span>
<span class="nc" id="L1472">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1473" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1474">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}

<span class="nc bnc" id="L1477" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
				// first the earliest startime has changes, then load everything
				// till end
<span class="nc" id="L1480">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=&quot;);</span>
<span class="nc" id="L1481">				pStmt.append(&quot;(select min(&quot;).append(TIME).append(&quot;) from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1482">				pStmt.append(&quot; X where X.&quot;).append(TIME).append(&quot;&gt;=? and X.&quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc" id="L1483">				pStmt.append(&quot; and ((X.MODIFIED is null and X.CREATED&gt;?) or X.MODIFIED&gt;?) and X.QUEUEID in (select ID from QUEUE Y where Y.SID in &quot;);</span>
<span class="nc" id="L1484">				pStmt.append(inClause).append(&quot;))&quot;);</span>
			}
<span class="nc" id="L1486">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1488">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1489">			int lastUpdatePos = 1;</span>
<span class="nc" id="L1490">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc" id="L1491">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc bnc" id="L1492" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1493">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1494">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc" id="L1495">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1496">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1497">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
<span class="nc" id="L1499">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1500">			return convertActual(rs, metaTC, queueIDCol, start, end1, jdmo.isWhatIf());</span>
<span class="nc" id="L1501">		} catch (JdmoException e) {</span>
<span class="nc" id="L1502">			throw e;</span>
<span class="nc" id="L1503">		} catch (Exception e) {</span>
<span class="nc" id="L1504">			e.printStackTrace();</span>
<span class="nc" id="L1505">			return tcArray;</span>
		} finally {
<span class="nc" id="L1507">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace
	 * Types
	 *
	 * @param ID
	 *            , Queue ID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
														 Date lastUpdate, boolean includeAllServiceGoalTypes) throws JdmoException {

<span class="fc" id="L1528">		Jdmo jdmo = null;</span>
		try {
<span class="fc" id="L1530">			jdmo = new Jdmo();</span>
<span class="fc" id="L1531">			return getTimeSeriesFromLastUpdate(metaTC, queueID, start, end, lastUpdate, jdmo, includeAllServiceGoalTypes);</span>
		} finally {
<span class="pc bpc" id="L1533" title="3 of 4 branches missed.">			if (jdmo != null) {</span>
<span class="pc" id="L1534">				jdmo.cleanUp();</span>
			}
		}
	}

	public static Collection getTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
														 Date lastUpdate, Jdmo jdmo, boolean includeAllServiceGoalTypes) throws JdmoException {
<span class="fc" id="L1541">		ArrayList tcArray = new ArrayList();</span>
		// Anticipate the collection size won't exceed the real days in between
		// start/end
<span class="fc" id="L1544">		int arraySz = 0;</span>
<span class="pc bpc" id="L1545" title="2 of 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L1546">			arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
		}
<span class="pc bpc" id="L1548" title="1 of 2 branches missed.">		if (arraySz != 0) {</span>
<span class="fc" id="L1549">			tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
		}
		// Prepare for select window
<span class="fc" id="L1552">		Date traceStart = getTraceStart(metaTC, start);</span>
<span class="fc" id="L1553">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="fc" id="L1554">		Date traceEnd = getTraceEnd(metaTC, end1);</span>
<span class="fc" id="L1555">		JdmoRowset rs = getSingleQueueTrace(metaTC, queueID, start, end1, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="fc" id="L1556">		convertTraceChunks(rs, metaTC, queueID, tcArray, start, end1, includeAllServiceGoalTypes, jdmo.isWhatIf());</span>
<span class="fc" id="L1557">		return tcArray;</span>
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace
	 * Types
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param spqueuesBySID
	 * isNoPhantom is set to false as the default behavior.
	 * @return TraceCube
	 */
	public static TraceCube getTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
															Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID, Map&lt;ID,Queue&gt; idQueueMap) throws Exception {
<span class="fc" id="L1574">		return getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end,</span>
				lastUpdate, spqueuesBySID, idQueueMap, false);
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types.
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param spqueuesBySID
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 * ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws Exception
	 */
	public static TraceCube getTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
															Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID, Map&lt;ID,Queue&gt; idQueueMap,  boolean isNoPhantom) throws Exception {
<span class="fc" id="L1593">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Prepare for select window
<span class="fc" id="L1596">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="fc" id="L1597">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="fc" id="L1598">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
<span class="fc" id="L1599">			JdmoRowset rs = getSingleQueueTrace(metaTC, queueID, start, end1, lastUpdate, jdmo, traceStart, traceEnd, isNoPhantom);</span>
<span class="fc" id="L1600">			return convert(rs, metaTC, queueID, start, end1, false, jdmo.isWhatIf(), spqueuesBySID, idQueueMap, isNoPhantom);</span>
<span class="nc" id="L1601">		} catch (JdmoException e) {</span>
<span class="nc" id="L1602">			throw e;</span>
		} finally {
<span class="pc" id="L1604">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace
	 * Types
	 *
	 * @param ID
	 *            , Queue ID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return TraceCube
	 */
	public static TraceCube getActualTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
																  Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="nc" id="L1624">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Prepare for select window
<span class="nc" id="L1627">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1628">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1629">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
			// Prepare the Statement
<span class="nc" id="L1631">			StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="nc" id="L1632">			pStmt.append(getDESelectStmt(metaTC, jdmo));</span>
<span class="nc" id="L1633">			String TIME = getDETimeColumn(metaTC, true, false);</span>
			// first the earliest startime has changes, then load everything
			// till end
<span class="nc" id="L1636">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=&quot;);</span>
<span class="nc bnc" id="L1637" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1638">				pStmt.append(&quot;(select min(&quot;).append(TIME).append(&quot;) from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1639">				pStmt.append(&quot; X where X.&quot;).append(TIME).append(&quot;&gt;=? and X.&quot;).append(TIME).append(&quot;&lt;=? and &quot;);</span>
<span class="nc" id="L1640">				pStmt.append(&quot; and ((X.MODIFIED is null and X.CREATED&gt;?) or X.MODIFIED&gt;?) and X.QUEUEID=(select ID from QUEUE where SID=?))&quot;);</span>
			} else {
<span class="nc" id="L1642">				pStmt.append(&quot;?&quot;);</span>
			}
<span class="nc" id="L1644">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc" id="L1645">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1647">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1648">			jQuery.setParString(1, DAOUtil.mapIDToDEID(queueID, new QueueFieldInfo()).toString());</span>
<span class="nc" id="L1649">			int lastUpdatePos = 2;</span>
<span class="nc" id="L1650">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1652">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1653">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1654">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1655">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1656">				jQuery.setParID(lastUpdatePos, queueID);</span>
			}
<span class="nc" id="L1658">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1659">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1660">			return convert(rs, metaTC, queueID, start, end1, false, jdmo.isWhatIf(), spqueuesBySID, null, false);</span>
<span class="nc" id="L1661">		} catch (JdmoException e) {</span>
<span class="nc" id="L1662">			throw e;</span>
		} finally {
<span class="nc" id="L1664">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd
	 * isNoPhantom will default to false.
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSingleQueueTrace(TraceCube metaTC, ID queueID, Date start, Date end, Date lastUpdate,
												  Jdmo jdmo, Date traceStart, Date traceEnd) throws JdmoException {
<span class="fc" id="L1683">		return getSingleQueueTrace(metaTC, queueID, start, end, lastUpdate,</span>
				jdmo, traceStart, traceEnd, false);
	}

	/**
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 * ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSingleQueueTrace(TraceCube metaTC, ID queueID, Date start, Date end, Date lastUpdate,
												  Jdmo jdmo, Date traceStart, Date traceEnd, boolean isNoPhantom) throws JdmoException {
		// Prepare the Statement
<span class="fc" id="L1704">		StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="fc" id="L1705">		pStmt.append(getDESelectStmt(metaTC, jdmo, isNoPhantom));</span>
<span class="fc" id="L1706">		appendDateClause(metaTC, pStmt, start, end, lastUpdate, isNoPhantom);</span>
		// SQL Execution
<span class="fc" id="L1708">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
		try {
<span class="fc" id="L1710">			jQuery.setParString(1, DAOUtil.mapIDToDEID(queueID, new QueueFieldInfo()).toString());</span>
<span class="fc" id="L1711">			int lastUpdatePos = 2;</span>
<span class="pc bpc" id="L1712" title="1 of 2 branches missed.">			if (traceStart != null) {</span>
<span class="fc" id="L1713">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">				if (traceEnd != null) {</span>
<span class="fc" id="L1715">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			} else {
<span class="nc bnc" id="L1718" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1719">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			}
<span class="pc bpc" id="L1722" title="1 of 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1723">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1724">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1725">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L1726" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1727">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1728">					jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
				}
			}
<span class="fc" id="L1731">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L1732">			return rs;</span>
<span class="nc" id="L1733">		}catch(BbmFinderException e){</span>
<span class="nc" id="L1734">			throw new JdmoException(&quot;Exception in method getSingleQueueTrace while getting ID from SID for queue &quot;+e.getMessage());</span>
		}
	}

	private static void appendDateClause(TraceCube metaTC, StringBuffer pStmt, Date start, Date end, Date lastUpdate, boolean isNoPhantom) {
<span class="fc" id="L1739">		boolean instanceOfForecast = metaTC instanceof ForecastTraceCube;</span>
<span class="fc" id="L1740">		boolean instanceOfPredict = metaTC instanceof PredictTraceCube;</span>
<span class="fc" id="L1741">		String TIME = null;</span>
<span class="fc bfc" id="L1742" title="All 4 branches covered.">		if ((instanceOfForecast || instanceOfPredict)) {</span>
<span class="fc" id="L1743">			TIME = &quot;F.&quot; + getDETimeColumn(metaTC, false, isNoPhantom);</span>
<span class="fc" id="L1744">			pStmt.append(&quot; AND A.ID in (SELECT F.ID FROM &quot;).append(getTraceTable(metaTC, isNoPhantom)).append(&quot; F, SPQUEUE D WHERE &quot;);</span>
<span class="fc" id="L1745">			pStmt.append(&quot; D.ID = F.SPQUEUEID AND D.QUEUEID= ?&quot;);</span>
<span class="fc bfc" id="L1746" title="All 2 branches covered.">			if (instanceOfForecast) {</span>
<span class="fc" id="L1747">				appendForecastInstanceID(metaTC, pStmt);</span>
			}

<span class="pc bpc" id="L1750" title="2 of 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L1751">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1752" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1753">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1754" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1755">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="pc bpc" id="L1757" title="1 of 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1758">				pStmt.append(&quot; and ((F.MODIFIED is null and F.CREATED&gt;?) or F.MODIFIED&gt;? ) &quot;);</span>
			}
<span class="fc" id="L1760">			pStmt.append(&quot;)&quot;);</span>
<span class="fc" id="L1761">			TIME = getDETimeColumn(metaTC, true, isNoPhantom); // this is reqd for the order</span>
			// by clause below
		} else {
<span class="fc" id="L1764">			TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="pc bpc" id="L1765" title="2 of 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L1766">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1767" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1768">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1769" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1770">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="pc bpc" id="L1772" title="1 of 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1773">				pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc bnc" id="L1774" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1775">					pStmt.append(&quot;or (B.MODIFIED is null and B.CREATED&gt;?) or B.MODIFIED&gt;?&quot;);</span>
				}
<span class="nc" id="L1777">				pStmt.append(&quot;)&quot;);</span>
			}
		}
<span class="fc" id="L1780">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="fc" id="L1781">	}</span>

	/**
	 * Retrieve SGTimeSeries for a Queue, specifying a given period for all
	 * Trace Types
	 *
	 * @param Set
	 *            , SPID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return TraceCube
	 */
	public static TraceCube getSGTimeSeriesCubeFromLastUpdate(ID queueID, Set SPIDSet, String mediaDeID, Date start,
															  Date end, Date lastUpdate, boolean includeAllServiceGoalTypes, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="fc" id="L1799">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Prepare for select window
<span class="fc" id="L1802">			Date traceStart = getTraceStart(TraceUtil.META_SERVICEGOAL, start);</span>
<span class="fc" id="L1803">			Date traceEnd = getTraceEnd(TraceUtil.META_SERVICEGOAL, end);</span>
<span class="fc" id="L1804">			JdmoRowset rs = getSGTimeSeries(SPIDSet, mediaDeID, start, end, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="fc" id="L1805">			return convert(rs, TraceUtil.META_SERVICEGOAL, queueID, start, end, includeAllServiceGoalTypes, jdmo.isWhatIf(),</span>
					spqueuesBySID, null, false);
<span class="nc" id="L1807">		} catch (JdmoException e) {</span>
<span class="nc" id="L1808">			throw e;</span>
		} finally {
<span class="pc" id="L1810">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param SPIDSet
	 * @param mediaDeID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSGTimeSeries(Set SPIDSet, String mediaDeID, Date start, Date end, Date lastUpdate,
											  Jdmo jdmo, Date traceStart, Date traceEnd) throws JdmoException {
		// Prepare the Statement
<span class="fc" id="L1829">		StringBuffer pStmt = new StringBuffer(6800);</span>
<span class="fc" id="L1830">		pStmt.append(getDESelectStmt(SPIDSet, mediaDeID, jdmo));</span>
<span class="fc" id="L1831">		String TIME = getDETimeColumn(TraceUtil.META_SERVICEGOAL, true, false);</span>
<span class="pc bpc" id="L1832" title="2 of 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="fc" id="L1833">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1834" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1835">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1836" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1837">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
		}
<span class="pc bpc" id="L1839" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1840">			pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc" id="L1841">			pStmt.append(&quot;or (B.MODIFIED is null and B.CREATED&gt;?) or B.MODIFIED&gt;?&quot;);</span>
<span class="nc" id="L1842">			pStmt.append(&quot;)&quot;);</span>
		}
<span class="fc" id="L1844">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
		// SQL Execution
<span class="fc" id="L1846">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L1847">		int lastUpdatePos = 1;</span>
<span class="pc bpc" id="L1848" title="1 of 2 branches missed.">		if (traceStart != null) {</span>
<span class="fc" id="L1849">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="pc bpc" id="L1850" title="1 of 2 branches missed.">			if (traceEnd != null) {</span>
<span class="fc" id="L1851">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
			}
		} else {
<span class="nc bnc" id="L1854" title="All 2 branches missed.">			if (traceEnd != null) {</span>
<span class="nc" id="L1855">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
			}
		}
<span class="pc bpc" id="L1858" title="1 of 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1859">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1860">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1861">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1862">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1863">			jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
		}
<span class="fc" id="L1865">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc" id="L1866">		return rs;</span>
	}

	/**
	 * Retrieve SGTimeSeries for a Queue, specifying a given period for all
	 * Trace Types
	 *
	 * @param Set
	 *            , SPID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @param Date
	 *            , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getSGTimeSeriesFromLastUpdate(ID queueID, Set SPIDSet, String mediaDeID, Date start, Date end,
														   Date lastUpdate, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L1885">		ArrayList tcArray = new ArrayList();</span>
		try {
			// Anticipate the collection size won't exceed the real days in
			// between start/end
<span class="nc" id="L1889">			int arraySz = 0;</span>
<span class="nc bnc" id="L1890" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1891">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1893" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1894">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1897">			Date traceStart = getTraceStart(TraceUtil.META_SERVICEGOAL, start);</span>
<span class="nc" id="L1898">			Date traceEnd = getTraceEnd(TraceUtil.META_SERVICEGOAL, end);</span>
<span class="nc" id="L1899">			JdmoRowset rs = getSGTimeSeries(SPIDSet, mediaDeID, start, end, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="nc" id="L1900">			convertTraceChunks(rs, TraceUtil.META_SERVICEGOAL, queueID, tcArray, start, end, false, jdmo.isWhatIf());</span>
<span class="nc" id="L1901">			return tcArray;</span>
<span class="nc" id="L1902">		} catch (JdmoException e) {</span>
<span class="nc" id="L1903">			throw e;</span>
<span class="nc" id="L1904">		} catch (Exception e) {</span>
<span class="nc" id="L1905">			e.printStackTrace();</span>
<span class="nc" id="L1906">			return tcArray;</span>
		}
	} // getSGTimeSeriesFromLastUpdate

	private static Date getTraceStart(TraceCube metaTC, Date start) {
<span class="pc bpc" id="L1911" title="1 of 2 branches missed.">		if (start != null) {</span>
<span class="fc bfc" id="L1912" title="All 6 branches covered.">			if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube</span>
					|| metaTC instanceof RequireTraceCube) {
<span class="fc" id="L1914">				return new Date(start.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
			}
		}
<span class="fc" id="L1917">		return start;</span>
	}

	private static Date getTraceEnd(TraceCube metaTC, Date end) {
<span class="pc bpc" id="L1921" title="1 of 2 branches missed.">		if (end != null) {</span>
<span class="fc bfc" id="L1922" title="All 4 branches covered.">			if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube) {</span>
<span class="fc" id="L1923">				return new Date(end.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
			}
		}
<span class="fc" id="L1926">		return end;</span>
	}

	// non skill based SG load is from Combined Media queue
	private static String getDESelectStmt
	(Set SPIDSet, String mediaDeID, Jdmo jdmo) throws JdmoException {
<span class="fc" id="L1932">		StringBuffer pStmt = new StringBuffer(15 * TraceUtil.META_SERVICEGOAL.getTraceTypes().length);</span>
		// TODO: add TIMEZONEMAP.JAVATZIDENT in query for DST fix
<span class="fc" id="L1934">		pStmt.append(&quot;select SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, B.SERVICELEVELGOALTYPE from &quot;);</span>
<span class="fc" id="L1935">		pStmt.append(getTraceTable(TraceUtil.META_SERVICEGOAL)).append(&quot; A, SPQUEUE B&quot;);</span>
<span class="fc" id="L1936">		pStmt.append(&quot; where A.SPQUEUEID=B.ID and &quot;);</span>
		// if no skill based, need get the trace from combined media queue
		// instead
<span class="fc" id="L1939">		pStmt.append(&quot;B.ID in (select SPQUEUE.ID from SPQUEUE, SP where SPQUEUE.SPID=SP.ID and SP.SID in &quot;);</span>
<span class="fc" id="L1940">		pStmt.append(jdmo.createInClause(SPIDSet)).append(&quot; and MEDIAID='&quot;);</span>
<span class="fc" id="L1941">		pStmt.append(mediaDeID).append(&quot;' and QUEUEID is null)&quot;);</span>
<span class="fc" id="L1942">		return pStmt.toString();</span>
	}

	/**
	 * direct load for single queue
	 * @param metaTC
	 * @param jdmo
	 * Sets isNoPhantom to false as the default.
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmt(TraceCube metaTC, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L1954">		return getDESelectStmt(metaTC, jdmo, false);</span>
	}

	/**
	 * direct load for single queue
	 * @param metaTC
	 * @param jdmo
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 * ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmt(TraceCube metaTC, Jdmo jdmo, boolean isNoPhantom) throws JdmoException {
<span class="fc" id="L1967">		StringBuffer pStmt = new StringBuffer(15 * metaTC.getTraceTypes().length);</span>
<span class="fc" id="L1968">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L1969">		pStmt.append(&quot;select &quot;);</span>
<span class="pc bpc" id="L1970" title="1 of 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1971">			return getDESelectStmtForActualTC(metaTC, jdmo, pStmt, types);</span>
		}
<span class="fc bfc" id="L1973" title="All 2 branches covered.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="fc" id="L1974">			return getDESelectStmtForForecastTC(metaTC, pStmt, types);</span>
		}
<span class="fc bfc" id="L1976" title="All 2 branches covered.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L1977">			return getDESelectStmtForRequireTC(metaTC, pStmt, types);</span>
		}
<span class="fc bfc" id="L1979" title="All 2 branches covered.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="fc" id="L1980">			return getDESelectStmtForPredictTC(metaTC, isNoPhantom, pStmt,</span>
					types);
		}
<span class="pc bpc" id="L1983" title="1 of 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L1984">			return getDESelectStmtForSGTC(metaTC, pStmt);</span>
		}
<span class="nc" id="L1986">		return null;</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @return
	 */
	private static String getDESelectStmtForSGTC(TraceCube metaTC,
												 StringBuffer pStmt) {
		// TODO: add TIMEZONEMAP.JAVATZIDENT in query for DST fix
<span class="fc" id="L1997">		pStmt.append(&quot;SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, B.SERVICELEVELGOALTYPE, MAXDIALS from &quot;);</span>
<span class="fc" id="L1998">		pStmt.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B&quot;);</span>
<span class="fc" id="L1999">		pStmt.append(&quot; where A.SPQUEUEID=B.ID and &quot;);</span>
<span class="fc" id="L2000">		pStmt.append(&quot;B.QUEUEID=? &quot;);</span>
<span class="fc" id="L2001">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param isNoPhantom
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForPredictTC(TraceCube metaTC,
													  boolean isNoPhantom, StringBuffer pStmt, short[] types) {

<span class="fc bfc" id="L2014" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L2015" title="All 2 branches covered.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="fc bfc" id="L2016" title="All 2 branches covered.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
					// bad hack; done for Netstaffing feature. implemeneted
					// as per Jason's directive for performance reasons.
<span class="fc bfc" id="L2019" title="All 2 branches covered.">					if (types[t] == Trace.ASTAFFING) {</span>
<span class="fc" id="L2020">						pStmt.append(&quot;ISNULL(ASTAFF&quot;).append(i).append(&quot;,STAFFING&quot;).append(i).append(&quot;) ASTAFF&quot;)</span>
<span class="fc" id="L2021">								.append(i).append(&quot;,&quot;);</span>
						// ISNULL(ASTAFF,STAFFING) ASTAFF1
<span class="fc bfc" id="L2023" title="All 2 branches covered.">					} else if (types[t] == Trace.AFTE) {</span>
<span class="fc" id="L2024">						pStmt.append(&quot;ISNULL(AFTE&quot;).append(i).append(&quot;,FTE&quot;).append(i).append(&quot;) AFTE&quot;).append(i)</span>
<span class="fc" id="L2025">								.append(&quot;,&quot;);</span>
					} else {
<span class="fc" id="L2027">						pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
					}
				}
			}
		}
<span class="fc" id="L2032">		pStmt.append(getDETimeColumn(metaTC, true, isNoPhantom));</span>
<span class="fc" id="L2033">		pStmt.append(&quot;, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;);</span>
<span class="fc" id="L2034">		pStmt.append(getTraceTable(metaTC, isNoPhantom)).append(&quot; A, SPQUEUE B, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP &quot;);</span>
<span class="fc" id="L2035">		pStmt.append(&quot; where SP.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID&quot;);</span>
<span class="fc" id="L2036">		pStmt.append(&quot; and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and SP.ID=B.SPID and A.SPQUEUEID=B.ID &quot;);</span>
<span class="fc" id="L2037">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForRequireTC(TraceCube metaTC,
													  StringBuffer pStmt, short[] types) {
<span class="fc bfc" id="L2048" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L2049" title="All 2 branches covered.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="pc bpc" id="L2050" title="1 of 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L2051">					pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
		// STARTTIME is needed, there may be skipped lines in the DB
<span class="fc" id="L2056">		pStmt.append(&quot; A.DATETIME, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;).append(</span>
<span class="fc" id="L2057">				getTraceTable(metaTC));</span>
<span class="fc" id="L2058">		pStmt.append(&quot; A, SPQUEUE B, TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID &quot;);</span>
<span class="fc" id="L2059">		pStmt.append(&quot;AND  CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME &quot;);</span>
<span class="fc" id="L2060">		pStmt.append(&quot;AND SP.ID=B.SPID and B.ID = A.SPQUEUEID and B.QUEUEID=? &quot;);</span>
<span class="fc" id="L2061">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForForecastTC(TraceCube metaTC,
													   StringBuffer pStmt, short[] types) {
<span class="fc bfc" id="L2072" title="All 2 branches covered.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L2073" title="All 2 branches covered.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="fc bfc" id="L2074" title="All 2 branches covered.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L2075">					pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
		// select TIMEZONEMAP.JAVATZIDENT from
		// TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID
		// and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and
		// TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and
		// SP.ID=SPQUEUE.SPID
		// STARTTIME is needed, there may be skipped lines in the DB
<span class="fc" id="L2085">		pStmt.append(&quot; A.DATETIME, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;).append(</span>
<span class="fc" id="L2086">				getTraceTable(metaTC));</span>
<span class="fc" id="L2087">		pStmt.append(&quot; A, SPQUEUE B, TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID &quot;);</span>
<span class="fc" id="L2088">		pStmt.append(&quot; and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME&quot;);</span>
<span class="fc" id="L2089">		pStmt.append(&quot; and SP.ID=B.SPID and B.ID = A.SPQUEUEID &quot;);</span>
<span class="fc" id="L2090">		appendForecastInstanceID(metaTC, pStmt);</span>
		// pStmt.append(&quot; and B.QUEUEID=(select ID from QUEUE where SID=?) &quot;);
<span class="fc" id="L2092">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param jdmo
	 * @param pStmt
	 * @param types
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmtForActualTC(TraceCube metaTC,
													 Jdmo jdmo, StringBuffer pStmt, short[] types) throws JdmoException {
<span class="nc bnc" id="L2105" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2106" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2107">				pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
			}
		}
<span class="nc" id="L2110">		pStmt.append(&quot; TIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L2111">		pStmt.append(&quot; A where QUEUEID=?&quot;);</span>
<span class="nc" id="L2112">		return pStmt.toString();</span>
	}

	// TODO:change the calcComputedTraceValuesForTraceChunk to other place
	// So far this is always called either from reports, or metaTC is an
	// instance of
	// ServiceGoalsTraceCube. 2011-09-08
	private static void convertTraceChunks(JdmoRowset rs, TraceCube metaTC, ID queueID, ArrayList tcArray, Date start, Date end,
										   boolean includeAllServiceGoalTypes, boolean isWhatIf) throws JdmoException {
<span class="fc" id="L2121">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L2122">		ID mediaID = TraceOperatorAdapter.getMediaIDForQueue(queueID, isWhatIf);</span>
<span class="pc bpc" id="L2123" title="1 of 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc bnc" id="L2124" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2125">				TraceChunk tc = new TraceChunk(queueID, TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;)));</span>
<span class="nc" id="L2126">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2127" title="All 2 branches missed.">				for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2128" title="All 2 branches missed.">					if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2129">						tc.setTraceValue(types[i], rs.getFloat(resultSetCounter++));</span>
					}
				}
<span class="nc" id="L2132">				metaTC.calcComputedTraceValuesForTraceChunk(tc, mediaID);// TODO:</span>
				// add
				// computed
				// Method
				// for
				// Tracechunk
<span class="nc" id="L2138">				tcArray.add(tc);</span>
<span class="nc" id="L2139">			}</span>
		}
<span class="pc bpc" id="L2141" title="3 of 6 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
			// calculate the total trace types excluding the computed ones
<span class="nc" id="L2143">			int typeLen = 0;</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">			for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L2146">					typeLen++;</span>
				}
			}
<span class="nc" id="L2149">			Date prvEndOfDay = null;</span>
<span class="nc bnc" id="L2150" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2151">				DstObject dstObj = new DstObject();</span>
<span class="nc" id="L2152">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L2153">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L2154">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L2155">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L2156">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end); // used in report dump for individual queues and</span>
				//from pulse UI for history get &amp; update
<span class="nc bnc" id="L2158" title="All 2 branches missed.">				if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L2159">					continue;</span>
				}
<span class="nc bnc" id="L2161" title="All 2 branches missed.">				if (dstObj.needNewTraceCube) {</span>
<span class="nc" id="L2162">					tcArray.clear(); // Need to initialize teh arraylist and</span>
					// clear all the values it is holding
				}
<span class="nc" id="L2165">				Date lineStart = dstObj.lineStart;</span>
<span class="nc" id="L2166">				boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
<span class="nc" id="L2167">				boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="nc" id="L2168">				int dstPoints = dstObj.dstPoints; // track points</span>
<span class="nc" id="L2169">				boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to</span>
				// track transition

<span class="nc bnc" id="L2172" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L2173" title="All 2 branches missed.">					if (fallsIn(lineStart, start, end)) {</span>
<span class="nc bnc" id="L2174" title="All 6 branches missed.">						if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
							// if transition will happen on this line
<span class="nc bnc" id="L2176" title="All 2 branches missed.">							if (tz.inDaylightTime(lineStart) != prvDSTFlag) {</span>
								// from this point, there is dst transition
<span class="nc" id="L2178">								int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">								if (tfrIn) {</span>
									// skip points
<span class="nc" id="L2181">									i += dstIntv - 1;</span>
<span class="nc bnc" id="L2182" title="All 2 branches missed.">									prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L2183">									continue;</span>
								}
								// add points
<span class="nc bnc" id="L2186" title="All 2 branches missed.">								for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L2187">									TraceChunk tc = new TraceChunk(queueID, lineStart);</span>
<span class="nc bnc" id="L2188" title="All 2 branches missed.">									for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2189">										tc.setTraceValue(types[t], Trace.TRACENA);</span>
									}
<span class="nc" id="L2191">									tcArray.add(tc);</span>
<span class="nc" id="L2192">									lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">									if (lineStart.after(end)) {</span>
<span class="nc" id="L2194">										break;</span>
									}
								}
							}
						}
<span class="nc" id="L2199">						TraceChunk tc = new TraceChunk(queueID, lineStart);</span>
<span class="nc" id="L2200">						int resultSetCounter = 1; // this is done to omit the</span>
						// computed types
<span class="nc bnc" id="L2202" title="All 2 branches missed.">						for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L2203" title="All 2 branches missed.">							if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L2204">								tc.setTraceValue(types[idx], rs.getFloat(typeLen * i + resultSetCounter++));</span>
							}
						}
<span class="nc" id="L2207">						metaTC.calcComputedTraceValuesForTraceChunk(tc, mediaID);</span>
<span class="nc" id="L2208">						tcArray.add(tc);</span>
<span class="nc bnc" id="L2209" title="All 2 branches missed.">					} else if (lineStart.after(end)) {</span>
<span class="nc" id="L2210">						break;</span>
					}
<span class="nc bnc" id="L2212" title="All 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L2213">						prvDSTFlag = tz.inDaylightTime(lineStart);</span>
					}
<span class="nc" id="L2215">					lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
				// }
				// always save last line's end date
<span class="nc" id="L2219">				prvEndOfDay = lineStart;</span>
<span class="nc" id="L2220">			}</span>
		}
<span class="pc bpc" id="L2222" title="1 of 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc bfc" id="L2223" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L2224">				Date hour = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="fc" id="L2225">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="fc" id="L2226">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>
<span class="fc" id="L2227">				boolean isMaxDialsEnabled = isTypeMaxDialsEnabled(mediaID);</span>
				// hack for ops release. set PCAType to false to always show SL.
				// typeASAEnabled = false;
<span class="fc" id="L2230">				TraceChunk tc = new TraceChunk(queueID, hour);</span>
<span class="pc bpc" id="L2231" title="1 of 2 branches missed.">				if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2232">					tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2233" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2234">						tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					} else {
<span class="nc" id="L2236">						tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
					}
<span class="pc bpc" id="L2238" title="1 of 2 branches missed.">				} else if (!typeASAEnabled) {</span>
<span class="fc" id="L2239">					tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="pc bpc" id="L2240" title="1 of 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2241">						tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					}
				} else {
<span class="nc" id="L2244">					tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}

<span class="fc bfc" id="L2247" title="All 2 branches covered.">				if (isMaxDialsEnabled) {</span>
<span class="fc" id="L2248">					tc.setTraceValue(Trace.MAX_DIALS, rs.getFloat(&quot;MAXDIALS&quot;));</span>
				}

<span class="fc" id="L2251">				tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="fc" id="L2252">				tcArray.add(tc);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report
				// is per 15 mins
<span class="fc bfc" id="L2255" title="All 2 branches covered.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="fc" id="L2256">					TraceChunk tc1 = new TraceChunk(queueID, new Date(hour.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="pc bpc" id="L2257" title="1 of 2 branches missed.">					if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2258">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2260">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						} else {
<span class="nc" id="L2262">							tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
						}
<span class="pc bpc" id="L2264" title="1 of 2 branches missed.">					} else if (!typeASAEnabled) {</span>
<span class="fc" id="L2265">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="pc bpc" id="L2266" title="1 of 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2267">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L2270">						tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
					}
<span class="fc" id="L2272">					tc1.setTraceValue(Trace.ABANDONMENT, tc.getTraceValue(Trace.ABANDONMENT));</span>
<span class="fc bfc" id="L2273" title="All 2 branches covered.">					if (isMaxDialsEnabled) {</span>
<span class="fc" id="L2274">						tc1.setTraceValue(Trace.MAX_DIALS, tc.getTraceValue(Trace.MAX_DIALS));</span>
					}
<span class="fc" id="L2276">					tcArray.add(tc1);</span>
				}
<span class="fc" id="L2278">			}</span>
		}
<span class="fc" id="L2280">	}</span>

	private static Collection convertActual(JdmoRowset rs, TraceCube metaTC, Collection queueIDCol, Date start, Date end,
											boolean isWhatif) throws Exception {
<span class="nc" id="L2284">		HashMap cubeMap = new HashMap(queueIDCol.size());</span>
<span class="nc" id="L2285">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L2286">		Map queueMediaMap = TraceOperatorAdapter.getMediaForQueues(queueIDCol, isWhatif);</span>
<span class="nc bnc" id="L2287" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2288">			Date insertPoint = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
<span class="nc" id="L2289">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L2290">			TraceCube cube = (TraceCube) cubeMap.get(queueID);</span>
<span class="nc bnc" id="L2291" title="All 2 branches missed.">			if (cube == null) {</span>
<span class="nc" id="L2292">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L2294">			double[] value = new double[types.length];</span>
<span class="nc" id="L2295">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2296" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2297" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2298">					value[i] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L2301">			cube.setTraceValue(types, value, insertPoint);</span>
<span class="nc" id="L2302">			cubeMap.put(queueID, cube);</span>
<span class="nc" id="L2303">		}</span>
<span class="nc bnc" id="L2304" title="All 2 branches missed.">		for (Iterator iterator = cubeMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2305">			TraceCube cube = (TraceCube) iterator.next();</span>
<span class="nc" id="L2306">			cube.calcComputedTraceValues((ID) queueMediaMap.get(cube.getQueueID()));</span>
<span class="nc" id="L2307">		}</span>

<span class="nc" id="L2309">		return cubeMap.values();</span>
	}

	/**
	 * Convert a rowset into a TraceCube of type metaTC.
	 * this method is used in pulse to see the different trace types
	 * @param rs
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param isWhatif
	 * @param spqueuesBySID
	 * @param isNoPhantom
	 * @return
	 * @throws Exception
	 */
	private static TraceCube convert(JdmoRowset rs, TraceCube metaTC, ID queueID, Date start, Date end,
									 boolean includeAllServiceGoalTypes, boolean isWhatif, Map&lt;ID, SPQueue&gt; spqueuesBySID, Map&lt;ID, Queue&gt; idQueueMap,
									 boolean isNoPhantom) throws Exception {

<span class="fc" id="L2331">		TraceCube cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="fc" id="L2332">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L2333">		ID mediaID= null;</span>
<span class="pc bpc" id="L2334" title="1 of 4 branches missed.">		if (idQueueMap != null &amp;&amp; idQueueMap.get(cube.getQueueID()) != null) {</span>
<span class="fc" id="L2335">			mediaID = idQueueMap.get(cube.getQueueID()).getMediaID();</span>
		} else {
<span class="fc" id="L2337">			mediaID = TraceOperatorAdapter.getMediaIDForQueue(cube.getQueueID(), isWhatif); //inside ejb call to get queue object</span>
		}
<span class="pc bpc" id="L2339" title="1 of 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L2340">			convertActualTC(rs, metaTC, cube, types);</span>
		}
<span class="fc bfc" id="L2342" title="All 6 branches covered.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L2343">			cube = convertForecastPredictRequiredTC(rs, metaTC, queueID, start,</span>
					end, spqueuesBySID, cube, types, isNoPhantom);
		}
<span class="fc bfc" id="L2346" title="All 2 branches covered.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L2347">			convertSGTC(rs, queueID, end, includeAllServiceGoalTypes, cube,</span>
					types, mediaID);
		}
<span class="fc" id="L2350">		cube.calcComputedTraceValues(mediaID);</span>
<span class="fc bfc" id="L2351" title="All 2 branches covered.">		for (short type : cube.getTraceTypes()) {</span>
<span class="fc" id="L2352">			cube.setTypeDirty(type, false);</span>
		}
<span class="fc" id="L2354">		return cube;</span>
	}

	/**
	 * @param rs
	 * @param queueID
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param cube
	 * @param types
	 * @param mediaID
	 * @throws JdmoException
	 */
	private static void convertSGTC(JdmoRowset rs, ID queueID, Date end,
									boolean includeAllServiceGoalTypes, TraceCube cube, short[] types,
									ID mediaID) throws JdmoException {
		// TODO: this needs to be fixed for DST issues. Sameet, March 2006
		// SKILL Queue, Reqd SVC Level not blank for OCT
<span class="fc" id="L2372">		Date prvEndOfDay = null;</span>
<span class="fc bfc" id="L2373" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L2374">			Date hour = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="fc" id="L2375">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(&quot;SERVICELEVELGOALTYPE&quot;));</span>
<span class="fc" id="L2376">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(&quot;SERVICELEVELGOALTYPE&quot;));</span>
<span class="fc" id="L2377">			boolean isMaxDialsEnabled = isTypeMaxDialsEnabled(mediaID);</span>
			// hack for ops release. set PCAType to false to always show SL.
			// typeASAEnabled = false;
<span class="fc" id="L2380">			ArrayList tcList = new ArrayList(4);</span>
<span class="fc" id="L2381">			TraceChunk tc = new TraceChunk(queueID, hour);</span>
<span class="pc bpc" id="L2382" title="1 of 2 branches missed.">			if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2383">				tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2384" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2385">					tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L2387">					tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="pc bpc" id="L2389" title="1 of 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="fc" id="L2390">				tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="pc bpc" id="L2391" title="1 of 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2392">					tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				}
			} else {
<span class="nc" id="L2395">				tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
			}
<span class="fc" id="L2397">			tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="pc bpc" id="L2398" title="1 of 2 branches missed.">			if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2399">				tc.setTraceValue(Trace.MAX_DIALS, rs.getFloat(&quot;MAXDIALS&quot;));</span>
			}
<span class="fc" id="L2401">			tcList.add(tc);</span>
			// Add 3 identical TCs, as DE service goal is per hour, report
			// is per 15 mins
<span class="fc bfc" id="L2404" title="All 2 branches covered.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="fc" id="L2405">				Date exStart = new Date(hour.getTime() + i * Trace.INTERVAL_IN_MILLIS);</span>
<span class="fc" id="L2406">				TraceChunk tc1 = new TraceChunk(queueID, exStart);</span>
<span class="pc bpc" id="L2407" title="1 of 2 branches missed.">				if (exStart.before(end)) {</span>
<span class="pc bpc" id="L2408" title="1 of 2 branches missed.">					if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2409">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2411">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						} else {
<span class="nc" id="L2413">							tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
						}
<span class="pc bpc" id="L2415" title="1 of 2 branches missed.">					} else if (!typeASAEnabled) {</span>
<span class="fc" id="L2416">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="pc bpc" id="L2417" title="1 of 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2418">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L2421">						tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
					}
<span class="fc" id="L2423">					tc1.setTraceValue(Trace.ABANDONMENT, tc.getTraceValue(Trace.ABANDONMENT));</span>
<span class="pc bpc" id="L2424" title="1 of 2 branches missed.">					if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2425">						tc1.setTraceValue(Trace.MAX_DIALS, tc.getTraceValue(Trace.MAX_DIALS));</span>
					}
<span class="fc" id="L2427">					tcList.add(tc1);</span>
				} else {
					break;
				}
			}
			// now add Chunk back to Cube
<span class="fc bfc" id="L2433" title="All 2 branches covered.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="fc" id="L2434">				int[] value = new int[tcList.size()];</span>
<span class="fc" id="L2435">				int i = 0;</span>
<span class="fc bfc" id="L2436" title="All 2 branches covered.">				for (Iterator it = tcList.iterator(); it.hasNext();) {</span>
<span class="fc" id="L2437">					TraceChunk tc1 = (TraceChunk) it.next();</span>
<span class="fc" id="L2438">					value[i++] = TraceUtil.roundDouble(tc1.getTraceValue(types[t]));</span>
<span class="fc" id="L2439">				}</span>
<span class="fc" id="L2440">				((ServiceGoalTraceCube) cube).initTraceValue(types[t], value, hour);</span>
			}
<span class="fc" id="L2442">		}</span>
<span class="fc" id="L2443">	}</span>

	/**
	 * This method is package private for unit testing
	 *
	 * @param rs
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param cube
	 * @param types
	 * @return
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	static TraceCube convertForecastPredictRequiredTC(JdmoRowset rs,
													  TraceCube metaTC, ID queueID, Date start, Date end,
													  Map&lt;ID, SPQueue&gt; spqueuesBySID, TraceCube cube, short[] types,
													  boolean isNoPhantom) throws JdmoException, BbmTimeSeriesException {

<span class="fc" id="L2465">		Date prvEndOfDay = null;</span>
		// calculate the total trace types excluding the computed ones
<span class="fc" id="L2467">		int typeLen = 0;</span>
<span class="fc bfc" id="L2468" title="All 2 branches covered.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="fc bfc" id="L2469" title="All 2 branches covered.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="fc" id="L2470">				typeLen++;</span>
			}
		}
<span class="fc bfc" id="L2473" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L2474">			DstObject dstObj = new DstObject();</span>
<span class="fc" id="L2475">			dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(getDETimeColumn(metaTC, false, isNoPhantom))); //&quot;DATETIME&quot;));</span>
<span class="fc" id="L2476">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="fc" id="L2477">			dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="fc" id="L2478">			dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="fc" id="L2479">			dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="fc bfc" id="L2480" title="All 2 branches covered.">			if (dstObj.shouldSkip(start, end)) {</span>
<span class="fc" id="L2481">				continue;</span>
			}


<span class="fc bfc" id="L2485" title="All 2 branches covered.">			if (dstObj.needNewTraceCube) {</span>
<span class="fc" id="L2486">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="fc" id="L2488">			cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="fc" id="L2489">			ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="fc" id="L2490">			cube.setSPQueueSID(spQueueSID);</span>
<span class="fc" id="L2491">			SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="fc bfc" id="L2492" title="All 2 branches covered.">			if (spq != null) {</span>
<span class="fc" id="L2493">				cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="fc" id="L2494">				cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="fc" id="L2495">				cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
			}
<span class="fc" id="L2497">			Date currentIntervalStart = dstObj.lineStart;</span>
<span class="fc" id="L2498">			Date cubeInsertPoint = new Date(dstObj.lineStart.getTime());</span>
<span class="fc" id="L2499">			boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
<span class="fc" id="L2500">			boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="fc" id="L2501">			int dstPoints = dstObj.dstPoints; // track points</span>
<span class="fc" id="L2502">			boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to</span>
			// track transition
<span class="fc" id="L2504">			boolean init = false;</span>
<span class="fc" id="L2505">			double[][] values = new double[types.length][];</span>
<span class="fc" id="L2506">			int arrIdx = 0;</span>
<span class="fc" id="L2507">			int arrSz = 0;</span>
<span class="fc bfc" id="L2508" title="All 2 branches covered.">			for (int rsIdx = 0; rsIdx &lt; Trace.DAYPOINTS; rsIdx++) {</span>
<span class="pc bpc" id="L2509" title="1 of 2 branches missed.">				if (fallsIn(currentIntervalStart, start, end)) {</span>

<span class="fc bfc" id="L2511" title="All 2 branches covered.">					if (!init) {</span>
<span class="fc" id="L2512">						cubeInsertPoint = currentIntervalStart;</span>
<span class="fc" id="L2513">						arrSz = Trace.DAYPOINTS;</span>
<span class="pc bpc" id="L2514" title="1 of 2 branches missed.">						if (tfrOut) {</span>
<span class="nc" id="L2515">							arrSz = arrSz + dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="fc bfc" id="L2517" title="All 2 branches covered.">						if (tfrIn) {</span>
<span class="fc" id="L2518">							arrSz = arrSz - dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="fc bfc" id="L2520" title="All 2 branches covered.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="fc" id="L2521">							values[t] = new double[arrSz];</span>
						}
<span class="fc" id="L2523">						init = true;</span>
					}

<span class="pc bpc" id="L2526" title="2 of 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="fc bfc" id="L2528" title="All 2 branches covered.">						if (tz.inDaylightTime(currentIntervalStart) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="fc" id="L2530">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="pc bpc" id="L2531" title="1 of 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="fc" id="L2533">								rsIdx += dstIntv - 1;</span>
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>

<span class="pc bpc" id="L2536" title="1 of 2 branches missed.">								if (dstObj.isLineStartInPartialTransition) {</span>
									//Adjust currentIntervalStart accordingly so we don't exit the loop prematurely
<span class="nc" id="L2538">									currentIntervalStart = new Date(currentIntervalStart.getTime()</span>
											- ((Trace.HOURPOINTS - dstIntv) * Trace.INTERVAL_IN_MILLIS));
								}
								continue;
							}
							// add points
<span class="nc bnc" id="L2544" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L2545" title="All 2 branches missed.">								for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2546">									values[t][arrIdx] = Trace.TRACENA;</span>
								}
<span class="nc" id="L2548">								arrIdx++;</span>
<span class="nc" id="L2549">								currentIntervalStart = new Date(currentIntervalStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L2550" title="All 2 branches missed.">								if (currentIntervalStart.after(end)) {</span>
<span class="nc" id="L2551">									break;</span>
								}
							}
						}
					}
<span class="pc bpc" id="L2556" title="1 of 2 branches missed.">					if (!init) {</span>
<span class="nc" id="L2557">						cubeInsertPoint = currentIntervalStart;</span>
<span class="nc" id="L2558">						arrSz = Trace.DAYPOINTS - rsIdx;</span>
<span class="nc bnc" id="L2559" title="All 2 branches missed.">						if (tfrOut) {</span>
<span class="nc" id="L2560">							arrSz = arrSz + dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2562" title="All 2 branches missed.">						if (tfrIn) {</span>
<span class="nc" id="L2563">							arrSz = arrSz - dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2565" title="All 2 branches missed.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2566">							values[t] = new double[arrSz];</span>
						}
<span class="nc" id="L2568">						init = true;</span>
					}
<span class="fc" id="L2570">					int resultSetCounter = 1; // this is done to omit the</span>
					// computed types
<span class="fc bfc" id="L2572" title="All 2 branches covered.">					for (int t = 0; t &lt; types.length; t++) {</span>
<span class="fc bfc" id="L2573" title="All 2 branches covered.">						if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="fc" id="L2574">							values[t][arrIdx] = rs.getFloat(typeLen * rsIdx + resultSetCounter++);</span>
						}
					}
<span class="fc" id="L2577">					arrIdx++;</span>
				}
<span class="pc bpc" id="L2579" title="1 of 2 branches missed.">				if (currentIntervalStart.after(end)) {</span>
<span class="nc" id="L2580">					break;</span>
				}
<span class="pc bpc" id="L2582" title="1 of 4 branches missed.">				if (tfrIn || tfrOut) {</span>
<span class="fc" id="L2583">					prvDSTFlag = tz.inDaylightTime(currentIntervalStart);</span>
				}
<span class="fc" id="L2585">				currentIntervalStart = new Date(currentIntervalStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}

			// check if need shrink
<span class="pc bpc" id="L2589" title="1 of 2 branches missed.">			if (arrIdx &lt; arrSz) {</span>
<span class="nc bnc" id="L2590" title="All 2 branches missed.">				for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2591">					double[] value = new double[arrIdx];</span>
<span class="nc" id="L2592">					System.arraycopy(values[t], 0, value, 0, arrIdx);</span>
<span class="nc" id="L2593">					values[t] = value;</span>
				}
			}

<span class="fc bfc" id="L2597" title="All 2 branches covered.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="fc" id="L2598">				cube.setTraceValue(types[t], values[t], getInsertionDate(prvEndOfDay, cubeInsertPoint, dstObj));</span>
			}

			// save last line's end day
<span class="fc" id="L2602">			prvEndOfDay = currentIntervalStart;</span>
<span class="fc" id="L2603">		}</span>
<span class="fc" id="L2604">		return cube;</span>
	}

	private static Date getInsertionDate(Date prvEndOfDay, Date cubeInsertPoint, DstObject dstObj) {
<span class="fc" id="L2608">		Date resultDate = cubeInsertPoint;</span>
<span class="pc bpc" id="L2609" title="3 of 6 branches missed.">		if (prvEndOfDay != null &amp;&amp; prvEndOfDay.before(cubeInsertPoint) &amp;&amp; dstObj.isLineStartInPartialTransition) {</span>
<span class="nc" id="L2610">			resultDate = prvEndOfDay;</span>
		}
<span class="fc" id="L2612">		return resultDate;</span>
	}

	/**
	 * @param rs
	 * @param metaTC
	 * @param cube
	 * @param types
	 * @throws JdmoException
	 */
	private static void convertActualTC(JdmoRowset rs, TraceCube metaTC,
										TraceCube cube, short[] types) throws JdmoException {
<span class="nc bnc" id="L2624" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2625">			Date insertPoint = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
<span class="nc" id="L2626">			double[] value = new double[types.length];</span>
<span class="nc" id="L2627">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2630">					value[i] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L2633">			cube.setTraceValue(types, value, insertPoint);</span>
<span class="nc" id="L2634">		}</span>
<span class="nc" id="L2635">	}</span>

	private static boolean queueFallsIn(ID queueID, Date time, Map spQMap, Map spTimeRangeMap) {
<span class="fc bfc" id="L2638" title="All 2 branches covered.">		for (Iterator it = spTimeRangeMap.keySet().iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L2639">			ID spID = (ID) it.next();</span>
<span class="fc" id="L2640">			Date[] range = (Date[]) spTimeRangeMap.get(spID);</span>
<span class="pc bpc" id="L2641" title="1 of 2 branches missed.">			if (fallsIn(time, range[0], range[1])) {</span>
<span class="fc" id="L2642">				Collection queueIDCol = (Collection) spQMap.get(spID);</span>
<span class="fc bfc" id="L2643" title="All 2 branches covered.">				if (queueIDCol.contains(queueID)) {</span>
<span class="fc" id="L2644">					return true;</span>
				}
			}
<span class="fc" id="L2647">		}</span>
<span class="fc" id="L2648">		return false;</span>
	}

	protected static boolean fallsIn(Date point, Date start, Date end) {
<span class="pc bpc" id="L2652" title="1 of 2 branches missed.">		if (start == null) {</span>
<span class="nc bnc" id="L2653" title="All 2 branches missed.">			if (end != null) {</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">				return !point.after(end);</span>
			}
		} else {
<span class="fc bfc" id="L2657" title="All 2 branches covered.">			if (!point.before(start)) {</span>
<span class="pc bpc" id="L2658" title="1 of 2 branches missed.">				if (end != null) {</span>
<span class="fc bfc" id="L2659" title="All 2 branches covered.">					return !point.after(end);</span>
				}
			} else {
<span class="fc" id="L2662">				return false;</span>
			}
		}
<span class="nc" id="L2665">		return true;</span>
	}

	private static boolean existingRow(ID queueID, Date start, Jdmo jdmo) throws JdmoException {
<span class="nc bnc" id="L2669" title="All 4 branches missed.">		if (m_ignoreFutureData &amp;&amp; start.after(new Date())) {</span>
<span class="nc" id="L2670">			return false;</span>
		}
<span class="nc" id="L2672">		StringBuffer pStmt = new StringBuffer(&quot;select QUEUEID from &quot;);</span>
<span class="nc" id="L2673">		pStmt.append(ActualTraceTableName).append(&quot; where TIME=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L2674">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2675">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2676">		jQuery.setParID(2, queueID);</span>
<span class="nc" id="L2677">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2678">		boolean exists = false;</span>
<span class="nc bnc" id="L2679" title="All 2 branches missed.">		if (rs.next()) {</span>
<span class="nc" id="L2680">			exists = true;</span>
		}
<span class="nc" id="L2682">		rs.close();</span>
<span class="nc" id="L2683">		return exists;</span>
	}

	/**
	 * Note that Timestamp extends Date but cannot be compared to an instance of
	 * Date. Code that needs to compare the returned Timestamps to Dates should
	 * first convert them to Date objects.
	 *
	 * @param queueID
	 * @param start
	 * @param end
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 * @see java.sql.Timestamp
	 */
	static Set&lt;Timestamp&gt; existingRow(ID queueID, Date start, Date end, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2700">		StringBuffer pStmt = new StringBuffer(&quot;select TIME from &quot;);</span>
<span class="nc" id="L2701">		pStmt.append(ActualTraceTableName).append(</span>
				&quot; where TIME&gt;=? and TIME&lt;=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);
<span class="nc" id="L2703">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
		// Date end1 = adjustActualEndDateForDemo(end, new ActualTraceCube());
		// // only called to determine whether or not to update
<span class="nc" id="L2706">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2707">		jQuery.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L2708">		jQuery.setParID(3, queueID);</span>
<span class="nc" id="L2709">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2710">		Set&lt;Timestamp&gt; timeSet = new HashSet();</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2712">			timeSet.add(rs.getTimestamp(1));</span>
		}
<span class="nc" id="L2714">		rs.close();</span>
<span class="nc" id="L2715">		return timeSet;</span>
	}

	private static Set&lt;ID&gt; existingRows(Collection queueIDCol, Date start, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2719">		HashSet&lt;ID&gt; queIDSet = new HashSet(queueIDCol.size());</span>
<span class="nc bnc" id="L2720" title="All 4 branches missed.">		if (m_ignoreFutureData &amp;&amp; start.after(new Date())) {</span>
<span class="nc" id="L2721">			return queIDSet;</span>
		}
<span class="nc" id="L2723">		StringBuffer pStmt = new StringBuffer(&quot;select B.SID from &quot;);</span>
<span class="nc" id="L2724">		pStmt.append(ActualTraceTableName).append(&quot; A, QUEUE B where A.TIME=? and A.QUEUEID=B.ID and B.SID in &quot;);</span>
<span class="nc" id="L2725">		pStmt.append(jdmo.createInClause(queueIDCol));</span>
<span class="nc" id="L2726">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2727">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2728">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc bnc" id="L2730" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2731">			queIDSet.add(rs.getID(1));</span>
		}
<span class="nc" id="L2733">		return queIDSet;</span>
	}

	private static Set&lt;Date&gt; existingActualRows(ID queueID, Date start, Date end, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2737">		StringBuffer pStmt = new StringBuffer(&quot;select TIME from &quot;);</span>
<span class="nc" id="L2738">		pStmt.append(ActualTraceTableName).append(</span>
				&quot; where TIME&gt;=? and TIME&lt;=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);
<span class="nc" id="L2740">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2741">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(TraceUtil.snapDate(start)));</span>
<span class="nc" id="L2742">		jQuery.setParTimestamp(2, TimeZoneUtil.toTimestamp(TraceUtil.snapDate(end)));</span>
<span class="nc" id="L2743">		jQuery.setParID(3, queueID);</span>
<span class="nc" id="L2744">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2745">		Set&lt;Date&gt; timeSet = new HashSet();</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2747">			timeSet.add(TimeZoneUtil.toDate(rs.getTimestamp(1)));</span>
		}
<span class="nc" id="L2749">		return timeSet;</span>
	}

	/**
	 * For a particular StartDate, need update the existing Trace
	 *
	 * @param TraceChunk
	 * @param Jdmo
	 */
	static void updateChunkForActual(TraceChunk chunk, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2759">		StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L2760">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc" id="L2761">		iStmt.append(&quot;update &quot;).append(getTraceTable(cube)).append(&quot; set &quot;);</span>
<span class="nc" id="L2762">		short[] types = chunk.getTraceTypes();</span>
		// add parameters for Start
<span class="nc bnc" id="L2764" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2765" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2766">				iStmt.append(getDETraceColumn(types[i])).append(&quot;=&quot;).append(chunk.getTraceValue(types[i])).append(&quot;, &quot;);</span>
			}
		}
<span class="nc" id="L2769">		iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;' where TIME='&quot;);</span>
<span class="nc" id="L2770">		iStmt.append(JdmoUtil.formatDBString(chunk.getStartDate()));</span>
<span class="nc" id="L2771">		iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(chunk.getQueueID()).append(&quot;)&quot;);</span>
<span class="nc" id="L2772">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L2773">	} // updateChunkForActual</span>

	/**
	 * For a particular StartDate, need create the new Trace
	 *
	 * @param TraceChunk
	 * @param Jdmo
	 */
	static void createChunkForActual(TraceChunk chunk, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2782">		StringBuffer iStmt = new StringBuffer(500);</span>
<span class="nc" id="L2783">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc" id="L2784">		iStmt.append(&quot;insert into &quot;).append(getTraceTable(cube));</span>
<span class="nc" id="L2785">		iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L2786">		StringBuffer vStmt = new StringBuffer(200);</span>
<span class="nc" id="L2787">		vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L2788">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(chunk.getStartDate())).append(&quot;',&quot;);</span>
<span class="nc" id="L2789">		short[] types = chunk.getTraceTypes();</span>
<span class="nc bnc" id="L2790" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2791" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2792">				iStmt.append(getDETraceColumn(types[i])).append(&quot;, &quot;);</span>
<span class="nc" id="L2793">				vStmt.append(chunk.getTraceValue(types[i])).append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L2796">		iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L2797">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L2798">		vStmt.append(&quot;' from QUEUE where SID=&quot;).append(chunk.getQueueID());</span>
<span class="nc" id="L2799">		iStmt.append(vStmt);</span>
<span class="nc" id="L2800">		jdmo.addBatch(iStmt.toString());</span>

<span class="nc" id="L2802">	} // creatChunk</span>

	/**
	 * Internal routine to return TraceColumn names
	 */
	private static StringBuffer getDETraceColumn(short type) {
<span class="fc" id="L2808">		StringBuffer column = new StringBuffer(14);</span>
<span class="pc bpc" id="L2809" title="5 of 20 branches missed.">		switch (type) {</span>
			case Trace.CV:
<span class="fc" id="L2811">				column.append(&quot;CALLVOLUME&quot;);</span>
<span class="fc" id="L2812">				break;</span>
			case Trace.AHT:
<span class="fc" id="L2814">				column.append(&quot;AHT&quot;);</span>
<span class="fc" id="L2815">				break;</span>
			case Trace.PCA:
<span class="fc" id="L2817">				column.append(&quot;SERVICELEVEL&quot;);</span>
<span class="fc" id="L2818">				break;</span>
			case Trace.ASA:
<span class="fc" id="L2820">				column.append(&quot;ASA&quot;);</span>
<span class="fc" id="L2821">				break;</span>
			case Trace.ABANDONMENT:
<span class="fc" id="L2823">				column.append(&quot;ABANDONS&quot;);</span>
<span class="fc" id="L2824">				break;</span>
			case Trace.BACKLOG:
<span class="fc" id="L2826">				column.append(&quot;BACKLOG&quot;);</span>
<span class="fc" id="L2827">				break;</span>
			case Trace.STAFFING:
<span class="fc" id="L2829">				column.append(&quot;STAFFING&quot;);</span>
<span class="fc" id="L2830">				break;</span>
			case Trace.OCCUPANCY:
<span class="fc" id="L2832">				column.append(&quot;OCCUPANCY&quot;);</span>
<span class="fc" id="L2833">				break;</span>
			case Trace.FTE:
<span class="fc" id="L2835">				column.append(&quot;FTE&quot;);</span>
<span class="fc" id="L2836">				break;</span>
			case Trace.DIALS:
<span class="fc" id="L2838">				column.append(&quot;DIALS&quot;);</span>
<span class="fc" id="L2839">				break;</span>
			case Trace.CONNECTS:
<span class="nc" id="L2841">				column.append(&quot;CONNECTS&quot;);</span>
<span class="nc" id="L2842">				break;</span>
			case Trace.CRATE:
<span class="fc" id="L2844">				column.append(&quot;CRATE&quot;);</span>
<span class="fc" id="L2845">				break;</span>
			case Trace.RPC:
<span class="nc" id="L2847">				column.append(&quot;RPC&quot;);</span>
<span class="nc" id="L2848">				break;</span>
			case Trace.RPCRATE:
<span class="fc" id="L2850">				column.append(&quot;RPCRATE&quot;);</span>
<span class="fc" id="L2851">				break;</span>
			case Trace.RPCAHT:
<span class="fc" id="L2853">				column.append(&quot;RPCAHT&quot;);</span>
<span class="fc" id="L2854">				break;</span>
			case Trace.VH:
<span class="nc" id="L2856">				column.append(&quot;VH&quot;);</span>
<span class="nc" id="L2857">				break;</span>
			case Trace.DEADLINE_TIME:
<span class="nc" id="L2859">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2860">				break;</span>
			case Trace.ASTAFFING:
<span class="fc" id="L2862">				column.append(&quot;ASTAFF&quot;);</span>
<span class="fc" id="L2863">				break;</span>
			case Trace.AFTE:
<span class="fc" id="L2865">				column.append(&quot;AFTE&quot;);</span>
<span class="fc" id="L2866">				break;</span>
			default:
<span class="nc" id="L2868">				return null;</span>
		}
<span class="fc" id="L2870">		return column;</span>
	}

	private static StringBuffer getDESelectTraceColumn(Jdmo jdmo, short type, TraceCube metaTC) throws JdmoException {
<span class="nc" id="L2874">		StringBuffer column = new StringBuffer(25);</span>
<span class="nc" id="L2875">		column.append(jdmo.getNullFunctionName()).append(&quot;(&quot;);</span>
<span class="nc" id="L2876">		StringBuffer sbTraceCol = getDETraceColumn(type);</span>
<span class="nc bnc" id="L2877" title="All 2 branches missed.">		if (sbTraceCol == null) {</span>
<span class="nc" id="L2878">			return null;</span>
		}
<span class="nc" id="L2880">		column.append(sbTraceCol);</span>
<span class="nc" id="L2881">		column.append(&quot;,&quot;).append(Trace.TRACENA).append(&quot;)&quot;);</span>
<span class="nc" id="L2882">		return column;</span>
	} // getTraceColumn

	/**
	 * Internal routine to return TraceColumn names that are used for the
	 * reportdump table and utility. this has nothing to do directly with PULSE
	 * tables
	 */
	private static StringBuffer getTraceColumn(short type) {
<span class="fc" id="L2891">		StringBuffer column = new StringBuffer(14);</span>
<span class="pc bpc" id="L2892" title="21 of 22 branches missed.">		switch (type) {</span>
			case Trace.CV:
<span class="nc" id="L2894">				column.append(&quot;CV&quot;);</span>
<span class="nc" id="L2895">				break;</span>
			case Trace.AHT:
<span class="nc" id="L2897">				column.append(&quot;AHT&quot;);</span>
<span class="nc" id="L2898">				break;</span>
			case Trace.PCA:
<span class="nc" id="L2900">				column.append(&quot;PCA&quot;);</span>
<span class="nc" id="L2901">				break;</span>
			case Trace.ASA:
<span class="nc" id="L2903">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2904">				break;</span>
			case Trace.ABANDONMENT:
<span class="nc" id="L2906">				column.append(&quot;ABANDONMENT&quot;);</span>
<span class="nc" id="L2907">				break;</span>
			case Trace.BACKLOG:
<span class="nc" id="L2909">				column.append(&quot;BACKLOG&quot;);</span>
<span class="nc" id="L2910">				break;</span>
			case Trace.STAFFING:
<span class="fc" id="L2912">				column.append(&quot;STAFFING&quot;);</span>
<span class="fc" id="L2913">				break;</span>
			case Trace.OCCUPANCY:
<span class="nc" id="L2915">				column.append(&quot;OCCUPANCY&quot;);</span>
<span class="nc" id="L2916">				break;</span>
			case Trace.FTE:
<span class="nc" id="L2918">				column.append(&quot;FTE&quot;);</span>
<span class="nc" id="L2919">				break;</span>
			case Trace.DIALS:
<span class="nc" id="L2921">				column.append(&quot;DIALS&quot;);</span>
<span class="nc" id="L2922">				break;</span>
			case Trace.CONNECTS:
<span class="nc" id="L2924">				column.append(&quot;CONNECTS&quot;);</span>
<span class="nc" id="L2925">				break;</span>
			case Trace.CRATE:
<span class="nc" id="L2927">				column.append(&quot;CRATE&quot;);</span>
<span class="nc" id="L2928">				break;</span>
			case Trace.RPC:
<span class="nc" id="L2930">				column.append(&quot;RPC&quot;);</span>
<span class="nc" id="L2931">				break;</span>
			case Trace.RPCRATE:
<span class="nc" id="L2933">				column.append(&quot;RPCRATE&quot;);</span>
<span class="nc" id="L2934">				break;</span>
			case Trace.RPCAHT:
<span class="nc" id="L2936">				column.append(&quot;RPCAHT&quot;);</span>
<span class="nc" id="L2937">				break;</span>
			case Trace.VH:
<span class="nc" id="L2939">				column.append(&quot;VH&quot;);</span>
<span class="nc" id="L2940">				break;</span>
			case Trace.VAR:
<span class="nc" id="L2942">				column.append(&quot;VAR&quot;);</span>
<span class="nc" id="L2943">				break;</span>
			case Trace.CV_VH:
<span class="nc" id="L2945">				column.append(&quot;CV_VH&quot;);</span>
<span class="nc" id="L2946">				break;</span>
			case Trace.DEADLINE_TIME:
<span class="nc" id="L2948">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2949">				break;</span>
			case Trace.ASTAFFING:
<span class="nc" id="L2951">				column.append(&quot;ASTAFF&quot;);</span>
<span class="nc" id="L2952">				break;</span>
			case Trace.AFTE:
<span class="nc" id="L2954">				column.append(&quot;AFTE&quot;);</span>
<span class="nc" id="L2955">				break;</span>
			default:
<span class="nc" id="L2957">				return null;</span>
		}
<span class="fc" id="L2959">		return column;</span>
	} // getTraceColumn

	private static String getDETimeColumn(TraceCube tc, boolean needPrefix, boolean isNoPhantom) {
<span class="fc bfc" id="L2963" title="All 2 branches covered.">		if (isNoPhantom) {</span>
<span class="fc bfc" id="L2964" title="All 2 branches covered.">			if (needPrefix) {</span>
<span class="fc" id="L2965">				return &quot;A.TIMESERIESDATE&quot;;</span>
			}
<span class="fc" id="L2967">			return &quot;TIMESERIESDATE&quot;;</span>
<span class="pc bpc" id="L2968" title="1 of 8 branches missed.">		} else if (tc instanceof ForecastTraceCube || tc instanceof PredictTraceCube || tc instanceof RequireTraceCube</span>
				|| tc instanceof ServiceGoalTraceCube) {
<span class="fc bfc" id="L2970" title="All 2 branches covered.">			if (needPrefix) {</span>
<span class="fc" id="L2971">				return &quot;A.DATETIME&quot;;</span>
			}
<span class="fc" id="L2973">			return &quot;DATETIME&quot;;</span>
		}
<span class="nc" id="L2975">		return &quot;TIME&quot;;</span>
	}

	private static String getTraceTable(TraceCube tc) {
<span class="fc" id="L2979">		return getTraceTable(tc, false);</span>
	}

	private static String getTraceTable(TraceCube tc, boolean isNoPhantom) {
<span class="pc bpc" id="L2983" title="1 of 4 branches missed.">		if (isNoPhantom &amp;&amp; tc instanceof PredictTraceCube) {</span>
<span class="fc" id="L2984">			return PredictNoPhantomTraceTableName;</span>
		}
<span class="fc bfc" id="L2986" title="All 2 branches covered.">		if (tc instanceof ForecastTraceCube) {</span>
<span class="fc" id="L2987">			return ForecastTraceTableName;</span>
		}
<span class="fc bfc" id="L2989" title="All 2 branches covered.">		if (tc instanceof PredictTraceCube) {</span>
<span class="fc" id="L2990">			return PredictTraceTableName;</span>
		}
<span class="fc bfc" id="L2992" title="All 2 branches covered.">		if (tc instanceof RequireTraceCube) {</span>
<span class="fc" id="L2993">			return RequireTraceTableName;</span>
		}
<span class="pc bpc" id="L2995" title="1 of 2 branches missed.">		if (tc instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L2996">			return ServiceGoalTraceTableName;</span>
		}
<span class="nc bnc" id="L2998" title="All 2 branches missed.">		if (tc instanceof ActualTraceCube) {</span>
<span class="nc" id="L2999">			return ActualTraceTableName;</span>
		}
<span class="nc" id="L3001">		return null;</span>
	}

	// combine new line to existing trace chunk
	private static TraceChunk combineRpt(short[] types, Date time, List&lt;float[]&gt; lines) {
<span class="nc" id="L3006">		TraceChunk chunk = new TraceChunk(null, time);</span>
		try {
<span class="nc bnc" id="L3008" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L3009">				short type = types[i];</span>
<span class="nc" id="L3010">				chunk.setTraceValue(type, 0);</span>
<span class="nc bnc" id="L3011" title="All 8 branches missed.">				switch (type) {</span>
					// CV/Backlog is Sum(type)
					case Trace.CV:
					case Trace.BACKLOG:
					case Trace.ABANDONMENT:
					case Trace.FTE:
					case Trace.AFTE:
					case Trace.DIALS:
					case Trace.RPC:
					case Trace.CONNECTS:
					case Trace.VAR:
					case Trace.CV_VH:
<span class="nc" id="L3023">						float value = 0;</span>
<span class="nc bnc" id="L3024" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">							if (newLine[type] &gt; 0) {</span>
<span class="nc" id="L3026">								value += newLine[type];</span>
							}
<span class="nc" id="L3028">						}</span>
<span class="nc" id="L3029">						chunk.setTraceValue(type, value);</span>
<span class="nc" id="L3030">						break;</span>
					case Trace.VH:
<span class="nc" id="L3032">						float valueVH = 0;</span>
<span class="nc bnc" id="L3033" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc bnc" id="L3034" title="All 2 branches missed.">							if (newLine[type] &gt;= 0) {</span>
<span class="nc" id="L3035">								valueVH += newLine[type];</span>
							} else {
<span class="nc" id="L3037">								valueVH = Trace.TRACENA; // abondon the combine</span>
								// since one queue is
								// empty and we need all
								// valid
<span class="nc" id="L3041">								break;</span>
							}
<span class="nc" id="L3043">						}</span>
<span class="nc" id="L3044">						chunk.setTraceValue(type, valueVH);</span>
<span class="nc" id="L3045">						break;</span>
					// AHT/PCA is Sum(CV*type)/Sum(CV)

					case Trace.AHT:
					case Trace.PCA:
					case Trace.DEADLINE_TIME: {
<span class="nc" id="L3051">						float aggVAR = 0;</span>
<span class="nc" id="L3052">						float aggVal = 0;</span>
<span class="nc" id="L3053">						short type_VAR_CVVH = 0;</span>
<span class="nc bnc" id="L3054" title="All 4 branches missed.">						if (type == Trace.PCA || type == Trace.DEADLINE_TIME) {</span>
<span class="nc" id="L3055">							type_VAR_CVVH = Trace.VAR;</span>
<span class="nc bnc" id="L3056" title="All 2 branches missed.">						} else if (type == Trace.AHT) {</span>
<span class="nc bnc" id="L3057" title="All 2 branches missed.">							type_VAR_CVVH = Trace.isVolumeHandledEnabled() ? Trace.VH : Trace.CV;</span>
						}
<span class="nc bnc" id="L3059" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L3060">							float val = newLine[type];</span>
<span class="nc" id="L3061">							float var = newLine[type_VAR_CVVH];</span>
<span class="nc bnc" id="L3062" title="All 2 branches missed.">							if (type == Trace.AHT) { // for outbound we need</span>
								// Connects instead of CV
<span class="nc bnc" id="L3064" title="All 2 branches missed.">								if (var &lt; 0) {// if values is less than zero then</span>
									// try CV
<span class="nc" id="L3066">									var = newLine[Trace.CV];</span>
								}
<span class="nc bnc" id="L3068" title="All 2 branches missed.">								if (var &lt; 0) {// if value is still zero try Connects</span>
<span class="nc" id="L3069">									var = newLine[Trace.CONNECTS];</span>
								}
							}
<span class="nc bnc" id="L3072" title="All 4 branches missed.">							if (var == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L3073">								continue;</span>
							}
							// PCA in percentage if it exceeds 100, that's invalid
							// point
<span class="nc bnc" id="L3077" title="All 2 branches missed.">							if (type == Trace.PCA) {</span>
<span class="nc bnc" id="L3078" title="All 4 branches missed.">								if (val &gt; 100 || val &lt; 0) {</span>
<span class="nc" id="L3079">									continue;</span>
								}
							}
<span class="nc" id="L3082">							aggVal += var * val;</span>
<span class="nc" id="L3083">							aggVAR += var;</span>
<span class="nc" id="L3084">						}</span>
<span class="nc bnc" id="L3085" title="All 2 branches missed.">						if (aggVAR &gt; 0) {</span>
<span class="nc" id="L3086">							chunk.setTraceValue(type, (aggVal / aggVAR));</span>
							// Fix for issue where both values are 0 so the combined
							// q shld be 0
							// required for virtual / dist queues.
						}
						break;
					}
					case Trace.RPCAHT: {
<span class="nc" id="L3094">						float aggCV = 0;</span>
<span class="nc" id="L3095">						float aggAHT_PCA = 0;</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">						short type_CV_Connects_RPC = (type != Trace.RPCAHT ? Trace.CV : Trace.RPC);</span>
<span class="nc bnc" id="L3097" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L3098">							float val = newLine[type];</span>
<span class="nc" id="L3099">							float cv = newLine[type_CV_Connects_RPC];</span>
<span class="nc bnc" id="L3100" title="All 4 branches missed.">							if (cv == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L3101">								continue;</span>
								// continue;
							}
<span class="nc" id="L3104">							aggAHT_PCA += cv * val;</span>
<span class="nc" id="L3105">							aggCV += cv;</span>
<span class="nc" id="L3106">						}</span>
<span class="nc bnc" id="L3107" title="All 2 branches missed.">						if (aggCV &gt; 0) {</span>
<span class="nc" id="L3108">							chunk.setTraceValue(type, aggAHT_PCA / aggCV);</span>
						}
						break;
					}
					// ASA is Sum((CV-ABN)*ASA)/Sum(CV-ABN)
					case Trace.ASA:
<span class="nc" id="L3114">						float aggABN = 0;</span>
<span class="nc" id="L3115">						float aggASA = 0;</span>
<span class="nc bnc" id="L3116" title="All 2 branches missed.">						for (Iterator it = lines.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3117">							float[] newLine = (float[]) it.next();</span>
<span class="nc" id="L3118">							float cv = newLine[Trace.CV];</span>
<span class="nc" id="L3119">							float abn = newLine[Trace.ABANDONMENT];</span>
<span class="nc" id="L3120">							float val = newLine[type];</span>
<span class="nc bnc" id="L3121" title="All 6 branches missed.">							if (val == Trace.TRACENA || cv == Trace.TRACENA || abn == Trace.TRACENA) {</span>
<span class="nc" id="L3122">								continue;</span>
							}
<span class="nc bnc" id="L3124" title="All 2 branches missed.">							if (cv - abn &lt; 0) {</span>
<span class="nc" id="L3125">								continue;</span>
							}
<span class="nc" id="L3127">							aggASA += (cv - abn) * val;</span>
<span class="nc" id="L3128">							aggABN += (cv - abn);</span>
<span class="nc" id="L3129">						}</span>
<span class="nc bnc" id="L3130" title="All 2 branches missed.">						if (aggABN &gt; 0) {</span>
<span class="nc" id="L3131">							chunk.setTraceValue(type, aggASA / aggABN);</span>
						}
						break;
					case Trace.STAFFING:
					case Trace.ASTAFFING:
					case Trace.OCCUPANCY:
					case Trace.NETSTAFFING:
<span class="nc" id="L3138">						chunk.setTraceValue(type, -2);</span>
<span class="nc" id="L3139">						break;</span>
					case Trace.CRATE:
					case Trace.RPCRATE: {
<span class="nc" id="L3142">						float aggDials = 0;</span>
<span class="nc" id="L3143">						float aggVal = 0;</span>
<span class="nc bnc" id="L3144" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L3145">							float val = newLine[type];</span>
<span class="nc" id="L3146">							float dials = newLine[Trace.DIALS];</span>
<span class="nc bnc" id="L3147" title="All 4 branches missed.">							if (dials == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L3148">								continue;</span>
								// continue;
							}
<span class="nc bnc" id="L3151" title="All 2 branches missed.">							if (val &gt; 100) { // CRate or RPCRate cannot be greater</span>
								// than 100
<span class="nc" id="L3153">								continue;</span>
							}
<span class="nc" id="L3155">							aggVal += dials * val;</span>
<span class="nc" id="L3156">							aggDials += dials;</span>
<span class="nc" id="L3157">						}</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">						if (aggDials &gt; 0) {</span>
<span class="nc" id="L3159">							chunk.setTraceValue(type, (aggVal / aggDials));</span>
						}
						break;
					}
					default:
				}
			}
<span class="nc" id="L3166">		} catch (Exception e) {</span>
<span class="nc" id="L3167">			m_cat.error(&quot;Exception in combineRpt&quot;, e);</span>
<span class="nc" id="L3168">		}</span>
<span class="nc" id="L3169">		return chunk;</span>
	}

	// combine new line to existing trace chunk
	private static void combineRptDayLine(short types[], Date time, ArrayList dayLines, Date prvEndOfDay, TimeZone tz,
										  Date start, Date end, ArrayList tcArray, DstObject dstObj) throws JdmoException {
<span class="nc" id="L3175">		ArrayList chunkList = new ArrayList(Trace.DAYPOINTS);</span>
<span class="nc" id="L3176">		dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end); // used in</span>
		// Reportdump
		// logic
<span class="nc bnc" id="L3179" title="All 2 branches missed.">		if (dstObj.skipLoop) {</span>
<span class="nc" id="L3180">			return;</span>
		}
<span class="nc bnc" id="L3182" title="All 2 branches missed.">		if (dstObj.needNewTraceCube) {</span>
<span class="nc" id="L3183">			tcArray.clear();// Flush the contents of the tcarray since this is</span>
			// the real start line.
		}
<span class="nc" id="L3186">		Date lineStart = dstObj.lineStart;</span>
<span class="nc" id="L3187">		boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink sameet</span>
<span class="nc" id="L3188">		boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="nc" id="L3189">		int dstPoints = dstObj.dstPoints; // track points</span>
<span class="nc" id="L3190">		boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to track</span>
		// transition
		/*
		 * boolean tfrIn = false; // 92 points day, need shrink sameet commented
		 * boolean tfrOut = false; // 100 points day, need expand int dstPoints
		 * = tz.getDSTSavings(); // track points boolean prvDSTFlag = false; //
		 * temp variable to track transition if (tz.useDaylightTime()) {
		 * prvDSTFlag = tz.inDaylightTime(time); Date endOfDay = new
		 * Date(time.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG-1); if
		 * (prvDSTFlag) { if (!tz.inDaylightTime(endOfDay)) { tfrOut = true; } }
		 * else { if (tz.inDaylightTime(endOfDay)) { tfrIn = true; } } }
		 * ArrayList chunkList = new ArrayList(Trace.DAYPOINTS); // Special
		 * handling needed as DE stores wrong Start Time Date lineStart = new
		 * Date(time.getTime()); if (prvEndOfDay != null &amp;&amp;
		 * time.before(prvEndOfDay)) { lineStart = prvEndOfDay; // overlap with
		 * previous day, need skip DST points for (int
		 * i=dstPoints/(int)Trace.INTERVAL_IN_MILLIS; i&lt;Trace.DAYPOINTS; i++) {
		 * ArrayList lines = new ArrayList(); for (Iterator
		 * it=dayLines.iterator(); it.hasNext(); ) { float[][] dayLine =
		 * (float[][])it.next(); lines.add(dayLine[i]); }
		 * chunkList.add(combineRpt(types, lineStart, lines)); lineStart = new
		 * Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS); } } else{
		 */
<span class="nc bnc" id="L3213" title="All 2 branches missed.">		for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L3214" title="All 6 branches missed.">			if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
				// if transition will happen on this line
<span class="nc bnc" id="L3216" title="All 2 branches missed.">				if (tz.inDaylightTime(lineStart) != prvDSTFlag) {</span>
					// from this point, there is dst transition
<span class="nc" id="L3218">					int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3219" title="All 2 branches missed.">					if (tfrIn) {</span>
						// skip points
<span class="nc" id="L3221">						i += dstIntv - 1;</span>
<span class="nc bnc" id="L3222" title="All 2 branches missed.">						prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3223">						continue;</span>
					}
					// add points
<span class="nc bnc" id="L3226" title="All 2 branches missed.">					for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L3227">						TraceChunk chunk = new TraceChunk(null, lineStart);</span>
<span class="nc bnc" id="L3228" title="All 2 branches missed.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3229">							chunk.setTraceValue(types[t], Trace.TRACENA);</span>
						}
<span class="nc" id="L3231">						chunkList.add(chunk);</span>
<span class="nc" id="L3232">						lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
					}
				}
			} // else{
<span class="nc" id="L3236">			ArrayList lines = new ArrayList();</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">			for (Iterator it = dayLines.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3238">				float[][] dayLine = (float[][]) it.next();</span>
<span class="nc" id="L3239">				lines.add(dayLine[i]);</span>
<span class="nc" id="L3240">			}</span>
<span class="nc" id="L3241">			chunkList.add(combineRpt(types, lineStart, lines));</span>
			// QA 92053 - report not showing combined REQ FTE for Sunday Oct 26.
			// prvDSTFlag should be re-calculate if not DST code transition
			// above will be executed all the loop
<span class="nc bnc" id="L3245" title="All 4 branches missed.">			if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3246">				prvDSTFlag = tz.inDaylightTime(lineStart);</span>
			}
<span class="nc" id="L3248">			lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
		}
		// }
		// }
<span class="nc" id="L3252">		tcArray.addAll(chunkList);</span>
<span class="nc" id="L3253">	}</span>

	/**
	 * Seems to be called from a lot of places in the client code.
	 * This method does not have any effect on PredictTraceCubes. 2011-09-08
	 * TODO: DST issue for this method is not tested, Sameet, March 2006 for CV
	 * in service goal tracecube.
	 *
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param jdmo
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param spqueuesBySID
	 * @return
	 * @throws Exception
	 */
	private static Collection convert(JdmoRowset rs, TraceCube metaTC, Map spQMap, Map spTimeRangeMap, Jdmo jdmo,
									  Date start, Date end, boolean includeAllServiceGoalTypes, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="fc" id="L3275">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L3276">		HashMap queueTraceMap = new HashMap();</span>
<span class="fc" id="L3277">		HashMap queueEndOfDayMap = new HashMap();</span>
<span class="pc bpc" id="L3278" title="1 of 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L3279">			convertActualTC(rs, metaTC, spQMap, spTimeRangeMap, start, end,</span>
					types, queueTraceMap);
		}
<span class="fc bfc" id="L3282" title="All 4 branches covered.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L3283">			convertForecastRequiredTC(rs, metaTC, spQMap, spTimeRangeMap,</span>
					start, end, spqueuesBySID, types, queueTraceMap,
					queueEndOfDayMap);
		}
<span class="fc bfc" id="L3287" title="All 2 branches covered.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L3288">			convertSGTC(rs, spQMap, spTimeRangeMap, jdmo, start, end,</span>
					includeAllServiceGoalTypes, types, queueTraceMap);
		}
		// calculate the computed trace values
<span class="fc" id="L3292">		HashMap queueMediaMap = TraceOperatorAdapter.getMediaForQueues(queueTraceMap.values().toArray(), jdmo.isWhatIf());</span>
<span class="fc bfc" id="L3293" title="All 2 branches covered.">		for (Iterator iterator = queueTraceMap.values().iterator(); iterator.hasNext(); ) {</span>
<span class="fc" id="L3294">			TraceCube cube = (TraceCube) iterator.next();</span>
<span class="fc" id="L3295">			cube.calcComputedTraceValues((ID) queueMediaMap.get(cube.getQueueID()));</span>
<span class="fc" id="L3296">		}</span>
<span class="fc" id="L3297">		ArrayList traceList = new ArrayList(queueTraceMap.size());</span>
<span class="fc" id="L3298">		traceList.addAll(queueTraceMap.values());</span>
<span class="fc" id="L3299">		return traceList;</span>
	}

	/**
	 * @param rs
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param jdmo
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param types
	 * @param queueTraceMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertSGTC(JdmoRowset rs, Map spQMap,
									Map spTimeRangeMap, Jdmo jdmo, Date start, Date end,
									boolean includeAllServiceGoalTypes, short[] types,
									HashMap queueTraceMap) throws JdmoException, BbmTimeSeriesException {
		// special handling here, as it need load Forecast CV for each queue
		// Track affected SP for Forecast load
<span class="fc" id="L3321">		HashSet spSet = new HashSet();</span>
<span class="fc" id="L3322">		HashSet queueSet = new HashSet();</span>
<span class="fc" id="L3323">		HashMap sgTimeLines = new HashMap();</span>
<span class="fc bfc" id="L3324" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L3325">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="fc" id="L3326">			ID queueID = rs.getID(5);</span>
<span class="fc" id="L3327">			ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="fc bfc" id="L3328" title="All 2 branches covered.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="fc" id="L3329">				continue;</span>
			}
			// Add 1 line per Time for all queues
<span class="fc" id="L3332">			ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="fc bfc" id="L3333" title="All 2 branches covered.">			if (tcList == null) {</span>
<span class="fc" id="L3334">				tcList = new ArrayList();</span>
			}
<span class="fc" id="L3336">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(7));</span>
<span class="fc" id="L3337">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(7));</span>
			// hack for ops release. set PCAType to false to always show SL.
			// typeASAEnabled = false;
<span class="fc" id="L3340">			TraceChunk sgTC = new TraceChunk(queueID, curTime);</span>
<span class="pc bpc" id="L3341" title="1 of 2 branches missed.">			if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L3342">				sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L3343" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3344">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L3346">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="pc bpc" id="L3348" title="1 of 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="fc" id="L3349">				sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="pc bpc" id="L3350" title="1 of 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3351">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				}
			} else {
<span class="nc" id="L3354">				sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
			}
<span class="fc" id="L3356">			sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="fc" id="L3357">			tcList.add(sgTC);</span>
<span class="fc" id="L3358">			sgTimeLines.put(curTime, tcList);</span>
			// Add 3 identical TCs, as DE service goal is per hour, report
			// is per 15 mins
<span class="fc bfc" id="L3361" title="All 2 branches covered.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="fc" id="L3362">				TraceChunk tc1 = new TraceChunk(queueID, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="fc" id="L3363">				ArrayList tc1List = (ArrayList) sgTimeLines.get(tc1.getStartDate());</span>
<span class="fc bfc" id="L3364" title="All 2 branches covered.">				if (tc1List == null) {</span>
<span class="fc" id="L3365">					tc1List = new ArrayList();</span>
				}
<span class="pc bpc" id="L3367" title="1 of 2 branches missed.">				if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L3368">					tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3369" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3370">						tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
					} else {
<span class="nc" id="L3372">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="pc bpc" id="L3374" title="1 of 2 branches missed.">				} else if (!typeASAEnabled) {</span>
<span class="fc" id="L3375">					tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="pc bpc" id="L3376" title="1 of 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3377">						tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
					}
				} else {
<span class="nc" id="L3380">					tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
				}
<span class="fc" id="L3382">				tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="fc" id="L3383">				tc1List.add(tc1);</span>
<span class="fc" id="L3384">				sgTimeLines.put(tc1.getStartDate(), tc1List);</span>
			}
			// track all affected sps
<span class="fc" id="L3387">			spSet.add(rs.getID(6));</span>
			// track all affected queues
<span class="fc" id="L3389">			queueSet.add(queueID);</span>
<span class="fc" id="L3390">		}</span>
<span class="fc" id="L3391">		rs.close();</span>
<span class="pc bpc" id="L3392" title="1 of 2 branches missed.">		if (!sgTimeLines.isEmpty()) {</span>
<span class="fc" id="L3393">			Set affectedTimeSet = sgTimeLines.keySet();</span>
			// Prepare to load Forecast CV for all queues in affected SPs
<span class="fc" id="L3395">			StringBuffer pStmt = new StringBuffer();</span>
<span class="fc" id="L3396">			pStmt.append(&quot;select &quot;);</span>
<span class="fc bfc" id="L3397" title="All 2 branches covered.">			for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="fc" id="L3398">				pStmt.append(&quot;CALLVOLUME&quot;).append(i).append(&quot;,&quot;);</span>
			}
<span class="fc" id="L3400">			pStmt.append(&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE , B.SID SPQUEUESID  from &quot;)</span>
<span class="fc" id="L3401">					.append(ForecastTraceTableName);</span>
<span class="fc" id="L3402">			pStmt.append(</span>
					&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN where C.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.FORECASTINSTANCEID is null and A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;)
<span class="fc" id="L3404">					.append(jdmo.createInClause(spSet));</span>
<span class="fc" id="L3405">			pStmt.append(&quot; and A.FORECASTINSTANCEID is null and D.SID in &quot;).append(jdmo.createInClause(queueSet));</span>
<span class="fc" id="L3406">			pStmt.append(&quot; order by A.DATETIME asc&quot;);</span>
<span class="fc" id="L3407">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="fc" id="L3408">			HashMap hashMapPrevEndOfDayForQ = new HashMap();</span>
<span class="fc bfc" id="L3409" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L3410">				ID queID = rs.getID(Trace.DAYPOINTS + 2);</span>
<span class="fc" id="L3411">				Date prvEndOfDay = (Date) hashMapPrevEndOfDayForQ.get(queID);</span>
<span class="fc" id="L3412">				DstObject dstObj = new DstObject();</span>
<span class="fc" id="L3413">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="fc" id="L3414">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="fc" id="L3415">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="fc" id="L3416">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="fc" id="L3417">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end); // TESTED</span>
				// reqd
				// svc
				// level
				// for
				// Skill
				// campagain
				// at
				// comb
				// level
<span class="pc bpc" id="L3427" title="1 of 2 branches missed.">				if (dstObj.skipLoop) {</span>
<span class="nc" id="L3428">					continue;</span>
				}
<span class="fc bfc" id="L3430" title="All 2 branches covered.">				if (dstObj.needNewTraceCube) {</span>
					// tcArray.clear();//Flush the contents of the tcarray
					// since this is the real start line.
				}
<span class="fc" id="L3434">				Date insertPoint = dstObj.lineStart;</span>
<span class="fc" id="L3435">				boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
				// sameet
<span class="fc" id="L3437">				boolean tfrOut = dstObj.tfrOut; // 100 points day, need</span>
				// expand
<span class="fc" id="L3439">				int dstPoints = dstObj.dstPoints; // track points</span>
<span class="fc" id="L3440">				boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to</span>
				// track transition
<span class="fc bfc" id="L3442" title="All 2 branches covered.">				for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
					// This is wrong as it increments the time on DST
					// transition day in APR
					// Date insertPoint = new Date(lineStart.getTime() +
					// (i-1)*Trace.INTERVAL_IN_MILLIS);
<span class="pc bpc" id="L3447" title="3 of 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="nc bnc" id="L3449" title="All 2 branches missed.">						if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="nc" id="L3451">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3452" title="All 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="nc" id="L3454">								i += dstIntv - 1;</span>
<span class="nc bnc" id="L3455" title="All 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3456">								continue;</span>
							}
							// add points
<span class="nc bnc" id="L3459" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L3460" title="All 2 branches missed.">								for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3461">									ArrayList tcList = (ArrayList) sgTimeLines.get(insertPoint);</span>
<span class="nc bnc" id="L3462" title="All 2 branches missed.">									if (tcList != null) {</span>
<span class="nc bnc" id="L3463" title="All 2 branches missed.">										for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3464">											TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc bnc" id="L3465" title="All 2 branches missed.">											if (tc.getQueueID().equals(queID)) {</span>
<span class="nc" id="L3466">												tc.setTraceValue(Trace.CV, Trace.TRACENA);</span>
											}
<span class="nc" id="L3468">										}</span>
									}
								}
<span class="nc" id="L3471">								insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
							}
						}
					}
<span class="pc bpc" id="L3475" title="1 of 2 branches missed.">					if (insertPoint.after(end)) {</span>
<span class="nc" id="L3476">						break;</span>
					}
					// regular processing
<span class="pc bpc" id="L3479" title="1 of 2 branches missed.">					if (affectedTimeSet.contains(insertPoint)) {</span>
<span class="fc" id="L3480">						ArrayList tcList = (ArrayList) sgTimeLines.get(insertPoint);</span>
<span class="pc bpc" id="L3481" title="1 of 2 branches missed.">						if (tcList != null) {</span>
<span class="fc bfc" id="L3482" title="All 2 branches covered.">							for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L3483">								TraceChunk tc = (TraceChunk) it.next();</span>
<span class="fc bfc" id="L3484" title="All 2 branches covered.">								if (tc.getQueueID().equals(queID)) {</span>
<span class="fc" id="L3485">									tc.setTraceValue(Trace.CV, rs.getFloat(i));</span>
								}
<span class="fc" id="L3487">							}</span>
						}
					}
<span class="pc bpc" id="L3490" title="2 of 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3491">						prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
					}
<span class="fc" id="L3493">					insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
				// }
<span class="fc" id="L3496">				prvEndOfDay = insertPoint;</span>
<span class="fc" id="L3497">				hashMapPrevEndOfDayForQ.put(queID, prvEndOfDay);</span>
<span class="fc" id="L3498">			}</span>
			// now add to cube
<span class="fc bfc" id="L3500" title="All 2 branches covered.">			for (Iterator it = affectedTimeSet.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L3501">				Date chunkTime = (Date) it.next();</span>
<span class="pc bpc" id="L3502" title="1 of 2 branches missed.">				if (fallsIn(chunkTime, start, end)) {</span>
<span class="fc" id="L3503">					ArrayList lines = (ArrayList) sgTimeLines.get(chunkTime);</span>
<span class="fc bfc" id="L3504" title="All 2 branches covered.">					for (Iterator lineIt = lines.iterator(); lineIt.hasNext(); ) {</span>
<span class="fc" id="L3505">						TraceChunk chunk = (TraceChunk) lineIt.next();</span>
<span class="fc" id="L3506">						ID qID = chunk.getQueueID();</span>
<span class="fc" id="L3507">						TraceCube cube = (TraceCube) queueTraceMap.get(qID);</span>
<span class="fc bfc" id="L3508" title="All 2 branches covered.">						if (cube == null) {</span>
<span class="fc" id="L3509">							cube = TraceUtil.META_AGGR_REQUIRE.newInstance(qID, start, end, types);</span>
						}
<span class="fc" id="L3511">						cube.setTraceValue(types, chunk.getTraceValues(types), chunkTime);</span>
<span class="fc" id="L3512">						cube.setTraceValue(Trace.CV, chunk.getTraceValue(Trace.CV), chunkTime, true);</span>
						// calcComputedValues Method needs media ID only for
						// Actual timeSeries
<span class="fc" id="L3515">						cube.calcComputedTraceValues((ID) null);</span>
<span class="fc" id="L3516">						queueTraceMap.put(qID, cube);</span>
<span class="fc" id="L3517">					}</span>
				}
<span class="fc" id="L3519">			}</span>
		}
<span class="fc" id="L3521">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param types
	 * @param queueTraceMap
	 * @param queueEndOfDayMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertForecastRequiredTC(JdmoRowset rs,
												  TraceCube metaTC, Map spQMap, Map spTimeRangeMap, Date start,
												  Date end, Map&lt;ID, SPQueue&gt; spqueuesBySID, short[] types,
												  HashMap queueTraceMap, HashMap queueEndOfDayMap)
			throws JdmoException, BbmTimeSeriesException {
<span class="fc" id="L3542">		Date prvEndOfDay = null;</span>
<span class="fc bfc" id="L3543" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L3544">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="fc" id="L3545">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="fc bfc" id="L3546" title="All 2 branches covered.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="fc" id="L3547">				continue;</span>
			}
<span class="fc" id="L3549">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="fc" id="L3550">			double[][] dayLine = new double[Trace.DAYPOINTS][];</span>
<span class="fc" id="L3551">			int resultSetCounter = 1;</span>
<span class="fc bfc" id="L3552" title="All 2 branches covered.">			for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="fc" id="L3553">				double[] newLine = new double[types.length]; // forecast is</span>
				// CV/AHT
<span class="fc bfc" id="L3555" title="All 2 branches covered.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="fc bfc" id="L3556" title="All 2 branches covered.">					if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="fc" id="L3557">						newLine[j] = rs.getFloat(resultSetCounter++);</span>
					}
				}
<span class="fc" id="L3560">				dayLine[i] = newLine;</span>
			}
<span class="fc" id="L3562">			convertLinesMap(metaTC, start, end, types, queueID, dayLine, queueTraceMap, curTime, queueEndOfDayMap, tz,</span>
					spqueuesBySID, rs);
			/*
			 * Sameet March 2006 this is wrong since it does not take care
			 * of DST transition where End of the Day will not be 24 hrs
			 * This part of code is moved to the method above
			 * converLinesMap() which will take care of adjusting the
			 * Previous end of Day as required
			 * 
			 * prvEndOfDay = new Date(curTime.getTime() +
			 * Trace.INTERVAL_IN_MILLIS * Trace.DAYPOINTS);
			 * queueEndOfDayMap.put(queueID, prvEndOfDay);
			 */
<span class="fc" id="L3575">		}</span>
<span class="fc" id="L3576">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param types
	 * @param queueTraceMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertActualTC(JdmoRowset rs, TraceCube metaTC,
										Map spQMap, Map spTimeRangeMap, Date start, Date end,
										short[] types, HashMap queueTraceMap) throws JdmoException,
			BbmTimeSeriesException {
<span class="nc bnc" id="L3594" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3595">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
			// check if the queue ID is in the association window or not
<span class="nc" id="L3597">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3598">			ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3599" title="All 2 branches missed.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3600">				continue;</span>
			}
<span class="nc" id="L3602">			double[] newLine = new double[types.length];</span>
<span class="nc" id="L3603">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3604" title="All 2 branches missed.">			for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3605" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3606">					newLine[j] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L3609">			TraceCube cube = (TraceCube) queueTraceMap.get(queueID);</span>
<span class="nc bnc" id="L3610" title="All 2 branches missed.">			if (cube == null) {</span>
<span class="nc" id="L3611">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L3613">			cube.setTraceValue(types, newLine, curTime);</span>
<span class="nc" id="L3614">			cube.calcComputedTraceValues(mediaID);</span>
<span class="nc" id="L3615">			queueTraceMap.put(queueID, cube);</span>
<span class="nc" id="L3616">		}</span>
<span class="nc" id="L3617">	}</span>

	// Used to calculate trace types for a combined Queue. Indvl queues are
	// passed to this method, one day at a time for the whole SP
	private static void convertLinesMap(TraceCube metaTC, Date start, Date end, short[] types, ID qID, double[][] values,
										HashMap queueTraceMap, Date lineStart, HashMap queueEndOfDayMap, TimeZone tz, Map&lt;ID, SPQueue&gt; spqueuesBySID,
										JdmoRowset rs) throws BbmTimeSeriesException, JdmoException {

<span class="fc" id="L3625">		TraceCube cube = (TraceCube) queueTraceMap.get(qID);</span>
<span class="fc" id="L3626">		Date insertPoint = new Date(lineStart.getTime());</span>
<span class="fc" id="L3627">		Date prvEndOfDay = (Date) queueEndOfDayMap.get(qID);</span>
<span class="fc" id="L3628">		DstObject dstObj = new DstObject();</span>
<span class="fc" id="L3629">		dstObj.lineStart = lineStart;</span>
<span class="fc" id="L3630">		dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="fc" id="L3631">		dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="fc" id="L3632">		dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);// tested</span>
<span class="pc bpc" id="L3633" title="1 of 2 branches missed.">		if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L3634">			return;</span>
		}
<span class="pc bpc" id="L3636" title="1 of 4 branches missed.">		if (dstObj.needNewTraceCube || cube == null) {</span>
<span class="fc" id="L3637">			cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="fc" id="L3639">		cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="fc" id="L3640">		ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="fc" id="L3641">		cube.setSPQueueSID(spQueueSID);</span>
<span class="fc" id="L3642">		SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="pc bpc" id="L3643" title="1 of 2 branches missed.">		if (spq != null) {</span>
<span class="fc" id="L3644">			cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="fc" id="L3645">			cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="fc" id="L3646">			cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
		}
<span class="fc" id="L3648">		lineStart = dstObj.lineStart;</span>
<span class="fc" id="L3649">		insertPoint = new Date(dstObj.lineStart.getTime());</span>
<span class="fc" id="L3650">		boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
<span class="fc" id="L3651">		boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="fc" id="L3652">		int dstPoints = dstObj.dstPoints; // track points</span>
<span class="fc" id="L3653">		boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to track</span>
		// transition
		/*
		 * boolean tfrIn = false; // 92 points day, need shrink sameet commented
		 * boolean tfrOut = false; // 100 points day, need expand int dstPoints
		 * = tz.getDSTSavings(); // track points boolean prvDSTFlag = false; //
		 * temp variable to track transition Date endOfDay = new
		 * Date(lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG-1);
		 * if (tz.useDaylightTime()) { prvDSTFlag =
		 * tz.inDaylightTime(lineStart);
		 * 
		 * tfrOut = prvDSTFlag &amp;&amp; !tz.inDaylightTime(endOfDay); tfrIn =
		 * !prvDSTFlag &amp;&amp; tz.inDaylightTime(endOfDay); //need to calculate real
		 * end of day after DSt transition in Apr , shrink by 4 points, its only
		 * 23 hr day if (tfrIn) { endOfDay = new Date(lineStart.getTime() +
		 * TimeZoneUtil.DAY_IN_MILLISECONDS_LONG - dstPoints - 1); //Skip this
		 * day completely if the start and end of the day do not fall in the
		 * start and end of SP if (!fallsIn(lineStart, start, end)&amp;&amp;
		 * !fallsIn(endOfDay, start, end)){ if (m_cat.isDebugEnabled()) {
		 * m_cat.debug(&quot;DST transition SP; Skipping this day; endOfDay=&quot; +
		 * endOfDay + &quot;:SP start&quot; + start); } return; } } }
		 * 
		 * /* this is reqd to skip overlap data on the POST-POST DST transition
		 * week if (insertPoint.before(start) &amp;&amp; !fallsIn(start, insertPoint,
		 * endOfDay)) { if (m_cat.isDebugEnabled()) m_cat.debug(
		 * &quot;Around DST transition SP; skipping this day totally lineStart=&quot; +
		 * insertPoint + &quot; SP start=&quot; + start); return; } else if
		 * (insertPoint.equals(start)) { //Ignore all the data Collected before
		 * this time since it was collected for wrong day cube =
		 * metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());
		 * prvEndOfDay=null; } //this is done to fix the shift by 4 points in
		 * the POST DST week starting in APR. //before this fix the points used
		 * to shift by 4 starting on 1st monday after DST //Also it adjust in
		 * the OCT Post DST week where an overlap of 4 points was found on the
		 * next day of DST transition if (prvEndOfDay != null &amp;&amp;
		 * (insertPoint.after(prvEndOfDay)|| insertPoint.before(prvEndOfDay))) {
		 * if (m_cat.isDebugEnabled())
		 * m_cat.debug(&quot;DST transition SP; Changing insertPoint from &quot; +
		 * insertPoint + &quot; TO &quot; + prvEndOfDay); insertPoint = prvEndOfDay; }
		 */
<span class="fc bfc" id="L3693" title="All 2 branches covered.">		for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="pc bpc" id="L3694" title="1 of 2 branches missed.">			if (fallsIn(insertPoint, start, end)) {</span>
<span class="pc bpc" id="L3695" title="2 of 6 branches missed.">				if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
					// if transition will happen on this line
<span class="fc bfc" id="L3697" title="All 2 branches covered.">					if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
						// from this point, there is dst transition
<span class="fc" id="L3699">						int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="pc bpc" id="L3700" title="1 of 2 branches missed.">						if (tfrIn) {</span>
							// skip points
<span class="fc" id="L3702">							i += dstIntv - 1;</span>
<span class="pc bpc" id="L3703" title="1 of 2 branches missed.">							prvDSTFlag = !prvDSTFlag;</span>
<span class="fc" id="L3704">							continue;</span>
						}
						// add points
<span class="nc bnc" id="L3707" title="All 2 branches missed.">						for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L3708" title="All 2 branches missed.">							for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3709">								cube.setTraceValue(types[t], Trace.TRACENA, insertPoint, true);</span>
							}
<span class="nc" id="L3711">							insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3712" title="All 2 branches missed.">							if (insertPoint.after(end)) {</span>
<span class="nc" id="L3713">								break;</span>
							}
						}
					}
				}
<span class="fc bfc" id="L3718" title="All 2 branches covered.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="fc" id="L3719">					cube.setTraceValue(types[j], values[i][j], insertPoint, true);</span>
				}
			}
<span class="pc bpc" id="L3722" title="1 of 4 branches missed.">			if (tfrIn || tfrOut) {</span>
<span class="fc" id="L3723">				prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
			}
<span class="fc" id="L3725">			insertPoint.setTime(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="fc bfc" id="L3726" title="All 2 branches covered.">			if (insertPoint.after(end)) {</span>
<span class="fc" id="L3727">				break;</span>
			}
		}
		// this code is moved from the callee method to this to accomdate for
		// the DST transition days where day does not have 24 hrs
		// prvEndOfDay = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS
		// * Trace.DAYPOINTS);
<span class="fc" id="L3734">		queueEndOfDayMap.put(qID, insertPoint);</span>
<span class="fc" id="L3735">		cube.calcComputedTraceValues((ID) null); // passing null for media id</span>
		// since it is reqd only for
		// actuals not forecast
<span class="fc" id="L3738">		queueTraceMap.put(qID, cube);</span>
<span class="fc" id="L3739">	}</span>

	// This method does not have any effect on PredictTraceCubes. 2011-09-08
	private static void convert(JdmoRowset rs, TraceCube metaTC, HashMap spQMap, HashMap spTimeRangeMap,
								ArrayList&lt;TraceChunk&gt; tcArray, Date start, Date end, Jdmo jdmo, HashMap traceChunkMap) throws JdmoException {
<span class="nc" id="L3744">		Date prvTime = null;</span>
<span class="nc" id="L3745">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L3746">		ArrayList lines = new ArrayList();</span>
<span class="nc bnc" id="L3747" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc bnc" id="L3748" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3749">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
				// check if the queue ID is in the association window or not
<span class="nc" id="L3751">				ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3752">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3753" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3754">					continue;</span>
				}
<span class="nc" id="L3756">				float[] newLine = new float[types.length];</span>
<span class="nc" id="L3757">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3758" title="All 2 branches missed.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">					if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3760">						newLine[j] = rs.getFloat(resultSetCounter++);</span>
					}
				}
<span class="nc" id="L3763">				metaTC.calcComputedTraceValues(types, newLine, mediaID);</span>
<span class="nc bnc" id="L3764" title="All 4 branches missed.">				if (prvTime == null || !prvTime.equals(curTime)) {</span>
					// if prvTime is not null, means we can aggregate previous
					// time point
<span class="nc bnc" id="L3767" title="All 2 branches missed.">					if (prvTime != null) {</span>
						// aggregate
<span class="nc" id="L3769">						tcArray.add(combineRpt(types, prvTime, lines));</span>
<span class="nc" id="L3770">						lines.clear();</span>
					}
<span class="nc" id="L3772">					prvTime = curTime;</span>
				}
<span class="nc" id="L3774">				lines.add(newLine);</span>
<span class="nc" id="L3775">			}</span>
<span class="nc bnc" id="L3776" title="All 4 branches missed.">			if (!lines.isEmpty() &amp;&amp; prvTime != null) {</span>
<span class="nc" id="L3777">				tcArray.add(combineRpt(types, prvTime, lines));</span>
			}
		}
<span class="nc bnc" id="L3780" title="All 4 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L3781">			Date prvEndOfDay = null;</span>
<span class="nc" id="L3782">			TimeZone prvTZ = null;</span>
<span class="nc" id="L3783">			DstObject dstObj = null;</span>
<span class="nc bnc" id="L3784" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3785">				dstObj = new DstObject();</span>
<span class="nc" id="L3786">				dstObj.lineStart = prvTime;</span>
<span class="nc" id="L3787">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L3788">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3789">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L3790">				ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3791">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3792" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3793">					continue;</span>
				}
<span class="nc" id="L3795">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc bnc" id="L3796" title="All 4 branches missed.">				if (prvTime == null || !prvTime.equals(curTime)) {</span>
					// if prvTime is not null, means we can aggregate previous
					// time point
<span class="nc bnc" id="L3799" title="All 2 branches missed.">					if (prvTime != null) {</span>
						// aggregate
<span class="nc" id="L3801">						combineRptDayLine(types, prvTime, lines, prvEndOfDay, prvTZ, start, end, tcArray, dstObj);</span>
<span class="nc" id="L3802">						prvEndOfDay = new Date(prvTime.getTime() + Trace.INTERVAL_IN_MILLIS * Trace.DAYPOINTS);</span>
<span class="nc" id="L3803">						lines.clear();</span>
					}
				}
<span class="nc" id="L3806">				prvTime = curTime;</span>
<span class="nc" id="L3807">				prvTZ = tz;</span>
<span class="nc" id="L3808">				float[][] dayLine = new float[Trace.DAYPOINTS][];</span>
<span class="nc" id="L3809">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3810" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3811">					float[] newLine = new float[Trace.MAX_TYPE]; // forecast is</span>
					// CV/AHT
<span class="nc bnc" id="L3813" title="All 2 branches missed.">					for (int j = 0; j &lt; newLine.length; j++) {</span>
<span class="nc" id="L3814">						newLine[j] = Trace.TRACENA;</span>
					}
<span class="nc bnc" id="L3816" title="All 2 branches missed.">					for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3817" title="All 2 branches missed.">						if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3818">							newLine[types[j]] = rs.getFloat(resultSetCounter++);</span>
						}
					}
<span class="nc" id="L3821">					metaTC.calcComputedTraceValues(types, newLine, mediaID);</span>
<span class="nc" id="L3822">					Date timeNow = new Date(prvTime.getTime() + (Trace.INTERVAL_IN_MILLIS * i));</span>
<span class="nc bnc" id="L3823" title="All 2 branches missed.">					HashMap queChunkMap = traceChunkMap != null ? (HashMap) traceChunkMap.get(timeNow) : null;</span>
<span class="nc bnc" id="L3824" title="All 2 branches missed.">					TraceChunk predictChunk = queChunkMap != null ? (TraceChunk) queChunkMap.get(queueID) : null;</span>

<span class="nc bnc" id="L3826" title="All 2 branches missed.">					if (predictChunk != null) {</span>
<span class="nc" id="L3827">						newLine[Trace.DIALS] = predictChunk.getTraceValue(Trace.DIALS);</span>
						// Predicted Connects &amp; RPC are computed values
						// dependent on CRATE &amp; RPCSRATE from Forecast
						// Timeseries.
						// These cannot be always computed before this call
						// If its not available then compute based on DIALS and
						// RPCRATE
						// make a call to calculate the computed values
<span class="nc" id="L3835">						new PredictTraceCube().calcComputedTraceValues(Trace.TYPES, newLine, null);</span>
						// System.out.println(&quot;timeNow=&quot;+timeNow +&quot;=queueID=&quot;+
						// queueID+&quot;:DIALS=&quot;+ newLine[Trace.DIALS]+&quot;:CRATE=&quot;+
						// newLine[Trace.CRATE]+&quot;:CONNECTS=&quot;+
						// newLine[Trace.CONNECTS]+&quot;:RPCRATE=&quot;+
						// newLine[Trace.RPCRATE]+&quot;:RPC=&quot;+ newLine[Trace.RPC]);
					}
<span class="nc" id="L3842">					dayLine[i] = newLine;</span>
				}
<span class="nc" id="L3844">				lines.add(dayLine);</span>
<span class="nc" id="L3845">			}</span>
<span class="nc bnc" id="L3846" title="All 4 branches missed.">			if (prvTime != null &amp;&amp; !lines.isEmpty()) {</span>
<span class="nc" id="L3847">				combineRptDayLine(types, prvTime, lines, prvEndOfDay, prvTZ, start, end, tcArray, dstObj);</span>
			}
		}
<span class="nc bnc" id="L3850" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
			// special handling here, as it need load Forecast CV for each queue
			// Track affected SP for Forecast load
<span class="nc" id="L3853">			HashSet spSet = new HashSet();</span>
<span class="nc" id="L3854">			HashSet queueSet = new HashSet();</span>
<span class="nc" id="L3855">			HashMap sgTimeLines = new HashMap();</span>
<span class="nc bnc" id="L3856" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3857">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L3858">				ID queueID = rs.getID(5);</span>
<span class="nc" id="L3859">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3860" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3861">					continue;</span>
				}
				// Add 1 line per Time for all queues
<span class="nc" id="L3864">				ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="nc bnc" id="L3865" title="All 2 branches missed.">				if (tcList == null) {</span>
<span class="nc" id="L3866">					tcList = new ArrayList();</span>
				}
<span class="nc" id="L3868">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(7));</span>
<span class="nc" id="L3869">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(7));</span>
				// hack for ops release. set PCAType to false to always show SL.
				// typeASAEnabled = false;
<span class="nc" id="L3872">				TraceChunk sgTC = new TraceChunk(queueID, curTime);</span>
<span class="nc bnc" id="L3873" title="All 2 branches missed.">				if (!typeASAEnabled) {</span>
<span class="nc" id="L3874">					sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L3875" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3876">						sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					}
				} else {
<span class="nc" id="L3879">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc" id="L3881">				sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L3882">				tcList.add(sgTC);</span>
<span class="nc" id="L3883">				sgTimeLines.put(curTime, tcList);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report
				// is per 15 mins
<span class="nc bnc" id="L3886" title="All 2 branches missed.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L3887">					TraceChunk tc1 = new TraceChunk(queueID, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc" id="L3888">					ArrayList tc1List = (ArrayList) sgTimeLines.get(tc1.getStartDate());</span>
<span class="nc bnc" id="L3889" title="All 2 branches missed.">					if (tc1List == null) {</span>
<span class="nc" id="L3890">						tc1List = new ArrayList();</span>
					}
<span class="nc bnc" id="L3892" title="All 2 branches missed.">					if (!typeASAEnabled) {</span>
<span class="nc" id="L3893">						tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3894" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3895">							tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L3898">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L3900">					tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc" id="L3901">					tc1List.add(tc1);</span>
<span class="nc" id="L3902">					sgTimeLines.put(tc1.getStartDate(), tc1List);</span>
				}
				// track all affected sps
<span class="nc" id="L3905">				spSet.add(rs.getID(6));</span>
				// track all affected queues
<span class="nc" id="L3907">				queueSet.add(queueID);</span>
<span class="nc" id="L3908">			}</span>
<span class="nc" id="L3909">			rs.close();</span>
<span class="nc bnc" id="L3910" title="All 2 branches missed.">			if (!sgTimeLines.isEmpty()) {</span>
<span class="nc" id="L3911">				Set affectedTimeSet = sgTimeLines.keySet();</span>
				// Prepare to load Forecast CV for all queues in affected SPs
<span class="nc" id="L3913">				StringBuffer pStmt = new StringBuffer();</span>
<span class="nc" id="L3914">				pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L3915" title="All 2 branches missed.">				for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3916">					pStmt.append(&quot;CALLVOLUME&quot;).append(i).append(&quot;,&quot;);</span>
				}
<span class="nc" id="L3918">				pStmt.append(&quot; A.DATETIME, D.SID from &quot;).append(ForecastTraceTableName);</span>
<span class="nc" id="L3919">				pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D where A.FORECASTINSTANCEID is null AND &quot;);</span>
<span class="nc" id="L3920">				pStmt.append(&quot; A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;).append(</span>
<span class="nc" id="L3921">						jdmo.createInClause(spSet));</span>
<span class="nc" id="L3922">				pStmt.append(&quot; and D.SID in &quot;).append(jdmo.createInClause(queueSet));</span>
<span class="nc" id="L3923">				rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L3924" title="All 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L3925">					Date dayTime = TimeZoneUtil.toDate(rs.getTimestamp(Trace.DAYPOINTS + 1));</span>
<span class="nc bnc" id="L3926" title="All 2 branches missed.">					for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3927">						Date curTime = new Date(dayTime.getTime() + (i - 1) * Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3928" title="All 2 branches missed.">						if (affectedTimeSet.contains(curTime)) {</span>
<span class="nc" id="L3929">							ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="nc bnc" id="L3930" title="All 2 branches missed.">							if (tcList != null) {</span>
<span class="nc bnc" id="L3931" title="All 2 branches missed.">								for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3932">									TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc bnc" id="L3933" title="All 2 branches missed.">									if (tc.getQueueID().equals(rs.getID(Trace.DAYPOINTS + 2))) {</span>
<span class="nc" id="L3934">										float cv = rs.getFloat(i);</span>
<span class="nc" id="L3935">										tc.setTraceValue(Trace.CV, cv);</span>
										// VAR &amp; CV_VH =CV for Forecast or
										// REquired Timeseries
<span class="nc" id="L3938">										tc.setTraceValue(Trace.VAR, cv);</span>
<span class="nc" id="L3939">										tc.setTraceValue(Trace.CV_VH, cv);</span>
									}
<span class="nc" id="L3941">								}</span>
							}
						}
					}
<span class="nc" id="L3945">				}</span>
				// now add to tcArray
<span class="nc bnc" id="L3947" title="All 2 branches missed.">				for (Iterator it = affectedTimeSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3948">					Date chunkTime = (Date) it.next();</span>
<span class="nc" id="L3949">					lines = (ArrayList) sgTimeLines.get(chunkTime);</span>
<span class="nc" id="L3950">					ArrayList dataLines = new ArrayList(lines.size());</span>
<span class="nc bnc" id="L3951" title="All 2 branches missed.">					for (Iterator lineIt = lines.iterator(); lineIt.hasNext(); ) {</span>
<span class="nc" id="L3952">						dataLines.add(((TraceChunk) lineIt.next()).getTraceValues());</span>
					}
<span class="nc" id="L3954">					tcArray.add(combineRpt(types, chunkTime, dataLines));</span>
<span class="nc" id="L3955">				}</span>
			}
		}
<span class="nc" id="L3958">	}</span>

	/* this method is used for Combined Predicted Time series Calculation */
	private static TraceCube convert(JdmoRowset rs, TraceCube metaTC, Date start, Date end, ID mediaID,
									 boolean includeAllServiceGoalTypes, boolean isWhatIf, Map&lt;ID, SPQueue&gt; spqueuesBySID,
									 boolean isNoPhantom) throws Exception {
<span class="fc" id="L3964">		TraceCube cube = metaTC.newInstance(null, start, end, metaTC.getTraceTypes());</span>
<span class="fc bfc" id="L3965" title="All 4 branches covered.">		if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L3966">			cube = convertForPredictRequiredTC(rs, metaTC, start, end,</span>
					spqueuesBySID, cube, isNoPhantom);
		}
<span class="fc bfc" id="L3969" title="All 2 branches covered.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L3970">			convertForSGTC(rs, start, end, mediaID, includeAllServiceGoalTypes, cube);</span>
		}
<span class="fc" id="L3972">		cube.calcComputedTraceValues(TraceOperatorAdapter.getMediaIDForQueue(cube.getQueueID(), isWhatIf));</span>
<span class="fc" id="L3973">		return cube;</span>
	}

	/**
	 * @param rs
	 * @param start
	 * @param end
	 * @param mediaID
	 * @param includeAllServiceGoalTypes
	 * @param cube
	 * @throws JdmoException
	 */
	private static void convertForSGTC(JdmoRowset rs, Date start, Date end,
									   ID mediaID, boolean includeAllServiceGoalTypes, TraceCube cube)
			throws JdmoException {
<span class="fc bfc" id="L3988" title="All 2 branches covered.">		while (rs.next()) {</span>
<span class="fc" id="L3989">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="fc" id="L3990">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="fc" id="L3991">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>

<span class="fc" id="L3993">			List&lt;Integer&gt; valueList = new ArrayList&lt;Integer&gt;();</span>
<span class="fc" id="L3994">			List&lt;Short&gt; typeList = new ArrayList&lt;Short&gt;();</span>
<span class="fc bfc" id="L3995" title="All 2 branches covered.">			if (includeAllServiceGoalTypes) {</span>
<span class="fc" id="L3996">				typeList.add(Trace.PCA);</span>
<span class="fc" id="L3997">				valueList.add(TraceUtil.roundDouble(rs.getFloat(1)));</span>
<span class="pc bpc" id="L3998" title="1 of 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3999">					typeList.add(Trace.DEADLINE_TIME);</span>
				} else {
<span class="fc" id="L4001">					typeList.add(Trace.ASA);</span>
				}
<span class="fc" id="L4003">				valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
<span class="pc bpc" id="L4004" title="1 of 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="pc bpc" id="L4005" title="1 of 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L4006">					typeList.add(Trace.DEADLINE_TIME);</span>
<span class="nc" id="L4007">					valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
				}
<span class="fc" id="L4009">				typeList.add(Trace.PCA);</span>
<span class="fc" id="L4010">				valueList.add(TraceUtil.roundDouble(rs.getFloat(1)));</span>
			} else {
<span class="nc" id="L4012">				typeList.add(Trace.ASA);</span>
<span class="nc" id="L4013">				valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
			}
<span class="fc" id="L4015">			typeList.add(Trace.ABANDONMENT);</span>
<span class="fc" id="L4016">			valueList.add(TraceUtil.roundDouble(rs.getFloat(3)));</span>

			// typeList and valueList must be of the same length.
<span class="fc" id="L4019">			double[] values = new double[valueList.size()];</span>
<span class="fc" id="L4020">			short[] types = new short[valueList.size()];</span>
<span class="fc bfc" id="L4021" title="All 2 branches covered.">			for (int i = 0; i &lt; valueList.size(); ++i) {</span>
<span class="fc" id="L4022">				values[i] = valueList.get(i);</span>
<span class="fc" id="L4023">				types[i] = typeList.get(i);</span>
			}

<span class="pc bpc" id="L4026" title="1 of 2 branches missed.">			if (fallsIn(curTime, start, end)) {</span>
<span class="fc" id="L4027">				cube.setTraceValue(types, values, curTime);</span>
			}
			// Add 3 identical TCs, as DE service goal is per hour, report
			// is per 15 mins
<span class="fc bfc" id="L4031" title="All 2 branches covered.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="fc" id="L4032">				Date insPoint = new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS);</span>
<span class="pc bpc" id="L4033" title="1 of 2 branches missed.">				if (fallsIn(insPoint, start, end)) {</span>
<span class="fc" id="L4034">					cube.setTraceValue(types, values, insPoint);</span>
				}
			}
<span class="fc" id="L4037">		}</span>
<span class="fc" id="L4038">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param cube
	 * @return
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static TraceCube convertForPredictRequiredTC(JdmoRowset rs,
														 TraceCube metaTC, Date start, Date end,
														 Map&lt;ID, SPQueue&gt; spqueuesBySID, TraceCube cube, boolean isNoPhantom)
			throws JdmoException, BbmTimeSeriesException {
<span class="fc" id="L4055">		int typeLen = 0;</span>
<span class="fc" id="L4056">		Date prvEndOfDay = null;</span>
<span class="fc" id="L4057">		short[] types = metaTC.getTraceTypes();</span>
<span class="fc bfc" id="L4058" title="All 2 branches covered.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="fc bfc" id="L4059" title="All 2 branches covered.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="fc" id="L4060">				typeLen++;</span>
			}
		}
<span class="fc bfc" id="L4063" title="All 2 branches covered.">		while (rs.next()) {</span>
			/*
			 * Date lineStart = TimeZoneUtil.toDate(rs.getTimestamp(typeLen
			 * * Trace.DAYPOINTS + 1)); TimeZone tz =
			 * TimeZone.getTimeZone(rs.getString(typeLen * Trace.DAYPOINTS +
			 * 2));
			 */
<span class="fc" id="L4070">			DstObject dstObj = new DstObject();</span>
<span class="fc" id="L4071">			dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(getDETimeColumn(metaTC, false, isNoPhantom))); //&quot;DATETIME&quot;));</span>
<span class="fc" id="L4072">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="fc" id="L4073">			dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="fc" id="L4074">			dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="fc" id="L4075">			dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);// tested</span>
<span class="fc bfc" id="L4076" title="All 2 branches covered.">			if (dstObj.shouldSkip(start, end)) {</span>
<span class="fc" id="L4077">				continue;</span>
			}
<span class="fc bfc" id="L4079" title="All 2 branches covered.">			if (dstObj.needNewTraceCube) {</span>
<span class="fc" id="L4080">				cube = metaTC.newInstance(null, start, end, metaTC.getTraceTypes());</span>
			}
<span class="fc" id="L4082">			cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="fc" id="L4083">			ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="fc" id="L4084">			cube.setSPQueueSID(spQueueSID);</span>
<span class="fc" id="L4085">			SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="pc bpc" id="L4086" title="1 of 2 branches missed.">			if (spq != null) {</span>
<span class="nc" id="L4087">				cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="nc" id="L4088">				cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="nc" id="L4089">				cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
			}
<span class="fc" id="L4091">			Date insertPoint = dstObj.lineStart;</span>
<span class="fc" id="L4092">			boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
			// sameet
<span class="fc" id="L4094">			boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="fc" id="L4095">			int dstPoints = dstObj.dstPoints; // track points</span>
<span class="fc" id="L4096">			boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to</span>
			// track transition
<span class="fc bfc" id="L4098" title="All 2 branches covered.">			for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="fc bfc" id="L4099" title="All 2 branches covered.">				if (fallsIn(insertPoint, start, end)) {</span>
<span class="pc bpc" id="L4100" title="2 of 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="fc bfc" id="L4102" title="All 2 branches covered.">						if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="fc" id="L4104">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="pc bpc" id="L4105" title="1 of 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="fc" id="L4107">								i += dstIntv - 1;</span>
<span class="pc bpc" id="L4108" title="1 of 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>
<span class="fc" id="L4109">								continue;</span>
							}
							// add points
<span class="nc bnc" id="L4112" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L4113" title="All 2 branches missed.">								for (int t = 0; t &lt; typeLen; t++) {</span>
<span class="nc" id="L4114">									cube.setTraceValue(metaTC.getTraceTypes()[t], Trace.TRACENA, insertPoint, true);</span>
								}
<span class="nc" id="L4116">								insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L4117" title="All 2 branches missed.">								if (insertPoint.after(end)) {</span>
<span class="nc" id="L4118">									break;</span>
								}
							}
						}
					}
<span class="fc" id="L4123">					double[] values = new double[types.length];</span>
<span class="fc" id="L4124">					int resultSetCounter = 1; // this is done to omit the</span>
					// comupted types
<span class="fc bfc" id="L4126" title="All 2 branches covered.">					for (int j = 0; j &lt; types.length; j++) {</span>
<span class="fc bfc" id="L4127" title="All 2 branches covered.">						if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="fc" id="L4128">							values[j] = rs.getFloat(typeLen * i + resultSetCounter++);</span>
						}
					}
<span class="fc" id="L4131">					cube.setTraceValue(metaTC.getTraceTypes(), values, insertPoint);</span>
				}
<span class="pc bpc" id="L4133" title="1 of 4 branches missed.">				if (tfrIn || tfrOut) {</span>
<span class="fc" id="L4134">					prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
				}
<span class="fc" id="L4136">				insertPoint.setTime(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
			// prvEndOfDay = new Date(lineStart.getTime() +
			// Trace.INTERVAL_IN_MILLIS * Trace.DAYPOINTS);
<span class="fc" id="L4140">			prvEndOfDay = insertPoint;</span>
<span class="fc" id="L4141">		}</span>
<span class="fc" id="L4142">		return cube;</span>
	}

	private static void convert(JdmoRowset rs, TraceCube metaTC, List&lt;TraceChunk&gt; tcArray, Date start, Date end, ID mediaID)
			throws JdmoException {
		// int typeLen = metaTC.getTraceTypes().length;
<span class="nc" id="L4148">		int typeLen = 0;</span>
<span class="nc" id="L4149">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L4150" title="All 2 branches missed.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L4151" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L4152">				typeLen++;</span>
			}
		}
<span class="nc bnc" id="L4155" title="All 4 branches missed.">		if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L4156">			boolean RTC = metaTC instanceof RequireTraceCube;</span>
<span class="nc" id="L4157">			Date prvEndOfDay = null;</span>
			// predict is always precombined just load
<span class="nc bnc" id="L4159" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4160">				DstObject dstObj = new DstObject();</span>
<span class="nc" id="L4161">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L4162">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L4163">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L4164">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L4165">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);// used</span>
				// in
				// report
				// dump
				// logic
<span class="nc bnc" id="L4170" title="All 2 branches missed.">				if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L4171">					continue;</span>
				}
<span class="nc bnc" id="L4173" title="All 2 branches missed.">				if (dstObj.needNewTraceCube) {</span>
<span class="nc" id="L4174">					tcArray.clear();// Flush the contents of the tcarray since</span>
					// this is the real start line.
				}
<span class="nc" id="L4177">				Date insertPoint = dstObj.lineStart;</span>
<span class="nc" id="L4178">				boolean tfrIn = dstObj.tfrIn; // 92 points day, need shrink</span>
				// sameet
<span class="nc" id="L4180">				boolean tfrOut = dstObj.tfrOut; // 100 points day, need expand</span>
<span class="nc" id="L4181">				int dstPoints = dstObj.dstPoints; // track points</span>
<span class="nc" id="L4182">				boolean prvDSTFlag = dstObj.prvDSTFlag; // temp variable to</span>
				// track transition
				/*
				 * Date curTime =
				 * TimeZoneUtil.toDate(rs.getTimestamp(typeLen*Trace.DAYPOINTS +
				 * 1)); TimeZone tz =
				 * TimeZone.getTimeZone(rs.getString(typeLen*Trace.DAYPOINTS +
				 * 2)); boolean tfrIn = false; // 92 points day, need shrink
				 * sameet commented boolean tfrOut = false; // 100 points day,
				 * need expand int dstPoints = tz.getDSTSavings(); // track
				 * points boolean prvDSTFlag = false; // temp variable to track
				 * transition if (tz.useDaylightTime()) { prvDSTFlag =
				 * tz.inDaylightTime(curTime); Date endOfDay = new
				 * Date(curTime.getTime() +
				 * TimeZoneUtil.DAY_IN_MILLISECONDS_LONG-1); if (prvDSTFlag) {
				 * if (!tz.inDaylightTime(endOfDay)) { tfrOut = true; } } else {
				 * if (tz.inDaylightTime(endOfDay)) { tfrIn = true; } } } Date
				 * insertPoint = new Date(curTime.getTime()); // Special
				 * handling needed as DE stores wrong Start Time if (prvEndOfDay
				 * != null &amp;&amp; curTime.before(prvEndOfDay)) { // overlap with
				 * previous day, need skip DST points insertPoint = prvEndOfDay;
				 * for (int i=dstPoints/(int)Trace.INTERVAL_IN_MILLIS;
				 * i&lt;Trace.DAYPOINTS; i++) { TraceChunk tc = new
				 * TraceChunk(null, insertPoint); if (RTC) {
				 * tc.setTraceValue(Trace.FTE, rs.getFloat(typeLen*i+1)); } else
				 * { tc.setTraceValue(Trace.PCA, rs.getFloat(typeLen*i+1));
				 * tc.setTraceValue(Trace.ASA, rs.getFloat(typeLen*i+2));
				 * tc.setTraceValue(Trace.ABANDONMENT,
				 * rs.getFloat(typeLen*i+3)); tc.setTraceValue(Trace.BACKLOG,
				 * rs.getFloat(typeLen*i+4)); tc.setTraceValue(Trace.STAFFING,
				 * rs.getFloat(typeLen*i+5)); tc.setTraceValue(Trace.OCCUPANCY,
				 * rs.getFloat(typeLen*i+6)); tc.setTraceValue(Trace.FTE,
				 * rs.getFloat(typeLen*i+7)); tc.setTraceValue(Trace.DIALS,
				 * rs.getFloat(typeLen*i+8)); } tcArray.add(tc); insertPoint =
				 * new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS); }
				 * } else {
				 */
<span class="nc bnc" id="L4219" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L4220" title="All 2 branches missed.">					if (fallsIn(insertPoint, start, end)) {</span>
<span class="nc bnc" id="L4221" title="All 6 branches missed.">						if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
							// if transition will happen on this line
<span class="nc bnc" id="L4223" title="All 2 branches missed.">							if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
								// from this point, there is dst transition
<span class="nc" id="L4225">								int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L4226" title="All 2 branches missed.">								if (tfrIn) {</span>
									// skip points
<span class="nc" id="L4228">									i += dstIntv - 1;</span>
<span class="nc bnc" id="L4229" title="All 2 branches missed.">									prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L4230">									continue;</span>
								}
								// add points
<span class="nc bnc" id="L4233" title="All 2 branches missed.">								for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L4234">									TraceChunk tc = new TraceChunk(null, insertPoint);</span>
<span class="nc bnc" id="L4235" title="All 2 branches missed.">									if (RTC) {</span>
<span class="nc" id="L4236">										tc.setTraceValue(Trace.FTE, Trace.TRACENA);</span>
									} else {
<span class="nc" id="L4238">										tc.setTraceValue(Trace.PCA, Trace.TRACENA);</span>
<span class="nc" id="L4239">										tc.setTraceValue(Trace.ASA, Trace.TRACENA);</span>
<span class="nc" id="L4240">										tc.setTraceValue(Trace.ABANDONMENT, Trace.TRACENA);</span>
<span class="nc" id="L4241">										tc.setTraceValue(Trace.BACKLOG, Trace.TRACENA);</span>
<span class="nc" id="L4242">										tc.setTraceValue(Trace.STAFFING, Trace.TRACENA);</span>
<span class="nc" id="L4243">										tc.setTraceValue(Trace.OCCUPANCY, Trace.TRACENA);</span>
<span class="nc" id="L4244">										tc.setTraceValue(Trace.FTE, Trace.TRACENA);</span>
<span class="nc" id="L4245">										tc.setTraceValue(Trace.DIALS, Trace.TRACENA);</span>
<span class="nc" id="L4246">										tc.setTraceValue(Trace.CONNECTS, Trace.TRACENA);</span>
<span class="nc" id="L4247">										tc.setTraceValue(Trace.ASTAFFING, Trace.TRACENA);</span>
<span class="nc" id="L4248">										tc.setTraceValue(Trace.AFTE, Trace.TRACENA);</span>
<span class="nc" id="L4249">										tc.setTraceValue(Trace.NETSTAFFING, Trace.TRACENA);</span>
									}
<span class="nc" id="L4251">									tcArray.add(tc);</span>
<span class="nc" id="L4252">									insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
								}
							}
						}
<span class="nc" id="L4256">						TraceChunk tc = new TraceChunk(null, insertPoint);</span>
<span class="nc bnc" id="L4257" title="All 2 branches missed.">						if (RTC) {</span>
<span class="nc" id="L4258">							tc.setTraceValue(Trace.FTE, rs.getFloat(typeLen * i + 1));</span>
						} else {
<span class="nc" id="L4260">							tc.setTraceValue(Trace.PCA, rs.getFloat(typeLen * i + 1));</span>
<span class="nc" id="L4261">							tc.setTraceValue(Trace.ASA, rs.getFloat(typeLen * i + 2));</span>
<span class="nc" id="L4262">							tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(typeLen * i + 3));</span>
<span class="nc" id="L4263">							tc.setTraceValue(Trace.BACKLOG, rs.getFloat(typeLen * i + 4));</span>
<span class="nc" id="L4264">							tc.setTraceValue(Trace.STAFFING, rs.getFloat(typeLen * i + 5));</span>
<span class="nc" id="L4265">							tc.setTraceValue(Trace.OCCUPANCY, rs.getFloat(typeLen * i + 6));</span>
<span class="nc" id="L4266">							tc.setTraceValue(Trace.FTE, rs.getFloat(typeLen * i + 7));</span>
<span class="nc" id="L4267">							tc.setTraceValue(Trace.DIALS, rs.getFloat(typeLen * i + 8));</span>
						}
<span class="nc" id="L4269">						tcArray.add(tc);</span>
<span class="nc bnc" id="L4270" title="All 2 branches missed.">					} else if (insertPoint.after(end)) {</span>
<span class="nc" id="L4271">						break;</span>
					}
<span class="nc bnc" id="L4273" title="All 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L4274">						prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
					}
<span class="nc" id="L4276">					insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
<span class="nc" id="L4278">				prvEndOfDay = insertPoint;</span>
<span class="nc" id="L4279">			}</span>
		}
<span class="nc bnc" id="L4281" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc bnc" id="L4282" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4283">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L4284">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="nc" id="L4285">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>
				// hack for ops release. set PCAType to false to always show SL.
				// typeASAEnabled = false;
<span class="nc" id="L4288">				TraceChunk sgTC = new TraceChunk(null, curTime);</span>
<span class="nc bnc" id="L4289" title="All 2 branches missed.">				if (!typeASAEnabled) {</span>
<span class="nc" id="L4290">					sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
				}
<span class="nc bnc" id="L4292" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L4293">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L4295">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc" id="L4297">				sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L4298">				tcArray.add(sgTC);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report
				// is per 15 mins
<span class="nc bnc" id="L4301" title="All 2 branches missed.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L4302">					TraceChunk tc1 = new TraceChunk(null, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc bnc" id="L4303" title="All 2 branches missed.">					if (!typeASAEnabled) {</span>
<span class="nc" id="L4304">						tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L4305" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L4306">							tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L4309">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L4311">					tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc" id="L4312">					tcArray.add(tc1);</span>
				}
<span class="nc" id="L4314">			}</span>
		}
<span class="nc" id="L4316">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param queueID
	 * @param areatype
	 * @param start
	 * @param end
	 */
	public static void createAudit(ID campaignID, ID mediaID, ID queueID, short areatype, Date start, Date end)
			throws JdmoException {
<span class="nc" id="L4328">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4330">			HashMap map = new HashMap();</span>
<span class="nc bnc" id="L4331" title="All 2 branches missed.">			if (campaignID != null) {</span>
<span class="nc" id="L4332">				map.put(&quot;CAMPAIGNID&quot;, campaignID);</span>
			}
<span class="nc bnc" id="L4334" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L4335">				map.put(&quot;MEDIAID&quot;, mediaID);</span>
			}
<span class="nc bnc" id="L4337" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4338">				map.put(&quot;QUEUEID&quot;, queueID);</span>
			}
<span class="nc" id="L4340">			map.put(&quot;AREATYPE&quot;, NumberFactory.newShort(areatype));</span>
<span class="nc" id="L4341">			map.put(&quot;STARTTIME&quot;, start);</span>
<span class="nc" id="L4342">			map.put(&quot;ENDTIME&quot;, end);</span>
<span class="nc" id="L4343">			map.put(&quot;LASTMODIFIEDAT&quot;, new Date());</span>
<span class="nc" id="L4344">			jdmo.addBatchInsert(TimeSeriesAuditTableName, map);</span>
<span class="nc" id="L4345">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L4347">			jdmo.cleanUp();</span>
<span class="nc" id="L4348">		}</span>
<span class="nc" id="L4349">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param queueID
	 * @param areatype
	 * @param start
	 * @param end
	 * @param lastCheck
	 */
	public static boolean hasAudit(ID campaignID, ID mediaID, ID queueID, Date start, Date end, Date lastCheck)
			throws JdmoException {
<span class="nc" id="L4362">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4364">			StringBuffer findAudit = new StringBuffer(128);</span>
<span class="nc" id="L4365">			findAudit.append(&quot;select AREATYPE from &quot;).append(TimeSeriesAuditTableName).append(&quot; where &quot;);</span>
<span class="nc bnc" id="L4366" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4367">				findAudit.append(&quot;QUEUEID=&quot;).append(queueID).append(&quot; and &quot;);</span>
<span class="nc bnc" id="L4368" title="All 2 branches missed.">			} else if (mediaID != null) {</span>
<span class="nc" id="L4369">				findAudit.append(&quot;MEDIAID=&quot;).append(mediaID).append(&quot; and &quot;);</span>
			} else {
<span class="nc" id="L4371">				findAudit.append(&quot;CAMPAIGNID=&quot;).append(campaignID).append(&quot; and &quot;);</span>
			}
<span class="nc" id="L4373">			findAudit.append(&quot;STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;' and ENDTIME&gt;='&quot;)</span>
<span class="nc" id="L4374">					.append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
<span class="nc bnc" id="L4375" title="All 2 branches missed.">			if (lastCheck != null) {</span>
<span class="nc" id="L4376">				findAudit.append(&quot; and LASTMODIFIEDAT&gt;='&quot;).append(JdmoUtil.formatDBString(lastCheck)).append(&quot;'&quot;);</span>
			}
<span class="nc" id="L4378">			JdmoRowset rs = jdmo.createRowset(findAudit.toString());</span>
<span class="nc bnc" id="L4379" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L4380">				return true;</span>
			}
<span class="nc" id="L4382">			return false;</span>
		} finally {
<span class="nc" id="L4384">			jdmo.cleanUp();</span>
		}
	}

	public static boolean[] getAudit(ID campaignID, ID mediaID, ID queueID, Date start, Date end) throws JdmoException {
<span class="nc" id="L4389">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4391">			StringBuffer sb = new StringBuffer(&quot;select distinct AREATYPE from TRACETRACK where &quot;);</span>
<span class="nc bnc" id="L4392" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4393">				sb.append(&quot;QUEUEID=&quot;).append(queueID);</span>
			} else {
<span class="nc bnc" id="L4395" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L4396">					sb.append(&quot;MEDIAID=&quot;).append(mediaID).append(&quot; and &quot;);</span>
				}
<span class="nc" id="L4398">				sb.append(&quot;CAMPAIGNID=&quot;).append(campaignID);</span>
			}
<span class="nc" id="L4400">			sb.append(&quot; and STARTTIME&lt;=&quot;).append(JdmoUtil.formatDBString(end)).append(&quot; and ENDTIME&gt;=&quot;)</span>
<span class="nc" id="L4401">					.append(JdmoUtil.formatDBString(start));</span>
<span class="nc" id="L4402">			JdmoRowset rs = jdmo.createRowset(sb.toString());</span>
<span class="nc" id="L4403">			boolean[] changedArea = new boolean[TraceUtil.MAXAREA];</span>
<span class="nc" id="L4404">			boolean changed = false;</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4406">				short type = rs.getShort(1);</span>
<span class="nc bnc" id="L4407" title="All 2 branches missed.">				if (type &lt; TraceUtil.MAXAREA) {</span>
<span class="nc" id="L4408">					changed = true;</span>
<span class="nc" id="L4409">					changedArea[rs.getShort(1)] = true;</span>
				}
<span class="nc" id="L4411">			}</span>
<span class="nc bnc" id="L4412" title="All 2 branches missed.">			if (!changed) {</span>
<span class="nc" id="L4413">				return null;</span>
			}
<span class="nc" id="L4415">			return changedArea;</span>
		} finally {
<span class="nc" id="L4417">			jdmo.cleanUp();</span>
		}
	}

	public static Collection getCombinedQueueStaffing(ID campaignID, ID mediaID, Set spSet, Date start, Date end)
			throws JdmoException {
<span class="nc" id="L4423">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4425">			JdmoRowset rs = jdmo.createRowset(getCombinedQueueStaffingStmt(campaignID, mediaID, spSet, start, end, null,</span>
					jdmo));
<span class="nc" id="L4427">			ArrayList stfChunkCol = new ArrayList();</span>
<span class="nc bnc" id="L4428" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4429">				CombinedQueueStaffing stf = new CombinedQueueStaffing();</span>
<span class="nc" id="L4430">				stf.setTimeInterval(rs.getTimestamp(1));</span>
<span class="nc" id="L4431">				stf.setStaffing(rs.getFloat(2));</span>
<span class="nc" id="L4432">				stfChunkCol.add(stf);</span>
<span class="nc" id="L4433">			}</span>
<span class="nc" id="L4434">			return stfChunkCol;</span>
		} finally {
<span class="nc" id="L4436">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueStaffingStmt(ID campaignID, ID mediaID, Set spSet, Date start, Date end,
													   Date lastUpdate, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L4442">		StringBuffer pStmt = new StringBuffer(150);</span>
<span class="nc" id="L4443">		pStmt.append(&quot;select A.TIMEINTERVAL, A.STAFFING from SPCOMBINEDQUEUESTAFFING&quot;);</span>
<span class="nc" id="L4444">		pStmt.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;).append(</span>
<span class="nc" id="L4445">				jdmo.createInClause(spSet));</span>
<span class="nc" id="L4446">		pStmt.append(&quot; and QUEUEID is null and CAMPAIGNID=(select ID from CAMPAIGN where SID=&quot;).append(campaignID)</span>
<span class="nc" id="L4447">				.append(&quot;)&quot;);</span>
<span class="nc bnc" id="L4448" title="All 2 branches missed.">		if (mediaID != null) {</span>
<span class="nc" id="L4449">			pStmt.append(&quot; and MEDIAID=(select ID from MEDIA where SID=&quot;).append(mediaID).append(&quot;)&quot;);</span>
		} else {
<span class="nc" id="L4451">			pStmt.append(&quot; and MEDIAID is null&quot;);</span>
		}
<span class="nc bnc" id="L4453" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L4454">			pStmt.append(&quot; and A.TIMEINTERVAL&gt;='&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4456" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L4457">			pStmt.append(&quot; and A.TIMEINTERVAL&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4459" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L4460">			pStmt.append(&quot; and A.LASTMODIFIEDAT&gt;'&quot;).append(JdmoUtil.formatDBString(lastUpdate)).append(&quot;'&quot;);</span>
		}
<span class="nc" id="L4462">		return pStmt.toString();</span>
	}

	public static HashMap getCombinedQueueStaffing(ID campaignID, ID mediaID, Date start, Date end, Date lastUpdate)
			throws JdmoException {
<span class="nc" id="L4467">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4469">			JdmoRowset rs = jdmo</span>
<span class="nc" id="L4470">					.createRowset(getCombinedQueueStaffingStmt(campaignID, mediaID, start, end, lastUpdate, jdmo));</span>
<span class="nc" id="L4471">			HashMap stfMap = new HashMap();</span>
<span class="nc bnc" id="L4472" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4473">				CombinedQueueStaffing stf = new CombinedQueueStaffing();</span>
<span class="nc" id="L4474">				stf.setTimeInterval(rs.getTimestamp(1));</span>
<span class="nc" id="L4475">				stf.setStaffing(rs.getFloat(2));</span>
<span class="nc" id="L4476">				stfMap.put(stf.getTimeInterval(), stf);</span>
<span class="nc" id="L4477">			}</span>
<span class="nc" id="L4478">			return stfMap;</span>
		} finally {
<span class="nc" id="L4480">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueStaffingStmt(ID campaignID, ID mediaID, Date start, Date end, Date lastUpdate,
													   Jdmo jdmo) throws JdmoException {
<span class="nc" id="L4486">		StringBuffer pStmt = new StringBuffer(150);</span>
<span class="nc" id="L4487">		pStmt.append(&quot;select A.TIMEINTERVAL, A.STAFFING from SPCOMBINEDQUEUESTAFFING&quot;);</span>
<span class="nc" id="L4488">		pStmt.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID &quot;);</span>
<span class="nc" id="L4489">		pStmt.append(&quot; and B.QUEUEID is null and C.CAMPAIGNID=(select ID from CAMPAIGN where SID=&quot;).append(campaignID)</span>
<span class="nc" id="L4490">				.append(&quot;)&quot;);</span>
		// Sameet Bug #81134 10/04/2005
		// Media Id should not be null and -10 (-10 represents no Media) for
		// COMB-COMB QUEUES
<span class="nc bnc" id="L4494" title="All 4 branches missed.">		if (mediaID != null &amp;&amp; mediaID.toInt() != -10) {</span>
<span class="nc" id="L4495">			pStmt.append(&quot; and B.MEDIAID=(select ID from MEDIA where SID=&quot;).append(mediaID).append(&quot;)&quot;);</span>
		} else {
<span class="nc" id="L4497">			pStmt.append(&quot; and B.MEDIAID is null&quot;);</span>
		}
<span class="nc bnc" id="L4499" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L4500">			pStmt.append(&quot; and A.TIMEINTERVAL&gt;='&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4502" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L4503">			pStmt.append(&quot; and A.TIMEINTERVAL&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4505" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L4506">			pStmt.append(&quot; and (A.LASTMODIFIEDAT is null or A.LASTMODIFIEDAT&gt;'&quot;).append(JdmoUtil.formatDBString(lastUpdate))</span>
<span class="nc" id="L4507">					.append(&quot;')&quot;);</span>
		}
<span class="nc" id="L4509">		return pStmt.toString();</span>
	}

	public static DstObject getDSTFix(DstObject dstObject, TimeZone tz, Date prvEndOfDay, Date start, Date end) {
<span class="fc" id="L4513">		printDebugInfo();</span>
		try {
<span class="fc" id="L4515">			dstObject.dstPoints = tz.getDSTSavings();</span>

			// temp variable to track transition
<span class="fc" id="L4518">			dstObject.prvDSTFlag = false;</span>

			// this is the computed end of the day. (start + 24 hrs)
<span class="fc" id="L4521">			dstObject.endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG - 1);</span>

<span class="fc" id="L4523">			boolean isDSTTransitionSPWeekOut = false;</span>
<span class="fc" id="L4524">			boolean isDSTTransitionSPWeekIn = false;</span>
<span class="pc bpc" id="L4525" title="1 of 2 branches missed.">			if (tz.useDaylightTime()) {</span>
<span class="pc bpc" id="L4526" title="2 of 4 branches missed.">				if (dstObject.spStartDate == null || dstObject.spEndDate == null) {</span>
<span class="nc" id="L4527">					m_cat.info(&quot;.spStartDate ==null || spEndDate==null&quot;);</span>
<span class="nc" id="L4528">					throw new Exception(&quot;TimeSeriesDAO getDSTFix() spStartDate ==null || spEndDate==null&quot;);</span>
				}
<span class="fc bfc" id="L4530" title="All 2 branches covered.">				isDSTTransitionSPWeekOut = (tz.inDaylightTime(dstObject.spStartDate) &amp;&amp; !tz</span>
<span class="pc bpc" id="L4531" title="1 of 2 branches missed.">						.inDaylightTime(dstObject.spEndDate));</span>
<span class="fc bfc" id="L4532" title="All 2 branches covered.">				isDSTTransitionSPWeekIn = (!tz.inDaylightTime(dstObject.spStartDate) &amp;&amp; tz</span>
<span class="fc bfc" id="L4533" title="All 2 branches covered.">						.inDaylightTime(dstObject.spEndDate));</span>

<span class="fc" id="L4535">				dstObject.prvDSTFlag = tz.inDaylightTime(dstObject.lineStart);</span>
<span class="pc bpc" id="L4536" title="1 of 4 branches missed.">				dstObject.tfrOut = dstObject.prvDSTFlag &amp;&amp; !tz.inDaylightTime(dstObject.endOfDay);</span>
<span class="fc bfc" id="L4537" title="All 4 branches covered.">				dstObject.tfrIn = !dstObject.prvDSTFlag &amp;&amp; tz.inDaylightTime(dstObject.endOfDay);</span>

<span class="fc" id="L4539">				Date beforeStOfDay = new Date(dstObject.lineStart.getTime() - 1);</span>
<span class="pc bpc" id="L4540" title="1 of 4 branches missed.">				dstObject.tfrInBeforeStartOfday = dstObject.prvDSTFlag &amp;&amp; !tz.inDaylightTime(beforeStOfDay);</span>
<span class="pc bpc" id="L4541" title="1 of 4 branches missed.">				dstObject.tfrOutBeforeStartOfday = !dstObject.prvDSTFlag &amp;&amp; tz.inDaylightTime(beforeStOfDay);</span>

<span class="pc bpc" id="L4543" title="2 of 4 branches missed.">				if (dstObject.tfrInBeforeStartOfday || dstObject.tfrOutBeforeStartOfday) {</span>
<span class="nc" id="L4544">					dstObject.prvDSTFlag = tz.inDaylightTime(beforeStOfDay);</span>
				}

				// need to calculate real end of day after DST transition. In April, shrink by 4 points, its only 23 hr day.
<span class="fc bfc" id="L4548" title="All 2 branches covered.">				if (dstObject.tfrIn) {</span>
<span class="fc" id="L4549">					dstObject.endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG</span>
							- dstObject.dstPoints - 1);

					// Skip this day completely if the start and end of the day do not fall in the start and end of SP.
<span class="pc bpc" id="L4553" title="3 of 4 branches missed.">					if (!fallsIn(dstObject.lineStart, start, end) &amp;&amp; !fallsIn(dstObject.endOfDay, start, end)) {</span>
<span class="nc bnc" id="L4554" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4555">							m_cat.debug(&quot;DST transition SP; Skipping this day; endOfDay=&quot; + dstObject.endOfDay + &quot;:SP start&quot;</span>
									+ start);
						}
<span class="nc" id="L4558">						dstObject.skipLoop = true;</span>
<span class="nc" id="L4559">						return dstObject;</span>
					}
				}
			}

<span class="fc bfc" id="L4564" title="All 4 branches covered.">			if (dstObject.lineStart.before(start) &amp;&amp; !fallsIn(start, dstObject.lineStart, dstObject.endOfDay)) {</span>
<span class="pc bpc" id="L4565" title="1 of 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L4566">					m_cat.debug(&quot;Around DST transition SP; skipping this day totally dstObject.lineStart=&quot;</span>
							+ dstObject.lineStart + &quot; SP start=&quot; + start);
				}
<span class="fc" id="L4569">				dstObject.skipLoop = true;</span>
<span class="fc" id="L4570">				return dstObject;</span>

<span class="fc bfc" id="L4572" title="All 2 branches covered.">			} else if (dstObject.lineStart.equals(start)) {</span>
				// Ignore all the data Collected before this time since it was collected for wrong day
<span class="fc" id="L4574">				dstObject.needNewTraceCube = true;</span>
<span class="fc" id="L4575">				prvEndOfDay = null;</span>
			}

<span class="fc" id="L4578">			fixLineStartDueToThickClientWeirdness(dstObject, tz, isDSTTransitionSPWeekOut, isDSTTransitionSPWeekIn);</span>

<span class="nc" id="L4580">		} catch (Exception e) {</span>
<span class="nc" id="L4581">			e.printStackTrace();</span>
<span class="fc" id="L4582">		}</span>
<span class="fc" id="L4583">		return fixDstObjectForPartialTransitions(dstObject, tz);</span>
	}

	private static DstObject fixDstObjectForPartialTransitions(DstObject dstObject, TimeZone tz) {

<span class="fc" id="L4588">		Calendar lineStartCal = Calendar.getInstance(tz);</span>
<span class="fc" id="L4589">		lineStartCal.setTime(dstObject.lineStart);</span>
<span class="fc" id="L4590">		int minutes = lineStartCal.get(Calendar.MINUTE);</span>
<span class="pc bpc" id="L4591" title="1 of 2 branches missed.">		if (minutes &gt; 0) {</span>

<span class="nc" id="L4593">			Date endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc bnc" id="L4594" title="All 2 branches missed.">			if (DSTConversionUtil.hourContainsPartialDaylightTransition(endOfDay, tz)) {</span>
				//final hour of the day
<span class="nc" id="L4596">				dstObject.dstPoints = minutes * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc bnc" id="L4597" title="All 2 branches missed.">			} else if (DSTConversionUtil.hourContainsPartialDaylightTransition(dstObject.lineStart, tz)) {</span>
				//first hour of the day
<span class="nc" id="L4599">				dstObject.dstPoints = (60 - minutes) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L4600">				dstObject.prvDSTFlag = false;</span>
<span class="nc" id="L4601">				dstObject.tfrOut = false;</span>
<span class="nc" id="L4602">				dstObject.tfrIn = true;</span>
<span class="nc" id="L4603">				dstObject.isLineStartInPartialTransition = true;</span>
			}
		}
<span class="fc" id="L4606">		return dstObject;</span>
	}

	/**
	 * If we are in a transition week, the C++ F&amp;S thick client will not put the correct start
	 * times in the days following a DST transition for the remainder of that week.
	 * Instead, it will continue to put start times as if there was no DST transition.
	 * The data that is in that row represents data from the day boundary, but the start time
	 * will not reflect that. We need to check for that scenario.
	 * First, check that a transition happens in the SP and has already occurred.
	 */
	private static void fixLineStartDueToThickClientWeirdness(DstObject dstObject, TimeZone tz,
				boolean isDSTTransitionSPWeekOut, boolean isDSTTransitionSPWeekIn) {
<span class="fc bfc" id="L4619" title="All 2 branches covered.">		if (isDSTTrransitioning(dstObject, tz, isDSTTransitionSPWeekOut, isDSTTransitionSPWeekIn)) {</span>
<span class="fc" id="L4620">            Calendar cal = Calendar.getInstance(tz);</span>
<span class="fc" id="L4621">            cal.setTime(dstObject.spEndDate);</span>
<span class="fc" id="L4622">            int spEndHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L4623">            int spEndMinute = cal.get(Calendar.MINUTE);</span>

<span class="fc" id="L4625">            cal = Calendar.getInstance(tz);</span>
<span class="fc" id="L4626">            cal.setTime(dstObject.lineStart);</span>
<span class="fc" id="L4627">            int lineStartHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L4628">            int lineStartMinute = cal.get(Calendar.MINUTE);</span>

            // If the wall clock hour or seconds do not match, it probably
            // is because F&amp;S didn't apply the DST amount. Shift the times
            // by the DST amount
<span class="pc bpc" id="L4633" title="2 of 4 branches missed.">            if ((spEndHour != lineStartHour) || (spEndMinute != lineStartMinute)) {</span>
<span class="nc bnc" id="L4634" title="All 2 branches missed.">                if (isDSTTransitionSPWeekOut) {</span>
<span class="nc" id="L4635">                    cal.add(Calendar.MILLISECOND, tz.getDSTSavings());</span>
<span class="nc bnc" id="L4636" title="All 2 branches missed.">                } else if (isDSTTransitionSPWeekIn) {</span>
<span class="nc" id="L4637">                    cal.add(Calendar.MILLISECOND, -tz.getDSTSavings());</span>
                }
                // Check that we actually solved the issue.
<span class="nc bnc" id="L4640" title="All 4 branches missed.">                if ((spEndHour == cal.get(Calendar.HOUR_OF_DAY)) &amp;&amp; (spEndMinute == cal.get(Calendar.MINUTE))) {</span>
<span class="nc" id="L4641">                    dstObject.lineStart = new Date(cal.getTime().getTime());</span>
                } else {
<span class="nc" id="L4643">					logWeirdness(dstObject);</span>
				}
            }
        }
<span class="fc" id="L4647">	}</span>

	private static boolean isDSTTrransitioning(DstObject dstObject, TimeZone tz, 
											   boolean isDSTTransitionSPWeekOut, boolean isDSTTransitionSPWeekIn) {
<span class="pc bpc" id="L4651" title="5 of 6 branches missed.">		boolean condition1 = isDSTTransitionSPWeekOut &amp;&amp; (!tz.inDaylightTime(dstObject.lineStart) &amp;&amp; !dstObject.tfrOutBeforeStartOfday);</span>
<span class="pc bpc" id="L4652" title="1 of 6 branches missed.">		boolean condition2 = isDSTTransitionSPWeekIn &amp;&amp; (tz.inDaylightTime(dstObject.lineStart) &amp;&amp; !dstObject.tfrInBeforeStartOfday);</span>
<span class="pc bpc" id="L4653" title="1 of 4 branches missed.">		return (condition1 || condition2);</span>
	}

	private static void logWeirdness(DstObject dstObject) {
		// The issue was something other than the F&amp;S client
		// neglecting to use the DST offset for the start
		// timestamp, so log it.
<span class="nc" id="L4660">		SimpleDateFormat timestampFormat = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;);</span>
<span class="nc" id="L4661">		timestampFormat.setTimeZone(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L4662">		SimpleDateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm:ssZ&quot;);</span>
<span class="nc" id="L4663">		timeFormat.setTimeZone(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L4664">		m_cat.l7dWarn(</span>
                BbmEjbLogBundleKey.UNEXPECTED_TIME_SERIES_DATETIME,
<span class="nc" id="L4666">                new Object[] { timestampFormat.format(dstObject.lineStart),</span>
<span class="nc" id="L4667">                        timeFormat.format(dstObject.spEndDate) });</span>
<span class="nc" id="L4668">	}</span>

	private static void printDebugInfo() {
		// This is debug for Devp purposes only
		if (false &amp;&amp; m_cat.isDebugEnabled()) {
			StringBuffer sbuff = new StringBuffer();
			try {
				throw new Exception(&quot;TimeSeriesDAO getDSTFix() TRACE&quot;);
			} catch (Exception e) {
				StackTraceElement elem[] = e.getStackTrace();
				for (int i = 0; i &lt; (elem.length &gt; 3 ? 3 : elem.length); i++) {
					if (i == 1) {
						sbuff.append(&quot;Caller for getDSTFix[&quot;).append(elem[i].getLineNumber()).append(&quot;]&quot;)
								.append(elem[i].getMethodName());
						m_cat.debug(sbuff);
						break;
					}
				}
			}
		}
<span class="fc" id="L4688">	}</span>

<span class="pc" id="L4690">	public static class DstObject {</span>
		/* start of Out Variables */
<span class="fc" id="L4692">		boolean tfrInBeforeStartOfday = false;</span>
<span class="fc" id="L4693">		boolean tfrOutBeforeStartOfday = false;</span>
<span class="fc" id="L4694">		boolean tfrIn = false; // 92 points/day, need to shrink Apr</span>
<span class="fc" id="L4695">		boolean tfrOut = false; // 100 points/day , need to expand Oct</span>
<span class="fc" id="L4696">		int dstPoints = 0; // track points</span>
<span class="fc" id="L4697">		boolean prvDSTFlag = false; // temp variable to track transition</span>
<span class="fc" id="L4698">		Date endOfDay = null;// this is the computed end of the day start +24</span>
								// hrs
<span class="fc" id="L4700">		boolean skipLoop = false; // this is required so that we skip one loop</span>
									// when loop through the request Object
<span class="fc" id="L4702">		boolean needNewTraceCube = false; // Indicates if new traceCube needs to</span>
											// initialized
		/* start of IN / OUT Variables */
<span class="fc" id="L4705">		Date lineStart = null;</span>
<span class="fc" id="L4706">		Date spStartDate = null;</span>
<span class="fc" id="L4707">		Date spEndDate = null;</span>

<span class="fc" id="L4709">		boolean isLineStartInPartialTransition = false;</span>

		private long getDayDurationInMilliseconds() {

<span class="fc" id="L4713">			long duration = TimeUnit.DAYS.toMillis(1);</span>
<span class="pc bpc" id="L4714" title="1 of 2 branches missed.">			if (tfrOut) {</span>
<span class="nc" id="L4715">				duration += dstPoints;</span>
			}
<span class="fc bfc" id="L4717" title="All 2 branches covered.">			if (tfrIn) {</span>
<span class="fc" id="L4718">				duration -= dstPoints;</span>
			}
<span class="fc" id="L4720">			return duration;</span>
		}

		/**
		 * 
		 * @param dayStart - start of day
		 * @param rangeStart - Inclusive start of the range to check
		 * @param rangeEnd - Exclusive end of the range to check
		 * @return  true if the range defined by [rangStart,rangeEnd) falls into the day defined by lineStart
		 *  
		 */
		private boolean rangeIsInDay(Date rangeStart, Date rangeEnd) {

<span class="pc bpc" id="L4733" title="1 of 2 branches missed.">			rangeStart = rangeStart == null ? new Date(0L) : rangeStart;</span>
<span class="pc bpc" id="L4734" title="1 of 2 branches missed.">			rangeEnd = rangeEnd == null ? new Date(Long.MAX_VALUE) : rangeEnd;</span>
<span class="fc" id="L4735">			TimeRange dayRange = new TimeRange(lineStart, getDayDurationInMilliseconds());</span>
<span class="fc" id="L4736">			TimeRange loadRange = new TimeRange(rangeStart, rangeEnd);</span>
<span class="fc" id="L4737">			int relation = loadRange.getRelativeLocationTo(dayRange);</span>
<span class="pc bpc" id="L4738" title="1 of 4 branches missed.">			return relation != TimeRange.TIME_BEFORE &amp;&amp; relation != TimeRange.TIME_AFTER;</span>

		}

		boolean shouldSkip(Date rangeStart, Date rangeEnd) {
<span class="fc bfc" id="L4743" title="All 4 branches covered.">			return skipLoop || !rangeIsInDay(rangeStart, rangeEnd);</span>
		}

	}

	private static boolean isTypeASAEnabled(ID mediaID, boolean typeASAEnabled) {
		// removed earlier hack done by amit for ops release. set PCAType to
		// false to always show SL.
		// Change:
		// typeASAEnabled should always be false for Defered and null media as
		// per Jason,
		// Should always consider PCA if media type does not exist or is
		// defered.
		// Sameet, Apr-2008
<span class="pc bpc" id="L4757" title="1 of 4 branches missed.">		if (mediaID == null || !Media.isMediaImmediate(mediaID)) {</span>
<span class="fc" id="L4758">			typeASAEnabled = false;</span>
		}
<span class="fc" id="L4760">		return typeASAEnabled;</span>
	}

	/**
	 * Returns whether deadline time should be populated for the specified media
	 * ID and goal type.
	 *
	 * @param mediaID
	 * @return
	 */
	private static boolean isTypeDeadlineTimeEnabled(ID mediaID, boolean nonPCAGoalType) {
<span class="pc bpc" id="L4771" title="5 of 6 branches missed.">		return nonPCAGoalType &amp;&amp; mediaID != null &amp;&amp; Media.isMediaDeferred(mediaID);</span>
	}

	/**
	 * Returns whether dials data should be populated for the specified media
	 * ID.
	 *
	 * @param mediaID
	 * @return
	 */
	private static boolean isTypeMaxDialsEnabled(ID mediaID) {
<span class="pc bpc" id="L4782" title="1 of 4 branches missed.">		return mediaID != null &amp;&amp; Media.isMediaOutbound(mediaID);</span>
	}

	/**
	 *
	 */

	public static void updatePredictTraceCube(PredictTraceCube cube, short[] types, Map&lt;? extends ID, SPQueue&gt; spQMap)
			throws Exception {
<span class="fc" id="L4791">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L4793">			SPQueue spQ = spQMap.get(cube.getSPQueueSID());</span>
<span class="fc" id="L4794">			ID spID = spQ.getSpID();</span>
<span class="fc" id="L4795">			SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO(jdmo);</span>
<span class="fc" id="L4796">			SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spID);</span>
<span class="fc" id="L4797">			Date spStartDate = sp.getStartTime();</span>
<span class="fc" id="L4798">			ID campaignID = sp.getCampaignID();</span>
<span class="fc" id="L4799">			CampaignDAO campDAO = new CampaignDAO(jdmo);</span>
<span class="fc" id="L4800">			Campaign camp = campDAO.getCampaignByID(campaignID, false);</span>
<span class="fc" id="L4801">			Calendar cal = Calendar.getInstance(camp.getTimeZone());</span>
<span class="fc" id="L4802">			cal.setTime(spStartDate);</span>

			// we need to initially set i to the offset of the start of the cube
			// relative to the SP day that it falls in.
<span class="fc" id="L4806">			int i = getIntervalOffset(spStartDate, cube.getRawStartDate(), camp.getTimeZone());</span>
<span class="fc" id="L4807">			int dayOffset = i / Trace.DAYPOINTS;</span>
<span class="fc" id="L4808">			i %= Trace.DAYPOINTS;</span>

<span class="fc bfc" id="L4810" title="All 2 branches covered.">			for (int dayCounter = 0; dayCounter &lt; dayOffset; dayCounter++) {</span>
<span class="fc" id="L4811">				cal.add(Calendar.DAY_OF_MONTH, 1);</span>
			}

<span class="fc" id="L4814">			int j = 0;</span>
<span class="fc bfc" id="L4815" title="All 2 branches covered.">			while (cal.getTime().before(cube.getRawEndDate())) { // getEndDate</span>
<span class="fc" id="L4816">				StringBuffer pStmt = new StringBuffer();</span>
<span class="fc" id="L4817">				pStmt.append(&quot; UPDATE &quot;).append(PredictTraceTableName).append(&quot; SET &quot;);</span>
<span class="fc" id="L4818">				boolean isFirstValue = true;</span>
				// in data array, data is stored from index 0. but the column
				// name in db is starting from index 1.
<span class="fc" id="L4821">				boolean reachedEndOfarray = false;</span>

<span class="pc bpc" id="L4823" title="1 of 2 branches missed.">				for (; i &lt; Trace.DAYPOINTS; i++, j++) {</span>
<span class="fc bfc" id="L4824" title="All 2 branches covered.">					for (short t = 0; t &lt; types.length; t++) {</span>
<span class="pc bpc" id="L4825" title="2 of 4 branches missed.">						if (!cube.isTraceTypeComputed(types[t]) &amp;&amp; cube.isDirty(types[t])) {</span>
<span class="fc" id="L4826">							double[] traceValArray = cube.getTraceValueD(types[t]);</span>
<span class="pc bpc" id="L4827" title="1 of 4 branches missed.">							if (traceValArray == null || traceValArray.length &lt;= j) {</span>
<span class="fc" id="L4828">								m_cat.debug(&quot;stopping update for this trace type; reached the end of array; it has no values tracetype=&quot;</span>
<span class="fc" id="L4829">										+ getTraceColumn(types[t]) + &quot; index=&quot; + j);</span>
<span class="fc" id="L4830">								reachedEndOfarray = true;</span>
<span class="fc" id="L4831">								break; // reached the end of array of array has</span>
										// no values
							}
<span class="fc bfc" id="L4834" title="All 2 branches covered.">							if (isFirstValue) {</span>
<span class="fc" id="L4835">								isFirstValue = false;</span>
							} else {
<span class="fc" id="L4837">								pStmt.append(&quot;, &quot;);</span>
							}
<span class="fc" id="L4839">							pStmt.append(getDETraceColumn(types[t])).append(i + 1).append(&quot;=&quot;)</span>
<span class="fc" id="L4840">									.append((float) cube.getTraceValueD(types[t], j));</span>
						}
					}
<span class="fc bfc" id="L4843" title="All 2 branches covered.">					if (reachedEndOfarray) {</span>
<span class="fc" id="L4844">						m_cat.debug(&quot;stopping update all trace types; reached the end of array; it has no values index=&quot; + j);</span>
<span class="fc" id="L4845">						break;</span>
					}
				}
<span class="pc bpc" id="L4848" title="1 of 2 branches missed.">				if (isFirstValue == false) {// if isFirstValue==false then it</span>
											// means there is something to
											// update.
<span class="fc" id="L4851">					pStmt.append(&quot; where SPQUEUEID ='&quot;).append(spQ.getDEID()).append(&quot;' AND DATETIME='&quot;)</span>
<span class="fc" id="L4852">							.append(JdmoUtil.formatDBString(cal.getTime())).append(&quot;'&quot;);</span>
<span class="fc" id="L4853">					jdmo.execute(pStmt.toString());</span>
				} else {
<span class="nc" id="L4855">					m_cat.error(&quot;ERROR NOTHING TO UPDATE ; where SPQUEUEID ='&quot; + spQ.getDEID() + &quot;' AND DATETIME='&quot;</span>
<span class="nc" id="L4856">							+ JdmoUtil.formatDBString(cal.getTime()) + &quot;'\t CUBE=&quot; + cube);</span>
				}
<span class="fc" id="L4858">				cal.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="fc" id="L4859">				i = 0; // start of the next day in the SP</span>
<span class="fc" id="L4860">			}</span>
		} finally {
<span class="pc" id="L4862">			jdmo.cleanUp();</span>
<span class="fc" id="L4863">		}</span>
<span class="fc" id="L4864">	}</span>

	/**
	 * Get the number of 15-minute intervals between two dates.
	 */
	private static int getIntervalOffset(Date startDate, Date endDate, TimeZone tz) {
<span class="fc" id="L4870">		int i = 0;</span>
<span class="fc" id="L4871">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="fc" id="L4872">		cal.setTime(startDate);</span>

<span class="fc bfc" id="L4874" title="All 2 branches covered.">		while (cal.getTime().before(endDate)) {</span>
<span class="fc" id="L4875">			cal.add(Calendar.MINUTE, 15);</span>
<span class="fc" id="L4876">			i++;</span>
		}

<span class="fc" id="L4879">		return i;</span>
	}

	/**
	 * Get the SPIDS to recalc based on Changes to Forecasted data ( checks Time of change of Forecasted data
	 * with Predicted Data to decide which SPs need recalc. Only checks for SPs that falls in the date range
	 * from today to (Today + lookfwdDays)
	 * Also returns  SPIDS that have any scheduling activity for the same range=&gt;has defect 144472
	 * Defect 144472:The old query only gets data on SPWORKRESOURCE so it only works if the SP has isUsingallemployees =0, then employees are physically added to SPWORKRESOURCE
	 * The fixed query also handles for isUsingallemployees =1, the employees will get from spcallcenter and workresourceorganization 
	 *
	 * @param lookfwdDays
	 * @return
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 * @throws java.rmi.RemoteException
	 */
public static Set getSPIDsToReCalc(int lookfwdDays, Date lastRunTime) throws Exception {
<span class="nc" id="L4897">	Jdmo jdmo = null;</span>
<span class="nc" id="L4898">	HashSet retSet = new HashSet();</span>
<span class="nc" id="L4899">	JdmoRowset rs = null;</span>
	try {
<span class="nc" id="L4901">		jdmo = new Jdmo();</span>
<span class="nc" id="L4902">		StringBuffer pStmt = new StringBuffer();</span>
<span class="nc" id="L4903">		pStmt.append(&quot; SELECT DISTINCT SP.SID &quot;);</span>
<span class="nc" id="L4904">		pStmt.append(&quot; FROM FORECASTTIMESERIES F with (nolock), PREDICTEDTIMESERIES P with (nolock),SPQUEUE Q with (nolock), SP with (nolock) &quot;);</span>
<span class="nc" id="L4905">		pStmt.append(&quot; WHERE F.SPQUEUEID in (SELECT DISTINCT ID FROM SPQUEUE WHERE SPQUEUE.SPID = Q.SPID) &quot;);</span>
<span class="nc" id="L4906">		pStmt.append(&quot; AND   P.SPQUEUEID in (SELECT DISTINCT ID FROM SPQUEUE WHERE SPQUEUE.SPID = Q.SPID) &quot;);</span>
<span class="nc" id="L4907">		pStmt.append(&quot; AND Q.SPID = SP.ID AND Q.ID = F.SPQUEUEID AND F.DATETIME= P.DATETIME &quot;);</span>
<span class="nc" id="L4908">		pStmt.append(&quot; AND ( F.CREATED &gt; P.CREATED ) &quot;);</span>
<span class="nc" id="L4909">		pStmt.append(&quot; AND F.DATETIME&lt; (GETUTCDATE() + &quot;).append(lookfwdDays).append(&quot;) &quot;);</span>
<span class="nc" id="L4910">		pStmt.append(&quot; AND F.DATETIME &gt;='&quot;).append(JdmoUtil.formatDBString(lastRunTime)).append(&quot;'&quot;);</span>
<span class="nc" id="L4911">		rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L4912" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L4913">			retSet.add(rs.getID(1));</span>
		}
<span class="nc bnc" id="L4915" title="All 2 branches missed.">		if (rs != null) {</span>
<span class="nc" id="L4916">			rs.close();</span>
		}

<span class="nc" id="L4919">		pStmt = new StringBuffer();</span>
<span class="nc" id="L4920">		pStmt.append(&quot; SELECT DISTINCT SP.SID FROM AUDITTRAILENTRY A with (nolock), SP with (nolock) &quot;);</span>
<span class="nc" id="L4921">		pStmt.append(&quot; WHERE IMPACTSTART&lt;TODATE AND IMPACTEND&gt;FROMDATE &quot;);</span>
<span class="nc" id="L4922">		pStmt.append(&quot; AND MODULEID = &quot;).append(AuditTrailEntry.MODULE_SCHEDULING);</span>

		//make sure the modified schedule is between the lookback and lookforward
<span class="nc" id="L4925">		pStmt.append(&quot; AND IMPACTSTART &lt;= (GETUTCDATE()+ &quot;).append(lookfwdDays).append(&quot;) &quot;);</span>
<span class="nc" id="L4926">		pStmt.append(&quot; AND IMPACTSTART &gt;'&quot;).append(JdmoUtil.formatDBString(lastRunTime)).append(&quot;'&quot;);</span>

		//An SP's statistics are out-of-date if the schedule was changed after the last recalc
<span class="nc" id="L4929">		pStmt.append(&quot; AND ATWHEN &gt; &quot;);</span>
<span class="nc" id="L4930">		pStmt.append(&quot; (SELECT ISNULL(MAX(E.ATWHEN), '&quot;).append(JdmoUtil.formatDBString(lastRunTime));</span>
<span class="nc" id="L4931">		pStmt.append(&quot;') FROM AUDITTRAILENTRY E, AUDITTRAILPROPERTY P &quot;);</span>
		
<span class="nc" id="L4933">		pStmt.append(&quot; WHERE E.ID = P.AUDITTRAILENTRYID AND E.ACTIONID = &quot;);</span>
<span class="nc" id="L4934">		pStmt.append(AuditTrailEntry.ACTION_SCHEDULER_COMPLETE);</span>
<span class="nc" id="L4935">		pStmt.append(&quot; and E.PRIMARYOBJECTID = SP.SID &quot;);</span>
<span class="nc" id="L4936">		pStmt.append(&quot; and E.MODULEID = &quot;).append(AuditTrailEntry.MODULE_SCHEDULING);</span>
<span class="nc" id="L4937">		pStmt.append(&quot; and P.NAME='Scheduling Mode' &quot;);</span>
<span class="nc" id="L4938">		pStmt.append(&quot; and P.VALUE in ('SILENTRECALC', 'SILENTRECALCWEB', 'RECALC', 'RECALCWEB', 'SCHEDULE', 'SCHEDULENOUI', 'SCHEDULEWEB', 'SCHEDULENOUIWEB')) &quot;);</span>

<span class="nc" id="L4940">		pStmt.append(&quot; AND (  (SP.ISUSINGALLEMPLOYEES = 0 and SP.ID  in (select w.SPID from SPWORKRESOURCE w with (nolock)&quot; );</span>
<span class="nc" id="L4941">		pStmt.append(&quot;  						     	where WORKRESOURCEID = PRIMARYOBJECTID&quot;);</span>
<span class="nc" id="L4942">		pStmt.append(&quot;									and SP.ISUSINGALLEMPLOYEES = 0&quot;);</span>
<span class="nc" id="L4943">		pStmt.append(&quot;                                      			)&quot;);</span>
<span class="nc" id="L4944">		pStmt.append(&quot;         ) &quot;);</span>
<span class="nc" id="L4945">		pStmt.append(&quot;		OR ( SP.ISUSINGALLEMPLOYEES =1 and  SP.ID in &quot; );</span>
<span class="nc" id="L4946">		pStmt.append(&quot;	 					         (select sp_o.SPID from workresourceorganization wrs &quot; );</span>
<span class="nc" id="L4947">		pStmt.append(&quot;									inner join spcallcenter sp_o on wrs.ORGANIZATIONid =sp_o.organizationid&quot; );</span>
<span class="nc" id="L4948">		pStmt.append(&quot;									inner join WORKRESOURCE r on r.ID = wrs.WORKRESOURCEID&quot; );</span>
<span class="nc" id="L4949">		pStmt.append(&quot;									where sp_o.SPID = sp.id &quot;);</span>
<span class="nc" id="L4950">		pStmt.append(&quot;									and SP.ISUSINGALLEMPLOYEES = 1&quot;);</span>
<span class="nc" id="L4951">		pStmt.append(&quot; 									and WORKRESOURCEID = PRIMARYOBJECTID&quot;);</span>
<span class="nc" id="L4952">		pStmt.append(&quot;	   							 )&quot;);</span>
<span class="nc" id="L4953">		pStmt.append(&quot;	   		)&quot;);</span>
<span class="nc" id="L4954">		pStmt.append(&quot;		) &quot;);</span>

<span class="nc" id="L4956">		rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L4957" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L4958">			retSet.add(rs.getID(1));</span>
		}
	} finally {
<span class="nc bnc" id="L4961" title="All 4 branches missed.">		if (rs != null) {</span>
<span class="nc" id="L4962">			rs.close();</span>
		}
<span class="nc bnc" id="L4964" title="All 4 branches missed.">		if (jdmo != null) {</span>
<span class="nc" id="L4965">			jdmo.cleanUp();</span>
		}
	}
<span class="nc" id="L4968">	return retSet;</span>
}

	/**
	 * Checks if Forecasted staffing &amp; FTE exists for the given time range for
	 * the said employee QC 138372: The old query only gets data on
	 * SPWORKRESOURCE so it only works if the SP has isUsingallemployees =0,
	 * then employees are physically added to SPWORKRESOURCE The fixed query
	 * also handles for isUsingallemployees =1, the employees will get from
	 * spcallcenter and workresourceorganization
	 * 
	 * @param empID
	 * @param start
	 * @param end
	 * @return
	 */
	public static boolean doesStaffingExistForPeriod(ID empID, Date start, Date end) throws Exception {
<span class="fc" id="L4985">		Jdmo jdmo = null;</span>
<span class="fc" id="L4986">		JdmoRowset rs = null;</span>
		try {
<span class="fc" id="L4988">			jdmo = new Jdmo();</span>
<span class="fc" id="L4989">			StringBuffer pStmt = new StringBuffer();</span>
<span class="fc" id="L4990">			pStmt = new StringBuffer();</span>
<span class="fc" id="L4991">			pStmt.append(&quot;SELECT distinct SP.ID ,	SP.FROMDATE, SP.TODATE	,sp.ISUSINGALLEMPLOYEES	from PREDICTEDTIMESERIES P ,SPQUEUE Q,  SP SP&quot;);</span>
<span class="fc" id="L4992">			pStmt.append(&quot;		WHERE Q.ID =P.SPQUEUEID and sp.id = q.SPID&quot;);</span>
<span class="fc" id="L4993">			pStmt.append(&quot;       and ((sp.ISUSINGALLEMPLOYEES = 0 and q.SPID  in (select w.SPID from SPWORKRESOURCE w&quot;);</span>
<span class="fc" id="L4994">			pStmt.append(&quot;									inner join SP on w.SPID =sp.id &quot;);</span>
<span class="fc" id="L4995">			pStmt.append(&quot;                                  inner join workresource r on r.ID = w.WORKRESOURCEID&quot;);</span>
<span class="fc" id="L4996">			pStmt.append(&quot;  						     	where WORKRESOURCEID = &quot;).append(empID);</span>
<span class="fc" id="L4997">			pStmt.append(&quot; 								 	and r.WORKRESTYPE='&quot;).append(WorkResourceInner.TYPE_EMPLOYEE).append(&quot;'&quot;);</span>
<span class="fc" id="L4998">			pStmt.append(&quot;									and SP.ISUSINGALLEMPLOYEES = 0&quot;);</span>
<span class="fc" id="L4999">			pStmt.append(&quot;									and SP.TODATE &gt;'&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
<span class="fc" id="L5000">			pStmt.append(&quot;									and SP.FROMDATE &lt;'&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;' ) )&quot;);</span>
<span class="fc" id="L5001">			pStmt.append(&quot;	or ( sp.ISUSINGALLEMPLOYEES =1 and q.SPID in &quot;);</span>
<span class="fc" id="L5002">			pStmt.append(&quot;	 					         (select sp_o.SPID from workresourceorganization wrs &quot;);</span>
<span class="fc" id="L5003">			pStmt.append(&quot;									inner join spcallcenter sp_o on wrs.ORGANIZATIONid =sp_o.organizationid&quot;);</span>
<span class="fc" id="L5004">			pStmt.append(&quot;									inner join WORKRESOURCE r on r.ID = wrs.WORKRESOURCEID&quot;);</span>
<span class="fc" id="L5005">			pStmt.append(&quot;									inner join SP on sp_o.SPID = sp.id 	&quot;);</span>
<span class="fc" id="L5006">			pStmt.append(&quot;									where SP.TODATE &gt;'&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
<span class="fc" id="L5007">			pStmt.append(&quot;									AND SP.FROMDATE &lt;'&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
<span class="fc" id="L5008">			pStmt.append(&quot;									and SP.ISUSINGALLEMPLOYEES = 1&quot;);</span>
<span class="fc" id="L5009">			pStmt.append(&quot; 									and WORKRESOURCEID =&quot;).append(empID);</span>
<span class="fc" id="L5010">			pStmt.append(&quot;	   								and r.WORKRESTYPE='&quot;).append(WorkResourceInner.TYPE_EMPLOYEE).append(&quot;' ))&quot;);</span>
<span class="fc" id="L5011">			pStmt.append(&quot;					) &quot;);</span>
<span class="fc" id="L5012">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="fc" id="L5013">			TreeSet retSet = new TreeSet();</span>
<span class="fc bfc" id="L5014" title="All 2 branches covered.">			while (rs.next()) {</span>
<span class="fc" id="L5015">				TimeRange tr = new TimeRange(rs.getTimestamp(2), rs.getTimestamp(3));</span>
<span class="pc bpc" id="L5016" title="2 of 4 branches missed.">				if (tr.includes(start) &amp;&amp; tr.includes(end)) {</span>
					// no point in going ahead this looks good. the period is
					// contained in a single SP
<span class="fc" id="L5019">					return true;</span>
				}
<span class="nc" id="L5021">				retSet.add(tr);</span>
<span class="nc" id="L5022">			}</span>
<span class="pc bpc" id="L5023" title="2 of 4 branches missed.">			if (retSet != null &amp;&amp; retSet.size() &gt; 1) {</span>
<span class="nc" id="L5024">				TimeRange rangePrev = null;</span>
<span class="nc" id="L5025">				boolean startDateIsIncluded = false;</span>
<span class="nc" id="L5026">				boolean endDateIsIncluded = false;</span>
<span class="nc bnc" id="L5027" title="All 2 branches missed.">				for (Iterator iterator = retSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L5028">					TimeRange range = (TimeRange) iterator.next();</span>
<span class="nc bnc" id="L5029" title="All 4 branches missed.">					if (rangePrev != null &amp;&amp; range.getAdjacency(rangePrev) == TimeRange.ADJACENT_NONE) {</span>
						// there are gaps , return false. no point continuing
<span class="nc" id="L5031">						return false;</span>
					}
<span class="nc bnc" id="L5033" title="All 2 branches missed.">					if (range.includes(start)) {</span>
<span class="nc" id="L5034">						startDateIsIncluded = true;</span>
					}
<span class="nc bnc" id="L5036" title="All 2 branches missed.">					if (range.includes(end)) {</span>
<span class="nc" id="L5037">						endDateIsIncluded = true;</span>
					}
<span class="nc" id="L5039">					rangePrev = range;</span>
<span class="nc" id="L5040">				}</span>
				// All ranges are covered. we are good. because if any gap is
				// found then we returned false in the loop already
<span class="nc bnc" id="L5043" title="All 4 branches missed.">				return (startDateIsIncluded &amp;&amp; endDateIsIncluded);</span>
			}
		} finally {
<span class="pc bpc" id="L5046" title="8 of 10 branches missed.">			if (rs != null) {</span>
<span class="pc" id="L5047">				rs.close();</span>
			}
<span class="pc bpc" id="L5049" title="8 of 10 branches missed.">			if (jdmo != null) {</span>
<span class="pc" id="L5050">				jdmo.cleanUp();</span>
			}
		}
<span class="fc" id="L5053">		return false;</span>
	}

	/**
	 * For marketing demo, database will be populated with future data, but
	 * queries should only return data prior to current time.
	 */
	private static Date adjustActualEndDateForDemo(Date end, TraceCube metaTC) {
<span class="fc" id="L5061">		Date newEnd = end;</span>
<span class="pc bpc" id="L5062" title="4 of 6 branches missed.">		if (end != null &amp;&amp; m_ignoreFutureData &amp;&amp; metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L5063">			Date now = new Date();</span>
<span class="nc bnc" id="L5064" title="All 2 branches missed.">			newEnd = end.after(now) ? now : end;</span>
		}

<span class="fc" id="L5067">		return newEnd;</span>
}

	/**
	 * Gets the list of months that has valid volume/aht data in the queuehistorytimeseries table
	 *
	 * @return List of month/year (Format: yyyymm)
	 * @throws JdmoException
	 */
	public static List&lt;String&gt; getMonthYearListInActualTimeSeries(ID queueID, int nOffset) throws JdmoException {
<span class="nc" id="L5077">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L5078">		final ArrayList&lt;String&gt; monthYearList = new ArrayList&lt;String&gt;();</span>
		try {
<span class="nc" id="L5080">			String sqlString = getSqlQueryToGetMonthYearListInActualTimeSeries(queueID, nOffset);</span>
<span class="nc" id="L5081">			final JdmoQuery jq = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L5082">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L5083" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L5084">				monthYearList.add(rs.getString(&quot;MONTHYEAR&quot;));</span>
			}
<span class="nc" id="L5086">			return monthYearList;</span>
<span class="nc" id="L5087">		} catch (final JdmoException e) {</span>
<span class="nc" id="L5088">			throw e;</span>
		} finally {
<span class="nc" id="L5090">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Gets the list of date that has valid volume/aht data in the queuehistorytimeseries table
	 *
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public static List&lt;String&gt; getDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws JdmoException {
<span class="nc" id="L5101">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L5102">		final ArrayList&lt;String&gt; daymonthYearList = new ArrayList&lt;String&gt;();</span>
		try {
<span class="nc" id="L5104">			String sqlString = getSqlQueryToGetDayMonthYearListInActualTimeSeries(queueID, startDate, endDate);</span>
<span class="nc" id="L5105">			final JdmoQuery jq = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L5106">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L5107" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L5108">				daymonthYearList.add(rs.getString(&quot;DAYMONTHYEAR&quot;));</span>
			}
<span class="nc" id="L5110">			return daymonthYearList;</span>
<span class="nc" id="L5111">		} catch (final JdmoException e) {</span>
<span class="nc" id="L5112">			throw e;</span>
		} finally {
<span class="nc" id="L5114">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Gets the list of week start date that has valid volume/aht data in the queuehistorytimeseries table
	 * The list does not include partial weeks in the year
	 *
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public static List&lt;String&gt; getWeekListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws JdmoException {
<span class="nc" id="L5126">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L5127">		final ArrayList&lt;String&gt; weekList = new ArrayList&lt;String&gt;();</span>
		try {
<span class="nc" id="L5129">			final JdmoQuery query = jdmo.createQuery(&quot;GETWEEKSWITHDATAINACTUALTIMESERIES&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="nc" id="L5130">			query.setParTimestamp(1, new Timestamp(startDate.getTime()));</span>
<span class="nc" id="L5131">			query.setParTimestamp(2, new Timestamp(endDate.getTime()));</span>
<span class="nc" id="L5132">			query.setParString(3, queueID.toString());</span>

<span class="nc" id="L5134">			final JdmoRowset rs = jdmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L5135" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L5136">				weekList.add(rs.getString(&quot;WeekStart&quot;));</span>
			}
<span class="nc" id="L5138">			return weekList;</span>
<span class="nc" id="L5139">		} catch (JdmoException e) {</span>
<span class="nc" id="L5140">			throw e;</span>
		} finally {
<span class="nc" id="L5142">			jdmo.cleanUp();</span>
		}
	}

	private static String getSqlQueryToGetActualTimeSeriesData(ID qID, Date startDate, Date endDate) {
<span class="nc" id="L5147">		StringBuffer stringBuffer = new StringBuffer(&quot;SELECT TIME, &quot;);</span>
<span class="nc" id="L5148">		stringBuffer.append(&quot;(CASE WHEN CALLVOLUME&lt;0 THEN -1 ELSE CALLVOLUME END) AS CALLVOLUME, &quot;);</span>
<span class="nc" id="L5149">		stringBuffer.append(&quot;(CASE WHEN AHT&lt;0 THEN -1 ELSE AHT END) AS AHT \n&quot;);</span>
<span class="nc" id="L5150">		stringBuffer.append(&quot;FROM QUEUEHISTORYTIMESERIES \n&quot;);</span>
<span class="nc" id="L5151">		stringBuffer.append(&quot;WHERE (QUEUEID=&quot;);</span>
<span class="nc" id="L5152">		JdmoUtil.asSqlLiteral(qID.toString(), stringBuffer);</span>
<span class="nc" id="L5153">		stringBuffer.append(&quot;AND TIME BETWEEN&quot;);</span>
<span class="nc" id="L5154">		stringBuffer.append(&quot;'&quot;).append(JdmoUtil.formatDBString(startDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L5155">		stringBuffer.append(&quot;AND&quot;);</span>
<span class="nc" id="L5156">		stringBuffer.append(&quot;'&quot;).append(JdmoUtil.formatDBString(endDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L5157">		stringBuffer.append(&quot;)&quot;);</span>
<span class="nc" id="L5158">		return stringBuffer.toString();</span>
	}

	private static String getSqlQueryToGetMonthYearListInActualTimeSeries(ID queueID, int nOffset) {
<span class="nc" id="L5162">		StringBuffer stringBuffer = new StringBuffer(&quot;SELECT DISTINCT STR(DATEPART(YEAR, DATEADD(minute,&quot;);</span>
<span class="nc" id="L5163">		stringBuffer.append(nOffset);</span>
<span class="nc" id="L5164">		stringBuffer.append(&quot;, [TIME]))*100 + DATEPART(MONTH, DATEADD(minute,&quot;);</span>
<span class="nc" id="L5165">		stringBuffer.append(nOffset);</span>
<span class="nc" id="L5166">		stringBuffer.append(&quot;, [TIME]))) AS MONTHYEAR FROM QUEUEHISTORYTIMESERIES WHERE QUEUEID=&quot;);</span>
<span class="nc" id="L5167">		JdmoUtil.asSqlLiteral(queueID.toString(), stringBuffer);</span>
<span class="nc" id="L5168">		stringBuffer.append(&quot;AND NOT(CALLVOLUME IS NULL)ORDER BY MONTHYEAR&quot;);</span>
<span class="nc" id="L5169">		return stringBuffer.toString();</span>
	}

	private static String getSqlQueryToGetDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) {
<span class="nc" id="L5173">		StringBuffer stringBuffer = new StringBuffer();</span>
<span class="nc bnc" id="L5174" title="All 2 branches missed.">		if (startDate == null) {</span>
<span class="nc" id="L5175">			stringBuffer.append(&quot;SELECT DISTINCT STR(DATEPART(YEAR,TIME)*10000 + DATEPART(MONTH,TIME)*100 + DATEPART(DAY,TIME)) AS DAYMONTHYEAR&quot;);</span>
<span class="nc" id="L5176">			stringBuffer.append(&quot; FROM QUEUEHISTORYTIMESERIES  WHERE QUEUEID =&quot;);</span>
<span class="nc" id="L5177">			JdmoUtil.asSqlLiteral(queueID.toString(), stringBuffer);</span>
<span class="nc" id="L5178">			stringBuffer.append(&quot;AND NOT(CALLVOLUME IS NULL) ORDER BY DAYMONTHYEAR&quot;);</span>
		} else {
<span class="nc" id="L5180">			stringBuffer.append(&quot;SELECT DISTINCT STR(DATEPART(YEAR,TIME)*10000 + DATEPART(MONTH,TIME)*100 + DATEPART(DAY,TIME)) AS DAYMONTHYEAR&quot;);</span>
<span class="nc" id="L5181">			stringBuffer.append(&quot; FROM QUEUEHISTORYTIMESERIES  WHERE QUEUEID =&quot;);</span>
<span class="nc" id="L5182">			JdmoUtil.asSqlLiteral(queueID.toString(), stringBuffer);</span>
<span class="nc" id="L5183">			stringBuffer.append(&quot;AND NOT(CALLVOLUME IS NULL)&quot;);</span>
<span class="nc" id="L5184">			stringBuffer.append(&quot;AND CALLVOLUME &gt;= 0&quot;);</span>
<span class="nc" id="L5185">			stringBuffer.append(&quot;AND TIME &gt;=&quot;);</span>
<span class="nc" id="L5186">			stringBuffer.append(&quot;'&quot;).append(JdmoUtil.formatDBString(startDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L5187">			stringBuffer.append(&quot;AND TIME &lt; &quot;);</span>
<span class="nc" id="L5188">			stringBuffer.append(&quot;'&quot;).append(JdmoUtil.formatDBString(endDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L5189">			stringBuffer.append(&quot;ORDER BY DAYMONTHYEAR&quot;);</span>
		}
<span class="nc" id="L5191">		return stringBuffer.toString();</span>
	}

	public static List&lt;Date&gt; getDaysWithHistoryForQueues(Collection&lt;ID&gt; queueIds, Date startDate, Date endDate)
			throws JdmoException {

<span class="nc bnc" id="L5197" title="All 4 branches missed.">		if (queueIds == null || queueIds.isEmpty()) {</span>
<span class="nc" id="L5198">			return Collections.emptyList();</span>
		}

<span class="nc" id="L5201">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L5202">		final List&lt;Date&gt; dateList = new ArrayList&lt;Date&gt;();</span>
		try {
<span class="nc" id="L5204">			final JdmoQuery query = jdmo.createQuery(&quot;GET_DAYS_WITH_HISTORY&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="nc" id="L5205">			query.setParString(1, StringUtil.createDelimitedString(queueIds.toArray(new ID[]{})));</span>
<span class="nc" id="L5206">			query.setParTimestamp(2, new Timestamp(startDate.getTime()));</span>
<span class="nc" id="L5207">			query.setParTimestamp(3, new Timestamp(endDate.getTime()));</span>

<span class="nc" id="L5209">			final JdmoRowset rs = jdmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L5210" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L5211">				dateList.add(rs.getTimestamp(&quot;DaysWithHistory&quot;));</span>
			}
<span class="nc" id="L5213">			return dateList;</span>
<span class="nc" id="L5214">		} catch (final JdmoException e) {</span>
<span class="nc" id="L5215">			throw e;</span>
		} finally {
<span class="nc" id="L5217">			jdmo.cleanUp();</span>
		}
	}
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>