<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarEventTemplateImpl.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">CalendarEventTemplateImpl.java</span></div><h1>CalendarEventTemplateImpl.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  This is an internal helper class that describes the generic
 *               properties of calendar events that can be of various types.
 *               Contains common information in recurring events and floating
 *               events, such as duration and activity
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectRoot;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;

<span class="fc" id="L30">public class CalendarEventTemplateImpl extends ValueObjectRoot implements CalendarEventTemplate, Externalizable {</span>
	// meta data info.
<span class="fc" id="L32">	private static FieldInfo m_fieldInfo = new CalendarEventTemplateFields();</span>

	@Override
	protected FieldInfo getFieldInfo() {
<span class="fc" id="L36">		return m_fieldInfo;</span>
	}

	/**
	 * Returns the type of the calendar event template object. This could be one
	 * of the int values defined as constants in CalendarEventTemplate
	 * interface: simple, floating, recurring, or recurring floating
	 */
	public short getTemplateType() {
<span class="nc" id="L45">		return getFieldValueShort(CalendarEventTemplateFields.TEMPLATETYPE);</span>
	}

	/**
	 * Sets the type of the calendar event template object. This could be one of
	 * the int values defined as constants in CalendarEventTemplate interface:
	 * simple, floating, recurring, or recurring floating
	 */
	public void setTemplateType(short templateType) {
<span class="fc" id="L54">		setFieldValue(CalendarEventTemplateFields.TEMPLATETYPE, templateType);</span>
<span class="fc" id="L55">	}</span>

	/**
	 * Returns the type of the calendar event object instances of which this
	 * template will create. See the com.bluepumpkin.ejb.bbm.activity.Event
	 * class for possible values.
	 */
	public int getEventType() {
<span class="fc" id="L63">		return getFieldValueInt(CalendarEventTemplateFields.EVENTTYPE);</span>
	}

	/**
	 * Sets the type of the calendar event object instances of which this
	 * template will create. See the com.bluepumpkin.ejb.bbm.activity.Event
	 * class for possible values. Possible values are:
	 * Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT or
	 * Event.EVENT_TYPE_TIME_OFF_EVENT to create recurring time off events or
	 * Event.EVENT_TYPE_UNAVAILABILITY_EVENT to create recurring
	 * unavailabilities
	 */
	public void setEventType(int eventType) {
<span class="fc" id="L76">		setFieldValue(CalendarEventTemplateFields.EVENTTYPE, eventType);</span>
<span class="fc" id="L77">	}</span>

	/**
	 * &lt;B&gt;getDescription&lt;/B&gt;
	 * &lt;P&gt;
	 * 
	 * @return String description of event
	 */
	public String getDescription() {
<span class="fc" id="L86">		return getFormattedFieldValue(CalendarEventTemplateFields.DESCRIPTION);</span>
	}

	/** sets the event description */
	public void setDescription(String strDescription) {
<span class="nc" id="L91">		setFieldValue(CalendarEventTemplateFields.DESCRIPTION, strDescription);</span>
<span class="nc" id="L92">	}</span>

	/**
	 * &lt;B&gt;getDuration&lt;/B&gt;
	 * &lt;P&gt;
	 * 
	 * @return int - duration (in minutes) of the event
	 */
	public int getDuration() {
<span class="fc" id="L101">		return getFieldValueInt(CalendarEventTemplateFields.DURATION);</span>
	}

	/** sets the event duration (in minutes) */
	public void setDuration(int nMinutes) {
<span class="nc" id="L106">		setFieldValue(CalendarEventTemplateFields.DURATION, nMinutes);</span>
<span class="nc" id="L107">	}</span>

	/**
	 * &lt;B&gt;getActivityID&lt;/B&gt;
	 * &lt;P&gt;
	 * 
	 * @return the unique ID of this event's activity
	 */
	public ID getActivityID() {
<span class="fc" id="L116">		return (ID) getFieldValue(CalendarEventTemplateFields.ACTIVITYID);</span>
	}

	/** sets the activity ID for this event */
	public void setActivityID(ID activityID) {
<span class="nc" id="L121">		setFieldValue(CalendarEventTemplateFields.ACTIVITYID, activityID);</span>
<span class="nc" id="L122">	}</span>

	/**
	 * Returns the shift overlap type of the event template
	 */
	public short getOverlapType() {
<span class="fc" id="L128">		return getFieldValueShort(CalendarEventTemplateFields.OVERLAPTYPE);</span>
	}

	/**
	 * Sets the overlap type of the event template
	 */
	public void setOverlapType(short nOverlapType) {
<span class="nc" id="L135">		setFieldValue(CalendarEventTemplateFields.OVERLAPTYPE, nOverlapType);</span>
<span class="nc" id="L136">	}</span>

	/**
	 * &lt;B&gt;getOverlayPrecedence&lt;/B&gt; the precedence is an integer value,&lt;br&gt;
	 * with a higher value being a higher precedence&lt;br&gt;
	 * and 0 being lowest.
	 * &lt;p&gt;
	 * if there are several overlaying events this value is used to &lt;br&gt;
	 * determine which event takes precedence&lt;br&gt;
	 * &lt;P&gt;
	 * 
	 * @return int value of precedence
	 */
	public int getOverlayPrecedence() {
<span class="fc" id="L150">		return getFieldValueShort(CalendarEventTemplateFields.PRECEDENCE);</span>
	}

	/** sets the overlay precedence for this event */
	public void setOverlayPrecedence(int precedence) {
<span class="fc" id="L155">		setFieldValue(CalendarEventTemplateFields.PRECEDENCE, (short) precedence);</span>
<span class="fc" id="L156">	}</span>

	/**
	 * Returns a collection of work resource attendees for this event template
	 */
	public Collection&lt;ID&gt; getWorkResourceIDs() {
<span class="fc" id="L162">		Collection&lt;CalendarEventTemplateAttendee&gt; attendees = (Collection&lt;CalendarEventTemplateAttendee&gt;) getChildObjects(CalendarEventTemplateFields.CHILD_ATTENDEE);</span>

		/**
		 * QC27140 based on the current design of dao, the child object can be
		 * removed only if the whole child object with id is passed into deleted
		 * children list, but since F&amp;S calls removeWorkResourceID api to remove
		 * child in corba layer and that API didn't set the child object id, we
		 * have to fix the problem here
		 */
<span class="fc" id="L171">		Collection&lt;CalendarEventTemplateAttendee&gt; deleteds = (Collection&lt;CalendarEventTemplateAttendee&gt;) getDeletedChildObjects(CalendarEventTemplateFields.CHILD_ATTENDEE);</span>
<span class="pc bpc" id="L172" title="3 of 4 branches missed.">		if (deleteds != null &amp;&amp; !deleteds.isEmpty()) {</span>
<span class="nc" id="L173">			CalendarEventTemplateAttendee deleted = null;</span>
<span class="nc" id="L174">			CalendarEventTemplateAttendee anyone = null;</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventTemplateAttendee&gt; i = deleteds.iterator(); i.hasNext();) {</span>
<span class="nc" id="L176">				deleted = i.next();</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">				if (deleted.getID() == null) {</span>
					// set the id to make deletion works later in dao
<span class="nc bnc" id="L179" title="All 2 branches missed.">					for (Iterator&lt;CalendarEventTemplateAttendee&gt; j = attendees.iterator(); j.hasNext();) {</span>
<span class="nc" id="L180">						anyone = j.next();</span>
<span class="nc bnc" id="L181" title="All 4 branches missed.">						if (anyone.getID() != null &amp;&amp; anyone.getWorkResourceID().equals(deleted.getWorkResourceID()))</span>
<span class="nc" id="L182">							deleted.setID(anyone.getID());</span>
					}
				}
			}
		}

		// now the attendees is able to exclude the deleted attendees
<span class="fc" id="L189">		attendees = (Collection&lt;CalendarEventTemplateAttendee&gt;) getChildObjects(CalendarEventTemplateFields.CHILD_ATTENDEE);</span>

<span class="fc" id="L191">		Collection&lt;ID&gt; ids = new ArrayList&lt;ID&gt;(attendees.size());</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">		for (Iterator&lt;CalendarEventTemplateAttendee&gt; it = attendees.iterator(); it.hasNext();) {</span>
<span class="fc" id="L193">			CalendarEventTemplateAttendee attendee = it.next();</span>
<span class="fc" id="L194">			ids.add(attendee.getWorkResourceID());</span>
<span class="fc" id="L195">		}</span>

<span class="fc" id="L197">		return ids;</span>
	}

	/**
	 * Adds a work resource as attendee to this event
	 */
	public void addWorkResourceID(ID workResourceID) {
<span class="nc" id="L204">		CalendarEventTemplateAttendee attendee = new CalendarEventTemplateAttendee();</span>
<span class="nc" id="L205">		attendee.setWorkResourceID(workResourceID);</span>
<span class="nc" id="L206">		createChildObject(CalendarEventTemplateFields.CHILD_ATTENDEE, attendee);</span>
<span class="nc" id="L207">	}</span>

	/**
	 * Removes a work resource as an attendee from this event
	 */
	public void removeWorkResourceID(ID workResourceID) {
		/*
		 * qc27140: the children can not be removed without id
		 */
		// find attendee
<span class="nc" id="L217">		Collection attendees = getChildObjects(CalendarEventTemplateFields.CHILD_ATTENDEE);</span>
<span class="nc" id="L218">		CalendarEventTemplateAttendee attendee = null;</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">		for (Iterator i = attendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L220">			attendee = (CalendarEventTemplateAttendee) i.next();</span>
<span class="nc bnc" id="L221" title="All 4 branches missed.">			if (attendee.getID() != null &amp;&amp; attendee.getWorkResourceID().equals(workResourceID))</span>
<span class="nc" id="L222">				break; // there should be one all the time.</span>
		}
<span class="nc" id="L224">		deleteChildObject(CalendarEventTemplateFields.CHILD_ATTENDEE, attendee);</span>
<span class="nc" id="L225">	}</span>

	/**
	 * This method was requested by Tyler for keeping track of which template
	 * attendees have been removed so that she can check their conflicts
	 */
	public Collection getRemovedWorkResourceIDs() {
<span class="nc" id="L232">		Collection listDeleted = getDeletedChildObjects(CalendarEventTemplateFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L233" title="All 4 branches missed.">		if (listDeleted == null || listDeleted.isEmpty())</span>
<span class="nc" id="L234">			return Collections.EMPTY_LIST;</span>

<span class="nc" id="L236">		ArrayList listReturn = new ArrayList(listDeleted.size());</span>
<span class="nc bnc" id="L237" title="All 2 branches missed.">		for (Iterator it = listDeleted.iterator(); it.hasNext();) {</span>
<span class="nc" id="L238">			CalendarEventTemplateAttendee attendee = (CalendarEventTemplateAttendee) it.next();</span>
<span class="nc" id="L239">			listReturn.add(attendee.getWorkResourceID());</span>
<span class="nc" id="L240">		}</span>
<span class="nc" id="L241">		return listReturn;</span>
	}

	/**
	 * Returns the number of minutes the event instances from this template will
	 * count towards various rules, such as vacation allocation, min/max hours,
	 * etc. This property will only have an effect on recurring time off events.
	 */
	public int getCountsMinutesTowardsRules() {
<span class="nc" id="L250">		return getFieldValueInt(CalendarEventTemplateFields.COUNTSMINSTOWARDSRULES);</span>
	}

	/**
	 * Sets the number of minutes the event instances from this template will
	 * count towards various rules, such as vacation allocation, min/max hours,
	 * etc. This property will only have an effect on recurring time off events.
	 */
	public void setCountsMinutesTowardsRules(int mins) {
<span class="nc" id="L259">		setFieldValue(CalendarEventTemplateFields.COUNTSMINSTOWARDSRULES, mins);</span>
<span class="nc" id="L260">	}</span>

	/**
	 * Returns the enumeration value that tells how to calculate the minutes the
	 * event instances from this template will count towards various rules (e.g.
	 * vacation allocation, min/max hours, etc.). Possible enumeration values
	 * are: use underlying shift or use the value specified by
	 * CountsMinutesTowardsRules property. This property will only have an
	 * effect on recurring time off events.
	 */
	public short getTimeOffRule() {
<span class="nc" id="L271">		return getFieldValueShort(CalendarEventTemplateFields.TIMEOFFRULE);</span>
	}

	/**
	 * Sets the enumeration value that tells how to calculate the minutes the
	 * event instances from this template will count towards various rules (e.g.
	 * vacation allocation, min/max hours, etc.). This property will only have
	 * an effect on recurring time off events.
	 */
	public void setTimeOffRule(short rule) {
<span class="nc" id="L281">		setFieldValue(CalendarEventTemplateFields.TIMEOFFRULE, rule);</span>
<span class="nc" id="L282">	}</span>

	/**
	 * Creates a single calendar event assignment on a given date using
	 * parameters of this template and the supplied attendee list
	 */
	public CalendarEventAssignment getEventInstance(Date dtEventStart, Collection&lt;ID&gt; attendees) {
<span class="fc" id="L289">		CalendarEventAssignment event = null;</span>
<span class="pc bpc" id="L290" title="2 of 3 branches missed.">		switch (getEventType()) {</span>
		case Event.EVENT_TYPE_TIME_OFF:
<span class="nc" id="L292">			event = new TimeOffEvent();</span>
<span class="nc" id="L293">			((TimeOffEvent) event).setTimeOffRule(this.getTimeOffRule());</span>
<span class="nc" id="L294">			((TimeOffEvent) event).setCountsMinutesTowardsRules(this.getCountsMinutesTowardsRules());</span>
<span class="nc" id="L295">			break;</span>

		case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="nc" id="L298">			event = new UnavailabilityEvent();</span>
<span class="nc" id="L299">			break;</span>

		default:
<span class="fc" id="L302">			event = new CalendarEvent();</span>
<span class="fc" id="L303">			((CalendarEvent) event).setOverlapType(this.getOverlapType());</span>
			break;
		}
<span class="fc" id="L306">		event.setActivityID(this.getActivityID());</span>
<span class="fc" id="L307">		event.setDuration(this.getDuration());</span>
<span class="fc" id="L308">		event.setDescription(this.getDescription());</span>
<span class="fc" id="L309">		event.setOverlayPrecedence(this.getOverlayPrecedence());</span>
<span class="fc" id="L310">		event.setStartTime(dtEventStart);</span>
<span class="fc" id="L311">		event.setLocked(false);</span>
<span class="fc" id="L312">		event.setParentID(this.getID());</span>
<span class="fc" id="L313">		event.setFieldValue(CalendarEventAssignmentFields.EVENTTYPE, this.getEventType());</span>
<span class="fc bfc" id="L314" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; it = attendees.iterator(); it.hasNext();) {</span>
<span class="fc" id="L315">			ID workResourceID = it.next();</span>
<span class="fc" id="L316">			event.addWorkResourceID(workResourceID);</span>
<span class="fc" id="L317">		}</span>
<span class="fc" id="L318">		return event;</span>
	}

	/**
	 * Creates a single calendar event assignment on a given date using
	 * parameters of this template and the supplied attendee list
	 */
	// Fix for QA 55778. Caluculate end time and pass it on for duration
	// calculation
	public CalendarEventAssignment getRecurringEventInstance(Date dtEventStart, Date dtEventEnd, Collection&lt;ID&gt; attendees) {
<span class="nc" id="L328">		CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L329" title="All 3 branches missed.">		switch (getEventType()) {</span>
		case Event.EVENT_TYPE_TIME_OFF:
<span class="nc" id="L331">			event = new TimeOffEvent();</span>
<span class="nc" id="L332">			((TimeOffEvent) event).setTimeOffRule(this.getTimeOffRule());</span>
<span class="nc" id="L333">			((TimeOffEvent) event).setCountsMinutesTowardsRules(this.getCountsMinutesTowardsRules());</span>
<span class="nc" id="L334">			break;</span>

		case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="nc" id="L337">			event = new UnavailabilityEvent();</span>
<span class="nc" id="L338">			break;</span>

		default:
<span class="nc" id="L341">			event = new CalendarEvent();</span>
<span class="nc" id="L342">			((CalendarEvent) event).setOverlapType(this.getOverlapType());</span>
			break;
		}
<span class="nc" id="L345">		event.setActivityID(this.getActivityID());</span>

<span class="nc" id="L347">		event.setDuration(getDuration());</span>
<span class="nc" id="L348">		event.setDescription(this.getDescription());</span>
<span class="nc" id="L349">		event.setOverlayPrecedence(this.getOverlayPrecedence());</span>
<span class="nc" id="L350">		event.setStartTime(dtEventStart);</span>
<span class="nc" id="L351">		event.setLocked(false);</span>
<span class="nc" id="L352">		event.setParentID(this.getID());</span>
<span class="nc" id="L353">		event.setFieldValue(CalendarEventAssignmentFields.EVENTTYPE, this.getEventType());</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; it = attendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L355">			ID workResourceID = it.next();</span>
<span class="nc" id="L356">			event.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L357">		}</span>
<span class="nc" id="L358">		return event;</span>
	}

	/**
	 * Provides some rudimentary checking for validity of this event template
	 * object
	 */
	public void checkIsValid() throws java.io.InvalidObjectException {
		/* check that the event length is greater than 0 hrs */
<span class="pc bpc" id="L367" title="1 of 2 branches missed.">		if (!isFieldValueSet(CalendarEventTemplateFields.DURATION))</span>
<span class="nc" id="L368">			throw new java.io.InvalidObjectException(&quot;duration must be set on template&quot; + toString());</span>

<span class="pc bpc" id="L370" title="1 of 2 branches missed.">		if (!isFieldValueSet(CalendarEventTemplateFields.EVENTTYPE))</span>
<span class="nc" id="L371">			throw new java.io.InvalidObjectException(&quot;event type must be set on template&quot; + toString());</span>

<span class="pc bpc" id="L373" title="1 of 2 branches missed.">		if (getDuration() &lt;= 0)</span>
<span class="nc" id="L374">			throw new java.io.InvalidObjectException(&quot;duration must be greater than 0 on template&quot; + toString());</span>

		/* if time off event check the time off rule parameter */
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">		if (getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			if (!isFieldValueSet(CalendarEventTemplateFields.TIMEOFFRULE)) {</span>
<span class="nc" id="L379">				throw new java.io.InvalidObjectException(&quot;time off rule must be set on template&quot; + toString());</span>
			}
<span class="nc" id="L381">			short timeOffRule = getTimeOffRule();</span>
<span class="nc bnc" id="L382" title="All 4 branches missed.">			if (timeOffRule != TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES</span>
					&amp;&amp; timeOffRule != TimeOffEvent.TIME_OFF_RULE_USE_SHIFT) {
<span class="nc" id="L384">				throw new java.io.InvalidObjectException(</span>
<span class="nc" id="L385">						&quot;time off rule must be either use X minutes or use underlying on template&quot; + toString());</span>
			}
		}
<span class="fc" id="L388">	}</span>

	/**
	 * Reconstitute this object from a stream (i.e., deserialize it).
	 */
	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="fc" id="L394">		ValueObjectUtil.defaultReadExternal(this, in);</span>
<span class="fc" id="L395">	}</span>

	/**
	 * Save the state of this object to a stream (i.e., serialize it).
	 */
	public void writeExternal(ObjectOutput out) throws IOException {
<span class="fc" id="L401">		ValueObjectUtil.defaultWriteExternal(this, out);</span>
<span class="fc" id="L402">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>