<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MaxPaidBreakRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.model.externalrules</a> &gt; <span class="el_source">MaxPaidBreakRule.java</span></div><h1>MaxPaidBreakRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.workrules.model.externalrules;

/**
 * Title:        Blue Pumpkin Software BBM
 * Description: Implementation of the Maximum Paid Break Rule pay rule template
 * A sample rule:
 * Employees who are on activity BREAK for periods
 *    that total up to 30 minutes in one shift
 *  are paid REGULAR
 *  (We assume that the default pay status for BREAK is not paid)
 *
 * The Template:
 *         Employees who are on activity &lt;SpecialActivity&gt; for periods
 *         that total up to &lt;nMaxMinutesPaidSpecialActivityDuration&gt;
 *         minutes in one shift
 *         are paid &lt;SpecialActivityRate&gt;
 *
 * Copyright:    Copyright (c) 2003
 * Company:      Blue Pumpkin Software, Inc
 * @author
 * @version 1.0
 */

import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Locale;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workrules.model.ExternalWorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleException;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleParameter;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleUtil;

<span class="nc" id="L40">public class MaxPaidBreakRule implements ExternalWorkRule,java.io.Serializable{</span>

	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
<span class="nc" id="L46">	public static int MAX_SPECIAL_PERIOD = 6000; //Minutes</span>

	public void initialize(LocalDate dtStartDate, LocalDate dtEndDate, Collection pOrganizations, Collection cWorkResourceIDs)
						throws WorkRuleException
	{
<span class="nc" id="L51">	}</span>

	public Collection getWorkRuleConflicts(Collection pWorkRuleParameters,int nPriority,
											 Organization pOrganization, int eOverlap,
											 Date dtStartDate, Date dtEndDate, Collection pEvents,
											 Collection pOldConflicts) throws WorkRuleException
	{
		// Initialize
<span class="nc" id="L59">		LinkedList pNewConflicts = new LinkedList();</span>
<span class="nc" id="L60">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L61">		ID idSpecialActivity  = ((WorkRuleParameter)w.next()).getActivityIDValue();</span>
<span class="nc" id="L62">		int nMaxPaidMinutes = ((WorkRuleParameter)w.next()).getIntValue();</span>
<span class="nc" id="L63">		int nTotalMinutesInActivity = 0;</span>

		// Start working if the special activity is defined
<span class="nc bnc" id="L66" title="All 2 branches missed.">		if (idSpecialActivity != null)</span>
		{
			//iterate over the event collection
<span class="nc bnc" id="L69" title="All 2 branches missed.">			for( Iterator iter = pEvents.iterator(); iter.hasNext(); )</span>
			{
<span class="nc" id="L71">				Event pEvent = (Event)iter.next();</span>
				// Work on time records, not time intervals
<span class="nc bnc" id="L73" title="All 2 branches missed.">					if (WorkRuleUtil.isInPeriodAndApproved(pEvent,dtStartDate,dtEndDate,eOverlap))</span>
					{
						//iterate over time records with special activities
<span class="nc" id="L76">						Collection cSubEvents = pEvent.getChildren();</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">						for(Iterator it = cSubEvents.iterator(); it.hasNext();)</span>
						{
<span class="nc" id="L79">							Event subEvent = (Event)it.next();</span>
<span class="nc" id="L80">							ID idCurrentActivity = subEvent.getActivityID();</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">							if (idCurrentActivity.equals(idSpecialActivity))</span>
							{
<span class="nc" id="L83">								int nDurationInMinutes = subEvent.getDuration();</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">								if (nTotalMinutesInActivity + nDurationInMinutes &lt;= nMaxPaidMinutes)</span>
								{ // Less than the max time. Merits special pay. Add a conflict
<span class="nc" id="L86">									nTotalMinutesInActivity += nDurationInMinutes;</span>
//									CommonConflict pConflict = new CommonConflict(
//											subEvent.getStartTime(),subEvent.getEndTime(),subEvent.getID());
//											pNewConflicts.add(pConflict);
<span class="nc" id="L90">									pNewConflicts.addAll(WorkRuleUtil.SplitConflicts(pEvent,pOldConflicts,nPriority,</span>
<span class="nc" id="L91">																subEvent.getStartTime(),subEvent.getEndTime(),false));</span>
								}
<span class="nc bnc" id="L93" title="All 2 branches missed.">								else if (nTotalMinutesInActivity &lt; nMaxPaidMinutes)</span>
								{ // A part or all of the break duration is paid regular,
									// another unpaid. Need to adjust the paid part of the break.
<span class="nc" id="L96">									Date dtOriginalEndTime = subEvent.getEndTime();</span>
<span class="nc" id="L97">									Calendar cal= Calendar.getInstance();</span>
<span class="nc" id="L98">									cal.setTime(dtOriginalEndTime);</span>
									// Subtract superfluous minutes from end time
<span class="nc" id="L100">									cal.add(Calendar.MINUTE,( nMaxPaidMinutes -</span>
												(nDurationInMinutes + nTotalMinutesInActivity) ));
<span class="nc" id="L102">									Date dAdjustedEndTime = cal.getTime();</span>
<span class="nc" id="L103">									pNewConflicts.addAll(WorkRuleUtil.SplitConflicts(pEvent,pOldConflicts,nPriority,</span>
<span class="nc" id="L104">																subEvent.getStartTime(), dAdjustedEndTime ,false));</span>
									// the following will prevent generation of any future alerts
<span class="nc" id="L106">									nTotalMinutesInActivity = nMaxPaidMinutes;</span>
								}
								// in case of nTotalMinutesInActivity==nMaxPaidMinutes we do nothing
							} //end for(Iterator it = cSubEvents.iterator()...
<span class="nc" id="L110">						}</span>
					}

<span class="nc" id="L113">			}</span>
		}
<span class="nc" id="L115">		return pNewConflicts;</span>
	}

	public int getLookBack(Collection pWorkRuleParameters)
	{
<span class="nc" id="L120">		return 0; // No need to look back</span>
	}

	public int getLookForward(Collection pWorkRuleParameters)
	{
<span class="nc" id="L125">		return 0; // No need to look forward</span>
	}

	public boolean isValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
	Locale locale, StringBuffer sMessage) throws WorkRuleException
	{
<span class="nc" id="L131">		boolean bValid = false;</span>
<span class="nc" id="L132">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L133">		ID idSpecialActivity  = ((WorkRuleParameter)w.next()).getActivityIDValue();</span>
<span class="nc" id="L134">		int nMaxPaidMinutes = ((WorkRuleParameter)w.next()).getIntValue();</span>
<span class="nc bnc" id="L135" title="All 4 branches missed.">		if ( nMaxPaidMinutes &gt;= 0 &amp;&amp; nMaxPaidMinutes &lt; MAX_SPECIAL_PERIOD)</span>
		{
<span class="nc" id="L137">			bValid = true;</span>
		}
		else
		{
<span class="nc" id="L141">			sMessage = new StringBuffer(&quot;Invalid value for Maximum Paid Minutes&quot;);</span>
		}
<span class="nc" id="L143">		return bValid;</span>
	}
/*
	public static void main(String[] args) {
	try {

		ID idOrganization = new ID(-3002);
		ID idEarningType = new ID(1);
		LocalDate dtStartDate = new LocalDate(1910,1,1,0,0);
		LocalDate dtEndDate = new LocalDate(1960,1,1,0,0);

		StringBuffer sMessage = new StringBuffer();

		ID idWorkResource = new ID(100);
		ID idWorkResource2 = new ID(102);
		ID idWorkResource3 = new ID(103);
		Organization pOrganization = new Organization();
		pOrganization.setID(idOrganization);
		pOrganization.setTimeZone(TimeZone.getTimeZone(&quot;PST&quot;));
		HashMap pActivites = new HashMap();
		Collection cOrganizations = new ArrayList();
		cOrganizations.add(pOrganization);

		ID idActivity = new ID(1);
		ID idActivity1 = new ID(2);
		int nMinutes = 30;

		Collection cWorkResources = new ArrayList();
		cWorkResources.add(idWorkResource);

		Calendar cCalendar = Calendar.getInstance();

		LocalDate dtStart = new LocalDate(1950,7,11,0,0);
		LocalDate dtEnd = new LocalDate(1950,7,20,0,0);

		ArrayList pEvents = new ArrayList();
		ArrayList pConflicts = new ArrayList();

		LocalDate s1 = new LocalDate(50,7,13,9,0);
		LocalDate s2 = new LocalDate(50,7,13,20,30);
		pEvents.add(new TestEvent(s1.getTime(), s2.getTime()));
//	  pEvents.add(new TestEvent(new Date(50,7,14,9,0),new Date(50,7,14,19,30))) ;


		TimeRecord pTimeRec = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.TIMEENTRY);
		
		LocalDate s3 = new LocalDate(50,7,11,19,0);
		LocalDate s4 = new LocalDate(50,7,11,19,25);
		pTimeRec.addChild(new TimeRecordEntry(idActivity, s3.getTime(), s4.getTime(),1,true,&quot;&quot;));
		LocalDate s5 = new LocalDate(50,7,11,19,25);
		LocalDate s6 = new LocalDate(50,7,11,19,25);
		pTimeRec.addEndShift(new TimeRecordEntry(Activity.ACTIVITY_NONE, s5.getTime(),s6.getTime(),1,true,&quot;&quot;));
		pTimeRec.setApprove(true);
		pEvents.add(pTimeRec);
*/		
/*
		TimeRecord pTimeRec2 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.TIMEENTRY);
		pTimeRec2.addChild(new TimeRecordEntry(idActivity,new Date(50,7,11,19,0),new Date(50,7,11,19,33),1,true,&quot;&quot;));
		pTimeRec2.addEndShift(new TimeRecordEntry(Activity.ACTIVITY_NONE,new Date(50,7,11,19,33),new Date(50,7,11,19,33),1,true,&quot;&quot;));
		pTimeRec2.setApprove(true);
		pEvents.add(pTimeRec2);

		TimeRecord pTimeRec3 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.TIMEENTRY);
		pTimeRec3.addChild(new TimeRecordEntry(idActivity,new Date(50,7,11,19,0),new Date(50,7,11,19,20),1,true,&quot;&quot;));
		pTimeRec3.addChild(new TimeRecordEntry(idActivity1,new Date(50,7,11,19,22),new Date(50,7,11,19,23),1,true,&quot;&quot;));
		pTimeRec3.addChild(new TimeRecordEntry(idActivity,new Date(50,7,11,19,24),new Date(50,7,11,19,34),1,true,&quot;&quot;));
		pTimeRec3.addEndShift(new TimeRecordEntry(Activity.ACTIVITY_NONE,new Date(50,7,11,19,34),new Date(50,7,11,19,34),1,true,&quot;&quot;));
		pTimeRec3.setApprove(true);
		pEvents.add(pTimeRec3);

		TimeRecord pTimeRec4 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.TIMEENTRY);
		pTimeRec4.addChild(new TimeRecordEntry(idActivity,new Date(50,7,11,19,0),new Date(50,7,11,19,21),1,true,&quot;&quot;));
		pTimeRec4.addChild(new TimeRecordEntry(idActivity1,new Date(50,7,11,19,21),new Date(50,7,11,19,29),1,true,&quot;&quot;));
		pTimeRec4.addChild(new TimeRecordEntry(idActivity,new Date(50,7,11,19,29),new Date(50,7,11,19,49),1,true,&quot;&quot;));
		pTimeRec4.addEndShift(new TimeRecordEntry(Activity.ACTIVITY_NONE,new Date(50,7,11,19,49),new Date(50,7,11,19,49),1,true,&quot;&quot;));
		pTimeRec4.setApprove(true);
		pEvents.add(pTimeRec4);
*/

/*
		LocalDate s7 = new LocalDate(50,7,19,9,0);
		LocalDate s8 = new LocalDate(50,7,19,19,40);
		pEvents.add(new TestEvent(s7.getTime(),s8.getTime())) ;

	//create Test WorkRule

		TreeSet pWorkRuleParams = new TreeSet();
		pWorkRuleParams.add(new WorkRuleParameter(0,WorkRuleParameter.ACTIVITY,idActivity));
		pWorkRuleParams.add(new WorkRuleParameter(1,WorkRuleParameter.INT,nMinutes));

		WorkRule pWorkRule = new WorkRule(null,null,&quot;Maximum Paid Break Time&quot;,
								idOrganization,dtStartDate,dtEndDate,WorkRule.NOPERIOD,0,idEarningType,0,
								pWorkRuleParams,0);
		pWorkRule.setExternalFunction(&quot;com.bluepumpkin.ejb.bbm.workrules.model.externalrules.MaxPaidBreakRule&quot;);

		System.out.println(&quot;******Validity &quot; + pWorkRule.isValid(sMessage) +&quot; &quot;+ sMessage);

		pWorkRule.initialize(dtStart,dtEnd,cOrganizations,cWorkResources,WorkRule.STARTSIN);

		Collection pNewConflicts = pWorkRule.getConflicts(idWorkResource,pOrganization,
								dtStart,dtEnd,pEvents,pConflicts);

		System.out.println(&quot;**********Got work rule Alerts&quot;);

		for(Iterator i = pNewConflicts.iterator(); i.hasNext(); )
		{
			CommonConflict pException = (CommonConflict)i.next();
			System.out.println(&quot;*************&quot; + pException);
		}
	}
	catch (Exception e) {
		e.printStackTrace(System.out);
	}

	}

*/
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>