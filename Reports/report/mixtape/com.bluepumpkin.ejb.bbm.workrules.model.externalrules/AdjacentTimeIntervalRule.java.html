<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AdjacentTimeIntervalRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.model.externalrules</a> &gt; <span class="el_source">AdjacentTimeIntervalRule.java</span></div><h1>AdjacentTimeIntervalRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.workrules.model.externalrules;

/**
 * Title:        Blue Pumpkin Software BBM
 * Description:
 * Copyright:    Copyright (c) 2001
 * Company:      Blue Pumpkin Software, Inc
 * @author
 * @version 1.0
 */

import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Locale;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeInterval;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workrules.model.CommonConflict;
import com.bluepumpkin.ejb.bbm.workrules.model.ExternalWorkRule;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleException;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleParameter;

<span class="nc" id="L29">public class AdjacentTimeIntervalRule implements ExternalWorkRule,java.io.Serializable{</span>
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	public void initialize(LocalDate dtStartDate, LocalDate dtEndDate, Collection pOrganizations, Collection cWorkResourceIDs)
	throws WorkRuleException {
<span class="nc" id="L39">	}</span>
	
	public Collection getWorkRuleConflicts(Collection pWorkRuleParameters,int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents,
			Collection pOldConflicts) throws WorkRuleException{
		
		//Employees with adjacent or overlapping &quot;Activity X&quot; Time Intervals are not paid for &quot;Activity Y&quot; Time Intervals
		//I'm assuming the Event collection is ordered by start time
		
<span class="nc" id="L49">		LinkedList pNewConflicts = new LinkedList();</span>
<span class="nc" id="L50">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L51">		ID idAbsentActivity  = ((WorkRuleParameter)w.next()).getActivityIDValue();</span>
<span class="nc" id="L52">		ID idUnpaidActivity  = ((WorkRuleParameter)w.next()).getActivityIDValue();</span>
		
<span class="nc" id="L54">		Event pPreviousEvent = null;</span>
<span class="nc" id="L55">		Event pCurrentEvent = null;</span>
		
		//iterate over the event collection
<span class="nc bnc" id="L58" title="All 2 branches missed.">		for( Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L59">			Event pEvent = (Event)i.next();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_TIME_RECORD &amp;&amp;</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">					((TimeRecord)pEvent).getType() == TimeRecord.TIMEINTERVAL) {</span>
				//found a Time Interval
<span class="nc" id="L63">				pPreviousEvent = pCurrentEvent;</span>
<span class="nc" id="L64">				pCurrentEvent = pEvent;</span>
				
<span class="nc" id="L66">				ID idCurrentActivity = pEvent.getActivityID();</span>
<span class="nc" id="L67">				ID idPreviousActivity = null;</span>
<span class="nc bnc" id="L68" title="All 2 branches missed.">				if (pPreviousEvent != null)</span>
<span class="nc" id="L69">					idPreviousActivity = pPreviousEvent.getActivityID();</span>
				
<span class="nc bnc" id="L71" title="All 4 branches missed.">				if (idCurrentActivity != null &amp;&amp; idPreviousActivity != null) {</span>
<span class="nc bnc" id="L72" title="All 4 branches missed.">					if (idCurrentActivity.equals(idUnpaidActivity) &amp;&amp; idPreviousActivity.equals(idAbsentActivity)) {</span>
<span class="nc" id="L73">						CommonConflict pConflict = createConflictFromTimeInterval(pEvent,pOldConflicts,pNewConflicts);</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">						if (pConflict != null) pNewConflicts.add(pConflict);</span>
<span class="nc" id="L75">					}</span>
<span class="nc bnc" id="L76" title="All 4 branches missed.">					else if (idPreviousActivity.equals(idUnpaidActivity) &amp;&amp; idCurrentActivity.equals(idAbsentActivity)) {</span>
<span class="nc" id="L77">						CommonConflict pConflict = createConflictFromTimeInterval(pPreviousEvent,pOldConflicts,pNewConflicts);</span>
<span class="nc bnc" id="L78" title="All 2 branches missed.">						if (pConflict != null) pNewConflicts.add(pConflict);</span>
					}
				}
<span class="nc" id="L81">			}</span>
			else {
				//this isn't a Time Interval
<span class="nc" id="L84">				pPreviousEvent = null;</span>
<span class="nc" id="L85">				pCurrentEvent = null;</span>
			}
<span class="nc" id="L87">		}</span>
<span class="nc" id="L88">		return pNewConflicts;</span>
	}
	
	private static CommonConflict createConflictFromTimeInterval(Event pEvent,Collection pOldConflicts,Collection pNewConflicts) {
		//check for a conflict already targetting this Time Interval among the old or new conflicts
<span class="nc bnc" id="L93" title="All 2 branches missed.">		for( Iterator j = pOldConflicts.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L94">			CommonConflict pConflict = (CommonConflict)j.next();</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">			if (pConflict.getEventID() == pEvent.getID())</span>
<span class="nc" id="L96">				return null;</span>
<span class="nc" id="L97">		}</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		for( Iterator j = pNewConflicts.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L99">			CommonConflict pConflict = (CommonConflict)j.next();</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">			if (pConflict.getEventID() == pEvent.getID())</span>
<span class="nc" id="L101">				return null;</span>
<span class="nc" id="L102">		}</span>
<span class="nc" id="L103">		TimeRecord pTimeRecord = (TimeRecord)pEvent;</span>
<span class="nc" id="L104">		TimeInterval pTimeInterval = (TimeInterval)pTimeRecord.getChildren().iterator().next();</span>
<span class="nc" id="L105">		CommonConflict pConflict = new CommonConflict(pEvent.getStartTime(),pEvent.getEndTime(),pEvent.getID());</span>
<span class="nc" id="L106">		pConflict.setAdjustment(- pTimeInterval.getDuration());</span>
<span class="nc" id="L107">		return pConflict;</span>
	}
	
	public int getLookBack(Collection pWorkRuleParameters) {
<span class="nc" id="L111">		return 3;</span>
	}
	
	public int getLookForward(Collection pWorkRuleParameters) {
<span class="nc" id="L115">		return 3;</span>
	}
	
	public boolean isValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage) {
<span class="nc" id="L120">		return true;</span>
	}
	
	/*
	 public static void main(String[] args) {
	 try {
	 
	 ID idOrganization = new ID(-3002);
	 ID idEarningType = new ID(1);
	 LocalDate dtStartDate = new LocalDate(1910,1,1,0,0);
	 LocalDate dtEndDate = new LocalDate(1960,1,1,0,0);
	 
	 StringBuffer sMessage = new StringBuffer();
	 
	 ID idWorkResource = new ID(100);
	 Organization pOrganization = new Organization();
	 pOrganization.setID(idOrganization);
	 pOrganization.setTimeZone(TimeZone.getTimeZone(&quot;PST&quot;));
	 HashMap pActivites = new HashMap();
	 Collection cOrganizations = new ArrayList();
	 cOrganizations.add(pOrganization);
	 
	 ID idActivity = new ID(1);
	 ID idActivity1 = new ID(2);
	 
	 Collection cWorkResources = new ArrayList();
	 cWorkResources.add(idWorkResource);
	 
	 Calendar cCalendar = Calendar.getInstance();
	 
	 LocalDate dtStart = new LocalDate(1950,7,11,0,0);
	 LocalDate dtEnd = new LocalDate(1950,7,20,0,0);
	 
	 ArrayList pEvents = new ArrayList();
	 ArrayList pConflicts = new ArrayList();
	 
	 */
	/*
	 pEvents.add(new TestEvent(new Date(50,7,13,9,0),new Date(50,7,13,20,30))) ;
	 pEvents.add(new TestEvent(new Date(50,7,14,9,0),new Date(50,7,14,19,30))) ;
	 
	 TimeRecord pTimeInterval1 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.EVENT_TYPE_TIME_INTERVAL);
	 pTimeInterval1.addChild(new TimeInterval(idActivity,new Date(50,7,11,9,0),new Date(50,7,11,19,30),400,1,true,&quot;&quot;));
	 pEvents.add(pTimeInterval1);
	 
	 TimeRecord pTimeInterval2 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.EVENT_TYPE_TIME_INTERVAL);
	 pTimeInterval2.addChild(new TimeInterval(idActivity1,new Date(50,7,18,9,0),new Date(50,7,18,19,30),400,1,true,&quot;&quot;));
	 pEvents.add(pTimeInterval2);
	 
	 TimeRecord pTimeInterval4 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.EVENT_TYPE_TIME_INTERVAL);
	 pTimeInterval4.setID(new ID(10));
	 pTimeInterval4.addChild(new TimeInterval(idActivity1,new Date(50,7,18,9,0),new Date(50,7,18,19,30),400,1,true,&quot;&quot;));
	 pEvents.add(pTimeInterval4);
	 
	 TimeRecord pTimeInterval3 = new TimeRecord(idWorkResource,idWorkResource,TimeRecord.EVENT_TYPE_TIME_INTERVAL);
	 pTimeInterval3.addChild(new TimeInterval(idActivity,new Date(50,7,11,9,0),new Date(50,7,11,19,30),400,1,true,&quot;&quot;));
	 pEvents.add(pTimeInterval3);
	 
	 
	 
	 pEvents.add(new TestEvent(new Date(50,7,19,9,0),new Date(50,7,19,19,30))) ;
	 */
	//create Test WorkRule
	/*
	 TreeSet pWorkRuleParameters5 = new TreeSet();
	 pWorkRuleParameters5.add(new WorkRuleParameter(0,WorkRuleParameter.ACTIVITY,idActivity));
	 pWorkRuleParameters5.add(new WorkRuleParameter(1,WorkRuleParameter.ACTIVITY,idActivity1));
	 
	 WorkRule pWorkRule5 = new WorkRule(null,null,&quot;holiday adjacent to sick&quot;,
	 idOrganization,dtStartDate,dtEndDate,WorkRule.NOPERIOD,0,idEarningType,0,
	 pWorkRuleParameters5,0);
	 pWorkRule5.setExternalFunction(&quot;com.bluepumpkin.ejb.bbm.workrules.model.externalrules.AdjacentTimeIntervalRule&quot;);
	 
	 System.out.println(&quot;******Validity &quot; + pWorkRule5.isValid(sMessage) +&quot; &quot;+ sMessage);
	 
	 pWorkRule5.initialize(dtStart,dtEnd,cOrganizations,cWorkResources,WorkRule.STARTSIN);
	 
	 Collection pNewConflicts = pWorkRule5.getConflicts(idWorkResource,pOrganization,
	 dtStart,dtEnd,pEvents,pConflicts);
	 
	 System.out.println(&quot;**********Got exceptions&quot;);
	 
	 for(Iterator i = pNewConflicts.iterator(); i.hasNext(); ) {
	 CommonConflict pException = (CommonConflict)i.next();
	 System.out.println(&quot;************************&quot; + pException);
	 }
	 
	 
	 
	 
	 }
	 catch (Exception e) {
	 e.printStackTrace(System.out);
	 }
	 
	 }
	 
	 */
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>