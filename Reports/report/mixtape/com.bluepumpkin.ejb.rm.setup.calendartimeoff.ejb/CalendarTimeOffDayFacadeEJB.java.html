<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarTimeOffDayFacadeEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb</a> &gt; <span class="el_source">CalendarTimeOffDayFacadeEJB.java</span></div><h1>CalendarTimeOffDayFacadeEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb;

import java.rmi.RemoteException;
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase.NullObject;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOIntervalCalendar;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.BlackoutDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.CalendarTimeOffDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignmentFieldInfo;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmployeeReferenceScheduleAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmployeeReferenceScheduleAssignmentUpdateParameters;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalAllocation;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalApprovedAndPending;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TOIntervalCalendarUtil;

/**
 * Title:        CalendarTimeOffDayFacadeEJB
 * Description:  EJB for TOPool, CalendarTimeOffDay &amp; EMP-TOPool effectivity
 * Copyright:    Copyright (c) 2010
 * Company:      Verint, Inc.
 *
 * @author Sameet Joshi
 * @version 1.0
 */
<span class="fc" id="L54">public class CalendarTimeOffDayFacadeEJB extends SessionEJBBase {</span>
<span class="fc" id="L55">	private static Category m_cat = Log.initCategory(CalendarTimeOffDayFacadeEJB.class.getName());</span>
<span class="fc" id="L56">	private static final String m_className = CalendarTimeOffDayFacadeEJB.class.getName();</span>

<span class="fc" id="L58">	private EventAuditTrailManager m_auditManager = null;</span>

	{
<span class="fc" id="L61">		super.init(CalendarTimeOffDayFacadeEJB.class.getName());</span>
<span class="fc" id="L62">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="fc" id="L69">		return m_cat;</span>
	}

	@Override
	public void ejbCreate() {
		try {
<span class="fc" id="L75">			m_auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L76">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L77">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L78">		}</span>
<span class="fc" id="L79">	}</span>

	@Override
	public void ejbRemove() {
		try {
<span class="nc bnc" id="L84" title="All 2 branches missed.">			if (m_auditManager != null) {</span>
<span class="nc" id="L85">				m_auditManager.remove();</span>
			}
<span class="nc" id="L87">		} catch (Exception ignore) {</span>
<span class="nc" id="L88">			m_cat.l7dError(ignore.getMessage());</span>
<span class="nc" id="L89">		}</span>
<span class="nc" id="L90">	}</span>

	/**
	 * see {@link CalendarTimeOffDayFacade#getCalendarTimeOffDays(ID, LocalDate, LocalDate, boolean) getCalendarTimeOffDays}
	 * &lt;p/&gt;
	 * Gets the time off calendar data configured for all days for specified Month and Year.
	 *
	 * @param toPoolID - ID for the TO Pool.
	 * @param pMonth   - integer value representing month.
	 * @param pYear    - integer value representing year.
	 * @return Collection - Collection of CalendarTimeOffDay objects.
	 * @throws BbmFinderException
	 */
	public Collection getCalendarTimeOffDays(ID toPoolID, int pMonth, int pYear) throws BbmFinderException {
<span class="fc" id="L104">		final String l_MethodName = &quot;getCalendarTimeOffDays&quot;;</span>
<span class="fc" id="L105">		methodStart(l_MethodName, toPoolID, NumberFactory.newInteger(pMonth), NumberFactory.newInteger(pYear));</span>
<span class="fc" id="L106">		Jdmo dmo = null;</span>
<span class="fc" id="L107">		ArrayList results = new ArrayList();</span>
		try {
<span class="fc" id="L109">			dmo = new Jdmo();</span>
<span class="fc" id="L110">			MonthRange monthRange = new MonthRange(pMonth, pYear);</span>
<span class="fc" id="L111">			Calendar c = new GregorianCalendar(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="fc" id="L112">			c.setTime(monthRange.startDate);</span>

			// get blackout days for this month
<span class="fc" id="L115">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="fc" id="L116">			BlackoutDay[] blackoutDays = blackoutDAO.findWithinMonth(toPoolID, monthRange);</span>

			// get timeoff allocation calendar days
<span class="fc" id="L119">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
<span class="fc" id="L120">			CalendarTimeOffDay[] timeoffCalDays = timeoffCalDAO.findWithinMonth(toPoolID, monthRange);</span>

			// now create a new collection of timeoff objects by merging the blackoutDay
			//  and timeoffCalendarDay objects retrieved from the database.
<span class="fc bfc" id="L124" title="All 2 branches covered.">			for (int i = 0; i &lt; blackoutDays.length; i++) {</span>
<span class="fc" id="L125">				CalendarTimeOffDay timeoffCalDay = timeoffCalDays[i];</span>

				// is this a blackout day?
<span class="fc bfc" id="L128" title="All 2 branches covered.">				boolean isBlackOutDay = blackoutDays[i] != null;</span>

				// if timeOffCalDay exisits, mark it as a blackout day
<span class="fc bfc" id="L131" title="All 2 branches covered.">				if (timeoffCalDay != null) {</span>
<span class="fc" id="L132">					timeoffCalDay.setBlackOutDay(isBlackOutDay);</span>
<span class="fc" id="L133">					results.add(timeoffCalDay);</span>
<span class="pc bpc" id="L134" title="1 of 2 branches missed.">				} else if (isBlackOutDay) {// if timeoffCal Day does not exist, create one and mark it as blackout day</span>
<span class="nc" id="L135">					timeoffCalDay = new CalendarTimeOffDay();</span>
<span class="nc" id="L136">					timeoffCalDay.setTOPoolID(toPoolID);</span>
<span class="nc" id="L137">					timeoffCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L138">					c.set(Calendar.DAY_OF_MONTH, c.getMinimum(Calendar.DAY_OF_MONTH) + i);</span>
<span class="nc" id="L139">					timeoffCalDay.setTimeOffDate(c.getTime());</span>
<span class="nc" id="L140">					results.add(timeoffCalDay);</span>
				}
			}
<span class="nc" id="L143">		} catch (Exception e) {</span>
<span class="nc" id="L144">			handleException(e);</span>
<span class="nc" id="L145">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L147" title="3 of 4 branches missed.">			if (dmo != null) {</span>
<span class="pc" id="L148">				dmo.cleanUp();</span>
			}
<span class="pc" id="L150">			methodFinish();</span>
<span class="fc" id="L151">		}</span>
<span class="fc" id="L152">		return results;</span>
	}

	/**
	 * This method combines the blackout days and timeoff cal days into one collection. It has to handle collections
	 * are sparse and figure out the overlap.
	 * &lt;p/&gt;
	 * &lt;p&gt; 3 possible scenarios:
	 * &lt;li&gt; timeoff allocation and blackout match
	 * &lt;li&gt; timeoff allocation present, blackout absent
	 * &lt;li&gt; timeoff allocation absent,  blackout present
	 */
	private Collection processBlackoutDays(Collection blackoutDays, Collection timeoffCalDays, ID pTOPoolID) {
		// if blackoutDays collection is empty, we are done. simply return the timeoffCalDays collection
<span class="pc bpc" id="L166" title="1 of 2 branches missed.">		if (blackoutDays.isEmpty()) {</span>
<span class="fc" id="L167">			return timeoffCalDays;</span>
		}
		// now we need to consider the blackoutDays in the date range as well. In effect,
		// we need to do the following:
		//     if blackoutDay object and timeoffCalendarDay object exist for the same day,
		//          set the blackout day flag in the timeOffCalendar object
		//     if blackoutDay object exists but timeOffCalendarDay object doesn't for a given
		//          day, create a new timeoffCalendarDay object and set the blackout day flag.
		//     if blackoutDay object doesn't exist but timeOffCalendarDay object exists for a
		//          a given day, reset the blackout day flag.

		// collection to hold timeOffCalendarDay objects
<span class="nc" id="L179">		ArrayList results = new ArrayList(timeoffCalDays.size());</span>
<span class="nc" id="L180">		Iterator boItr = blackoutDays.iterator(), ctoItr = timeoffCalDays.iterator();</span>
		// for each blackout day identify the corresponding calendarTimeOffDayData VO
		//   if it exists
		//      mark it as a blackout day.
		//   else
		//      create a new calendarTimeOffDayData VO and mark it as a blackout day.

		// Both lists are sorted and for now, assume that the date for the same day compares as equal.  They should,
		// since they get written from the same value input.  Might need to revisit that assumption later...
<span class="nc bnc" id="L189" title="All 2 branches missed.">		CalendarTimeOffDay currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
		// At the start of **each** loop itertion, if currTOCalDay != null then this calendarTimeOffDay hasn't
		// been added to the results yet.  If the loop terminates this needs to be added
		// to the results collection outside the loop.
<span class="nc bnc" id="L193" title="All 2 branches missed.">		while (boItr.hasNext()) {</span>
			// Four possibilies at this point:
			//     No current timeOffCalendarDay exists (currTOCalDay == null).
			//     currTOCalDay &lt; currBlackoutDay
			//     currTOCalDay == currBlackoutDay
			//     currTOCalDay &gt; currBlackoutDay.
<span class="nc" id="L199">			BlackoutDay currBODay = (BlackoutDay) boItr.next();</span>

			// scan until the timeOffCalendarDayData's date is &quot;equal to&quot; or after the current
			// black out day.  Add the current timeOffCalDayData to the 'results' array without marking
			// it as a 'blackout' day.
<span class="nc bnc" id="L204" title="All 4 branches missed.">			while (currTOCalDay != null &amp;&amp; currTOCalDay.getTimeOffDate().before(currBODay.getBlackoutDate())) {</span>
<span class="nc" id="L205">				results.add(currTOCalDay); // Add timeoffCalDay to results &amp; advance to the next timeOffCalendarDayData</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">				currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
			}

			// At this point, either timeoffCalDay is null (all timeoffCalDays have been processed),
			// equals the current blackout day or is after the current blackout day.
			//
			// If it is null (all timeoffCalDay objects processed) or is after
			// the current blackout day, create a new timeoffcaleandarDayData VO.
<span class="nc bnc" id="L214" title="All 4 branches missed.">			if ((currTOCalDay == null) || currTOCalDay.getTimeOffDate().after(currBODay.getBlackoutDate())) {</span>
				// create a new ValueObject (VO) &amp; mark it as a blackout day.
<span class="nc" id="L216">				CalendarTimeOffDay newTimeoffCalDay = new CalendarTimeOffDay();</span>
<span class="nc" id="L217">				newTimeoffCalDay.setTOPoolID(pTOPoolID);</span>
<span class="nc" id="L218">				newTimeoffCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L219">				newTimeoffCalDay.setTimeOffDate(currBODay.getBlackoutDate());</span>
<span class="nc" id="L220">				results.add(newTimeoffCalDay);</span>
<span class="nc" id="L221">			} else { // found timeoffCalDay object and blackoutDay object for the same day.</span>
<span class="nc" id="L222">				currTOCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L223">				results.add(currTOCalDay);</span>
				// advance to the next timeOffCalendarDayData
<span class="nc bnc" id="L225" title="All 2 branches missed.">				currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
			}
<span class="nc" id="L227">		}</span>
		// if the last TOCalendarDay was not added (within the above loop), add it
<span class="nc bnc" id="L229" title="All 2 branches missed.">		if (currTOCalDay != null) {</span>
<span class="nc" id="L230">			results.add(currTOCalDay);</span>
		}
		// Add any left over timeoffCalDay objects
<span class="nc bnc" id="L233" title="All 2 branches missed.">		while (ctoItr.hasNext()) {</span>
<span class="nc" id="L234">			results.add(ctoItr.next());</span>
		}
<span class="nc" id="L236">		return results;</span>
	}

	/**
	 * Gets the time off calendar data configured for all days
	 * in the given range, inclusive
	 *
	 * @param pTOPoolID            - ID for the Time-Off Pool.
	 * @param pStart               - beginning of the range
	 * @param pEnd                 - end of the range
	 * @param pIncludeBlackOutInfo - true =&gt; adds processing to set the
	 *                             black out day flags in the appropriate days,
	 *                             false =&gt; black out information is not returned.
	 * @return Collection - Collection of CalendarTimeOffDay objects, sorted in
	 *         ascending order by date.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public Collection getCalendarTimeOffDays(ID pTOPoolID, LocalDate pStart, LocalDate pEnd, boolean pIncludeBlackOutInfo)
			throws BbmFinderException {
<span class="fc" id="L256">		final String l_MethodName = &quot;getCalendarTimeOffDays&quot;;</span>
<span class="fc" id="L257">		methodStart(l_MethodName, pTOPoolID, pStart, pEnd);</span>
<span class="fc" id="L258">		Jdmo dmo = null;</span>
		try {
<span class="fc" id="L260">			dmo = new Jdmo();</span>
			// obtain the timeoffCalendarDay objects for the given date range
<span class="fc" id="L262">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
<span class="fc" id="L263">			Collection timeoffCalDays = timeoffCalDAO.findInRange(pTOPoolID, pStart, pEnd);</span>

			// if blackout information not needed, simply return the timeoffCalendarDay objects
<span class="fc bfc" id="L266" title="All 2 branches covered.">			if (!pIncludeBlackOutInfo) {</span>
<span class="fc" id="L267">				return timeoffCalDays;</span>
			}

			// obtain the blackoutDay objects in the given date range.
<span class="fc" id="L271">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="fc" id="L272">			Collection blackOutDays = blackoutDAO.findInRange(pTOPoolID, pStart, pEnd);</span>
<span class="fc" id="L273">			return processBlackoutDays(blackOutDays, timeoffCalDays, pTOPoolID);</span>
<span class="nc" id="L274">		} catch (Exception e) {</span>
<span class="nc" id="L275">			handleException(e);</span>
<span class="nc" id="L276">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L278">			methodFinish();</span>
<span class="pc bpc" id="L279" title="4 of 6 branches missed.">			if (dmo != null) {</span>
<span class="pc" id="L280">				dmo.cleanUp();</span>
			}
		}
	}

	/**
	 * see {@link CalendarTimeOffDayFacade#getBlackoutDays(ID, LocalDate, LocalDate) getBlackoutDays}
	 * &lt;p/&gt;
	 * Gets the time off black out day data configured for all days
	 * in the given range, inclusive
	 *
	 * @param pTOPoolID - ID for the Time-Off Pool.
	 * @param pStart    - beginning of the range
	 * @param pEnd      - end of the range
	 * @return Collection - Collection of BlackoutDay objects, sorted in
	 *         ascending order by date.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public Collection&lt;BlackoutDay&gt; getBlackoutDays(ID pTOPoolID, LocalDate pStart, LocalDate pEnd) throws BbmFinderException {
<span class="fc" id="L300">		final String methodName = &quot;getBlackoutDays&quot;;</span>
<span class="fc" id="L301">		methodStart(methodName, pTOPoolID, pStart, pEnd);</span>
<span class="fc" id="L302">		BlackoutDayDAO dao = null;</span>
		try {
<span class="fc" id="L304">			dao = new BlackoutDayDAO();</span>
<span class="fc" id="L305">			return dao.findInRange(pTOPoolID, pStart, pEnd);</span>
<span class="nc" id="L306">		} catch (Exception e) {</span>
<span class="nc" id="L307">			handleException(e);</span>
<span class="nc" id="L308">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L310" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L311">				dao.cleanUp();</span>
			}
<span class="pc" id="L313">			methodFinish();</span>
		}
	}

	/**
	 * Gets the employee's effective blackout days for the time range.
	 *
	 * @param employeeID
	 * @param startTime
	 * @param endTime
	 *            Exclusive end time.
	 */
	public List&lt;BlackoutDay&gt; getEffectiveBlackoutDaysForEmployee(ID employeeID, Date startTime, Date endTime) throws BbmFinderException {
<span class="nc" id="L326">		final String methodName = &quot;getEffectiveBlackoutDaysForEmployee&quot;;</span>
<span class="nc" id="L327">		methodStart(methodName, employeeID, startTime, endTime);</span>
<span class="nc" id="L328">		BlackoutDayDAO dao = null;</span>
		try {
<span class="nc" id="L330">			dao = new BlackoutDayDAO();</span>
<span class="nc" id="L331">			return dao.getEffectiveBlackoutDaysForEmployee(employeeID, startTime, endTime);</span>
<span class="nc" id="L332">		} catch (Exception e) {</span>
<span class="nc" id="L333">			handleException(e);</span>
<span class="nc" id="L334">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L336" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L337">				dao.cleanUp();</span>
			}
<span class="nc" id="L339">			methodFinish();</span>
		}
	}

	/**
	 * Save the collection of BlackoutDays. The blackhout days trickle down
	 * from the current org to its children.
	 *
	 * @param start-    Localdate start of range
	 * @param end-      Localdate end of range
	 * @param pTOPoolID - ID for the Time-Off Pool.
	 * @param delete    - whether to delet blackout days.
	 * @throws BbmFinderException
	 */
	public void saveBlackoutDaysForRange(LocalDate start, LocalDate end, ID pTOPoolID, boolean delete) throws BbmFinderException {
<span class="nc" id="L354">		final String l_MethodName = &quot;saveBlackoutDaysForRange&quot;;</span>
<span class="nc" id="L355">		methodStart(l_MethodName, start, end, pTOPoolID);</span>
<span class="nc" id="L356">		BlackoutDayDAO dao = null;</span>
		try {
<span class="nc" id="L358">			dao = new BlackoutDayDAO();</span>
<span class="nc" id="L359">			dao.saveBlackoutDaysForRange(pTOPoolID, start, end, delete);</span>
<span class="nc" id="L360">			triggerWaitlistScan(pTOPoolID, start.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)), end.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)));</span>
<span class="nc" id="L361">		} catch (Exception e) {</span>
<span class="nc" id="L362">			handleException(e);</span>
<span class="nc" id="L363">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L365" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L366">				dao.cleanUp();</span>
			}
<span class="nc" id="L368">			methodFinish();</span>
<span class="nc" id="L369">		}</span>
<span class="nc" id="L370">	}</span>

	/**
	 * Save the calendar allocated time off hours and blackout days data
	 * for an entire month. This method will not save more than one month
	 * at a time.
	 * The allocated time off hours and blackout days are stored in different
	 * table and use very different logic. The blackhout days trickle down
	 * from the current org to its children. The available time off hours
	 * are processed using information derived from the ownerOrgID.
	 *
	 * @param pTimeOffDays - Collection of CalendarTimeOffDay objects holding
	 *                     available time off hours and blackout day information.
	 * @param pTOPoolID    - ID for the Time-Off Pool.
	 * @throws BbmUpdateException
	 */
	public void saveCalendarTimeOffDays(Collection pTimeOffDays, ID pTOPoolID) throws BbmUpdateException {
<span class="fc" id="L387">		final String l_MethodName = &quot;saveCalendarTimeOffDays&quot;;</span>
<span class="fc" id="L388">		methodStart(l_MethodName, pTimeOffDays, pTOPoolID);</span>

<span class="fc" id="L390">		Calendar c = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="fc" id="L391">		int timeoffYear = 0;</span>
<span class="fc" id="L392">		int timeoffMonth = 0;</span>

		// convert the data from collection to a month array
<span class="fc" id="L395">		CalendarTimeOffDay[] timeoffDays = new CalendarTimeOffDay[31];</span>
<span class="fc" id="L396">		BlackoutDay[] blackoutDays = new BlackoutDay[31];</span>

		// create two month arrays, one each for timeoffDays and blackoutDays, from
		// pTimeOffDays.  Also validate the entries in pTimeOffDays.

		//store the earliest start date &amp; last end date , to be used for TOWaitlist scan
<span class="fc" id="L402">		Date earliestDate = null;</span>
<span class="fc" id="L403">		Date endDate = null;</span>
<span class="fc" id="L404">		int i = 0;</span>
<span class="fc bfc" id="L405" title="All 2 branches covered.">		for (Iterator itr = pTimeOffDays.iterator(); itr.hasNext(); i++) {</span>
			// obtain
<span class="fc" id="L407">			CalendarTimeOffDay timeoffDay = (CalendarTimeOffDay) itr.next();</span>

			// if timeOffDate not specified, t_hrow exception.
<span class="fc" id="L410">			Date timeOffDate = timeoffDay.getTimeOffDate();</span>
<span class="pc bpc" id="L411" title="1 of 2 branches missed.">			if (timeOffDate == null) {</span>
<span class="nc" id="L412">				throw new IllegalArgumentException(&quot;A null TimeOffDate is not allowed:\n&quot; + &quot;entryIDx=&quot; + i + &quot;;\nrecord=&quot; + timeoffDay);</span>
			}
<span class="fc" id="L414">			c.setTime(timeOffDate);</span>

			// set timeoff year and month if not set.
<span class="fc bfc" id="L417" title="All 2 branches covered.">			if (timeoffYear == 0) {</span>
<span class="fc" id="L418">				timeoffYear = c.get(Calendar.YEAR);</span>
<span class="fc" id="L419">				timeoffMonth = c.get(Calendar.MONTH);</span>
			}

			// validate that all timeoffCalendarDay objects must belong to the same year and month.
<span class="pc bpc" id="L423" title="2 of 4 branches missed.">			if ((timeoffYear != c.get(Calendar.YEAR)) || (timeoffMonth != c.get(Calendar.MONTH))) {</span>
<span class="nc" id="L424">				throw new IllegalArgumentException(&quot;All time off dates must be in &quot; + &quot;the same month and year:\nentryIDx=&quot; + i</span>
						+ &quot;;\nrecord=&quot; + timeoffDay);
			}

			// index into the arrays
<span class="fc" id="L429">			int dayOfMonth = c.get(Calendar.DAY_OF_MONTH) - c.getMinimum(Calendar.DAY_OF_MONTH);</span>

			// ensure that an entry at the index doesn't already exist
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">			if (timeoffDays[dayOfMonth] != null) {</span>
<span class="nc" id="L433">				throw new IllegalArgumentException(&quot;Cannot save two separate entries &quot; + &quot;for the same day:\nentryIDx=&quot; + i</span>
						+ &quot;;\ncurrent record=&quot; + timeoffDay + &quot;\n previous record=&quot; + timeoffDays[dayOfMonth]);
			}

			// store in timeoffCalendarDays array if the entry's available hours is positive (--nonzero).
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">			if (timeoffDay.getAllocatedHours() &gt;= 0) {</span>
<span class="fc" id="L439">				timeoffDays[dayOfMonth] = timeoffDay;</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">				if (earliestDate == null) {</span>
<span class="fc" id="L441">					earliestDate = timeOffDate;</span>
				}
<span class="fc" id="L443">				endDate = timeOffDate; //set this everytime there are available hours</span>
			}

			// store in blackoutDays array if it is a blackout day.
<span class="fc bfc" id="L447" title="All 2 branches covered.">			if (timeoffDay.isBlackOutDay()) {</span>
<span class="fc" id="L448">				blackoutDays[dayOfMonth] = new BlackoutDay();</span>
<span class="fc" id="L449">				blackoutDays[dayOfMonth].setBlackoutDate(timeoffDay.getTimeOffDate());</span>
			}
			//Logic to find date range for the waitlist scan.
<span class="pc bpc" id="L452" title="1 of 4 branches missed.">			if (timeoffDay.isBlackOutDay() || timeoffDay.getAllocatedHours() &gt;= 0) {</span>
<span class="fc" id="L453">				timeoffDays[dayOfMonth] = timeoffDay;</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">				if (earliestDate == null) {</span>
<span class="nc" id="L455">					earliestDate = timeOffDate;</span>
				}
<span class="fc" id="L457">				endDate = timeOffDate; //set this everytime there are available hours</span>
			}
		}
<span class="fc" id="L460">		Jdmo dmo = null;</span>
		try {
<span class="fc" id="L462">			dmo = new Jdmo();</span>
<span class="fc" id="L463">			MonthRange monthRange = new MonthRange(timeoffMonth, timeoffYear);</span>
			// save the blackoutDays object
<span class="fc" id="L465">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="fc" id="L466">			blackoutDAO.saveBlackoutDays(pTOPoolID, monthRange, blackoutDays);</span>
<span class="fc" id="L467">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
			// save time off days
<span class="fc" id="L469">			timeoffCalDAO.saveTimeOffDays(pTOPoolID, monthRange, timeoffDays);</span>
			// audit time off days after the save
<span class="fc" id="L471">			auditTimeOffDays(pTOPoolID, monthRange, timeoffDays);</span>
			//scan should be triggered for end hour of the end date hence adding a day to enddate.
<span class="fc" id="L473">			triggerWaitlistScan(pTOPoolID, earliestDate, new Date(endDate.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG));</span>
<span class="nc" id="L474">		} catch (Exception e) {</span>
<span class="nc" id="L475">			handleException(e);</span>
<span class="nc" id="L476">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L478" title="3 of 4 branches missed.">			if (dmo != null) {</span>
<span class="pc" id="L479">				dmo.cleanUp();</span>
			}
<span class="pc" id="L481">			methodFinish();</span>
<span class="fc" id="L482">		}</span>
<span class="fc" id="L483">	}</span>

	/**
	 * Audit allocated hours for the time off days in the month range for the given pool.
	 * @param toPoolID pool id being audited
	 * @param monthRange start and end day range to audit
	 * @param timeOffDays data for the whole month being audited
	 * @param changedTimeoffDays saved time off allocation hours
	 *
	 */
	private void auditTimeOffDays(ID toPoolID, MonthRange monthRange, CalendarTimeOffDay[] changedTimeoffDays) {
		TOPool toPool;
		try {
<span class="fc" id="L496">			toPool = getTOPool(toPoolID);</span>
<span class="nc" id="L497">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L498">			toPool = new TOPool();</span>
<span class="nc" id="L499">			toPool.setID(toPoolID);</span>
<span class="fc" id="L500">		}</span>

<span class="fc" id="L502">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
														 AuditTrailEntry.ACTION_TIME_OFF_POOL_HOURSALLOCATION,
<span class="fc" id="L504">														 toPool.getId(), toPool.getName(), monthRange.startDate,</span>
														 monthRange.endDate);
		try {
<span class="fc" id="L507">			String notifyType = TONotifyMessage.getNotifyString(TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE);</span>

<span class="fc" id="L509">			Organization toPoolOrg = CacheUtilBBM.getOrganizationByID(toPool.getOrganizationId());</span>
<span class="fc" id="L510">			String toAllocationCalendar = TOCalendarUtil.getTOAllocationCalendarForTimeOffDays(toPoolID, toPoolOrg, changedTimeoffDays,</span>
					new TimeRange(monthRange.startDate, monthRange.endDate));

<span class="fc" id="L513">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF_POOL, toAllocationCalendar, notifyType, false);</span>
<span class="fc" id="L514">			m_auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L515">		} catch (Exception e) {</span>
<span class="nc" id="L516">			m_cat.debug(&quot;unable to audit allocation hours changes for time off pool with id: &quot; + toPool.getId()</span>
<span class="nc" id="L517">					+ &quot; because of exception : &quot; + e.getMessage());</span>
<span class="fc" id="L518">		}</span>
<span class="fc" id="L519">	}</span>

	public void triggerWaitlistScan(ID pTOPoolID, Date startDate, Date endDate) throws BbmUpdateException {
<span class="fc" id="L522">		TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE);</span>
<span class="fc" id="L523">		msg.setTOPoolId(pTOPoolID);</span>
<span class="fc" id="L524">		msg.setStartDate(startDate);</span>
<span class="fc" id="L525">		msg.setEndDate(endDate);</span>
<span class="fc" id="L526">		msg.sendMessage();</span>
<span class="fc" id="L527">	}</span>

	public TOPool getTOPool(ID toPoolID) throws BbmFinderException {
<span class="fc" id="L530">		TOPoolDAO toPoolDAO = null;</span>
<span class="fc" id="L531">		TOPool toPool = null;</span>
		try {
<span class="fc" id="L533">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L534">			toPool = (TOPool) toPoolDAO.getObjectByID(toPoolID);</span>
<span class="nc" id="L535">		} catch (Exception e) {</span>
<span class="nc" id="L536">			handleException(e);</span>
<span class="nc" id="L537">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L539" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L540">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L543">		return toPool;</span>
	}

	public Collection getTOPoolsByIDs(Collection colIDs) throws BbmFinderException {
<span class="nc" id="L547">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L549">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L550">			return toPoolDAO.getTOPoolsByIDs(colIDs);</span>
<span class="nc" id="L551">		} catch (Exception e) {</span>
<span class="nc" id="L552">			handleException(e);</span>
<span class="nc" id="L553">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L555" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L556">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public ID createTOPool(TOPool toPool) throws BbmFinderException {
<span class="fc" id="L562">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L564">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L565">			return toPoolDAO.createObject(toPool);</span>
<span class="nc" id="L566">		} catch (Exception e) {</span>
<span class="nc" id="L567">			handleException(e);</span>
<span class="nc" id="L568">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L570" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L571">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public void updateTOPool(TOPool toPool) throws BbmFinderException {
<span class="fc" id="L577">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L579">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L580">			toPoolDAO.updateObject(toPool);</span>
<span class="nc" id="L581">		} catch (Exception e) {</span>
<span class="nc" id="L582">			handleException(e);</span>
<span class="nc" id="L583">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L585" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L586">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L589">	}</span>

	public void deleteTOPool(ID toPoolID) throws BbmUpdateException {
<span class="nc" id="L592">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L594">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L595">			toPoolDAO.deleteObject(toPoolID);</span>
<span class="nc" id="L596">		} catch (Exception e) {</span>
<span class="nc" id="L597">			handleException(e);</span>
		} finally {
<span class="nc bnc" id="L599" title="All 6 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L600">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L603">	}</span>

	public Collection getTOPoolsForOrg(ID orgID, boolean inclParentOrgs) throws BbmFinderException {
<span class="fc" id="L606">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L608">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L609">			return toPoolDAO.getTOPoolsForOrg(orgID, inclParentOrgs);</span>
<span class="nc" id="L610">		} catch (Exception e) {</span>
<span class="nc" id="L611">			handleException(e);</span>
<span class="nc" id="L612">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L614" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L615">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public Collection getWorkResourceAssignmentsForTOPool(ID toPoolID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L621">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L623">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L624">			return dao.getValidEmpTOPoolAssignments(toPoolID, null, dtStart, dtEnd, false);</span>
<span class="nc" id="L625">		} catch (Exception e) {</span>
<span class="nc" id="L626">			handleException(e);</span>
<span class="nc" id="L627">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L629" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L630">				dao.cleanUp();</span>
			}
		}
	}

	public Collection getEmployeeIDsForTOPool(ID toPoolID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L636">		Collection col = getWorkResourceAssignmentsForTOPool(toPoolID, dtStart, dtEnd);</span>
<span class="fc" id="L637">		return ValueObjectUtil.getFieldObjectCol(EmpTOPoolAssignmentFieldInfo.EMPTOPOOL_WORKRESOURCEID, col);</span>
	}

	public Collection getValidEmpTOPoolAssignments(ID empID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L641">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L643">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L644">			return dao.getValidEmpTOPoolAssignments(null, Collections.singleton(empID), dtStart, dtEnd, false);</span>
<span class="nc" id="L645">		} catch (Exception e) {</span>
<span class="nc" id="L646">			handleException(e);</span>
<span class="nc" id="L647">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L649" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L650">				dao.cleanUp();</span>
			}
		}
	}

	/*
	 * Get the reference schedule assignments for the given employees for the specified time instance.
	 * Note that since this for one specific instance of time each employee will have only one assignment.
	 */
	public Map&lt;ID, EmployeeReferenceScheduleAssignment&gt; getReferenceScheduleForWorkResources(Collection&lt;ID&gt; employeeIds, Date dt)
			throws BbmFinderException {
<span class="nc" id="L661">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L663">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L664">			List&lt;EmployeeReferenceScheduleAssignment&gt; list = dao.getValidAssignments(employeeIds, dt);</span>
<span class="nc" id="L665">			Map&lt;ID, EmployeeReferenceScheduleAssignment&gt; map = new HashMap&lt;ID, EmployeeReferenceScheduleAssignment&gt;();</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">			for (EmployeeReferenceScheduleAssignment refSch : list) {</span>
<span class="nc" id="L667">				map.put(refSch.getWorkResourceID(), refSch);</span>
<span class="nc" id="L668">			}</span>
<span class="nc" id="L669">			return map;</span>
<span class="nc" id="L670">		} catch (Exception e) {</span>
<span class="nc" id="L671">			handleException(e);</span>
<span class="nc" id="L672">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L674" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L675">				dao.cleanUp();</span>
			}
		}
	}

	public List&lt;EmployeeReferenceScheduleAssignment&gt; getValidReferenceScheduleAssignments(Collection&lt;ID&gt; employeeIds, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="nc" id="L682">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L684">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L685">			return dao.getValidAssignments(employeeIds, dtStart, dtEnd);</span>
<span class="nc" id="L686">		} catch (Exception e) {</span>
<span class="nc" id="L687">			handleException(e);</span>
<span class="nc" id="L688">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L690" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L691">				dao.cleanUp();</span>
			}
		}
	}

	public List&lt;EmployeeReferenceScheduleAssignment&gt; getFillerAssignments(Collection&lt;ID&gt; employeeIds, Date viewDate)
			throws BbmFinderException {
<span class="nc" id="L698">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L700">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L701">			return dao.getFillerAssignments(employeeIds, viewDate);</span>
<span class="nc" id="L702">		} catch (Exception e) {</span>
<span class="nc" id="L703">			handleException(e);</span>
<span class="nc" id="L704">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L706" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L707">				dao.cleanUp();</span>
			}
		}
	}

	public boolean hasAtLeastOneCommonSchedulingPeriod(Collection&lt;ID&gt; employeeIds) throws BbmFinderException {

<span class="nc bnc" id="L714" title="All 4 branches missed.">		if (employeeIds == null || employeeIds.isEmpty()) {</span>
<span class="nc" id="L715">			return false;</span>
		}

<span class="nc" id="L718">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L720">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L721">			List&lt;ID&gt; commondIds = dao.getCommonSchedulingPeriodDEIDs(employeeIds, 1);</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">			return !commondIds.isEmpty();</span>
<span class="nc" id="L723">		} catch (Exception e) {</span>
<span class="nc" id="L724">			handleException(e);</span>
<span class="nc" id="L725">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L727" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L728">				dao.cleanUp();</span>
			}
		}
	}

	public void updateEmployeeReferenceScheduleEffectivity(Collection&lt;ID&gt; empIDs, Date asOfDate,
			EmployeeReferenceScheduleAssignmentUpdateParameters update) throws BbmFinderException {

<span class="nc" id="L736">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L738">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L739">			dao.updateEmployeeReferenceScheduleEffectivity(empIDs, asOfDate, update);</span>

<span class="nc" id="L741">			TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_REF_SCHEDULE_CHANGE);</span>
<span class="nc" id="L742">			msg.setEmployeeIDs(empIDs);</span>
<span class="nc" id="L743">			msg.setStartDate(asOfDate);</span>
<span class="nc" id="L744">			msg.sendMessage();</span>

<span class="nc" id="L746">		} catch (Exception e) {</span>
<span class="nc" id="L747">			handleException(e);</span>
<span class="nc" id="L748">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L750" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L751">				dao.cleanUp();</span>
			}
		}

<span class="nc" id="L755">	}</span>

	/**
	 * Gets the time off calendar data configured for all days
	 * in the given range, inclusive
	 *
	 * @param empIDs  a collection of employee ids
	 * @param dtStart - beginning of the range
	 * @param dtEnd   - end of the range
	 * @return a hashmap of (employeeid, EmpTOPoolAssignment Collection) pairs
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public HashMap getTOPoolsForWorkResources(Collection empIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L769">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L771">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L772">			return dao.getTOPoolsForEmployees(empIDs, dtStart, dtEnd);</span>
<span class="nc" id="L773">		} catch (Exception e) {</span>
<span class="nc" id="L774">			handleException(e);</span>
<span class="nc" id="L775">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L777" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L778">				dao.cleanUp();</span>
			}
		}
	}

	/**
	 * @param colEmployeeIDs a collection of employee ids
	 * @param dtNow:         a given time in GMT
	 * @return a hashmap of (employeeid, TOPool) pairs
	 */
	public HashMap getEmployeesTOPoolsAsOfDate(Collection colEmployeeIDs, Date dtNow) throws BbmFinderException {
<span class="nc" id="L789">		return getTOPoolsForWorkResources(colEmployeeIDs, dtNow, dtNow);</span>
	}

	/**
	 * Update an empoyee's Time Off Pool effective dates.
	 * @param empID        - ID of the employee
	 * @param asOfDate     - The date which we will use to get all of the employee pool set.
	 * @param newTOPoolID  - The ID of the Time Off Pool that you want to assign the given employee(s) to. Must never be null.
	 * @param newStartDate - The start date of the time off pool assignment. Can be a Date object, ValueObjectBase.NullObject, or null.
	 * 					  		a date will change the value in the database to that date
	 * 							null or a ValueObjectBase.NullObject will leave the value unchanged in the database
	 * @param newEndDate   - The end date of the time off pool assignment. Can be a Date object, ValueObjectBase.NullObject, or null.
	 * 					  		a date will change the value in the database to that date
	 * 							a ValueObjectBase.NullObject will change the value to null in the database
	 * 							null will leave the value unchanged in the database.
	 */
	public void updateEmployeeTimeOffPoolEffectivity(Collection empIDs, Date asOfDate, Object newTOPoolID, Object startDate, Object endDate)
			throws BbmFinderException {
<span class="fc" id="L807">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L809">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L810">			Date minStartDate = null;</span>
<span class="fc" id="L811">			Date maxEndDate = null;</span>
<span class="fc" id="L812">			LinkedHashSet pTOPoolSet = new LinkedHashSet();</span>
<span class="fc" id="L813">			pTOPoolSet.addAll(getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate));</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">			for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L815">				ID empID = (ID) iterator.next();</span>
<span class="fc" id="L816">				EmpTOPoolAssignment newPoolAssign = new EmpTOPoolAssignment();</span>
<span class="fc" id="L817">				Employee emp = BbmManagerFactory.getWorkResourceManager().getEmployeeByID(empID, asOfDate,</span>
						Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);
<span class="fc" id="L819">				Date hireDate = emp.getStartTime();</span>
<span class="fc" id="L820">				Date fireDate = emp.getEndTime();</span>

<span class="fc" id="L822">				Object newStartDate = startDate;</span>
<span class="fc" id="L823">				Object newEndDate = endDate;</span>
<span class="fc" id="L824">				boolean bEndDateNoChange = false; //true menas that we should keep the current assignment's end date unchanged in the database</span>

<span class="pc bpc" id="L826" title="3 of 6 branches missed.">				if ((newStartDate != null) &amp;&amp; (newStartDate instanceof Date) &amp;&amp; (hireDate != null)</span>
<span class="pc bpc" id="L827" title="1 of 2 branches missed.">						&amp;&amp; ((Date) newStartDate).before(hireDate)) {</span>
<span class="nc" id="L828">					newStartDate = hireDate;</span>
				}

<span class="pc bpc" id="L831" title="1 of 2 branches missed.">				if (newEndDate == null) {</span>
<span class="nc" id="L832">					bEndDateNoChange = true;</span>
				} else {
<span class="pc bpc" id="L834" title="5 of 6 branches missed.">					if ((newEndDate instanceof Date) &amp;&amp; (fireDate != null) &amp;&amp; ((Date) newEndDate).after(fireDate)) {</span>
<span class="nc" id="L835">						newEndDate = fireDate;</span>
<span class="pc bpc" id="L836" title="1 of 2 branches missed.">					} else if (newEndDate instanceof NullObject) {</span>
<span class="pc bpc" id="L837" title="1 of 2 branches missed.">						if (fireDate != null) {</span>
<span class="nc" id="L838">							newEndDate = fireDate;</span>
						} else {
<span class="fc" id="L840">							newEndDate = null;</span>
						}
					}
				}

				//need to find this employee's pool assignment (if any) on the asOfDate
<span class="fc" id="L846">				Collection poolAssignments = getValidEmpTOPoolAssignments(empID, asOfDate, asOfDate);</span>
<span class="pc bpc" id="L847" title="2 of 4 branches missed.">				if (poolAssignments != null &amp;&amp; poolAssignments.size() &gt; 0) {</span>

<span class="nc bnc" id="L849" title="All 2 branches missed.">					for (Iterator asgIt = poolAssignments.iterator(); asgIt.hasNext();) {</span>
<span class="nc" id="L850">						newPoolAssign = (EmpTOPoolAssignment) asgIt.next();</span>
<span class="nc bnc" id="L851" title="All 4 branches missed.">						if (newStartDate == null || (newStartDate instanceof NullObject)) {</span>
<span class="nc" id="L852">							newStartDate = newPoolAssign.getStartTime(); //We want to use the current assignment's start date</span>
						}

<span class="nc bnc" id="L855" title="All 2 branches missed.">						if (bEndDateNoChange) {</span>
<span class="nc" id="L856">							newEndDate = newPoolAssign.getEndTime(); //We want to use the current assignment's end date</span>
						}

						break; //there should only be one assignment since we querried for a single instant
					}
				} else {
					//no pool assignment found

<span class="pc bpc" id="L864" title="2 of 4 branches missed.">					if ((newStartDate == null) || (newStartDate instanceof NullObject)) {</span>
						//We want to use the current assignment's start date

						//get the previous pool assignment (if any) before the asOfDate. The previous assignment's endDate will be the new assignment's startDate.
<span class="nc" id="L868">						Date prevPoolEnd = dao.getPreviousPoolAssignmentEnd(empID, asOfDate);</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">						if (prevPoolEnd != null) {</span>
<span class="nc" id="L870">							newStartDate = prevPoolEnd;</span>
						} else {
							//there was no previous pool assignment. Use the employee's hire date.
<span class="nc" id="L873">							newStartDate = hireDate;</span>
						}
					}

<span class="pc bpc" id="L877" title="1 of 2 branches missed.">					if (bEndDateNoChange) {</span>
						//We want to use the current assignment's end date

						//get the next pool assignment (if any) after the asOfDate. The next assignment's startDate will be the new assignment's endDate.
<span class="nc" id="L881">						Date nextPoolStart = dao.getNextPoolAssignmentStart(empID, asOfDate);</span>
<span class="nc bnc" id="L882" title="All 2 branches missed.">						if (nextPoolStart != null) {</span>
<span class="nc" id="L883">							newEndDate = nextPoolStart;</span>
						} else {
							//there is no next pool assignment. Use the employee's fire date.
<span class="nc" id="L886">							newEndDate = fireDate;</span>
						}
					}
				}

				//update/create the time off pool assignment in the database
<span class="fc" id="L892">				newPoolAssign.setStartTime((Date) newStartDate);</span>
<span class="fc" id="L893">				newPoolAssign.setEndTime((Date) newEndDate);</span>
<span class="fc" id="L894">				newPoolAssign.setTOPoolID((ID) newTOPoolID);</span>
<span class="fc" id="L895">				newPoolAssign.setWorkResourceID(empID);</span>
<span class="fc" id="L896">				dao.merge(newPoolAssign);</span>
<span class="fc" id="L897">				dao.updateNoOverlapAssignment(newPoolAssign, EmpTOPoolAssignmentFieldInfo.EMPTOPOOL_WORKRESOURCEID, -1);</span>

				//store the min/max dates for the TONotifyMessage
<span class="pc bpc" id="L900" title="1 of 2 branches missed.">				minStartDate = (minStartDate == null) ? (Date) newStartDate : minDate(minStartDate, (Date) newStartDate);</span>
<span class="pc bpc" id="L901" title="1 of 2 branches missed.">				if (newEndDate != null) {</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">					maxEndDate = (maxEndDate == null) ? (Date) newEndDate : maxDate(maxEndDate, (Date) newEndDate);</span>
				}
<span class="fc" id="L904">			}</span>

			//prepare and send a TONotifyMessage
<span class="fc" id="L907">			pTOPoolSet.addAll(getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate));</span>
<span class="fc" id="L908">			pTOPoolSet.add(getTOPool((ID) newTOPoolID));</span>
<span class="fc" id="L909">			TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_EMP_TOPOOL_CHANGE);</span>
<span class="fc" id="L910">			msg.setObject(pTOPoolSet);</span>
<span class="fc" id="L911">			msg.setEmployeeIDs(empIDs);</span>
<span class="pc bpc" id="L912" title="1 of 2 branches missed.">			msg.setStartDate(minStartDate == null ? asOfDate : minStartDate);</span>
<span class="fc" id="L913">			msg.setEndDate(maxEndDate);</span>
<span class="fc" id="L914">			msg.sendMessage();</span>

<span class="nc" id="L916">		} catch (Exception e) {</span>
<span class="nc" id="L917">			handleException(e);</span>
<span class="nc" id="L918">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L920" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L921">				dao.cleanUp();</span>
			}
		}
<span class="fc" id="L924">	}</span>

	private Date minDate(Date d1, Date d2) {
<span class="nc bnc" id="L927" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L928">			return d2;</span>
		}
<span class="nc bnc" id="L930" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L931">			return d1;</span>
		}
<span class="nc bnc" id="L933" title="All 2 branches missed.">		if (d1.before(d2)) {</span>
<span class="nc" id="L934">			return d1;</span>
		}
<span class="nc" id="L936">		return d2;</span>
	}

	private Date maxDate(Date d1, Date d2) {
<span class="nc bnc" id="L940" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L941">			return d2;</span>
		}
<span class="nc bnc" id="L943" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L944">			return d1;</span>
		}
<span class="nc bnc" id="L946" title="All 2 branches missed.">		if (d1.before(d2)) {</span>
<span class="nc" id="L947">			return d2;</span>
		}
<span class="nc" id="L949">		return d1;</span>
	}

	public Collection getOrgIDsUnderTOPool(ID pTOPoolID) throws BbmFinderException {
<span class="nc" id="L953">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L955">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L956">			return toPoolDAO.getOrgIDsUnderTOPool(pTOPoolID);</span>
<span class="nc" id="L957">		} catch (Exception e) {</span>
<span class="nc" id="L958">			handleException(e);</span>
<span class="nc" id="L959">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L961" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L962">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public Collection getTOPoolsForEmployees(Collection empIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L968">		EmpTOPoolAssignmentDAO dao = null;</span>
<span class="fc" id="L969">		TOPoolDAO toPoolDAO = null;</span>
<span class="fc" id="L970">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L972">			dao = new EmpTOPoolAssignmentDAO(jdmo);</span>
<span class="fc" id="L973">			toPoolDAO = new TOPoolDAO(jdmo);</span>
<span class="fc" id="L974">			Set toPoolIDSet = dao.getTOPoolIDSetForEmployees(empIDs, dtStart, dtEnd);</span>
<span class="fc" id="L975">			return toPoolDAO.getObjectsByIDs(toPoolIDSet);</span>
<span class="nc" id="L976">		} catch (Exception e) {</span>
<span class="nc" id="L977">			handleException(e);</span>
<span class="nc" id="L978">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L980" title="3 of 4 branches missed.">			if (jdmo != null) {</span>
<span class="pc" id="L981">				jdmo.cleanUp();</span>
			}
		}
	}

	public Collection getTOPoolsForOrgIDs(Collection orgIDs) throws BbmFinderException {
<span class="fc" id="L987">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L989">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L990">			return toPoolDAO.getTOPoolsForOrgIDs(orgIDs);</span>
<span class="nc" id="L991">		} catch (Exception e) {</span>
<span class="nc" id="L992">			handleException(e);</span>
<span class="nc" id="L993">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L995" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L996">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Returns collection of all TOPools in the system. Couldn't be simpler.
	 * @return Returns collection of TOPools
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *          if error occurs while reading from DB
	 */
	public Collection getAllTOPools() throws BbmFinderException {
<span class="nc" id="L1008">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1010">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1011">			return toPoolDAO.getAllTOPools();</span>
<span class="nc" id="L1012">		} catch (Exception e) {</span>
<span class="nc" id="L1013">			handleException(e);</span>
<span class="nc" id="L1014">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1016" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1017">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * get TOPool ids given their names
	 *
	 * @param setTOPoolNames a hashset of organization names
	 * @return a HashMap of (TOPoolName, TOPoolID) pairs
	 */
	public HashMap getTOPoolIDsByNames(HashSet setTOPoolNames) throws BbmFinderException {
<span class="fc" id="L1029">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L1031">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L1032">			return toPoolDAO.getTOPoolIDsByNames(setTOPoolNames);</span>
<span class="nc" id="L1033">		} catch (Exception e) {</span>
<span class="nc" id="L1034">			handleException(e);</span>
<span class="nc" id="L1035">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1037" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L1038">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Return the end date of the last pool assignment after asOfDate for the empID.
	 * @param empID    - The employee ID that we need to find the previous pool assignment for.
	 * @param asOfDate - The date that the pool assignment must occur before.
	 * @return
	 */
	public Date getPreviousPoolAssignmentEnd(ID empID, Date asOfDate) throws BbmFinderException {
<span class="fc" id="L1050">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L1052">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L1053">			return dao.getPreviousPoolAssignmentEnd(empID, asOfDate);</span>
<span class="nc" id="L1054">		} catch (Exception e) {</span>
<span class="nc" id="L1055">			handleException(e);</span>
<span class="nc" id="L1056">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1058" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L1059">				dao.cleanUp();</span>
			}
		}
	}

	/**
	 * Return the start date of the next pool assignment after asOfDate for the empID.
	 * @param empID    - The employee ID that we need to find the next pool assignment for.
	 * @param asOfDate - The date that the pool assignment must occur after.
	 * @return
	 */
	public Date getNextPoolAssignmentStart(ID empID, Date asOfDate) throws BbmFinderException {
<span class="fc" id="L1071">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="fc" id="L1073">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="fc" id="L1074">			return dao.getNextPoolAssignmentStart(empID, asOfDate);</span>
<span class="nc" id="L1075">		} catch (Exception e) {</span>
<span class="nc" id="L1076">			handleException(e);</span>
<span class="nc" id="L1077">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1079" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L1080">				dao.cleanUp();</span>
			}
		}
	}

	public Collection getTOPoolIDsWithWaitListScanEnabled() throws BbmFinderException {
<span class="fc" id="L1086">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="fc" id="L1088">			toPoolDAO = new TOPoolDAO();</span>
<span class="fc" id="L1089">			return toPoolDAO.getTOPoolIDsWithWaitListScanEnabled();</span>
<span class="nc" id="L1090">		} catch (Exception e) {</span>
<span class="nc" id="L1091">			handleException(e);</span>
<span class="nc" id="L1092">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1094" title="3 of 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="pc" id="L1095">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Gets the time of interval calendar for the administrator.
	 */
	public TOIntervalCalendar getTOIntervalCalendarForAdmin(Organization org, ID toPoolID, int year, int month) throws BbmFinderException {
<span class="nc" id="L1104">		return TOIntervalCalendarUtil.getTOIntervalCalendarForAdmin(org, toPoolID, year, month);</span>
	}

	/**
	 * Gets a collection of intervals within the Time off pool over the time range.
	 *
	 * @param timeOffPoolID
	 *            The TOP ID.
	 * @param startDate
	 *            The start of the range.
	 * @param endDate
	 *            The exclusive end of the range.
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Collection&lt;TOIntervalAllocation&gt; getTimeOffIntervals(ID timeOffPoolID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L1121">		methodStart(&quot;getTimeOffIntervals&quot;, timeOffPoolID, startDate, endDate);</span>

<span class="nc" id="L1123">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1125">			dmo = new Jdmo();</span>
<span class="nc" id="L1126">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1127">			return timeoffCalDAO.find(timeOffPoolID, startDate, endDate);</span>
<span class="nc" id="L1128">		} catch (Exception e) {</span>
<span class="nc" id="L1129">			handleException(e);</span>
<span class="nc" id="L1130">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1132" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1133">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1135">			methodFinish();</span>
		}
	}

	/**
	 * Get the intervals for the given entity (Employee or TOP) over the specified date range.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 *
	 * @param employeeID
	 *            If specified, intervals for the employee will be returned based on the employee's TOP assignments.
	 *            All values will be returned.
	 * @param toPoolID
	 *            If specified, the TOP intervals will be returned with allocated, approved, and pending.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @return
	 * @throws BbmFinderException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByInterval(ID employeeID, ID toPoolID, Date startTime, Date endTime)
			throws BbmFinderException {
<span class="nc" id="L1157">		methodStart(&quot;getApprovedAndPendingByInterval&quot;, employeeID, toPoolID, startTime, endTime);</span>

<span class="nc" id="L1159">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1161">			dmo = new Jdmo();</span>
<span class="nc" id="L1162">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1163">			return timeoffCalDAO.getApprovedAndPendingByInterval(employeeID, toPoolID, startTime, endTime);</span>
<span class="nc" id="L1164">		} catch (Exception e) {</span>
<span class="nc" id="L1165">			handleException(e);</span>
<span class="nc" id="L1166">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1168" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1169">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1171">			methodFinish();</span>
		}
	}

	/**
	 * Get the intervals for the Organization over the specified date range with the pending and approved minutes.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 *
	 * @param organizationID
	 *            The organization's ID.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @return
	 * @throws BbmFinderException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByIntervalForOrg(ID organizationID, Date startTime, Date endTime)
			throws BbmFinderException {
<span class="nc" id="L1190">		methodStart(&quot;getApprovedAndPendingByIntervalForOrg&quot;, organizationID, startTime, endTime);</span>

<span class="nc" id="L1192">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1194">			dmo = new Jdmo();</span>
<span class="nc" id="L1195">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1196">			return timeoffCalDAO.getApprovedAndPendingByIntervalForOrg(organizationID, startTime, endTime);</span>
<span class="nc" id="L1197">		} catch (Exception e) {</span>
<span class="nc" id="L1198">			handleException(e);</span>
<span class="nc" id="L1199">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1201" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1202">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1204">			methodFinish();</span>
		}
	}

	/**
	 * Save the time off interval calendar data. All the data must be for a single month.
	 *
	 * @param hTimeOffIntervals - HashMap of all time off intervals per day, key is the short date, values is all intervals of that day
	 * @param pTOPoolID    - ID for the Time-Off Pool.
	 * @param tz -Organization TimeZone
	 * @throws BbmFinderException, RemoteException
	 */

	public int[] saveCalendarTimeOffIntervals(Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals, ID pTOPoolID, TimeZone tz)
			throws BbmCreateDuplicateKeyException, BbmRemoveException, BbmUpdateException {
<span class="nc" id="L1219">		final String l_MethodName = &quot;saveCalendarTimeOffIntervals&quot;;</span>
<span class="nc" id="L1220">		methodStart(l_MethodName, hTimeOffIntervals, pTOPoolID, tz);</span>
<span class="nc" id="L1221">		int[] result = { 0, 0, 0 };</span>
<span class="nc" id="L1222">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1224">			dmo = new Jdmo();</span>
<span class="nc" id="L1225">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
			// save time off intervals
<span class="nc" id="L1227">			result = timeoffCalDAO.saveTimeOffIntervals(pTOPoolID, hTimeOffIntervals, tz);</span>
			// audit time off intervals after the save
			//may be in the FUTURE as time off days
<span class="nc" id="L1230">			triggerWaitlistScan(pTOPoolID, hTimeOffIntervals);</span>
<span class="nc" id="L1231">			return result;</span>
<span class="nc" id="L1232">		} catch (BbmCreateDuplicateKeyException e) {</span>
<span class="nc" id="L1233">			throw e;</span>
<span class="nc" id="L1234">		} catch (Exception e) {</span>
<span class="nc" id="L1235">			handleException(e);</span>
<span class="nc" id="L1236">			m_cat.debug(&quot; Debug for saveCalendarTimeOffIntervals= &quot; + e.toString());</span>
<span class="nc" id="L1237">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1239" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1240">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1242">			methodFinish();</span>
		}
	}

	/**
	 * Saves the Time-off interval calendar data.
	 */
	public void saveTimeOffIntervalCalendar(Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals, ID pTOPoolID, TimeZone tz,
			MonthRange monthRange, BlackoutDay[] blackoutDays) throws BbmUpdateException {
<span class="nc" id="L1251">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1253">			saveCalendarTimeOffIntervals(hTimeOffIntervals, pTOPoolID, tz);</span>

<span class="nc" id="L1255">			dmo = new Jdmo();</span>
<span class="nc" id="L1256">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="nc" id="L1257">			blackoutDAO.saveBlackoutDays(pTOPoolID, monthRange, blackoutDays);</span>
<span class="nc" id="L1258">		} catch (Exception e) {</span>
<span class="nc" id="L1259">			handleException(e);</span>
<span class="nc" id="L1260">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1262" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1263">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1265">			methodFinish();</span>
<span class="nc" id="L1266">		}</span>
<span class="nc" id="L1267">	}</span>

	private void triggerWaitlistScan(ID pTOPoolID, Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals) throws BbmUpdateException {
<span class="nc bnc" id="L1270" title="All 2 branches missed.">		if (hTimeOffIntervals.isEmpty()) {</span>
<span class="nc" id="L1271">			return;</span>
		}
<span class="nc" id="L1273">		Set&lt;LocalDate&gt; keys = hTimeOffIntervals.keySet();</span>
<span class="nc" id="L1274">		LocalDate startDate = keys.iterator().next();</span>
<span class="nc" id="L1275">		LocalDate endDate = startDate;</span>
<span class="nc bnc" id="L1276" title="All 2 branches missed.">		for (LocalDate date : keys) {</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">			if (date.before(startDate)) {</span>
<span class="nc" id="L1278">				startDate = date;</span>
			}
<span class="nc bnc" id="L1280" title="All 2 branches missed.">			if (date.after(endDate)) {</span>
<span class="nc" id="L1281">				endDate = date;</span>
			}
<span class="nc" id="L1283">		}</span>
<span class="nc" id="L1284">		endDate.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1285">		triggerWaitlistScan(pTOPoolID, startDate.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)), endDate.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)));</span>
<span class="nc" id="L1286">	}</span>

	public void deleteTimeOffDays(ID toPoolId, Date startDate, Date endDate) throws BbmRemoveException,BbmFinderException
	{
<span class="nc" id="L1290">		final String l_MethodName = &quot;deleteTimeOffDays&quot;;</span>
<span class="nc" id="L1291">		methodStart(l_MethodName, toPoolId, startDate, endDate);</span>

		try {
<span class="nc" id="L1294">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO();</span>
<span class="nc" id="L1295">			timeoffCalDAO.deleteCalendarTimeOffDays(toPoolId, startDate, endDate);</span>
<span class="nc" id="L1296">        } catch (Exception e) {</span>
<span class="nc" id="L1297">            handleException(e);</span>
<span class="nc" id="L1298">            throw new BbmRemoveException(e);</span>
        } finally {
<span class="nc" id="L1300">            methodFinish();</span>
<span class="nc" id="L1301">        }</span>
<span class="nc" id="L1302">    }</span>

    public void createTimeOffDays(Collection calTimeOffDays) throws BbmCreateException {
<span class="nc" id="L1305">        final String l_MethodName = &quot;createTimeOffDays&quot;;</span>
<span class="nc" id="L1306">        methodStart(l_MethodName, calTimeOffDays);</span>
        try {
<span class="nc" id="L1308">            CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO();</span>
<span class="nc" id="L1309">            timeoffCalDAO.createObjects(calTimeOffDays);</span>
<span class="nc" id="L1310">        } catch (Exception e) {</span>
<span class="nc" id="L1311">            handleException(e);</span>
<span class="nc" id="L1312">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L1314">            methodFinish();</span>

<span class="nc" id="L1316">        }</span>
<span class="nc" id="L1317">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>