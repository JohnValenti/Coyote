<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeIntervalAtTime.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.time</a> &gt; <span class="el_source">TimeIntervalAtTime.java</span></div><h1>TimeIntervalAtTime.java</h1><pre class="source lang-java linenums">/*
 * ï¿½ 2009-2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.time;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashSet;
import java.util.List;

import com.bluepumpkin.common.datatypes.DayOfWeek;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.verint.common.util.IFilter;
import com.bluepumpkin.ejb.bbm.time.TimeInterval.DayStartPolicy;

/**
 * This immutable class is an abstraction for an interval of time that starts at
 * a particular time.
 */
public final class TimeIntervalAtTime implements Comparable&lt;TimeIntervalAtTime&gt;, ISimpleRegion&lt;TimeIntervalAtTime&gt; {
	private Date m_startTime;
	private TimeInterval m_duration;

	/**
	 * Creates a new TimeIntervalAtTime having the specified start time and
	 * duration.
	 * 
	 * @param startTime
	 * @param duration
	 */
<span class="nc" id="L33">	public TimeIntervalAtTime(Date startTime, TimeInterval duration) {</span>
<span class="nc" id="L34">		m_startTime = new Date(startTime.getTime());</span>
<span class="nc" id="L35">		m_duration = duration;</span>
<span class="nc" id="L36">	}</span>

	/**
	 * Creates a new TimeIntervalAtTime that is identical to the source
	 * TimeIntervalAtTime except that it is based on the specified TimeContext.
	 * In particular, the new TimeIntervalAtTime's start time is the same local
	 * time as the source TimeIntervalAtTime's, specified in their respective
	 * time zones. Likewise the new TimeIntervalAtTime's duration is specified
	 * using the target TimeContext's time zone.
	 * 
	 * @param source
	 * @param targetContext
	 */
<span class="nc" id="L49">	public TimeIntervalAtTime(TimeIntervalAtTime source, TimeContext targetContext) {</span>
<span class="nc" id="L50">		Calendar bookmarkStartTime = Calendar.getInstance(source.getTimeContext().getTimeZone());</span>
<span class="nc" id="L51">		bookmarkStartTime.setTime(source.getStartTime());</span>
<span class="nc" id="L52">		Calendar newStartTime = Calendar.getInstance(targetContext.getTimeZone());</span>
<span class="nc" id="L53">		newStartTime.set(bookmarkStartTime.get(Calendar.YEAR), bookmarkStartTime.get(Calendar.MONTH),</span>
<span class="nc" id="L54">				bookmarkStartTime.get(Calendar.DAY_OF_MONTH), bookmarkStartTime.get(Calendar.HOUR_OF_DAY),</span>
<span class="nc" id="L55">				bookmarkStartTime.get(Calendar.MINUTE), bookmarkStartTime.get(Calendar.SECOND));</span>
<span class="nc" id="L56">		newStartTime.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L57">		m_startTime = newStartTime.getTime();</span>
<span class="nc" id="L58">		m_duration = new TimeInterval(source.getDuration(), targetContext);</span>
<span class="nc" id="L59">	}</span>

	/**
	 * Returns a collection of subintervals of the specified duration within
	 * this interval, that satisfy the specified filter. Contiguous intervals
	 * are collected into a single, longer interval.
	 * 
	 * @param granularity
	 * @param filter
	 * @return
	 */
	public Collection&lt;TimeIntervalAtTime&gt; filterInterval(TimeInterval granularity, IFilter&lt;TimeIntervalAtTime&gt; filter) {
<span class="nc" id="L71">		Collection&lt;TimeIntervalAtTime&gt; qualifiedIntervals = new HashSet&lt;TimeIntervalAtTime&gt;();</span>
<span class="nc" id="L72">		boolean inQualifiedInterval = false;</span>
<span class="nc" id="L73">		Date intervalStart = null;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		for (TimeIntervalAtTime candidateInterval : getIntervalSubdivisions(granularity, DayStartPolicy.UseMidnight)) {</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">			if (filter.isAccepted(candidateInterval)) {</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">				if (!inQualifiedInterval) {</span>
<span class="nc" id="L77">					intervalStart = candidateInterval.getStartTime();</span>
<span class="nc" id="L78">					inQualifiedInterval = true;</span>
				}
			} else {
<span class="nc bnc" id="L81" title="All 2 branches missed.">				if (inQualifiedInterval) {</span>
<span class="nc" id="L82">					qualifiedIntervals.add(new TimeIntervalAtTime(intervalStart, new TimeInterval(granularity</span>
<span class="nc" id="L83">							.getUnits(), intervalStart, candidateInterval.getStartTime(), candidateInterval</span>
<span class="nc" id="L84">							.getTimeContext())));</span>
<span class="nc" id="L85">					inQualifiedInterval = false;</span>
				}
			}
<span class="nc" id="L88">		}</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (inQualifiedInterval) {</span>
<span class="nc" id="L90">			qualifiedIntervals.add(new TimeIntervalAtTime(intervalStart, new TimeInterval(granularity.getUnits(),</span>
<span class="nc" id="L91">					intervalStart, getEndTime(), getTimeContext())));</span>
<span class="nc" id="L92">			inQualifiedInterval = false;</span>
		}
<span class="nc" id="L94">		return qualifiedIntervals;</span>
	}

	/**
	 * Returns the start time of this interval.
	 * 
	 * @return
	 */
	public Date getStartTime() {
<span class="nc" id="L103">		return new Date(m_startTime.getTime());</span>
	}

	/**
	 * Returns the end time of this interval.
	 * 
	 * @return
	 */
	public Date getEndTime() {
<span class="nc" id="L112">		return m_duration.getNextTime(m_startTime);</span>
	}

	/**
	 * Returns the duration of this interval.
	 * 
	 * @return
	 */
	public TimeInterval getDuration() {
<span class="nc" id="L121">		return m_duration;</span>
	}

	/**
	 * Returns the time context within which this interval is defined.
	 * 
	 * @return
	 */
	public TimeContext getTimeContext() {
<span class="nc" id="L130">		return m_duration.getTimeContext();</span>
	}

	/**
	 * Returns whether the specified subinterval is completely contained within
	 * this interval.
	 * 
	 * @param subinterval
	 * @return
	 */
	@Override
	public boolean contains(TimeIntervalAtTime subinterval) {
<span class="nc bnc" id="L142" title="All 4 branches missed.">		return !getStartTime().after(subinterval.getStartTime()) &amp;&amp; !getEndTime().before(subinterval.getEndTime());</span>
	}

	/**
	 * Returns whether the specified interval overlaps this interval.
	 * 
	 * @param interval
	 * @return
	 */
	@Override
	public boolean intersects(TimeIntervalAtTime interval) {
<span class="nc bnc" id="L153" title="All 4 branches missed.">		return getStartTime().before(interval.getEndTime()) &amp;&amp; getEndTime().after(interval.getStartTime());</span>
	}

	/**
	 * Returns whether the specified interval is exactly adjacent to this
	 * interval.
	 * 
	 * @param interval
	 * @return
	 */
	@Override
	public boolean adjoins(TimeIntervalAtTime interval) {
<span class="nc bnc" id="L165" title="All 4 branches missed.">		return getStartTime().equals(interval.getEndTime()) || getEndTime().equals(interval.getStartTime());</span>
	}

	/**
	 * Checks for equality.
	 */
	@Override
	public boolean equals(Object o) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">		if (this == o) {</span>
<span class="nc" id="L174">			return true;</span>
		}
<span class="nc bnc" id="L176" title="All 2 branches missed.">		if (!(o instanceof TimeIntervalAtTime)) {</span>
<span class="nc" id="L177">			return false;</span>
		}
<span class="nc" id="L179">		TimeIntervalAtTime other = (TimeIntervalAtTime) o;</span>
<span class="nc bnc" id="L180" title="All 4 branches missed.">		return this.m_startTime.equals(other.m_startTime) &amp;&amp; this.m_duration.equals(other.m_duration);</span>
	}

	/**
	 * Return an appropriate hashcode.
	 * 
	 * Based on code from _Effective Java_ by Joshua Bloch, 1st Ed., item 8.
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L190">		int result = 17;</span>
<span class="nc" id="L191">		result = 37 * result + m_startTime.hashCode();</span>
<span class="nc" id="L192">		result = 37 * result + m_duration.hashCode();</span>
<span class="nc" id="L193">		return result;</span>
	}

	/**
	 * Returns a String representation of this TimeIntervalAtTime.
	 */
	@Override
	public String toString() {
<span class="nc" id="L201">		return m_duration.toString() + &quot; at &quot; + m_startTime.toLocaleString();</span>
	}

	/**
	 * Compares this {@code TimeIntervalAtTime} with the specified
	 * {@code TimeIntervalAtTime}. Returns -1, 0, or 1 as this
	 * {@code TimeIntervalAtTime} is less than, equal to, or greater than the
	 * specified {@code TimeIntervalAtTime}.
	 * &lt;p&gt;
	 * The comparison is based first on start time, then on duration. Earlier
	 * start times are ordered before later start times. Shorter intervals are
	 * ordered before longer intervals.
	 * &lt;p&gt;
	 * Note: The duration part of this comparison is ordered by length, which is
	 * less specific than equality. For example,
	 * &lt;code&gt;7_DAYS_STARTING_JAN_1.compareTo(1_WEEK_STARTING_JAN_1) == 0&lt;/code&gt;,
	 * but
	 * &lt;code&gt;7_DAYS_STARTING_JAN_1.equals(1_WEEK_STARTING_JAN_1) == false&lt;/code&gt;.
	 * &lt;p&gt;
	 * The duration part of this comparison currently operates at one-second
	 * precision.
	 */
	public int compareTo(TimeIntervalAtTime other) {
<span class="nc bnc" id="L224" title="All 2 branches missed.">		if (this.m_startTime.before(other.m_startTime)) {</span>
<span class="nc" id="L225">			return -1;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">		} else if (this.m_startTime.after(other.m_startTime)) {</span>
<span class="nc" id="L227">			return 1;</span>
		} else {
<span class="nc" id="L229">			return compareDuration(other);</span>
		}
	}

	/**
	 * Compares this {@code TimeIntervalAtTime} with the specified
	 * {@code TimeIntervalAtTime} for length. Returns -1, 0, or 1 as this
	 * {@code TimeIntervalAtTime} is shorter than, as long as, or longer than
	 * the specified {@code TimeIntervalAtTime}.
	 * &lt;p&gt;
	 * Note: This comparison is ordered by length, which is less specific than
	 * equality. For example,
	 * 7_DAYS_STARTING_JAN_1.compareTo(1_WEEK_STARTING_JAN_1) == 0, but
	 * 7_DAYS_STARTING_JAN_1.equals(1_WEEK_STARTING_JAN_1) == false.
	 * &lt;p&gt;
	 * This comparison currently operates at one-second precision.
	 */
	public int compareDuration(TimeIntervalAtTime other) {
<span class="nc" id="L247">		long durationDifference = this.getDuration().getDurationInSeconds(this.getStartTime())</span>
<span class="nc" id="L248">				- other.getDuration().getDurationInSeconds(other.getStartTime());</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">		if (durationDifference &gt; 0)</span>
<span class="nc" id="L251">			return 1;</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">		if (durationDifference &lt; 0)</span>
<span class="nc" id="L253">			return -1;</span>
<span class="nc" id="L254">		return 0;</span>
	}

	/**
	 * Returns whether this TimeInterval is longer than the specified other
	 * TimeInterval.
	 * 
	 * @param other
	 * @return
	 */
	public boolean isLongerThan(TimeIntervalAtTime other) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">		return compareDuration(other) &gt; 0;</span>
	}

	/**
	 * Returns whether this TimeInterval is shorter than the specified other
	 * TimeInterval.
	 * 
	 * @param other
	 * @return
	 */
	public boolean isShorterThan(TimeIntervalAtTime other) {
<span class="nc bnc" id="L276" title="All 2 branches missed.">		return compareDuration(other) &lt; 0;</span>
	}

	/**
	 * Returns all the TimeIntervalAtTime objects of &lt;code&gt;divisor&lt;/code&gt; length
	 * and context that contain time represented by this
	 * &lt;code&gt;TimeIntervalAtTime&lt;/code&gt;.
	 * 
	 * This method uses the default behavior for the start of day policy which
	 * is TimeInterval.DayStartPolicy.UseDayBoundary (in other words, it uses
	 * the TimeInterval's time context to determine the start of the day). When
	 * dividing by days, days are therefore assumed to start at the day boundary
	 * defined in the time context. If a different behavior is desired, use
	 * getIntervalSubdivisions(TimeInterval, DayStartPolicy).
	 * 
	 * @return
	 */
	public List&lt;TimeIntervalAtTime&gt; getIntervalSubdivisions(TimeInterval divisor) {
<span class="nc" id="L294">		return getIntervalSubdivisions(divisor, DayStartPolicy.UseDayBoundary);</span>
	}

	/**
	 * Returns all the TimeIntervalAtTime objects of &lt;code&gt;divisor&lt;/code&gt; length
	 * and context that contain time represented by this
	 * &lt;code&gt;TimeIntervalAtTime&lt;/code&gt;.
	 * 
	 * @param divisor
	 * @param dayStartPolicy
	 *            Used when dividing by intervals with a length of a Day.
	 *            DayStartPolicy has two options: UseDayBoundary, which uses the
	 *            TimeInterval's time context to determine the start of a day,
	 *            and UseMidnight, which ignores the time context's day boundary
	 *            and always treats days as starting at midnight. In most cases,
	 *            UseDayBoundary should be used, but optimization applets show
	 *            daily data always as Midnight-Midnight, and the related view
	 *            code requires that a UseMidnight policy be used.
	 * @return
	 */
	public List&lt;TimeIntervalAtTime&gt; getIntervalSubdivisions(TimeInterval divisor, DayStartPolicy dayStartPolicy) {
<span class="nc" id="L315">		List&lt;TimeIntervalAtTime&gt; retVal = new ArrayList&lt;TimeIntervalAtTime&gt;();</span>
<span class="nc" id="L316">		Date timeCursor = divisor.getStartTime(this.getStartTime(), dayStartPolicy);</span>
<span class="nc" id="L317">		Date endTime = this.getEndTime();</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">		while (timeCursor.before(endTime)) {</span>
<span class="nc" id="L319">			retVal.add(new TimeIntervalAtTime(timeCursor, divisor));</span>
<span class="nc" id="L320">			timeCursor = divisor.getNextTime(timeCursor);</span>
		}
<span class="nc" id="L322">		return retVal;</span>
	}

	/**
	 * Returns true if the start and end times of the input interval are both
	 * equal to the start and end times of this interval. Differs from the
	 * equals method in that the duration (TimeInterval) component of these
	 * objects is not compared for equality.
	 */
	public boolean areDateRangesEqual(TimeIntervalAtTime other) {
<span class="nc bnc" id="L332" title="All 4 branches missed.">		return this.getStartTime().equals(other.getStartTime()) &amp;&amp; this.getEndTime().equals(other.getEndTime());</span>
	}

	/**
	 * Adds another {@link TimeIntervalAtTime} to this one and returns a list
	 * containing the resulting interval(s). If this and the other interval
	 * intersect or are adjacent then the result is a list containing a single
	 * interval that is the union of the two intervals, otherwise it is a list
	 * containing the two intervals separately.
	 */
	@Override
	public Collection&lt;TimeIntervalAtTime&gt; add(TimeIntervalAtTime other) {
<span class="nc bnc" id="L344" title="All 2 branches missed.">		if (!this.getTimeContext().equals(other.getTimeContext())) {</span>
<span class="nc" id="L345">			throw new IllegalArgumentException(&quot;Cannot add two intervals with different time contexts.&quot;);</span>
		}
<span class="nc" id="L347">		List&lt;TimeIntervalAtTime&gt; result = new ArrayList&lt;TimeIntervalAtTime&gt;();</span>
<span class="nc bnc" id="L348" title="All 4 branches missed.">		if (this.intersects(other) || this.getStartTime().equals(other.getEndTime())</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">				|| this.getEndTime().equals(other.getStartTime())) {</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">			if (this.contains(other)) {</span>
<span class="nc" id="L351">				result.add(this);</span>
			} else {
<span class="nc bnc" id="L353" title="All 2 branches missed.">				TimeUnits units = (this.getDuration().getUnits().isShorterThan(other.getDuration().getUnits())) ? this</span>
<span class="nc" id="L354">						.getDuration().getUnits() : other.getDuration().getUnits();</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">				Date start = (this.getStartTime().before(other.getStartTime())) ? this.getStartTime() : other</span>
<span class="nc" id="L356">						.getStartTime();</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">				Date end = (this.getEndTime().after(other.getEndTime())) ? this.getEndTime() : other.getEndTime();</span>
<span class="nc" id="L358">				result.add(new TimeIntervalAtTime(start, new TimeInterval(units, start, end, this.getTimeContext())));</span>
<span class="nc" id="L359">			}</span>
		} else {
<span class="nc" id="L361">			result.add(this);</span>
<span class="nc" id="L362">			result.add(other);</span>
		}
<span class="nc" id="L364">		return result;</span>
	}

	/**
	 * Subtracts another {@link TimeIntervalAtTime} from this one and returns a
	 * list containing the resulting intervals, if any. If this and the other
	 * interval are disjoint then the result is a list containing this interval
	 * unchanged; if this is entirely contained in the other then the result is
	 * an empty list; if the other is entirely contained in this then the result
	 * is the two intervals surrounding the other interval; otherwise the result
	 * is a list containing that part of this interval which is outside the
	 * other interval.
	 */
	@Override
	public List&lt;TimeIntervalAtTime&gt; subtract(TimeIntervalAtTime other) {
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (!this.getTimeContext().equals(other.getTimeContext())) {</span>
<span class="nc" id="L380">			throw new IllegalArgumentException(&quot;Cannot add two intervals with different time contexts.&quot;);</span>
		}
<span class="nc" id="L382">		List&lt;TimeIntervalAtTime&gt; result = new ArrayList&lt;TimeIntervalAtTime&gt;();</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">		if (other.contains(this)) {</span>
			// This interval is completely removed by the other interval
			// so we do nothing and return an empty list.
		} else {
<span class="nc bnc" id="L387" title="All 2 branches missed.">			if (other.intersects(this)) {</span>
<span class="nc bnc" id="L388" title="All 2 branches missed.">				TimeUnits units = (this.getDuration().getUnits().isShorterThan(other.getDuration().getUnits())) ? this</span>
<span class="nc" id="L389">						.getDuration().getUnits() : other.getDuration().getUnits();</span>
				// This interval may be split in two, or just shortened.
<span class="nc bnc" id="L391" title="All 2 branches missed.">				if (other.getStartTime().after(this.getStartTime())) {</span>
<span class="nc" id="L392">					result.add(new TimeIntervalAtTime(this.getStartTime(), new TimeInterval(units, this.getStartTime(),</span>
<span class="nc" id="L393">							other.getStartTime(), this.getTimeContext())));</span>
				}
<span class="nc bnc" id="L395" title="All 2 branches missed.">				if (other.getEndTime().before(this.getEndTime())) {</span>
<span class="nc" id="L396">					result.add(new TimeIntervalAtTime(other.getEndTime(), new TimeInterval(units, other.getEndTime(),</span>
<span class="nc" id="L397">							this.getEndTime(), this.getTimeContext())));</span>
				}
<span class="nc" id="L399">			} else {</span>
				// There is no overlap so this interval is unaffected.
<span class="nc" id="L401">				result.add(this);</span>
			}
		}
<span class="nc" id="L404">		return result;</span>
	}

	public DayOfWeek getDayOfWeekAtStartOfInterval() {
<span class="nc" id="L408">		Calendar cal = Calendar.getInstance(this.getTimeContext().getTimeZone());</span>
<span class="nc" id="L409">		cal.setTime(this.getStartTime());</span>
<span class="nc" id="L410">		return DayOfWeek.fromCalendarConstant(cal.get(Calendar.DAY_OF_WEEK));</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>