<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidAuctionUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">ShiftBidAuctionUtil.java</span></div><h1>ShiftBidAuctionUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Aug 19, 2003
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.util;

import java.io.ByteArrayOutputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.io.Serializable;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTemplate;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.Phantom;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.SerializedAuctionDetail;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.MD5;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.SerializedAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManagerEJB;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableScheduleDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidderDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleInstance;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableShift;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestBiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * @author rrajendran
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
<span class="nc bnc" id="L93" title="All 2 branches missed.">public class ShiftBidAuctionUtil {</span>

<span class="nc" id="L95">    private static final Category m_cat = Log.initCategory(ShiftBidAuctionUtil.class.getName());</span>
	public static final String CACHEKEY_PHANTOMS = &quot;ShiftBidAuctionUtil.Phantoms&quot;;
	public static final String CACHEKEY_SKILL_ASSIGNMENTS_FOR_TEMPLATE = &quot;ShiftBidAuctionUtil.SkillAssignmentsForTemplate&quot;;

    //MD5 checksums are 16 bytes long.  String representation as hex number is 32 chars.
//    private static String m_MD5ForShiftNotFound = &quot;0102030405060708090a0b0c0d0e0f&quot;;

    public static final int COLLTYPE_EMPS = 1;
    public static final int COLLTYPE_EMPIDS = 2;

    static final String CACHEKEY_MAXRANK = &quot;CACHEKEY_MAXRANK&quot;;

<span class="nc" id="L107">    private static final String m_className = ShiftBidAuctionUtil.class.getName();</span>

	/**
     * Represents a single shift assignment and its associated shift event assignments.
     *
     * @author rrajendran
     *
     * To change this generated comment go to
     * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
     */
    public static class SingleShiftSchedule {
        public ID m_phantomEmpID;
        public ID m_phantomEmpOrgID;
        public ShiftAssignment m_shiftAssn;
        public List m_shiftEventAssns;

        /**
         * @param phantomEmpOrgID
         * @param phantomShiftAssn
         * @param shiftEventAssns
         */
        public SingleShiftSchedule(ID phantomEmpID, ID phantomEmpOrgID, ShiftAssignment phantomShiftAssn,
            List shiftEventAssns)
<span class="nc" id="L130">        {</span>
<span class="nc" id="L131">            m_phantomEmpID = phantomEmpID;</span>
<span class="nc" id="L132">            m_phantomEmpOrgID = phantomEmpOrgID;</span>
<span class="nc" id="L133">            m_shiftAssn = phantomShiftAssn;</span>
<span class="nc" id="L134">            m_shiftEventAssns = shiftEventAssns;</span>
<span class="nc" id="L135">        }</span>

        @Override
		public String toString() {
<span class="nc" id="L139">            return &quot;SingleShift Schedule: phantomEmpID, phantomOrgID, shiftAssn ID, start, end: &quot; + m_phantomEmpID + ',' +</span>
<span class="nc" id="L140">                m_phantomEmpOrgID + ',' + m_shiftAssn.getID() + ',' + m_shiftAssn.getStartTime() + ',' + m_shiftAssn.getEndTime();</span>
        }
    }


    /**
     * Represents a collection of single Shift Schedules (shift assignments).
     *
     * @author rrajendran
     *
     * To change this generated comment go to
     * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
     */
    public static class WeeklySchedule {
        public ID m_phantomEmpID;
        public ID m_phantomEmpOrgID;
        public List m_singleShiftSchedules;

        /**
         * @param orgID
         * @param singleShiftSchedules
         */
<span class="nc" id="L162">        public WeeklySchedule(ID phantomEmpID, ID orgID, List singleShiftSchedules)   {</span>
<span class="nc" id="L163">            m_phantomEmpID = phantomEmpID;</span>
<span class="nc" id="L164">            m_phantomEmpOrgID = orgID;</span>
<span class="nc" id="L165">            m_singleShiftSchedules = singleShiftSchedules;</span>
<span class="nc" id="L166">        }</span>

        @Override
		public String toString() {
<span class="nc" id="L170">            return &quot;Weekly Schedule: phantomEmpID, phantomOrgID, # of shifts: &quot; + m_phantomEmpID + ',' +</span>
<span class="nc" id="L171">                m_phantomEmpOrgID + ',' + m_singleShiftSchedules.size() + '\n' + RmUtil.dumpCollection(m_singleShiftSchedules);</span>
        }
    }

    /**
     * @author rrajendran
     *
     * To change this generated comment go to
     * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
     */
<span class="nc" id="L181">    public static class ShiftAssignmentComparator implements Comparator&lt;ShiftAssignment&gt; {</span>

        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(ShiftAssignment o1, ShiftAssignment o2) {
<span class="nc" id="L188">            long diff = o1.getStartTime().getTime() - o2.getEndTime().getTime();</span>
<span class="nc bnc" id="L189" title="All 4 branches missed.">            return (diff == 0)?0:(diff &lt; 0)?-1:1;</span>
        }

    }

<span class="nc" id="L194">    public static class ShiftEventAssignmentComparator implements Comparator {</span>
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L197">        	ShiftEventAssignment event1 = (ShiftEventAssignment)o1;</span>
<span class="nc" id="L198">        	ShiftEventAssignment event2 = (ShiftEventAssignment)o2;</span>

        	//compare Activity ID
<span class="nc" id="L201">        	long diff = event1.getActivityID().compareTo(event2.getActivityID());</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">        	if(diff == 0) { //compare start time</span>
<span class="nc" id="L203">            	diff = event1.getStartTime().getTime() - event2.getStartTime().getTime();</span>
        	}
<span class="nc bnc" id="L205" title="All 2 branches missed.">        	if(diff == 0) { //compare end time</span>
<span class="nc" id="L206">            	diff = event1.getEndTime().getTime() - event2.getEndTime().getTime();</span>
        	}

<span class="nc bnc" id="L209" title="All 4 branches missed.">            return (diff == 0)?0:(diff &lt; 0)?-1:1;</span>
        }
    }

<span class="nc" id="L213">    public static class BiddableShiftComparator implements Comparator  {</span>
        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L219">            return ((BiddableShift)o1).getOrder() - ((BiddableShift) o2).getOrder();</span>
        }
    }

<span class="nc" id="L223">    public static class ShiftBidRequestBiddableScheduleComparator implements Comparator  {</span>
        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L229">            return ((ShiftBidRequestBiddableSchedule)o1).getOrder() -</span>
<span class="nc" id="L230">                ((ShiftBidRequestBiddableSchedule) o2).getOrder();</span>
        }
    }

    /**
     * Comparator to sort shift bid requests.  Sorting is done using the score assigned
     * to shift bid requests (req's score is the bidder's score).
     *
     * Title:        Blue Pumpkin Software Request Management Module
     * Copyright:    Copyright (c) 2001-2004
     * Company:      Blue Pumpkin Software, inc
     * @author       Raja Rajendran
     */
    public static class ShiftBidRequestComparatorUsingScore implements Comparator {

<span class="nc" id="L245">        ID m_rankingForBidderID = null;</span>
<span class="nc" id="L246">        boolean m_rankByScoreWithBonus = false;</span>

        /**
         * Comparator to rank shift bid requests by 'score'.  The score used can either
         * be 'scoreWithBonus' or 'scoreWithoutBonus' based on the 'withBonus' flag. See
         * parameter doc for further details.
         *
         * @param rankingForBidderID
         * &lt;li&gt; if non-null, then sorting of sbReqs is done in the context
         * of this bidder.  In this case either the 'scoreWithBonus'
         * or 'scoreWithoutBonus' is used, based on the 'withBonus' parameter, only for
         * the requests which belongs to this bidder ID.  For requests
         * belonging to other bidders, the score is computed using the request's 'useBonus' flag.
         * &lt;li&gt; if null, then sorting is done using the score based on the 'useBonus' flag of the requests.
         * The 'withBonus' parameter is ignored in this case.
         * @param withBonus used only if 'rankingForBidderID' parm is non-null.  If 'null' ignored.
         * See doc for 'rankingForBidderID' for more info.
         */
<span class="nc" id="L264">        public ShiftBidRequestComparatorUsingScore(ID rankingForBidderID, boolean withBonus) {</span>
<span class="nc" id="L265">            m_rankingForBidderID = rankingForBidderID;</span>
<span class="nc" id="L266">            m_rankByScoreWithBonus = withBonus;</span>
<span class="nc" id="L267">        }</span>

        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L274">            ShiftBidRequest sbReq1 = ((ShiftBidRequest)o1);</span>
<span class="nc" id="L275">            int score1 = 0;</span>
            // if request belongs to the bidder , use the score with bonus or score without bonus
            // based on m_rankByScoreWithBonus member.
<span class="nc bnc" id="L278" title="All 4 branches missed.">            if (m_rankingForBidderID != null &amp;&amp; m_rankingForBidderID.equals(sbReq1.getShiftBidderID())) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">                score1 = (m_rankByScoreWithBonus)?sbReq1.getOptMethods().getScoreWithBonus():</span>
<span class="nc" id="L280">                            sbReq1.getOptMethods().getScoreWithoutBonus();</span>
            } else { // if bid request does not belong to the user, get the score based on 'isBonusUsed' flag in sbReq
<span class="nc" id="L282">                score1 = sbReq1.getOptMethods().getScoreUsingIsBonusFlag();</span>
            }


<span class="nc" id="L286">            ShiftBidRequest sbReq2 = (ShiftBidRequest)o2;</span>
<span class="nc" id="L287">            int score2 = 0;</span>
            // if request belongs to the bidder , use the score with bonus or score without bonus
            // based on m_rankByScoreWithBonus member.
<span class="nc bnc" id="L290" title="All 4 branches missed.">            if (m_rankingForBidderID != null &amp;&amp; m_rankingForBidderID.equals(sbReq2.getShiftBidderID())) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">                score2 = (m_rankByScoreWithBonus)?sbReq2.getOptMethods().getScoreWithBonus():</span>
<span class="nc" id="L292">                            sbReq2.getOptMethods().getScoreWithoutBonus();</span>
            } else {// if bid request does not belong to the user, get the score based on 'isBonusUsed' flag in sbReq
<span class="nc" id="L294">                score2 = sbReq2.getOptMethods().getScoreUsingIsBonusFlag();</span>
            }

<span class="nc" id="L297">            return  score1 - score2;</span>
        }
    }

    public static class ShiftBidRequestComparatorUsingScoreAndPrefASC extends  ShiftBidRequestComparatorUsingScore {

        /**
         * @param rankingForBidderID
         * @param withBonus
         */
        public ShiftBidRequestComparatorUsingScoreAndPrefASC(ID rankingForBidderID, boolean withBonus) {
<span class="nc" id="L308">            super(rankingForBidderID, withBonus);</span>
<span class="nc" id="L309">        }</span>

        /* (non-Javadoc)
         * @see com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScore#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L316">            int result = super.compare(o1, o2);</span>

            // 2 or more requests submitted by the same employee must be sorted with
            // preference as the secondary sort key if primary sort key (score) is the same.
            //
            // if the 'score' for the requests are equal
<span class="nc bnc" id="L322" title="All 2 branches missed.">            if (result  == 0 ) {</span>
<span class="nc" id="L323">                ShiftBidRequest sbReq1 = (ShiftBidRequest) o1;</span>
<span class="nc" id="L324">                ShiftBidRequest sbReq2 = (ShiftBidRequest) o2;</span>

                // check if requests are from same employee
<span class="nc bnc" id="L327" title="All 2 branches missed.">                if (sbReq1.getEmployeeID().equals(sbReq2.getEmployeeID())) {</span>
                    // use 'preference' as a secondary sort criteria
<span class="nc" id="L329">                    result = sbReq1.getPreference() - sbReq2.getPreference();</span>
                }
            }

<span class="nc" id="L333">            return result;</span>
        }
    }

    public static class ShiftBidRequestComparatorUsingScoreAndPrefDESC extends  ShiftBidRequestComparatorUsingScore {

        /**
         * @param rankingForBidderID
         * @param withBonus
         */
        public ShiftBidRequestComparatorUsingScoreAndPrefDESC(ID rankingForBidderID, boolean withBonus) {
<span class="nc" id="L344">            super(rankingForBidderID, withBonus);</span>
<span class="nc" id="L345">        }</span>

        /* (non-Javadoc)
         * @see com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScore#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
        	// Sort DESC Score by multiply by -1
<span class="nc" id="L353">            int result = -1 * super.compare(o1, o2);</span>

            // 2 or more requests submitted by the same employee must be sorted with
            // preference as the secondary sort key if primary sort key (score) is the same.
            //
            // if the 'score' for the requests are equal
<span class="nc bnc" id="L359" title="All 2 branches missed.">            if (result  == 0 ) {</span>
<span class="nc" id="L360">                ShiftBidRequest sbReq1 = (ShiftBidRequest) o1;</span>
<span class="nc" id="L361">                ShiftBidRequest sbReq2 = (ShiftBidRequest) o2;</span>

                // check if requests are from same employee
<span class="nc bnc" id="L364" title="All 2 branches missed.">                if (sbReq1.getEmployeeID().equals(sbReq2.getEmployeeID())) {</span>
                	// keep Pref ASC
                    // use 'preference' as a secondary sort criteria
<span class="nc" id="L367">                    result = sbReq1.getPreference() - sbReq2.getPreference();</span>
                }
            }

<span class="nc" id="L371">            return result;</span>
        }
    }

    public static class ShiftBidderComparator implements Comparator{
<span class="nc" id="L376">        private int m_rankBy = -1;</span>

        /**
         * @param rankBy
         */
<span class="nc" id="L381">        public ShiftBidderComparator(int rankBy) {</span>
<span class="nc" id="L382">            m_rankBy = rankBy;</span>
<span class="nc" id="L383">        }</span>

        /* (non-Javadoc)
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L390">            ShiftBidder bidder1 = (ShiftBidder) o1;</span>
<span class="nc" id="L391">            ShiftBidder bidder2 = (ShiftBidder) o2;</span>

<span class="nc bnc" id="L393" title="All 6 branches missed.">            switch (m_rankBy) {</span>
                case ShiftBidder.RANKBY_ACCUMULATEDBONUS:
<span class="nc" id="L395">                    return bidder1.getOptMethods().getAccumulatedBonus() -</span>
<span class="nc" id="L396">                        bidder2.getOptMethods().getAccumulatedBonus();</span>
                case ShiftBidder.RANKBY_EMPLOYEERANK:
                    // For employee rank, a lower value means a higher rank (for example
                    // a rank of 1 is higher than a rank of 2).  For this reason we compute
                    // (bidder2.rank - bidder1.rank) instead of (bidder1.rank - bidder2.rank)
<span class="nc" id="L401">                    return bidder2.getOptMethods().getEmployee().getRank() -</span>
<span class="nc" id="L402">                        bidder1.getOptMethods().getEmployee().getRank();</span>
                case ShiftBidder.RANKBY_SENIORITY:
<span class="nc" id="L404">                    return bidder1.getOptMethods().getEmployee().getSeniority() -</span>
<span class="nc" id="L405">                        bidder2.getOptMethods().getEmployee().getSeniority();</span>
                case ShiftBidder.RANKBY_SCORE:
<span class="nc" id="L407">                    return bidder1.getOptMethods().getScoreWithBonus() -</span>
<span class="nc" id="L408">                        bidder2.getOptMethods().getScoreWithBonus();</span>
                case ShiftBidder.RANKBY_SHIFTBIDDER_BONUS:
<span class="nc" id="L410">                    return bidder1.getBonusThisAuction() - bidder2.getBonusThisAuction();</span>
                default:
<span class="nc" id="L412">                    throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
            }
        }
    }

    /**
     * @author rrajendran
     *
     * To change this generated comment go to
     * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
     */
<span class="nc" id="L423">    public static class ValueObjectBaseIDComparator implements Comparator {</span>

        /**
         * Compare two value object bases based on ID;
         *
         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
         */
        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L432">            ID obj1ID = ((ValueObjectBase)o1).getID();</span>
<span class="nc" id="L433">            ID obj2ID = ((ValueObjectBase)o2).getID();</span>

<span class="nc" id="L435">            return obj1ID.compareTo(obj2ID);</span>
        }
    }

//  QA 81714 - Compare skill ID insted of Skill Assignment ID (null)
<span class="nc" id="L440">    public static class SkillAssignmentComparator implements Comparator {</span>

        @Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L444">            ID skill1ID = ((SkillAssignment)o1).getSkillID();</span>
<span class="nc" id="L445">            ID skill2ID = ((SkillAssignment)o2).getSkillID();</span>

<span class="nc" id="L447">            return skill1ID.compareTo(skill2ID);</span>
        }
    }

    private static String computeMD5Hash(StringBuffer signature) throws IOException {
<span class="nc" id="L452">        m_cat.debug(&quot;computeMD5Hash for: &quot; + signature);</span>

        // convert signature to byte[]
<span class="nc" id="L455">        ByteArrayOutputStream byteOutStr = new ByteArrayOutputStream();</span>
<span class="nc" id="L456">        DataOutputStream dataOutStream = new DataOutputStream(byteOutStr);</span>
<span class="nc" id="L457">        dataOutStream.writeChars(signature.toString());</span>
<span class="nc" id="L458">        dataOutStream.close();</span>

        // compute MD5 hash
<span class="nc" id="L461">        MD5 md5 = new MD5();</span>
<span class="nc" id="L462">        md5.update(byteOutStr.toByteArray());</span>
<span class="nc" id="L463">        byte[] md5Hash = new byte[16];</span>
<span class="nc" id="L464">        md5.md5final(md5Hash);</span>

<span class="nc" id="L466">        StringBuffer md5HashStrbuf = new StringBuffer(64);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">        for (int k = 0; k &lt; md5Hash.length; k++) {</span>
<span class="nc" id="L468">            String hexDigitStr = Integer.toHexString(md5Hash[k]);</span>
            // range of byte values: -128 to 127.  toHexString() translates -ve values with
            // the prefix ffffff.  Strip the prefix to make hex string 2 chars long.
<span class="nc" id="L471">            String negativePrefix = &quot;ffffff&quot;;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (hexDigitStr.startsWith(negativePrefix)) hexDigitStr = hexDigitStr.substring(negativePrefix.length());</span>

            // if hexDigitStr is 1 char long, prefix it with &quot;0&quot;.
<span class="nc bnc" id="L475" title="All 2 branches missed.">            md5HashStrbuf.append((hexDigitStr.length() == 1)?&quot;0&quot;:&quot;&quot;).append(hexDigitStr);</span>
        }

<span class="nc bnc" id="L478" title="All 4 branches missed.">        assert md5HashStrbuf.length() == 32:&quot;md5HashStr.length() = &quot; + md5HashStrbuf.length();</span>

<span class="nc" id="L480">        return md5HashStrbuf.toString();</span>
    }

    /**
     * &lt;p&gt; Computes the MD5 checksum for the biddable schedule instances associated with the
     * given biddableschedule.  The parameter 'firstBidSchedInstOnly' determines if the
     * checksum is computed only for the first bidSchedInstance or all bidSchedInstances.
     *
     * @return a List of computed MD5 checksums.
     * For a valid biddableSchedule, the # of entries in the list matches {@link BiddableSchedule#getNumOfAvailableInstances() getNumOfAvailableInstances()}.
     * For an invalid biddableSchedule, this count or its entries may be inconsitent as
     * follows:
     * &lt;li&gt; The list may be empty if all bidSchedIntances associated with the bidSched were removed
     * from the DB (this can happen if all phantoms were deleted from DE).
     * &lt;li&gt; # of entries in the returned md5 list may not match the bidSched.getnumOfAvailInstances().
     * This can happen if the phantoms are deleted outside RM (for instance, if a few phantoms were
     * deleted from DE).
     * &lt;li&gt; An md5 element may be 'null' if the bidSchedInstance associated with the bidSched does not
     * have any associated shift assignments (ie all shift assignments associated
     * with the biddableScheduleInstance have been deleted)
     * @throws Exception
     */
    public static List&lt;String&gt; computeMD5ForBiddableSched(BiddableSchedule bidSched, boolean firstBidSchedInstOnly, SimpleCache cache)
        throws Exception
    {
<span class="nc" id="L505">        ID phantomOrgID = bidSched.getOrgID();</span>

        // MD5 computation for firstBidSchedInstance only or all the biddable schedule instances.
<span class="nc" id="L508">        List bidSchedInsts = null;</span>
<span class="nc bnc" id="L509" title="All 2 branches missed.">        if (firstBidSchedInstOnly) {</span>
<span class="nc" id="L510">			BiddableScheduleInstance firstAvailBidSchedInst =</span>
<span class="nc" id="L511">				bidSched.getOptMethods().getFirstAvailBiddableSchedInst();</span>

			// firstAvailBidSchedInst == null if the bidSchedInst was deleted during the deletion of the
			// phantom in DE.  See javadoc for bidSched.getFirstAvailBidSchedInst().
<span class="nc bnc" id="L515" title="All 2 branches missed.">            bidSchedInsts = (firstAvailBidSchedInst == null)?Collections.EMPTY_LIST:Collections.singletonList(firstAvailBidSchedInst);</span>
<span class="nc" id="L516">        } else {</span>
<span class="nc" id="L517">			bidSchedInsts = bidSched.getOptMethods().getBiddableScheduleInstances();</span>
        }

<span class="nc" id="L520">        SkillManager skillMgr = WfmManagerFactory.getSkillManager();</span>
<span class="nc" id="L521">        ScheduleAccessManager scheduleMgr = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L522">		ShiftBidAuctionManager sbAuctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L524">		ShiftBidAuction auction = sbAuctionMgr.getAuctionByID(bidSched.getShiftBidAuctionID(), ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L526">        Date currDate = new Date();  //TODO: use the auction's start and end time.</span>
<span class="nc" id="L527">        StringBuffer signature = new StringBuffer(256);</span>

<span class="nc" id="L529">        List&lt;String&gt; md5List = new ArrayList&lt;String&gt;(5);</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">        for (Iterator bidSchedInstIter = bidSchedInsts.iterator(); bidSchedInstIter.hasNext();) {</span>
<span class="nc" id="L531">            BiddableScheduleInstance bidSchedInst = (BiddableScheduleInstance) bidSchedInstIter.next();</span>

<span class="nc" id="L533">			ID phantomEmpID = bidSchedInst.getPhantomEmployeeID();</span>

			//QA 80189 - Shift Bidding combines different shift(s) together but it's wrong
	        //get skill for employeeTemplateID insted of employeeID
<span class="nc" id="L537">			Phantom phantom = getPhantom(scheduleMgr, bidSchedInst, phantomEmpID, cache);</span>

<span class="nc" id="L539">			Collection&lt;SkillAssignment&gt; skillsColl = getSkillAssignmentsForTemplate(skillMgr, phantom.getEmployeeTemplateID(),</span>
					currDate, cache);

<span class="nc" id="L542">			List phantomSkillsListSorted = getSkillsForPhantomSorted(phantomEmpID, skillsColl);</span>

<span class="nc" id="L544">			signature.delete(0, signature.length());</span>

			// QC#182931 ([QVC - Approved Bid Withdrawal] Withdrawing a bid that has a stitched shift involving an identical shift gives an error)
			// Problem: For multishift approved requests, if a &quot;shift block&quot; was stitched to a bigger shift, the checksum of that shift will not match
			// the checksum of its BSI's BiddableSchedule, so the BSI  will be consider invalid and will be deleted (which is incorrect)
			// Solution: if the stitched shift was not modified since approval, for checksum calculation, we will replace the stitched shift with
			// an &quot;equivalent&quot; &quot;in memory&quot; shift having same attributes as the original phantom's shift (i.e. before approval happens) to make sure
			// checksum will match the BiddableSchedule's checksum
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L553">			List&lt;ShiftAssignment&gt; shiftAssignments = bidSchedInst.getOptMethods().getShiftAssignments();</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">			if (shiftAssignments != null &amp;&amp; shiftAssignments.size()&gt;0) {</span>
<span class="nc bnc" id="L555" title="All 8 branches missed.">				if (bidSchedInst.getStatus() == BiddableScheduleInstance.STATUS_ASSIGNED &amp;&amp; bidSchedInst.getPhantomStartTime() != null &amp;&amp; bidSchedInst.getPhantomEndTime() != null &amp;&amp; shiftAssignments.size() == 1</span>
<span class="nc bnc" id="L556" title="All 4 branches missed.">						&amp;&amp; !shiftAssignments.get(0).getStartTime().equals(bidSchedInst.getPhantomStartTime()) || !shiftAssignments.get(0).getEndTime().equals(bidSchedInst.getPhantomEndTime())) {</span>
<span class="nc bnc" id="L557" title="All 4 branches missed.">					if (auction.getIsMultiShift() &amp;&amp; ShiftBidAuctionUtil.computeMD5(shiftAssignments.get(0)).equals(bidSchedInst.getBidSchedInstCheckSum())) {</span>
<span class="nc" id="L558">						TimeRange blockRange = new TimeRange(bidSchedInst.getPhantomStartTime(), bidSchedInst.getPhantomEndTime());</span>
						// Create an &quot;equivalent&quot; &quot;in memory&quot; shift having same attributes as the original phantom's shift
<span class="nc" id="L560">						ShiftAssignment blockShiftAssignment = RequestUtil.createCustomShiftAssignment(shiftAssignments.get(0), bidSchedInst);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">						for (ShiftEventAssignment event : shiftAssignments.get(0).getChildren()) {</span>
<span class="nc" id="L562">							TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">							if (eventRange.equals(blockRange) || eventRange.getOverlapDuration(blockRange) &gt; 0) {</span>
<span class="nc" id="L564">								blockShiftAssignment.addShiftEventAssignment(RequestUtil.createCustomShiftEvent(event, bidSchedInst));</span>
							}
<span class="nc" id="L566">						}</span>
						// Replace actual shift assignment by the new &quot;equivalent&quot; &quot;in memory&quot; shift assignment
						// so generated MD5 checksum will match checksum of original shift &quot;block&quot; from phantom
<span class="nc" id="L569">						shiftAssignments = Arrays.asList(blockShiftAssignment);</span>
<span class="nc" id="L570">					}</span>
				}
			} else {
<span class="nc" id="L573">				RmException rmExc = new RmException(RmEjbBundleKey.BUNDLE_NAME,</span>
						RmEjbBundleKey.SBR_ONE_OR_MORE_BIDSCHEDS_BECAME_INVALID, null);
<span class="nc bnc" id="L575" title="All 2 branches missed.">				if (m_cat != null) {</span>
<span class="nc" id="L576">					m_cat.error(rmExc, rmExc);</span>
				}
<span class="nc" id="L578">				throw rmExc;</span>
			}

<span class="nc" id="L581">			String md5 = computeMD5AndCreateWeeklyOrSingleShiftSched(bidSched.getIsFullPeriod(), signature,</span>
				phantomEmpID, phantomOrgID, shiftAssignments,
				false, phantomSkillsListSorted, null);

			// A null entry will be added to this list when when there are no
			// shift assignments associated with the bidSchedInstance.
<span class="nc" id="L587">			md5List.add(md5);</span>
<span class="nc" id="L588">        }</span>

<span class="nc" id="L590">        return md5List;</span>
    }

	/**
	 * Gets the Skill Assignments for the employee template. First it looks in the SimpleCache and then falls back
	 * to the skill manager.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	private static Collection&lt;SkillAssignment&gt; getSkillAssignmentsForTemplate(SkillManager skillMgr, ID employeeTemplateID, Date currDate,
			SimpleCache cache) throws BbmFinderException, RemoteException {
<span class="nc" id="L600">		Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; skillAssignmentCache = cache.getMap(CACHEKEY_SKILL_ASSIGNMENTS_FOR_TEMPLATE);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">		if (skillAssignmentCache.containsKey(employeeTemplateID)) {</span>
<span class="nc" id="L602">			return skillAssignmentCache.get(employeeTemplateID);</span>
		}
<span class="nc" id="L604">		Collection&lt;SkillAssignment&gt; skillAssignments = skillMgr.getSkillAssignmentsForTemplate(employeeTemplateID, currDate, currDate);</span>
<span class="nc" id="L605">		skillAssignmentCache.put(employeeTemplateID, skillAssignments);</span>
<span class="nc" id="L606">		return skillAssignments;</span>
	}

	/**
	 * Gets the phantom employee from the BiddableScheduleInstance, the cache or loads it from the ScheduleManager.
	 */
	private static Phantom getPhantom(ScheduleAccessManager scheduleMgr, BiddableScheduleInstance bidSchedInst, ID phantomEmpID,
			SimpleCache cache) throws BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L614">		Phantom phantom = null;</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">		if ((bidSchedInst.getDetailLevel() &amp; BiddableScheduleInstance.DL_EMPLOYEE) != 0) {</span>
<span class="nc" id="L616">			phantom = bidSchedInst.getOptMethods().getEmployee();</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">			if (phantom != null) {</span>
<span class="nc" id="L618">				return phantom;</span>
			}
		}

<span class="nc" id="L622">		Map&lt;ID, Phantom&gt; phantomCache = cache.getMap(CACHEKEY_PHANTOMS);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">		if (phantomCache.containsKey(phantomEmpID)) {</span>
<span class="nc" id="L624">			return phantomCache.get(phantomEmpID);</span>
		}

<span class="nc" id="L627">		phantom = scheduleMgr.getPhantomByID(phantomEmpID);</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">		if (phantom != null) {</span>
<span class="nc" id="L629">			phantomCache.put(phantomEmpID, phantom);</span>
		}
<span class="nc" id="L631">		return phantom;</span>
	}

    /**
     * @param phantomEmpID
     * @return
     */
    private static List getSkillsForPhantomSorted(ID phantomEmpID, Collection phanSkillsColl) {
<span class="nc" id="L639">        List phanSkillsSortedList = Collections.EMPTY_LIST;</span>
<span class="nc bnc" id="L640" title="All 4 branches missed.">        if (phanSkillsColl != null &amp;&amp; !phanSkillsColl.isEmpty()) {</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">            if (phanSkillsColl.size() == 1) {</span>
<span class="nc" id="L642">                phanSkillsSortedList = Collections.singletonList(phanSkillsColl.iterator().next());</span>
            } else {
<span class="nc" id="L644">                phanSkillsSortedList = RequestUtil.getListFromCollection(phanSkillsColl);</span>
<span class="nc" id="L645">                Collections.sort(phanSkillsSortedList, new SkillAssignmentComparator());</span>
            }
        }

<span class="nc" id="L649">        return phanSkillsSortedList;</span>
    }

    /**
     * Dual purpose method:
     * Given a single phantom's shiftAssignments, orgID and skills, this method
     * &lt;li&gt; optionally computes the signature (string used to computed MD5) and the MD5 (using the above data)
     * &lt;li&gt; optioanlly creates a weekly/singleShift schedule.
     *
     * &lt;p&gt;  The following is used to assemble the 'signature':
     * &lt;li&gt; phantom orgID
     * &lt;li&gt; phantom skills.
     * &lt;li&gt; shift assignments (starttime, endtime)
     * &lt;li&gt; shift event assignments (starttime, endtime).
     *
     * &lt;p&gt; Besides the return value, the parameters 'signature' and 'outputWeeklyOrSingleShiftSched' also
     * contain data to be returned to the caller.
     *
     * @param isFullPeriodSched
     * @param signature  if non-null, the signature which will be used for md5 computation is assembled and
     * stored here. If null, then no signature is assembled
     * computed.
     * @param phantomEmpID
     * @param phantomOrgID
     * @param phantomShiftAssns
     * @param areShiftAssnsSorted
     * @param outputWeeklyOrSingleShiftSched  if non-null, it is initialized as either a
     * {@link ShiftBidAuctionUtil.SingleShiftSchedule SingleShiftSchedule} or
     * {@link ShiftBidAuctionUtil.WeeklySchedule WeeklySchedule} using the other parameters.
     *
     * @return the MD5 checksum from the signature.  If signature is null, then a 'null' MD5 is returned.
     * @throws IOException
     */
    public static String computeMD5AndCreateWeeklyOrSingleShiftSched(boolean isFullPeriodSched, StringBuffer signature,
        ID phantomEmpID, ID phantomOrgID, List phantomShiftAssns, boolean areShiftAssnsSorted,
        List phantomSkillsSortedList, Object outputWeeklyOrSingleShiftSched ) throws IOException
    {
<span class="nc bnc" id="L686" title="All 6 branches missed.">        if (!isFullPeriodSched) assert phantomShiftAssns.size() &lt;= 1:&quot;!isFullPeriodSchecule &amp;&amp; phantomShiftAssns.size() &lt;= 1&quot;;</span>

<span class="nc bnc" id="L688" title="All 4 branches missed.">        if (phantomShiftAssns == null || phantomShiftAssns.isEmpty())  return null;</span>

        //TODO: handle case where employee has no shift assignments for scheduling period, ie. phantomShiftAssns list is
        // empty.  This must be handled in this method's caller and not here.
<span class="nc bnc" id="L692" title="All 4 branches missed.">        if (!areShiftAssnsSorted &amp;&amp; phantomShiftAssns.size() &gt; 1)</span>
<span class="nc" id="L693">            Collections.sort(phantomShiftAssns, new ShiftAssignmentComparator());</span>

<span class="nc bnc" id="L695" title="All 4 branches missed.">        if (!isFullPeriodSched &amp;&amp; phantomShiftAssns.size() != 1)</span>
<span class="nc" id="L696">            throw new IllegalArgumentException(&quot;isFullPeriodSched &amp;&amp; phantomShiftAssns.size() != 1: &quot; + phantomShiftAssns.size());</span>

        // cast the passed argument to weeklySchedule if isFullPeriodSched == true
<span class="nc bnc" id="L699" title="All 4 branches missed.">        WeeklySchedule outputWeeklySched = (outputWeeklyOrSingleShiftSched != null &amp;&amp; isFullPeriodSched)?</span>
            (WeeklySchedule) outputWeeklyOrSingleShiftSched:null;

        // cast the passed argument to singleShiftSchedule if isFullPeriodSched == true
<span class="nc bnc" id="L703" title="All 4 branches missed.">        SingleShiftSchedule outputSingleShiftSched = (outputWeeklyOrSingleShiftSched != null &amp;&amp; !isFullPeriodSched)?</span>
            (SingleShiftSchedule) outputWeeklyOrSingleShiftSched:null;

<span class="nc bnc" id="L706" title="All 2 branches missed.">        if (signature != null) {</span>
            // org ID
<span class="nc" id="L708">            signature.append(&quot;orgid;&quot;).append(phantomOrgID).append(';');</span>
            // skills
<span class="nc bnc" id="L710" title="All 2 branches missed.">            if (phantomSkillsSortedList != null) appendSkillsSignature(phantomSkillsSortedList, signature);</span>
        }

        // Shift assignments for **an** employee which needs to be transformed into a single shift
        // schedule or weeklySchedule (based on isFullPeriodSched). The MD5 checksum is computed as well
        // if necessary.
<span class="nc bnc" id="L716" title="All 2 branches missed.">        for (int shiftAssnsIdx =0; shiftAssnsIdx  &lt; phantomShiftAssns.size(); shiftAssnsIdx++ )  {</span>
<span class="nc" id="L717">            ShiftAssignment shiftAssn = (ShiftAssignment) phantomShiftAssns.get(shiftAssnsIdx);</span>

            // verify that all shift assignments belong to the same phantom.
            //ID empID = (ID) shiftAssn.getWorkResourceIDs().iterator().next();
			//empID is not necessarily phantomEmpID
			//If this function is called after the request is approved empId will be the id of the employee making the request

<span class="nc bnc" id="L724" title="All 2 branches missed.">            if (signature != null) {</span>
                // add shift start and end time to signature
<span class="nc" id="L726">                appendShiftAssnSignature(shiftAssn, signature);</span>
            }

            //get shift event Assignments for this shiftAssignment and sort.
<span class="nc" id="L730">            List shiftEventAssnList = RequestUtil.getListFromCollection(shiftAssn.getChildren());</span>
            //method getListFromCollection() might return a Collections.singletonList() which does not
            // allow its set() method to be called (immutable list).  The check below prevents this.
<span class="nc bnc" id="L733" title="All 2 branches missed.">            if (shiftEventAssnList.size() &gt; 1)  {</span>
<span class="nc" id="L734">                Collections.sort(shiftEventAssnList, new ShiftEventAssignmentComparator());</span>
            }

            // add shift event assignment to signature.
<span class="nc bnc" id="L738" title="All 2 branches missed.">            if (signature != null) {</span>
<span class="nc" id="L739">                for (int shiftEventAssnIdx =0;</span>
<span class="nc bnc" id="L740" title="All 4 branches missed.">                    shiftEventAssnList != null &amp;&amp; shiftEventAssnIdx  &lt; shiftEventAssnList.size(); shiftEventAssnIdx ++)  {</span>

<span class="nc" id="L742">                    ShiftEventAssignment shiftEventAssn = ((ShiftEventAssignment)shiftEventAssnList.get(shiftEventAssnIdx ));</span>
<span class="nc" id="L743">                    appendShiftEventAssnSignature(signature, shiftEventAssn);</span>
                }
            }

<span class="nc bnc" id="L747" title="All 2 branches missed.">            if (outputWeeklySched != null) {</span>
<span class="nc" id="L748">                SingleShiftSchedule sss = new SingleShiftSchedule(phantomEmpID, phantomOrgID, shiftAssn, shiftEventAssnList);</span>
<span class="nc" id="L749">                outputWeeklySched.m_singleShiftSchedules.add(sss);</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">            } else if (outputSingleShiftSched != null) {</span>
                //Note: only one shift assignment associated with this biddableSchedInst (single shift biddable schedule instance)
<span class="nc bnc" id="L752" title="All 4 branches missed.">                assert outputSingleShiftSched.m_phantomEmpID != null;</span>
<span class="nc bnc" id="L753" title="All 4 branches missed.">                assert outputSingleShiftSched.m_phantomEmpOrgID != null;</span>
<span class="nc" id="L754">                outputSingleShiftSched.m_shiftAssn = shiftAssn;</span>
<span class="nc" id="L755">                outputSingleShiftSched.m_shiftEventAssns = shiftEventAssnList;</span>
            }
        }

<span class="nc" id="L759">        String md5CheckSum = null;</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">        if (signature != null) {</span>
<span class="nc" id="L761">            md5CheckSum = computeMD5Hash(signature);</span>
<span class="nc" id="L762">            m_cat.debug(&quot;signature and computed MD5: &quot; + signature + &quot; =&gt; &quot; + md5CheckSum);</span>
        }

<span class="nc bnc" id="L765" title="All 2 branches missed.">        return (signature != null)?md5CheckSum:null;</span>
    }


    @SuppressWarnings(&quot;unchecked&quot;)
    public static String computeMD5(ShiftAssignment shiftAssn) throws IOException {
<span class="nc" id="L771">        StringBuffer signature = new StringBuffer();</span>

        // add shift start and end time to signature
<span class="nc" id="L774">        appendShiftAssnSignature(shiftAssn, signature);</span>
        // add shift assignment activity id
<span class="nc" id="L776">        signature.append(shiftAssn.getActivityID()).append(&quot;;&quot;);</span>

        //get shift event Assignments for this shiftAssignment and sort.
<span class="nc" id="L779">        List&lt;ShiftEventAssignment&gt; shiftEventAssnList = new ArrayList&lt;ShiftEventAssignment&gt;(shiftAssn.getChildren());</span>
<span class="nc" id="L780">        Collections.sort(shiftEventAssnList, new ShiftEventAssignmentComparator());</span>

        // add shift event assignment to signature.
<span class="nc bnc" id="L783" title="All 2 branches missed.">        for (ShiftEventAssignment shiftEventAssn : shiftEventAssnList)  {</span>
<span class="nc" id="L784">            appendShiftEventAssnSignature(signature, shiftEventAssn);</span>
<span class="nc" id="L785">        }</span>

<span class="nc" id="L787">        return computeMD5Hash(signature);</span>
    }


    /**
     * @param phantomSkillsSortedList
     * @param signature
     */
    private static void appendSkillsSignature(List phantomSkillsSortedList, StringBuffer signature) {
        // get skills signature for the phantom
<span class="nc bnc" id="L797" title="All 4 branches missed.">        if (phantomSkillsSortedList != null &amp;&amp; !phantomSkillsSortedList.isEmpty()) {</span>
<span class="nc" id="L798">            signature.append(&quot;skillids;&quot;);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">            for (Iterator phantomSkillsIter = phantomSkillsSortedList.iterator(); phantomSkillsIter.hasNext();) {</span>
<span class="nc" id="L800">                SkillAssignment skillAssn = (SkillAssignment) phantomSkillsIter.next();</span>
<span class="nc" id="L801">                signature.append(skillAssn.getSkillID()).append(';');</span>
<span class="nc" id="L802">            }</span>
        }
<span class="nc" id="L804">    }</span>

    /**
     * Groups identical weekly schedules (using MD5 checksums) to create BiddableSchedules.  Generates
     * a Map of MD5 checksums to a collection of similar weekly schedules. (represented as
     * {@link ShiftBidAuctionManagerEJB.WeeklySchedule WeeklySchedule}
     *
     * @param md5HashToWeeklyScheduleCollMap Map used as output.  Similar weekly schedules are grouped
     *   together under a single MD5 checksum and stored in the map.  Each map entry maps a MD5 checksum
     *   and its associated collection of weekly schedules.
     * @param phantomEmpsOrEmpIDs collection of Employees or Employee IDs (depending on the collType paramter).
     * @param collType Type of above collection.  Can either be {@link #COLLTYPE_EMPIDS COLLTYPE_EMPIDS} or
     *    {@link #COLLTYPE_EMPS COLLTYPE_EMPS}.
     * @param phantomEmpOrgIDs Collection of OrgIDs.  Specifies the OrgID for each phantom employee in the
     *    phantomEmpsOrEmpIDs collection.
     * @param phantomEmpWeeklySchedules Collection of Collection of schedules.  Represents the schedule collection
     *    (for the scheduling period) for the corresponding employee in phantomEmpsOrEmpIDs parameter.
     * @throws IOException
     */
//  public static void compileMD5MapForFullPeriodSchedList(Map md5HashToWeeklyScheduleCollMap, Collection phantomEmpsOrEmpIDs,
//      int collType, List phantomEmpOrgIDs, List phantomEmpsSchedForSP) throws IOException
//  {
//      Iterator phantomEmpOrEmpIDItr = phantomEmpsOrEmpIDs.iterator();
//      for (int schedCollsIdx = 0; schedCollsIdx &lt; phantomEmpsSchedForSP.size(); schedCollsIdx++) {
//          ID phantomEmpID = (collType == COLLTYPE_EMPIDS)?(ID) phantomEmpOrEmpIDItr.next():
//              ((Phantom) phantomEmpOrEmpIDItr.next()).getID();
//
//          //TODO: phantom shiftAssignments for a period more than one week.
//          //TODO: casting to List knowing that ScheduleAccessManager.getEventsFor...() returns a List of Lists.
//          List empShiftAssnsForSP = (List) phantomEmpsSchedForSP.get(schedCollsIdx);
//          if (empShiftAssnsForSP == null) continue;
//
//          // add orgID to signature
//          StringBuffer signature = new StringBuffer(256);
//          ID phantomEmpOrgID = (ID) phantomEmpOrgIDs.get(schedCollsIdx);
//          signature.append(phantomEmpOrgID);
//
//          WeeklySchedule weeklySched = new WeeklySchedule(phantomEmpID, phantomEmpOrgID, new ArrayList());
//
//          // sort the shiftAssignments
//          Collections.sort(empShiftAssnsForSP, new ShiftAssignmentComparator());
//
//          // sort the shiftEventAssignments associated with each shiftAssignment
//          for (int shiftAssnsIdx = 0; shiftAssnsIdx &lt; empShiftAssnsForSP.size(); shiftAssnsIdx++)  {
//              ShiftAssignment phantomShiftAssn = (ShiftAssignment) empShiftAssnsForSP.get(shiftAssnsIdx);
//              // add shift assignment start and end time to signature
//              appendShiftAssnSignature(phantomShiftAssn, signature);
//
//              List shiftEventAssnList = RequestUtil.getListFromCollection(phantomShiftAssn.getChildren());
//              //method getListFromCollection() might return a Collectoins.singletonList() which does not
//              // allow its set() method to be called.  The check below prevents this.
//              if (shiftEventAssnList.size() &gt; 1)  {
//                  Collections.sort(shiftEventAssnList, new ShiftEventAssignmentComparator());
//              }
//
//              // append the shiftevent assignment start and end time to the signature
//              for (int shiftEventAssnsIdx = 0; shiftEventAssnsIdx &lt; shiftEventAssnList.size(); shiftEventAssnsIdx++)   {
//                  ShiftEventAssignment shiftEventAssn = (ShiftEventAssignment) shiftEventAssnList.get(shiftEventAssnsIdx);
//                  appendShiftEventAssnSignature(signature, shiftEventAssn);
//              }
//
//              // create a single shift schedule and add to weeklySched.
//              SingleShiftSchedule singleShiftSched = new SingleShiftSchedule(phantomEmpID, phantomEmpOrgID,
//                      phantomShiftAssn, shiftEventAssnList);
//              weeklySched.m_singleShiftSchedules.add(singleShiftSched);
//          }
//
//          // compute MD5 hash for the weekly schedule signature.
//          String md5Hash = computeMD5Hash(signature);
//
//          // Add pair to md5Hash Map.
//          addToHash(md5HashToWeeklyScheduleCollMap, md5Hash, weeklySched);
//      }
//  }

    /**
     * Creates a BiddableSchedule from the given list of {@link ShiftBidAuctionUtil.SingleShiftSchedule SingleShiftSchedules}
     * or {@link ShiftBidAuctionUtil.WeeklySchedule weeklySchedules}.  Each passed singleShiftSchedule or weeklySchedule
     * maps to a biddableScheduleInstance. These similar biddableScheduleInstances are represented
     * as the children of a single BiddableSchedule.
     *
     * @param md5Hash
     * @param auctionID
     * @param singleShiftOrWeeklySchedList List of {@link WeeklySchedule weeklySchedules} or {@link SingleShiftSchedule SingleShiftSchedules}
     * @param isFullPeriod True if singleOrWeekSchedList contains weeklySchedules.  False if it contains
     *    singleShiftSchedules.
     * @return A BiddableSchedule for the given collection of schedules(weekly or single day).
     */
    public static BiddableSchedule createBiddableSchedVO(String md5Hash, ID auctionID, ID orgID, List singleShiftOrWeeklySchedList,
        boolean isFullPeriod)
    {
        // create the biddbable schedule VO and set its attributes
<span class="nc" id="L896">        BiddableSchedule biddableSched = new BiddableSchedule(BiddableSchedule.DL_BASIC);</span>
<span class="nc" id="L897">        biddableSched.setBonusPoints(0);</span>
        //setting the actual number of available instances is done by bidSChed.addBidSchedInst() method.
<span class="nc" id="L899">        biddableSched.getSetters().setNumOfAvailInstances(0);</span>
<span class="nc" id="L900">        biddableSched.getSetters().setBiddableScheduleChecksum(md5Hash);</span>
<span class="nc" id="L901">        biddableSched.getSetters().setShiftBidAuctionID(auctionID);</span>
<span class="nc" id="L902">        biddableSched.getSetters().setOrgID(orgID);</span>
<span class="nc" id="L903">        biddableSched.getSetters().setIsFullPeriod(isFullPeriod);</span>

        // iterate thru the collection of singleShiftOrWeeklySchedules and create a biddbale
        // schedule instance for each entry in the collection.
<span class="nc bnc" id="L907" title="All 2 branches missed.">        for (Iterator singleOrWeekSchedIter = singleShiftOrWeeklySchedList.iterator();singleOrWeekSchedIter.hasNext();) {</span>
<span class="nc" id="L908">            ShiftBidAuctionUtil.WeeklySchedule weeklySched = null;</span>

<span class="nc bnc" id="L910" title="All 2 branches missed.">            if (isFullPeriod)  {</span>
<span class="nc" id="L911">                weeklySched = (ShiftBidAuctionUtil.WeeklySchedule) singleOrWeekSchedIter.next();</span>
            } else  {
                // convert single shift schedule to a weekly schedule (adapting this object for processing later).
<span class="nc" id="L914">                ShiftBidAuctionUtil.SingleShiftSchedule singleShiftSched =</span>
<span class="nc" id="L915">                    (ShiftBidAuctionUtil.SingleShiftSchedule) singleOrWeekSchedIter.next();</span>
<span class="nc" id="L916">                weeklySched = new ShiftBidAuctionUtil.WeeklySchedule(singleShiftSched.m_phantomEmpID,</span>
<span class="nc" id="L917">                    singleShiftSched.m_phantomEmpOrgID, Collections.singletonList(singleShiftSched));</span>
            }

            // create a bidSchedInstance VO and set its attributes.
<span class="nc" id="L921">            BiddableScheduleInstance bidSchedInst = new BiddableScheduleInstance(BiddableScheduleInstance.DL_BASIC);</span>
<span class="nc" id="L922">            bidSchedInst.setStatus(BiddableScheduleInstance.STATUS_UNASSIGNED);</span>
<span class="nc" id="L923">            bidSchedInst.setShiftBidAuctionID(auctionID);</span>
<span class="nc" id="L924">            bidSchedInst.setPhantomEmployeeID(weeklySched.m_phantomEmpID);</span>

            // Add shift assignments to the bidSchedInst.
<span class="nc" id="L927">            List singleShiftSchedules = weeklySched.m_singleShiftSchedules;</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">            for (int singleShiftSchedIdx = 0; singleShiftSchedIdx &lt; singleShiftSchedules.size(); singleShiftSchedIdx++)  {</span>
<span class="nc" id="L929">                ShiftBidAuctionUtil.SingleShiftSchedule singleShiftSched = (ShiftBidAuctionUtil.SingleShiftSchedule) singleShiftSchedules.get(singleShiftSchedIdx);</span>

<span class="nc" id="L931">                BiddableShift biddableShift = new BiddableShift(BiddableShift.DL_BASIC);</span>
<span class="nc" id="L932">                biddableShift.setShiftAssignmentID(singleShiftSched.m_shiftAssn.getID());</span>
<span class="nc" id="L933">                biddableShift.setOrder(singleShiftSchedIdx+1);</span>

<span class="nc" id="L935">                bidSchedInst.addBiddableShift(biddableShift);</span>
            }

<span class="nc" id="L938">            bidSchedInst.getSetters().setBiddableScheduleCheckSum(md5Hash);</span>

            // add the bidSchedInstance to the biddableSchedule.
<span class="nc" id="L941">            biddableSched.getSetters().addBiddableScheduleInstance(bidSchedInst);</span>
<span class="nc" id="L942">        }</span>

<span class="nc" id="L944">        return biddableSched;</span>
    }

    /**
     * Groups identical weekly schedules (using MD5 checksums) to create BiddableSchedules.  Generates
     * a Map of MD5 checksums to a collection of similar weekly schedules. (represented as
     * {@link ShiftBidAuctionManagerEJB.WeeklySchedule WeeklySchedule}
     *
     * @param md5HashToWeeklyScheduleCollMap Map used as output.  Similar weekly schedules are grouped
     *   together under a single MD5 checksum and stored in the map.  Each map entry maps a MD5 checksum
     *   and its associated collection of weekly schedules.
     * @param phantomEmpsOrEmpIDs collection of Employees or Employee IDs (depending on the collType paramter).
     * @param collType Type of above collection.  Can either be {@link #COLLTYPE_EMPIDS COLLTYPE_EMPIDS} or
     *    {@link #COLLTYPE_EMPS COLLTYPE_EMPS}.
     * @param phantomEmpOrgIDs Collection of OrgIDs.  Specifies the OrgID for each phantom employee in the
     *    phantomEmpsOrEmpIDs collection.
     * @param phantomEmpWeeklySchedules Collection of Collection of schedules.  Represents the schedule collection
     *    (for the scheduling period) for the corresponding employee in phantomEmpsOrEmpIDs parameter.
     * @throws IOException
     */
    public static void compileMD5MapForPhantomShiftAssns(Map md5HashToWeeklyScheduleCollMap, Collection phanEmpIDs,
            List phantomEmpOrgIDs, List phantomEmpsSchedForSP, Map phanTemplateSkillsMap, Map empTemplateMap, boolean isFullPeriodSched) throws IOException, Exception
    {
<span class="nc" id="L967">        String methodName = &quot;compileMD5MapForPhantomShiftAssns(): &quot;;</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) m_cat.debug( RmUtil.dumpEnterMethod(methodName, RmUtil.dumpCollection(phanEmpIDs),</span>
            new Boolean(isFullPeriodSched)));

        // iterate over the collection of employees or employee IDs
<span class="nc" id="L972">        Iterator phanEmpIDIter = phanEmpIDs.iterator();</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">        for (int schedCollsIdx = 0; schedCollsIdx &lt; phantomEmpsSchedForSP.size(); schedCollsIdx++) {</span>
<span class="nc" id="L974">            ID phantomEmpID = (ID) phanEmpIDIter.next();</span>

            //TODO: phantom shiftAssignments for a period more than one week.
            // get the corresponding shift assignments for the employee
<span class="nc" id="L978">            List empShiftAssnsForSP = (List) phantomEmpsSchedForSP.get(schedCollsIdx);</span>
<span class="nc bnc" id="L979" title="All 2 branches missed.">            if (empShiftAssnsForSP == null) continue;</span>

            // get phantom employee's orgID
<span class="nc" id="L982">            ID phantomEmpOrgID = (ID) phantomEmpOrgIDs.get(schedCollsIdx);</span>

            // sort phantom's skill assignment
<span class="nc" id="L985">            Collection phantomSkillsColl = (Collection)phanTemplateSkillsMap.get(empTemplateMap.get(phantomEmpID));</span>
<span class="nc" id="L986">            List phantomSkillsSortedList = getSkillsForPhantomSorted(phantomEmpID, phantomSkillsColl);</span>

            // for a full period schedule, treat the collection of shift assignments as a single unit.  In other words,
            // a biddable schedule instance is created from the collection of shift assignments.
<span class="nc bnc" id="L990" title="All 2 branches missed.">            if (isFullPeriodSched) {</span>
                // add phantom employee's org id to the signature.
<span class="nc" id="L992">                WeeklySchedule weeklySched = new WeeklySchedule(phantomEmpID, phantomEmpOrgID, new ArrayList());</span>

                // compute md5 for the biddable schedule and create the weekly schedule
<span class="nc" id="L995">                StringBuffer signature = new StringBuffer(256);</span>
<span class="nc" id="L996">                String md5Hash = computeMD5AndCreateWeeklyOrSingleShiftSched(isFullPeriodSched, signature,</span>
                    phantomEmpID, phantomEmpOrgID, empShiftAssnsForSP, false, phantomSkillsSortedList, weeklySched);

                // Add weekly schedule to Map.
<span class="nc" id="L1000">                addToHash(md5HashToWeeklyScheduleCollMap, md5Hash, weeklySched);</span>
<span class="nc" id="L1001">            } else {</span>
                //for individual shift auction, treat each shift assignment as an unit.  Each shift assignment
                // translates to a biddable schedule instance.

                // iterate over each shift assignment.
<span class="nc" id="L1006">                StringBuffer signature = new StringBuffer(256);</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">                for (int shiftAssnsIdx = 0; shiftAssnsIdx &lt; empShiftAssnsForSP.size(); shiftAssnsIdx++)  {</span>
<span class="nc" id="L1008">                    ShiftAssignment phantomShiftAssn = (ShiftAssignment) empShiftAssnsForSP.get(shiftAssnsIdx);</span>
<span class="nc" id="L1009">                    SingleShiftSchedule singleShiftSched = new SingleShiftSchedule(phantomEmpID, phantomEmpOrgID,</span>
                        phantomShiftAssn, null);

                    // compute md5 for biddable schedule and create the singleShift schedule
<span class="nc" id="L1013">                    signature.delete(0, signature.length());</span>
<span class="nc" id="L1014">                    String md5Hash = computeMD5AndCreateWeeklyOrSingleShiftSched(isFullPeriodSched, signature,</span>
<span class="nc" id="L1015">                        phantomEmpID, phantomEmpOrgID, Collections.singletonList(phantomShiftAssn),</span>
                        true, phantomSkillsSortedList, singleShiftSched);

                    // Add single shift schedule to md5Hash Map.
<span class="nc" id="L1019">                    addToHash(md5HashToWeeklyScheduleCollMap, md5Hash, singleShiftSched);</span>
                }
            }
        }

<span class="nc" id="L1024">        m_cat.debug( RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L1025">    }</span>

    public static void createBidSchedInstancesForShiftAssns(ID auctionID, ID phantomID,
        Collection phanShiftAssns) throws Exception
    {
<span class="nc" id="L1030">        BiddableScheduleDAO bidSchedDAO = null;</span>
        try {
<span class="nc" id="L1032">            bidSchedDAO = new BiddableScheduleDAO(BiddableSchedule.DL_BASIC);</span>

<span class="nc" id="L1034">            Collection bidSchedsToBeCreated = compileBiddableSchedsForShiftAssns(auctionID, phantomID,</span>
                phanShiftAssns);

<span class="nc bnc" id="L1037" title="All 2 branches missed.">            for (Iterator iter = bidSchedsToBeCreated.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1038">                BiddableSchedule bidSchedToBeCreated = (BiddableSchedule) iter.next();</span>

                // check if a biddable schedule exists with the same checksum in the db.
<span class="nc" id="L1041">                BiddableSchedule bidSchedFromDB = bidSchedDAO.getBiddableScheduleForMD5(bidSchedToBeCreated.getBiddableScheduleCheckSum(),</span>
                    auctionID, BiddableSchedule.DL_BASIC | BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES);

                // if bidSched found, then add bid sched instance as child.
<span class="nc bnc" id="L1045" title="All 2 branches missed.">                if (bidSchedFromDB != null) {</span>
<span class="nc" id="L1046">                    List bidSchedInstList = bidSchedToBeCreated.getOptMethods().getBiddableScheduleInstances();</span>
                    // created biddable schedule can only have a single biddable schedule instance.
<span class="nc bnc" id="L1048" title="All 4 branches missed.">                    assert bidSchedInstList.size() == 1:&quot;bidSchedInstList.size() == 1: &quot; + bidSchedInstList.size();</span>

                    // add the biddable schedule instance to bid sched.
<span class="nc" id="L1051">                    BiddableScheduleInstance bidSchedInstToBeCreated = (BiddableScheduleInstance) bidSchedInstList.get(0);</span>
<span class="nc" id="L1052">                    bidSchedFromDB.getSetters().addBiddableScheduleInstance(bidSchedInstToBeCreated);</span>
//                    bidSchedFromDB.getSetters().setNumOfAvailInstances(
//                        bidSchedFromDB.getNumOfAvailableInstances() + 1);

                    // save the bid sched in db along with the bid sched instance
<span class="nc" id="L1057">                    bidSchedDAO.updateBiddableSchedulesForAuction(Collections.singletonList(bidSchedFromDB));</span>

                    // refetch and update firstBiddableScheduleInstanceID if necessary
<span class="nc bnc" id="L1060" title="All 2 branches missed.">                    if (bidSchedFromDB.getFirstAvailBiddableSchedInstanceID() == null) {</span>
<span class="nc" id="L1061">                        bidSchedFromDB = bidSchedDAO.getBiddableScheduleByID(bidSchedFromDB.getID(),</span>
                            BiddableSchedule.DL_BASIC | BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES);

<span class="nc" id="L1064">                        updateBiddableSchedsWithFirstAvailInstanceID(bidSchedDAO, Collections.singletonList(bidSchedFromDB));</span>
                    }
<span class="nc" id="L1066">                } else { // create a new biddable schedule for this bid sched instance.</span>
                    // create the bid schedule.
<span class="nc" id="L1068">                    Collection IDs = bidSchedDAO.createBiddableSchedules(Collections.singletonList(bidSchedToBeCreated));</span>
<span class="nc" id="L1069">                    bidSchedToBeCreated.setID((ID) IDs.iterator().next());</span>

                    // update the firstBiddableScheduleInstanceID.
<span class="nc" id="L1072">                    updateBiddableSchedsWithFirstAvailInstanceID(bidSchedDAO, Collections.singletonList(bidSchedToBeCreated));</span>
                }
<span class="nc" id="L1074">            }</span>
        } finally {
<span class="nc bnc" id="L1076" title="All 4 branches missed.">            if (bidSchedDAO != null) bidSchedDAO.cleanUp();</span>
        }
<span class="nc" id="L1078">    }</span>

    /**
     * This compiles a collection of biddableSchedules (for single shift auction, collection may have
     * one or more entries; for fullPeriod auctions, collection will have at most 1 entry) from the
     * list of shiftAssns for **a phantom employee**.  In contrast, the method
     * {@link #compileBiddableSchedsForAuction(ShiftBidAuction, SchedulingPeriod, WorkResourceManager) compileBiddableSchedsForAuction}
     * compiles biddableSchedules for all phantoms in an auction.
     *
     * @param auctionID
     * @param phantomEmpID
     * @param phanShiftAssns
     * @return
     * @throws Exception
     */
    public static Collection compileBiddableSchedsForShiftAssns(ID auctionID, ID phantomEmpID,
        Collection phanShiftAssns) throws Exception
    {
<span class="nc" id="L1096">        String methodName = &quot;compileBiddableSchedsForShiftAssns(): &quot;;</span>
<span class="nc" id="L1097">        m_cat.debug( RmUtil.dumpEnterMethod(methodName, auctionID, phantomEmpID, phanShiftAssns));</span>

<span class="nc" id="L1099">        ShiftBidAuctionDAO sbAuctionDAO = null;</span>
        try {
<span class="nc" id="L1101">            sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1102">            ShiftBidAuction sbAuction = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L1104">            SkillManager skillMgr = WfmManagerFactory.getSkillManager();</span>
<span class="nc" id="L1105">            Date startDate = sbAuction.getStartTime();</span>
<span class="nc" id="L1106">            Date endDate = sbAuction.getEndTime();</span>

            //QA 80189 - Shift Bidding combines different shift(s) together but it's wrong
            //get skill for employeeTemplateID insted of employeeID
<span class="nc" id="L1110">            ArrayList phantoms = (ArrayList)WfmManagerFactory.getScheduleAccessManager().getPhantomsByIDs(Collections.singletonList(phantomEmpID));</span>
<span class="nc" id="L1111">            ArrayList empTemplateIDs = new ArrayList();</span>
<span class="nc" id="L1112">            HashMap empTemplateMap = new HashMap();</span>
<span class="nc" id="L1113">            Iterator i = phantoms.iterator();</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">            while(i.hasNext()){</span>
<span class="nc" id="L1115">            	Phantom phantom = (Phantom)i.next();</span>
<span class="nc" id="L1116">            	empTemplateIDs.add(phantom.getEmployeeTemplateID());</span>
<span class="nc" id="L1117">            	empTemplateMap.put(phantom.getID(), phantom.getEmployeeTemplateID());</span>
<span class="nc" id="L1118">            }</span>

<span class="nc" id="L1120">            Map phanEmpTemplateIDToSkillsMap = skillMgr.getSkillAssignmentsForTemplates(empTemplateIDs, startDate, endDate);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">            if (m_cat.isDebugEnabled()) m_cat.debug( &quot;Skills for phantom: &quot; + RmUtil.dumpMap(phanEmpTemplateIDToSkillsMap));</span>

<span class="nc" id="L1123">            ID phantomOrgID = ValidationUtil.getOrgIDForEmployeeDuringPeriod(phantomEmpID, startDate, endDate);</span>
<span class="nc" id="L1124">            m_cat.debug( &quot;OrgID for phantom: &quot; + phantomOrgID);</span>

<span class="nc" id="L1126">            Collection biddableScheds = compileBiddableSchedules(sbAuction.getIsFullPeriodSchedule(),</span>
<span class="nc" id="L1127">                auctionID, Collections.singletonList(phantomEmpID),</span>
<span class="nc" id="L1128">                Collections.singletonList(phantomOrgID), Collections.singletonList(phanShiftAssns),</span>
                phanEmpTemplateIDToSkillsMap, empTemplateMap);

<span class="nc" id="L1131">            return biddableScheds;</span>
        } finally {
<span class="nc" id="L1133">            m_cat.debug( RmUtil.dumpExitMethod(methodName));</span>
<span class="nc bnc" id="L1134" title="All 4 branches missed.">            if (sbAuctionDAO != null) sbAuctionDAO.cleanUp();</span>
        }
    }

    /**
     * Compiles a list of biddable schedules using the phantoms associated with an auction.
     * &lt;li&gt; Identifies phantoms for the SP the auction is associated with
     * &lt;li&gt; Retrieves their shiftAssns, organization association and skills.
     * &lt;li&gt; passes this information to compile biddable scheudles for the auction.
     *
     * @param phanEmpIDs if 'null', all phantoms for the specified auction are used to
     * compile the biddableSchedules.  If 'non-null', then only the specified phantoms are
     * used to compile the bidScheds.  Note that in the latter case, the bidSched is incomplete
     * because it only contains bidSchedInstances for the specified phantoms.  BidSchedInstances
     * from other phantoms are not considered.
     */
    public static Collection compileBiddableSchedsForAuction(ShiftBidAuction auction,
        Collection phanEmpIDs, WorkResourceManager wrm) throws Exception
    {
<span class="nc" id="L1153">        ID schedPeriodID = auction.getSPID();</span>

<span class="nc" id="L1155">        ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

        //identify phantom employees for SPID
<span class="nc bnc" id="L1158" title="All 2 branches missed.">        wrm = (wrm == null)?BbmManagerFactory.getWorkResourceManager():wrm;</span>
<span class="nc bnc" id="L1159" title="All 2 branches missed.">        if ( phanEmpIDs == null ) {</span>
<span class="nc" id="L1160">        Collection phantoms = sam.getPhantoms(schedPeriodID);</span>
<span class="nc" id="L1161">            phanEmpIDs = RequestUtil.getListOfIDsFromVOBases(phantoms);</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">            if (m_cat.isDebugEnabled()) m_cat.debug(&quot;Following phantoms identified for auction: &quot; + RmUtil.dumpCollection(phanEmpIDs));</span>
<span class="nc" id="L1163">        } else {</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">            if (m_cat.isDebugEnabled()) m_cat.debug(&quot;compiling bidScheds for the specified phantom IDs: &quot; + RmUtil.dumpCollection(phanEmpIDs));</span>
        }

        //Find org associations for phantoms
<span class="nc" id="L1168">        Date aucStartTime = auction.getStartTime();</span>
<span class="nc" id="L1169">        List phanEmpIDTimePairs = new ArrayList(phanEmpIDs.size());</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">        for (Iterator iter = phanEmpIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1171">            ID phanEmpID = (ID) iter.next();</span>
<span class="nc" id="L1172">            phanEmpIDTimePairs.add(new Pair(phanEmpID, aucStartTime));</span>
<span class="nc" id="L1173">        }</span>
<span class="nc" id="L1174">        List orgIDs = wrm.getEmployeeOrganizations(phanEmpIDTimePairs);</span>

        //identify shift assignments, shift event assignments and needed skills for phantom employees
        //during the SP period (SP start and end date).
<span class="nc" id="L1178">        List phantomScheds = sam.getEventsForWorkResourcesByType(</span>
            Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT, phanEmpIDs,
<span class="nc" id="L1180">            aucStartTime, auction.getEndTime());</span>

        //TODO: get skills for shifteventassignments.
<span class="nc" id="L1183">        SkillManager skillMgr = WfmManagerFactory.getSkillManager();</span>
        //QA 80189 - Shift Bidding combines different shift(s) together but it's wrong
        //get skill for employeeTemplateID insted of employeeID
<span class="nc" id="L1186">        ArrayList phantoms = (ArrayList)sam.getPhantomsByIDs(phanEmpIDs);</span>
<span class="nc" id="L1187">        ArrayList empTemplateIDs = new ArrayList();</span>
<span class="nc" id="L1188">        HashMap empTemplateMap = new HashMap();</span>
<span class="nc" id="L1189">        Iterator i = phantoms.iterator();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">        while(i.hasNext()){</span>
<span class="nc" id="L1191">        	Phantom phantom = (Phantom)i.next();</span>
<span class="nc" id="L1192">        	empTemplateIDs.add(phantom.getEmployeeTemplateID());</span>
<span class="nc" id="L1193">        	empTemplateMap.put(phantom.getID(), phantom.getEmployeeTemplateID());</span>
<span class="nc" id="L1194">        }</span>
<span class="nc" id="L1195">        Map phanTemplateSkillsMap = skillMgr.getSkillAssignmentsForTemplates(empTemplateIDs, auction.getStartTime(), auction.getEndTime());</span>


        //if (auctionType == singleShifts)
        //   identify similar shift assignments within a single organization.
        //else if (auctionType == completeSchedule)
        //   identify phantoms within an org that have similar schedule for the entire week.
        //end if
<span class="nc" id="L1203">        Collection biddableScheds = compileBiddableSchedules(auction.getIsFullPeriodSchedule(),</span>
<span class="nc" id="L1204">                auction.getID(), phanEmpIDs, orgIDs, phantomScheds, phanTemplateSkillsMap, empTemplateMap);</span>

        //create biddableschedules and return.
<span class="nc" id="L1207">        return biddableScheds;</span>
    }

    /**
     * Transforms the raw schedule information for each employee biddable schedules.  Does the transform
     * in 2 steps:
     * &lt;li&gt; transform orgID, skills and schedule information into a MD5CheckSum to collection of
     * {@link WeeklySchedule WeeklySchedules} or {@link SingleShiftSchedule SingleShiftSchedules} map.
     * &lt;li&gt; transform map to a collection of biddable schedules.
     *
     * @param isFullPeriod
     * @param auctionID
     * @param phantomEmpsOrEmpIDs
     * @param collType
     * @param phantomEmpOrgIDs
     * @param phantomEmpWeeklySchedules
     * @param empSkillsMap
     * @param empTemplateMap
     * @return
     * @throws Exception
     */
    protected static List compileBiddableSchedules(boolean isFullPeriod, ID auctionID,
            Collection phanEmpIDs, List phantomEmpOrgIDs, List phantomEmpWeeklySchedules,
            Map phanTemplateSkillsMap, Map empTemplateMap) throws Exception
    {
        //TODO: refactor to eliminate weeklySchedule and singleShiftSchedule used as intermediate objects.
        // Instead create biddableSchedules directly without these intermediate objects.

        // Group identical shift assignments.  Identical shiftAssignments have the same
        // MD5 hash computed using the shiftAssignment data. computed md5Hashes are stored as a key (in a map)
        // which maps to a list of shiftAssignments with this md5Hash.
<span class="nc" id="L1238">        Map mapMD5CSumToSingleShiftOrWeeklySchedColl = new HashMap();</span>
<span class="nc" id="L1239">        ShiftBidAuctionUtil.compileMD5MapForPhantomShiftAssns(mapMD5CSumToSingleShiftOrWeeklySchedColl,</span>
                phanEmpIDs, phantomEmpOrgIDs, phantomEmpWeeklySchedules, phanTemplateSkillsMap, empTemplateMap, isFullPeriod);

        // Now create the biddableSchedules (and its child objects) using the grouping done above.
<span class="nc" id="L1243">        List biddableScheds = new ArrayList();</span>
<span class="nc bnc" id="L1244" title="All 2 branches missed.">        for (Iterator md5Iter = mapMD5CSumToSingleShiftOrWeeklySchedColl.keySet().iterator(); md5Iter.hasNext();) {</span>
<span class="nc" id="L1245">            String md5Hash = (String) md5Iter.next();</span>
<span class="nc" id="L1246">            List singleShiftOrWeeklyScheds = (List) mapMD5CSumToSingleShiftOrWeeklySchedColl.get(md5Hash);</span>

<span class="nc" id="L1248">            ID phantomOrgID = null;</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">            if (isFullPeriod) {</span>
<span class="nc" id="L1250">                phantomOrgID = ((WeeklySchedule) singleShiftOrWeeklyScheds.get(0)).m_phantomEmpOrgID;</span>
            } else {
<span class="nc" id="L1252">                phantomOrgID = ((SingleShiftSchedule) singleShiftOrWeeklyScheds.get(0)).m_phantomEmpOrgID;</span>
            }

<span class="nc" id="L1255">            BiddableSchedule biddableSched = ShiftBidAuctionUtil.createBiddableSchedVO(md5Hash, auctionID,</span>
                phantomOrgID, singleShiftOrWeeklyScheds, isFullPeriod);
<span class="nc" id="L1257">            biddableScheds.add(biddableSched);</span>
<span class="nc" id="L1258">        } // iterate over md5Hash collection</span>

<span class="nc" id="L1260">        return biddableScheds;</span>
    }


    /**
     * validates the BiddableScheds passed to this method.  After validation, returns the list of biddable
     * schedules that were updated.  Optionally, the passed set of BiddableSchedules may be modified to reflect
     * the validation (entries can either be added or removed).&lt;br&gt;
     *
     * &lt;p&gt;Note:
     * &lt;li&gt; Validation is not performed unless the detailLevel is sufficient for validation.
     * &lt;li&gt; If parameter 'updateGivenBidSched' is true, the passed bidScheds collection is updated in place.
     * This update does not preserve the original ordering of the collection.
     * &lt;li&gt; If parameter 'updateGivenBidSched' is true, then the passed collection is updated and the updated
     * collection may have fewere bidScheds than the origial collection (bidScheds with bidSched.numOfAvailInstances == 0
     * are removed from the collection).
     *
     * &lt;p&gt; Following are the reasons for an invalid bidSched:
     * &lt;li&gt; Number of bidSchedIntances associated with the bidSched != bidSched.numOfAvailInstances
     * (indicated by computedMD5List.size() == 0)
     * &lt;li&gt; One of the assoicated bidSchedInsts has no shift assignments (indicated
     * by bidSchedInst.md5Sum == null).
     * &lt;li&gt; one of the associated bidSchedInst has been modified (indicated by
     * bidSchedInst.md5Sum != bidSched.md5Sum).  This can be caused by several factors: modification
     * of the phantom's skills, phantom's shift assns etc.
     * &lt;li&gt; The bidSchedID points to a non-existent biddableScheduleInstance.
     *
     * &lt;p&gt;Biddable Schedules are validated to verify if the BiddableSchedule's MD5 checksum matches each of the
     * BiddableScheduleInstance's MD5 checksum.  If not, the mismatched BiddableScheduleInstance is moved
     * to a matching BiddableSchedule or placed under a new BiddableSchedule.
     *
     * &lt;p&gt;&lt;b&gt;Note:&lt;/b&gt; During validation, if any updates were performed to one or more biddable schedules,
     * the passed collection (a set) is not updated unless the flag &lt;b&gt;updateGivenBidSchedSet&lt;/b&gt; is set to true.
     * This update operation is the reason for using the 'Set' datatype for the passed collection.
     *
     * @param bidSchedDAO
     * @param givenBidSchedSet
     * @param actionType
     * @return
     * @throws Exception
     */
    public static Collection validateBiddableSchedInstancesForBidScheds(BiddableScheduleDAO bidSchedDAO,
        Set givenBidSchedSet, long detailLevel, int actionType, boolean updateGivenBidSchedSet, SimpleCache cache) throws Exception  {

<span class="nc bnc" id="L1304" title="All 2 branches missed.">        if (actionType != RequestUtil.ACTION_FETCH) return Collections.EMPTY_SET;</span>

        //TODO: validate biddable schedule to see if it is still valid (if right detail level found).
        //   -- Verify if firstBiddableScheduleInstance is valid
        //   -- Verify if all biddableScheduleInstances are valid
        //   -- Either remove or move invalid BiddableScheduleInstances under an existing or new BiddableSchedule.
<span class="nc" id="L1310">        m_cat.debug(&quot;Validating biddable schedule set: size = &quot; + givenBidSchedSet.size());</span>

<span class="nc" id="L1312">		final long detLevelShiftAssns = (BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL |</span>
						ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);
<span class="nc" id="L1314">        HashSet updatedBidSchedSet = null;</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">        for (Iterator bidSchedIter = givenBidSchedSet.iterator(); bidSchedIter.hasNext(); ) {</span>
<span class="nc" id="L1316">            BiddableSchedule bidSched = (BiddableSchedule) bidSchedIter.next();</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">            if (bidSched != null){</span>
<span class="nc" id="L1318">	            ID bidSchedID = bidSched.getID();</span>

<span class="nc" id="L1320">	            BiddableSchedule fixedBidSched = null;</span>
<span class="nc" id="L1321">	            long bidSchedDetailLevel = bidSched.getDetailLevel();</span>
	            // BiddableSchedules are validated only if the detailLevel is sufficient for validation.
	            //
	            // if all biddable schedule instances were loaded, validate them.
<span class="nc bnc" id="L1325" title="All 2 branches missed.">				if ((bidSchedDetailLevel &amp; BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES) != 0) {</span>
<span class="nc" id="L1326">	                fixedBidSched = validateBSIsForBSWithDL_BSIs(bidSched, detailLevel, false, bidSchedDAO, cache);</span>
	            // if only the firstBiddableSchedule instance was loaded
<span class="nc bnc" id="L1328" title="All 2 branches missed.">	            } else if ( (bidSchedDetailLevel &amp; detLevelShiftAssns) != 0 )  {</span>
<span class="nc" id="L1329">	                fixedBidSched = validateBSIsForBSWithDL_SHIFTASSNS(bidSched, detailLevel, false, bidSchedDAO, cache);</span>
	            } else {
<span class="nc" id="L1331">	                m_cat.debug(&quot;BiddableSchedule not validated due to insufficent detailLevel: ID, detailLevel = &quot; +</span>
	                    bidSchedID + ',' + bidSchedDetailLevel);
	            }

	            // if this bidsched was fixed (updated)
<span class="nc bnc" id="L1336" title="All 2 branches missed.">	            if (fixedBidSched != null)  {</span>
<span class="nc" id="L1337">	                m_cat.debug(&quot;adding biddable schedule to update set: ID = &quot; + bidSchedID);</span>
	                // add to the updated list
<span class="nc bnc" id="L1339" title="All 2 branches missed.">	                updatedBidSchedSet = (updatedBidSchedSet == null)?new HashSet():updatedBidSchedSet;</span>
<span class="nc" id="L1340">	                updatedBidSchedSet.add(fixedBidSched);</span>
	            }
            }
<span class="nc" id="L1343">	    } // for each biddable schedule</span>


//		Collection updatedBidSchedsFromDB = null;
        // if any bidscheds were updated (fixed)
<span class="nc bnc" id="L1348" title="All 4 branches missed.">        if (updatedBidSchedSet != null &amp;&amp; updateGivenBidSchedSet)  {</span>
//            m_cat.debug(&quot;loading updated  bidScheds from DB: size = &quot; + updatedBidSchedSet.size());
//
//            // reload the fixed bidscheds.
//            bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detailLevel):bidSchedDAO;
//            Collection updatedBidSchedIDs = RequestUtil.getListOfIDsFromVOBases(updatedBidSchedSet);
//            // Note: 'updatedBidSchedsFromDB' may seem to be a redundant copy of 'updatedBidSchedSet'
//            // but it is still necessary since updatedBidSched elements (bidScheds) might have children
//            // in their 'deleted child' list.  And the behavior of getChildrenXXX() methods for
//            // ValueObjectNodes with 'deleted children' is not well documented.  So the updated bidScheds
//            // are reloaded.
//            //
//            // Note: if a bidSched's numOfAvailInstances is set to 0 during validation, this bidSched
//            // will not be loaded by the call below.  As a result, the # of entries in the 'updatedBidSchedSet'
//            // collection can be different than the # in 'updatedBidSchedsFromDB' collection.
//            updatedBidSchedsFromDB = bidSchedDAO.getBiddableSchedulesByIDs(updatedBidSchedIDs, false, detailLevel);

            // replace the updated bidScheds in the given bidScheds collection.
            // TODO: VBS: the ordering of the passed collection is violated here
<span class="nc" id="L1367">            givenBidSchedSet.removeAll(updatedBidSchedSet);</span>
//            givenBidSchedSet.addAll(updatedBidSchedsFromDB);
<span class="nc bnc" id="L1369" title="All 2 branches missed.">            for (Iterator iter = updatedBidSchedSet.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1370">                BiddableSchedule fixedBidSched = (BiddableSchedule) iter.next();</span>

                // filter out bidScheds with no bidSchedInstances
<span class="nc bnc" id="L1373" title="All 2 branches missed.">                if ( fixedBidSched.getNumOfAvailableInstances() &gt; 0) {</span>
<span class="nc" id="L1374">                    givenBidSchedSet.add(fixedBidSched);</span>
                }
<span class="nc" id="L1376">            }</span>

<span class="nc" id="L1378">            m_cat.debug(&quot;updated passed biddable sched collection with updated bid scheds = &quot; + givenBidSchedSet.size());</span>
        }

        // Note: do not return 'updatedBidSchedsFromDB' collection for the reason listed below.
        // This return value is used by the caller to detect if an update was made during validation.
        // In the case where only one bidSched is fixed and this bidSched's numOfAvailInstances is set
        // to 0, 'updatedBidSchedsFromDB' collection will not contain this fixed bidSched.  As a result
        // the caller is incorrectly notified that no updates were made although an update was done.
        //
        // return updated bidScheds
<span class="nc bnc" id="L1388" title="All 4 branches missed.">        return (updatedBidSchedSet != null &amp;&amp; updateGivenBidSchedSet)?</span>
            ((Collection) updatedBidSchedSet):Collections.EMPTY_LIST;
    }

    private static BiddableSchedule validateBSIsForBSWithDL_SHIFTASSNS(BiddableSchedule bidSched, long detailLevel,
    		boolean moveMismatchedBSIOrCreateNewBS, BiddableScheduleDAO bidSchedDAO, SimpleCache cache) throws Exception {

<span class="nc" id="L1395">		ID bidSchedID = bidSched.getID();</span>
<span class="nc" id="L1396">		m_cat.debug(&quot;validating first biddable schedule instance associated with this biddable schedule: ID = &quot; + bidSchedID);</span>

		// if only the firstAvailBidSchedInstance was loaded as a child, validate
		// its MD5 checksum with the biddable schedule's
<span class="nc" id="L1400">		List computedMD5List = ShiftBidAuctionUtil.computeMD5ForBiddableSched(bidSched, true, cache);</span>

<span class="nc" id="L1402">		String computedMD5 = null;</span>
<span class="nc" id="L1403">		boolean md5ListEmpty = computedMD5List.isEmpty();</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">		if (!md5ListEmpty) {</span>
<span class="nc" id="L1405">		    computedMD5 = (String) computedMD5List.get(0);</span>
		}

        //
		// computedMD5 == null when the shift assignment collection associated
        //   with the bidSchedInst is empty (computedMD5 was retrieved from the md5List collection)
        // md5List is empty if the firstAvailBidSchedInst was deleted outside RM (phantom deleted in DE)
		// first avail bidSchedInstance's MD5 mismatches bidSched's MD5 when bidSchedInstance
        //   was modified in some way (shift assns moved, phantom skills changed etc).
<span class="nc" id="L1414">        BiddableSchedule fixedBidSched = null;</span>
<span class="nc bnc" id="L1415" title="All 6 branches missed.">		if (md5ListEmpty || computedMD5 == null || !computedMD5.equals(bidSched.getBiddableScheduleCheckSum()))  {</span>
<span class="nc" id="L1416">		    m_cat.debug(&quot;fixing biddable schedule: ID, md5ListEmpty, mismatchedMD5 = &quot; +</span>
		        bidSchedID + ',' + md5ListEmpty + ',' + computedMD5);

		    // fix this biddable schedule (involves moving or removing one or more associated bidSchedInstances
<span class="nc" id="L1420">		    fixedBidSched = fixBiddableScheduleInDB(bidSchedDAO, bidSched, detailLevel, null,</span>
                moveMismatchedBSIOrCreateNewBS, cache);
		}

<span class="nc" id="L1424">        return fixedBidSched;</span>
	}

	/**
     * validateBSIsForBSWithDL_BSIs == Validate bidSchedInstances For bidSched with DL_BIDDABLESCHEDULEINSTANCES.
     *
	 * @param bidSchedDAO
	 * @param detailLevel
	 * @param bidSched
	 * @return
	 * @throws Exception
	 */
	private static BiddableSchedule validateBSIsForBSWithDL_BSIs(BiddableSchedule bidSched, long detailLevel,
        boolean moveMismatchedBSIOrCreateNewBS, BiddableScheduleDAO bidSchedDAO, SimpleCache cache) throws Exception {

<span class="nc" id="L1439">		ID bidSchedID = bidSched.getID();</span>
<span class="nc" id="L1440">		m_cat.debug(&quot;validating all biddable schedule instances associated with this biddable schedule: ID = &quot; + bidSchedID);</span>

<span class="nc" id="L1442">        BiddableSchedule fixedBidSched = null;</span>

		// obtain MD5 for each biddable scheudle instance associated with this biddable scheudle.
<span class="nc" id="L1445">		List computedMD5List = ShiftBidAuctionUtil.computeMD5ForBiddableSched(bidSched, false, cache);</span>
<span class="nc" id="L1446">		int md5ListSize = computedMD5List.size();</span>
<span class="nc" id="L1447">		int bidSchedNumOfAvailInst = bidSched.getNumOfAvailableInstances();</span>
<span class="nc bnc" id="L1448" title="All 2 branches missed.">		boolean bidSchedInstCountMisMatch = (md5ListSize != bidSchedNumOfAvailInst);</span>
<span class="nc bnc" id="L1449" title="All 2 branches missed.">		if (bidSchedInstCountMisMatch) {</span>
<span class="nc" id="L1450">		    m_cat.debug(&quot;BidSched.numOfAvailInstances does not match # of &quot; +</span>
		        &quot;associated bidSchedInsts: &quot; + md5ListSize + ',' + bidSchedNumOfAvailInst);

<span class="nc" id="L1453">		    fixedBidSched = fixBiddableScheduleInDB(bidSchedDAO, bidSched, detailLevel, computedMD5List,</span>
                moveMismatchedBSIOrCreateNewBS, cache);

		    // refresh the updated count (by fixBiddableScheduleInDB()).
<span class="nc" id="L1457">		    bidSchedNumOfAvailInst = bidSched.getNumOfAvailableInstances();</span>
		} else {
		    // verify each biddable schedule instance's MD5 matches the biddable schedule's MD5.
<span class="nc bnc" id="L1460" title="All 2 branches missed.">		    for (int computedMD5Idx = 0; computedMD5Idx &lt; md5ListSize; computedMD5Idx++) {</span>
<span class="nc" id="L1461">		        String computedMD5 = (String) computedMD5List.get(computedMD5Idx);</span>

		        //computedMD5 == null when the shift assignment collection associated with the bidSchedInst is empty
<span class="nc bnc" id="L1464" title="All 4 branches missed.">		        if (computedMD5 == null || !computedMD5.equals(bidSched.getBiddableScheduleCheckSum()))  {</span>
<span class="nc" id="L1465">		            m_cat.debug(&quot;fixing biddable schedule: ID, mismatchedMD5 = &quot; + bidSchedID + ',' + computedMD5);</span>

		            // fix this biddable schedule (involves moving or removing one or more associated bidSchedInstances
<span class="nc" id="L1468">		            fixedBidSched = fixBiddableScheduleInDB(bidSchedDAO, bidSched, detailLevel, computedMD5List,</span>
                        moveMismatchedBSIOrCreateNewBS, cache);

		            // stop validating other bidSchedInstances as a
		            // biddableSchedule needs to be fixed only once.
<span class="nc" id="L1473">		            break;</span>
		        }
		    }
		}

<span class="nc" id="L1478">		return fixedBidSched;</span>
	}

	/**
     * returns a Set of updated BiddableSchedules after validation.  Flag &lt;b&gt;updateGivenBidSchedSet&lt;/b&gt;, if set,
     * optionally updates the passed givenBidScheds collection to reflect the updates.
     *
     * &lt;p&gt; validation of biddableSchedules involves verifying if the associated biddable schedule instances
     * are valid (biddable schedule instance checksum ==  checksum computed using shift assignments in the
     * biddable schedule instance).
     *
     * &lt;p&gt;Note: If parameter 'updateGivenBidSched' is true, The passed bidScheds collection is updated in place.
     * This update does not preserve the original ordering of the collection unless 'preserveOrder' is set to true.
     *
     * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest.ShiftBidRequestOptMethods#getBiddableSchedules()
     *
     * @param bidSchedDAO
     * @param givenBidScheds
     * @param detailLevel
     * @param actionType
     * @param updateGivenBidSchedSet
     * @param preserveOrder If true the order of the elements in 'givenBidScheds' collection is preserved.  Also
     * the collection must be an instance of {@link List List}.
     * @return
     * @throws Exception
     */
    public static Collection validateBiddableScheds(BiddableScheduleDAO bidSchedDAO, Collection givenBidScheds,
        long detailLevel, int actionType, boolean updateGivenBidSchedSet, boolean preserveOrder) throws Exception {

<span class="nc" id="L1507">        Collection updatedBidScheds = null;</span>

<span class="nc" id="L1509">        long detLvlToChk = (BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL |</span>
            BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);

<span class="nc bnc" id="L1512" title="All 2 branches missed.">        if ( (detailLevel &amp; detLvlToChk) != 0 /*&amp;&amp; actionType == RequestUtil.ACTION_FETCH*/ )  {</span>
            // if 'preserve order' specified, save an ordered ID list.
<span class="nc" id="L1514">            List orderedBidSchedIDs = null;</span>
<span class="nc bnc" id="L1515" title="All 2 branches missed.">            if (preserveOrder) {</span>
<span class="nc" id="L1516">                orderedBidSchedIDs = RequestUtil.getListOfIDsFromVOBases(givenBidScheds);</span>
            }

<span class="nc" id="L1519">            Set validatedBidSchedsSet = RequestUtil.getSetFromCollection(givenBidScheds);</span>

<span class="nc" id="L1521">			SimpleCache simpleCache = new SimpleCache();</span>
            // validate bidSchedInstances for bidScheds.  Returns the updated bidScheds and also updates the
            // bidScheds in the passed bidSchedSet.
<span class="nc" id="L1524">            updatedBidScheds = validateBiddableSchedInstancesForBidScheds(bidSchedDAO, validatedBidSchedsSet, detailLevel,</span>
				actionType, updateGivenBidSchedSet, simpleCache);

            // if flag to update the givenBidSchedSched == true and bidScheds were updated.
<span class="nc bnc" id="L1528" title="All 4 branches missed.">            if (updateGivenBidSchedSet &amp;&amp; updatedBidScheds.size() &gt; 0)   {</span>
<span class="nc" id="L1529">                m_cat.debug(&quot;replacing passed bidScheds collection with updated bidScheds collection&quot;);</span>

                // TODO: VBS: the ordering of the passed collection is violated here
<span class="nc" id="L1532">                givenBidScheds.clear();</span>
                //givenBidSchedsSet was updated in place by validateBiddableSchedInstancesForBidScheds() method above
<span class="nc" id="L1534">                givenBidScheds.addAll(validatedBidSchedsSet);</span>

                //preserver order if requested.
<span class="nc bnc" id="L1537" title="All 2 branches missed.">                if (preserveOrder) {</span>
<span class="nc" id="L1538">                    RequestUtil.orderVOsByGivenIDs(orderedBidSchedIDs, (List) givenBidScheds);</span>
                }
            }
<span class="nc" id="L1541">        } else {</span>
<span class="nc" id="L1542">            m_cat.debug(&quot;Skipping validateBiddableScheds() method logic. Insufficient detailLevel &quot; + detailLevel);</span>
        }

<span class="nc bnc" id="L1545" title="All 2 branches missed.">        return (updatedBidScheds == null)?Collections.EMPTY_SET:updatedBidScheds;</span>
    }

    public static void updateBiddableSchedsWithFirstAvailInstanceID(BiddableScheduleDAO biddableSchedDao,
        Collection biddableScheds) throws Exception {

        // update each biddable schedule with its first avaialable biddable schedule instance ID.
        // Use the biddable schedule instance ID created by createBiddableSchedules() method call
        // to perform this update.
<span class="nc" id="L1554">        Collection updatedBidScheds = null;</span>
<span class="nc bnc" id="L1555" title="All 2 branches missed.">        for (Iterator biddableSchedsCollIter = biddableScheds.iterator(); biddableSchedsCollIter.hasNext();) {</span>
<span class="nc" id="L1556">            BiddableSchedule bidSched = (BiddableSchedule) biddableSchedsCollIter.next();</span>

<span class="nc bnc" id="L1558" title="All 2 branches missed.">            if (bidSched.getBiddableScheduleCheckSum()!=null){</span>
	            // flag indicates if any updates were made or not.
<span class="nc" id="L1560">	            boolean updated = bidSched.getSetters().fixNumOfAvailInstsAndFirstAvailBSIIDIfNecess(</span>
<span class="nc" id="L1561">	                bidSched.getNumOfAvailableInstances());</span>
	            // if updated, add to update list.
<span class="nc bnc" id="L1563" title="All 2 branches missed.">	            if (updated) {</span>
<span class="nc bnc" id="L1564" title="All 2 branches missed.">	                updatedBidScheds = (updatedBidScheds == null)?new ArrayList():updatedBidScheds;</span>
<span class="nc" id="L1565">	                updatedBidScheds.add(bidSched);</span>
	            }
            }
<span class="nc" id="L1568">        }</span>

<span class="nc bnc" id="L1570" title="All 2 branches missed.">        if (updatedBidScheds != null) {</span>
<span class="nc" id="L1571">            biddableSchedDao.updateBiddableSchedulesForAuction(updatedBidScheds);</span>
        }
<span class="nc" id="L1573">    }</span>

    /**
     * fixes the given biddableSchedule by validating its associated biddable schedule instances.
     *
     * &lt;p&gt; See {@link #validateBiddableSchedInstancesForBidScheds(BiddableScheduleDAO, Set, long, int, boolean) validateBiddableSchedInstancesForBidScheds()}
     * for a list of reasons why a bidSched could be invalid.
     *
     * &lt;pre&gt;
     * for each bidSchedInst assoc with bidSched
     *    if bidSchedInst checksum is null (all bidSchedInst's shift assn were deleted)
     *       remove assoc between bidSchedInst and bidSched
     *    else bidSchedInst checksum != bidSched checksum
     *       move bidSchedInst to a newly created bidSched or an existing bidSched (with same checksum as bidSchedInst).
     *    end if.
     * end for.
     *
     * persist any changes to the DB.
     * &lt;/pre&gt;
     *
     * @param moveMismatchedBSIOrCreateNewBS determines if the mismatched bidSchedInstance in the bidSched being
     * fixed will be moved to an existing/new bidSched or not.
     *
     * @return if passed biddableSchedule was updated, the updated biddableSchedule.  Null otherwise.
     */
    private static BiddableSchedule fixBiddableScheduleInDB(BiddableScheduleDAO bidSchedDAO, BiddableSchedule origBidSched,
        long detailLevel, List computedMD5List, boolean moveMismatchedBSIOrCreateNewBS, SimpleCache cache) throws Exception {

<span class="nc" id="L1601">        String methodName = &quot;fixBiddableScheduleInDB(): &quot;;</span>
<span class="nc bnc" id="L1602" title="All 2 branches missed.">        boolean DAONeedsAlloc = bidSchedDAO == null;</span>

<span class="nc bnc" id="L1604" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) RmUtil.dumpEnterMethod(methodName, origBidSched, new Long(detailLevel), RmUtil.dumpCollection(computedMD5List));</span>

        try  {
            // detailLevel and computedMD5List are linked.  Verify.
<span class="nc" id="L1608">            long detLevelShiftAssnsColl = (BiddableSchedule.DL_SHIFT_ASSIGNMENTS_COLL | ShiftBidRequest.DL_SHIFT_ASSIGNMENTS_COLL);</span>
<span class="nc" id="L1609">			long detLevelBidSchedInsts = BiddableSchedule.DL_BIDDABLESCHEDULEINSTANCES</span>
					| BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES;
<span class="nc bnc" id="L1611" title="All 10 branches missed.">            assert ((detailLevel &amp; detLevelBidSchedInsts) != 0 &amp;&amp; computedMD5List != null) ||</span>
                ((detailLevel &amp; detLevelShiftAssnsColl) != 0 &amp;&amp; computedMD5List == null):
                &quot;detailLevel, computedMD5List: &quot; + detailLevel + ',' + computedMD5List;

            // All BiddableScheduleInstances are necessary to fix a biddable schedule. so load them.
<span class="nc bnc" id="L1616" title="All 2 branches missed.">            if ((detailLevel &amp; detLevelBidSchedInsts) == 0)  {</span>
<span class="nc" id="L1617">                m_cat.debug( methodName + &quot; Loading biddable schedule instances for bidSched: ID = &quot; + origBidSched.getID());</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">                bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detLevelBidSchedInsts):bidSchedDAO;</span>

<span class="nc" id="L1620">				origBidSched = bidSchedDAO.getBiddableScheduleByIDIgnoreInvalidFirstInstance(origBidSched.getID(),</span>
        			detLevelBidSchedInsts | BiddableScheduleInstance.DL_EMPLOYEE); // QC 128705: ensure the BSI's phantoms are loaded as well
<span class="nc" id="L1622">                computedMD5List = ShiftBidAuctionUtil.computeMD5ForBiddableSched(origBidSched, false, cache);</span>
            }

            // Note: must also accomodate the unusual case where the phantoms are deleted from the
            // campaing week.  Deleting a phantom also deletes the biddableScheduleInstances associated with the
            // phantom which leaves the biddableScheduleInstance with an incorrect value for the 'numOfAvailInstances'
            // field and possibly a non-existent ID in the 'firstAvailBidSchedInst' field.
            //
            // Note: this check must be done before calling other bidSched methods which may cache data
            // internally.  Calling such a method will cache incorrect data.
<span class="nc" id="L1632">            boolean origBidSchedUpdated = false;</span>
<span class="nc" id="L1633">            int numOfBidSchedInsts = computedMD5List.size();</span>
<span class="nc" id="L1634">			origBidSchedUpdated =</span>
<span class="nc" id="L1635">				origBidSched.getSetters().fixNumOfAvailInstsAndFirstAvailBSIIDIfNecess(numOfBidSchedInsts);</span>
<span class="nc bnc" id="L1636" title="All 2 branches missed.">			if (origBidSchedUpdated) {</span>
<span class="nc" id="L1637">				m_cat.debug(&quot;BidSched updated: numOfAvailInstances and/or firstAvailBidSchedInstID &quot;);</span>
			}

<span class="nc" id="L1640">			int bidSchedNumOfAvailInsts = origBidSched.getNumOfAvailableInstances();</span>
<span class="nc bnc" id="L1641" title="All 2 branches missed.">            if (!origBidSched.getIsFullPeriod()) {</span>
                // Note: Using the '&lt;= 1' below handles the following cases properly:
                //    # of shift assignments can be zero if the shift was deleted.
                //    # of shift assignments can be zero if no biddable schedule instances are
                //       assoc with this BiddableSched (ie. all biddableSchedInstances have been assigned or
                //       the bidSchedInst was deleted by the cascase delete process when a phantom is deleted
                //       in DE).
                //
				// assert that number of shift assignments match auction type.
<span class="nc" id="L1650">				int origShiftAssnsSize = origBidSched.getOptMethods().getShiftAssignments().size();</span>
<span class="nc bnc" id="L1651" title="All 4 branches missed.">                assert origShiftAssnsSize &lt;= 1:&quot;(!origBidSched.getIsFullPeriod() &amp;&amp; (origShiftAssnsSize &lt;= 0))&quot;;</span>
            }

            // scan the biddable schedule instances and validate them.
<span class="nc" id="L1655">            String origBidSchedMD5 = origBidSched.getBiddableScheduleCheckSum();</span>
<span class="nc" id="L1656">            List bidSchedInstList = origBidSched.getOptMethods().getBiddableScheduleInstances();</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">            for (int bidSchedInstIdx = 0; bidSchedInstIdx &lt; bidSchedInstList.size(); bidSchedInstIdx++) {</span>
                // get the computed MD5 checksum for the biddable schedule instance being processed
<span class="nc" id="L1659">                String computedMD5ForThisBidSchedInst = (String) computedMD5List.get(bidSchedInstIdx);</span>

                // if they match continue with next biddable schedule instance.
<span class="nc bnc" id="L1662" title="All 2 branches missed.">                if (origBidSchedMD5.equals(computedMD5ForThisBidSchedInst))  continue;</span>

<span class="nc" id="L1664">                BiddableScheduleInstance misMatchedBidSchedInst = (BiddableScheduleInstance) bidSchedInstList.get(bidSchedInstIdx);</span>

<span class="nc bnc" id="L1666" title="All 2 branches missed.">                bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detailLevel):bidSchedDAO;</span>

<span class="nc" id="L1668">                m_cat.debug( &quot;origMD5, computedMD5: &quot; + origBidSchedMD5 + ',' + computedMD5ForThisBidSchedInst);</span>

<span class="nc" id="L1670">                BiddableSchedule newBidSched = null, locatedBidSchedForMD5 = null;</span>
<span class="nc bnc" id="L1671" title="All 2 branches missed.">                if (computedMD5ForThisBidSchedInst == null)  { // if no shifts associated with bid sched instance.</span>
                    //Handle the scenario where the shift assignments associated with biddablescheduleinstances were deleted.
                    //Happens during shiftBidRequest approval where the phantom shift assignments are moved to the actual employee
                    //shift assignments.

<span class="nc" id="L1676">                    m_cat.debug( &quot;BidSchedInst Mismatch found. Deleting biddable scheudle instance as no shifts associated with it. ID: &quot; + misMatchedBidSchedInst.getID());</span>

                    // delete the biddable schedule instance as it doesn't have any shifts associated
<span class="nc bnc" id="L1679" title="All 4 branches missed.">                    assert bidSchedNumOfAvailInsts &gt; 0:&quot;origBidSched.getNumOfAvailableInstances() &gt; 0&quot;;</span>
                    //origBidSched.getSetters().setNumOfAvailInstances(origBidSched.getNumOfAvailableInstances() -1);
<span class="nc" id="L1681">                    origBidSched.getSetters().deleteBiddableScheduleInstance(misMatchedBidSchedInst.getID());</span>
                } else  { // computed bidSchedInst MD5 != bidSched MD5.
                    // delete the bidSchedInst from the source
<span class="nc bnc" id="L1684" title="All 4 branches missed.">                    assert bidSchedNumOfAvailInsts &gt; 0:&quot;origBidSched.getNumOfAvailableInstances() &gt; 0&quot;;</span>
                    //origBidSched.getSetters().setNumOfAvailInstances(origBidSched.getNumOfAvailableInstances() -1);
<span class="nc" id="L1686">                    origBidSched.getSetters().deleteBiddableScheduleInstance(misMatchedBidSchedInst.getID()); // delete from original.</span>

                    // Either move the biddaableScheduleInstance which mismatches to another biddable schedule or
                    // create a new biddable schedule to host it only if this parameter is set to 'true'
                    //
                    // If DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES is not specified, then an existing bidSched
                    // with numOfAvailInstances == 0, for the md5 being searched for, will not be udpated.
                    // Instead a new bidSched for the same md5 will be created.
<span class="nc bnc" id="L1694" title="All 2 branches missed.">                    if (moveMismatchedBSIOrCreateNewBS) {</span>
<span class="nc" id="L1695">                        locatedBidSchedForMD5 = bidSchedDAO.getBiddableScheduleForMD5(computedMD5ForThisBidSchedInst,</span>
<span class="nc" id="L1696">                            origBidSched.getShiftBidAuctionID(),</span>
                            BiddableSchedule.DL_BASIC | BiddableSchedule.DL_INCLUDE_ZERO_NUM_OF_AVAIL_INSTANCES);

                        // if biddable schedule found for mismatched MD5, move BiddbaleScheduleInstance
                        // to the located BiddableSchedule.
<span class="nc bnc" id="L1701" title="All 2 branches missed.">                        if (locatedBidSchedForMD5 != null)  {</span>
<span class="nc" id="L1702">                            m_cat.debug( &quot;BidSchedInst Mismatch. Found another biddableSchedule which matchs this inst: inst ID, bidSched ID: &quot; +</span>
<span class="nc" id="L1703">                                misMatchedBidSchedInst.getID() + ',' + locatedBidSchedForMD5.getID());</span>

                            // Add it to the target.
<span class="nc" id="L1706">                            locatedBidSchedForMD5.getSetters().addBiddableScheduleInstance(misMatchedBidSchedInst); // move the biddable schedule instance</span>
                        } else { // can't find biddable schedule with the given MD5. need to create a new Biddable schedule for this biddableScheduleInstance
<span class="nc" id="L1708">                            m_cat.debug( &quot;BidSchedInst Mismatch. create new bidSchedule: inst ID: &quot; + misMatchedBidSchedInst.getID());</span>

                            // convert shift assignments to WeeklySchedule or SingleShiftSchedule list.
<span class="nc" id="L1711">                            Object singleShiftOrWeeklySched = null;</span>
<span class="nc bnc" id="L1712" title="All 2 branches missed.">                            if (origBidSched.getIsFullPeriod()) {</span>
<span class="nc" id="L1713">                                singleShiftOrWeeklySched = new WeeklySchedule(misMatchedBidSchedInst.getPhantomEmployeeID(), origBidSched.getOrgID(), new ArrayList());</span>
                            } else {
<span class="nc" id="L1715">                                singleShiftOrWeeklySched = new SingleShiftSchedule(misMatchedBidSchedInst.getPhantomEmployeeID(), origBidSched.getOrgID(), null, null);</span>
                            }
                            // this method fills the weeklySched or singleShiftObject passed as an argument.
<span class="nc" id="L1718">                            computeMD5AndCreateWeeklyOrSingleShiftSched(origBidSched.getIsFullPeriod(), null, misMatchedBidSchedInst.getPhantomEmployeeID(),</span>
<span class="nc" id="L1719">                                origBidSched.getOrgID(), misMatchedBidSchedInst.getOptMethods().getShiftAssignments(), true,</span>
                                null, singleShiftOrWeeklySched);

                           // create the new biddable schedule.
<span class="nc" id="L1723">                            newBidSched = createBiddableSchedVO(computedMD5ForThisBidSchedInst,</span>
<span class="nc" id="L1724">                                origBidSched.getShiftBidAuctionID(), origBidSched.getOrgID(),</span>
<span class="nc" id="L1725">                                Collections.singletonList(singleShiftOrWeeklySched), origBidSched.getIsFullPeriod());</span>
                        }
                    } //if moveMismatchedBSIOrCreateNewBS
                }

                // if a new biddable schedule was created, persist it.
<span class="nc bnc" id="L1731" title="All 2 branches missed.">                if (newBidSched != null)  {</span>
<span class="nc bnc" id="L1732" title="All 2 branches missed.">                    bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detailLevel):bidSchedDAO;</span>

<span class="nc" id="L1734">                    List newBidScheds = Collections.singletonList(newBidSched);</span>
<span class="nc" id="L1735">                    bidSchedDAO.createBiddableSchedules(newBidScheds);</span>
                    // created biddable schedules have their firstAvailBidSchedInst field set to null.  Update this.
<span class="nc" id="L1737">                    updateBiddableSchedsWithFirstAvailInstanceID(bidSchedDAO, newBidScheds);</span>

<span class="nc" id="L1739">                    m_cat.debug( &quot;new bidSched persisted in db and first avail bid sched inst updated: ID = &quot; + newBidSched.getID());</span>
                }

                // if biddable schedule instance was moved to another biddable scheudle, persist the receiving biddable schedule.
<span class="nc bnc" id="L1743" title="All 2 branches missed.">                if (locatedBidSchedForMD5 != null)  {</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">                    bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detailLevel):bidSchedDAO;</span>

<span class="nc" id="L1746">                    bidSchedDAO.updateBiddableSchedulesForAuction(Collections.singletonList(locatedBidSchedForMD5));</span>
<span class="nc" id="L1747">                    m_cat.debug( &quot;hosting bid sched updated and first avail bid sched inst updated: ID = &quot; + locatedBidSchedForMD5.getID());</span>
                }
            } //for (int bidSchedInstIdx = 0; bidSchedInstIdx &lt; bidSchedInstList.size(); bidSchedInstIdx++) {

            // update the original biddable schedule in the database.
<span class="nc" id="L1752">            BiddableSchedule fixedBidSched = null;</span>
<span class="nc bnc" id="L1753" title="All 4 branches missed.">            if (origBidSched.getOptMethods().getWereBiddableSchedInstancesDeleted() || origBidSchedUpdated )  {</span>
<span class="nc bnc" id="L1754" title="All 2 branches missed.">                bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(detailLevel):bidSchedDAO;</span>

<span class="nc" id="L1756">                bidSchedDAO.updateBiddableSchedulesForAuction(Collections.singletonList(origBidSched));</span>
<span class="nc" id="L1757">                m_cat.debug( &quot;updating orig bid sched in the db: ID = &quot; + origBidSched.getID());</span>

<span class="nc" id="L1759">                fixedBidSched = origBidSched;</span>
            }

<span class="nc" id="L1762">            return fixedBidSched;</span>
        } finally  {
<span class="nc" id="L1764">            RmUtil.dumpExitMethod(methodName);</span>
<span class="nc bnc" id="L1765" title="All 8 branches missed.">            if (DAONeedsAlloc &amp;&amp; bidSchedDAO != null) bidSchedDAO.cleanUp();</span>
        }
    }

    /**
     * @param md5HashToOrgIDShiftAssnCollMap
     * @param md5Hash
     */
    static private void addToHash(Map md5HashToOrgIDShiftAssnCollMap, String md5Hash, Object schedule)  {
<span class="nc bnc" id="L1774" title="All 2 branches missed.">        if (md5HashToOrgIDShiftAssnCollMap.containsKey(md5Hash))  { //add to existing list in map</span>
<span class="nc" id="L1775">            ((List)md5HashToOrgIDShiftAssnCollMap.get(md5Hash)).add(schedule);</span>
<span class="nc" id="L1776">            m_cat.debug( &quot;For MD5: &quot; + md5Hash + &quot; add weeky/single shift schedule: &quot; + schedule);</span>
        } else  { //create list and add to map with md5hash as key
<span class="nc" id="L1778">            List pairList = new ArrayList();</span>
<span class="nc" id="L1779">            pairList.add(schedule);</span>
<span class="nc" id="L1780">            md5HashToOrgIDShiftAssnCollMap.put(md5Hash, pairList);</span>
<span class="nc" id="L1781">            m_cat.debug( &quot;For MD5: &quot; + md5Hash + &quot; add weeky/single shift schedule: &quot; + schedule);</span>
        }
<span class="nc" id="L1783">    }</span>


    static private void appendShiftEventAssnSignature(StringBuffer signature, ShiftEventAssignment shiftEventAssn) {
<span class="nc" id="L1787">        signature.append(&quot;shifteventassn;&quot;);</span>
<span class="nc" id="L1788">        signature.append(shiftEventAssn.getActivityID()).append(&quot;;&quot;);</span>
<span class="nc" id="L1789">        signature.append(shiftEventAssn.getStartTime().getTime()).append(';');</span>
<span class="nc" id="L1790">        signature.append(shiftEventAssn.getEndTime().getTime()).append(';');</span>
<span class="nc" id="L1791">    }</span>


    static private void appendShiftAssnSignature(ShiftAssignment shiftAssn, StringBuffer signature) {
<span class="nc" id="L1795">        signature.append(&quot;shiftassn;&quot;);</span>
<span class="nc" id="L1796">        signature.append(shiftAssn.getStartTime().getTime()).append(';');</span>
<span class="nc" id="L1797">        signature.append(shiftAssn.getEndTime().getTime()).append(';');</span>
<span class="nc" id="L1798">    }</span>

    /**
     * &lt;p&gt; Computes for the given shift bid request and/or shiftBidder:
     * &lt;li&gt; bonus this auction (assigned to shiftBidder) + accumulated points
     * &lt;li&gt; score using accumulated points (seniority * weighting factor +
     *   rank * weighting factor + (bonus this auc + accum points) * weighting factor)
     * &lt;li&gt; score without using accum points  (seniority * weighting factor + rank *
     *   weighting factor + (bonus this auc) * weighting factor )
     *
     * &lt;p&gt;The computed values are set in the given shiftBidder and/or shiftBidRequest objects.
     *
     * &lt;p&gt; To compute the bonus and score with/without bonus the following are needed:
     * &lt;li&gt; shiftBidder
     * &lt;li&gt; shiftBidAuction.
     *
     * &lt;p&gt; Thus either sbReq must be non null (from which the shiftBidder and shiftBidAuction will be
     * fetched) or (shiftBidder and sbAuction) must be non null.
     *
     * @param sbReq if null, then parameters shiftBidder and sbAuction must be specified.  If specified
     * DL_EMPLOYEE | DL_AUCTION is necessary.
     * @param shiftBidder if null, then parameter sbReq must be specified from which the shift bidder will be
     * retrieved. if specified, detail level DL_EMPLOYEE is necessary.
     * @param sbAuction if null, then parameter sbReq must be specified from which sbAuction will be retrieved.
     * if specified, detail level DL_BASIC is adequate
     * @param bidderOrgID optional.  if null, will be fetched.
     * @param bidderOrgSetting optional, if null, will be fetched.
     * @param orgIDToOrgSettingCacheMap if null, ignored.  if non-null used to cache the retrieved orgSetting
     * between invocations of this method.
     * @param dataCache if null, ignored.  if non-null, passed map used to cache expensive data
     * between invocations of this method.
     *
     * @throws Exception
     *
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getBonusComputed()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithoutBonus()
     */
    public static void computeBonusAndScoreWithAndWithoutPoints(ShiftBidRequest sbReq,
        ShiftBidder shiftBidder, ShiftBidAuction sbAuction, ID bidderOrgID,
        OrganizationSetting bidderOrgSetting, Map orgIDToOrgSettingCacheMap, Map dataCache) throws Exception {

<span class="nc bnc" id="L1840" title="All 2 branches missed.">        ID reqID = (sbReq == null)?new ID(0):sbReq.getID();</span>

        // get bidder for request
<span class="nc bnc" id="L1843" title="All 2 branches missed.">        shiftBidder = (shiftBidder == null)?sbReq.getOptMethods().getShiftBidder():shiftBidder;</span>
<span class="nc" id="L1844">        ID bidderID = shiftBidder.getID();</span>

        // compute the bonus used in scoring this shift bid request
<span class="nc" id="L1847">        int computedBonus = computeBidderBonusAndEmpPointsSum(shiftBidder, true);</span>

        // set computed bonus in request and bidder.
<span class="nc bnc" id="L1850" title="All 2 branches missed.">        if (sbReq != null) sbReq.getSetters().setBonusComputed(computedBonus);</span>
<span class="nc" id="L1851">        shiftBidder.getSetters().setBonusComputed(computedBonus);</span>
<span class="nc" id="L1852">        m_cat.debug(&quot;computed 'bonus this auction' for request/bidder: requestID, bidderID, computedBonus: &quot; +</span>
            reqID + ',' + bidderID + ',' + computedBonus);

        // get the organization settings for the shiftBidder's organization
<span class="nc bnc" id="L1856" title="All 2 branches missed.">        sbAuction = (sbAuction == null)?sbReq.getOptMethods().getShiftBidAuction():sbAuction;</span>

        // check if auction uses scoring. if not, then scoring need not be done
<span class="nc bnc" id="L1859" title="All 2 branches missed.">        if (!sbAuction.getUsesScoring()) {</span>
<span class="nc" id="L1860">            m_cat.debug(&quot;No scores computed for request/bidder as scoring is disabled for &quot; +</span>
                &quot;the auction: requestid, bidderid: &quot; + reqID + ',' + bidderID);

<span class="nc" id="L1863">            shiftBidder.getSetters().setScoreWithBonus(0);</span>
<span class="nc" id="L1864">            shiftBidder.getSetters().setScoreWithoutBonus(0);</span>
<span class="nc" id="L1865">            return;</span>
        }

		// fetch validation cache if sbReq != null
<span class="nc bnc" id="L1869" title="All 2 branches missed.">		ValidationCache valCache = (sbReq != null)?sbReq.getValidationCache():null;</span>
		// fetch bidder's orgID if null.
<span class="nc bnc" id="L1871" title="All 2 branches missed.">        if (bidderOrgID == null) {</span>
			// use validation cache if non null
<span class="nc bnc" id="L1873" title="All 2 branches missed.">			if (valCache != null) {</span>
<span class="nc" id="L1874">				bidderOrgID = valCache.getOrgIDForEmployeeDuringPeriod(shiftBidder.getEmployeeID(),</span>
<span class="nc" id="L1875">					sbAuction.getStartTime(), sbAuction.getEndTime());</span>
			} else {
<span class="nc" id="L1877">				bidderOrgID = ValidationUtil.getOrgIDForEmployeeDuringPeriod(shiftBidder.getEmployeeID(),</span>
<span class="nc" id="L1878">					sbAuction.getStartTime(), sbAuction.getEndTime());</span>
			}
        }

        // fetch orgSetting if null.
<span class="nc bnc" id="L1883" title="All 2 branches missed.">        if (bidderOrgSetting == null) {</span>
            // first check the cache
<span class="nc bnc" id="L1885" title="All 2 branches missed.">            if (orgIDToOrgSettingCacheMap != null) {</span>
<span class="nc" id="L1886">                bidderOrgSetting = (OrganizationSetting) orgIDToOrgSettingCacheMap.get(bidderOrgID);</span>
            }

            // if cache not specified or orgSetting not found in cache, fetch from DB.
<span class="nc bnc" id="L1890" title="All 2 branches missed.">            if (bidderOrgSetting == null) {</span>
				// use validation cache if non null
<span class="nc bnc" id="L1892" title="All 2 branches missed.">				if (valCache != null) {</span>
<span class="nc" id="L1893">					bidderOrgSetting = valCache.getOrgSettingForOrgID(bidderOrgID);</span>
				} else {
<span class="nc" id="L1895">	                bidderOrgSetting = RequestUtil.getOrgSetting(bidderOrgID, null);</span>
				}

                //save in cache
<span class="nc bnc" id="L1899" title="All 2 branches missed.">                if (orgIDToOrgSettingCacheMap != null) {</span>
<span class="nc" id="L1900">                    orgIDToOrgSettingCacheMap.put(bidderOrgID, bidderOrgSetting);</span>
                }
            }
        }

<span class="nc" id="L1905">        int maxRankNumberForEmp = getMaxRankNumberForEmps(dataCache);</span>

        // compute the score for this shift bid request with the bonus
<span class="nc" id="L1908">        int computedScore = computeScoreForBidder(shiftBidder, bidderOrgSetting, maxRankNumberForEmp, true);</span>
<span class="nc" id="L1909">        m_cat.debug(&quot;computed score with bonus for request/bidder: requestID, bidderID, computedScoreWithBonus: &quot; +</span>
            reqID + ',' + bidderID + ',' + computedScore);

        // set the score with bonus in request and bidder.
<span class="nc bnc" id="L1913" title="All 2 branches missed.">        if (sbReq != null) sbReq.getSetters().setScoreWithBonus(computedScore);</span>
<span class="nc" id="L1914">        shiftBidder.getSetters().setScoreWithBonus(computedScore);</span>

        // compute score for this shift bid request without including the bonus
<span class="nc" id="L1917">        computedScore = computeScoreForBidder(shiftBidder, bidderOrgSetting, maxRankNumberForEmp, false);</span>
<span class="nc" id="L1918">        m_cat.debug(&quot;computed score without bonus for request/bidder: requestID, bidderID, computedScoreWithoutBonus: &quot; +</span>
            reqID + ',' + bidderID + ',' + computedScore);

        // set score without bonus in shift bid request and shiftBidder.
<span class="nc bnc" id="L1922" title="All 2 branches missed.">        if (sbReq != null) sbReq.getSetters().setScoreWithoutBonus(computedScore);</span>
<span class="nc" id="L1923">        shiftBidder.getSetters().setScoreWithoutBonus(computedScore);</span>
<span class="nc" id="L1924">    }</span>

	/**
	 * Gets the maximum rank number assigned to the the employess (ie. max value of EMPLOYEEAM.RANK column).
	 *
	 * @param dataCache
	 * @return
	 * @throws Exception
	 */
    private static int getMaxRankNumberForEmps(Map dataCache) throws Exception {
        // lazy initialization.
<span class="nc" id="L1935">        ShiftBidderDAO bidderDAO = null;</span>

        try {
<span class="nc" id="L1938">            int maxRank = 0;</span>
            // if cache passed as parm.
<span class="nc bnc" id="L1940" title="All 2 branches missed.">            if (dataCache != null) {</span>
                // attempt to get value from cache.
<span class="nc" id="L1942">                Integer maxRankInt = (Integer) dataCache.get(CACHEKEY_MAXRANK);</span>

                // if value not found in cache.
<span class="nc bnc" id="L1945" title="All 2 branches missed.">                if (maxRankInt == null) {</span>
                    // get value
<span class="nc bnc" id="L1947" title="All 2 branches missed.">                    bidderDAO = (bidderDAO == null)?new ShiftBidderDAO(ShiftBidder.DL_BASIC):bidderDAO;</span>
<span class="nc" id="L1948">                    maxRank = bidderDAO.getMaxRankNumberForEmps();</span>

                    // cache value.
<span class="nc" id="L1951">                    maxRankInt = new Integer(maxRank);</span>
<span class="nc" id="L1952">                    dataCache.put(CACHEKEY_MAXRANK, maxRankInt);</span>
                } else {
                    // value retrieved from cache.
<span class="nc" id="L1955">                    maxRank = maxRankInt.intValue();</span>
                }
<span class="nc" id="L1957">            } else { // no cache was passed as parm.</span>
                // get maxRank using DAO from DB.
<span class="nc bnc" id="L1959" title="All 2 branches missed.">                bidderDAO = (bidderDAO == null)?new ShiftBidderDAO(ShiftBidder.DL_BASIC):bidderDAO;</span>
<span class="nc" id="L1960">                maxRank = bidderDAO.getMaxRankNumberForEmps();</span>
            }

<span class="nc" id="L1963">            return maxRank;</span>
        } finally {
<span class="nc bnc" id="L1965" title="All 4 branches missed.">            if (bidderDAO != null) bidderDAO.cleanUp();</span>
        }
    }

    protected static int computeBidderBonusAndEmpPointsSum(ShiftBidder shiftBidder, boolean inclAccumPoints) {
<span class="nc bnc" id="L1970" title="All 2 branches missed.">        int computedBonus = shiftBidder.getBonusThisAuction() +</span>
<span class="nc" id="L1971">			((inclAccumPoints)?shiftBidder.getOptMethods().getEmployee().getAssignedPoints():0);</span>

<span class="nc" id="L1973">        return computedBonus;</span>
    }

    protected static int computeScoreForBidder(ShiftBidder shiftBidder, OrganizationSetting orgSetting,
        int maxRankNumber, boolean inclAccumPoints) {

<span class="nc" id="L1979">        Employee emp = shiftBidder.getOptMethods().getEmployee();</span>

<span class="nc" id="L1981">        float seniorityMultiplier = orgSetting.getShiftBidSeniorityFactor();</span>
<span class="nc" id="L1982">        int seniorityInMonths = TimeZoneUtil.numberOfMonths(emp.getStartTime(), new Date());</span>

<span class="nc" id="L1984">        float rankMultiplier = orgSetting.getShiftBidRankFactor();</span>
<span class="nc" id="L1985">        int empRank = emp.getRank();</span>
<span class="nc bnc" id="L1986" title="All 4 branches missed.">        assert maxRankNumber &gt;= empRank:&quot;maxBonus &gt;= empRank: &quot; + maxRankNumber + &quot;&gt;=&quot; + empRank;</span>
<span class="nc" id="L1987">        empRank = maxRankNumber - empRank; // lower 'rank' (say rank = 1) must translate to higher score.</span>

<span class="nc" id="L1989">        float bonusMultiplier = orgSetting.getShiftBidBonusPointFactor();</span>
<span class="nc" id="L1990">        int computedBonus = computeBidderBonusAndEmpPointsSum(shiftBidder, inclAccumPoints);</span>

<span class="nc" id="L1992">        int computedScore = (int) (rankMultiplier * empRank +</span>
            seniorityMultiplier * seniorityInMonths +
            bonusMultiplier * computedBonus);

<span class="nc" id="L1996">        return computedScore;</span>
    }

//    protected static int computeScoreWithoutBonusForBidder(ShiftBidder shiftBidder, OrganizationSetting orgSetting, int maxRank) {
//        Employee emp = shiftBidder.getOptMethods().getEmployee();
//
//        float rankMultiplier = orgSetting.getShiftBidRankFactor();
//        int empRank = emp.getRank();
//        assert maxRank &gt;= empRank:&quot;maxBonus &gt;= empRank: &quot; + maxRank + &quot;&gt;=&quot; + empRank;
//        empRank = maxRank - empRank; // lower 'rank' (say rank = 1) must translate to higher score.
//
//        float seniorityMultiplier = orgSetting.getShiftBidSeniorityFactor();
//        int seniorityInMonths = emp.getSeniority() / 30; // getSeniority() returns # of days since emp startDate.
//
//        int computedScoreWithoutBonus = (int) (rankMultiplier * empRank + seniorityMultiplier * seniorityInMonths);
//
//        return computedScoreWithoutBonus;
//    }
//
    /**
     * Note: this method may return 'null' if no HOO assignments are found for the employee's org.
     *
     * Obtain the bid deadline for 'nextBidder' after which the next eligible bidder will be added
     * to the serialized auction.
     *
     * Method declared public for access from unit test code.
     *
     * @param bidderTimeLimit
     * @return
     */
    public static Date getBidderDeadlineForSerAuction(ShiftBidder nextBidder, Date currDate, int bidderTimeLimit) throws Exception {
        // resolution for deadline computation in this method is a minute.  So trim the given date to
        // minutes, by resetting seconds and milliseconds to zero.
<span class="nc" id="L2029">        currDate = RequestUtil.getDateWithSecondsReset(currDate);</span>

        // Bidders org can be 'null' if the employee's 'endDate' has expired.
<span class="nc" id="L2032">        Organization org = ValidationUtil.getOrganizationForEmployeeDuringPeriod(nextBidder.getEmployeeID(), currDate, currDate);</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">        if (org == null) {</span>
<span class="nc" id="L2034">        	return null;</span>
        }

		// get the HOOs for shift bidder's org.
<span class="nc" id="L2038">        Collection hoos = RequestUtil.getHooAssignmentsDuringPeriod(org, new TimeRange(currDate, currDate));</span>

		// HOOs collection can never be empty for an org (in London).  But in some test databases in QA,
		// HOO assignments for orgs do not exist.
<span class="nc bnc" id="L2042" title="All 4 branches missed.">		if ( hoos == null || hoos.isEmpty() ) {</span>
<span class="nc" id="L2043">			return null;</span>
		}

        // verify that only one hoo exists in collection.
<span class="nc bnc" id="L2047" title="All 4 branches missed.">        assert hoos.size() == 1:&quot;hoos.size() == 1: &quot; + hoos.size();</span>

        // get the hoo assignment.
<span class="nc" id="L2050">        HOOAssignment hooAssn = (HOOAssignment) hoos.iterator().next();</span>

        //4 possible cases:
        //  currTime falls on a non open day.
        //  currTime before day start
        //  currTime after day end
        //  currTime between day start and end.

        //
        //  if (currTime falls on non open day)
        //     move currtime to next open day.
        //  end if
        //  if (currTime before day's HOO start)
        //    move currtime to day start of this day(if day open) or next open day's hoo start
        //  endif
        //  if currTime after day's HOO end
        //     move currtime to next open day's hoo start.
        //  end if
        //  while (timeLimit &gt; 0)
        //    if currTime + timeLimit within day's HOO
        //       computeDeadlineTime.
        //       timeLimit = 0
        //    else if currTime + timeLimit after day's HOO end.
        //       timeLimit -= remaining minutes for day
        //       move to next open day's hoo start.
        //    end if
        //  end while

        // ********* controlling varaibles: currDate, midnightForCurrDate, currDayOpen, currDayClose. *********
        // initial value for deadline.
<span class="nc" id="L2080">        TimeZone orgTZ = org.getTimeZone();</span>
        //Date currDate = currDate;
        // get calendar for deadline.
<span class="nc" id="L2083">        Calendar currDateCal = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L2084">        currDateCal.setTime(currDate);</span>
        // get midnight for deadline day
<span class="nc" id="L2086">        Date midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>

<span class="nc" id="L2088">        Date currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2089">        Date currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2090">        Calendar currDayCloseCal = Calendar.getInstance(orgTZ);</span>
        //currDayCloseCal.setTime(currDayClose) not done as currDayClose could be null.

        //if currDate does not fall during hours of operation (currDate
        // falls on closed day, before dayStart or after dayEnd)
<span class="nc bnc" id="L2095" title="All 6 branches missed.">        if (currDayOpen == null || currDate.before(currDayOpen) || currDate.after(currDayClose)) {</span>
            // set currDate to next day start
<span class="nc" id="L2097">            currDate = getNextDayOpenForHOO(currDate, hooAssn, orgTZ);</span>

            // recompute associated data.
<span class="nc" id="L2100">            currDateCal.setTime(currDate);</span>
<span class="nc" id="L2101">            midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L2102">            currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2103">            currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2104">            currDayCloseCal.setTime(currDayClose);</span>
        } else {
<span class="nc" id="L2106">            currDayCloseCal.setTime(currDayClose);</span>
        }

<span class="nc bnc" id="L2109" title="All 2 branches missed.">        while (bidderTimeLimit &gt; 0) {</span>
            // add the bidderTimeLimit to the deadLineDate.
<span class="nc" id="L2111">            currDateCal.add(Calendar.MINUTE, bidderTimeLimit);</span>

            // if currDate + timeLimit &lt;= day end
<span class="nc bnc" id="L2114" title="All 2 branches missed.">            if (currDayClose.after(currDateCal.getTime())) {</span>
<span class="nc" id="L2115">                currDate = currDateCal.getTime();</span>
<span class="nc" id="L2116">                bidderTimeLimit = 0; //terminate loop</span>
            } else { // if currDate + timeLimit &gt; day end; we need to get minutes from the next day open.
                // compute minutes left until end of day.
<span class="nc" id="L2119">                int minutesLeft = (int) ((currDayClose.getTime() - currDate.getTime())/60000L);</span>

                // debit # of minutes from bidderTimeLimit
<span class="nc" id="L2122">                bidderTimeLimit -= minutesLeft;</span>
<span class="nc bnc" id="L2123" title="All 4 branches missed.">                assert bidderTimeLimit &gt;= 0:&quot;bidderTimeLimit &gt;= 0: &quot; + bidderTimeLimit;</span>

                // move deadlineDate to next day's start time for which call center is open.
<span class="nc" id="L2126">                currDate = getNextDayOpenForHOO(currDate, hooAssn, orgTZ);</span>
                // recompute associated data.
<span class="nc" id="L2128">                currDateCal.setTime(currDate);</span>
<span class="nc" id="L2129">                midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L2130">                currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2131">                currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2132">                currDayCloseCal.setTime(currDayClose);</span>
<span class="nc" id="L2133">            }</span>
        }

<span class="nc" id="L2136">        return currDate;</span>
    }


    private static Date getNextDayOpenForHOO(Date currDate, HOOAssignment hooAssn, TimeZone orgTZ) {
        // possible cases:
        //   currDate falls on day call center is closed
        //   currDate falls on day call center is open and before day open
        //   currDate falls on day call center is open and between day open and close.
        //   currDate falls on day call center is open and after day open

        // while call center closed or (call center open and currDate is after day start)
        //    find next open day
        //    currDate = day start.
        // end while
        //
        // //At this point we have an open day with currDate before or at dayStart.
        // get day start for currDay.
        // return day start.

        // ********* controlling variables: currDate, midnight for curr date, daystart and dayend. *********
<span class="nc" id="L2157">        Date midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L2158">        Calendar midnightForCurrDateCal = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L2159">        midnightForCurrDateCal.setTime(midnightForCurrDate);</span>

<span class="nc" id="L2161">        Date dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L2162">        Date dayOpenForGivenDate = dayOpenForCurrDate;</span>

        // keep skipping until we find a open day.
        // QA 87592 - Auction Deadline Defaults to 24h
		// if currDate is also the dayOpenForCurrDate then this 'while' will be failed
        //while (dayOpenForCurrDate == null || currDate.after(dayOpenForCurrDate)) {
<span class="nc bnc" id="L2168" title="All 4 branches missed.">        while (dayOpenForCurrDate == null || !dayOpenForCurrDate.after(dayOpenForGivenDate)) {</span>
            // move to next day's midnight
            //midnightForCurrDateCal.add(Calendar.DAY_OF_MONTH, 1);
<span class="nc" id="L2171">			TOCalcUtil.addDaysToCalendar(midnightForCurrDateCal, 1);</span>
<span class="nc" id="L2172">            midnightForCurrDate = midnightForCurrDateCal.getTime();</span>

            // get the opening time for next day.
<span class="nc" id="L2175">            dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc bnc" id="L2176" title="All 2 branches missed.">            currDate = (dayOpenForCurrDate != null)?dayOpenForCurrDate:midnightForCurrDate;</span>
        }

        // At this point, we have an open day with currDate either before or at dayStart.  Now adjust accordingly.
<span class="nc" id="L2180">        midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L2181">        dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>

<span class="nc" id="L2183">        return dayOpenForCurrDate;</span>
    }


    /**
     * Returns the sorted list of bidders (sorted by the given sort criteria) who are 'unadded' and
     * marked as 'seraialized auction bidders'.  If no such bidders exist, return null.
     *
     * @param auctionID
     * @return
     */
    private static List getSortedBiddersForSerAuction(ID auctionID, int rankBy, ShiftBidderDAO bidderDAO)
        throws Exception {

<span class="nc bnc" id="L2197" title="All 2 branches missed.">        boolean bidderDAOAllocNeeded = (bidderDAO == null);</span>
<span class="nc" id="L2198">        ShiftBidAuctionDAO sbAucDAO = null;</span>
        try {
<span class="nc bnc" id="L2200" title="All 2 branches missed.">            bidderDAO = (bidderDAO == null)?new ShiftBidderDAO(ShiftBidder.DL_BASIC):bidderDAO;</span>

//            Collection notAddedBidders = bidderDAO.getShiftBiddersForAuction(auctionID, null,
//                ShiftBidder.STATUS_NOT_ADDED, ShiftBidder.DL_BASIC | ShiftBidder.DL_EMPLOYEE);
<span class="nc" id="L2204">            Collection notAddedSerAucBidders = bidderDAO.getSerializedAuctionBiddersForAuction(</span>
                auctionID, ShiftBidder.DL_BASIC | ShiftBidder.DL_EMPLOYEE);

            // return if no 'not added' bidders found.
<span class="nc bnc" id="L2208" title="All 2 branches missed.">            if (notAddedSerAucBidders.isEmpty()) return null;</span>

            // need to compute the score for the bidders if ranking is by 'score'
<span class="nc bnc" id="L2211" title="All 4 branches missed.">            if (!notAddedSerAucBidders.isEmpty() &amp;&amp; rankBy == ShiftBidder.RANKBY_SCORE) {</span>
                // fetch the auction object.
<span class="nc bnc" id="L2213" title="All 2 branches missed.">                sbAucDAO = (sbAucDAO != null)?sbAucDAO:new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2214">                ShiftBidAuction sbAuction = sbAucDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

                // this caches the orgSettings in between invocations of 'computeBonusAnd....()' method below.
<span class="nc" id="L2217">                Map orgIDToOrgSettingCacheMap = new HashMap(16);</span>
<span class="nc" id="L2218">                Map methodDataCacheMap = new HashMap(10);</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">                for (Iterator notAddedSerAucBiddersIter = notAddedSerAucBidders.iterator(); notAddedSerAucBiddersIter.hasNext();) {</span>
<span class="nc" id="L2220">                    ShiftBidder notAddedBidder = (ShiftBidder) notAddedSerAucBiddersIter.next();</span>

<span class="nc" id="L2222">                    computeBonusAndScoreWithAndWithoutPoints(null, notAddedBidder, sbAuction, null, null,</span>
                        orgIDToOrgSettingCacheMap, methodDataCacheMap);
<span class="nc" id="L2224">                }</span>
            }

<span class="nc" id="L2227">            List notAddedBiddersList = RequestUtil.getListFromCollection(notAddedSerAucBidders);</span>
<span class="nc bnc" id="L2228" title="All 2 branches missed.">            if (notAddedBiddersList.size() &gt; 1)</span>
<span class="nc" id="L2229">                Collections.sort(notAddedBiddersList, new ShiftBidAuctionUtil.ShiftBidderComparator(rankBy));</span>

<span class="nc" id="L2231">            return notAddedBiddersList;</span>
        } finally {
<span class="nc bnc" id="L2233" title="All 12 branches missed.">            if (bidderDAOAllocNeeded &amp;&amp; bidderDAO != null) bidderDAO.cleanUp();</span>
<span class="nc bnc" id="L2234" title="All 6 branches missed.">            if (sbAucDAO != null) sbAucDAO.cleanUp();</span>
        }
    }

    /**
     * TODO: think about if bidder's state transistion and isSerializedBidder flag must be linked.  If
     * so, this is the method where the link can be enforced.
     *
     * @param origBidderFromDB
     * @param newStatus
     */
    protected static ValidationResult validateShiftBidderStateTrans(ShiftBidder origBidderFromDB,
        int newStatus) {

<span class="nc" id="L2248">        int origStatus = origBidderFromDB.getStatus();</span>
        //int newStatus = givenBidder.getStatus();

<span class="nc bnc" id="L2251" title="All 2 branches missed.">        if (origStatus == newStatus)</span>
<span class="nc" id="L2252">            return null;</span>

        // valid transistions:
        //
        //             Not Added  Added  Scheduled
        //  Not Added               x       x
        //    Added       x                 x
        //  Scheduled     x
        //
<span class="nc bnc" id="L2261" title="All 4 branches missed.">        if (origStatus == ShiftBidder.STATUS_UNAVAILABLE &amp;&amp; newStatus == ShiftBidder.STATUS_ADDED) {</span>
<span class="nc" id="L2262">			String oldState = ShiftBidder.STATUS_STRARR[origStatus];</span>
<span class="nc" id="L2263">			String newState = ShiftBidder.STATUS_STRARR[newStatus];</span>

<span class="nc" id="L2265">			return ValidationUtil.setAndLogHardValidationResult(origBidderFromDB,</span>
					RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
					new Serializable[] {oldState, newState, &quot;n/a&quot;}, m_className);
		}

<span class="nc" id="L2270">        return null;</span>
    }

    /**
     * &lt;p&gt;Note: To detect if any updates were done, check for a hard or soft validation error.
     * &lt;p&gt;
     * If the shiftBidder VO has invalid fields, then either:
     * &lt;li&gt; shiftBidder VO is updated with the invalid value replaced with a valid value, a soft
     * validation result is added to the shiftBidder VO but a 'null' is still returned.
     * &lt;li&gt; or a hard validation error is added to the shiftBidder VO and this non-null hard
     * validation result is returned to the caller.
     *
     * &lt;p&gt; one or more of the following validations are done (depending on the 'actionType' parameter)
     * &lt;li&gt; if bidder is being added to the auction, has the auction already expired?
     * &lt;li&gt; bidder deadline is not later than auction deadline
     * &lt;li&gt; Does bidder status have a valid value?
     * &lt;li&gt; Is the status transition valid for the bidder?
     * &lt;li&gt; Is employee in good standing?
     * &lt;li&gt; Must employee's status be changed from 'scheduled' to another or to 'scheduled' from another.
     *
     * @param sbAuction if non null, then the bidder's deadline is validated against the auction deadline.  If
     * null, then this check is not made.
     *
     * @param origBidderFromDB Used for update validation and represents the original bidder object fetched from DB
     * before the update. Must be non-null if actionType = {@link RequestUtil#ACTION_UPDATE ACTION_UPDATE}.
     * Can be null otherwise.
     *
     * @param givenBidder For ACTION_UPDATE, represents the updated object.  Contrast this with 'origBidderFromDB'
     * parameter.  For other actions, represents the bidder object to be validated.
     */
    public static ValidationResult validateShiftBidderAndUpdate(ShiftBidder givenBidder, ShiftBidder origBidderFromDB,
            int actionType, ShiftBidAuction sbAuction, Collection&lt;ID&gt; unavailableEmpIDs )  throws Exception
    {
        //
        // validate shiftBidder on get
        //    shiftBidder deadline &lt;= auctionDeadline.
        //    employee in good standing
        // validate shiftbidder on create
        //    shiftBidder deadline &lt;= auctionDeadline.
        //    valid state.
        //    employee in good standing
        // validate shiftBidder on update
        //    updateable fields: deadline, status, bonusThisAuction.
        //    shift bidder deadline &lt;= auctionDeadline.
        //    valid state and state transition
        //    employee in good standing
        // validate shiftBidder on delete:
        //    not necessary
        //
<span class="nc" id="L2319">        ID bidderID = givenBidder.getID();</span>
<span class="nc" id="L2320">		ValidationResult valResult = null;</span>
<span class="nc bnc" id="L2321" title="All 2 branches missed.">        if (actionType == RequestUtil.ACTION_UPDATE) {</span>
            // copy 'unset' fields from origBidderFromDB to 'givenBidder'.
<span class="nc" id="L2323">            givenBidder.getSetters().copyUnsetFields(origBidderFromDB);</span>

            // verify state transition validation.
<span class="nc" id="L2326">			valResult = validateShiftBidderStateTrans(origBidderFromDB, givenBidder.getStatus());</span>
<span class="nc bnc" id="L2327" title="All 2 branches missed.">            if (valResult != null) return valResult;</span>

<span class="nc bnc" id="L2329" title="All 4 branches missed.">            boolean bidderAddition = !origBidderFromDB.isStatusAdded() &amp;&amp; givenBidder.isStatusAdded();</span>
            // Note: A bidder can be added to a closed auction.  For instance, the mgr can add bidders to a
            // a closed auction and then open the auction.

            // verify bidder cannot be 'added' to an expired auction.
<span class="nc" id="L2334">            Date currDate = new Date();</span>
<span class="nc bnc" id="L2335" title="All 6 branches missed.">            if (bidderAddition &amp;&amp; sbAuction != null &amp;&amp; sbAuction.getAuctionDeadLine().before(currDate)) {</span>
<span class="nc" id="L2336">                return ValidationUtil.setAndLogHardValidationResult(givenBidder,</span>
                    RmEjbBundleKey.AUC_CANT_ADD_BIDDER_AFTER_AUC_DEADLINE, RmEjbLogBundleKey.AUC_CANT_ADD_BIDDER_AFTER_AUC_DEADLINE,
<span class="nc" id="L2338">                    new Serializable[]{origBidderFromDB.getID(), sbAuction.getID()}, m_className);</span>
            }
        }

        // bidder deadline is no later than auction deadline.
<span class="nc" id="L2343">        Date bidderDeadlineDate = givenBidder.getDeadlineDate();</span>
<span class="nc bnc" id="L2344" title="All 6 branches missed.">        if (sbAuction != null &amp;&amp; bidderDeadlineDate != null &amp;&amp; bidderDeadlineDate.after(sbAuction.getAuctionDeadLine())) {</span>
<span class="nc" id="L2345">            Date aucDeadline = sbAuction.getAuctionDeadLine();</span>
<span class="nc" id="L2346">            givenBidder.setDeadlineDate(aucDeadline);</span>

<span class="nc" id="L2348">            m_cat.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_DEADLINE_WITH_AUC_DEALINE,</span>
								new Object[]{bidderID, aucDeadline});
<span class="nc" id="L2350">            ValidationUtil.setSoftValidationResult(givenBidder,</span>
								RmEjbLogBundleKey.AUC_UPDATED_BIDDER_DEADLINE_WITH_AUC_DEALINE, m_className);
        }

        // Does bidder status have a valid value?
<span class="nc bnc" id="L2355" title="All 4 branches missed.">        if (givenBidder.getStatus() &lt; ShiftBidder.STATUS_FIRST || givenBidder.getStatus() &gt; ShiftBidder.STATUS_LAST) {</span>
<span class="nc" id="L2356">			return ValidationUtil.setAndLogHardValidationResult(givenBidder,</span>
                    RmEjbBundleKey.AUC_INVALID_BIDDER_STATUS,
					RmEjbLogBundleKey.AUC_INVALID_BIDDER_STATUS,
<span class="nc" id="L2359">                    new Serializable[] {bidderID, NumberFactory.newInteger(givenBidder.getStatus())}, m_className);</span>
        }

        // Is employee in good standing?  detail level == EMPLOYEE is checked to ensure that any call
        // to fetch a shift bidder with detail level != EMPLOYEE, say thru the EJB API, will not result in an exception here.
<span class="nc bnc" id="L2364" title="All 2 branches missed.">        if ((givenBidder.getDetailLevel() &amp; ShiftBidder.DL_EMPLOYEE) != 0)  {</span>
<span class="nc" id="L2365">            Employee emp = givenBidder.getOptMethods().getEmployee();</span>
            // Is employee's end time in the future?
<span class="nc bnc" id="L2367" title="All 4 branches missed.">            if (emp.getEndTime() != null &amp;&amp; emp.getEndTime().getTime() &lt; System.currentTimeMillis()) {</span>
<span class="nc" id="L2368">				return ValidationUtil.setAndLogHardValidationResult(givenBidder,</span>
                        RmEjbBundleKey.EMP_HAS_BEEN_TERMINATED, RmEjbLogBundleKey.EMP_HAS_BEEN_TERMINATED,
<span class="nc" id="L2370">                        new Serializable[] {bidderID, emp.getEndTime()}, m_className);</span>
            }
        }

<span class="nc" id="L2374">		valResult = validateShiftBidderForScheduled(givenBidder, unavailableEmpIDs);</span>
<span class="nc bnc" id="L2375" title="All 2 branches missed.">		if (valResult != null) return valResult;</span>

<span class="nc" id="L2377">        return null;</span>
    }

	/**
	 * @param givenBidder
	 * @param bidderEmpIDToNumOfShiftsMap
	 * @return a validationResult which reflects the validation modification made.
	 * &lt;li&gt; If validaiton modifications were made, returns a non-null value.  If
	 * {@link SimpleValidationResult#getValResult() SimpleValidationResult.getValResult()} returns
	 * {@link SimpleValidationResult#VALRESULT_ERROR VALRESULT_ERROR} then a hard validation error was
	 * encountered.  Otherwise a soft validation error (recoverable) occured.
	 * &lt;li&gt; If no validation modifications were done returns 'null.
	 */
	private static ValidationResult validateShiftBidderForScheduled(ShiftBidder givenBidder,
			Collection&lt;ID&gt; unavailableEmpIDs) {

<span class="nc" id="L2393">		ID bidderEmpID = givenBidder.getEmployeeID();</span>
<span class="nc" id="L2394">		ID bidderID = givenBidder.getID();</span>

        // if employee is scheduled for SP week
<span class="nc bnc" id="L2397" title="All 4 branches missed.">		if (unavailableEmpIDs != null &amp;&amp; unavailableEmpIDs.contains(bidderEmpID)) {</span>
			// if status is not 'scheduled', make it scheduled.
<span class="nc bnc" id="L2399" title="All 2 branches missed.">			if (givenBidder.getStatus() != ShiftBidder.STATUS_UNAVAILABLE) {</span>
				// since the employee has shifts during the SP week, switch status to scheduled.
				//verify if this status transistion is valid.
<span class="nc" id="L2402">				ValidationResult stateTransValRes = validateShiftBidderStateTrans(givenBidder, ShiftBidder.STATUS_UNAVAILABLE);</span>
				// if transition is invalid, return.
<span class="nc bnc" id="L2404" title="All 2 branches missed.">				if (stateTransValRes != null) return stateTransValRes;</span>

<span class="nc" id="L2406">				givenBidder.getSetters().setStatus(ShiftBidder.STATUS_UNAVAILABLE);</span>
                // reset deadline date.  deadline set only for status == 'added'.
<span class="nc" id="L2408">                givenBidder.setDeadlineDate(null);</span>

                // 'bonus this auction' is not reset.  Keep the value as a reference for
                // the manager after the bidder's req is approved and scheduled.
                // Not resetting this to zero on 'scheduled' status does not affect anything else.
                //
				//givenBidder.setBonusThisAuction(0);

<span class="nc" id="L2416">				m_cat.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS,</span>
						new Object[]{bidderID,
<span class="nc" id="L2418">												 NumberFactory.newInteger(givenBidder.getStatus()),</span>
<span class="nc" id="L2419">												 NumberFactory.newInteger(ShiftBidder.STATUS_UNAVAILABLE)});</span>
<span class="nc" id="L2420">				ValidationUtil.setSoftValidationResult(givenBidder,</span>
					RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS, m_className);
<span class="nc" id="L2422">			}</span>
		// if employee is not scheduled for SP week
<span class="nc bnc" id="L2424" title="All 4 branches missed.">		} else if (unavailableEmpIDs != null &amp;&amp; !unavailableEmpIDs.contains(bidderEmpID)) {</span>
			// if employee is marked scheduled.
<span class="nc bnc" id="L2426" title="All 2 branches missed.">			if (givenBidder.getStatus() == ShiftBidder.STATUS_UNAVAILABLE) {</span>
				//verify if this status transistion is valid.
<span class="nc" id="L2428">				ValidationResult stateTransValRes = validateShiftBidderStateTrans(givenBidder, ShiftBidder.STATUS_NOT_ADDED);</span>
				// if transistion is invalid, return.
<span class="nc bnc" id="L2430" title="All 2 branches missed.">				if (stateTransValRes != null) return stateTransValRes;</span>
<span class="nc" id="L2431">				givenBidder.getSetters().setStatus(ShiftBidder.STATUS_NOT_ADDED);</span>
<span class="nc" id="L2432">				givenBidder.setDeadlineDate(null);  //reset deadline date.  deadline set only for status == 'added'.</span>

<span class="nc" id="L2434">				m_cat.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS,</span>
						new Object[]{bidderID,
<span class="nc" id="L2436">												 NumberFactory.newInteger(ShiftBidder.STATUS_UNAVAILABLE),</span>
<span class="nc" id="L2437">												 NumberFactory.newInteger(ShiftBidder.STATUS_NOT_ADDED),</span>
						});
<span class="nc" id="L2439">				ValidationUtil.setSoftValidationResult(givenBidder,</span>
					RmEjbBundleKey.AUC_UPDATED_BIDDER_STATUS, m_className);
			}
		}

<span class="nc" id="L2444">		return null;</span>
	}

    /**
     * &lt;p&gt; Loads the bidder VOs from DB corresponding to the bidders in 'givenBidders'. Validates each bidder
     *  in 'givenBidders'.  If validation fails for a bidder, bidder is removed from the 'givenBidders' collection.
     *
     * &lt;p&gt;Note: The list of givenBidders must be a mutable list. This method might remove elements from this
     * list.
     *
     * &lt;p&gt; All shift bidder updates happen thru' this method except for updates to 'isSerializedAuctionBidder'
     * flag for a bidder.  This is done using a DAO method (called by startAuctionSerialization() and
     * stopAuctionSerialization() methods).
     *
     * @param auctionID
     * @param givenBidders
     * @param sbAuctionDAO
     * @param bidderDAO
     * @throws Exception
     */
    public static void validateShiftBiddersForUpdateActionAndUpdate(ID auctionID, Collection givenBidders,
        ShiftBidAuctionDAO sbAuctionDAO, ShiftBidderDAO bidderDAO) throws Exception {
<span class="nc bnc" id="L2466" title="All 2 branches missed.">        boolean bidderDAONeedsCreate = bidderDAO == null;</span>
<span class="nc bnc" id="L2467" title="All 2 branches missed.">        boolean sbAuctionDAONeedsCreate = sbAuctionDAO == null;</span>
        try  {
<span class="nc" id="L2469">            List shiftBidderIDs = RequestUtil.getListOfIDsFromVOBases(givenBidders);</span>

            // get auction VO.
<span class="nc bnc" id="L2472" title="All 2 branches missed.">            sbAuctionDAO = (sbAuctionDAONeedsCreate)?new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC):sbAuctionDAO;</span>
<span class="nc" id="L2473">            ShiftBidAuction sbAuction = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

            // load given bidders from DB.
<span class="nc bnc" id="L2476" title="All 2 branches missed.">            bidderDAO = (bidderDAONeedsCreate)?new ShiftBidderDAO(ShiftBidder.DL_BASIC):bidderDAO;</span>
<span class="nc" id="L2477">            List givenBidderIDs = RequestUtil.getListOfIDsFromVOBases(givenBidders);</span>
<span class="nc" id="L2478">            Collection biddersFromDB = bidderDAO.getShiftBiddersByIDs(givenBidderIDs,</span>
<span class="nc" id="L2479">                false, ShiftBidder.getDetailLevelForValidation());</span>
<span class="nc" id="L2480">            Map bidderIDTobidderFromDBMap = RequestUtil.getMapOfIDsForVOBases(biddersFromDB);</span>

<span class="nc bnc" id="L2482" title="All 2 branches missed.">            for (Iterator givenBiddersIter = givenBidders.iterator(); givenBiddersIter.hasNext();) {</span>
<span class="nc" id="L2483">                ShiftBidder givenBidder = (ShiftBidder) givenBiddersIter.next();</span>

                // validate if the update operation
<span class="nc" id="L2486">                ValidationResult hardValResult = validateShiftBidderAndUpdate(givenBidder,</span>
<span class="nc" id="L2487">                    (ShiftBidder) bidderIDTobidderFromDBMap.get(givenBidder.getID()), RequestUtil.ACTION_UPDATE, sbAuction, null);</span>

                //TODO: handle this better.  Need to notify caller.
<span class="nc bnc" id="L2490" title="All 2 branches missed.">                if (hardValResult != null) { // &amp;&amp; valResult.getValResult() == SimpleValidationResult.VALRESULT_ERROR) {</span>
<span class="nc" id="L2491">                    m_cat.debug(hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), TimeZone.getDefault()));</span>
<span class="nc" id="L2492">                    givenBiddersIter.remove();</span>
                }
<span class="nc" id="L2494">            }</span>

<span class="nc" id="L2496">            m_cat.debug(&quot;Updating shift bidders: size = &quot; + givenBidders.size());</span>
<span class="nc" id="L2497">            bidderDAO.updateShiftBidders(givenBidders);</span>
        } finally  {
<span class="nc bnc" id="L2499" title="All 8 branches missed.">            if (bidderDAONeedsCreate &amp;&amp; bidderDAO != null) bidderDAO.cleanUp();</span>
<span class="nc bnc" id="L2500" title="All 8 branches missed.">            if (sbAuctionDAONeedsCreate &amp;&amp; sbAuctionDAO != null) sbAuctionDAO.cleanUp();</span>
        }
<span class="nc" id="L2502">    }</span>

    /**
     * &lt;li&gt; identify unadded shift bidders and rank them.  Get first bidder in list.
     * &lt;li&gt; Add first as current bidder.
     * &lt;li&gt; compute deadline for current bidder to respond by.
     * &lt;li&gt; update AuctionSerialization table with currentBidder and bidderDeadline.
     * &lt;li&gt; update current bidder's status to 'added'
     * &lt;li&gt; Notify current bidder.
     *
     * @param serAucDAO optional.  If not specifid, then a DAO is created for internal use.  If not, passed
     *   DAO reused.
     * @param serAuc optional.  If specified, object reused internally.  If not, then object loaded from DB.
     * @return 'null' if no bidders were added (ie all eligible bidders have been added alread).
     * the added shift bidder if otherwise.
     * @throws Exception
     */
    public static ShiftBidder addNextBidderToSerAucUpdateAndNotify(SerializedAuction serAuc, SerializedAuctionDAO serAucDAO, ShiftBidderDAO shiftBidderDAO) throws Exception {
<span class="nc bnc" id="L2520" title="All 2 branches missed.">        boolean serAucDaoCreateNeeded = (serAucDAO == null);</span>
<span class="nc bnc" id="L2521" title="All 2 branches missed.">        boolean shiftBidderDAOCreateNeeded = (shiftBidderDAO == null);</span>

        try {
<span class="nc bnc" id="L2524" title="All 2 branches missed.">            serAucDAO = (serAucDaoCreateNeeded)?new SerializedAuctionDAO():serAucDAO;</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">            shiftBidderDAO = (shiftBidderDAOCreateNeeded)?new ShiftBidderDAO(ShiftBidder.DL_BASIC):shiftBidderDAO;</span>

//            // if serialized auction already exists, fetch from db, and set the serialized auction ID
//            SerializedAuction serAucFromDB = serAucDAO.getSerializedAuctionForAuctionID(serAuc.getAuctionID());
//            if (serAucFromDB != null) serAuc.setID(serAucFromDB.getID());

            // set &quot;isEnabled&quot; = true in AuctionSerailization table.
<span class="nc" id="L2532">            serAuc.setIsEnabled(true);</span>

            // get sorted list of bidders for serialized auction (sorted by given criteria)
<span class="nc" id="L2535">            ID serAucID = serAuc.getAuctionID();</span>
<span class="nc" id="L2536">            List sortedBiddersList = getSortedBiddersForSerAuction(serAucID, serAuc.getRankingMethod(), shiftBidderDAO);</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">            if (sortedBiddersList == null) {</span>
<span class="nc" id="L2538">                m_cat.debug(&quot;No bidder found (All bidders already added) for adding to the serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L2539">                return null;</span>
            }

            // choose the first **valid** top ranked bidder (start with the end of the list to find bidders with highest rank)
<span class="nc" id="L2543">            Date currDate = new Date();</span>
<span class="nc" id="L2544">            Date nextBidderAdditionDeadline = null;</span>
<span class="nc" id="L2545">            ShiftBidder topBidder = null;</span>
<span class="nc" id="L2546">            List topBidderSingletonList = new ArrayList(1);</span>
<span class="nc" id="L2547">            int i = 0;</span>
<span class="nc bnc" id="L2548" title="All 2 branches missed.">            for (i = (sortedBiddersList.size() - 1); i &gt;=0; i-- ) {</span>
                // TODO: tie breaker must be used if multiple bidders are tied for the first spot.
                // Note: top ranked bidder is the last in the list and not the first.
<span class="nc" id="L2551">                topBidder = (ShiftBidder) sortedBiddersList.get(i);</span>

                // get time after which the next eligible bidder will be added to the serialized auction.
<span class="nc" id="L2554">                nextBidderAdditionDeadline =</span>
<span class="nc" id="L2555">                    getBidderDeadlineForSerAuction(topBidder, currDate, serAuc.getBidderTimelimit());</span>

                // if the deadline can't computed (most likely reason: no org hoo assignment for employee's org).
<span class="nc bnc" id="L2558" title="All 2 branches missed.">                if (nextBidderAdditionDeadline == null) {</span>
<span class="nc" id="L2559">                	continue;</span>
                }

                // update status to added.
<span class="nc" id="L2563">                topBidder.getSetters().setStatus(ShiftBidder.STATUS_ADDED);</span>
<span class="nc" id="L2564">                topBidder.setDeadlineDate(nextBidderAdditionDeadline);</span>

                // update shiftBidder in DB (status was changed to 'added')
<span class="nc" id="L2567">                topBidderSingletonList.add(topBidder);</span>
<span class="nc" id="L2568">                ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(serAucID,</span>
                    topBidderSingletonList, null, shiftBidderDAO);

                // if bidder passed validation.
<span class="nc bnc" id="L2572" title="All 2 branches missed.">                if ( !topBidderSingletonList.isEmpty()) {</span>
<span class="nc" id="L2573">                    m_cat.debug(&quot;Added bidder ID &quot; + topBidder.getID() + &quot; to auction ID &quot; + serAucID);</span>
<span class="nc" id="L2574">                    break;</span>
                }

                // validation failed for bidder.  bidder was not updated in the DB.
<span class="nc" id="L2578">                m_cat.debug(&quot;Bidder ID &quot; + topBidder.getID() + &quot; not added to auction ID &quot; + serAucID + &quot; due to bidder validation error&quot;);</span>
                // look for the next bidder.
            }
            // if no valid bidders were found
<span class="nc bnc" id="L2582" title="All 2 branches missed.">            if (i &lt; 0 ) {</span>
<span class="nc" id="L2583">                m_cat.debug(&quot;No valid bidders (from eligible bidders) found for adding to the serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L2584">                return null;</span>
            }

            // update serialized auction attributes.
<span class="nc" id="L2588">            serAuc.setCurrentBidderDeadline(nextBidderAdditionDeadline);</span>
<span class="nc" id="L2589">            serAuc.setCurrentBidderID(topBidder.getID());</span>

            // if first time auction is serialized, create AuctionSerialization record in db.
<span class="nc bnc" id="L2592" title="All 2 branches missed.">            if (serAuc.getID() == null) {</span>
<span class="nc" id="L2593">                m_cat.debug(&quot;Creating serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L2594">                serAucDAO.createSerializedAuction(serAuc);</span>
            } else  { // if auction was serialized earlier, update the existing record in db.
<span class="nc" id="L2596">                m_cat.debug(&quot;updating serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L2597">                serAucDAO.updateSerializedAuction(serAuc);</span>
            }

            // send notification
<span class="nc" id="L2601">            ShiftBidAuction sbAuction = _getAuctionByID(serAucID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2602">            fireSerAuctionNotification(serAuc, topBidder, sbAuction);</span>

<span class="nc" id="L2604">            return topBidder;</span>
        } finally {
<span class="nc bnc" id="L2606" title="All 16 branches missed.">            if (serAucDaoCreateNeeded &amp;&amp; serAucDAO != null) serAucDAO.cleanUp();</span>
<span class="nc bnc" id="L2607" title="All 16 branches missed.">            if (shiftBidderDAOCreateNeeded &amp;&amp; shiftBidderDAO != null) shiftBidderDAO.cleanUp();</span>
        }
    }

    public static ShiftBidAuction _getAuctionByID(ID auctionID, long detailLevel) throws Exception {
<span class="nc" id="L2612">        ShiftBidAuctionDAO auctionDao = null;</span>
        try  {
<span class="nc" id="L2614">            auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L2615">            Collection auctions = auctionDao.getAuctionsByIDs(Collections.singletonList(auctionID), detailLevel);</span>

<span class="nc bnc" id="L2617" title="All 2 branches missed.">            if (auctions.size() == 0) {</span>
<span class="nc" id="L2618">                throw RequestUtil.createRmException(RmEjbLogBundleKey.AUC_NOT_FOUND,</span>
                    auctionID, m_cat);
            }

<span class="nc" id="L2622">            return (ShiftBidAuction)auctions.iterator().next();</span>
        } finally  {
<span class="nc bnc" id="L2624" title="All 4 branches missed.">            if (auctionDao != null) auctionDao.cleanUp();</span>
        }
    }


    /**
     * This method should not throw any exceptions to ensure that the current transaction
     * is not aborted because notification failed.
     *
     * @param serAuc
     */
    private static void fireSerAuctionNotification(SerializedAuction serAuc, ShiftBidder nextBidder, ShiftBidAuction sbAuction)  {
<span class="nc" id="L2636">        m_cat.debug(&quot;fireSerAuctionNotification: Sending JMS message to Notification subsystem&quot;);</span>

<span class="nc" id="L2638">        SerializedAuctionDetail serAucDetail = new SerializedAuctionDetail();</span>
<span class="nc" id="L2639">        serAucDetail.setAuctionID(serAuc.getID());</span>
<span class="nc" id="L2640">        serAucDetail.setAuctionName(sbAuction.getName());</span>
<span class="nc" id="L2641">        serAucDetail.setNextEmployeeBidDeadline(serAuc.getCurrentBidderDeadline());</span>
<span class="nc" id="L2642">        serAucDetail.setNextEmployeeID(nextBidder.getEmployeeID());</span>
<span class="nc" id="L2643">        serAucDetail.setNextShiftBidderID(serAuc.getCurrentBidderID());</span>

<span class="nc" id="L2645">        JMSNotifyUtil.notifyOnUserAction(serAucDetail);</span>
<span class="nc" id="L2646">    }</span>

    /**
     * computes the rank of the given shift bid request, in the context of the shiftbid request's
     * bidder.
     *
     * &lt;li&gt; obtains the biddable schedules associated with the shift bid request.
     * &lt;li&gt; for each biddable schedule, obtains all shift bid requests which refer to it and
     * with state 'pending', 'escalated' or 'tentatively approved'
     * &lt;li&gt; orders this list of shift bid requests using 'score with bonus' and 'score without bonus'.
     * &lt;li&gt; computes the rank of the given shift bid request in this list of shiftbid requests.
     *
     * &lt;p&gt; for 'weekly schedule' auctions, shift bid request is associated with only one biddable
     * schedule.  But for 'single shift auctions', a shiftbid request can be associated with one or
     * more biddable schedules.  In this case, the rank of the request for each biddable schedule is
     * computed and the lowest rank is the final rank of the shift bid request.
     *
     * @param sbReqGiven This must at least have the detailLevel {@link ShiftBidRequest#DL_BIDRANK_FOR_SHIFTBIDREQUEST}
     * which ensures that the associated biddableSchedules are loaded.
     *
     * @param isGivenSBReqPersisted flag which indicates if the given SB request is persisted in the DB or
     * not.  This method may be used to compute the rank for shift bid requests not persisted in the DB (for
     * instance to display the rank for an SBRequest in 'create' screen of the UI)
     *
     * @param bidSchedIDToBidSchedWithAssocBidReqsCache map of bidSchedID to bidSchedule.  used to cache biddable schedules
     * needed by this method in between invocations of this method (ie data cached during 1st invocation of
     * this method can be used by the 2nd invocation).
     *
     * @param bidSchedDAO
     *
     * @throws Exception
     *
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getBonusComputed()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getBonusToBeAwarded()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithoutBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getRankWithBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getRankWithoutBonus()
     */
    public static void computeRankForShiftBidRequest(ShiftBidRequest sbReqGiven, boolean isGivenSBReqPersisted,
            Map bidSchedIDToBidSchedWithAssocBidReqsCache, BiddableScheduleDAO bidSchedDAO ) throws Exception
    {
<span class="nc" id="L2688">    	computeRankForShiftBidRequest(sbReqGiven, isGivenSBReqPersisted,</span>
                bidSchedIDToBidSchedWithAssocBidReqsCache, bidSchedDAO, false);
<span class="nc" id="L2690">    }</span>
    
    public static void computeRankForShiftBidRequest(ShiftBidRequest sbReqGiven, boolean isGivenSBReqPersisted,
        Map bidSchedIDToBidSchedWithAssocBidReqsCache, BiddableScheduleDAO bidSchedDAO, boolean incExpired ) throws Exception
    {
        // Ranking can only be done for reqs with one of the soft validation states.
<span class="nc bnc" id="L2696" title="All 2 branches missed.">        if ( !RequestAuditTrail.SOFT_VALIDATION_STATES.contains(sbReqGiven.getRequestStatus()))</span>
<span class="nc" id="L2697">            return;</span>

        // does bidSchedDAO need to be instantiated in this method?
<span class="nc bnc" id="L2700" title="All 2 branches missed.">        boolean allocBidSchedDAO = (bidSchedDAO == null);</span>

<span class="nc" id="L2702">        m_cat.debug(&quot;Computing rank for shift bid request: ID = &quot; + sbReqGiven.getID());</span>
        try {
            // get biddable schedule(s) associated with this shiftBidRequest. Request for full period
            // auction has one biddable schedule.  Request for single shift auction has multiple.
<span class="nc" id="L2706">            List bidSchedsFromReq = sbReqGiven.getOptMethods().getBiddableSchedules();</span>

            //iteratate thru the bidScheds associated with the req to compute the rank for each bidSched.
<span class="nc bnc" id="L2709" title="All 2 branches missed.">            for (Iterator bidSchedsFromReqIter = bidSchedsFromReq.iterator();bidSchedsFromReqIter.hasNext(); ) {</span>
<span class="nc" id="L2710">                BiddableSchedule bidSchedFromReq = (BiddableSchedule) bidSchedsFromReqIter.next();</span>

                // bidSched associated with this request can be null if the associated bidSched has
                // bidSched.numOfAvailInstances == 0.  In this case, the request is invalid and might be marked
                // as such later (when the hard vaidators are run).
<span class="nc bnc" id="L2715" title="All 2 branches missed.">                if (bidSchedFromReq == null) continue;</span>

<span class="nc bnc" id="L2717" title="All 2 branches missed.">                bidSchedDAO = (bidSchedDAO == null)?new BiddableScheduleDAO(BiddableSchedule.DL_BASIC):bidSchedDAO;</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">                bidSchedIDToBidSchedWithAssocBidReqsCache =</span>
                    (bidSchedIDToBidSchedWithAssocBidReqsCache == null)?new HashMap():bidSchedIDToBidSchedWithAssocBidReqsCache;

                // if the given SBReq is not persisted in the DB, pass it the following method to add it to
                // the list being sorted.
<span class="nc bnc" id="L2723" title="All 2 branches missed.">                Pair sortedSBReqsPair = getSortedSBReqsForBiddableSched(bidSchedFromReq,</span>
<span class="nc" id="L2724">                    (isGivenSBReqPersisted)?null:sbReqGiven, sbReqGiven.getShiftBidderID(),</span>
                    true, bidSchedIDToBidSchedWithAssocBidReqsCache, bidSchedDAO, incExpired);

<span class="nc" id="L2727">                List sbReqsForBidSchedSortedByScoreWithBonus = (List) sortedSBReqsPair.getFirst();</span>
<span class="nc" id="L2728">                List sbReqsForBidSchedSortedByScoreWithoutBonus = (List) sortedSBReqsPair.getSecond();</span>

                // set the lower of the current rank and the new rank.
                // see ShiftBidRequest.ShiftRequestOptMethods#getRankWithBonus().
<span class="nc" id="L2732">                setSBReqRankWithAndWithoutBonus(sbReqGiven, sbReqsForBidSchedSortedByScoreWithBonus,</span>
                    sbReqsForBidSchedSortedByScoreWithoutBonus);
<span class="nc" id="L2734">            }</span>
        } finally {
<span class="nc bnc" id="L2736" title="All 8 branches missed.">            if (allocBidSchedDAO &amp;&amp; bidSchedDAO != null) bidSchedDAO.cleanUp();</span>
        }
<span class="nc" id="L2738">    }</span>


    public static void computeRankForBiddableSched(BiddableSchedule bidSched, ID bidderIDToBeRanked,
        BiddableScheduleDAO bidSchedDAO) throws Exception {
<span class="nc" id="L2743">        m_cat.debug(&quot;Computing rank for bidSched, bidderIDToBeRanked: &quot; + bidSched.getID() + ',' +  bidderIDToBeRanked);</span>

<span class="nc" id="L2745">        Map bidSchedIDToBidSchedWithAssocBidReqsCache = new HashMap(10);</span>

        // TODO: future optimization is to first determine if the given bidderIDToBeRanked has any
        // shift bid requests (using a light weight SQL query) towards this biddable schedule and
        // then perform the ranking only if necessary.
<span class="nc" id="L2750">        Pair sortedSBReqsPair = getSortedSBReqsForBiddableSched(bidSched, null, bidderIDToBeRanked,</span>
            true, bidSchedIDToBidSchedWithAssocBidReqsCache, bidSchedDAO);

<span class="nc" id="L2753">        List sbReqsForBidSchedSortedByScoreWithBonus = (List) sortedSBReqsPair.getFirst();</span>
<span class="nc" id="L2754">        List sbReqsForBidSchedSortedByScoreWithoutBonus = (List) sortedSBReqsPair.getSecond();</span>

<span class="nc" id="L2756">        setBidSchedRankWithAndWithoutBonus(bidSched, bidderIDToBeRanked, sbReqsForBidSchedSortedByScoreWithBonus,</span>
            sbReqsForBidSchedSortedByScoreWithoutBonus);
<span class="nc" id="L2758">    }</span>


    /**
     * @param bidSched
     * @param sbReqsForBidSchedSortedByScoreWithBonus
     * @param sbReqsForBidSchedSortedByScoreWithoutBonus
     */
    protected static void setBidSchedRankWithAndWithoutBonus(BiddableSchedule bidSched, ID bidderIDToRank,
        List sbReqsForBidSchedSortedByScoreWithBonus, List sbReqsForBidSchedSortedByScoreWithoutBonus) {

<span class="nc" id="L2769">        int listSize = sbReqsForBidSchedSortedByScoreWithBonus.size();</span>

        // compute and set the rank with bonus
<span class="nc" id="L2772">        int indexWithBonus = RequestUtil.findInVOBaseListByFieldValue(sbReqsForBidSchedSortedByScoreWithBonus,</span>
            ShiftBidRequestFieldInfo.SHIFTBIDREQUEST_I_SHIFTBIDDERID, bidderIDToRank);
<span class="nc" id="L2774">        bidSched.getSetters().setBidRankForShiftBidderWithBonus(</span>
            new Pair(new Integer(indexWithBonus + 1), new Integer(listSize)));
<span class="nc" id="L2776">        m_cat.debug(&quot;Setting rank with bonus for bidSched: ID, rank: &quot; + bidSched.getID() +</span>
            ',' + indexWithBonus + 1 + '/' + listSize);

        // compute and set the rank without bonus.
<span class="nc" id="L2780">        int indexWithoutBonus = RequestUtil.findInVOBaseListByFieldValue(sbReqsForBidSchedSortedByScoreWithoutBonus,</span>
                    ShiftBidRequestFieldInfo.SHIFTBIDREQUEST_I_SHIFTBIDDERID, bidderIDToRank);
<span class="nc" id="L2782">        bidSched.getSetters().setBidRankForShiftBidderWithoutBonus(</span>
            new Pair(new Integer(indexWithoutBonus + 1), new Integer(listSize)));
<span class="nc" id="L2784">        m_cat.debug(&quot;Setting rank without bonus for bidSched: ID, rank: &quot; + bidSched.getID() +</span>
            ',' + indexWithoutBonus + 1 + '/' + listSize);
<span class="nc" id="L2786">    }</span>


    /**
     * Gets sorted list of sb requests for the given biddable schedule, in the context of the given bidder.
     * The sorting is done by scoring the shiftBid requests associated with the biddable schedule,
     * and then ordering the shift bid requests by the score. Also sets the computed bonus, score with
     * bonus and score without bonus values in the shiftBidder VO associated with the shift bid request.
     *
     * @param bidSched
     * @param sbReqNotPersisted if non null, indicates that this SBReq must be added to the list of SBReqs
     * associated with the biddable schedule (and persisted in the DB) and the entire list must be sorted.
     * If null, this parameter is ignored.
     * @param bidderIDToBeRanked
     * @param onlyReqsWithSVS only requests with soft validation states {@link RequestAuditTrail#SOFT_VALIDATION_STATES SOFT_VALIDATION_STATES}
     * @param BSIDToBSWithSBRsCacheMap bidSchedIDToBidSchedWithAssocBidReqsCache
     * @param bidSchedDAO
     * @return A pair: first element is the sorted {@link List List} of SB Requests by 'score with bonus'.  Second is
     * the sorted {@link List List} by 'score without bonus'.
     */
	protected static Pair getSortedSBReqsForBiddableSched(BiddableSchedule bidSched, ShiftBidRequest sbReqNotPersisted, ID
			bidderIDToBeRanked, boolean onlyReqsWithSVS, Map BSIDToBSWithSBRsCacheMap, BiddableScheduleDAO bidSchedDAO) throws Exception {
<span class="nc" id="L2808">		return getSortedSBReqsForBiddableSched(bidSched, sbReqNotPersisted, bidderIDToBeRanked, onlyReqsWithSVS, BSIDToBSWithSBRsCacheMap,</span>
				bidSchedDAO, false);
	}

	protected static Pair getSortedSBReqsForBiddableSched(BiddableSchedule bidSched, ShiftBidRequest sbReqNotPersisted,
        ID bidderIDToBeRanked, boolean onlyReqsWithSVS, Map BSIDToBSWithSBRsCacheMap, BiddableScheduleDAO bidSchedDAO, boolean incExpired) 
        		throws Exception {
        /*
         * for each bidSched
         *    get all shiftBidReqs associated with bidSched.
         *    if (bidder has a ShiftbidReq towards this bidSched)
         *       compute Rank of employee's shiftBidReq.
         *    else
         *       makr bidSched as 'no bids from employee'
         *    end if
         * end for.
         */

<span class="nc" id="L2826">        ID bidSchedID = bidSched.getID();</span>
<span class="nc" id="L2827">        m_cat.debug(&quot;Obtaining sorted SBReqs associated with biddableSchedule: ID = &quot; + bidSchedID);</span>

<span class="nc" id="L2829">        List sbReqsForBidSched = null;</span>
        //TODO: better optimization is to not just cache the biddableScheduleWithAssocShiftBidRequests but
        // to cache the biddableSchedule and the sorted shift bid requests.
<span class="nc" id="L2832">        BiddableSchedule bidSchedWithAssocBidReqs =</span>
<span class="nc" id="L2833">            (BiddableSchedule) BSIDToBSWithSBRsCacheMap.get(bidSchedID);</span>
        // if biddable schedule was not cached
<span class="nc bnc" id="L2835" title="All 2 branches missed.">        if (bidSchedWithAssocBidReqs == null) {</span>
            // biddable schedule not found in cache.
            // So load biddable schedule and all shift bid requests associated with this biddable schedule.
            // (Given shift bid request --&gt; biddable schedule --&gt; set of shift bid requests).
            // The loaded set of shift bid requests will contain the given shift bid request.
<span class="nc" id="L2840">            bidSchedWithAssocBidReqs = bidSched;</span>
<span class="nc bnc" id="L2841" title="All 2 branches missed.">			if ((bidSchedWithAssocBidReqs.getDetailLevel() &amp; BiddableSchedule.DL_BIDRANK_FOR_SHIFTBIDREQUEST) == 0) {</span>
<span class="nc bnc" id="L2842" title="All 2 branches missed.">				long detailLevel = incExpired ? BiddableSchedule.DL_BIDRANK_FOR_SHIFTBIDREQUEST | RequestDetailLevel.DL_INCLUDE_EXPIRED :</span>
						BiddableSchedule.DL_BIDRANK_FOR_SHIFTBIDREQUEST;
<span class="nc" id="L2844">				bidSchedWithAssocBidReqs = bidSchedDAO.getBiddableScheduleByID(bidSchedID, detailLevel);</span>
			}

<span class="nc bnc" id="L2847" title="All 2 branches missed.">            sbReqsForBidSched = (onlyReqsWithSVS)?</span>
<span class="nc" id="L2848">                bidSchedWithAssocBidReqs.getOptMethods().getShiftBidRequestsForBSWithSoftValStates():</span>
<span class="nc" id="L2849">                bidSchedWithAssocBidReqs.getOptMethods().getShiftBidRequestsForBiddableSched();</span>

            // add the not persisted shift bid request to the list (used to compute the rank for
            // a shift bid request being created (and not yet persisted in the DB).
<span class="nc bnc" id="L2853" title="All 2 branches missed.">            if (sbReqNotPersisted != null) {</span>
<span class="nc" id="L2854">                sbReqsForBidSched.add(sbReqNotPersisted);</span>
            }

            // iterate thru' the shift bid requests associated with this biddbale schedule and
            // compute score for each.
<span class="nc" id="L2859">            computeBonusAndScoreForSBReqs(sbReqsForBidSched);</span>

            // cache the result.
<span class="nc" id="L2862">            BSIDToBSWithSBRsCacheMap.put(bidSchedWithAssocBidReqs.getID(), bidSchedWithAssocBidReqs);</span>
        } else { // if bid sched was cached
            // Note: if the bidSched was cached, then the sbReqs associated with the bidSched must also
            // be cached internally within the bidSched.  Reason is that a newly created shift bid request
            // may be added to the list of shift bid requests in the 'if' block above.
<span class="nc bnc" id="L2867" title="All 2 branches missed.">            sbReqsForBidSched = (onlyReqsWithSVS)?</span>
<span class="nc" id="L2868">                bidSchedWithAssocBidReqs.getOptMethods().getShiftBidRequestsForBSWithSoftValStates():</span>
<span class="nc" id="L2869">                bidSchedWithAssocBidReqs.getOptMethods().getShiftBidRequestsForBiddableSched();</span>
        }

        // list to hold shift bid requests sorted by score, using score with bonus
<span class="nc" id="L2873">        List sbReqsForBidSchedSortedByScoreWithBonus = sbReqsForBidSched;</span>

        // duplicate list to hold shiftbid requests sorted by score, using score without bonus
<span class="nc" id="L2876">        List sbReqsForBidSchedSortedByScoreWithoutBonus =</span>
<span class="nc" id="L2877">            RequestUtil.getListFromCollection(sbReqsForBidSchedSortedByScoreWithBonus);</span>

        // sort the shift bid requests by score with and without bonus.
<span class="nc bnc" id="L2880" title="All 2 branches missed.">        if (sbReqsForBidSchedSortedByScoreWithBonus.size() &gt; 1) {</span>
            // sort shift bid request list by score with bonus.
<span class="nc" id="L2882">            Collections.sort(sbReqsForBidSchedSortedByScoreWithBonus,</span>
                new ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScore(bidderIDToBeRanked, true));

            // sort shift bid request list by score without bonus.
<span class="nc" id="L2886">            Collections.sort(sbReqsForBidSchedSortedByScoreWithoutBonus,</span>
                new ShiftBidAuctionUtil.ShiftBidRequestComparatorUsingScore(bidderIDToBeRanked, false));
        }

<span class="nc" id="L2890">        m_cat.debug(&quot;Sorted SBReqs assoc with bidSched: bidSchedID, WithBonusSortedSize, WithoutBonusSortedSize: &quot; +</span>
<span class="nc" id="L2891">            bidSchedID + ',' + sbReqsForBidSchedSortedByScoreWithBonus.size() + ',' +</span>
<span class="nc" id="L2892">            sbReqsForBidSchedSortedByScoreWithoutBonus.size());</span>
<span class="nc" id="L2893">        return new Pair(sbReqsForBidSchedSortedByScoreWithBonus, sbReqsForBidSchedSortedByScoreWithoutBonus);</span>
    }


    /**
     * Computes the 'bonus' (employee's accumulated points + shift Bidder bonus) and
     * score (with and without bonus) for the given set of SBReqs
     *
     * @param sbReqs
     * @throws Exception
     */
    public static void computeBonusAndScoreForSBReqs(Collection sbReqs) throws Exception {
        // cache to hold orgSetting for an organization. orgSetting contains the multiplers used to compute the 'score'.
<span class="nc" id="L2906">        Map orgIDToOrgSettingCacheMap = new HashMap();</span>

<span class="nc" id="L2908">        Map methodDataCacheMap = null;</span>
<span class="nc bnc" id="L2909" title="All 2 branches missed.">        for (Iterator sbReqsIter = sbReqs.iterator(); sbReqsIter.hasNext(); ) {</span>
<span class="nc" id="L2910">            ShiftBidRequest sbReq = (ShiftBidRequest) sbReqsIter.next();</span>

            // instantiate cache if necessary.
<span class="nc bnc" id="L2913" title="All 2 branches missed.">            methodDataCacheMap = (methodDataCacheMap == null)?new HashMap(10):methodDataCacheMap;</span>

<span class="nc" id="L2915">            m_cat.debug(&quot;Computing score and bonus for SBReq: ID = &quot; + sbReq.getID());</span>
<span class="nc" id="L2916">            ShiftBidAuctionUtil.computeBonusAndScoreWithAndWithoutPoints(sbReq, null, null,</span>
                null, (OrganizationSetting) null, orgIDToOrgSettingCacheMap, methodDataCacheMap);
<span class="nc" id="L2918">        }</span>
<span class="nc" id="L2919">    }</span>

    /**
     * see {@link ShiftBidRequest.ShiftBidRequestOptMethods#getRankWithBonus() getRankWithBonus()}.
     *
     * compute the rank of the given request in the shift bid request list.  Set the request's new
     * rank to the lower of the request's current rank and the rank in this shift bid request list.
     *
     * @param sbReqGiven
     * @param sbReqsSortedByScoreWithBonusForBidSched
     * @param sbReqsSortedByScoreWithoutBonusForBidSched
     * @throws RmException
     *
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getBonusComputed()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getBonusToBeAwarded()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getScoreWithoutBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getRankWithBonus()
     * @see ShiftBidRequest.ShiftBidRequestOptMethods#getRankWithoutBonus()
     */
    protected static void setSBReqRankWithAndWithoutBonus(ShiftBidRequest sbReqGiven,
        List sbReqsSortedByScoreWithBonusForBidSched, List sbReqsSortedByScoreWithoutBonusForBidSched) throws RmException {
        // locate this request in the list of shift bid requests sorted by score with bonus
<span class="nc" id="L2942">        ID sbReqID = sbReqGiven.getID();</span>

<span class="nc" id="L2944">        int index = RequestUtil.findInVOBaseListByID(sbReqsSortedByScoreWithBonusForBidSched, sbReqID);</span>
<span class="nc bnc" id="L2945" title="All 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L2946">            throw RequestUtil.createRmException(RmEjbLogBundleKey.SBR_NOT_FOUND_IN_WITHBONUS_LIST,</span>
                sbReqID, new Integer(index), m_cat);
        }

<span class="nc" id="L2950">        int sbrListSize = sbReqsSortedByScoreWithBonusForBidSched.size();</span>
        // requests sorted by score in ascending order.  request's towards the bottom of the list are higher in rank
<span class="nc" id="L2952">        Pair newRankWithBonus = new Pair(new Integer(sbrListSize - index), new Integer(sbrListSize));</span>
<span class="nc" id="L2953">        Pair lowerRank = getLowerOfGivenRanks(sbReqGiven.getOptMethods().getRankWithBonus(), newRankWithBonus);</span>

<span class="nc" id="L2955">        sbReqGiven.getSetters().setRankWithBonus(lowerRank);</span>
<span class="nc" id="L2956">        m_cat.debug(&quot;Setting rank with bonus for shiftBidReq: ID, rank: &quot; + sbReqID + ',' +</span>
<span class="nc" id="L2957">            ((Integer)lowerRank.getFirst()).intValue() + '/' + ((Integer)lowerRank.getSecond()).intValue() );</span>

        // locate this request in the list of shift bid requests sorted by score without bonus
<span class="nc" id="L2960">        index = RequestUtil.findInVOBaseListByID(sbReqsSortedByScoreWithoutBonusForBidSched, sbReqID);</span>
<span class="nc bnc" id="L2961" title="All 2 branches missed.">        if (index &lt; 0) {</span>
<span class="nc" id="L2962">            throw RequestUtil.createRmException(RmEjbLogBundleKey.SBR_NOT_FOUND_IN_WITHOUTBONUS_LIST,</span>
                    sbReqID, new Integer(index), m_cat);
        }

<span class="nc" id="L2966">        sbrListSize = sbReqsSortedByScoreWithoutBonusForBidSched.size();</span>
        // requests sorted by score in ascending order.  request's towards the bottom of the list are higher in rank
<span class="nc" id="L2968">        Pair newRankWithoutBonus = new Pair(new Integer(sbrListSize - index), new Integer(sbrListSize));</span>
<span class="nc" id="L2969">        lowerRank = getLowerOfGivenRanks(sbReqGiven.getOptMethods().getRankWithoutBonus(), newRankWithoutBonus);</span>

<span class="nc" id="L2971">        sbReqGiven.getSetters().setRankWithoutBonus(lowerRank);</span>
<span class="nc" id="L2972">        m_cat.debug(&quot;Setting rank without bonus for shiftBidReq: ID, rank: &quot; + sbReqID + ',' +</span>
<span class="nc" id="L2973">            ((Integer)lowerRank.getFirst()).intValue() + '/' + ((Integer)lowerRank.getSecond()).intValue() );</span>
<span class="nc" id="L2974">    }</span>


    /**
     * gets the lower of the two given ranks.  A rank is lower than the other if its rank fraction is greater
     * than the other's rank fraction.  For instance 7/12 is lower in rank than 1/12.
     */
    protected static Pair getLowerOfGivenRanks(Pair oldRankPair, Pair newRankPair) {
<span class="nc bnc" id="L2982" title="All 2 branches missed.">        if (oldRankPair == null) return newRankPair;</span>

<span class="nc" id="L2984">        float oldRankFrac = ((float)((Integer)oldRankPair.getFirst()).intValue()) / ((Integer)oldRankPair.getSecond()).intValue();</span>
<span class="nc" id="L2985">        float newRankFrac = ((float)((Integer)newRankPair.getFirst()).intValue()) / ((Integer)newRankPair.getSecond()).intValue();</span>

<span class="nc bnc" id="L2987" title="All 2 branches missed.">        return (oldRankFrac &gt; newRankFrac)?oldRankPair:newRankPair;</span>
    }
	public static Collection getSkillAssnsForBidder(ShiftBidRequest sbReq)
	        throws BbmEJBCreateException, BbmFinderException, RemoteException {

<span class="nc" id="L2992">		ShiftBidAuction sbAuction = sbReq.getOptMethods().getShiftBidAuction();</span>
<span class="nc" id="L2993">		SkillManager skillMgr = WfmManagerFactory.getSkillManager();</span>

		// obtain shift bidder's skills
<span class="nc" id="L2996">		Collection skillAssnsForBidder = skillMgr.getSkillAssignments(sbReq.getEmployeeID(),</span>
<span class="nc" id="L2997">		        sbAuction.getStartTime(), sbAuction.getEndTime());</span>
<span class="nc bnc" id="L2998" title="All 2 branches missed.">		skillAssnsForBidder = (skillAssnsForBidder == null) ? Collections.EMPTY_LIST : skillAssnsForBidder;</span>
<span class="nc" id="L2999">		return skillAssnsForBidder;</span>
	}

	public static  List getSkillAssignsForPhanID(ID phantomID, ScheduleAccessManager sam) throws BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L3003">		Phantom phantom = sam.getPhantomByID(phantomID);</span>
		// get employee template id associated with phantom.
<span class="nc" id="L3005">		ID empTemplateID = phantom.getEmployeeTemplateID();</span>
		// get employee template for phantom.
<span class="nc" id="L3007">		EmployeeTemplate empTemplate = sam.getEmployeeTemplateByID(empTemplateID);</span>
		// fetch the skills for the phantom assoc with the bidSchedInst.  These BidSchedInstances may have different
		// phantoms but each phantom has the same skill assignments.
<span class="nc" id="L3010">		List skillAssnsForPhantom = empTemplate.getSkillAssignments();</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">		skillAssnsForPhantom = (skillAssnsForPhantom == null) ? Collections.EMPTY_LIST : skillAssnsForPhantom;</span>

<span class="nc" id="L3013">		return skillAssnsForPhantom;</span>
	}

	public static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrder(ShiftBidAuction auction, ShiftBidder shiftBidder, int bidOrderBasis) {
		try {

<span class="nc bnc" id="L3019" title="All 2 branches missed.">			if (bidOrderBasis == ShiftBidder.RANKBY_ACCUMULATEDBONUS) {</span>
<span class="nc" id="L3020">				return calculateBidApprovalOrderByPoints(auction, shiftBidder);</span>
<span class="nc bnc" id="L3021" title="All 2 branches missed.">			} else if (bidOrderBasis == ShiftBidder.RANKBY_SENIORITY) {</span>
<span class="nc" id="L3022">				return calculateBidApprovalOrderBySeniority(auction, shiftBidder);</span>
<span class="nc bnc" id="L3023" title="All 2 branches missed.">			} else if (bidOrderBasis == ShiftBidder.RANKBY_EMPLOYEERANK) {</span>
<span class="nc" id="L3024">				return calculateBidApprovalOrderByRank(auction, shiftBidder);</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">			} else if (bidOrderBasis == ShiftBidder.RANKBY_SCORE) {</span>
<span class="nc" id="L3026">				return calculateBidApprovalOrderByScore(auction, shiftBidder);</span>
<span class="nc bnc" id="L3027" title="All 2 branches missed.">			} else if (bidOrderBasis == ShiftBidder.RANKBY_SHIFTBIDDER_BONUS) {</span>
<span class="nc" id="L3028">				return calculateBidApprovalOrderByBonus(auction, shiftBidder);</span>
			}

<span class="nc" id="L3031">		} catch (Exception e) {</span>
<span class="nc" id="L3032">			RmUtil.logException(e);</span>
<span class="nc" id="L3033">			throw RmRuntimeException.toRuntimeException(e);</span>
<span class="nc" id="L3034">		}</span>

<span class="nc" id="L3036">		throw new IllegalArgumentException(&quot;Unknown bid order basis.&quot;);</span>

	}

	private static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrderByPoints(ShiftBidAuction auction, ShiftBidder shiftBidder) throws Exception{

<span class="nc" id="L3042">		ShiftBidAuctionManager auctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L3044">		Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; bidders = auctionMgr.getShiftBiddersForAuction(auction.getID(), null, false, ShiftBidder.SORTBY_POINTS,</span>
				SupportNavigation.SORT_DESCENDING, Integer.MAX_VALUE, null, ShiftBidder.DL_BASIC
						| ShiftBidder.DL_EMPLOYEE, true);
<span class="nc" id="L3047">		return getRankingOrderPair(shiftBidder,  bidders.getFirst());</span>

	}


	private static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrderByBonus(ShiftBidAuction auction, ShiftBidder shiftBidder) throws Exception {

<span class="nc" id="L3054">		ShiftBidAuctionManager auctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L3056">		Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; bidders = auctionMgr.getShiftBiddersForAuction(auction.getID(), null, false, ShiftBidder.SORTBY_BONUS,</span>
				SupportNavigation.SORT_DESCENDING, Integer.MAX_VALUE, null, ShiftBidder.DL_BASIC
						| ShiftBidder.DL_EMPLOYEE, true);

<span class="nc" id="L3060">		return getRankingOrderPair(shiftBidder, bidders.getFirst());</span>

	}

	private static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrderByScore(ShiftBidAuction auction, ShiftBidder shiftBidder) throws Exception {

<span class="nc" id="L3066">		ShiftBidAuctionManager auctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L3068">		Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; bidders = auctionMgr.getShiftBiddersForAuction(auction.getID(), null, false, ShiftBidder.SORTBY_SCORE,</span>
				SupportNavigation.SORT_DESCENDING, Integer.MAX_VALUE, null,
				ShiftBidder.DL_BASIC | ShiftBidder.DL_EMPLOYEE | ShiftBidder.DL_SHIFTBIDDER_SCORE, true);

<span class="nc" id="L3072">		return getRankingOrderPair(shiftBidder,  bidders.getFirst());</span>

	}

	private static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrderByRank(ShiftBidAuction auction, ShiftBidder shiftBidder) throws Exception {

<span class="nc" id="L3078">		ShiftBidAuctionManager auctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L3080">		Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; bidders = auctionMgr.getShiftBiddersForAuction(auction.getID(), null, false, ShiftBidder.SORTBY_RANK,</span>
				SupportNavigation.SORT_ASCENDING, Integer.MAX_VALUE, null, ShiftBidder.DL_BASIC
						| ShiftBidder.DL_EMPLOYEE, true);

<span class="nc" id="L3084">		return getRankingOrderPair(shiftBidder, bidders.getFirst());</span>
	}

	static Pair&lt;Integer, Integer&gt; calculateBidApprovalOrderBySeniority(ShiftBidAuction auction, ShiftBidder shiftBidder) throws Exception {

<span class="nc" id="L3089">		ShiftBidAuctionManager auctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>

<span class="nc" id="L3091">		Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; bidders = auctionMgr.getShiftBiddersForAuction(auction.getID(), null, false, ShiftBidder.SORTBY_SENIORITY,</span>
				SupportNavigation.SORT_ASCENDING, Integer.MAX_VALUE, null, ShiftBidder.DL_BASIC
						| ShiftBidder.DL_EMPLOYEE, true);

<span class="nc" id="L3095">		return getRankingOrderPair(shiftBidder, bidders.getFirst());</span>
	}

	private static Pair&lt;Integer, Integer&gt; getRankingOrderPair(ShiftBidder shiftBidder, List&lt;ID&gt; bidderIDs) {

<span class="nc bnc" id="L3100" title="All 4 branches missed.">		if(bidderIDs == null || bidderIDs.isEmpty()){</span>
			// shouldn't happen!
<span class="nc" id="L3102">			return null;</span>
		}

<span class="nc" id="L3105">		int ranking = bidderIDs.indexOf(shiftBidder.getID()) + 1;</span>
<span class="nc bnc" id="L3106" title="All 2 branches missed.">		if (ranking &lt;= 0) {</span>
<span class="nc" id="L3107">			return null;</span>
		}

<span class="nc" id="L3110">		int size = bidderIDs.size();</span>
<span class="nc" id="L3111">		Pair&lt;Integer, Integer&gt; pair = new Pair(ranking, size);</span>

<span class="nc" id="L3113">		System.out.println(&quot;getRankingOrderPair Result-- &quot; + pair.getFirst() + &quot; : &quot; + pair.getSecond());</span>
<span class="nc" id="L3114">		return pair;</span>
	}

	/**
     * Usually all the scheduled employees with SP are marked as scheduled/unavailable
     * With the new setting to allow previously scheduled employees, we need to
     * verify that setting is checked or not and filter employees based on this setting
     */
	public static Collection&lt;ID&gt; getUnavailableEmpIdsForAuction (Collection empIDs, ShiftBidAuction auction,
			ShiftBidderDAO bidderDAO) throws Exception {
		Collection&lt;ID&gt; unavailableEmpIDs;
<span class="nc bnc" id="L3125" title="All 2 branches missed.">		if (!auction.getIncPrevSchedEmp()) {</span>
			// unavailable employees are employees who have shifts for the SP this auction is for.
<span class="nc" id="L3127">			unavailableEmpIDs = bidderDAO.getNumOfShiftsDuringAuctionForEmps(empIDs, auction.getStartTime(),</span>
<span class="nc" id="L3128">				auction.getEndTime()).keySet();</span>
		} else {
			// unavailable employees are employees who have at least one approved shift bidding request in this auction
<span class="nc" id="L3131">			unavailableEmpIDs = bidderDAO.getEmployeeIDsByAuctionAndRequestStatus(</span>
<span class="nc" id="L3132">					Collections.singleton(auction.getID()), new String[] {RequestAuditTrail.STATUS_APPROVED});</span>
		}
<span class="nc" id="L3134">		return unavailableEmpIDs;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>