<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DAOUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">DAOUtil.java</span></div><h1>DAOUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Aug 7, 2003
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.util;

import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;

/**
 * @author RRajendran
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
<span class="nc" id="L36">public class DAOUtil {</span>
<span class="fc" id="L37">    private static final Category m_cat = Log.initCategory(DAOUtil.class.getName());</span>

<span class="fc" id="L39">    private static final ColumnMetaData[] m_firstColAsIDColMDArr = new ColumnMetaData[]</span>
        { new ColumnMetaData(ColumnMetaData.COLUMNTYPE_ID, 1)};

<span class="nc" id="L42">    public static class ColumnMetaData</span>
    {
		public static final int COLUMNTYPE_ID = 1;
		public static final int COLUMNTYPE_STRING = 2;
		public static final int COLUMNTYPE_DATE = 3;
		public static final int COLUMNTYPE_INTEGER = 4;

<span class="fc" id="L49">        private static final ColumnMetaData m_colMetaDataForDate = new ColumnMetaData(COLUMNTYPE_DATE, -1);</span>
<span class="fc" id="L50">        private static final ColumnMetaData m_colMetaDataForString = new ColumnMetaData(COLUMNTYPE_STRING, -1);</span>
<span class="fc" id="L51">        private static final ColumnMetaData m_colMetaDataForInteger = new ColumnMetaData(COLUMNTYPE_INTEGER, -1);</span>
<span class="fc" id="L52">        private static final ColumnMetaData m_colMetaDataForID = new ColumnMetaData(COLUMNTYPE_ID, -1);</span>

        private final int m_colType;
        private final int m_colIndex;

		/**
		 * column index starts from 1 and not 0.
		 *
		 * @param colType
		 * @param colIndex
		 */
<span class="fc" id="L63">		public ColumnMetaData(int colType, int colIndex) {</span>
<span class="fc" id="L64">			m_colType = colType;</span>
<span class="fc" id="L65">			m_colIndex = colIndex;</span>
<span class="fc" id="L66">		}</span>

        /**
         * @return
         */
        public static ColumnMetaData getColMetaDataForDate() {
<span class="fc" id="L72">            return m_colMetaDataForDate;</span>
        }

        /**
         * @return
         */
        public static ColumnMetaData getColMetaDataForID() {
<span class="nc" id="L79">            return m_colMetaDataForID;</span>
        }

        /**
         * @return
         */
        public static ColumnMetaData getColMetaDataForInteger() {
<span class="nc" id="L86">            return m_colMetaDataForInteger;</span>
        }

        /**
         * @return
         */
        public static ColumnMetaData getColMetaDataForString() {
<span class="nc" id="L93">            return m_colMetaDataForString;</span>
        }



        /**
         * index starts from 1 and not 0.
         *
         * @return
         */
        public int getColIndex() {
<span class="fc" id="L104">            return m_colIndex;</span>
        }

        /**
         * @return
         */
        public int getColType() {
<span class="fc" id="L111">            return m_colType;</span>
        }

        public boolean isID() {
<span class="fc bfc" id="L115" title="All 2 branches covered.">            return m_colType == COLUMNTYPE_ID;</span>
        }

        public boolean isString() {
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">            return m_colType == COLUMNTYPE_STRING;</span>
        }

        public boolean isDate() {
<span class="nc bnc" id="L123" title="All 2 branches missed.">            return m_colType == COLUMNTYPE_DATE;</span>
        }

        public boolean isInteger() {
<span class="nc bnc" id="L127" title="All 2 branches missed.">            return m_colType == COLUMNTYPE_INTEGER;</span>
        }
    }


    /**
     * Append the given subClauseToAppend to the the passed whereClause.  The sub clause is
     * appended with either 'AND' or 'WHERE' baased on the the whereClauseAppended flag.
     *
     * @param whereClause
     * @param subClauseToAppend
     * @param whereClauseAdded
     * @return
     */
    public static boolean appendToWhereClause(StringBuffer whereClause, String subClauseToAppend, boolean whereClauseAdded) {
        // add join for where clause
<span class="fc bfc" id="L143" title="All 2 branches covered.">        whereClause = whereClauseAdded?whereClause.append(&quot; AND &quot;):whereClause.append(&quot; WHERE &quot;);</span>
<span class="fc" id="L144">        whereClause.append(subClauseToAppend);</span>

<span class="fc" id="L146">        return true;</span>
    }

    /**
     * Returns a list with the values of the first column for the given query.  The first column
     * must be an ID column.
     *
     * @param dmo
     * @param strQuery
     * @return
     * @throws BbmFinderException
     */
    public static List getIDsUsingSQLQuery(Jdmo dmo, String strQuery)
        throws Exception
    {
<span class="fc" id="L161">        return getFromSQLQueryCols(dmo, strQuery, m_firstColAsIDColMDArr)[0];</span>
    }

    /**
     * Executes given parameterized query using the query arguments and query argument types.
     *  
     * @param dmo
     * @param strQuery
     * @param queryParms
     * @param colMetaData
     * @return
     * @throws JdmoException
     */
	public static List&lt;ID&gt; getIDsUsingSQLQuery(Jdmo dmo, String strQuery, Object[] queryParms,
        ColumnMetaData[] colMetaData) throws JdmoException {
        
<span class="fc" id="L177">        JdmoQuery jQuery = dmo.createQuery(strQuery, Jdmo.PARAM_QUERY);</span>
        
<span class="fc bfc" id="L179" title="All 2 branches covered.">        for (int i = 0; i &lt; colMetaData.length; i++) {</span>
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            if (colMetaData[i].getColType() == ColumnMetaData.COLUMNTYPE_DATE) {                </span>
<span class="fc" id="L181">                Date date = (Date) queryParms[i];</span>
<span class="fc" id="L182">                jQuery.setParTimestamp(i+1, new Timestamp(date.getTime()));</span>
<span class="pc bnc" id="L183" title="All 2 branches missed.">            } else if (colMetaData[i].getColType() == ColumnMetaData.COLUMNTYPE_ID) {</span>
<span class="nc" id="L184">                ID id = (ID) queryParms[i];</span>
<span class="nc" id="L185">                jQuery.setParID(i+1, id);</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">            } else if (colMetaData[i].getColType() == ColumnMetaData.COLUMNTYPE_INTEGER) {</span>
<span class="nc" id="L187">                Integer integer = (Integer) queryParms[i];</span>
<span class="nc" id="L188">                jQuery.setParInt(i+1, integer.intValue());</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">            } else if (colMetaData[i].getColType() == ColumnMetaData.COLUMNTYPE_STRING) {</span>
<span class="nc" id="L190">                String str = (String) queryParms[i];</span>
<span class="nc" id="L191">                jQuery.setParString(i+1, str);</span>
<span class="nc" id="L192">            } else {</span>
<span class="nc" id="L193">				throw new IllegalArgumentException(&quot;&quot; + Integer.toString(i) + ',' + colMetaData[i].getColType());</span>
            }
        }

<span class="fc" id="L197">        JdmoRowset rs = dmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
        
<span class="fc" id="L199">		List&lt;ID&gt; ids = null;</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        while (rs.next()) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">			ids = (ids == null) ? new ArrayList&lt;ID&gt;(32) : ids;</span>
            
<span class="nc" id="L203">            ids.add(rs.getID(1));</span>
        }
        
<span class="pc bpc" id="L206" title="1 of 2 branches missed.">		if (ids == null) {</span>
<span class="fc" id="L207">			return Collections.emptyList();</span>
		}
<span class="nc" id="L209">		return ids;</span>
    }
            

    /**
     * Executes the given SQL query and selectively returns the specified columns in the returned
     * rowset.
     *
     * The columns specified are returned as an array of {@link List Lists}.
     * Each List in the array represents the values for a column.  The argument
     * 'colMetaDataArr' specifies which columns from the resultSet are to be returned.
     *
     * Note: *** column index, specified by {@link ColumnMetaData ColumnMetaData} array,
     * starts from 1 and not 0.
     *
     * @param dmo
     * @param strQuery
     * @param colMetaDataArr
     * @return
     * @throws BbmFinderException
     */
    public static List[] getFromSQLQueryCols(Jdmo dmo, String strQuery, ColumnMetaData[] colMetaDataArr)
        throws Exception
    {
<span class="fc" id="L233">        List listArr[] = new List[colMetaDataArr.length];</span>

<span class="fc bfc" id="L235" title="All 2 branches covered.">        for (int i=0; i &lt; colMetaDataArr.length; i++) {</span>
<span class="fc" id="L236">            listArr[i] = new ArrayList();</span>
        }

//        try {
<span class="fc" id="L240">            JdmoRowset rs = dmo.createRowset(strQuery);</span>

<span class="fc" id="L242">            Object o = null;</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">            while (rs.next()) {</span>
<span class="fc bfc" id="L244" title="All 2 branches covered.">                for (int i=0; i &lt; colMetaDataArr.length; i++) {</span>
<span class="fc" id="L245">                    o = getObjectFromRS(rs, colMetaDataArr[i]);</span>

<span class="fc" id="L247">                    listArr[i].add(o);</span>
                }
            }

<span class="fc" id="L251">            rs.close();</span>
//        } c_atch (Exception e) {
//            t_hrow RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);
//        }

<span class="fc" id="L256">        return listArr;</span>
    }

    /**
     * Use this if only a single value from a a query that returns a single row is needed.  Avoids the overhead of
     * Lists and arrays of lists incurred in getFromQueryCols() method.
     *
     * Note: *** column index starts from 1 and not 0.
     *
     * @param dmo
     * @param strQuery
     * @return
     * @throws BbmFinderException
     */
    public static Object getFromSQLQuerySingleValue(Jdmo dmo, String strQuery, ColumnMetaData colMetaData)
        throws Exception {
<span class="nc" id="L272">            JdmoRowset rs = dmo.createRowset(strQuery);</span>

<span class="nc" id="L274">            Object o = null;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">            if (rs.next()) {</span>
<span class="nc" id="L276">                o = getObjectFromRS(rs, colMetaData);</span>
            }
<span class="nc" id="L278">            rs.close();</span>

<span class="nc" id="L280">            return o;</span>

    }

    /**
     * Builds and returns a map using the given SQL query.
     * Executes the given sql query, constructs and returns a Map with keys and values specified by the
     * 'colMetaDataArr' method argument.
     *
     * Note: *** column index, specified by {@link ColumnMetaData ColumnMetaData} array,
     * starts from 1 and not 0.
     *
     * @param dmo
     * @param strQuery
     * @param colMetaDataArr
     * @param capacityHint
     * @return
     * @throws BbmFinderException
     */
    public static Map getFromSQLQueryColMap(Jdmo dmo, String strQuery, ColumnMetaData[] colMetaDataArr,
        int capacityHint) throws Exception
    {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">        if (colMetaDataArr.length != 2 )</span>
<span class="nc" id="L303">            throw new IllegalArgumentException(&quot;colMetaDataArr.length != 2; actual = &quot; + colMetaDataArr.length);</span>

<span class="pc bpc" id="L305" title="1 of 2 branches missed.">        capacityHint = (capacityHint &gt; 0)?capacityHint:20;</span>
<span class="fc" id="L306">        Map hashMap = new HashMap(capacityHint);</span>
<span class="fc" id="L307">            JdmoRowset rs = dmo.createRowset(strQuery);</span>

<span class="fc bfc" id="L309" title="All 2 branches covered.">            while (rs.next()) {</span>
<span class="fc" id="L310">                hashMap.put(getObjectFromRS(rs, colMetaDataArr[0]), getObjectFromRS(rs, colMetaDataArr[1]));</span>
            }
<span class="fc" id="L312">            rs.close();</span>

<span class="fc" id="L314">        return hashMap;</span>
    }

    /**
     * Retrieves the column from the record set described by the argument colMD (the column metadata)
     *
     * Note: *** column index, specified by {@link ColumnMetaData ColumnMetaData} array,
     * starts from 1 and not 0.
     *
     * @param rs
     * @param colMD
     * @return
     * @throws JdmoException
     */
    protected static Object getObjectFromRS(JdmoRowset rs, ColumnMetaData colMD)
        throws JdmoException
    {
<span class="fc" id="L331">        Object o = null;</span>
<span class="fc bfc" id="L332" title="All 2 branches covered.">        if ( colMD.isID() )</span>
<span class="fc" id="L333">            o = rs.getID( colMD.getColIndex() );</span>
<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        else if ( colMD.isString() )</span>
<span class="fc" id="L335">            o = rs.getString( colMD.getColIndex());</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">        else if ( colMD.isDate() )</span>
<span class="nc" id="L337">            o = rs.getTimestamp( colMD.getColIndex());</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">        else if ( colMD.isInteger() )</span>
<span class="nc" id="L339">            o = new Integer(rs.getInt( colMD.getColIndex()));</span>
        else
<span class="nc" id="L341">            throw new IllegalArgumentException(&quot;colMD.getColType() = &quot; + colMD.getColType() +</span>
<span class="nc" id="L342">                &quot;; colMD.getColIndex() = &quot; + colMD.getColIndex());</span>

<span class="fc" id="L344">        return o;</span>
    }

    /**
     * Returns an in clause formatted from the given string array.  This includes the
     * the '( )' enclosing paranthesis as well.
     *
     * @param statusArr
     * @param dmo
     * @return
     */
    public static String createInClause(String[] statusArr) {
<span class="pc bpc" id="L356" title="1 of 2 branches missed.">        if ( statusArr.length == 0 ) return &quot;&quot;;</span>

<span class="fc" id="L358">        StringBuffer inClause = new StringBuffer(statusArr.length * 16);</span>
<span class="fc" id="L359">        inClause.append('(');</span>
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (int i = 0; i &lt; statusArr.length; i++) {</span>
<span class="fc" id="L361">            inClause.append('\'').append(JdmoUtil.formatDBString(statusArr[i])).append(&quot;',&quot;);</span>
        }

        //Note: Normally StrBuf.setLength() should never be called as it has inefficient memory
        // allocation logic.  if StrBuf.toString() is called, then the new string object created
        // and the strBuf object both point to the same shared char array.  Later if StrBuf.setLength(0)
        // is called, StrBuf allocates another char array of the same size as the currently shared
        // array and sets its contents to '\0'.  so for instance, if the orignal strBuf had a 5000 element
        // char array, calling setLength(0) allocates another 5000 element char array and sets each element
        // to '\0'.
        //
        // Calling strBuf.setLength() here is safe since strBuf.toString() was not called earlier.
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (inClause.length() &gt; 1) // condition ' &gt; 1', instead of ' &gt; 0' used due to the '(' as the first char of string buffer.</span>
<span class="fc" id="L374">            inClause.setLength(inClause.length() - 1); //trim the last ','</span>

<span class="fc" id="L376">        inClause.append(')');</span>

<span class="fc" id="L378">        return inClause.toString();</span>
    }
    
    public static String getSortDirection(int sortDirection) {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">        return (sortDirection == SupportNavigation.SORT_DESCENDING)?&quot; DESC &quot;:&quot; ASC &quot;;</span>
    }
    
	/**
	 * 
	 * @param tempTableName The temp table name to be created. 
	 * This need not include the # char (this function will append the # char the specified table name)
	 * @param fieldDefinitions The field definitions for the table name. 
	 * For example &quot;employeeId int, asOfDate datetime&quot; will create a temp table with two columns
	 * 
	 */
	public static void createTempTable(Jdmo dmo, String tempTableName, String fieldDefinitions) throws JdmoException {

<span class="fc" id="L395">		String adjustedTempName = tempTableName.trim().replace(&quot;#&quot;, &quot;&quot;);</span>

		//@formatter:off
<span class="fc" id="L398">		String sql = String.format(&quot;if Object_ID('tempdb..#%s') is Not Null \n begin \n Drop Table #%s \n end \n Create table #%s (%s) &quot;,  // NOSONAR</span>
				adjustedTempName, 
				adjustedTempName, 
				adjustedTempName, 
				fieldDefinitions);
		//@formatter:on
<span class="fc" id="L404">		dmo.execute(sql);</span>
<span class="fc" id="L405">	}</span>
	
	/**
	 * format a list of strings as used by SQL in clause
	 * e.g. given a list of strings s1, s2, s3, ...
	 *      return a string ('s1', 's2', 's3'...)
	 */
	public static String formatStringList(Collection colNames)
	{
<span class="fc" id="L414">		StringBuilder strResult = new StringBuilder();</span>
<span class="fc" id="L415">		strResult.append(&quot;(&quot;);</span>
<span class="fc" id="L416">		Iterator it = colNames.iterator();</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">		while (it.hasNext()) {</span>
<span class="fc" id="L418">			strResult.append(&quot;'&quot;).append(JdmoUtil.formatDBString((String) it.next())).append(&quot;'&quot;);</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">			if (it.hasNext())</span>
<span class="fc" id="L420">				strResult.append(&quot;,&quot;);</span>
		}
		
<span class="fc" id="L423">		strResult.append(&quot;)&quot;);</span>
		
<span class="fc" id="L425">		return new String(strResult);</span>
	}

	public static int getNextKey(Jdmo dmo, String tableName, int numKeysToReserve) throws JdmoException {
<span class="nc" id="L429">		JdmoQuery query = dmo.createQuery(&quot;BP_NEXTKEY&quot;, Jdmo.STORPROC_QUERY_NORS);</span>
<span class="nc" id="L430">		query.setParString(1, tableName);</span>
<span class="nc" id="L431">		query.regParInt(2);</span>
<span class="nc" id="L432">		query.setParInt(3, numKeysToReserve);</span>
<span class="nc" id="L433">		dmo.execute(query);</span>
<span class="nc" id="L434">		return query.getParInt(2);</span>
	}

    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>