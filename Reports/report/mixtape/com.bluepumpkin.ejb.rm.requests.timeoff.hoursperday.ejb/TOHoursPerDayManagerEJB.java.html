<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOHoursPerDayManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb</a> &gt; <span class="el_source">TOHoursPerDayManagerEJB.java</span></div><h1>TOHoursPerDayManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.rmi.RemoteException;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDPair;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.holiday.ejb.HolidayManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculator;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculatorHelper;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffDefaultFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignmentFieldInfo;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDayFieldInfo;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.TimeOffIntervalAllocationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TimeOffActivitySummary;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;


<span class="fc" id="L70">public class TOHoursPerDayManagerEJB extends SessionEJBBase {    </span>
<span class="fc" id="L71">	private static final String CLASSNAME = TOHoursPerDayManagerEJB.class.getName();</span>
<span class="fc" id="L72">	private static final Category LOG = Log.initCategory(TOHoursPerDayManagerEJB.CLASSNAME);</span>
	private static final long ONEDAYINMILLISECS = 24 * 60 * 60 * 1000;
<span class="fc" id="L74">	private static Byte lock = new Byte(&quot;1&quot;);</span>

	private static final int DEFAULT_NOTIFY_MSG_TYPE = TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE;
	
	// non-static initializer
	{
<span class="fc" id="L80">		super.init(TOHoursPerDayManagerEJB.class.getName());</span>
	}

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L88">		return LOG;</span>
	}

	public Collection getTOHoursPerDaysByTimeOffRequestIds(Collection toReqCol) throws BbmFinderException {
<span class="fc" id="L92">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="pc bpc" id="L94" title="1 of 4 branches missed.">			if (toReqCol == null || toReqCol.isEmpty()) {</span>
<span class="fc" id="L95">				return toReqCol;</span>
			}
<span class="fc" id="L97">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L98">			HashMap toChoiceMap = new HashMap();</span>
<span class="fc" id="L99">			HashMap toChoiceReqIdsMap = new HashMap();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">			for (Iterator iterator = toReqCol.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L101">				TORequest tor = (TORequest) iterator.next();</span>
<span class="fc bfc" id="L102" title="All 2 branches covered.">				for (Iterator iter1 = tor.getRequestChoiceList().iterator(); iter1.hasNext();) {</span>
<span class="fc" id="L103">					TOChoice toChoice = (TOChoice) iter1.next();</span>
<span class="fc" id="L104">					toChoiceMap.put(toChoice.getID(), toChoice);</span>
<span class="fc" id="L105">					toChoiceReqIdsMap.put(toChoice.getID(), tor);</span>
<span class="fc" id="L106">				}</span>
<span class="fc" id="L107">			}</span>
<span class="fc" id="L108">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(toChoiceMap.keySet(), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFCHOICEID, null);</span>
<span class="pc bpc" id="L109" title="2 of 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L111">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="fc" id="L112">					TOChoice toChoice = (TOChoice) toChoiceMap.get(hoursPerDay.getTOChoiceID());</span>
<span class="fc" id="L113">					TORequest tor = (TORequest) toChoiceReqIdsMap.get(toChoice.getID());</span>
<span class="fc" id="L114">					toChoice.setHoursPerDay(hoursPerDay);</span>
<span class="pc bpc" id="L115" title="2 of 4 branches missed.">					if (!hoursPerDay.getIsDirty() &amp;&amp; hoursPerDay.getStatus().equals(tor.getRequestStatus())) {</span>
<span class="fc" id="L116">						toChoiceMap.remove(hoursPerDay.getTOChoiceID());</span>
					}
<span class="fc" id="L118">				}</span>
			}
<span class="pc bpc" id="L120" title="2 of 4 branches missed.">			if (toChoiceMap != null &amp;&amp; !toChoiceMap.isEmpty()) {</span>
<span class="nc" id="L121">				Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				for (Iterator iter1 = toChoiceMap.values().iterator(); iter1.hasNext();) {</span>
<span class="nc" id="L123">					TOChoice choice = (TOChoice) iter1.next();</span>
<span class="nc" id="L124">					TORequest tor = (TORequest) toChoiceReqIdsMap.get(choice.getID());</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">					if (tor.getTimeOffDebitType().equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
<span class="nc" id="L126">						choice.setHoursPerDay(new TOHoursPerDay());</span>
<span class="nc" id="L127">						LOG.info(&quot;Ignoring TO Request since it is of TYPE DONT-DEBIT:&quot; + tor);</span>
<span class="nc" id="L128">						continue;</span>
					}
<span class="nc" id="L130">					toHoursPerDayToUpdate.add(TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, choice, tor.getEmployeeID()));</span>
<span class="nc" id="L131">				}</span>
<span class="nc" id="L132">				refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, false);</span>
			}
<span class="nc" id="L134">		} catch (Exception e) {</span>
<span class="nc" id="L135">			handleException(e);</span>
<span class="nc" id="L136">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L138" title="4 of 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L139">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L142">		return toReqCol;</span>
	}

	public TOHoursPerDay getTOHoursPerDaysForTOEvent(ID empID, TimeOffEvent timeoffEvt) throws BbmFinderException {
<span class="nc" id="L146">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L147">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="nc" id="L149">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L150">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(Collections.singleton(timeoffEvt.getID()), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFEVENTID, null);</span>
<span class="nc bnc" id="L151" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L153">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">					if (!hoursPerDay.getIsDirty()) {</span>
<span class="nc" id="L155">						return hoursPerDay;</span>
					}
				}
			}
<span class="nc" id="L159">			hoursPerDay = TOHoursPerDayUtil.convertTOEventToHoursPerDay(hoursPerDay, timeoffEvt, empID);</span>
<span class="nc" id="L160">			ArrayList list = new ArrayList();</span>
<span class="nc" id="L161">			list.add(hoursPerDay);</span>
<span class="nc" id="L162">			refreshAndUpdateTOHoursPerDay(list, true);</span>
<span class="nc" id="L163">		} catch (Exception e) {</span>
<span class="nc" id="L164">			handleException(e);</span>
<span class="nc" id="L165">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L167" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L168">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L171">		return hoursPerDay;</span>
	}

	public void updateHoursPerDay(ScheduleChangeDetails changeDetails) throws BbmUpdateException {
<span class="fc" id="L175">		updateHoursPerDay(changeDetails, DEFAULT_NOTIFY_MSG_TYPE);</span>
<span class="fc" id="L176">	}</span>
	
	//Called on pulish &amp; unpublish
	@SuppressWarnings(&quot;rawtypes&quot;)
	private void updateHoursPerDay(ScheduleChangeDetails changeDetails, int msgType) throws BbmUpdateException {
<span class="fc" id="L181">		Iterator itWrk = changeDetails.getWorkResourceIDs().iterator();</span>
<span class="fc" id="L182">		Iterator itOldEvents = changeDetails.getOldEvents().iterator();</span>
<span class="fc" id="L183">		Iterator itNewEvents = changeDetails.getNewEvents().iterator();</span>
<span class="fc" id="L184">		HashSet setIDs = new HashSet();</span>
<span class="fc" id="L185">		HashSet newTOEventIDs = new HashSet();</span>
<span class="fc" id="L186">		Date startDate = changeDetails.getStartDate();</span>
<span class="fc" id="L187">		Date endDate = changeDetails.getEndDate();</span>
<span class="fc" id="L188">		HashSet toEventEmpPairsToDel = new HashSet();</span>
<span class="fc" id="L189">		HashMap newOrUpdatedTOEventsMap = new HashMap();</span>
<span class="pc bpc" id="L190" title="1 of 6 branches missed.">		while (itWrk.hasNext() &amp;&amp; itOldEvents.hasNext() &amp;&amp; itNewEvents.hasNext()) {</span>
<span class="fc" id="L191">			ID workResourceID = (ID) itWrk.next();</span>
<span class="fc" id="L192">			setIDs.add(workResourceID);</span>
<span class="fc" id="L193">			Collection listOldEvents = (Collection) itOldEvents.next();</span>
<span class="fc" id="L194">			Collection listNewEvents = (Collection) itNewEvents.next();</span>
<span class="fc bfc" id="L195" title="All 2 branches covered.">			if (listOldEvents != null) {</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">				for (Iterator iterator = listOldEvents.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L197">					Event event = (Event) iterator.next();</span>
<span class="pc bpc" id="L198" title="1 of 2 branches missed."> 					if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc" id="L199">						toEventEmpPairsToDel.add(new IDPair(event.getID(), workResourceID));</span>
					}
<span class="fc" id="L201">				}</span>
			}
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">			if (listNewEvents != null) {</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">				for (Iterator iterator = listNewEvents.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L205">					Event event = (Event) iterator.next();</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">					if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="fc" id="L207">						IDPair empTOEventPair = new IDPair(event.getID(), workResourceID);</span>
<span class="pc bpc" id="L208" title="1 of 2 branches missed.">						if (!toEventEmpPairsToDel.remove(empTOEventPair)) {</span>
							// If the empTOEventPair does not exist in  toEventEmpPairsToDel set then its a new event
<span class="fc" id="L210">							newTOEventIDs.add(empTOEventPair.getFirst());</span>
						}
<span class="fc" id="L212">						newOrUpdatedTOEventsMap.put(empTOEventPair, TOHoursPerDayUtil.convertTOEventToHoursPerDay(null, (TimeOffEvent) event, workResourceID));</span>
					}
<span class="fc" id="L214">				}</span>
			}
<span class="fc" id="L216">		}</span>
<span class="fc" id="L217">		updateTOEventsForEmployees(msgType, changeDetails.isPublish(), changeDetails.getWorkResourceIDs(), startDate, endDate, toEventEmpPairsToDel, newOrUpdatedTOEventsMap, newTOEventIDs);</span>
<span class="fc" id="L218">	}</span>


	public void updateTOEventsForEmployees(boolean isPublish, Collection empIDs, Date startDate, Date endDate, Collection toEventEmpPairsToDel, HashMap newTOEvents, HashSet newTOEventIDs) throws BbmUpdateException {
<span class="nc" id="L222">		 updateTOEventsForEmployees(DEFAULT_NOTIFY_MSG_TYPE, isPublish, empIDs, startDate, endDate, toEventEmpPairsToDel, newTOEvents, newTOEventIDs);</span>
<span class="nc" id="L223">	}</span>

	@SuppressWarnings(&quot;unchecked&quot;)
	private void updateTOEventsForEmployees(int msgType, boolean isPublish, Collection&lt;ID&gt; empIDs, Date startDate, Date endDate, Collection toEventEmpPairsToDel, HashMap newTOEvents, HashSet newTOEventIDs) throws BbmUpdateException {
<span class="fc" id="L227">		TOHoursPerDayDAO dao = null;</span>
<span class="fc" id="L228">		boolean isLastPubDateChanged = false;</span>
		try {
<span class="fc" id="L230">			dao = new TOHoursPerDayDAO();</span>
			//isLastPubDateChanged checks shifts against EMPLOYEELASTPUBDATE, which records (seemingly)
			//the last shift published for the employee by date
<span class="fc" id="L233">			isLastPubDateChanged = dao.isLastPublishedDateChanged(empIDs);</span>
			// this call returns true if the published / unpublished schedule causes changes in last published date of the workresource
<span class="pc bpc" id="L235" title="1 of 4 branches missed.">			if (newTOEventIDs == null || newTOEventIDs.isEmpty()) {</span>
<span class="fc" id="L236">				LOG.info(&quot;New TOEventIDs Collection is null or empty&quot;);</span>
			}
<span class="pc bpc" id="L238" title="2 of 6 branches missed.">			if (newTOEventIDs != null &amp;&amp; !newTOEventIDs.isEmpty() &amp;&amp; !dao.checkIfNewTOEventsAreCommited(newTOEventIDs)) {</span>
<span class="nc" id="L239">				LOG.info(&quot;Received Notification for New TOEvents but following IDs do not exist in Database:&quot; + newTOEventIDs + &quot;; Most probably the transaction has been rolled back&quot;);</span>
<span class="nc" id="L240">				return;</span>
			}
<span class="fc" id="L242">			List&lt;TOHoursPerDay&gt; hrsPerColToUpdate = new ArrayList&lt;TOHoursPerDay&gt;();</span>
			
<span class="fc bfc" id="L244" title="All 2 branches covered.">			if (!isPublish) { </span>
				//update last published date to current last published date before updating to hoursperday
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">				if (isLastPubDateChanged) {    </span>
					 //only refresh the date if last published date has changed.
<span class="nc" id="L248">					dao.refreshLastPublishedDate(empIDs);</span>
				}
			} else {
<span class="fc bfc" id="L251" title="All 2 branches covered.">				if (isLastPubDateChanged) {</span>
					//lock the employees whose last pub date has changed
					//to prevent issues related to simultaneous publish of same employee
					//from several DE clients.
<span class="fc" id="L255">					lockEmployees(empIDs);</span>
				}
			}
			
			// always check for deleted TOEvents. We do not always receive deleted events in published schedule
			// deleted events are never received in unpublished schedule
<span class="fc" id="L261">			dao.deleteTOHoursPerDayOnUnPublish(empIDs, startDate, endDate);</span>
<span class="pc bpc" id="L262" title="2 of 4 branches missed.">			if (toEventEmpPairsToDel != null &amp;&amp; !toEventEmpPairsToDel.isEmpty()) {</span>
<span class="nc" id="L263">				deleteTOHoursPerDayForTOEventEmpPairs(toEventEmpPairsToDel);</span>
			}
<span class="fc bfc" id="L265" title="All 2 branches covered.">			if (isLastPubDateChanged) {</span>
				//if last published shift date changed, get updates from end date + 7 days
				//Why? 
				//this call is required on publish and unpublish schedule only where the last pub date has changed.
				// Not required on the TO Request approval / withdrawal.
<span class="fc" id="L270">				hrsPerColToUpdate.addAll(dao.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIDs, null, TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null))); // NOSONAR</span>
			} else {
				//if last published shift date changed, get updates after last pub date. Why?
				//if TO approval or withdrawal then get all valid Requests that have &quot;USE MY TO HOURS&quot;
				// intersecting +- 7 days of the date range only if end date falls after the last pub date
<span class="fc" id="L275">				hrsPerColToUpdate.addAll(dao.getValidHoursPerDayForDateRangeOnlyAfterLastPubDate(empIDs, null,</span>
<span class="fc" id="L276">				        new TimeRange(TOHoursPerDayUtil.getDateForDaysBefore(startDate, 7, null),</span>
<span class="fc" id="L277">				                TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null))));</span>
			}
			
			//Need to update Valid requests &amp; TO Events intersecting the date range
<span class="fc" id="L281">			hrsPerColToUpdate.addAll(dao.getValidHoursPerDayForEmpIds((empIDs), null, new TimeRange(startDate, endDate)));</span>
			
			// REFERENCE SCHEDULES
			// Get the requests that are generated using reference schedules (assuming this period may be referenced)
			// The dates may be wildly different from this period
<span class="fc" id="L286">			Collection&lt;TOHoursPerDay&gt; listReferenceScheduleHoursPerDay = getHoursPerDayGeneratedByReferenceSchedule(empIDs, startDate, endDate);</span>
<span class="fc" id="L287">			hrsPerColToUpdate.addAll(listReferenceScheduleHoursPerDay);</span>
			
			
<span class="pc bpc" id="L290" title="1 of 4 branches missed.">			if (newTOEvents != null &amp;&amp; !newTOEvents.isEmpty()) { </span>
				// identify the TOevents  to be updated
<span class="pc bpc" id="L292" title="1 of 4 branches missed.">				if (hrsPerColToUpdate != null &amp;&amp; !hrsPerColToUpdate.isEmpty()) {</span>
<span class="fc bfc" id="L293" title="All 2 branches covered.">					for (Iterator iterator = hrsPerColToUpdate.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L294">						TOHoursPerDay hrsPerDayOld = (TOHoursPerDay) iterator.next();</span>
<span class="fc" id="L295">						IDPair empTOEventPair = new IDPair(hrsPerDayOld.getID(), hrsPerDayOld.getEmployeeID());</span>
<span class="pc bpc" id="L296" title="1 of 4 branches missed.">						if (hrsPerDayOld.getTOEventID() != null &amp;&amp; newTOEvents.containsKey(empTOEventPair)) {</span>
<span class="nc" id="L297">							TOHoursPerDay toHoursPerDayNew = (TOHoursPerDay) newTOEvents.get(empTOEventPair);</span>
<span class="nc" id="L298">							iterator.remove();</span>
<span class="nc" id="L299">							toHoursPerDayNew.setID(hrsPerDayOld.getID());</span>
						}
<span class="fc" id="L301">					}</span>
				}
<span class="fc" id="L303">				hrsPerColToUpdate.addAll(newTOEvents.values());//add the  events</span>
			}

<span class="pc bpc" id="L306" title="1 of 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L307">				LOG.info(&quot;TOTAL TIME in PUBLISH SCHEDULE:&quot;</span>
<span class="nc" id="L308">						+ RmUtil.dumpCollection(empIDs, &quot;,&quot;)</span>
<span class="nc" id="L309">						+ &quot; updated objects=&quot; + hrsPerColToUpdate.size());</span>
			}
			
<span class="pc bpc" id="L312" title="1 of 4 branches missed.">			if (hrsPerColToUpdate != null &amp;&amp; !hrsPerColToUpdate.isEmpty()) {</span>
<span class="fc" id="L313">				refreshAndUpdateTOHoursPerDay(msgType, hrsPerColToUpdate, true,</span>
						true);
			}
			
<span class="pc bpc" id="L317" title="1 of 4 branches missed.">			if (isLastPubDateChanged &amp;&amp; isPublish) {//update last published date to current last published date after updating to hoursperday</span>
<span class="fc" id="L318">				dao.refreshLastPublishedDate(empIDs);</span>
			}
<span class="nc" id="L320">		} catch (Exception e) {</span>
<span class="nc" id="L321">			handleException(e);</span>
<span class="nc" id="L322">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L324" title="5 of 6 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L325">				dao.cleanUp();</span>
			}
		}
<span class="fc" id="L328">	}</span>

	/*
	 * getHoursPerDayGeneratedByReferenceSchedule
	 * Some requests are generated from reference schedules.
	 * The dates of the reference schedule will likely not coincide with the request date.
	 * When the reference schedule is published/unpublished, we need to update those
	 * requests. Return here a list of their Hours Per Day. 
	 */
	
	private Collection&lt;TOHoursPerDay&gt; getHoursPerDayGeneratedByReferenceSchedule(
			Collection&lt;ID&gt; empIDs, Date startDate, Date endDate) throws BbmFinderException {
			
<span class="fc" id="L341">			TOHoursPerDayDAO dao = null;</span>
			
			try {
<span class="fc" id="L344">				dao = new TOHoursPerDayDAO();</span>
<span class="fc" id="L345">				 return dao.getHoursPerDayGeneratedByReferenceSchedule(empIDs,startDate, endDate);</span>
<span class="nc" id="L346">			}catch(Exception e){</span>
<span class="nc" id="L347">				throw new BbmFinderException(e);</span>
			}finally{
<span class="pc bpc" id="L349" title="3 of 4 branches missed.">				if (dao != null) {</span>
<span class="pc" id="L350">					dao.cleanUp();</span>
				}
			}
			
	}
	
	private Collection&lt;TOHoursPerDay&gt; getHoursPerDayFromTOChoiceList(Collection&lt;ID&gt; toChoiceList) throws BbmFinderException {
			
<span class="nc" id="L358">			TOHoursPerDayDAO dao = null;</span>
			
			try {
<span class="nc" id="L361">				dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L362">				 return dao.getHoursPerDayFromTOChoiceList(toChoiceList);</span>
<span class="nc" id="L363">			}catch(Exception e){</span>
<span class="nc" id="L364">				throw new BbmFinderException(e);</span>
			}finally{
<span class="nc bnc" id="L366" title="All 4 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L367">					dao.cleanUp();</span>
				}
			}
			
	}
	
	
	
	

	public void updateTOHoursPerDayForTORequest(TORequest tor, boolean refreshOrigMinutes) throws BbmUpdateException {
<span class="fc" id="L378">		updateTOHoursPerDayForTORequest(DEFAULT_NOTIFY_MSG_TYPE, tor, refreshOrigMinutes);</span>
<span class="fc" id="L379">	}</span>
	
	private void updateTOHoursPerDayForTORequest(int msgType, TORequest tor, boolean refreshOrigMinutes) throws BbmUpdateException {
<span class="fc" id="L382">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L383">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="fc" id="L385">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L386">			Collection toHoursPerDayToRefresh = new ArrayList();</span>
<span class="fc" id="L387">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">			if (tor.getTimeOffDebitType().equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
<span class="nc" id="L389">				LOG.info(&quot;Ignoring TO Request since it is of TYPE DONT-DEBIT:&quot; + tor);</span>
<span class="nc" id="L390">				return;</span>
			}
<span class="fc" id="L392">			HashMap toChoiceMap = ValueObjectUtil.getIDObjectMap(tor.getRequestChoiceList());</span>
<span class="fc" id="L393">			Collection colTOHrsPerDay = toHoursPerDayDAO.getObjects(toChoiceMap.keySet(), TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFCHOICEID, null);</span>
<span class="pc bpc" id="L394" title="1 of 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L396">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="fc" id="L397">					TOChoice choice = (TOChoice) toChoiceMap.remove(hoursPerDay.getTOChoiceID());</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">					if (TOHoursPerDayUtil.isTOHoursPerDayDifferentFromTOChoice(tor, choice, hoursPerDay)) {</span>
<span class="fc" id="L399">						choice.setHoursPerDay(hoursPerDay);</span>
<span class="fc" id="L400">						hoursPerDay = TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, choice, tor.getEmployeeID());</span>
<span class="fc" id="L401">						hoursPerDay.setRefreshOrignalMinutes(refreshOrigMinutes);</span>
<span class="pc bpc" id="L402" title="1 of 2 branches missed.">						if (TOHoursPerDayUtil.isTOHoursPerDayRefreshRequired(tor, choice, hoursPerDay)) {</span>
<span class="nc" id="L403">							toHoursPerDayToRefresh.add(hoursPerDay);</span>
						} else {
<span class="fc" id="L405">							hoursPerDay.setIsDirty(false);</span>
<span class="fc" id="L406">							toHoursPerDayToUpdate.add(hoursPerDay);</span>
						}
					}
<span class="fc" id="L409">				}</span>
			}
<span class="pc bpc" id="L411" title="1 of 4 branches missed.">			if (toChoiceMap != null &amp;&amp; !toChoiceMap.isEmpty()) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">				for (Iterator iterator = toChoiceMap.values().iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L413">					TOChoice toChoice = (TOChoice) iterator.next();</span>
<span class="fc" id="L414">					hoursPerDay = TOHoursPerDayUtil.convertTOChoiceToHoursPerDay(tor, toChoice, tor.getEmployeeID());</span>
<span class="fc" id="L415">					hoursPerDay.setRefreshOrignalMinutes(refreshOrigMinutes);</span>
<span class="fc" id="L416">					toHoursPerDayToRefresh.add(hoursPerDay);</span>
<span class="fc" id="L417">				}</span>
			}
<span class="pc bpc" id="L419" title="1 of 4 branches missed.">			if (toHoursPerDayToRefresh != null &amp;&amp; !toHoursPerDayToRefresh.isEmpty()) {</span>
<span class="fc" id="L420">				refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayToRefresh, false, false);</span>
			}
<span class="pc bpc" id="L422" title="1 of 4 branches missed.">			if (toHoursPerDayToUpdate != null &amp;&amp; !toHoursPerDayToUpdate.isEmpty()) {</span>
<span class="fc" id="L423">				updateObjects(toHoursPerDayToUpdate);</span>
			}
<span class="nc" id="L425">		} catch (Exception e) {</span>
<span class="nc" id="L426">			handleException(e);</span>
<span class="nc" id="L427">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L429" title="5 of 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L430">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L433">	}</span>

	public float calculateTotalLength(ID empID, Date startDate, Date endDate, ID activityID) throws BbmFinderException {
<span class="nc" id="L436">		float totalHrs = 0f;</span>
<span class="nc" id="L437">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L438">		TOHoursPerDay hoursPerDay = null;</span>
		try {
<span class="nc" id="L440">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L441">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L442">			Collection colTOHrsPerDay = toHoursPerDayDAO.getHoursPerDayForTOevents(Collections.singleton(empID), Collections.singleton(activityID), new TimeRange(startDate, endDate));</span>
<span class="nc bnc" id="L443" title="All 4 branches missed.">			if (colTOHrsPerDay != null &amp;&amp; !colTOHrsPerDay.isEmpty()) {</span>
<span class="nc bnc" id="L444" title="All 2 branches missed.">				for (Iterator iterator = colTOHrsPerDay.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L445">					hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">					if (!hoursPerDay.getIsDirty()) {</span>
<span class="nc" id="L447">						boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L448">						boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L449" title="All 4 branches missed.">						if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">							DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">							        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L452">							        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L453">							totalHrs += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L454">						} else {</span>
<span class="nc" id="L455">							totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
						}
<span class="nc" id="L457">					} else {</span>
<span class="nc" id="L458">						toHoursPerDayToUpdate.add(hoursPerDay);</span>
					}
				}
			}
<span class="nc bnc" id="L462" title="All 4 branches missed.">			if (toHoursPerDayToUpdate != null &amp;&amp; !toHoursPerDayToUpdate.isEmpty()) {</span>
<span class="nc" id="L463">				refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, true);</span>
<span class="nc bnc" id="L464" title="All 2 branches missed.">				for (Iterator it = toHoursPerDayToUpdate.iterator(); it.hasNext();) {</span>
<span class="nc" id="L465">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc" id="L466">					boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L467">					boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L468" title="All 4 branches missed.">					if (isToEvtStartBeforeStart || isToEvtEndAfterEnd) {</span>
<span class="nc bnc" id="L469" title="All 2 branches missed.">						DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">						        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L471">						        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L472">						totalHrs += dailyBuckets.getTotalHours();</span>
<span class="nc" id="L473">					} else {</span>
<span class="nc" id="L474">						totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
					}
<span class="nc" id="L476">					totalHrs += (hoursPerDay.getTotalMinutes() / 60f);</span>
<span class="nc" id="L477">				}</span>
			}
<span class="nc" id="L479">		} catch (Exception e) {</span>
<span class="nc" id="L480">			handleException(e);</span>
<span class="nc" id="L481">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L483" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L484">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L487">		return totalHrs;</span>
	}

	public Collection getHoursPerDayForCalendar(Collection empIDs, Date startDate, Date endDate, Collection activityIDs, boolean schedOrPending) throws BbmFinderException {
<span class="fc" id="L491">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L492">		Collection hrsPerDayCol = new ArrayList();</span>
		try {
<span class="fc" id="L494">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L495">			HashMap hrsPerDaySchedMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDs, activityIDs, new TimeRange(startDate, endDate), schedOrPending);</span>
<span class="fc" id="L496">			hrsPerDayCol = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="fc" id="L497">			Collection hrsPerDayToUpdate = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">			if (hrsPerDayCol == null) {</span>
<span class="fc" id="L499">				hrsPerDayCol = new ArrayList();</span>
			}
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">			if (hrsPerDayToUpdate != null) {</span>
<span class="nc" id="L502">				hrsPerDayCol.addAll(refreshAndUpdateTOHoursPerDay(hrsPerDayToUpdate, true));</span>
			}
<span class="nc" id="L504">		} catch (Exception e) {</span>
<span class="nc" id="L505">			handleException(e);</span>
<span class="nc" id="L506">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L508" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L509">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L512">		return hrsPerDayCol;</span>
	}

	public Collection[] getHoursPerDayForCalendar(Collection empIDsSched, Collection empIDsPending, Date startDate, Date endDate, Collection activityIDs) throws BbmFinderException {
<span class="fc" id="L516">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L517">		Collection hrsPerDaySchedCol = new ArrayList();</span>
<span class="fc" id="L518">		Collection hrsPerDayPendingCol = new ArrayList();</span>
<span class="fc" id="L519">		long currentime = new Date().getTime();</span>
		try {
<span class="fc" id="L521">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L522">			HashMap hrsPerDaySchedMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDsSched, activityIDs, new TimeRange(startDate, endDate), true);</span>

<span class="fc" id="L524">			hrsPerDaySchedCol = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="pc bpc" id="L525" title="1 of 2 branches missed.">			if (hrsPerDaySchedCol == null) {</span>
<span class="fc" id="L526">				hrsPerDaySchedCol = new ArrayList();</span>
			}
<span class="fc" id="L528">			Collection hrsPerDaySchedToUpdate = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>

<span class="fc" id="L530">			HashMap hrsPerDayPendingMap = toHoursPerDayDAO.getHoursPerDayForCalendar(empIDsPending, activityIDs, new TimeRange(startDate, endDate), false);</span>
<span class="pc bpc" id="L531" title="1 of 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L532">				LOG.info(&quot;$$$$TOTAL TIME for FETCH ALL DATA FOR CALC=&quot; + (new Date().getTime() - currentime));</span>
			}
<span class="fc" id="L534">			hrsPerDayPendingCol = (Collection) hrsPerDayPendingMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="fc bfc" id="L535" title="All 2 branches covered.">			if (hrsPerDayPendingCol == null) {</span>
<span class="fc" id="L536">				hrsPerDayPendingCol = new ArrayList();</span>
			}
<span class="fc" id="L538">			Collection hrsPerDayPendingToUpdate = (Collection) hrsPerDayPendingMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>
<span class="fc" id="L539">			Collection hrsPerDayCol = new ArrayList();</span>
<span class="pc bpc" id="L540" title="3 of 4 branches missed.">			if (hrsPerDaySchedToUpdate != null &amp;&amp; !hrsPerDaySchedToUpdate.isEmpty()) {</span>
<span class="nc" id="L541">				hrsPerDayCol.addAll(hrsPerDaySchedToUpdate);</span>
<span class="nc" id="L542">				hrsPerDaySchedCol.addAll(hrsPerDaySchedToUpdate);</span>
			}
<span class="pc bpc" id="L544" title="3 of 4 branches missed.">			if (hrsPerDayPendingToUpdate != null &amp;&amp; !hrsPerDayPendingToUpdate.isEmpty()) {</span>
<span class="nc" id="L545">				hrsPerDayPendingCol.addAll(hrsPerDayPendingToUpdate);</span>
<span class="nc" id="L546">				hrsPerDayCol.addAll(hrsPerDayPendingToUpdate);</span>
			}
<span class="pc bpc" id="L548" title="2 of 4 branches missed.">			if (hrsPerDayCol != null &amp;&amp; !hrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L549">				refreshAndUpdateTOHoursPerDay(hrsPerDayCol, true);</span>
			}

<span class="nc" id="L552">		} catch (Exception e) {</span>
<span class="nc" id="L553">			handleException(e);</span>
<span class="nc" id="L554">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L556" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L557">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="pc bpc" id="L560" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L561">			LOG.info(&quot;TOTAL TIME for entire CALC LOAD=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj sched=&quot; + hrsPerDaySchedCol.size() + &quot;:pend=&quot; + hrsPerDayPendingCol.size());</span>
		}
<span class="fc" id="L563">		Collection[] hrsPerDayCol = new Collection[2];</span>
<span class="fc" id="L564">		hrsPerDayCol[TOCalendarUtil.BKT_PENDING] = hrsPerDayPendingCol;</span>
<span class="fc" id="L565">		hrsPerDayCol[TOCalendarUtil.BKT_SCHED] = hrsPerDaySchedCol;</span>
<span class="fc" id="L566">		return hrsPerDayCol;</span>
	}

	public Collection refreshAndUpdateTOHoursPerDay(Collection toHoursPerDayCol, boolean verifyTOChoiceStatus) throws BbmFinderException {
<span class="nc" id="L570">		return refreshAndUpdateTOHoursPerDay(DEFAULT_NOTIFY_MSG_TYPE, toHoursPerDayCol, verifyTOChoiceStatus, false);</span>
	}

	public Collection refreshAndUpdateTOHoursPerDay(int msgType, Collection toHoursPerDayCol, boolean verifyTOChoiceStatus, boolean doNotRefreshLongReq) throws BbmFinderException {
<span class="fc" id="L574">		long currentime = new Date().getTime();</span>
<span class="fc" id="L575">		TOHoursPerDay hoursPerDay = null;</span>
<span class="fc" id="L576">		Collection toHoursPerDayToInsert = new ArrayList();</span>
<span class="fc" id="L577">		Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="fc" id="L578">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="fc" id="L580">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="pc bpc" id="L581" title="1 of 4 branches missed.">			if (toHoursPerDayCol != null &amp;&amp; !toHoursPerDayCol.isEmpty()) {</span>
<span class="fc" id="L582">				Date startDate = null;</span>
<span class="fc" id="L583">				Date endDate = null;</span>
<span class="fc" id="L584">				HashMap empHrsPerDayMap = new HashMap();</span>
<span class="fc" id="L585">				Set activtyIds = new HashSet(toHoursPerDayCol.size());</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">				for (Iterator it = toHoursPerDayCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L587">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="pc bpc" id="L588" title="1 of 4 branches missed.">					if (doNotRefreshLongReq &amp;&amp; isGreaterThanMaxAllowedLength(hoursPerDay)) { //Do not adjust start &amp; end Date based on extraordinarily long requests</span>
<span class="nc" id="L589">						hoursPerDay.setIsDirty(true);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">						if (hoursPerDay.getID() == null) {</span>
<span class="nc" id="L591">							toHoursPerDayToInsert.add(hoursPerDay);</span>
						} else {
<span class="nc" id="L593">							toHoursPerDayToUpdate.add(hoursPerDay);</span>
						}
<span class="nc" id="L595">						LOG.info(&quot;Skipping This TOHoursPerday Since it Exceeds Max Size;&quot; + hoursPerDay);</span>
					} else {
<span class="fc bfc" id="L597" title="All 4 branches covered.">						startDate = (startDate == null || startDate.after(hoursPerDay.getStartTime()) ? hoursPerDay.getStartTime() : startDate);</span>
<span class="pc bpc" id="L598" title="1 of 4 branches missed.">						endDate = (endDate == null || endDate.before(hoursPerDay.getEndTime()) ? hoursPerDay.getEndTime() : endDate);</span>

<span class="fc" id="L600">						EmpHrsPerDayCol empHrsPerDayCol = (EmpHrsPerDayCol) empHrsPerDayMap.get(hoursPerDay.getEmployeeID());</span>
<span class="fc" id="L601">						activtyIds.add(hoursPerDay.getActivityID());</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">						if (empHrsPerDayCol == null) {</span>
<span class="fc" id="L603">							empHrsPerDayCol = new EmpHrsPerDayCol();</span>
<span class="fc" id="L604">							empHrsPerDayMap.put(hoursPerDay.getEmployeeID(), empHrsPerDayCol);</span>
						}
<span class="fc" id="L606">						empHrsPerDayCol.add(hoursPerDay);</span>
<span class="fc" id="L607">					}</span>
				}
<span class="pc bpc" id="L609" title="2 of 4 branches missed.">				if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="fc" id="L610">					Map bulkDataMap = getTOCalcDataForEmpIDs(empHrsPerDayMap.keySet(), startDate, endDate);</span>
<span class="fc bfc" id="L611" title="All 2 branches covered.">					for (Iterator iterator = empHrsPerDayMap.values().iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L612">						EmpHrsPerDayCol empHrsPerDayCol = (EmpHrsPerDayCol) iterator.next();</span>
<span class="fc" id="L613">						refreshHoursPerDayForEmployee(msgType, empHrsPerDayCol, bulkDataMap, toHoursPerDayToInsert, toHoursPerDayToUpdate, doNotRefreshLongReq);</span>
<span class="fc" id="L614">					}</span>
				}
<span class="pc bpc" id="L616" title="1 of 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L617">					LOG.info(&quot;\t$$$$TOTAL TIME FOR CALC REFRESH=&quot; + (new Date().getTime() - currentime) + &quot; :: TOTAL objs updated=&quot; + toHoursPerDayCol.size());</span>
				}
<span class="fc" id="L619">				toHoursPerDayCol.clear();</span>
<span class="fc" id="L620">				toHoursPerDayCol.addAll(toHoursPerDayToInsert);</span>
<span class="fc" id="L621">				toHoursPerDayCol.addAll(toHoursPerDayToUpdate);</span>
<span class="fc bfc" id="L622" title="All 2 branches covered.">				if (verifyTOChoiceStatus) {</span>
<span class="fc" id="L623">					toHoursPerDayDAO.refreshStatusForTOChoices(toHoursPerDayCol);</span>
				}
<span class="fc" id="L625">				createObjects(toHoursPerDayToInsert);</span>
<span class="fc" id="L626">				updateObjects(toHoursPerDayToUpdate);</span>
			}
<span class="nc" id="L628">		} catch (Exception e) {</span>
<span class="nc" id="L629">			handleException(e);</span>
<span class="nc" id="L630">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L632" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L633">				toHoursPerDayDAO.cleanUp();</span>
			}
<span class="pc bpc" id="L635" title="3 of 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L636">				LOG.info(&quot;TOTAL TIME for DB REFRESH=&quot; + (new Date().getTime() - currentime) + &quot;:TOTAL records affected=&quot; + toHoursPerDayCol.size());</span>
			}
		}
<span class="fc" id="L639">		return toHoursPerDayCol;</span>
	}

	public void deleteTOHoursPerDayForTOEventEmpPairs(Collection toEventEmpPairs) throws BbmUpdateException {
<span class="nc" id="L643">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L645">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L646">			toHoursPerDayDAO.deleteTOHoursPerDayForTOEventEmpPairs(toEventEmpPairs);</span>
<span class="nc" id="L647">		} catch (Exception e) {</span>
<span class="nc" id="L648">			handleException(e);</span>
<span class="nc" id="L649">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L651" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L652">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L655">	}</span>


	public void createObjects(Collection toHoursPerDayToInsert) throws BbmFinderException {
<span class="fc" id="L659">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="fc" id="L661">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L663">				LOG.info(&quot;start of createObjects=[&quot; + RmUtil.dumpCollection(toHoursPerDayToInsert, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="fc" id="L665">			toHoursPerDayDAO.createObjects(toHoursPerDayToInsert);</span>
<span class="nc" id="L666">		} catch (Exception e) {</span>
<span class="nc" id="L667">			LOG.info(&quot;Caught Exception in createObjects (Collection) now trying insertOrUpdate:&quot;+ e.getMessage());</span>
			try {
<span class="nc bnc" id="L669" title="All 2 branches missed.">				if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L670">					toHoursPerDayDAO.cleanUp();</span>
				}
<span class="nc" id="L672">				toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L673">				Set toEventSet = TOHoursPerDayUtil.extractFieldSet(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_TIMEOFFEVENTID, toHoursPerDayToInsert);</span>
<span class="nc bnc" id="L674" title="All 6 branches missed.">				if (toEventSet != null &amp;&amp; !toEventSet.isEmpty() &amp;&amp; !toHoursPerDayDAO.checkIfNewTOEventsAreCommited(toEventSet)) {</span>
<span class="nc" id="L675">					LOG.info(&quot;one of the following TOEvents IDs do not exist in Database:&quot; + TOCalcUtil.dumpCollection(toEventSet, &quot;,&quot;) + &quot;; Most probably the transaction has been rolled back&quot;);</span>
<span class="nc" id="L676">					return;</span>
				}
<span class="nc" id="L678">			} catch (Exception ep) {</span>
<span class="nc" id="L679">				LOG.info(&quot; Caught Exception in checkIfNewTOEventsAreCommited() still continuing&quot;, ep);</span>
<span class="nc" id="L680">			}</span>
			try {
<span class="nc" id="L682">				toHoursPerDayDAO.insertOrUpdateObjects(toHoursPerDayToInsert);</span>
<span class="nc" id="L683">			} catch (Exception ed) {</span>
<span class="nc" id="L684">				LOG.error(&quot; Caught Exception in insertOrUpdateObjects() now trying one object a time&quot;, ed);</span>
<span class="nc" id="L685">				int exceptionCou = 0;</span>
<span class="nc" id="L686">				TOHoursPerDay hoursPerDay = null;</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">				for (Iterator iterator = toHoursPerDayToInsert.iterator(); iterator.hasNext();) {</span>
					try {
<span class="nc" id="L689">						hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc" id="L690">						toHoursPerDayDAO.createObject(hoursPerDay);</span>
<span class="nc" id="L691">					} catch (Exception ex) {</span>
<span class="nc" id="L692">						exceptionCou++;</span>
<span class="nc" id="L693">						handleException(&quot;Caught Exception in createObject one at a time ) hoursPerDay= &quot; + hoursPerDay, ex);</span>
<span class="nc" id="L694">						String str = hoursPerDay.toString() + dumpDuplicateEvents(hoursPerDay);</span>
<span class="nc" id="L695">						traceDebugData(&quot;CREATEOBJECT:&quot;, str, ex, 0);</span>
<span class="nc" id="L696">					}</span>
				}
<span class="nc" id="L698">				LOG.info(&quot;Number of exceptions in createObjects one at a time=&quot; + exceptionCou + &quot; : Total HrsPerDay Count=&quot; + toHoursPerDayToInsert.size());</span>
<span class="nc bnc" id="L699" title="All 4 branches missed.">				if (exceptionCou &gt; 1 &amp;&amp; exceptionCou == toHoursPerDayToInsert.size()) {</span>
<span class="nc" id="L700">					throw new BbmFinderException(e);</span>
				}
<span class="nc" id="L702">			}</span>
		} finally {
<span class="pc bpc" id="L704" title="7 of 8 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L705">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L708">	}</span>

	private String dumpDuplicateEvents(TOHoursPerDay hoursPerDay) {
<span class="nc" id="L711">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L712">		StringBuffer sb = new StringBuffer(1000);</span>
		try {
<span class="nc" id="L714">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L715">			StringBuffer buf = new StringBuffer(256);</span>
<span class="nc" id="L716">			buf.append(&quot;SELECT EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME , MIN(CALENDAREVENTASSIGNMENTID)IDMIN,MAX(CALENDAREVENTASSIGNMENTID ) IDMAX ,COUNT(*) COUNT, 'U*P' PUB ,getdate() ATWHEN &quot;);</span>
<span class="nc" id="L717">			buf.append(&quot;FROM CALENDAREVENTATTENDEE A,CALENDAREVENTASSIGNMENT P  &quot;);</span>
<span class="nc" id="L718">			buf.append(&quot;WHERE P.ID= A.CALENDAREVENTASSIGNMENTID  and EVENTTYPE=512      &quot;);</span>
<span class="nc" id="L719">			buf.append(&quot;GROUP BY EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME  &quot;);</span>
<span class="nc" id="L720">			buf.append(&quot;HAVING COUNT(1)&gt;1 &quot;);</span>
<span class="nc" id="L721">			JdmoRowset rs = toHoursPerDayDAO.getDMO().createRowset(buf.toString());</span>
<span class="nc" id="L722">			sb.append(&quot;\n DUPEVENT UNPUB :&quot;);</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L724">				sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">				for (int ix = 1; ix &lt;= rs.getMetaData().getColumnCount(); ix++) {</span>
<span class="nc" id="L726">					sb.append(&quot;\t&quot;).append(rs.getMetaData().getColumnName(ix)).append(&quot;=&quot;).append(rs.getObject(ix));</span>
				}
			}
<span class="nc bnc" id="L729" title="All 2 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L730">				toHoursPerDayDAO.cleanUp();</span>
			}
<span class="nc" id="L732">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L733">			buf = new StringBuffer(256);</span>
<span class="nc" id="L734">			buf.append(&quot;SELECT EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME , MIN(CALENDAREVENTASSIGNMENTID)IDMIN,MAX(CALENDAREVENTASSIGNMENTID ) IDMAX ,COUNT(*) COUNT, 'P*B' PUB ,getdate() ATWHEN &quot;);</span>
<span class="nc" id="L735">			buf.append(&quot;FROM CALENDAREVENTATTENDEEPUB A,CALENDAREVENTASSIGNMENTPUB P  &quot;);</span>
<span class="nc" id="L736">			buf.append(&quot;WHERE P.ID= A.CALENDAREVENTASSIGNMENTID and EVENTTYPE=512       &quot;);</span>
<span class="nc" id="L737">			buf.append(&quot;GROUP BY EVENTTYPE, WORKRESOURCEID, STARTTIME,ENDTIME  &quot;);</span>
<span class="nc" id="L738">			buf.append(&quot;HAVING COUNT(1)&gt;1 &quot;);</span>
<span class="nc" id="L739">			rs = toHoursPerDayDAO.getDMO().createRowset(buf.toString());</span>
<span class="nc" id="L740">			sb.append(&quot;\n DUPEVENT PUB :&quot;);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L742">				sb.append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">				for (int ix = 1; ix &lt;= rs.getMetaData().getColumnCount(); ix++) {</span>
<span class="nc" id="L744">					sb.append(&quot;\t&quot;).append(rs.getMetaData().getColumnName(ix)).append(&quot;=&quot;).append(rs.getObject(ix));</span>
				}

			}
<span class="nc" id="L748">			sb.append(&quot;\n DUPLICATE EVENTS IN TIMEOFFHOURSPERDAY&quot;).append(TOCalcUtil.dumpCollection(toHoursPerDayDAO.getObjectsWithExactMatch(hoursPerDay), &quot;\n&quot;));</span>
<span class="nc" id="L749">		} catch (Exception e) {</span>
<span class="nc" id="L750">			handleException(e);</span>
		} finally {
<span class="nc bnc" id="L752" title="All 6 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L753">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
		
<span class="nc" id="L757">		return sb.toString();</span>
	}

	public void updateObjects(Collection toHoursPerDayToUpdate) throws BbmFinderException {
<span class="fc" id="L761">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="fc" id="L763">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="pc bpc" id="L764" title="1 of 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L765">				LOG.info(&quot;start of updateObjects=[&quot; + RmUtil.dumpCollection(toHoursPerDayToUpdate, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="fc" id="L767">			toHoursPerDayDAO.updateObjects(toHoursPerDayToUpdate);</span>
<span class="nc" id="L768">		} catch (Exception e) {</span>
<span class="nc" id="L769">			handleException(e);</span>
<span class="nc" id="L770">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L772" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L773">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L776">	}</span>

	private void refreshHoursPerDayForEmployee(int msgType, EmpHrsPerDayCol empHrsPerDayCol, Map bulkDataMap, Collection toHoursPerDayToInsert, Collection toHoursPerDayToUpdate, boolean doNotRefreshLongReq) throws Exception {
<span class="pc bpc" id="L779" title="2 of 4 branches missed.">		if (empHrsPerDayCol.hrsPerDaySet != null &amp;&amp; !empHrsPerDayCol.hrsPerDaySet.isEmpty()) {</span>
<span class="fc" id="L780">			ID empID = empHrsPerDayCol.empID;</span>
<span class="fc" id="L781">			Map orgIDMap = (Map) bulkDataMap.get(&quot;orgIDMap&quot;);</span>
<span class="fc" id="L782">			Map empIDToLastShiftAssnMap = (Map) bulkDataMap.get(&quot;empIDToLastShiftAssnMap&quot;);</span>
<span class="fc" id="L783">			Map empAllotmentMap = (Map) bulkDataMap.get(&quot;empAllotmentMap&quot;);</span>
<span class="fc" id="L784">			Map adjTimeRangeMap = (Map) bulkDataMap.get(&quot;adjTimeRangeMap&quot;);</span>
<span class="fc" id="L785">			Map empIDToShiftAssnsPubMap = (Map) bulkDataMap.get(&quot;empIDToShiftAssnsPubMap&quot;);</span>
<span class="fc" id="L786">			Map empIDToUnavailsPubMap = (Map) bulkDataMap.get(&quot;empIDToUnavailsPubMap&quot;);</span>
<span class="fc" id="L787">			Map empIDToTimeOffPubMap = (Map) bulkDataMap.get(&quot;empIDToTimeOffPubMap&quot;);</span>
<span class="fc" id="L788">			Map hoosForOrgMap = (Map) bulkDataMap.get(&quot;hoosForOrgMap&quot;);</span>
<span class="fc" id="L789">			Map holidayMap = (Map) bulkDataMap.get(&quot;holidayMap&quot;);</span>
<span class="fc" id="L790">			Map empIdOrgAssignmentMap = (Map) bulkDataMap.get(&quot;empOrgAssignment&quot;);</span>
<span class="fc" id="L791">			Map empIdTerminationDateMap = (Map) bulkDataMap.get(&quot;empIdTerminationDateMap&quot;);</span>
			//start building the calc and removing data from maps that are relevant to employee
<span class="fc" id="L793">			Collection empShiftAssns = (Collection) empIDToShiftAssnsPubMap.remove(empID); //only remove emp assignments</span>
<span class="fc" id="L794">			Collection empUnavails = (Collection) empIDToUnavailsPubMap.remove(empID);</span>
<span class="fc" id="L795">			Collection empTimeOffPub = (Collection) empIDToTimeOffPubMap.remove(empID);</span>
<span class="fc" id="L796">			Collection empOrgAssignmentsCol = (Collection) empIdOrgAssignmentMap.remove(empID);</span>
<span class="fc" id="L797">			Date terminationDate = (Date) empIdTerminationDateMap.remove(empID);</span>
<span class="pc bpc" id="L798" title="2 of 4 branches missed.">			if (empOrgAssignmentsCol == null || empOrgAssignmentsCol.isEmpty()) {</span>
<span class="nc" id="L799">				LOG.debug(&quot;WorkResource Assignment For empID =&quot; + empID + &quot;null=[&quot; + RmUtil.dumpCollection(empOrgAssignmentsCol, &quot;\n&quot;) + &quot;]&quot;);</span>
			}
<span class="fc" id="L801">			HashMap allotmentMap = ValueObjectUtil.getFieldObjectMap(EmployeeTimeOffDefaultFieldInfo.TMOFFDEFAULT_ACTIVITYID, (ArrayList) empAllotmentMap.remove(empID));</span>
<span class="fc" id="L802">			ShiftAssignment lastShift = (ShiftAssignment) empIDToLastShiftAssnMap.remove(empID);</span>
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">			lastShift = (lastShift == null ? defaultLastShift : lastShift);</span>
<span class="fc" id="L804">			TimeOffLengthCalculator toCalc = null;</span>
<span class="fc" id="L805">			TOHoursPerDay hoursPerDay = null;</span>
<span class="fc" id="L806">			WorkResourceAssignment workResourceAssignment = null;</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">			for (Iterator it = empHrsPerDayCol.hrsPerDaySet.iterator(); it.hasNext();) {</span>
<span class="fc" id="L808">				hoursPerDay = (TOHoursPerDay) it.next();</span>

				//decide Org for Employee Here; based on the startDate  &amp; then build a new CALC if there is a ORG change
<span class="pc bpc" id="L811" title="3 of 6 branches missed.">				if (workResourceAssignment == null || (workResourceAssignment.getEndTime() != null &amp;&amp; hoursPerDay.getStartTime().after(workResourceAssignment.getEndTime()))) {</span>
<span class="pc bpc" id="L812" title="1 of 2 branches missed.">					if (workResourceAssignment != null){</span>
<span class="nc" id="L813">						LOG.debug(&quot;Changing Employee ORG Here hrsPerDay St Time=&quot; + hoursPerDay.getStartTime() + &quot;:OLD WRA=&quot; + workResourceAssignment);</span>
					}
<span class="fc" id="L815">					workResourceAssignment = getWorkResourceAssignmentForGivenDate(empOrgAssignmentsCol, hoursPerDay.getStartTime());</span>
					//The employee has been terminated before the given start date . use the root org to avoid exception
<span class="pc bpc" id="L817" title="1 of 2 branches missed.">					ID orgID = workResourceAssignment == null ? Organization.ROOT_ORG_ID_OBJ : workResourceAssignment.getOrganizationID();</span>
<span class="fc" id="L818">					Organization org = (Organization) orgIDMap.get(orgID);</span>
										
<span class="fc" id="L820">					toCalc = TimeOffLengthCalculatorHelper.getCalculator(empID,</span>
<span class="fc" id="L821">					        org, (TimeRange) adjTimeRangeMap.get(org.getID()),</span>
					        empShiftAssns, empUnavails, empTimeOffPub,
<span class="fc" id="L823">					        (Collection) hoosForOrgMap.get(org.getID()),</span>
<span class="fc" id="L824">					        (Collection) holidayMap.get(org.getID()),</span>
					        lastShift, allotmentMap, terminationDate);
				}
<span class="pc bpc" id="L827" title="1 of 4 branches missed.">				if (doNotRefreshLongReq &amp;&amp; isGreaterThanMaxAllowedLength(hoursPerDay)) {</span>
					 //Do not adjust start &amp; end Date based on extraordinarily long requests
<span class="nc" id="L829">					LOG.info(&quot;Skipping This TOHoursPerday Since it Exceeds Max Size;&quot; + hoursPerDay);</span>
<span class="nc" id="L830">					hoursPerDay.setIsDirty(true);</span>
				} else {
<span class="fc" id="L832">					StringBuilder hoursPerDayChange = new StringBuilder();</span>
<span class="fc" id="L833">					hoursPerDay = TOHoursPerDayUtil.refreshMinsForTOHoursPerDay(hoursPerDay, toCalc, hoursPerDayChange);</span>
					// audit for only TO events hours/day changes for employee
<span class="fc bfc" id="L835" title="All 2 branches covered.">					if (!hoursPerDayChange.toString().isEmpty()) { </span>
<span class="fc" id="L836">						auditTOHoursPerDayChange(empID, msgType, hoursPerDay.getStartTime(), hoursPerDay.getEndTime(), hoursPerDayChange.toString());</span>
					}
				}
<span class="fc bfc" id="L839" title="All 2 branches covered.">				if (hoursPerDay.getID() == null) {</span>
<span class="fc" id="L840">					toHoursPerDayToInsert.add(hoursPerDay);</span>
				} else {
<span class="fc" id="L842">					toHoursPerDayToUpdate.add(hoursPerDay);</span>
				}
			}
		}
<span class="fc" id="L846">	}</span>

	private void auditTOHoursPerDayChange(ID empID, int msgType, Date startDate, Date endDate, String hoursPerDayChange) {
<span class="fc" id="L849">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
														AuditTrailEntry.ACTION_TIME_OFF_HOURS_PER_DAY,
														empID, null, startDate, endDate);
		try {
<span class="fc" id="L853">			String notifyType = TONotifyMessage.getNotifyString(msgType);</span>
			
<span class="fc" id="L855">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF, </span>
								   hoursPerDayChange,
								   notifyType, false);
<span class="fc" id="L858">			BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(auditEntry);</span>
<span class="nc" id="L859">		} catch (Exception e) {</span>
<span class="nc" id="L860">		  LOG.debug(&quot;unable to audit TO hours per day changes for employee with id: &quot; + empID + </span>
<span class="nc" id="L861">			&quot; because of exception : &quot; + e.getMessage());</span>
<span class="fc" id="L862">		} </span>
<span class="fc" id="L863">	}</span>

	private WorkResourceAssignment getWorkResourceAssignmentForGivenDate(Collection wras, Date startDate) {
<span class="fc" id="L866">		WorkResourceAssignment wra = null;</span>
<span class="pc bpc" id="L867" title="2 of 4 branches missed.">		if (wras != null &amp;&amp; !wras.isEmpty()) {</span>
<span class="pc bpc" id="L868" title="1 of 2 branches missed.">			for (Iterator it = wras.iterator(); it.hasNext();) {</span>
<span class="fc" id="L869">				wra = (WorkResourceAssignment) it.next();</span>
<span class="pc bpc" id="L870" title="2 of 4 branches missed.">				if (wra != null &amp;&amp; startDate != null &amp;&amp;</span>
<span class="pc bpc" id="L871" title="4 of 6 branches missed.">				        (wra.getEndTime() == null || !startDate.after(wra.getEndTime())) &amp;&amp; !startDate.before(wra.getStartTime())) {</span>
<span class="fc" id="L872">					break;</span>
				}
			}
		}
<span class="fc" id="L876">		return wra;</span>
	}

	//Called on HOLIDAY change
	private Collection updateTOHoursPerDayForOrg(ID orgID, Date startDate, Date endDate, int msgType) throws BbmUpdateException {
<span class="nc" id="L881">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="nc" id="L883">			dao = new TOHoursPerDayDAO();</span>
			//should add 7 days before and after date range to accomdate for Change in accounted hours for requests
			//  in that period on account of emp weekly defaults.
<span class="nc" id="L886">			Collection empIDs = RequestUtil.getEmpIdsInOrg(orgID, startDate, endDate, true);</span>
<span class="nc" id="L887">			Collection returnCol = dao.getObjects(empIDs, TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID,</span>
<span class="nc" id="L888">			        new TimeRange(TOHoursPerDayUtil.getDateForDaysBefore(startDate, 7, null),</span>
<span class="nc" id="L889">			                TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null)));</span>
<span class="nc" id="L890">			return refreshAndUpdateTOHoursPerDay(msgType, returnCol, true, false);</span>
<span class="nc" id="L891">		} catch (Exception e) {</span>
<span class="nc" id="L892">			handleException(e);</span>
<span class="nc" id="L893">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L895" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L896">				dao.cleanUp();</span>
			}
		}

	}

	//Called on any TOHoursPerday change
	public void updateTOHoursPerDay(TONotifyMessage msg) throws BbmUpdateException {
<span class="fc" id="L904">		int notifyType = msg.getNotificationType();</span>
		//TODO: convert to xml &amp; save the msg to database as a task
<span class="pc bpc" id="L906" title="4 of 8 branches missed.">		switch (notifyType) {</span>
			case TONotifyMessage.TO_NOTIFY_EMP_ORG_CHANGE:
<span class="fc" id="L908">				updateTOHoursPerDayForEmp(notifyType, msg.getObject());</span>
<span class="fc" id="L909">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_UNAVAIL_CHANGE:
<span class="fc" id="L911">				updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(notifyType, msg.getEmployeeIDs(), null, msg.getEndDate());</span>
<span class="fc" id="L912">				break;</span>
			case TONotifyMessage.TO_NOTIFY_HOLIDAY_CHANGE:
<span class="nc" id="L914">				updateTOHoursPerDayForOrg(msg.getOrgId(), msg.getStartDate(), msg.getEndDate(), notifyType);</span>
<span class="nc" id="L915">				break;</span>
			case TONotifyMessage.TO_NOTIFY_ORG_HOO_CHANGE:
<span class="nc" id="L917">				updateTOHoursPerDayForOrgAfterLastPublishedDate(msg.getOrgId(), notifyType);</span>
<span class="nc" id="L918">				break;</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_PART:
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH:
			case TONotifyMessage.TO_NOTIFY_SCHED_UNPUBLISH:
<span class="fc" id="L922">				updateHoursPerDay((ScheduleChangeDetails) msg.getObject(), notifyType);</span>
<span class="fc" id="L923">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_TO_DEF_HOURS_CHANGE:
<span class="fc" id="L925">				updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(notifyType, msg.getEmployeeIDs(), Collections.singleton(msg.getActivityId()), null);</span>
<span class="fc" id="L926">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOREQUEST_UPDATE:
<span class="nc" id="L928">				Pair pair = (Pair) msg.getObject();</span>
<span class="nc" id="L929">				updateTOHoursPerDayForTORequest(notifyType, (TORequest) pair.getFirst(), ((Boolean) pair.getSecond()).booleanValue());</span>
<span class="nc" id="L930">				break;</span>
			default: 
				//should never come to this block
		}
		//TODO: flag the task saved to DB as completed
<span class="fc" id="L935">	}</span>

	private Collection updateTOHoursPerDayForEmp(int msgType, Object obj) throws BbmUpdateException {
<span class="fc" id="L938">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="fc" id="L940">			dao = new TOHoursPerDayDAO();</span>
<span class="fc" id="L941">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="fc" id="L942">			Pair pair = (Pair) obj;</span>
<span class="fc" id="L943">			Employee empBefore = (Employee) pair.getFirst();</span>
<span class="fc" id="L944">			Employee empAfter = (Employee) pair.getSecond();</span>
<span class="fc" id="L945">			Collection empIDs = Collections.singleton(empAfter.getID());</span>
<span class="pc bpc" id="L946" title="2 of 4 branches missed.">			long endTimeBefore = empBefore != null &amp;&amp; empBefore.getEndTime() != null ? empBefore.getEndTime().getTime() : -1;</span>
<span class="pc bpc" id="L947" title="2 of 4 branches missed.">			long endTimeAfter = empAfter != null &amp;&amp; empAfter.getEndTime() != null ? empAfter.getEndTime().getTime() : -1;</span>
<span class="pc bpc" id="L948" title="1 of 2 branches missed.">			if (endTimeBefore != endTimeAfter) {//Employee Termination</span>
				//take the scan date as earliest of the two dates
<span class="nc bnc" id="L950" title="All 6 branches missed.">				Date scanStartDate = new Date((endTimeBefore == -1 || (endTimeAfter != -1 &amp;&amp; endTimeBefore &gt; endTimeAfter)) ? endTimeAfter : endTimeBefore);</span>
<span class="nc" id="L951">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpAfterGivenDate(empAfter.getID(), null, scanStartDate, false));</span>
				//This is required since the Total minutes are updated on employee termination
				// and we need to restore them to original values when termination date is changed.
<span class="nc bnc" id="L954" title="All 2 branches missed.">				for (Iterator iterator = toHoursPerDayToUpdate.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L955">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) iterator.next();</span>
<span class="nc bnc" id="L956" title="All 2 branches missed.">					if (hoursPerDay.getTimeOffRule() == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">						if (hoursPerDay.getTOEventID() != null) {</span>
							//toChoiceHrsPerDayMap.put(hoursPerDay.getTOEventID(), hoursPerDay);
							//QC164874
<span class="nc" id="L960">							hoursPerDay.setHoursPerDay(hoursPerDay.getOriginalHoursPerDay());</span>
<span class="nc" id="L961">							hoursPerDay.setTotalMinutes(hoursPerDay.getOriginalMinutes());</span>
						}
<span class="nc bnc" id="L963" title="All 4 branches missed.">						if (hoursPerDay.getTOChoiceID() != null &amp;&amp; RequestAuditTrail.STATUS_APPROVED.equals(hoursPerDay.getStatus())) {</span>
<span class="nc" id="L964">							hoursPerDay.setTotalMinutes(hoursPerDay.getOriginalMinutes());</span>
						}
					}
<span class="nc" id="L967">				}</span>
<span class="nc" id="L968">			} else { </span>
				//Employee creation or Org change
<span class="fc" id="L970">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIDs, null, null));</span>
			}
<span class="fc" id="L972">			return refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayToUpdate, true, false);</span>
<span class="nc" id="L973">		} catch (Exception e) {</span>
<span class="nc" id="L974">			handleException(e);</span>
<span class="nc" id="L975">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L977" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L978">				dao.cleanUp();</span>
			}
		}
	}

	//Called on  EMP org change &amp; termination only
	private Collection updateTOHoursPerDayForEmp(Collection empIDs, Date startDate, Date endDate) throws BbmUpdateException {
<span class="nc" id="L985">		TOHoursPerDayDAO dao = null;</span>
		try {
<span class="nc" id="L987">			dao = new TOHoursPerDayDAO();</span>
<span class="nc" id="L988">			dao.insertLastPublishedDate(empIDs, null);</span>
<span class="nc" id="L989">			Collection toHoursPerDayToUpdate = new ArrayList();</span>
<span class="nc" id="L990">			Map empIDToLastnShiftAssnMap = TOCalcUtil.getLastShiftAssignmentsForEmpIDs(empIDs, true, null);</span>
<span class="nc" id="L991">			WorkResourceManager wrMgr = RequestUtil.getWorkResourceManager();</span>
<span class="nc" id="L992">			Map terminatedEmpIdMap = wrMgr.getTerminatedEmployees(empIDs);</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">			for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L994">				ID empId = (ID) iterator.next();</span>
				//scanStartDate is the earliest of the
				// 1&gt; passed start date OR
				// 2&gt; passed end date  OR
				// 3&gt; actual employee termination date  OR
				// 4&gt; last published date if it exists.
<span class="nc" id="L1000">				Date scanStartDate = startDate;</span>
<span class="nc bnc" id="L1001" title="All 6 branches missed.">				if (endDate != null &amp;&amp; (scanStartDate == null || scanStartDate.after(endDate))) {</span>
<span class="nc" id="L1002">					scanStartDate = endDate;</span>
				}
<span class="nc" id="L1004">				Date empEndDate = (Date) terminatedEmpIdMap.get(empId);</span>
<span class="nc bnc" id="L1005" title="All 6 branches missed.">				if (empEndDate != null &amp;&amp; (scanStartDate == null || scanStartDate.after(empEndDate))) {</span>
<span class="nc" id="L1006">					scanStartDate = empEndDate;</span>
				}
<span class="nc" id="L1008">				ShiftAssignment lastShift = (ShiftAssignment) empIDToLastnShiftAssnMap.remove(empId);</span>
<span class="nc bnc" id="L1009" title="All 6 branches missed.">				if (lastShift != null &amp;&amp; (scanStartDate == null || scanStartDate.after(lastShift.getStartTime()))) {</span>
<span class="nc" id="L1010">					scanStartDate = lastShift.getStartTime();</span>
				}
<span class="nc" id="L1012">				toHoursPerDayToUpdate.addAll(dao.getHoursPerDayForEmpAfterGivenDate(empId, null, scanStartDate, false));</span>
<span class="nc" id="L1013">			}</span>
<span class="nc" id="L1014">			return refreshAndUpdateTOHoursPerDay(toHoursPerDayToUpdate, true);</span>
<span class="nc" id="L1015">		} catch (Exception e) {</span>
<span class="nc" id="L1016">			handleException(e);</span>
<span class="nc" id="L1017">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L1019" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1020">				dao.cleanUp();</span>
			}
		}
	}
	

	//Called on ORG HOO change
	private void updateTOHoursPerDayForOrgAfterLastPublishedDate(ID orgID, int msgType) throws BbmUpdateException {
		try {
<span class="nc" id="L1029">			Collection empIds = RequestUtil.getEmpIdsInOrg(orgID, new Date(), RequestUtil.MAX_DATE, false);</span>
<span class="nc bnc" id="L1030" title="All 4 branches missed.">			if (empIds != null &amp;&amp; !empIds.isEmpty()) {</span>
<span class="nc" id="L1031">				int maxEmpRefreshSize = getMaxEmpRefreshSize();</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">				if (empIds.size() &gt; maxEmpRefreshSize) {</span>
<span class="nc" id="L1033">					List empList = new ArrayList();</span>
<span class="nc" id="L1034">					empList.addAll(empIds);</span>
<span class="nc" id="L1035">					Collection empIdListArray[] = split(empList, maxEmpRefreshSize);</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">					for (int i = 0; i &lt; empIdListArray.length; i++) {</span>
<span class="nc" id="L1037">						LOG.info(&quot;empList =&quot; + empList.size() + &quot;; empIdListArray[i]=&quot; + empIdListArray[i].size() + &quot; :count=&quot; + i);</span>
<span class="nc" id="L1038">						updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(msgType, empIdListArray[i], null, null);</span>
					}
<span class="nc" id="L1040">				} else {</span>
<span class="nc" id="L1041">					updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(msgType, empIds, null, null);</span>
				}
			}
<span class="nc" id="L1044">		} catch (Exception e) {</span>
<span class="nc" id="L1045">			handleException(e);</span>
<span class="nc" id="L1046">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1047">		}</span>
<span class="nc" id="L1048">	}</span>

	public static List[] split(final List pList, final int pSize) {
<span class="nc bnc" id="L1051" title="All 6 branches missed.">		if (pList == null || pList.isEmpty() || pSize == 0) {</span>
<span class="nc" id="L1052">			return new List[]{};</span>
		}
<span class="nc bnc" id="L1054" title="All 4 branches missed.">		if (pSize &lt; 0 || pSize &gt; pList.size()){</span>
<span class="nc" id="L1055">			return new List[]{pList};</span>
		}
		// Calculate the number of batches
<span class="nc" id="L1058">		int numBatches = (pList.size() / pSize) + 1;</span>
		// Create a new array of Lists to hold the return value
<span class="nc" id="L1060">		List[] batches = new List[numBatches];</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">		for (int index = 0; index &lt; numBatches; index++) {</span>
<span class="nc" id="L1062">			int count = index + 1;</span>
<span class="nc" id="L1063">			int fromIndex = Math.max(((count - 1) * pSize), 0);</span>
<span class="nc" id="L1064">			int toIndex = Math.min((count * pSize), pList.size());</span>
<span class="nc" id="L1065">			batches[index] = pList.subList(fromIndex, toIndex);</span>
		}
<span class="nc" id="L1067">		return batches;</span>
	}

	private boolean isGreaterThanMaxAllowedLength(TOHoursPerDay hrsPerDay) {
<span class="fc" id="L1071">		long timeIndays = -1;</span>
<span class="pc bpc" id="L1072" title="1 of 2 branches missed.">		if (hrsPerDay != null) {</span>
<span class="fc" id="L1073">			timeIndays = (hrsPerDay.getEndTime().getTime() - hrsPerDay.getStartTime().getTime()) / ONEDAYINMILLISECS;</span>
		}
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">		return (timeIndays &gt; getMaxAlowedTOLength());</span>
	}

<span class="fc" id="L1078">	private static Integer maxLengthInDays = null;</span>

	private static long getMaxAlowedTOLength() {
		try {
<span class="fc bfc" id="L1082" title="All 2 branches covered.">			if (maxLengthInDays == null) {</span>
<span class="fc" id="L1083">				int maxLenInDays = BbmManagerFactory.getDBConfigManager(false).getIntValue(&quot;HOURS_PER_DAY_MAX_TO_LENGTH&quot;);</span>
<span class="pc bpc" id="L1084" title="1 of 2 branches missed.">				if (maxLenInDays &lt; 0) {</span>
<span class="fc" id="L1085">					maxLenInDays = 100;</span>
				}
<span class="fc" id="L1087">				maxLengthInDays = new Integer(maxLenInDays);</span>
			}
<span class="fc" id="L1089">			return maxLengthInDays.intValue();</span>
<span class="nc" id="L1090">		} catch (Exception e) {</span>
<span class="nc" id="L1091">			LOG.debug(e);</span>
<span class="nc" id="L1092">			return 100;</span>
		}
	}

	private int getMaxEmpRefreshSize() {
<span class="nc" id="L1097">		int maxEmpRefreshSize = 100;</span>
		try {
<span class="nc" id="L1099">			maxEmpRefreshSize = BbmManagerFactory.getDBConfigManager(false).getIntValue(&quot;HOURS_PER_DAY_MAX_EMP_REFRESH_SIZE&quot;);</span>
<span class="nc bnc" id="L1100" title="All 2 branches missed.">			if (maxEmpRefreshSize &lt; 0) {</span>
<span class="nc" id="L1101">				maxEmpRefreshSize = 100;</span>
			}
<span class="nc" id="L1103">		} catch (Exception e) {</span>
<span class="nc" id="L1104">			LOG.debug(e);</span>
<span class="nc" id="L1105">		}</span>
<span class="nc" id="L1106">		return maxEmpRefreshSize;</span>
	}

	private void updateHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(int msgType, Collection empIds, Collection activityIdCol, Date endDate) throws BbmUpdateException {
<span class="fc" id="L1110">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="fc" id="L1112">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L1113">			refreshAndUpdateTOHoursPerDay(msgType, toHoursPerDayDAO.getHoursPerDayForEmpsBetweenLastPubDateAndGivenDate(empIds, activityIdCol, TOHoursPerDayUtil.getDateForDaysAfter(endDate, 7, null)), true, false);</span>
			/*
			for (Iterator iterator = empIds.iterator(); iterator.hasNext();) {
				ID empID = (ID) iterator.next();
				updateTOHoursPerDayForEmp(empID, null);
			}*/
<span class="nc" id="L1119">		} catch (Exception e) {</span>
<span class="nc" id="L1120">			handleException(e);</span>
<span class="nc" id="L1121">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L1123" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L1124">				toHoursPerDayDAO.cleanUp();</span>
			}
		}

<span class="fc" id="L1128">	}</span>

<span class="fc" id="L1130">	class EmpHrsPerDayCol {</span>
		ID empID;
<span class="fc" id="L1132">		Date startDate = null;</span>
<span class="fc" id="L1133">		Date endDate = null;</span>
<span class="fc" id="L1134">		Set hrsPerDaySet = new TreeSet();</span>

		void add(TOHoursPerDay hrsPerDay) {
<span class="fc bfc" id="L1137" title="All 2 branches covered.">			if (empID == null) {</span>
<span class="fc" id="L1138">				empID = hrsPerDay.getEmployeeID();</span>
			}
<span class="fc bfc" id="L1140" title="All 4 branches covered.">			startDate = (startDate == null || startDate.after(hrsPerDay.getStartTime()) ? hrsPerDay.getStartTime() : startDate);</span>
<span class="pc bpc" id="L1141" title="1 of 4 branches missed.">			endDate = (endDate == null || endDate.before(hrsPerDay.getEndTime()) ? hrsPerDay.getEndTime() : endDate);</span>
<span class="fc bfc" id="L1142" title="All 2 branches covered.">			if (hrsPerDaySet.contains(hrsPerDay)) {</span>
<span class="pc bpc" id="L1143" title="1 of 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1144">					LOG.info(&quot;hrsPerDaySet already contains this row=&quot; + hrsPerDay);</span>
				}
			} else {
<span class="fc" id="L1147">				hrsPerDaySet.add(hrsPerDay);</span>
			}

<span class="fc" id="L1150">		}</span>
	}

	protected static TORequestManager getTORequestManager() throws BbmCreateException {
<span class="nc" id="L1154">		return RmManagerFactory.getInstance(true).getTimeOffRequestManager();</span>
	}

	public Collection getAllDirtyTOHoursPerDay(Collection empIDs) throws BbmFinderException {
<span class="nc" id="L1158">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1159">		Collection returnCol = new ArrayList();</span>
		try {
<span class="nc" id="L1161">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1162">			returnCol = toHoursPerDayDAO.getAllDirtyTOHoursPerDay(empIDs);</span>
<span class="nc" id="L1163">		} catch (Exception e) {</span>
<span class="nc" id="L1164">			handleException(e);</span>
<span class="nc" id="L1165">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1167" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1168">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1171">		return returnCol;</span>
	}

	public int getCountOfAllDirtyTOHoursPerDay() throws BbmFinderException {
<span class="fc" id="L1175">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L1176">		int retVal = -1;</span>
		try {
<span class="fc" id="L1178">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L1179">			retVal = toHoursPerDayDAO.getCountOfAllDirtyTOHoursPerDay();</span>
<span class="nc" id="L1180">		} catch (Exception e) {</span>
<span class="nc" id="L1181">			handleException(e);</span>
<span class="nc" id="L1182">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1184" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L1185">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L1188">		return retVal;</span>
	}

	private Map getTOCalcDataForEmpIDs(Set empIDsUncachedSet, Date startDate, Date endDate) throws Exception {
<span class="fc" id="L1192">		long currentime = new Date().getTime();</span>
<span class="fc" id="L1193">		ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="fc" id="L1194">		WorkResourceManager wrMgr = RequestUtil.getWorkResourceManager();</span>
		// readjust range to start and end of org week boundaries.
<span class="pc bpc" id="L1196" title="1 of 4 branches missed.">		Date adjStDate =  startDate==null|| startDate.after(new Date())? new Date():startDate;</span>
<span class="fc" id="L1197">		HashMap empOrgAssignment = wrMgr.getValidWorkResourceAssignments(empIDsUncachedSet, new LocalDate(adjStDate), new LocalDate(endDate), false);</span>
<span class="fc" id="L1198">		Collection empOrgs = new ArrayList();</span>
<span class="fc bfc" id="L1199" title="All 2 branches covered.">		for (Iterator iterator = empOrgAssignment.values().iterator(); iterator.hasNext(); empOrgs.addAll((Collection) iterator.next())) {</span>
			;
		}
<span class="fc" id="L1202">		long diff = new Date().getTime() - currentime;</span>
<span class="pc bpc" id="L1203" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1204">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getEmployeesReportingOrgs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1206">		Collection orgList = new ArrayList();</span>
<span class="fc" id="L1207">		orgList.addAll(TOHoursPerDayUtil.extractFieldSet(WorkResourceAssignmentFieldInfo.WRASSIGNMENT_ORGANIZATIONID, empOrgs));</span>
<span class="fc" id="L1208">		orgList.add(Organization.ROOT_ORG_ID_OBJ);</span>
<span class="fc" id="L1209">		HashMap orgIDMap = ValueObjectUtil.getIDObjectMap(wrMgr.getOrganizationsByIDs(orgList));</span>
<span class="fc" id="L1210">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1212">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationsByIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1214">		Date startDateX = null;</span>
<span class="fc" id="L1215">		Date endDateX = null;</span>
<span class="fc" id="L1216">		HashMap adjTimeRangeMap = new HashMap(orgIDMap.size() * 2);</span>
<span class="fc bfc" id="L1217" title="All 2 branches covered.">		for (Iterator iterator = orgIDMap.values().iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L1218">			Organization org = (Organization) iterator.next();</span>
<span class="fc" id="L1219">			Date m_adjStartDate = TimeOffLengthCalculatorHelper.expandTOCalcRangeStart(startDate, null, org);</span>
<span class="fc" id="L1220">			Date m_adjEndDate = TimeOffLengthCalculatorHelper.expandTOCalcRangeEnd(endDate, null, org);</span>
<span class="pc bpc" id="L1221" title="1 of 4 branches missed.">			startDateX = (startDateX == null || startDateX.after(m_adjStartDate) ? m_adjStartDate : startDateX);</span>
<span class="pc bpc" id="L1222" title="1 of 4 branches missed.">			endDateX = (endDateX == null || endDateX.before(m_adjEndDate) ? m_adjEndDate : endDateX);</span>
<span class="fc" id="L1223">			adjTimeRangeMap.put(org.getID(), new TimeRange(m_adjStartDate, m_adjEndDate));</span>
<span class="fc" id="L1224">		}</span>
<span class="fc" id="L1225">		HashMap hoosForOrgMap = wrMgr.getOrganizationHOOAssignments(orgIDMap.keySet(), startDateX, endDateX);</span>
<span class="fc" id="L1226">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1227" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1228">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationHOOAssignments=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
		
<span class="fc" id="L1231">		HolidayManager hm = BbmManagerFactory.getHolidayManager();</span>
<span class="fc" id="L1232">	    Map holidayMap = hm.getHolidays(orgIDMap.keySet(), new LocalDate(startDateX), new LocalDate(endDateX));</span>
		
<span class="fc" id="L1234">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1235" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1236">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getOrganizationsByIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1238">		HashMap empAllotmentMap = wrMgr.getTOAllotmentMapForEmpIDs(empIDsUncachedSet);</span>
		// bulk load published events (unavails, shifts) for all org employees.
<span class="fc" id="L1240">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1241" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1242">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getTOAllotmentMapForEmpIDs=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1244">		List pubShiftAssnEvtsForEmps = sam.getPublishedEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT | Event.EVENT_TYPE_TIME_OFF,</span>
		        empIDsUncachedSet, startDateX, endDateX);
<span class="fc" id="L1246">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1247" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1248">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getPublishedEventsForWorkResourcesByType size=&quot; + pubShiftAssnEvtsForEmps.size() + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

<span class="fc" id="L1251">		List unavailEvtsForEmps = sam.getEventsForWorkResourcesByType(Event.EVENT_TYPE_UNAVAILABILITY, empIDsUncachedSet, startDateX, endDateX);</span>
<span class="fc" id="L1252">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1253" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1254">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.getEventsForWorkResourcesByType=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

		// segregate the bulk loaded events by empID and eventType.
<span class="fc" id="L1258">		Map empIDToUnavailsPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>
<span class="fc" id="L1259">		Map empIDToShiftAssnsPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>
<span class="fc" id="L1260">		Map empIDToTimeOffPubMap = new HashMap(empIDsUncachedSet.size() * 2);</span>

		//To reuse the moved moved to ToCalUtil
<span class="fc" id="L1263">		TOCalcUtil.segregateBulkLoadedEvts(empIDsUncachedSet, pubShiftAssnEvtsForEmps, empIDToShiftAssnsPubMap, empIDToTimeOffPubMap);</span>
<span class="fc" id="L1264">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1265" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1266">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.segregateBulkLoadedEvts=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

<span class="fc" id="L1269">		TOCalcUtil.createUnavailsMap(empIDsUncachedSet, unavailEvtsForEmps, empIDToUnavailsPubMap);</span>
<span class="fc" id="L1270">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1271" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1272">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.createUnavailsMap=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}

		// fetch the last shift assignments for employees
<span class="fc" id="L1276">		Map empIDToLastShiftAssnMap = TOCalcUtil.getLastShiftAssignmentsForEmpIDs(empIDsUncachedSet, true, sam);</span>
<span class="fc" id="L1277">		Map empIdTerminationDateMap = wrMgr.getTerminatedEmployees(empIDsUncachedSet);</span>
<span class="fc" id="L1278">		diff = new Date().getTime() - (currentime + diff);</span>
<span class="pc bpc" id="L1279" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1280">			LOG.info(&quot;\t\t$$$$TOTAL TIME FOR getTOCalcDataForEmpIDs.empIDToLastShiftAssnMap=&quot; + &quot;\tELAP=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1282">		HashMap bulkDataMap = new HashMap(12);</span>
<span class="fc" id="L1283">		bulkDataMap.put(&quot;orgIDMap&quot;, orgIDMap);</span>
<span class="fc" id="L1284">		bulkDataMap.put(&quot;empOrgAssignment&quot;, empOrgAssignment);</span>
<span class="fc" id="L1285">		bulkDataMap.put(&quot;empIDToLastShiftAssnMap&quot;, empIDToLastShiftAssnMap);</span>
<span class="fc" id="L1286">		bulkDataMap.put(&quot;empAllotmentMap&quot;, empAllotmentMap);</span>
<span class="fc" id="L1287">		bulkDataMap.put(&quot;adjTimeRangeMap&quot;, adjTimeRangeMap);</span>
<span class="fc" id="L1288">		bulkDataMap.put(&quot;empIDToShiftAssnsPubMap&quot;, empIDToShiftAssnsPubMap);</span>
<span class="fc" id="L1289">		bulkDataMap.put(&quot;empIDToUnavailsPubMap&quot;, empIDToUnavailsPubMap);</span>
<span class="fc" id="L1290">		bulkDataMap.put(&quot;empIDToTimeOffPubMap&quot;, empIDToTimeOffPubMap);</span>
<span class="fc" id="L1291">		bulkDataMap.put(&quot;hoosForOrgMap&quot;, hoosForOrgMap);</span>
<span class="fc" id="L1292">		bulkDataMap.put(&quot;holidayMap&quot;, holidayMap);</span>
<span class="fc" id="L1293">		bulkDataMap.put(&quot;empIdTerminationDateMap&quot;, empIdTerminationDateMap);</span>
<span class="pc bpc" id="L1294" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1295">			LOG.info(&quot;TOTAL TIME FOR building CALC DATA=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="fc" id="L1297">		return bulkDataMap;</span>
	}

<span class="fc" id="L1300">	static ShiftAssignment defaultLastShift = TOCalcUtil.getDefaultLastShift();</span>

	public boolean checkHealth() throws BbmFinderException {
<span class="fc" id="L1303">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L1304">		boolean retVal = false;</span>
		try {
<span class="fc" id="L1306">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L1307">			retVal = toHoursPerDayDAO.checkHealth();</span>
<span class="nc" id="L1308">		} catch (Exception e) {</span>
<span class="nc" id="L1309">			handleException(e);</span>
<span class="nc" id="L1310">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1312" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L1313">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L1316">		return retVal;</span>
	}

	public HashMap getSumOfAccountedHoursForDateRange(ID empID, HashMap activitySummaryMap, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L1320">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="nc" id="L1322">			toHoursPerDayDAO.getHoursPerDayContainedInDateRange(activitySummaryMap, empID, startDate, endDate, true);</span>
<span class="nc" id="L1323">			toHoursPerDayDAO.getHoursPerDayContainedInDateRange(activitySummaryMap, empID, startDate, endDate, false);</span>
			//process scheduled/taken time- off that cross the year boundaries.
<span class="nc" id="L1325">			Collection scheduleOrTakenTimeOffEvents = null;</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">			if (scheduleOrTakenTimeOffEvents != null) {</span>
<span class="nc bnc" id="L1327" title="All 2 branches missed.">				for (Iterator it = scheduleOrTakenTimeOffEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1328">					TOHoursPerDay hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc" id="L1329">					boolean isToEvtStartBeforeStart = hoursPerDay.getStartTime().before(startDate);</span>
<span class="nc" id="L1330">					boolean isToEvtEndAfterEnd = hoursPerDay.getEndTime().after(endDate);</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">					DailyHoursBuckets dailyBuckets = TOHoursPerDayUtil.getDailyHoursBucketsForDateRange(null, hoursPerDay,</span>
<span class="nc bnc" id="L1332" title="All 2 branches missed.">					        isToEvtStartBeforeStart ? startDate : hoursPerDay.getStartTime(),</span>
<span class="nc" id="L1333">					        isToEvtEndAfterEnd ? endDate : hoursPerDay.getEndTime());</span>
<span class="nc" id="L1334">					float usedHoursForTOYear = dailyBuckets.getTotalHours();</span>
<span class="nc" id="L1335">				}</span>
			}
			// At this point, the total, used and scheduled fields are filled in.  We can calculate the remaining hours
<span class="nc bnc" id="L1338" title="All 2 branches missed.">			for (Iterator it = activitySummaryMap.values().iterator(); it.hasNext();) {</span>
<span class="nc" id="L1339">				TimeOffActivitySummary summary = (TimeOffActivitySummary) it.next();</span>
<span class="nc" id="L1340">				summary.setRemaining(summary.getTotal() - summary.getUsed() - summary.getScheduled());</span>
<span class="nc" id="L1341">			}</span>
<span class="nc" id="L1342">		} catch (Exception e) {</span>
<span class="nc" id="L1343">			handleException(e);</span>
<span class="nc" id="L1344">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1346" title="All 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="nc" id="L1347">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1350">		return activitySummaryMap;</span>
	}

	public void lockRecords(TONotifyMessage msgObj) throws BbmUpdateException {
<span class="fc" id="L1354">		LOG.debug(&quot;from TOHoursPerDayManagerEJB; before lockRecords uniqID=&quot; + msgObj.getUniqID());</span>
<span class="fc" id="L1355">		int returnVal = msgObj.lockRecords();</span>
<span class="fc" id="L1356">		LOG.debug(&quot;from TOHoursPerDayManagerEJB; after lockRecords count=&quot; + returnVal + msgObj);</span>
<span class="pc bpc" id="L1357" title="2 of 4 branches missed.">		if (msgObj.isMessageForTOHoursPerDayUpdate() &amp;&amp; returnVal &lt; 1) {</span>
<span class="nc" id="L1358">			msgObj.setRetryDelivery(false); // no point in trying redeliver the message. It will always fail.</span>
<span class="nc" id="L1359">			throw new BbmUpdateException(&quot;Cannot lock or proceed with TOHoursUpdate;  lockRecords count=&quot; + returnVal + &quot; For:&quot; + msgObj);</span>
		}
<span class="fc" id="L1361">	}</span>

	public void lockEmployees(Collection empIDs) throws JdmoException {
<span class="fc" id="L1364">		Jdmo jdmo = null;</span>
		try {
<span class="fc" id="L1366">			jdmo = new Jdmo();</span>
<span class="fc" id="L1367">			jdmo.executeCommand(&quot; UPDATE EMPLOYEELASTPUBDATE SET ID = ID  WHERE ID IN &quot; + jdmo.createInClause(empIDs));</span>
		} finally {
<span class="pc bpc" id="L1369" title="3 of 4 branches missed.">			if (jdmo != null) {</span>
<span class="pc" id="L1370">				jdmo.cleanUp();</span>
			}
		}
<span class="fc" id="L1373">	}</span>

	public void syncTOHoursPerDay() throws BbmUpdateException {
<span class="fc" id="L1376">		StringBuffer strBuff = new StringBuffer();</span>
<span class="fc" id="L1377">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
		try {
<span class="fc" id="L1379">			ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="fc" id="L1380">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
			//Get Missing TOEvents
<span class="fc" id="L1382">			Collection col = toHoursPerDayDAO.getMissingTOEventsToBeSynced();</span>
<span class="pc bpc" id="L1383" title="2 of 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1384">				strBuff.append(&quot;Missing TOEVENTIDS: &quot; + RmUtil.dumpCollection(col));</span>
			}
<span class="pc bpc" id="L1386" title="3 of 6 branches missed.">			if (RequestUtil.isRMDebugEnabled() || (col != null &amp;&amp; !col.isEmpty())) {</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">				LOG.info(&quot; Syncing TimeOffEvent start :&quot; + (col != null ? &quot;&quot; + col.size() : &quot; NULL&quot;));</span>
			}
<span class="pc bpc" id="L1389" title="1 of 2 branches missed.">			for (Iterator iterator = col.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1390">				IDPair idPair = (IDPair) iterator.next();</span>
<span class="nc" id="L1391">				CalendarEventAssignment cAss = sam.getPublishedCalendarEventAssignmentByID((ID) idPair.getFirst());</span>
<span class="nc" id="L1392">				LOG.debug(&quot; Syncing TimeOffEvent for EMPID=&quot; + idPair.getSecond().toString() + &quot; EVENT=&quot; + cAss);</span>
<span class="nc" id="L1393">				getTOHoursPerDaysForTOEvent((ID) idPair.getSecond(), (TimeOffEvent) cAss);</span>
<span class="nc" id="L1394">			}</span>
<span class="pc bpc" id="L1395" title="3 of 6 branches missed.">			if (RequestUtil.isRMDebugEnabled() || (col != null &amp;&amp; !col.isEmpty())) {</span>
<span class="nc bnc" id="L1396" title="All 2 branches missed.">				LOG.info(&quot; Syncing TimeOffEvent end:&quot; + (col != null ? &quot;&quot; + col.size() : &quot; NULL&quot;));</span>
			}
<span class="fc" id="L1398">			col = toHoursPerDayDAO.getMissingEntriesInLastPubDate();</span>
<span class="pc bpc" id="L1399" title="2 of 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1400">				strBuff.append(&quot;Missing LASTPUBDATE: &quot; + RmUtil.dumpCollection(col));</span>
			}
			//Update Missing Entries in EMP LAST PUB DATE
<span class="pc bpc" id="L1403" title="3 of 6 branches missed.">			if (RequestUtil.isRMDebugEnabled() || (col != null &amp;&amp; !col.isEmpty())) {</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">				LOG.info(&quot; Syncing MissingEntries InLast PubDate start:&quot; + (col != null ? &quot;&quot; + col.size() : &quot; NULL&quot;));</span>
			}
<span class="pc bpc" id="L1406" title="2 of 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1407">				toHoursPerDayDAO.insertLastPublishedDate(col, null);</span>
<span class="nc" id="L1408">				toHoursPerDayDAO.refreshLastPublishedDate(col);</span>
			}
<span class="pc bpc" id="L1410" title="3 of 6 branches missed.">			if (RequestUtil.isRMDebugEnabled() || (col != null &amp;&amp; !col.isEmpty())) {</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">				LOG.info(&quot; Syncing MissingEntries InLast PubDate End:&quot; + (col != null ? &quot;&quot; + col.size() : &quot; NULL&quot;));</span>
			}
<span class="pc bpc" id="L1413" title="1 of 2 branches missed.">			if (strBuff.length() &gt; 10) {</span>
<span class="nc" id="L1414">				traceDebugData(null, strBuff.toString(), null, 0);</span>
			}

<span class="nc" id="L1417">		} catch (Exception e) {</span>
<span class="nc" id="L1418">			handleException(e);</span>
<span class="nc" id="L1419">			traceDebugData(null, strBuff.toString(), e, 0);</span>
<span class="nc" id="L1420">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L1422" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L1423">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L1426">	}</span>

	public void traceDebugData(String objectID, Object object, Exception e, int count) {
<span class="nc" id="L1429">		Jdmo jdmo = null;</span>
		try {
<span class="nc bnc" id="L1431" title="All 2 branches missed.">			if (&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(&quot;bluepumpkin/rm/traceDebugData/TOHoursPerDayManager&quot;))) {</span>
<span class="nc" id="L1432">				String sStackTraceStr = null;</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">				if (e != null) {</span>
<span class="nc" id="L1434">					StringWriter sStackTrace = new StringWriter();</span>
<span class="nc" id="L1435">					PrintWriter pStackTrace = new PrintWriter(sStackTrace);</span>
<span class="nc" id="L1436">					e.printStackTrace(pStackTrace);</span>
<span class="nc" id="L1437">					sStackTraceStr = sStackTrace.toString();</span>
				}

<span class="nc" id="L1440">				jdmo = new Jdmo();</span>
<span class="nc" id="L1441">				ArrayList colFieldValues = new ArrayList();</span>
<span class="nc" id="L1442">				String arrFieldNames[] = new String[]{&quot;OBJECTID&quot;, &quot;OBJECTDATA&quot;, &quot;STACKTRACE&quot;, &quot;ATWHEN&quot;, &quot;COUNT&quot;};</span>
<span class="nc" id="L1443">				int arrFieldTypes[] = {Types.VARCHAR, Types.VARCHAR, Types.VARCHAR, Types.TIMESTAMP, Types.INTEGER};</span>
<span class="nc bnc" id="L1444" title="All 4 branches missed.">				Object arrFieldValues[] = new Object[]{</span>
					(objectID != null) ? objectID : &quot;NULL&quot;,
<span class="nc" id="L1446">					(object != null) ? object.toString() : &quot;NULL&quot;,</span>
					sStackTraceStr, new Date(), new Integer(count)};
<span class="nc" id="L1448">				colFieldValues.add(arrFieldValues);</span>
<span class="nc" id="L1449">				jdmo.insertBatchAndExecute(&quot;BPTRACEDEBUGDATA&quot;, arrFieldNames, arrFieldTypes, colFieldValues);</span>
			}
<span class="nc" id="L1451">		} catch (Exception e2) {</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">			LOG.error(&quot;Trace TO notification handler exception failed \n&quot; +</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">			        &quot;Ex: &quot; + ((e != null) ? e.getMessage() : &quot; NULL&quot;) +</span>
<span class="nc" id="L1454">			        &quot;Msg: &quot; + ((object != null) ? object.toString() : &quot;NULL&quot;));</span>
		} finally {
<span class="nc bnc" id="L1456" title="All 6 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1457">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L1460">	}</span>

	public HashMap getHoursPerDayForRange(HashMap empStDateMap, HashMap empEnDateMap, Collection activityIDs) throws BbmFinderException {
<span class="nc" id="L1463">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="nc" id="L1464">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1465">		HashMap hrsPerDaySchedMap = new HashMap();</span>
<span class="nc" id="L1466">		Collection hrsPerDayCol = null;</span>
		try {
<span class="nc" id="L1468">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="nc" id="L1469">			hrsPerDaySchedMap = toHoursPerDayDAO.getHoursPerDayForRange(empStDateMap, empEnDateMap, activityIDs);</span>

<span class="nc" id="L1471">			hrsPerDayCol = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_CLEAN);</span>
<span class="nc bnc" id="L1472" title="All 2 branches missed.">			if (hrsPerDayCol == null) {</span>
<span class="nc" id="L1473">				hrsPerDayCol = new ArrayList();</span>
			}
<span class="nc" id="L1475">			Collection hrsPerDaySchedToUpdate = (Collection) hrsPerDaySchedMap.get(TOHoursPerDay.ISDIRTY_VAL_BOOLEAN_DIRTY);</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1477">				LOG.info(&quot;$$$$TOTAL TIME for FETCH ALL getHoursPerDayForRange=&quot; + (new Date().getTime() - currentime));</span>
			}

<span class="nc bnc" id="L1480" title="All 4 branches missed.">			if (hrsPerDaySchedToUpdate != null &amp;&amp; !hrsPerDaySchedToUpdate.isEmpty()) {</span>
<span class="nc" id="L1481">				refreshAndUpdateTOHoursPerDay(hrsPerDaySchedToUpdate, true);</span>
<span class="nc" id="L1482">				hrsPerDayCol.addAll(hrsPerDaySchedToUpdate);</span>
			}
<span class="nc" id="L1484">			hrsPerDaySchedMap = TOHoursPerDayUtil.groupByField(TOHoursPerDayFieldInfo.TIMEOFFHOURSPERDAY_I_EMPLOYEEID, hrsPerDayCol);</span>

<span class="nc" id="L1486">		} catch (Exception e) {</span>
<span class="nc" id="L1487">			handleException(e);</span>
<span class="nc" id="L1488">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1490" title="All 4 branches missed.">			if (toHoursPerDayDAO != null){</span>
<span class="nc" id="L1491">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="nc bnc" id="L1494" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1495">			LOG.info(&quot;TOTAL TIME for getHoursPerDayForRange=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; + hrsPerDayCol.size());</span>
		}
<span class="nc" id="L1497">		return hrsPerDaySchedMap;</span>
	}
	public Collection getOrderedTOWaitlists(TOPool pTOPool,  Collection empIds, Date stDate, Date enDate) throws BbmFinderException {
<span class="fc" id="L1500">		ArrayList arrItems = new ArrayList();</span>
<span class="fc" id="L1501">		TOHoursPerDayDAO toHoursPerDayDAO = null;</span>
<span class="fc" id="L1502">		long currentime = new Date().getTime();</span>
<span class="fc" id="L1503">		ArrayList hrsPerDayToUpdate= new ArrayList();</span>
		try {
<span class="fc" id="L1505">			toHoursPerDayDAO = new TOHoursPerDayDAO();</span>
<span class="fc" id="L1506">			String selectClause=toHoursPerDayDAO.getOrderedTOWaitlistsQry( pTOPool,  empIds,  stDate,  enDate) ;</span>
<span class="fc" id="L1507">			JdmoRowset rs = toHoursPerDayDAO.getDMO().createRowset(selectClause);</span>
<span class="pc bpc" id="L1508" title="1 of 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1509">				TOHoursPerDay item = (TOHoursPerDay) toHoursPerDayDAO.readObjectFromDB(rs);</span>
<span class="nc bnc" id="L1510" title="All 2 branches missed.">				if(item.getIsDirty()) {</span>
<span class="nc" id="L1511">					hrsPerDayToUpdate.add(item);</span>
				}
<span class="nc" id="L1513">				arrItems.add(new Pair(rs.getID(&quot;TIMEOFFREQUESTID&quot;), item));</span>
<span class="nc" id="L1514">			}</span>
<span class="pc bpc" id="L1515" title="2 of 4 branches missed.">			if (hrsPerDayToUpdate != null&amp;&amp; !hrsPerDayToUpdate.isEmpty()) {</span>
<span class="nc" id="L1516">				refreshAndUpdateTOHoursPerDay(hrsPerDayToUpdate, true);</span>
<span class="nc bnc" id="L1517" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1518">					LOG.info(&quot;TOTAL TIME for hrsPerDay refresh in getOrderedTOWaitlists=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; +  hrsPerDayToUpdate.size());</span>
				}
			}
<span class="nc" id="L1521">		} catch (Exception e) {</span>
<span class="nc" id="L1522">			handleException(e);</span>
<span class="nc" id="L1523">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L1525" title="3 of 4 branches missed.">			if (toHoursPerDayDAO != null) {</span>
<span class="pc" id="L1526">				toHoursPerDayDAO.cleanUp();</span>
			}
		}
<span class="pc bpc" id="L1529" title="1 of 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()){</span>
<span class="nc" id="L1530">			LOG.info(&quot;TOTAL TIME for getOrderedTOWaitlists=&quot; + (new Date().getTime() - currentime) + &quot;: TOTAL Obj =&quot; + arrItems.size());</span>
		}
<span class="fc" id="L1532">		return arrItems;</span>
	}


	/*
	 * A reference schedule assignment has changed (not published/unpublished), affecting the TORequestChoices passed in.
	 * We must update those choices.
	 */

	public void onReferenceScheduleChange(TONotifyMessage message, List&lt;ID&gt; choiceIDs) throws BbmUpdateException {
		try {
			
<span class="nc" id="L1544">			List&lt;TOHoursPerDay&gt; hrsPerColToUpdate = new ArrayList&lt;TOHoursPerDay&gt;();</span>

			// REFERENCE SCHEDULES
			// Get the HoursPerDay that are generated using reference schedules
			// (assuming this period may be referenced)
			// The dates may be wildly different from this period
<span class="nc" id="L1550">			Collection&lt;TOHoursPerDay&gt; listReferenceScheduleHoursPerDay = getHoursPerDayFromTOChoiceList(choiceIDs);</span>
<span class="nc" id="L1551">			hrsPerColToUpdate.addAll(listReferenceScheduleHoursPerDay);</span>

<span class="nc bnc" id="L1553" title="All 2 branches missed.">			if (!hrsPerColToUpdate.isEmpty()) {</span>
<span class="nc" id="L1554">				refreshAndUpdateTOHoursPerDay(hrsPerColToUpdate, true);</span>
			}

<span class="nc" id="L1557">		} catch (Exception e) {</span>
<span class="nc" id="L1558">			handleException(e);</span>
<span class="nc" id="L1559">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1560">		}finally {</span>
			
<span class="nc" id="L1562">		}</span>
<span class="nc" id="L1563">	}</span>

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>