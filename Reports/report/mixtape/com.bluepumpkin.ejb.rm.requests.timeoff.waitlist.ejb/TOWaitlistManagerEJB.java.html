<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOWaitlistManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb</a> &gt; <span class="el_source">TOWaitlistManagerEJB.java</span></div><h1>TOWaitlistManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.TimeZone;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityProperties;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestDAO;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;


<span class="fc" id="L64">public class TOWaitlistManagerEJB extends SessionEJBBase {     //OUTSIDE_CONTAINER</span>
<span class="fc" id="L65">	private static final String m_className = TOWaitlistManagerEJB.class.getName();</span>
<span class="fc" id="L66">	private static Category m_cat = Log.initCategory(TOWaitlistManagerEJB.m_className);</span>
	private static final long oneDayInMilliSecs = 24 * 60 * 60 * 1000;
	private static final int INVALID_MSG_NOTIFY_TYPE = -999;

	{
<span class="fc" id="L71">		super.init(TOWaitlistManagerEJB.class.getName());</span>
<span class="fc" id="L72">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L79">		return m_cat;</span>
	}

	public void deleteTOWaitlistRequestSetting(ID pTOWaitlistID) throws BbmRemoveException {
<span class="nc" id="L83">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L85">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L86">			toWaitlistDAO.deleteObject(pTOWaitlistID);</span>
		} finally {

<span class="nc bnc" id="L89" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L90">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L93">	}</span>

	public ID createTOWaitlistRequest(TOWaitlist pTOWaitlist) throws RmException, BbmCreateException {
<span class="nc" id="L96">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L98">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L99">			return toWaitlistDAO.createTOWaitlistRequest(pTOWaitlist);</span>
		} finally {
<span class="nc bnc" id="L101" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L102">				toWaitlistDAO.cleanUp();</span>
			}
		}
	}

	public TOWaitlist getTOWaitlistByTimeOffRequestId(ID toRequestId) throws BbmFinderException {
<span class="fc" id="L108">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="fc" id="L110">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="fc" id="L111">			return toWaitlistDAO.getWaitlistByTimeOffRequestId(toRequestId);</span>
		} finally {
<span class="pc bpc" id="L113" title="3 of 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="pc" id="L114">				toWaitlistDAO.cleanUp();</span>
			}
		}
	}


	public void updateStatusForExpiredTOWaitlistRequests() throws BbmUpdateException {
<span class="fc" id="L121">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="fc" id="L123">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="fc" id="L124">			Collection toReqIDCol = toWaitlistDAO.getWaitlistedTORequestIdsThatArePastExpiryDate();</span>
<span class="fc" id="L125">			TORequestManager toReqMgr = getTORequestManager();</span>
<span class="fc" id="L126">			long detailLevel = TORequest.DL_BASIC;</span>
<span class="fc" id="L127">			Collection toRequests = toReqMgr.getRequestsById(toReqIDCol, false, false, false, detailLevel);</span>
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">			for (Iterator iterator = toRequests.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L129">				TORequest toRequest = (TORequest) iterator.next();</span>
<span class="nc" id="L130">				toRequest.setRequestStatus(RequestAuditTrail.STATUS_DENIED);</span>
<span class="nc" id="L131">				toReqMgr.updateRequest(toRequest, RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED_WAITLIST_EXPIRYDATE), true);</span>
<span class="nc" id="L132">			}</span>
<span class="nc" id="L133">		} catch (Exception e) {</span>
<span class="nc" id="L134">			throw  new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L136" title="3 of 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="pc" id="L137">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L140">	}</span>

	public void scanAllTOWaitlistRequests() throws BbmUpdateException {
<span class="nc" id="L143">		TOWaitlistDAO toWaitlistDAO = null;</span>
		try {
<span class="nc" id="L145">			toWaitlistDAO = new TOWaitlistDAO();</span>
<span class="nc" id="L146">			Collection toReqIDCol = toWaitlistDAO.getAllWaitlistedTORequestIds();</span>
<span class="nc" id="L147">			TORequestManager toReqMgr = getTORequestManager();</span>
<span class="nc" id="L148">			final long detailLevel = TORequest.DL_AUDIT_TRAIL |</span>
			        TORequest.DL_TIMEOFF_CHOICES |
			        TORequest.DL_TIMEOFF_CHOICES_LENGTH |
			        TORequest.DL_TIMEOFF_WAITLIST;
<span class="nc bnc" id="L152" title="All 2 branches missed.">			for (Iterator iterator = toReqIDCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L153">				ID reqID = (ID) iterator.next();</span>
<span class="nc" id="L154">				TORequest toRequest = (TORequest) toReqMgr.getRequestByID(reqID, false, false, detailLevel);</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">				if (toRequest.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L156">					toReqMgr._autoProcess(toRequest, &quot;waitlist scan @ &quot; + new Date(), true);</span>
				}
<span class="nc" id="L158">			}</span>
<span class="nc" id="L159">		} catch (Exception e) {</span>
<span class="nc" id="L160">			throw  new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L162" title="All 4 branches missed.">			if (toWaitlistDAO != null) {</span>
<span class="nc" id="L163">				toWaitlistDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L166">	}</span>

	public Pair sortAndSetPriortyOrderForWaitlists(List reqIDsSorted, ID pTOPoolID, int sortColumn, String sortDirStr, long detailLevel, boolean runSoftValids) throws BbmException {
<span class="nc" id="L169">		TORequestDAO toDAO = null;</span>
<span class="nc" id="L170">		List sbReqsList = null;</span>
		try {
<span class="nc" id="L172">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L173">			TOPool toPool = toCalFacade.getTOPool(pTOPoolID);</span>
<span class="nc" id="L174">			Pair[] sortSeqPairArray = toPool.getTOWaitlistPriortyOrderSettings();</span>
			//if the Array is null then the Priority order need not be computed.
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (sortSeqPairArray != null) {</span>
<span class="nc" id="L177">				detailLevel |= TORequest.DL_AUDIT_TRAIL |</span>
				        TORequest.DL_TIMEOFF_CHOICES |
				        TORequest.DL_TIMEOFF_CHOICES_LENGTH |
				        TORequest.DL_TIMEOFF_WAITLIST | Request.DL_EMPLOYEE;
<span class="nc" id="L181">				toDAO = new TORequestDAO(detailLevel);</span>
<span class="nc" id="L182">				Collection sbReqs = getTORequestManager().getRequestsById(reqIDsSorted, false, runSoftValids, true, detailLevel);</span>
<span class="nc" id="L183">				sbReqsList = RequestUtil.getListFromCollection(sbReqs);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">				if (sbReqsList.size() &gt; 1) {//throws UnsupportedOperationException if the size is one</span>
<span class="nc" id="L185">					Collections.sort(sbReqsList, new TORequestUtil.TOWailistComparator(sortSeqPairArray));</span>
				}
<span class="nc bnc" id="L187" title="All 2 branches missed.">				for (int i = 0; i &lt; sbReqsList.size(); i++) {</span>
<span class="nc" id="L188">					TORequest toRequest = (TORequest) sbReqsList.get(i);</span>
<span class="nc" id="L189">					toRequest.setTOWaitlistPriorityOrder(i + 1);</span>
				}
				//Request Ids are already sorted in the database query but that is useless if requests need to be
				//sorted by Priority order, in that case we need to re-sort the reqIDsSorted collection
<span class="nc bnc" id="L193" title="All 2 branches missed.">				if (sortColumn == Request.SORT_TO_WAITLIST_PRIORITY_ORDER) {</span>
					//Reverse the list if the request need to be sorted in reverse order
<span class="nc bnc" id="L195" title="All 2 branches missed.">					if (RequestUtil.SORTDIR_DESC.equalsIgnoreCase(sortDirStr)) {</span>
<span class="nc" id="L196">						RequestUtil.getListReversed(sbReqsList);</span>
					}
<span class="nc" id="L198">					reqIDsSorted = new ArrayList();</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">					for (int i = 0; i &lt; sbReqsList.size(); i++) {</span>
<span class="nc" id="L200">						TORequest toRequest = (TORequest) sbReqsList.get(i);</span>
<span class="nc" id="L201">						reqIDsSorted.add(toRequest.getID());</span>
					}
				}
			}
<span class="nc" id="L205">		} catch (Exception e) {</span>
<span class="nc" id="L206">			handleException(e);</span>
<span class="nc" id="L207">			throw  new BbmException();</span>
		} finally {
<span class="nc bnc" id="L209" title="All 4 branches missed.">			if (toDAO != null) toDAO.cleanUp();</span>
<span class="nc" id="L210">			methodFinish();</span>
<span class="nc" id="L211">		}</span>
		//Please note that reqIDsSorted are sorted correctly but sbReqsList is not.
		//We expect the caller to use hashmap to get request for a given REQ ID.
<span class="nc" id="L214">		return new Pair(reqIDsSorted, sbReqsList);</span>
	}

	protected static CommonRequestManager getCommonRequestManager() throws BbmCreateException {
<span class="nc" id="L218">		return RmManagerFactory.getInstance(true).getCommonRequestManager();</span>
	}

	protected static TORequestManager getTORequestManager() throws BbmCreateException {
<span class="fc" id="L222">		return RmManagerFactory.getInstance(true).getTimeOffRequestManager();</span>
	}

	/**
	 * This method will return Ordered Time-Off Waitlist Requests falling in the given Date Range.
	 * The List will be ordered by the Priority Settings for the TOPool.
	 *
	 * @param pTOPool          ID for which order waitlists are required.
	 * @param startDate
	 * @param endDate
	 * @param checkForAutoScan
	 * @return Pair
	 * @throws BbmFinderException This method will return Ordered Time-Off Waitlist Requests falling in the given Date Range.
	 *                            The Returned Waitlists will depend upon the shared allocation hour Settings.
	 *                            If hours are shared then list will be returned for all Organizations sharing the hours.
	 *                            The List will be ordered by the Priority Settings of the Parent Org.
	 */
	public Pair getOrderedTOWaitlistsForTOPool(TOPool pTOPool, Date stDate, Date enDate, boolean checkForAutoScan) throws BbmFinderException {
		try {
<span class="pc bpc" id="L241" title="2 of 6 branches missed.">			if (!pTOPool.isWaitlistEnabled() || (checkForAutoScan &amp;&amp; !pTOPool.isIsWaitlistscan())) {</span>
				//Return  empty list because waitlist is not enabled or checkForAutoScan is true and waitlist scan is not enabled
<span class="fc" id="L243">				return new Pair(Collections.EMPTY_LIST, null);</span>
			}
<span class="fc" id="L245">			Collection empIDsFiltered = RmManagerFactory.getInstance(true).getTimeOffDayFacade().getEmployeeIDsForTOPool(pTOPool.getID(), stDate, enDate);</span>
<span class="pc bpc" id="L246" title="1 of 4 branches missed.">			if (empIDsFiltered == null || empIDsFiltered.isEmpty()) {</span>
<span class="fc" id="L247">				return new Pair(Collections.EMPTY_LIST, null);</span>
			}
<span class="fc" id="L249">			TOHoursPerDayManager hrsPerDayMgr = RmManagerFactory.getInstance(true).getTOHoursPerDayManager();</span>
<span class="fc" id="L250">			return new Pair(hrsPerDayMgr.getOrderedTOWaitlists(pTOPool, empIDsFiltered, stDate, enDate), empIDsFiltered);</span>
<span class="nc" id="L251">		} catch (Exception e) {</span>
<span class="nc" id="L252">			handleException(e, false);</span>
<span class="nc" id="L253">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

<span class="fc" id="L257">	private static final ID genericlock = new ID(-3001);</span>

	public void processWaitlistsForDecision(int msgNotifyType, ID pTOPoolID, Date startDate, Date endDate, boolean fullCheck) throws BbmException {
		try {
<span class="fc" id="L261">			CalendarTimeOffDayFacade ctodf = getCalendarTimeOffDayFacade();</span>
<span class="fc" id="L262">			TOPool pTOPool = ctodf.getTOPool(pTOPoolID);</span>
<span class="fc" id="L263">			RequestUtil.getTOWaitlistManager().processWaitlistsForDecision(msgNotifyType, pTOPool, startDate, endDate, fullCheck);</span>
<span class="nc" id="L264">		} catch (Exception e) {</span>
<span class="nc" id="L265">			e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.</span>
<span class="fc" id="L266">		}</span>
<span class="fc" id="L267">	}</span>

	private CalendarTimeOffDayFacade getCalendarTimeOffDayFacade() throws BbmCreateException {
<span class="fc" id="L270">		return RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
	}
	
	public void processWaitlistsForDecision(int msgNotifyType, TOPool toPool, Date startDate, Date endDate, boolean fullCheck) throws BbmException {
		try {
<span class="fc" id="L275">			ID toPoolID = toPool.getID();</span>
<span class="fc" id="L276">			m_cat.debug(&quot;processWaitlistsForDecision toPoolID=&quot; + toPoolID + &quot; :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);</span>
			/* bug fixfor timezone issue bug# 94621; sameet 2007;
			/* advance the end date by one day and rollback the start date by one day to account for all time zones of the user requests)*/
<span class="fc" id="L279">			long timeStart = Calendar.getInstance().getTimeInMillis();</span>
<span class="pc bpc" id="L280" title="1 of 2 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L281">				m_cat.info(&quot; PERF, BEFORE synchronized(orgLock),toPoolID=&quot; + toPoolID + &quot; :&quot;</span>
<span class="nc" id="L282">						+ ((Calendar.getInstance().getTimeInMillis() - timeStart)) + &quot; Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot;</span>
						+ endDate);
			}
<span class="fc" id="L285">			timeStart = Calendar.getInstance().getTimeInMillis();</span>

<span class="fc" id="L287">			synchronized (genericlock) {</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">				if (startDate != null) {</span>
<span class="fc" id="L289">					startDate = new Date(startDate.getTime() - oneDayInMilliSecs);</span>
				} else {
<span class="fc" id="L291">					startDate = new Date();</span>
				}
<span class="fc bfc" id="L293" title="All 2 branches covered.">				if (endDate != null) {</span>
<span class="fc" id="L294">					endDate = new Date(endDate.getTime() + oneDayInMilliSecs);</span>
					
				} else {
<span class="fc" id="L297">					endDate = new Date(RequestUtil.MAX_DATE.getTime());</span>
				}
				
				// get time-off waitlist requests for pool in the waitlist scan date range. 				
<span class="fc" id="L301">				Pair pair = RequestUtil.getTOWaitlistManager().getOrderedTOWaitlistsForTOPool(toPool, startDate, endDate, true);</span>
				
				@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L304">				Collection&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt; wlCol = (Collection&lt;Pair&lt;ID, TOHoursPerDay&gt;&gt;) pair.getFirst();</span>
<span class="pc bpc" id="L305" title="2 of 4 branches missed.">				if (wlCol == null || wlCol.isEmpty()) {</span>
<span class="fc" id="L306">					m_cat.info(&quot; PERF, No Waitlisted Requests to scan ,toPoolID=&quot; + toPoolID + &quot; :&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) + &quot; Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);</span>
<span class="fc" id="L307">					return;</span>
				}
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">					m_cat.info(&quot; PERF, after _getOrderedTOWaitlistsForOrg,&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) + &quot; Msecs size=&quot; + (wlCol != null ? wlCol.size() : 0));</span>
				}
<span class="nc" id="L312">				Collection orgEmpIDs = (Collection) pair.getSecond();</span>
				
				
				// get max start/end time range by looking at all wait-listed time off requests start/end date.
<span class="nc" id="L316">				TimeRange maxDateRange = null;</span>
<span class="nc bnc" id="L317" title="All 2 branches missed.">				for (Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair : wlCol) {</span>
<span class="nc" id="L318">					TOHoursPerDay item = reqIDHrsPerDayPair.getSecond();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">					if (maxDateRange == null) {</span>
<span class="nc" id="L320">						maxDateRange = new TimeRange(item.getStartTime(), item.getEndTime());</span>
					}
<span class="nc bnc" id="L322" title="All 2 branches missed.">					if (maxDateRange.getStartDate().after(item.getStartTime())) {</span>
<span class="nc" id="L323">						maxDateRange.setStartDate(item.getStartTime());</span>
					}
<span class="nc bnc" id="L325" title="All 2 branches missed.">					if (maxDateRange.getEndDate().before(item.getEndTime())) {</span>
<span class="nc" id="L326">						maxDateRange.setEndDate(item.getEndTime());</span>
					}
<span class="nc" id="L328">				}</span>
				
				// get org associated with the pool
<span class="nc" id="L331">				Organization org = CacheUtilBBM.getOrganizationByID(toPool.getOrganizationId());</span>
				
				// Use the max start/date time range encompassing all wait-listed time off requests to audit.
				
				// get scheduled TO hours for pool for this max date range to use in audit before processing wait-listed TOs 			
<span class="nc" id="L336">				DailyHoursBuckets beforeScanScheduledTOHours = TOCalendarUtil.getTOScheduledData(toPoolID, org, maxDateRange, null);</span>
				
				// get allocated TO hours for pool for this max date range
<span class="nc" id="L339">				DailyHoursBuckets allocatedTOHours = TOCalendarUtil.getTOAllocatedData(toPoolID, org, maxDateRange);</span>
				
		        // get TO pools for all emps (again look back over a year from start of waitlist scan date)
<span class="nc" id="L342">				Date minStDate = TOCalendarUtil.getBackAyearforDate(maxDateRange.getStartDate());</span>
<span class="nc" id="L343">				HashMap wras = RequestUtil.getTOWaitlistManager().getWorkResourceAssignments(org, orgEmpIDs, minStDate, maxDateRange.getEndDate());</span>
<span class="nc" id="L344">				HashMap empTOPoolAssnMap = getCalendarTimeOffDayFacade().getTOPoolsForWorkResources(orgEmpIDs, minStDate, maxDateRange.getEndDate());</span>
				

<span class="nc" id="L347">				timeStart = Calendar.getInstance().getTimeInMillis();</span>
<span class="nc" id="L348">				TORequestManager toReqMgr = getTORequestManager();</span>
<span class="nc" id="L349">				Date today = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;)).getTime();</span>
<span class="nc" id="L350">				long detailLevel = RequestAggregate.getDetailLevelForValidation(Request.REQUESTTYPE_TIMEOFF);</span>
<span class="nc" id="L351">				int count = 0;</span>
<span class="nc" id="L352">				DailyHoursBuckets availTOHours = null;</span>
				

				// iterate over the wait-list TO requests and if there are available hours approve time off request, else deny
<span class="nc bnc" id="L356" title="All 2 branches missed.">				for (Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair : wlCol) {</span>
					try {

<span class="nc bnc" id="L359" title="All 4 branches missed.">						if (!fullCheck &amp;&amp; availTOHours == null) {</span>
<span class="nc" id="L360">							availTOHours = getAvailableHoursForDailyTOPool(toPool, org, maxDateRange, allocatedTOHours);</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">							if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L362">								m_cat.info(&quot;getAvailableHoursForTOPool;loaded=&quot; + count++);</span>
							}
						}
<span class="nc bnc" id="L365" title="All 2 branches missed.">						if (fullCheck</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">								|| checkAvailableHrsForDailyPool(toPoolID, org, availTOHours,</span>
<span class="nc" id="L367">										reqIDHrsPerDayPair.getSecond(), wras, empTOPoolAssnMap)) {</span>

<span class="nc" id="L369">							TORequest req = (TORequest) toReqMgr.getRequestByID(reqIDHrsPerDayPair.getFirst(), false, false, detailLevel);</span>

<span class="nc bnc" id="L371" title="All 2 branches missed.">							if (isWaitListedAndNotExpired(today, req)) {</span>
<span class="nc" id="L372">								logFullCheck(fullCheck, reqIDHrsPerDayPair, req);</span>
<span class="nc" id="L373">								availTOHours = runAutoProcessing(toReqMgr, today, availTOHours, req);</span>
							} else {
<span class="nc" id="L375">								toReqMgr.denyRequest(req, RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED_WAITLIST_EXPIRYDATE));</span>
							}
						}

<span class="nc" id="L379">					} catch (Exception e) {</span>
<span class="nc" id="L380">						m_cat.info(&quot;Exception thrown for Request=&quot; + reqIDHrsPerDayPair.getFirst());</span>
<span class="nc" id="L381">						handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L382">						continue;</span>
<span class="nc" id="L383">					}</span>
<span class="nc" id="L384">				}</span>

				// get scheduled TO hours for pool for this max date range to use in audit after processing wait-listed TOs, 
				// only if the scheduled TO hours changed during processing of the wait-listed TO requests.
<span class="nc" id="L388">				DailyHoursBuckets afterScanScheduledTOHours = TOCalendarUtil.getTOScheduledData(toPoolID, org, maxDateRange, null);</span>
				
				// audit calendar state after processing wait-listed TO requests.
<span class="nc" id="L391">				auditWaitlistScan(msgNotifyType, toPool, maxDateRange.getStartDate(), maxDateRange.getEndDate(), </span>
<span class="nc" id="L392">							TOCalendarUtil.getTOCalendar(allocatedTOHours, beforeScanScheduledTOHours, afterScanScheduledTOHours));</span>
							
<span class="nc bnc" id="L394" title="All 2 branches missed.">				if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">					m_cat.info(&quot; PERF, after synch&amp;autoprocess complete toPoolID=&quot; + toPoolID + &quot;;fullCheck=&quot; + fullCheck +</span>
<span class="nc" id="L396">					        &quot;:No of Rows=&quot; + (wlCol != null ? wlCol.size() : 0) + &quot;:,&quot; + ((Calendar.getInstance().getTimeInMillis() - timeStart)) +</span>
					        &quot;:Msecs :startDate=&quot; + startDate + &quot; :endDate=&quot; + endDate);
				}
<span class="nc" id="L399">			}</span>
<span class="nc" id="L400">		} catch (Exception e) {</span>
<span class="nc" id="L401">			handleException(e);</span>
<span class="nc" id="L402">			throw new BbmException(e);</span>
<span class="nc" id="L403">		}</span>
<span class="nc" id="L404">	}</span>

	private DailyHoursBuckets runAutoProcessing(TORequestManager toReqMgr, Date today, DailyHoursBuckets availTOHours, TORequest req)
			throws BbmUpdateException, RmHardValidationException, MultiUserException, RemoteException {

<span class="nc" id="L409">		Pair result = toReqMgr._autoProcess(req, &quot;waitlist scan @ &quot; + today, true);</span>

<span class="nc bnc" id="L411" title="All 6 branches missed.">		if (result != null &amp;&amp; Boolean.getBoolean(result.getFirst().toString()) &amp;&amp; result.getSecond() != null) {</span>
			//reload from db to check if request is approved
<span class="nc bnc" id="L413" title="All 2 branches missed.">			m_cat.info(&quot;OLDSTATUS=&quot; + (req != null ? req.getID() + &quot; &quot; + req.getRequestStatus() : &quot;NULL&quot;) + &quot;:NEWSTATUS=&quot;</span>
<span class="nc" id="L414">					+ result.getSecond());</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">			if (result.getSecond().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L416">				m_cat.info(&quot;Approved Request in Waitlist scan; REQ=&quot; + req);</span>
<span class="nc" id="L417">				return null;</span>
			}
		}
<span class="nc" id="L420">		return availTOHours;</span>
	}

	private void logFullCheck(boolean fullCheck, Pair&lt;ID, TOHoursPerDay&gt; reqIDHrsPerDayPair, TORequest req) {
<span class="nc bnc" id="L424" title="All 2 branches missed.">		if (!fullCheck) {</span>
<span class="nc" id="L425">			m_cat.info(&quot;fullCheck=&quot; + fullCheck + &quot;: Req has avail hours TOChoice=&quot; + req.getWaitlistTOChoice().getID()</span>
<span class="nc" id="L426">					+ &quot;:EMPID=&quot; + req.getEmployeeID() + &quot;: ACCT MINS=&quot; + reqIDHrsPerDayPair.getSecond().getTotalMinutes()</span>
<span class="nc" id="L427">					+ &quot;: ST=&quot; + req.getWaitlistTOChoice().getStartDate() + &quot;:END=&quot; + req.getWaitlistTOChoice().getEndDate());</span>
		}
<span class="nc" id="L429">	}</span>

	private boolean isWaitListedAndNotExpired(Date today, TORequest req) {
<span class="nc bnc" id="L432" title="All 4 branches missed.">		return req.isWaitlisted() &amp;&amp; today.before(req.getWaitlistInfo().getTOWaitlistExpiryDate());</span>
	}

	public HashMap getWorkResourceAssignments(Organization org, Collection orgEmpIDs, Date startDate, Date endDate) throws BbmException {
		try {
<span class="nc" id="L437">			return RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(orgEmpIDs,</span>
<span class="nc" id="L438">			        new LocalDate(startDate, org.getTimeZone()),</span>
<span class="nc" id="L439">			        new LocalDate(endDate, org.getTimeZone()), false);</span>
<span class="nc" id="L440">		} catch (Exception e) {</span>
<span class="nc" id="L441">			throw new BbmException(e);</span>
		}
	}

	/**
	 * Audit time off pool's calendar after processing wait-listed TO requests.
	 * @param msgNotifyType
	 * @param toPool
	 * @param auditStDate
	 * @param auditEndDate
	 * @param toCalendar
	 */
	private void auditWaitlistScan(int msgNotifyType, TOPool toPool, Date auditStDate, Date auditEndDate, String toCalendar) {
<span class="nc" id="L454">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
													AuditTrailEntry.ACTION_TIME_OFF_POOL_WAITLISTSCAN,
<span class="nc" id="L456">													toPool.getId(), toPool.getName(), auditStDate, auditEndDate);</span>
		try {
<span class="nc" id="L458">			String notifyType = TONotifyMessage.getNotifyString(msgNotifyType);</span>
			
<span class="nc" id="L460">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF_POOL, toCalendar, notifyType, false);</span>
			
<span class="nc" id="L462">			EventAuditTrailManager auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L463">			auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L464">		} catch (Exception e) {</span>
<span class="nc" id="L465">			m_cat.debug(&quot;unable to audit waitlist scan process for time off pool with id: &quot; + toPool.getId() + </span>
<span class="nc" id="L466">					&quot; because of exception : &quot; + e.getMessage());</span>
<span class="nc" id="L467">		} </span>
<span class="nc" id="L468">	}</span>
	
	private boolean checkAvailableHrsForDailyPool(ID pTOPoolID, Organization pTOPoolOrg, DailyHoursBuckets availBkts,
			TOHoursPerDay hrsPerDay, HashMap empWrs, HashMap empTOPoolAssnMap) throws Exception {

<span class="nc" id="L473">		boolean result = false;</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">		if (hrsPerDay == null || hrsPerDay.getTotalMinutes() &lt;= 0) {</span>
<span class="nc" id="L475">			m_cat.info(&quot;total minutes are zero or hrsperday is null=&quot; + hrsPerDay);</span>
<span class="nc" id="L476">			return result;</span>
		}

<span class="nc" id="L479">		Organization currOrg = TOCalendarUtil.getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">		if (currOrg == null) {</span>
<span class="nc" id="L481">			m_cat.info(&quot;employee has been terminated EMP=&quot; + hrsPerDay.getEmployeeID());</span>
<span class="nc" id="L482">			return result; //employee has been terminated or has been changed org and does not belong to the current requested list</span>
		}

<span class="nc" id="L485">		ID empTOPoolID = TOCalendarUtil.getTOPoolIDforDate(hrsPerDay.getStartTime(), (Collection) empTOPoolAssnMap.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">		if (empTOPoolID == null || !empTOPoolID.equals(pTOPoolID)) {</span>
<span class="nc" id="L487">			m_cat.debug(&quot;ignoring TOHoursPerday because employee does not belong to this TOPOOLId=&quot; + empTOPoolID</span>
			        + &quot;: on start date of this:&quot; + hrsPerDay);
<span class="nc" id="L489">			return result; //employee has  changed TOPool and does not belong to the current TOPOOL</span>
		}

<span class="nc bnc" id="L492" title="All 2 branches missed.">		if (requestActivityUsesIntervalPool(hrsPerDay)) {</span>
			//if the request uses the interval pool go ahead and run the approval process 
<span class="nc" id="L494">			return true;</span>
		}

<span class="nc" id="L497">		DailyHoursBuckets bkt = TOHoursPerDayUtil.getDailyHoursBuckets(pTOPoolOrg, hrsPerDay);</span>
		// Check that each &quot;day&quot; during request period has enough available hours for the pending request.
<span class="nc" id="L499">		Date firstShortDay = availBkts.checkAllocation(bkt);</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">		result = (firstShortDay == null);</span>
<span class="nc" id="L501">		return result;</span>
	}

	private boolean requestActivityUsesIntervalPool(TOHoursPerDay requestHrsPerDay) throws Exception { // NOSONAR

<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
<span class="nc" id="L507">			return false;</span>
		}

<span class="nc" id="L510">		ID activityID = requestHrsPerDay.getActivityID();</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">		if (activityID == null) {</span>
<span class="nc" id="L512">			return false;</span>
		}
<span class="nc" id="L514">		ActivityProperties property = TORequestUtil.getActivityProperties(activityID);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		if (property == null) {</span>
<span class="nc" id="L516">			return false;</span>
		}

<span class="nc" id="L519">		return property.isUseIntervalTOPool();</span>
	}

	private DailyHoursBuckets getAvailableHoursForDailyTOPool(TOPool pTOPool, Organization org, TimeRange toRange,
			DailyHoursBuckets allocHrs) throws Exception {
<span class="nc" id="L524">		long currentime = new Date().getTime();</span>
		
<span class="nc" id="L526">		DailyHoursBuckets availHrs = new DailyHoursBuckets(allocHrs);</span>
		// the buckets end date expanded to org day start and end
<span class="nc" id="L528">		Date stDate = availHrs.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L529">		Date enDate = availHrs.getDHBRangeEndAsOrgDayEnd();</span>
	
<span class="nc" id="L531">		TimeRange availTOHoursBktsForOrgTimeRange = new TimeRange(stDate, enDate);</span>
<span class="nc" id="L532">		Collection&lt;ID&gt; dailyPoolActivities = TOCalendarUtil.getListOfDailyPoolAllotmentActivities();</span>
<span class="nc" id="L533">		DailyHoursBuckets orgSched = TOCalendarUtil.getTOScheduledData(pTOPool.getID(), org, availTOHoursBktsForOrgTimeRange,</span>
				dailyPoolActivities);
<span class="nc" id="L535">		availHrs.subFromBucket(orgSched, stDate, enDate);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L537">			m_cat.info(&quot;TOTAL TIME for getAvailableHoursForDailyTOPool=&quot; + (new Date().getTime() - currentime));</span>
		}
<span class="nc" id="L539">		return availHrs;</span>
	}

	public void triggerWaitlistScanForEmployeeIDs(Collection empIDs, int msgNotifyType, Date minStartDate, Date maxEndDate, boolean scanForOneEmpOnly) throws BbmException {
		try {
<span class="fc" id="L544">			Collection pTOPoolCol = getCalendarTimeOffDayFacade().getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate);</span>
<span class="fc" id="L545">			processWaitlistsForDecision(msgNotifyType, pTOPoolCol, minStartDate, maxEndDate);</span>
<span class="nc" id="L546">		} catch (Exception e) {</span>
<span class="nc" id="L547">			handleException(e);</span>
<span class="nc" id="L548">			throw new BbmException(e);</span>
<span class="fc" id="L549">		}</span>
<span class="fc" id="L550">	}</span>

	/*DONE FOR TOPOOL*/
	public void processOrgWaitlistsForDecision(Collection orgIDs, int msgNotifyType, Date startDate, Date endDate) throws BbmException {
		try {
<span class="fc" id="L555">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="fc" id="L556">			Collection pTOPoolCol = toCalFacade.getTOPoolsForOrgIDs(orgIDs);</span>
<span class="fc" id="L557">			processWaitlistsForDecision(msgNotifyType, pTOPoolCol, startDate, endDate);</span>
<span class="nc" id="L558">		} catch (Exception e) {</span>
<span class="nc" id="L559">			handleException(e);</span>
<span class="nc" id="L560">			throw new BbmException(e);</span>
<span class="fc" id="L561">		}</span>
<span class="fc" id="L562">	}</span>

	private void processWaitlistsForDecision(int msgNotifyType, Collection toPoolSet, Date startDate, Date endDate) {
<span class="fc bfc" id="L565" title="All 2 branches covered.">		for (Iterator iterator = toPoolSet.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L566">			TOPool toPool = (TOPool) iterator.next();</span>
<span class="pc bpc" id="L567" title="3 of 6 branches missed.">			if (toPool != null &amp;&amp; toPool.isWaitlistEnabled() &amp;&amp; toPool.isIsWaitlistscan()) {</span>
				//This is needed for transaction level isolation, since this method requires new transaction.
				try {
<span class="fc" id="L570">					RequestUtil.getTOWaitlistManager().processWaitlistsForDecision(msgNotifyType, toPool, startDate, endDate, false);</span>
<span class="nc" id="L571">				} catch (Exception e) {</span>
<span class="nc" id="L572">					handleException(e);</span>
<span class="fc" id="L573">				}</span>
			}
<span class="fc" id="L575">		}</span>
<span class="fc" id="L576">	}</span>

	static final long detailLevel = TORequest.DL_AUDIT_TRAIL | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH | TORequest.DL_TIMEOFF_WAITLIST;

	public void processWaitlistScan(TONotifyMessage msgObj) throws BbmException {
<span class="fc bfc" id="L581" title="All 2 branches covered.">		if (!TORequestUtil.isTOWaitlistFeatureEnabled()) {</span>
<span class="fc" id="L582">			return;</span>
		}

<span class="fc" id="L585">		boolean cacheEnabled = false; </span>

		try {
<span class="fc" id="L588">			cacheEnabled = ThreadLocalCache.enable();</span>

<span class="fc" id="L590">			m_cat.debug(&quot;MDB TONotifyMessage: &quot; + msgObj);</span>
<span class="pc bpc" id="L591" title="4 of 9 branches missed.">			switch (msgObj.getNotificationType()) {</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_COMPLETE:
<span class="fc" id="L593">				triggerWaitlistScanForEmployeeIDs(msgObj.getEmployeeIDs(), msgObj.getNotificationType(), msgObj.getStartDate(),</span>
<span class="fc" id="L594">						msgObj.getEndDate(), false);</span>
<span class="fc" id="L595">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_ORG_CHANGE:
<span class="nc" id="L597">				triggerWaitlistScanForEmployeeIDs(msgObj.getEmployeeIDs(), msgObj.getNotificationType(), new Date(0), null, false);</span>
<span class="nc" id="L598">				break;</span>
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH:
			case TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_TO_ONLY: {
<span class="nc" id="L601">				ScheduleChangeDetails changeDetails = (ScheduleChangeDetails) msgObj.getObject();</span>
<span class="nc" id="L602">				triggerWaitlistScanForEmployeeIDs(changeDetails.getWorkResourceIDs(), msgObj.getNotificationType(),</span>
<span class="nc" id="L603">						changeDetails.getStartDate(), changeDetails.getEndDate(), false);</span>
<span class="nc" id="L604">				break;</span>
			}
			case TONotifyMessage.TO_NOTIFY_VALIDATION_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_FILING_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_AUTO_PROCESS_RULE_CHANGE:
			case TONotifyMessage.TO_NOTIFY_WAITLIST_SETTING_CHANGE:
<span class="fc" id="L610">				processOrgWaitlistsForDecision((HashSet) msgObj.getObject(), msgObj.getNotificationType(), null, null);</span>
<span class="fc" id="L611">				break;</span>
			case TONotifyMessage.TO_NOTIFY_ORG_BLACKOUTDAY_CHANGE:
<span class="nc" id="L613">				processOrgWaitlistsForDecision(Collections.singletonList(msgObj.getOrgId()), msgObj.getNotificationType(),</span>
<span class="nc" id="L614">						msgObj.getStartDate(), msgObj.getEndDate());</span>
<span class="nc" id="L615">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE:
			case TONotifyMessage.TO_NOTIFY_APPROVED_TOREQUEST_WITHDRAW:
			case TONotifyMessage.TO_NOTIFY_GENERIC_WAITLIST_MSG:
<span class="fc" id="L619">				processWaitlistsForDecision(msgObj.getNotificationType(), msgObj.getTOPoolId(), msgObj.getStartDate(), msgObj.getEndDate(),</span>
						false);
<span class="fc" id="L621">				break;</span>
			case TONotifyMessage.TO_NOTIFY_EMP_TOPOOL_CHANGE:
<span class="fc" id="L623">				processWaitlistsForDecision(msgObj.getNotificationType(), (Collection) msgObj.getObject(), msgObj.getStartDate(),</span>
<span class="fc" id="L624">						msgObj.getEndDate());</span>
<span class="fc" id="L625">				break;</span>
			case TONotifyMessage.TO_NOTIFY_TOPOOL_FULL_SCAN:
<span class="fc" id="L627">				processWaitlistsForDecision(msgObj.getNotificationType(), msgObj.getTOPoolId(), null, null, true);</span>
				break;

			}
		} finally {
<span class="pc" id="L632">			ThreadLocalCache.clear(cacheEnabled);</span>
<span class="fc" id="L633">		}</span>
<span class="fc" id="L634">	}</span>

	/**
	 * returns an int array containing rank of the request as 1st element and total waitlisted requests as 2n element
	 * for the range of the waitlisted request Id passed to this API.
	 *
	 * @param toReqID
	 * @return
	 */
	public int[] getWaitlistRank(ID toReqID) {
<span class="nc" id="L644">		int[] returnVal = new int[2];</span>
		try {
<span class="nc" id="L646">			TORequest tor = (TORequest) getTORequestManager().getRequestByID(toReqID, false, false, detailLevel);</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">			if (tor != null &amp;&amp; tor.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L648">				Pair pair = getOrderedTOWaitlistsForTOPool(tor.getValidationCache().getTOPool(),</span>
<span class="nc" id="L649">				        tor.getWaitlistTOChoice().getStartDate(), tor.getWaitlistTOChoice().getEndDate(), false);</span>
<span class="nc" id="L650">				Collection col = (Collection) pair.getFirst();</span>
<span class="nc" id="L651">				int count = 0;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">				for (Iterator iterator = col.iterator(); iterator.hasNext(); count++) {</span>
<span class="nc" id="L653">					Pair reqIDHrsPerDayPair = (Pair) iterator.next();</span>
<span class="nc bnc" id="L654" title="All 2 branches missed.">					if (reqIDHrsPerDayPair.getFirst().equals(toReqID)) {</span>
<span class="nc" id="L655">						returnVal[0] = count + 1;</span>
<span class="nc" id="L656">						returnVal[1] = col.size();</span>
					}
				}
			}
<span class="nc" id="L660">		} catch (Exception e) {</span>
<span class="nc" id="L661">			handleException(e);</span>
<span class="nc" id="L662">		}</span>
<span class="nc" id="L663">		return returnVal;</span>
	}

}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>