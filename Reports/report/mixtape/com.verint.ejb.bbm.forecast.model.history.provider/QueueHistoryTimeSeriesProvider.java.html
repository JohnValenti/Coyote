<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>QueueHistoryTimeSeriesProvider.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.model.history.provider</a> &gt; <span class="el_source">QueueHistoryTimeSeriesProvider.java</span></div><h1>QueueHistoryTimeSeriesProvider.java</h1><pre class="source lang-java linenums">package com.verint.ejb.bbm.forecast.model.history.provider;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.pulse.model.ForecastUsage;
import com.bluepumpkin.ejb.bbm.pulse.model.PulseNoteBO;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalFactory;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.verint.ejb.bbm.forecast.model.history.service.IHistoryDataService;
import com.verint.ejb.bbm.forecast.model.history.service.INotesDataService;

import java.util.*;

/**
 * Loads and caches history data for a single queue.
 */
public class QueueHistoryTimeSeriesProvider implements IHistoryProvider {

	protected final Queue queue;
	private final IHistoryDataService historyDataService;
	private final INotesDataService notesDataService;
	private final TimeIntervalFactory timeIntervalFactory;

	/**
	 * This map is a cache of time series history data by TimeIntervalAtTime for this queue.
	 * NOTE: if you are going to be referencing this field, please be aware that it may be accessed by multiple
	 * threads simultaneously.  Currently, only getHistory() and getHistoryDataByQueueID() access this field and
	 * these methods have been marked as synchronized to prevent any concurrency issues.
	 *
	 * key - TimeIntervalAtTime (duration of one day or one week), value - trace cube of the history for that day or week
	 * Note that both weekly and daily history is stored in this map.  When the user is picking a week to add, the calendar
	 * will load data in weekly chunks instead of days as that is faster.  However, ProfileEntryHistoryPeriods will construct
	 * history data by concatenating the history for each day in the interval into a week.  What we do then is when the history
	 * data for the entire week is cached (in the add historical week dialog via the calendar) we slice that weekly cube into days
	 * and cache those so the ProfileEntryHistoryPeriods don't have to go back to the server to retrieve the daily history data.
	 */
<span class="nc" id="L43">	private Map&lt;TimeIntervalAtTime, ActualTraceCube&gt; historyByTimeIntervalAtTime =</span>
			new HashMap&lt;TimeIntervalAtTime, ActualTraceCube&gt;();

	/**
	 * This cache stores the PulseNote objects that belong to (intersect) with daily time intervals at time.
	 * These daily intervals represent segments of history periods.
	 */
<span class="nc" id="L50">	private Map&lt;TimeIntervalAtTime, Collection&lt;PulseNoteBO&gt;&gt; notesByTimeIntervalAtTime =</span>
			new HashMap&lt;TimeIntervalAtTime, Collection&lt;PulseNoteBO&gt;&gt;();

<span class="nc" id="L53">	private Map&lt;DateRange, List&lt;Date&gt;&gt; cachedHistoryDays = new HashMap&lt;DateRange, List&lt;Date&gt;&gt;();</span>

	public QueueHistoryTimeSeriesProvider(Queue queue, TimeContext timeContext, IHistoryDataService historyDataService,
<span class="nc" id="L56">			INotesDataService notesDataService) {</span>
<span class="nc" id="L57">		this.queue = queue;</span>
<span class="nc" id="L58">		this.historyDataService = historyDataService;</span>
<span class="nc" id="L59">		this.notesDataService = notesDataService;</span>
<span class="nc" id="L60">		this.timeIntervalFactory = new TimeIntervalFactory(timeContext);</span>
<span class="nc" id="L61">	}</span>

	/**
	 * This method is marked as synchronized because at times the history cache is accessed from a separate thread
	 * in the Add Historical Week dialog (not the AWT event thread).  We want it synchronized in order to prevent the
	 * history cache from entering an invalid state in case it gets accessed simultaneously from multiple threads.
	 */
	public synchronized ActualTraceCube getHistory(TimeIntervalAtTime period) throws BbmException {
<span class="nc bnc" id="L69" title="All 2 branches missed.">		if (historyByTimeIntervalAtTime.containsKey(period)) {</span>
<span class="nc" id="L70">			return historyByTimeIntervalAtTime.get(period);</span>
		}

		//Before storing the history in the cache, we need to take into account exclude pulse notes as those
		//indicate whether or not history is excluded for the time ranges specified in the note
<span class="nc" id="L75">		Map&lt;ID, ActualTraceCube&gt; historyMap = historyDataService.getHistory(Collections.singleton(queue), period);</span>
<span class="nc" id="L76">		ActualTraceCube history = historyMap.get(queue.getID());</span>

<span class="nc" id="L78">		Collection&lt;PulseNoteBO&gt; periodNotes = getNotes(period);</span>

<span class="nc" id="L80">		adjustHistory(history, periodNotes);</span>

<span class="nc" id="L82">		storeHistoryInCache(period, history);</span>

<span class="nc" id="L84">		return history;</span>
	}

	@Override
	public Collection&lt;PulseNoteBO&gt; getNotes(TimeIntervalAtTime interval) throws BbmException {
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (notesByTimeIntervalAtTime.containsKey(interval)) {</span>
<span class="nc" id="L90">			return notesByTimeIntervalAtTime.get(interval);</span>
		}

<span class="nc" id="L93">		Collection&lt;PulseNoteBO&gt; retVal = notesDataService.getNotes(Collections.singletonList(queue.getID()),</span>
<span class="nc" id="L94">				interval.getStartTime(), new Date(interval.getEndTime().getTime() - 1));</span>

<span class="nc" id="L96">		notesByTimeIntervalAtTime.put(interval, retVal);</span>

<span class="nc" id="L98">		return retVal;</span>
	}

	@Override
	public List&lt;Date&gt; getDaysWithHistory(Date start, Date end) throws BbmException {
<span class="nc" id="L103">		DateRange range = new DateRange(start, end);</span>

<span class="nc bnc" id="L105" title="All 2 branches missed.">		if (cachedHistoryDays.get(range) != null) {</span>
<span class="nc" id="L106">			return cachedHistoryDays.get(range);</span>
		}

<span class="nc" id="L109">		List&lt;Date&gt; daysWithHistory = historyDataService.getDaysWithHistory(Collections.singleton(queue), start, end);</span>

<span class="nc" id="L111">		cachedHistoryDays.put(range, daysWithHistory);</span>
<span class="nc" id="L112">		return daysWithHistory;</span>
	}

	Queue getQueue() {
<span class="nc" id="L116">		return queue;</span>
	}

	boolean isHistoryLoadedForPeriod(TimeIntervalAtTime period) {
<span class="nc" id="L120">		return historyByTimeIntervalAtTime.containsKey(period);</span>
	}

	boolean isNotesLoadedForPeriod(TimeIntervalAtTime period) {
<span class="nc" id="L124">		return notesByTimeIntervalAtTime.containsKey(period);</span>
	}

	/**
	 *
	 * @param history
	 * @param period
	 */
	void setHistoryForPeriod(ActualTraceCube history, TimeIntervalAtTime interval) throws BbmException {

		//notesByTimeIntervalAtTime.put(interval, notes);

<span class="nc" id="L136">		adjustHistory(history, getNotes(interval));</span>

<span class="nc" id="L138">		storeHistoryInCache(interval, history);</span>
<span class="nc" id="L139">	}</span>

	void setNotesForPeriod(Collection&lt;PulseNoteBO&gt; notes, TimeIntervalAtTime period) {
<span class="nc" id="L142">		notesByTimeIntervalAtTime.put(period, notes);</span>
<span class="nc" id="L143">	}</span>

	/**
	 *
	 * @param history
	 * @param notes
	 * @return
	 */
	private void adjustHistory(ActualTraceCube history, Collection&lt;PulseNoteBO&gt; notes) {
<span class="nc bnc" id="L152" title="All 2 branches missed.">		if (notes != null) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			for (PulseNoteBO note : notes) {</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">				if (note.getExcludeFromForeCast() != null &amp;&amp;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">						note.getExcludeFromForeCast().equals(ForecastUsage.NO_WEIGHTS_TO_PERIOD)) {</span>
					Date startDate;
					Date endDate;
<span class="nc bnc" id="L158" title="All 2 branches missed.">					if (history.getRawStartDate().after(note.getStartTime())) {</span>
<span class="nc" id="L159">						startDate = history.getRawStartDate();</span>
					} else {
<span class="nc" id="L161">						startDate = note.getStartTime();</span>
					}
<span class="nc bnc" id="L163" title="All 2 branches missed.">					if (history.getRawEndDate().before(note.getEndTime())) {</span>
<span class="nc" id="L164">						endDate = history.getRawEndDate();</span>
					} else {
<span class="nc" id="L166">						endDate = note.getEndTime();</span>
					}
<span class="nc bnc" id="L168" title="All 2 branches missed.">					for (short traceType : history.getTraceTypes()) {</span>
						//Set the history trace cube values to TRACENA for the time period specified by the exclude note
						//TODO: do we need to fix this for when BPCONFIG has IncludeUnknownCV set to true? (i.e. should this be zero instead?)
<span class="nc" id="L171">						TraceOperator.setTraceToValueForPeriod(history, traceType, Trace.TRACENA, startDate, endDate);</span>
					}
				}
<span class="nc" id="L174">			}</span>
		}
<span class="nc" id="L176">	}</span>

	private void storeHistoryInCache(TimeIntervalAtTime interval, ActualTraceCube history) throws BbmException {

<span class="nc" id="L180">		historyByTimeIntervalAtTime.put(interval, history);</span>

		//If we are caching history by week, we will also cache it by each day in the week as the
		//profile entry history periods will retrieve history data for each individual day in the
		//history period.  Since we already have the whole week loaded, we can split them up into
		//days and cache them which will save seven trips to the server when the profile entry history
		//period tries to load history data for each of its constituent days.
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (interval.getDuration().equals(timeIntervalFactory.getOneWeek())) {</span>
<span class="nc" id="L188">			List&lt;TimeIntervalAtTime&gt; dailyIntervals = interval.getIntervalSubdivisions(timeIntervalFactory.getOneDay());</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">			for (TimeIntervalAtTime dailyInterval : dailyIntervals) {</span>
<span class="nc" id="L190">				historyByTimeIntervalAtTime.put(dailyInterval,</span>
<span class="nc" id="L191">						(ActualTraceCube)TraceUtil.sliceTraceCube(history,</span>
<span class="nc" id="L192">								dailyInterval.getStartTime(),</span>
<span class="nc" id="L193">								new Date(dailyInterval.getEndTime().getTime() - 1)));</span>
<span class="nc" id="L194">			}</span>
		}
<span class="nc" id="L196">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>