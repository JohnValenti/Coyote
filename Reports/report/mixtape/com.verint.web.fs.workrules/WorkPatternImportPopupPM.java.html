<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkPatternImportPopupPM.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.web.fs.workrules</a> &gt; <span class="el_source">WorkPatternImportPopupPM.java</span></div><h1>WorkPatternImportPopupPM.java</h1><pre class="source lang-java linenums">package com.verint.web.fs.workrules;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeType;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workrules.model.Shift;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftFieldInfo;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern.StartTime;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPatternPeriod;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPatternShiftAttributes;
import com.bluepumpkin.ejb.bbm.workrules.model.VTOEvent;
import com.bluepumpkin.web.bbm.campaign.CampaignModelHandler;
import com.bluepumpkin.web.bbm.organization.setup.employeetype.EmployeeTypeModelHandler;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.bluepumpkin.web.fs.shift.ShiftUtil;
import com.witness.web.uif.base.Message;
import com.witness.web.uif.data.DataSet;
import com.witness.web.uif.data.DataTable;
import com.witness.web.uif.data.DataTableRow;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.reflection.ParameterUtil;

/**
 * Work pattern import implementation
 * @author lchase
 */
public class WorkPatternImportPopupPM extends WorkRulesImportPopupPM {
	private static final long serialVersionUID = 1L;
	public static final String FORM_ACTION = &quot;work_pattern_import&quot;;
	
	// Work Patterns Constants
	private static final String WORK_PATTERNS_TABLE_FN = &quot;WORK_PATTERNS_TABLE_FN&quot;;
	private static final String WORK_PATTERN_ORG_CAMPAIGN_NAME_FN = &quot;WORK_PATTERN_ORG_CAMPAIGN_NAME_FN&quot;;
	private static final String WORK_PATTERN_NAME_FN = &quot;WORK_PATTERN_NAME_FN&quot;;
	private static final String WORK_PATTERN_DESCRIPTION_FN = &quot;WORK_PATTERN_DESCRIPTION_FN&quot;;
	private static final String WORK_PATTERN_CONSITENCY_TOLERANCE_FN = &quot;WORK_PATTERN_CONSITENCY_TOLERANCE_FN&quot;;
	private static final String WORK_PATTERN_EMPLOYEE_TYPE_FN = &quot;WORK_PATTERN_EMPLOYEE_TYPE_FN&quot;;
	private static final String WORK_PATTERN_TYPE_FN = &quot;WORK_PATTERN_TYPE_FN&quot;;
	
	// Work Days Constants
	private static final String WORK_DAYS_TABLE_FN = &quot;WORK_DAYS_TABLE_FN&quot;;
	private static final String SHIFT_NAME_FN = &quot;SHIFT_NAME_FN&quot;;
	private static final String WORK_DAYS_FN = &quot;WORK_DAYS_FN&quot;;
	private static final String CONSISTENT_SHIFT_EVENTS_FN = &quot;CONSISTENT_SHIFT_EVENTS_FN&quot;;
	private static final String SHIFT_MIN_CONSECUTIVE_DAYS_FN = &quot;SHIFT_MIN_CONSECUTIVE_DAYS_FN&quot;;
	private static final String SHIFT_MAX_CONSECUTIVE_DAYS_FN = &quot;SHIFT_MAX_CONSECUTIVE_DAYS_FN&quot;;
	
	// Consistency Constants
	private static final String CONSISTENCY_TABLE_FN = &quot;CONSISTENCY_TABLE_FN&quot;;
	private static final String CONSISTENCY_FN = &quot;CONSISTENCY_FN&quot;;
	
	// VTO Events Constants
	private static final String VTO_EVENTS_TABLE_FN = &quot;VTO_EVENTS_TABLE_FN&quot;;
	private static final String VTO_EVENT_NAME_FN = &quot;VTO_EVENT_NAME_FN&quot;;
	private static final String VTO_EVENT_START_TIMES_FN = &quot;VTO_EVENT_START_TIMES_FN&quot;;
	
	private static final int DAILY_DURATION_MIN_TIME = 0;
	private static final int DAILY_DURATION_MAX_TIME = 23 * 60 + 59;	// 23:59 in minutes.
	
	// OT Extension Constants
	private static final String OT_EXTENSIONS_TABLE_FN = &quot;OT_EXTENSIONS_TABLE_FN&quot;;
	private static final String OT_EXTENSION_NAME_FN = &quot;OT_EXTENSION_NAME_FN&quot;;
	private static final String OT_EXTENSION_START_TIMES_FN = &quot;OT_EXTENSION_START_TIMES_FN&quot;;
	
	private Map&lt;ID, Organization&gt; m_organizationMap;
<span class="nc" id="L76">	private Collection&lt;EmployeeType&gt; m_employeeTypes = new ArrayList&lt;EmployeeType&gt;();</span>
<span class="nc" id="L77">	private ArrayList&lt;String&gt; m_workPatternsIgnored = new ArrayList&lt;String&gt;();</span>
	
	/**
	 * Standard constructor required by framework life-cycle
	 * @param context Request Context
	 * @see com.witness.uif.web.system.RequestContext
	 */
	public WorkPatternImportPopupPM(RequestContext context) {
<span class="nc" id="L85">		super(context);</span>
<span class="nc" id="L86">		setIsCommaDelimiterEnabled(false);</span>
<span class="nc" id="L87">		setIsNumberOfLinesToIgnoreEnabled(false);</span>
<span class="nc" id="L88">		setNumberOfLinesToIgnore(1);</span>
<span class="nc" id="L89">	}</span>
	
	/**
	 * Returns an instance of the class which is required by the framework life-cycle.
	 * @param context Request Context
	 * @return WorkPatternImportPopupPM
	 * @see com.witness.uif.web.system.RequestContext
	 */
	public static WorkPatternImportPopupPM getInstance(RequestContext context) {
<span class="nc" id="L98">		return (WorkPatternImportPopupPM)getInstance(context, WorkPatternImportPopupPM.class);</span>
	}
	
	/**
	 * Implementation of abstract field initialization
	 */
	@Override
	protected void initializeFieldInfo() {
<span class="nc" id="L106">		m_isByOrganization = Boolean.parseBoolean(ParameterUtil.getParameter(m_context.getRequest(), IS_BY_ORG_ARGUMENT));</span>
<span class="nc" id="L107">		m_fsResourceBundle = m_localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>
<span class="nc" id="L108">		initWorkPatternsFields();</span>
<span class="nc" id="L109">		initWorkDaysFields();</span>
<span class="nc" id="L110">		initConsistencyFields();</span>
<span class="nc" id="L111">		initVTOEventsFields();</span>
<span class="nc" id="L112">		initOTExtensionsFields();</span>
<span class="nc" id="L113">	}</span>
	
	/**
	 * Initializes the work pattern fields for import
	 */
	protected void initWorkPatternsFields() {
		// Work Patterns Table Initialization
<span class="nc" id="L120">		TableInfo tableInfo = new TableInfo(WORK_PATTERNS_TABLE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.WORK_PATTERNS));</span>
		
<span class="nc" id="L122">		ArrayList&lt;FieldInfo&gt; fieldDefinitions = new ArrayList&lt;FieldInfo&gt;();</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">		if(m_isByOrganization) {</span>
<span class="nc" id="L124">			fieldDefinitions.add(new FieldInfo(WORK_PATTERN_ORG_CAMPAIGN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_ORGANIZATION), true, true, false));</span>
		} else {
<span class="nc" id="L126">			fieldDefinitions.add(new FieldInfo(WORK_PATTERN_ORG_CAMPAIGN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_CAMPAIGN), true, true, false));</span>
		}
<span class="nc" id="L128">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN), true, true, false));</span>
<span class="nc" id="L129">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_DESCRIPTION_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_DESCRIPTION), false, true, false));</span>
<span class="nc" id="L130">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_CONSITENCY_TOLERANCE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_CONSISTENCY_TOLERANCE), false, true, false));</span>
<span class="nc" id="L131">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_EMPLOYEE_TYPE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_EMPLOYEE_TYPE), false, true, true));  // Default value = Full-Time.</span>
<span class="nc" id="L132">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_TYPE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_TYPE), true /* isDisabled */, true /* isChecked */, false /* isDefaultProvided */));</span>
		
<span class="nc" id="L134">		addTableFieldInfo(tableInfo, fieldDefinitions);</span>
<span class="nc" id="L135">	}</span>
	
	/**
	 * Initializes the work day fields from import
	 */
	protected void initWorkDaysFields() {
		// Work Days Table Initialization
<span class="nc" id="L142">		TableInfo tableInfo = new TableInfo(WORK_DAYS_TABLE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_DAYS));</span>
		
<span class="nc" id="L144">		ArrayList&lt;FieldInfo&gt; fieldDefinitions = new ArrayList&lt;FieldInfo&gt;();</span>
<span class="nc" id="L145">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_NAME), true, true, false));</span>
<span class="nc" id="L146">		fieldDefinitions.add(new FieldInfo(SHIFT_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_SHIFT_NAME), true, true, false));</span>
		
		// This whole block requires some logic for start of week as well as monthly features implementation.
<span class="nc" id="L149">		fieldDefinitions.add(new FieldInfo(WORK_DAYS_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_DAYS), true, true, false));</span>
		
<span class="nc" id="L151">		fieldDefinitions.add(new FieldInfo(CONSISTENT_SHIFT_EVENTS_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_CONSISTENT_SHIFT_EVENTS_HEADER), true, true, false));</span>
		
<span class="nc" id="L153">		fieldDefinitions.add(new FieldInfo(SHIFT_MIN_CONSECUTIVE_DAYS_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_MIN_CONSECUTIVE_DAYS_HEADER), true, true, false));</span>
<span class="nc" id="L154">		fieldDefinitions.add(new FieldInfo(SHIFT_MAX_CONSECUTIVE_DAYS_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_MAX_CONSECUTIVE_DAYS_HEADER), true, true, false));</span>
		
<span class="nc" id="L156">		addTableFieldInfo(tableInfo, fieldDefinitions);</span>
<span class="nc" id="L157">	}</span>
	
	/**
	 * Initializes consistency fields for import
	 */
	protected void initConsistencyFields() {	
		// Consistency Table Initialization
<span class="nc" id="L164">		TableInfo tableInfo = new TableInfo(CONSISTENCY_TABLE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_CONSISTENCY));</span>
		
<span class="nc" id="L166">		ArrayList&lt;FieldInfo&gt; fieldDefinitions = new ArrayList&lt;FieldInfo&gt;();</span>
<span class="nc" id="L167">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_NAME), true, true, false));</span>
<span class="nc" id="L168">		fieldDefinitions.add(new FieldInfo(SHIFT_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_SHIFT_NAME), true, true, false));</span>
<span class="nc" id="L169">		fieldDefinitions.add(new FieldInfo(CONSISTENCY_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_CONSISTENCY), true, true, false));</span>
		
<span class="nc" id="L171">		addTableFieldInfo(tableInfo, fieldDefinitions);		</span>
<span class="nc" id="L172">	}</span>
	
	/**
	 * Initializes VTO event fields for import
	 */
	protected void initVTOEventsFields() {
		// VTO Events Table Initialization
<span class="nc" id="L179">		TableInfo tableInfo = new TableInfo(VTO_EVENTS_TABLE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_VTO_EVENTS));</span>
		
<span class="nc" id="L181">		ArrayList&lt;FieldInfo&gt; fieldDefinitions = new ArrayList&lt;FieldInfo&gt;();</span>
<span class="nc" id="L182">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_NAME), true, true, false));</span>
<span class="nc" id="L183">		fieldDefinitions.add(new FieldInfo(VTO_EVENT_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_VTO_EVENT), true, true, false));</span>
<span class="nc" id="L184">		fieldDefinitions.add(new FieldInfo(VTO_EVENT_START_TIMES_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_START_TIMES), true, true, false));</span>
		
<span class="nc" id="L186">		addTableFieldInfo(tableInfo, fieldDefinitions);</span>
<span class="nc" id="L187">	}</span>
	
	/**
	 * Initializes overtime extension fields for import
	 */
	protected void initOTExtensionsFields() {
		// OT Extensions Table Initialization
<span class="nc" id="L194">		TableInfo tableInfo = new TableInfo(OT_EXTENSIONS_TABLE_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_OT_EXTS));</span>
		
<span class="nc" id="L196">		ArrayList&lt;FieldInfo&gt; fieldDefinitions = new ArrayList&lt;FieldInfo&gt;();</span>
<span class="nc" id="L197">		fieldDefinitions.add(new FieldInfo(WORK_PATTERN_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_NAME), true, true, false));</span>
<span class="nc" id="L198">		fieldDefinitions.add(new FieldInfo(OT_EXTENSION_NAME_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_OT_EXTENSION), true, true, false));</span>
<span class="nc" id="L199">		fieldDefinitions.add(new FieldInfo(OT_EXTENSION_START_TIMES_FN, i18n(m_fsResourceBundle, FsWebBundleKey.FS_START_TIMES), true, true, false));</span>
		
<span class="nc" id="L201">		addTableFieldInfo(tableInfo, fieldDefinitions);</span>
<span class="nc" id="L202">	}</span>
	
	/**
	 * Override of base import parse
	 * @param dataSet The {@link com.witness.web.uif.data.DataSet DataSet} parsed from the import
	 * @see com.witness.web.uif.data.DataSet
	 */
	@Override
	protected void parseImport(DataSet dataSet) throws Exception {
<span class="nc" id="L211">		String tableName = i18n(m_fsResourceBundle, FsWebBundleKey.WORK_PATTERNS);</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">		if (dataSet.get(tableName) != null) {</span>
<span class="nc" id="L213">			processWorkPatterns(dataSet.get(tableName));</span>
		}
		
<span class="nc" id="L216">		tableName = i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_DAYS);</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">		if (dataSet.get(tableName) != null) {</span>
<span class="nc" id="L218">			processWorkDays(dataSet.get(tableName));</span>
		}
		
<span class="nc" id="L221">		tableName = i18n(m_fsResourceBundle, FsWebBundleKey.FS_CONSISTENCY);</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">		if (dataSet.get(tableName) != null) {</span>
<span class="nc" id="L223">			processConsistency(dataSet.get(tableName));</span>
		}
		
<span class="nc" id="L226">		tableName = i18n(m_fsResourceBundle, FsWebBundleKey.FS_VTO_EVENTS);</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (dataSet.get(tableName) != null) {</span>
<span class="nc" id="L228">			processVTOEvents(dataSet.get(tableName));</span>
		}
		
<span class="nc" id="L231">		tableName = i18n(m_fsResourceBundle, FsWebBundleKey.FS_OT_EXTS);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (dataSet.get(tableName) != null) {</span>
<span class="nc" id="L233">			processOTExtensions(dataSet.get(tableName));</span>
		}
		
<span class="nc" id="L236">		setPageAction(SUCCESS);</span>
<span class="nc" id="L237">	}</span>
	
	/**
	 * Process work patterns portion of the import
	 * @param table {@link com.witness.web.uif.data.DataTable DataTable} from the {@link com.witness.web.uif.data.DataSet DataSet}
	 * @see com.witness.web.uif.data.DataTable
	 */
	protected void processWorkPatterns(DataTable table) throws Exception {
<span class="nc" id="L245">		boolean success = true;</span>
		
<span class="nc" id="L247">		Collection&lt;ShiftPattern&gt; workPatterns = new ArrayList&lt;ShiftPattern&gt;();</span>
<span class="nc" id="L248">		Map&lt;String, ID&gt; workPatternNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L249">		Map&lt;ID, ShiftPattern&gt; workPatternByIdMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc" id="L250">		Map&lt;String, ID&gt; employeeTypeNameIdMap = new HashMap&lt;String, ID&gt;();</span>
		
<span class="nc" id="L252">		m_organizationMap = new HashMap&lt;ID, Organization&gt;();</span>
		
<span class="nc" id="L254">		int workPatternsCreated = 0;</span>
<span class="nc" id="L255">		int workPatternsSkipped = 0;</span>
<span class="nc" id="L256">		Collection&lt;ShiftPattern&gt; workPatternsToUpdate = new ArrayList&lt;ShiftPattern&gt;();</span>
		
		try {
			// Build look-up maps.
<span class="nc bnc" id="L260" title="All 2 branches missed.">			if(m_isByOrganization) {</span>
<span class="nc" id="L261">				ID orgID = new ID(m_organizationId);</span>
<span class="nc" id="L262">				workPatterns = WorkRulesModelHandler.getShiftPatternsByOrg(m_context, orgID);</span>
				
<span class="nc" id="L264">				Collection&lt;ID&gt; orgParams = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L265">				orgParams.add(orgID);</span>
				
<span class="nc" id="L267">				m_employeeTypes = EmployeeTypeModelHandler.getEmployeeTypes(m_context, orgID);</span>
<span class="nc" id="L268">				m_organizationMap = WorkRulesModelHandler.getOrgs(m_context, orgParams);</span>
<span class="nc" id="L269">			} else {</span>
				// By campaign
<span class="nc" id="L271">				ID spID = new ID(m_schedulingPeriodId);</span>
<span class="nc" id="L272">				SchedulingPeriod sp = CampaignModelHandler.getSchedPeriod(m_context, spID);</span>
<span class="nc" id="L273">				workPatterns = WorkRulesModelHandler.getShiftPatternsBySchedulingPeriodCampaignOnly(m_context, sp);</span>
				
<span class="nc" id="L275">				Collection&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L276">				campaignIds.add(sp.getCampaignID());</span>
<span class="nc" id="L277">				m_employeeTypes = EmployeeTypeModelHandler.getEmployeeTypes(m_context,</span>
<span class="nc" id="L278">						WorkRulesModelHandler.getOrgIDsLinkedToSP(m_context, spID));</span>
			}
			
			// Build work pattern by id and name look-up map
<span class="nc bnc" id="L282" title="All 2 branches missed.">			for(ShiftPattern wp : workPatterns) {</span>
<span class="nc" id="L283">				workPatternByIdMap.put(wp.getID(), wp);</span>
<span class="nc" id="L284">				workPatternNameIdMap.put(wp.getName(), wp.getID());</span>
<span class="nc" id="L285">			}</span>
			
			// Build employee type by name look-up map
<span class="nc bnc" id="L288" title="All 2 branches missed.">			for(EmployeeType empType : m_employeeTypes) {</span>
<span class="nc" id="L289">				employeeTypeNameIdMap.put(empType.getDescription(), empType.getID());</span>
<span class="nc" id="L290">			}</span>
			
			// Build organization ID by name look-up map
<span class="nc" id="L293">			Map&lt;String, ID&gt; orgsNameIDMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">			for(ID key : m_organizationMap.keySet()) {</span>
<span class="nc" id="L295">				orgsNameIDMap.put(m_organizationMap.get(key).getName(), key);</span>
<span class="nc" id="L296">			}</span>
			
<span class="nc bnc" id="L298" title="All 2 branches missed.">			for(DataTableRow row : table.getRows()) {</span>
<span class="nc" id="L299">				boolean hasErrors = false;</span>
<span class="nc" id="L300">				boolean isNew = true;</span>
				
<span class="nc" id="L302">				Object workPatternName = null;			</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				if (isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_NAME_FN)) { // REQUIRED</span>
<span class="nc" id="L304">					workPatternName = row.get(WORK_PATTERN_NAME_FN);</span>
				}
				
<span class="nc" id="L307">				ShiftPattern workPattern = null;</span>
				
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if(workPatternName != null) {</span>
					// Identify the shift to work with.
<span class="nc" id="L311">					ID workPatternId = workPatternNameIdMap.get(workPatternName);</span>
<span class="nc bnc" id="L312" title="All 2 branches missed.">					if(workPatternId != null) {</span>
<span class="nc" id="L313">						workPattern = workPatternByIdMap.get(workPatternId);</span>
<span class="nc" id="L314">						isNew = false;</span>
					}
				}
				
				// If no work pattern is found, create a new shift.
<span class="nc bnc" id="L319" title="All 2 branches missed.">				if(workPattern == null) {</span>
<span class="nc" id="L320">					workPattern = new ShiftPattern();</span>
<span class="nc" id="L321">					workPattern.setName(workPatternName.toString());</span>
<span class="nc" id="L322">					isNew = true;</span>
				}
				
<span class="nc bnc" id="L325" title="All 2 branches missed.">				if (isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_ORG_CAMPAIGN_NAME_FN)) { // REQUIRED </span>
<span class="nc" id="L326">					Object organization = row.get(WORK_PATTERN_ORG_CAMPAIGN_NAME_FN);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">					if(organization.toString().toLowerCase().compareTo(i18n(m_fsResourceBundle, FsWebBundleKey.LOCAL).toLowerCase()) == 0) {	// ! magic string.</span>
<span class="nc" id="L328">						workPattern.setOrganizationID(null);</span>
<span class="nc" id="L329">						workPattern.setCampaignID(new ID(m_campaignId));</span>
					} else {
<span class="nc" id="L331">						ID lookupOrg = orgsNameIDMap.get(organization.toString());</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">						if(lookupOrg == null || !lookupOrg.equals(new ID(m_organizationId))) {</span>
<span class="nc" id="L333">							addImportStatusMessage(</span>
<span class="nc" id="L334">									m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_ORGANIZATION,</span>
<span class="nc" id="L335">											new Object[] { workPatternName, String.valueOf(organization) }));</span>
<span class="nc" id="L336">							hasErrors = true;</span>
						} else {
<span class="nc" id="L338">							workPattern.setCampaignID(null);</span>
<span class="nc" id="L339">							workPattern.setOrganizationID(lookupOrg);</span>
						}
					}
					// Look for the permitted organization ID settings, should be a specific ID or null (in the case of scheduling periods).
				}
				
<span class="nc bnc" id="L345" title="All 2 branches missed.">				if(isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_DESCRIPTION_FN)) {</span>
<span class="nc" id="L346">					Object description = row.get(WORK_PATTERN_DESCRIPTION_FN);</span>
					try {
<span class="nc" id="L348">						workPattern.setDescription(description.toString());</span>
<span class="nc" id="L349">					} catch (Exception ex) {</span>
<span class="nc" id="L350">						addImportStatusMessage(</span>
<span class="nc" id="L351">								m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_DESCRIPTION_FORMAT,</span>
<span class="nc" id="L352">										new Object[] { workPatternName, String.valueOf(description) }));</span>
<span class="nc" id="L353">						hasErrors = true;</span>
<span class="nc" id="L354">					}</span>
				}
				
<span class="nc bnc" id="L357" title="All 2 branches missed.">				if(isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_CONSITENCY_TOLERANCE_FN)) {</span>
<span class="nc" id="L358">					Object consistency = row.get(WORK_PATTERN_CONSITENCY_TOLERANCE_FN);</span>
					try {
<span class="nc" id="L360">						int consistencyDurationInMinutes = parseDurationMinutesFromHHMM(consistency.toString());</span>
<span class="nc bnc" id="L361" title="All 4 branches missed.">						if(consistencyDurationInMinutes &gt;= DAILY_DURATION_MIN_TIME &amp;&amp; consistencyDurationInMinutes &lt;= DAILY_DURATION_MAX_TIME) {</span>
<span class="nc" id="L362">							workPattern.setConsistentStartsTolerance(consistencyDurationInMinutes);</span>
						} else {
<span class="nc" id="L364">							addImportStatusMessage(</span>
<span class="nc" id="L365">									m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_CONSISTENCY_VALUE,</span>
<span class="nc" id="L366">											new Object[] { workPatternName, String.valueOf(consistency.toString()) }));</span>
<span class="nc" id="L367">							hasErrors = true;</span>
						}
<span class="nc" id="L369">					} catch (Exception ex) {</span>
<span class="nc" id="L370">						addImportStatusMessage(</span>
<span class="nc" id="L371">								m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_CONSISTENCY_FORMAT,</span>
<span class="nc" id="L372">										new Object[] { workPatternName, String.valueOf(consistency.toString()) }));</span>
<span class="nc" id="L373">						hasErrors = true;</span>
<span class="nc" id="L374">					}</span>
				}
				
<span class="nc bnc" id="L377" title="All 2 branches missed.">				if(isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_EMPLOYEE_TYPE_FN)) {</span>
<span class="nc" id="L378">					Object employeeType = row.get(WORK_PATTERN_EMPLOYEE_TYPE_FN);</span>
					try {
<span class="nc bnc" id="L380" title="All 2 branches missed.">						if(employeeTypeNameIdMap.containsKey(employeeType.toString())) {</span>
<span class="nc" id="L381">							workPattern.setEmployeeTypeID(employeeTypeNameIdMap.get(employeeType.toString()));</span>
						} else {
<span class="nc" id="L383">							addImportStatusMessage(</span>
<span class="nc" id="L384">									m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_EMPLOYEE_TYPE,</span>
<span class="nc" id="L385">											new Object[] { workPatternName, String.valueOf(employeeType) }));</span>
<span class="nc" id="L386">							hasErrors = true;</span>
						}
<span class="nc" id="L388">					} catch (Exception ex) {</span>
<span class="nc" id="L389">						addImportStatusMessage(</span>
<span class="nc" id="L390">								m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_EMPLOYEE_TYPE,</span>
<span class="nc" id="L391">										new Object[] { workPatternName, String.valueOf(employeeType) }));</span>
<span class="nc" id="L392">						hasErrors = true;</span>
<span class="nc" id="L393">					}</span>
				}
				
<span class="nc bnc" id="L396" title="All 2 branches missed.">				if(isChecked(WORK_PATTERNS_TABLE_FN, WORK_PATTERN_TYPE_FN)) {</span>
<span class="nc" id="L397">					Object workPatternType = row.get(WORK_PATTERN_TYPE_FN);</span>
					try {
<span class="nc" id="L399">						ShiftPatternPeriod period = ShiftUtil.parseWorkPatternPeriodLocalizedValue(m_localizer, workPatternType.toString());</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">						if (period != null) {</span>
<span class="nc" id="L401">							workPattern.setPeriod(period);</span>
						} else {
<span class="nc" id="L403">							addImportStatusMessage(</span>
<span class="nc" id="L404">									m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_PERIOD_TYPE,</span>
<span class="nc" id="L405">											new Object[] { workPatternName, String.valueOf(workPatternType) }));</span>
<span class="nc" id="L406">							hasErrors = true;</span>
						}
<span class="nc" id="L408">					} catch (Exception ex) {</span>
<span class="nc" id="L409">						addImportStatusMessage(</span>
<span class="nc" id="L410">								m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_PERIOD_TYPE,</span>
<span class="nc" id="L411">										new Object[] { workPatternName, String.valueOf(workPatternType) }));</span>
<span class="nc" id="L412">						hasErrors = true;</span>
<span class="nc" id="L413">					}</span>
				}
				
<span class="nc" id="L416">				List&lt;Message&gt; workPatternValidationResults = ShiftUtil.validateWorkPattern(m_localizer, workPattern);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">				for(Message m : workPatternValidationResults) {</span>
<span class="nc" id="L418">					addImportStatusMessage(m.getLocalizedMessage(m_localizer));</span>
<span class="nc" id="L419">				}</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">				if(workPatternValidationResults.size() &gt; 0) hasErrors = true;</span>
				
<span class="nc bnc" id="L422" title="All 2 branches missed.">				if(!hasErrors) {</span>
<span class="nc bnc" id="L423" title="All 6 branches missed.">					if (isNew &amp;&amp; (m_importBehavior.compareTo(IMPORT_BEHAVIOR_ADD_UPDATE) == 0 || m_importBehavior.compareTo(IMPORT_BEHAVIOR_ADD_ONLY) == 0)) {</span>
<span class="nc" id="L424">						WorkRulesModelHandler.createShiftPattern(m_context, workPattern);</span>
<span class="nc" id="L425">						workPatternsCreated++;</span>
<span class="nc bnc" id="L426" title="All 6 branches missed.">					} else if (!isNew  &amp;&amp; (m_importBehavior.compareTo(IMPORT_BEHAVIOR_ADD_UPDATE) == 0 || m_importBehavior.compareTo(IMPORT_BEHAVIOR_UPDATE_ONLY) == 0)) {</span>
<span class="nc" id="L427">						workPatternsToUpdate.add(workPattern);</span>
					} else {
<span class="nc" id="L429">						m_workPatternsIgnored.add(workPattern.getName().toLowerCase());</span>
					}
				} else {
					// If we aren't processing a work pattern, track it so we don't do any of the other section updates for this name
					// No sense in reporting a work pattern not existing if we aren't trying to add it.
<span class="nc" id="L434">					m_workPatternsIgnored.add(workPattern.getName().toLowerCase());</span>
<span class="nc" id="L435">					workPatternsSkipped++;</span>
				}
<span class="nc" id="L437">			}</span>
<span class="nc" id="L438">		} catch (Exception ex) {</span>
<span class="nc" id="L439">			log.error(ex);</span>
<span class="nc" id="L440">			addPageMessage(new Message(Message.ERROR_TYPE,</span>
<span class="nc" id="L441">					i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_PROCESSING_WORK_PATTERNS)));</span>
<span class="nc" id="L442">		}</span>
		
<span class="nc bnc" id="L444" title="All 4 branches missed.">		if (m_importBehavior.compareTo(IMPORT_BEHAVIOR_ADD_UPDATE) == 0 || m_importBehavior.compareTo(IMPORT_BEHAVIOR_UPDATE_ONLY) == 0) {</span>
<span class="nc" id="L445">			WorkRulesModelHandler.updateShiftPatterns(m_context, workPatternsToUpdate);</span>
		}
		
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if(m_importStatusMessages.size() &gt; 0){</span>
<span class="nc" id="L449">			addPageMessage(new Message(Message.WARNING_TYPE, FsWebBundleKey.FS_IMPORT_FAILURE_MESSAGE, </span>
					FsWebBundleKey.BUNDLE_NAME, 
					new String[] { 
<span class="nc" id="L452">						String.valueOf(i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN)),</span>
<span class="nc" id="L453">						String.valueOf(workPatternsCreated), </span>
<span class="nc" id="L454">						String.valueOf(workPatternsToUpdate.size()), </span>
<span class="nc" id="L455">						String.valueOf(workPatternsSkipped) </span>
					}));
		} else {
<span class="nc" id="L458">			addPageMessage(new Message(Message.INFO_TYPE, FsWebBundleKey.FS_IMPORT_SUCCESS_MESSAGE,</span>
					FsWebBundleKey.BUNDLE_NAME,
					new String[] {
<span class="nc" id="L461">						String.valueOf(i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN)),</span>
<span class="nc" id="L462">						String.valueOf(workPatternsCreated),</span>
<span class="nc" id="L463">						String.valueOf(workPatternsToUpdate.size())</span>
					}));
		}
<span class="nc bnc" id="L466" title="All 2 branches missed.">		if (success) { </span>
<span class="nc" id="L467">			setPageAction(SUCCESS);</span>
		}
<span class="nc" id="L469">	}</span>
	
	/**
	 * Process work pattern work days portion of the import
	 * @param table {@link com.witness.web.uif.data.DataTable DataTable} from the {@link com.witness.web.uif.data.DataSet DataSet}
	 * @see com.witness.web.uif.data.DataTable
	 */
	protected void processWorkDays(DataTable table) throws Exception {
<span class="nc" id="L477">		Collection&lt;ShiftPattern&gt; workPatterns = new ArrayList&lt;ShiftPattern&gt;();</span>
		
<span class="nc" id="L479">		Map&lt;String, ID&gt; workPatternNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L480">		Map&lt;ID, ShiftPattern&gt; workPatternByIdMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc" id="L481">		Map&lt;ID, String&gt; shiftIdNameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc" id="L482">		Map&lt;String, ID&gt; shiftNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L483">		Map&lt;String, Shift&gt; shiftByNameMap = new HashMap&lt;String, Shift&gt;();</span>
		
<span class="nc" id="L485">		Collection&lt;ShiftPattern&gt; workPatternsToUpdate = new ArrayList&lt;ShiftPattern&gt;();</span>
		try {
			
			// Build look-up maps.
<span class="nc bnc" id="L489" title="All 2 branches missed.">			if(m_isByOrganization) {</span>
<span class="nc" id="L490">				ID orgID = new ID(m_organizationId);</span>
<span class="nc" id="L491">				workPatterns = WorkRulesModelHandler.getShiftPatternsByOrg(m_context, orgID);</span>
				
<span class="nc" id="L493">				Collection&lt;ID&gt; orgParams = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L494">				orgParams.add(orgID);</span>
				
<span class="nc" id="L496">				m_organizationMap = WorkRulesModelHandler.getOrgs(m_context, orgParams);</span>
<span class="nc" id="L497">				shiftIdNameMap = WorkRulesModelHandler.getShiftNamesByOrg(m_context, orgID);</span>
				
<span class="nc" id="L499">			} else {</span>
				// By campaign
<span class="nc" id="L501">				ID spID = new ID(m_schedulingPeriodId);</span>
<span class="nc" id="L502">				SchedulingPeriod sp = CampaignModelHandler.getSchedPeriod(m_context, spID);</span>
<span class="nc" id="L503">				workPatterns = WorkRulesModelHandler.getShiftPatternsBySchedulingPeriodCampaignOnly(m_context, sp);</span>
				
<span class="nc" id="L505">				Collection&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L506">				campaignIds.add(sp.getCampaignID());</span>
<span class="nc" id="L507">				shiftIdNameMap = WorkRulesModelHandler.getShiftNamesBySchedulingPeriod(m_context, sp);</span>
			}
			
			// Add in Possible Days Off shift as viable (actually required)
<span class="nc" id="L511">			Shift daysOffShift = WorkRulesModelHandler.getPossibleDaysOffShift(m_context);</span>
<span class="nc" id="L512">			shiftIdNameMap.put(daysOffShift.getID(), daysOffShift.getName());</span>
			
			// Build work pattern by id and name look-up map
<span class="nc bnc" id="L515" title="All 2 branches missed.">			for(ShiftPattern wp : workPatterns) {</span>
<span class="nc" id="L516">				workPatternByIdMap.put(wp.getID(), wp);</span>
<span class="nc" id="L517">				workPatternNameIdMap.put(wp.getName(), wp.getID());</span>
<span class="nc" id="L518">			} </span>
			
<span class="nc" id="L520">			Collection&lt;ID&gt; shiftIds = new ArrayList&lt;ID&gt;();</span>
			// Build shift by id look up map
<span class="nc bnc" id="L522" title="All 2 branches missed.">			for(ID key : shiftIdNameMap.keySet()) {</span>
<span class="nc" id="L523">				shiftNameIdMap.put(shiftIdNameMap.get(key), key);</span>
<span class="nc" id="L524">				shiftIds.add(key);</span>
<span class="nc" id="L525">			}</span>
			
<span class="nc" id="L527">			Collection&lt;Shift&gt; shiftMap = WorkRulesModelHandler.getShiftsByIDs(m_context, shiftIds);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">			for(Shift shift : shiftMap) {</span>
<span class="nc" id="L529">				shiftByNameMap.put(shift.getName(), shift);</span>
<span class="nc" id="L530">			}</span>
<span class="nc" id="L531">			shiftByNameMap.put(daysOffShift.getName(), daysOffShift);</span>
			
			// We will parse the whole list prior to saving work pattern VTO events because 
			// the list of assigned VTO events will replace any existing items so we need the full
			// definition before saving the work pattern.
<span class="nc" id="L536">			Map&lt;ID, HashMap&lt;Shift, ShiftPatternShiftAttributes&gt;&gt; attributes = new HashMap&lt;ID, HashMap&lt;Shift, ShiftPatternShiftAttributes&gt;&gt;();</span>
<span class="nc" id="L537">			Collection&lt;ID&gt; workPatternWithErrors = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">			for(DataTableRow row : table.getRows()) {</span>
<span class="nc" id="L539">				boolean hasErrors = false;</span>
				
				// WORK_PATTERN_NAME_FN
				// Retrieve the work pattern name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L543">				Object workPatternName = row.get(WORK_PATTERN_NAME_FN);</span>
				
				// If the work pattern this is supposed to be associated to didn't qualify to be
				// involved in the import process (either update or add), then don't do any related record
				// processing.
<span class="nc bnc" id="L548" title="All 2 branches missed.">				if(m_workPatternsIgnored.contains(workPatternName.toString().toLowerCase())) continue;</span>
				
				// Retrieve the shift name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L551">				Object shiftName = row.get(SHIFT_NAME_FN);</span>
				
				// Retrieve the work days, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L554">				Object workDays = row.get(WORK_DAYS_FN);</span>
				
<span class="nc" id="L556">				Object isConsistentShiftActivities = row.get(CONSISTENT_SHIFT_EVENTS_FN);</span>
				
				// Retrieve the min consecutive days, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L559">				Object shiftMinConsecutiveDays = row.get(SHIFT_MIN_CONSECUTIVE_DAYS_FN);</span>
				
				// Retrieve the max consecutive days, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L562">				Object shiftMaxConsecutiveDays = row.get(SHIFT_MAX_CONSECUTIVE_DAYS_FN);</span>
				
<span class="nc" id="L564">				ShiftPattern workPattern = null;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">				if (!workPatternNameIdMap.containsKey(workPatternName.toString())) {</span>
<span class="nc" id="L566">					addImportStatusMessage(</span>
<span class="nc" id="L567">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_WORK_PATTERN,</span>
<span class="nc" id="L568">									new Object[] { shiftName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L569">					hasErrors = true;</span>
<span class="nc" id="L570">					continue;	// The other validations are irrelevant, the work pattern can't even be found.</span>
				} else {
<span class="nc" id="L572">					workPattern = workPatternByIdMap.get(workPatternNameIdMap.get(workPatternName.toString()));</span>
				}
				
<span class="nc" id="L575">				Shift shift = null;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">				if (!shiftNameIdMap.containsKey(shiftName.toString())) {</span>
<span class="nc" id="L577">					addImportStatusMessage(</span>
<span class="nc" id="L578">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_SHIFT,</span>
<span class="nc" id="L579">									new Object[] { shiftName.toString() }));</span>
<span class="nc" id="L580">					hasErrors = true;</span>
				} else {
<span class="nc" id="L582">					shift = shiftByNameMap.get(shiftName.toString());</span>
				}
				
				// Keep running track of the shift assignments and attributes by work pattern
<span class="nc" id="L586">				HashMap&lt;Shift, ShiftPatternShiftAttributes&gt; workPatternAttributes = new HashMap&lt;Shift, ShiftPatternShiftAttributes&gt;();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">				if (!attributes.containsKey(workPattern.getID())) {</span>
<span class="nc" id="L588">					attributes.put(workPattern.getID(), workPatternAttributes);</span>
				} else {
<span class="nc" id="L590">					workPatternAttributes = attributes.get(workPattern.getID());</span>
				}
				
				// TODO: Check definition vs. work pattern type.
				
				// Parse the working days data into a collection of active days represented by a collection
				// of integers that indicate which days relative to the start of the business week.
<span class="nc" id="L597">				Collection&lt;Integer&gt; workDaysArray = ShiftUtil.parseWorkDaysArrayFromString(workDays.toString());</span>
				
				// Get the attributes associated with the current shift.
<span class="nc" id="L600">				ShiftPatternShiftAttributes spsa = workPatternAttributes.get(shift);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">				if(spsa == null) {</span>
<span class="nc" id="L602">					spsa = new ShiftPatternShiftAttributes();	// Create a new one if it doesn't already exist.</span>
<span class="nc" id="L603">					workPatternAttributes.put(shift, spsa);</span>
				}
				
				// set working days definition
<span class="nc bnc" id="L607" title="All 2 branches missed.">				for(Integer iWorkDay : workDaysArray) {</span>
<span class="nc" id="L608">					spsa.getOccurrenceDays().add(iWorkDay);</span>
<span class="nc" id="L609">				}</span>
				
				try {
<span class="nc" id="L612">					spsa.setisConsistentShiftActivities(m_localizer.parseYesNo(isConsistentShiftActivities.toString()));</span>
<span class="nc" id="L613">				} catch (Exception ex) {</span>
<span class="nc" id="L614">					addImportStatusMessage(</span>
<span class="nc" id="L615">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_SHIFT_CONSISTENCY,</span>
<span class="nc" id="L616">									new Object[] { shiftName.toString(), isConsistentShiftActivities.toString() }));</span>
<span class="nc" id="L617">					hasErrors = true;</span>
<span class="nc" id="L618">				}</span>
				
				try {
<span class="nc" id="L621">					spsa.setMinConsecutiveDay(Integer.parseInt(shiftMinConsecutiveDays.toString()));</span>
<span class="nc" id="L622">				} catch (Exception ex) {</span>
<span class="nc" id="L623">					addImportStatusMessage(</span>
<span class="nc" id="L624">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_MIN_CONSECUTIVE_DAYS_FORMAT,</span>
<span class="nc" id="L625">									new Object[] { shiftName.toString(), shiftMinConsecutiveDays.toString() }));</span>
<span class="nc" id="L626">					hasErrors = true;</span>
<span class="nc" id="L627">				}</span>
				
				try {
<span class="nc" id="L630">					spsa.setMaxConsecutiveDay(Integer.parseInt(shiftMaxConsecutiveDays.toString()));</span>
<span class="nc" id="L631">				} catch (Exception ex) {</span>
<span class="nc" id="L632">					addImportStatusMessage(</span>
<span class="nc" id="L633">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_MAX_CONSECUTIVE_DAYS_FORMAT,</span>
<span class="nc" id="L634">									new Object[] { shiftName.toString(), shiftMaxConsecutiveDays.toString() }));</span>
<span class="nc" id="L635">					hasErrors = true;</span>
<span class="nc" id="L636">				}</span>
				
				// Min consecutive days can't be greater than the max consecutive days.
<span class="nc bnc" id="L639" title="All 2 branches missed.">				if(spsa.getMinConsecutiveDay() &gt; spsa.getMaxConsecutiveDay()) {</span>
<span class="nc" id="L640">					addImportStatusMessage(</span>
<span class="nc" id="L641">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_MIN_MAX_CONSECUTIVE_DAYS_DEFINTION,</span>
<span class="nc" id="L642">									new Object[] { shiftName.toString() }));</span>
<span class="nc" id="L643">					hasErrors = true;</span>
				}
				
<span class="nc bnc" id="L646" title="All 4 branches missed.">				if(hasErrors &amp;&amp; !workPatternWithErrors.contains(workPattern.getID())) {</span>
<span class="nc" id="L647">					workPatternWithErrors.add(workPattern.getID());</span>
<span class="nc" id="L648">					System.out.println(&quot;### DEBUG ### : &quot; + workPattern.getName() + &quot; will not have Work Days updated, it had errors&quot;);</span>
				}
<span class="nc" id="L650">			}</span>
			
			// One validation before update is that each shift must have an off-days shift assigned/defined.
			
<span class="nc bnc" id="L654" title="All 2 branches missed.">			for(ID workPatternID : attributes.keySet()) {</span>
<span class="nc" id="L655">				ShiftPattern workPattern = workPatternByIdMap.get(workPatternID);</span>
<span class="nc" id="L656">				workPattern.setShiftPatternShiftAttributes(attributes.get(workPatternID));</span>

				// Only update work patterns with no errors.
<span class="nc bnc" id="L659" title="All 2 branches missed.">				if (!workPatternWithErrors.contains(workPattern.getID())) {</span>
<span class="nc" id="L660">					System.out.println(&quot;### DEBUG ### : &quot; + workPattern.getName() + &quot; will be updated for work days, no errors encountered&quot;);</span>
<span class="nc" id="L661">					workPatternsToUpdate.add(workPattern);</span>
				}
				else {
					// Log an warning that this record was not updated because of errors.
<span class="nc" id="L665">					addImportStatusMessage(m_localizer.i18n(m_fsResourceBundle,</span>
							FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_WORK_PATTERN_NOT_UPDATED_DUE_TO_WORK_DAY,
<span class="nc" id="L667">							new Object[] { workPattern.getName() }));</span>
				}
<span class="nc" id="L669">			}</span>
			
<span class="nc" id="L671">			WorkRulesModelHandler.updateShiftPatterns(m_context, workPatternsToUpdate);		// Save changes	</span>
<span class="nc" id="L672">		} catch (Exception ex) {</span>
<span class="nc" id="L673">			log.error(ex);</span>
<span class="nc" id="L674">			addPageMessage(new Message(Message.ERROR_TYPE,</span>
<span class="nc" id="L675">					i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_PROCESSING_WORK_DAYS)));</span>
<span class="nc" id="L676">		}</span>
<span class="nc" id="L677">	}</span>
	
	/**
	 * Process work pattern consistency portion of the import
	 * @param table {@link com.witness.web.uif.data.DataTable DataTable} from the {@link com.witness.web.uif.data.DataSet DataSet}
	 * @see com.witness.web.uif.data.DataTable
	 */
	protected void processConsistency(DataTable table) throws Exception {
		// IMPORTANT: This will not do a replace operation on the shift attributes like work days does, it will presume that
		// work days has defined the full set of shifts assigned for the work patterns.  This is a secondary update to just the
		// consistency days.
		
<span class="nc" id="L689">		Collection&lt;ShiftPattern&gt; workPatterns = new ArrayList&lt;ShiftPattern&gt;();</span>
		
<span class="nc" id="L691">		Map&lt;String, ID&gt; workPatternNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L692">		Map&lt;ID, ShiftPattern&gt; workPatternByIdMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc" id="L693">		Map&lt;ID, String&gt; shiftIdNameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc" id="L694">		Map&lt;String, ID&gt; shiftNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L695">		Map&lt;String, Shift&gt; shiftByNameMap = new HashMap&lt;String, Shift&gt;();</span>
		
<span class="nc" id="L697">		Collection&lt;ShiftPattern&gt; workPatternsToUpdate = new ArrayList&lt;ShiftPattern&gt;();</span>
		try {
			
			// Build look-up maps.
<span class="nc bnc" id="L701" title="All 2 branches missed.">			if(m_isByOrganization) {</span>
<span class="nc" id="L702">				ID orgID = new ID(m_organizationId);</span>
<span class="nc" id="L703">				workPatterns = WorkRulesModelHandler.getShiftPatternsByOrg(m_context, orgID);</span>
				
<span class="nc" id="L705">				Collection&lt;ID&gt; orgParams = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L706">				orgParams.add(orgID);</span>
				
<span class="nc" id="L708">				m_organizationMap = WorkRulesModelHandler.getOrgs(m_context, orgParams);</span>
<span class="nc" id="L709">				shiftIdNameMap = WorkRulesModelHandler.getShiftNamesByOrg(m_context, orgID);</span>
				
<span class="nc" id="L711">			} else {</span>
				// By campaign
<span class="nc" id="L713">				ID spID = new ID(m_schedulingPeriodId);</span>
<span class="nc" id="L714">				SchedulingPeriod sp = CampaignModelHandler.getSchedPeriod(m_context, spID);</span>
<span class="nc" id="L715">				workPatterns = WorkRulesModelHandler.getShiftPatternsBySchedulingPeriodCampaignOnly(m_context, sp);</span>
				
<span class="nc" id="L717">				Collection&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L718">				campaignIds.add(sp.getCampaignID());</span>
<span class="nc" id="L719">				shiftIdNameMap = WorkRulesModelHandler.getShiftNamesBySchedulingPeriod(m_context, sp);</span>
			}
			
			// Add in Possible Days Off shift as viable (actually required)
<span class="nc" id="L723">			Shift daysOffShift = WorkRulesModelHandler.getPossibleDaysOffShift(m_context);</span>
<span class="nc" id="L724">			shiftIdNameMap.put(daysOffShift.getID(), daysOffShift.getName());</span>
			
			// Build work pattern by id and name look-up map
<span class="nc bnc" id="L727" title="All 2 branches missed.">			for(ShiftPattern wp : workPatterns) {</span>
<span class="nc" id="L728">				workPatternByIdMap.put(wp.getID(), wp);</span>
<span class="nc" id="L729">				workPatternNameIdMap.put(wp.getName(), wp.getID());</span>
<span class="nc" id="L730">			} </span>
			
<span class="nc" id="L732">			Collection&lt;ID&gt; shiftIds = new ArrayList&lt;ID&gt;();</span>
			// Build shift by id look up map
<span class="nc bnc" id="L734" title="All 2 branches missed.">			for(ID key : shiftIdNameMap.keySet()) {</span>
<span class="nc" id="L735">				shiftNameIdMap.put(shiftIdNameMap.get(key), key);</span>
<span class="nc" id="L736">				shiftIds.add(key);</span>
<span class="nc" id="L737">			}</span>
			
<span class="nc" id="L739">			Collection&lt;Shift&gt; shiftMap = WorkRulesModelHandler.getShiftsByIDs(m_context, shiftIds);</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">			for(Shift shift : shiftMap) {</span>
<span class="nc" id="L741">				shiftByNameMap.put(shift.getName(), shift);</span>
<span class="nc" id="L742">			}</span>
<span class="nc" id="L743">			shiftByNameMap.put(daysOffShift.getName(), daysOffShift);</span>
			
			// We will parse the whole list prior to saving work pattern VTO events because 
			// the list of assigned VTO events will replace any existing items so we need the full
			// definition before saving the work pattern.
<span class="nc" id="L748">			Map&lt;ID, HashMap&lt;Shift, ShiftPatternShiftAttributes&gt;&gt; attributes = new HashMap&lt;ID, HashMap&lt;Shift, ShiftPatternShiftAttributes&gt;&gt;();</span>
<span class="nc" id="L749">			Collection&lt;ID&gt; workPatternWithErrors = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L750" title="All 2 branches missed.">			for(DataTableRow row : table.getRows()) {</span>
<span class="nc" id="L751">				boolean hasErrors = false;</span>
				
				// WORK_PATTERN_NAME_FN
				// Retrieve the work pattern name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L755">				Object workPatternName = row.get(WORK_PATTERN_NAME_FN);</span>
				
				// If the work pattern this is supposed to be associated to didn't qualify to be
				// involved in the import process (either update or add), then don't do any related record
				// processing.
<span class="nc bnc" id="L760" title="All 2 branches missed.">				if(m_workPatternsIgnored.contains(workPatternName.toString().toLowerCase())) continue;</span>
				
				// Retrieve the shift name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L763">				Object shiftName = row.get(SHIFT_NAME_FN);</span>
				
				// Retrieve the work days, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L766">				Object consistency = row.get(CONSISTENCY_FN);</span>
							
<span class="nc" id="L768">				ShiftPattern workPattern = null;</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">				if (!workPatternNameIdMap.containsKey(workPatternName.toString())) {</span>
<span class="nc" id="L770">					addImportStatusMessage(</span>
<span class="nc" id="L771">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_WORK_PATTERN,</span>
<span class="nc" id="L772">									new Object[] { shiftName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L773">					hasErrors = true;</span>
<span class="nc" id="L774">					continue;	// Work pattern not found, no need to continue, there will be a lot of issues.</span>
				} else {
<span class="nc" id="L776">					workPattern = workPatternByIdMap.get(workPatternNameIdMap.get(workPatternName.toString()));</span>
				}
				
<span class="nc" id="L779">				Shift shift = null;</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">				if (!shiftNameIdMap.containsKey(shiftName.toString())) {</span>
<span class="nc" id="L781">					addImportStatusMessage(</span>
<span class="nc" id="L782">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_SHIFT,</span>
<span class="nc" id="L783">									new Object[] { shiftName.toString() }));</span>
<span class="nc" id="L784">					hasErrors = true;</span>
<span class="nc" id="L785">					continue;	// Work pattern not found, no need to continue, there will be a lot of issues.</span>
				} else {
<span class="nc" id="L787">					shift = shiftByNameMap.get(shiftName.toString());</span>
				}
				
				// Keep running track of the shift assignments and attributes by work pattern
<span class="nc bnc" id="L791" title="All 2 branches missed.">				if (!attributes.containsKey(workPattern.getID())) {</span>
<span class="nc" id="L792">					attributes.put(workPattern.getID(), workPattern.getShiftPatternShiftAttributes());</span>
				}
				
				// Parse the working days data into a collection of active days represented by a collection
				// of integers that indicate which days relative to the start of the business week.
<span class="nc" id="L797">				String[] consistencyValues = consistency.toString().split(&quot;,&quot;);</span>
<span class="nc" id="L798">				HashMap&lt;Integer, Integer&gt; consistencyDaysMap = new HashMap&lt;Integer, Integer&gt;();</span>
<span class="nc" id="L799">				int patternDaysRequired = workPattern.getPeriod().getDaysInPeriod().length;</span>
<span class="nc bnc" id="L800" title="All 2 branches missed.">				if(patternDaysRequired == consistencyValues.length) {</span>
<span class="nc" id="L801">					int i=1;</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">					for(String consistencyValue : consistencyValues) {</span>
<span class="nc bnc" id="L803" title="All 2 branches missed.">						if(consistencyValue.toString().compareTo(&quot;0&quot;) != 0) {</span>
<span class="nc" id="L804">							consistencyDaysMap.put(i,Integer.parseInt(consistencyValue.trim()));</span>
						}
<span class="nc" id="L806">						i++;</span>
					}
<span class="nc bnc" id="L808" title="All 2 branches missed.">					if (shift.getID().toInt() != ShiftFieldInfo.POSSIBLE_DAYS_OFF_SHIFT_ID) {</span>
						// If there isn't a shift pattern shift attributes it is because
						// there wasn't a work days definition so don't do anything with
						// consistency because it doesn't make any sense.
<span class="nc" id="L812">						ShiftPatternShiftAttributes shiftAttr = workPattern.getShiftPatternShiftAttributes().get(shift);</span>
<span class="nc bnc" id="L813" title="All 2 branches missed.">						if(shiftAttr != null) {</span>
<span class="nc" id="L814">							shiftAttr.setConsistentShiftGroupMap(consistencyDaysMap);</span>
						}
					}
<span class="nc" id="L817">				} else {</span>
					// The definition doesn't match the work pattern type.
<span class="nc" id="L819">					addImportStatusMessage(</span>
<span class="nc" id="L820">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_CONSISTENCY_DEFINITION,</span>
<span class="nc" id="L821">									new Object[] { shiftName.toString(), consistencyValues.length, workPattern.getNumOfWeeks() }));</span>
<span class="nc" id="L822">					hasErrors = true;</span>
				}
<span class="nc bnc" id="L824" title="All 4 branches missed.">				if(hasErrors &amp;&amp; !workPatternWithErrors.contains(workPattern.getID())) {</span>
<span class="nc" id="L825">					workPatternWithErrors.add(workPattern.getID());</span>
				}
<span class="nc" id="L827">			}</span>
			
			// One validation before update is that each shift must have an off-days shift assigned/defined.
<span class="nc bnc" id="L830" title="All 2 branches missed.">			for(ID workPatternID : attributes.keySet()) {</span>
<span class="nc" id="L831">				ShiftPattern workPattern = workPatternByIdMap.get(workPatternID);</span>
<span class="nc" id="L832">				workPattern.setShiftPatternShiftAttributes(attributes.get(workPatternID));</span>

				// Only update work patterns with no errors.
<span class="nc bnc" id="L835" title="All 2 branches missed.">				if (!workPatternWithErrors.contains(workPattern)) workPatternsToUpdate.add(workPattern);	</span>
<span class="nc" id="L836">			}</span>
			
<span class="nc" id="L838">			WorkRulesModelHandler.updateShiftPatterns(m_context, workPatternsToUpdate);		// Save changes</span>
<span class="nc" id="L839">		} catch (Exception ex) {</span>
<span class="nc" id="L840">			log.error(ex);</span>
<span class="nc" id="L841">			addPageMessage(new Message(Message.ERROR_TYPE,</span>
<span class="nc" id="L842">					i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_PROCESSING_CONSISTENCY)));</span>
<span class="nc" id="L843">		}</span>
<span class="nc" id="L844">	}</span>
	
	/**
	 * Process work pattern VTO events portion of the import
	 * @param table {@link com.witness.web.uif.data.DataTable DataTable} from the {@link com.witness.web.uif.data.DataSet DataSet}
	 * @see com.witness.web.uif.data.DataTable
	 */
	protected void processVTOEvents(DataTable table) throws Exception {
<span class="nc" id="L852">		Collection&lt;ShiftPattern&gt; workPatterns = new ArrayList&lt;ShiftPattern&gt;();</span>
		
<span class="nc" id="L854">		Map&lt;String, ID&gt; workPatternNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L855">		Map&lt;ID, ShiftPattern&gt; workPatternByIdMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc" id="L856">		Map&lt;ID, String&gt; vtoEventIdNameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc" id="L857">		Map&lt;String, ID&gt; vtoEventNameIdMap = new HashMap&lt;String, ID&gt;();</span>

<span class="nc" id="L859">		int vtoEventsSkipped = 0;</span>
<span class="nc" id="L860">		Collection&lt;ShiftPattern&gt; vtoWorkPatternsToUpdate = new ArrayList&lt;ShiftPattern&gt;();</span>
		try {
			
			// Build look-up maps.
<span class="nc bnc" id="L864" title="All 2 branches missed.">			if(m_isByOrganization) {</span>
<span class="nc" id="L865">				ID orgID = new ID(m_organizationId);</span>
<span class="nc" id="L866">				workPatterns = WorkRulesModelHandler.getShiftPatternsByOrg(m_context, orgID);</span>
				
<span class="nc" id="L868">				Collection&lt;ID&gt; orgParams = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L869">				orgParams.add(orgID);</span>
				
<span class="nc" id="L871">				m_organizationMap = WorkRulesModelHandler.getOrgs(m_context, orgParams);</span>
<span class="nc" id="L872">				vtoEventIdNameMap = WorkRulesModelHandler.getVTONamesByOrg(m_context, orgID);</span>
<span class="nc" id="L873">			} else {</span>
				// By campaign
<span class="nc" id="L875">				ID spID = new ID(m_schedulingPeriodId);</span>
<span class="nc" id="L876">				SchedulingPeriod sp = CampaignModelHandler.getSchedPeriod(m_context, spID);</span>
<span class="nc" id="L877">				workPatterns = WorkRulesModelHandler.getShiftPatternsBySchedulingPeriodCampaignOnly(m_context, sp);</span>
				
<span class="nc" id="L879">				Collection&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L880">				campaignIds.add(sp.getCampaignID());</span>
<span class="nc" id="L881">				vtoEventIdNameMap = WorkRulesModelHandler.getVTONamesBySchedulingPeriod(m_context, sp);</span>
			}
			
			// Build work pattern by id and name look-up map
<span class="nc bnc" id="L885" title="All 2 branches missed.">			for(ShiftPattern wp : workPatterns) {</span>
<span class="nc" id="L886">				workPatternByIdMap.put(wp.getID(), wp);</span>
<span class="nc" id="L887">				workPatternNameIdMap.put(wp.getName(), wp.getID());</span>
<span class="nc" id="L888">			}</span>
			
			// Build vto event name and id reverse look-up
<span class="nc bnc" id="L891" title="All 2 branches missed.">			for(ID id : vtoEventIdNameMap.keySet()) {</span>
<span class="nc" id="L892">				vtoEventNameIdMap.put(vtoEventIdNameMap.get(id), id);</span>
<span class="nc" id="L893">			}</span>
			
			// We will parse the whole list prior to saving work pattern VTO events because 
			// the list of assigned VTO events will replace any existing items so we need the full
			// definition before saving the work pattern.
<span class="nc" id="L898">			Map&lt;ID, HashMap&lt;VTOEvent, StartTime&gt;&gt; workPatternVtoEventsById = new HashMap&lt;ID, HashMap&lt;VTOEvent, StartTime&gt;&gt;();</span>
			
<span class="nc bnc" id="L900" title="All 2 branches missed.">			for(DataTableRow row : table.getRows()) {</span>
<span class="nc" id="L901">				boolean hasErrors = false;</span>
				
				// Retrieve the work pattern name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L904">				Object workPatternName = row.get(WORK_PATTERN_NAME_FN);</span>
				
				// If the work pattern this is supposed to be associated to didn't qualify to be
				// involved in the import process (either update or add), then don't do any related record
				// processing.
<span class="nc bnc" id="L909" title="All 2 branches missed.">				if(m_workPatternsIgnored.contains(workPatternName.toString().toLowerCase())) continue;</span>
				
				// Retrieve the vto event name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L912">				Object vtoEventName = row.get(VTO_EVENT_NAME_FN);</span>
				
				// Retrieve the shift event start times, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L915">				Object vtoEventStartTime = row.get(VTO_EVENT_START_TIMES_FN);</span>

<span class="nc bnc" id="L917" title="All 2 branches missed.">				if (!workPatternNameIdMap.containsKey(workPatternName.toString())) {</span>
<span class="nc" id="L918">					addImportStatusMessage(</span>
<span class="nc" id="L919">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_VTO_EVENT_INVALID_WORK_PATTERN,</span>
<span class="nc" id="L920">									new Object[] { vtoEventName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L921">					hasErrors = true;</span>
				}
				
<span class="nc" id="L924">				ShiftPattern workPattern = workPatternByIdMap.get(workPatternNameIdMap.get(workPatternName.toString()));</span>
<span class="nc" id="L925">				VTOEvent vtoEvent = null;</span>
				
				// Try to retrieve the vto event if it already exists within the scope, otherwise error.
<span class="nc bnc" id="L928" title="All 2 branches missed.">				if(vtoEventNameIdMap.containsKey(vtoEventName)) {</span>
<span class="nc" id="L929">					vtoEvent = WorkRulesModelHandler.getVTOEventByID(m_context, vtoEventNameIdMap.get(vtoEventName));</span>
				} else {
<span class="nc" id="L931">					addImportStatusMessage(</span>
<span class="nc" id="L932">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_VTO_EVENT,</span>
<span class="nc" id="L933">									new Object[] { vtoEventName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L934">					hasErrors = true;</span>
				}
				
<span class="nc" id="L937">				ShiftPattern.StartTime startTime = WorkRulesUtil.parseVTOEventStartTimeText(m_localizer, vtoEventStartTime.toString());</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">				if(startTime == null) {</span>
<span class="nc" id="L939">					addImportStatusMessage(</span>
<span class="nc" id="L940">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_VTO_EVENT_START_TIME,</span>
<span class="nc" id="L941">									new Object[] { vtoEventName.toString(), vtoEventStartTime.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L942">					hasErrors = true;</span>
				}
				
				// If there is a work pattern and vto event, find the work pattern in the running collection and add the vto event/start time.
				// After we are done with all the records we will cycle through the collection and set all the work pattern vto event/start times.
				
<span class="nc bnc" id="L948" title="All 4 branches missed.">				if(workPattern != null &amp;&amp; vtoEvent != null) {</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">					if(hasErrors == true) {</span>
<span class="nc" id="L950">						vtoEventsSkipped++;</span>
					} else {
<span class="nc" id="L952">						HashMap&lt;VTOEvent, StartTime&gt; map = new HashMap&lt;VTOEvent, StartTime&gt;();</span>
						
<span class="nc bnc" id="L954" title="All 2 branches missed.">						if(workPatternVtoEventsById.containsKey(workPattern.getID())) {</span>
							// If the work pattern is already being tracked, just add this definition.
<span class="nc" id="L956">							map = workPatternVtoEventsById.get(workPattern.getID());</span>
<span class="nc" id="L957">							map.put(vtoEvent, startTime);</span>
						} else {
							// Not tracked, add a new entry
<span class="nc" id="L960">							map.put(vtoEvent, startTime);</span>
<span class="nc" id="L961">							workPatternVtoEventsById.put(workPattern.getID(), map);</span>
						}
					}
				}
<span class="nc" id="L965">			}</span>
			
<span class="nc bnc" id="L967" title="All 2 branches missed.">			for(ID id : workPatternVtoEventsById.keySet()) {</span>
<span class="nc" id="L968">				ShiftPattern wp = workPatternByIdMap.get(id);</span>
<span class="nc" id="L969">				wp.setVTOEventStartTimes(workPatternVtoEventsById.get(id));</span>
<span class="nc" id="L970">				vtoWorkPatternsToUpdate.add(wp);</span>
<span class="nc" id="L971">			}</span>
<span class="nc" id="L972">			WorkRulesModelHandler.updateShiftPatterns(m_context, vtoWorkPatternsToUpdate);</span>
			
<span class="nc" id="L974">		} catch (Exception ex) {</span>
<span class="nc" id="L975">			log.error(ex);</span>
<span class="nc" id="L976">			addPageMessage(new Message(Message.ERROR_TYPE,</span>
<span class="nc" id="L977">					i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_PROCESSING_VTO)));</span>
<span class="nc" id="L978">		}</span>
<span class="nc" id="L979">	}</span>
	
	/**
	 * Process work pattern overtime extensions portion of the import
	 * @param table {@link com.witness.web.uif.data.DataTable DataTable} from the {@link com.witness.web.uif.data.DataSet DataSet}
	 * @see com.witness.web.uif.data.DataTable
	 */
	protected void processOTExtensions(DataTable table) throws Exception {
<span class="nc" id="L987">		int otExtensionsSkipped = 0;</span>
<span class="nc" id="L988">		Collection&lt;ShiftPattern&gt; vtoWorkPatternsToUpdate = new ArrayList&lt;ShiftPattern&gt;();</span>
		try {
<span class="nc" id="L990">			Collection&lt;ShiftPattern&gt; workPatterns = new ArrayList&lt;ShiftPattern&gt;();</span>
			
<span class="nc" id="L992">			Map&lt;String, ID&gt; workPatternNameIdMap = new HashMap&lt;String, ID&gt;();</span>
<span class="nc" id="L993">			Map&lt;ID, ShiftPattern&gt; workPatternByIdMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc" id="L994">			Map&lt;ID, String&gt; otExtIdNameMap = new HashMap&lt;ID, String&gt;();</span>
<span class="nc" id="L995">			Map&lt;String, ID&gt; otExtNameIdMap = new HashMap&lt;String, ID&gt;();</span>
			
			// Build look-up maps.
<span class="nc bnc" id="L998" title="All 2 branches missed.">			if(m_isByOrganization) {</span>
<span class="nc" id="L999">				ID orgID = new ID(m_organizationId);</span>
<span class="nc" id="L1000">				workPatterns = WorkRulesModelHandler.getShiftPatternsByOrg(m_context, orgID);</span>
				
<span class="nc" id="L1002">				Collection&lt;ID&gt; orgParams = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1003">				orgParams.add(orgID);</span>
				
<span class="nc" id="L1005">				m_organizationMap = WorkRulesModelHandler.getOrgs(m_context, orgParams);</span>
<span class="nc" id="L1006">				otExtIdNameMap = WorkRulesModelHandler.getOTExtensionNamesByOrg(m_context, orgID);</span>
<span class="nc" id="L1007">			} else {</span>
				// By campaign
<span class="nc" id="L1009">				ID spID = new ID(m_schedulingPeriodId);</span>
<span class="nc" id="L1010">				SchedulingPeriod sp = CampaignModelHandler.getSchedPeriod(m_context, spID);</span>
<span class="nc" id="L1011">				workPatterns = WorkRulesModelHandler.getShiftPatternsBySchedulingPeriodCampaignOnly(m_context, sp);</span>
				
<span class="nc" id="L1013">				Collection&lt;ID&gt; campaignIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1014">				campaignIds.add(sp.getCampaignID());</span>
				
<span class="nc" id="L1016">				otExtIdNameMap = WorkRulesModelHandler.getOTExtensionNamesBySchedulingPeriod(m_context, sp);</span>
			}
			
			// Build work pattern by id and name look-up map
<span class="nc bnc" id="L1020" title="All 2 branches missed.">			for(ShiftPattern wp : workPatterns) {</span>
<span class="nc" id="L1021">				workPatternByIdMap.put(wp.getID(), wp);</span>
<span class="nc" id="L1022">				workPatternNameIdMap.put(wp.getName(), wp.getID());</span>
<span class="nc" id="L1023">			}</span>
			
			// Build ot extension name and id reverse look-up
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			for(Entry&lt;ID, String&gt; entry : otExtIdNameMap.entrySet()) {</span>
<span class="nc" id="L1027">				otExtNameIdMap.put(entry.getValue(), entry.getKey());</span>
<span class="nc" id="L1028">			}</span>
			
			// We will parse the whole list prior to saving work pattern VTO events because 
			// the list of assigned VTO events will replace any existing items so we need the full
			// definition before saving the work pattern.
<span class="nc" id="L1033">			Map&lt;ID, HashMap&lt;ShiftOTExtension, StartTime&gt;&gt; workPatternOTExtenstions = new HashMap&lt;ID, HashMap&lt;ShiftOTExtension, StartTime&gt;&gt;();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">			for(DataTableRow row : table.getRows()) {</span>
<span class="nc" id="L1035">				boolean hasErrors = false;</span>
				
				// Retrieve the work pattern name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L1038">				Object workPatternName = row.get(WORK_PATTERN_NAME_FN);</span>
				
				// If the work pattern this is supposed to be associated to didn't qualify to be
				// involved in the import process (either update or add), then don't do any related record
				// processing.
<span class="nc bnc" id="L1043" title="All 2 branches missed.">				if(m_workPatternsIgnored.contains(workPatternName.toString().toLowerCase())) continue;</span>
				
				// Retrieve the vto event name, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L1046">				Object otExtName = row.get(OT_EXTENSION_NAME_FN);</span>
				
				// Retrieve the shift event start times, no isChecked(..) because this is expected as a required field.
<span class="nc" id="L1049">				Object otExtensionStartTime = row.get(OT_EXTENSION_START_TIMES_FN);</span>

<span class="nc bnc" id="L1051" title="All 2 branches missed.">				if (!workPatternNameIdMap.containsKey(workPatternName.toString())) {</span>
<span class="nc" id="L1052">					addImportStatusMessage(</span>
<span class="nc" id="L1053">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_OT_EXTENSION_INVALID_WORK_PATTERN,</span>
<span class="nc" id="L1054">									new Object[] { otExtName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L1055">					hasErrors = true;</span>
				}
				
<span class="nc" id="L1058">				ShiftPattern workPattern = workPatternByIdMap.get(workPatternNameIdMap.get(workPatternName.toString()));</span>
<span class="nc" id="L1059">				ShiftOTExtension otExtension = null;</span>
				
				// Try to retrieve the vto event if it already exists within the scope, otherwise error.
<span class="nc bnc" id="L1062" title="All 2 branches missed.">				if(otExtNameIdMap.containsKey(otExtName)) {</span>
<span class="nc" id="L1063">					otExtension = WorkRulesModelHandler.getShiftOTExtensionByID(m_context, otExtNameIdMap.get(otExtName));</span>
				} else {
<span class="nc" id="L1065">					addImportStatusMessage(</span>
<span class="nc" id="L1066">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_OT_EXTENSION,</span>
<span class="nc" id="L1067">									new Object[] { otExtName.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L1068">					hasErrors = true;</span>
				}
				
<span class="nc" id="L1071">				ShiftPattern.StartTime startTime = WorkRulesUtil.parseOTExtensionStartTimeText(m_localizer, otExtensionStartTime.toString());</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">				if(startTime == null) {</span>
<span class="nc" id="L1073">					addImportStatusMessage(</span>
<span class="nc" id="L1074">							m_localizer.i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_INVALID_OT_EXTENSION_START_TIME,</span>
<span class="nc" id="L1075">									new Object[] { otExtName.toString(), otExtensionStartTime.toString(), workPatternName.toString() }));</span>
<span class="nc" id="L1076">					hasErrors = true;</span>
				}
				
				// If there is a work pattern and vto event, find the work pattern in the running collection and add the vto event/start time.
				// After we are done with all the records we will cycle through the collection and set all the work pattern vto event/start times.
<span class="nc bnc" id="L1081" title="All 4 branches missed.">				if(workPattern != null &amp;&amp; otExtension != null) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">					if(hasErrors == true) {</span>
<span class="nc" id="L1083">						otExtensionsSkipped++;</span>
					} else {
<span class="nc" id="L1085">						HashMap&lt;ShiftOTExtension, StartTime&gt; map = new HashMap&lt;ShiftOTExtension, StartTime&gt;();</span>
						
<span class="nc bnc" id="L1087" title="All 2 branches missed.">						if(workPatternOTExtenstions.containsKey(workPattern.getID())) {</span>
							// If the work pattern is already being tracked, just add this definition.
<span class="nc" id="L1089">							map = workPatternOTExtenstions.get(workPattern.getID());</span>
<span class="nc" id="L1090">							map.put(otExtension, startTime);</span>
						} else {
							// Not tracked, add a new entry
<span class="nc" id="L1093">							map.put(otExtension, startTime);</span>
<span class="nc" id="L1094">							workPatternOTExtenstions.put(workPattern.getID(), map);</span>
						}
					}
				}
<span class="nc" id="L1098">			}</span>
			
<span class="nc bnc" id="L1100" title="All 2 branches missed.">			for(Entry&lt;ID, HashMap&lt;ShiftOTExtension, StartTime&gt;&gt; entry : workPatternOTExtenstions.entrySet()) {</span>
<span class="nc" id="L1101">				ShiftPattern wp = workPatternByIdMap.get(entry.getKey());</span>
<span class="nc" id="L1102">				wp.setOTExtensionStartTimes(entry.getValue());</span>
<span class="nc" id="L1103">				vtoWorkPatternsToUpdate.add(wp);</span>
<span class="nc" id="L1104">			}</span>
<span class="nc" id="L1105">			WorkRulesModelHandler.updateShiftPatterns(m_context, vtoWorkPatternsToUpdate);</span>
<span class="nc" id="L1106">		} catch (Exception ex) {</span>
<span class="nc" id="L1107">			log.error(ex);</span>
<span class="nc" id="L1108">			addPageMessage(new Message(Message.ERROR_TYPE,</span>
<span class="nc" id="L1109">					i18n(m_fsResourceBundle, FsWebBundleKey.FS_WORK_PATTERN_IMPORT_ERROR_PROCESSING_OT_EXTENSIONS)));</span>
<span class="nc" id="L1110">		}</span>
<span class="nc" id="L1111">	}</span>

	/**
	 * Return URL for HTML Form Action
	 */
	public String getFormAction() {
<span class="nc" id="L1117">		return FORM_ACTION;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>