<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleEventHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">ScheduleEventHandler.java</span></div><h1>ScheduleEventHandler.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  This class reacts to various events happening the schedule
 *               access manager EJB, such creation of an event, publishing of
 *               the schedule, etc.
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.PatternLayout;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringFloatingEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ValueObjectAggEventTemplate;
import com.bluepumpkin.ejb.bbm.schedulelock.ejb.ScheduleLockManager;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffHoursManagerBridge;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.witness.ejb.core.gcr.ejb.GCRManager;
import com.witness.ejb.core.gcr.model.GCREntry;

/**
 * Note that all of the methods have package scope because they are only meant
 * to be called by Schedule Access Manager EJB implementation class
 */
class ScheduleEventHandler {
	private final Category m_cat;
	private final ResourceBundle m_bundle; // for logging only, so we use default
										// locale
	private final Localizer m_defLocalizer;
	private final ScheduleLockManager m_lockManager;
	private final EventAuditTrailManager m_auditManager;
	private final ScheduleAccessManager m_scheduleAccessManager;

	/**
	 * ctor
	 */
	ScheduleEventHandler(Category cat, ScheduleLockManager lockManager, EventAuditTrailManager auditManager,
			ScheduleAccessManager scheduleAccessManager) {
<span class="fc" id="L76">		this(cat, lockManager, auditManager, scheduleAccessManager, DefaultLocalizationManager</span>
<span class="fc" id="L77">				.getDefaultInstance().getLocalizer(), DefaultLocalizationManager.getDefaultInstance().getLocalizer()</span>
<span class="fc" id="L78">				.getBundle(BbmEjbLogBundleKey.BUNDLE_NAME));</span>
<span class="fc" id="L79">	}</span>

	ScheduleEventHandler(Category cat, ScheduleLockManager lockManager, EventAuditTrailManager auditManager,
<span class="fc" id="L82">			ScheduleAccessManager scheduleAccessManager, Localizer localizer, ResourceBundle bundle) {</span>
<span class="fc" id="L83">		m_cat = cat;</span>
<span class="fc" id="L84">		m_defLocalizer = localizer;</span>
<span class="fc" id="L85">		m_bundle = bundle;</span>
<span class="fc" id="L86">		m_lockManager = lockManager;</span>
<span class="fc" id="L87">		m_auditManager = auditManager;</span>
<span class="fc" id="L88">		m_scheduleAccessManager = scheduleAccessManager;</span>
<span class="fc" id="L89">	}</span>

	Map&lt;ID, EmployeeName&gt; getEmployeeNamesMap(Collection&lt;ID&gt; workResourceIDs) {
<span class="fc" id="L92">		CachePerEJBMethod cache = CachePerEJBMethod.getCache();</span>
<span class="fc" id="L93">		return cache.getEmployeeNames(workResourceIDs);</span>
	}

	private void createAuditTrailForUnpublishedEvent(Event event, short action) throws Exception {
<span class="nc" id="L97">		createAuditTrailForUnpublishedEvent(event.getWorkResourceIDs(), event, action);</span>
<span class="nc" id="L98">	}</span>

	private void createAuditTrailForUnpublishedEvent(Collection c, Event event, short action) throws Exception {
<span class="fc" id="L101">		createAuditTrailForUnpublishedEvent(c, event, event.getStartTime(), event.getDuration(), action);</span>
<span class="fc" id="L102">	}</span>

	private void createAuditTrailForUnpublishedEvent(Collection c, Event event, Date st, int duration, short action)
			throws Exception {
		/*
		 * ArrayList listAuditTrails = new ArrayList(); for (Iterator it =
		 * c.iterator(); it.hasNext(); ) { ID workResourceID= (ID) it.next();
		 * listAuditTrails.add(new EventAuditTrailEntry( workResourceID,
		 * event.getID(), event.getEventType(), action, st, duration, false)); }
		 * m_auditManager.createAuditTrail(listAuditTrails);
		 */
<span class="fc" id="L113">		ArrayList list = new ArrayList(1);</span>
<span class="fc" id="L114">		list.add(event);</span>
<span class="fc" id="L115">		createAuditTrailEntry(c, list, action, AuditTrailEntry.MODULE_SCHEDULING, false);</span>
<span class="fc" id="L116">	}</span>

	private void createAuditTrailForUnpublishedEventTemplate(CalendarEventTemplate cet, short action) throws Exception {
<span class="nc" id="L119">		createAuditTrailForUnpublishedEventTemplate(cet.getWorkResourceIDs(), cet, action);</span>
<span class="nc" id="L120">	}</span>

	private void createAuditTrailForUnpublishedEventTemplate(Collection col, CalendarEventTemplate cet, short action)
			throws Exception {
<span class="nc" id="L124">		createAuditTrailForUnpublishedEventTemplate(col, cet,</span>
<span class="nc" id="L125">				((ValueObjectAggEventTemplate) cet).getEarliestPossibleStartTime(), cet.getDuration(), action);</span>
<span class="nc" id="L126">	}</span>

	private void createAuditTrailForUnpublishedEventTemplate(Collection col, CalendarEventTemplate cet, Date start,
			int duration, short action) throws Exception {
<span class="nc" id="L130">		ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L131">		list.add(cet);</span>
<span class="nc" id="L132">		createAuditTrailEntry(col, list, action, AuditTrailEntry.MODULE_SCHEDULING, true);</span>
<span class="nc" id="L133">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to check the
	 * pre-conditions before creating an event
	 */
	void preCreateEvent(Object lockID, Event event) throws Exception {
<span class="nc" id="L140">		preCreateEvents(lockID, Arrays.asList(event));</span>
<span class="nc" id="L141">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event gets created
	 */
	void postCreateEvent(Event event) throws Exception {
<span class="fc" id="L148">		postCreateEvents(Arrays.asList(event));</span>
<span class="fc" id="L149">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to check the
	 * pre-conditions before creating an event
	 */
	void preCreateEvents(Object lockID, Collection events) throws Exception {
<span class="fc" id="L156">		checkModifiable(lockID, events);</span>
<span class="fc" id="L157">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event gets created
	 */
	void postCreateEvents(Collection events) throws Exception {
<span class="fc" id="L164">		auditAndLogEventChange(events, null);</span>
<span class="fc" id="L165">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before an
	 * existing event gets updated
	 */
	void preUpdateEvent(Object lockID, Event oldEvent, Event newEvent) throws Exception {
<span class="fc" id="L172">		preUpdateEvents(lockID, Arrays.asList(oldEvent), Arrays.asList(newEvent));</span>
<span class="fc" id="L173">	}</span>

	void preUpdateEvents(Object lockID, Collection oldEvents, Collection newEvents) throws Exception {
<span class="fc" id="L176">		checkModifiable(lockID, oldEvents);</span>
<span class="fc" id="L177">		checkModifiable(lockID, newEvents);</span>
<span class="fc" id="L178">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing event gets updated
	 */
	void postUpdateEvent(Object lockID, Event oldEvent, Event newEvent) throws Exception {
		/*
		 * now check if there's another user that has locked the given schedule
		 * period, if so, reject the operation String lockObject= lockID != null
		 * &amp;&amp; lockID instanceof String ? (String)lockID : null;
		 * m_lockManager.checkEmployeeScheduleCanBeModified( lockObject,
		 * newEvent.getWorkResourceIDs(), newEvent.getStartTime(),
		 * newEvent.getEndTime());
		 */

		/** log the fact that we've just updated an event */
<span class="fc" id="L195">		Collection c3[] = WorkResourcesAndTimeRange.splitCollections(oldEvent.getWorkResourceIDs(),</span>
<span class="fc" id="L196">				newEvent.getWorkResourceIDs());</span>
		// Fix 98190 Changes made to the activity of Overtime not getting
		// published
		/*
		 * The change would not get through only if there is no other change
		 * apart from changing the activity for the Overtime period. i.e no
		 * change to shift length or overtime length or any other change.
		 */
<span class="fc" id="L204">		boolean bOvertimeActivityChange = true;</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">		if (c3[0] != null) // old employees removed from the event</span>
<span class="fc" id="L206">			createAuditTrailForUnpublishedEvent(c3[0], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="fc bfc" id="L207" title="All 2 branches covered.">		if (c3[2] != null) // new employees added to the event</span>
<span class="fc" id="L208">			createAuditTrailForUnpublishedEvent(c3[2], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">		if (c3[1] != null) // employees remained in the event</span>
		{
<span class="fc" id="L211">			Date n1 = newEvent.getStartTime(), n9 = newEvent.getEndTime(), o1 = oldEvent.getStartTime(), o9 = oldEvent</span>
<span class="fc" id="L212">					.getEndTime();</span>
<span class="pc bpc" id="L213" title="2 of 8 branches missed.">			boolean bSameTimes = n1.equals(o1) &amp;&amp; n9.equals(o9), bTimesIntersect = bSameTimes ? true : n1.before(o9)</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">					&amp;&amp; o1.before(n9);</span>
			// Fix 94726 - Changes to shift activities are not showing in web
			// after re-publishing from campaign in FS
			// let check all children of Shifassignment if they have any change
			// in case nothing was change for the Shift
<span class="fc" id="L219">			boolean bSameChilds = true;</span>
<span class="pc bpc" id="L220" title="1 of 6 branches missed.">			if (bSameTimes &amp;&amp; oldEvent instanceof ShiftAssignment &amp;&amp; newEvent instanceof ShiftAssignment) {</span>

<span class="fc" id="L222">				if ((((ShiftAssignment) oldEvent).getOTExtensionBeforeActivityID() != ((ShiftAssignment) newEvent)</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">						.getOTExtensionBeforeActivityID())</span>
<span class="fc" id="L224">						|| (((ShiftAssignment) oldEvent).getOTExtensionAfterActivityID() != ((ShiftAssignment) newEvent)</span>
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">								.getOTExtensionAfterActivityID())) {</span>
<span class="nc" id="L226">					bOvertimeActivityChange = false;</span>
				}
<span class="fc" id="L228">				Collection oldChildCol = ((ShiftAssignment) oldEvent).getChildren();</span>
<span class="fc" id="L229">				Collection newChildCol = ((ShiftAssignment) newEvent).getChildren();</span>

				// Reset all old Child Events Id to null to make sure that the
				// objects are compare base on Start &amp; End time
<span class="fc bfc" id="L233" title="All 2 branches covered.">				for (Iterator it = oldChildCol.iterator(); it.hasNext();) {</span>
<span class="fc" id="L234">					((ShiftEventAssignment) it.next()).setID(null);</span>
				}

<span class="pc bpc" id="L237" title="1 of 4 branches missed.">				if (!(oldChildCol.containsAll(newChildCol) &amp;&amp; newChildCol.containsAll(oldChildCol)))</span>
<span class="fc" id="L238">					bSameChilds = false;</span>
			}
			// Change start for QA-96353
			// this checks if there is a change in meeting attending status for
			// any of the work resource id.
<span class="fc" id="L243">			boolean bResourceAllattendingSync = true;</span>
			// for QC-90782,this boolean is to check whether old event's
			// comments and new event's comments are in sync or not
<span class="fc" id="L246">			boolean bDescriptionSync = true;</span>
<span class="fc" id="L247">			boolean bOverlapTypesSync = true;</span>
<span class="fc" id="L248">			boolean eventIsCalendarEvent = (oldEvent instanceof CalendarEvent);</span>
<span class="pc bpc" id="L249" title="6 of 8 branches missed.">			if (c3[1] != null &amp;&amp; (eventIsCalendarEvent &amp;&amp; bSameTimes &amp;&amp; bSameChilds &amp;&amp;</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">					newEvent.getActivityID().equals(oldEvent.getActivityID()))) {</span>
<span class="nc" id="L251">				Collection oldIds = c3[1];</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">				for (Iterator oldId = oldIds.iterator(); oldId.hasNext();) {</span>
<span class="nc" id="L253">					ID id = (ID) oldId.next();</span>
<span class="nc" id="L254">					if (((CalendarEvent) oldEvent).isWorkResourceAttending(id) != ((CalendarEvent) newEvent)</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">							.isWorkResourceAttending(id)) {</span>
<span class="nc" id="L256">						bResourceAllattendingSync = false;</span>
<span class="nc" id="L257">						break;</span>
					}
<span class="nc" id="L259">				}</span>
				// for QC-90782,set bDescriptionSync=false only if old event's
				// comment is not equal to new event's comments .
<span class="nc bnc" id="L262" title="All 2 branches missed.">				if (!(((CalendarEvent) oldEvent).getDescription() == null &amp;&amp; ((CalendarEvent) newEvent)</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">						.getDescription() == null)) {</span>

<span class="nc bnc" id="L265" title="All 2 branches missed.">					if (((CalendarEvent) oldEvent).getDescription() == null</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">							|| ((CalendarEvent) newEvent).getDescription() == null</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">							|| !((CalendarEvent) oldEvent).getDescription().equals(</span>
<span class="nc" id="L268">									((CalendarEvent) newEvent).getDescription())) {</span>

<span class="nc" id="L270">						bDescriptionSync = false;</span>
					}
				}

<span class="nc" id="L274">				bOverlapTypesSync = getOverlapTypesSync(oldEvent, newEvent);</span>
			}
			// Fix 93421, For employees stay in the same calendar event (not be
			// removed or updated from the attendee list).
			// and calendar event start time, end time don't change
			// --&gt; These employees don't have any updates
			// --&gt; don't need to create AuditTrailEntry these employees
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">			if (bTimesIntersect) {</span>
				// for QC-90782, added bDescriptionSync in the condition
<span class="pc bpc" id="L283" title="4 of 14 branches missed.">				if (!(bResourceAllattendingSync &amp;&amp; bSameTimes &amp;&amp; bSameChilds &amp;&amp; newEvent.getActivityID().equals(oldEvent.getActivityID())</span>
						&amp;&amp; bOvertimeActivityChange &amp;&amp; bDescriptionSync &amp;&amp; bOverlapTypesSync)) {
					// for QA-96353, added bResourceAllattendingSync in the
					// condition
					// for QC-98190 added bOvertimeActivityChange in the
					// condition
<span class="fc" id="L289">					createAuditTrailForUnpublishedEvent(c3[1], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="fc" id="L290">					createAuditTrailForUnpublishedEvent(c3[1], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
				}
				/*
				 * this case has been taken care at the very beginning as c3[0]
				 * - QC70842, QC59392 else { // actually, it is possible that
				 * nothing changed. // e.g., we could remove one attendee...
				 * Date st= n1.before(o1) ? n1 : o1, end= n9.before(o9) ? o9 :
				 * n9; createAuditTrailForUnpublishedEvent(c3[1], newEvent, st,
				 * (int)((end.getTime() - st.getTime()) /
				 * ShiftAssignment.MILLIS_IN_ONE_MIN),
				 * AuditTrailEntry.ACTION_UPDATE_OBJECT);
				 * 
				 * }
				 */
			} else {
<span class="nc" id="L305">				createAuditTrailForUnpublishedEvent(c3[1], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc" id="L306">				createAuditTrailForUnpublishedEvent(c3[1], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
			}
			// Change end for QA-96353
		}
<span class="pc bpc" id="L310" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="fc" id="L311">			m_cat.l7dInfo(</span>
					BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT,
<span class="fc" id="L313">					new Object[] { getEventTypeString(newEvent.getEventType()), newEvent.getID(),</span>
<span class="fc" id="L314">							getEmployeeNames(newEvent.getWorkResourceIDs()), newEvent.getStartTime(),</span>
<span class="fc" id="L315">							NumberFactory.newInteger(newEvent.getDuration()) });</span>
		}
<span class="fc" id="L317">	}</span>

	boolean getOverlapTypesSync(Event oldEvent, Event newEvent) {
<span class="nc bnc" id="L320" title="All 2 branches missed.">		return ((CalendarEvent)newEvent).getOverlapType() == ((CalendarEvent)oldEvent).getOverlapType();</span>
	}

	void postUpdateEvents(Object lockID, Collection newEvents, HashMap oldIdEventMap) throws Exception {
<span class="nc" id="L324">		ArrayList auditRecords = new ArrayList();</span>
<span class="nc" id="L325">		Event event = null;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (Iterator i = newEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L327">			event = (Event) i.next();</span>
<span class="nc" id="L328">			auditRecords.addAll(getAuditTrailForUnpublihsedEvent(event, (Event) oldIdEventMap.get(event.getID())));</span>
		}
<span class="nc" id="L330">		m_auditManager.createAuditEntry(auditRecords);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just created a bunch of new shift
			 * assignments
			 */
<span class="nc" id="L337">			StringBuffer buf = new StringBuffer(200);</span>
<span class="nc bnc" id="L338" title="All 2 branches missed.">			for (Iterator it = newEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L339">				event = (Event) it.next();</span>
<span class="nc" id="L340">				buf.append(m_defLocalizer.i18n(</span>
						m_bundle,
						BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT_TEMPLATE,
<span class="nc" id="L343">						new Object[] { getEventTypeString(event.getEventType()), event.getID(),</span>
<span class="nc" id="L344">								getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="nc" id="L345">								NumberFactory.newInteger(event.getDuration()) }));</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">				if (it.hasNext())</span>
<span class="nc" id="L347">					buf.append(PatternLayout.LINE_SEP);</span>
			}
<span class="nc" id="L349">			m_cat.info(buf.toString());</span>
		}
<span class="nc" id="L351">	}</span>

	private Collection getAuditTrailForUnpublihsedEvent(Event newEvent, Event oldEvent) throws Exception {
<span class="nc" id="L354">		ArrayList list = new ArrayList();</span>
		/** log the fact that we've just updated an event */
<span class="nc" id="L356">		Collection c3[] = WorkResourcesAndTimeRange.splitCollections(oldEvent.getWorkResourceIDs(),</span>
<span class="nc" id="L357">				newEvent.getWorkResourceIDs());</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (c3[0] != null) // old employees removed from the event</span>
<span class="nc" id="L359">			list.addAll(getAuditTrailForUnpublishedEvent(c3[0], oldEvent, oldEvent.getStartTime(),</span>
<span class="nc" id="L360">					oldEvent.getDuration(), AuditTrailEntry.ACTION_DELETE_OBJECT));</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">		if (c3[2] != null) // new employees added to the event</span>
<span class="nc" id="L362">			list.addAll(getAuditTrailForUnpublishedEvent(c3[2], newEvent, newEvent.getStartTime(),</span>
<span class="nc" id="L363">					newEvent.getDuration(), AuditTrailEntry.ACTION_CREATE_OBJECT));</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		if (c3[1] != null) // employees remained in the event</span>
		{
<span class="nc" id="L366">			Date n1 = newEvent.getStartTime(), n9 = newEvent.getEndTime(), o1 = oldEvent.getStartTime(), o9 = oldEvent</span>
<span class="nc" id="L367">					.getEndTime();</span>
<span class="nc bnc" id="L368" title="All 8 branches missed.">			boolean bSameTimes = n1.equals(o1) &amp;&amp; n9.equals(o9), bTimesIntersect = bSameTimes ? true : n1.before(o9)</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">					&amp;&amp; o1.before(n9);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">			if (bTimesIntersect) {</span>
				// actually, it is possible that nothing changed.
				// e.g., we could remove one attendee...
<span class="nc bnc" id="L373" title="All 4 branches missed.">				Date st = n1.before(o1) ? n1 : o1, end = n9.before(o9) ? o9 : n9;</span>
<span class="nc" id="L374">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], newEvent, st,</span>
<span class="nc" id="L375">						(int) ((end.getTime() - st.getTime()) / ShiftAssignment.MILLIS_IN_ONE_MIN),</span>
						AuditTrailEntry.ACTION_UPDATE_OBJECT));
<span class="nc" id="L377">			} else {</span>
<span class="nc" id="L378">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], oldEvent, oldEvent.getStartTime(),</span>
<span class="nc" id="L379">						oldEvent.getDuration(), AuditTrailEntry.ACTION_DELETE_OBJECT));</span>
<span class="nc" id="L380">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], newEvent, newEvent.getStartTime(),</span>
<span class="nc" id="L381">						newEvent.getDuration(), AuditTrailEntry.ACTION_CREATE_OBJECT));</span>
			}
		}
<span class="nc" id="L384">		return list;</span>
	}

	private Collection getAuditTrailForUnpublishedEvent(Collection c, Event event, Date st, int duration, short action)
			throws Exception {
<span class="nc" id="L389">		List&lt;AuditTrailEntry&gt; listAuditTrails = new ArrayList&lt;AuditTrailEntry&gt;();</span>
<span class="nc" id="L390">		Map mapNames = collectEmployeeOrPhantomNameList(c);</span>
<span class="nc bnc" id="L391" title="All 2 branches missed.">		for (Iterator it = c.iterator(); it.hasNext();) {</span>
<span class="nc" id="L392">			ID workResourceID = (ID) it.next();</span>

<span class="nc" id="L394">			AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING,</span>
<span class="nc" id="L395">					AuditTrailEntry.ACTION_UPDATE_OBJECT, workResourceID, (mapNames.get(workResourceID)).toString(),</span>
<span class="nc" id="L396">					event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L397">			entry.setTimeStamp(new Date());</span>
<span class="nc" id="L398">			entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(event.getEventType()), &quot;-1&quot;, false);</span>

<span class="nc" id="L400">			listAuditTrails.add(entry);</span>
<span class="nc" id="L401">		}</span>
<span class="nc" id="L402">		return listAuditTrails;</span>
	}

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a given type is about to be deleted
	 */
	void preDeleteEvents(Object lockID, Collection listEvents) throws Exception {
<span class="fc" id="L410">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">		if (range != null) {</span>
<span class="pc bpc" id="L412" title="1 of 4 branches missed.">			String lockObject = lockID != null &amp;&amp; lockID instanceof String ? (String) lockID : null;</span>
<span class="fc" id="L413">			m_lockManager.checkEmployeeScheduleCanBeModified(lockObject, range.getWorkResources(), range.getMinStart(),</span>
<span class="fc" id="L414">					range.getMaxEnd());</span>
		}
<span class="fc" id="L416">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a given type gets deleted
	 */
	void postDeleteEvents(Collection listEvents) throws Exception {
<span class="fc" id="L423">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">		if (range == null)</span>
<span class="fc" id="L425">			return;</span>

		/** log the fact that we've just deleted a bunch of events */
<span class="fc" id="L428">		createAuditTrailEntry(range.getWorkResources(), listEvents, AuditTrailEntry.ACTION_DELETE_OBJECT,</span>
				AuditTrailEntry.MODULE_SCHEDULING, false);

<span class="pc bpc" id="L431" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/*
			 * find the employee names for all work resource ids whose events
			 * are being deleted
			 */

<span class="fc" id="L437">			Map&lt;ID, EmployeeName&gt; mapNames = getEmployeeNamesMap(range.getWorkResources());</span>

<span class="fc" id="L439">			StringBuffer buf = new StringBuffer(300);</span>
<span class="fc" id="L440">			buf.append(m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENTS));</span>

			// MessageFormat formatter = new MessageFormat (&quot;&quot;);
			// formatter.setLocale(Locale.getDefault());
			// formatter.applyPattern(m_bundle.getString(BbmEjbBundleKey.SCHEDULE_DELETED_EVENT));
<span class="fc bfc" id="L445" title="All 2 branches covered.">			for (Iterator it = listEvents.iterator(); it.hasNext();) {</span>
<span class="fc" id="L446">				Event event = (Event) it.next();</span>
<span class="fc" id="L447">				buf.append(PatternLayout.LINE_SEP);</span>
<span class="fc" id="L448">				buf.append(m_defLocalizer.i18n(</span>
						m_bundle,
						BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENT,
<span class="fc" id="L451">						new Object[] { getEventTypeString(event.getEventType()), event.getID(),</span>
<span class="fc" id="L452">								getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="fc" id="L453">								NumberFactory.newInteger(event.getDuration()) }));</span>
<span class="fc" id="L454">			}</span>
<span class="fc" id="L455">			m_cat.info(buf.toString());</span>
		}
<span class="fc" id="L457">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a set
	 * of shift assignments gets created
	 */
	void preCreateShiftAssignments(Object lockID, Collection listEvents) throws Exception {
<span class="fc" id="L464">		checkModifiable(lockID, listEvents);</span>
<span class="fc" id="L465">	}</span>

	private void checkModifiable(Object lockID, Collection events) throws Exception {
<span class="fc" id="L468">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(events);</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">		if (range != null) {</span>
<span class="fc" id="L470">			Iterator it = events.iterator();</span>
<span class="fc" id="L471">			ID campaignID = null; // Jason: so far, we don't support to create a</span>
									// list of shifts belonging to diff
									// campaigns in one shoot
<span class="fc" id="L474">			ID id = null;</span>
<span class="fc bfc" id="L475" title="All 2 branches covered.">			while (it.hasNext()) {</span>
<span class="fc" id="L476">				Object event = it.next();</span>
<span class="fc bfc" id="L477" title="All 2 branches covered.">				if (event instanceof ShiftAssignment) {</span>
<span class="fc" id="L478">					id = ((ShiftAssignment) event).getCampaignID();</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">					if (campaignID == null)</span>
<span class="fc" id="L480">						campaignID = id;</span>
<span class="pc bpc" id="L481" title="2 of 4 branches missed.">					else if (id != null &amp;&amp; !id.equals(campaignID)) {</span>
<span class="nc" id="L482">						throw new BbmUpdateException(&quot; Don't support to create/update shifts in different campaigns.&quot;);</span>
					}
				}
<span class="fc" id="L485">			}</span>
<span class="fc bfc" id="L486" title="All 2 branches covered.">			if (campaignID != null)</span>
<span class="fc" id="L487">				m_lockManager.checkIfEmployeeExistingInSP(campaignID, range.getWorkResources());</span>

<span class="pc bpc" id="L489" title="1 of 4 branches missed.">			String lockObject = lockID != null &amp;&amp; lockID instanceof String ? (String) lockID : null;</span>
<span class="fc" id="L490">			m_lockManager.checkEmployeeScheduleCanBeModified(lockObject, range.getWorkResources(), range.getMinStart(),</span>
<span class="fc" id="L491">					range.getMaxEnd());</span>
		}
<span class="fc" id="L493">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of shift assignments gets created
	 */
	void postCreateShiftAssignments(Collection listEvents) throws Exception {
		/**
		 * log the fact that we've just created a bunch of new shift assignments
		 */
		// MessageFormat formatter = new MessageFormat (&quot;&quot;);
		// formatter.setLocale(Locale.getDefault());
		// formatter.applyPattern(m_bundle.getString(BbmEjbBundleKey.SCHEDULE_CREATED_EVENT));
		/* all the event should have te same type - shift assignment */
<span class="fc" id="L507">		String strEventType = getEventTypeString(Event.EVENT_TYPE_SHIFT_ASSIGNMENT);</span>
<span class="fc" id="L508">		auditAndLogEventChange(listEvents, strEventType);</span>
<span class="fc" id="L509">	}</span>

	private void auditAndLogEventChange(Collection listEvents, String eventType) throws Exception {
<span class="fc" id="L512">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">		if (range == null)</span>
<span class="fc" id="L514">			return;</span>

<span class="fc" id="L516">		createAuditTrailEntry(range.getWorkResources(), listEvents, AuditTrailEntry.ACTION_CREATE_OBJECT,</span>
				AuditTrailEntry.MODULE_SCHEDULING, false);

<span class="pc bpc" id="L519" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just created a bunch of new shift
			 * assignments
			 */
<span class="fc" id="L524">			StringBuffer buf = new StringBuffer(200);</span>
<span class="fc" id="L525">			String typeString = eventType;</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">			for (Iterator it = listEvents.iterator(); it.hasNext();) {</span>
<span class="fc" id="L527">				Event event = (Event) it.next();</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">				if (eventType == null)</span>
<span class="fc" id="L529">					typeString = getEventTypeString(event.getEventType());</span>
<span class="fc" id="L530">				buf.append(m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_CREATED_EVENT, new Object[] {</span>
<span class="fc" id="L531">						typeString, event.getID(), getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="fc" id="L532">						NumberFactory.newInteger(event.getDuration()) }));</span>
<span class="fc bfc" id="L533" title="All 2 branches covered.">				if (it.hasNext())</span>
<span class="fc" id="L534">					buf.append(PatternLayout.LINE_SEP);</span>
<span class="fc" id="L535">			}</span>
<span class="fc" id="L536">			m_cat.info(buf.toString());</span>
		}
<span class="fc" id="L538">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before the
	 * schedule gets cleared for a set of employees and a given time window
	 */
	void preClearSchedule(String lockID, Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
<span class="nc" id="L545">		m_lockManager.checkEmployeeScheduleCanBeModified(lockID, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L546">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever the
	 * schedule gets cleared for a set of employees and a given time window
	 */
	void postClearSchedule(Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime, boolean unlockedOnly,
			Collection listEvents) throws Exception {
		// add audit trail entry, fix bug92949
		// createAuditTrailEntry(workResourceIDs, listEvents,
		// AuditTrailEntry.ACTION_DELETE_OBJECT,
		// AuditTrailEntry.MODULE_SCHEDULING, false);

<span class="fc" id="L559">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="fc" id="L560">		Collection&lt;AuditTrailEntry&gt; audits = new ArrayList&lt;AuditTrailEntry&gt;(listEvents.size());</span>

		// the bug fix of silk 92949 introduces too many of audit records and
		// too much of details. sql server is out of memory if
		// deleting shifts of 4 weeks sp for 1600 employees.
		// here we can simplify the audit record, for each workresource, one
		// record per shift with the impact time range, no other details; same
		// as 771
<span class="fc" id="L568">		Event event = null;</span>
<span class="fc" id="L569">		ID workResourceID = null;</span>
<span class="fc" id="L570">		Date impactStart = null, impactEnd = null;</span>
<span class="fc" id="L571">		AuditTrailEntry entry = null;</span>
<span class="fc bfc" id="L572" title="All 2 branches covered.">		for (Iterator i = listEvents.iterator(); i.hasNext();) {</span>
<span class="fc" id="L573">			event = (Event) i.next();</span>
<span class="fc" id="L574">			workResourceID = event.getWorkResourceIDs().iterator().next();</span>
<span class="fc" id="L575">			impactStart = event.getStartTime();</span>
<span class="fc" id="L576">			impactEnd = event.getEndTime();</span>
<span class="fc" id="L577">			entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_DELETE_OBJECT,</span>
<span class="fc" id="L578">					workResourceID, (mapNames.get(workResourceID)).toString(), impactStart, impactEnd);</span>
<span class="fc" id="L579">			entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(event.getEventType()), &quot;-1&quot;, false);//Audit Viewer shows &quot;An existing unknown for employee 'Employee, New' has been removed. It starts from 08/09/2013 11:45 AM to 08/09/2013 7:45 PM.&quot; in the audit viewer under the scheduling module with the action type of delete. - ESR#4102298</span>
<span class="fc" id="L580">			audits.add(entry);</span>
		}
<span class="fc" id="L582">		m_auditManager.createAuditEntry(audits);</span>

<span class="pc bpc" id="L584" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just deleted a bunch of shift assignments
			 */
<span class="pc bpc" id="L588" title="1 of 2 branches missed.">			if (!unlockedOnly) {</span>
<span class="fc" id="L589">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CLEARED_SCHEDULE, new Object[] {</span>
<span class="fc" id="L590">						getEmployeeNames(workResourceIDs), startTime, endTime });</span>
			} else {
<span class="nc" id="L592">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CLEARED_SCHEDULE_UNLOCKED_ONLY, new Object[] {</span>
<span class="nc" id="L593">						getEmployeeNames(workResourceIDs), startTime, endTime });</span>
			}
		}
<span class="fc" id="L596">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a new
	 * event template gets created
	 */
	void preCreateEventTemplate(CalendarEventTemplate eventTemplate) throws Exception {
<span class="fc" id="L603">		preActionEventTemplate(eventTemplate);</span>
<span class="fc" id="L604">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event template gets created
	 */
	void postCreateEventTemplate(CalendarEventTemplate eventTemplate) throws Exception {
<span class="nc" id="L611">		createAuditTrailForUnpublishedEventTemplate(eventTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>

<span class="nc" id="L613">		Collection listAttendees = eventTemplate.getWorkResourceIDs();</span>
<span class="nc bnc" id="L614" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L615">			String strTemplateType = getEventTemplateTypeString(eventTemplate.getTemplateType());</span>
<span class="nc" id="L616">			Integer duration = NumberFactory.newInteger(eventTemplate.getDuration());</span>
<span class="nc" id="L617">			Object listNames = getEmployeeNames(listAttendees);</span>

			/** log the fact that we've just created a new event template */
<span class="nc" id="L620">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CREATED_EVENT_TEMPLATE, new Object[] { strTemplateType,</span>
<span class="nc" id="L621">					eventTemplate.getID(), listNames, duration });</span>
		}
<span class="nc" id="L623">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets updated
	 */
	void preUpdateEventTemplate(CalendarEventTemplate oldTemplate) throws Exception {
<span class="nc" id="L630">		preActionEventTemplate(oldTemplate);</span>
<span class="nc" id="L631">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets updated
	 */
	void postUpdateEventTemplate(CalendarEventTemplate oldTemplate, CalendarEventTemplate newTemplate) throws Exception {
<span class="nc bnc" id="L638" title="All 2 branches missed.">		if (newTemplate instanceof ValueObjectAggEventTemplate) {</span>
<span class="nc" id="L639">			ValueObjectAggEventTemplate calTemplate = (ValueObjectAggEventTemplate) newTemplate;</span>
<span class="nc" id="L640">			m_lockManager.checkEmployeeScheduleCanBeModified(null, calTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L641">					calTemplate.getEarliestPossibleStartTime(), calTemplate.getLatestPossibleEndTime());</span>
		}
		/** log the fact that we've just updated an event */
<span class="nc" id="L644">		Collection c3[] = WorkResourcesAndTimeRange.splitCollections(oldTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L645">				newTemplate.getWorkResourceIDs());</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">		if (c3[0] != null) // old employees removed from the event</span>
<span class="nc" id="L647">			createAuditTrailForUnpublishedEventTemplate(c3[0], oldTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">		if (c3[2] != null) // new employees added to the event</span>
<span class="nc" id="L649">			createAuditTrailForUnpublishedEventTemplate(c3[2], newTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (c3[1] != null) // employees remained in the event</span>
		{
<span class="nc" id="L652">			Date n1 = ((ValueObjectAggEventTemplate) newTemplate).getEarliestPossibleStartTime(), n9 = ((ValueObjectAggEventTemplate) newTemplate)</span>
<span class="nc" id="L653">					.getLatestPossibleEndTime(), o1 = ((ValueObjectAggEventTemplate) oldTemplate)</span>
<span class="nc" id="L654">					.getEarliestPossibleStartTime(), o9 = ((ValueObjectAggEventTemplate) oldTemplate)</span>
<span class="nc" id="L655">					.getLatestPossibleEndTime();</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">			boolean bSameTimes= n1.equals(o1) &amp;&amp; n9.equals(o9);</span>
			
<span class="nc bnc" id="L658" title="All 2 branches missed.">			if (bSameTimes) {</span>
				// actually, it is possible that nothing changed.
				// e.g., we could remove one attendee...
<span class="nc bnc" id="L661" title="All 4 branches missed.">				Date st = n1.before(o1) ? n1 : o1, end = n9.before(o9) ? o9 : n9;</span>
<span class="nc" id="L662">				createAuditTrailForUnpublishedEventTemplate(c3[1], newTemplate, st,</span>
<span class="nc" id="L663">						(int) ((end.getTime() - st.getTime()) / ShiftAssignment.MILLIS_IN_ONE_MIN),</span>
						AuditTrailEntry.ACTION_UPDATE_OBJECT);
<span class="nc" id="L665">			} else {</span>
<span class="nc" id="L666">				createAuditTrailForUnpublishedEventTemplate(c3[1], oldTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc" id="L667">				createAuditTrailForUnpublishedEventTemplate(c3[1], newTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
			}
		}
		/*
		 * createAuditTrailForUnpublishedEventTemplate(newTemplate,
		 * AuditTrailEntry.ACTION_UPDATE_OBJECT);
		 */

<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L676">			String strTemplateType = getEventTemplateTypeString(newTemplate.getTemplateType());</span>
<span class="nc" id="L677">			Integer duration = NumberFactory.newInteger(newTemplate.getDuration());</span>
<span class="nc" id="L678">			Object listNames = getEmployeeNames(newTemplate.getWorkResourceIDs());</span>

			/** log the fact that we've just updated an existing event template */
<span class="nc" id="L681">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT_TEMPLATE, new Object[] { strTemplateType,</span>
<span class="nc" id="L682">					newTemplate.getID(), listNames, duration });</span>
		}
<span class="nc" id="L684">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets deleted
	 */
	void preDeleteEventTemplate(CalendarEventTemplate eventTemplate) throws Exception {
<span class="nc" id="L691">		preActionEventTemplate(eventTemplate);</span>
<span class="nc" id="L692">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets deleted
	 */
	void postDeleteEventTemplate(CalendarEventTemplate eventTemplate) throws Exception {
<span class="nc" id="L699">		Collection listAttendees = eventTemplate.getWorkResourceIDs();</span>
		/** log the fact that we've just deleted an existing event template */
<span class="nc" id="L701">		createAuditTrailForUnpublishedEventTemplate(eventTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L704">			String strTemplateType = getEventTemplateTypeString(eventTemplate.getTemplateType());</span>
<span class="nc" id="L705">			Integer duration = NumberFactory.newInteger(eventTemplate.getDuration());</span>
<span class="nc" id="L706">			Object listNames = getEmployeeNames(listAttendees);</span>

			/** log the fact that we've just updated an existing event template */
<span class="nc" id="L709">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENT_TEMPLATE, new Object[] { strTemplateType,</span>
<span class="nc" id="L710">					eventTemplate.getID(), listNames, duration });</span>
		}
<span class="nc" id="L712">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * exception to the recurring event template rule gets created
	 */
	void postCreateRecurringException(ID lockID, CalendarEventAssignment eventException) throws Exception {
		/*
		 * first check if there's another user that has locked the given
		 * schedule period, if so, reject the operation
		 */
<span class="nc" id="L723">		m_lockManager.checkEmployeeScheduleCanBeModified(null, eventException.getWorkResourceIDs(),</span>
<span class="nc" id="L724">				eventException.getStartTime(), eventException.getEndTime());</span>

<span class="nc" id="L726">		createAuditTrailForUnpublishedEvent(eventException, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>

<span class="nc bnc" id="L728" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just created an exception */
<span class="nc" id="L730">			m_cat.l7dInfo(</span>
					BbmEjbLogBundleKey.SCHEDULE_CREATED_RECURRING_EXCEPTION,
<span class="nc" id="L732">					new Object[] { eventException.getEventTemplateID(),</span>
<span class="nc" id="L733">							getEmployeeNames(eventException.getWorkResourceIDs()), eventException.getStartTime() });</span>
		}
<span class="nc" id="L735">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a
	 * recurring event instance gets deleted (i.e. there is a &quot;hole&quot; in the
	 * recurring event template rule)
	 */
	void preDeleteRecurringEventInstance(Collection listEvents, Collection workResourceIDs) throws Exception {
<span class="nc" id="L743">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">		if (range != null) {</span>
<span class="nc" id="L745">			m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, range.getMinStart(),</span>
<span class="nc" id="L746">					range.getMaxEnd());</span>
		}
<span class="nc" id="L748">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * recurring event instance gets deleted (i.e. there is a &quot;hole&quot; in the
	 * recurring event template rule)
	 */
	void postDeleteRecurringEventInstance(ID templateID, Collection listEvents, Collection workResourceIDs)
			throws Exception {
<span class="nc bnc" id="L757" title="All 2 branches missed.">		if (!listEvents.isEmpty()) {</span>
			/*
			 * we just need a single event from this collection because we are
			 * only interested in the event start and end time, and all
			 * instances in the collection have the same start/end times
			 */
<span class="nc" id="L763">			Event event = (Event) listEvents.iterator().next();</span>

<span class="nc" id="L765">			createAuditTrailForUnpublishedEvent(event, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>

<span class="nc bnc" id="L767" title="All 2 branches missed.">			if (m_cat.isInfoEnabled()) {</span>
				/**
				 * log the fact that we've just deleted a recurring event
				 * instance
				 */
<span class="nc" id="L772">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_DELETED_RECURRING_INSTANCE, new Object[] { templateID,</span>
<span class="nc" id="L773">						getEmployeeNames(workResourceIDs), event.getStartTime() });</span>
			}
		}
<span class="nc" id="L776">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is locked for the specified set of workresources in a
	 * given time window
	 */
	void preLockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
<span class="fc" id="L784">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="fc" id="L785">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is locked for the specified set of workresources in a
	 * given time window
	 */
	void postLockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
		// no audit trail event saved for now (b/c no event here)
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="fc" id="L796">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_LOCKED_EVENTS, new Object[] { getEmployeeNames(workResourceIDs),</span>
					startTime, endTime });
		}
		// generate audit records.
<span class="fc" id="L800">		generateAuditRecordForLockUnlockEvents(workResourceIDs, startTime, endTime);</span>
<span class="fc" id="L801">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is unlocked for the specified set of workresources in a
	 * given time window
	 */
	void preUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
<span class="nc" id="L809">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L810">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is unlocked for the specified set of workresources in a
	 * given time window
	 */
	void postUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws Exception { // no
																										// audit
																										// trail
																										// events
																										// saved
																										// for
																										// now
																										// (b/c
																										// no
																										// event
																										// here)
<span class="nc bnc" id="L828" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L830">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UNLOCKED_EVENTS, new Object[] {</span>
<span class="nc" id="L831">					getEmployeeNames(workResourceIDs), startTime, endTime });</span>
		}

		// generate audit records.
<span class="nc" id="L835">		generateAuditRecordForLockUnlockEvents(workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L836">	}</span>

	private void generateAuditRecordForLockUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime)
			throws Exception {
<span class="pc bpc" id="L840" title="2 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.isEmpty())</span>
<span class="nc" id="L841">			return;</span>
<span class="fc" id="L842">		Collection entries = new ArrayList(workResourceIDs.size());</span>
<span class="fc" id="L843">		ID empID = null;</span>
<span class="fc" id="L844">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="fc bfc" id="L845" title="All 2 branches covered.">		for (Iterator i = workResourceIDs.iterator(); i.hasNext();) {</span>
<span class="fc" id="L846">			empID = (ID) i.next();</span>
<span class="fc" id="L847">			entries.add(new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_UPDATE_OBJECT,</span>
<span class="fc" id="L848">					empID, (mapNames.get(empID)).toString(), startTime, endTime));</span>
		}
<span class="fc" id="L850">		m_auditManager.createAuditEntry(entries);</span>
<span class="fc" id="L851">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets published for the given set of work resources and the given
	 * time window
	 */
	void postPublishSchedule(Collection workResourceIDs, Date dtStartDate, Date dtEndDate,
			ScheduleChangeDetails changeDetails) throws Exception { // no audit
																	// trail
																	// events
																	// here
		/** need to notify that there's a change in published schedule */
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">		if (changeDetails != null) {</span>
<span class="nc" id="L865">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
			/*
			 * this call moved to ScheduleAccessManagerEJB
			 * triggerTONotification(changeDetails);
			 */
		}

<span class="pc bpc" id="L872" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="fc" id="L874">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_PUBLISHED_SCHEDULE, new Object[] {</span>
<span class="fc" id="L875">					getEmployeeNames(workResourceIDs), dtStartDate, dtEndDate });</span>
		}
<span class="fc" id="L877">	}</span>

	void postPublishEvent(Collection events, ScheduleChangeDetails changeDetails) throws Exception {
		/** need to notify that there's a change in published schedule */
<span class="pc bpc" id="L881" title="1 of 2 branches missed.">		if (changeDetails != null)</span>
<span class="nc" id="L882">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>

<span class="pc bpc" id="L884" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled())</span>
			/** log the fact that we've just published a schedule */
<span class="fc" id="L886">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_PUBLISHED_EVENT, new Object[] { events });</span>
<span class="fc" id="L887">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * published schedule gets updated for the given set of work resources and
	 * the given time window
	 */
	void postUpdatePublishedSchedule(Collection workResourceIDs, Date dtStartDate, Date dtEndDate,
			ScheduleChangeDetails changeDetails) throws Exception { // no audit
																	// trail
																	// event
																	// here
		/** need to notify that there's a change in published schedule */
<span class="nc bnc" id="L900" title="All 2 branches missed.">		if (changeDetails != null) {</span>
<span class="nc" id="L901">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		}

<span class="nc bnc" id="L904" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L906">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UPDATED_PUBLISHED_SCHEDULE, new Object[] {</span>
<span class="nc" id="L907">					getEmployeeNames(workResourceIDs), dtStartDate, dtEndDate });</span>
		}
<span class="nc" id="L909">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets un-published for the given set of work resources and the
	 * given time window
	 */
	void postUnPublishSchedule(Collection workResourceIDs, Date startTime, Date endTime)
			throws BbmSchedulePublishingException { // no audit trail event here
		/** need to notify to TO recalculator */
<span class="fc" id="L919">		ScheduleChangeDetails changeDetails = new ScheduleChangeDetails(workResourceIDs, startTime, endTime,</span>
				Collections.EMPTY_LIST, Collections.EMPTY_LIST);
<span class="fc" id="L921">		changeDetails.setIsPublish(false);</span>
<span class="fc" id="L922">		JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		// Adding TO Notification here based on suggestions from angela. Sameet
		// Sept 2007
		try {
<span class="fc" id="L926">			triggerTONotification(changeDetails, false);</span>
<span class="nc" id="L927">		} catch (Exception e) {</span>

<span class="nc" id="L929">			throw new BbmSchedulePublishingException(e);</span>
<span class="fc" id="L930">		}</span>
<span class="pc bpc" id="L931" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just un-published a schedule */
<span class="fc" id="L933">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UNPUBLISHED_SCHEDULE, new Object[] {</span>
<span class="fc" id="L934">					getEmployeeNames(workResourceIDs), startTime, endTime });</span>
		}
<span class="fc" id="L936">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets reverted to published state for the given set of work
	 * resources and the given time window
	 */
	void preRevertToPublishedSchedule(Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
<span class="nc" id="L944">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L945">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets reverted to published state for the given set of work
	 * resources and the given time window
	 */
	void postRevertToPublishedSchedule(Collection workResourceIDs, Date startTime, Date endTime) throws Exception {
		// add audit trail here
<span class="nc" id="L954">		ID workResourceID = null;</span>
<span class="nc" id="L955">		AuditTrailEntry entry = null;</span>
<span class="nc" id="L956">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="nc" id="L957">		Date cur = new Date();</span>
<span class="nc" id="L958">		ArrayList auditTrailEntries = new ArrayList(workResourceIDs.size());</span>
<span class="nc bnc" id="L959" title="All 2 branches missed.">		for (Iterator j = workResourceIDs.iterator(); j.hasNext();) {</span>
<span class="nc" id="L960">			workResourceID = (ID) j.next();</span>
<span class="nc" id="L961">			entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_CREATE_OBJECT,</span>
<span class="nc" id="L962">					workResourceID, (mapNames.get(workResourceID)).toString(), startTime, endTime);</span>
<span class="nc" id="L963">			entry.setTimeStamp(cur);</span>
<span class="nc" id="L964">			auditTrailEntries.add(entry);</span>
		}

<span class="nc" id="L967">		m_auditManager.createAuditEntry(auditTrailEntries);</span>
<span class="nc bnc" id="L968" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just reverted the schedule to published
			 * state
			 */
<span class="nc" id="L973">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_REVERTED_SCHEDULE, new Object[] {</span>
<span class="nc" id="L974">					getEmployeeNames(workResourceIDs), startTime, endTime });</span>
		}
<span class="nc" id="L976">	}</span>

	/**
	 * This is a method that returns an event type string given an integer event
	 * type
	 */
	protected String getEventTypeString(int eventType) {
<span class="fc" id="L983">		String bundleKey = BbmEjbLogBundleKey.SCHEDULE_EVENT_TYPE_PREFIX + eventType;</span>
		String strEventType;
		try {
<span class="fc" id="L986">			strEventType = m_defLocalizer.i18n(m_bundle, bundleKey);</span>
<span class="nc" id="L987">		} catch (MissingResourceException mre) {</span>
<span class="nc" id="L988">			bundleKey = BbmEjbLogBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE;</span>
<span class="nc" id="L989">			strEventType = m_defLocalizer.i18n(m_bundle, bundleKey,</span>
<span class="nc" id="L990">					new Object[] { NumberFactory.newInteger(eventType) });</span>
<span class="fc" id="L991">		}</span>
<span class="fc" id="L992">		return strEventType;</span>
	}

	/**
	 * This is a method that returns an event template type string given an
	 * event template type
	 */
	private String getEventTemplateTypeString(int templateType) {
		String strTemplateType;
		try {
<span class="nc" id="L1002">			strTemplateType = m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_EVENT_TEMPLATE_TYPE_PREFIX</span>
					+ templateType);
<span class="nc" id="L1004">		} catch (MissingResourceException mre) {</span>
<span class="nc" id="L1005">			strTemplateType = m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE,</span>
<span class="nc" id="L1006">					new Object[] { NumberFactory.newInteger(templateType) });</span>
<span class="nc" id="L1007">		}</span>
<span class="nc" id="L1008">		return strTemplateType;</span>
	}

	/**
	 * Private method that returns a collection of displayable employee names
	 * for a given collection of work resource IDs
	 */
	private Object getEmployeeNames(Collection&lt;ID&gt; workResourceIDs) {
<span class="fc" id="L1016">		Map&lt;ID, EmployeeName&gt; mapNames = getEmployeeNamesMap(workResourceIDs);</span>
		// I hope actual locale is not needed to represent employee names
		// - umm, except for &quot;Unknown&quot;... And name format...
		// But actually, it is for Logging only
<span class="fc" id="L1020">		return EmployeeName.getEmployeeDisplayNames(mapNames.values(), DefaultLocalizationManager.getDefaultInstance()</span>
<span class="fc" id="L1021">				.getLocalizer());</span>
	}

	private String getActivityName(ID id) {
<span class="nc" id="L1025">		CachePerEJBMethod cache = CachePerEJBMethod.getCache();</span>
<span class="nc" id="L1026">		Activity activity = cache.getActivity(id);</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">		if (activity != null)</span>
<span class="nc" id="L1028">			return activity.getName();</span>
<span class="nc" id="L1029">		return &quot;unknown&quot;;</span>
	}

	public static void triggerTONotificationOnTOApproval(ScheduleChangeDetails changeDetails) throws BbmUpdateException {
		try {
<span class="nc" id="L1034">			int msgType = TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_TO_ONLY;</span>
<span class="nc" id="L1035">			TONotifyMessage msg = new TONotifyMessage(msgType);</span>
<span class="nc" id="L1036">			msg.setEmployeeIDs(changeDetails.getWorkResourceIDs());</span>
<span class="nc" id="L1037">			msg.setObject(changeDetails);</span>
<span class="nc" id="L1038">			msg.sendMessage();</span>
<span class="nc" id="L1039">		} catch (Exception e) {</span>
<span class="nc" id="L1040">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1041">		}</span>

<span class="nc" id="L1043">	}</span>

	public static void triggerTONotification(ScheduleChangeDetails changeDetails, boolean isBatchPublish)
			throws BbmUpdateException {
		try {
<span class="fc bfc" id="L1048" title="All 2 branches covered.">			int msgType = changeDetails.isPublish() ? TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH</span>
					: TONotifyMessage.TO_NOTIFY_SCHED_UNPUBLISH;
<span class="pc bpc" id="L1050" title="1 of 4 branches missed.">			if (changeDetails.isPublish() &amp;&amp; isBatchPublish) {</span>
<span class="fc" id="L1051">				msgType = TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_PART;</span>
			}
<span class="fc" id="L1053">			TONotifyMessage msg = new TONotifyMessage(msgType);</span>
<span class="fc" id="L1054">			msg.setEmployeeIDs(changeDetails.getWorkResourceIDs());</span>
<span class="fc" id="L1055">			msg.setObject(changeDetails);</span>
<span class="fc" id="L1056">			msg.sendMessage();</span>
<span class="nc" id="L1057">		} catch (Exception e) {</span>
<span class="nc" id="L1058">			throw new BbmUpdateException(e);</span>
<span class="fc" id="L1059">		}</span>

<span class="fc" id="L1061">	}</span>

	public void triggerTONotificationSynrchronized(ScheduleChangeDetails changeDetails) throws Exception {
<span class="fc" id="L1064">		String gcrType = &quot;TIMEOFFHOURSMANAGER_BRIDGE&quot;;</span>
<span class="fc" id="L1065">		GCRManager m_gcrManager = CoreManagerFactory.getGCRManagerRemote(false);</span>
<span class="fc" id="L1066">		Collection entries = m_gcrManager.getGCREntryOfType(gcrType);</span>
<span class="fc" id="L1067">		Class clazz = Class.forName(((GCREntry) (entries.iterator().next())).getHook());</span>
<span class="fc" id="L1068">		TimeOffHoursManagerBridge bridge = (TimeOffHoursManagerBridge) clazz.newInstance();</span>
<span class="fc" id="L1069">		bridge.updateHoursPerDay(changeDetails);</span>
<span class="fc" id="L1070">	}</span>

	public void triggerTONotification(Collection wrkResIds, Date startDate, Date endDate, boolean isPublish)
			throws BbmUpdateException {
		try {
<span class="pc bpc" id="L1075" title="1 of 2 branches missed.">			if (isPublish) { // We do not need unpublish notification for now</span>
<span class="fc" id="L1076">				TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_COMPLETE);</span>
<span class="fc" id="L1077">				msg.setEmployeeIDs(wrkResIds);</span>
<span class="fc" id="L1078">				msg.setStartDate(startDate);</span>
<span class="fc" id="L1079">				msg.setEndDate(endDate);</span>
<span class="fc" id="L1080">				msg.sendMessage();</span>
			}
<span class="nc" id="L1082">		} catch (Exception e) {</span>
<span class="nc" id="L1083">			throw new BbmUpdateException(e);</span>
<span class="fc" id="L1084">		}</span>
<span class="fc" id="L1085">	}</span>

	// ========= AUDIT TRAIL SUPPORT ===================

	public void createAuditTrailEntryForPublishing(Collection eventList, Collection publishedAttendeeList, short action)
			throws Exception {
<span class="fc" id="L1091">		createAuditTrailEntry(publishedAttendeeList, eventList, action, AuditTrailEntry.MODULE_PUBLISHING, false);</span>
<span class="fc" id="L1092">	}</span>

	public void createAuditTrailEntryForPublishing(Collection eventList, short action) throws Exception {
<span class="fc" id="L1095">		HashSet affectedAttendees = new HashSet();</span>
<span class="fc bfc" id="L1096" title="All 2 branches covered.">		for (Iterator i = eventList.iterator(); i.hasNext();) {</span>
<span class="fc" id="L1097">			affectedAttendees.addAll(((Event) i.next()).getWorkResourceIDs());</span>
		}
<span class="fc" id="L1099">		createAuditTrailEntry(affectedAttendees, eventList, action, AuditTrailEntry.MODULE_PUBLISHING, false);</span>
<span class="fc" id="L1100">	}</span>

	public void createAuditTrailEntry(Collection events, short action, short module, boolean isTemplate)
			throws Exception {
<span class="nc" id="L1104">		HashSet affectedAttendees = new HashSet();</span>
<span class="nc bnc" id="L1105" title="All 2 branches missed.">		for (Iterator i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1106">			affectedAttendees.addAll(((Event) i.next()).getWorkResourceIDs());</span>
		}
<span class="nc" id="L1108">		createAuditTrailEntry(affectedAttendees, events, action, module, isTemplate);</span>
<span class="nc" id="L1109">	}</span>

	public void createAuditTrailEntry(Collection affectedAttendees, Collection events, short action, short module,
			boolean isTemplate) throws Exception {
<span class="fc" id="L1113">		Event event = null;</span>
<span class="fc" id="L1114">		CalendarEventTemplate template = null;</span>
<span class="fc" id="L1115">		ID workResourceID = null;</span>
<span class="fc" id="L1116">		ArrayList auditTrailEntries = new ArrayList();</span>
<span class="fc" id="L1117">		AuditTrailEntry entry = null;</span>
<span class="fc" id="L1118">		Map mapNames = collectEmployeeOrPhantomNameList(affectedAttendees);</span>
<span class="fc" id="L1119">		Date start = null;</span>
<span class="fc" id="L1120">		Date end = null;</span>
<span class="fc" id="L1121">		int eventType = -1;</span>
<span class="fc" id="L1122">		String desc = null;</span>
<span class="fc" id="L1123">		int duration = 0;</span>
<span class="fc" id="L1124">		ID activityID = null;</span>
<span class="fc" id="L1125">		Collection attendees = null;</span>
<span class="fc bfc" id="L1126" title="All 2 branches covered.">		for (Iterator i = events.iterator(); i.hasNext();) {</span>
<span class="pc bpc" id="L1127" title="1 of 2 branches missed.">			if (isTemplate) {</span>
				// so far, only recurry event template is audited on template
				// object.
				// for floating event template, we will audit on the real
				// created events.
<span class="nc" id="L1132">				template = (CalendarEventTemplate) i.next();</span>
<span class="nc" id="L1133">				start = ((ValueObjectAggEventTemplate) template).getEarliestPossibleStartTime();</span>
				// end =
				// ((ValueObjectAggEventTemplate)template).getLatestPossibleEndTime();
				// fix bug 95991, the latest possible end time is only make
				// sense for floating, but for recurring, it is not
				// floated, so the end is start plus duration.
<span class="nc" id="L1139">				end = new Date(start.getTime() + template.getDuration() * 60 * 1000);</span>
				/*
				 * fix 94339, fix bug QC27832 : for recurring, the impact time
				 * is the whole recurring period. not only the first instance
				 */
<span class="nc bnc" id="L1144" title="All 2 branches missed.">				if (template.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING)</span>
<span class="nc" id="L1145">					end = ((RecurringEventTemplate) template).getLatestPossibleEndTime();</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">				if (template.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING)</span>
<span class="nc" id="L1147">					end = ((RecurringFloatingEventTemplate) template).getLatestPossibleEndTime();</span>

<span class="nc" id="L1149">				eventType = template.getEventType();</span>
<span class="nc" id="L1150">				desc = template.getDescription();</span>
<span class="nc" id="L1151">				activityID = template.getActivityID();</span>
<span class="nc" id="L1152">				attendees = template.getWorkResourceIDs();</span>
			} else {
<span class="fc" id="L1154">				event = (Event) i.next();</span>
<span class="fc" id="L1155">				start = event.getStartTime();</span>
<span class="fc" id="L1156">				duration = event.getDuration();</span>
<span class="fc" id="L1157">				end = event.getEndTime();</span>
<span class="fc" id="L1158">				eventType = event.getEventType();</span>
<span class="fc" id="L1159">				desc = event.getDescription();</span>
<span class="fc" id="L1160">				activityID = event.getActivityID();</span>
<span class="fc" id="L1161">				attendees = event.getWorkResourceIDs();</span>
			}
<span class="fc bfc" id="L1163" title="All 2 branches covered.">			for (Iterator j = affectedAttendees.iterator(); j.hasNext();) {</span>
<span class="fc" id="L1164">				workResourceID = (ID) j.next();</span>
<span class="fc bfc" id="L1165" title="All 2 branches covered.">				if (attendees.contains(workResourceID)) {</span>
					// for partial update, such as update attendee list only.
<span class="fc" id="L1167">					entry = new AuditTrailEntry(module, action, workResourceID,</span>
<span class="fc" id="L1168">							(mapNames.get(workResourceID)).toString(), start, end);</span>
<span class="fc" id="L1169">					entry.setTimeStamp(new Date());</span>
					// entry.addProperty(AuditTrailPropertyConstant.EVENT_DESC,
					// desc, &quot;-1&quot;, false);
					// entry.addProperty(AuditTrailPropertyConstant.EVENT_ACTIVITY,
					// getActivityName(activityID), &quot;-1&quot;, false);
<span class="fc" id="L1174">					entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(eventType), &quot;-1&quot;, false);</span>
					// entry.addProperty(AuditTrailPropertyConstant.EVENT_DURATION,
					// String.valueOf(duration), &quot;-1&quot;, false);
<span class="pc bpc" id="L1177" title="1 of 4 branches missed.">					if (!isTemplate &amp;&amp; event.getParentID() != null) {</span>
						// event might have template id
<span class="fc" id="L1179">						entry.addProperty(AuditTrailPropertyConstant.EVENT_TEMPLATE,</span>
<span class="fc" id="L1180">								String.valueOf(event.getParentID()), &quot;-1&quot;, false);</span>
					}
<span class="fc" id="L1182">					auditTrailEntries.add(entry);</span>
				}
			}
		}
<span class="fc" id="L1186">		m_auditManager.createAuditEntry(auditTrailEntries);</span>
<span class="fc" id="L1187">	}</span>

	private Map collectEmployeeOrPhantomNameList(Collection workresourceIDs) throws Exception {
<span class="fc" id="L1190">		Map names = getEmployeeNamesMap(workresourceIDs);</span>
<span class="fc" id="L1191">		EmployeeName empName = null;</span>
<span class="fc" id="L1192">		Object key = null;</span>
<span class="fc bfc" id="L1193" title="All 2 branches covered.">		for (Iterator i = names.keySet().iterator(); i.hasNext();) {</span>
<span class="fc" id="L1194">			key = i.next();</span>
<span class="fc" id="L1195">			empName = (EmployeeName) names.get(key);</span>
			// replace EmployeeName object with formatted string
<span class="fc" id="L1197">			names.put(key, empName.getDisplayName(m_defLocalizer));</span>
		}
<span class="fc" id="L1199">		ArrayList phantomList = new ArrayList(workresourceIDs);</span>
<span class="fc" id="L1200">		phantomList.removeAll(names.keySet()); // all the remaining ids are</span>
												// phantom ids.
<span class="pc bpc" id="L1202" title="1 of 2 branches missed.">		if (!phantomList.isEmpty()) {</span>
<span class="nc" id="L1203">			names.putAll(m_scheduleAccessManager.getPhantomEmployeeNamesByIDs(phantomList));</span>
		}
		// workresourceIDs will be used as affectedAttendees later.
<span class="fc" id="L1206">		return names;</span>
	}

	/**
	 * This method gives the EJB manager the opportunity to react before a new
	 * event template gets created
	 */
	private void preActionEventTemplate(CalendarEventTemplate eventTemplate) throws Exception {
<span class="pc bpc" id="L1214" title="1 of 2 branches missed.">		if (eventTemplate instanceof ValueObjectAggEventTemplate) {</span>
<span class="fc" id="L1215">			ValueObjectAggEventTemplate calTemplate = (ValueObjectAggEventTemplate) eventTemplate;</span>
<span class="fc" id="L1216">			m_lockManager.checkEmployeeScheduleCanBeModified(null, eventTemplate.getWorkResourceIDs(),</span>
<span class="fc" id="L1217">					calTemplate.getEarliestPossibleStartTime(), calTemplate.getLatestPossibleEndTime());</span>
		}
<span class="fc" id="L1219">	}</span>
}

/**
 * this is a helper class used to compute the earliest start time and the latest
 * end time and the complete set of workresources from a collection of events
 */
<span class="fc" id="L1226">class WorkResourcesAndTimeRange {</span>
<span class="fc" id="L1227">	private final HashSet m_setWorkresources = new HashSet();</span>
<span class="fc" id="L1228">	private Date m_dtMinStart = null;</span>
<span class="fc" id="L1229">	private Date m_dtMaxEnd = null;</span>

	static WorkResourcesAndTimeRange get(Collection listEvents) {
<span class="pc bpc" id="L1232" title="1 of 4 branches missed.">		if (listEvents == null || listEvents.isEmpty())</span>
<span class="fc" id="L1233">			return null;</span>

<span class="fc" id="L1235">		WorkResourcesAndTimeRange obj = new WorkResourcesAndTimeRange();</span>

		/*
		 * go through all the events to find all the work resources and the min
		 * start time and the max end time
		 */
<span class="fc bfc" id="L1241" title="All 2 branches covered.">		for (Iterator it = listEvents.iterator(); it.hasNext();) {</span>
<span class="fc" id="L1242">			Event event = (Event) it.next();</span>
<span class="fc" id="L1243">			obj.m_setWorkresources.addAll(event.getWorkResourceIDs());</span>

<span class="fc" id="L1245">			Date dtEventStart = event.getStartTime();</span>
<span class="fc bfc" id="L1246" title="All 4 branches covered.">			if (obj.m_dtMinStart == null || obj.m_dtMinStart.after(dtEventStart))</span>
<span class="fc" id="L1247">				obj.m_dtMinStart = dtEventStart;</span>

<span class="fc" id="L1249">			Date dtEventEnd = event.getEndTime();</span>
<span class="fc bfc" id="L1250" title="All 4 branches covered.">			if (obj.m_dtMaxEnd == null || obj.m_dtMaxEnd.before(dtEventEnd))</span>
<span class="fc" id="L1251">				obj.m_dtMaxEnd = dtEventEnd;</span>
<span class="fc" id="L1252">		}</span>
<span class="fc" id="L1253">		return obj;</span>
	}

	Collection getWorkResources() {
<span class="fc" id="L1257">		return m_setWorkresources;</span>
	}

	Date getMinStart() {
<span class="fc" id="L1261">		return m_dtMinStart;</span>
	}

	Date getMaxEnd() {
<span class="fc" id="L1265">		return m_dtMaxEnd;</span>
	}

	/**
	 * splits elements of 2 sets into 3 sets: of ones which are members of the
	 * first collection only; of ones which are common for both; of ones which
	 * are members of the second collection only;
	 * 
	 * @param c1
	 *            first collection
	 * @param c2
	 *            second collection
	 * @return array of 3 collections, as described above
	 */
	static public Collection[] splitCollections(Collection c1, Collection c2) {
<span class="fc" id="L1280">		ArrayList rc[] = new ArrayList[3];</span>
<span class="fc" id="L1281">		rc[0] = rc[1] = rc[2] = null;</span>
<span class="fc bfc" id="L1282" title="All 2 branches covered.">		for (Iterator it = c1.iterator(); it.hasNext();) {</span>
<span class="fc" id="L1283">			Object item = it.next();</span>
<span class="fc bfc" id="L1284" title="All 2 branches covered.">			if (c2.contains(item)) {</span>
<span class="pc bpc" id="L1285" title="1 of 2 branches missed.">				if (rc[1] == null)</span>
<span class="fc" id="L1286">					rc[1] = new ArrayList();</span>
<span class="fc" id="L1287">				rc[1].add(item);</span>
			} else {
<span class="pc bpc" id="L1289" title="1 of 2 branches missed.">				if (rc[0] == null)</span>
<span class="fc" id="L1290">					rc[0] = new ArrayList();</span>
<span class="fc" id="L1291">				rc[0].add(item);</span>
			}
<span class="fc" id="L1293">		}</span>
		// now, fast check: may be, the collections are same?
<span class="fc bfc" id="L1295" title="All 4 branches covered.">		if (rc[1] == null || rc[1].size() != c2.size())</span>
<span class="fc bfc" id="L1296" title="All 2 branches covered.">			for (Iterator it = c2.iterator(); it.hasNext();) {</span>
<span class="fc" id="L1297">				Object item = it.next();</span>
<span class="fc bfc" id="L1298" title="All 2 branches covered.">				if (!c1.contains(item)) {</span>
<span class="pc bpc" id="L1299" title="1 of 2 branches missed.">					if (rc[2] == null)</span>
<span class="fc" id="L1300">						rc[2] = new ArrayList();</span>
<span class="fc" id="L1301">					rc[2].add(item);</span>
				}
<span class="fc" id="L1303">			}</span>
<span class="fc" id="L1304">		return rc;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>