<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarEventAssignmentDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">CalendarEventAssignmentDAO.java</span></div><h1>CalendarEventAssignmentDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Calendar Event Assignment DAO class
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.*;

import com.bluepumpkin.common.util.*;
import com.bluepumpkin.ejb.bbm.dao.*;
import com.bluepumpkin.ejb.bbm.vo.*;
import com.bluepumpkin.ejb.bbm.schedule.model.*;
import com.bluepumpkin.common.datatypes.*;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.common.jdmo.*;
import com.bluepumpkin.ejb.bbm.l10n.*;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.core.base.MultiUserException;

class CalendarEventAssignmentDAO extends EventAssignmentUnpubDAO&lt;CalendarEventAssignment&gt;
		implements ScheduleConflictChecker&lt;CalendarEventAssignment&gt; {
	// meta data info.
<span class="fc" id="L27">	private static FieldInfo m_fieldInfo = new CalendarEventAssignmentFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="fc" id="L30">		return m_fieldInfo;</span>
	}

	public CalendarEventAssignmentDAO() {
<span class="fc" id="L34">		super();</span>
<span class="fc" id="L35">	}</span>

	public CalendarEventAssignmentDAO(Jdmo dmo) {
<span class="fc" id="L38">		super(dmo);</span>
<span class="fc" id="L39">	}</span>

	/**
	 * This is an override of the base class function to create an appropriate
	 * type of the value object based on the event type that is stored in
	 * CALENDAREVENTASSIGNMENT record
	 */
	protected CalendarEventAssignment createValueObject(JdmoRowset rs) throws Exception {
<span class="fc" id="L47">		int eventType = rs.getInt(&quot;EVENTTYPE&quot;);</span>
<span class="pc bpc" id="L48" title="1 of 4 branches missed.">		switch (eventType) {</span>
		case Event.EVENT_TYPE_TIME_OFF:
<span class="fc" id="L50">			return new TimeOffEvent();</span>

		case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="fc" id="L53">			return new UnavailabilityEvent();</span>

		case Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT:
<span class="fc" id="L56">			return new CalendarEvent();</span>

		default:
			/* this should never happen, could log an error here */
<span class="nc" id="L60">			ScheduleAccessManagerEJB.m_cat.l7dError(BbmEjbLogBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE,</span>
<span class="nc" id="L61">					new Object[] { NumberFactory.newInteger(eventType) });</span>
<span class="nc" id="L62">			return null;</span>
		}
	}

	/** This is an override of the base class function */
	protected CalendarEventAssignment createValueObject() {
		/** this flavor of createValueObject will never be called */
<span class="nc" id="L69">		return null;</span>
	}

	/** override from base class */
	protected DAOBase createChildDAO(int iType) {
<span class="fc bfc" id="L74" title="All 2 branches covered.">		if (iType == CalendarEventAssignmentFields.CHILD_ATTENDEE)</span>
<span class="fc" id="L75">			return new CalendarEventAttendeeDAO(m_dmo);</span>
		else
<span class="fc" id="L77">			return new CalendarEventProjectDAO(m_dmo);</span>
	}

	/**
	 * This method will be overriden by the derived class to provide an instance
	 * of the DAO class that model the published event
	 */
	protected CalendarEventAssignmentPubDAO getPublishedDAO() {
<span class="nc" id="L85">		return new CalendarEventAssignmentPubDAO(m_dmo);</span>
	}

	/** this is an override of base class */
	protected void calcAndSetEventPrecedence(CalendarEventAssignment objValue) throws Exception {
<span class="fc" id="L90">		CalendarEventAssignment event = objValue;</span>
<span class="fc" id="L91">		int precedence = EventPrecedenceRule.getEventOverlayPrecedence(event);</span>
<span class="fc" id="L92">		event.setOverlayPrecedence(precedence);</span>
<span class="fc" id="L93">	}</span>

	/** This is an override of the base class */
	@Override
	public ID createObject(CalendarEventAssignment objValue, boolean bBatched) throws BbmCreateException {
<span class="fc" id="L98">		CalendarEventAssignment event = objValue;</span>
		/*
		 * I don't really want to expose a method on CalendarEventAssignment
		 * like setEventType(), but we need to store the event type in the
		 * database table so we can know what type of event this was, so I will
		 * do this instead
		 */
<span class="fc" id="L105">		event.setFieldValue(CalendarEventAssignmentFields.EVENTTYPE, event.getEventType());</span>

<span class="pc bpc" id="L107" title="1 of 2 branches missed.">		if (objValue.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME)</span>
<span class="pc bpc" id="L108" title="1 of 2 branches missed.">				&amp;&amp; objValue.isFieldValueSet(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="fc" id="L109">			event.setFieldValue(CalendarEventAssignmentFields.ENDTIME,</span>
<span class="fc" id="L110">					new Date(event.getStartTime().getTime() + event.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}
<span class="fc" id="L112">		return super.createObject(objValue, bBatched);</span>
	}

	/**
	 * This function is called right after an newly created calendar event
	 * assignment has been persisted to the database. It checks whether this new
	 * calendar event assignment created any conflicts in the employee's
	 * schedule. The following are possible conflicts: 1) Some shift assignment
	 * overlaps this Unavailability calendar event assignment 2) this calendar
	 * event assignment overlaps with some other calendar event assignment
	 *
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObject(CalendarEventAssignment obj)
			throws BbmFinderException {
<span class="nc" id="L126">		return getConflictsForScheduleObject(obj, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObjects(Collection&lt;CalendarEventAssignment&gt; objs)
			throws BbmFinderException {
<span class="fc" id="L131">		List&lt;BbmScheduleConflict&gt; conflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="pc bpc" id="L132" title="1 of 2 branches missed.">		if (objs == null) {</span>
<span class="nc" id="L133">			return conflicts;</span>
		}
<span class="fc bfc" id="L135" title="All 2 branches covered.">		for (Iterator&lt;CalendarEventAssignment&gt; i = objs.iterator(); i.hasNext();) {</span>
<span class="fc" id="L136">			conflicts.addAll(getConflictsForScheduleObject(i.next(), true, null));</span>
		}
<span class="fc" id="L138">		return conflicts;</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedScheduleObject(CalendarEventAssignment obj) throws BbmFinderException {
<span class="fc" id="L142">		return getConflictsForScheduleObject(obj, false, null);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(CalendarEventAssignment obj, boolean isNewObject)
			throws BbmFinderException {
<span class="fc" id="L147">		return getConflictsForScheduleObject(obj, isNewObject, null);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(CalendarEventAssignment obj, boolean isNewObject,
			ID recurringTemplateID) throws BbmFinderException {
<span class="fc" id="L152">		CalendarEventAssignment event = obj;</span>
		try {
			// will be use later to check conflict.
<span class="fc" id="L155">			calcAndSetEventPrecedence(event);</span>
<span class="nc" id="L156">		} catch (Exception e) {</span>
<span class="nc" id="L157">			throw new BbmFinderException(e);</span>
<span class="fc" id="L158">		}</span>
<span class="fc" id="L159">		Collection&lt;ID&gt; workResourceIDs = event.getWorkResourceIDs();</span>

<span class="fc" id="L161">		List&lt;BbmScheduleConflict&gt; listConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="fc" id="L162">		List&lt;CalendarEventAssignment&gt; conflictEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>

<span class="fc" id="L164">		getAlreadyAttendingConflictsForScheduleObject(isNewObject, event, listConflicts);</span>

<span class="fc" id="L166">		getOverlapConflictsForScheduleObject(isNewObject, recurringTemplateID, event, workResourceIDs, listConflicts, conflictEvents);</span>

<span class="fc" id="L168">		getSamePrecedenceShiftAssignmentConflictsForScheduleObject(event, workResourceIDs, listConflicts);</span>

		/**
		 * the last step is to find all of the employee names for all
		 * of the conflicts returned from this method call
		 */
<span class="fc" id="L174">		ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>

<span class="fc" id="L176">		return listConflicts;</span>
	}

	/**
	 * Get conflicts where this calendar event is a template exception and has
	 * attendee which has already attended the other exceptions
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getAlreadyAttendingConflictsForScheduleObject(boolean isNewObject, CalendarEventAssignment event,
															   List&lt;BbmScheduleConflict&gt; listConflicts) throws BbmFinderException {
		// QA 94787 - F&amp;S receives an error occurs inside publish schedule
<span class="fc" id="L187">		ID tplID = event.getEventTemplateID();</span>
<span class="pc bpc" id="L188" title="1 of 4 branches missed.">		if (!isNewObject &amp;&amp; tplID != null) {</span>
<span class="nc" id="L189">			CalendarEventTemplateDAO tplDao = new CalendarEventTemplateDAO(this.m_dmo);</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (tplDao.getTemplateTypeByID(tplID) == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>

<span class="nc" id="L192">				Collection&lt;CalendarEventAttendee&gt; createdAttenddees = event</span>
<span class="nc" id="L193">						.getCreatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L194" title="All 4 branches missed.">				if (createdAttenddees != null &amp;&amp; !createdAttenddees.isEmpty()) {</span>

<span class="nc" id="L196">					RecurringEventTemplateDAO recTplDao = new RecurringEventTemplateDAO(this.m_dmo);</span>
<span class="nc" id="L197">					RecurringEventTemplateBase recTemplate = (RecurringEventTemplateBase) recTplDao</span>
<span class="nc" id="L198">							.getObjectByID(tplID);</span>

<span class="nc" id="L200">					Collection&lt;ID&gt; templateWorkResouces = recTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L201">					HashSet&lt;ID&gt; existingTemplateWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L202">					Iterator&lt;ID&gt; temp = templateWorkResouces.iterator();</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">					while (temp.hasNext()) {</span>
<span class="nc" id="L204">						existingTemplateWorkResources.add(temp.next());</span>
					}

<span class="nc" id="L207">					Collection&lt;ID&gt; conflictWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">					for (Iterator&lt;CalendarEventAttendee&gt; it = createdAttenddees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L209">						ID workResourceID = ((CalendarEventAttendee) it.next()).getWorkResourceID();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">						if (!existingTemplateWorkResources.contains(workResourceID)</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">								&amp;&amp; recTemplate.existsExceptionOnDate(event.getStartTime(), workResourceID)) {</span>
<span class="nc" id="L212">							conflictWorkResources.add(workResourceID);</span>
						}
<span class="nc" id="L214">					}</span>

<span class="nc bnc" id="L216" title="All 2 branches missed.">					if (!conflictWorkResources.isEmpty()) {</span>
<span class="nc" id="L217">						BbmScheduleConflict schConflict = new BbmScheduleConflict(event, conflictWorkResources);</span>
<span class="nc" id="L218">						listConflicts.add(schConflict);</span>
					}
				}
			}
		}
		// End #94787
<span class="fc" id="L224">	}</span>

	/**
	 * Get conflicts where this calendar event assignment overlaps with another
	 * calendar event assignment with the same precedence
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getOverlapConflictsForScheduleObject(boolean isNewObject, ID recurringTemplateID,
				CalendarEventAssignment event, Collection&lt;ID&gt; workResourceIDs,
				List&lt;BbmScheduleConflict&gt; listConflicts,
				List&lt;CalendarEventAssignment&gt; conflictEvents)
				throws BbmFinderException {
<span class="fc" id="L236">		Collection&lt;CalendarEventAttendee&gt; attendees = event.getChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="fc" id="L237">		Map&lt;ID,Boolean&gt; workResourceAttendeesMap = new HashMap&lt;ID, Boolean&gt;();</span>

<span class="fc bfc" id="L239" title="All 2 branches covered.">		for (Iterator&lt;CalendarEventAttendee&gt; it = attendees.iterator(); it.hasNext();) {</span>
<span class="fc" id="L240">			CalendarEventAttendee attendee = it.next();</span>
<span class="fc" id="L241">			workResourceAttendeesMap.put(attendee.getWorkResourceID(), attendee.isAttending());</span>
<span class="fc" id="L242">		}</span>
<span class="fc" id="L243">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = getAllAttendingEventsForWorkResources(workResourceIDs,</span>
<span class="fc" id="L244">				event.getStartTime(), event.getEndTime());</span>
<span class="fc bfc" id="L245" title="All 2 branches covered.">		for (Iterator&lt;Collection&lt;CalendarEventAssignment&gt;&gt; it = listEvents.iterator(); it.hasNext();) {</span>
<span class="fc" id="L246">			Collection&lt;CalendarEventAssignment&gt; wrkEvents = it.next();</span>
<span class="fc bfc" id="L247" title="All 4 branches covered.">			if (wrkEvents == null || wrkEvents.isEmpty()) {</span>
<span class="fc" id="L248">				continue;</span>
			}

<span class="fc bfc" id="L251" title="All 2 branches covered.">			for (Iterator&lt;CalendarEventAssignment&gt; it2 = wrkEvents.iterator(); it2.hasNext();) {</span>
<span class="fc" id="L252">				CalendarEventAssignment event2 = it2.next();</span>
<span class="pc bpc" id="L253" title="1 of 2 branches missed.">				if (isInstanceForSameFloatingTemplate(event, event2)) {</span>
					// update the same floating event template
<span class="nc" id="L255">					continue;</span>
				}

<span class="pc bpc" id="L258" title="3 of 4 branches missed.">				if (recurringTemplateID != null &amp;&amp; recurringTemplateID.equals(event2.getEventTemplateID())) {</span>
					// skip for similar recurring floating event
<span class="nc" id="L260">					continue;</span>
				}

<span class="fc bfc" id="L263" title="All 4 branches covered.">				if ((isNewObject || !event.getID().equals(event2.getID()))</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">						&amp;&amp; event.getOverlayPrecedence() == event2.getOverlayPrecedence()) {</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">					for (Iterator&lt;ID&gt; it3 = workResourceIDs.iterator(); it3.hasNext();) {</span>
<span class="nc" id="L266">						ID workResourceID = it3.next();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">						if (event2.getWorkResourceIDs().contains(workResourceID)</span>
<span class="nc bnc" id="L268" title="All 2 branches missed.">								&amp;&amp; workResourceAttendeesMap.get(workResourceID)) {</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">							if (!conflictEvents.contains(event2)) {</span>
								// only create schedule conflict obj once
<span class="nc" id="L271">								conflictEvents.add(event2);</span>
<span class="nc" id="L272">								listConflicts.add(new BbmScheduleConflict(event, event2));</span>
							}
						}
<span class="nc" id="L275">					}</span>
				}
<span class="fc" id="L277">			}</span>
<span class="fc" id="L278">		}</span>
<span class="fc" id="L279">	}</span>

	/**
	 * Get conflicts where Some shift assignment with the same precedence overlaps this calendar
	 * event assignment
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getSamePrecedenceShiftAssignmentConflictsForScheduleObject(CalendarEventAssignment event,
				Collection&lt;ID&gt; workResourceIDs, List&lt;BbmScheduleConflict&gt; listConflicts) throws BbmFinderException {
<span class="fc" id="L288">		ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO(m_dmo);</span>
<span class="fc" id="L289">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; shifts =</span>
<span class="fc" id="L290">				daoShift.getEventsForWorkResources(workResourceIDs, event.getStartTime(),</span>
<span class="fc" id="L291">				event.getEndTime());</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">		for (Iterator&lt;Collection&lt;ShiftAssignment&gt;&gt; it = shifts.iterator(); it.hasNext();) {</span>
<span class="fc" id="L293">			Collection&lt;ShiftAssignment&gt; wrkShifts = it.next();</span>
<span class="fc bfc" id="L294" title="All 4 branches covered.">			if (wrkShifts == null || wrkShifts.isEmpty()) {</span>
<span class="fc" id="L295">				continue;</span>
			}

<span class="fc bfc" id="L298" title="All 2 branches covered.">			for (Iterator&lt;ShiftAssignment&gt; it2 = wrkShifts.iterator(); it2.hasNext();) {</span>
				/*
				 * we can cast to ShiftAssignment here because this collection
				 * is a result of calling
				 * ShiftAssignmentDAO.getEventsForWorkResources which will only
				 * retrieve shift assignments
				 */
<span class="fc" id="L305">				ShiftAssignment shift = it2.next();</span>
<span class="pc bpc" id="L306" title="1 of 2 branches missed.">				if (shift.getOverlayPrecedence() == event.getOverlayPrecedence()) {</span>
<span class="nc" id="L307">					listConflicts.add(new BbmScheduleConflict(shift, event));</span>
				}
<span class="fc" id="L309">			}</span>
<span class="fc" id="L310">		}</span>
<span class="fc" id="L311">	}</span>

	protected boolean isInstanceForSameFloatingTemplate(CalendarEventAssignment event1, CalendarEventAssignment event2) {
<span class="fc" id="L314">		ID parentID1 = event1.getParentID();</span>
<span class="fc" id="L315">		ID parentID2 = event2.getParentID();</span>
<span class="pc bpc" id="L316" title="7 of 8 branches missed.">		if (parentID1 != null &amp;&amp; parentID2 != null &amp;&amp; parentID1.equals(parentID2) &amp;&amp; isAtLeaseOneFloatingEvent(event1, event2)) {</span>
<span class="nc" id="L317">			return true;</span>
		}
<span class="fc" id="L319">		return false;</span>
	}

	protected boolean isAtLeaseOneFloatingEvent(CalendarEventAssignment event1, CalendarEventAssignment event2) {
<span class="nc" id="L323">		CalendarEventTemplateDAO tplDao = new CalendarEventTemplateDAO(this.m_dmo);</span>
<span class="nc bnc" id="L324" title="All 4 branches missed.">		return (isFloatingEvent(event1, tplDao) || isFloatingEvent(event2, tplDao));</span>
	}

	protected boolean isFloatingEvent(CalendarEventAssignment event, CalendarEventTemplateDAO tplDao) {
<span class="nc" id="L328">		ID templateID = event.getEventTemplateID();</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">		if (templateID != null) {</span>
			try {
<span class="nc" id="L331">				short templateType = tplDao.getTemplateTypeByID(templateID);</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">				if (templateType == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING</span>
						|| templateType == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {
<span class="nc" id="L334">					return true;</span>
				}
<span class="nc" id="L336">			} catch (BbmFinderException bbmfe) {}</span>
		}
<span class="nc" id="L338">		return false;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 *
	 * Note: This is an override of the base class function to provide proper
	 * SQL clause for multi-attendee events and appropriate filter on the
	 * EVENTTYPE attribute
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="fc" id="L351">		StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L353">		strSQL.append(&quot; AND (&quot;);</span>
		/*
		 * strSQL.append(m_dmo.bitwiseAND(&quot;EVENTTYPE&quot;,
		 * NumberFactory.newInteger(eventTypeBitMask)));
		 * strSQL.append(&quot; != 0)&quot;);
		 */
<span class="fc" id="L359">		strSQL.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask));</span>
<span class="fc" id="L360">		strSQL.append(&quot; )&quot;);</span>
<span class="fc" id="L361">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="fc" id="L370">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, false);</span>
	}

	protected StringBuffer getWhereClauseForGetAttendingEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="fc" id="L375">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, true);</span>
	}

	private StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean isAttendingOnly) throws JdmoException {
		// to enhance the performance. waseem suggests to use temp table to hold
		// all the ids, and join the temp table with calendaeventattendee.
		// the predefined temp table should be used here, if no, oracle ddl will
		// commit the whole transaction
		// after creating or dropping new temp table. so far, IDS is only used
		// here. - fix93583
<span class="fc" id="L386">		String strTableName = &quot;IDS&quot;;</span>

		// insert ids into temp table
<span class="fc" id="L389">		String tempTableName = m_dmo.insertIDs(strTableName, workResourceIDs);</span>

<span class="fc" id="L391">		StringBuffer strSQL = new StringBuffer(200);</span>
		// strSQL.append(m_dmo.dateAddMinutes(&quot;A.DURATION&quot;, &quot;A.STARTTIME&quot;));
<span class="fc" id="L393">		strSQL.append(&quot; A.ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="fc" id="L394">		strSQL.append(&quot;' AND &quot;);</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">		if (dtEnd != null) {</span>
<span class="fc" id="L396">			strSQL.append(&quot; A.STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="fc" id="L397">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="fc" id="L399">		strSQL.append(&quot; A.ID in  (SELECT CALENDAREVENTASSIGNMENTID FROM CALENDAREVENTATTENDEE, &quot;);</span>
<span class="fc" id="L400">		strSQL.append(tempTableName).append(&quot; where &quot;).append(tempTableName)</span>
<span class="fc" id="L401">				.append(&quot;.bpid = CALENDAREVENTATTENDEE.workresourceid &quot;);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">		if (isAttendingOnly)</span>
<span class="fc" id="L403">			strSQL.append(&quot;  AND CALENDAREVENTATTENDEE.ISATTENDING = 1 &quot;);</span>
<span class="fc" id="L404">		strSQL.append(&quot;)&quot;);</span>
<span class="fc" id="L405">		return strSQL;</span>
		/*
		 * strSQL.append(&quot; EXISTS &quot;); strSQL.append(&quot; (SELECT ID &quot;);
		 * strSQL.append(&quot;  FROM CALENDAREVENTATTENDEE &quot;);
		 * strSQL.append(&quot;  WHERE WORKRESOURCEID IN &quot;);
		 * strSQL.append(m_dmo.createInClause(workResourceIDs)); if
		 * (isAttendingOnly) strSQL.append(&quot;  AND ISATTENDING = 1 &quot;);
		 * strSQL.append(&quot;  AND CALENDAREVENTASSIGNMENTID = A.ID ) &quot;); return
		 * strSQL;
		 */
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events that fall within the already published periods for a given set of
	 * work resources in a given time period
	 */
	protected StringBuffer getWhereClauseForGetEventsInPublishedPeriodsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws JdmoException {
<span class="nc" id="L424">		StringBuffer strSQL = new StringBuffer(200);</span>
		// strSQL.append(m_dmo.dateAddMinutes(&quot;A.DURATION&quot;, &quot;A.STARTTIME&quot;));
<span class="nc" id="L426">		strSQL.append(&quot; A.ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L427">		strSQL.append(&quot;' AND &quot;);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">		if (dtEnd != null) {</span>
<span class="nc" id="L429">			strSQL.append(&quot; A.STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L430">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="nc" id="L432">		strSQL.append(&quot; EXISTS (SELECT 1 &quot;);</span>
<span class="nc" id="L433">		strSQL.append(&quot; FROM PUBLISHINGPERIOD B, CALENDAREVENTATTENDEE C &quot;);</span>
<span class="nc" id="L434">		strSQL.append(&quot; WHERE C.WORKRESOURCEID = B.WORKRESOURCEID AND &quot;);</span>
<span class="nc" id="L435">		strSQL.append(&quot; A.STARTTIME &lt; B.ENDTIME AND &quot;);</span>
		// strSQL.append(m_dmo.dateAddMinutes(&quot;A.DURATION&quot;, &quot;A.STARTTIME&quot;));
<span class="nc" id="L437">		strSQL.append(&quot; A.ENDTIME &gt; B.STARTTIME AND &quot;);</span>
<span class="nc" id="L438">		strSQL.append(&quot; C.WORKRESOURCEID IN &quot;).append(m_dmo.createInClause(workResourceIDs)).append(&quot; AND &quot;);</span>
<span class="nc" id="L439">		strSQL.append(&quot; C.CALENDAREVENTASSIGNMENTID = A.ID) &quot;);</span>
<span class="nc" id="L440">		return strSQL;</span>
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L449">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L451">			return ScheduleDAOUtil.groupEventsByWorkResources(getObjects(strSQL.toString()), workResourceIDs);</span>
<span class="nc" id="L452">		} catch (JdmoException e) {</span>
<span class="nc" id="L453">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of calendar event assignments fo multiple work
	 * resources The returned collection is a combination of calendar event
	 * assignments created by user manually by placing them on the calendar,
	 * calendar event assignments instantiated from appropriate recurring event
	 * templates as well as floating calendar events
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="fc" id="L470">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = </span>
				new ArrayList&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt;(2);

<span class="fc" id="L473">		allEvents.add(this.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>

		/*
		 * Note: no need to do floating events separately since they will be
		 * already persisted as records in CALENDAREVENTASSIGNMENT table and
		 * this covered by CalendarEventAssignment DAO
		 */

<span class="fc" id="L481">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="fc" id="L482">		allEvents.add(daoRecurring.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>
<span class="fc" id="L483">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllAttendingEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L488">		return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, true);</span>
	}

	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAttendingEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L494">			StringBuffer strSQL = getWhereClauseForGetAttendingEventsQuery(workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L496">			return ScheduleDAOUtil.groupEventsByWorkResources(getObjects(strSQL.toString()), workResourceIDs);</span>
<span class="nc" id="L497">		} catch (JdmoException e) {</span>
<span class="nc" id="L498">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of calendar event assignments fo multiple work
	 * resources The returned collection is a combination of calendar event
	 * assignments created by user manually by placing them on the calendar,
	 * calendar event assignments instantiated from appropriate recurring event
	 * templates as well as floating calendar events
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L511">		return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, false);</span>
	}

	private Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd, boolean isAttendingOnly) throws BbmFinderException {
		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="fc" id="L520">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt;(2);</span>
<span class="fc bfc" id="L521" title="All 2 branches covered.">		if (!isAttendingOnly) {</span>
<span class="fc" id="L522">			allEvents.add(this.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
		} else {
<span class="fc" id="L524">			allEvents.add(this.getAttendingEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
		}

		/*
		 * Note: no need to do floating events separately since they will be
		 * already persisted as records in CALENDAREVENTASSIGNMENT table and
		 * this covered by CalendarEventAssignment DAO
		 */

<span class="fc" id="L533">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="fc" id="L534">		allEvents.add(daoRecurring.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
<span class="fc" id="L535">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	/**
	 * Locks or unlocks events of a given type for a given set of work resources
	 * and time period
	 */
	public void lockOrUnlockEvents(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean bLock, String extraCondition) // extracondition has and
													// keyword already.
			throws BbmUpdateException {
		try {
<span class="nc" id="L547">			StringBuffer buf = new StringBuffer(200);</span>
<span class="nc" id="L548">			buf.append(&quot;UPDATE CALENDAREVENTASSIGNMENT &quot;);</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">			buf.append(&quot;SET ISLOCKED = &quot;).append(bLock ? &quot;1 &quot; : &quot;0 &quot;);</span>
<span class="nc" id="L550">			buf.append(&quot;WHERE (&quot;);</span>
			/*
			 * buf.append(m_dmo.bitwiseAND(&quot;EVENTTYPE&quot;,
			 * NumberFactory.newInteger(eventTypeMask)));
			 * buf.append(&quot; != 0) AND &quot;);
			 */
<span class="nc" id="L556">			buf.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeMask)).append(&quot;)&quot;);</span>
			// buf.append(m_dmo.dateAddMinutes(&quot;DURATION&quot;, &quot;STARTTIME&quot;));
<span class="nc" id="L558">			buf.append(&quot; AND ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L559">			buf.append(&quot;' AND STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L560">			buf.append(&quot;' AND ID IN &quot;);</span>
<span class="nc" id="L561">			buf.append(&quot; (SELECT CALENDAREVENTASSIGNMENTID &quot;);</span>
<span class="nc" id="L562">			buf.append(&quot;  FROM CALENDAREVENTATTENDEE &quot;);</span>
<span class="nc" id="L563">			buf.append(&quot;  WHERE WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L564">			buf.append(m_dmo.createInClause(workResourceIDs)).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">			if (extraCondition.trim().length() &gt; 0)</span>
<span class="nc" id="L566">				buf.append(extraCondition);</span>

<span class="nc" id="L568">			m_dmo.executeCommand(buf.toString());</span>
<span class="nc" id="L569">		} catch (JdmoException e) {</span>
<span class="nc" id="L570">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L571">		}</span>
<span class="nc" id="L572">	}</span>

	/**
	 * This is an override of the base class function Takes the currently
	 * published schedule for the selected employees and time period and
	 * overwrites the current schedule with it.
	 */
	public Collection&lt;ID&gt; revertToPublishedSchedule(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
		try {
			/* first' we shall delete the current schedule */
<span class="nc" id="L583">			deleteEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			// V10SP6 HRF9 Activities are overlapping - ESR#4169926
<span class="nc" id="L586">			RecurringEventTemplateDAO daoRecTemplate = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L587">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; recInstances =</span>
<span class="nc" id="L588">					daoRecTemplate.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L589">			Collection&lt;CalendarEventAssignment&gt; recPerEmp = null;</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">			for (Iterator&lt;Collection&lt;CalendarEventAssignment&gt;&gt; i = recInstances.iterator(); i.hasNext();) {</span>
<span class="nc" id="L591">				recPerEmp = i.next();</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">				if (recPerEmp != null &amp;&amp; !recPerEmp.isEmpty()) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">					for (Iterator&lt;CalendarEventAssignment&gt; it = recPerEmp.iterator(); it.hasNext();) {</span>
<span class="nc" id="L594">						CalendarEventAssignment event = it.next();</span>
<span class="nc" id="L595">						Collection&lt;ID&gt; attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L596">						attendees.retainAll(workResourceIDs);</span>
<span class="nc" id="L597">						daoRecTemplate.deleteRecurringEventInstance(event.getParentID(), attendees,</span>
<span class="nc" id="L598">								event.getStartTime());</span>
<span class="nc" id="L599">					}</span>
				}
			}

			/* now get all the event assignments from the published schedule */
<span class="nc" id="L604">			CalendarEventAssignmentPubDAO daoPub = getPublishedDAO();</span>
<span class="nc" id="L605">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listPublishedEvents =</span>
<span class="nc" id="L606">					daoPub.getEventsToBeReverted(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * now that we've got this collection of events, go through and
			 * create copies of objects so that they can be persisted
			 */
<span class="nc" id="L612">			Collection&lt;CalendarEventAssignment&gt; listEventsToCreate = ScheduleDAOUtil.cloneEventsForPublishing(listPublishedEvents);</span>

			/*
			 * remove recurring event instance or exception from published area
			 * to avoid duplication.
			 */
<span class="nc" id="L618">			Collection&lt;ID&gt; recTemplateIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L619">			JdmoRowset rs = m_dmo.createRowset(&quot;SELECT ID FROM RECURRINGEVENTTEMPLATE&quot;);</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L621">				recTemplateIDs.add(rs.getID(1));</span>
			}

<span class="nc" id="L624">			Set&lt;CalendarEventAssignment&gt; recInstanceToMakeHole = new HashSet&lt;CalendarEventAssignment&gt;(recTemplateIDs.size());</span>
			// remove attendee that is not in the revert list
<span class="nc" id="L626">			CalendarEventAssignment cea = null;</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; i = listEventsToCreate.iterator(); i.hasNext();) {</span>
<span class="nc" id="L628">				cea = i.next();</span>
<span class="nc bnc" id="L629" title="All 4 branches missed.">				if (cea.getParentID() != null &amp;&amp; recTemplateIDs.contains(cea.getParentID())) {</span>
<span class="nc" id="L630">					recInstanceToMakeHole.add(cea);</span>
				}
<span class="nc" id="L632">				Collection&lt;CalendarEventAttendee&gt; attendees = cea.getChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L633" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAttendee&gt; it = attendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L634">					CalendarEventAttendee attendee = it.next();</span>
<span class="nc" id="L635">					ID wrkrId = attendee.getWorkResourceID();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">					if (workResourceIDs.contains(wrkrId))</span>
<span class="nc" id="L637">						cea.deleteChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, attendee.getID());</span>
<span class="nc" id="L638">				}</span>
<span class="nc" id="L639">			}</span>

			/**
			 * Now persist the given collection of published events to the
			 * current schedule
			 */
<span class="nc" id="L645">			Collection&lt;ID&gt; eventIds = createObjects(listEventsToCreate);</span>

			/**
			 * update the publishingperiod's publishtime, make it now. that
			 * means the schedule is sync with publish
			 */
<span class="nc" id="L651">			PublishingPeriodDAO daoPubPeriod = new PublishingPeriodDAO(m_dmo);</span>
<span class="nc" id="L652">			daoPubPeriod.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>

			// if recurring instance was reverted back, have to make a hole
<span class="nc bnc" id="L655" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it = recInstanceToMakeHole.iterator(); it.hasNext();) {</span>
<span class="nc" id="L656">				CalendarEventAssignment event = (CalendarEventAssignment) it.next();</span>
<span class="nc" id="L657">				Collection&lt;ID&gt; attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L658">				attendees.retainAll(workResourceIDs);</span>
<span class="nc" id="L659">				daoRecTemplate.deleteRecurringEventInstance(event.getParentID(), attendees, event.getStartTime());</span>
<span class="nc" id="L660">			}</span>

<span class="nc" id="L662">			return eventIds;</span>
<span class="nc" id="L663">		} catch (JdmoException e) {</span>
<span class="nc" id="L664">			throw new BbmSchedulePublishingException(e);</span>
<span class="nc" id="L665">		} catch (BbmException e) {</span>
<span class="nc" id="L666">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	/**
	 * This is a helper function only used internally by the schedule access
	 * manager EJB
	 */
	public Collection&lt;CalendarEventAssignment&gt; getEventsByTemplateID(ID templateID) throws BbmFinderException {
<span class="nc" id="L675">		return getObjects(&quot;CALENDAREVENTTEMPLATEID = &quot; + templateID);</span>
	}

	/** This is an override of the base class function */
	protected Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsToBePublished(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd, boolean bPublishedPeriodsOnly) throws BbmFinderException {
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">		if (!bPublishedPeriodsOnly) {</span>
<span class="fc" id="L682">			return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, false);</span>
		} else {
			/*
			 * iterate through the possible DAO types that get all possible
			 * types of event assignments
			 */
<span class="nc" id="L688">			Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents =</span>
					new ArrayList&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt;(2);

<span class="nc" id="L691">			allEvents.add(this.getEventsForWorkResourcesInPublishedPeriodsOnly(workResourceIDs, dtStart, dtEnd));</span>

			/*
			 * Note: no need to do floating events separately since they will be
			 * already persisted as records in CALENDAREVENTASSIGNMENT table and
			 * this covered by CalendarEventAssignment DAO
			 */
<span class="nc" id="L698">			RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L699">			allEvents.add(daoRecurring.getEventsToBePublishedInPublishedPeriodsOnly(workResourceIDs, dtStart, dtEnd));</span>
<span class="nc" id="L700">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
		}
	}

	// override the method defined in DAONode
	public void updateObject(CalendarEventAssignment objValue) throws MultiUserException, BbmUpdateException {
<span class="fc" id="L706">		CalendarEventAssignment event = objValue;</span>

<span class="pc bpc" id="L708" title="1 of 2 branches missed.">		if (objValue.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME)</span>
<span class="pc bpc" id="L709" title="1 of 2 branches missed.">				&amp;&amp; objValue.isFieldValueSet(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="fc" id="L710">			event.setFieldValue(CalendarEventAssignmentFields.ENDTIME,</span>
<span class="fc" id="L711">					new Date(event.getStartTime().getTime() + event.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}

<span class="fc" id="L714">		super.updateObject(objValue);</span>
<span class="fc" id="L715">	}</span>

	public static String getEventTypeWhereClause(int eventTypeBitMask) {
<span class="fc" id="L718">		StringBuffer sb = new StringBuffer(100);</span>
<span class="fc" id="L719">		List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(3);</span>
<span class="fc bfc" id="L720" title="All 2 branches covered.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="fc" id="L721">			list.add(new Integer(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT));</span>
		}
<span class="fc bfc" id="L723" title="All 2 branches covered.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_TIME_OFF) != 0) {</span>
<span class="fc" id="L724">			list.add(new Integer(Event.EVENT_TYPE_TIME_OFF));</span>
		}
<span class="fc bfc" id="L726" title="All 2 branches covered.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_UNAVAILABILITY) != 0) {</span>
<span class="fc" id="L727">			list.add(new Integer(Event.EVENT_TYPE_UNAVAILABILITY));</span>
		}

<span class="fc bfc" id="L730" title="All 2 branches covered.">		for (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();) {</span>
<span class="fc" id="L731">			Integer type = i.next();</span>
<span class="fc" id="L732">			sb.append(&quot;EVENTTYPE = &quot; + type.intValue());</span>
<span class="fc bfc" id="L733" title="All 2 branches covered.">			if (i.hasNext()) {</span>
<span class="fc" id="L734">				sb.append(&quot; OR &quot;);</span>
			}
<span class="fc" id="L736">		}</span>
<span class="fc" id="L737">		return sb.toString();</span>
	}

	@Deprecated
	public void deleteCalendarEventAssignments(Collection&lt;ID&gt; colWorkResourceIDs, Date start, Date end)
			throws BbmRemoveException, JdmoException {
<span class="nc" id="L743">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L744">		buf.append(&quot; SELECT A.ID FROM CALENDAREVENTASSIGNMENT A WHERE &quot;);</span>
<span class="nc" id="L745">		buf.append(getWhereClauseForGetEventsQuery(colWorkResourceIDs, start, end).toString());</span>
<span class="nc" id="L746">		deleteObjects(buf.toString());</span>
<span class="nc" id="L747">	}</span>

	// Tample:Add for QA 85638:START
	/**
	 * Deletes the entries in CalendarEventAttendee for the Ids passed and
	 * CalendarEventAssignment is deleted only if there are no entries in
	 * CalendarEventAssignment
	 */
	public void deleteObjects(Collection&lt;ID&gt; colIDs, Collection&lt;ID&gt; idsExistingInAttendee) throws BbmRemoveException {

		try {
<span class="nc" id="L758">			StringBuffer stmt = new StringBuffer(100);</span>

<span class="nc bnc" id="L760" title="All 6 branches missed.">			if (!(idsExistingInAttendee == null || idsExistingInAttendee.isEmpty() || colIDs == null || colIDs</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">					.isEmpty())) {</span>
				// delete child records in CalendarEventAttendee first
<span class="nc" id="L763">				stmt.append(</span>
						&quot;DELETE CALENDAREVENTATTENDEE WHERE WORKRESOURCEID IN &quot;
<span class="nc" id="L765">								+ m_dmo.createInClause(idsExistingInAttendee)).append(</span>
<span class="nc" id="L766">						&quot; AND CALENDAREVENTASSIGNMENTID IN&quot; + m_dmo.createInClause(colIDs));</span>
<span class="nc" id="L767">				m_dmo.execute(stmt.toString());</span>
			}
			// delete records in CalendarEventAssignmentPub only if no record
			// exists for the event in attendee
<span class="nc bnc" id="L771" title="All 4 branches missed.">			if (colIDs == null || colIDs.isEmpty())</span>
<span class="nc" id="L772">				return;</span>

<span class="nc" id="L774">			stmt = new StringBuffer(100);</span>
<span class="nc" id="L775">			stmt.append(&quot;DELETE CALENDAREVENTASSIGNMENT WHERE ID &quot;</span>
					+ &quot; IN &quot;
<span class="nc" id="L777">					+ m_dmo.createInClause(colIDs)</span>
					+ &quot; &quot;
					+ &quot; AND NOT EXISTS (SELECT 1 FROM CALENDAREVENTATTENDEE WHERE CALENDAREVENTATTENDEE.CALENDAREVENTASSIGNMENTID = CALENDAREVENTASSIGNMENT.ID)&quot;);

<span class="nc" id="L781">			m_dmo.execute(stmt.toString());</span>

<span class="nc" id="L783">		} catch (Exception ex) {</span>
<span class="nc" id="L784">			new BbmRemoveException(ex);</span>
<span class="nc" id="L785">		}</span>
<span class="nc" id="L786">	}</span>

	// Tample:Add for QA 85638:END
	@Deprecated
	public void deleteCalendarEventAssignments(Collection&lt;ID&gt; colWorkResourceIDs, Date start, Date end,
			Collection&lt;ID&gt; activityIDs) throws BbmRemoveException, JdmoException {
<span class="nc" id="L792">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L793">		buf.append(&quot; SELECT A.ID FROM CALENDAREVENTASSIGNMENT A WHERE &quot;);</span>
<span class="nc bnc" id="L794" title="All 4 branches missed.">		if (activityIDs != null &amp;&amp; !activityIDs.isEmpty())</span>
<span class="nc" id="L795">			buf.append(&quot; ACTIVITYID IN &quot;).append(m_dmo.createInClause(activityIDs)).append(&quot; AND &quot;);</span>
<span class="nc" id="L796">		buf.append(getWhereClauseForGetEventsQuery(colWorkResourceIDs, start, end).toString());</span>
<span class="nc" id="L797">		deleteObjects(buf.toString());</span>
<span class="nc" id="L798">	}</span>

	// the following two methods has the same logic in
	// getconflictsforscheduleobject api.
	public BbmScheduleConflict getConflict(CalendarEventAssignment event1, Collection&lt;CalendarEventAssignment&gt; overlapEvents, boolean isNewObject) {
<span class="nc bnc" id="L803" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; i = overlapEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L804">			CalendarEventAssignment event2 = i.next();</span>
<span class="nc bnc" id="L805" title="All 2 branches missed.">			if (isInstanceForSameFloatingTemplate(event1, event2))</span>
				// update the same floating event template
<span class="nc" id="L807">				return null;</span>
<span class="nc bnc" id="L808" title="All 6 branches missed.">			if ((isNewObject || event1.getID() == null || !event1.getID().equals(event2.getID()))</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">					&amp;&amp; event1.getOverlayPrecedence() == event2.getOverlayPrecedence()) {</span>
<span class="nc" id="L810">				Collection&lt;ID&gt; workResourceIDs = event1.getWorkResourceIDs();</span>
<span class="nc" id="L811">				workResourceIDs.retainAll(event2.getWorkResourceIDs());</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">				if (!workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L813">					return new BbmScheduleConflict(event1, event2);</span>
				}
			}
<span class="nc" id="L816">		}</span>
<span class="nc" id="L817">		return null;</span>
	}

	public BbmScheduleConflict getConflict(CalendarEventAssignment event, Collection&lt;ShiftAssignment&gt; overlapShifts) {
<span class="nc bnc" id="L821" title="All 2 branches missed.">		for (Iterator&lt;ShiftAssignment&gt; i = overlapShifts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L822">			ShiftAssignment shift = i.next();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">			if (shift.getOverlayPrecedence() == event.getOverlayPrecedence()) {</span>
<span class="nc" id="L824">				return new BbmScheduleConflict(shift, event);</span>
			}
<span class="nc" id="L826">		}</span>
<span class="nc" id="L827">		return null;</span>
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd, String strNativeTempName) throws BbmFinderException {

		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="nc" id="L840">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt;(2);</span>

<span class="nc" id="L842">		StringBuffer strSQL = new StringBuffer(200);</span>
<span class="nc" id="L843">		strSQL.append(&quot; calendareventassignmentid in (select c.id from calendareventassignment c , calendareventattendee a, &quot;</span>
				+ strNativeTempName
				+ &quot; t where c.id = a.calendareventassignmentid and a.workresourceid = t.workresourceid and c.starttime &lt; t.endtime and c.endtime &gt; t.starttime and (&quot;
<span class="nc" id="L846">				+ CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask) + &quot;))&quot;);</span>
<span class="nc" id="L847">		CalendarEventAttendeeDAO dao = (CalendarEventAttendeeDAO) createChildDAO(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc" id="L848">		Collection&lt;CalendarEventAttendee&gt; caAttendees = dao.getObjects(strSQL.toString());</span>

<span class="nc" id="L850">		CalendarEventAttendee attendee = null;</span>
<span class="nc" id="L851">		Map&lt;ID, List&lt;CalendarEventAttendee&gt;&gt; attendeeMap = new HashMap&lt;ID, List&lt;CalendarEventAttendee&gt;&gt;();</span>
<span class="nc" id="L852">		List&lt;CalendarEventAttendee&gt; attendeeList = null;</span>
<span class="nc" id="L853">		ID eventID = null;</span>
<span class="nc bnc" id="L854" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAttendee&gt; i = caAttendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L855">			attendee = i.next();</span>
<span class="nc" id="L856">			eventID = attendee.getParentID();</span>
<span class="nc" id="L857">			attendeeList = attendeeMap.get(eventID);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">			if (attendeeList == null) {</span>
<span class="nc" id="L859">				attendeeList = new ArrayList&lt;CalendarEventAttendee&gt;();</span>
<span class="nc" id="L860">				attendeeMap.put(eventID, attendeeList);</span>
			}
<span class="nc" id="L862">			attendeeList.add(attendee);</span>
		}

<span class="nc" id="L865">		strSQL = new StringBuffer(200);</span>
<span class="nc" id="L866">		strSQL.append(&quot; id in (select c.id from calendareventassignment c , calendareventattendee a, &quot;</span>
				+ strNativeTempName
				+ &quot; t where c.id = a.calendareventassignmentid and a.workresourceid = t.workresourceid and c.starttime &lt; t.endtime and c.endtime &gt; t.starttime and (&quot;
<span class="nc" id="L869">				+ CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask) + &quot;))&quot;);</span>
<span class="nc" id="L870">		Collection&lt;CalendarEventAssignment&gt; caEvents = getObjectsWithoutChild(strSQL.toString());</span>
<span class="nc" id="L871">		CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; i = caEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L873">			event = i.next();</span>
<span class="nc" id="L874">			attendeeList = attendeeMap.get(event.getID());</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">			if (attendeeList != null) {</span>
				// feed the children of event
<span class="nc bnc" id="L877" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAttendee&gt; ii = attendeeList.iterator(); ii.hasNext();)</span>
<span class="nc" id="L878">					event.fillChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, ii.next());</span>
			}
		}

<span class="nc" id="L882">		allEvents.add(ScheduleDAOUtil.groupEventsByWorkResources(caEvents, workResourceIDs));</span>

<span class="nc" id="L884">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L885">		allEvents.add(daoRecurring.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L887">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	protected Collection&lt;ID&gt; getCalendarEventAssignmentsForSelectedActivities(Collection&lt;ID&gt; colWorkResourceIDs,
		Date start, Date end, Collection&lt;ID&gt; activityIDs) throws JdmoException {

<span class="nc" id="L893">		Collection&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L894">		StringBuilder sb = new StringBuilder(200);</span>
<span class="nc" id="L895">		sb.append(&quot;SELECT A.ID FROM CALENDAREVENTASSIGNMENT A WHERE &quot;);</span>
<span class="nc bnc" id="L896" title="All 4 branches missed.">		if (activityIDs != null &amp;&amp; !activityIDs.isEmpty()) {</span>
<span class="nc" id="L897">			sb.append(&quot; A.ACTIVITYID IN &quot;).append(m_dmo.createInClause(activityIDs)).append(&quot; AND &quot;);</span>
		}
<span class="nc" id="L899">		sb.append(getWhereClauseForGetEventsQuery(colWorkResourceIDs, start, end).toString() );</span>

<span class="nc" id="L901">		JdmoRowset rs = m_dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">		while(rs.next()) {</span>
<span class="nc" id="L903">			ids.add(rs.getID(1));</span>
		}

<span class="nc" id="L906">		return ids;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>