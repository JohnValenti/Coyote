<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeOffIntervalPaidSegmentDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb</a> &gt; <span class="el_source">TimeOffIntervalPaidSegmentDAO.java</span></div><h1>TimeOffIntervalPaidSegmentDAO.java</h1><pre class="source lang-java linenums">/*
 * TimeOffIntervalPaidSegments.java
 * jthelen
 * Jan 25, 2016
 * Copyright (c) 2016, Verint, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.model.TimeOffIntervalPaidSegment;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.model.TimeOffIntervalPaidSegmentFieldInfo;


/**
 * DAO class for TimeOffIntervalPaidSegmentsDAO
 */
public class TimeOffIntervalPaidSegmentDAO extends DAOBase&lt;TimeOffIntervalPaidSegment&gt; {
   
<span class="fc" id="L43">    private static FieldInfo fieldInfo = new TimeOffIntervalPaidSegmentFieldInfo();</span>

<span class="fc" id="L45">    private static final Category LOG = Log.initCategory(TimeOffIntervalPaidSegment.class.getName());</span>

    /**
     * Constructor
     */
    public TimeOffIntervalPaidSegmentDAO() {
<span class="fc" id="L51">        super();</span>
<span class="fc" id="L52">    }</span>

    /** Constructor
     * @param - Jdmo - Jdmo object instance
     * @see Jdmo.
     */
    public TimeOffIntervalPaidSegmentDAO(Jdmo dmo) {
<span class="nc" id="L59">        super(dmo);</span>
<span class="nc" id="L60">    }</span>

    @Override
	protected FieldInfo getFieldInfo() {
<span class="fc" id="L64">        return fieldInfo;</span>
    }

    protected Category getCategory() {
<span class="nc" id="L68">        return LOG;</span>
    }
    
    /**
	 * Creates the value object.
	 *
	 * @return - returns new Value object
	 * @see com.bluepumpkin.ejb.bbm.vo.ValueObjectBase
	 * @see com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TimeOffIntervalPaidSegment
	 */
	@Override
	protected TimeOffIntervalPaidSegment createValueObject() {
<span class="nc" id="L80">		return (new TimeOffIntervalPaidSegment());</span>
	}

   
    /** Finds TimeOffIntervalPaidSegments for the id object passed as argument.
     *  @param - ID -  ID object for TimeOffIntervalPaidSegments.
     *  @return - TimeOffIntervalPaidSegments Object.
     *  @throw BbmFinderException, BbmObjectNotFoundException
     */
    public TimeOffIntervalPaidSegment findById(ID id) throws BbmFinderException {
    	
<span class="nc" id="L91">            return getObjectByID(id);</span>
    }

    /** Create new TimeOffIntervalPaidSegments for the object passed as argument.
     *  @param - TimeOffIntervalPaidSegments -  TimeOffIntervalPaidSegments object
     *  @return - ID object for created TimeOffIntervalPaidSegments.
     *        @throw BbmCreateException
     */
    public ID createTimeOffIntervalPaidSegment(TimeOffIntervalPaidSegment segment) throws RmException, BbmCreateException {

<span class="nc" id="L101">    	verifyTimeOffIntervalPaidSegmentValid(segment);</span>
        
		// Call base class method to create object
<span class="nc" id="L104">    	return createObject(segment);</span>
		

    }

    /** Update TimeOffIntervalPaidSegments database for the TimeOffIntervalPaidSegments object passed as argument.
     *  @param - segment -  TOChoice object for Time off Choice.
     *        @throw BbmUpdateException
     */
    public void updateTimeOffIntervalPaidSegment(TimeOffIntervalPaidSegment segment) throws RmException, MultiUserException, BbmUpdateException {
<span class="nc" id="L114">    	verifyTimeOffIntervalPaidSegmentValid(segment);</span>
<span class="nc" id="L115">            updateObject(segment);</span>
<span class="nc" id="L116">    }</span>

   
    public void deleteTimeOffIntervalPaidSegment(ID timeOffIntervalPaidSegmentId) throws BbmRemoveException {
<span class="nc" id="L120">            deleteObject(timeOffIntervalPaidSegmentId);</span>
<span class="nc" id="L121">    }</span>
    
	public void deleteTimeOffIntervalPaidSegmentsForTimeOffChoice(
			ID timeoffChoiceId) throws BbmRemoveException {

<span class="nc" id="L126">		deleteTimeOffIntervalsForTimeOffChoices(Collections.singleton(timeoffChoiceId));</span>

<span class="nc" id="L128">	}</span>
	

	public void deleteTimeOffIntervalsForTimeOffChoices(
			Collection&lt;ID&gt; timeOffChoiceIDs) throws BbmRemoveException {

		try {
<span class="fc" id="L135">			String sql = &quot;delete TIMEOFFINTERVALPAIDSEGMENT WHERE TIMEOFFCHOICEID in %s &quot;;</span>
<span class="fc" id="L136">			sql = String.format(sql, m_dmo.createInClause(timeOffChoiceIDs));</span>
<span class="fc" id="L137">			m_dmo.executeCommand(sql);</span>

<span class="nc" id="L139">		} catch (JdmoException e) {</span>
<span class="nc" id="L140">			throw new BbmRemoveException(e);</span>
<span class="fc" id="L141">		}</span>

<span class="fc" id="L143">	}</span>
	
    
    /**
	 * Finds all TimeOffIntervalPaidSegments for the Time off TOChoice id passed as argument.
	 * @param - ID - ID object for TOChoice.
	 * @return - Collection of TimeOffIntervalPaidSegments Object.
	 * @see TimeOffIntervalPaidSegments.
	 * @throw BbmFinderException
	 */
	public List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsForTimeOffChoice(ID timeoffChoiceId) throws BbmFinderException {
		
		
<span class="nc" id="L156">		StringBuilder strSQL = new StringBuilder(200);</span>
<span class="nc" id="L157">		strSQL.append(TimeOffIntervalPaidSegmentFieldInfo</span>
<span class="nc" id="L158">				.getColumnName(TimeOffIntervalPaidSegmentFieldInfo.TIMEOFFINTERVALPAIDSEGMENT_I_TIMEOFFCHOICEID));</span>
<span class="nc" id="L159">		strSQL.append(&quot; = &quot;);</span>
<span class="nc" id="L160">		strSQL.append(timeoffChoiceId.toString());</span>
<span class="nc" id="L161">		strSQL.append(&quot; ORDER BY &quot;);</span>
<span class="nc" id="L162">		strSQL.append(TimeOffIntervalPaidSegmentFieldInfo.getColumnName(TimeOffIntervalPaidSegmentFieldInfo.TIMEOFFINTERVALPAIDSEGMENT_D_STARTTIME))</span>
<span class="nc" id="L163">				.append(&quot; &quot;);</span>
		
		
<span class="nc" id="L166">		return (List&lt;TimeOffIntervalPaidSegment&gt;) getObjects(strSQL.toString());</span>
	}

	/**
	 * Finds all TimeOffIntervalPaidSegments that intersect the TimeRange passed
	 * as argument.
	 * 
	 * @param - TimeRange
	 * @return - Collection of TimeOffIntervalPaidSegments Object.
	 * @see List&lt;TimeOffIntervalPaidSegment&gt;
	 * @throw BbmFinderException
	 */
	public List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsIntersectTimeRange(
			TimeRange timeRange) throws BbmFinderException {

<span class="nc" id="L181">		StringBuilder where = new StringBuilder(256);</span>
<span class="nc" id="L182">		appendDateRangeClause(where, timeRange, &quot;&quot;, false);</span>
<span class="nc" id="L183">		where.append(&quot; ORDER BY &quot;);</span>
<span class="nc" id="L184">		where.append(</span>
				TimeOffIntervalPaidSegmentFieldInfo
<span class="nc" id="L186">						.getColumnName(TimeOffIntervalPaidSegmentFieldInfo.TIMEOFFINTERVALPAIDSEGMENT_D_STARTTIME))</span>
<span class="nc" id="L187">				.append(&quot; &quot;);</span>
<span class="nc" id="L188">		return (List&lt;TimeOffIntervalPaidSegment&gt;) getObjects(where.toString());</span>

	}
	/**
	 * Validity checking for fields in TimeOffIntervalPaidSegment 
	 * @param timeOffIntervalPaidSegment
	 * @throws RmException
	 */
	protected void verifyTimeOffIntervalPaidSegmentValid(
			TimeOffIntervalPaidSegment segment) throws RmException {

<span class="nc" id="L199">		Date start = segment.getStartTime();</span>
<span class="nc" id="L200">		Date end = segment.getEndTime();</span>

<span class="nc bnc" id="L202" title="All 6 branches missed.">		if ((start == null) || (end == null) || (end.before(start))) {</span>
<span class="nc" id="L203">			throw RequestUtil.createRmException(</span>
					RmEjbLogBundleKey.INVALID_TIME_RANGE, start, end, LOG);
		}

<span class="nc bnc" id="L207" title="All 2 branches missed.">		if (segment.getTOChoiceID() == null) {</span>
<span class="nc" id="L208">			throw RequestUtil</span>
<span class="nc" id="L209">					.createRmException(</span>
							RmEjbLogBundleKey.TIMEOFFINTERVALALLOCATIONSEGMENT_TOCHOICE_INVALID, LOG);
							
		}
<span class="nc" id="L213">	}</span>

	// if StartDate !=null then will return all requests that end after this
	// date
	// if endDate !=null then will return all requests that start before this
	// date.
	
	// if overlap==true, then the ENDTIME clause uses &gt;=, otherwise strictly =
	private void appendDateRangeClause(StringBuilder buf, TimeRange dateRange,
			String appendStr, boolean overlap) {
<span class="nc bnc" id="L223" title="All 2 branches missed.">		if (dateRange != null) {</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">			if (appendStr != null) {</span>
<span class="nc" id="L225">				buf.append(appendStr);</span>
			}
<span class="nc" id="L227">			buf.append(&quot; STARTTIME &lt;= '&quot;)</span>
<span class="nc" id="L228">					.append(JdmoUtil.formatDBString(dateRange.getEndDate()))</span>
<span class="nc" id="L229">					.append(&quot;' AND &quot;);</span>
<span class="nc" id="L230">			buf.append(&quot; ENDTIME &gt;&quot;);</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (overlap) {</span>
<span class="nc" id="L232">				buf.append(&quot;=&quot;);</span>
			}
<span class="nc" id="L234">			buf.append(&quot; '&quot;)</span>
<span class="nc" id="L235">					.append(JdmoUtil.formatDBString(dateRange.getStartDate()))</span>
<span class="nc" id="L236">					.append(&quot;' &quot;);</span>
		}
<span class="nc" id="L238">	}</span>
	
	/**
	 * @return 
	 * The list of time off request choices that are affected when the date range [start,end) is published/unpublished.
	 * 
	 * A request is affected if  
	 *  
	 *  The time off request choice intersects the range [start,end)  or the time off request choice 
	 *  is using the reference scheduling period with range [start,end)  and the request is pending/waitlisted and in the future
	 */
	public List&lt;ID&gt; getAffectedRequestChoices(Collection&lt;ID&gt; employeeIDs, Date start, Date end) throws BbmFinderException {

<span class="pc bpc" id="L251" title="2 of 4 branches missed.">		if (employeeIDs == null || employeeIDs.isEmpty()) {</span>
<span class="nc" id="L252">			return Collections.emptyList();</span>
		}

		try {
			//@formatter:off
<span class="fc" id="L257">			String sql =</span>
					  &quot;select TRC.ID &quot; 
					+ &quot;from TIMEOFFREQUESTCHOICE TRC &quot;
					+ &quot;inner join REQUEST R on TRC.TIMEOFFREQUESTID = R.ID &quot;
					+ &quot;left join SP on SP.SID = TRC.REFERENCESPID &quot;
					+ &quot;where R.EMPLOYEEID in %s  and  &quot;
					+ &quot;( (SP.FROMDATE = '%s' and SP.TODATE = '%s' and R.REQUESTSTATUS in ('pending','waitlist') and TRC.ENDTIME &gt; '%s') &quot;
					+ &quot;OR ( TRC.STARTTIME &lt; '%s' and TRC.ENDTIME &gt; '%s' ) )&quot; ;
			//@formatter:on

<span class="fc" id="L267">			String sqlStart = JdmoUtil.formatDBString(start);</span>
<span class="fc" id="L268">			String sqlEnd = JdmoUtil.formatDBString(end);</span>
<span class="fc" id="L269">			String sqlNow = JdmoUtil.formatDBString(new Date());</span>

<span class="fc" id="L271">			sql = String.format(sql, m_dmo.createInClause(employeeIDs), sqlStart, sqlEnd, sqlNow, sqlEnd, sqlStart);</span>

<span class="fc" id="L273">			JdmoRowset res = m_dmo.createRowset(sql);</span>
<span class="fc" id="L274">			List&lt;ID&gt; result = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">			while (res.next()) {</span>
<span class="fc" id="L276">				result.add(res.getID(&quot;ID&quot;));</span>
			}

<span class="fc" id="L279">			return result;</span>

<span class="nc" id="L281">		} catch (JdmoException e) {</span>
<span class="nc" id="L282">			throw new BbmFinderException(e);</span>
		}

	}



	
	
}
 
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>