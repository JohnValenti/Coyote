<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ValidationRequestHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.rm.setup.validation</a> &gt; <span class="el_source">ValidationRequestHandler.java</span></div><h1>ValidationRequestHandler.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.rm.setup.validation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.setup.validation.model.ValidationRule;
import com.bluepumpkin.ejb.rm.setup.validation.model.ValidationSetting;
import com.bluepumpkin.web.bbm.organization.OrganizationRequestHandler;
import com.bluepumpkin.web.rm.Log;
import com.bluepumpkin.web.rm.l10n.RmWebBundleKey;
import com.bluepumpkin.web.rm.l10n.RmWebLogBundleKey;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.web.uif.base.Message;
import com.witness.web.uif.keys.PageAction;
import com.witness.web.uif.system.RequestContext;


/**
 * Title          ValidationRequestHandler
 * Description    Handle request for the Validation page
 * Copyright      Copyright (c) 2002
 * Company        Blue Pumpkin Software, Inc
 * @author        Shubhangi Chavan
 * @version       1.0
 */
<span class="fc" id="L32">public class ValidationRequestHandler extends OrganizationRequestHandler {</span>
<span class="fc" id="L33">	private static final Category log =</span>
<span class="fc" id="L34">			Log.initCategory(ValidationRequestHandler.class.getName());</span>

	/**
	 * Process Request for the User page
	 * @param   context   RequestContext
	 * @throws Exception
	 */
	@Override
	public void processRequest(RequestContext context) throws Exception
    {
		// Process requested action
<span class="fc bfc" id="L45" title="All 2 branches covered.">		if (isAction(context, PageAction.SAVE)) {</span>
<span class="fc" id="L46">			processSave(context, true);</span>
<span class="pc bpc" id="L47" title="1 of 2 branches missed.">		} else if (isAction(context, PageAction.SAVE_AS)) {</span>
<span class="nc" id="L48">			processSave(context, false);</span>
		}
<span class="fc" id="L50">	}</span>

	/**
	 * Processes the Save action
	 * @param context - The Request context object
     * @param shallow - True means apply to this org only. False will apply to sub orgs too.
	 */
	private void processSave(RequestContext context, boolean shallow)
    {
<span class="pc bpc" id="L59" title="1 of 2 branches missed.">		if (!isAuthorizedForOrg(context,</span>
				new String[] {PrivilegeKeys.TOM_SETVALIDATIONRULES,
					PrivilegeKeys.SS_SETVALIDATIONRULES,
					PrivilegeKeys.SB_SETVALIDATIONRULES,
					PrivilegeKeys.CS_SETVALIDATIONRULES
				},
				true))
        {
<span class="nc" id="L67">			return;</span>
		}

		// Make page model and tell it to create the form model now because
		// we need this ValidationRulePC component in order to extract the
		// parameters.
<span class="fc" id="L73">		ValidationPageModel model = new ValidationPageModel(context);</span>
<span class="fc" id="L74">		model.createFormModel();</span>
<span class="fc" id="L75">		model.extractParameters(context.getRequest());</span>
		
		// JT
		// Validation By Timeoff Type
<span class="fc" id="L79">		List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs = model.getApplicableActivityIDs();</span>
		
		
		
<span class="fc" id="L83">		ID orgID = model.getSelectedIDObject();</span>
<span class="pc bpc" id="L84" title="2 of 4 branches missed.">		if (model.validate() &amp;&amp; orgID != null)</span>
        {
			try
            {
<span class="fc" id="L88">                ValidationSetting validationSetting = model.getConfiguration();</span>
<span class="fc" id="L89">                keepOnlyChangedSections(validationSetting, orgID, listSelectedTimeOffTypeActivityIDs);</span>
<span class="fc" id="L90">                Map validationRules = validationSetting.getValues();</span>

				// Pass the hashmap that has the validation rule
<span class="fc" id="L93">                ValidationModelHandler.updateValidationRules(validationRules, orgID, shallow, listSelectedTimeOffTypeActivityIDs);</span>
			}
<span class="nc" id="L95">			catch (Exception ex)</span>
            {
<span class="nc" id="L97">				log.l7dError(RmWebLogBundleKey.ORG_RM_VALIDATION_ERROR_SAVE, ex);</span>
<span class="nc" id="L98">				model.addPageMessage(Message.ERROR_TYPE,</span>
						RmWebBundleKey.ORG_RM_VALIDATION_ERROR_SAVE,
						RmWebBundleKey.BUNDLE_NAME);
<span class="fc" id="L101">			}</span>
		}
<span class="fc" id="L103">	}</span>

    /**
     * Given an ValidationSetting object, remove keys from all sections which have not changed.
     * If even a single key or param has changed in a section, we keep all of the keys in that section.
     * @param newSettings An ValidationSetting object which has a settings map in it.
     */
    private void keepOnlyChangedSections(ValidationSetting newSettings, ID orgID, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs) throws Exception
    {
        //The newSettings map has all of the new settings. Compare with the original settings to
        //decide which settings to actually save in the database.
<span class="fc" id="L114">        Map oldMap =  ValidationModelHandler.findValidationRules(Request.REQUESTTYPE_ALL, orgID, false,listSelectedTimeOffTypeActivityIDs);</span>
<span class="fc" id="L115">        Map newMap = newSettings.getValues();</span>
<span class="fc" id="L116">        List differentValueKeys = getDifferentValueKeys(newMap, oldMap);</span>

<span class="fc" id="L118">        HashMap reducedMap = new HashMap(differentValueKeys.size());</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if (differentValueKeys.size() &gt; 0)</span>
        {
<span class="fc bfc" id="L121" title="All 2 branches covered.">            for (Iterator it=differentValueKeys.iterator(); it.hasNext();)</span>
            {
<span class="fc" id="L123">                String key = (String)it.next();</span>

                //add all of the keys in this key's section to the reducedMap
<span class="fc" id="L126">                String[] sectionKeys = getSectionKeys(key);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">                for (int i=0; i&lt;sectionKeys.length; i++)</span>
                {
<span class="fc" id="L129">                    String sectionKey = sectionKeys[i];</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">                    if (!reducedMap.containsKey(sectionKey))</span>
                    {
<span class="fc" id="L132">                        reducedMap.put(sectionKey, newMap.get(sectionKey));</span>
                    }
                }
<span class="fc" id="L135">            }</span>
        }
        //even if the reducedMap is empty, we still need to use it
<span class="fc" id="L138">        newSettings.setValues(reducedMap);</span>
<span class="fc" id="L139">    }</span>

    /**
     * Get a list of all of the keys that have different values between two maps.
     * We assume both maps have the same keys.
     * @return A List of all of the keys from the maps which have different values between the two.
     */
    private List getDifferentValueKeys(Map map1, Map map2)
    {
<span class="fc" id="L148">        ArrayList diffValKeys = new ArrayList(32);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        for (Iterator it=map1.keySet().iterator(); it.hasNext();)</span>
        {
<span class="fc" id="L151">            String curKey = (String)it.next();</span>
<span class="fc" id="L152">            ValidationRule val1 = (ValidationRule)map1.get(curKey);</span>
<span class="fc" id="L153">            ValidationRule val2 = (ValidationRule)map2.get(curKey);</span>

<span class="fc bfc" id="L155" title="All 2 branches covered.">            if ((val1.getEnabledState() != val2.getEnabledState()) ||</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">                    !areParamsTheSame(val1.getParamMap(), val2.getParamMap())) {</span>
<span class="fc" id="L157">				diffValKeys.add(curKey);</span>
			}
<span class="fc" id="L159">        }</span>
<span class="fc" id="L160">        return diffValKeys;</span>
    }


    /**
     * Given two param HashMaps, determine whether they contain the same values.
     * @param params1 - The first params HashMap.
     * @param params2 - The second params HashMap.
     * @return True if the HashMaps contain the same values, false otherwise.
     */
    private boolean areParamsTheSame(HashMap params1, HashMap params2)
    {
<span class="pc bpc" id="L172" title="3 of 4 branches missed.">        if (params1==null &amp;&amp; params2==null) {</span>
<span class="nc" id="L173">			return true;</span>
<span class="pc bpc" id="L174" title="2 of 4 branches missed.">		} else if (params1==null || params2==null) {</span>
<span class="nc" id="L175">			return false;</span>
<span class="fc bfc" id="L176" title="All 2 branches covered.">		} else if (params1.size() != params2.size()) {</span>
<span class="fc" id="L177">			return false;</span>
		} else
        {
<span class="pc bpc" id="L180" title="1 of 2 branches missed.">            for (Iterator it1=params1.keySet().iterator(); it1.hasNext();)</span>
            {
<span class="nc" id="L182">                Object key = it1.next();</span>
<span class="nc" id="L183">                Object o1 = params1.get(key);</span>
<span class="nc" id="L184">                Object o2 = params2.get(key);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">                if (!o1.toString().equals(o2.toString())) {</span>
<span class="nc" id="L186">					return false;</span>
				}
<span class="nc" id="L188">            }</span>
        }
<span class="fc" id="L190">        return true;</span>
    }

    /**
     * Given an validation rule BundleKey, return all of the keys in it's same section (including itself).
     * @param key An validation rule BundleKey
     * @return A String array of all of the keys in the key's same section (including itself).
     */
    private String[] getSectionKeys(String key)
    {
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">        if (key.startsWith(&quot;VALIDATION_SB_&quot;))</span>
        {
<span class="nc" id="L202">            return new String[] {ValidationRule.VALIDATION_SB_COMPLY_RULES,</span>
                    ValidationRule.VALIDATION_SB_COMPLY_HRS,
                    ValidationRule.VALIDATION_SB_COMPLY_SKILLS,
                    ValidationRule.VALIDATION_SB_COMPLY_AT_LEAST_SKILLS,
                    ValidationRule.VALIDATION_SB_COMPLY_HOO};
        }
<span class="fc bfc" id="L208" title="All 4 branches covered.">        else if (key.startsWith(&quot;VALIDATION_SS_&quot;) || key.startsWith(&quot;VALIDATION_PSS_&quot;))</span>
        {
<span class="fc" id="L210">            return new String[] {ValidationRule.VALIDATION_SS_SAME_CALL_CENTER,</span>
                    ValidationRule.VALIDATION_SS_SAME_CAMPAIGN,
                    ValidationRule.VALIDATION_SS_SAME_SKILLS,
                    ValidationRule.VALIDATION_SS_AT_LEAST_SAME_SKILLS,
                    ValidationRule.VALIDATION_SS_SAME_PROFICIENCY,
                    ValidationRule.VALIDATION_SS_COMPLY_HRS,
                    ValidationRule.VALIDATION_SS_NO_EVENT_OVERLAP,
                    ValidationRule.VALIDATION_SS_EVENT_MUST_OVERLAP,
                    ValidationRule.VALIDATION_SS_PAID_HRS,
                    ValidationRule.VALIDATION_SS_SHIFT_START,
                    ValidationRule.VALIDATION_SS_COMPLY_RULES,
                    ValidationRule.VALIDATION_PSS_MIN_SHIFT_SWAP_DURATION,
                    ValidationRule.VALIDATION_PSS_MIN_REMAINING_SHIFT_DURATION,
                    ValidationRule.VALIDATION_PSS_MAX_SWAP_DURATION_PER_DAY,
                    ValidationRule.VALIDATION_PSS_NON_SWAPPABLE_ACTIVITIES,
                    ValidationRule.VALIDATION_PSS_SHIFT_GAP_CONDITIONS,
                    ValidationRule.VALIDATION_PSS_MAX_ALLOWABLE_OVERLAP,
                    ValidationRule.VALIDATION_SS_MAX_CONSECUTIVE_WORKING_DAYS,
                    ValidationRule.VALIDATION_SS_MIN_TIME_BETWEEN_SHIFT_ASSIGNMENTS,
                    ValidationRule.VALIDATION_SS_MAX_APPROVED_SWAP_PER_SHIFT,
                    ValidationRule.VALIDATION_SS_MAX_ONE_WAY_SWAP_PER_PERSON_PERIOD,
                    ValidationRule.VALIDATION_PSS_MAX_APPROVED_PARTIAL_SWAPS_PER_SHIFT,
					ValidationRule.VALIDATION_SS_MAX_HOURS_ALTERNATE_MAX_HOURS_PER_DAY
            };
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		} else if (key.startsWith(&quot;VALIDATION_APPROVED_SS_WITHDRAW_&quot;)){</span>
<span class="nc" id="L235">			return new String[] {ValidationRule.VALIDATION_APPROVED_SS_WITHDRAW_COMPLY_FILINGRULE};</span>
        }
<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        else if (key.startsWith(&quot;VALIDATION_APPROVED_TO_WITHDRAW_&quot;))</span>
        {
<span class="nc" id="L239">            return new String[] {ValidationRule.VALIDATION_APPROVED_TO_WITHDRAW_COMPLY_FILINGRULE};</span>
        }
<span class="fc bfc" id="L241" title="All 2 branches covered.">        else if (key.startsWith(&quot;VALIDATION_CS_&quot;))</span>
        {
<span class="fc" id="L243">            return new String[] {ValidationRule.VALIDATION_CS_FULFILLS_NET_STAFFING_SHORTAGE,</span>
            ValidationRule.VALIDATION_CS_MAX_SHIFT_DURATION_PER_DAY,
            ValidationRule.VALIDATION_CS_MIN_SHIFT_DURATION_PER_DAY,
            ValidationRule.VALIDATION_CS_MAX_CONSECUTIVE_WORKING_DAYS,
            ValidationRule.VALIDATION_CS_MIN_TIME_BETWEEN_SHIFT_ASSIGNMENTS,
            ValidationRule.VALIDATION_CS_COMPLY_RULES,
            ValidationRule.VALIDATION_CS_COMPLY_HRS,
            ValidationRule.VALIDATION_CS_COMPLY_HOO,
            ValidationRule.VALIDATION_CS_TIMEOFF_OVERLAP,
            ValidationRule.VALIDATION_CS_UNAVAILABILITY_OVERLAP,
            ValidationRule.VALIDATION_CS_PUBLISHED_PERIOD,
            };
        }
<span class="fc bfc" id="L256" title="All 2 branches covered.">        else if (key.startsWith(&quot;VALIDATION_FT_&quot;))</span>
        {
<span class="fc" id="L258">            return new String[] {</span>
	    		ValidationRule.VALIDATION_FT_MAX_DURATION,
	    		ValidationRule.VALIDATION_FT_MIN_DURATION,
	    		ValidationRule.VALIDATION_FT_MAX_NUMBER_FLEX_REQ_PER_PERIOD,
	    		ValidationRule.VALIDATION_FT_MAX_NUMBER_MAKEUP_PER_REQUEST,
	    		ValidationRule.VALIDATION_FT_MUST_OCCUR_ASAP,
	    		ValidationRule.VALIDATION_FT_AVOID_SCHEDULED_CALENDAR_EVENTS,
				ValidationRule.VALIDATION_FT_COMPLYING_FILING_RULES,
				ValidationRule.VALIDATION_FT_MAKEUP_COMPLYING_HOO,
				ValidationRule.VALIDATION_FT_MIN_GAP_BETWEEN_CONSECUTIVE_SHIFTS,
				ValidationRule.VALIDATION_FT_MAX_SHIFT_DURATION
            };
        }
        else
        {
            //It must be a time off validation rule
<span class="fc" id="L274">            return new String[] {ValidationRule.VALIDATION_AVAILABLE_TO_HRS,</span>
            ValidationRule.VALIDATION_ENOUGH_TO_HRS,
            ValidationRule.VALIDATION_COMPLY_FILINGRULE,
            ValidationRule.VALIDATION_AVOID_BLACKOUT,
            ValidationRule.VALIDATION_AVOID_CAL_EVENTS,
            ValidationRule.VALIDATION_TO_NOT_SWAPPED,
            ValidationRule.VALIDATION_REQ_MIN_DURATION,
            ValidationRule.VALIDATION_REQ_MAX_DURATION,
            ValidationRule.VALIDATION_REQUEST_IN_PAST,
            ValidationRule.VALIDATION_VTO_REDUCE_NET_STAFFING_SURPLUS,
            ValidationRule.VALIDATION_VTO_COMPLY_MAX_VTO_HRS,
            ValidationRule.VALIDATION_TOB_COMPLY_MAX_EMPLOYEE_APPROVAL,
            ValidationRule.VALIDATION_TOB_SUBMITTED_DATE,
            ValidationRule.VALIDATION_TOB_DONOT_APPROVE_OVERLAP_REQUEST
            };
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>