<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>WorkloadModelHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.bbm.workload</a> &gt; <span class="el_source">WorkloadModelHandler.java</span></div><h1>WorkloadModelHandler.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.bbm.workload;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.base.BPException;
import com.bluepumpkin.common.datatypes.BasicVO;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.ejb.bbm.base.BbmCreateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.datasourcegroup.model.GroupType;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueuePaginationData;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.web.bbm.l10n.BbmWebBundleKey;
import com.bluepumpkin.web.core.base.ModelHandler;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.verint.web.wfm.WfmModelHandler;
import com.witness.ejb.core.licensing.LicenseKeys;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.HtmlUtil;
import com.witness.web.uif.util.SortUtil;

/**
 * Title: WorkloadModelHandler Description: Handle interaction with Workload EJB
 * Copyright: Copyright (c) 2002 Company: Blue Pumpkin Software, Inc
 * 
 * @author Shimon Kakon
 * @version 1.0
 */
<span class="nc" id="L47">public class WorkloadModelHandler extends ModelHandler {</span>

    public static WorkloadManager getWorkloadManager(RequestContext context) throws BbmException {
<span class="fc" id="L50">        return WfmManagerFactory.getWorkloadManager(context.isInWhatIfMode());</span>
    }

    /**
     * Return All Media
     */
    public static Collection&lt;Media&gt; getAllMedia(RequestContext context) throws RemoteException, BbmException {
<span class="fc" id="L57">        return getWorkloadManager(context).getAllMedia();</span>
    }

    public static Collection getAllMediaSorted(RequestContext context, Localizer localizer) throws RemoteException, BbmException {
        // TODO: move method from WfmModelHandler into this WorkloadModelHandler
        // class
<span class="fc" id="L63">        return WfmModelHandler.getAllMediaSorted(context, localizer);</span>
    }

    public static Collection getSupportedGroupTypeSorted(RequestContext context, Localizer localizer) throws RemoteException, BbmException {
        // TODO: move method from WfmModelHandler into this WorkloadModelHandler
        // class
<span class="nc" id="L69">        return WfmModelHandler.getSupportedGroupTypeSorted(context, localizer);</span>
    }

    /**
     * Return Media by ID
     */
    public static Media getMedia(RequestContext context, ID mediaID) throws RemoteException, BbmException {
<span class="nc" id="L76">        return getWorkloadManager(context).getMediaByID(mediaID);</span>
    }

    /**
     * Create a Media Type Map return Map of Media Id, Media VO (key, value)
     */
    public static Map&lt;ID, Media&gt; getMediaMap(RequestContext context) throws RemoteException, BbmException {

<span class="fc" id="L84">        final Collection&lt;Media&gt; allMedia = getAllMedia(context);</span>
<span class="pc bpc" id="L85" title="2 of 4 branches missed.">        if ((allMedia == null) || allMedia.isEmpty()) {</span>
<span class="nc" id="L86">            return Collections.emptyMap();</span>
        }

<span class="fc" id="L89">        final HashMap&lt;ID, Media&gt; mediaMap = new HashMap&lt;ID, Media&gt;(allMedia.size());</span>
<span class="fc" id="L90">        Media media = null;</span>
<span class="fc bfc" id="L91" title="All 2 branches covered.">        for (final Iterator&lt;Media&gt; it = allMedia.iterator(); it.hasNext();) {</span>
<span class="fc" id="L92">            media = it.next();</span>
<span class="fc" id="L93">            mediaMap.put(media.getId(), media);</span>
        }
<span class="fc" id="L95">        return mediaMap;</span>
    }

    /**
     * Create a Queue Type Map return Map of Queue Id, Queue VO (key, value)
     *
     * public static Map&lt;ID, Queue&gt; getQueuesMap(RequestContext context) throws
     * RemoteException, BbmException {
     * 
     * Collection&lt;Queue&gt; allQueue = getAllQueues(context); if(allQueue == null
     * || allQueue.isEmpty()){ return Collections.EMPTY_MAP; }
     * 
     * HashMap&lt;ID, Queue&gt; queueMap = new HashMap&lt;ID, Queue&gt;(allQueue.size());
     * Queue queue = null; for (Iterator&lt;Queue&gt; it = allQueue.iterator();
     * it.hasNext();) { queue = it.next(); queueMap.put(queue.getID(), queue); }
     * return queueMap; }
     */

    /**
     * cretaes a delimited string of media names
     *
     * @param mediaCollection
     *            Collection of Media VO
     * @return a delimited string of media names
     */
    public static String getMediaDisplay(Collection mediaCollection) {
<span class="pc bpc" id="L121" title="1 of 4 branches missed.">        if ((mediaCollection == null) || mediaCollection.isEmpty()) {</span>
<span class="fc" id="L122">            return HtmlUtil.NBSP;</span>
        }
<span class="fc" id="L124">        Media media = null;</span>
<span class="fc" id="L125">        final StringBuffer sb = new StringBuffer(16);</span>
<span class="fc bfc" id="L126" title="All 2 branches covered.">        for (final Iterator it = mediaCollection.iterator(); it.hasNext();) {</span>
<span class="fc" id="L127">            media = (Media) it.next();</span>
<span class="fc" id="L128">            sb.append(media.getName());</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (it.hasNext()) {</span>
<span class="fc" id="L130">                sb.append(&quot;, &quot;);</span>
            }
        }
<span class="fc" id="L133">        return sb.toString();</span>
    }

    /**
     * cretaes a delimited string of media names
     *
     * @param mediaIds
     *            Collection of Media Ids
     * @return a delimited string of media names
     */
    public static String getMediaDisplayFromIds(RequestContext context, Collection mediaIds) throws RemoteException, BbmException {
<span class="pc bpc" id="L144" title="1 of 4 branches missed.">        if ((mediaIds == null) || mediaIds.isEmpty()) {</span>
<span class="fc" id="L145">            return HtmlUtil.NBSP;</span>
        }
<span class="nc" id="L147">        final Map allMediaMap = getMediaMap(context);</span>
<span class="nc" id="L148">        ID id = null;</span>
<span class="nc" id="L149">        Media media = null;</span>
<span class="nc" id="L150">        final StringBuffer sb = new StringBuffer(16);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">        for (final Iterator it = mediaIds.iterator(); it.hasNext();) {</span>
<span class="nc" id="L152">            id = (ID) it.next();</span>
<span class="nc" id="L153">            media = (Media) allMediaMap.get(id);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">            if (media != null) {</span>
<span class="nc" id="L155">                sb.append(media.getName());</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L157">                    sb.append(&quot;, &quot;);</span>
                }
            }
        }
<span class="nc" id="L161">        return sb.toString();</span>
    }

    /**
     * cretaes a delimited string of queue names
     *
     * @param queuesCollection
     *            Collection of Queue VO
     * @param limit
     *            - an integer representing the number of queues to return. If
     *            this is 0, all queues will be returned. If greater than 0 and
     *            less than the size of queuesCollection, will return the size
     *            of limit with an ellipsis &quot;...&quot; at the end of the returned
     *            string.
     * @return a delimited string of queue names
     */
    public static String getQueuesDisplay(Collection&lt;Queue&gt; queuesCollection, int limit) {
<span class="pc bpc" id="L178" title="1 of 4 branches missed.">        if ((queuesCollection == null) || queuesCollection.isEmpty()) {</span>
<span class="fc" id="L179">            return HtmlUtil.NBSP;</span>
        }

<span class="fc" id="L182">        Queue queue = null;</span>
<span class="fc" id="L183">        final StringBuffer sb = new StringBuffer(16);</span>
<span class="fc" id="L184">        int count = 0;</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        for (final Iterator&lt;Queue&gt; it = queuesCollection.iterator(); it.hasNext();) {</span>
<span class="fc" id="L186">            queue = it.next();</span>
<span class="fc" id="L187">            sb.append(queue.getName());</span>
<span class="fc" id="L188">            count++;</span>
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">            if (it.hasNext()) {</span>
<span class="nc bnc" id="L190" title="All 4 branches missed.">                if ((limit &gt; 0) &amp;&amp; (count &gt;= limit)) {</span>
<span class="nc" id="L191">                    sb.append(&quot;...&quot;);</span>
<span class="nc" id="L192">                    break;</span>
                } else {
<span class="nc" id="L194">                    sb.append(&quot;, &quot;);</span>
                }
            }
        }
<span class="fc" id="L198">        return sb.toString();</span>
    }

    /**
     * cretaes a delimited string of queue names
     *
     * @param queueIds
     *            Collection of Queue Ids
     * @return a delimited string of queue names
     */
    public static String getQueueDisplayFromIds(RequestContext context, Collection queueIds) throws RemoteException, BbmException {
<span class="pc bpc" id="L209" title="1 of 4 branches missed.">        if ((queueIds == null) || queueIds.isEmpty()) {</span>
<span class="fc" id="L210">            return HtmlUtil.NBSP;</span>
        }
<span class="nc" id="L212">        final Map allQueueMap = getQueuesMapByIDs(context, queueIds);</span>
<span class="nc" id="L213">        ID id = null;</span>
<span class="nc" id="L214">        Queue queue = null;</span>
<span class="nc" id="L215">        final StringBuffer sb = new StringBuffer(16);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        for (final Iterator it = queueIds.iterator(); it.hasNext();) {</span>
<span class="nc" id="L217">            id = (ID) it.next();</span>
<span class="nc" id="L218">            queue = (Queue) allQueueMap.get(id);</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">            if (queue != null) {</span>
<span class="nc" id="L220">                sb.append(queue.getName());</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">                if (it.hasNext()) {</span>
<span class="nc" id="L222">                    sb.append(&quot;, &quot;);</span>
                }
            }
        }
<span class="nc" id="L226">        return sb.toString();</span>
    }

    /**
     * @return a collection of (idMedia, strMediaName)
     */
    public static List getMediaAsStringsPairList(RequestContext context, Localizer localizer) throws Exception {
<span class="nc" id="L233">        return WfmModelHandler.getMediaAsStringsPairList(context, localizer);</span>
    }

    public static Collection getSubQueues(RequestContext context, ID queueID) throws RemoteException, BbmException {
<span class="fc" id="L237">        final Collection list = new ArrayList(1);</span>
<span class="fc" id="L238">        list.add(queueID);</span>
<span class="fc" id="L239">        return getWorkloadManager(context).getSubQueues(list);</span>
    }

    /**
     * Gets the sub queues of the specified queues
     *
     * @return Collectin ofQueue value objects
     */
    public static Collection getSubQueues(RequestContext context, Collection queueIDs) throws BbmException, RemoteException {
<span class="nc" id="L248">        return getWorkloadManager(context).getSubQueues(queueIDs);</span>
    }

    /**
     * Return Collection of Queue Type StringsPair sorted by display name
     * (String type , String typeName)
     */
    public static Collection&lt;StringsPair&gt; getQueueTypeStringsPairList(Localizer localizer) throws RemoteException, BPException {

<span class="fc" id="L257">        Collection&lt;QueueType&gt; allTypes = new ArrayList&lt;QueueType&gt;();</span>
<span class="fc" id="L258">        allTypes.add(new QueueType(QueueType.NORMAL, localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.QUEUE_TYPE_NORMAL)));</span>
<span class="pc bpc" id="L259" title="1 of 2 branches missed.">        if (WorkloadModelHandler.isMultiSiteLicense()) {</span>
<span class="fc" id="L260">            allTypes.add(new QueueType(QueueType.DISTRIBUTED, localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.QUEUE_TYPE_DISTRIBUTED)));</span>
        }
<span class="fc" id="L262">        allTypes.add(new QueueType(QueueType.VIRTUAL, localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.QUEUE_TYPE_VIRTUAL)));</span>
<span class="fc" id="L263">        allTypes.add(new QueueType(QueueType.PROCESS, localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.QUEUE_TYPE_PROCESS)));</span>

<span class="fc" id="L265">        allTypes = SortUtil.sortBasicVO(allTypes, localizer);</span>

<span class="fc" id="L267">        final Collection&lt;StringsPair&gt; typeStringsPair = new ArrayList&lt;StringsPair&gt;(allTypes.size());</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">        for (final Iterator&lt;QueueType&gt; it = allTypes.iterator(); it.hasNext();) {</span>
<span class="fc" id="L269">            final QueueType type = it.next();</span>
<span class="fc" id="L270">            typeStringsPair.add(new StringsPair(type.getTypeID(), type.getName()));</span>
<span class="fc" id="L271">        }</span>
<span class="fc" id="L272">        return typeStringsPair;</span>
    }

    public static boolean isQueueParent(RequestContext context, ID queueID) throws RemoteException, BbmException {
<span class="fc bfc" id="L276" title="All 2 branches covered.">        return (getSubQueues(context, queueID).isEmpty() ? false : true);</span>
    }

    /**
     * Return Collection of Media StringsPair sorted by display name (String
     * mediaId, String mediaName). Note that the String media ID that is
     * returned is trimmed!
     */
    public static Collection&lt;StringsPair&gt; getMediaWithStrIDStringsPairList(RequestContext context, Localizer localizer) throws RemoteException, BbmException {

        // TODO: move method from WfmModelHandler into this WorkloadModelHandler
        // class
<span class="fc" id="L288">        return WfmModelHandler.getMediaWithStrIDStringsPairList(context, localizer);</span>
    }

    /**
     * Return Collection of Media StringsPair sorted by display name (String
     * mediaId, String mediaName)
     */
    public static Collection getMediaWithIDStringsPairList(RequestContext context, Localizer localizer) throws RemoteException, BbmException {

<span class="fc" id="L297">        final Collection allMedia = getAllMediaSorted(context, localizer);</span>
<span class="pc bpc" id="L298" title="2 of 4 branches missed.">        if ((allMedia == null) || allMedia.isEmpty()) {</span>
<span class="nc" id="L299">            return Collections.EMPTY_LIST;</span>
        }

<span class="fc" id="L302">        final Collection mediaStringsPair = new ArrayList(allMedia.size());</span>
<span class="fc" id="L303">        Media media = null;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">        for (final Iterator it = allMedia.iterator(); it.hasNext();) {</span>
<span class="fc" id="L305">            media = (Media) it.next();</span>
<span class="fc" id="L306">            mediaStringsPair.add(new StringsPair(media.getID().toString(), media.getName()));</span>
        }
<span class="fc" id="L308">        return mediaStringsPair;</span>
    }

    /**
     * Return Collection of Group Type StringsPair sorted by display name
     * (String GroupTypeId, String typeName)
     */
    public static Collection getGroupTypeWithStrIDStringsPairList(RequestContext context, Localizer localizer) throws RemoteException, BbmException {

<span class="nc" id="L317">        final Collection groups = getSupportedGroupTypeSorted(context, localizer);</span>
<span class="nc bnc" id="L318" title="All 4 branches missed.">        if ((groups == null) || groups.isEmpty()) {</span>
<span class="nc" id="L319">            return Collections.EMPTY_LIST;</span>
        }

<span class="nc" id="L322">        final Collection groupStringsPair = new ArrayList(groups.size());</span>
<span class="nc" id="L323">        GroupType groupType = null;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">        for (final Iterator it = groups.iterator(); it.hasNext();) {</span>
<span class="nc" id="L325">            groupType = (GroupType) it.next();</span>
<span class="nc" id="L326">            groupStringsPair.add(new StringsPair(String.valueOf(groupType.getID()), groupType.getName()));</span>
        }
<span class="nc" id="L328">        return groupStringsPair;</span>
    }

    /**
     * Create a new Queue
     */
    public static ID createQueue(RequestContext context, Queue queue) throws RemoteException, BbmCreateDuplicateKeyException, BbmException {

<span class="fc" id="L336">        return getWorkloadManager(context).createQueue(queue);</span>
    }

    /**
     * Update attributes of an existing Queue
     */
    public static void updateQueue(RequestContext context, Queue queue) throws RemoteException, MultiUserException, BbmUpdateDuplicateKeyException, BbmException {
<span class="nc" id="L343">        getWorkloadManager(context).updateQueue(queue);</span>
<span class="nc" id="L344">    }</span>

    /**
     * Delete Queue
     */
    public static void deleteQueues(RequestContext context, Collection queueIDS) throws Exception {
<span class="nc" id="L350">        getWorkloadManager(context).deleteQueues(queueIDS);</span>
<span class="nc" id="L351">    }</span>

    /**
     * Copy Queue
     */
    public static ID copyQueue(RequestContext context, ID queueID) throws Exception {
<span class="nc" id="L357">        final String copyOf = context.getLocalizer().i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.COPY_OF);</span>
<span class="nc" id="L358">        return getWorkloadManager(context).copyQueue(queueID, copyOf);</span>
    }

    /**
     * Gets all the queues in the system
     * 
     * @return Collection of Queue value objects
     */
    public static Collection&lt;Queue&gt; getAllQueues(RequestContext context) throws BbmException, RemoteException {
<span class="nc" id="L367">        return getWorkloadManager(context).getAllQueues();</span>
    }

    /**
     * Gets all the queues in the system
     * 
     * @return Collectin of Queue value objects
     */
    public static Collection getQueuesByOrgID(RequestContext context, ID orgID) throws BbmException, RemoteException {
<span class="nc" id="L376">        return getWorkloadManager(context).getQueuesByOrgID(orgID);</span>
    }

    /**
     * Gets all the queues in the system (current org plus parent orgs)
     * 
     * @return Collectin of Queue value objects
     */
    public static Collection getQueuesByRecursedOrgID(RequestContext context, ID orgID) throws BbmException, RemoteException {
<span class="nc" id="L385">        return getWorkloadManager(context).getQueuesByRecursedOrgID(orgID);</span>
    }

    public static QueuePaginationData getPaginatedQueuesByRecursedOrgID(RequestContext context, ID orgID, String sortColumn, String sortOrder, int from, int limit, boolean down, Collection&lt;ID&gt; queueTypes) throws BbmFinderException, RemoteException, BbmException {
<span class="fc" id="L389">        return getWorkloadManager(context).getPaginatedQueuesByRecursedOrgID(orgID, sortColumn, sortOrder, from, limit, down, queueTypes);</span>
    }

    public static QueuePaginationData getPaginatedParentQueuesByRecursedOrgID(RequestContext context, ID orgID, String sortColumn, String sortOrder, int from, int limit, boolean down, Collection&lt;ID&gt; queueTypes) throws BbmFinderException, RemoteException, BbmException {
<span class="fc" id="L393">        return getWorkloadManager(context).getPaginatedParentQueuesByRecursedOrgID(orgID, sortColumn, sortOrder, from, limit, down, queueTypes);</span>
    }

    /**
     * get a collection of queue objects given its sid and a Media DEID
     * 
     * @param orgID
     *            - the ID of the org for which you want to get all the queues
     *            available to it (including those defined at parent orgs)
     * @param mediaIDs
     *            - a collection of DEID's (String ID's) of the Medias that you
     *            want to filter the queues by (EX: &quot;ID_PHONE       &quot;). Pass
     *            null for all.
     * @return all of the queues defined at orgID (or one of its parent orgs)
     *         which are of the specified media type.
     */
    public static Collection getQueuesByRecursedOrgID(RequestContext context, ID orgID, Collection mediaIDs) throws BbmException, RemoteException {
<span class="nc" id="L410">        return getWorkloadManager(context).getQueuesByRecursedOrgID(orgID, mediaIDs);</span>
    }

    /**
     * get a map of queue objects given its sid and a Media DEID
     * 
     * @param orgID
     *            - the ID of the org for which you want to get all the queues
     *            available to it (including those defined at parent orgs)
     * @param mediaIDs
     *            - a collection of DEID's (String ID's) of the Medias that you
     *            want to filter the queues by (EX: &quot;ID_PHONE       &quot;). Pass
     *            null for all.
     * @return all of the queues defined at orgID (or one of its parent orgs)
     *         which are of the specified media type.
     */
    public static Map&lt;ID, Queue&gt; getQueuesMapByRecursedOrgID(RequestContext context, ID orgID, Collection&lt;ID&gt; mediaIDs) throws BbmException, RemoteException {
<span class="fc" id="L427">        final Collection&lt;Queue&gt; queues = getWorkloadManager(context).getQueuesByRecursedOrgID(orgID, mediaIDs);</span>
<span class="fc" id="L428">        return convertQueuesCollectionToMap(queues);</span>
    }

    /**
     * Gets all the sub queues in the system
     * 
     * @return Collectin ofQueue value objects
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    public static Collection getAllNormalQueues(RequestContext context, String searchString, ID orgId, ID mediaId, ID queueId, int totalrows) throws BbmException, RemoteException {

<span class="fc" id="L439">        return getWorkloadManager(context).getQueuesByOrgIdTypeAndSearchString(searchString, orgId, mediaId, Queue.QUEUE_TYPE_NORMAL, queueId, totalrows);</span>
    }

    /**
     * Gets all the sub queues in the system
     * 
     * @return Collectin ofQueue value objects
     */
    public static Collection getAllNormalQueues(RequestContext context) throws BbmException, RemoteException {
<span class="nc" id="L448">        final Collection norQues = getWorkloadManager(context).getQueuesByType(Queue.QUEUE_TYPE_BIT_NORMAL);</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">        for (final Iterator iter = norQues.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L450">            final Queue queue = (Queue) iter.next();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">            if (queue.getParentID() != null) {</span>
<span class="nc" id="L452">                iter.remove();</span>
            }
<span class="nc" id="L454">        }</span>
<span class="nc" id="L455">        return norQues;</span>
    }

    /**
     * Returns queue by ID
     */
    public static Queue getQueueByID(RequestContext context, ID queueId) throws RemoteException, BbmFinderException, BbmException {
<span class="fc" id="L462">        return getWorkloadManager(context).getQueueByID(queueId);</span>
    }

    /**
     * Gets queue value objects by IDs
     * 
     * @param ids
     *            queue ids
     * @throws BbmException
     * @throws RemoteException
     * @return Collection of Queue value objects
     */
    public static Collection&lt;Queue&gt; getQueuesByIDs(RequestContext context, Collection&lt;ID&gt; ids) throws BbmException, RemoteException {
<span class="fc" id="L475">        return getWorkloadManager(context).getQueuesByIDs(ids);</span>
    }

    /**
     * Gets queue map (id, value objects) by IDs
     * 
     * @param ids
     *            queue ids
     * @throws BbmException
     * @throws RemoteException
     * @return queue map (id, value objects) by IDs
     */
    public static Map getQueuesMapByIDs(RequestContext context, Collection&lt;ID&gt; ids) throws BbmException, RemoteException {
<span class="fc" id="L488">        final Collection&lt;Queue&gt; queues = getWorkloadManager(context).getQueuesByIDs(ids);</span>
<span class="fc" id="L489">        return convertQueuesCollectionToMap(queues);</span>
    }

    /**
     * Given a collection of queue objects, return a map of the queueIDs to the
     * queue objects.
     */
    public static Map&lt;ID, Queue&gt; convertQueuesCollectionToMap(Collection&lt;Queue&gt; queues) {
<span class="pc bpc" id="L497" title="2 of 4 branches missed.">        if ((queues != null) &amp;&amp; !queues.isEmpty()) {</span>
<span class="fc" id="L498">            final HashMap&lt;ID, Queue&gt; queuesMap = new HashMap&lt;ID, Queue&gt;(queues.size());</span>
<span class="fc" id="L499">            Queue queue = null;</span>
<span class="fc bfc" id="L500" title="All 2 branches covered.">            for (final Iterator&lt;Queue&gt; it = queues.iterator(); it.hasNext();) {</span>
<span class="fc" id="L501">                queue = it.next();</span>
<span class="fc" id="L502">                queuesMap.put(queue.getID(), queue);</span>
            }
<span class="fc" id="L504">            return queuesMap;</span>
        } else {
<span class="nc" id="L506">            return new HashMap&lt;ID, Queue&gt;();</span>
        }
    }

    /**
     * 
     * @param context
     * @return Collection of IDs of all queues that are normal
     */
    public static Collection getAllNormalQueuesIDs(RequestContext context) throws BbmException, RemoteException {
<span class="nc" id="L516">        final Collection queues = getWorkloadManager(context).getQueuesByType(Queue.QUEUE_TYPE_BIT_NORMAL);</span>
<span class="nc" id="L517">        final ArrayList queueIDs = new ArrayList();</span>
<span class="nc bnc" id="L518" title="All 4 branches missed.">        if ((queues != null) &amp;&amp; !queues.isEmpty()) {</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">            for (final Iterator it = queues.iterator(); it.hasNext();) {</span>
<span class="nc" id="L520">                final Queue queue = (Queue) it.next();</span>
<span class="nc" id="L521">                queueIDs.add(queue.getID());</span>
<span class="nc" id="L522">            }</span>
        }
<span class="nc" id="L524">        return queueIDs;</span>

    }

    /**
     * 
     * @throws BbmException
     * @throws RemoteException
     */
    public static void unLinkQueuesFromQueue(RequestContext context, Collection qIds) throws BbmException, RemoteException {
<span class="fc" id="L534">        getWorkloadManager(context).unLinkQueuesParents(qIds);</span>
<span class="fc" id="L535">    }</span>

    public static void linkQueueToQueues(RequestContext context, ID queueID, Collection qIDs) throws BbmException, RemoteException {
<span class="fc" id="L538">        getWorkloadManager(context).linkQueues(queueID, qIDs);</span>
<span class="fc" id="L539">    }</span>

    public static void unLinkQueuesFromQueue(RequestContext context, ID queueID, Collection qIds) throws BbmException, RemoteException {
<span class="nc" id="L542">        getWorkloadManager(context).linkQueues(queueID, qIds);</span>
<span class="nc" id="L543">    }</span>

    public static boolean isMultiSiteLicense() throws RemoteException, BPException {
<span class="fc" id="L546">        return CoreManagerFactory.getLicenseManager().isLicensed(LicenseKeys.APP_MULTISIDE);</span>
    }

    public static boolean isQueueLinkedToCampaign(ID queueID) throws RemoteException, BbmException {
<span class="fc" id="L550">        final Collection col = WfmManagerFactory.getCampaignManager().getQueueCampaignAssignments(queueID, new Date(1000), new GregorianCalendar(2079, 1, 1).getTime());</span>
<span class="pc bpc" id="L551" title="2 of 4 branches missed.">        return (((col != null) &amp;&amp; !col.isEmpty()) ? true : false);</span>
    }

    /**
     * Returns a map of queueID (key), collection of skills VO (value)
     */
    public static Map getLinkedSkillIDsForQueues(RequestContext context, Collection queuesIds) throws BbmException, RemoteException {
        // First get the map queueID, collection of skills IDs
<span class="nc" id="L559">        final Map queueIdToSkillsIds = new HashMap();// getWorkloadManager(context).getLinkedSkillIDsForQueues(queuesIds);</span>
        // Now get all the skills Ids and use them to fetch the skill VO
<span class="nc" id="L561">        final ArrayList skillsIds = new ArrayList(queuesIds.size() * 2);</span>
<span class="nc" id="L562">        Collection skillsIdsPerQueue = null;</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">        for (final Iterator it = queuesIds.iterator(); it.hasNext();) {</span>
<span class="nc" id="L564">            skillsIdsPerQueue = (Collection) queueIdToSkillsIds.get(it.next());</span>
<span class="nc bnc" id="L565" title="All 4 branches missed.">            if ((skillsIdsPerQueue != null) &amp;&amp; !skillsIdsPerQueue.isEmpty()) {</span>
<span class="nc" id="L566">                skillsIds.addAll(skillsIdsPerQueue);</span>
            }
        }
<span class="nc bnc" id="L569" title="All 4 branches missed.">        if ((skillsIds == null) || skillsIds.isEmpty()) {</span>
<span class="nc" id="L570">            return queueIdToSkillsIds; // it is an empty map anyway</span>
        }
<span class="nc" id="L572">        final Collection skillsVO = WfmManagerFactory.getSkillManager(context.isInWhatIfMode()).getSkillsByIDs(skillsIds);</span>
        // convert the skill collection into skill map (id, value object)
<span class="nc" id="L574">        final HashMap skillsVOMap = new HashMap(skillsIds.size());</span>
<span class="nc" id="L575">        Skill skill = null;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">        for (final Iterator it = skillsVO.iterator(); it.hasNext();) {</span>
<span class="nc" id="L577">            skill = (Skill) it.next();</span>
<span class="nc" id="L578">            skillsVOMap.put(skill.getID(), skill);</span>
        }
        // Now create the returned map
<span class="nc" id="L581">        final HashMap linkedSkillsVOsMap = new HashMap(queuesIds.size()); // the</span>
                                                                          // returned
                                                                          // Map
<span class="nc" id="L584">        Collection linkedSkillsIds = null;</span>
<span class="nc" id="L585">        ArrayList linkedSkillsVO = null;</span>
<span class="nc" id="L586">        ID queueID = null;</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">        for (final Iterator it = queuesIds.iterator(); it.hasNext();) {</span>
<span class="nc" id="L588">            queueID = (ID) it.next();</span>
<span class="nc" id="L589">            linkedSkillsIds = (Collection) queueIdToSkillsIds.get(queueID);</span>
<span class="nc bnc" id="L590" title="All 4 branches missed.">            if ((linkedSkillsIds != null) &amp;&amp; !linkedSkillsIds.isEmpty()) {</span>
<span class="nc" id="L591">                linkedSkillsVO = new ArrayList(linkedSkillsIds.size());</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">                for (final Iterator it2 = linkedSkillsIds.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L593">                    linkedSkillsVO.add(skillsVOMap.get(it2.next()));</span>
                }
<span class="nc" id="L595">                linkedSkillsVOsMap.put(queueID, linkedSkillsVO);</span>
            } else {
<span class="nc" id="L597">                linkedSkillsVOsMap.put(queueID, Collections.EMPTY_LIST);</span>
            }
        }
<span class="nc" id="L600">        return linkedSkillsVOsMap;</span>
    }

<span class="nc" id="L603">    public static class QueueType implements BasicVO {</span>
        public final static int NORMAL = 0;
        public final static int DISTRIBUTED = 1;
        public final static int VIRTUAL = 2;
        public final static int PROCESS = 3;

<span class="fc" id="L609">        public QueueType(int index, String name) {</span>
<span class="fc" id="L610">            m_index = index;</span>
<span class="fc" id="L611">            m_name = name;</span>
<span class="fc" id="L612">        }</span>

        /*
         * (non-Javadoc)
         * 
         * @see com.bluepumpkin.common.datatypes.BasicVO#getID()
         */
        @Override
        public ID getID() {
<span class="nc" id="L621">            return null;</span>
        }

        /*
         * (non-Javadoc)
         * 
         * @see com.bluepumpkin.common.datatypes.BasicVO#getParentID()
         */
        @Override
        public ID getParentID() {
<span class="nc" id="L631">            return null;</span>
        }

        /*
         * (non-Javadoc)
         * 
         * @see com.bluepumpkin.common.datatypes.BasicVO#getName()
         */
        @Override
        public String getName() {
<span class="fc" id="L641">            return m_name;</span>
        }

        public String getTypeID() {
<span class="fc" id="L645">            return String.valueOf(m_index);</span>
        }

        @Override
        public String getIcon() {
<span class="nc" id="L650">            return null;</span>
        }

        String m_name;
        int m_index;
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>