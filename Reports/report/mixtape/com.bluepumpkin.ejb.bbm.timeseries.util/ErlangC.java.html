<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ErlangC.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">ErlangC.java</span></div><h1>ErlangC.java</h1><pre class="source lang-java linenums">/*
 * ï¿½ 2009-2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import java.util.HashMap;
import java.util.Map;

import org.apfloat.Apfloat;
import org.apfloat.ApfloatMath;

/**
 * An instance of this class may be used to perform FTE requirements calculations for
 * an immediate media type queue.
 * 
 * This is a considerably optimized Java port of erlangc.cpp and ab-erlangc.cpp from
 * the C++ Forecasting &amp; Scheduling client.
 */
public class ErlangC
{
	/**
	 * The default maximum number of agents for Erlang C calculations.
	 * &lt;p/&gt;
	 * There is no reason for this choice of values other than it's the same limit the C++
	 * client used for the largest organizations.  It would be smart to see if
	 * any performance problems arise at higher limits, and consider increasing
	 * this number still further.
	 */
	public static final int DEFAULT_MAX_AGENTS = 10000;
	// We cache instances because they generate large tables of objects.  Hopefully an application will
	// never have more than 1 or 2 instances at most.
<span class="fc" id="L32">	private static final Map&lt;Integer, ErlangC&gt; c_instanceMap = new HashMap&lt;Integer, ErlangC&gt;();</span>
	// This is chosen to be as large as possible without risking overflow in the non-multiprecision version of the Erlang formula.
	private static final double SMALL_ERLANG_THRESHOLD_WORKLOAD = 525000/900.0;
	// This means that multiprecision calculations are being done to 16 significant figures.
	// This is more than adequate for staffing requirements for large workloads but it is
	// important to remember that our calculations are not exact.
	private static final int MULTIPRECISION_PRECISION = 16;
	private static final int MIN_SUMMATION_SIGNIFICANT_FIGURES = 8;

	private final Apfloat[] m_factorialReciprocals;
	private final double[] m_factorialLogs;
	private final int m_absoluteMaxAgents;

	/**
	 * Returns an instance of ErlangC with an absolute maximum of 8000 agents.
	 * 
	 * 
	 * @return
	 */
	public static ErlangC getInstance()
	{
<span class="fc" id="L53">		return getInstance(DEFAULT_MAX_AGENTS);</span>
	}

	/**
	 * Returns an instance of ErlangC with the specified absolute maximum number of agents.
	 * 
	 * @return
	 */
	public synchronized static ErlangC getInstance(int absoluteMaximumAgents)
	{
<span class="fc" id="L63">		ErlangC instance = c_instanceMap.get(absoluteMaximumAgents);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">		if (instance == null)</span>
		{
<span class="fc" id="L66">			instance = new ErlangC(absoluteMaximumAgents);</span>
<span class="fc" id="L67">			c_instanceMap.put(absoluteMaximumAgents, instance);</span>
		}
<span class="fc" id="L69">		return instance;</span>
	}

	private ErlangC(int absoluteMaximumAgents)
<span class="fc" id="L73">	{</span>
<span class="fc" id="L74">		m_absoluteMaxAgents = absoluteMaximumAgents;</span>

<span class="fc" id="L76">		m_factorialReciprocals = FactorialUtil.createHighPrecisionFactorialReciprocalTable(m_absoluteMaxAgents+1, MULTIPRECISION_PRECISION);</span>
<span class="fc" id="L77">		m_factorialLogs = FactorialUtil.createLowPrecisionFactorialLogTable(m_absoluteMaxAgents);</span>
<span class="fc" id="L78">	}</span>

	/**
	 * Returns the absolute maximum number of agents that will be returned from an
	 * agent requirements calculation by this ErlangC instance.
	 * 
	 * @return
	 */
	public int getAbsoluteMaximumAgents()
	{
<span class="nc" id="L88">		return m_absoluteMaxAgents;</span>
	}

	/**
	 * Given traffic parameters arrival rate (lambda), average handling time (tau), and 
	 * abandonment percentage, computes the number of agents required to achieve the
	 * desired asa (average seconds to answer).  The value returned will be zero if the
	 * arrival rate is zero; it will fall in the range [0, absoluteMaximumAgents] if the
	 * service goal could be achieved within that range; an exception is thrown if the
	 * service goal could not be met even with absoluteMaximumAgents agents.
	 * &lt;p/&gt;
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * &lt;p/&gt;
	 * Abandonment is taken into account simply by adjusting the arrival rate by the
	 * percentage of people that do not abandon.  This implicitly seems to assume that
	 * every caller is in queue for long enough to abandon.
	 * &lt;p/&gt;
	 * Corresponds to the functions ab_agents_asa and ab_compute_asa in ab-erlangc.cpp.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param asa Average seconds to answer (service target)
	 * @param abandonmentPercentage
	 * @return the smallest value in [0, absoluteMaximumAgents] that satisfies the specified
	 * ASA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	public int getAgentsAsaWithAbandonment(
			double arrivalRate,
			double aht,
			double asa,
			double abandonmentPercentage)
	{
<span class="nc bnc" id="L123" title="All 2 branches missed.">		if (arrivalRate == 0) {</span>
<span class="nc" id="L124">			return 0;    // no work - no agents</span>
		}
<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (asa &lt;= 0) {</span>
<span class="nc" id="L127">			throw new IllegalArgumentException(&quot;Tried to find FTE for non-positive target ASA&quot;);</span>
		}

<span class="nc" id="L130">	    double effectiveArrivalRate = arrivalRate * (1.0 - (abandonmentPercentage/100.0));</span>
<span class="nc" id="L131">		double effectiveWorkload = aht * effectiveArrivalRate;</span>
<span class="nc" id="L132">		return getAgentsAsa(effectiveArrivalRate, aht, asa, (int)effectiveWorkload, getAgentsAsaUpperBound(effectiveWorkload));</span>
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired asa (average seconds
	 * to answer).  The value returned will be zero if the arrival rate is zero; it will
	 * fall in the range [0, absoluteMaximumAgents] if the service goal could be achieved
	 * within that range; an exception is thrown if the service goal could not be met even
	 * with absoluteMaximumAgents agents.
	 * 
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param targetAsa Average seconds to answer (service target)
	 * @return the smallest value in [0, absoluteMaximumAgents] that satisfies the specified
	 * ASA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	public int getAgentsAsa(double arrivalRate, double aht, double asa)
	{
<span class="nc bnc" id="L156" title="All 2 branches missed.">		if (asa &lt;= 0) {</span>
<span class="nc" id="L157">			throw new IllegalArgumentException(&quot;Tried to find FTE for non-positive target ASA&quot;);</span>
		}
<span class="nc" id="L159">		double workload = aht * arrivalRate;</span>
<span class="nc" id="L160">		return getAgentsAsa(arrivalRate, aht, asa, (int)workload, getAgentsAsaUpperBound(workload));</span>
	}

	/**
	 * Returns a rough upper bound for the number of agents required to handle the 
	 * specified workload.  This method does not take service level into account; it
	 * returns a value that will be sufficient if the service level is set to ASA = 1 second.
	 * 
	 * For large workloads the FTE requirement falls quite close to the workload.
	 * It would be good to tune this value further, perhaps expressing it as a function
	 * of workload.
	 * 
	 * @param workload
	 * @return
	 */
	private int getAgentsAsaUpperBound(double workload)
	{
<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (workload &gt; 500)</span>
		{
<span class="nc" id="L179">			return (int)Math.ceil(1.1 * workload);</span>
		}
<span class="nc bnc" id="L181" title="All 2 branches missed.">		else if (workload &gt; 50)</span>
		{
<span class="nc" id="L183">			return (int)Math.ceil(1.4 * workload);</span>
		}
<span class="nc bnc" id="L185" title="All 2 branches missed.">		else if (workload &gt; 20)</span>
		{
<span class="nc" id="L187">			return (int)Math.ceil(2 * workload);</span>
		}
<span class="nc bnc" id="L189" title="All 2 branches missed.">		else if (workload &gt; 5) {</span>
<span class="nc" id="L190">			return (int)Math.ceil(4 * workload);</span>
		} else {
<span class="nc" id="L192">			return 20;</span>
		}
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired asa (average seconds
	 * to answer).  The value returned will be zero if the arrival rate is zero; it will
	 * fall in the range [minAgents, maxAgents] if the service goal could be achieved
	 * within that range; an exception is thrown if the service goal could not be met even
	 * with maxAgents agents.
	 * 
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param targetAsa Average seconds to answer (service target)
	 * @param minAgents Minimum number of agents to consider
	 * @param maxAgents Maximum number of agents to consider
	 * @return the smallest value in [minAgents, maxAgents] that satisfies the specified
	 * ASA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	private int getAgentsAsa(double arrivalRate, double aht, double targetAsa, int minAgents, int maxAgents)
	{
<span class="nc bnc" id="L219" title="All 2 branches missed.">		if (arrivalRate == 0) return 0;    // no arrivals - no agents</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">		if (aht == 0) {</span>
<span class="nc" id="L221">			return minAgents + 1; // no AHT - each agent apparently smiles and says &quot;Next!&quot;</span>
		}

<span class="nc" id="L224">		boolean goalAchieved = false;</span>
<span class="nc" id="L225">		int min = minAgents;</span>
<span class="nc" id="L226">		int max = maxAgents;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		while (max - min &gt; 1)</span>
		{
<span class="nc" id="L229">			int candidateNumberOfAgents = (max + min) / 2;</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">			if (computeAsa(candidateNumberOfAgents, arrivalRate, aht) &gt; targetAsa)</span>
			{
<span class="nc" id="L232">				min = candidateNumberOfAgents;</span>
			}
			else
			{
<span class="nc" id="L236">				max = candidateNumberOfAgents;</span>
<span class="nc" id="L237">				goalAchieved = true;</span>
			}
<span class="nc" id="L239">		}       </span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">		if ( max &lt;= m_absoluteMaxAgents &amp;&amp;</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">			 (goalAchieved || computeAsa(max, arrivalRate, aht) &lt;= targetAsa) )</span>
		{
//System.out.println(&quot;FTE = &quot; + max + &quot;, probWait(&quot; + max + &quot;) = &quot; + probWait(max, lambda, tau) + &quot;, probWait(&quot; + (max-1) + &quot;) = &quot; + probWait(max-1, lambda, tau) + &quot;, probWait(&quot; + (max+1) + &quot;) = &quot; + probWait(max+1, lambda, tau));
<span class="nc" id="L244">			return max;</span>
		}
		else
		{
<span class="nc" id="L248">			throw new IllegalArgumentException(&quot;Maximum employee count &quot; + maxAgents + &quot; exceeded: lambda = &quot; + arrivalRate + &quot;, tau = &quot; + aht + &quot;, target ASA = &quot; + targetAsa + &quot;.&quot;);</span>
		}
	}

	/**
	 * Given traffic parameters arrival rate (lambda), average handling time (tau), and
	 * abandonment percentage, computes the number of agents required to achieve the
	 * desired PCA (percentage of calls answered) within the desired target number of
	 * seconds.  The value returned will be zero if the arrival rate is zero; it will
	 * fall in the range [0, absoluteMaximumAgents] if the service goal could be achieved
	 * within that range; an exception is thrown if the service goal could not be met even
	 * with absoluteMaximumAgents agents.
	 * &lt;p/&gt;
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * &lt;p/&gt;
	 * Abandonment is taken into account simply by adjusting the arrival rate by the
	 * percentage of people that do not abandon.  This implicitly seems to assume that
	 * every caller is in queue for long enough to abandon.
	 * &lt;p/&gt;
	 * Corresponds to the functions ab_agents_pca and ab_compute_pca in ab-erlangc.cpp.
	 * 
	 * @param arrivalRate
	 * @param aht
	 * @param pca
	 * @param seconds
	 * @param abandonmentPercentage
	 * @return
	 */
	public int getAgentsPcaWithAbandonment(
			double arrivalRate,
			double aht,
			double pca,
			double seconds,
			double abandonmentPercentage) {
<span class="nc bnc" id="L283" title="All 4 branches missed.">		if (arrivalRate == 0 || pca == 0.0) {</span>
<span class="nc" id="L284">			return 0;	   // no work - no agents    </span>
		}
<span class="nc bnc" id="L286" title="All 2 branches missed.">		if (pca &lt;= 0) {</span>
<span class="nc" id="L287">			throw new IllegalArgumentException(&quot;Tried to find FTE for non-positive target PCA&quot;);</span>
		}

<span class="nc" id="L290">	    double effectiveArrivalRate = arrivalRate * (1.0 - (abandonmentPercentage/100.0));</span>
<span class="nc" id="L291">		double effectiveWorkload = aht * effectiveArrivalRate;</span>
<span class="nc" id="L292">		return getAgentsPca(effectiveArrivalRate, aht, pca, seconds, (int)effectiveWorkload, getAgentsPcaUpperBound(effectiveWorkload));</span>
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired PCA (percentage of
	 * calls answered) within the desired target number of seconds.  The value returned
	 * will be zero if the arrival rate is zero; it will fall in the range 
	 * [0, absoluteMaximumAgents] if the service goal could be achieved within that 
	 * range; an exception is thrown if the service goal could not be met even
	 * with absoluteMaximumAgents agents.
	 * 
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param targetPca
	 * @param seconds
	 * @return the smallest value in [0, absoluteMaximumAgents] that satisfies the specified
	 * PCA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	public int getAgentsPca(double arrivalRate, double aht, double pca, double seconds)
	{
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">		if (pca &lt;= 0) {</span>
<span class="nc" id="L319">			throw new IllegalArgumentException(&quot;Tried to find FTE for non-positive target PCA&quot;);</span>
		}
<span class="fc" id="L321">		double workload = aht * arrivalRate;</span>
<span class="fc" id="L322">		return getAgentsPca(arrivalRate, aht, pca, seconds, (int)workload, getAgentsPcaUpperBound(workload));</span>
	}

	/**
	 * Returns a rough upper bound for the number of agents required to handle the 
	 * specified workload.  This method does not take service level into account; it
	 * returns a value that will be sufficient if the service level is set to PCA = 99%
	 * within 1 second.
	 * 
	 * For large workloads the FTE requirement falls quite close to the workload.
	 * It would be good to tune this value further, perhaps expressing it as a function
	 * of workload.
	 * 
	 * @param workload
	 * @return
	 */
	private int getAgentsPcaUpperBound(double workload)
	{
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">		if (workload &gt; 800)</span>
		{
<span class="nc" id="L342">			return (int)Math.ceil(1.1 * workload);</span>
		}
<span class="pc bpc" id="L344" title="1 of 2 branches missed.">		else if (workload &gt; 50)</span>
		{
<span class="nc" id="L346">			return (int)Math.ceil(1.5 * workload);</span>
		}
<span class="fc bfc" id="L348" title="All 2 branches covered.">		else if (workload &gt; 20)</span>
		{
<span class="fc" id="L350">			return (int)Math.ceil(2 * workload);</span>
		}
		else
		{
<span class="fc" id="L354">			return (int)Math.max(6, Math.ceil(6 * workload));</span>
		}
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired PCA (percentage of
	 * calls answered) within the desired target number of seconds.  The value returned 
	 * will be zero if the arrival rate is zero; it will fall in the range
	 * [minAgents, maxAgents] if the service goal could be achieved within that range;
	 * an exception is thrown if the service goal could not be met even with maxAgents
	 * agents.
	 * 
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param targetPca
	 * @param seconds
	 * @param minAgents Minimum number of agents to consider
	 * @param maxAgents Maximum number of agents to consider
	 * @return the smallest value in [minAgents, maxAgents] that satisfies the specified
	 * PCA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	private int getAgentsPca(double arrivalRate, double aht, double targetPca, double seconds, int minAgents, int maxAgents) {
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">		if (seconds &lt; 0) {</span>
<span class="nc" id="L383">			throw new IllegalArgumentException(&quot;agentsPca(): seconds = &quot; + seconds + &quot;; must be non-negative.&quot;);</span>
		}
<span class="pc bpc" id="L385" title="1 of 2 branches missed.">		if (targetPca == 0) {</span>
<span class="nc" id="L386">			return 0;                         </span>
		}
<span class="fc bfc" id="L388" title="All 2 branches covered.">		if (arrivalRate == 0) {</span>
			// no arrivals - no agents
<span class="fc" id="L390">			return 0;	       </span>
		}
<span class="fc bfc" id="L392" title="All 2 branches covered.">		if (aht == 0) {</span>
			// no AHT - each agent apparently smiles and says &quot;Next!&quot;
<span class="fc" id="L394">			return minAgents + 1; </span>
		}

<span class="fc" id="L397">		boolean goalAchieved = false;</span>
<span class="fc" id="L398">		int min = minAgents;</span>
<span class="fc" id="L399">		int max = maxAgents;</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">		while (max - min &gt; 1) {</span>
<span class="fc" id="L401">			int candidateNumberOfAgents = (max + min) / 2;</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">			if (computePca(candidateNumberOfAgents, arrivalRate, aht, seconds) &lt; targetPca) {</span>
<span class="fc" id="L403">				min = candidateNumberOfAgents;</span>
			} else {
<span class="fc" id="L405">				max = candidateNumberOfAgents;</span>
<span class="fc" id="L406">				goalAchieved = true;</span>
			}
<span class="fc" id="L408">		}</span>
<span class="pc bpc" id="L409" title="2 of 4 branches missed.">		if ( max &lt;= m_absoluteMaxAgents &amp;&amp;</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">				 (goalAchieved || computePca(max, arrivalRate, aht, seconds) &gt;= targetPca)) {</span>
<span class="fc" id="L411">			return max;</span>
		} else {
<span class="nc" id="L413">			throw new IllegalArgumentException(&quot;Maximum employee count &quot; + maxAgents + &quot; exceeded: lambda = &quot; + arrivalRate + &quot;, tau = &quot; + aht + &quot;, target PCA = &quot; + targetPca + &quot;, target seconds = &quot; + seconds + &quot;.&quot;);</span>
		}
	}	

	/**
	 * Returns the average seconds to answer for the given staffing, arrival rate, and
	 * AHT.
	 * &lt;p/&gt;
	 * Unchanged from the C++ Erlang library in erlangc.cpp.
	 * 
	 * @param nStaffing
	 * @param dCallsPerSecond
	 * @param dAHT
	 * @return
	 */
	public double computeAsa(int nStaffing, double dCallsPerSecond, double dAHT) {
<span class="nc bnc" id="L429" title="All 4 branches missed.">		if (nStaffing &lt;= 0 || nStaffing &gt; m_absoluteMaxAgents) {</span>
<span class="nc" id="L430">			return -1.0;</span>
		}
<span class="nc" id="L432">		double dWorkload = dCallsPerSecond * dAHT;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (dWorkload &lt; SMALL_ERLANG_THRESHOLD_WORKLOAD) {</span>
<span class="nc" id="L434">			return computeAsaSmall(nStaffing, dCallsPerSecond, dAHT);</span>
		}
<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (dWorkload == 0) {</span>
<span class="nc" id="L437">			return 0;</span>
		}

<span class="nc bnc" id="L440" title="All 2 branches missed.">		if (dWorkload &gt;= nStaffing) {</span>
			// Erlang doesn't work when workload &gt;= staffing!
<span class="nc" id="L442">			throw new IllegalArgumentException(&quot;Workload &quot; + dWorkload + &quot; exceeds staffing &quot; + nStaffing);</span>
		}
<span class="nc" id="L444">		double dProbWait = computeWaitProbability(nStaffing, dCallsPerSecond, dAHT);</span>
<span class="nc" id="L445">		double dAgentOccupancy = dWorkload / nStaffing;</span>
<span class="nc" id="L446">		double dASA = (dProbWait * dAHT) / (nStaffing * (1.0 - dAgentOccupancy));</span>
<span class="nc" id="L447">		return dASA;</span>
	}

	/**
	 * Returns the percentage of calls answered within the target time for the given
	 * staffing, arrival rate, and AHT.
	 * &lt;p/&gt;
	 * Unchanged from the C++ Erlang library in erlangc.cpp.
	 * 
	 * @param nStaffing
	 * @param dCallsPerSecond
	 * @param dAHT
	 * @param dGoalTime
	 * @return
	 */
	public double computePca(int nStaffing, double dCallsPerSecond, double dAHT, double dGoalTime) {
<span class="pc bpc" id="L463" title="2 of 4 branches missed.">		if (nStaffing &lt;= 0 || nStaffing &gt; m_absoluteMaxAgents) {</span>
<span class="nc" id="L464">			return -1.0;</span>
		}
<span class="fc" id="L466">		double dWorkload = dCallsPerSecond * dAHT;</span>
<span class="pc bpc" id="L467" title="1 of 2 branches missed.">		if (dWorkload &lt; SMALL_ERLANG_THRESHOLD_WORKLOAD) {</span>
<span class="fc" id="L468">			return computePcaSmall(nStaffing, dCallsPerSecond, dAHT, dGoalTime);</span>
		}

<span class="nc bnc" id="L471" title="All 2 branches missed.">		if (dWorkload == 0) {</span>
<span class="nc" id="L472">			return 100;</span>
		}
<span class="nc bnc" id="L474" title="All 2 branches missed.">		if (dWorkload &gt;= nStaffing) {</span>
<span class="nc" id="L475">			return 0; </span>
		}

<span class="nc" id="L478">		double dProbWait = computeWaitProbability(nStaffing, dCallsPerSecond, dAHT);</span>
<span class="nc" id="L479">		double dPCA = 1.0 - dProbWait * Math.exp(-(nStaffing - dWorkload) * dGoalTime / dAHT);</span>
		// expected output is % from 0 to 100
<span class="nc" id="L481">		return dPCA * 100.0; </span>
	}
	
	/**
	 * Returns the percentage of calls answered within the target time for the given
	 * staffing, arrival rate, and AHT.
	 * &lt;p/&gt;
	 * Unchanged from the C++ Erlang library in derlangc.cpp.
	 *
	 * @param s: dStaffingFTE
	 * @param lambda: dCallsPerSecond = dCallVolume / nSeconds
	 * @param tau: dAHT
	 * @param so: dGoalTime = (double) nPCAGoalSecs
	 * @return
	 */
	public double dcompute_pca (double s, double lambda, double tau, double so) {
<span class="nc bnc" id="L497" title="All 4 branches missed.">		if (s&lt;=0 || s&gt; m_absoluteMaxAgents) {</span>
<span class="nc" id="L498">			return -1.0;</span>
		}

<span class="nc" id="L501">		double a = lambda * tau;</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">		if (a==0) {</span>
<span class="nc" id="L503">			return 100.0;</span>
		}

<span class="nc bnc" id="L506" title="All 2 branches missed.">		if (s&lt;=a) {</span>
<span class="nc" id="L507">			return 0.0;</span>
		}

<span class="nc bnc" id="L510" title="All 2 branches missed.">		if (s &lt; 1) {</span>
			//interpolate between pca (s 0) and pca (s 1)
<span class="nc" id="L512">			return (s-a)/(1-a) * dcompute_pca(1.0,lambda,tau,so);</span>
<span class="nc bnc" id="L513" title="All 4 branches missed.">		} else if (s&gt;1 &amp;&amp; s&lt;2)  {</span>
			// interpolate between pca (s 1) and pca (s 2);
<span class="nc" id="L515">			double pca2 = dcompute_pca(2.0,lambda,tau,so);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">			if (a&lt;1) {</span>
<span class="nc" id="L517">				double pca1 = dcompute_pca(1.0,lambda,tau,so);</span>
<span class="nc" id="L518">				return pca1 + (s-1)*(pca2-pca1);</span>
			} else {
<span class="nc" id="L520">				return (s-a)/(2-a)* pca2;</span>
			}
		}

<span class="nc" id="L524">		double ln_a = Math.log(a);</span>
<span class="nc" id="L525">		double sum = 1;</span>
<span class="nc" id="L526">		double ln_apowerk=0;</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">		for ( int k = 1 ; k &lt;= (s - 1.0) ; k++ ) {</span>
<span class="nc" id="L529">			ln_apowerk = k*ln_a;</span>
<span class="nc" id="L530">			sum += Math.exp(ln_apowerk - dLogStirling(k));</span>
		}

		// irn - now we have to add the extra epsilon in the case that s is non-integer...
<span class="nc bnc" id="L534" title="All 2 branches missed.">		if ((s - (int)s) &gt; 0.0) {</span>
			double dk;
<span class="nc bnc" id="L536" title="All 2 branches missed.">			if (s &lt; 1.0) {</span>
<span class="nc" id="L537">				sum = sum * s;</span>
			} else {
<span class="nc" id="L539">				dk = s - 1.0;</span>
<span class="nc" id="L540">				ln_apowerk = dk*ln_a;</span>
<span class="nc" id="L541">				sum += Math.exp(ln_apowerk - dLogStirling(dk));</span>
			}
		}

<span class="nc" id="L545">		double tmp1 = 1 - a/s;</span>
		double sum2;
<span class="nc" id="L547">		sum2 =  Math.exp( s*ln_a - (Math.log(tmp1) + dLogStirling(s)));</span>
<span class="nc" id="L548">		double p0inv = sum + sum2 ;</span>
<span class="nc" id="L549">		double csa = sum2 / p0inv;</span>
<span class="nc" id="L550">		return 100.0*(1.0- csa * Math.exp (-(s-a)*so/tau));</span>
	}

	/**
	 * Unchanged from the C++ Erlang library in derlangc.cpp.
	 */
	private double dLogStirling(double x) {
<span class="nc" id="L557">		double pi = Math.atan(1.0) * 4;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">		if (x &lt;=1) {</span>
<span class="nc" id="L559">			return(0);</span>
		} else {
<span class="nc" id="L561">			return( x * (Math.log(x)-1.0) + 0.5*Math.log(pi*2*x) + Math.log(1 + (0.084/x)));</span>
		}
	}

	private double computeAsaSmall(int s, double lambda, double tau) {
<span class="nc bnc" id="L566" title="All 4 branches missed.">		if (s &lt;= 0 || s &gt; m_absoluteMaxAgents) {</span>
<span class="nc" id="L567">			return -1.0;</span>
		}

<span class="nc" id="L570">		double a = lambda * tau;</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (a == 0) {</span>
<span class="nc" id="L572">			return 0;			</span>
		}
<span class="nc" id="L574">		double ln_a = Math.log(a); </span>

<span class="nc" id="L576">		double sum = 1;	    </span>
<span class="nc" id="L577">		double ln_apowerk = 0; </span>

		
<span class="nc bnc" id="L580" title="All 2 branches missed.">		for ( int k = 1 ; k &lt; s ; k++ ) {</span>
<span class="nc" id="L581">			ln_apowerk = k * ln_a;</span>
<span class="nc" id="L582">			sum += Math.exp(ln_apowerk - m_factorialLogs[k]);</span>
		}

<span class="nc" id="L585">		double tmp1 = 1 - a / s;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">		if (tmp1 &lt;= 0) {</span>
<span class="nc" id="L587">			return -1.0;</span>
		}
		
<span class="nc" id="L590">		double sum2 =	Math.exp(s * ln_a - m_factorialLogs[s] - Math.log(tmp1)); </span>
<span class="nc" id="L591">		double p0inv = sum + sum2 ;    </span>
<span class="nc" id="L592">		double lq = Math.exp( s*ln_a + Math.log(a/s) - m_factorialLogs[s] - 2*Math.log(tmp1) - Math.log(p0inv) ); </span>
<span class="nc" id="L593">		double result = lq/lambda;</span>
	    
<span class="nc" id="L595">		return result;</span>
	}

	private double computePcaSmall(int s, double lambda, double tau, double so) {
<span class="pc bpc" id="L599" title="2 of 4 branches missed.">		if (s &lt;= 0 || s &gt; m_absoluteMaxAgents) {</span>
<span class="nc" id="L600">			return -1.0;</span>
		}
		
<span class="fc" id="L603">		double a = lambda * tau;</span>
<span class="pc bpc" id="L604" title="1 of 2 branches missed.">		if (a == 0) { </span>
<span class="nc" id="L605">			return 100.00;</span>
		}
<span class="fc" id="L607">		double ln_a = Math.log(a);		</span>
<span class="fc" id="L608">		double sum = 1;	    </span>
<span class="fc" id="L609">		double ln_apowerk = 0; </span>
			              
<span class="fc bfc" id="L611" title="All 2 branches covered.">		for ( int k = 1 ; k &lt; s ; k++ ) {</span>
<span class="fc" id="L612">			ln_apowerk = k * ln_a;</span>
<span class="fc" id="L613">			sum += Math.exp(ln_apowerk - m_factorialLogs[k]);</span>
		}
		
<span class="fc" id="L616">		double tmp1 = 1 - a / s;	                            </span>
<span class="pc bpc" id="L617" title="1 of 2 branches missed.">		if (tmp1 &lt;= 0) {</span>
<span class="nc" id="L618">			return 0.0;</span>
		}
<span class="fc" id="L620">		double sum2 = Math.exp(s * ln_a - m_factorialLogs[s] - Math.log(tmp1));</span>
<span class="fc" id="L621">		double p0inv = sum + sum2 ;    </span>
<span class="fc" id="L622">		double csa = sum2 / p0inv;</span>
<span class="fc" id="L623">		return 100.0 * (1.0 - csa * Math.exp(-(s - a) * so / tau));</span>
	}                           

	/**
	 * Returns a close approximation (6 or so significant figures) of the probability
	 * that a call will not be answered immediately given the staffing level, arrival
	 * rate, and average handling time.
	 * 
	 * Uses the following formula, available for reference
	 * at http://en.wikipedia.org/wiki/Erlang_unit
	 * 
	 *             A^N  N
	 *             --- ---
	 *              N! N-A
	 * Pw = --------------------
	 *      i=0 (A^i)    A^N  N
	 *      SUM( --- ) + --- ---
	 *      N-1 ( i!)     N! N-A
	 * 
	 * where A is workload = arrivalRate * AHT
	 *       N is the staffing level
	 * 
	 * @param nStaffing
	 * @param arrivalRate
	 * @param aht
	 * @return
	 */
	private double computeWaitProbability(int nStaffing, double arrivalRate, double aht)
	{
<span class="nc bnc" id="L652" title="All 4 branches missed.">		if (nStaffing &lt;= 0 || nStaffing &gt; m_absoluteMaxAgents)</span>
		{
<span class="nc" id="L654">			throw new IllegalArgumentException(&quot;probWait(): Invalid staffing level &quot; + nStaffing);</span>
		}
<span class="nc" id="L656">		double dWorkload = arrivalRate * aht;</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">		if (dWorkload == 0) </span>
<span class="nc" id="L658">			return 0;		// no work -&gt; ProbWait = 0</span>
<span class="nc" id="L659">		Apfloat workload = new Apfloat(dWorkload);</span>

<span class="nc" id="L661">		double dAgentOccupancy = dWorkload / nStaffing;</span>

		/*
		 * We improve performance significantly by trimming the terms that we include in
		 * the summation.  The magnitude of the terms increases from k=0 to k=workload+d
		 * where d is small, then decreases as k increases further.
		 * We are only concerned with perhaps 3 or 4 significant figures of Pwait so we
		 * can safely ignore terms that are more than 6 or 7 orders of magnitude smaller
		 * than the largest terms.
		 */
		/*
		 * First we perform a binary search to find more or less the largest element in
		 * the summation.  The search iterations themselves are not free so we settle for
		 * a number that is within a couple of digits of being the largest.  If we miss
		 * the largest term it just means that we compute the probability with slightly
		 * more precision than we intended so no harm done except for performance.
		 */
<span class="nc" id="L678">		int maxTermKMinBound = (int)dWorkload;</span>
<span class="nc" id="L679">		int maxTermKMaxBound = nStaffing;</span>
<span class="nc" id="L680">		Apfloat minBoundTerm = computeSummationTerm(maxTermKMinBound, workload);</span>
<span class="nc" id="L681">		Apfloat maxBoundTerm = computeSummationTerm(maxTermKMaxBound, workload);</span>

<span class="nc bnc" id="L683" title="All 2 branches missed.">		while (maxTermKMaxBound - maxTermKMinBound &gt; 1)</span>
		{
<span class="nc" id="L685">			int candidateK = (maxTermKMinBound + maxTermKMaxBound) / 2;</span>
<span class="nc" id="L686">			Apfloat candidateTerm = computeSummationTerm(candidateK, workload);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">			if (minBoundTerm.scale() &gt; maxBoundTerm.scale())</span>
			{
<span class="nc" id="L689">				maxTermKMaxBound = candidateK;</span>
<span class="nc" id="L690">				maxBoundTerm = candidateTerm;</span>
			}
			else
			{
<span class="nc" id="L694">				maxTermKMinBound = candidateK;</span>
<span class="nc" id="L695">				minBoundTerm = candidateTerm;</span>
			}
<span class="nc bnc" id="L697" title="All 2 branches missed.">			if (Math.abs(minBoundTerm.scale() - maxBoundTerm.scale()) &lt; 2)</span>
			{
<span class="nc" id="L699">				break;</span>
			}
<span class="nc" id="L701">		}</span>

		int maxTermK;
		long maxTermScale;
<span class="nc bnc" id="L705" title="All 2 branches missed.">		if (minBoundTerm.scale() &gt; maxBoundTerm.scale())</span>
		{
<span class="nc" id="L707">			maxTermK = maxTermKMinBound;</span>
<span class="nc" id="L708">			maxTermScale = minBoundTerm.scale();</span>
		}
		else
		{
<span class="nc" id="L712">			maxTermK = maxTermKMaxBound;</span>
<span class="nc" id="L713">			maxTermScale = maxBoundTerm.scale();</span>
		}

		/*
		 * Having found the largest term, we now search the earlier part of the series
		 * for the largest term that is 6 or 7 orders of magnitude smaller than the
		 * largest term in the series.  The terms increase steadily during the first
		 * part of the series so we can ignore all terms that precede that term.
		 */
<span class="nc" id="L722">		int lowerTermCutoffKMinBound = 0;</span>
<span class="nc" id="L723">		int lowerTermCutoffKMaxBound = (int)dWorkload;</span>
<span class="nc" id="L724">		int candidateK = 0;</span>
<span class="nc" id="L725">		Apfloat candidateTerm = Apfloat.ZERO;</span>

<span class="nc bnc" id="L727" title="All 2 branches missed.">		while (lowerTermCutoffKMaxBound - lowerTermCutoffKMinBound &gt; 1)</span>
		{
<span class="nc" id="L729">			candidateK = (lowerTermCutoffKMinBound + lowerTermCutoffKMaxBound) / 2;</span>
<span class="nc" id="L730">			candidateTerm = computeSummationTerm(candidateK, workload);</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">			if (candidateTerm.scale() &gt; maxTermScale - MIN_SUMMATION_SIGNIFICANT_FIGURES)</span>
			{
<span class="nc" id="L733">				lowerTermCutoffKMaxBound = candidateK;</span>
			}
<span class="nc bnc" id="L735" title="All 2 branches missed.">			else if (candidateTerm.scale() &lt; maxTermScale - (MIN_SUMMATION_SIGNIFICANT_FIGURES))</span>
			{
<span class="nc" id="L737">				lowerTermCutoffKMinBound = candidateK;</span>
			}
			else
			{
				break;
			}
		}

		// This loop performs the summation sum( (A^k)/(k!) ) over a range of terms.
		// The sum starts at zero because the skipped terms are so small compared to
		// the largest terms that the closest approximation to their sum to our
		// desired precision is zero.
<span class="nc" id="L749">		Apfloat summation = Apfloat.ZERO;</span>
<span class="nc" id="L750">		Apfloat workloadPowerK = ApfloatMath.pow(workload, candidateK);</span>
<span class="nc" id="L751">		Apfloat workloadPowerKOverKFactorial = candidateTerm;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">		for (int k = candidateK + 1; k &lt; nStaffing; k++)</span>
		{
<span class="nc" id="L754">			workloadPowerK = workloadPowerK.multiply(workload);</span>
<span class="nc" id="L755">			workloadPowerKOverKFactorial = workloadPowerK.multiply(m_factorialReciprocals[k]);</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">			if (k &gt; maxTermK &amp;&amp;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">				workloadPowerKOverKFactorial.scale() &lt; maxTermScale - MIN_SUMMATION_SIGNIFICANT_FIGURES)</span>
			{
				// This is the state expected when we exit this loop;
				// subsequent calculations depend on it.
<span class="nc" id="L761">				workloadPowerK = ApfloatMath.pow(workload, nStaffing - 1);</span>
<span class="nc" id="L762">				break;</span>
			}
<span class="nc" id="L764">			summation = summation.add(workloadPowerKOverKFactorial);</span>
		}

		// We rely on the end state of the foregoing loop.  Thus if it exits early
		// workloadPowerK must still be set correctly.
		//
		// We now get workload^staffing, because workload^staffing = workload * workload^(staffing-1)
<span class="nc" id="L771">		Apfloat workloadPowerStaffing = workloadPowerK.multiply(workload);</span>
<span class="nc" id="L772">		Apfloat workloadPowerStaffingDivStaffingFactorial = workloadPowerStaffing.multiply(m_factorialReciprocals[nStaffing]);</span>

		// Note: Apfloats are immutable.  We get a new one for every operation.
		// There is no point in using the same name for each value.
		// Improve these names as time permits.
<span class="nc" id="L777">		Apfloat mpfTemp = new Apfloat(1.0 - dAgentOccupancy);</span>
<span class="nc" id="L778">		mpfTemp = summation.multiply(mpfTemp);</span>
<span class="nc" id="L779">		mpfTemp = workloadPowerStaffingDivStaffingFactorial.add(mpfTemp);</span>
<span class="nc" id="L780">		mpfTemp = workloadPowerStaffingDivStaffingFactorial.divide(mpfTemp);</span>

<span class="nc" id="L782">		return mpfTemp.doubleValue(); // probability that a call has to wait.</span>
	}

	/**
	 * Returns the value (workload^k)/(k!)
	 * This term is summed over a large range of k as part of the formula for
	 * wait probability.  However this method should only be used to search for
	 * specific terms of particular interest, not to do the entire summation.
	 * This method is a reasonably efficient way to find a single term, but to
	 * find a long consecutive sequence of values one should use the logic in
	 * probWait().
	 * 
	 * @param k
	 * @param workload
	 * @return
	 */
	private Apfloat computeSummationTerm(int k, Apfloat workload)
	{
<span class="nc" id="L800">		return ApfloatMath.pow(workload, k).multiply(m_factorialReciprocals[k]);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>