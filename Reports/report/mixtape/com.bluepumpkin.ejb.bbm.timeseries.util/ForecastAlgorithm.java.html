<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ForecastAlgorithm.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">ForecastAlgorithm.java</span></div><h1>ForecastAlgorithm.java</h1><pre class="source lang-java linenums">/*
 * (c) 2010-2011 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import com.bluepumpkin.common.util.MathUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;

import java.util.*;

/**
 * This static class contains methods to compute different types of forecasts.
 */
public final class ForecastAlgorithm {
<span class="nc" id="L15">	private ForecastAlgorithm() {</span>
		// static class
<span class="nc" id="L17">	}</span>

	/**
	 * Returns an integer array that is the weighted combination of the two input
	 * integer arrays.
	 * &lt;p&gt;
	 * If {@code strategicForecastWeight} is 0, each element of the resulting array
	 * will be equal to the corresponding element of {@code tacticalForecastArray}.
	 * &lt;p&gt;
	 * If {@code strategicForecastWeight} is 100, each element of the resulting array
	 * will be equal to the corresponding element of {@code strategicForecastArray}.
	 * &lt;p&gt;
	 * For any value of {@code strategicForecastWeight} between 0 and 100, each element
	 * of the resulting array will be interpolated between the corresponding elements
	 * of {@code tacticalForecastArray} and {@code strategicForecastArray} proportionally
	 * to the weight's value; the closer the weight is to zero the closer the resulting
	 * value will be to the tactical forecast value, and the closer the weight is to 100
	 * the closer the resulting value will be to the strategic forecast value.
	 * &lt;p&gt;
	 * If {@code strategicForecastWeight} is between 0 and 100, at any point in the forecast
	 * where the strategic and the tactical forecasts are both negative the resulting
	 * value will be {@code Trace.TRACENA}.  Otherwise, at any point where the strategic
	 * forecast is negative the tactical forecast will be used, and vice versa.
	 *
	 * @param strategicForecast
	 * @param tacticalForecast
	 * @param strategicForecastWeight
	 * @return
	 */
	public static int[] getCombinedStrategicTacticalForecast(int[] strategicForecast, int[] tacticalForecast,
			int strategicForecastWeight) {
<span class="nc bnc" id="L48" title="All 2 branches missed.">		if (strategicForecast == null) {</span>
<span class="nc" id="L49">			throw new NullPointerException(&quot;Strategic forecast must not be null.&quot;);</span>
		}
<span class="nc bnc" id="L51" title="All 2 branches missed.">		if (tacticalForecast == null) {</span>
<span class="nc" id="L52">			throw new NullPointerException(&quot;Tactical forecast must not be null.&quot;);</span>
		}
<span class="nc bnc" id="L54" title="All 2 branches missed.">		if (strategicForecast.length != tacticalForecast.length) {</span>
<span class="nc" id="L55">			throw new IllegalArgumentException(&quot;Strategic and tactical forecast arrays must be the same length.&quot;);</span>
		}
<span class="nc bnc" id="L57" title="All 4 branches missed.">		if (strategicForecastWeight &lt; 0 || strategicForecastWeight &gt; 100) {</span>
<span class="nc" id="L58">			throw new IllegalArgumentException(&quot;Strategic forecast weight must be a percentage between 0 and 100, inclusive.&quot;);</span>
		}

<span class="nc bnc" id="L61" title="All 2 branches missed.">		if (strategicForecastWeight == 0) {</span>
<span class="nc" id="L62">			return Arrays.copyOf(tacticalForecast, tacticalForecast.length);</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">		} else if (strategicForecastWeight == 100) {</span>
<span class="nc" id="L64">			return Arrays.copyOf(strategicForecast, strategicForecast.length);</span>
		}

<span class="nc" id="L67">		int[] combinedForecast = new int[strategicForecast.length];</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">		for (int index = 0; index &lt; strategicForecast.length; ++index) {</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">			if (strategicForecast[index] &lt; 0) {</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">				if (tacticalForecast[index] &lt; 0) {</span>
<span class="nc" id="L72">					combinedForecast[index] = Trace.TRACENA;</span>
				} else {
<span class="nc" id="L74">					combinedForecast[index] = strategicForecast[index];</span>
				}
<span class="nc bnc" id="L76" title="All 2 branches missed.">			} else if (tacticalForecast[index] &lt; 0) {</span>
<span class="nc" id="L77">				combinedForecast[index] = strategicForecast[index];</span>
			} else {
<span class="nc" id="L79">				combinedForecast[index] = TraceUtil.roundDouble(</span>
						(strategicForecastWeight * strategicForecast[index] +
								(100 - strategicForecastWeight) * tacticalForecast[index]) / 100.);
			}
		}

<span class="nc" id="L85">		return combinedForecast;</span>
	}

	/**
	 * @param tacticalForecast
	 * @param scalePerDay
	 * @param startCal - Needed so that we can increment the counter by 15 minutes, and determine the day each time,
	 *                    in a DST-aware fashion.
	 * @return
	 */
	public static double[] getTacticalForecastWithStrategicWeight( double[] tacticalForecast, double[] scalePerDay,
			Calendar startCal){
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (tacticalForecast == null) {</span>
<span class="nc" id="L98">			throw new NullPointerException(&quot;Tactical forecast must not be null.&quot;);</span>
		}

<span class="nc" id="L101">		double[] combinedForecast = new double[tacticalForecast.length];</span>

<span class="nc" id="L103">		Calendar curCal = (Calendar)startCal.clone();</span>

		//keep track of next day start. This will help us determine which day each interval belongs to.
<span class="nc" id="L106">		Calendar nextDayStart = (Calendar)startCal.clone();</span>
<span class="nc" id="L107">		nextDayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L108">		int dayIndex = 0;</span>

<span class="nc" id="L110">		double carryOver = 0.0;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">		for (int index = 0; index &lt; tacticalForecast.length; ++index) {</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">			if(tacticalForecast[index] &gt;= 0) {</span>
<span class="nc" id="L113">				double scaledTacticalForecast = (tacticalForecast[index]+carryOver) * scalePerDay[dayIndex];</span>
<span class="nc" id="L114">				combinedForecast[index] = (int)Math.floor(scaledTacticalForecast);</span>
<span class="nc" id="L115">				carryOver = scaledTacticalForecast - combinedForecast[index];</span>
<span class="nc" id="L116">			} else {</span>
<span class="nc" id="L117">				combinedForecast[index] = Trace.TRACENA;</span>
			}

<span class="nc" id="L120">			curCal.add(Calendar.MINUTE, 15);</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">			if (curCal.getTime().equals(nextDayStart.getTime())) {</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">				if(dayIndex &lt; (scalePerDay.length - 1)) { //for DST day, simply adding a day will be out of day index.</span>
<span class="nc" id="L123">					dayIndex++;</span>
<span class="nc" id="L124">					nextDayStart.add(Calendar.DATE, 1);</span>
				}
			}
		}
<span class="nc" id="L128">		return combinedForecast;</span>
	}

	/**
	 * Calculates a forecast based on the specified profile entries, applying
	 * a weight to each constituent data series as a whole.
	 * &lt;p&gt;
	 * Each entry consists of historic data (volume, connect rate, or RPC
	 * rate) together with a weight that indicates the relative influence that
	 * profile entry should have on the resulting forecast.
	 * &lt;p&gt;
	 * The forecast at a given point is the weighted average of the
	 * historic values at that point, offset by the carryover from the
	 * previous calculation, and rounded to the nearest integer.  Values ending
	 * in .5 are rounded towards negative infinity.  The carryover is then
	 * offset by the difference between the actual weighted average and
	 * the rounded forecast value and used in the following calculation.
	 * Before the first calculation the carryover is zero.
	 * &lt;p&gt;
	 * History values that are negative are omitted from the calculation
	 * if &lt;code&gt;treatNegativeValuesAsZero&lt;/code&gt; is &lt;code&gt;false&lt;code&gt;, or treated
	 * as zero if &lt;code&gt;treatNegativeValuesAsZero&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.
	 * &lt;p&gt;
	 * If all historic values at a given point are negative, then the
	 * resulting forecast value will be zero.  A significant consequence of this
	 * is that after running the forecast calculation, client code may be obliged
	 * to re-apply hours of operation (HOO) delimiters.
	 *
	 * @param profileEntries history weeks to be included in the calculation
	 * @param treatNegativeValuesAsZero if &lt;code&gt;true&lt;/code&gt;, negative history values
	 * are treated as if they were zero; if &lt;code&gt;false&lt;/code&gt;, negative history values
	 * are omitted from the weighted average calculation at that point.
	 * @return
	 */
	public static double[] getSeriesWeightedAverageForecastWithCarryover(Collection&lt;ProfileEntry&gt; profileEntries,
			boolean treatNegativeValuesAsZero) {
		// Check profile entries for consistency.
<span class="nc" id="L165">		int historyLength = -1;</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">		for (ProfileEntry entry : profileEntries) {</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (historyLength == -1) {</span>
<span class="nc" id="L168">				historyLength = entry.getHistoryData().length;</span>
			} else {
<span class="nc bnc" id="L170" title="All 2 branches missed.">				if (entry.getHistoryData().length != historyLength) {</span>
<span class="nc" id="L171">					throw new IllegalArgumentException(&quot;Inconsistent history length: other weeks used &quot; +</span>
<span class="nc" id="L172">							historyLength + &quot;, current week uses &quot; + entry.getHistoryData().length);</span>
				}
			}
<span class="nc" id="L175">		}</span>

<span class="nc" id="L177">		double[] forecast = new double[historyLength];</span>
<span class="nc" id="L178">		double carryOver = 0;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">		for (int timeIndex = 0; timeIndex &lt; historyLength; ++timeIndex) {</span>
			// Total entry weight can vary from one history point to the next because
			// some but not all entries might be missing data at any particular point.
			// Thus we have to compute it for each history point rather than computing
			// it outside the loop.
<span class="nc" id="L184">			double totalEntryWeight = 0;</span>
<span class="nc" id="L185">			double weightedSum = 0;</span>
<span class="nc bnc" id="L186" title="All 2 branches missed.">			for (ProfileEntry entry : profileEntries) {</span>
<span class="nc" id="L187">				double historyValue = entry.getHistoryData()[timeIndex];</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">				if (treatNegativeValuesAsZero &amp;&amp; historyValue &lt; 0) {</span>
<span class="nc" id="L189">					historyValue = 0;</span>
				}
<span class="nc bnc" id="L191" title="All 2 branches missed.">				if (historyValue &gt;= 0) {</span>
<span class="nc" id="L192">					weightedSum += (double)entry.getEntryWeight() * historyValue;</span>
<span class="nc" id="L193">					totalEntryWeight += entry.getEntryWeight();</span>
				}
<span class="nc" id="L195">			}</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">			if (totalEntryWeight &gt; 0) {</span>
<span class="nc" id="L197">				weightedSum /= totalEntryWeight;</span>
				// Forecast volume is rounded down at half-values, for example 2.5 becomes 2.
<span class="nc" id="L199">				forecast[timeIndex] = MathUtil.roundHalfFloor(weightedSum + carryOver);</span>
				// The roundoff amount is carried forward the next summation.
<span class="nc" id="L201">				carryOver += weightedSum - forecast[timeIndex];</span>
			} else {
<span class="nc" id="L203">				forecast[timeIndex] = 0;</span>
			}
		}

<span class="nc" id="L207">		return forecast;</span>
	}

	/**
	 * Calculates a forecast based on the specified profile entries, applying
	 * a weight to each separate data point and a weight to each constituent
	 * series as a whole.  This is suitable for AHT calculations in a
	 * deferred or immediate forecast and for AHT and RPCAHT calculations
	 * in an outbound forecast.
	 * &lt;p&gt;
	 * Each profile entry consists of historic data (AHT or RPCAHT) and related
	 * weight data (volume, connect rate, or RPC rate depending on what
	 * is being forecast), together with an overall weight that indicates the
	 * relative influence that profile entry should have on the resulting forecast.
	 * &lt;p&gt;
	 * Before the forecast algorithm is applied to historic data, the historic
	 * data is smoothed using a weighted average of the two points on each side
	 * of each value.  The original value gets half the weight, while
	 * the remaining weight is divided evenly among the four neighbors.
	 * &lt;p&gt;
	 * This forecast algorithm takes a weighted average of the smoothed
	 * historic values at each point, where the smoothed value for each
	 * profile entry is weighted both by the weight value at that point
	 * and the overall weight for that profile entry.
	 *
	 * @param profileEntries
	 * @param calculateDefaultValues
	 * @return
	 */
	public static double[] getPointWeightedAverageForecastWithSmoothing(Collection&lt;ProfileEntry&gt; profileEntries,
			boolean calculateDefaultValues, boolean useWeightDataForSmoothing) {
<span class="nc" id="L238">		List&lt;ProfileEntry&gt; profileEntryList = new ArrayList&lt;ProfileEntry&gt;(profileEntries);</span>

		// Check profile entries for consistency.
<span class="nc" id="L241">		int historyLength = -1;</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">		for (ProfileEntry entry : profileEntryList) {</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">			if (historyLength == -1) {</span>
<span class="nc" id="L244">				historyLength = entry.getHistoryData().length;</span>
			} else {
<span class="nc bnc" id="L246" title="All 2 branches missed.">				if (entry.getHistoryData().length != historyLength) {</span>
<span class="nc" id="L247">					throw new IllegalArgumentException(&quot;Inconsistent history length: other weeks used &quot; +</span>
<span class="nc" id="L248">							historyLength + &quot;, current entry uses &quot; + entry.getHistoryData().length);</span>
				}
			}
<span class="nc bnc" id="L251" title="All 2 branches missed.">			if (entry.getWeightData().length != historyLength) {</span>
<span class="nc" id="L252">				throw new IllegalArgumentException(&quot;Inconsistent weight data length: history length was &quot; +</span>
<span class="nc" id="L253">						historyLength + &quot;, current entry uses &quot; + entry.getWeightData().length);</span>
			}
<span class="nc" id="L255">		}</span>

		// Smooth history data using the two neighboring points of each existing point.
		// The central point counts for 50% of the total weight, with the rest divided
		// evenly among the four neighbors.
<span class="nc" id="L260">		int smoothingRadius = 2;</span>
<span class="nc" id="L261">		double[] smoothingWeights = new double[] { .125, .125, .5, .125, .125 };</span>
<span class="nc" id="L262">		double[][] smoothedHistory = new double[profileEntryList.size()][];</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">		for (int profileIndex = 0; profileIndex &lt; profileEntryList.size(); ++profileIndex) {</span>
<span class="nc" id="L264">			ProfileEntry entry = profileEntryList.get(profileIndex);</span>

<span class="nc bnc" id="L266" title="All 2 branches missed.">			if (calculateDefaultValues) {</span>
<span class="nc" id="L267">				double[] historyDataWithAverage = getHistoryDataWithDefaultValues(entry.getHistoryData(),</span>
<span class="nc" id="L268">						entry.getWeightData(), entry.getDefaultValueWeightData());</span>
<span class="nc" id="L269">				smoothedHistory[profileIndex] = getSmoothedData(historyDataWithAverage, entry.getWeightData(),</span>
						smoothingWeights, smoothingRadius, useWeightDataForSmoothing);
<span class="nc" id="L271">			} else {</span>
<span class="nc" id="L272">				smoothedHistory[profileIndex] = getSmoothedData(entry.getHistoryData(), entry.getWeightData(),</span>
						smoothingWeights, smoothingRadius, useWeightDataForSmoothing);
			}
		}

		// The AHT forecast now becomes a weighted average at each point where the
		// historic AHT for each profile entry is weighted both by that profile entry's
		// historic volume at that point and by the overall weight for that profile entry.
<span class="nc" id="L280">		double[] forecast = new double[historyLength];</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">		for (int historyIndex = 0; historyIndex &lt; historyLength; ++historyIndex) {</span>
<span class="nc" id="L282">			double totalWeightAtPoint = 0;</span>
<span class="nc" id="L283">			double weightedSum = 0;</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">			for (int profileIndex = 0; profileIndex &lt; profileEntryList.size(); ++profileIndex) {</span>
<span class="nc" id="L285">				ProfileEntry entry = profileEntryList.get(profileIndex);</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">				if (entry.getWeightData()[historyIndex] &gt; 0) {</span>
<span class="nc" id="L287">					double weightAtPoint = entry.getEntryWeight() * entry.getWeightData()[historyIndex];</span>
<span class="nc" id="L288">					weightedSum += smoothedHistory[profileIndex][historyIndex] * weightAtPoint;</span>
<span class="nc" id="L289">					totalWeightAtPoint += weightAtPoint;</span>
				}
			}
<span class="nc bnc" id="L292" title="All 2 branches missed.">			if (totalWeightAtPoint &gt; 0) {</span>
<span class="nc" id="L293">				weightedSum /= totalWeightAtPoint;</span>
				// Forecast AHT is rounded up at half-values, for example 2.5 becomes 3.
<span class="nc" id="L295">				forecast[historyIndex] = MathUtil.roundHalfCeiling(weightedSum);</span>
			} else {
				// If totalWeightAtPoint is zero, then no profile entry had
				// nonzero weight data at this point.  At such points the
				// resulting forecast is zero.
<span class="nc" id="L300">				forecast[historyIndex] = 0;</span>
			}
		}

<span class="nc" id="L304">		return forecast;</span>
	}

	/**
	 * Smooths the entries of an array by taking the weighted average of points
	 * surrounding each point in the source array, according to the set of weights
	 * specified.
	 * &lt;p&gt;
	 * Generally, negative values are excluded from the weighted average calculation.
	 * If all values at within the neighborhood of a particular point are negative,
	 * then the resulting point will be zero.
	 */
	static double[] getSmoothedData(double[] sourceData, double[] weightData,
			double[] smoothingWeights, int smoothingRadius, boolean useWeightDataForSmoothing) {
<span class="nc" id="L318">		int sourceLength = sourceData.length;</span>
<span class="nc" id="L319">		double[] smoothedData = new double[sourceLength];</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">		for (int historyIndex = 0; historyIndex &lt; sourceLength; ++historyIndex) {</span>
<span class="nc" id="L321">			double smoothedEntry = 0;</span>
<span class="nc" id="L322">			double totalSmoothingWeight = 0;</span>
<span class="nc bnc" id="L323" title="All 2 branches missed.">			for (int smoothingOffset = -smoothingRadius; smoothingOffset &lt;= smoothingRadius; ++smoothingOffset) {</span>
<span class="nc" id="L324">				int smoothingIndex = historyIndex + smoothingOffset;</span>
				// To be consistent with the C++ forecasting algorithm, if a point to be used
				// in smoothing lies off the end of the history array, the closest existing
				// point is used in its place.
<span class="nc bnc" id="L328" title="All 2 branches missed.">				if (smoothingIndex &lt; 0) {</span>
<span class="nc" id="L329">					smoothingIndex = 0;</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">				} else if (smoothingIndex &gt;= sourceLength) {</span>
<span class="nc" id="L331">					smoothingIndex = sourceLength - 1;</span>
				}
<span class="nc" id="L333">				double sourceEntry = sourceData[smoothingIndex];</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">				if (sourceEntry &gt;= 0) {</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">					if (useWeightDataForSmoothing) {</span>
<span class="nc" id="L336">						smoothedEntry += sourceEntry * smoothingWeights[smoothingRadius + smoothingOffset] * weightData[smoothingIndex];</span>
<span class="nc" id="L337">						totalSmoothingWeight += smoothingWeights[smoothingRadius + smoothingOffset] * weightData[smoothingIndex];</span>
					} else {
<span class="nc" id="L339">						smoothedEntry += sourceEntry * smoothingWeights[smoothingRadius + smoothingOffset];</span>
<span class="nc" id="L340">						totalSmoothingWeight += smoothingWeights[smoothingRadius + smoothingOffset];</span>
					}
				}
			}
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (totalSmoothingWeight &gt; 0) {</span>
<span class="nc" id="L345">				smoothedData[historyIndex] = smoothedEntry / totalSmoothingWeight;</span>
			} else {
<span class="nc" id="L347">				smoothedData[historyIndex] = 0;</span>
			}
		}
<span class="nc" id="L350">		return smoothedData;</span>
	}

	/**
	 * Calculates the default history value for the given set of history data and weights for that data.
	 * If the weights contain no values &gt; 0, then the value returned will be a simple average (excluding
	 * zeroes) of the given historyData array.  Otherwise, the returned value will be a weighted average
	 * of the given historyData, weighted on weightData.
	 * @param historyData - The history data for which to calculate a default value.  For the typical case,
	 *                    this is AHT history of a deferred media queue.
	 * @param weightData - The weights used to calculate the default history value.  For the typical case,
	 *                   where AHT is the history, the weight data would be Volume Handled (VH).
	 */
	private static double calculateDefaultHistoryValue(double[] historyData, double[] weightData) {
<span class="nc" id="L364">		double averageAHT = 0.0;</span>
<span class="nc" id="L365">		double totalWeight = 0.0;</span>
<span class="nc" id="L366">		double totalTotal = 0.0;</span>

<span class="nc bnc" id="L368" title="All 2 branches missed.">		for (int i = 0; i &lt; historyData.length; i++) {</span>
<span class="nc" id="L369">			double history = historyData[i];</span>
<span class="nc" id="L370">			double weight = weightData[i];</span>

<span class="nc bnc" id="L372" title="All 2 branches missed.">			if (weight &lt; 0.0) {</span>
<span class="nc" id="L373">				weight = 0.0;</span>
			}
<span class="nc bnc" id="L375" title="All 2 branches missed.">			if (history &lt; 0.0) {</span>
<span class="nc" id="L376">				history = 0.0;</span>
			}

<span class="nc bnc" id="L379" title="All 2 branches missed.">			if (history &gt; 0.0) {</span>
<span class="nc" id="L380">				weight += .000001;</span>
<span class="nc" id="L381">				totalWeight += weight;</span>
<span class="nc" id="L382">				totalTotal += history * weight;</span>
			}
		}

<span class="nc bnc" id="L386" title="All 2 branches missed.">		if (totalWeight &gt; 0.0) {</span>
<span class="nc" id="L387">			averageAHT = totalTotal / totalWeight;</span>
		}

<span class="nc" id="L390">		return averageAHT;</span>
	}

	/**
	 * Returns a copy of historyData, modified to include &quot;default values&quot; for history where zero-values existed
	 * prior.  A &quot;default value&quot; is determined by calling the {@link #calculateDefaultHistoryValue} method.
	 */
	private static double[] getHistoryDataWithDefaultValues(double[] historyData, double[] weightData,
			double[] defaultValueWeightData) {

<span class="nc bnc" id="L400" title="All 4 branches missed.">		if (defaultValueWeightData == null || historyData.length != defaultValueWeightData.length) {</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			throw new IllegalArgumentException(&quot;Retrieving history with default values requires that historyData and&quot; +</span>
					&quot;defaultValueWeightData have matching length: history length was &quot; +
					historyData.length + &quot;, weight data was &quot; +
					(defaultValueWeightData == null ? &quot;null&quot; : &quot; length &quot; + defaultValueWeightData.length));
		}

<span class="nc" id="L407">		double[] historyDataWithDefaults = new double[historyData.length];</span>
<span class="nc" id="L408">		double averageAHT = calculateDefaultHistoryValue(historyData, defaultValueWeightData);</span>

		//insert the Average where AHT is 0...
<span class="nc bnc" id="L411" title="All 2 branches missed.">		for (int i = 0; i &lt; historyData.length; i++)</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">			if (weightData[i] &gt; 0.0 &amp;&amp; historyData[i] &lt;= 0.0) {</span>
<span class="nc" id="L413">				historyDataWithDefaults[i] = averageAHT;</span>
			} else {
<span class="nc" id="L415">				historyDataWithDefaults[i] = historyData[i];</span>
			}

<span class="nc" id="L418">		return historyDataWithDefaults;</span>
	}

	/**
	 * An instance of this class describes a single history week to be included in
	 * a forecast calculation.
	 * &lt;p&gt;
	 * A profile entry always contains history data and an overall weight.
	 * Depending on the context in which it is used, it may also require weight
	 * data corresponding to each history point as well as a separate set of weight
	 * data used to calculate default values for intervals without history.
	 * &lt;p&gt;
	 * For example, when forecasting volume you would use the ProfileEntry(double[], double)
	 * constructor and no weights would be needed.  When forecasting AHT you would use
	 * the ProfileEntry(double[], double[], double) constructor and specify AHT for the
	 * history data and volume for the weight data.
	 */
	public static class ProfileEntry {
		private final double[] historyData;
		private final double[] weightData;
		private final double[] defaultValueWeightData;
		private final double entryWeight;

		public ProfileEntry(double[] historyData, double entryWeight) {
<span class="nc" id="L442">			this(historyData, null, entryWeight);</span>
<span class="nc" id="L443">		}</span>

		public ProfileEntry(double[] historyData, double[] weightData, double entryWeight) {
<span class="nc" id="L446">			this(historyData, weightData, null, entryWeight);</span>
<span class="nc" id="L447">		}</span>

<span class="nc" id="L449">		public ProfileEntry(double[] historyData, double[] weightData, double[] defaultValueWeightData, double entryWeight) {</span>
<span class="nc" id="L450">			this.historyData = historyData;</span>
<span class="nc" id="L451">			this.weightData = weightData;</span>
<span class="nc" id="L452">			this.entryWeight = entryWeight;</span>
<span class="nc" id="L453">			this.defaultValueWeightData = defaultValueWeightData;</span>
<span class="nc" id="L454">		}</span>

		/**
		 * Returns this profile entry's history data.  This is the data that will
		 * be forecast and must always be specified.
		 */
		double[] getHistoryData() {
<span class="nc" id="L461">			return historyData;</span>
		}

		/**
		 * Returns this profile entry's weight data.  This is the data that will be
		 * used to weight the history data and is ignored in some forecast algorithms.
		 */
		double[] getWeightData() {
<span class="nc" id="L469">			return weightData;</span>
		}

		/**
		 * Returns this profile entry's overall weight.
		 */
		double getEntryWeight() {
<span class="nc" id="L476">			return entryWeight;</span>
		}

		/**
		 * Returns this profile entry's weight data that is used for the default
		 * value calculation.  At the time of writing, this was only used for Deferred Media and contains
		 * Volume Handled (VH) data.
		 */
		double[] getDefaultValueWeightData() {
<span class="nc" id="L485">			return defaultValueWeightData;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>