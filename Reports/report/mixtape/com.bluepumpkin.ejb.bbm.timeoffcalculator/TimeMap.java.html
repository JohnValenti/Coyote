<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeMap.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeoffcalculator</a> &gt; <span class="el_source">TimeMap.java</span></div><h1>TimeMap.java</h1><pre class="source lang-java linenums">/*
 * TimeMap.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.bbm.timeoffcalculator;

import java.util.BitSet;
import java.util.Date;
import java.util.TimeZone;

import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;

/**
 * Wraps a BitSet with operations designed to answer questions about the
 * validity of requests. Objects of this class are constructed using a BitSet
 * that represents things like Hours of Operation or Black out dates and then
 * questions about a range can be posed.
 *
 */
public class TimeMap {

	/**
	 * 1 minute resolution
	 */
	public static final long ONE_MINUTE = 1000 * 60;

	/**
	 * 15 minute resolution
	 */
	public static final long FIFTEEN_MIN = ONE_MINUTE * 15;

	/**
	 * 1 hour resolution
	 */
	public static final long ONE_HOUR = FIFTEEN_MIN * 4;

	/**
	 * one day resolution
	 */
	public static final long ONE_DAY = ONE_HOUR * 24;

	/**
	 * a date constant used to indicate that no correponding time exists in the
	 * map
	 */
<span class="fc" id="L49">	public static final Date NO_SUCH_TIME = new Date(-1L);</span>

	/**
     *
     */
<span class="fc" id="L54">	private Category m_cat = Log.initCategory(TimeMap.class.getName());</span>

	/**
	 * the bit map
	 *
	 * &lt;p&gt;
	 * from Javadoc: This class implements a vector of bits that grows as
	 * needed. Each component of the bit set has a boolean value. The bits of a
	 * BitSet are indexed by nonnegative integers. Individual indexed bits can
	 * be examined, set, or cleared.
	 *
	 * &lt;p&gt;
	 * Every bit set has a current size, which is the number of bits of space
	 * currently in use by the bit set. Note that the size is related to the
	 * implementation of a bit set, so it may change with implementation. The
	 * length of a bit set relates to logical length of a bit set and is defined
	 * independently of implementation.
	 *
	 * &lt;p&gt;
	 * An IndexOutOfBoundsException is thrown if the index used for the bitSet
	 * is -ve.
	 */
<span class="fc" id="L76">	protected BitSet m_bits = null;</span>

	/**
	 * the resolution
	 */
<span class="fc" id="L81">	protected long m_resolution = 0L;</span>

	/**
	 * the resolution in minutes
	 */
<span class="fc" id="L86">	protected long m_res_minutes = 0L;</span>

	/**
	 * the beginning time
	 */
<span class="fc" id="L91">	protected Date m_beginning = null;</span>

	/**
	 * the beginning time in minutes, used to avoid fractional minutes when
	 * computing map indexes.
	 */
<span class="fc" id="L97">	private long m_begMinutes = 0L;</span>

	/**
	 * the ending time, may be omitted, required for NOT, Next Off and Higest
	 * Off operations
	 */
<span class="fc" id="L103">	protected Date m_ending = null;</span>

	/**
	 * the ending time in minutes
	 */
<span class="fc" id="L108">	private long m_endMinutes = 0L;</span>

<span class="fc" id="L110">	private Organization m_org = null;</span>

	/**
	 * Creates a new TimeMap without a supplied bit set, an inital one with all
	 * the bits off will be created.
	 *
	 * @param resolution
	 *            the number of milliseconds each bit in the BitSet represents
	 * @param beginning
	 *            the date/time represented by the first bit in the bitset
	 * @param ending
	 *            the date/time represented by the last bit in the bitset
	 */
	public TimeMap(long resolution, Date beginning, Date ending) {
<span class="fc" id="L124">		this(new BitSet((int) ((ending.getTime() - beginning.getTime()) / resolution)), resolution, beginning, ending);</span>
<span class="fc" id="L125">	}</span>

	public TimeMap(long resolution, Date beginning, Date ending, Organization org) {
<span class="fc" id="L128">		this(new BitSet((int) ((ending.getTime() - beginning.getTime()) / resolution)), resolution, beginning, ending);</span>
<span class="fc" id="L129">		m_org = org;</span>
<span class="fc" id="L130">	}</span>

	/**
	 * Creates a new TimeMap.
	 *
	 * @param bits
	 *            a BitSet object that represents the time data.
	 * @param resolution
	 *            the number of milliseconds each bit in the BitSet represents
	 * @param beginning
	 *            the date/time represented by the first bit in the bitset
	 * @param ending
	 *            the date/time represented by the last bit in the bitset
	 */
<span class="fc" id="L144">	public TimeMap(BitSet bits, long resolution, Date beginning, Date ending) {</span>
<span class="fc" id="L145">		init(bits, resolution, beginning);</span>

		// ending date cannot be before begining
<span class="pc bpc" id="L148" title="1 of 2 branches missed.">		if (ending.before(beginning)) {</span>
<span class="nc" id="L149">			throw new IllegalArgumentException(&quot;ending before beginning&quot;);</span>
		}
<span class="fc" id="L151">		m_ending = ending;</span>

<span class="fc" id="L153">		m_endMinutes = (long) Math.ceil(ending.getTime() / (double) ONE_MINUTE);</span>

<span class="pc bpc" id="L155" title="1 of 2 branches missed.">		if (m_cat.isDebugEnabled())</span>
<span class="fc" id="L156">			m_cat.debug(&quot;TimeMap created: &quot; + toString());</span>
<span class="fc" id="L157">	}</span>

	private void init(BitSet bits, long resolution, Date beginning) {
		// Check that the bitset is not null
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">		if (bits == null) {</span>
<span class="nc" id="L162">			throw new IllegalArgumentException(&quot;null bitset&quot;);</span>
		}
<span class="fc" id="L164">		m_bits = bits;</span>

		// Resolution must range from one minute to one day
<span class="pc bpc" id="L167" title="2 of 4 branches missed.">		if ((resolution &lt; ONE_MINUTE) || (resolution &gt; ONE_DAY)) {</span>
<span class="nc" id="L168">			throw new IllegalArgumentException(&quot;resolution out of bounds: &quot; + resolution);</span>
		}
		// Resolution must be an even multiple of minutes
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">		if (resolution % ONE_MINUTE != 0) {</span>
<span class="nc" id="L172">			throw new IllegalArgumentException(&quot;resolution must be an even multiple of minutes&quot;);</span>
		}
<span class="fc" id="L174">		m_resolution = resolution;</span>
<span class="fc" id="L175">		m_res_minutes = resolution / ONE_MINUTE;</span>

		// beginning date cannot be null
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">		if (beginning == null) {</span>
<span class="nc" id="L179">			throw new IllegalArgumentException(&quot;null beginning&quot;);</span>
		}
		// Beginning date cannot be before epoch
<span class="pc bpc" id="L182" title="1 of 2 branches missed.">		if (beginning.getTime() &lt; 0) {</span>
<span class="nc" id="L183">			throw new IllegalArgumentException(&quot;date too early: &quot; + beginning);</span>
		}
<span class="fc" id="L185">		m_beginning = beginning;</span>

<span class="fc" id="L187">		m_begMinutes = beginning.getTime() / ONE_MINUTE;</span>
<span class="fc" id="L188">	}</span>

	/**
	 * Sets the bit for the given time point &quot;ON&quot;.
	 */
	public void set(Date date) {
<span class="nc bnc" id="L194" title="All 4 branches missed.">		if (m_ending != null &amp;&amp; date.after(m_ending))</span>
<span class="nc" id="L195">			return;</span>

		// by convention, use the floor for single bit calculations
<span class="nc" id="L198">		int ix = bitIndex(date, false);</span>
<span class="nc" id="L199">		m_bits.set(ix);</span>
<span class="nc" id="L200">	}</span>

	/**
	 * Sets the bit for the given time point &quot;ON&quot;. The time is passed as the raw
	 * milliseconds in the epoch. Useful for being called inside loops when you
	 * want to avoid creating new Date() objects.
	 */
	public void set(long time) {
<span class="nc bnc" id="L208" title="All 4 branches missed.">		if (m_ending != null &amp;&amp; m_ending.getTime() &lt; time)</span>
<span class="nc" id="L209">			return;</span>

		// by convention, use the floor for single bit calculations
<span class="nc" id="L212">		int ix = bitIndex(time, false);</span>
<span class="nc" id="L213">		m_bits.set(ix);</span>
<span class="nc" id="L214">	}</span>

	protected void setOrResetRange(boolean setFlag, long start, long end) {

<span class="pc bpc" id="L218" title="1 of 2 branches missed.">		if (start &gt; end)</span>
<span class="nc" id="L219">			throw new IllegalArgumentException(&quot;start after end: start = &quot; + start + &quot;; end = &quot; + end);</span>

		// later of start, timemap start.
<span class="fc" id="L222">		long mapStartTime = m_beginning.getTime();</span>
<span class="fc" id="L223">		long mapEndTime = m_ending.getTime();</span>

<span class="fc" id="L225">		long adjStartTime = Math.max(start, mapStartTime);</span>
<span class="fc" id="L226">		int startIdx = bitIndex(adjStartTime, false);</span>

<span class="fc" id="L228">		long adjEndTime = Math.min(end, mapEndTime);</span>
		// Move end time back by 1 millisecond only if the adjEndTime &gt;
		// adjStart.
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">		if (adjEndTime &gt; adjStartTime) {</span>
<span class="fc" id="L232">			adjEndTime = adjustTimeUsingResolution(adjEndTime);</span>
		}

<span class="fc" id="L235">		int endIdx = bitIndex(adjEndTime, false);</span>

<span class="fc bfc" id="L237" title="All 2 branches covered.">		if (setFlag) {</span>
			// Sets the bits from the specified fromIndex(inclusive) to the
			// specified toIndex(exclusive) to true
			// Note: using 'endIdx + 1' since the bid at endIdx must be set.
<span class="fc" id="L241">			m_bits.set(startIdx, endIdx + 1);</span>
		} else {
			// clears the bits from the specified fromIndex(inclusive) to the
			// specified toIndex(exclusive) to false
			// Note: using 'endIdx + 1' since the bid at endIdx must be reset.
<span class="fc" id="L246">			m_bits.clear(startIdx, endIdx + 1);</span>
		}
		// for (int i = startIdx; i &lt;= endIdx; i++ ) {
		// if (setFlag) {
		// m_bits.set(i);
		// } else {
		// m_bits.clear(i);
		// }
		// }
<span class="fc" id="L255">	}</span>

	/**
	 * See {@link TOCalcUtil#adjustTimeUsingResolution(long, long)
	 * adjustTimeUsingResolution() }
	 *
	 * @param timeInMs
	 * @return
	 */
	private long adjustTimeUsingResolution(long timeInMs) {
<span class="fc" id="L265">		long adjTime = TOCalcUtil.adjustTimeUsingResolution(timeInMs, getResolution());</span>
<span class="fc" id="L266">		return adjTime;</span>
	}

	public void setRange(Date start, Date end) {
<span class="fc" id="L270">		setRange(start.getTime(), end.getTime());</span>
<span class="fc" id="L271">	}</span>

	/**
	 * Set the range of bits from 'start' to 'end'
	 *
	 * @param start
	 * @param end
	 */
	public void setRange(long start, long end) {
<span class="fc" id="L280">		setOrResetRange(true, start, end);</span>
<span class="fc" id="L281">	}</span>

	/**
	 * Clears the bit for the given time point, sets it &quot;OFF&quot;
	 */
	public void clear(Date date) {
<span class="nc bnc" id="L287" title="All 4 branches missed.">		if (m_ending != null &amp;&amp; date.after(m_ending))</span>
<span class="nc" id="L288">			return;</span>

		// by convention, use the floor for single bit calculations
<span class="nc" id="L291">		int ix = bitIndex(date, false);</span>
<span class="nc" id="L292">		m_bits.clear(ix);</span>
<span class="nc" id="L293">	}</span>

	/**
	 * Clears the bit for the given time point, sets it &quot;OFF&quot; The time is passed
	 * as the raw milliseconds in the epoch. Useful for being called inside
	 * loops when you want to avoid creating new Date() objects.
	 */
	public void clear(long time) {
<span class="nc bnc" id="L301" title="All 4 branches missed.">		if (m_ending != null &amp;&amp; m_ending.getTime() &lt; time)</span>
<span class="nc" id="L302">			return;</span>

		// by convention, use the floor for single bit calculations
<span class="nc" id="L305">		int ix = bitIndex(time, false);</span>
<span class="nc" id="L306">		m_bits.clear(ix);</span>
<span class="nc" id="L307">	}</span>

	public void clearRange(Date start, Date end) {
<span class="nc" id="L310">		clearRange(start.getTime(), end.getTime());</span>
<span class="nc" id="L311">	}</span>

	public void clearRange(long start, long end) {
<span class="fc" id="L314">		setOrResetRange(false, start, end);</span>
<span class="fc" id="L315">	}</span>

	/**
	 * Get the value for the bit corresponding to the given time
	 */
	public boolean get(Date d) {
<span class="nc" id="L321">		int ix = bitIndex(d, false);</span>
<span class="nc" id="L322">		return m_bits.get(ix);</span>
	}

	/**
	 * @return
	 */
	public long getResolution() {
<span class="fc" id="L329">		return m_resolution;</span>
	}

	/**
	 * Count number of bits in the whole map that are ON.
	 */
	public int countBitsOn() {
		// Returns the number of bits set to true in this BitSet.
<span class="nc" id="L337">		return m_bits.cardinality();</span>

		// int result = 0;
		// int limit = m_bits.length(); // Note: m_bits.length() is the index of
		// the last set bit
		// for (int ix = 0; ix &lt; limit; ix++) {
		// if (m_bits.get(ix)) result++;
		// }
		//
		// return result;
	}

	/**
	 * Count the number of bits on in a range. This method does not require that
	 * the range be entirely covered by the map (or covered at all, for that
	 * matter).
	 *
	 * Note: 'BitSet' in J2SE 1.4 does not provide a direct method to count the
	 * # of bits in a specified range. So have to resort to scanning each bit.
	 *
	 * @param start
	 *            the beginning of the range (inclusive)
	 * @param end
	 *            the end of the range (exclusive)
	 * @return the number of bits in the range that are on portions of the range
	 *         that fall outside the map are assumed to be off.
	 */
	public int countBitsOn(Date start, Date end) {
<span class="pc bpc" id="L365" title="1 of 2 branches missed.">		if (end.before(start)) {</span>
<span class="nc" id="L366">			throw new IllegalArgumentException(&quot;end &quot; + end + &quot; before start &quot; + start);</span>
		}
		// Bug fix for issue# 99525, sameet April 2008, one minute shown as paid
		// holiday on next day of paid holiday.
		// should always return 0 if start == end as there are no bits in range
		// if start and end are the same date.
<span class="pc bpc" id="L372" title="1 of 4 branches missed.">		if ((start != null &amp;&amp; start.equals(end))) {</span>
<span class="fc" id="L373">			boolean bitvalue = false;</span>
<span class="fc bfc" id="L374" title="All 2 branches covered.">			if (!start.before(m_beginning)) {</span>
<span class="fc" id="L375">				bitvalue = m_bits.get(bitIndex(start, false));</span>
			}
<span class="fc" id="L377">			m_cat.debug(&quot;bitvalue=&quot; + bitvalue + &quot;:however returning zero; as start date equals end date= &quot; + start</span>
					+ &quot;: m_beginning=&quot; + m_beginning + &quot;: m_ending=&quot; + m_ending);
<span class="fc" id="L379">			return 0;</span>
		}
		// given range before timemap range
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">		if (end.before(m_beginning))</span>
<span class="nc" id="L383">			return 0;</span>

		// given range after timemap range
<span class="pc bpc" id="L386" title="2 of 4 branches missed.">		if (m_ending != null &amp;&amp; m_ending.before(start))</span>
<span class="nc" id="L387">			return 0; // no bits on in range, out of map</span>

		// if start is earlier than timemap start
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">		if (start.before(m_beginning))</span>
<span class="nc" id="L391">			start = m_beginning;</span>

		// Returns the &quot;logical size&quot; of this BitSet: the index of the highest
		// set bit in the BitSet plus one. Returns zero if the BitSet
		// contains no set bits.
<span class="fc" id="L396">		int limit = m_bits.length();</span>
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		if (inRange(end)) {</span>
			// Note: we set 'ceil' == true in the call to bitIndex() below since
			// we want a partial minute to be counted as a full minute.
			//
			// Incrementing return value of bitIndex() since 'limit' returned by
			// m_bits.length() above is 'index+1' while
			// return value of bitIndex() below is just 'index'.
<span class="fc" id="L404">			limit = Math.min(limit, bitIndex(end, false) + 1);</span>
		}

		// count the bits.
<span class="fc" id="L408">		int result = 0;</span>
<span class="fc" id="L409">		int ix = bitIndex(start, false);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">		while (ix &lt; limit) {</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">			if (m_bits.get(ix++))</span>
<span class="fc" id="L412">				result++;</span>
		}
<span class="fc" id="L414">		return result;</span>
	}

	/**
	 * Create Date based on BidSetIndex
	 */
	private final Date createDateBasedOnBitSetIndex(int bitIndex) {
<span class="fc" id="L421">		Date result = NO_SUCH_TIME;</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">		if (bitIndex &gt;= 0) { // if a 'set' bit was found</span>
<span class="fc" id="L423">			long tmpTime = m_beginning.getTime() + bitIndex * m_resolution;</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">			if (tmpTime &lt;= m_ending.getTime()) {</span>
<span class="fc" id="L425">				result = new Date(tmpTime);</span>
			}
		}
<span class="fc" id="L428">		return result;</span>
	}

	/**
	 * Find the time corresponding to the next on bit in the map
	 *
	 * Next on bit for unbounded time maps does not pose a problem (due to
	 * Bitmap.length())
	 *
	 * @param cur
	 *            the starting point for which &quot;next&quot; is relative
	 * @return the date corresponding to the next bit that is on in the map
	 */
	public Date findNextOn(Date cur) {
		// start search from specified index + 1 (for next set bit)
<span class="fc" id="L443">		int idx = bitIndex(cur, false) + 1;</span>
		// Returns the index of the first bit that is set to true that occurs on
		// or after the specified starting index
		// If no such bit exists then -1 is returned.
<span class="fc" id="L447">		int nextSetBit = m_bits.nextSetBit(idx);</span>

<span class="fc" id="L449">		return createDateBasedOnBitSetIndex(nextSetBit);</span>

		// // find the last set bit
		// int limit = m_bits.length(); // Note: m_bits.length() is the index of
		// the last set bit
		// // scan for the next on bit.
		// int idx = bitIndex(cur, false) + 1;
		// for (; idx &lt; limit; idx++) {
		// if (m_bits.get(idx)) {
		// result = new Date( m_beginning.getTime() + idx*m_resolution );
		// break;
		// }
		// }
		//
		// return result;
	}

	/**
	 * Find the time corresponding to the first on bit in the map
	 *
	 * @return the date corresponding to the first bit that is on in the map
	 */
	public Date findFirstOn() {
		// Returns the index of the first bit that is set to true that occurs on
		// or after the specified starting index
		// If no such bit exists then -1 is returned.
<span class="fc" id="L475">		int nextSetBit = m_bits.nextSetBit(0);</span>

<span class="fc" id="L477">		return createDateBasedOnBitSetIndex(nextSetBit);</span>

		// int limit = m_bits.length(); // Note: m_bits.length() is the index of
		// the last set bit
		// // scan for the first on bit.
		// for (int i=0; i &lt; limit; i++) {
		// if (m_bits.get(i)) {
		// result = new Date( m_beginning.getTime() + i*m_resolution );
		// break;
		// }
		// }
		//
		// return result;
	}

	/**
	 * Find the time corresponding to the last on bit in the map
	 *
	 * @return the date corresponding to the last bit that is on in the map
	 */
	public Date findLastOn() {
		// Returns the index of the last bit that is set to true that occurs on
		// or before the specified ending index
		// If no such bit exists then -1 is returned.
<span class="nc" id="L501">		int nextSetBit = previousSetBit(m_bits.length());</span>

<span class="nc" id="L503">		return createDateBasedOnBitSetIndex(nextSetBit);</span>
	}
	
	/**
	 * previousSetBit is defined in BitSet from Java 1.7. Temporary implementation till we upgrade.
	 * @param fromIndex
	 * @return index of first on bit from fromIndex backwards. -1 if not found.
	 */
	
	public int previousSetBit(int fromIndex) {
<span class="nc bnc" id="L513" title="All 2 branches missed.">        if (fromIndex &lt; 0) {</span>
<span class="nc" id="L514">            throw new IndexOutOfBoundsException(</span>
                &quot;fromIndex &lt; -1: &quot; + fromIndex);
        }

<span class="nc bnc" id="L518" title="All 2 branches missed.">        if (fromIndex&gt;m_bits.length()){</span>
<span class="nc" id="L519">        	throw new IndexOutOfBoundsException(</span>
<span class="nc" id="L520">                    &quot;fromIndex &gt; &quot;+m_bits.length()+&quot;: &quot;+ fromIndex);</span>
        }
<span class="nc" id="L522">        int u = fromIndex;</span>
        while (true) {
<span class="nc" id="L524">        	boolean val = m_bits.get(u);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">            if (val){</span>
<span class="nc" id="L526">                return u;</span>
            }
<span class="nc" id="L528">            u--;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">            if (u &lt; 0){</span>
<span class="nc" id="L530">                return -1;</span>
            }
<span class="nc" id="L532">        }</span>
    }

	/**
	 * Find the time corresponding to the first off bit in the map
	 *
	 * @return the date corresponding to the first bit that is off in the map
	 */
	public Date findFirstOff() {
		// Returns the index of the first bit that is set to false that occurs
		// on or after the specified starting index.
<span class="nc" id="L543">		int nextClearBit = m_bits.nextClearBit(0);</span>

<span class="nc" id="L545">		return createDateBasedOnBitSetIndex(nextClearBit);</span>

		// /*if (m_ending == null) // see class documentation
		// throw new IllegalArgumentException(&quot;not defined with upper limit&quot;);
		// */
		//
		// int limit = m_bits.length(); // Note: m_bits.length() is the index of
		// the last set bit
		// // if bounded time map, use m_ending.
		// if ( m_ending != null ) {
		// limit = bitIndex(m_ending, true);
		// }
		//
		//
		// Date result = NO_SUCH_TIME;
		// for (int i = 0; i &lt; limit; i++) {
		// if (!m_bits.get(i)) {
		// result = new Date( m_beginning.getTime() + i*m_resolution );
		// break;
		// }
		// }
		// return result;
	}

	/**
	 * Return true if the whole map is on...requires upper limit
	 */
	public boolean allOn() {
<span class="nc" id="L573">		return (findFirstOff().equals(NO_SUCH_TIME));</span>
	}

	/**
	 * Return true if the whole map is off
	 */
	public boolean allOff() {
<span class="nc bnc" id="L580" title="All 2 branches missed.">		return (m_bits.length() == 0); // Note: m_bits.length() is the index of</span>
										// the last set bit
	}

	/**
	 * Find the time corresponding to the next off bit in the map
	 *
	 * @param date
	 *            the starting point for which &quot;next&quot; is relative
	 * @return the date corresponding to the next bit that is on in the map
	 */
	public Date findNextOff(Date date) {

<span class="fc" id="L593">		int idx = bitIndex(date, false) + 1;</span>
		// Returns the index of the first bit that is set to false that occurs
		// on or after the specified starting index.
		// Note: 'idx + 1' since the clear bit after the specified index needs
		// to be determined.
<span class="fc" id="L598">		int nextClearBit = m_bits.nextClearBit(idx + 1);</span>

<span class="fc" id="L600">		return createDateBasedOnBitSetIndex(nextClearBit);</span>

		// //if (m_ending == null) throw new
		// IllegalArgumentException(&quot;not defined with upper limit&quot;);
		//
		// int limit = m_bits.length(); // Note: m_bits.length() is the index of
		// the last set bit
		// // if bounded time map, use m_ending
		// if ( m_ending != null ) {
		// limit = bitIndex(m_ending, true);
		// }
		//
		// Date result = NO_SUCH_TIME;
		// for (int i = bitIndex(date, false) + 1; i &lt; limit; i++) {
		// if (!m_bits.get(i)) {
		// result = new Date( m_beginning.getTime() + i*m_resolution );
		// break;
		// }
		// }
		//
		// return result;
	}

	/**
	 * Test to see that the given range includes at least one interval that is
	 * &quot;on&quot; in the map. Use this test to check that a time off request choice
	 * includes some of the hours of operation, for example.
	 *
	 * @param start
	 *            the beginning of the range
	 * @param end
	 *            the end of the range
	 * @return true if there's at least one bit on in the map in the set of of
	 *         bits that corresponds to the given range.
	 */
	public boolean onBitsOverlapRange(Date start, Date end) {
<span class="fc" id="L636">		String methodName = &quot;onBitsOverlapRange&quot;;</span>
<span class="pc bpc" id="L637" title="1 of 2 branches missed.">		if (m_cat.isDebugEnabled())</span>
<span class="fc" id="L638">			m_cat.debug(TOCalcUtil.dumpEnterMethod(methodName, start, end));</span>

<span class="pc bpc" id="L640" title="1 of 2 branches missed.">		if (validateNonOverlap(start, end))</span>
<span class="nc" id="L641">			return false;</span>

		// Since we just need to find one bit on in the range, we'll
		// want the floor when computing the start
<span class="fc" id="L645">		int ix = bitIndex(start, false);</span>

		// The BitSet can tell us the index of the higest bit set, so
		// there's no need to test beyond this. When computing what the
		// index of the range end should be, we'll take the ceiling.
		// Make sure that the limit is at least as large as the start
		// Note: m_bits.length() is the index of the last set bit
<span class="fc" id="L652">		int length = m_bits.length();</span>
<span class="fc bfc" id="L653" title="All 2 branches covered.">		if (length == 0) // No overlap, if no 'on' bits in this time map</span>
<span class="fc" id="L654">			return false;</span>

<span class="fc" id="L656">		int limit = Math.min(length, bitIndex(end, true));</span>

<span class="fc" id="L658">		int nextSetBit = m_bits.nextSetBit(ix);</span>
		// // Now, run through the map. If we find one bit on in the
		// // range, return true.
		// for ( ; ix &lt; limit; ix++ ) {
		// if (m_bits.get(ix)) {
		// break;
		// }
		// }

		// For QA 38932
		// When ix ( index of startdate) is greater than the length of bitmap
		// i.e m_bits, nestSetBit method returns -1. This means no such index
		// exists
		// So this is considered as non overlap than comparing this with end
		// limit and considering as
		// overlap period
<span class="pc bpc" id="L674" title="1 of 2 branches missed.">		if (nextSetBit == -1)</span>
<span class="nc" id="L675">			return false;</span>

<span class="pc bpc" id="L677" title="1 of 2 branches missed.">		if (m_cat.isDebugEnabled())</span>
<span class="pc bpc" id="L678" title="1 of 2 branches missed.">			m_cat.debug(TOCalcUtil.dumpExitMethod(methodName, new Boolean(nextSetBit &lt; limit)));</span>
<span class="pc bpc" id="L679" title="1 of 2 branches missed.">		return (nextSetBit &lt; limit);</span>
	}

	/**
	 * Test to see that the given range is contained within a continuous block
	 * of intervals that are on. Use the inverse of this test to check to see
	 * that a given time off request choice does not cover time that has already
	 * been scheduled as time off.
	 *
	 * @param start
	 *            the beginning of the range
	 * @param end
	 *            the end of the range
	 * @return true if the range falls completely within a contiguous block of
	 *         bits turned ON in the map.
	 */
	public boolean onBitsContainRange(Date start, Date end) {
<span class="pc bpc" id="L696" title="1 of 2 branches missed.">		if (validateNonOverlap(start, end))</span>
<span class="nc" id="L697">			return false;</span>

		// if range start is before this time map's start.
<span class="pc bpc" id="L700" title="1 of 2 branches missed.">		if (start.before(m_beginning))</span>
<span class="nc" id="L701">			return false;</span>

		// if range end exceeds this bounded time map
<span class="pc bpc" id="L704" title="2 of 4 branches missed.">		if (m_ending != null &amp;&amp; end.after(m_ending))</span>
<span class="nc" id="L705">			return false;</span>

		// In this case, we want the given range to be completely contained in
		// a contiguous block of bits in the map, we'll take the ceiling of the
		// starting index
<span class="fc" id="L710">		int ix = bitIndex(start, false);</span>

		// Since the map will tell us what the higest bit set is, we can
		// check this first. If the higest bit set is less than our start,
		// then there's no point in doing the test, we can return false since
		// we know there's no contiguous block of bits that could contain our
		// range
<span class="fc" id="L717">		int limit = bitIndex(end, true);</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		if (limit &gt; m_bits.length())</span>
<span class="fc" id="L719">			return false;</span>

<span class="nc" id="L721">		int nextClearBit = m_bits.nextClearBit(ix);</span>
		// // Now run through the range, all the bits must be on in order to
		// // return true
		// for ( ; ix &lt; limit; ix++ ) {
		// if (!m_bits.get(ix)) {
		// break;
		// }
		// }

<span class="nc bnc" id="L730" title="All 2 branches missed.">		return (nextClearBit &gt;= limit);</span>
	}

	/**
	 * Checks if the specified range does not overlap the timeMap's range.
	 *
	 * @param start
	 * @param end
	 * @return
	 */
	private boolean validateNonOverlap(Date start, Date end) {
		// invalid arguments?
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">		if (start.after(end))</span>
<span class="nc" id="L743">			return true;</span>

		// is 'end' before time map start
<span class="pc bpc" id="L746" title="1 of 2 branches missed.">		if (end.before(m_beginning))</span>
<span class="nc" id="L747">			return true;</span>

		// for bounded time maps, is 'start' after time map end.
<span class="pc bpc" id="L750" title="2 of 4 branches missed.">		if (m_ending != null &amp;&amp; start.after(m_ending))</span>
<span class="nc" id="L751">			return true;</span>

<span class="fc" id="L753">		return false;</span>
	}

	/**
	 * Test to see that the given range is contained within a continuous block
	 * of intervals that are off.
	 *
	 * @param start
	 *            the beginning of the range
	 * @param end
	 *            the end of the range
	 * @return true if the range falls completely within a contiguous block of
	 *         bits turned OFF in the map.
	 */
	public boolean excludesRange(Date start, Date end) {

<span class="nc bnc" id="L769" title="All 2 branches missed.">		return !onBitsContainRange(start, end);</span>

		/*
		 * // In this case, we want the given range to be completely contained
		 * in // a contiguous block of bits in the map, we'll take the ceiling
		 * of the // starting index int ix = bitIndex(start, true);
		 *
		 * int limit = Math.max(bitIndex(end, false),ix);
		 *
		 * // Now run through the range, all the bits must be off in order to //
		 * return ture boolean result = true; for (;ix&lt;limit;ix++) { if
		 * (m_bits.get(ix)) { // found a bit that was on result = false; break;
		 * } }
		 *
		 * return result;
		 */
	}

	/**
	 * Check to see if the given date is in the range covered by the map
	 */
	public boolean inRange(Date date) {
		// if date is before timemap start
<span class="pc bpc" id="L792" title="1 of 2 branches missed.">		if (date.before(m_beginning))</span>
<span class="nc" id="L793">			return false;</span>

		// if date is after timemap end
<span class="pc bpc" id="L796" title="2 of 4 branches missed.">		if (m_ending != null &amp;&amp; date.after(m_ending))</span>
<span class="nc" id="L797">			return false;</span>

<span class="fc" id="L799">		return true;</span>
	}

	/**
	 * Clear the underlying map
	 */
	public void clear() {
<span class="fc" id="L806">		m_bits.xor(m_bits); // xclusive or with self will clear all</span>
<span class="fc" id="L807">	}</span>

	/**
	 * Ensure that both time maps have the same resolution, start and end dates. Then perform &quot;and&quot; on bits.
	 * @param timeMap
	 */
	public void and(TimeMap timeMap) {
<span class="fc" id="L814">		validateTimeMapParam(timeMap);</span>
<span class="fc" id="L815">		m_bits.and(timeMap.m_bits);</span>
<span class="fc" id="L816">	}</span>

	/**
	 * Ensure that both time maps have the same resolution, start and end dates. Then perform &quot;or&quot; on bits.
	 * @param timeMap
	 */
	public void or(TimeMap timeMap) {
<span class="nc" id="L823">		validateTimeMapParam(timeMap);</span>
<span class="nc" id="L824">		m_bits.or(timeMap.m_bits);</span>
<span class="nc" id="L825">	}</span>

	public boolean intersects(TimeMap timeMap){
<span class="nc" id="L828">		validateTimeMapParam(timeMap);</span>
<span class="nc" id="L829">		return this.m_bits.intersects(timeMap.m_bits);</span>
	}

	private void validateTimeMapParam(TimeMap timeMap){
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">		if (timeMap.m_resolution != m_resolution){</span>
<span class="nc" id="L834">			throw new IllegalArgumentException(&quot;timeMap.m_resolution != m_resolution&quot;);</span>
		}

<span class="pc bpc" id="L837" title="1 of 2 branches missed.">		if (!timeMap.m_beginning.equals(m_beginning)){</span>
<span class="nc" id="L838">			throw new IllegalArgumentException(&quot;timeMap.m_beginning != m_beginning&quot;);</span>
		}

<span class="pc bpc" id="L841" title="2 of 4 branches missed.">		if (timeMap.m_ending != null &amp;&amp; !timeMap.m_ending.equals(m_ending)){</span>
<span class="nc" id="L842">			throw new IllegalArgumentException(&quot;timeMap.m_ending null or doesn't match&quot;);</span>
		}
<span class="fc" id="L844">	}</span>

	/**
	 * Compute the beginning index into the bit map that corresponds to the
	 * given date.
	 *
	 * @param d
	 *            the date for which to compute an index
	 * @param floor
	 *            used to indicate how to handle remainders in division. If true
	 *            then fraction is discarded. If true, then result is the
	 *            ceiling after dividing. This allows the map to be used for
	 *            operations that test complete inclusion (+/- one minute) even
	 *            when the inputs are all not even.
	 */
	protected int bitIndex(Date d, boolean ceiling) {
<span class="fc" id="L860">		return bitIndex(d.getTime(), ceiling);</span>
	}

	/**
	 * Compute the beginning index into the bit map that corresponds to the
	 * given date.
	 *
	 * @param d
	 *            the date for which to compute an index passed as the raw
	 *            milliseonds in the epoch.
	 * @param floor
	 *            used to indicate how to handle remainders in division. If true
	 *            then fraction is discarded. If true, then result is the
	 *            ceiling after dividing. This allows the map to be used for
	 *            operations that test complete inclusion (+/- one minute) even
	 *            when the inputs are all not even.
	 */
	protected int bitIndex(long d, boolean ceiling) {
<span class="fc" id="L878">		TOCalcUtil.dumpEnterMethod(&quot;bitIndex&quot;, new Long(d), new Boolean(ceiling), new Long(m_beginning.getTime()));</span>

		// Date objects store their values in millisecond resolution, to
		// avoid dealing with fractional minutes, convert to minutes
		long absMinutes;
		// Compute either the floor or the ceiling
<span class="fc bfc" id="L884" title="All 2 branches covered.">		if (ceiling) {</span>
<span class="fc" id="L885">			absMinutes = (long) Math.ceil(d / (double) ONE_MINUTE);</span>
		} else {
<span class="fc" id="L887">			absMinutes = (long) Math.floor(d / (double) ONE_MINUTE);</span>
		}

		// Now compute the relative minutes into the period covered by the map
<span class="fc" id="L891">		long idxInMinutes = absMinutes - m_begMinutes;</span>

		// if negative, then the input time was out of range, throw and error
<span class="pc bpc" id="L894" title="1 of 2 branches missed.">		if (idxInMinutes &lt; 0) {</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">			TimeZone orgTZ = (m_org != null ? m_org.getTimeZone() : null);</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">			if (TOCalcUtil.isTimeDifferenceDueToDSTTransition(orgTZ, new Date(d), m_beginning)) {</span>
<span class="nc" id="L897">				idxInMinutes = 0;</span>
			} else {
<span class="nc" id="L899">				throw new IllegalArgumentException(&quot;date out of range (minutes(absMinutes - m_begMinutes) &lt; 0): d = &quot;</span>
						+ new Date(d) + &quot; m_beginning:&quot; + m_beginning + &quot;; absMinutes = &quot; + absMinutes
						+ &quot;; m_begMinutes = &quot; + m_begMinutes + &quot;; m_endMinutes = &quot; + m_endMinutes);
			}
		}
<span class="pc bpc" id="L904" title="2 of 4 branches missed.">		if (m_endMinutes &gt; 0 &amp;&amp; absMinutes &gt; m_endMinutes) {</span>
<span class="nc" id="L905">			throw new IllegalArgumentException(&quot;date out of range (absMinutes &gt; m_endMinutes): d = &quot; + d</span>
					+ &quot;; absMinutes = &quot; + absMinutes + &quot;; m_endMinutes = &quot; + m_endMinutes + &quot;; m_begMinutes = &quot;
					+ m_begMinutes);
		}

		// Now compute the index using the resolution, remember the resolution
		// is
		// in milliseconds, so it must be converted to minutes

		long bitSetIdx;
<span class="fc bfc" id="L915" title="All 2 branches covered.">		if (ceiling) {</span>
<span class="fc" id="L916">			bitSetIdx = (long) Math.ceil(idxInMinutes / (double) m_res_minutes);</span>
		} else {
<span class="fc" id="L918">			bitSetIdx = (long) Math.floor(idxInMinutes / (double) m_res_minutes);</span>
		}
		// make sure it will fit in an int, if not throw an error
<span class="pc bpc" id="L921" title="1 of 2 branches missed.">		if (bitSetIdx &gt; Integer.MAX_VALUE) {</span>
<span class="nc" id="L922">			throw new IllegalArgumentException(&quot;date too long after beginning: &quot; + d);</span>
		}
<span class="fc" id="L924">		int index = (int) bitSetIdx;</span>

<span class="fc" id="L926">		TOCalcUtil.dumpExitMethod(&quot;bitIndex&quot;, new Integer(index));</span>
<span class="fc" id="L927">		return index;</span>
	}

	public String toString() {
<span class="fc" id="L931">		StringBuffer strBuf = new StringBuffer(128);</span>
<span class="fc" id="L932">		strBuf.append(&quot;Dumping time map: range = &quot;).append(m_beginning).append(&quot; to &quot;).append(m_ending)</span>
<span class="fc" id="L933">				.append(&quot;; m_resolution = &quot;).append(m_resolution).append('\n');</span>

		// true if positioned at the first On bit or no On bit found
		// false if positioned at the first off bit or no Off bit found.
<span class="fc" id="L937">		boolean atFirstOnBit = true;</span>
<span class="fc" id="L938">		Date result = findFirstOn();</span>
<span class="fc bfc" id="L939" title="All 2 branches covered.">		while (!result.equals(NO_SUCH_TIME)) {</span>
<span class="fc bfc" id="L940" title="All 2 branches covered.">			if (atFirstOnBit) {</span>
<span class="fc" id="L941">				strBuf.append(&quot;   &quot;).append(result).append(&quot; to &quot;);</span>

<span class="fc" id="L943">				atFirstOnBit = false;</span>
<span class="fc" id="L944">				result = findNextOff(result);</span>
			} else {
				// back up one bit
<span class="fc" id="L947">				strBuf.append(new Date(result.getTime() - m_resolution)).append(&quot;\n&quot;);</span>

<span class="fc" id="L949">				atFirstOnBit = true;</span>
<span class="fc" id="L950">				result = findNextOn(result);</span>
			}
		}

		// if partial output in buffer
<span class="fc bfc" id="L955" title="All 2 branches covered.">		if (!atFirstOnBit) {</span>
<span class="fc" id="L956">			strBuf.append(m_ending).append(&quot;\n&quot;);</span>
		}

<span class="fc" id="L959">		return strBuf.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>