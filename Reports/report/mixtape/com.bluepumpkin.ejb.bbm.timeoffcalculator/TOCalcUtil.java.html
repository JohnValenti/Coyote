<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOCalcUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeoffcalculator</a> &gt; <span class="el_source">TOCalcUtil.java</span></div><h1>TOCalcUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Apr 18, 2003
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.bbm.timeoffcalculator;

import java.rmi.RemoteException;
import java.text.MessageFormat;
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.CollectionUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.verint.ejb.wfm.ITimeOffCalcUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.verint.ejb.wfm.cache.WfmCacheUtil;

/**
 * @author RRajendran
 *         &lt;p/&gt;
 *         To change this generated comment go to Window&gt;Preferences&gt;Java&gt;Code
 *         Generation&gt;Code and Comments
 */
<span class="pc bpc" id="L43" title="1 of 2 branches missed.">public class TOCalcUtil implements ITimeOffCalcUtil {</span>
<span class="fc" id="L44">	private static ResourceBundle m_ejbBundle = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE);</span>
<span class="fc" id="L45">	private static Category m_cat = Log.initCategory(TOCalcUtil.class.getName());</span>

	/**
	 * Get the current organization for an employee
	 *
	 * @param emplID
	 *            the employee id of the request to check
	 * @throws BbmFinderException
	 *             when organization id cannot be found
	 */
	public static ID getCurrentOrgIDForEmployeeID(ID emplID) throws BbmFinderException {
		// todo: should this method be static?
		// Get the current organization for the employee
<span class="fc" id="L58">		ID orgID = null;</span>
<span class="fc" id="L59">		Collection wras = null;</span>
		try {
<span class="fc" id="L61">			wras = CacheUtilBBM.getWorkResourceAssnWithTZForWRID(emplID);</span>
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">			if (!wras.isEmpty()) {</span>
				// now look for overlap with now
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">				for (Iterator it = wras.iterator(); it.hasNext();) {</span>
<span class="fc" id="L65">					WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">					if (TimePeriodUtil.overlap(wra.getStartTime(), wra.getEndTime(), new Date(), null)) {</span>
<span class="fc" id="L67">						orgID = wra.getOrganizationID();</span>
<span class="fc" id="L68">						break;</span>
					}
<span class="nc" id="L70">				}</span>
			}
<span class="nc" id="L72">		} catch (Exception e) {</span>
			// todo: log error
			// m_cat.error(emplID, e);
<span class="nc" id="L75">			throw new BbmFinderException(e);</span>
<span class="fc" id="L76">		}</span>

<span class="pc bpc" id="L78" title="3 of 6 branches missed.">		if (wras != null &amp;&amp; !wras.isEmpty() &amp;&amp; orgID == null) {</span>
<span class="nc" id="L79">			orgID = ((WorkResourceAssignment) wras.iterator().next()).getOrganizationID();</span>
		}

		// Check to see that we got an org id
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L84">			throw new BbmFinderException(BbmEjbBundleKey.TOCALC_CANNOT_FIND_ORG_FOR_EMPID, new Object[] { emplID });</span>
		}

<span class="fc" id="L87">		return orgID;</span>
	}

	public static ID getOrgIDForEmployeeID(ID emplID, Date startDate) throws BbmFinderException {
<span class="fc" id="L91">		ID orgID = null;</span>
<span class="fc" id="L92">		Collection wras = null;</span>
		try {
<span class="fc" id="L94">			wras = CacheUtilBBM.getWorkResourceAssnWithTZForWRID(emplID);</span>
<span class="pc bpc" id="L95" title="2 of 4 branches missed.">			if (wras != null &amp;&amp; !wras.isEmpty()) {</span>
<span class="pc bpc" id="L96" title="1 of 2 branches missed.">				for (Iterator it = wras.iterator(); it.hasNext();) {</span>
<span class="fc" id="L97">					WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>

<span class="pc bpc" id="L99" title="4 of 6 branches missed.">					if (startDate != null &amp;&amp; (wra.getEndTime() == null || startDate.before(wra.getEndTime()))</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">							&amp;&amp; !startDate.before(wra.getStartTime())) {</span>
<span class="fc" id="L101">						orgID = wra.getOrganizationID();</span>
<span class="fc" id="L102">						break;</span>
					}
<span class="nc" id="L104">				}</span>
			}
<span class="nc" id="L106">		} catch (Exception e) {</span>
<span class="nc" id="L107">			throw new BbmFinderException(e);</span>
<span class="fc" id="L108">		}</span>
<span class="pc bpc" id="L109" title="3 of 6 branches missed.">		if (wras != null &amp;&amp; !wras.isEmpty() &amp;&amp; orgID == null) {</span>
<span class="nc" id="L110">			orgID = ((WorkResourceAssignment) wras.iterator().next()).getOrganizationID();</span>
		}
		// Check to see that we got an org id
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">		if (orgID == null) {</span>
<span class="nc" id="L114">			throw new BbmFinderException(BbmEjbBundleKey.TOCALC_CANNOT_FIND_ORG_FOR_EMPID, new Object[] { emplID });</span>
		}
<span class="fc" id="L116">		return orgID;</span>
	}

	public static ShiftAssignment getLastShiftAssignment(ID empID, boolean fromPubSched) {
<span class="fc" id="L120">		ShiftAssignment sa = null;</span>
		try {
<span class="fc" id="L122">			sa = WfmCacheUtil.getLastShiftAssn(empID, fromPubSched);</span>
<span class="nc" id="L123">		} catch (Exception e) {</span>
<span class="nc" id="L124">			m_cat.info(TOCalcUtil.formatEjbBundleMsg(BbmEjbBundleKey.TOCALC_USING_DEFAULT_LAST_SHIFT_FOR_EMP, empID), e);</span>
<span class="fc" id="L125">		}</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">		return (sa == null) ? getDefaultLastShift() : sa;</span>
	}

	public static Map getLastShiftAssignmentsForEmpIDs(Collection empIDs, boolean fromPubSched,
			ScheduleAccessManager sam) throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException,
			RemoteException {

<span class="pc bpc" id="L133" title="1 of 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L134">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}

<span class="fc" id="L137">		HashMap empIDToLastShiftMap = null;</span>
<span class="pc bpc" id="L138" title="1 of 2 branches missed.">		if (fromPubSched) {</span>
<span class="fc" id="L139">			empIDToLastShiftMap = sam.getLastPublishedShiftAssignments(empIDs);</span>
		} else {
<span class="nc" id="L141">			empIDToLastShiftMap = sam.getLastShiftAssignments(empIDs);</span>
		}

<span class="fc" id="L144">		return empIDToLastShiftMap;</span>

	}

	/**
	 * Note: this only returns a partial ShiftAssignment object, ie. not all the
	 * fields will be initialialized
	 *
	 * @return
	 */
	public static ShiftAssignment getDefaultLastShift() {
<span class="fc" id="L155">		ShiftAssignment sa = new ShiftAssignment();</span>

<span class="fc" id="L157">		sa.setStartTime(new Date(0 + 14 * 24 * 60 * 60 * 1000L)); // 14 days</span>
																	// after
																	// Date(0),
<span class="fc" id="L160">		sa.setDuration(8 * 60); // not used, but just in case set to 8 hours.</span>
<span class="fc" id="L161">		sa.setDescription(&quot;Default last shift for timeoff length calculator&quot;);</span>

<span class="fc" id="L163">		return sa;</span>
	}

	public static String formatEjbBundleMsg(String msgKey, Object parm) {
<span class="nc" id="L167">		return MessageFormat.format(m_ejbBundle.getString(msgKey), new Object[] { parm });</span>
	}

	public static String dumpCollection(Collection c) {
<span class="nc bnc" id="L171" title="All 2 branches missed.">		if (c == null)</span>
<span class="nc" id="L172">			return &quot;null\n&quot;;</span>

<span class="nc" id="L174">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L175">		buf.append(&quot;c.size() = &quot; + c.size() + '\n');</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">		for (Iterator itr = c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L177">			buf.append(itr.next() + &quot;\n&quot;);</span>
		}

<span class="nc" id="L180">		return buf.toString();</span>
	}

	public static String dumpArray(int[] arr) {
<span class="nc bnc" id="L184" title="All 2 branches missed.">		if (arr == null)</span>
<span class="nc" id="L185">			return &quot;null\n&quot;;</span>

<span class="nc" id="L187">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L188">		buf.append(&quot;arr.length = &quot; + arr.length + '\n');</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">		for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="nc" id="L190">			buf.append(arr[i] + &quot;,&quot;);</span>
		}

<span class="nc" id="L193">		return buf.toString();</span>
	}

	public static String dumpMap(Map map) {
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">		if (map == null)</span>
<span class="nc" id="L198">			return &quot;null\n&quot;;</span>

<span class="fc" id="L200">		StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L201">		buf.append(&quot;map.size() = &quot; + map.size() + '\n');</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">		for (Iterator itr = map.keySet().iterator(); itr.hasNext();) {</span>
<span class="fc" id="L203">			Object key = itr.next();</span>
<span class="fc" id="L204">			buf.append(key + &quot; ==&gt; &quot; + map.get(key));</span>
<span class="fc" id="L205">		}</span>

<span class="fc" id="L207">		return buf.toString();</span>
	}

	public static String dumpObj(Object obj) {
<span class="fc bfc" id="L211" title="All 2 branches covered.">		if (obj == null)</span>
<span class="fc" id="L212">			return &quot;null&quot;;</span>

<span class="fc bfc" id="L214" title="All 2 branches covered.">		if (obj instanceof Collection) {</span>
<span class="fc" id="L215">			return CollectionUtil.dumpCollection((Collection) obj);</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">		} else if (obj instanceof Map) {</span>
<span class="fc" id="L217">			return dumpMap((Map) obj);</span>
		}

<span class="fc" id="L220">		return obj.toString();</span>
	}

	public static String dumpEnterMethod(String methodName) {
<span class="nc" id="L224">		return dumpEnterMethod(methodName, null);</span>
	}

	public static String dumpEnterMethod(String methodName, Object obj1) {
<span class="nc" id="L228">		return dumpEnterMethod(methodName, new Object[] { obj1 });</span>
	}

	public static String dumpEnterMethod(String methodName, Object obj1, Object obj2) {
<span class="fc" id="L232">		return dumpEnterMethod(methodName, new Object[] { obj1, obj2 });</span>
	}

	public static String dumpEnterMethod(String methodName, Object obj1, Object obj2, Object obj3) {
<span class="fc" id="L236">		return dumpEnterMethod(methodName, new Object[] { obj1, obj2, obj3 });</span>
	}

	public static String dumpEnterMethod(String methodName, Object obj1, Object obj2, Object obj3, Object obj4) {
<span class="nc" id="L240">		return dumpEnterMethod(methodName, new Object[] { obj1, obj2, obj3, obj4 });</span>
	}

	// TODO: refactor code to use dumpExitMethod()
	public static String dumpEnterMethod(String methodName, Object[] objs) {
<span class="fc" id="L245">		StringBuffer buf = new StringBuffer(&quot;ENTER: &quot;).append(methodName).append('(');</span>

<span class="pc bpc" id="L247" title="1 of 4 branches missed.">		for (int i = 0; objs != null &amp;&amp; i &lt; objs.length; i++) {</span>
<span class="fc" id="L248">			buf.append(dumpObj(objs[i])).append(',');</span>
		}

<span class="fc" id="L251">		buf.append(')');</span>

<span class="fc" id="L253">		return buf.toString();</span>
	}

	public static String dumpExitMethod(String methodName) {
<span class="nc" id="L257">		return dumpExitMethod(methodName, null);</span>
	}

	public static String dumpExitMethod(String methodName, Object obj1) {
<span class="fc" id="L261">		return dumpExitMethod(methodName, new Object[] { obj1 });</span>
	}

	public static String dumpExitMethod(String methodName, Object obj1, Object obj2) {
<span class="nc" id="L265">		return dumpExitMethod(methodName, new Object[] { obj1, obj2 });</span>
	}

	public static String dumpExitMethod(String methodName, Object obj1, Object obj2, Object obj3) {
<span class="nc" id="L269">		return dumpExitMethod(methodName, new Object[] { obj1, obj2, obj3 });</span>
	}

	public static String dumpExitMethod(String methodName, Object obj1, Object obj2, Object obj3, Object obj4) {
<span class="nc" id="L273">		return dumpExitMethod(methodName, new Object[] { obj1, obj2, obj3, obj4 });</span>
	}

	// TODO: refactor code to use dumpExitMethod()
	public static String dumpExitMethod(String methodName, Object[] objs) {
<span class="fc" id="L278">		StringBuffer buf = new StringBuffer(&quot;EXIT: &quot;).append(methodName).append('(');</span>

<span class="pc bpc" id="L280" title="1 of 4 branches missed.">		for (int i = 0; objs != null &amp;&amp; i &lt; objs.length; i++) {</span>
<span class="fc" id="L281">			buf.append(dumpObj(objs[i])).append(',');</span>
		}

<span class="fc" id="L284">		buf.append(')');</span>

<span class="fc" id="L286">		return buf.toString();</span>
	}

	public static void setCalMinsOffsetFromMidnight(Calendar cal, int dayBoundaryOffset) {
<span class="fc" id="L290">		cal.set(Calendar.HOUR_OF_DAY, dayBoundaryOffset / 60);</span>
<span class="fc" id="L291">		cal.set(Calendar.MINUTE, dayBoundaryOffset % 60);</span>
<span class="fc" id="L292">		cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L293">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L294">	}</span>

	/**
	 * Compute the next day for the given date, retaining the hour, minute and
	 * seconds. For instance, if the given date is 11:53AM 1/1/2001, this
	 * returns 11:53AM, 1/2/2001.
	 * &lt;p/&gt;
	 * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
	 * days on which the DST starts or ends. Use a calendar to handle this case.
	 *
	 * @param date
	 * @param tz
	 * @return
	 */
	public static Date getDateForwardOneDay(Date date, TimeZone tz) {
<span class="fc" id="L309">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="fc" id="L310">		cal.setTime(date);</span>
<span class="fc" id="L311">		addDaysToCalendar(cal, 1);</span>
		// cal.add(Calendar.DAY_OF_MONTH, 1); //move to next day

<span class="fc" id="L314">		return cal.getTime();</span>
	}

	/**
	 * Compute the previous day for the given date, retaining the hour, minute
	 * and seconds. For instance, if the given date is 11:53AM 1/2/2001, this
	 * returns 11:53AM, 1/1/2001.
	 * &lt;p/&gt;
	 * Simply adding 24 * 60 * 60 * 1000 to the given date will not work for
	 * days on which the DST starts or ends. Use a calendar to handle this case.
	 *
	 * @param date
	 * @param tz
	 * @return
	 */
	public static Date getDateBackwardOneDay(Date date, TimeZone tz) {
<span class="nc" id="L330">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L331">		cal.setTime(date);</span>
<span class="nc" id="L332">		addDaysToCalendar(cal, -1);</span>
		// cal.add(Calendar.DAY_OF_MONTH, 1); //move to next day

<span class="nc" id="L335">		return cal.getTime();</span>
	}

	/**
	 * Return the start of the orgDay in which the given date falls.
	 *
	 * @param orgTZ
	 * @param orgDayBoundaryOffset
	 * @param date
	 * @return
	 */
	public static Date getDateForOrgDayStart(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="fc" id="L347">		return getCalendarForOrgDayStart(orgTZ, orgDayBoundaryOffset, date).getTime();</span>
	}

	public static LocalDate getLocalDateForOrgDayStart(Organization org, Date date) {
<span class="nc" id="L351">		return new LocalDate(getCalendarForOrgDayStart(org.getTimeZone(), org.getDayBoundaryOffset(), date), true);</span>
	}

	public static Calendar getCalendarForOrgDayStart(Organization org, Date date) {
<span class="nc" id="L355">		return getCalendarForOrgDayStart(org.getTimeZone(), org.getDayBoundaryOffset(), date);</span>
	}

	public static Calendar getCalendarForOrgDayStart(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="fc" id="L359">		Calendar cal = Calendar.getInstance(orgTZ);</span>
<span class="fc" id="L360">		cal.setTime(date);</span>
<span class="fc" id="L361">		setCalMinsOffsetFromMidnight(cal, orgDayBoundaryOffset);</span>
		// if the computed org day start is after the given date
<span class="pc bpc" id="L363" title="1 of 2 branches missed.">		if (cal.getTime().after(date)) {</span>
			// back up one day
<span class="nc" id="L365">			addDaysToCalendar(cal, -1);</span>
			// cal.add(Calendar.DAY_OF_MONTH, -1);
		}
<span class="fc" id="L368">		return cal;</span>
	}

	/**
	 * Return the start of the orgDay in which the given date falls.
	 *
	 * @param org
	 * @param date
	 * @return
	 */
	public static Date getDateForOrgDayStart(Organization org, Date date) {
<span class="fc" id="L379">		return getDateForOrgDayStart(org.getTimeZone(), org.getDayBoundaryOffset(), date);</span>
	}

	@Override
	public Date getDateForOrganizationDayStart(Organization org, Date date) {
<span class="nc" id="L384">		return TOCalcUtil.getDateForOrgDayStart(org, date);</span>
	}

	/**
	 * Return the end of the org day on which the given date falls
	 *
	 * @param orgTZ
	 * @param orgDayBoundaryOffset
	 * @param date
	 * @return
	 */

	public static Date getDateForOrgDayEnd(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="fc" id="L397">		return getCalendarForOrgDayEnd(orgTZ, orgDayBoundaryOffset, date).getTime();</span>
	}

	public static Calendar getCalendarForOrgDayEnd(Organization org, Date date) {
<span class="nc" id="L401">		return getCalendarForOrgDayEnd(org.getTimeZone(), org.getDayBoundaryOffset(), date);</span>
	}

	public static LocalDate getLocalDateForOrgDayEnd(Organization org, Date date) {
<span class="nc" id="L405">		return new LocalDate(getCalendarForOrgDayEnd(org.getTimeZone(), org.getDayBoundaryOffset(), date), true);</span>
	}

	public static Calendar getCalendarForOrgDayEnd(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="fc" id="L409">		Calendar cal = getCalendarForOrgDayStart(orgTZ, orgDayBoundaryOffset, date);</span>
<span class="fc" id="L410">		addDaysToCalendar(cal, 1);</span>
		// QC53627 if input date is e.g. 2:30am when clocks move from 2am to 3am
		// at DST transition
<span class="fc" id="L413">		TOCalcUtil.setCalMinsOffsetFromMidnight(cal, orgDayBoundaryOffset);</span>
<span class="fc" id="L414">		cal.add(Calendar.MILLISECOND, -1);</span>
<span class="fc" id="L415">		return cal;</span>
	}

	public static Calendar getCalendarForOrgDayEndExclusive(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="nc" id="L419">		Calendar cal = getCalendarForOrgDayEnd(orgTZ, orgDayBoundaryOffset, date);</span>
<span class="nc" id="L420">		cal.add(Calendar.MILLISECOND, 1);</span>
<span class="nc" id="L421">		return cal;</span>
	}

	public static Date getDateForOrgDayEndExclusive(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="nc" id="L425">		Calendar cal = getCalendarForOrgDayEndExclusive(orgTZ, orgDayBoundaryOffset, date);</span>
<span class="nc" id="L426">		return cal.getTime();</span>
	}

	/**
	 * Return the end of the org day on which the given date falls.
	 *
	 * @param org
	 * @param date
	 * @return
	 */
	public static Date getDateForOrgDayEnd(Organization org, Date date) {
<span class="fc" id="L437">		return TOCalcUtil.getDateForOrgDayEnd(org.getTimeZone(), org.getDayBoundaryOffset(), date);</span>
	}

	@Override
	public Date getDateForOrganizationDayEnd(Organization org, Date date) {
<span class="nc" id="L442">		return TOCalcUtil.getDateForOrgDayEnd(org, date);</span>
	}

	public static Date getDateForOrgWeekStart(Organization org, Date date) {
<span class="fc" id="L446">		Calendar calInOrgTZ = Calendar.getInstance(org.getTimeZone());</span>
<span class="fc" id="L447">		calInOrgTZ.setTime(date);</span>
		// todo: what is the range of getWeekStartDate(); range of
		// Calendar.day_0f_week;
<span class="fc" id="L450">		calInOrgTZ.set(Calendar.DAY_OF_WEEK, org.getWeekStartDate());</span>
<span class="fc" id="L451">		TOCalcUtil.setCalMinsOffsetFromMidnight(calInOrgTZ, org.getDayBoundaryOffset());</span>

		// if the computed org week start is after the given date
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">		if (calInOrgTZ.getTime().after(date)) {</span>
			// back up a week
<span class="nc" id="L456">			addDaysToCalendar(calInOrgTZ, -7);</span>
			// calInOrgTZ.add(Calendar.DAY_OF_MONTH, -7);
		}

<span class="fc" id="L460">		return calInOrgTZ.getTime();</span>
	}

	public static Date getDateForOrgWeekEnd(Organization org, Date date) {
<span class="fc" id="L464">		Calendar cal = Calendar.getInstance(org.getTimeZone());</span>
<span class="fc" id="L465">		cal.setTime(getDateForOrgWeekStart(org, date));</span>
<span class="fc" id="L466">		addDaysToCalendar(cal, 7);</span>
		// cal.add(Calendar.DAY_OF_MONTH, 7);
<span class="fc" id="L468">		cal.add(Calendar.MILLISECOND, -1);</span>

<span class="fc" id="L470">		return cal.getTime();</span>
	}

	/**
	 * Check if the given date is between the specified range, inclusive of the
	 * range boundaries.
	 *
	 * @param givenDate
	 * @param rangeStart
	 * @param rangeEnd
	 * @return
	 */
	public static boolean dateBetween(Date givenDate, Date rangeStart, Date rangeEnd) {
<span class="fc" id="L483">		long givenDateTime = givenDate.getTime();</span>

<span class="pc bpc" id="L485" title="1 of 4 branches missed.">		return (givenDateTime &gt;= rangeStart.getTime() &amp;&amp; givenDateTime &lt;= rangeEnd.getTime());</span>
	}

	/**
	 * Adjust the given time back by a millisecond if necessary.
	 * &lt;p/&gt;
	 * 1. n For example if a shift assignment ends at a multiple of a minute,
	 * adjust the end time back by one millisecond. if the SA is between
	 * 10:00:00.000 and 11:00:00.000 then the timemap must represent this as the
	 * range 10:00 and 10:59 instead of the range 10:00 and 11:00. This will
	 * make the the timeMap.countBitsOn() method to work correctly and count the
	 * range as 60 minutes instead of 61 minutes.
	 *
	 * @param timeInMs
	 * @param resolution
	 * @return
	 */
	public static long adjustTimeUsingResolution(long timeInMs, long resolution) {
		// if the given time is an exact multiple of the time map resolution,
		// decrement a millisecond.
<span class="fc bfc" id="L505" title="All 2 branches covered.">		return ((timeInMs % resolution) == 0) ? (timeInMs - 1) : timeInMs;</span>
	}

	/**
	 * @param date
	 * @param resolution
	 * @return
	 */
	public static Date adjustDateUsingResolution(Date date, long resolution) {
<span class="fc" id="L514">		long origTimeInMs = date.getTime();</span>
<span class="fc" id="L515">		long adjTimeInMs = TOCalcUtil.adjustTimeUsingResolution(origTimeInMs, resolution);</span>

<span class="pc bpc" id="L517" title="1 of 2 branches missed.">		return (origTimeInMs == adjTimeInMs) ? date : new Date(adjTimeInMs);</span>
	}

	/**
	 * @param pubShiftAssnEvtsForEmps
	 * @param empIDToShiftAssnsPubMap
	 * @param empIDTimeOffPubMap
	 */
	public static void segregateBulkLoadedEvts(Collection empIDs, Collection pubShiftAssnEvtsForEmps,
			Map empIDToShiftAssnsPubMap, Map empIDTimeOffPubMap) {

<span class="fc" id="L528">		Iterator evtsCollIter = pubShiftAssnEvtsForEmps.iterator();</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">		for (Iterator empIDIter = empIDs.iterator(); empIDIter.hasNext();) {</span>
<span class="fc" id="L530">			ID empIDCurr = (ID) empIDIter.next();</span>
<span class="fc" id="L531">			Collection eventsForEmp = (Collection) evtsCollIter.next();</span>

			// if no events were found for current employee
<span class="pc bpc" id="L534" title="1 of 2 branches missed.">			if (eventsForEmp == null) {</span>
				// map emp ID to empty list.

<span class="nc" id="L537">				empIDToShiftAssnsPubMap.put(empIDCurr, Collections.EMPTY_LIST);</span>
<span class="nc" id="L538">				empIDTimeOffPubMap.put(empIDCurr, Collections.EMPTY_LIST);</span>
<span class="nc" id="L539">				continue;</span>
			}

<span class="fc" id="L542">			Collection saCollForCurrEmp = new ArrayList(16);</span>
<span class="fc" id="L543">			Collection toCollForCurrEmp = new ArrayList(16);</span>

<span class="fc" id="L545">			segregateBulkLoadedEvts(eventsForEmp, saCollForCurrEmp, toCollForCurrEmp);</span>
			// add collections to map.

<span class="fc" id="L548">			empIDToShiftAssnsPubMap.put(empIDCurr, saCollForCurrEmp);</span>
<span class="fc" id="L549">			empIDTimeOffPubMap.put(empIDCurr, toCollForCurrEmp);</span>

<span class="fc" id="L551">		}</span>
<span class="fc" id="L552">	}</span>

	public static void segregateBulkLoadedEvts(Collection pubShiftAssnEvts, Collection saColl, Collection toColl) {
		// for each event found
<span class="fc bfc" id="L556" title="All 2 branches covered.">		for (Iterator evtsIter = pubShiftAssnEvts.iterator(); evtsIter.hasNext();) {</span>
			// get event.
<span class="fc" id="L558">			Event evtForCurrEmp = (Event) evtsIter.next();</span>

			// add to the proper collection.
<span class="fc bfc" id="L561" title="All 2 branches covered.">			if (evtForCurrEmp.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>

<span class="fc" id="L563">				saColl.add(evtForCurrEmp);</span>
<span class="pc bpc" id="L564" title="1 of 2 branches missed.">			} else if (evtForCurrEmp.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="fc" id="L565">				toColl.add(evtForCurrEmp);</span>
			} else {
<span class="nc bnc" id="L567" title="All 2 branches missed.">				assert false : &quot;Unexpected event type: ID, type: &quot; + evtForCurrEmp.getID() + ','</span>
<span class="nc" id="L568">						+ evtForCurrEmp.getEventType();</span>
			}
<span class="fc" id="L570">		}</span>

<span class="fc" id="L572">		return;</span>
	}

	/**
	 * @param empIDs
	 * @param unavailEvtsForEmps
	 * @param empIDToUnavailsMap
	 */
	public static void createUnavailsMap(Collection empIDs, Collection unavailEvtsForEmps, Map empIDToUnavailsMap) {

<span class="fc" id="L582">		Iterator evtsCollIter = unavailEvtsForEmps.iterator();</span>
<span class="fc bfc" id="L583" title="All 2 branches covered.">		for (Iterator empIDIter = empIDs.iterator(); empIDIter.hasNext();) {</span>
<span class="fc" id="L584">			ID empIDCurr = (ID) empIDIter.next();</span>
<span class="fc" id="L585">			Collection eventsForEmp = (Collection) evtsCollIter.next();</span>

			// if no events were found for current employee
<span class="fc bfc" id="L588" title="All 2 branches covered.">			if (eventsForEmp == null) {</span>
				// map emp ID to empty list.
<span class="fc" id="L590">				empIDToUnavailsMap.put(empIDCurr, Collections.EMPTY_LIST);</span>
<span class="fc" id="L591">				continue;</span>
			}

<span class="fc" id="L594">			Collection unavailsCollForCurrEmp = null;</span>

			// for each event found for the current employee
<span class="pc bpc" id="L597" title="1 of 2 branches missed.">			for (Iterator evtsIter = eventsForEmp.iterator(); evtsIter.hasNext();) {</span>
				// get event.
<span class="nc" id="L599">				Event evtForCurrEmp = (Event) evtsIter.next();</span>

				// add to the proper collection.
<span class="nc bnc" id="L602" title="All 2 branches missed.">				if (evtForCurrEmp.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc bnc" id="L603" title="All 2 branches missed.">					unavailsCollForCurrEmp = (unavailsCollForCurrEmp == null) ? new ArrayList(16)</span>
							: unavailsCollForCurrEmp;
<span class="nc" id="L605">					unavailsCollForCurrEmp.add(evtForCurrEmp);</span>
				} else {
<span class="nc bnc" id="L607" title="All 2 branches missed.">					assert false : &quot;Unexpected event type: ID, type: &quot; + evtForCurrEmp.getID() + ','</span>
<span class="nc" id="L608">							+ evtForCurrEmp.getEventType();</span>
				}
<span class="nc" id="L610">			}</span>

			// add collections to map.
<span class="pc bpc" id="L613" title="1 of 2 branches missed.">			unavailsCollForCurrEmp = (unavailsCollForCurrEmp == null) ? Collections.EMPTY_LIST : unavailsCollForCurrEmp;</span>
<span class="fc" id="L614">			empIDToUnavailsMap.put(empIDCurr, unavailsCollForCurrEmp);</span>
<span class="fc" id="L615">		}</span>
<span class="fc" id="L616">	}</span>

	public static void createUnavailsColl(Collection unavailEvts, Collection unavailsColl) {
		// for each event found
<span class="nc bnc" id="L620" title="All 2 branches missed.">		for (Iterator evtsIter = unavailEvts.iterator(); evtsIter.hasNext();) {</span>

			// get event.
<span class="nc" id="L623">			Event evtForCurrEmp = (Event) evtsIter.next();</span>

			// add to the proper collection.
<span class="nc bnc" id="L626" title="All 2 branches missed.">			if (evtForCurrEmp.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc" id="L627">				unavailsColl.add(evtForCurrEmp);</span>

			} else {
<span class="nc bnc" id="L630" title="All 2 branches missed.">				assert false : &quot;Unexpected event type: ID, type: &quot; + evtForCurrEmp.getID() + ','</span>
<span class="nc" id="L631">						+ evtForCurrEmp.getEventType();</span>
			}
<span class="nc" id="L633">		}</span>

<span class="nc" id="L635">		return;</span>
	}

	// check if the DST transition time falls between start and end date &amp; check
	// if the differnce is not more than an hours.
	// If yes then return true;
	// **************CAUTION: this method should be used only for DST
	// adjustments where the dates need to be wolled up or down
	// should never be used to check if two dates have a DST in between.
	// ***************CAUTION

	public static boolean isTimeDifferenceDueToDSTTransition(TimeZone tz, Date start, Date end) {
<span class="nc" id="L647">		boolean returnVal = false;</span>
<span class="nc bnc" id="L648" title="All 4 branches missed.">		if (tz != null &amp;&amp; tz.inDaylightTime(start) != tz.inDaylightTime(end)) {</span>
<span class="nc" id="L649">			long timeDiff = start.getTime() - end.getTime();</span>
<span class="nc" id="L650">			m_cat.debug(&quot;timeDiff=&quot; + timeDiff + &quot; Milli Secs; start=&quot; + start + &quot;: end=&quot; + end);</span>
			// This confirms that the time difference is defintely not due to
			// DST.
<span class="nc bnc" id="L653" title="All 2 branches missed.">			returnVal = (Math.abs(timeDiff) &lt;= TimeZoneUtil.HOUR_IN_MILLISECONDS);// this</span>
																					// takes
																					// care
																					// of
																					// negative
																					// as
																					// well
		}
<span class="nc" id="L661">		return returnVal;</span>
	}

	// because of BUG in JROCKIT JVM 1.4_05 bug on DST transition for brazil
	// use this function to move to the next day for the calendar
	public static void addDaysToCalendar(Calendar cal, int days) {
<span class="fc" id="L667">		cal.set(Calendar.DAY_OF_MONTH, cal.get(Calendar.DAY_OF_MONTH) + days);</span>
<span class="fc" id="L668">	}</span>

	public static Organization getOrganizationForEmployee(ID empId, Date rangeStart, Date rangeEnd)
			throws BbmFinderException {
		try {
<span class="nc" id="L673">			WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L674">			ID orgId = Organization.ROOT_ORG_ID_OBJ;</span>
<span class="nc" id="L675">			Map wrOrgMap = wrm.getValidWorkResourceAssignments(Collections.singleton(empId), new LocalDate(rangeStart),</span>
					new LocalDate(rangeEnd), false);
<span class="nc" id="L677">			Collection wrOrg = (Collection) wrOrgMap.get(empId);</span>
<span class="nc bnc" id="L678" title="All 4 branches missed.">			if (wrOrg != null &amp;&amp; !wrOrg.isEmpty()) {</span>
<span class="nc" id="L679">				WorkResourceAssignment wra = (WorkResourceAssignment) wrOrg.iterator().next();</span>
<span class="nc" id="L680">				orgId = wra.getOrganizationID();</span>
			}
<span class="nc" id="L682">			return CacheUtilBBM.getOrganizationByID(orgId);</span>
<span class="nc" id="L683">		} catch (Exception e) {</span>
<span class="nc" id="L684">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Dump the collections's size and each element in the collection. dump of
	 * each entry is delimited with a newline.
	 * 
	 * @param c
	 * @return
	 */
	public static String dumpCollection(Collection c, String seperationStr) {
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (c == null)</span>
<span class="nc" id="L697">			return &quot;null\n&quot;;</span>
<span class="nc" id="L698">		StringBuffer buf = new StringBuffer();</span>
<span class="nc" id="L699">		buf.append(&quot;c.size() = &quot; + c.size() + '\n');</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">		for (Iterator itr = c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L701">			buf.append(itr.next() + seperationStr);</span>
		}
<span class="nc" id="L703">		return buf.toString();</span>
	}

	// method returns organization time range on a particular day
	// QC106371 changes
	public static TimeRange getTimeRangeForOrgDay(TimeZone orgTZ, int orgDayBoundaryOffset, Date date) {
<span class="fc" id="L709">		Calendar cal = Calendar.getInstance(orgTZ);</span>
<span class="fc" id="L710">		cal.setTime(date);</span>
<span class="fc" id="L711">		setCalMinsOffsetFromMidnight(cal, orgDayBoundaryOffset);</span>
<span class="fc" id="L712">		Date bStartDate = cal.getTime();</span>
<span class="fc" id="L713">		addDaysToCalendar(cal, 1);</span>
<span class="fc" id="L714">		cal.add(Calendar.MILLISECOND, -1);</span>
<span class="fc" id="L715">		Date bEndDate = cal.getTime();</span>
<span class="fc" id="L716">		TimeRange range = new TimeRange(bStartDate, bEndDate);</span>
<span class="fc" id="L717">		return range;</span>
	}

	/**
	 * Gets the organization's month range (end is exclusive).
	 */
	public static TimeRange getMonthTimeRange(Date date, TimeZone timeZone, int orgDayBoundaryOffset) {
<span class="nc" id="L724">		Calendar cal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L725">		cal.setTime(date);</span>
<span class="nc" id="L726">		cal.set(Calendar.DATE, 1);</span>
<span class="nc" id="L727">		TOCalcUtil.setCalMinsOffsetFromMidnight(cal, orgDayBoundaryOffset);</span>
<span class="nc" id="L728">		Date monthStart = cal.getTime();</span>

<span class="nc" id="L730">		cal.add(Calendar.MONTH, 1);</span>
<span class="nc" id="L731">		Date monthEnd = cal.getTime();</span>
<span class="nc" id="L732">		TOCalcUtil.setCalMinsOffsetFromMidnight(cal, orgDayBoundaryOffset);</span>

<span class="nc" id="L734">		return new TimeRange(monthStart, monthEnd);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>