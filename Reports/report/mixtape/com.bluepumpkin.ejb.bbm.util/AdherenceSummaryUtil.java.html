<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AdherenceSummaryUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.util</a> &gt; <span class="el_source">AdherenceSummaryUtil.java</span></div><h1>AdherenceSummaryUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.util;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.HashMap;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.RTAAException;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeTrackingEvent;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.ActivityMapping;
import com.bluepumpkin.common.datatypes.ID;

/**
 * Helper methods for the Quick View Adherence Day Summary and My Adherence
 * Summary Table.
 * 
 * @author GQuintanar 10/06/08
 */
<span class="nc" id="L25">public class AdherenceSummaryUtil {</span>
<span class="nc" id="L26">	public static final ID NO_ACTIVITY_ID = new ID(Activity.NO_ACTIVITY);</span>

	/**
	 * Adjust Calendar to Day Start
	 */
	public static void adjustToDayStart(Calendar aCal) {
<span class="nc" id="L32">		aCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L33">		aCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L34">		aCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L35">		aCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L36">	}</span>

	/**
	 * Adjust Calendar to Day End at 23:59:59
	 * 
	 * @param includeNextDayStart
	 *            : If you want to include midnight of the next day, pass true.
	 */
	public static void adjustToDayEnd(Calendar aCal, boolean includeNextDayStart) {
<span class="nc bnc" id="L45" title="All 2 branches missed.">		if (includeNextDayStart) {</span>
<span class="nc" id="L46">			aCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L47">			aCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L48">			aCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L49">			aCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L50">			aCal.add(Calendar.DATE, 1);</span>
		} else {
<span class="nc" id="L52">			aCal.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L53">			aCal.set(Calendar.MINUTE, 59);</span>
<span class="nc" id="L54">			aCal.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L55">			aCal.set(Calendar.MILLISECOND, 0);</span>
		}
<span class="nc" id="L57">	}</span>

	/**
	 * Get Event start time.
	 * 
	 * @param obj
	 *            - An object of type SimpleEvent, RTAAEXCeption, or
	 *            TimeTrackingEvent.
	 * @return start date for the event.
	 */
	public static Date getEventStartTime(Object obj) {
<span class="nc bnc" id="L68" title="All 2 branches missed.">		if (obj instanceof SimpleEvent) {</span>
<span class="nc" id="L69">			return ((SimpleEvent) obj).getStartTime();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		} else if (obj instanceof RTAAException) {</span>
<span class="nc" id="L71">			return ((RTAAException) obj).getStartTime();</span>
<span class="nc bnc" id="L72" title="All 2 branches missed.">		} else if (obj instanceof TimeTrackingEvent) {</span>
<span class="nc" id="L73">			return ((TimeTrackingEvent) obj).getStartTime();</span>
		}
<span class="nc" id="L75">		return null;</span>
	}

	/**
	 * Get Event end time.
	 * 
	 * @param obj
	 *            - An object of type SimpleEvent, RTAAEXCeption, or
	 *            TimeTrackingEvent.
	 * @return end date for the event.
	 */
	public static Date getEventEndTime(Object obj) {
<span class="nc bnc" id="L87" title="All 2 branches missed.">		if (obj instanceof SimpleEvent) {</span>
<span class="nc" id="L88">			return ((SimpleEvent) obj).getEndTime();</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		} else if (obj instanceof RTAAException) {</span>
<span class="nc" id="L90">			return ((RTAAException) obj).getEndTime();</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">		} else if (obj instanceof TimeTrackingEvent) {</span>
<span class="nc" id="L92">			return ((TimeTrackingEvent) obj).getEndTime();</span>
		}
<span class="nc" id="L94">		return null;</span>
	}

	/**
	 * Get the number of milliseconds of Adherence Exceptions during In-Office
	 * Hours for one exception.
	 * 
	 * @param validPlannedRanges
	 *            The scheduled events
	 * @param exceptRange
	 *            The time range of an unapproved exception during in-office
	 *            hours
	 */
	public static int getRestrictedExceptionTime(Collection validPlannedRanges, TimeRange exceptRange) {
<span class="nc" id="L108">		int exceptions = 0;</span>

<span class="nc bnc" id="L110" title="All 4 branches missed.">		if (validPlannedRanges != null &amp;&amp; !validPlannedRanges.isEmpty()) {</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">			for (Iterator i = validPlannedRanges.iterator(); i.hasNext();) {</span>
<span class="nc" id="L112">				TimeRange schedRange = (TimeRange) i.next();</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">				if (schedRange != null) {</span>
<span class="nc" id="L114">					exceptions += exceptRange.getOverlapDuration(schedRange);</span>
				}
<span class="nc" id="L116">			}</span>
		}
<span class="nc" id="L118">		return exceptions;</span>
	}

	/**
	 * Calculae the percentage of time adhering.
	 * 
	 * @param scheduled
	 *            - the scheduled time
	 * @param exceptions
	 *            - the unapproved exception time
	 * @return the percentage of time adhering. If scheduled is 0, then we
	 *         return -1.0, which means Not Applicable.
	 */
	public static float getPercentage(long scheduled, long exceptions) {
<span class="nc" id="L132">		float percentage = 0.0f;</span>
<span class="nc bnc" id="L133" title="All 2 branches missed.">		if (scheduled == 0) {</span>
<span class="nc" id="L134">			percentage = -1.0f;</span>
		} else {
<span class="nc" id="L136">			percentage = 1.0f - ((exceptions * 1.0f) / scheduled);</span>
		}

<span class="nc" id="L139">		return percentage;</span>
	}

	/**
	 * Calculate the columns of data for the Summary Table, and store the data
	 * in m_adherenceSummaryData.
	 * 
	 * @param hmActivityMappings
	 *            - HashMap of all ActivityMappings for this set of data.
	 * @return an int array containing: [0] : approved milliseconds [1] :
	 *         unapproved milliseconds [2] : scheduled milliseconds [3] :
	 *         exceptions milliseconds
	 */
	public static int[] calculateDaySummaryData(CalendarRange aDay, Collection plannedEvents,
			Collection rtaaExceptions, HashMap hmActivityMappings) {
<span class="nc" id="L154">		int approved = 0;</span>
<span class="nc" id="L155">		int unapproved = 0;</span>
<span class="nc" id="L156">		int scheduled = 0;</span>
<span class="nc" id="L157">		int exceptions = 0;</span>

<span class="nc" id="L159">		ArrayList validPlannedRanges = new ArrayList();</span>
<span class="nc" id="L160">		Date end = aDay.getEndDate();</span>

<span class="nc bnc" id="L162" title="All 4 branches missed.">		if (plannedEvents != null &amp;&amp; !plannedEvents.isEmpty()) {</span>
<span class="nc" id="L163">			boolean endFound = false;</span>

<span class="nc bnc" id="L165" title="All 2 branches missed.">			for (Iterator i = plannedEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L166">				SimpleEvent event = (SimpleEvent) i.next();</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">				if (event != null) {</span>
<span class="nc" id="L168">					TimeRange eventRange = new TimeRange(AdherenceSummaryUtil.getEventStartTime(event),</span>
<span class="nc" id="L169">							AdherenceSummaryUtil.getEventEndTime(event));</span>

<span class="nc bnc" id="L171" title="All 2 branches missed.">					if (eventRange.includes(end)) {</span>
						// we only count scheduled minutes up to end of date range
<span class="nc" id="L173">						eventRange.setEndDate(end); </span>
<span class="nc" id="L174">						endFound = true;</span>
					}

<span class="nc bnc" id="L177" title="All 2 branches missed.">					if (!aDay.getStartDate().after(eventRange.getStartDate())</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">							&amp;&amp; !aDay.getEndDate().before(eventRange.getEndDate())</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">							&amp;&amp; event.getActivityID().toInt() != Activity.NO_ACTIVITY</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">							&amp;&amp; event.getActivityID().toInt() != Activity.ACTIVITY_DELETED.toInt()</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">							&amp;&amp; !isNoActivity(event.getActivityID(), hmActivityMappings)) {</span>
<span class="nc" id="L182">						scheduled += eventRange.getDurationMsec();</span>
<span class="nc" id="L183">						validPlannedRanges.add(eventRange);</span>
					}
<span class="nc bnc" id="L185" title="All 2 branches missed.">					if (endFound) {</span>
						// We are assuming events are in chronological order!
<span class="nc" id="L187">						break; </span>
					}
				}
<span class="nc" id="L190">			}</span>
		}

<span class="nc bnc" id="L193" title="All 4 branches missed.">		if (rtaaExceptions != null &amp;&amp; !rtaaExceptions.isEmpty()) {</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">			for (Iterator i = rtaaExceptions.iterator(); i.hasNext();) {</span>
<span class="nc" id="L195">				RTAAException event = (RTAAException) i.next();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">				if (event != null) {</span>
<span class="nc" id="L197">					TimeRange eventRange = new TimeRange(AdherenceSummaryUtil.getEventStartTime(event),</span>
<span class="nc" id="L198">							AdherenceSummaryUtil.getEventEndTime(event));</span>

<span class="nc bnc" id="L200" title="All 2 branches missed.">					if (!aDay.getStartDate().after(eventRange.getStartDate())</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">							&amp;&amp; !aDay.getEndDate().before(eventRange.getEndDate())</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">							&amp;&amp; event.getPlannedActivityID().toInt() != Activity.ACTIVITY_DELETED.toInt()) {</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">						if (event.isApproved()) {</span>
<span class="nc" id="L204">							approved += eventRange.getDurationMsec();</span>
						} else {
<span class="nc" id="L206">							unapproved += eventRange.getDurationMsec();</span>
<span class="nc" id="L207">							exceptions += AdherenceSummaryUtil.getRestrictedExceptionTime(validPlannedRanges,</span>
									eventRange);
						}
					}
				}
<span class="nc" id="L212">			}</span>
		}
<span class="nc" id="L214">		return new int[] { approved, unapproved, scheduled, exceptions };</span>
	}

	/**
	 * Given a number of milliseconds such as 4020000, get the number of whole
	 * minutes, rounded up if seconds &gt;= 30. The milliseconds are also rounded
	 * up if &gt;= 500.
	 * 
	 * @param duration
	 *            a number of milliseconds such as 4020000.
	 */
	public static int getRoundedMinutes(int duration) {
<span class="nc" id="L226">		int hh = duration / (1000 * 60 * 60);</span>
<span class="nc" id="L227">		int mm = (duration % (1000 * 60 * 60)) / (1000 * 60);</span>
<span class="nc" id="L228">		int ss = (duration - (((hh * 60) + mm) * 60 * 1000)) / 1000;</span>
<span class="nc" id="L229">		int ms = (duration - (((hh * 60) + mm) * 60 * 1000)) % 1000;</span>

		// round up to the nearest second and minute
<span class="nc bnc" id="L232" title="All 2 branches missed.">		if (ms &gt;= 500) {</span>
<span class="nc" id="L233">			ms = 0;</span>
<span class="nc" id="L234">			ss++;</span>
		}
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (ss &gt;= 30) {</span>
<span class="nc" id="L237">			ss = 0;</span>
<span class="nc" id="L238">			mm++;</span>
		}
<span class="nc" id="L240">		return (hh * 60) + mm;</span>
	}

	/**
	 * Given a number of milliseconds such as 4020000, get the number of whole
	 * seconds, rounded up if milliseconds &gt;= 500.
	 * 
	 * @param duration
	 *            a number of milliseconds such as 4020000.
	 */
	// Changing input param to long from int for QA-96175 to avoid int overflow
	// issue. Also added casting to calculate hour, min, ..
	public static int getRoundedSeconds(long duration) {
<span class="nc" id="L253">		int hh = (int) (duration / (1000 * 60 * 60));</span>
<span class="nc" id="L254">		int mm = (int) ((duration % (1000 * 60 * 60)) / (1000 * 60));</span>
		// Changed for QA98409 Type cast operation to lang
<span class="nc" id="L256">		int ss = (int) ((duration - ((long) ((hh * 60) + mm) * 60 * 1000)) / 1000);</span>
		// Changed for QA98409 Type cast operation to lang
<span class="nc" id="L258">		int ms = (int) ((duration - ((long) ((hh * 60) + mm) * 60 * 1000)) % 1000);</span>

		// round up to the nearest second and minute
<span class="nc bnc" id="L261" title="All 2 branches missed.">		if (ms &gt;= 500) {</span>
<span class="nc" id="L262">			ms = 0;</span>
<span class="nc" id="L263">			ss++;</span>
		}
<span class="nc" id="L265">		return (hh * 60 * 60) + (mm * 60) + ss;</span>
	}

	/**
	 * Given an integer, return a 2-or-more digit string for it. for axample,
	 * given 1, return &quot;01&quot;. Given 111, return &quot;111&quot;.
	 */
	public static String padInt(int num) {
<span class="nc bnc" id="L273" title="All 2 branches missed.">		if (num &lt; 10) {</span>
<span class="nc" id="L274">			return &quot;0&quot; + num;</span>
		}
<span class="nc" id="L276">		return &quot;&quot; + num;</span>
	}

	/**
	 * Determine whether the specified activity is mapped to &quot;No Activity&quot;.
	 * 
	 * @param hmActivityMappings
	 * @return true if the specified activity is mapped to &quot;No Activity&quot;, false
	 *         otherwise.
	 */
	public static boolean isNoActivity(ID activityID, HashMap hmActivityMappings) {
<span class="nc bnc" id="L287" title="All 4 branches missed.">		if (activityID == null || hmActivityMappings == null) {</span>
<span class="nc" id="L288">			return false;</span>
		}

		// first, check the activities mapped to activityID
<span class="nc" id="L292">		ActivityMapping activityMapping = (ActivityMapping) hmActivityMappings.get(activityID);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">		if (activityMapping != null) {</span>
<span class="nc" id="L294">			Collection mappedActivities = activityMapping.getMappedActivityIDs();</span>
<span class="nc bnc" id="L295" title="All 4 branches missed.">			if (mappedActivities != null &amp;&amp; mappedActivities.contains(NO_ACTIVITY_ID)) {</span>
<span class="nc" id="L296">				return true;</span>
			}
		}

<span class="nc" id="L300">		return false;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>