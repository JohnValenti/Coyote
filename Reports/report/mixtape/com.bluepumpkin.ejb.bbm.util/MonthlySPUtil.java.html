<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>MonthlySPUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.util</a> &gt; <span class="el_source">MonthlySPUtil.java</span></div><h1>MonthlySPUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.util;

import java.util.Calendar;
import java.util.Date;
import java.util.HashSet;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.util.TimeZoneUtil;

public class MonthlySPUtil {

<span class="nc" id="L13">	private MonthlySPUtil() {</span>
		// private constructor to hide the implicit public one.
<span class="nc" id="L15">	}</span>

	/**
	 * Returns day of week given minute offset from 12AM Sunday (like
	 * Calendar.SUNDAY for 0, Calendar.MONDAY for 1440).
	 *
	 * @param weekStart minute offset from 12AM Sunday
	 * @return day of week (Calendar.SUNDAY, Calendar.MONDAY etc.)
	 */
	public static int getWeekStartDay(int weekStart) {
<span class="nc" id="L25">		return (weekStart / TimeZoneUtil.DAY_IN_MINUTES) % 7 + 1;</span>
	}

	/**
	 * Returns the number of days from given date (and given time zone) to
	 * the nearest previous week start date (which must be different to the
	 * current date). The return value will be less than 7 (for partial
	 * weeks) or 7 (for full weeks) or 0 (if given date is SP start date).
	 *
	 * @param tz time zone for the provided date
	 * @param currentDate the date to calculate from
	 * @param weekStartDay day of the week that week starts from
	 * @param spStart SP's start date
	 * @return number of days from current date to the nearest previous week start date (must be different to the current date)
	 */
	public static int getNumOfDaysToWeekStartDate(TimeZone tz, Date currentDate, int weekStartDay, Date spStart) {
<span class="nc" id="L41">		int result = 0;</span>
<span class="nc" id="L42">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L43">		cal.setTime(currentDate);</span>

<span class="nc bnc" id="L45" title="All 2 branches missed.">		while (cal.getTime().after(spStart)) {</span>
<span class="nc bnc" id="L46" title="All 4 branches missed.">			if (!cal.getTime().equals(currentDate) &amp;&amp; (cal.get(Calendar.DAY_OF_WEEK) == weekStartDay)) {</span>
<span class="nc" id="L47">				break;</span>
			}

<span class="nc" id="L50">			result++;</span>
<span class="nc" id="L51">			cal.setTime(currentDate);</span>
<span class="nc" id="L52">			cal.add(Calendar.DATE, -result);</span>
		}

<span class="nc bnc" id="L55" title="All 2 branches missed.">		if (cal.getTime().before(spStart)) {</span>
			//you have gone too far (DST bug QC#168139)
<span class="nc" id="L57">			result--;</span>
		}

<span class="nc" id="L60">		return result;</span>
	}

	/**
	 * Returns the number of days from given date (and given time zone) to
	 * the nearest week end date (which must be different to the current
	 * date - unless current date is SP end date). The return value will be
	 * less than 7 (for partial weeks) or 7 (for full weeks) or 0 (if given
	 * date is SP end date).
	 *
	 * @param tz time zone for the provided date
	 * @param currentDate the date to calculate from
	 * @param weekStartDay day of the week that week starts from
	 * @param spEnd SP's end date
	 * @return number of days from current date to the nearest week end date
	 */
	public static int getNumOfDaysToWeekEndDate(TimeZone tz, Date currentDate, int weekStartDay, Date spEnd) {
		int result;
<span class="nc" id="L78">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc bnc" id="L80" title="All 2 branches missed.">		for (result = 0, cal.setTime(currentDate); cal.getTime().before(spEnd); result++, cal.setTime(currentDate), cal.add(Calendar.DATE, result)) {</span>
<span class="nc bnc" id="L81" title="All 4 branches missed.">			if (!cal.getTime().equals(currentDate) &amp;&amp; (cal.get(Calendar.DAY_OF_WEEK) == weekStartDay)) {</span>
<span class="nc" id="L82">				break;</span>
			}
		}

<span class="nc" id="L86">		return result;</span>
	}

	/**
	 * Returns the week end date for given date (in given time zone). The
	 * week end date will be the next week start date or SP end date
	 * (whichever comes first). It must be different to the given date
	 * (unless the given date is SP end date).
	 *
	 * @param tz time zone for the provided date
	 * @param currentDate the date to calculate from
	 * @param weekStartDay day of the week that week starts from
	 * @param spEnd SP's end date
	 * @return Returns the week end date for given date
	 */
	public static Date getWeekEndDate(TimeZone tz, Date currentDate, int weekStartDay, Date spEnd) {
		Date sourceWeekEnd;
<span class="nc" id="L103">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L104">		cal.setTime(currentDate);</span>
<span class="nc" id="L105">		cal.add(Calendar.DATE, getNumOfDaysToWeekEndDate(tz, currentDate, weekStartDay, spEnd));</span>
<span class="nc" id="L106">		sourceWeekEnd = cal.getTime();</span>
<span class="nc" id="L107">		return sourceWeekEnd;</span>
	}

	/**
	 * Returns true if the given week (by start date and end date) is a
	 * partial week.
	 *
	 * @param tz time zone
	 * @param startWeek week start date
	 * @param endWeek week end date
	 * @return true if the given week (by start date and end date) is a partial week
	 */
	public static boolean isPartialWeek(TimeZone tz, Date startWeek, Date endWeek) {
<span class="nc" id="L120">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L121">		cal.setTime(startWeek);</span>
<span class="nc" id="L122">		cal.add(Calendar.DATE, 7);</span>
<span class="nc" id="L123">		Date endFullWeek = cal.getTime();</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">		return !endFullWeek.equals(endWeek);</span>
	}

	/**
	 * Returns subrange of week1 which contains days of weeks of week2
	 * (week1 and week2 can be full or partial weeks).
	 *
	 * @param tz time zone
	 * @param week1Start week1 start date
	 * @param week1End week1 end date
	 * @param week2Start week2 start date
	 * @param week2End week2 end date
	 * @return Returns subrange of week1 which contains days of weeks of week2 (week1 and week2 can be full or partial weeks).
	 */
	public static Date[] findSubRangeHasSameDaysOfWeek(TimeZone tz, Date week1Start, Date week1End, Date week2Start, Date week2End) {
<span class="nc" id="L139">		Date[] result = {null, null};</span>
<span class="nc" id="L140">		Calendar cal = Calendar.getInstance(tz);</span>
		int days;

		// find all days of week in week2
<span class="nc" id="L144">		Set&lt;Integer&gt; checkDaysOfWeek = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		for (days = 0, cal.setTime(week2Start); cal.getTime().before(week2End); days++, cal.setTime(week2Start), cal.add(Calendar.DATE, days)) {</span>
<span class="nc" id="L146">			checkDaysOfWeek.add(cal.get(Calendar.DAY_OF_WEEK));</span>
		}


		// find start of subrange by looping over the week1 and find first day of week which also belongs to week2
<span class="nc bnc" id="L151" title="All 2 branches missed.">		for (days = 0, cal.setTime(week1Start); cal.getTime().before(week1End); days++, cal.setTime(week1Start), cal.add(Calendar.DATE, days)) {</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">			if (checkDaysOfWeek.contains(cal.get(Calendar.DAY_OF_WEEK))) {</span>
<span class="nc" id="L153">				result[0] = cal.getTime();</span>
<span class="nc" id="L154">				break;</span>
			}
		}


		// find end of subrange in week1
<span class="nc bnc" id="L160" title="All 2 branches missed.">		if (result[0] != null) {</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">			for (days = 0, cal.setTime(result[0]); cal.getTime().before(week1End); days++, cal.setTime(result[0]), cal.add(Calendar.DATE, days)) {</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">				if (!checkDaysOfWeek.contains(cal.get(Calendar.DAY_OF_WEEK))) {</span>
<span class="nc" id="L163">					break;</span>
				}
			}
<span class="nc" id="L166">			result[1] = cal.getTime();</span>
		}

<span class="nc" id="L169">		return result;</span>
	}

	/**
	 * Returns the number of days between two dates (negative if date 1 is after date 2).
	 *
	 * @param tz time zone
	 * @param d1 date 1
	 * @param d2 date 2
	 * @return Returns the number of days between two dates (negative if date 1 is after date 2).
	 */
	public static int getDaysBetween(TimeZone tz, Date d1, Date d2) {

		// Find &quot;estimated&quot; offset value between d1 and d2
<span class="nc" id="L183">		int dayOffset1 = (int) ((d2.getTime() - d1.getTime()) / TimeZoneUtil.DAY_IN_MILLISECONDS);</span>
<span class="nc" id="L184">		Calendar cal = Calendar.getInstance(tz);</span>

		// Find offset between (d1 + estimated offset) and d2
		int dayOffset2;
<span class="nc" id="L188">		cal.setTime(d1);</span>
<span class="nc" id="L189">		cal.add(Calendar.DATE, dayOffset1);</span>
<span class="nc" id="L190">		Date d1New = cal.getTime();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">		if (d1New.after(d2)) {</span>
<span class="nc bnc" id="L192" title="All 2 branches missed.">			for (dayOffset2 = 0, cal.setTime(d1New); cal.getTime().after(d2); ) {</span>
<span class="nc" id="L193">				dayOffset2--;</span>
<span class="nc" id="L194">				cal.setTime(d1New);</span>
<span class="nc" id="L195">				cal.add(Calendar.DATE, dayOffset2);</span>
			}
<span class="nc bnc" id="L197" title="All 2 branches missed.">		} else if (d1New.before(d2)) {</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">			for (dayOffset2 = 0, cal.setTime(d1New); cal.getTime().before(d2); ) {</span>
<span class="nc" id="L199">				dayOffset2++;</span>
<span class="nc" id="L200">				cal.setTime(d1New);</span>
<span class="nc" id="L201">				cal.add(Calendar.DATE, dayOffset2);</span>
			}
<span class="nc" id="L203">			dayOffset2--;</span>
		} else {
<span class="nc" id="L205">			dayOffset2 = 0;</span>
		}

<span class="nc" id="L208">		return dayOffset1 + dayOffset2;</span>
	}

	/**
	 * Given a range which intersecting with given source week, find
	 * corresponding subrange in target week (the result range must contain
	 * all the days of week which exist in both source week and end week).
	 * Source week and target week can be full or partial weeks and share
	 * same week start day.
	 *
	 * @param tz time zone for the Date values
	 * @param rangeStart range's start date
	 * @param rangeEnd range's end date
	 * @param sourceWeekStart source week's start date
	 * @param sourceWeekEnd source week's end date
	 * @param targetWeekStart target week's start date
	 * @param targetWeekEnd target week's end date
	 * @return corresponding subrange in target week (return array of two null values if no corresponding subrange can be found)
	 */
	public static Date[] relocateRangeFromOldWeekToNewWeek(TimeZone tz, Date rangeStart, Date rangeEnd,
		Date sourceWeekStart, Date sourceWeekEnd, Date targetWeekStart, Date targetWeekEnd) {

<span class="nc" id="L230">		Date[] result = {null, null};</span>

<span class="nc" id="L232">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc" id="L234">		Date[] sourceSubRange = findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart, sourceWeekEnd, targetWeekStart, targetWeekEnd);</span>
<span class="nc" id="L235">		Date[] targetSubRange = findSubRangeHasSameDaysOfWeek(tz, targetWeekStart, targetWeekEnd, sourceWeekStart, sourceWeekEnd);</span>

<span class="nc bnc" id="L237" title="All 6 branches missed.">		if (sourceSubRange[0] != null &amp;&amp; sourceSubRange[1] != null &amp;&amp; isOverlapped(rangeStart, rangeEnd, sourceSubRange[0], sourceSubRange[1])) {</span>

<span class="nc" id="L239">			Date rangeStartNew = rangeStart;</span>
<span class="nc" id="L240">			Date rangeEndNew = rangeEnd;</span>

			// cut the extra
<span class="nc bnc" id="L243" title="All 2 branches missed.">			if (rangeStartNew.before(sourceSubRange[0])) {</span>
<span class="nc" id="L244">				rangeStartNew = sourceSubRange[0];</span>
			}
<span class="nc bnc" id="L246" title="All 4 branches missed.">			if (rangeEndNew == null || rangeEndNew.after(sourceSubRange[1])) {</span>
<span class="nc" id="L247">				rangeEndNew = sourceSubRange[1];</span>
			}

			// find day offset
<span class="nc" id="L251">			int days = getDaysBetween(tz, sourceSubRange[0], targetSubRange[0]);</span>


			// now move the data to new range using day offset

<span class="nc" id="L256">			cal.setTime(rangeStartNew);</span>
<span class="nc" id="L257">			cal.add(Calendar.DATE, days);</span>
<span class="nc" id="L258">			result[0] = cal.getTime();</span>

<span class="nc" id="L260">			cal.setTime(rangeEndNew);</span>
<span class="nc" id="L261">			cal.add(Calendar.DATE, days);</span>
<span class="nc" id="L262">			result[1] = cal.getTime();</span>
		}

<span class="nc" id="L265">		return result;</span>
	}

	private static boolean isOverlapped(Date range1Start, Date range1End, Date range2Start, Date range2End) {
<span class="nc bnc" id="L269" title="All 6 branches missed.">		return (range1End == null || range2Start.getTime() &lt; range1End.getTime())</span>
<span class="nc bnc" id="L270" title="All 2 branches missed.">				&amp;&amp; (range2End == null || range2End.getTime() &gt; range1Start.getTime());</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>