<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ForecastTimeSeriesManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.bbm.forecast.ejb</a> &gt; <span class="el_source">ForecastTimeSeriesManagerEJB.java</span></div><h1>ForecastTimeSeriesManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * (c) 2009-2012 Verint Systems, Inc.
 */
package com.verint.ejb.bbm.forecast.ejb;

import com.bluepumpkin.common.datatypes.Duration;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.common.jdmo.*;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.ejb.bbm.campaign.ejb.*;
import com.bluepumpkin.ejb.bbm.campaign.model.*;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.time.TimeContextFactory;
import com.bluepumpkin.ejb.bbm.time.TimeIntervalAtTime;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.*;
import com.bluepumpkin.ejb.bbm.timeseries.model.*;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.QueueDAO;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.MediaType;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueFieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.bbm.forecast.ForecastTraceCubeUtil;
import com.verint.ejb.bbm.forecast.ejb.calculator.ForecastCalculatorFactory;
import com.verint.ejb.bbm.forecast.ejb.calculator.IForecastCalculator;
import com.verint.ejb.bbm.forecast.model.*;
import com.verint.ejb.bbm.forecast.model.ProfileComponent.Type;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntry;
import com.verint.ejb.bbm.forecast.model.history.ProfileEntryHistoryPeriod;
import com.verint.ejb.bbm.forecast.model.history.provider.HistoryProviderFactory;
import com.verint.ejb.bbm.forecast.model.history.provider.IHistoryProvider;
import com.verint.ejb.bbm.forecast.model.history.provider.OutboundHistoryProvider;
import com.verint.ejb.bbm.fterequirements.FteRequirementsUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.RemoteException;
import java.util.*;

/**
 * This session bean handles saving forecast data including active forecasts,
 * base forecasts, profiles, and instances, and loading and saving distributed
 * queue allocation data.
 * &lt;p&gt;
 * Most forecast data is loaded in {@link TimeSeriesManagerEJB}.
 */
@SuppressWarnings(&quot;serial&quot;)
<span class="fc" id="L64">public class ForecastTimeSeriesManagerEJB extends SessionEJBBase {</span>
	public static final int ALLOCATION_VALUES_PER_ROW = 96;
<span class="fc" id="L66">	private static Category m_cat = Log.initCategory(ForecastTimeSeriesManagerEJB.class.getName());</span>
	
	private TimeSeriesManager m_timeSeriesManager;
	private WorkloadManager m_workloadManager;
	private CampaignManager m_campaignManager;
	private ForecastTimeSeriesManager m_forecastTimeSeriesManager;
	private WorkloadManager workloadManager;
	private TimeSeriesManager timeSeriesManager;

<span class="fc" id="L75">	private boolean m_whatIfMode = false;</span>

	// Instance initializer.  Instance initializers are run after any superclass
	// constructors complete, and before any constructors in this class.
	{
<span class="fc" id="L80">		super.init(ForecastTimeSeriesManagerEJB.class.getName());</span>
	}

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L87">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L88">			Boolean WIF = (Boolean)initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">			if (WIF != null)</span>
<span class="fc" id="L90">				m_whatIfMode = WIF.booleanValue();</span>
<span class="fc" id="L91">			m_timeSeriesManager = WfmManagerFactory.getTimeSeriesManager(m_whatIfMode);</span>
<span class="fc" id="L92">			m_workloadManager = WfmManagerFactory.getWorkloadManager(m_whatIfMode);</span>
<span class="fc" id="L93">			m_campaignManager = WfmManagerFactory.getCampaignManager(m_whatIfMode);</span>
<span class="fc" id="L94">			m_forecastTimeSeriesManager = WfmManagerFactory.getForecastTimeSeriesManager(m_whatIfMode);</span>
<span class="fc" id="L95">			workloadManager = WfmManagerFactory.getWorkloadManager(m_whatIfMode);</span>
<span class="fc" id="L96">			timeSeriesManager = WfmManagerFactory.getTimeSeriesManager(m_whatIfMode);</span>
<span class="nc" id="L97">		} catch (Exception e) {</span>
<span class="nc" id="L98">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="fc" id="L99">		}</span>
<span class="fc" id="L100">	}</span>
	
	/**
	 * Returns a collection of forecast profile lists belonging to the given forecast profiles.  The map returned is
	 * keyed on the forecast profile ID, and the values in the map correspond to the forecast profile lists belonging
	 * to that profile.
	 */
	public Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; getForecastProfileListsByProfile(Collection&lt;ForecastProfile&gt; profiles)
			throws BbmFinderException {
<span class="fc" id="L109">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>
<span class="fc" id="L110">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; profileLists = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
		try {
<span class="fc bfc" id="L112" title="All 2 branches covered.">			for (ForecastProfile profile : profiles) {</span>
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">				if (!profileLists.containsKey(profile.getID())) {</span>
<span class="fc" id="L114">					profileLists.put(profile.getID(), dao.getForecastProfileListsByForecastProfileID(profile.getStringID()));</span>
				} else {
<span class="nc" id="L116">					profileLists.get(profile.getID()).addAll(</span>
<span class="nc" id="L117">							dao.getForecastProfileListsByForecastProfileID(profile.getStringID()));</span>
				}
<span class="fc" id="L119">			}</span>
<span class="fc" id="L120">			return profileLists;</span>
		} finally {
<span class="pc" id="L122">			dao.cleanUp();</span>
		}
	}
    
	private ID getSPID(ID spQueueID) throws BbmFinderException {
<span class="fc" id="L127">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
		try {
<span class="fc" id="L129">			return spqDAO.getSPQueuesByIDs(Collections.singleton(spQueueID)).iterator().next().getSpID();</span>
		} finally {
<span class="pc" id="L131">			spqDAO.cleanUp();</span>
		}
	}

	// {{ ------------------- Start Forecast Profiles -------------------- //
	/**
	 * Saves a forecast profile object (including any profile components set on it) and the ProfileTimeSeries
	 * objects associated with this forecast profile.
	 * 
	 * If the forecast profile already has an id, this method will do a db update. If not, it will do a create.
	 * 
	 * If the forecast profile is named, this method will first remove any profiles with that name.
	 */
	public ID saveForecastProfile(ForecastProfile forecastProfile, Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection)
			throws BbmException {
<span class="nc" id="L146">		methodStart(&quot;saveForecastProfile&quot;, forecastProfile, timeSeriesCollection);</span>
<span class="nc" id="L147">		ProfileTimeSeriesDAO ptsDao = new ProfileTimeSeriesDAO();</span>

<span class="nc" id="L149">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="nc" id="L150">		ID retVal = null;</span>

		// Create ForecastProfile
<span class="nc" id="L153">		Collection&lt;ID&gt; fpIDs = saveForecastProfileRecords(Collections.singleton(forecastProfile));</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">		if (fpIDs != null &amp;&amp; fpIDs.isEmpty() == false) {</span>
<span class="nc" id="L155">			retVal = fpIDs.iterator().next();</span>
		}

		// Create ProfileTimeSeries
		try {
<span class="nc" id="L160">			Collection&lt;ProfileTimeSeries&gt; tsToCreate = new ArrayList&lt;ProfileTimeSeries&gt;();</span>
<span class="nc" id="L161">			Collection&lt;ProfileTimeSeries&gt; tsToUpdate = new ArrayList&lt;ProfileTimeSeries&gt;();</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">			for (ProfileTimeSeries pts : timeSeriesCollection) {</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">				if (pts.getID() == null || pts.getID().equals(ValueObjectBase.m_nullObject)) {</span>
<span class="nc" id="L164">					tsToCreate.add(pts);</span>
<span class="nc" id="L165">					pts.setCreated(new Date());</span>
<span class="nc" id="L166">					pts.setCreatedBy(user);</span>
				} else {
<span class="nc" id="L168">					tsToUpdate.add(pts);</span>
<span class="nc" id="L169">					pts.setModified(new Date());</span>
<span class="nc" id="L170">					pts.setModifiedBy(user);</span>
				}
<span class="nc" id="L172">				pts.setForecastProfileID(forecastProfile.getID());</span>
<span class="nc" id="L173">			}</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">			if (! tsToCreate.isEmpty()) ptsDao.createObjects(tsToCreate);</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">			if (! tsToUpdate.isEmpty()) ptsDao.updateObjects(tsToUpdate);</span>
<span class="nc" id="L176">		} catch (Exception e) {</span>
<span class="nc" id="L177">			handleException(e);</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L180">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L182">			ptsDao.cleanUp();</span>
<span class="nc" id="L183">			methodFinish();</span>
<span class="nc" id="L184">		}</span>
<span class="nc" id="L185">		return retVal;</span>
	}
	
	/**
	 * Saves a forecast profile for an outbound media queue, including the associated ProfileTimeSeries and
	 * ForecastProfileLists for the profile.
	 * @param forecastProfile - the ForecastProfile to persist in the database
	 * @param timeSeriesCollection - 
	 * @param forecastProfileLists -
	 * @param type - ProfileComponent.Type, either Absolute or Relative
	 * @return the ID of the newly persisted ForecastProfile
	 */
	public ID saveOutboundForecastProfile(ForecastProfile forecastProfile,
			Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection, Collection&lt;ForecastProfileList&gt; forecastProfileLists,
			Date spWeekStartDate, Type type) throws BbmException {
<span class="nc" id="L200">		methodStart(&quot;saveOutboundForecastProfile&quot;, forecastProfile, timeSeriesCollection, forecastProfileLists);</span>
		
		ID newForecastProfileID;
		
		try {
<span class="nc" id="L205">			newForecastProfileID = saveForecastProfile(forecastProfile, timeSeriesCollection);</span>
			
			//If this is an absolute profile, then we need to adjust the start/end dates of the forecast
			//profile list so that they are adjusted relative to the start date of the current SP week.  Then,
			//when the profile is loaded into another SP week, the lists will be re-constituted with the same dates
			//relative to the start of the new SP week.
<span class="nc bnc" id="L211" title="All 6 branches missed.">			if (Type.Absolute.equals(type) &amp;&amp; forecastProfile.isModified() &amp;&amp;</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">					forecastProfileLists != null &amp;&amp; forecastProfileLists.size() &gt; 0) {</span>

<span class="nc bnc" id="L214" title="All 2 branches missed.">				for (ForecastProfileList fpl : forecastProfileLists) {</span>
<span class="nc" id="L215">					fpl.setProfileId(newForecastProfileID);</span>

<span class="nc" id="L217">					int daysBetweenFplAndSpWeek = TimeZoneUtil.numberOfDaysRound(spWeekStartDate, fpl.getStartTime());</span>
<span class="nc" id="L218">					int lengthOfFplInDays = TimeZoneUtil.numberOfDaysRound(fpl.getStartTime(), fpl.getEndTime());</span>
					
<span class="nc" id="L220">					Calendar fplStartDate = ForecastProfileList.getReferenceDateForManuallyModifiedProfiles();</span>
<span class="nc" id="L221">					fplStartDate.add(Calendar.DATE, daysBetweenFplAndSpWeek);</span>
<span class="nc" id="L222">					Calendar fplEndDate = (Calendar)fplStartDate.clone();</span>
<span class="nc" id="L223">					fplEndDate.add(Calendar.DATE, lengthOfFplInDays);</span>
<span class="nc" id="L224">					fpl.setStartTime(fplStartDate.getTime());</span>
<span class="nc" id="L225">					fpl.setEndTime(fplEndDate.getTime());</span>
<span class="nc" id="L226">				}</span>
				
<span class="nc" id="L228">				HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; profileListMap =</span>
						new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();
<span class="nc" id="L230">				profileListMap.put(newForecastProfileID, forecastProfileLists);</span>
<span class="nc" id="L231">				saveForecastProfileLists(profileListMap);</span>
			}
<span class="nc" id="L233">		} catch (BbmException e) {</span>
<span class="nc" id="L234">			handleException(e);</span>
<span class="nc" id="L235">			throw e;</span>
		} finally {
<span class="nc" id="L237">			methodFinish();</span>
<span class="nc" id="L238">		}</span>
		
<span class="nc" id="L240">		return newForecastProfileID;</span>
	}
	
	/**
	 * Saves the ForecastProfile record into the database. If the parameter already has an id set, 
	 * it will do an update, if not, it will create.
	 * &lt;p&gt;
	 * This method will remove any existing Forecast Profile records from the database if they fill the 
	 * same role and do not have the same id as the ForecastProfile object passed in. For more information
	 * about the different roles that a ForecastProfile object can be, see the &lt;code&gt;ForecastProfileDAO.getObjectsWithRole&lt;/code&gt;
	 * documentation.
	 * &lt;p&gt;
	 * This method automatically sets created and modified metadata.
	 * 
	 * @param forecastProfile
	 * @return
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private Collection&lt;ID&gt; saveForecastProfileRecords(Collection&lt;ForecastProfile&gt; forecastProfiles)
			throws BbmException {
<span class="fc" id="L261">		methodStart(&quot;saveForecastProfileRecords&quot;, forecastProfiles);</span>
<span class="fc" id="L262">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>

<span class="fc" id="L264">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
<span class="fc" id="L265">		Collection&lt;ID&gt; retVal = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L266">        Collection&lt;ID&gt; profilesToDelete = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L267">		Collection&lt;ForecastProfile&gt; profilesToCreate = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="fc" id="L268">		Collection&lt;ForecastProfile&gt; profilesToUpdate= new ArrayList&lt;ForecastProfile&gt;();      </span>
		try {
			// Delete any profile with the same role
<span class="fc bfc" id="L271" title="All 2 branches covered.">			for (ForecastProfile forecastProfile : forecastProfiles) {</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">				for (ForecastProfile fp : dao.getObjectsWithRole(forecastProfile.getSPQueueID(), forecastProfile.getName(),</span>
<span class="fc" id="L273">						forecastProfile.getForecastInstanceID(), forecastProfile.getStartDate())) {</span>
<span class="pc bpc" id="L274" title="1 of 2 branches missed.">					if (!fp.getID().equals(forecastProfile.getID())) {</span>
<span class="fc" id="L275">                        profilesToDelete.add(fp.getID());</span>
                    }
<span class="fc" id="L277">				}</span>

<span class="pc bpc" id="L279" title="1 of 2 branches missed.">				if (forecastProfile.getID() == null)  {</span>
<span class="fc" id="L280">					forecastProfile.setCreatedBy(user);</span>
<span class="fc" id="L281">					forecastProfile.setCreatedDate(new Date());</span>
<span class="fc" id="L282">					profilesToCreate.add(forecastProfile);</span>
				} else {
<span class="nc" id="L284">					forecastProfile.setModifiedBy(user);</span>
<span class="nc" id="L285">					forecastProfile.setModifiedDate(new Date());</span>
<span class="nc" id="L286">					profilesToUpdate.add(forecastProfile);</span>
				}
<span class="fc" id="L288">			}</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">            if (profilesToDelete.isEmpty() == false) {</span>
<span class="fc" id="L290">                dao.deleteObjects(profilesToDelete);</span>
            }
<span class="pc bpc" id="L292" title="1 of 2 branches missed.">			if (profilesToCreate.isEmpty() == false) {</span>
<span class="fc" id="L293">				retVal.addAll(dao.createObjects(profilesToCreate));</span>
			}
<span class="pc bpc" id="L295" title="1 of 2 branches missed.">			if (profilesToUpdate.isEmpty() == false) {</span>
<span class="nc" id="L296">				dao.updateObjects(profilesToUpdate);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">				for (ForecastProfile fp : profilesToUpdate) {</span>
<span class="nc" id="L298">					retVal.add(fp.getID());</span>
<span class="nc" id="L299">				}</span>
			}
<span class="nc" id="L301">		} catch (BbmException e) {</span>
<span class="nc" id="L302">			logSaveForecastProfileRecordsException(forecastProfiles);</span>
<span class="nc" id="L303">			handleException(e);</span>
<span class="nc" id="L304">			throw e;</span>
<span class="nc" id="L305">		} catch (MultiUserException e) {</span>
<span class="nc" id="L306">			logSaveForecastProfileRecordsException(forecastProfiles);</span>
<span class="nc" id="L307">			handleException(e);</span>
<span class="nc" id="L308">			throw new BbmException(e);</span>
		} finally {
<span class="pc" id="L310">			dao.cleanUp();</span>
<span class="pc" id="L311">			methodFinish();</span>
<span class="fc" id="L312">		}</span>
<span class="fc" id="L313">		return retVal;</span>
	}

	private void logSaveForecastProfileRecordsException(Collection&lt;ForecastProfile&gt; forecastProfiles) {
<span class="nc" id="L317">		m_cat.error(&quot;Error in saveForecastProfileRecords:&quot;);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">		for (ForecastProfile profile : forecastProfiles) {</span>
<span class="nc" id="L319">			m_cat.error(&quot;    ForecastProfile ID = &quot; + profile.getID() + &quot; SPQUEUEID = &quot; + profile.getSPQueueID() +</span>
<span class="nc" id="L320">					&quot; STARTDATE = &quot; + profile.getStartDate() + &quot; NAME = &quot; + profile.getName() + &quot; FINSTANCEID = &quot; +</span>
<span class="nc" id="L321">					profile.getForecastInstanceID() + &quot; FPROFILEID = &quot; + profile.getForecastProfileID());</span>
<span class="nc" id="L322">		}</span>
<span class="nc" id="L323">	}</span>
	
	private void persistForecastProfileLists(Collection&lt;ForecastProfileList&gt; onesToDelete,
			Collection&lt;ForecastProfileList&gt; onesToCreate) throws BbmCreateException, BbmUpdateException, BbmRemoveException {
<span class="fc" id="L327">		methodStart(&quot;persistForecastProfileLists&quot;);</span>
<span class="fc" id="L328">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>

<span class="pc bpc" id="L330" title="1 of 2 branches missed.">		for (ForecastProfileList oneToDelete : onesToDelete) {</span>
<span class="nc" id="L331">			dao.deleteObject(oneToDelete.getID());</span>
<span class="nc" id="L332">		}</span>
<span class="fc" id="L333">		insertForecastProfileLists(onesToCreate);</span>
<span class="fc" id="L334">	}</span>
	
	private void insertForecastProfileLists(Collection&lt;ForecastProfileList&gt; onesToCreate) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L337">		methodStart(&quot;insertForecastProfileLists&quot;);</span>
<span class="fc" id="L338">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>

<span class="fc" id="L340">		String user = m_sessionContext.getCallerPrincipal().getName();</span>

		try {
<span class="fc bfc" id="L343" title="All 2 branches covered.">			for (ForecastProfileList oneToCreate : onesToCreate) {</span>
<span class="fc" id="L344">				oneToCreate.setCreatedBy(user);</span>
<span class="fc" id="L345">				oneToCreate.setCreatedDate(new Date());</span>
<span class="fc" id="L346">				dao.createObject(oneToCreate);</span>
<span class="fc" id="L347">			}</span>
		} finally {
<span class="pc" id="L349">			dao.cleanUp();</span>
<span class="pc" id="L350">			methodFinish();</span>
<span class="fc" id="L351">		}</span>
<span class="fc" id="L352">	}</span>

	public void deleteForecastProfile(ID forecastProfileID) throws BbmRemoveException {
<span class="nc" id="L355">		methodStart(&quot;deleteForecastProfile&quot;, forecastProfileID);</span>
<span class="nc" id="L356">		ProfileTimeSeriesDAO ptsDAO = new ProfileTimeSeriesDAO();</span>
<span class="nc" id="L357">		ForecastProfileDAO dao = new ForecastProfileDAO(ptsDAO.getDMO());</span>
		try {
<span class="nc" id="L359">			ptsDAO.deleteObjectsWithParentID(forecastProfileID);</span>
<span class="nc" id="L360">			dao.deleteObjects(Collections.singleton(forecastProfileID));</span>
<span class="nc" id="L361">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L362">			handleException(e);</span>
<span class="nc" id="L363">			throw e;</span>
		} finally {
<span class="nc" id="L365">			dao.cleanUp();</span>
<span class="nc" id="L366">			methodFinish();</span>
<span class="nc" id="L367">		}</span>
<span class="nc" id="L368">	}</span>

	public Collection&lt;ForecastProfile&gt; getActiveForecastProfilesBySPQueueIDs(Collection&lt;ID&gt; spQueueIDs)
	throws BbmFinderException {
<span class="fc" id="L372">		methodStart(&quot;getActiveForecastProfilesBySPQueueIDs&quot;, spQueueIDs);</span>
<span class="fc" id="L373">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
<span class="fc" id="L375">			return dao.getActive(spQueueIDs);</span>
<span class="nc" id="L376">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L377">			handleException(e, false);</span>
<span class="nc" id="L378">			throw e;</span>
		} finally {
<span class="pc" id="L380">			dao.cleanUp();</span>
<span class="pc" id="L381">			methodFinish();</span>
		}
	}

	/**
	 * Returns all forecast profiles associated to the given forecast instance.
	 * 
	 * FIXME: the spqueueIDs are never used!  This method returns all forecast profiles for the given
	 * instance regardless of which spqueue is associated to the profile.
	 */
	public Collection&lt;ForecastProfile&gt; getForecastProfilesByForecastInstanceIDAndSPQueueIDs(ID forecastInstanceID , Collection&lt;ID&gt; spQueueIDs)
	throws BbmFinderException {
<span class="nc" id="L393">		methodStart(&quot;getForecastProfilesByForecastInstanceIDAndSPQueueIDs&quot;, forecastInstanceID);</span>
<span class="nc" id="L394">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
			//QC-117409 (from QC-115976) ESR 4113828 Port to 11.2
			//Fixed so that ForecastProfiles could be got based on QueueIDs	
<span class="nc" id="L398">			Collection&lt;ForecastProfile&gt; fps = new LinkedHashSet&lt;ForecastProfile&gt;(dao.getObjectsByForecastInstanceAndSPQueueID(forecastInstanceID, spQueueIDs));			</span>
<span class="nc" id="L399">			fixReforecastProfiles(fps);</span>
<span class="nc" id="L400">			return fps;</span>
<span class="nc" id="L401">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L402">			handleException(e, false);</span>
<span class="nc" id="L403">			throw e;</span>
		} finally {
<span class="nc" id="L405">			dao.cleanUp();</span>
<span class="nc" id="L406">			methodFinish();</span>
		}
	}
	
	/**
 	 * Pulse's reforecast functionality saves a forecast instance with sloppy values in the ForecastProfile table.
	 * Things it does wrong are:
	 * &lt;ol&gt;
	 * &lt;li&gt;Has a duration of 7, even for multi-week SPs.
	 * &lt;li&gt;Has null startdate and enddate fields.
	 * &lt;li&gt;Does not save a record for each sp-queue-week. It saves one for each sp-queue.
	 * &lt;/ol&gt;
	 * This method will delete these records and create some with more appropriate values. It will only attempt
	 * to fix records that match all of the bad behavior listed above. If a record only has a subset of these
	 * problems, it will be left as is. 
	 * @param fps
	 */
	private void fixReforecastProfiles(Collection&lt;ForecastProfile&gt; fps) throws BbmFinderException {
		
		// First, collect any profiles that need to be fixed.
<span class="nc" id="L426">		Map&lt;ID, ForecastProfile&gt; fpsToFixBySPQueueID = new HashMap&lt;ID, ForecastProfile&gt;();</span>
<span class="nc bnc" id="L427" title="All 2 branches missed.">		for (ForecastProfile fp : fps) {</span>
			// Check for null Start &amp; End Dates, as well as duration
<span class="nc bnc" id="L429" title="All 4 branches missed.">			if (fp.getStartDate() == null &amp;&amp; fp.getEndDate() == null) {</span>
				// Check for only one record for each sp-queue
<span class="nc bnc" id="L431" title="All 2 branches missed.">				if (fpsToFixBySPQueueID.remove(fp.getSPQueueID()) != null) continue;</span>
				
<span class="nc" id="L433">				fpsToFixBySPQueueID.put(fp.getSPQueueID(), fp);</span>
			}
<span class="nc" id="L435">		}</span>
		
<span class="nc bnc" id="L437" title="All 2 branches missed.">		if (!fpsToFixBySPQueueID.isEmpty()) {</span>
<span class="nc" id="L438">			SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="nc" id="L439">			SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="nc" id="L440">			CampaignDAO campaignDAO = new CampaignDAO();</span>
			try {
				// We need to create a forecast profile record for each spqueue week
<span class="nc" id="L443">				Collection&lt;ForecastProfile&gt; recordsToAdd = new LinkedList&lt;ForecastProfile&gt;();</span>
				
				// First get SP &amp; Campaign
<span class="nc" id="L446">				SPQueue spq = spqDAO.getSPQueue(fpsToFixBySPQueueID.keySet().iterator().next());</span>
<span class="nc" id="L447">				SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spq.getSpID());</span>
<span class="nc" id="L448">				Campaign campaign = campaignDAO.getObjectByID(sp.getCampaignID());</span>

				// Loop through all weeks in SP, creating a new object for each sp-queue-week 
<span class="nc" id="L451">				Calendar spWeekStart = Calendar.getInstance(campaign.getTimeZone());</span>
<span class="nc" id="L452">				spWeekStart.setTime(sp.getStartTime());</span>
<span class="nc" id="L453">				Calendar nextWeekStart = Calendar.getInstance(campaign.getTimeZone());</span>
<span class="nc" id="L454">				nextWeekStart.setTime(sp.getStartTime());</span>
<span class="nc" id="L455">				nextWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">				while (spWeekStart.getTime().getTime() &lt; sp.getEndTime().getTime()) {</span>
<span class="nc bnc" id="L457" title="All 2 branches missed.">					for (ForecastProfile fp : fpsToFixBySPQueueID.values()) {</span>
<span class="nc" id="L458">						ForecastProfile newProfile = fp.cloneForecastProfileValueFields();</span>
<span class="nc" id="L459">						newProfile.setStartDate(spWeekStart.getTime());</span>
<span class="nc" id="L460">						newProfile.setEndDate(nextWeekStart.getTime());</span>
<span class="nc" id="L461">						recordsToAdd.add(newProfile);</span>
<span class="nc" id="L462">					}</span>
<span class="nc" id="L463">					spWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc" id="L464">					nextWeekStart.add(Calendar.WEEK_OF_YEAR, 1);</span>
				}
				
<span class="nc" id="L467">				ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
<span class="nc" id="L468">				fps.removeAll(fpsToFixBySPQueueID.values());</span>
<span class="nc" id="L469">				fpDAO.deleteObjects(ValueObjectUtil.getIDFromObjects(fpsToFixBySPQueueID.values()));</span>
<span class="nc" id="L470">				fpDAO.createObjects(recordsToAdd);</span>
<span class="nc" id="L471">				fps.addAll(recordsToAdd);</span>
<span class="nc" id="L472">			} catch (Exception e) {</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">				if (e instanceof BbmFinderException) throw (BbmFinderException)e;</span>
<span class="nc" id="L474">				else throw new BbmFinderException(e);</span>
			} finally {
<span class="nc" id="L476">				spqDAO.cleanUp();</span>
<span class="nc" id="L477">				spDAO.cleanUp();</span>
<span class="nc" id="L478">				campaignDAO.cleanUp();</span>
<span class="nc" id="L479">			}</span>
		}
<span class="nc" id="L481">	}</span>
	
	public Collection&lt;ForecastProfile&gt; getManuallySavedForecastProfiles() throws BbmFinderException {
<span class="nc" id="L484">		methodStart(&quot;getForecastProfiles&quot;);</span>
<span class="nc" id="L485">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
<span class="nc" id="L487">			return dao.getObjects(&quot;spqueueid is null and forecastinstanceid is null&quot;);</span>
<span class="nc" id="L488">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L489">			handleException(e, false);</span>
<span class="nc" id="L490">			throw e;</span>
		} finally {
<span class="nc" id="L492">			dao.cleanUp();</span>
<span class="nc" id="L493">			methodFinish();</span>
		}
	}

	public Collection&lt;ProfileTimeSeries&gt; getProfileTimeSeriesByProfileID(ID profileID)
	throws BbmFinderException {
<span class="nc" id="L499">		methodStart(&quot;getProfileTimeSeriesByProfileID&quot;, profileID);</span>
<span class="nc" id="L500">		ForecastProfileDAO fpDao = new ForecastProfileDAO();</span>
<span class="nc" id="L501">		ProfileTimeSeriesDAO dao = new ProfileTimeSeriesDAO(fpDao.getDMO());</span>
		try {
<span class="nc" id="L503">			return dao.getObjectsByParentID(profileID);</span>
<span class="nc" id="L504">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L505">			handleException(e, false);</span>
<span class="nc" id="L506">			throw e;</span>
		} finally {
<span class="nc" id="L508">			fpDao.cleanUp();</span>
<span class="nc" id="L509">			dao.cleanUp();</span>
<span class="nc" id="L510">			methodFinish();</span>
		}
	}

	public void saveProfileTimeSeries(Collection&lt;ProfileTimeSeries&gt; timeSeriesCollection) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L515">		methodStart(&quot;saveProfileTimeSeries&quot;, timeSeriesCollection);</span>
<span class="nc" id="L516">		ProfileTimeSeriesDAO dao = new ProfileTimeSeriesDAO();</span>
		try {
<span class="nc" id="L518">			HashSet&lt;ProfileTimeSeries&gt; objectsToCreate = new HashSet&lt;ProfileTimeSeries&gt;();</span>
<span class="nc" id="L519">			HashSet&lt;ProfileTimeSeries&gt; objectsToUpdate = new HashSet&lt;ProfileTimeSeries&gt;();</span>
<span class="nc bnc" id="L520" title="All 2 branches missed.">			for ( ProfileTimeSeries pts : timeSeriesCollection) {</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">				if (pts.getID() == null) objectsToCreate.add(pts);</span>
<span class="nc" id="L522">				else objectsToUpdate.add(pts);</span>
<span class="nc" id="L523">			}</span>
<span class="nc bnc" id="L524" title="All 2 branches missed.">			if (objectsToCreate.size() &gt; 0) dao.createObjects(objectsToCreate);</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">			if (objectsToUpdate.size() &gt; 0) dao.updateObjects(objectsToUpdate);</span>
<span class="nc" id="L526">		} catch (Exception e) {</span>
<span class="nc" id="L527">			handleException(e);</span>
<span class="nc bnc" id="L528" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L530">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L532">			dao.cleanUp();</span>
<span class="nc" id="L533">			methodFinish();</span>
<span class="nc" id="L534">		}</span>
<span class="nc" id="L535">	}</span>

	// }} ------------------- End Forecast Profiles -------------------- //

	// {{ ------------------- Start Instances -------------------------- //

	public Collection&lt;ForecastInstance&gt; getForecastInstancesForSPQueue(ID spQueueID) throws BbmFinderException {
<span class="nc" id="L542">		methodStart(&quot;getForecastInstancesForSPQueue&quot;, spQueueID);</span>
<span class="nc" id="L543">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
<span class="nc" id="L544">		ForecastProfileDAO fpDao = new ForecastProfileDAO(dao.getDMO());</span>
		try {
<span class="nc" id="L546">			Set&lt;ID&gt; fiIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">			for (ForecastProfile fp : fpDao.getObjectsBySPQueueID(spQueueID)) {</span>
<span class="nc" id="L548">				ID fiID = fp.getForecastInstanceID();</span>
<span class="nc bnc" id="L549" title="All 2 branches missed.">				if (fiID != null) fiIDSet.add(fiID);</span>
<span class="nc" id="L550">			}</span>
<span class="nc" id="L551">			return dao.getObjectsByIDs(fiIDSet);</span>
<span class="nc" id="L552">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L553">			handleException(e, false);</span>
<span class="nc" id="L554">			throw e;</span>
		} finally {
<span class="nc" id="L556">			dao.cleanUp();</span>
<span class="nc" id="L557">			fpDao.cleanUp();</span>
<span class="nc" id="L558">			methodFinish();</span>
		}
	}

	public Collection&lt;ForecastInstance&gt; getForecastInstancesForSP(ID spID) throws BbmFinderException {
<span class="nc" id="L563">		methodStart(&quot;getForecastInstancesForSP&quot;, spID);</span>
<span class="nc" id="L564">		ForecastInstanceDAO dao = new ForecastInstanceDAO();</span>
		try {
<span class="nc" id="L566">			return dao.getObjectsByParentID(spID);</span>
<span class="nc" id="L567">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L568">			handleException(e, false);</span>
<span class="nc" id="L569">			throw e;</span>
		} finally {
<span class="nc" id="L571">			dao.cleanUp();</span>
<span class="nc" id="L572">			methodFinish();</span>
		}
	}

	/**
	 * Saves the forecast instance for immediate media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveImmediateMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 * 
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveImmediateMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveImmediateMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveImmediateMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L595">		methodStart(&quot;saveImmediateMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, isBase);</span>
		try {
<span class="fc" id="L597">			return saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="nc" id="L598">		} catch (Exception e) {</span>
<span class="nc" id="L599">			handleException(e);</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L602">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L604">			methodFinish();</span>
		}
	}

	/**
	 * Saves the forecast instance for deferred media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveImmediateMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 * 
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param spQueues - Collection of associated SPQueue objects that will be updated as part of this operation.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveDeferredMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveDeferredMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveDeferredMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, Collection&lt;SPQueue&gt; spQueues, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L628">		methodStart(&quot;saveDeferredMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, spQueues, isBase);</span>
		try {
<span class="fc" id="L630">			ForecastInstance fi = saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="fc" id="L631">			saveAssociatedDataForDeferredMediaForecastInstance(spQueues, fi.getID());</span>
<span class="fc" id="L632">        	return fi;</span>
<span class="nc" id="L633">		} catch (Exception e) {</span>
<span class="nc" id="L634">    		handleException(e);</span>
<span class="nc bnc" id="L635" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L637">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L639">			methodFinish();</span>
		}
	}
	
	/**
	 * Saves the additional (non-time series) data associated with a forecast instance that contains
	 * deferred media queues.  This includes the forecasted interim backlog that is associated to each
	 * deferred queue.
	 */
	private void saveAssociatedDataForDeferredMediaForecastInstance(Collection&lt;SPQueue&gt; spQueues, ID forecastInstanceID)
	throws MultiUserException, BbmUpdateException, BbmFinderException, BbmCreateException, JdmoException {
<span class="fc" id="L650">		SPQueueDAO dao = new SPQueueDAO();</span>
<span class="fc" id="L651">    	ForecastInterimBacklogDAO fibDAO = new ForecastInterimBacklogDAO();</span>
		try {
<span class="fc" id="L653">			dao.updateObjects(spQueues);</span>
<span class="fc" id="L654">        	fibDAO.updateInterimBacklogForForecastInstance(spQueues, forecastInstanceID);</span>
		} finally {
<span class="pc" id="L656">			dao.cleanUp();</span>
<span class="pc" id="L657">			fibDAO.cleanUp();</span>
<span class="fc" id="L658">		}</span>
<span class="fc" id="L659">	}</span>

	/**
	 * Saves the forecast instance for outbound media queues. Profiles must all be in the same SP.
	 * NOTE: if you are saving a base forecast use saveOutboundMediaForecastAsBase instead.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
	 * @param name - Name of the forecast instance.  This parameter is required.
	 * @param profiles - Set of forecast profiles associated to the instance.  This parameter is optional (can be null or empty collection).
	 * @param forecastsBySPQueueID - Forecast tracecube data associated to each SP Queue.  This parameter is required.
	 * @param isBase - Indicates if this is a base forecast.  NOTE: for clients this should always be set to false.  If you need
	 * to set a base forecast use saveOutboundMediaForecastAsBase instead!  This is regrettably confusing, but this method is used
	 * by the saveOutboundMediaForecastAsBase method and it was required that this method be declared public on the remote
	 * interface in order to wrap it in a separate EJB transaction before FTE requirements are calculated.
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public ForecastInstance saveOutboundMediaForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile, boolean isBase) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L681">		methodStart(&quot;saveOutboundMediaForecastInstance&quot;, name, profiles, forecastsBySPQueueID, listsByProfile, isBase);</span>

		try {
<span class="fc" id="L684">			ForecastInstance retVal = saveForecastInstance(name, profiles, forecastsBySPQueueID, isBase);</span>
<span class="fc" id="L685">			saveAssociatedDataForOutboundMediaForecastInstance(retVal.getId(), listsByProfile);</span>

<span class="fc" id="L687">			return retVal;</span>
<span class="nc" id="L688">		} catch (Exception e) {</span>
<span class="nc" id="L689">			handleException(e);</span>
<span class="nc bnc" id="L690" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L692">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L694">			methodFinish();</span>
		}
	}

	/**
	 * Saves the additional (non-time series) data associated with a forecast instance that contains
	 * outbound media queues.  This includes the forecasted outbound call lists that are associated to
	 * each outbound queue.
	 */
	private void saveAssociatedDataForOutboundMediaForecastInstance(ID forecastInstanceID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmException {
<span class="fc" id="L705">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
			//Profiles may have been cloned in previous step, we need to retrieve the forecast profiles for the
			//given instance and then the forecast profile IDs on those profiles need to be set on the forecast profile lists
<span class="fc" id="L709">			Collection&lt;ForecastProfile&gt; profiles = fpDAO.getObjectsByForecastInstanceID(forecastInstanceID);			</span>
<span class="fc" id="L710">			saveForecastProfileLists(getOutboundProfileListsByForecastProfileID(profiles, listsByProfile));	</span>
		} finally {
<span class="pc" id="L712">			fpDAO.cleanUp();</span>
<span class="fc" id="L713">		}</span>
<span class="fc" id="L714">	}</span>

	/**
	 * Saves the forecast instance. Profiles must all be in the same SP.  Used internally by the save forecast instance methods for specific media types.
	 * The instance may be a named instance or the Base instance.
	 * This method supports incremental saves. If data exists for a SPQueue specified by the 
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 */
	private ForecastInstance saveForecastInstance(String name, Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, boolean isBase) throws BbmFinderException, BbmException, CloneNotSupportedException {
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">		if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>
<span class="pc bpc" id="L725" title="2 of 4 branches missed.">		if (profiles != null &amp;&amp; profiles.size() &gt; 0) {</span>
<span class="fc" id="L726">			boolean shouldCloneProfiles = false;</span>

			//Check to see if we have a previously saved instance with this name for the given SP.  If we do,
			// then we need to create a new set of profiles as we will be creating a new instance as well.
			//
			// [RWF, 2010-12-14] I'm not sure why we need this. I am guessing that it was needed to clear out old
			// data. However, the saveForecastProfileRecord already does some cleanup. There is no time
			// left in the dev cycle to investigate this further.
<span class="fc" id="L734">			ForecastInstance previouslySavedInstance = getSavedForecastInstance(getSPID(forecastsBySPQueueID.keySet().iterator().next()),</span>
					name, isBase);
<span class="fc bfc" id="L736" title="All 2 branches covered.">			if (previouslySavedInstance != null) shouldCloneProfiles = true;</span>
			
			// If it is a base forecast, clone the profiles. This is done because, often, people will code the client such
			// that they pass in the active forecast profiles and want to set it as the base. If we don't clone the profiles, the 
			// nature of the profile records would change from an active forecast to a base forecast. By cloning, we leave the 
			// active forecast alone.
<span class="pc bpc" id="L742" title="1 of 2 branches missed.">			if (isBase) shouldCloneProfiles = true;</span>
			
<span class="pc bpc" id="L744" title="1 of 2 branches missed.">			if (shouldCloneProfiles) {</span>
<span class="fc" id="L745">				Collection&lt;ForecastProfile&gt; clonedProfiles = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="fc bfc" id="L746" title="All 2 branches covered.">				for (ForecastProfile profile : profiles) {</span>
<span class="fc" id="L747">					clonedProfiles.add(profile.cloneForecastProfileValueFields());</span>
<span class="fc" id="L748">				}</span>
<span class="fc" id="L749">				profiles = clonedProfiles;</span>
			}
		}
<span class="fc" id="L752">		ForecastInstance fi = saveForecastInstanceRecord(name, getSPID(forecastsBySPQueueID.keySet().iterator().next()), isBase);</span>
<span class="pc bpc" id="L753" title="2 of 4 branches missed.">		if (profiles != null &amp;&amp; !profiles.isEmpty()) {</span>
<span class="fc" id="L754">			saveForecastProfiles(profiles, fi.getID());</span>
		}
<span class="fc" id="L756">		saveForecastTimeSeries(forecastsBySPQueueID, fi.getID());</span>
<span class="fc" id="L757">		return fi;</span>
	}
	
	/**
	 * Saves a record in the ForecastInstance table.
	 *  
	 * @param name
	 * @param data
	 * @param timeZone
	 * @param isBase
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private ForecastInstance saveForecastInstanceRecord(String name, ID spID, boolean isBase) throws BbmException {
<span class="fc" id="L771">		methodStart(&quot;saveForecastInstance&quot;, name, spID, isBase);</span>
<span class="fc" id="L772">		ForecastInstanceDAO fiDAO = new ForecastInstanceDAO();</span>
<span class="fc" id="L773">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="fc" id="L774">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
<span class="fc" id="L775">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>
<span class="fc" id="L776">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
		try {
<span class="fc" id="L778">			ForecastInstance fi = getSavedForecastInstance(spID, name, isBase);</span>
			
			// If no FI exists, create new
<span class="fc bfc" id="L781" title="All 2 branches covered.">			if (fi == null) {</span>
<span class="fc" id="L782">				fi = new ForecastInstance();</span>
<span class="fc" id="L783">				fi.setCreated(new Date());</span>
<span class="fc" id="L784">				fi.setCreatedBy(user);</span>
<span class="fc" id="L785">				fi.setDescription(name);</span>
<span class="fc" id="L786">				fi.setIsBase(isBase);</span>
<span class="fc" id="L787">				fi.setSpId(spID);</span>
<span class="fc" id="L788">				fiDAO.createObject(fi);</span>
			} else  {
				// If FI already exists, modify
<span class="fc" id="L791">				fi.setModified(new Date());</span>
<span class="fc" id="L792">				fi.setModifiedBy(user);</span>
<span class="fc" id="L793">				fi.setDescription(name);</span>
<span class="fc" id="L794">				fi.setIsBase(isBase);</span>
<span class="fc" id="L795">				fi.setSpId(spID);</span>
<span class="fc" id="L796">				fiDAO.updateObject(fi);</span>
			}
<span class="fc" id="L798">			return fi;</span>
<span class="nc" id="L799">		} catch (MultiUserException e) {</span>
<span class="nc" id="L800">			throw new BbmCreateException(e);</span>
<span class="nc" id="L801">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L802">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L804">			spQueueDAO.cleanUp();</span>
<span class="pc" id="L805">			fpDAO.cleanUp();</span>
<span class="pc" id="L806">			ftsDAO.cleanUp();</span>
<span class="pc" id="L807">			fiDAO.cleanUp();</span>
<span class="pc" id="L808">			methodFinish();</span>
		}
	}
	
	/**
	 * Returns the forecast instance with the given name and Scheduling Period (or the base forecast of the scheduling
	 * period if isBase is true).  Returns null if a forecast instance does not exist for these parameters.
	 */
	private ForecastInstance getSavedForecastInstance(ID spID, String name, boolean isBase) throws BbmFinderException {
<span class="fc" id="L817">		methodStart(&quot;getSavedForecastInstance&quot;);</span>

<span class="fc" id="L819">		ForecastInstance fi = null;</span>
<span class="fc" id="L820">		ForecastInstanceDAO fiDAO = new ForecastInstanceDAO();</span>
		try
		{
<span class="pc bpc" id="L823" title="3 of 4 branches missed.">			if (! isBase &amp;&amp; ! StringUtil.isEmpty(name))fi = fiDAO.getObjectByNameAndSPID(name, spID);</span>
<span class="pc bpc" id="L824" title="1 of 2 branches missed.">			else if (isBase) fi = fiDAO.getBaseForecastInstance(spID);</span>
<span class="fc" id="L825">			return fi;</span>
<span class="nc" id="L826">		}catch(Exception e) {</span>
<span class="nc" id="L827">			handleException(e);</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L829">			throw new BbmFinderException(e);</span>
		} finally{
<span class="pc" id="L831">			fiDAO.cleanUp();</span>
<span class="pc" id="L832">			methodFinish();</span>
		}

	}

	// }} ------------------- End Instances -------------------------- //

	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the spQueues are the keys in the forecastsBySPQueueID map).
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 */
	public void saveImmediateMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L848">		saveImmediateMediaForecastAsActive(profiles, forecastsBySPQueueID, ForecastUpdateOriginalSource.UnknownUpdate);</span>
<span class="fc" id="L849">	}</span>
	
	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the Ids of spQueues are the keys in the forecastsBySPQueueID map).
	 * NOTE: This is essentially an optimized version of saveImmediateMediaForecastAsActive.  It is only intended to be used for the RFS import
	 * as it skips some steps for the saving of forecast data that are normally required (mainly allocations).  In almost all cases, you want to
	 * use saveImmediateMediaForecastAsActive instead!
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 */
	public void saveImmediateMediaForecastAsActiveForRFS(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID)
				throws BbmCreateException, BbmUpdateException {
		try {
<span class="nc bnc" id="L864" title="All 4 branches missed.">			if (forecastsBySPQueueID != null &amp;&amp; !forecastsBySPQueueID.isEmpty()) {</span>
				//Persist forecast time series
<span class="nc" id="L866">				saveDataForImmediateMediaActiveForecast(profiles, forecastsBySPQueueID);</span>
			}
<span class="nc" id="L868">		} catch (Exception e) {</span>
<span class="nc" id="L869">			handleException(e);</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L872">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L874">			methodFinish();</span>
<span class="nc" id="L875">		}</span>
<span class="nc" id="L876">	}</span>

	/**
	 * Saves an active immediate media forecast with forecast profiles for the given spQueues (the spQueues are the keys in the forecastsBySPQueueID map).
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param updateSource if &lt;code&gt;ForecastUpdateOriginalSource.ChildUpdate&lt;/code&gt; and the forecasted
	 * queues include distributed child queues, then the children's parent forecasts and
	 * allocation percentages will be updated as well.  Otherwise the updates will not occur.
	 * Normally this parameter would be &lt;code&gt;ForecastUpdateOriginalSource.ChildUpdate&lt;/code&gt;
	 * but if the child forecast is itself being updated as a result of an update to the parent
	 * forecast then the changes to the child should not loop back to the parent.
	 */
	private void saveImmediateMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			ForecastUpdateOriginalSource updateSource)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L894">		methodStart(&quot;saveImmediateMediaForecastAsActive&quot;);</span>
	
		try {
<span class="fc" id="L897">			Collection&lt;ID&gt; savedSPQueueIDs = m_forecastTimeSeriesManager.saveDataForImmediateMediaActiveForecast(profiles, forecastsBySPQueueID);</span>
			//After the transaction for saving forecast data has been committed, we now kick off the fte
			//requirements calculations for these spqueues
<span class="fc" id="L900">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(savedSPQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="fc" id="L901">			updateAllocations(savedSPQueueIDs, updateSource);</span>
<span class="nc" id="L902">		} catch (Exception e) {</span>
<span class="nc" id="L903">			handleException(e);</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L906">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L908">			methodFinish();</span>
<span class="fc" id="L909">		}</span>
<span class="fc" id="L910">	}</span>
	
    /**
     * This method is used by saveDataForImmediateMediaActiveForecast to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active immediate media forecasts.  Use saveImmediateMediaForecastAsActive instead!
     */
	public Collection&lt;ID&gt; saveDataForImmediateMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles, Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L921">		methodStart(&quot;saveDataForImmediateMediaActiveForecast&quot;);</span>
		
		try {
<span class="fc" id="L924">			saveForecastProfiles(profiles, null);</span>
<span class="fc" id="L925">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>

<span class="fc" id="L927">			return ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="nc" id="L929">		} catch (Exception e) {</span>
<span class="nc" id="L930">			handleException(e);</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L933">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L935">			methodFinish();</span>
		}		
	}
	
    /**
     * Saves an active project media forecast with forecast and project profiles for the given spQueues in forecastsBySPQueueID.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
     * @param projectProfiles
     * @param profiles
     * @param forecastsBySPQueueID
     * @throws BbmCreateException
     * @throws BbmUpdateException
     * @throws BbmRemoveException
     * @throws RemoteException
     */
	public void saveProjectMediaForecastAsActive(
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfile)
	throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L954">		methodStart(&quot;saveProjectMediaForecastAsActive&quot;);</span>
		try {
<span class="nc" id="L956">			m_forecastTimeSeriesManager.saveDataForProjectMediaActiveForecast(projectsByForecastProfile);</span>
<span class="nc" id="L957">			Collection&lt;ID&gt; spQueueIDs = ValueObjectUtil.getFieldObjectCol(</span>
<span class="nc" id="L958">					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, projectsByForecastProfile.keySet());</span>
<span class="nc" id="L959">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIDs, m_whatIfMode);</span>
<span class="nc" id="L960">		} catch (Exception e) {</span>
<span class="nc" id="L961">			handleException(e);</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L964">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L966">			methodFinish();</span>
<span class="nc" id="L967">		}</span>
<span class="nc" id="L968">	}</span>
	
    /**
     * This method is used by saveProjectMediaForecastAsActive to save the necessary data for the project queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active project forecasts.  Use saveProjectMediaForecastAsActive instead!
     */
	public void saveDataForProjectMediaActiveForecast(
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfile)
	throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L981">		methodStart(&quot;saveDataForProjectMediaActiveForecast&quot;);</span>
<span class="nc" id="L982">		ForecastProfileProjectDAO dao = new ForecastProfileProjectDAO();</span>

		try {
<span class="nc bnc" id="L985" title="All 4 branches missed.">			if (projectsByForecastProfile != null &amp;&amp; !projectsByForecastProfile.isEmpty()) {</span>
<span class="nc" id="L986">				Collection&lt;ID&gt; forecastProfilesToDelete = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L987">				Collection&lt;ForecastProfileProject&gt; projectsToSave = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L988">				saveForecastProfiles(projectsByForecastProfile.keySet(), null);</span>
                for (Map.Entry&lt;ForecastProfile, Collection&lt;ForecastProfileProject&gt;&gt; projectsByForecastProfileEntry :
<span class="nc bnc" id="L990" title="All 2 branches missed.">            			projectsByForecastProfile.entrySet()) {</span>
<span class="nc" id="L991">	                ForecastProfile forecastProfile = projectsByForecastProfileEntry.getKey();</span>
<span class="nc" id="L992">					Collection&lt;ForecastProfileProject&gt; filterProjectProfiles = projectsByForecastProfileEntry.getValue();</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                    if (forecastProfile.getForecastProfileID() != null) {</span>
<span class="nc" id="L994">                        forecastProfilesToDelete.add(forecastProfile.getForecastProfileID());</span>
                    }
<span class="nc bnc" id="L996" title="All 4 branches missed.">					if (filterProjectProfiles != null &amp;&amp; filterProjectProfiles.isEmpty() == false) {</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">						for (ForecastProfileProject fpp : filterProjectProfiles) {</span>
							/**
							 * Fix for QC#88192
							 */
<span class="nc bnc" id="L1001" title="All 2 branches missed.">							if (fpp.getID() != null) {</span>
<span class="nc" id="L1002">								fpp.setID(null);</span>
							}
<span class="nc" id="L1004">							fpp.setForecastProfileID(forecastProfile.getForecastProfileID());</span>
<span class="nc" id="L1005">							projectsToSave.add(fpp);</span>
<span class="nc" id="L1006">						}</span>
					}
<span class="nc" id="L1008">				}</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">				if (forecastProfilesToDelete.isEmpty() == false) {</span>
<span class="nc" id="L1010">					dao.deleteByForecastProfileIDs(forecastProfilesToDelete);</span>
				}
<span class="nc bnc" id="L1012" title="All 2 branches missed.">				if (projectsToSave.isEmpty() == false) {</span>
<span class="nc" id="L1013">					saveForecastProjectRecords(projectsToSave);</span>
				}
			}
<span class="nc" id="L1016">		} catch (Exception e) {</span>
<span class="nc" id="L1017">			handleException(e);</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1019" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1020">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1022">			methodFinish();</span>
<span class="nc" id="L1023">			dao.cleanUp();</span>
<span class="nc" id="L1024">		}</span>
<span class="nc" id="L1025">	}</span>

	/**
     * Saves an active outbound media forecast with forecast profiles and forecasted outbound call lists for the given spQueues in forecastsBySPQueueID.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param listsByProfile - hashmap: key = forecast profile, value = list of forecasted outbound call lists for the forecast profile
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void saveOutboundMediaForecastAsActive(Collection&lt;ForecastProfile&gt; profiles, 
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, 
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1041">		methodStart(&quot;saveOutboundMediaForecastAsActive&quot;);</span>
		try {			
<span class="fc" id="L1043">			m_forecastTimeSeriesManager.saveDataForOutboundMediaActiveForecast(profiles, forecastsBySPQueueID, listsByProfile);	</span>
<span class="fc" id="L1044">			Collection&lt;ID&gt; spQueueIDs = ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="fc" id="L1046">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1047">		} catch (Exception e) {</span>
<span class="nc" id="L1048">			handleException(e);</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1051">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1053">			methodFinish();</span>
<span class="fc" id="L1054">		}</span>
<span class="fc" id="L1055">	}</span>
	
    /**
     * This method is used by saveOutboundMediaForecastAsActive to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active outbound forecasts.  Use saveOutboundMediaForecastAsActive instead!
     */
	public void saveDataForOutboundMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles, 
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID, 
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1068">		methodStart(&quot;saveDataForOutboundMediaActiveForecast&quot;);</span>
		try {
<span class="fc" id="L1070">			saveForecastProfiles(profiles, null);</span>
			
			//We know that when we make the call to saveForecastProfiles above, it is possible that the profiles
			//are actually deleted and new ones created rather than just updating.  What we need to do then is
			//update the forecast profile IDs on the forecast profile lists with the new IDs before we save the lists.
<span class="fc" id="L1075">			saveForecastProfileLists(getOutboundProfileListsByForecastProfileID(profiles, listsByProfile));</span>
<span class="fc" id="L1076">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>
<span class="nc" id="L1077">		} catch (Exception e) {</span>
<span class="nc" id="L1078">			handleException(e);</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1080" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1081">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1083">			methodFinish();</span>
<span class="fc" id="L1084">		}</span>
<span class="fc" id="L1085">	}</span>

	/**
	 * Saves an active deferred media forecast with forecast profiles for the given spQueues.
	 * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
	 * is stored on the SPQueue value object.
	 * It is only intended to be used for the RFS import as it does not recalculate the Required FTE after saving.
	 * In almost all cases, you want to use saveDeferredMediaForecastAsActive instead.
	 * 
	 * @param profiles             - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues             - SPQueue value objects we are updating
	 */
	public void saveDeferredMediaForecastAsActiveForRFS(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L1102">		methodStart(&quot;saveDeferredMediaForecastAsActiveForRFS&quot;, profiles, forecastsBySPQueueID,  spQueues);</span>
		try {
<span class="nc" id="L1104">			m_forecastTimeSeriesManager.saveDataForDeferredMediaActiveForecast(profiles, forecastsBySPQueueID, spQueues);</span>
<span class="nc" id="L1105">		} catch (Exception e) {</span>
<span class="nc" id="L1106">			handleException(e);</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1109">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1111">			methodFinish();</span>
<span class="nc" id="L1112">		}</span>
<span class="nc" id="L1113">	}</span>

	/**
     * Saves an active deferred media forecast with forecast profiles for the given spQueues.
     * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
     * is stored on the SPQueue value object.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues - SPQueue value objects we are updating
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void saveDeferredMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1133">		saveDeferredMediaForecastAsActive(profiles, forecastsBySPQueueID, spQueues, ForecastUpdateOriginalSource.UnknownUpdate);</span>
<span class="fc" id="L1134">	}</span>
	/**
     * Saves an active deferred media forecast with forecast profiles for the given spQueues.
     * The given SPQueues will also be updated as part of this operation as certain data for deferred media forecasts
     * is stored on the SPQueue value object.
     * Once the forecast is saved FTE Requirements will then be calculated for these spqueues.  The FTE Requirements calculation
     * is done asynchronously.
	 * @param profiles - forecast profiles belonging to the selected queues
	 * @param forecastsBySPQueueID - hashmap: key = spqueueID, value = forecasted trace data of the spqueue
	 * @param spQueues - SPQueue value objects we are updating
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void saveDeferredMediaForecastAsActive(
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues,
			ForecastUpdateOriginalSource updateSource)
				throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1154">		methodStart(&quot;saveDeferredMediaForecastAsActive&quot;);</span>
		try {
<span class="fc" id="L1156">			Collection&lt;ID&gt; savedSPQueueIDs = m_forecastTimeSeriesManager.saveDataForDeferredMediaActiveForecast(profiles, forecastsBySPQueueID, spQueues);</span>
			//After the transaction for saving forecast data has been committed, we now kick off the fte
			//requirements calculations for these spqueues
<span class="fc" id="L1159">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(savedSPQueueIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="fc" id="L1160">			updateAllocations(savedSPQueueIDs, updateSource);</span>
<span class="nc" id="L1161">		} catch (Exception e) {</span>
<span class="nc" id="L1162">    		handleException(e);</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1164" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1165">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1167">			methodFinish();</span>
<span class="fc" id="L1168">		}</span>
<span class="fc" id="L1169">	}</span>
	
    /**
     * This method is used by saveDeferredMediaForecastAsActive to save the necessary data for the outbound queues before FTE Requirements are recalculated.
	 * This method uses the 'RequiresNew' EJB transaction attribute instead of the standard 'Requires'.
	 * This means this method will get its own dedicated EJB transaction.  This is required since FTE requirements
	 * queries the data base for the updated forecast data and that data needs to be committed before FTE requirements
	 * are recalculated.
     * NOTE: Clients SHOULD NOT use this method to save active deferred forecasts.  Use saveDeferredMediaForecastAsActive instead!
     */
	public Collection&lt;ID&gt; saveDataForDeferredMediaActiveForecast(Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1182">		methodStart(&quot;saveDataForDeferredMediaActiveForecast&quot;);</span>
<span class="fc" id="L1183">		SPQueueDAO dao = new SPQueueDAO();</span>
		try {
<span class="fc" id="L1185">			saveForecastProfiles(profiles, null);</span>
<span class="fc" id="L1186">			saveForecastTimeSeries(forecastsBySPQueueID, null);</span>
<span class="fc" id="L1187">        	dao.updateObjects(spQueues);</span>
			
<span class="fc" id="L1189">        	return ValueObjectUtil.getFieldObjectCol(</span>
					ForecastProfileFieldInfo.FORECASTPROFILE_SPQUEUEID, profiles);
<span class="nc" id="L1191">		} catch (Exception e) {</span>
<span class="nc" id="L1192">    		handleException(e);</span>
<span class="nc bnc" id="L1193" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1194" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1195">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1197">        	dao.cleanUp();</span>
<span class="pc" id="L1198">			methodFinish();</span>
		}
	}

	/**
	 * Sets the forecast instance id on each Forecast Profile before saving
	 * @param profiles
	 * @param forecastInstanceID
	 * @throws BbmException
	 */
	private void saveForecastProfiles(Collection&lt;ForecastProfile&gt; profiles, ID forecastInstanceID) throws BbmException {
<span class="fc bfc" id="L1209" title="All 2 branches covered.">		for (ForecastProfile fp : profiles) {</span>
<span class="fc" id="L1210">			fp.setForecastInstanceID(forecastInstanceID);</span>
<span class="fc" id="L1211">		}</span>
<span class="fc" id="L1212">		saveForecastProfileRecords(profiles);</span>
<span class="fc" id="L1213">	}</span>
	
	/**
	 * Saves a collection of ForecastProfileLists (forecasted outbound call lists) associated to the given forecast profiles
	 * (specified by the ID of the ForecastProfile as the key of the hashmap of the parameter to this method).
	 */
	private void saveForecastProfileLists(Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsByProfileId) throws BbmException {
		//TODO: this seems to be getting called four times during save for a four week sp
<span class="fc" id="L1221">		ForecastProfileListDAO listDao = new ForecastProfileListDAO();</span>
<span class="fc bfc" id="L1222" title="All 2 branches covered.">		for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; entry : listsByProfileId.entrySet()) {</span>
<span class="fc" id="L1223">			ID profileId = entry.getKey();</span>
			// Now for this profile, see how the persisted lists match with the input lists and decide which ones to delete,
			// which ones to update and which ones to create
<span class="fc" id="L1226">			Map&lt;ID, ForecastProfileList&gt; originalList = ValueObjectUtil.getIDObjectMap(listDao.getForecastProfileListsByForecastProfileID(profileId));</span>
<span class="fc" id="L1227">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listFromUI = createForecastProfileListMap(entry.getValue());</span>
			
<span class="fc" id="L1229">			Collection&lt;ForecastProfileList&gt; onesToDelete = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc" id="L1230">			Collection&lt;ForecastProfileList&gt; onesToUpdate = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc" id="L1231">			getForecastProfileListsToDeleteAndUpdate(originalList, listFromUI, onesToDelete, onesToUpdate);</span>
<span class="fc" id="L1232">			Collection&lt;ForecastProfileList&gt; onesToCreate = getForecastProfileListsToCreate(originalList, listFromUI);</span>
			
			//The forecast profiles that we want to update actually need to be re-created, because the profiles that
			//were saved in the previous operation were cloned from the old profile and the old ones were deleted.  During
			//that delete operation, that profile's set of profile lists were deleted as well.  Therefore, we will re-create
			//the profile's forecasted lists here.
<span class="pc bpc" id="L1238" title="1 of 2 branches missed.">			for (ForecastProfileList profileListToUpdate : onesToUpdate) {</span>
<span class="nc" id="L1239">				profileListToUpdate.setID(null);</span>
<span class="nc" id="L1240">				onesToCreate.add(profileListToUpdate);</span>
<span class="nc" id="L1241">			}</span>
<span class="fc" id="L1242">			persistForecastProfileLists(onesToDelete, onesToCreate);</span>
<span class="fc" id="L1243">		}</span>
<span class="fc" id="L1244">	}</span>
	
	/**
	 * Returns a map of forecast profile list collections, keyed on the forecast profile list's ID.  Most entries
	 * in the map will only have collections with one object in them, since most forecast profile lists have a unique
	 * ID.  The exception will be for brand new lists with null IDs, that collection will contain all newly created lists
	 * that have yet to be saved.
	 */
	private Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; createForecastProfileListMap(Collection&lt;ForecastProfileList&gt; lists) {
<span class="fc" id="L1253">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; map = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
<span class="fc bfc" id="L1254" title="All 2 branches covered.">		for (ForecastProfileList forecastProfileList : lists) {</span>
<span class="pc bpc" id="L1255" title="1 of 2 branches missed.">			if (map.containsKey(forecastProfileList.getID()) == false) {</span>
<span class="fc" id="L1256">				map.put(forecastProfileList.getID(), new HashSet&lt;ForecastProfileList&gt;());</span>
			}
<span class="fc" id="L1258">			map.get(forecastProfileList.getID()).add(forecastProfileList);</span>
<span class="fc" id="L1259">		}</span>
<span class="fc" id="L1260">		return map;</span>
	}
	
	/**
	 * Populates the forecast profile lists to delete and update.
	 *
	 * @param existingOnes the existing (currently persisted) forecast profile lists
	 * @param listsFromUI the lists coming from the UI that need to e persisted (synched) into the persistence store
	 * @param onesToDelete the ones to delete - this is like an output parameter, the method will populate this collection with lists that
	 * need to be deleted based on the existing and new forecast profile lists.
	 * @param onesToUpdate the ones to update - this is like an output parameter, the method will populate this collection with lists that
	 * need to be updated based on the existing and new forecast profile lists.
	 * @return the forecast profile lists to delete
	 */
	private void getForecastProfileListsToDeleteAndUpdate(
			Map&lt;ID, ForecastProfileList&gt; existingOnes, 
			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsFromUI, 
			Collection&lt;ForecastProfileList&gt; onesToDelete,
			Collection&lt;ForecastProfileList&gt; onesToUpdate) {
		// if an existing one is not among new ones - that needs to be deleted
<span class="pc bpc" id="L1280" title="1 of 2 branches missed.">		for (Map.Entry&lt;ID, ForecastProfileList&gt; existingOneEntry : existingOnes.entrySet()) {</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">			if (!listsFromUI.containsKey(existingOneEntry.getKey())) {</span>
<span class="nc" id="L1282">				onesToDelete.add(existingOneEntry.getValue());</span>
			} else {
<span class="nc" id="L1284">				Collection&lt;ForecastProfileList&gt; listColFromUI = listsFromUI.get(existingOneEntry.getKey());</span>
<span class="nc bnc" id="L1285" title="All 2 branches missed.">				for (ForecastProfileList listFromUI : listColFromUI) { </span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">					if (isForecastProfileListModified(existingOneEntry.getValue(), listFromUI)) {</span>
<span class="nc" id="L1287">						onesToUpdate.add(listFromUI);</span>
					}
<span class="nc" id="L1289">				}</span>
			}
<span class="nc" id="L1291">		}</span>
<span class="fc" id="L1292">	}</span>
	
	private boolean isForecastProfileListModified(ForecastProfileList original, ForecastProfileList oneToCheck) {
<span class="nc bnc" id="L1295" title="All 4 branches missed.">		return (original.getRetries() != oneToCheck.getRetries() || original.getLength() != oneToCheck.getLength());</span>
	}
	
	private Collection&lt;ForecastProfileList&gt; getForecastProfileListsToCreate(Map&lt;ID, ForecastProfileList&gt; existingOnes, 
			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; newOnes) {
<span class="fc" id="L1300">		Collection&lt;ForecastProfileList&gt; onesToCreate = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="fc bfc" id="L1301" title="All 2 branches covered.">		for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; newOneEntry : newOnes.entrySet()) {</span>
<span class="pc bpc" id="L1302" title="1 of 2 branches missed.">			if (!existingOnes.containsKey(newOneEntry.getKey())) {</span>
<span class="fc" id="L1303">				onesToCreate.addAll(newOneEntry.getValue());</span>
			}
<span class="fc" id="L1305">		}</span>
<span class="fc" id="L1306">		return onesToCreate;</span>
	}

	private void saveForecastTimeSeries(Map&lt;? extends ID, ? extends TraceCube&gt; dataBySPQueueID, ID forecastInstanceID) throws BbmException {
<span class="pc bpc" id="L1310" title="2 of 4 branches missed.">		if (dataBySPQueueID == null || dataBySPQueueID.isEmpty()) return;</span>
<span class="fc" id="L1311">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="fc" id="L1312">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>
<span class="fc" id="L1313">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="fc" id="L1314">		CampaignDAO cDAO = new CampaignDAO();</span>
		try {
			// Get campaign time zone
<span class="fc" id="L1317">			SPQueue spQueue = spQueueDAO.getSPQueuesByIDs(Collections.singleton(dataBySPQueueID.keySet().iterator().next())).iterator().next();</span>
<span class="fc" id="L1318">			SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spQueue.getSpID());</span>
<span class="fc" id="L1319">			Campaign c = cDAO.getCampaign(Collections.singleton(sp.getCampaignID()), false).iterator().next();</span>
<span class="fc" id="L1320">			TimeContext timeContext = TimeContextFactory.getTimeContext(c);</span>

<span class="fc" id="L1322">			String user = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="fc" id="L1324">			Collection&lt;ForecastTimeSeries&gt; ftsToSave = new HashSet&lt;ForecastTimeSeries&gt;();</span>
<span class="fc bfc" id="L1325" title="All 2 branches covered.">			for (ID spQueueID : dataBySPQueueID.keySet()) {</span>
<span class="fc" id="L1326">				TraceCube tc = dataBySPQueueID.get(spQueueID);</span>
<span class="fc bfc" id="L1327" title="All 2 branches covered.">				for (ForecastTimeSeries fts : ForecastTimeSeriesUtil.getForecastTimeSeriesCol(tc, timeContext)) {</span>
<span class="fc" id="L1328">					fts.setCreated(new Date());</span>
<span class="fc" id="L1329">					fts.setCreatedBy(user);</span>
<span class="fc" id="L1330">					fts.setForecastInstanceId(forecastInstanceID);</span>
<span class="fc" id="L1331">					fts.setSpQueueId(spQueueID);</span>
<span class="fc" id="L1332">					ftsToSave.add(fts);</span>
<span class="fc" id="L1333">				}</span>
<span class="fc" id="L1334">			}</span>
			// Delete any old forecasts for the spqueues, then save
<span class="fc" id="L1336">			ftsDAO.deleteObjectsByInstanceAndSPQueueIDs(forecastInstanceID, dataBySPQueueID.keySet());</span>
<span class="fc" id="L1337">			ftsDAO.createObjects(ftsToSave);</span>
<span class="nc" id="L1338">		} catch(Exception ex) {</span>
<span class="nc" id="L1339">			handleException(ex);</span>
<span class="nc" id="L1340">			throw new BbmUpdateException(ex); </span>
		}
		finally {
<span class="pc" id="L1343">			spQueueDAO.cleanUp();</span>
<span class="pc" id="L1344">			spDAO.cleanUp();</span>
<span class="pc" id="L1345">			cDAO.cleanUp();</span>
<span class="pc" id="L1346">			ftsDAO.cleanUp();</span>
<span class="fc" id="L1347">		}</span>
<span class="fc" id="L1348">	}</span>

	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves. If data exists for a SPQueue specified by the 
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records with the correct forecastInstanceID set.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveImmediateMediaForecastAsBase(
			String name,
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1369">		methodStart(&quot;saveImmediateMediaForecastAsBase&quot;);</span>

		try {
<span class="pc bpc" id="L1372" title="2 of 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>
	
			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="fc" id="L1376">			m_forecastTimeSeriesManager.saveImmediateMediaForecastInstance(name, profiles, forecastsBySPQueueID, true); // true means is base forecast</span>

			//recalculate FTE requirements for the given spqueues
<span class="fc" id="L1379">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L1380" title="All 2 branches covered.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="fc" id="L1381">				spqIDs.add(id);</span>
<span class="fc" id="L1382">			}		</span>
<span class="fc" id="L1383">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1384">		} catch (Exception e) {</span>
<span class="nc" id="L1385">    		handleException(e);</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1388">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1390">			methodFinish();</span>
<span class="fc" id="L1391">		}</span>
<span class="fc" id="L1392">	}</span>
	
	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves. If data exists for a SPQueue specified by the 
	 * passed in ForecastProfile, it will be replaced, but existing forecast data for spqueues
	 * that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records with the correct forecastInstanceID set.
	 * &lt;li&gt; Updates the SPQueue value objects as some data corresponding to the forecast is stored in those value objects.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveDeferredMediaForecastAsBase(
			String name,
			Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Collection&lt;SPQueue&gt; spQueues) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1415">		methodStart(&quot;saveDeferredMediaForecastAsBase&quot;);</span>
		try {
<span class="pc bpc" id="L1417" title="2 of 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>

			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="fc" id="L1421">			m_forecastTimeSeriesManager.saveDeferredMediaForecastInstance(name, profiles, forecastsBySPQueueID, spQueues, true); // true means is base forecast</span>

			//recalculate FTE requirements for the given spqueues
<span class="fc" id="L1424">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L1425" title="All 2 branches covered.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="fc" id="L1426">				spqIDs.add(id);</span>
<span class="fc" id="L1427">			}		</span>
<span class="fc" id="L1428">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1429">		} catch (Exception e) {</span>
<span class="nc" id="L1430">			handleException(e);</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">			if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1432" title="All 2 branches missed.">			if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1433">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1435">			methodFinish();</span>
<span class="fc" id="L1436">		}</span>
<span class="fc" id="L1437">	}</span>
	
	/**
	 * This method will:
	 * &lt;ol&gt;
	 * &lt;li&gt;Save the ForecastInstance record as a base forecast. This method supports incremental saves.
	 *   If data exists for a SPQueue specified by the passed in ForecastProfile, it will be replaced,
	 *   but existing forecast data for spqueues that are not passed into the method will not be modified.
	 * &lt;li&gt; Sets the ForecastInstanceID on each ForecastProfile object and saves it. If it already has
	 *   an id, it will do an update, if not, it will create.
	 * &lt;li&gt; Deletes any old ForecastTimeSeries data for the given TraceCubes then inserts new records
	 *   with the correct forecastInstanceID set.
	 * &lt;li&gt; Saves the forecasted outbound lists for the given forecast profiles.
	 * &lt;li&gt; Re-calculates the FTE requirement
	 * &lt;/ol&gt;
	 * @param profiles
	 * @param forecastsBySPQueueID
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public void saveOutboundMediaForecastAsBase(String name, Collection&lt;ForecastProfile&gt; profiles,
			Map&lt;? extends ID, ? extends TraceCube&gt; forecastsBySPQueueID,
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByProfile) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1460">		methodStart(&quot;saveOutboundMediaForecastAsBase&quot;);</span>
<span class="fc" id="L1461">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
<span class="pc bpc" id="L1463" title="2 of 4 branches missed.">			if (forecastsBySPQueueID == null || forecastsBySPQueueID.isEmpty()) throw new IllegalArgumentException(&quot;Forecast data must be specified.&quot;);</span>

			//The following method call executes in its own transaction.  This is necessary as the forecast data needs to be committed
			//before the call to recalculate FTE Requirements (which is done via an asynchronous JMS queue).
<span class="fc" id="L1467">			m_forecastTimeSeriesManager.saveOutboundMediaForecastInstance(name, profiles, forecastsBySPQueueID, listsByProfile, true); // true means is base forecast</span>
			
			//recalculate FTE requirements for the given spqueues
<span class="fc" id="L1470">			Collection&lt;ID&gt; spqIDs = new ArrayList&lt;ID&gt;();</span>
<span class="fc bfc" id="L1471" title="All 2 branches covered.">			for (ID id : forecastsBySPQueueID.keySet()) {</span>
<span class="fc" id="L1472">				spqIDs.add(id);</span>
<span class="fc" id="L1473">			}		</span>
<span class="fc" id="L1474">			FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spqIDs, forecastsBySPQueueID, m_whatIfMode);</span>
<span class="nc" id="L1475">		} catch (Exception e) {</span>
<span class="nc" id="L1476">    		handleException(e);</span>
<span class="nc bnc" id="L1477" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1479">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1481">			fpDAO.cleanUp();</span>
<span class="pc" id="L1482">			methodFinish();</span>
<span class="fc" id="L1483">		}</span>
<span class="fc" id="L1484">	}</span>

	/**
	 * Checks to see if a base forecast has been set for the given spQueueIDs
	 * @param spQueueIDs
	 * @returns Map&lt;ID, Boolean&gt; of booleans specifying if the base forecast for key SPQueue ID has been set
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Map&lt;ID, Boolean&gt; isBaseForecastSet(Collection&lt;? extends ID&gt; spQueueIDs) throws BbmFinderException {
<span class="pc bpc" id="L1494" title="2 of 4 branches missed.">		if (spQueueIDs == null || spQueueIDs.isEmpty()) return Collections.emptyMap();</span>

<span class="fc" id="L1496">		ForecastInstanceDAO fiDao = new ForecastInstanceDAO();</span>
<span class="fc" id="L1497">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="fc" id="L1498">		ForecastTimeSeriesDAO dao = new ForecastTimeSeriesDAO();</span>
		try {
<span class="fc" id="L1500">			Map&lt;ID, Boolean&gt; retVal = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc bfc" id="L1501" title="All 2 branches covered.">			for (ID id : spQueueIDs) retVal.put(id, Boolean.FALSE);</span>

<span class="fc" id="L1503">			ID spID = null;</span>
<span class="fc" id="L1504">			spID = spqDAO.getObjectByID(spQueueIDs.iterator().next()).getSpID();</span>

<span class="fc" id="L1506">			ForecastInstance baseForecast = fiDao.getBaseForecastInstance(spID);</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">			if (baseForecast == null) return retVal;</span>

<span class="fc" id="L1509">			return dao.isForecastSet(baseForecast.getID(), spQueueIDs);</span>
<span class="nc" id="L1510">		} catch (Exception e) {</span>
<span class="nc" id="L1511">			handleException(e);</span>
<span class="nc bnc" id="L1512" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L1513">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1515">			spqDAO.cleanUp();</span>
<span class="pc" id="L1516">			fiDao.cleanUp();</span>
<span class="pc" id="L1517">			dao.cleanUp();</span>
		}
	}

	/**
	 * Creates and saves a base forecast instance for the given SchedulingPeriod that includes a copy of the
	 * active forecasts of all of the given sp queues.
	 */
	public void saveActiveForecastAsBase(String name, Collection&lt;ID&gt; spQueueIDs, SchedulingPeriod sp) throws BbmCreateException, BbmUpdateException {
<span class="fc" id="L1526">		methodStart(&quot;saveActiveForecastAsBase&quot;, name, spQueueIDs, sp);</span>
		try {
<span class="pc bpc" id="L1528" title="2 of 4 branches missed.">			if (spQueueIDs == null || spQueueIDs.isEmpty())</span>
<span class="nc" id="L1529">				return;</span>
			//get active forecast profiles and null out ids to insert as new record
<span class="fc" id="L1531">			Collection&lt;ForecastProfile&gt; profiles = this.getActiveForecastProfilesBySPQueueIDs(spQueueIDs);</span>
<span class="pc bpc" id="L1532" title="2 of 4 branches missed.">			if (profiles == null || profiles.isEmpty()) {</span>
<span class="nc" id="L1533">				return; //no active forecast, nothing to set as the base</span>
			}

			//Load forecast data for each sp queue
<span class="fc" id="L1537">			Map&lt;ID, ForecastTraceCube&gt; forecastsBySPQueueID = getForecastTraceCubesForSPQueues(spQueueIDs,</span>
<span class="fc" id="L1538">					sp.getCampaignID(), sp.getStartTime(), new Date(sp.getEndTime().getTime() - 1));</span>

			//Save the base forecast instance
<span class="fc" id="L1541">			ForecastInstance baseInstance = saveForecastInstance(name, profiles, forecastsBySPQueueID, true);</span>

<span class="fc" id="L1543">			Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesByIDs(spQueueIDs);</span>
<span class="fc" id="L1544">			Map&lt;MediaType, Collection&lt;SPQueue&gt;&gt; spQueueMediaMap = MediaType.getMediaTypeMapForSPQueues(spQueues);</span>

			//Save associated data for outbound forecast instances if there are outbound queues present
<span class="pc bpc" id="L1547" title="1 of 4 branches missed.">			if (spQueueMediaMap.containsKey(MediaType.OUTBOUND) &amp;&amp; spQueueMediaMap.get(MediaType.OUTBOUND).isEmpty() == false) {</span>
				//Load the forecast profile lists (outbound call lists) for the given spqueues.  These will be copied to the
				//base forecast instance.
<span class="fc" id="L1550">				Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsByProfileID = getForecastProfileListsByProfile(profiles);</span>
<span class="fc" id="L1551">				Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; forecastProfileListsByProfile =</span>
					new HashMap&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt;();
<span class="fc bfc" id="L1553" title="All 2 branches covered.">				for (Map.Entry&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; entry : forecastProfileListsByProfileID.entrySet()) {</span>
<span class="pc bpc" id="L1554" title="1 of 2 branches missed.">					if (entry.getValue() != null) {</span>
<span class="fc bfc" id="L1555" title="All 2 branches covered.">						for (ForecastProfile profile : profiles) {</span>
<span class="pc bpc" id="L1556" title="1 of 2 branches missed.">							if (entry.getKey().equals(profile.getID())) {</span>
<span class="fc" id="L1557">								forecastProfileListsByProfile.put(profile, entry.getValue());</span>
							}
<span class="fc" id="L1559">						}</span>
					}
<span class="fc" id="L1561">				}</span>
<span class="fc" id="L1562">				saveAssociatedDataForOutboundMediaForecastInstance(baseInstance.getId(), forecastProfileListsByProfile);</span>
			}

			//Save associated data for deferred forecast instances if there are deferred queues present
<span class="fc bfc" id="L1566" title="All 2 branches covered.">			if (spQueueMediaMap.containsKey(MediaType.DEFERRED)) {</span>
<span class="fc" id="L1567">				Collection&lt;SPQueue&gt; deferredSPQueues = spQueueMediaMap.get(MediaType.DEFERRED);</span>
<span class="fc" id="L1568">				saveAssociatedDataForDeferredMediaForecastInstance(deferredSPQueues, baseInstance.getID());</span>
			}
<span class="nc" id="L1570">		} catch (Exception e) {</span>
<span class="nc" id="L1571">    		handleException(e);</span>
<span class="nc bnc" id="L1572" title="All 2 branches missed.">    		if (e instanceof BbmCreateException) throw (BbmCreateException) e;</span>
<span class="nc bnc" id="L1573" title="All 2 branches missed.">    		if (e instanceof BbmUpdateException) throw (BbmUpdateException) e;</span>
<span class="nc" id="L1574">    		throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1576">			methodFinish();</span>
<span class="fc" id="L1577">		}</span>
<span class="fc" id="L1578">	}</span>

	public void deleteForecastInstance(ID forecastInstanceID, Collection&lt;ID&gt; spQueueIDs)throws BbmFinderException
	{
<span class="nc" id="L1582">		ForecastTimeSeriesDAO ftsDAO = new ForecastTimeSeriesDAO();</span>
<span class="nc" id="L1583">		ForecastInstanceDAO fiDao = new ForecastInstanceDAO();</span>
<span class="nc" id="L1584">		ForecastProfileDAO fpDAO = new ForecastProfileDAO();</span>
		try {
<span class="nc" id="L1586">			ftsDAO.deleteObjectsByInstanceAndSPQueueIDs(forecastInstanceID, spQueueIDs);</span>
<span class="nc" id="L1587">			fpDAO.deleteObjectsByInstanceAndSPQueues(forecastInstanceID, spQueueIDs);</span>
<span class="nc" id="L1588">			fiDao.deleteObject(forecastInstanceID);</span>
<span class="nc" id="L1589">		}catch (Exception e) {</span>
<span class="nc" id="L1590">			handleException(e);</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">			if (e instanceof BbmFinderException) throw (BbmFinderException) e;</span>
<span class="nc" id="L1592">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1594">			ftsDAO.cleanUp();</span>
<span class="nc" id="L1595">			fpDAO.cleanUp();</span>
<span class="nc" id="L1596">			fiDao.cleanUp();</span>
<span class="nc" id="L1597">		}</span>

<span class="nc" id="L1599">	}</span>
	
	public Collection&lt;ForecastProfileProject&gt; getActiveProjects(Collection&lt;ID&gt; spQueueIDs) throws JdmoException, BbmFinderException
	{
<span class="nc" id="L1603">		Collection&lt;ForecastProfileProject&gt; projects = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1604">		methodStart(&quot;getActiveProjects&quot;, spQueueIDs);</span>
		try {
<span class="nc" id="L1606">			ForecastProfileProjectDAO fppDAO = new ForecastProfileProjectDAO();</span>
<span class="nc" id="L1607">			projects = fppDAO.getActiveForecastProfileProjects(spQueueIDs);</span>
<span class="nc" id="L1608">		} catch(BbmFinderException e){</span>
<span class="nc" id="L1609">			handleException(e,false);</span>
<span class="nc" id="L1610">			throw e;</span>
		} finally {
<span class="nc" id="L1612">			methodFinish();</span>
<span class="nc" id="L1613">		}</span>
<span class="nc" id="L1614">		return projects;</span>
	}
	
	/**
	 * @param forecastProfile
	 * @return
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	private void saveForecastProjectRecords(Collection&lt;ForecastProfileProject&gt; forecastProfileProjects) throws BbmCreateException, BbmUpdateException {
<span class="nc" id="L1624">		methodStart(&quot;saveForecastProjectRecords&quot;, forecastProfileProjects);</span>
<span class="nc" id="L1625">		ForecastProfileProjectDAO dao = new ForecastProfileProjectDAO();</span>

<span class="nc" id="L1627">		String user = m_sessionContext.getCallerPrincipal().getName();</span>
		try {
<span class="nc" id="L1629">			Collection&lt;ForecastProfileProject&gt; projectsToCreate = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1630">			Collection&lt;ForecastProfileProject&gt; projectsToUpdate = new ArrayList&lt;ForecastProfileProject&gt;();</span>
<span class="nc" id="L1631">            Collection&lt;ID&gt; queueSIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1632">            QueueFieldInfo queueFieldInfo = new QueueFieldInfo();</span>
			
<span class="nc bnc" id="L1634" title="All 2 branches missed.">			for (ForecastProfileProject project : forecastProfileProjects) {</span>
<span class="nc bnc" id="L1635" title="All 2 branches missed.">				if (project.getID() == null)  {</span>
<span class="nc" id="L1636">					project.setCreatedBy(user);</span>
<span class="nc" id="L1637">					project.setCreatedDate(new Date());</span>
<span class="nc" id="L1638">                    queueSIDs.add(project.getQueueID());</span>
<span class="nc" id="L1639">					projectsToCreate.add(project);</span>
				} else {
<span class="nc" id="L1641">					project.setModifiedBy(user);</span>
<span class="nc" id="L1642">					project.setModifiedDate(new Date());</span>
<span class="nc" id="L1643">					projectsToUpdate.add(project);</span>
				}				
<span class="nc" id="L1645">			}</span>
			
<span class="nc bnc" id="L1647" title="All 2 branches missed.">			if (projectsToCreate.isEmpty() == false) {</span>
<span class="nc" id="L1648">                Map&lt;ID, ID&gt; mappedQueueIDs = DAOUtil.mapIDsToDEIDs(queueSIDs, queueFieldInfo);</span>
<span class="nc bnc" id="L1649" title="All 2 branches missed.">                for (ForecastProfileProject project : projectsToCreate) {</span>
<span class="nc" id="L1650">                    project.setQueueID(mappedQueueIDs.get(project.getQueueID()));</span>
<span class="nc" id="L1651">                }</span>
<span class="nc" id="L1652">				dao.createObjects(projectsToCreate);</span>
			}

<span class="nc bnc" id="L1655" title="All 2 branches missed.">			if (projectsToUpdate.isEmpty() == false) {</span>
<span class="nc" id="L1656">				dao.updateObjects(projectsToUpdate);</span>
			}
<span class="nc" id="L1658">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1659">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1660">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1661">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L1662">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1663">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1665">			dao.cleanUp();</span>
<span class="nc" id="L1666">			methodFinish();</span>
<span class="nc" id="L1667">		}</span>
<span class="nc" id="L1668">	}</span>

	// {{ ------------------- Start Distributed Allocation -------------------- //

	/**
	 * Updates allocations and related parent or child forecasts to reflect the newly saved
	 * forecast data for the specified SPQueues.
	 * &lt;p/&gt;
	 * For every parent distributed queue in the list of SPQueueIDs, reallocates the
	 * newly saved forecast to its child queues.
	 * &lt;p/&gt;
	 * For every distributed child queue, updates the forecast allocations for its parent
	 * and the parent forecast itself.
	 * 
	 * @param savedSPQueueIDs the IDs of the SPQueues for which forecast data has just been
	 * saved.
	 * @param updateSource whether the allocations are being updated as a result of an
	 * update to the parent forecast, or the child forecast, or it is not known which.
	 * 
	 * @throws RemoteException
	 * @throws BbmFinderException
	 * @throws BbmUpdateException
	 * @throws BbmCreateException
	 */
	private void updateAllocations(
			Collection&lt;ID&gt; savedSPQueueIDs,
			ForecastUpdateOriginalSource updateSource) 
				throws RemoteException, BbmFinderException, BbmUpdateException, BbmCreateException {
		// This call only does something if spQueueId is associated with a parent distributed queue.
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">		if (updateSource != ForecastUpdateOriginalSource.ChildUpdate) {</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">			for (ID spQueueId : savedSPQueueIDs) {</span>
<span class="fc" id="L1699">				allocateForecastForSingleOrCombinedQueueIfAppropriate(spQueueId);</span>
<span class="fc" id="L1700">			}</span>
		}
		// If on the other hand this is a distributed child queue we update the parent's
		// allocations and total forecast.
<span class="fc bfc" id="L1704" title="All 2 branches covered.">		if (updateSource != ForecastUpdateOriginalSource.ParentUpdate) {</span>
<span class="fc" id="L1705">			Set&lt;SPQueue&gt; parentsToRecalculate = new HashSet&lt;SPQueue&gt;();</span>
<span class="fc bfc" id="L1706" title="All 2 branches covered.">			for (ID spQueueId : savedSPQueueIDs) {</span>
<span class="fc" id="L1707">				SPQueue parentSpQueue = m_campaignManager.getDistributedParentSpQueue(spQueueId);</span>
<span class="pc bpc" id="L1708" title="1 of 2 branches missed.">				if (parentSpQueue != null) {</span>
<span class="nc" id="L1709">					parentsToRecalculate.add(parentSpQueue);</span>
				}
<span class="fc" id="L1711">			}</span>
<span class="pc bpc" id="L1712" title="1 of 2 branches missed.">			for (SPQueue parentSpQueue : parentsToRecalculate) {</span>
<span class="nc" id="L1713">				updateChildAllocationsAndRecalculateParentForecast(parentSpQueue);</span>
<span class="nc" id="L1714">			}		</span>
		}
<span class="fc" id="L1716">	}</span>

	/**
	 * Returns a map keyed by child SP queue ID of the forecast allocation percentages for
	 * each child SP queue of the specified parent SP queue.
	 * 
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildForecastAllocationsForDistributedSpQueue(ID parentSpQueueID) 
			throws BbmFinderException {
<span class="fc" id="L1727">		Map&lt;ID, double[]&gt; allocationMap = new HashMap&lt;ID, double[]&gt;();</span>
		try {
<span class="fc" id="L1729">			Collection&lt;ForecastAllocationTimeSeries&gt; allocationRawSeries = getRawChildForecastAllocations(parentSpQueueID);</span>
<span class="fc" id="L1730">			allocationMap = convertTraceSegmentsToDataMap(</span>
<span class="fc" id="L1731">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="fc" id="L1732">					getForecastAllocationTraceSegments(allocationRawSeries),</span>
					DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
		}
<span class="nc" id="L1735">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1736">			handleException(bfe);</span>
<span class="nc" id="L1737">			throw bfe;</span>
		}
<span class="nc" id="L1739">		catch (Exception e) {</span>
<span class="nc" id="L1740">			handleException(e);</span>
<span class="nc" id="L1741">			throw new BbmFinderException(e);</span>
<span class="fc" id="L1742">		}</span>
<span class="fc" id="L1743">		return allocationMap;</span>
	}

	/**
	 * Returns any existing child forecast allocations for the specified parent
	 * SPQueue ID.
	 * 
	 * @param parentSpQueueID
	 * @return the child forecast allocations for {@code parentSpQueueID} or an
	 * empty collection if there are none defined
	 * @throws BbmFinderException
	 */
	private Collection&lt;ForecastAllocationTimeSeries&gt; getRawChildForecastAllocations(ID parentSpQueueID)
			throws BbmFinderException {
<span class="fc" id="L1757">		ForecastAllocationTimeSeriesDAO fatsDAO = new ForecastAllocationTimeSeriesDAO();</span>
		try {
<span class="fc" id="L1759">			return fatsDAO.getObjectsByParentID(parentSpQueueID);</span>
		}
		finally {
<span class="pc" id="L1762">			fatsDAO.cleanUp();</span>
		}
	}

	/**
	 * Converts the specified trace segments into a map from child SPQueue ID to data
	 * arrays.
	 * &lt;p/&gt;
	 * If the trace segment collection is empty, fills every data array with zeros.
	 * &lt;p/&gt;
	 * Converts from 96-interval days to DST aware data, filling any Fall-back DST
	 * transitions encountered with the values indicated by the specified fill type.  
	 * 
	 * @param parentSpQueue
	 * @param traceSegments
	 * @param fillType the strategy for filling in a DST transition interval of the
	 * fall-back variety
	 * @return
	 * @throws BbmFinderException
	 */
	private Map&lt;ID, double[]&gt; convertTraceSegmentsToDataMap(
			SPQueue parentSpQueue,
			Collection&lt;? extends AbstractTraceSegment&lt;? extends ValueObjectBase&gt;&gt; traceSegments,
			DSTTransitionFillType fillType)
				throws BbmFinderException, RemoteException {
<span class="fc" id="L1787">		Map&lt;ID, double[]&gt; dataMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="fc" id="L1788">		SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
		try {
<span class="fc" id="L1790">			ID spId = parentSpQueue.getSpID();</span>
<span class="fc" id="L1791">			SchedulingPeriod sp = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(spId, spDAO.getDaoFieldInfo()));</span>
<span class="fc" id="L1792">			double valueToInsertIntoGaps = 0.0;</span>
<span class="pc bpc" id="L1793" title="1 of 2 branches missed.">			if (traceSegments.isEmpty()) {</span>
<span class="fc" id="L1794">				dataMap = createDefaultAllocationMap(sp.getStartTime(), sp.getEndTime(), parentSpQueue.getID());</span>
			} else {
<span class="nc" id="L1796">				dataMap = collateTraceSegments(traceSegments, sp.getStartTime(), sp.getEndTime());</span>
<span class="nc bnc" id="L1797" title="All 2 branches missed.">				switch (fillType) {</span>
				default:
				case FillWithZeros:
<span class="nc" id="L1800">					valueToInsertIntoGaps = 0;</span>
<span class="nc" id="L1801">					break;</span>
				case FillWithEvenAllocationAcrossQueues:
<span class="nc" id="L1803">					valueToInsertIntoGaps = 100.0 / dataMap.size();</span>
				}
			}
<span class="fc" id="L1806">			dataMap = convertDataMapFromIdealTimeToDSTAwareTime(dataMap, valueToInsertIntoGaps, sp.getStartTime(), m_campaignManager.getChildSPQueueTimeZonesByParentSPQueueID(parentSpQueue.getID()));</span>
		}
		finally {
<span class="pc" id="L1809">			spDAO.cleanUp();</span>
<span class="fc" id="L1810">		}</span>
<span class="fc" id="L1811">		return dataMap;</span>
	}
	/**
	 * Returns a map keyed by child SP queue ID of the predicted allocation percentages for
	 * each child SP queue of the specified parent SP queue.
	 * 
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildPredictedAllocationsForDistributedSpQueue(ID parentSpQueueID) 
			throws BbmFinderException {
<span class="nc" id="L1822">		Map&lt;ID, double[]&gt; predictedAllocationMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1823">		PredictedAllocationTimeSeriesDAO patsDAO = new PredictedAllocationTimeSeriesDAO();</span>
		try {
<span class="nc" id="L1825">			Collection&lt;PredictedAllocationTimeSeries&gt; predictedAllocationRawSeries = patsDAO.getObjectsByParentID(parentSpQueueID);</span>
<span class="nc" id="L1826">			predictedAllocationMap = convertTraceSegmentsToDataMap(</span>
<span class="nc" id="L1827">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="nc" id="L1828">					getPredictedAllocationTraceSegments(predictedAllocationRawSeries),</span>
					DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
		}
<span class="nc" id="L1831">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1832">			handleException(bfe);</span>
<span class="nc" id="L1833">			throw bfe;</span>
		}
<span class="nc" id="L1835">		catch (Exception e) {</span>
<span class="nc" id="L1836">			handleException(e);</span>
<span class="nc" id="L1837">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L1840">			patsDAO.cleanUp();</span>
<span class="nc" id="L1841">		}</span>
<span class="nc" id="L1842">		return predictedAllocationMap;</span>
	}

	/**
	 * Returns a map keyed by child SP queue ID of the predicted paid staffing levels for
	 * each child SP queue of the specified parent SP queue.
	 * 
	 * @param parentSpQueueID
	 * @return
	 */
	public Map&lt;ID, double[]&gt; getChildPredictedStaffingForDistributedSpQueue(ID parentSpQueueID) 
			throws BbmFinderException {
<span class="nc" id="L1854">		Map&lt;ID, double[]&gt; predictedStaffingMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L1855">		PredictedAllocationTimeSeriesDAO patsDAO = new PredictedAllocationTimeSeriesDAO();</span>
		try {
<span class="nc" id="L1857">			Collection&lt;PredictedAllocationTimeSeries&gt; predictedStaffingRawSeries = patsDAO.getObjectsByParentID(parentSpQueueID);</span>
<span class="nc" id="L1858">			predictedStaffingMap = convertTraceSegmentsToDataMap(</span>
<span class="nc" id="L1859">					m_campaignManager.getSPQueue(parentSpQueueID),</span>
<span class="nc" id="L1860">					getPredictedStaffingTraceSegments(predictedStaffingRawSeries),</span>
					DSTTransitionFillType.FillWithZeros);
		}
<span class="nc" id="L1863">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L1864">			handleException(bfe);</span>
<span class="nc" id="L1865">			throw bfe;</span>
		}
<span class="nc" id="L1867">		catch (Exception e) {</span>
<span class="nc" id="L1868">			handleException(e);</span>
<span class="nc" id="L1869">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L1872">			patsDAO.cleanUp();</span>
<span class="nc" id="L1873">		}</span>
<span class="nc" id="L1874">		return predictedStaffingMap;</span>
	}

	/**
	 * Creates a default forecast allocation map that contains all zeros for the
	 * child SpQueues of the specified parent SpQueue.  The returned time series
	 * are based on idealized 24-hour days and must be further converted to
	 * DST-aware series before being suitable for client use.
	 * 
	 * @param startTime
	 * @param endTime
	 * @param distributedSpQueueId
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws JdmoException
	 */
	private Map&lt;ID, double[]&gt; createDefaultAllocationMap(
			Date startTime,
			Date endTime,
			ID distributedSpQueueId)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L1896">		Map&lt;ID, double[]&gt; defaultMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="fc" id="L1897">		int numPoints = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, endTime);</span>
<span class="fc bfc" id="L1898" title="All 2 branches covered.">		for (SPQueue spQueue : m_campaignManager.getChildSpQueuesOfDistributedSpQueue(distributedSpQueueId)) {</span>
<span class="fc" id="L1899">			defaultMap.put(spQueue.getID(), new double[numPoints]);			</span>
<span class="fc" id="L1900">		}</span>
<span class="fc" id="L1901">		return defaultMap;</span>
	}

	/**
	 * Recalculates all child
	 * forecast allocations for the children of the parent queue based on the latest
	 * saved child forecast data, recalculates the parent forecast volume, and saves all
	 * the resulting data.
	 *  
	 * @param parentSpQueue
	 * @param parentQueue
	 * @param parentSchedulingPeriod
	 * @throws BbmFinderException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void updateChildAllocationsAndRecalculateParentForecast(SPQueue parentSpQueue)
			throws BbmFinderException, BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L1920">		Queue parentQueue = new QueueDAO().getObjects(Collections.singleton(parentSpQueue.getQueueID())).iterator().next();</span>
<span class="nc" id="L1921">		ID parentSpId = parentSpQueue.getSpID();</span>
<span class="nc" id="L1922">		SchedulingPeriod parentSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(parentSpId, new SchedulingPeriodFieldInfo()));</span>
<span class="nc" id="L1923">		Collection&lt;ForecastAllocationTimeSeries&gt; rawAllocations = getRawChildForecastAllocations(parentSpQueue.getID());</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">		if ( ! rawAllocations.isEmpty() ) {</span>
<span class="nc" id="L1925">			CampaignDAO campaignDao = new CampaignDAO();</span>
			try {
<span class="nc" id="L1927">				Campaign parentCampaign = campaignDao.getObjectByID(parentSchedulingPeriod.getCampaignID());</span>
<span class="nc" id="L1928">				Collection&lt;ID&gt; queueIds = m_workloadManager.getSubQueues(Collections.singleton(parentQueue.getID()));</span>
<span class="nc" id="L1929">				ForecastTraceCube meta = new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
<span class="nc" id="L1930">				Collection&lt;TraceCube&gt; childForecasts = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
						// We don't have the child campaign ID and the method doesn't use it for 
						// a ForecastTraceCube anyway.  If the method ever starts using it we'll
						// get NullPointerExceptions and know we have to fix this.
						null, 
						queueIds,
<span class="nc" id="L1937">						parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L1938">						parentSchedulingPeriod.getEndTime());</span>
<span class="nc" id="L1939">				TraceCube parentForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
<span class="nc" id="L1941">						parentCampaign.getID(),</span>
<span class="nc" id="L1942">						Collections.singleton(parentQueue.getID()),</span>
<span class="nc" id="L1943">						parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L1944">						parentSchedulingPeriod.getEndTime()).iterator().next();</span>
<span class="nc bnc" id="L1945" title="All 2 branches missed.">				if ( ! childForecasts.isEmpty() ) {</span>
<span class="nc" id="L1946">					calculateAllocationsAndAdjustParentForecast(</span>
							parentForecast,
							childForecasts,
<span class="nc" id="L1949">							parentSchedulingPeriod.getStartTime(),</span>
<span class="nc" id="L1950">							parentSchedulingPeriod.getEndTime(),</span>
							parentSpQueue,
							parentSchedulingPeriod,
							parentQueue,
							rawAllocations);
				}
			}
			finally {
<span class="nc" id="L1958">				campaignDao.cleanUp();</span>
<span class="nc" id="L1959">			}</span>
		}
<span class="nc" id="L1961">	}</span>

	/**
	 * Recalculates all child
	 * forecast allocations for the children of the parent queue based on the latest
	 * saved child forecast data, recalculates the parent forecast volume, and saves all
	 * the resulting data.
	 * 
	 * @param parentForecast
	 * @param childForecasts
	 * @param startTime
	 * @param endTime
	 * @param parentSpQueue
	 * @param parentSp
	 * @param parentQueue
	 * @param oldRawAllocations
	 * @throws BbmFinderException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	private void calculateAllocationsAndAdjustParentForecast(
			TraceCube parentForecast,
			Collection&lt;TraceCube&gt; childForecasts,
			Date startTime,
			Date endTime,
			SPQueue parentSpQueue,
			SchedulingPeriod parentSp,
			Queue parentQueue,
			Collection&lt;ForecastAllocationTimeSeries&gt; oldRawAllocations)
				throws BbmFinderException, BbmCreateException, BbmUpdateException, RemoteException {
<span class="nc" id="L1992">		Map&lt;ID, double[]&gt; oldChildAllocations = convertTraceSegmentsToDataMap(</span>
				parentSpQueue,
<span class="nc" id="L1994">				getForecastAllocationTraceSegments(oldRawAllocations),</span>
				DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
<span class="nc" id="L1996">		Set&lt;ID&gt; childSpQueueIds = oldChildAllocations.keySet();</span>
<span class="nc" id="L1997">		Map&lt;ID, double[]&gt; childAllocations = new HashMap&lt;ID, double[]&gt;();</span>
		// Forecasts and allocation ignore DST
<span class="nc" id="L1999">		int numberOfTimeIntervals = TimeZoneUtil.numberOfDaysRound(startTime, endTime) * Trace.DAYPOINTS;</span>
<span class="nc" id="L2000">		Map&lt;ID, ID&gt; spQueueIdsByQueueIds = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc" id="L2001">		SPQueueDAO spqDao = new SPQueueDAO();</span>
<span class="nc" id="L2002">		CampaignDAO campaignDao = new CampaignDAO();</span>
		try {
<span class="nc bnc" id="L2004" title="All 2 branches missed.">			for (ID childSpQueueId : childSpQueueIds) {</span>
<span class="nc" id="L2005">				SPQueue childSpQueue = spqDao.getObjectByID(childSpQueueId);</span>
<span class="nc" id="L2006">				spQueueIdsByQueueIds.put(childSpQueue.getQueueID(), childSpQueueId);</span>
<span class="nc" id="L2007">				childAllocations.put(childSpQueueId, new double[numberOfTimeIntervals]);</span>
<span class="nc" id="L2008">			}</span>
<span class="nc" id="L2009">			Campaign parentCampaign = campaignDao.getObjectByID(parentSp.getCampaignID());</span>
<span class="nc" id="L2010">			int dayStartHours = parentCampaign.getDayBoundaryOffset() / 60;</span>
<span class="nc" id="L2011">			int dayStartMinutes = parentCampaign.getDayBoundaryOffset() % 60;</span>
<span class="nc" id="L2012">			Calendar currentDateCal = Calendar.getInstance(parentCampaign.getTimeZone());</span>
<span class="nc" id="L2013">			currentDateCal.setTime(startTime);</span>
<span class="nc" id="L2014">			int arrayIndex = 0;</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">			while (currentDateCal.getTime().before(endTime)) {</span>
				// Deliberately avoid taking DST into account when stepping through the
				// scheduling period.
				// We step through each day advancing wall clock in 15-minute increments.
				// This causes us to ignore DST transitions.  We also offset the current
				// hour and minute by the campaign's day start offset.
<span class="nc bnc" id="L2021" title="All 2 branches missed.">				for (int hour = 0; hour &lt; 24; ++hour) {</span>
<span class="nc" id="L2022">					int currentHour = (hour + dayStartHours) % 24;</span>
<span class="nc bnc" id="L2023" title="All 2 branches missed.">					for (int minute = 0; minute &lt; 60; minute += 15) {</span>
<span class="nc" id="L2024">						int currentMinute = (minute + dayStartMinutes) % 60;</span>
<span class="nc" id="L2025">						Calendar currentTimeCal = Calendar.getInstance(parentCampaign.getTimeZone());</span>
<span class="nc" id="L2026">						currentTimeCal.setTime(currentDateCal.getTime());</span>
						// If the day start offset has pushed us into the next day...
<span class="nc bnc" id="L2028" title="All 6 branches missed.">						if (currentHour &lt; hour || (currentHour == hour &amp;&amp; currentMinute &lt; minute)) {</span>
							// ... then bump the cursor up by one day.
<span class="nc" id="L2030">							currentTimeCal.add(Calendar.DAY_OF_MONTH, 1);</span>
						}
						// TODO: This may run into problems because
						// if you call set(Calendar.MILLISECOND, 0), or seconds, or minutes on a Calendar
						// that's pointing to 1am PDT on an autumn DST transition you get 1am PST which is
						// an hour later.
<span class="nc" id="L2036">						currentTimeCal.set(Calendar.HOUR_OF_DAY, hour);</span>
<span class="nc" id="L2037">						currentTimeCal.set(Calendar.MINUTE, minute);</span>

<span class="nc" id="L2039">						int parentVolumeTotal = 0;</span>
<span class="nc" id="L2040">						double rawTotalWeightedAHT = 0;</span>
<span class="nc bnc" id="L2041" title="All 2 branches missed.">						for (TraceCube childForecast : childForecasts) {</span>
<span class="nc" id="L2042">							int currentVolume = Math.max(0, childForecast.getTraceValue(Trace.CV, currentTimeCal.getTime()));</span>
<span class="nc" id="L2043">							parentVolumeTotal += currentVolume;</span>
<span class="nc" id="L2044">							rawTotalWeightedAHT += currentVolume * Math.max(0, childForecast.getTraceValue(Trace.AHT, currentTimeCal.getTime()));</span>
<span class="nc" id="L2045">						}</span>
<span class="nc bnc" id="L2046" title="All 2 branches missed.">						for (TraceCube childForecast : childForecasts) {</span>
<span class="nc" id="L2047">							ID childSpQueueID = spQueueIdsByQueueIds.get(childForecast.getQueueID());</span>
							// It's possible that one of the child queues has no forecast allocation percentages,
							// which would imply there is no entry for it in oldRawAllocations and eventually the
							// spQueueIdsByQueueIds map; in that case skip that child queues forecast adjustment
<span class="nc bnc" id="L2051" title="All 2 branches missed.">							if (childSpQueueID == null) {</span>
<span class="nc" id="L2052">								continue;</span>
							}
<span class="nc" id="L2054">							double[] allocationArray = childAllocations.get(childSpQueueID);</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">							if (parentVolumeTotal &gt; 0) {</span>
<span class="nc" id="L2056">								allocationArray[arrayIndex] = </span>
<span class="nc" id="L2057">									Math.max(childForecast.getTraceValue(Trace.CV, currentTimeCal.getTime()), 0.) / parentVolumeTotal * 100;</span>
							} else {
								// if the parent forecast is zero use the old allocation
<span class="nc" id="L2060">								allocationArray[arrayIndex] = oldChildAllocations.get(childSpQueueID)[arrayIndex];</span>
							}
<span class="nc" id="L2062">						}</span>
<span class="nc" id="L2063">						parentForecast.setTraceValue(Trace.CV, parentVolumeTotal, currentTimeCal.getTime(), true);</span>
<span class="nc bnc" id="L2064" title="All 2 branches missed.">						if (parentVolumeTotal &gt; 0) {</span>
<span class="nc" id="L2065">							parentForecast.setTraceValue(Trace.AHT, TraceUtil.roundDouble(rawTotalWeightedAHT / parentVolumeTotal), currentTimeCal.getTime(), true);</span>
						} else {
<span class="nc" id="L2067">							parentForecast.setTraceValue(Trace.AHT, 0, currentTimeCal.getTime(), true);</span>
						}
<span class="nc" id="L2069">						arrayIndex++;</span>
					}
				}
<span class="nc" id="L2072">				currentDateCal.add(Calendar.DATE, 1);</span>
			}
<span class="nc" id="L2074">			Collection&lt;ForecastProfile&gt; parentProfiles = getOrCreateForecastProfiles(parentSpQueue.getID());</span>
<span class="nc bnc" id="L2075" title="All 2 branches missed.">			for (ForecastProfile profile : parentProfiles) {</span>
				// Because this save operation is the result of a manual update to a child forecast,
				// the parent forecast is now implicitly manually defined.
<span class="nc" id="L2078">				profile.setIsModified(true);</span>
<span class="nc" id="L2079">			}</span>
<span class="nc" id="L2080">			Map&lt;ID, TraceCube&gt; forecastsBySpQueueId = new HashMap&lt;ID, TraceCube&gt;();</span>
<span class="nc" id="L2081">			forecastsBySpQueueId.put(parentSpQueue.getID(), parentForecast);</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">			if (Media.isMediaImmediate(parentQueue.getMediaID())) {</span>
<span class="nc" id="L2083">				saveImmediateMediaForecastAsActive(</span>
						parentProfiles,
						forecastsBySpQueueId,
						ForecastUpdateOriginalSource.ChildUpdate);
			} else {
<span class="nc" id="L2088">				saveDeferredMediaForecastAsActive(</span>
						parentProfiles,
						forecastsBySpQueueId,
<span class="nc" id="L2091">						Collections.singleton(parentSpQueue),</span>
						ForecastUpdateOriginalSource.ChildUpdate);
			}
<span class="nc" id="L2094">			saveChildForecastAllocationsForDistributedSpQueue(parentSpQueue.getID(), childAllocations);</span>
		}
		finally {
<span class="nc" id="L2097">			campaignDao.cleanUp();</span>
<span class="nc" id="L2098">			spqDao.cleanUp();</span>
<span class="nc" id="L2099">		}</span>
<span class="nc" id="L2100">	}</span>

	/**
	 * If the specified SpQueue is associated with an immediate or deferred media
	 * parent distributed queue (single or combined), and if child queue allocation
	 * percentages have been defined for that queue, this method allocates the currently
	 * saved forecast across the queue's children using the currently defined child allocation
	 * percentages.
	 * &lt;p/&gt;
	 * Otherwise, this method does nothing.
	 * 
	 * @param parentSpQueue an immediate or deferred parent distributed SpQueue ID, which
	 * may be either a single parent queue or a single-media combined queue.
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private void allocateForecastForSingleOrCombinedQueueIfAppropriate(ID parentSpQueueID)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L2118">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
<span class="fc" id="L2120">			SPQueue parentSpQueue = spqDao.getObjectByID(parentSpQueueID);</span>
<span class="pc bpc" id="L2121" title="1 of 2 branches missed.">			if (parentSpQueue.getMediaID() == null) {</span>
				// We don't handle combined-combined, but neither does the forecast applet.
<span class="nc" id="L2123">				return;</span>
			}
<span class="fc bfc" id="L2125" title="All 2 branches covered.">			if (Media.isMediaImmediate(parentSpQueue.getMediaID()) ||</span>
<span class="pc bpc" id="L2126" title="1 of 2 branches missed.">				Media.isMediaDeferred(parentSpQueue.getMediaID())) {</span>
<span class="pc bpc" id="L2127" title="1 of 2 branches missed.">				if (parentSpQueue.getQueueID() == null) {</span>
					// We have a combined queue; have to check allocation for every
					// queue.
<span class="nc" id="L2130">					Collection&lt;Queue&gt; singleQueues = m_workloadManager.getNonCombinedQueuesByMediaAndSP(parentSpQueue.getMediaID(), parentSpQueue.getSpID());</span>
<span class="nc bnc" id="L2131" title="All 2 branches missed.">					for (Queue singleQueue : singleQueues) {</span>
<span class="nc" id="L2132">						SPQueue spQueue = m_campaignManager.getSPQueue(parentSpQueue.getSpID(), singleQueue.getID());</span>
<span class="nc" id="L2133">						allocateForecastForSingleQueueIfAppropriate(spQueue);</span>
<span class="nc" id="L2134">					}</span>
<span class="nc" id="L2135">				} else {</span>
<span class="fc" id="L2136">					allocateForecastForSingleQueueIfAppropriate(parentSpQueue);</span>
				}
			}
		}
		finally {
<span class="pc" id="L2141">			spqDao.cleanUp();</span>
<span class="fc" id="L2142">		}</span>
<span class="fc" id="L2143">	}</span>

	/**
	 * If the specified SpQueue is associated with a single immediate or deferred media
	 * parent distributed queue, and if child queue allocation percentages have been
	 * defined for that queue, this method allocates the currently saved forecast
	 * across the queue's children using the currently defined child allocation
	 * percentages.
	 * &lt;p&gt;
	 * Otherwise, this method does nothing.
	 * 
	 * @param parentSpQueue an immediate or deferred parent distributed SpQueue ID, which
	 * must be a single parent queue, not combined.
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private void allocateForecastForSingleQueueIfAppropriate(SPQueue parentSpQueue)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L2161">		ID parentQueueId = parentSpQueue.getQueueID();</span>
<span class="pc bpc" id="L2162" title="1 of 2 branches missed.">		if (parentQueueId != null) {</span>
<span class="fc" id="L2163">			QueueDAO queueDao = new QueueDAO(); // Doesn't need cleanup call.</span>
<span class="fc" id="L2164">			Queue queue = queueDao.getObjects(Collections.singleton(parentQueueId)).iterator().next();</span>
<span class="fc bfc" id="L2165" title="All 2 branches covered.">			if (queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="fc" id="L2166">				Collection&lt;ForecastAllocationTimeSeries&gt; rawAllocations = getRawChildForecastAllocations(parentSpQueue.getID());</span>
<span class="pc bpc" id="L2167" title="1 of 2 branches missed.">				if ( ! rawAllocations.isEmpty() ) {</span>
<span class="nc" id="L2168">					SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO();</span>
<span class="nc" id="L2169">					CampaignDAO campaignDao = new CampaignDAO();</span>
					try {
<span class="nc" id="L2171">						Map&lt;ID, double[]&gt; childAllocations = convertTraceSegmentsToDataMap(</span>
								parentSpQueue,
<span class="nc" id="L2173">								getForecastAllocationTraceSegments(rawAllocations),</span>
								DSTTransitionFillType.FillWithEvenAllocationAcrossQueues);
<span class="nc" id="L2175">						ID spId = parentSpQueue.getSpID();</span>
<span class="nc" id="L2176">						SchedulingPeriod parentSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(spId, spDAO.getDaoFieldInfo()));</span>
<span class="nc" id="L2177">						Campaign parentCampaign = campaignDao.getObjectByID(parentSchedulingPeriod.getCampaignID());</span>
<span class="nc" id="L2178">						allocateParentForecastAmongChildren(parentSpQueue, parentSchedulingPeriod, parentCampaign, childAllocations);</span>
					}
					finally {
						
<span class="nc" id="L2182">						spDAO.cleanUp();</span>
<span class="nc" id="L2183">						campaignDao.cleanUp();</span>
<span class="nc" id="L2184">					}</span>
				}
			}
		}
<span class="fc" id="L2188">	}</span>

	private Collection&lt;ForecastAllocationTraceSegment&gt; getForecastAllocationTraceSegments(Collection&lt;ForecastAllocationTimeSeries&gt; sourceValueObjects) {
<span class="fc" id="L2191">		Collection&lt;ForecastAllocationTraceSegment&gt; destinationSegments = new ArrayList&lt;ForecastAllocationTraceSegment&gt;();</span>
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">		for (ForecastAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2193">			destinationSegments.add(new ForecastAllocationTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2194">		}</span>
<span class="fc" id="L2195">		return destinationSegments;</span>
	}

	private Collection&lt;PredictedAllocationTraceSegment&gt; getPredictedAllocationTraceSegments(Collection&lt;PredictedAllocationTimeSeries&gt; sourceValueObjects) {
<span class="nc" id="L2199">		Collection&lt;PredictedAllocationTraceSegment&gt; destinationSegments = new ArrayList&lt;PredictedAllocationTraceSegment&gt;();</span>
<span class="nc bnc" id="L2200" title="All 2 branches missed.">		for (PredictedAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2201">			destinationSegments.add(new PredictedAllocationTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2202">		}</span>
<span class="nc" id="L2203">		return destinationSegments;</span>
	}

	private Collection&lt;PredictedStaffingTraceSegment&gt; getPredictedStaffingTraceSegments(Collection&lt;PredictedAllocationTimeSeries&gt; sourceValueObjects) {
<span class="nc" id="L2207">		Collection&lt;PredictedStaffingTraceSegment&gt; destinationSegments = new ArrayList&lt;PredictedStaffingTraceSegment&gt;();</span>
<span class="nc bnc" id="L2208" title="All 2 branches missed.">		for (PredictedAllocationTimeSeries sourceValueObject : sourceValueObjects) {</span>
<span class="nc" id="L2209">			destinationSegments.add(new PredictedStaffingTraceSegment(sourceValueObject));</span>
<span class="nc" id="L2210">		}</span>
<span class="nc" id="L2211">		return destinationSegments;</span>
	}

	/**
	 * Saves distributed child forecast allocations for the specified SPQueue.
	 * 
	 * @param parentSpQueueID the SPQueue ID of the parent
	 * @param childAllocations child forecast allocations, keyed by SPQueue ID.
	 * @throws BbmFinderException
	 */
	public void saveChildForecastAllocationsForDistributedSpQueue(
			ID parentSpQueueID,
			Map&lt;ID, double[]&gt; childAllocations)
			throws BbmFinderException {
<span class="fc" id="L2225">		ForecastAllocationTimeSeriesDAO fatsDAO = new ForecastAllocationTimeSeriesDAO();</span>
<span class="fc" id="L2226">		SPQueueDAO spQueueDAO = new SPQueueDAO();</span>

		try {
<span class="fc" id="L2229">			String user = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="fc" id="L2231">			Collection&lt;ForecastAllocationTimeSeries&gt; fatsToSave = new HashSet&lt;ForecastAllocationTimeSeries&gt;();</span>
<span class="fc bfc" id="L2232" title="All 2 branches covered.">			for (ID spQueueID : childAllocations.keySet()) {</span>
				// Get child organization time zone
<span class="fc" id="L2234">				SPQueue childSpQueue = spQueueDAO.getSPQueuesByIDs(Collections.singleton(spQueueID)).iterator().next();</span>
<span class="fc" id="L2235">				SchedulingPeriod sp = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(childSpQueue.getSpID(), spQueueDAO.getDaoFieldInfo()));</span>
<span class="fc" id="L2236">				TimeZone timeZone = m_campaignManager.getTimeZoneByCampaignID(sp.getCampaignID());</span>
<span class="fc" id="L2237">				double[] allocations = childAllocations.get(spQueueID);</span>
<span class="fc" id="L2238">				allocations = DSTConversionUtil.convertFromDSTAwareTimeToIdealTime(allocations, 0.0, sp.getStartTime(), Duration.fromMinutes(15), timeZone);</span>
<span class="fc" id="L2239">				double[] allocationsToSave = setNegativeValuesToZero(allocations);</span>
<span class="fc bfc" id="L2240" title="All 2 branches covered.">				for (ForecastAllocationTimeSeries fats : splitDataIntoTimeSeries(sp.getStartTime(), timeZone, allocationsToSave)) {</span>
<span class="fc" id="L2241">					fats.setSourceSpQueueId(parentSpQueueID);</span>
<span class="fc" id="L2242">					fats.setDestinationSpQueueId(spQueueID);</span>
<span class="fc" id="L2243">					fats.setCreateDate(new Date());</span>
<span class="fc" id="L2244">					fats.setCreatedBy(user);</span>
<span class="fc" id="L2245">					fatsToSave.add(fats);</span>
<span class="fc" id="L2246">				}</span>
<span class="fc" id="L2247">			}</span>
			// Delete any old forecast allocations for the spqueues, then save
<span class="fc" id="L2249">			fatsDAO.deleteObjectsWithParentID(parentSpQueueID);</span>
<span class="fc" id="L2250">			fatsDAO.createObjects(fatsToSave);</span>
		}
<span class="nc" id="L2252">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2253">			handleException(bfe);</span>
<span class="nc" id="L2254">			throw bfe;</span>
		}
<span class="nc" id="L2256">		catch (BbmRemoveException bre) {</span>
<span class="nc" id="L2257">			handleException(bre);</span>
<span class="nc" id="L2258">			throw new BbmFinderException(bre);</span>
		}
<span class="nc" id="L2260">		catch (BbmCreateException bce) {</span>
<span class="nc" id="L2261">			handleException(bce);</span>
<span class="nc" id="L2262">			throw new BbmFinderException(bce);</span>
		}
<span class="nc" id="L2264">		catch (Exception e) {</span>
<span class="nc" id="L2265">			handleException(e);</span>
<span class="nc" id="L2266">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="pc" id="L2269">			fatsDAO.cleanUp();</span>
<span class="pc" id="L2270">			spQueueDAO.cleanUp();</span>
<span class="fc" id="L2271">		}</span>
<span class="fc" id="L2272">	}</span>

	/**
	 * Obtains the predicted child queue allocations for each distributed parent queue
	 * with the specified media type, aggregates that data according to the specified
	 * granularity, and saves it as the queue's forecast allocation percentages.
	 */
	public void saveAndApplyPredictedAllocationsForCombinedQueueSkilled(
			Campaign campaign,
			SPQueue parentSpQueue,
			SchedulingPeriod schedulingPeriod,
			ID mediaId,
			Duration granularity)
		throws BbmFinderException {
		// For each constituent queue,
		//   * load the predicted allocations for that queue,
		//   * aggregate them to the selected granularity,
		//   * save them as forecast allocations,
		//   * and apply them to that forecast
		try {
<span class="nc" id="L2292">			Collection&lt;Queue&gt; constituentQueues = QueueDAO.getNonCombinedQueuesByMediaAndSP(mediaId, schedulingPeriod.getID());</span>
<span class="nc" id="L2293">			Collection&lt;ID&gt; distributedSpQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">			for (Queue candidate : constituentQueues) {</span>
<span class="nc bnc" id="L2295" title="All 2 branches missed.">				if (candidate.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L2296">					distributedSpQueueIds.add(SPQueueDAO.getSPQueueID(schedulingPeriod.getID(), candidate.getID()));</span>
				}
<span class="nc" id="L2298">			}</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">			for (ID constituentSpQueueId : distributedSpQueueIds) {</span>
<span class="nc" id="L2300">				Map&lt;ID, double[]&gt; childPredictedAllocations = getChildPredictedAllocationsForDistributedSpQueue(constituentSpQueueId);</span>
<span class="nc" id="L2301">				Map&lt;ID, double[]&gt; aggregatedAllocations = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">				for (ID childSpQueueId : childPredictedAllocations.keySet()) {</span>
<span class="nc" id="L2303">					aggregatedAllocations.put(childSpQueueId, TraceOperator.averageArrayWithGranularity(childPredictedAllocations.get(childSpQueueId), granularity));</span>
<span class="nc" id="L2304">				}</span>
<span class="nc" id="L2305">				saveChildForecastAllocationsForDistributedSpQueue(constituentSpQueueId, aggregatedAllocations);</span>
<span class="nc" id="L2306">				allocateParentForecastAmongChildren(parentSpQueue, schedulingPeriod, campaign, aggregatedAllocations);</span>
<span class="nc" id="L2307">			}</span>
		}
<span class="nc" id="L2309">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2310">			handleException(bfe);</span>
<span class="nc" id="L2311">			throw bfe;</span>
		}
<span class="nc" id="L2313">		catch (Exception e) {</span>
<span class="nc" id="L2314">			handleException(e);</span>
<span class="nc" id="L2315">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2316">		}</span>
<span class="nc" id="L2317">	}</span>

	/**
	 * Obtains the predicted child queue allocations for the combined parent queue
	 * with the specified media type, aggregates that data according to the specified
	 * granularity, and saves it to each constituent parent distributed queue for the
	 * specified media type as that queue's forecast allocation percentages.
	 * &lt;p&gt;
	 * Returns a collection of constituent parent queue names for parent queues that
	 * could not be updated because at least one child SpQueue in the combined predicted 
	 * allocation data did not have any child queue of the failed parent queue linked to
	 * its scheduling period.
	 */
	public Collection&lt;String&gt; saveAndApplyPredictedAllocationsForCombinedQueueUnskilled(
			Campaign campaign,
			SPQueue parentSpQueue,
			SchedulingPeriod schedulingPeriod,
			ID mediaId,
			Duration granularity)
		throws BbmFinderException {
<span class="nc" id="L2337">		Collection&lt;String&gt; failedParentQueueNames = new ArrayList&lt;String&gt;();</span>
		// Load the predicted allocations for the parent queue,
		// aggregate them to the selected granularity,
		// then for each constituent queue,
		//   * do a sanity check to see if the constituent parent queue has linked subqueues
		//     corresponding to every child SP of the parent SpQueue;
		//       * if that fails, add the constituent parent queue's SpQueue ID to the list of
		//         failed SpQueue IDs,
		//       * otherwise
		//           * save the predicted allocations as forecast allocations,
		//           * and apply them to that forecast
<span class="nc" id="L2348">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
<span class="nc" id="L2350">			Map&lt;ID, double[]&gt; combinedPredictedAllocations = getChildPredictedAllocationsForDistributedSpQueue(parentSpQueue.getID());</span>
<span class="nc" id="L2351">			Map&lt;ID, double[]&gt; aggregatedCombinedAllocations = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">			for (ID childSpQueueId : combinedPredictedAllocations.keySet()) {</span>
<span class="nc" id="L2353">				aggregatedCombinedAllocations.put(childSpQueueId, TraceOperator.averageArrayWithGranularity(combinedPredictedAllocations.get(childSpQueueId), granularity));</span>
<span class="nc" id="L2354">			}</span>
<span class="nc" id="L2355">			Collection&lt;Queue&gt; constituentQueues = QueueDAO.getNonCombinedQueuesByMediaAndSP(mediaId, schedulingPeriod.getID());</span>
<span class="nc" id="L2356">			Collection&lt;ID&gt; distributedSpQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">			for (Queue candidate : constituentQueues) {</span>
<span class="nc bnc" id="L2358" title="All 2 branches missed.">				if (candidate.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L2359">					distributedSpQueueIds.add(SPQueueDAO.getSPQueueID(schedulingPeriod.getID(), candidate.getID()));</span>
				}
<span class="nc" id="L2361">			}</span>
<span class="nc" id="L2362">			QueueDAO queueDao = new QueueDAO();</span>
<span class="nc" id="L2363">			Collection&lt;ID&gt; failedParentQueueIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L2364" title="All 2 branches missed.">			for (ID constituentSpQueueId : distributedSpQueueIds) {</span>
<span class="nc" id="L2365">				SPQueue constituentSpQueue = spqDao.getSPQueue(constituentSpQueueId);</span>
<span class="nc" id="L2366">				Map&lt;ID, double[]&gt; mappedAllocations = mapCombinedPredictedAllocationsToConstituentSpQueue(aggregatedCombinedAllocations, constituentSpQueue);</span>
<span class="nc bnc" id="L2367" title="All 2 branches missed.">				if (mappedAllocations.isEmpty()) {</span>
<span class="nc" id="L2368">					failedParentQueueIds.add(constituentSpQueue.getQueueID());</span>
				} else {
<span class="nc" id="L2370">					saveChildForecastAllocationsForDistributedSpQueue(constituentSpQueueId, mappedAllocations);</span>
<span class="nc" id="L2371">					allocateParentForecastAmongChildren(constituentSpQueue, schedulingPeriod, campaign, mappedAllocations);</span>
				}
<span class="nc" id="L2373">			}</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">			for (Queue failedParentQueue : queueDao.getObjects(failedParentQueueIds)) {</span>
<span class="nc" id="L2375">				failedParentQueueNames.add(failedParentQueue.getName());</span>
<span class="nc" id="L2376">			}</span>
		}
<span class="nc" id="L2378">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2379">			handleException(bfe);</span>
<span class="nc" id="L2380">			throw bfe;</span>
		}
<span class="nc" id="L2382">		catch (Exception e) {</span>
<span class="nc" id="L2383">			handleException(e);</span>
<span class="nc" id="L2384">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L2387">			spqDao.cleanUp();</span>
<span class="nc" id="L2388">		}</span>
<span class="nc" id="L2389">		return failedParentQueueNames;</span>
	}

	/**
	 * For each child SpQueue represented in {@code sourceAllocations}, finds the child
	 * SpQueue of {@code targetSpQueue} with the same scheduling period, and maps
	 * the allocations in {@code sourceAllocations} to that SpQueue ID in the resulting
	 * map.  If no such target SpQueue exists the method stops processing and returns
	 * an empty map.
	 * 
	 * @param aggregatedCombinedAllocations
	 * @param constituentSpQueueId
	 * @return
	 */
	private Map&lt;ID, double[]&gt; mapCombinedPredictedAllocationsToConstituentSpQueue(
			Map&lt;ID, double[]&gt; sourceAllocations,
			SPQueue targetSpQueue)
				throws JdmoException, BbmObjectNotFoundException, BbmFinderException, RemoteException {

<span class="nc" id="L2408">		Map&lt;ID, double[]&gt; mappedAllocations = new HashMap&lt;ID, double[]&gt;();</span>

<span class="nc" id="L2410">		Collection&lt;SPQueue&gt; targetChildSpQueues = m_campaignManager.getChildSpQueuesOfDistributedSpQueue(targetSpQueue.getID());</span>

		// If the target SpQueue has fewer children than there are entries in the allocation
		// map, then we already know we're missing a queue somewhere.
<span class="nc bnc" id="L2414" title="All 2 branches missed.">		if (targetChildSpQueues.size() &lt; sourceAllocations.size()) {</span>
<span class="nc" id="L2415">			return Collections.emptyMap();</span>
		}

<span class="nc" id="L2418">		SPQueueDAO spqDao = new SPQueueDAO();</span>
		try {
			// For each child combined spqueue, we try to find a child of the target parent
			// spqueue that has the same SP ID, and if we find it we map the source allocations
			// to the child spqueue that we found.  Otherwise we return null because there was
			// an spqueue in the allocations that had no corresponding child of the target
			// parent.
<span class="nc bnc" id="L2425" title="All 2 branches missed.">			for (ID childCombinedSpQueueId : sourceAllocations.keySet()) {</span>
<span class="nc" id="L2426">				SPQueue childCombinedSpQueue = spqDao.getSPQueue(childCombinedSpQueueId);</span>
<span class="nc" id="L2427">				SPQueue targetChildSpQueue = null;</span>
<span class="nc bnc" id="L2428" title="All 2 branches missed.">				for (SPQueue candidate : targetChildSpQueues) {</span>
<span class="nc bnc" id="L2429" title="All 2 branches missed.">					if (candidate.getSpID().equals(childCombinedSpQueue.getSpID())) {</span>
<span class="nc" id="L2430">						targetChildSpQueue = candidate;</span>
<span class="nc" id="L2431">						break;</span>
					}
<span class="nc" id="L2433">				}</span>
<span class="nc bnc" id="L2434" title="All 2 branches missed.">				if (targetChildSpQueue == null) {</span>
<span class="nc" id="L2435">					return Collections.emptyMap();</span>
				} else {
<span class="nc" id="L2437">					mappedAllocations.put(targetChildSpQueue.getID(), sourceAllocations.get(childCombinedSpQueue.getID()));</span>
				}
<span class="nc" id="L2439">			}</span>
		}
		finally {
<span class="nc" id="L2442">			spqDao.cleanUp();</span>
<span class="nc" id="L2443">		}</span>

<span class="nc" id="L2445">		return mappedAllocations;</span>
	}

	/**
	 * Collates time series data from a collection of trace segments into a map from ID to
	 * array of data values.  The returned data arrays are based on idealized 24-hour
	 * days and must be further converted to DST-aware data before being suitable for
	 * client use.
	 * 
	 * @param dataProviders
	 * @param startTime
	 * @param endTime
	 * @return
	 */
	private Map&lt;ID, double[]&gt; collateTraceSegments(
			Collection&lt;? extends AbstractTraceSegment&lt;? extends ValueObjectBase&gt;&gt; dataProviders,
			Date startTime,
			Date endTime) {

<span class="nc" id="L2464">		Map&lt;ID, double[]&gt; timeSeriesMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="nc" id="L2465">		int numPoints = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, endTime);</span>
<span class="nc bnc" id="L2466" title="All 2 branches missed.">		for (AbstractTraceSegment&lt;? extends ValueObjectBase&gt; dataProvider : dataProviders) {</span>
<span class="nc" id="L2467">			Date rowStart = dataProvider.getDate();</span>
<span class="nc" id="L2468">			int offset = ALLOCATION_VALUES_PER_ROW * TimeZoneUtil.numberOfDaysRound(startTime, rowStart);</span>
<span class="nc" id="L2469">			double[] timeSeries = timeSeriesMap.get(dataProvider.getID());</span>
<span class="nc bnc" id="L2470" title="All 2 branches missed.">			if (timeSeries == null) {</span>
<span class="nc" id="L2471">				timeSeries = new double[numPoints];</span>
<span class="nc" id="L2472">				timeSeriesMap.put(dataProvider.getID(), timeSeries);</span>
			}
<span class="nc" id="L2474">			double[] sourceArray = dataProvider.getTraceData();</span>
<span class="nc" id="L2475">			System.arraycopy(sourceArray, 0, timeSeries, offset, sourceArray.length);</span>
<span class="nc" id="L2476">		}</span>
<span class="nc" id="L2477">		return timeSeriesMap;</span>
	}

	/**
	 * Converts the array of double values into a collection of {@link ForecastAllocationTimeSeries},
	 * one for each day of data in the original array.
	 * 
	 * @param startDate the start date of the array of data
	 * @param timeZone the time zone within which the data are defined
	 * @param data double values, assumed to be specified at 15-minute intervals
	 * @return
	 */
	private Collection&lt;ForecastAllocationTimeSeries&gt; splitDataIntoTimeSeries(Date startDate, TimeZone timeZone, double[] data) {
<span class="fc" id="L2490">		Collection&lt;ForecastAllocationTimeSeries&gt; seriesCollection = new ArrayList&lt;ForecastAllocationTimeSeries&gt;();</span>
<span class="fc" id="L2491">		Calendar currentDateCal = Calendar.getInstance(timeZone);</span>
<span class="fc" id="L2492">		currentDateCal.setTime(startDate);</span>
<span class="fc" id="L2493">		int dayStartIndex = 0;</span>
<span class="fc bfc" id="L2494" title="All 2 branches covered.">		while (dayStartIndex &lt; data.length) {</span>
<span class="fc" id="L2495">			ForecastAllocationTimeSeries allocationTimeSeries = new ForecastAllocationTimeSeries();</span>
<span class="fc" id="L2496">			allocationTimeSeries.setDateTime(currentDateCal.getTime());</span>
<span class="fc" id="L2497">			allocationTimeSeries.setAllocationTimeSeries(Arrays.copyOfRange(data, dayStartIndex, dayStartIndex + ALLOCATION_VALUES_PER_ROW));</span>
<span class="fc" id="L2498">			currentDateCal.add(Calendar.DATE, 1);</span>
<span class="fc" id="L2499">			seriesCollection.add(allocationTimeSeries);</span>
<span class="fc" id="L2500">			dayStartIndex += ALLOCATION_VALUES_PER_ROW;</span>
<span class="fc" id="L2501">		}</span>
<span class="fc" id="L2502">		return seriesCollection;</span>
	}

	/**
	 * Converts each array in the source map from idealized 24-hour days to DST-aware time, where
	 * a day may be 23, 24, or 25 hours long.
	 * 
	 * @param sourceMap
	 * @param valueToInsertIntoGaps
	 * @param startTime
	 * @param timeZone
	 * @return
	 */
	private Map&lt;ID, double[]&gt; convertDataMapFromIdealTimeToDSTAwareTime(Map&lt;ID, double[]&gt; sourceMap, double valueToInsertIntoGaps, Date startTime, Map&lt;ID, TimeZone&gt; childQueueTimeZones) {
<span class="fc" id="L2516">		Map&lt;ID, double[]&gt; resultMap = new HashMap&lt;ID, double[]&gt;();</span>
<span class="fc" id="L2517">		Duration fifteenMinutes = Duration.fromMinutes(15);</span>
<span class="fc bfc" id="L2518" title="All 2 branches covered.">		for (ID childQueueId : sourceMap.keySet()) {</span>
<span class="fc" id="L2519">			double[] idealArray = sourceMap.get(childQueueId);</span>
<span class="fc" id="L2520">			double[] dstAwareArray = DSTConversionUtil.convertFromIdealTimeToDSTAwareTime(idealArray, valueToInsertIntoGaps, startTime, fifteenMinutes, childQueueTimeZones.get(childQueueId));</span>
<span class="fc" id="L2521">			resultMap.put(childQueueId, dstAwareArray);</span>
<span class="fc" id="L2522">		}</span>
<span class="fc" id="L2523">		return resultMap;</span>
	}

	/**
	 * Returns an array of values which are identical to the source values except
	 * that any negative values are replaced by zero.
	 * 
	 * @param sourceArray
	 * @return
	 */
	private double[] setNegativeValuesToZero(double[] sourceArray) {
<span class="fc" id="L2534">		double[] targetArray = new double[sourceArray.length];</span>
<span class="fc bfc" id="L2535" title="All 2 branches covered.">		for (int index = 0; index &lt; sourceArray.length; ++index) {</span>
<span class="fc" id="L2536">			targetArray[index] = Math.max(0., sourceArray[index]);</span>
		}
<span class="fc" id="L2538">		return targetArray;</span>
	}

	/**
	 * Applies the specified forecast allocations to the specified parent forecast and
	 * saves the resulting child forecasts as the active forecast for each child queue.
	 * 
	 * @param parentSpQueue the parent SP Queue
	 * @param parentSchedulingPeriod
	 * @param parentCampaign
	 * @param childAllocations a map from child SpQueueId to a time series of allocation
	 * percentages for the corresponding child queue
	 * 
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public void allocateParentForecastAmongChildren(
			SPQueue parentSpQueue,
			SchedulingPeriod parentSchedulingPeriod,
			Campaign parentCampaign,
			Map&lt;ID, double[]&gt; childAllocations)
		throws BbmFinderException, RemoteException {
<span class="fc" id="L2560">		SPQueueDAO spqDAO = new SPQueueDAO();</span>
<span class="fc" id="L2561">		QueueDAO qDAO = new QueueDAO();</span>
		try {
<span class="fc" id="L2563">			ForecastTraceCube meta = new ForecastTraceCube(new short[] {Trace.CV, Trace.AHT, Trace.CV_VH});</span>
<span class="fc" id="L2564">			Collection&lt;ID&gt; queueIds = Collections.singleton(parentSpQueue.getQueueID());</span>
<span class="fc" id="L2565">			Collection&lt;TraceCube&gt; rawParentForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
					meta,
<span class="fc" id="L2567">					parentCampaign.getID(),</span>
					queueIds,
<span class="fc" id="L2569">					parentSchedulingPeriod.getStartTime(),</span>
<span class="fc" id="L2570">					parentSchedulingPeriod.getEndTime());</span>
<span class="pc bpc" id="L2571" title="1 of 2 branches missed.">			ForecastTraceCube parentForecast = rawParentForecast.size() != 0 ?</span>
<span class="pc" id="L2572">					(ForecastTraceCube)rawParentForecast.iterator().next() :</span>
<span class="pc" id="L2573">					createZeroForecast(parentSpQueue.getQueueID(), parentSchedulingPeriod.getStartTime(), parentSchedulingPeriod.getEndTime());</span>
<span class="fc" id="L2574">			Map&lt;ID, TraceCube&gt; childForecasts = new HashMap&lt;ID, TraceCube&gt;();</span>
<span class="fc" id="L2575">			Collection&lt;ForecastProfile&gt; profiles = new ArrayList&lt;ForecastProfile&gt;();</span>
<span class="fc" id="L2576">			Collection&lt;SPQueue&gt; childSpQueues = new HashSet&lt;SPQueue&gt;();</span>
<span class="fc bfc" id="L2577" title="All 2 branches covered.">			for (ID childSpQueueId : childAllocations.keySet()) {</span>
<span class="fc" id="L2578">				SPQueue childSpQueue = spqDAO.getObjectByID(childSpQueueId);</span>
<span class="fc" id="L2579">				SchedulingPeriod childSchedulingPeriod = m_campaignManager.getSchedulingPeriodByID(DAOUtil.mapIDToSID(childSpQueue.getSpID(), spqDAO.getDaoFieldInfo()));</span>
<span class="fc" id="L2580">				Collection&lt;TraceCube&gt; rawChildForecast = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
						meta,
<span class="fc" id="L2582">						childSchedulingPeriod.getCampaignID(),</span>
<span class="fc" id="L2583">						Collections.singleton(childSpQueue.getQueueID()),</span>
<span class="fc" id="L2584">						parentSchedulingPeriod.getStartTime(),</span>
<span class="fc" id="L2585">						parentSchedulingPeriod.getEndTime());</span>
<span class="pc bpc" id="L2586" title="1 of 2 branches missed.">				ForecastTraceCube childForecast = rawChildForecast.size() != 0 ?</span>
<span class="pc" id="L2587">						(ForecastTraceCube)rawChildForecast.iterator().next() :</span>
<span class="pc" id="L2588">						createZeroForecast(childSpQueue.getQueueID(), childSchedulingPeriod.getStartTime(), childSchedulingPeriod.getEndTime());</span>
<span class="fc" id="L2589">				childForecasts.put(childSpQueueId, childForecast);</span>
<span class="fc" id="L2590">				childSpQueues.add(childSpQueue);</span>
<span class="fc" id="L2591">				profiles.addAll(getOrCreateForecastProfiles(childSpQueueId));</span>
<span class="fc" id="L2592">			}</span>
<span class="fc bfc" id="L2593" title="All 2 branches covered.">			for (ForecastProfile profile : profiles) {</span>
				// By definition, all child forecasts of distributed queues are manually defined
				// because they are derived by applying the manually defined allocation percentages
				// to the parent forecast, regardless of the source of the parent forecast.
<span class="fc" id="L2597">				profile.setIsModified(true);</span>
<span class="fc" id="L2598">			}</span>
			// Allocate volume
<span class="fc" id="L2600">			TraceOperator.distributeParentToChildren(parentForecast, childForecasts, new short[] {Trace.CV}, childAllocations);</span>
			// Copy AHT
<span class="fc bfc" id="L2602" title="All 2 branches covered.">			for (TraceCube childForecast : childForecasts.values()) {</span>
<span class="fc" id="L2603">				childForecast.setTraceValue(Trace.AHT, parentForecast.getTraceValueD(Trace.AHT, parentForecast.getRawStartDate(), parentForecast.getRawEndDate()), parentForecast.getRawStartDate());</span>
<span class="fc" id="L2604">			}</span>
<span class="fc" id="L2605">			Queue parentQueue = qDAO.getObjects(Collections.singleton(parentSpQueue.getQueueID())).iterator().next();</span>
<span class="pc bpc" id="L2606" title="1 of 2 branches missed.">			if (Media.isMediaImmediate(parentQueue.getMediaID())) {</span>
<span class="fc" id="L2607">				saveImmediateMediaForecastAsActive(profiles, childForecasts, ForecastUpdateOriginalSource.ParentUpdate);</span>
			} else {
<span class="nc" id="L2609">				saveDeferredMediaForecastAsActive(profiles, childForecasts, childSpQueues, ForecastUpdateOriginalSource.ParentUpdate);</span>
			}
		}
<span class="nc" id="L2612">		catch (BbmTimeSeriesException btse) {</span>
<span class="nc" id="L2613">			handleException(btse);</span>
<span class="nc" id="L2614">			throw new BbmFinderException(btse);</span>
		}
<span class="nc" id="L2616">		catch (BbmCreateException bce) {</span>
<span class="nc" id="L2617">			handleException(bce);</span>
<span class="nc" id="L2618">			throw new BbmFinderException(bce);</span>
		}
<span class="nc" id="L2620">		catch (BbmUpdateException bue) {</span>
<span class="nc" id="L2621">			handleException(bue);</span>
<span class="nc" id="L2622">			throw new BbmFinderException(bue);</span>
		}
		finally {
<span class="pc" id="L2625">			spqDAO.cleanUp();</span>
<span class="fc" id="L2626">		}</span>
<span class="fc" id="L2627">	}</span>

	/**
	 * Loads any forecast profiles that exist for the specified SPQueue ID.  If there are none,
	 * creates a forecast profile for each week of the associated SP.
	 * 
	 * @param spQueueID
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private Collection&lt;ForecastProfile&gt; getOrCreateForecastProfiles(ID spQueueID)
			throws BbmFinderException, RemoteException {
<span class="fc" id="L2640">		Collection&lt;ForecastProfile&gt; profiles = getActiveForecastProfilesBySPQueueIDs(Collections.singleton(spQueueID));</span>
<span class="pc bpc" id="L2641" title="1 of 2 branches missed.">		if (profiles.isEmpty()) {</span>
<span class="fc" id="L2642">			SPQueue spq = m_campaignManager.getSPQueue(spQueueID);</span>
			// This roundabout way of obtaining the weeks of the SP ensures that the
			// HOOs and the profiles are in sync.  There may be even better ways of doing
			// this, though.  I copied it from ForecastModelService.
<span class="fc" id="L2646">			Collection&lt;CampaignHOO&gt; hoos = m_campaignManager.getCampaignHOOAssignmentsBySP(spq.getSpID());</span>
<span class="fc bfc" id="L2647" title="All 2 branches covered.">			for (CampaignHOO hoo : hoos) {</span>
<span class="fc" id="L2648">				ForecastProfile forecastProfile = new ForecastProfile();</span>
<span class="fc" id="L2649">				forecastProfile.setSPQueueID(spQueueID);</span>
<span class="fc" id="L2650">				forecastProfile.setStartDate(hoo.getStartTime());</span>
<span class="fc" id="L2651">				forecastProfile.setEndDate(hoo.getEndTime());</span>
<span class="fc" id="L2652">				profiles.add(forecastProfile);</span>
<span class="fc" id="L2653">			}</span>
		}
<span class="fc" id="L2655">		return profiles;</span>
	}

	/**
	 * Creates a {@link ForecastTraceCube} whose volume, AHT, and CV/VH traces
	 * are all filled with zeros.
	 * 
	 * @param queueId
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	private static ForecastTraceCube createZeroForecast(ID queueId, Date start, Date end) throws BbmTimeSeriesException {
<span class="nc" id="L2669">		short[] types = new short[] {Trace.CV, Trace.AHT, Trace.CV_VH};</span>
<span class="nc" id="L2670">		ForecastTraceCube result = new ForecastTraceCube(queueId, start, end, types);</span>
<span class="nc bnc" id="L2671" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L2672">			result.initTraceValue(type, 0);</span>
		}
<span class="nc" id="L2674">		return result;</span>
	}

	// }} ------------------- End Distributed Allocation -------------------- //

	/**
	 * Returns a trace cube containing any strategic forecast volume or AHT values
	 * that exist within the specified time range.  Any part of the trace cube
	 * for which values were not available will contain Trace.TRACENA.
	 * 
	 * @param queueId
	 * @param startTime
	 * @param endTime
	 * @return
	 * @throws BbmFinderException
	 */
	public TraceCube getStrategicForecast(ID queueId, Date startTime, Date endTime)
			throws BbmFinderException {
<span class="nc" id="L2692">		StrategicForecastDAO strategicDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2694">			return strategicDAO.getStrategicForecastTraceCube(queueId, startTime, endTime);</span>
		}
<span class="nc" id="L2696">		catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2697">			handleException(bfe);</span>
<span class="nc" id="L2698">			throw bfe;</span>
		}
<span class="nc" id="L2700">		catch (Exception e) {</span>
<span class="nc" id="L2701">			handleException(e);</span>
<span class="nc" id="L2702">			throw new BbmFinderException(e);</span>
		}
		finally {
<span class="nc" id="L2705">			strategicDAO.cleanUp();</span>
		}
	}

	public void deleteStrategicForecast(ID queueId, Date startTime, Date endTime)
			throws BbmFinderException, BbmRemoveException {
<span class="nc" id="L2711">		StrategicForecastDAO strategicDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2713">			strategicDAO.deleteStrategicForecasts(queueId, startTime, endTime);</span>
<span class="nc" id="L2714">		} catch (BbmFinderException bfe) {</span>
<span class="nc" id="L2715">			handleException(bfe);</span>
<span class="nc" id="L2716">			throw bfe;</span>
<span class="nc" id="L2717">		} catch (JdmoException e) {</span>
<span class="nc" id="L2718">			handleException(e);</span>
<span class="nc" id="L2719">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L2721">			strategicDAO.cleanUp();</span>
<span class="nc" id="L2722">		}</span>
<span class="nc" id="L2723">	}</span>


	public void createStrategicForecast(Collection&lt;StrategicForecast&gt; strategicForecastList)
			throws BbmCreateException, RemoteException {
<span class="nc" id="L2728">		methodStart(&quot;createStrategicForecast&quot;, strategicForecastList);</span>
<span class="nc" id="L2729">		StrategicForecastDAO strategicForecastDAO = new StrategicForecastDAO();</span>
		try {
<span class="nc" id="L2731">			strategicForecastDAO.createObjects(strategicForecastList);</span>
<span class="nc" id="L2732">		} catch (Exception e) {</span>
<span class="nc" id="L2733">			handleException(e);</span>
<span class="nc" id="L2734">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L2736">			methodFinish();</span>
<span class="nc" id="L2737">			strategicForecastDAO.cleanUp();</span>
<span class="nc" id="L2738">		}</span>
<span class="nc" id="L2739">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L2744">		return m_cat;</span>
	}
	
	/**
	 * This method is used by the outbound forecast API.  When saving an outbound forecast, the associated forecast profiles
	 * are saved first and when that occurs, it is possible that the IDs on the forecast profiles get updated (sometimes the profiles
	 * are cloned before they are saved if we are saving a new instance for example).  When this happens, the IDs on the old forecast
	 * profiles are no longer valid for the associated forecast profile lists.  What we need to do then is take the ID from the new
	 * profiles and assign that forecast profile ID to its associated forecasted call lists.  This method returns a map of new forecast
	 * profile IDs and the forecasted call lists that are associated to that ID.  The lists themselves will also have thier forecast profile IDs
	 * updated.
	 * 
	 * The forecasted lists coming out of this method can then be saved since they now have the correct forecast profile ID.
	 */
	private Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; getOutboundProfileListsByForecastProfileID(Collection&lt;ForecastProfile&gt; newProfiles, 
			Map&lt;ForecastProfile, Collection&lt;ForecastProfileList&gt;&gt; listsByOldProfile) {
		//We know that when we make the call to saveForecastInstance above, it is possible that the profiles
		//are actually deleted and new ones created rather than just updating.  What we need to do then is
		//update the forecast profile IDs on the forecast profile lists with the new IDs before we save the lists.
<span class="fc" id="L2763">		Map&lt;ForecastProfile, ID&gt; profileToNewIDMap = new HashMap&lt;ForecastProfile, ID&gt;();</span>
<span class="fc bfc" id="L2764" title="All 2 branches covered.">		for (ForecastProfile oldProfile : listsByOldProfile.keySet()) {</span>
<span class="fc bfc" id="L2765" title="All 2 branches covered.">			for (ForecastProfile newProfile : newProfiles) {</span>
<span class="fc bfc" id="L2766" title="All 2 branches covered.">				if (oldProfile.areSPQueuesAndStartDatesEqual(newProfile)) {</span>
<span class="fc" id="L2767">					profileToNewIDMap.put(oldProfile, newProfile.getStringID());</span>
				}
<span class="fc" id="L2769">			}</span>
<span class="fc" id="L2770">		}</span>
<span class="fc" id="L2771">		Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; listsByProfileId = new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();</span>
<span class="fc bfc" id="L2772" title="All 2 branches covered.">		for (ForecastProfile oldProfile : listsByOldProfile.keySet()) {</span>
<span class="fc bfc" id="L2773" title="All 2 branches covered.">			for (ForecastProfileList profileList : listsByOldProfile.get(oldProfile)) {</span>
<span class="fc" id="L2774">				profileList.setProfileId(profileToNewIDMap.get(oldProfile));</span>
<span class="fc" id="L2775">			}</span>
<span class="fc" id="L2776">			listsByProfileId.put(profileToNewIDMap.get(oldProfile), listsByOldProfile.get(oldProfile));</span>
<span class="fc" id="L2777">		}</span>
		
<span class="fc" id="L2779">		return listsByProfileId;</span>
	}
	/*
	 * Though it is returning a collection of Interim Backlog it would only contain one backlog entry.
	 * As for every ForecastinstanceID and SPQueueID there is supposed to be only one backlog entry in the table
	 */
	public Collection&lt;ForecastInterimBacklog&gt; getInterimBacklogByInstanceIDnSPQID(ID forecastInstanceID , Collection&lt;ID&gt; spQueueIDs)throws BbmFinderException{
		
<span class="nc" id="L2787">		Collection&lt;ForecastInterimBacklog&gt; fibs = null;</span>
<span class="nc" id="L2788">		ForecastInterimBacklogDAO fibDAO  = null;</span>
		try {
<span class="nc" id="L2790">			fibDAO = new ForecastInterimBacklogDAO();</span>
<span class="nc" id="L2791">			fibs = fibDAO.getInterimBacklogForForecastInstance(spQueueIDs, DAOUtil.mapIDToSID(forecastInstanceID, new ForecastInstanceFieldInfo()));</span>
<span class="nc" id="L2792">		} catch (MultiUserException e) {</span>
<span class="nc" id="L2793">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2794">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2795">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2796">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2797">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2798">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L2799">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2800">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2801">		} catch (JdmoException e) {</span>
<span class="nc" id="L2802">			handleException(&quot;getInterimBacklogByInstanceIDnSPQID(forecastInstanceID:&quot;+forecastInstanceID+&quot;+spQueueIDs :&quot;+spQueueIDs,e);</span>
<span class="nc" id="L2803">			throw new BbmFinderException(e);</span>
		}finally{
<span class="nc bnc" id="L2805" title="All 4 branches missed.">			if(fibDAO != null){</span>
<span class="nc" id="L2806">				fibDAO.cleanUp();				</span>
			}
		}
<span class="nc" id="L2809">		return fibs;</span>
	}

	/**
	 * Indicates the original source of a forecast update.  Used to prevent infinite looping
	 * of updates in a distributed forecast because parent forecasts are updated when the child
	 * forecast is updated and vice versa.
	 */
<span class="pc" id="L2817">	public static enum ForecastUpdateOriginalSource {</span>
		/** A child forecast is being saved because of an update to a parent forecast. */
<span class="fc" id="L2819">		ParentUpdate,</span>
		/** A parent forecast is being saved because of an update to a child forecast. */
<span class="fc" id="L2821">		ChildUpdate,</span>
		/** Nothing is known about whether the forecast being saved is a parent forecast, a child forecast, or neither. */
<span class="fc" id="L2823">		UnknownUpdate</span>
	}

	/**
	 * Indicates how DST transition intervals are to be filled with data when converting
	 * from ideal time to DST-aware time, if the raw data was not already empty.
	 */
<span class="pc" id="L2830">	private static enum DSTTransitionFillType {</span>
		/** The transition period is to be filled with all zeros. */
<span class="fc" id="L2832">		FillWithZeros,</span>
		/** The transition period is to be filled with 100.0 / (number of queues) */
<span class="fc" id="L2834">		FillWithEvenAllocationAcrossQueues</span>
	}
	
	/**
	 * Loads and returns forecast data in a ForecastTraceCube for each of the given
	 * SPQueues in spQueueIDs.  The trace types of each cube are determined by the media
	 * type of the queue.
	 * 
	 * If a combined SPQueue is handed in, the ForecastTraceCube that is returned will be
	 * an aggregation of the constituent sp queues.
	 * 
	 * This method assumes that all of the given SPQueues belong to the same campaign.  The
	 * SPQueues can be any combination of media types.
	 * 
	 * @param spQueueIDs - a collection of SPQueues for which forecast data will be retrieved.
	 * Must all belong to the same campaign but can be any combination of media type.
	 * @param campaignID - campaign ID of the given SPQueues.
	 * @param startDate - start period of the data to retrieve
	 * @param endDate - end period of the data to retrieve
	 * @return A map of SPQueueID -&gt; ForecastTraceCube
	 */
	public Map&lt;ID, ForecastTraceCube&gt; getForecastTraceCubesForSPQueues(
			Collection&lt;ID&gt; spQueueIDs,
			ID campaignID,
			Date startDate,
			Date endDate)
			throws BbmFinderException, RemoteException, BbmTimeSeriesException
	{
<span class="fc" id="L2862">		Map&lt;ID, ForecastTraceCube&gt; retVal = new HashMap&lt;ID, ForecastTraceCube&gt;();</span>
<span class="fc" id="L2863">		Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesByIDs(spQueueIDs);</span>
		//Separate combined and non-combined spqueues and then group the non-combined queues by media type
<span class="fc" id="L2865">		Collection&lt;SPQueue&gt; combinedSPQueues = new ArrayList&lt;SPQueue&gt;();</span>
<span class="fc" id="L2866">		Collection&lt;SPQueue&gt; nonCombinedSPQueues = new ArrayList&lt;SPQueue&gt;(spQueues);</span>
		
		//First we'll separate the combined from the non-combined
<span class="fc bfc" id="L2869" title="All 2 branches covered.">		for (Iterator&lt;SPQueue&gt; iter = nonCombinedSPQueues.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2870">			SPQueue spQueue = iter.next();</span>
<span class="pc bpc" id="L2871" title="1 of 2 branches missed.">			if (spQueue.getQueueID() == null) {</span>
<span class="nc" id="L2872">				combinedSPQueues.add(spQueue);</span>
<span class="nc" id="L2873">				iter.remove();</span>
			}
<span class="fc" id="L2875">		}</span>
		
		//Group non-combined queues by media type.  Different media types use different trace types in their meta trace cubes
<span class="fc" id="L2878">		Map&lt;MediaType, Collection&lt;SPQueue&gt;&gt; nonCombinedSPQueueMediaMap = MediaType.getMediaTypeMapForSPQueues(nonCombinedSPQueues);</span>
		
		//Load forecast data for non-combined spqueues
<span class="fc bfc" id="L2881" title="All 2 branches covered.">		for (Map.Entry&lt;MediaType, Collection&lt;SPQueue&gt;&gt; entry : nonCombinedSPQueueMediaMap.entrySet()) {</span>
			//key = queueID, value = associated spqueue
<span class="fc" id="L2883">			Map&lt;ID, SPQueue&gt; queueIDSPQueueMap = ValueObjectUtil.getFieldObjectMap(</span>
<span class="fc" id="L2884">					SPQueueFieldInfo.SPQUEUE_QUEUEID, entry.getValue());</span>
<span class="fc" id="L2885">			Collection&lt;TraceCube&gt; forecasts = m_timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
<span class="fc" id="L2886">					ForecastTraceCubeUtil.getMetaTraceCubeForMediaType(entry.getKey()), campaignID, </span>
<span class="fc" id="L2887">					queueIDSPQueueMap.keySet(), startDate, endDate);</span>
<span class="pc bpc" id="L2888" title="2 of 4 branches missed.">			if (forecasts != null &amp;&amp; forecasts.isEmpty() == false) {</span>
<span class="fc bfc" id="L2889" title="All 2 branches covered.">				for (TraceCube forecast : forecasts) {</span>
					//The TraceCubes have queueIDs set on them.  Use the queueID to look up the SPQueueID
					//and put the spqueueID + cube in the return map.
<span class="pc bpc" id="L2892" title="1 of 2 branches missed.">					if (queueIDSPQueueMap.containsKey(forecast.getQueueID())) {</span>
<span class="fc" id="L2893">						retVal.put(queueIDSPQueueMap.get(forecast.getQueueID()).getID(),</span>
								(ForecastTraceCube)forecast);
					}
<span class="fc" id="L2896">				}</span>
			}
<span class="fc" id="L2898">		}</span>
		
		//Load forecast data for combined spqueues
<span class="pc bpc" id="L2901" title="1 of 2 branches missed.">		for (SPQueue combinedSPQueue : combinedSPQueues) {</span>
<span class="nc" id="L2902">			Collection&lt;TraceCube&gt; constituentForecasts = m_timeSeriesManager.getRawCombinedQueuesTimeSeries(</span>
<span class="nc" id="L2903">					ForecastTraceCubeUtil.getMetaTraceCubeForMediaType(MediaType.get(combinedSPQueue.getMediaID())),</span>
<span class="nc" id="L2904">					campaignID, combinedSPQueue.getMediaID(), startDate, endDate);</span>
<span class="nc bnc" id="L2905" title="All 4 branches missed.">			if (constituentForecasts != null &amp;&amp; constituentForecasts.isEmpty() == false) {</span>
				//Combine the constituent forecasts
<span class="nc" id="L2907">				Map&lt;ID, ID&gt; queueMediaMap = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc bnc" id="L2908" title="All 2 branches missed.">				for (TraceCube traceCube : constituentForecasts) {</span>
<span class="nc" id="L2909">					queueMediaMap.put(traceCube.getQueueID(), combinedSPQueue.getMediaID());</span>
<span class="nc" id="L2910">				}</span>
<span class="nc" id="L2911">				ForecastTraceCube[] forecastArray =</span>
<span class="nc" id="L2912">					(ForecastTraceCube[])constituentForecasts.toArray(new ForecastTraceCube[constituentForecasts.size()]); </span>
<span class="nc" id="L2913">				ForecastTraceCube aggregatedForecast = (ForecastTraceCube)TraceOperator.combineQueue(forecastArray, true, queueMediaMap);</span>
<span class="nc" id="L2914">				retVal.put(combinedSPQueue.getID(), aggregatedForecast);</span>
			}
<span class="nc" id="L2916">		}</span>
		
		//For any SPQueue that does not have forecast data associated to it, create a forecast trace cube populated with zero values
<span class="fc bfc" id="L2919" title="All 2 branches covered.">		for (SPQueue spQueue : spQueues) {</span>
<span class="pc bpc" id="L2920" title="1 of 2 branches missed.">			if (retVal.containsKey(spQueue.getID()) == false) {</span>
<span class="nc" id="L2921">				retVal.put(spQueue.getID(), </span>
<span class="nc" id="L2922">					ForecastTraceCubeUtil.createZeroForecast(spQueue.getMediaID(), spQueue.getQueueID(), startDate, endDate));</span>
			}
<span class="fc" id="L2924">		}</span>
		
<span class="fc" id="L2926">		return retVal;</span>
	}

	/**
	 * SP Queues that have already been cloned but do not yet have a forecast time series generated after the clone
	 * operation will need to have their forecasts calculated and persisted.  This method determines which of the
	 * given SP Queues require a recalculation of their forecast data.
	 * @param spDeid - The string based ID of the SP containing these SP Queues.
	 * @param spQueuesToIdentify - List of SP Queues to verify.
	 * @return - Collection&lt;SPQueue&gt; - A subset of spQueuesToIdentify containing the sp queues that require forecast
	 * generation.
	 */
	private Collection&lt;SPQueue&gt; filterQueuesRequiringForecastGeneration(ID spDeid,
			Collection&lt;SPQueue&gt; spQueuesToIdentify) throws JdmoException {

<span class="fc" id="L2941">		methodStart(&quot;filterQueuesRequiringForecastGeneration&quot;, spDeid, spQueuesToIdentify);</span>

<span class="pc bpc" id="L2943" title="2 of 4 branches missed.">		if (spQueuesToIdentify == null || spQueuesToIdentify.isEmpty()) {</span>
<span class="nc" id="L2944">			return Collections.emptyList();</span>
		}
<span class="fc" id="L2946">		Map&lt;ID, SPQueue&gt; spQueueMap =</span>
<span class="fc" id="L2947">				ValueObjectUtil.getFieldObjectMap(SPQueueFieldInfo.SPQUEUE_ID, spQueuesToIdentify);</span>

<span class="fc" id="L2949">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L2950">		Collection&lt;SPQueue&gt; retVal = new ArrayList&lt;SPQueue&gt;();</span>
		try {
<span class="fc" id="L2952">			JdmoQuery query = dmo.createQuery(&quot;CLONESP_CHECKRELATIVEPROFILEDATA&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="fc" id="L2953">			query.setParID(1, spDeid);</span>
<span class="fc" id="L2954">			JdmoRowset rs = dmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="pc bpc" id="L2955" title="1 of 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2956">				ID spQueueNeedingForecast = rs.getID(1);</span>
<span class="nc bnc" id="L2957" title="All 2 branches missed.">				if (spQueueNeedingForecast != null) {</span>
<span class="nc" id="L2958">					retVal.add(spQueueMap.get(spQueueNeedingForecast));</span>
				} else {
<span class="nc" id="L2960">					m_cat.warn(&quot;CLONESP_CHECKRELATIVEPROFILEDATA returned NULL SPQueue IDs for SP &quot; + spDeid);</span>
				}
<span class="nc" id="L2962">			}</span>
<span class="fc" id="L2963">			rs.close();</span>
			//An SP Queue requires forecast generation if it does not already have ForecastTimeSeries data persisted in
			//the database AND it also has profile components linked to its forecast profile.
<span class="pc bpc" id="L2966" title="1 of 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L2967">				m_cat.debug(&quot;ForecastTimeSeriesManager.filterQueuesRequiringForecastGeneration: Returning &quot; +</span>
<span class="fc" id="L2968">						Arrays.toString(retVal.toArray()));</span>
			}
<span class="fc" id="L2970">			return retVal;</span>
<span class="nc" id="L2971">		} catch (JdmoException ex) {</span>
<span class="nc" id="L2972">			handleException(ex);</span>
<span class="nc" id="L2973">			throw ex;</span>
		} finally {
<span class="pc" id="L2975">			dmo.cleanUp();</span>
<span class="pc" id="L2976">			methodFinish();</span>
		}
	}

	/**
	 * Generates forecast time series data for some SPQueues in the given target sp.  The SPQueues that will
	 * have their forecasts generated are the ones that could not have their forecasts generated in the
	 * Clone SP stored procedure because of limitations in that stored procedure.  The SPQueues requiring
	 * forecast generation are the ones which have forecasts containing relative profile components.
	 *
	 * This method is intended to be used during the Clone SP operation, after the CloneSp stored procedure
	 * has been executed.
	 *
	 * This method will generate forecast time series data for the SPQueues that require it, persist that
	 * forecast data, and then re-calculate and persist the FTE Requirements time series for those SPQueues.
	 * @param sp - The new, recently cloned SP.
	 */
	public void recalculateForecastDataForClonedSp(SchedulingPeriod sp) throws BbmException, RemoteException,
			JdmoException {

<span class="fc" id="L2996">		methodStart(&quot;recalculateForecastDataForClonedSp&quot;, sp);</span>

		try {
<span class="fc" id="L2999">			m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - generating data for Sp Id:&quot; +</span>
<span class="fc" id="L3000">					sp.getID());</span>
<span class="fc" id="L3001">			Collection&lt;SPQueue&gt; spQueues = m_campaignManager.getSPQueuesBySPIDsFixed(Collections.singleton(sp.getID()));</span>

<span class="fc" id="L3003">			spQueues = filterQueuesRequiringForecastGeneration(sp.getDEID(), spQueues);</span>

<span class="pc bpc" id="L3005" title="1 of 2 branches missed.">			if (!spQueues.isEmpty()) {</span>
				// Doesn't need cleanup call.
<span class="nc" id="L3007">				QueueDAO queueDao = new QueueDAO();</span>
<span class="nc" id="L3008">				Campaign campaign = m_campaignManager.getCampaignByID(sp.getCampaignID());</span>
<span class="nc" id="L3009">				Collection&lt;ForecastProfile&gt; fps =</span>
<span class="nc" id="L3010">						getActiveForecastProfilesBySPQueueIDs(ValueObjectUtil.getIDFromObjects(spQueues));</span>
<span class="nc" id="L3011">				Collection&lt;Queue&gt; queues = queueDao.getObjects(</span>
<span class="nc" id="L3012">						ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues));</span>
<span class="nc" id="L3013">				Map&lt;ID, Queue&gt; queueIdMap = ValueObjectUtil.getIDObjectMap(queues);</span>
<span class="nc" id="L3014">				Map&lt;ID, SPQueue&gt; spQueueIdMap = ValueObjectUtil.getIDObjectMap(spQueues);</span>
<span class="nc" id="L3015">				ForecastCalculationResult result = recalculateForecastForForecastProfiles(fps, campaign, sp, spQueueIdMap,</span>
						queueIdMap);

<span class="nc" id="L3018">				Map&lt;ID, TraceCube&gt; forecastDataBySpQueueId = result.getConcatenatedForecastData();</span>

				//Convert OutboundClientForecastTraceCubes to standard ForecastTraceCubes before saving
<span class="nc" id="L3021">				convertOutboundForecastsToSavableFormat(forecastDataBySpQueueId, queueIdMap);</span>

				//Persist forecast time series data
<span class="nc" id="L3024">				saveForecastTimeSeries(forecastDataBySpQueueId, null);</span>

				//Persist forecasted outbound call lists
<span class="nc" id="L3027">				createForecastProfileLists(result.getForecastProfileLists());</span>

				//Generate FTE Requirements using new forecasts
<span class="nc" id="L3030">				FteRequirementsUtil.recalculateFteRequirementsForSPQueues(spQueueIdMap.keySet(), forecastDataBySpQueueId,</span>
						m_whatIfMode);
			}
<span class="nc" id="L3033">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3034">			handleException(ex);</span>
<span class="nc" id="L3035">			throw ex;</span>
<span class="nc" id="L3036">		} catch (JdmoException ex) {</span>
<span class="nc" id="L3037">			handleException(ex);</span>
<span class="nc" id="L3038">			throw ex;</span>
<span class="nc" id="L3039">		} catch (BbmException ex) {</span>
<span class="nc" id="L3040">			handleException(ex);</span>
<span class="nc" id="L3041">			throw ex;</span>
		} finally {
<span class="pc" id="L3043">			methodFinish();</span>
<span class="fc" id="L3044">		}</span>
<span class="fc" id="L3045">	}</span>

	/**
	 * Recalculates forecast data for the given ForecastProfiles.
	 *
	 * @param fps - Collection of ForecastProfiles for which forecast data will be calculated
	 * @param campaign - Campaign linked to the forecast profiles
	 * @param sp - SP linked to the campaign/forecast profiles
	 * @param spQueueIdMap - ID/SPQueue map of SPQueues linked to the SP/forecast profiles
	 * @param queueIdMap - ID/Queue map of Queues linked to the SP/forecast profiles
	 * @return ForecastCalculationResult containing the calculated forecast time series data and calculated
	 * ForecastProfileLists for the given ForecastProfiles.
	 */
	private ForecastCalculationResult recalculateForecastForForecastProfiles(Collection&lt;ForecastProfile&gt; fps,
			Campaign campaign, SchedulingPeriod sp, Map&lt;ID, SPQueue&gt; spQueueIdMap, Map&lt;ID, Queue&gt; queueIdMap)
			throws BbmException, RemoteException {

<span class="nc" id="L3062">		methodStart(&quot;recalculateForecastForForecastProfiles&quot;, campaign, sp, fps, spQueueIdMap, queueIdMap);</span>

		try {
<span class="nc" id="L3065">			Map&lt;ID, Collection&lt;TraceCube&gt;&gt; recalculatedForecastsBySpQueue = new HashMap&lt;ID, Collection&lt;TraceCube&gt;&gt;();</span>
<span class="nc" id="L3066">			Map&lt;ID, Collection&lt;ForecastProfileList&gt;&gt; recalculatedForecastProfileListsBySpQueue =</span>
					new HashMap&lt;ID, Collection&lt;ForecastProfileList&gt;&gt;();

<span class="nc" id="L3069">			Collection&lt;Media&gt; allMedia = m_workloadManager.getAllMedia();</span>
<span class="nc" id="L3070">			Map&lt;ID, Media&gt; mediaIdMap = ValueObjectUtil.getIDObjectMap(allMedia);</span>
<span class="nc" id="L3071">			boolean useUnknownVolumeInForecast = getUseUnknownVolumeInForecasts();</span>
<span class="nc" id="L3072">			boolean useWeightedSmoothingInForecast = getUseWeightedSmoothingInForecast();</span>
<span class="nc" id="L3073">			TimeContext tc = new TimeContext(campaign.getTimeZone(), campaign.getDayBoundaryOffset());</span>

<span class="nc bnc" id="L3075" title="All 2 branches missed.">			for (ForecastProfile fp : fps) {</span>
<span class="nc" id="L3076">				Queue queue = queueIdMap.get(spQueueIdMap.get(fp.getSPQueueID()).getQueueID());</span>
<span class="nc" id="L3077">				Profile p = new Profile(fp, queue, tc);</span>
<span class="nc bnc" id="L3078" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3079">					m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - &quot; +</span>
<span class="nc" id="L3080">							&quot;Generating forecast for profile: Interval&quot; + p.getInterval().toString());</span>
				}

<span class="nc" id="L3083">				Media media = mediaIdMap.get(queue.getMediaID());</span>

<span class="nc" id="L3085">				IHistoryProvider historyProvider = HistoryProviderFactory.createHistoryProvider(campaign,</span>
<span class="nc" id="L3086">						media, p.getQueue(), tc, m_whatIfMode);</span>
<span class="nc" id="L3087">				Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; historyData = getHistoryDataForProfile(historyProvider, p);</span>
<span class="nc" id="L3088">				IForecastCalculator calculator = ForecastCalculatorFactory.createForecastCalculator(queue.getMediaID());</span>
<span class="nc" id="L3089">				Map&lt;ID, Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt;&gt; queueHistoryMap = new</span>
						HashMap&lt;ID, Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt;&gt;();
<span class="nc" id="L3091">				queueHistoryMap.put(queue.getID(), historyData);</span>
<span class="nc" id="L3092">				TraceCube forecast = calculator.calculate(p, sp, false, null, null,</span>
						queueHistoryMap, false, useUnknownVolumeInForecast, useWeightedSmoothingInForecast);
<span class="nc bnc" id="L3094" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3095">					m_cat.debug(&quot;ForecastTimeSeriesManager.recalculateForecastDataForClonedSp - &quot; +</span>
<span class="nc" id="L3096">							&quot;Forecast data calculated for Profile &quot; + p.toString() + &quot;: &quot; +</span>
<span class="nc" id="L3097">							forecast.toString());</span>
				}
<span class="nc bnc" id="L3099" title="All 2 branches missed.">				if (recalculatedForecastsBySpQueue.get(fp.getSPQueueID()) == null) {</span>
<span class="nc" id="L3100">					recalculatedForecastsBySpQueue.put(fp.getSPQueueID(), new ArrayList&lt;TraceCube&gt;());</span>
				}
<span class="nc" id="L3102">				recalculatedForecastsBySpQueue.get(fp.getSPQueueID()).add(forecast);</span>

<span class="nc bnc" id="L3104" title="All 2 branches missed.">				if (Media.isMediaOutbound(queue.getMediaID())) {</span>
<span class="nc bnc" id="L3105" title="All 2 branches missed.">					if (recalculatedForecastProfileListsBySpQueue.get(fp.getSPQueueID()) == null) {</span>
<span class="nc" id="L3106">						recalculatedForecastProfileListsBySpQueue.put(fp.getSPQueueID(),</span>
								new ArrayList&lt;ForecastProfileList&gt;());
					}
<span class="nc" id="L3109">					Collection&lt;ForecastProfileList&gt; forecastProfileLists =</span>
<span class="nc" id="L3110">							getHistoricalOutboundCallLists(p, (OutboundHistoryProvider) historyProvider);</span>
<span class="nc bnc" id="L3111" title="All 2 branches missed.">					if (!forecastProfileLists.isEmpty()) {</span>
<span class="nc" id="L3112">						recalculatedForecastProfileListsBySpQueue.get(fp.getSPQueueID()).addAll(forecastProfileLists);</span>
					}
				}
<span class="nc" id="L3115">			}</span>

<span class="nc" id="L3117">			return new ForecastCalculationResult(recalculatedForecastsBySpQueue, recalculatedForecastProfileListsBySpQueue);</span>
		} finally {
<span class="nc" id="L3119">			methodFinish();</span>
		}
	}

	private void createForecastProfileLists(Collection&lt;ForecastProfileList&gt; forecastProfileLists) throws BbmException {

<span class="nc" id="L3125">		methodStart(&quot;createForecastProfileLists&quot;, forecastProfileLists);</span>

<span class="nc" id="L3127">		ForecastProfileListDAO dao = new ForecastProfileListDAO();</span>
		try {
<span class="nc" id="L3129">			dao.createObjects(forecastProfileLists);</span>
		} finally {
<span class="nc" id="L3131">			dao.cleanUp();</span>
<span class="nc" id="L3132">			methodFinish();</span>
<span class="nc" id="L3133">		}</span>
<span class="nc" id="L3134">	}</span>

	private Collection&lt;ForecastProfileList&gt; getHistoricalOutboundCallLists(Profile p,
			OutboundHistoryProvider historyProvider) throws BbmEJBCreateException, BbmFinderException {

<span class="nc" id="L3139">		methodStart(&quot;getHistoricalOutboundCallLists&quot;, p, historyProvider);</span>

		try {
<span class="nc" id="L3142">			Map&lt;TimeIntervalAtTime, List&lt;OutboundCallsList&gt;&gt; reforecastedOutboundCallLists =</span>
<span class="nc" id="L3143">					historyProvider.reforecastOutboundCallLists(Collections.singleton(p));</span>
<span class="nc" id="L3144">			Collection&lt;ForecastProfileList&gt; retVal = new ArrayList&lt;ForecastProfileList&gt;();</span>
<span class="nc bnc" id="L3145" title="All 2 branches missed.">			for (Collection&lt;OutboundCallsList&gt; listOfLists : reforecastedOutboundCallLists.values()) {</span>
<span class="nc bnc" id="L3146" title="All 2 branches missed.">				for (OutboundCallsList list : listOfLists) {</span>
<span class="nc" id="L3147">					retVal.add(list.getForecastProfileList());</span>
<span class="nc" id="L3148">				}</span>
<span class="nc" id="L3149">			}</span>

<span class="nc bnc" id="L3151" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3152">				m_cat.debug(&quot;getHistoricalOutboundCallLists: returning the following ForecastProfileLists: &quot;);</span>
<span class="nc bnc" id="L3153" title="All 2 branches missed.">				for (ForecastProfileList list : retVal) {</span>
<span class="nc" id="L3154">					m_cat.debug(&quot;	&quot; + list.toString());</span>
<span class="nc" id="L3155">				}</span>
			}

<span class="nc" id="L3158">			return retVal;</span>
		} finally {
<span class="nc" id="L3160">			methodFinish();</span>
		}
	}

	/**
	 * Returns the history covering the time periods of each of the profile entries in the given profile.
	 * @return Map: Key = ProfileEntryHistoryPeriod, Value = History tracecube for that period
	 */
	private Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; getHistoryDataForProfile(IHistoryProvider historyProvider,
			Profile p) throws BbmException {
<span class="nc" id="L3170">		methodStart(&quot;getHistoryDataForProfile&quot;, historyProvider, p);</span>

		try {
<span class="nc" id="L3173">			Map&lt;ProfileEntryHistoryPeriod, TraceCube&gt; historyMap = new HashMap&lt;ProfileEntryHistoryPeriod, TraceCube&gt;();</span>
<span class="nc bnc" id="L3174" title="All 2 branches missed.">			for (ProfileEntry pe : p.getProfileEntries()) {</span>
<span class="nc" id="L3175">				TraceCube historyTraceCube = pe.getHistoryPeriod().getHistoryTraceCube(historyProvider);</span>
<span class="nc bnc" id="L3176" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3177">					m_cat.debug(&quot;ForecastTimeSeriesManager.getHistoryDataForProfile for Profile: &quot; + p.toString() +</span>
<span class="nc" id="L3178">							&quot; History Data: &quot; + historyTraceCube.toString());</span>
				}
<span class="nc" id="L3180">				historyMap.put(pe.getHistoryPeriod(), historyTraceCube);</span>
<span class="nc" id="L3181">			}</span>
<span class="nc" id="L3182">			return historyMap;</span>
		} finally {
<span class="nc" id="L3184">			methodFinish();</span>
		}
	}

	/**
	 * Returns an ActualTraceCube for each queue which contains the history for that queue spanning the given
	 * date range.  The trace types in the returned cube will contain call volume and aht history data.
	 */
	public Map&lt;ID, ActualTraceCube&gt; getVolumeAndAhtHistory(Collection&lt;Queue&gt; queues, ID campaignId, Date startDate,
			Date endDate) throws BbmTimeSeriesException, BbmFinderException, BbmEJBCreateException, RemoteException {
<span class="nc" id="L3194">		methodStart(&quot;getVolumeAndAhtHistory&quot;, queues, campaignId, startDate, endDate);</span>

		try {
<span class="nc" id="L3197">			ActualTraceCube meta = new ActualTraceCube(new short[]{Trace.CV, Trace.AHT, Trace.CV_VH, Trace.VH});</span>
<span class="nc" id="L3198">			return getHistoryForForecasts(meta, queues, campaignId, startDate, endDate);</span>
<span class="nc" id="L3199">		} catch (BbmTimeSeriesException ex) {</span>
<span class="nc" id="L3200">			handleException(ex);</span>
<span class="nc" id="L3201">			throw ex;</span>
<span class="nc" id="L3202">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3203">			handleException(ex);</span>
<span class="nc" id="L3204">			throw ex;</span>
<span class="nc" id="L3205">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3206">			handleException(ex);</span>
<span class="nc" id="L3207">			throw ex;</span>
<span class="nc" id="L3208">		} catch (BbmEJBCreateException ex) {</span>
<span class="nc" id="L3209">			handleException(ex);</span>
<span class="nc" id="L3210">			throw ex;</span>
		} finally {
<span class="nc" id="L3212">			methodFinish();</span>
		}
	}

	/**
	 * Returns an ActualTraceCube for each queue which contains the history for that queue spanning the given
	 * date range.  The trace types in the returned cube will contain dials, connects/rpc, connect rate/rpcr,
	 * and aht/rpcaht.
	 */
	public Map&lt;ID, ActualTraceCube&gt; getOutboundHistory(Collection&lt;Queue&gt; queues, ID campaignId,
			Date startDate, Date endDate) throws RemoteException, BbmTimeSeriesException, BbmEJBCreateException,
			BbmFinderException {
<span class="nc" id="L3224">		methodStart(&quot;getOutboundHistory&quot;, queues, campaignId, startDate, endDate);</span>
		try {
<span class="nc" id="L3226">			ActualTraceCube meta = new ActualTraceCube(new short[]{Trace.DIALS, Trace.CONNECTS, Trace.RPC, Trace.CRATE,</span>
					Trace.AHT, Trace.RPCRATE, Trace.RPCAHT});
<span class="nc" id="L3228">			return getHistoryForForecasts(meta, queues, campaignId, startDate, endDate);</span>
<span class="nc" id="L3229">		} catch (BbmTimeSeriesException ex) {</span>
<span class="nc" id="L3230">			handleException(ex);</span>
<span class="nc" id="L3231">			throw ex;</span>
<span class="nc" id="L3232">		} catch (RemoteException ex) {</span>
<span class="nc" id="L3233">			handleException(ex);</span>
<span class="nc" id="L3234">			throw ex;</span>
<span class="nc" id="L3235">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3236">			handleException(ex);</span>
<span class="nc" id="L3237">			throw ex;</span>
<span class="nc" id="L3238">		} catch (BbmEJBCreateException ex) {</span>
<span class="nc" id="L3239">			handleException(ex);</span>
<span class="nc" id="L3240">			throw ex;</span>
		} finally {
<span class="nc" id="L3242">			methodFinish();</span>
		}
	}

	private Map&lt;ID, ActualTraceCube&gt; getHistoryForForecasts(ActualTraceCube metaCube, Collection&lt;Queue&gt; queues,
			ID campaignId, Date startDate, Date endDate) throws BbmEJBCreateException, RemoteException,
			BbmTimeSeriesException, BbmFinderException {
<span class="nc" id="L3249">		Map&lt;ID, ActualTraceCube&gt; retVal = new HashMap&lt;ID, ActualTraceCube&gt;();</span>
<span class="nc" id="L3250">		boolean includeUnknownVolume = getUseUnknownVolumeInForecasts();</span>

<span class="nc" id="L3252">		List&lt;Queue&gt; queuesToLoadHistoryFor = new ArrayList&lt;Queue&gt;(queues);</span>
<span class="nc bnc" id="L3253" title="All 2 branches missed.">		for (Iterator&lt;Queue&gt; iter = queuesToLoadHistoryFor.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3254">			Queue queue = iter.next();</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">			if (queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L3256">				retVal.put(queue.getID(), getHistoryForDistributedQueue(metaCube, queue, campaignId,</span>
						startDate, endDate, includeUnknownVolume));
<span class="nc" id="L3258">				iter.remove();</span>
			}
<span class="nc" id="L3260">		}</span>

<span class="nc bnc" id="L3262" title="All 2 branches missed.">		if (!queuesToLoadHistoryFor.isEmpty()) {</span>
<span class="nc" id="L3263">			Collection&lt;TraceCube&gt; history = timeSeriesManager.getRawMultipleQueuesTimeSeries(</span>
<span class="nc bnc" id="L3264" title="All 2 branches missed.">					metaCube, campaignId, ValueObjectUtil.getIDFromObjects(queuesToLoadHistoryFor), startDate,</span>
					endDate, false, !includeUnknownVolume);

<span class="nc bnc" id="L3267" title="All 2 branches missed.">			for (TraceCube tc : history) {</span>
<span class="nc" id="L3268">				retVal.put(tc.getQueueID(), (ActualTraceCube) tc);</span>
<span class="nc" id="L3269">			}</span>
		}

<span class="nc bnc" id="L3272" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3273">			StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L3274">			sb.append(&quot;ForecastTimeSeriesManager.getHistoryForForecasts - Returning &quot;);</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">			for (ActualTraceCube history : retVal.values()) {</span>
<span class="nc" id="L3276">				sb.append(history.toString());</span>
<span class="nc" id="L3277">			}</span>
<span class="nc" id="L3278">			m_cat.debug(sb.toString());</span>
		}
<span class="nc" id="L3280">		return retVal;</span>
	}

	private ActualTraceCube getHistoryForDistributedQueue(ActualTraceCube metaCube, Queue distributedQueue,
			ID campaignId, Date startDate, Date endDate, boolean includeUnknownVolume)
			throws BbmTimeSeriesException, BbmFinderException, RemoteException {
		// Handle a distributed queue.  We return the aggregate of the histories of
		// all the requested queue's child queues.
<span class="nc" id="L3288">		Collection&lt;ID&gt; childQueueIds = workloadManager.getSubQueues(Collections.singleton(distributedQueue.getID()));</span>
<span class="nc bnc" id="L3289" title="All 2 branches missed.">		Collection&lt;TraceCube&gt; childHistories = timeSeriesManager.getRawMultipleQueuesTimeSeries(metaCube, campaignId,</span>
				childQueueIds, startDate, endDate, false, !includeUnknownVolume);
<span class="nc" id="L3291">		TraceCube[] childHistoryArray = new TraceCube[childHistories.size()];</span>
<span class="nc" id="L3292">		childHistoryArray = childHistories.toArray(childHistoryArray);</span>
<span class="nc" id="L3293">		Map&lt;ID, ID&gt; queueMediaMap = new HashMap&lt;ID, ID&gt;();</span>
<span class="nc bnc" id="L3294" title="All 2 branches missed.">		for (TraceCube childHistory : childHistories) {</span>
<span class="nc" id="L3295">			queueMediaMap.put(childHistory.getQueueID(), distributedQueue.getMediaID());</span>
<span class="nc" id="L3296">		}</span>
<span class="nc bnc" id="L3297" title="All 2 branches missed.">		return (ActualTraceCube) TraceOperator.combineQueue(childHistoryArray,</span>
				!includeUnknownVolume, queueMediaMap);
	}

	private boolean getUseUnknownVolumeInForecasts() throws BbmEJBCreateException, RemoteException {
<span class="nc" id="L3302">		return BbmManagerFactory.getDBConfigManager().getBooleanValue(ConfigKey.FORECASTING_INCLUDEUNKNOWNCV);</span>
	}

	private boolean getUseWeightedSmoothingInForecast() throws BbmEJBCreateException, RemoteException {
<span class="nc" id="L3306">		return BbmManagerFactory.getDBConfigManager().getBooleanValue(IForecastCalculator.useWeightedSmoothingConfigKey);</span>
	}

	private static void convertOutboundForecastsToSavableFormat(Map&lt;ID, TraceCube&gt; forecastDataBySpQueueId,
			Map&lt;ID, Queue&gt; queueIdMap) throws BbmTimeSeriesException {
<span class="nc bnc" id="L3311" title="All 2 branches missed.">		for (ID spQueueId : forecastDataBySpQueueId.keySet()) {</span>
<span class="nc" id="L3312">			TraceCube forecast = forecastDataBySpQueueId.get(spQueueId);</span>
<span class="nc bnc" id="L3313" title="All 2 branches missed.">			if (Media.isMediaOutbound(queueIdMap.get(forecast.getQueueID()).getMediaID())) {</span>
<span class="nc" id="L3314">				forecastDataBySpQueueId.put(spQueueId,</span>
<span class="nc" id="L3315">						ForecastTraceCubeUtil.convertOutboundClientForecastIntoSavableFormat(forecast));</span>
			}
<span class="nc" id="L3317">		}</span>
<span class="nc" id="L3318">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>