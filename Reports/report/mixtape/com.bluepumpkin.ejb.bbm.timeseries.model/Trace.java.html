<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Trace.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">Trace.java</span></div><h1>Trace.java</h1><pre class="source lang-java linenums">/*
 * (c) 2007-2011 Verint Systems, Inc.
 */
//TODO: Insert correct original year of publication
package com.bluepumpkin.ejb.bbm.timeseries.model;

import java.io.Serializable;
import java.util.Date;



import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.timeseries.model.DataValueConstraints.Bound;
import com.bluepumpkin.ejb.bbm.timeseries.model.DataValueConstraints.BoundType;
import com.bluepumpkin.ejb.bbm.workload.model.TimeUnit;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Trace object, base object for all flavors of Trace
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 *
 * @author Sheng Song
 * @version 2.0
 */

public abstract class Trace implements Serializable {

	private static final long serialVersionUID = 1L;

	// Special values for trace points that indicate the absence of data.

	/**
	 * TRACENA generally implies that data is not available in TIMESERIES
	 * from that point forward or is invalid for that point.
	 */
	public static final int TRACENA = Integer.MIN_VALUE;
	protected static final char PRINT_TRACENA= 'N'; //used in toString
	/**
	 * TRACEOFF: NO trace value should exist for the point. This applies to
	 * immediate queues only that work within HOO (hours of operation).
	 * Deferred queues like email etc whose inflow rate is not controlled
	 * do not have this value. TRACEOFF is used in the UI only. The value
	 * sent to the database for off intervals is 0.
	 */
	public static final int TRACEOFF = Integer.MIN_VALUE+1;
	protected static final char PRINT_TRACEOFF= 'X'; //used in toString

    /**
	 * NETSTAFF_UNDER implies that the queue is under-staffed for this point.
	 */
	public static final int NETSTAFF_UNDER = -1;
	/**
	 * NETSTAFF_OVER implies that the queue is over-staffed for this point.
	 */
	public static final int NETSTAFF_OVER = 1;
	/**
	 * NETSTAFF_NOT_OVER_OR_UNDER implies that the queue is neither over-staffed or under-staffed at this point.
	 */
	public static final int NETSTAFF_NOT_OVER_OR_UNDER = 0;
	/**
	 * NETSTAFF_NA implies that we dont have Netstaffing data for this queue for this point.
	 */
	public static final int NETSTAFF_NA = Integer.MIN_VALUE;

	/**
	 * Obsolete.  Do not use.
	 */
	//TRACEUNB is obsolete--removed. all occurances changed to TRACENA
	//public static final int TRACEUNB = -3;
	/**
	 * TRACEINCOMP is applicable only to actual queues (in the real world) where
	 * data is incomplete for some intervals. The TRACEINCOMP are basically
	 * holes in the TIMESERIES data followed by more valid points. These points
	 * exist in actual time series  due to failed ACDs or similar problems where
	 * there is data missing for a very small interval followed by valid data
	 * again. This is differentiation between TRACENA and TRACEINCOMP was done
	 * to satisfy a business need to identify aggregated /combined values having
	 * some holes.
	 */
	public static final int TRACEINCOMP = Integer.MIN_VALUE+2; //denotes Incomplete trace value for Combined Queues
	protected static final char PRINT_TRACEINCOMP= 'I'; //used in toString

	/** Trace is always captured in 15 minutes interval */
	public static final short INTERVAL = 15;
	/** The time interval between trace points, in milliseconds */
	public static final long INTERVAL_IN_MILLIS = INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;
	// Every hour, there are 4 points
	public static final short HOURPOINTS = 60 / INTERVAL;
	// Every 24 hours, there are 96 points
	public static final short DAYPOINTS = 24 * 60 / INTERVAL;
	// Each week, 7 days, there are 96*7 points
	public static final short WEEKPOINTS = DAYPOINTS * 7;

	// TODO: This should really be an enum.
	// Alternatively, how about a class that parameterizes all the things that currently
	// hang from the trace type enum such as aggregation strategy, constraints, maybe even
	// persistence parameters, and have a few predefined instances of that class for the
	// current trace types, plus the ability to create arbitrary instances with the
	// desired behaviors?  That way a new client with new requirements can simply
	// instantiate a new trace type instead of the developer having to come in here
	// and add a new trace type.
	// There are 26 and counting pre-defined traces supported
	public static final short CV = 0;
	public static final short AHT = 1;
	public static final short PCA = 2;
	public static final short ASA = 3;
	public static final short ABANDONMENT = 4;
	public static final short BACKLOG = 5;
	public static final short STAFFING = 6;
	public static final short OCCUPANCY = 7;
	public static final short FTE = 8;
	//start of constants for outbound support
	public static final short DIALS = 9;
	public static final short CONNECTS = 10;
	public static final short CRATE = 11;
	public static final short RPC = 12;
	public static final short RPCRATE = 13;
	public static final short RPCAHT = 14;
	//end of constants for outbound
	public static final short VH = 15;//Volume Handled (only used when BPCONFIG.Volume_Handled is 'true')
	public static final short VAR = 16; //contains CV / VH used for calculating weighted avg for service level changes based on media type
	public static final short CV_VH =17;  // contains CV / VH used for calculating weighted avg for AHT. changes based on availability of VH &amp; VH_ENABLED_FLAG
	// For deferred media service goals
	public static final short DEADLINE_TIME = 18;
	// For Service Goals client representation of service goals, which requires that weighted averages of
	// PCA, ASA, and DEADLINE_TIME are treated as simple averages when all weights are zero.
	public static final short SERVICE_GOALS_PCA_IMMEDIATE = 19;
	public static final short SERVICE_GOALS_PCA_DEFERRED = 20;
	public static final short SERVICE_GOALS_ASA = 21;
	public static final short SERVICE_GOALS_DEADLINE_TIME = 22;


	// For Forecaster client representation, which requires that AHT is weighted on volume for
	// inbound queues and CRATE for outbound queues, and RPCAHT is weighted on RPCRATE.  Further,
	// it requires that CRATE and RPCRATE time series are treated as simple averages.
	public static final short FORECASTING_CRATE = 23;
	public static final short FORECASTING_AHT = 24;
	public static final short FORECASTING_RPCRATE = 25;
	public static final short FORECASTING_RPCAHT = 26;
	//Constants added for Netsaffing functionality
	public static final short ASTAFFING = 27;  //Adjusted Staffing applies only to Predict timeseries
	public static final short AFTE = 28;       //Adjusted FTE  applies only to Predict timeseries
	public static final short NETSTAFFING = 29;       //Netstaffing applies only  to Predict timeseries
	public static final short OVER_UNDER = 30;       //Netstaffing applies only  to Predict timeseries
	public static final short MAX_DIALS = 31;

	// A helper Type array for BPX to insert a chunk of Trace with predefined sequence
<span class="fc" id="L150">	public static final short[] TYPES = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,27,28,29,30,31};</span>
	// F&amp;S supports 9 built-in traces
<span class="fc" id="L152">	public static final short MAX_TYPE = (short) TYPES.length;</span>

	/** This constraints instance can be used for any trace type that is a percentage. */
<span class="fc" id="L155">	private static final DataValueConstraints TRACE_PERCENTAGE = DataValueConstraints.createPercentageConstraints(DataType.ForcedInteger);</span>
	/** Certain service goals types are constrained to a maximum of 99% rather than 100%, as
	 * 100% is not achievable for certain metrics. */
<span class="fc" id="L158">	private static final DataValueConstraints TRACE_0_TO_99 = new DataValueConstraints(DataType.ForcedInteger, Bound.SCALE_FROM_ZERO, new Bound(BoundType.SCALE_ORIGIN, 99));</span>

	/**
	 * Used for deadline goals
	 */

	/**
	 * Deadline Time in Seconds
	 * Modified to keep support for 1 year limit as Max deadline time in seconds 31536000
	 * 24 hrs * 60 mins *60 sec * 365 days = 31536000 seconds
	 */
<span class="fc" id="L169">	private static final DataValueConstraints TRACE_0_TO_31536000 = new DataValueConstraints(DataType.ForcedInteger, Bound.SCALE_FROM_ZERO, new Bound(BoundType.SCALE_ORIGIN, 31536000));</span>


	/**
	 * Used for trace types like Max Dials
	 */
<span class="fc" id="L175">	private static final DataValueConstraints TRACE_0_TO_100000 = new DataValueConstraints(DataType.ForcedInteger, Bound.SCALE_FROM_ZERO, new Bound(BoundType.SCALE_ORIGIN, 100000));</span>

	/**
	 * ASA, for example, is constrained to be &gt;= 0 and &lt; 1 million in the web GUI
	 */
<span class="fc" id="L180">	private static final DataValueConstraints TRACE_0_TO_999999 = new DataValueConstraints(DataType.ForcedInteger, Bound.SCALE_FROM_ZERO, new Bound(BoundType.SCALE_ORIGIN, 999999));</span>

	/**
	 * Used for data types that have a an aggregation type of AggregationType.SUM.  Summing aggregation types need a truncated upper bound rather than a scaled upper bound.
	 */
<span class="fc" id="L185">	private static final DataValueConstraints TRACE_0_TO_999999_WITH_TRUNCATION = new DataValueConstraints(DataType.ForcedInteger, Bound.SCALE_FROM_ZERO, new Bound(BoundType.TRUNCATION_POINT, 999999));</span>

	/** This constraints instance represents arbitrary non-negative trace data.  Use of this
	 * constraints instance should be minimized as it does not provide any safeguards against
	 * overflow. */
<span class="fc" id="L190">	private static final DataValueConstraints TRACE_NONNEGATIVE = DataValueConstraints.createNonNegativeConstraints(DataType.ForcedInteger, null);</span>

	/** Constraints for each trace type.  These constraints apply to individual values in a trace.
	 * The bounds on the aggregate of an interval on a trace may be different from those on a
	 * single trace value.  For instance, if volume were constrained to a maximum of 500,000 for
	 * each individual value, the upper bound for an interval containing four values would be
	 * 2,000,000.
	 */
	//TODO: Establish upper limits for all trace types.
<span class="fc" id="L199">	private static final DataValueConstraints[] TRACE_TYPE_CONSTRAINTS = new DataValueConstraints[] {</span>
		TRACE_NONNEGATIVE, // CV
		TRACE_NONNEGATIVE, // AHT
		TRACE_PERCENTAGE, // PCA--uses the most permissive constraints for any PCA type
		TRACE_NONNEGATIVE, // ASA
		TRACE_NONNEGATIVE, // ABANDONMENT COUNT
		TRACE_NONNEGATIVE, // BACKLOG
		TRACE_NONNEGATIVE, // STAFFING
		TRACE_PERCENTAGE, // OCCUPANCY
		TRACE_0_TO_999999_WITH_TRUNCATION, // FTE
		TRACE_NONNEGATIVE, // DIALS
		TRACE_NONNEGATIVE, // CONNECTS
		TRACE_PERCENTAGE, // CRATE
		TRACE_NONNEGATIVE, // RPC
		TRACE_PERCENTAGE, // RPCRATE
		TRACE_NONNEGATIVE, // RPCAHT
		TRACE_NONNEGATIVE, // VH
		TRACE_NONNEGATIVE, // VAR
		TRACE_NONNEGATIVE, // CV_VH
		TRACE_NONNEGATIVE, // DEADLINE
		TRACE_0_TO_99, // CLIENT_PCA_IMMEDIATE
		TRACE_PERCENTAGE, // CLIENT_PCA_DEFERRED
		TRACE_0_TO_999999, // CLIENT_ASA
		TRACE_0_TO_31536000, // CLIENT_DEADLINE_TIME
		TRACE_PERCENTAGE, // FORECASTING_CRATE
		TRACE_NONNEGATIVE, // FORECASTING_AHT
		TRACE_PERCENTAGE, // FORECASTING_RPCRATE
		TRACE_NONNEGATIVE, // FORECASTING_RPCAHT
		TRACE_NONNEGATIVE, // Adjusted STAFFING
		TRACE_NONNEGATIVE, // Adjusted FTE
		TRACE_NONNEGATIVE, // NETSTAFFING  FIXME: DataValueConstraints should support negative values
		TRACE_NONNEGATIVE, // OVER_UNDER  FIXME: DataValueConstraints should support negative values
		TRACE_0_TO_100000,  //MAX_DIALS
	};
<span class="fc" id="L233">	private static final DataValueConstraints ABANDONMENT_PERCENTAGE_CONSTRAINTS = TRACE_PERCENTAGE;</span>

	// Queue ID
	protected ID m_QueueID;
	// Trace must have a Start Date
	protected Date m_StartDate;

	// Default Constructor
	public Trace() {
<span class="fc" id="L242">		super();</span>
<span class="fc" id="L243">	}</span>

	// Each Trace must have a Start Date
	public Date getStartDate() {
<span class="fc" id="L247">		return m_StartDate;</span>
	}

	// Each Trace is only associated with one Queue
	public ID getQueueID() {
<span class="fc" id="L252">		return m_QueueID;</span>
	}

	public void setQueueID(ID id) {
<span class="fc" id="L256">		m_QueueID = id;</span>
<span class="fc" id="L257">	}</span>

	/**
	 * Used by toString() routine to dump Trace Information
	 */
	public static String getTraceName(short type) {
<span class="pc bpc" id="L263" title="9 of 33 branches missed.">		switch (type) {</span>
			case CV:
<span class="fc" id="L265">				return &quot;CV&quot;;</span>
			case AHT:
<span class="fc" id="L267">				return &quot;AHT&quot;;</span>
			case PCA:
<span class="fc" id="L269">				return &quot;PCA&quot;;</span>
			case ASA:
<span class="fc" id="L271">				return &quot;ASA&quot;;</span>
			case ABANDONMENT:
<span class="fc" id="L273">				return &quot;ABA&quot;;</span>
			case BACKLOG:
<span class="fc" id="L275">				return &quot;BKG&quot;;</span>
			case STAFFING:
<span class="fc" id="L277">				return &quot;STF&quot;;</span>
			case OCCUPANCY:
<span class="fc" id="L279">				return &quot;OCU&quot;;</span>
			case FTE:
<span class="fc" id="L281">				return &quot;FTE&quot;;</span>
			case DIALS:
<span class="fc" id="L283">				return &quot;DIALS&quot;;</span>
			case CONNECTS:
<span class="fc" id="L285">				return &quot;CONNECTS&quot;;</span>
			case CRATE:
<span class="fc" id="L287">				return &quot;CRATE&quot;;</span>
			case RPC:
<span class="fc" id="L289">				return &quot;RPC&quot;;</span>
			case RPCRATE:
<span class="fc" id="L291">				return &quot;RPCRATE&quot;;</span>
			case RPCAHT:
<span class="fc" id="L293">				return &quot;RPCAHT&quot;;</span>
			case VH:
<span class="fc" id="L295">				return &quot;VH&quot;;</span>
			case VAR:
<span class="fc" id="L297">				return &quot;VAR&quot;;</span>
			case CV_VH:
<span class="fc" id="L299">				return &quot;CV_VH&quot;;</span>
			case DEADLINE_TIME:
<span class="fc" id="L301">				return &quot;DEADLINE_TIME&quot;;</span>
			case SERVICE_GOALS_PCA_IMMEDIATE:
<span class="nc" id="L303">				return &quot;SERVICE_GOALS_PCA_IMMEDIATE&quot;;</span>
			case SERVICE_GOALS_PCA_DEFERRED:
<span class="nc" id="L305">				return &quot;SERVICE_GOALS_PCA_DEFERRED&quot;;</span>
			case SERVICE_GOALS_ASA:
<span class="nc" id="L307">				return &quot;SERVICE_GOALS_ASA&quot;;</span>
			case SERVICE_GOALS_DEADLINE_TIME:
<span class="nc" id="L309">				return &quot;SERVICE_GOALS_DEADLINE_TIME&quot;;</span>
			case FORECASTING_CRATE:
<span class="nc" id="L311">				return &quot;FORECASTING_CRATE&quot;;</span>
			case FORECASTING_AHT:
<span class="nc" id="L313">				return &quot;FORECASTING_AHT&quot;;</span>
			case FORECASTING_RPCRATE:
<span class="nc" id="L315">				return &quot;FORECASTING_RPCRATE&quot;;</span>
			case FORECASTING_RPCAHT:
<span class="nc" id="L317">				return &quot;FORECASTING_RPCAHT&quot;;</span>
            			case ASTAFFING:
<span class="fc" id="L319">				return &quot;ASTAFFING&quot;;</span>
			case AFTE:
<span class="fc" id="L321">				return &quot;AFTE&quot;;</span>
			case NETSTAFFING:
<span class="fc" id="L323">				return &quot;NETSTAFFING&quot;;</span>
			case OVER_UNDER:
<span class="fc" id="L325">				return &quot;OVER/ UNDER&quot;;</span>
			case MAX_DIALS:
<span class="fc" id="L327">				return &quot;MAX_DIALS&quot;;</span>
			default:
<span class="nc" id="L329">				return &quot;Unk&quot;;</span>
		}
	}

	public static String getTraceName(short[] types) {
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (types == null)</span>
<span class="nc" id="L335">			return null;</span>
<span class="nc" id="L336">		StringBuffer sb = new StringBuffer(types.length * 4);</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++)</span>
<span class="nc" id="L338">			sb.append(getTraceName(types[i])).append(',');</span>
<span class="nc" id="L339">		return sb.toString();</span>
	}

	/**
	 * Returns the numeric constraints associated with a trace type.  Because two different
	 * types of abandonment are stored in a single trace type it is also currently necessary
	 * to supply a flag whether the data type is required.
	 *
	 * @param traceType
	 * @param isRequiredData
	 * @return
	 */
	public static DataValueConstraints getTraceConstraints(short traceType, boolean isRequiredData) {
		//TODO: abandonment as a percentage should be stored in a separate trace from abandonment as a count
<span class="pc bpc" id="L353" title="3 of 4 branches missed.">		if (isRequiredData &amp;&amp; traceType == ABANDONMENT) {</span>
<span class="nc" id="L354">			return ABANDONMENT_PERCENTAGE_CONSTRAINTS;</span>
		}

<span class="fc" id="L357">		return TRACE_TYPE_CONSTRAINTS[traceType];</span>
	}

	/**
	 * Returns the numeric constraints associated with a trace type.  Because two different
	 * types of abandonment are stored in a single trace type it is also currently necessary
	 * to supply a flag whether the data type is required.  This overload also takes a time unit
	 * parameter as some trace types (current just SERVICE_GOALS_DEADLINE_TIME) have differing
	 * constraints depending on which time unit is configured for the media type.
	 *
	 * @param traceType
	 * @param isRequiredData
	 * @param tu - the time unit that has been configured for the data being represented by the trace
	 * @return
	 */
	public static DataValueConstraints getTraceConstraints(short traceType, boolean isRequiredData, TimeUnit tu) {


<span class="nc bnc" id="L375" title="All 2 branches missed.">		if (traceType != SERVICE_GOALS_DEADLINE_TIME) {</span>
<span class="nc" id="L376">			return getTraceConstraints(traceType, isRequiredData);</span>
		}

<span class="nc" id="L379">		DataValueConstraints traceConstraint = TRACE_TYPE_CONSTRAINTS[traceType];</span>
<span class="nc" id="L380">		double maxBound = 0;</span>
<span class="nc" id="L381">		double minBound = 0;</span>

<span class="nc bnc" id="L383" title="All 4 branches missed.">		if((tu != null &amp;&amp; traceConstraint != null)) {</span>

<span class="nc" id="L385">			maxBound = traceConstraint.getMaxValue();</span>
<span class="nc" id="L386">			minBound = traceConstraint.getMinValue();</span>

<span class="nc bnc" id="L388" title="All 4 branches missed.">			if (minBound != 0 &amp;&amp; !(minBound &lt; Integer.MIN_VALUE)) {</span>
<span class="nc" id="L389">				minBound = tu.convertSeconds((int)minBound);</span>
			}

<span class="nc bnc" id="L392" title="All 2 branches missed.">			if (!(maxBound &gt; Integer.MAX_VALUE)) {</span>
<span class="nc" id="L393">				maxBound = tu.convertSeconds((int)maxBound);</span>
			}

<span class="nc" id="L396">			return new DataValueConstraints(DataType.ForcedInteger,  new Bound(BoundType.SCALE_ORIGIN, minBound),</span>
					new Bound(BoundType.SCALE_ORIGIN, maxBound));
		} else {
<span class="nc" id="L399">			return TRACE_TYPE_CONSTRAINTS[traceType];</span>
		}


	}

	/**
	 * Returns the flag stating whether or not Actual Volume Handled (Actual VH) is enabled.
	 * @return The flag is always enabled, so we always return true.
	 */
	public static boolean isVolumeHandledEnabled() {
<span class="nc" id="L410">		return true;</span>
	}

	/**
	 * The flag stating whether or not Actual Volume Handled (Actual VH) is enabled.
	 * The flag is always enabled.
	 */
<span class="fc" id="L417">	private static boolean volumeEnabled = true; </span>

	/**
	 * Sets the flag stating whether or not Actual Volume Handled (Actual VH) is enabled.
	 */
	public static void setVolumeEnabled(boolean val) {
<span class="nc" id="L423">		volumeEnabled = val;</span>
<span class="nc" id="L424">	}</span>

	/**
	 * The flag telling the Trace aggregations to weigh Actual Service Level for Immediate queues by 
	 * Actual VH, instead of Actual CV. Note that for Deferred queues, we already weigh it by Actual VH,
	 * so this flag won't affect Deferred queues.
	 */
	private static boolean alwaysUseVHInsteadOfCV;

	/**
	 * Returns the flag telling the Trace aggregations to weigh Actual Service Level for Immediate queues by 
	 * Actual VH, instead of Actual CV. Note that for Deferred queues, we already weigh it by Actual VH,
	 * so this flag won't affect Deferred queues.
	 * @return true if we should weigh Actual Service Level for Immediate queues by Actual VH.
	 */
	public static boolean isAlwaysUseVHInsteadOfCV() {
<span class="nc" id="L440">		return alwaysUseVHInsteadOfCV;</span>
	}

	/**
	 * Sets the flag telling the Trace aggregations to weigh Actual Service Level for Immediate queues by 
	 * Actual VH, instead of Actual CV. Note that for Deferred queues, we already weigh it by Actual VH,
	 * so this flag won't affect Deferred queues.
	 */
	public static void setAlwaysUseVHInsteadOfCV(boolean val) {
<span class="fc" id="L449">		alwaysUseVHInsteadOfCV = val;</span>
<span class="fc" id="L450">	}</span>

	/**
	 * The flag telling the Trace aggregations to weigh Predicted Service Level for Deferred queues by 
	 * Predicted VH, instead of Forecasted CV. Note that for Immediate queues, we always weigh it by Forecasted CV,
	 * and this flag won't affect Immediate queues.
	 */
<span class="fc" id="L457">	private static boolean computeSLOnIntervalHandled = false;</span>
	
	/**
	 * Returns the flag telling the Trace aggregations to weigh Predicted Service Level for Deferred queues by 
	 * Predicted VH, instead of Forecasted CV. Note that for Immediate queues, we always weigh it by Forecasted CV,
	 * and this flag won't affect Immediate queues.
	 * @return true if we should weigh Predicted Service Level for Deferred queues by Predicted VH.
	 */
	public static boolean isComputeSLOnIntervalHandled() {
<span class="fc" id="L466">		return computeSLOnIntervalHandled;</span>
	}

	/**
	 * Sets the flag telling the Trace aggregations to weigh Predicted Service Level for Deferred queues by 
	 * Predicted VH, instead of Forecasted CV. Note that for Immediate queues, we always weigh it by Forecasted CV,
	 * and this flag won't affect Immediate queues.
	 */
	public static void setComputeSLOnIntervalHandled(boolean useVH) {
<span class="fc" id="L475">		computeSLOnIntervalHandled = useVH;</span>
<span class="fc" id="L476">	}</span>
	
	/**
	 * If true, Actual Service level for Immediate media should be weighted by (VH + Abandons) when computing Combinations 
	 * and Aggregations. This setting supercedes ALWAYS_USE_VOLUME_HANDLED. But if there is no Avtual VH or Abandons defined, 
	 * then we will use the ALWAYS_USE_VOLUME_HANDLED setting if present. Otherwise, we use CV. 
	 */
<span class="fc" id="L483">	private static boolean computeActualImmediateSLOnVHAndAbandons = false;</span>
	
	/**
	 * If true, Actual Service level for Immediate media should be weighted by (VH + Abandons) when computing Combinations 
	 * and Aggregations. This setting supercedes ALWAYS_USE_VOLUME_HANDLED. But if there is no Avtual VH or Abandons defined, 
	 * then we will use the ALWAYS_USE_VOLUME_HANDLED setting if present. Otherwise, we use CV. 
	 */
	public static boolean isComputeActualImmediateSLOnVHAndAbandons() {
<span class="nc" id="L491">		return computeActualImmediateSLOnVHAndAbandons;</span>
	}

	/**
	 * If true, Actual Service level for Immediate media should be weighted by (VH + Abandons) when computing Combinations 
	 * and Aggregations. This setting supercedes ALWAYS_USE_VOLUME_HANDLED. But if there is no Avtual VH or Abandons defined, 
	 * then we will use the ALWAYS_USE_VOLUME_HANDLED setting if present. Otherwise, we use CV. 
	 */
	public static void setComputeActualImmediateSLOnVHAndAbandons(boolean val) {
<span class="fc" id="L500">		computeActualImmediateSLOnVHAndAbandons = val;</span>
<span class="fc" id="L501">	}</span>
	

	//Checks if the value has a special meaning like  TRACEOFF, TRACENA or TRACEINCOMP
	public static boolean isValidValue(double value){
<span class="fc bfc" id="L506" title="All 6 branches covered.">		return (value!=Trace.TRACENA &amp;&amp; value!=Trace.TRACEOFF &amp;&amp; value!=Trace.TRACEINCOMP);</span>
	}
 
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>