<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestAggregateManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.ejb</a> &gt; <span class="el_source">RequestAggregateManager.java</span></div><h1>RequestAggregateManager.java</h1><pre class="source lang-java linenums">/*
 * RequestAggregateManager.java
 *
 * Created on February 25, 2003, 2:10 AM
 */

package com.bluepumpkin.ejb.rm.requests.common.ejb;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.RequestNotificationDetail;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleChecker;
import com.bluepumpkin.ejb.rm.requests.common.validation.AutoProcessingRuleCheckerHelper;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffIntervalAllocationManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AgentGoodStandingValidationRuleHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffBidPeriodPerChoiceHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.WorkableTimeWithinScheduleTimeOffHV;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.ejb.TimeOffBiddingManager;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;
import com.witness.ejb.core.security.model.User;

/**
 * @author RRajendran
 *
 * To change the template for this generated type comment go to
 * Window&amp;gt;Preferences&amp;gt;Java&amp;gt;Code Generation&amp;gt;Code and Comments
 */
/**
 *
 * @author  Raja Rajendran.
 */
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">public abstract class RequestAggregateManager extends SessionEJBBase implements IRequestType //OUTSIDE_CONTAINER</span>
//public abstract class RequestAggregateManager extends SessionEjbBaseForTest implements IRequestType //OUTSIDE_CONTAINER
{
<span class="fc" id="L90">    private static final String m_className = RequestAggregateManager.class.getName();</span>
<span class="fc" id="L91">    private static final Category m_cat = Log.initCategory(m_className);</span>

    // todo: potential problem of data corruption due to multithreaded access. checkout
    // EJB threading rules.
<span class="fc" id="L95">    protected HashMap s_validatorsMap = new HashMap();</span>
<span class="fc" id="L96">	public static short ARRAY_INDEX_FOR_AUTO_APPROVE=0;</span>
<span class="fc" id="L97">	public static short ARRAY_INDEX_FOR_AUTO_DENY=1;</span>
<span class="fc" id="L98">	public static short ARRAY_INDEX_FOR_AUTO_WAITLIST=2;</span>
	public final static String m_tentativeNotImplemented = &quot;Tentative approval/denial/withdrawal processing not supported for this request type:&quot;;

    /** Creates a new instance of RequestAggregateManager */
<span class="fc" id="L102">    public RequestAggregateManager() {</span>
<span class="fc" id="L103">    }</span>

    //TODO: remove incExpired.  detailLevel must be sufficient.
    protected RequestAggregate _getRequestByID(ID reqID, boolean incExpired,
        boolean runHardValids, boolean runSoftValids, long detailLevel) throws Exception
    {
<span class="fc" id="L109">        String methodName = &quot;_getRequestByID&quot;;</span>
<span class="fc" id="L110">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqID, new Boolean(incExpired), new Boolean(runHardValids),</span>
            new Boolean(runSoftValids)));

<span class="fc" id="L113">        RequestAggregateDAO reqAggDAO = null;</span>
        try {
<span class="fc" id="L115">            reqAggDAO = getDAO(detailLevel);</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (incExpired) {</span>
<span class="fc" id="L117">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}

<span class="fc" id="L120">            RequestAggregate reqAgg = null;</span>
            try {
<span class="fc" id="L122">            	reqAgg = reqAggDAO.getRequestByID(reqID, detailLevel);</span>
<span class="nc" id="L123">            } catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L124">            	m_cat.error(&quot;BbmObjectNotFoundException caught and not propogated: Unable to load request with ID: &quot; + reqID, e);</span>
<span class="fc" id="L125">            }</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">            if (reqAgg == null) {</span>
<span class="nc" id="L127">				return null;</span>
			}

            // TODO: if employee's org setting == timeoff workflow disabled, do not return request.
            /*
            if (tor.getCache().getManagerTimeOffWorkflowActive()) {
                RequestUtil.throwBbmFinderException(RmEjbBundleKey.MANAGER_TIME_OFF_WORKFLOW_INACTIVE,
                    null, m_cat);
            }*/
<span class="fc" id="L136">            getRequestPreValidationProcess(Collections.singleton(reqAgg), detailLevel);</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">            if (runHardValids) {</span>
<span class="fc" id="L138">            	m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(reqAgg))._validateRequest(reqAgg, runSoftValids, true);</span>
            }

<span class="fc" id="L141">            getRequestPostProcess(Collections.singleton(reqAgg), detailLevel);</span>

<span class="fc" id="L143">            m_cat.debug(RmUtil.dumpExitMethod(methodName, reqAgg));</span>
<span class="fc" id="L144">            return reqAgg;</span>
        } finally {
<span class="pc bpc" id="L146" title="5 of 6 branches missed.">	        if (reqAggDAO != null) {</span>
<span class="pc" id="L147">				reqAggDAO.cleanUp();</span>
			}
        }
    }

<span class="fc" id="L152">	private final RmManagerFactory m_managerFactory = RmManagerFactory.getInstance(true);</span>

    // returns a Request
    @Override
	public RequestAggregate getRequestByID(ID reqID, boolean incExpired, boolean runSoftValids, long detailLevel)
            throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L158">        String _method_ = &quot;getRequestByID&quot;;</span>
<span class="fc" id="L159">        methodStart(_method_, reqID, new Boolean(incExpired), new Boolean(runSoftValids), new Long(detailLevel));</span>

<span class="fc" id="L161">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L162">        boolean cacheEnabled = false;</span>
        try {
<span class="fc" id="L164">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // Note: we need these detail levels for doing hard and soft validations.  Otherwise
            // the validators will crash.
<span class="fc" id="L168">            detailLevel |= getDetailLevelForValidation();</span>

<span class="fc" id="L170">            return _getRequestByID(reqID, incExpired, true, runSoftValids, detailLevel);</span>
<span class="nc" id="L171">        } catch (RmHardValidationException e) {</span>
        	//RM exceptions are always logged at the point where they are thrown.
        	//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L178">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L179">        	throw e;</span>
<span class="nc" id="L180">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L181">			m_cat.error(e, e);</span>
<span class="nc" id="L182">			handleException(e);</span>
<span class="nc" id="L183">			throw e;</span>
<span class="nc" id="L184">        } catch (Exception e) {</span>
<span class="nc" id="L185">            handleException(e);</span>
<span class="nc" id="L186">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L188" title="2 of 4 branches missed.">            if (cacheEnabled) {</span>
<span class="pc" id="L189">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L191">            methodFinish();</span>
        }
    }
<span class="fc" id="L194">	public static Integer USER_TRANSACTION_TIMEOUT = null;</span>

	public int getUserTransactionTimeOut() throws Exception {
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (USER_TRANSACTION_TIMEOUT == null) {</span>
<span class="nc" id="L198">			String transTimeOut = BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.REQUEST_MANAGEMENT + &quot;USER_TRANSACTION_TIMEOUT&quot;);</span>
<span class="nc bnc" id="L199" title="All 2 branches missed.">			USER_TRANSACTION_TIMEOUT = new Integer(StringUtil.isEmpty(transTimeOut) ? 300 : Integer.parseInt(transTimeOut));</span>
		}
<span class="nc" id="L201">		return USER_TRANSACTION_TIMEOUT.intValue();</span>
	}
    // returns a Collection of validated specific Requests (e.g. TO, SS, SB)
	@Override
	public Collection getRequestsById(Collection requestIds, boolean incExpired, boolean runSoftValids, boolean runNetStaffingSoftVal, long detailLevel)
	        throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L207">        String _method_ = &quot;getRequestsById&quot;;</span>
<span class="fc" id="L208">        methodStart(_method_, requestIds, new Boolean(incExpired), new Boolean(runSoftValids),</span>
                new Long(detailLevel));

<span class="fc" id="L211">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="fc" id="L212">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L213">        boolean cacheEnabled = false;</span>
<span class="fc" id="L214">		boolean threadCacheEnabled = false;</span>
        try {
<span class="fc" id="L216">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="fc" id="L217">			threadCacheEnabled = ThreadLocalCache.enable();</span>

            // Note: we need these detail levels for doing hard and soft validations.  Otherwise
            // the validators will crash.
<span class="fc" id="L221">            detailLevel |= getDetailLevelForValidation();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">            if (incExpired) {</span>
<span class="fc" id="L223">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}
<span class="fc" id="L225">	        RmManagerFactory m_managerFactory = RmManagerFactory.getInstance();</span>
<span class="fc" id="L226">            reqAggDAO = getDAO(detailLevel);</span>
<span class="fc" id="L227">            Collection reqAggs = reqAggDAO.getRequestsByIDs(requestIds, detailLevel);</span>
<span class="fc" id="L228">            getRequestPreValidationProcess (reqAggs, detailLevel);</span>
<span class="fc bfc" id="L229" title="All 2 branches covered.">            for (Iterator it = reqAggs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L230">		        RequestAggregate reqAgg = null;</span>
		        try {
<span class="fc" id="L232">			        reqAgg = (RequestAggregate) it.next();</span>
<span class="fc" id="L233">			        m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(reqAgg))._validateRequest(reqAgg, runSoftValids, runNetStaffingSoftVal);</span>
<span class="nc" id="L234">		        } catch (Exception e) {</span>
<span class="nc bnc" id="L235" title="All 2 branches missed.">			        m_cat.error(&quot;Thrown exception in User Transaction REQID=:&quot; + (reqAgg != null ? reqAgg.getID().toString() : &quot; IS NULL&quot;), e);</span>
<span class="fc" id="L236">            }</span>
<span class="fc" id="L237">	        }</span>
<span class="fc" id="L238">            getRequestPostProcess(reqAggs, detailLevel);</span>

<span class="fc" id="L240">            return reqAggs;</span>
<span class="nc" id="L241">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L248">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L249">			throw e;</span>
<span class="nc" id="L250">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L251">			m_cat.error(e, e);</span>
<span class="nc" id="L252">			handleException(e);</span>
<span class="nc" id="L253">			throw e;</span>
<span class="nc" id="L254">        } catch (Exception e) {</span>
<span class="nc" id="L255">            handleException(e);</span>
<span class="nc" id="L256">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L258" title="2 of 4 branches missed.">			if (cacheEnabled) {</span>
<span class="pc" id="L259">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L261" title="3 of 4 branches missed.">			if (reqAggDAO != null) {</span>
<span class="pc" id="L262">				reqAggDAO.cleanUp();</span>
			}
<span class="pc" id="L264">			ThreadLocalCache.clear(threadCacheEnabled);</span>
<span class="pc" id="L265">            methodFinish();</span>
        }
    }

	/**
	 * Get a collection of RequestAggregate from Request IDs
	 * @param requestIDs
	 * @param detailLevel
	 * @return
	 * @throws RmException
	 */
    @Override
	public Collection&lt;RequestAggregate&gt; getRequestsByIDs(Collection requestIDs, long detailLevel) throws RmException {
<span class="nc" id="L278">		RequestAggregateDAO reqAggDao = null;</span>
		try {
<span class="nc" id="L280">			reqAggDao = getDAO(detailLevel);</span>
<span class="nc" id="L281">			return reqAggDao.getRequestsByIDs(requestIDs, detailLevel);</span>
<span class="nc" id="L282">		} catch (Exception e) {</span>
<span class="nc" id="L283">			handleException(e);</span>
<span class="nc" id="L284">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		}
		finally {
<span class="nc bnc" id="L287" title="All 4 branches missed.">			if(reqAggDao != null) {</span>
<span class="nc" id="L288">				reqAggDao.cleanUp();</span>
			}
		}
    }
    
    /**
     * Get a Map&lt;ID, RequestAggregate&gt; of RequestAggregate from Request IDs
     * @param requestIDs
     * @param detailLevel
     * @return
     * @throws RmException
     */
    @Override
	public Map&lt;ID, RequestAggregate&gt; getRequestMapByIDs(Collection requestIDs, long detailLevel) throws RmException {
<span class="nc" id="L302">    	Collection&lt;RequestAggregate&gt; reqs = getRequestsByIDs(requestIDs, detailLevel);</span>
<span class="nc" id="L303">    	Map&lt;ID, RequestAggregate&gt; map = new HashMap&lt;ID, RequestAggregate&gt;();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">    	for(RequestAggregate req: reqs) {</span>
<span class="nc" id="L305">    		map.put(req.getID(), req);</span>
<span class="nc" id="L306">    	}</span>
    	
<span class="nc" id="L308">    	return map;</span>
    }
	
	private String getRequestTypeWithFlexTimeFix(RequestAggregate reqAgg) {
<span class="fc" id="L312">		String requestType = reqAgg.getRequestType();</span>
<span class="pc bpc" id="L313" title="2 of 4 branches missed.">		if (Request.REQUESTTYPE_TIMEOFF.equals(requestType) &amp;&amp; ((TORequest) reqAgg).isFlexTimeRequest()) {</span>
<span class="nc" id="L314">			requestType = Request.REQUESTTYPE_FLEXTIME;</span>
		}
<span class="fc" id="L316">		return requestType;</span>
	}

    // returns a Collection of Request IDs for a given employee
    @Override
	public Collection getRequestIdsByEmployee(ID employeeId, boolean incExpired)
    	throws BbmFinderException, RmHardValidationException
    {
<span class="nc" id="L324">        String _method_ = &quot;getRequestIdsByEmployee&quot;;</span>
<span class="nc" id="L325">        methodStart(_method_, employeeId, new Boolean(incExpired));</span>

<span class="nc" id="L327">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L328">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L329">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L331">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            /*
            if (!isTimeOffWorkflowActiveForEmp(employeeId)) {
                return Collections.EMPTY_LIST;
            } */

<span class="nc" id="L338">            long detailLevel = RequestDetailLevel.DL_BASIC;</span>
<span class="nc" id="L339">            reqAggDAO = getDAO(detailLevel);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">            if (incExpired) {</span>
<span class="nc" id="L341">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}

<span class="nc" id="L344">            return reqAggDAO.getRequestIDsByEmployee(employeeId, detailLevel);</span>
<span class="nc" id="L345">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L352">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L353">			throw e;</span>
<span class="nc" id="L354">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L355">			m_cat.error(e, e);</span>
<span class="nc" id="L356">			handleException(e);</span>
<span class="nc" id="L357">			throw e;</span>
<span class="nc" id="L358">        } catch (Exception e) {</span>
<span class="nc" id="L359">            handleException(e);</span>
<span class="nc" id="L360">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L362" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L363">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L365" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L366">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L368">            methodFinish();</span>
        }
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#getRequestsByEmployee(com.bluepumpkin.common.datatypes.ID, boolean, boolean, long)
     */
    @Override
	public Collection getRequestsByEmployee(ID employeeId, boolean incExpired, boolean runSoftValids, long detailLevel)
            throws BbmFinderException, RmHardValidationException {
<span class="fc" id="L378">	    String _method_ = &quot;getRequestsByEmployee&quot;;</span>
<span class="fc" id="L379">	    methodStart(_method_, employeeId, new Boolean(incExpired), new Boolean(runSoftValids));</span>

<span class="fc" id="L381">	    RequestAggregateDAO reqAggDAO = null;</span>
<span class="fc" id="L382">	    String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L383">	    boolean cacheEnabled = false;</span>
	    try {
<span class="fc" id="L385">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

		    /*
		    // if &quot;timeoff workflow active&quot; org setting for employee is disabled, return empty list.
		    if (!isTimeOffWorkflowActiveForEmp(employeeId)) {
		        return Collections.EMPTY_LIST;
		    } */
		    // Note: we need these detail levels for doing hard and soft validations.  Otherwise
		    // the validators will crash.
<span class="fc" id="L394">		    detailLevel |= getDetailLevelForValidation();</span>
<span class="pc bpc" id="L395" title="1 of 2 branches missed.">		    if (incExpired) {</span>
<span class="nc" id="L396">				detailLevel |= RequestDetailLevel.DL_INCLUDE_EXPIRED;</span>
			}
<span class="fc" id="L398">		    RmManagerFactory m_managerFactory = RmManagerFactory.getInstance();</span>
<span class="fc" id="L399">		    reqAggDAO = getDAO(detailLevel);</span>
<span class="fc" id="L400">		    Collection reqAggs = reqAggDAO.getRequestsByEmployee(employeeId, detailLevel);</span>
<span class="fc" id="L401">		    getRequestPreValidationProcess(reqAggs, detailLevel);</span>
<span class="fc bfc" id="L402" title="All 2 branches covered.">		    for (Iterator it = reqAggs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L403">			    RequestAggregate req = null;</span>
			    try {
<span class="fc" id="L405">				    req = (RequestAggregate) it.next();</span>
<span class="fc" id="L406">				    m_managerFactory.getRequestManagerByType(getRequestTypeWithFlexTimeFix(req))._validateRequest(req, runSoftValids, true);</span>
<span class="nc" id="L407">			    } catch (Exception e) {</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">				    m_cat.error(&quot;Thrown exception in User Transaction REQID=:&quot; + (req != null ? req.getID().toString() : &quot; IS NULL&quot;), e);</span>
<span class="fc" id="L409">			    }</span>
<span class="fc" id="L410">		    }</span>
<span class="fc" id="L411">		    getRequestPostProcess(reqAggs, detailLevel);</span>
<span class="fc" id="L412">		    return reqAggs;</span>
<span class="nc" id="L413">	    } catch (RmHardValidationException e) {</span>
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L417">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L418">		    throw e;</span>
<span class="nc" id="L419">	    } catch (BbmFinderException e) {</span>
<span class="nc" id="L420">		    m_cat.error(e, e);</span>
<span class="nc" id="L421">		    handleException(e);</span>
<span class="nc" id="L422">		    throw e;</span>
<span class="nc" id="L423">	    } catch (Exception e) {</span>
<span class="nc" id="L424">		    handleException(e);</span>
<span class="nc" id="L425">		    throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="pc bpc" id="L427" title="3 of 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L428">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L430" title="3 of 4 branches missed.">		    if (reqAggDAO != null) {</span>
<span class="pc" id="L431">				reqAggDAO.cleanUp();</span>
			}
<span class="pc" id="L433">		    methodFinish();</span>
	    }
    }

    /**
     * Called after requests are loaded from DB and after validations are run.
     *
     * @param reqAggs
     */
    protected abstract void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception;
 /**
     * Called after requests are loaded from DB and before validations are run.
     *
     * @param reqAggs
     */

     protected  void getRequestPreValidationProcess(Collection reqAggs, long detailLevel) throws Exception{

<span class="fc" id="L451">    }</span>

    /**
     * Preprocess request before creation. verify if request fields have valid values.
     * only checks outside the hard validations need be done.
     *
     * &lt;p&gt; Note: overridden by subclasses
     *
     * @param reqAgg
     */
    protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO)
    	throws Exception {

		/*
		 * Fields in Request table.
			ID
			REQUESTTYPE
			REQUESTSTATUS
			SUBMITTEDON
			CREATORID
			CHANGECOUNTER
			MODIFIEDBY
			LASTMODIFIEDAT
			EMPLOYEEID
			EXPIRATIONDATE
		 *
		 */

		// If creatorID is set in Request object, ensure it's the same as
		// the employeeID from the logged in user. If it's not set,
		// set it to the user's employeeID.
<span class="fc" id="L482">		User loginUserBasic = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">		if (loginUserBasic == null) {</span>
<span class="nc" id="L484">		  throw RequestUtil.createRmException(RmEjbLogBundleKey.CREATE_INVALID_LOGINUSERID,</span>
<span class="nc" id="L485">					new Object[] { m_sessionContext.getCallerPrincipal().getName()}, m_cat);</span>
		}
<span class="fc" id="L487">		ID loginUserID = loginUserBasic.getID();</span>

		// if creator ID not set, assign login user ID
<span class="fc" id="L490">		Request aggdReq = reqAgg.getAggregatedRequest();</span>
<span class="fc" id="L491">		ID creatorUserID = aggdReq.getCreatorID();</span>
<span class="pc bpc" id="L492" title="1 of 2 branches missed.">		if ( creatorUserID == null ) {</span>
<span class="fc" id="L493">			aggdReq.setCreatorID(creatorUserID = loginUserID);</span>
		}

		// validate creatorID == login user ID.
<span class="pc bpc" id="L497" title="1 of 2 branches missed.">		if ( !creatorUserID.equals(loginUserID)) {</span>
<span class="nc" id="L498">			throw RequestUtil.createRmException(RmEjbLogBundleKey.CREATE_INVALID_CREATORID,</span>
				new Object[] { creatorUserID, loginUserID }, m_cat);
		}

		// Do not set the employeeID using the login user's empID as a manager can create reqs for an emp.
		// aggdReq.setEmployeeID(loginUserBasic.getEmployeeID());

		// Set submittedon field if necessary
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">		if (aggdReq.getSubmittedOn() == null) {</span>
<span class="fc" id="L507">			aggdReq.setSubmittedOn(new Date());</span>
		}
<span class="fc" id="L509">	}</span>

    /**
     * Create a new request with the given 'comment' in the audit trail
     *
     * &lt;p&gt;This method starts a new transaction since createRequest()'s transaction
     * attribute is 'Not Required'.
     *
     * &lt;p&gt; Method visibility is public since it is exposed in the remtoe interface (for
     * specifying a transaction attribute in ejb-jar.xml).
     *
     * @param request - TORequest for creation.
     * @param comment - string comment for creation
     * @return ID - Id for the newly created timeoof request.
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws - BbmCreateException
     * @throws - RmHardValidationException is any hardValidations fail.
     */
    @Override
	public ID _createRequest(RequestAggregate reqAgg, String comment)
        throws RmHardValidationException, BbmCreateException
    {
<span class="fc" id="L531">        String _method_ = &quot;_createRequest&quot;;</span>

<span class="fc" id="L533">        methodStart(_method_, reqAgg, comment);</span>

<span class="fc" id="L535">        RequestAggregateDAO reqAggDao = null;</span>
<span class="fc" id="L536">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L537">        boolean cacheEnabled = false;</span>
        try {
<span class="fc" id="L539">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L541">            reqAggDao = getDAO(RequestDetailLevel.DL_BASIC);</span>

<span class="fc" id="L543">            assignDefaultsForReqAgg(reqAgg);</span>

<span class="fc" id="L545">            createRequestPreProcess(reqAgg, reqAggDao);</span>

            // do hard validations.
<span class="fc" id="L548">            doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_CREATOR, null, false);</span>

            // Validations sucessful, create object
<span class="fc" id="L551">            User loginUserBasic = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="fc" id="L552">			reqAgg.setID(reqAggDao.createRequest(reqAgg, comment, loginUserBasic));</span>
<span class="fc" id="L553">            createRequestPostProcess(reqAgg,reqAggDao);</span>
<span class="fc" id="L554">            return reqAgg.getID();</span>
<span class="nc" id="L555">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L562">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L563">			throw e;</span>
<span class="nc" id="L564">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L565">			m_cat.error(e, e);</span>
<span class="nc" id="L566">			handleException(e);</span>
<span class="nc" id="L567">			throw e;</span>
<span class="nc" id="L568">        } catch (Exception e) {</span>
<span class="nc" id="L569">            handleException(e);</span>
<span class="nc" id="L570">            throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L572" title="3 of 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L573">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L575" title="3 of 4 branches missed.">            if ( reqAggDao != null ) {</span>
<span class="pc" id="L576">				reqAggDao.cleanUp();</span>
			}
<span class="pc" id="L578">            methodFinish();</span>
        }
    }

    /**
     * Creates a request with the given comment in the audit trail and does autoProcessing. &lt;br&gt;
     * To check if any hard vaidation failed, check validation results in the request.
     *
     * &lt;p&gt;Request creation and autoprocessing runs in its own transaction.  If not, an exception raised
     * during autoprocessing will undo the newly created request.
     *
     * TODO: this method has the transaction attribute &quot;Not Required&quot;.  Change it to &quot;Required&quot;
     * and mark _createRequest and _autoProcess with &quot;RequiresNew&quot;.  This ensures database operations
     * by this method are bracketed by a transaction while _createRequest() and _autoProcess() run within
     * a nested transaction.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#createRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	public ID createRequest(RequestAggregate reqAgg, String comment)
    	throws BbmCreateException, RmHardValidationException,MultiUserException {

<span class="fc" id="L600">        String _method_ = &quot;createRequest&quot;;</span>
<span class="fc" id="L601">        methodStart(_method_, reqAgg, comment);</span>

<span class="fc" id="L603">        RequestAggregateDAO reqAggDao = null;</span>
<span class="fc" id="L604">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L605">        boolean cacheEnabled = false;</span>
        try {
<span class="fc" id="L607">	        cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L609">	        IRequestType reqMgr = getRequestManager();</span>
	        // creation logic is bracketed by its own transaction. So not included as part of this method.
<span class="fc" id="L611">	        ID createdReqID = reqMgr._createRequest(reqAgg, comment);</span>
<span class="fc" id="L612">	        long detailLevel = getDetailLevelForValidation();</span>
<span class="fc" id="L613">	        boolean reqStatusChanged = false;</span>
	        // autoprocessing done if state is pending (SS request can be created with 'pending' if picked up from SSPosting).
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">	        if (reqAgg.isPending()) {</span>
		        // reload object to refresh objectVersionNumber (or column 'changeCounter' in DB used
		        // for optimistic locking to prevent multi-user updates).
<span class="fc" id="L618">		        RequestAggregate reqAggOld = reqAgg;</span>
<span class="fc" id="L619">		        reqAggDao = getDAO(detailLevel);</span>
<span class="fc" id="L620">		        reqAgg = reqAggDao.getRequestByID(createdReqID, detailLevel);</span>
<span class="fc" id="L621">		        setTOHoursPerDayForRequest(reqAggOld, reqAgg);</span>
		        // autoprocessing bracketed by its own transaction.
<span class="fc" id="L623">		        Pair pair = reqMgr._autoProcess(reqAgg, comment, true);</span>
<span class="pc bpc" id="L624" title="2 of 4 branches missed.">		        reqStatusChanged = (pair != null &amp;&amp; Boolean.getBoolean(pair.getFirst().toString()));</span>
	        }
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">	        if (!reqStatusChanged) {</span>
<span class="fc" id="L627">		        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>
	        }
<span class="fc" id="L629">	        return createdReqID;</span>
<span class="nc" id="L630">        } catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L637">            handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L638">			throw e;</span>
<span class="nc" id="L639">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L640">			m_cat.error(e, e);</span>
<span class="nc" id="L641">			handleException(e, false);</span>
<span class="nc" id="L642">			throw e;</span>
<span class="nc" id="L643">        }catch (MultiUserException e) {</span>
<span class="nc" id="L644">			handleException(e);</span>
<span class="nc" id="L645">			throw e;</span>
<span class="nc" id="L646">    	} catch (Exception e) {</span>
<span class="nc" id="L647">            handleException(e, false);</span>
<span class="nc" id="L648">            throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L650" title="3 of 4 branches missed.">            if (cacheEnabled) {</span>
<span class="pc" id="L651">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L653" title="3 of 4 branches missed.">            if ( reqAggDao != null ) {</span>
<span class="pc" id="L654">				reqAggDao.cleanUp();</span>
			}
<span class="pc" id="L656">            methodFinish();</span>
        }
    }
	//This method just transfers the hoursperday from the old requests to the new request ;
	//this is done to avoid unnecessary calls to the TOHoursPerDay.
	public void setTOHoursPerDayForRequest(RequestAggregate reqAggOld, RequestAggregate reqAggNew) {
<span class="pc bpc" id="L662" title="1 of 2 branches missed.">		if (reqAggOld.isTimeOffRequest()) {</span>
<span class="fc" id="L663">			HashMap toChoiceIDHourPerDayMap = ValueObjectUtil.getIDObjectMap(((TORequest) reqAggOld).getRequestChoiceList());</span>
<span class="fc" id="L664">			Collection tochoiceList = ((TORequest) reqAggNew).getRequestChoiceList();</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">			for (Iterator iterator = tochoiceList.iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L666">				TOChoice toChoice = (TOChoice) iterator.next();</span>
<span class="fc" id="L667">				toChoice.setHoursPerDay(((TOChoice) toChoiceIDHourPerDayMap.get(toChoice.getID())).getHoursPerDay());</span>
<span class="fc" id="L668">			}</span>
		}
<span class="fc" id="L670">	}</span>
    /**
     * Method is declared Public as it is part of the SSReqManager's remote interface (for declaration of
     * method's transaction attribute).  For SSReqManager, this method is declared with a transaction attribute
     * of Required
     *
     * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
     * _changeRequestStateByID().
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String, java.lang.String)
     *
     * @param reqID
     * @param newState
     * @param objVerNum
     * @param comment
     * @throws
     * @throws RmHardValidationException
     */
    public void _changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException {
<span class="nc" id="L690">    	_changeRequestStateByID(reqID,newState,objectVersionNumber,comment,false);</span>
<span class="nc" id="L691">    }</span>
    /**
     * 
     * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
     * _changeRequestStateByID().
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String, java.lang.String)
     *
     * @param reqID
     * @param newState
     * @param objVerNum
     * @param comment
     * @param boolean skipSomeHardRulesWhenUpdate : for Time Off Requests only to serve new Group approval action for Time off bid requests 
     * @throws
     * @throws RmHardValidationException
     */
    public void _changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment, boolean skipSomeHardRulesWhenUpdate)
            throws  RmHardValidationException, RmException
        {
<span class="fc" id="L710">            String _method_ = &quot;changeRequestStateByID&quot;;</span>
<span class="fc" id="L711">            methodStart(_method_, reqID, newState, objectVersionNumber, comment);</span>

<span class="fc" id="L713">            String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L714">            boolean cacheEnabled = false;</span>
            try {
<span class="fc" id="L716">                cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L718">                RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="fc" id="L719">                String oldState = reqAgg.getRequestStatus();</span>

                // if a tentatively approved request is being withdrawn, then undo the schedule changes done for
                // tentative approval.  Note that this must be done before the request update below (as the update
                // changes the request's status and possibly other fields).
<span class="pc bpc" id="L724" title="1 of 2 branches missed.">                if (RequestAuditTrail.STATUS_TENTATIVE.equals(oldState) &amp;&amp;</span>
<span class="nc bnc" id="L725" title="All 2 branches missed.">                    RequestAuditTrail.STATUS_WITHDRAWN.equals(newState)) {</span>
<span class="nc" id="L726">                    _undoSchedule(reqAgg, null, null);</span>
                }

<span class="fc" id="L729">                reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
                // The old code without skipSomeHardRulesWhenUpdate  _updateRequest(reqAgg, newState, comment, null, false, true);
<span class="fc" id="L731">               _updateRequest(reqAgg, newState, comment, null, false, false, true, skipSomeHardRulesWhenUpdate);</span>

                // refresh 'newState' since _updateRequest could have marked the status 'invalid'.
<span class="fc" id="L734">                newState = reqAgg.getRequestStatus();</span>

                // fire notifications only if there is a state change.
<span class="pc bpc" id="L737" title="1 of 2 branches missed.">                if (!oldState.equals(newState)) {</span>
<span class="fc" id="L738">                    fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>

<span class="fc" id="L740">                    fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_ESCALATED, reqAgg);</span>
                }
<span class="nc" id="L742">    		} catch (RmHardValidationException e) {</span>
    			//RM exceptions are always logged at the point where they are thrown.
    			//m_cat.error(e, e);

                // Logged with priority 'debug' since this exception is generated by RM during validations or
                // workflow processing and happens often during normal operation.  If logged with a different
                // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L749">                handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L750">    			throw e;</span>
<span class="nc" id="L751">    		} catch (RmException e) {</span>
<span class="nc" id="L752">    			m_cat.error(e, e);</span>
<span class="nc" id="L753">    			handleException(e);</span>
<span class="nc" id="L754">    			throw e;</span>
<span class="nc" id="L755">            } catch (Exception e) {</span>
<span class="nc" id="L756">                handleException(e);</span>
<span class="nc" id="L757">                throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
            } finally {
<span class="pc bpc" id="L759" title="3 of 4 branches missed.">                if (cacheEnabled) {</span>
<span class="nc" id="L760">    				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
    			}
<span class="pc" id="L762">                methodFinish();</span>
<span class="fc" id="L763">            }</span>
<span class="fc" id="L764">        }</span>

    /**
     * Note:
     * This method is overridden by SSReqMgr.  sSReqMgr does not call this
     * overridden method.  This is unlike the usual implementation where the overriding method
     * calls the overridden method.
     * Since 15.1.0_120, this method is also overriden by TORequestManager
     * See below method javadoc for the reason for 2 similar methods: changeRequesStateByID() and
     * _changeRequestStateByID().
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(com.bluepumpkin.common.datatypes.ID, java.lang.String, java.lang.String, java.lang.String)
     */
    @Override
	public void changeRequestStateByID(ID reqID, String newState, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException, MultiUserException {
        // SSReqMgr.changeRequestByID() also needs to be modified if additional code is added to this method body.
<span class="nc" id="L781">        _changeRequestStateByID(reqID, newState, objectVersionNumber, comment);</span>
<span class="nc" id="L782">    }</span>

    /**
     * Preprocess request before request is updated.  Return value is the updated request (***** could be the same as request passed ******) with the updated fields
     * validated or assigned defaults.
     *
     * @param reqAgg
     */
    protected abstract RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg,
        RequestAggregateDAO reqAggDAO, boolean loadedFromDB) throws Exception;

    /**
     * Postprocess request after request is updated.
     * should be implementd to preform any tasks that need to be done after updating the request.
     * @param reqAgg
     */
    protected void updateRequestPostProcess(RequestAggregate reqAgg,
                                            RequestAggregateDAO reqAggDAO, boolean loadedFromDB, String origState) throws Exception {
<span class="nc" id="L800">    }</span>

	protected void createRequestPostProcess(RequestAggregate reqAgg,
	                                        RequestAggregateDAO reqAggDAO) throws Exception {

<span class="nc" id="L805">	}</span>
    /**
     * Note: request will not be marked invalid if hardValidation fails.  See
     * {@link #doHardValidations(RequestAggregate, int, String, boolean) doHardValidations} for further
     * information.
     *
     * @param reqAgg
     * @param newState
     * @param comment
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
        String methodSubType, boolean suppressHardValidation, boolean suppressPrivilegeChecking,
        boolean loadedFromDB) throws Exception {
<span class="nc" id="L823">    	_updateRequest(reqAgg,newState,comment,methodSubType,suppressHardValidation,suppressPrivilegeChecking,loadedFromDB,false);</span>
<span class="nc" id="L824">    }</span>
    /**
     * Note: request will not be marked invalid if hardValidation fails.  See
     * {@link #doHardValidations(RequestAggregate, int, String, boolean) doHardValidations} for further
     * information.
     *
     * @param reqAgg
     * @param newState
     * @param comment
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @param skipSomeHardRulesWhenUpdate - To support for approve any choice of TO request. 1 TO Request can have multi-choices. 
     * If one of them is invalid , it should not marked as invalid=&gt; the hard validation rule should not run in this case
     * Instead of that, some rules will be replaced by similar soft validation rules
     * @throws Exception
     */
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
            String methodSubType, boolean suppressHardValidation, boolean suppressPrivilegeChecking,
            boolean loadedFromDB,boolean skipSomeHardRulesWhenUpdate) throws Exception {

<span class="fc" id="L846">            String methodName = &quot;_updateRequest&quot;;</span>
<span class="fc" id="L847">            m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Object[] { reqAgg, newState, comment,</span>
                new Boolean(suppressHardValidation), new Boolean(suppressPrivilegeChecking)} ));
<span class="fc" id="L849">            RequestAggregateDAO reqAggDAO = null;</span>
            try  {
<span class="fc" id="L851">    	        String origState= reqAgg.getRequestStatus();</span>
<span class="fc" id="L852">                reqAggDAO = getDAO(getDetailLevelForValidation());</span>
<span class="fc" id="L853">                reqAgg = updateRequestPreProcess(reqAgg, reqAggDAO, loadedFromDB);</span>

                //webtier calls updateRequest() passing a shiftBidRequest with only the updateable
                //fields set to the proper value.  In this case, the parameter 'newState' will be &quot;&quot;.
<span class="pc bpc" id="L857" title="1 of 2 branches missed.">    	        if (StringUtil.isEmpty(newState)) {</span>
<span class="nc" id="L858">    				newState = reqAgg.getRequestStatus();</span>
    			}

<span class="fc" id="L861">                checkStateTransitionAndUpdatePrivilege(reqAgg, newState, suppressPrivilegeChecking);</span>

                // do hard validations
<span class="pc bpc" id="L864" title="1 of 2 branches missed.">                if (!suppressHardValidation) {</span>
<span class="fc" id="L865">                    doHardValidationsRaiseException(reqAgg, RequestUtil.METHODTYPE_MODIFIER, methodSubType, false,skipSomeHardRulesWhenUpdate);</span>
                }

<span class="fc" id="L868">                reqAgg.setRequestStatus(newState);</span>
<span class="pc bpc" id="L869" title="1 of 2 branches missed.">                reqAggDAO.updateRequest(reqAgg, (comment == null)?&quot;&quot;:comment,</span>
<span class="fc" id="L870">                	RequestUtil.getLoginUserBasic(m_sessionContext));</span>
<span class="fc" id="L871">                updateRequestPostProcess(reqAgg, reqAggDAO, loadedFromDB,origState);</span>
<span class="fc" id="L872">                m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
            } finally   {
<span class="pc bpc" id="L874" title="3 of 4 branches missed.">                if (reqAggDAO != null) {</span>
<span class="pc" id="L875">    				reqAggDAO.cleanUp();</span>
    			}
            }
<span class="fc" id="L878">    }</span>
    protected void _updateRequest(RequestAggregate reqAgg, String newState, String comment,
        String methodSubType, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L882">        _updateRequest(reqAgg, newState, comment, methodSubType,</span>
            false, suppressPrivilegeChecking, loadedFromDB);
<span class="nc" id="L884">    }</span>

	@Override
	public      void updateRequest(RequestAggregate reqAgg, String comment)
        throws BbmUpdateException, MultiUserException, RmHardValidationException {
<span class="nc" id="L889">          updateRequest( reqAgg,  comment,false);</span>
<span class="nc" id="L890">	}</span>
    /**
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#updateRequest(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	public void updateRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeCheck)
        throws BbmUpdateException, MultiUserException, RmHardValidationException {

        //RmUtil.dumpCollection(tor.getRequestChoiceList())
        //RmUtil.dumpCollection(ssr.getShiftSwapItems())
<span class="nc" id="L900">    	String _method_ = &quot;updateRequest&quot;;</span>
<span class="nc" id="L901">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L903">        long detailLevelForVal = getDetailLevelForValidation();</span>
<span class="nc" id="L904">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L905">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L906">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L908">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L909">            IRequestType reqMgr = getRequestManager();</span>

            //fetch request from DB to obtain old status
<span class="nc bnc" id="L912" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(detailLevelForVal):reqAggDAO;</span>
<span class="nc" id="L913">            RequestAggregate oldReqAgg = reqAggDAO.getRequestByID(reqAgg.getID(), RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L914">            String oldStatus = oldReqAgg.getRequestStatus();</span>

            // tentatively approved requests cannot be edited.
<span class="nc" id="L917">            String newStatus = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L918" title="All 4 branches missed.">            if (oldStatus.equals(newStatus) &amp;&amp; RequestAuditTrail.STATUS_TENTATIVE.equals(oldStatus)) {</span>
<span class="nc" id="L919">                throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.REQ_CANNOT_EDIT_TENTATIVE_REQ , m_cat);</span>
            }

            // if a tentatively approved request is being withdrawn, then undo the schedule changes done for
            // tentative approval.  Note that this must be done before the request update below (as the update
            // changes the request's status and possibly other fields).
<span class="nc bnc" id="L925" title="All 2 branches missed.">            if (RequestAuditTrail.STATUS_TENTATIVE.equals(oldStatus) &amp;&amp;</span>
<span class="nc bnc" id="L926" title="All 2 branches missed.">                RequestAuditTrail.STATUS_WITHDRAWN.equals(newStatus)) {</span>
<span class="nc" id="L927">                _undoSchedule(reqAgg, null, null);</span>
            }

            // cannot pass 'oldReqAgg' and set the 'loadedFromDB' parameter to 'true'
            // in the following call since 'oldReqAgg' does not have the updates done to 'reqAgg'.
<span class="nc" id="L932">            _updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, suppressPrivilegeCheck, false);</span>

            // fire notifications only if request status has changed.
<span class="nc bnc" id="L935" title="All 2 branches missed.">            if (!oldStatus.equals(newStatus)) {</span>
<span class="nc" id="L936">                fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_PENDING, reqAgg);</span>

<span class="nc" id="L938">                fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_ESCALATED, reqAgg);</span>
            }

            // do autoprocessing if necessary.
<span class="nc bnc" id="L942" title="All 4 branches missed.">            if (reqAgg.isPending()||reqAgg.isWaitlisted()) {</span>
                // reload object to refresh objectVersionNumber (or column 'changeCounter' in DB used
                // for optimistic locking to prevent multi-user updates).
<span class="nc" id="L945">	            RequestAggregate reqAggOld =reqAgg;</span>

<span class="nc bnc" id="L947" title="All 2 branches missed.">	            reqAggDAO = (reqAggDAO == null) ? getDAO(detailLevelForVal) : reqAggDAO;</span>
<span class="nc" id="L948">	            reqAgg = reqAggDAO.getRequestByID(reqAgg.getID(), detailLevelForVal);</span>
<span class="nc" id="L949">	             setTOHoursPerDayForRequest( reqAggOld,  reqAgg);</span>
                //TODO: autoprocessing bracketed by its own transaction.
<span class="nc" id="L951">	             reqMgr._autoProcess(reqAgg, comment, true);</span>
            }
<span class="nc" id="L953">		} catch (BbmObjectNotFoundException e) {</span>
			// Show more specific error message if exception happens because the request has just become expired
<span class="nc" id="L955">			RequestAggregate req = getRequest(reqAgg.getID());</span>
<span class="nc" id="L956">			handleException(e);</span>
<span class="nc bnc" id="L957" title="All 4 branches missed.">			if (req != null &amp;&amp; req.hasExpired()) {</span>
<span class="nc" id="L958">				throw new BbmUpdateException(e, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.FLEX_REQ_ALREADY_EXPIRED, null);</span>
			} else {
<span class="nc" id="L960">				throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
			}
<span class="nc" id="L962">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L969">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L970">			throw e;</span>
<span class="nc" id="L971">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L972">			m_cat.error(e, e);</span>
<span class="nc" id="L973">			handleException(e);</span>
<span class="nc" id="L974">			throw e;</span>
<span class="nc" id="L975">		} catch (MultiUserException e) {</span>
<span class="nc" id="L976">			handleException(e);</span>
<span class="nc" id="L977">			throw e;</span>
<span class="nc" id="L978">    	} catch (Exception e) {</span>
<span class="nc" id="L979">    		handleException(e);</span>
<span class="nc" id="L980">    		throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
    	} finally {
<span class="nc bnc" id="L982" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L983">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L985" title="All 4 branches missed.">            if (reqAggDAO != null) {</span>
<span class="nc" id="L986">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L988">            methodFinish();</span>
<span class="nc" id="L989">    	}</span>
<span class="nc" id="L990">    }</span>


	private RequestAggregate getRequest(ID id) {
		try {
<span class="nc" id="L995">			return _getRequestByID(id, true, false, false, getDetailLevelForValidation());</span>
<span class="nc" id="L996">		} catch (Exception e) {</span>
			// ignore it
		}
<span class="nc" id="L999">		return null;</span>
	}

	public static final RmHardValidationException createAndLogHardValForUnathToPurge(String userName, ID privFailedOrgID, Category cat) {
<span class="nc" id="L1003">		return RequestUtil.createAndLogRmHardValidationException(</span>
				RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_TO_PURGE,
				RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_TO_PURGE,
				new Object[]{userName, privFailedOrgID},
				cat);
	}

    // deletes a Request
    @Override
	public void deleteRequest(ID requestId, String comment) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1013">        String _method_ = &quot;deleteRequest&quot;;</span>
<span class="nc" id="L1014">        methodStart(_method_, requestId, comment);</span>

        // Validate that requestor has purge privilege
<span class="nc" id="L1017">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1018">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1019">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1021">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1023">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1024">            Collection orgIDs = getCurrentOrgIDsForReqID(requestId, reqAggDAO);</span>

<span class="nc" id="L1026">    		String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>
<span class="nc" id="L1027">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, orgIDs, getPrivIDPurge());</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1029">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID,	m_cat);</span>
			}

<span class="nc" id="L1032">            reqAggDAO.deleteRequest(requestId);</span>
<span class="nc" id="L1033">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			// Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1038">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1039">			throw e;</span>
<span class="nc" id="L1040">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1041">			m_cat.error(e, e);</span>
<span class="nc" id="L1042">			handleException(e);</span>
<span class="nc" id="L1043">			throw e;</span>
<span class="nc" id="L1044">        } catch (Exception e) {</span>
<span class="nc" id="L1045">            handleException(e);</span>
<span class="nc" id="L1046">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1048" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1049">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1051" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1052">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1054">            methodFinish();</span>
<span class="nc" id="L1055">        }</span>
<span class="nc" id="L1056">    }</span>

    // deletes a Collection of Requests
    @Override
	public void deleteRequests(Collection reqIDs, String comment) throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1061">        String _method_ = &quot;deleteRequests&quot;;</span>
<span class="nc" id="L1062">        methodStart(_method_, reqIDs, comment);</span>

<span class="nc" id="L1064">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1065">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1066">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1068">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1070">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>

            // Get the set of organizations involved in the delete
<span class="nc" id="L1073">            Set orgIDSet = new HashSet();</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">            for (Iterator it = reqIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1075">                ID reqId = (ID) it.next();</span>
                // todo: can't we do a bulk load.
<span class="nc" id="L1077">                orgIDSet.add(getCurrentOrgIDsForReqID(reqId, reqAggDAO));</span>
<span class="nc" id="L1078">            }</span>

            // Check that the user has purge privilege in each organization
<span class="nc" id="L1081">			String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>
<span class="nc" id="L1082">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, orgIDSet, getPrivIDPurge());</span>
<span class="nc bnc" id="L1083" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1084">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID,	m_cat);</span>
			}

<span class="nc" id="L1087">            reqAggDAO.deleteRequests(reqIDs);</span>
<span class="nc" id="L1088">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1095">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1096">			throw e;</span>
<span class="nc" id="L1097">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1098">			m_cat.error(e, e);</span>
<span class="nc" id="L1099">			handleException(e);</span>
<span class="nc" id="L1100">			throw e;</span>
<span class="nc" id="L1101">        } catch (Exception e) {</span>
<span class="nc" id="L1102">            handleException(e);</span>
<span class="nc" id="L1103">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1105" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1106">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1108" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1109">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1111">            methodFinish();</span>
<span class="nc" id="L1112">        }</span>
<span class="nc" id="L1113">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByType(ID, boolean, String, ID) deleteRequestsByType}
     *
     * Delete all the requests of the given subtype.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequests(ID organizationId, boolean isForBranch, ID subType) throws BbmRemoveException, RmHardValidationException {
<span class="fc" id="L1136">        String _method_ = &quot;deleteRequests&quot;;</span>
<span class="fc" id="L1137">        methodStart(_method_, organizationId, new Boolean(isForBranch), subType);</span>

        // Validate that requestor has purge privilege
<span class="fc" id="L1140">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="fc" id="L1141">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L1142">        boolean cacheEnabled = false;</span>
        try {
<span class="fc" id="L1144">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="fc" id="L1146">			String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="fc" id="L1148">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singletonList(organizationId), getPrivIDPurge());</span>
<span class="pc bpc" id="L1149" title="1 of 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1150">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="fc" id="L1153">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="fc" id="L1154">            reqAggDAO.deleteRequests(organizationId, isForBranch, getRequestType(), subType);</span>
<span class="nc" id="L1155">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1162">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1163">			throw e;</span>
<span class="nc" id="L1164">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1165">			m_cat.error(e, e);</span>
<span class="nc" id="L1166">			handleException(e);</span>
<span class="nc" id="L1167">			throw e;</span>
<span class="nc" id="L1168">        } catch (Exception e) {</span>
<span class="nc" id="L1169">            handleException(e);</span>
<span class="nc" id="L1170">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L1172" title="3 of 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1173">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc bpc" id="L1175" title="3 of 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="pc" id="L1176">				reqAggDAO.cleanUp();</span>
			}
<span class="pc" id="L1178">            methodFinish();</span>
<span class="fc" id="L1179">        }</span>
<span class="fc" id="L1180">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByDate(ID, boolean, Date, String, ID) deleteRequestsByDate}
     *
     * Delete all the requests of the given subtype that concern dates that
     * are older than the given date.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param date purge the requests that concern dates older than this date
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequestsByDate(ID organizationId, boolean isForBranch, Date date, ID subType)
        throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1207">        String _method_ = &quot;deleteRequestsByDate&quot;;</span>
<span class="nc" id="L1208">        methodStart(_method_, organizationId, new Boolean(isForBranch), date, subType);</span>

<span class="nc" id="L1210">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1211">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1212">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1214">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1216">			String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L1218">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1220">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L1223">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1224">            reqAggDAO.deleteRequestsByDate(organizationId, isForBranch, date, getRequestType(), subType);</span>
<span class="nc" id="L1225">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1232">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1233">			throw e;</span>
<span class="nc" id="L1234">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1235">			m_cat.error(e, e);</span>
<span class="nc" id="L1236">			handleException(e);</span>
<span class="nc" id="L1237">			throw e;</span>
<span class="nc" id="L1238">        } catch (Exception e) {</span>
<span class="nc" id="L1239">            handleException(e);</span>
<span class="nc" id="L1240">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1242" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1243">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1245" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1246">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1248">            methodFinish();</span>
<span class="nc" id="L1249">        }</span>
<span class="nc" id="L1250">    }</span>

    /**
     * see {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManagerEJB#deleteRequestsByDateRange(ID, boolean, TimeRange, String, ID) deleteRequestsByDateRange}
     *
     * Delete all the requests of the given subtype that were created in the
     * given date range.
     *
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param range the range to use when purging requests.  All subject requests that were
     * created within this time range will be purged.
     *
     * @param requestType the type of request to purge.  This can be all or a specific
     * type like time off or shift swap.  The constants to use for this parameter are defined
     * in the {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public void deleteRequestsByDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException {
<span class="nc" id="L1282">        String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L1283">        methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L1285">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L1286">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1287">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1289">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1291">            String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L1293">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L1295">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L1298">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L1299">            reqAggDAO.deleteRequestsByDateRange(organizationId, isForBranch, range, getRequestType(), subType);</span>
<span class="nc" id="L1300">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			
            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1306">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1307">			throw e;</span>
<span class="nc" id="L1308">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1309">			m_cat.error(e, e);</span>
<span class="nc" id="L1310">			handleException(e);</span>
<span class="nc" id="L1311">			throw e;</span>
<span class="nc" id="L1312">        } catch (Exception e) {</span>
<span class="nc" id="L1313">            handleException(e);</span>
<span class="nc" id="L1314">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1316" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1317">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L1319" title="All 4 branches missed.">            if ( reqAggDAO != null ) {</span>
<span class="nc" id="L1320">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1322">            methodFinish();</span>
<span class="nc" id="L1323">        }</span>
<span class="nc" id="L1324">    }</span>

    /**
     * Delete all the requests of the given subtype that were start within the
     * given date range.
     * to be implemented by respective request managers
     * @param organizationId the organization id for which to purge the requests
     *
     * @param isForBranch true=&gt; the purge request affects the given organization and
     * all suborganizations, i.e. the whole &quot;branch&quot;.  false=&gt; the purge request affects
     * only the given organization and not any organizations under it.
     *
     * @param range the range to use when purging requests.  All subject requests that were
     * created within this time range will be purged.
     *
     * @param requestType the type of request to purge.  This can be all or a specific
     * type like time off or shift swap.  The constants to use for this parameter are defined
     * in the {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request} value object.
     *
     * @param subType this ID parameter defines the subtype of the request type to purge.
     * It can be null (and indeed should be for requestType=ALL requests).  Its meaning is
     * request type dependent.
     *
     * @throws com.bluepumpkin.ejb.bbm.base.BbmRemoveException when an error prevents
     * the purge operation from completing
     * @throws java.rmi.RemoteException when there was an RMI communication failure
     */
    @Override
	public abstract void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
            throws BbmRemoveException, RmHardValidationException;

    /**
     * @param reqAgg
     * @param toChoiceID
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected boolean  _waitlistRequest(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1364">        return false;</span>
	}

    /**
     * @param reqAgg
     * @param apprChoiceID only applies for TORequest.  If 'null', then the first TOChoice is approved.
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected abstract void _approveRequest(RequestAggregate reqAgg, ID apprChoiceID,
        String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception;
	/**
     * Overridden by TORequestManagerEJB.
     * @param reqAgg
     * @param apprChoiceID only applies for TORequest. It serves for new Group Action: Approve Time Off Choice without violations
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _approveRequestChoice(RequestAggregate reqAgg, ID apprChoiceID,
        String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
    	
<span class="nc" id="L1389">    }</span>

    /**
     * approves the request specified by its ID.  For Shiftswap request, approves
     * the shift swap and swaps the shifts.  For TORequest the first TOChoice is approved
     * and the schedule is updated.  If any hard validations fail, then request not approved
     * and is marked invalid.
     *
     * @param reqID ID of the request to be approved
     * @param reqItemIndex the TOChoice to be approved (only for TORequests)
     * @throws
     */
    @Override
	public void approveRequestByID(ID reqID, ID choiceID, String objectVersionNumber, String comment)
            throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L1404">	    String _method_ = &quot;approveRequestByID&quot;;</span>
<span class="nc" id="L1405">	    methodStart(_method_, reqID, choiceID, objectVersionNumber, comment);</span>

<span class="nc" id="L1407">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1408">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L1410">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

		    // get the timeoff request for the given ID
<span class="nc" id="L1413">		    RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>

		    // set the object version number if necessary
<span class="nc bnc" id="L1416" title="All 2 branches missed.">		    if (objectVersionNumber != null) {</span>
<span class="nc" id="L1417">				reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
			}
<span class="nc" id="L1419">		    _approveRequestWorkFlow(reqAgg, choiceID, comment, false, true);</span>
<span class="nc" id="L1420">	    } catch (MultiUserException exM) {</span>
<span class="nc" id="L1421">		    handleException(Priority.DEBUG, exM);</span>
<span class="nc" id="L1422">		    throw exM;</span>
<span class="nc" id="L1423">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.
		    //m_cat.error(e, e);

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1430">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1431">		    throw e;</span>
<span class="nc" id="L1432">	    } catch (RmException e) {</span>
<span class="nc" id="L1433">		    m_cat.error(e, e);</span>
<span class="nc" id="L1434">		    handleException(e);</span>
<span class="nc" id="L1435">		    throw e;</span>
<span class="nc" id="L1436">	    } catch (Exception e) {</span>
<span class="nc" id="L1437">		    handleException(e);</span>
<span class="nc" id="L1438">		    throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L1440" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L1441">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1443">		    methodFinish();</span>
<span class="nc" id="L1444">	    }</span>
<span class="nc" id="L1445">    }</span>

    /**
     * approves the given request.  For Shiftswap request, approves
     * the shift swap and swaps the shifts.  For TORequest the first TOChoice is approved
     * and the schedule is updated.  If any hard validations fail, then the request
     * is not approved and is marked invalid.
     *
     * TODO: verify that this method is not called by code in the bean class.  must call _approveRequest instead.
     *
     * @param reqAgg the request to be approved
     * @param reqItemIndex the TOChoice to be approved (only for TORequests)
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws
     */
    @Override
	public void approveRequest(RequestAggregate reqAgg, ID choiceID, String comment)
        throws    RmHardValidationException, RmException {
<span class="nc" id="L1463">        String _method_ = &quot;approveRequest&quot;;</span>
<span class="nc" id="L1464">        methodStart(_method_, reqAgg, choiceID, comment);</span>

<span class="nc" id="L1466">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1467">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1469">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1471">            _approveRequestWorkFlow(reqAgg, choiceID, comment, false, false);</span>
<span class="nc" id="L1472">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1479">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1480">			throw e;</span>
<span class="nc" id="L1481">		} catch (RmException e) {</span>
<span class="nc" id="L1482">			m_cat.error(e, e);</span>
<span class="nc" id="L1483">			handleException(e);</span>
<span class="nc" id="L1484">			throw e;</span>
<span class="nc" id="L1485">        } catch (Exception e) {</span>
<span class="nc" id="L1486">            handleException(e);</span>
<span class="nc" id="L1487">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1489" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1490">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1492">            methodFinish();</span>
<span class="nc" id="L1493">        }</span>
<span class="nc" id="L1494">    }</span>

    /**
     * Overridden by TORequestManagerEJB.
     *
     * @param reqAgg
     * @param choiceID Applies only to TOReqs.  See {@link com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManagerEJB#_approveRequest(RequestAggregate, ID, String, boolean, boolean) _approveRequest()}
     * for further information.
     *
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _approveRequestWorkFlow(RequestAggregate reqAgg, ID choiceID, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="fc" id="L1511">        _approveRequest(reqAgg, choiceID, comment, suppressPrivilegeChecking, loadedFromDB);</span>

<span class="fc" id="L1513">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_APPROVED, reqAgg);</span>

<span class="fc" id="L1515">        _approveRequestPostProcess(reqAgg, choiceID, comment);</span>
<span class="fc" id="L1516">    }</span>
	/**
     * Overridden by TORequestManagerEJB.
     *
     * @param reqAgg
     * @param choiceID Applies only to TOReqs.  See {@link com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManagerEJB#_approveRequest(RequestAggregate, ID, String, boolean, boolean) _approveRequest()}
     * for further information.
     *
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _approveRequestChoiceWorkFlow(RequestAggregate reqAgg, ID choiceID, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc" id="L1532">        _approveRequestChoice(reqAgg, choiceID, comment, suppressPrivilegeChecking, loadedFromDB);</span>

<span class="nc" id="L1534">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_APPROVED, reqAgg);</span>

<span class="nc" id="L1536">        _approveRequestPostProcess(reqAgg, choiceID, comment);</span>
<span class="nc" id="L1537">    }</span>
    
	/**
	 *
	 * @param reqAgg
	 * for further information.
	 *
	 * @param toChoiceID
     * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	protected boolean _waitlistRequestWorkFlow(RequestAggregate reqAgg, ID toChoiceID, String comment, boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1551">		boolean result = _waitlistRequest(reqAgg, toChoiceID, comment, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc bnc" id="L1552" title="All 2 branches missed.">		if (result) {</span>
<span class="nc" id="L1553">			fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WAITLIST, reqAgg);</span>
<span class="nc" id="L1554">			_waitlistRequestPostProcess(reqAgg, comment);</span>
		}
<span class="nc" id="L1556">		return result;</span>
	}

	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 * @param reqAgg  for further information.
	 */
	public boolean areWaitlistPreferencesSetForRequest(RequestAggregate reqAgg) throws BbmException{
<span class="nc" id="L1565">		return false;</span>
	}
	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 */
    public  boolean canRequestBeWaitlistedBasedOnValidations(int[] apprDenyResult1, Collection[] apprDenyValResults1)throws BbmException{
<span class="nc" id="L1572">        return false;</span>
    }
	/**
	 * overridden by TORequestManagerEJB only, returns false for all other types of Requests
	 *
	 * @param reqAgg  for further information.
	 */
	public boolean ignoreAmbiguousAutoProcessResults(RequestAggregate reqAgg) {
<span class="nc" id="L1580">		return false;</span>
	}
	/**
	 * overridden by TORequestManagerEJB only.
	 *
	 * @param reqAgg
	 * for further information.
	 * @param comment
	 */
	protected  void _waitlistRequestPostProcess(RequestAggregate reqAgg, String comment){

<span class="nc" id="L1591">	}</span>
	protected abstract void _approveRequestPostProcess(RequestAggregate reqAgg, ID choiceID, String comment);

    /**
     * @param reqAgg
     * @param choiceID only applies for TORequests.  If 'null', then the first TOChoice is approved.
     * @param comment
     */
    protected abstract void _approveRequestTentatively(RequestAggregate reqAgg, ID choiceID, String comment,
        boolean loadedFromDB) throws Exception;

    /**
     * @see IRequestType#approveRequestTentativelyByID
     *
     * @param reqID - ID of the time off request.
     * @param choiceID - Choice id for teh time off request.
     * @param objectVersionNumber - object version number of request on which status change is based.
     * @param pComments - comments for time off request.
     * @throws - BbmUpdateException.
     */
    @Override
	public void approveRequestTentativelyByID(ID reqID, ID choiceID, String objectVersionNumber, String comment)
            throws RmHardValidationException, RmException, MultiUserException {
<span class="nc" id="L1614">	    String _method_ = &quot;approveRequestTentativelyByID&quot;;</span>
<span class="nc" id="L1615">	    methodStart(_method_, reqID, choiceID, objectVersionNumber, comment);</span>

<span class="nc" id="L1617">	    String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1618">	    boolean cacheEnabled = false;</span>
	    try {
<span class="nc" id="L1620">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
		    //obtain the Request object
<span class="nc" id="L1622">		    RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>
<span class="nc bnc" id="L1623" title="All 2 branches missed.">		    if (objectVersionNumber != null) {</span>
<span class="nc" id="L1624">				reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
			}

<span class="nc" id="L1627">		    _approveRequestTentatively(reqAgg, choiceID, comment, true);</span>
		    // Notifications not supported for tentative approval
<span class="nc" id="L1629">	    } catch (MultiUserException exM) {</span>
<span class="nc" id="L1630">		    handleException(Priority.DEBUG, exM);</span>
<span class="nc" id="L1631">		    throw exM;</span>
<span class="nc" id="L1632">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1637">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1638">		    throw e;</span>
<span class="nc" id="L1639">	    } catch (RmException e) {</span>
<span class="nc" id="L1640">		    m_cat.error(e, e);</span>
<span class="nc" id="L1641">		    handleException(e);</span>
<span class="nc" id="L1642">		    throw e;</span>
<span class="nc" id="L1643">	    } catch (Exception e) {</span>
<span class="nc" id="L1644">		    handleException(e);</span>
<span class="nc" id="L1645">		    throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="nc bnc" id="L1647" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L1648">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1650">		    methodFinish();</span>
<span class="nc" id="L1651">	    }</span>
<span class="nc" id="L1652">    }</span>

     protected abstract void _denyRequest(RequestAggregate reqAgg, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception;


    /**
     * @see IRequestType#denyRequestByID denyRequestByID
     *
     * @param reqID
     * @param objectVersionNumber
     * @param comment
     * @throws
     * @throws RmHardValidationException
     */
    @Override
	public void denyRequestByID(ID reqID, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException
    {
<span class="nc" id="L1671">        String _method_ = &quot;denyRequestByID&quot;;</span>
<span class="nc" id="L1672">        methodStart(_method_, reqID, objectVersionNumber, comment);</span>

<span class="nc" id="L1674">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1675">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1677">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // get the timeoff request for the given ID
<span class="nc" id="L1680">            RequestAggregate toReq = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>

            // set the object version number if necessary
<span class="nc bnc" id="L1683" title="All 2 branches missed.">            if ( objectVersionNumber != null ) {</span>
<span class="nc" id="L1684">				toReq.setObjectVersionNumber(objectVersionNumber);</span>
			}

<span class="nc" id="L1687">            _denyRequestWorkflow(toReq, comment, false, true);</span>
<span class="nc" id="L1688">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1693">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1694">			throw e;</span>
<span class="nc" id="L1695">		} catch (RmException e) {</span>
<span class="nc" id="L1696">			m_cat.error(e, e);</span>
<span class="nc" id="L1697">			handleException(e);</span>
<span class="nc" id="L1698">			throw e;</span>
<span class="nc" id="L1699">        } catch (Exception e) {</span>
<span class="nc" id="L1700">            handleException(e);</span>
<span class="nc" id="L1701">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1703" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1704">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1706">            methodFinish();</span>
<span class="nc" id="L1707">        }</span>
<span class="nc" id="L1708">    }</span>

    /**
     * Denies the given request.  If any hard validations fail, then
     * request is marked invalid.
     *
     * @param reqAgg the request to be approved
     * @return To check if any hard vaidations failed, check validation results in the request.
     * @throws
     */
    @Override
	public void denyRequest(RequestAggregate reqAgg, String comment)
        throws  RmHardValidationException, RmException
    {
<span class="nc" id="L1722">        String _method_ = &quot;denyRequest&quot;;</span>
<span class="nc" id="L1723">        methodStart(_method_, reqAgg, comment);</span>

<span class="nc" id="L1725">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L1726">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L1728">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1730">            _denyRequestWorkflow(reqAgg, comment, false, false);</span>
<span class="nc" id="L1731">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
		    // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1736">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1737">			throw e;</span>
<span class="nc" id="L1738">		} catch (RmException e) {</span>
<span class="nc" id="L1739">			m_cat.error(e, e);</span>
<span class="nc" id="L1740">			handleException(e);</span>
<span class="nc" id="L1741">			throw e;</span>
<span class="nc" id="L1742">        } catch (Exception e) {</span>
<span class="nc" id="L1743">            handleException(e);</span>
<span class="nc" id="L1744">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1746" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L1747">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L1749">            methodFinish();</span>
<span class="nc" id="L1750">        }</span>
<span class="nc" id="L1751">    }</span>


    protected void _denyRequestWorkflow(RequestAggregate reqAgg, String comment, boolean suppressPrivChecking,
        boolean loadedFromDB) throws Exception {
<span class="fc" id="L1756">        _denyRequest(reqAgg, comment, suppressPrivChecking, loadedFromDB);</span>

<span class="fc" id="L1758">        fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_DENIED, reqAgg);</span>

<span class="fc" id="L1760">        _denyRequestPostProcess(reqAgg, comment);</span>
<span class="fc" id="L1761">    }</span>

    /**
     * @param reqAgg
     * @param comment
     */
    protected abstract void _denyRequestPostProcess(RequestAggregate reqAgg, String comment);

    /**
     * Determine if a request is a shift swap withdrawl request.
     * To be overriden if necessary in extending classes.
     */
    public boolean isShiftSwapWithdrawRequest(RequestAggregate reqAgg) {
<span class="fc" id="L1774">    	return false;</span>
    }

    /**
     * Do the auto processing for a request.
     *
     * &lt;pre&gt;
     *   Rules:
     *       1. Find all autoProc rules that apply to the request.
     *       2. If any rule specifies &quot;APPRCLAUSE_DONOT_APPROVE&quot;, then the request must not be approved irrespective
     *       of what the other rules evalaute to.
     *       3. If a rule evaluates to &quot;APPRCLAUSE_NO_VIOLATIONS&quot;, then can ignore &quot;APPRCLAUSE_VIOLATIONS_FOUND&quot;
     *       from rules after it.  But must still consider APPRCLAUSE_DONOT_APPROVE from these rules.
     *       4. If any rule specifies &quot;DENYCLAUSE_DONOT_DENY&quot;, then the request must not be denied irrespective of
     *       what the other rules evaluate to.
     *       5. If any rule evaluates to &quot;DENYCLAUSE_VIOLATIONS_FOUND&quot;, then can ignore &quot;DENYCLAUSE_NO_VIOLATIONS&quot;
     *       from rules after it. But still should consider &quot;DENYCLAUSE_DONOT_DENY&quot; from these rules.
     *       6. if rule evaluates to both &quot;APPRCLAUSE_APPR_NO_VIOLATIONS&quot; and &quot;DENYCLAUSE_DENY_VIOLATIONS_FOUND&quot;
     *       then request must not be autoprocessed.
     *
     *       7. For SSReqs, both ssItems need to be considered before deciding to approve or deny
     *       the request.
     *           7a. Only if both SSItems evaluate to &quot;APPRCLAUSE_APPR_NO_VIOLATIONS&quot; request is approved.
     *           7b. if one or both ssItems evaluate to &quot;DENYCLAUSE_DENY_NO_VIOLATIONS&quot; and the other does
     *           not evaluate to DENYCLAUSE_DO_NOT_DENY, then the request is denied.
     *
     *
     *   Short circuits:
     *       1. Stop if approval == APPRCLAUSE_DONOT_APPROVE and denial == DENYCLAUSE_DONOT_DENY
     *       2. First scan autoProc rules to see if APPRCLAUSE_DONOT_APPROVE and DENYCLAUSE_DONOT_DENY can be detected.
     *      If so, then the other autoprocessing rules need not be evaluated.
     *
     * &lt;/pre&gt;
     *
     * TODO: change transaction attribute to RequiresNew
     *
     * @param ssr The ShiftSwapRequest for which to do auto processing.
     * @param comment The original comment for the operation (update or create)
     *
     * @return True if request was approved or denied by autoprocessing.
     *         False otherwise.
     *
     */
    @Override
	public Pair _autoProcess(RequestAggregate reqAgg, String comment, boolean loadedFromDB)
            throws BbmUpdateException, RmHardValidationException,MultiUserException {
<span class="fc" id="L1820">	    Pair retPair = new Pair(&quot;false&quot;, null);</span>
<span class="fc" id="L1821">	    String _method_ = &quot;_autoProcess&quot;;</span>
<span class="fc" id="L1822">	    methodStart(_method_, reqAgg, comment);</span>
	    // if not in pending request, auto processing not done.
<span class="fc" id="L1824">	    String reqStatus = reqAgg.getRequestStatus();</span>
<span class="pc bpc" id="L1825" title="1 of 2 branches missed.">	    if ((reqStatus != null)</span>
<span class="pc bpc" id="L1826" title="3 of 4 branches missed.">	            &amp;&amp; !(reqStatus.equals(RequestAuditTrail.STATUS_PENDING) || reqStatus.equals(RequestAuditTrail.STATUS_WAITLIST) </span>
<span class="nc bnc" id="L1827" title="All 2 branches missed.">	            		|| isShiftSwapWithdrawRequest(reqAgg))) {</span>
<span class="nc" id="L1828">		    return retPair;</span>
	    }
<span class="pc bpc" id="L1830" title="1 of 2 branches missed.">	    comment = (comment == null) ? &quot;&quot; : comment;</span>
<span class="fc" id="L1831">	    StringBuffer denyCommentBuff = new StringBuffer(comment);</span>
<span class="fc" id="L1832">	    String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L1833">	    boolean cacheEnabled = false;</span>
	    try {
<span class="fc" id="L1835">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="fc" id="L1836">		    ValidationCache vc = reqAgg.getValidationCache();</span>
			//Lock the employee's time off pool if this is a time off request
<span class="fc" id="L1838">			TimeOffPoolDBLock.getTimeOffPoolLock(reqAgg);</span>
<span class="fc" id="L1839">		    boolean processAllTimeRangePairs = isProcessAllTimeRangePairs(reqAgg);</span>
		    // auto process each item in the request separately. this way the
		    // set of validators for each organization is passed to the checker separately
		    // also the validators can
<span class="fc" id="L1843">		    Pair pair = getEmpIDTimeRangePairsForAutoProcess(reqAgg);</span>
<span class="fc" id="L1844">		    Collection empIDTimeRangePairs = (Collection) pair.getFirst();</span>
<span class="fc" id="L1845">		    ArrayList toChoiceList = (ArrayList) pair.getSecond();</span>
<span class="fc" id="L1846">		    Iterator iter = empIDTimeRangePairs.iterator();</span>
<span class="fc" id="L1847">		    boolean denyFirstTimeRangePair = false;</span>
<span class="fc" id="L1848">		    int counter = 0;</span>
<span class="fc" id="L1849">		    TOChoice toChoice = null;</span>
<span class="fc bfc" id="L1850" title="All 2 branches covered.">		    for (; iter.hasNext(); counter++) {</span>
			    // this map stores the status of executed validators so they don't need
			    // to be run more than once.  a map of validator name to a collection of validation results.
<span class="fc" id="L1853">			    Map ruleNameToValResultsMap = new HashMap(19);</span>
<span class="fc" id="L1854">			    Pair empIDTimeRangePair = (Pair) iter.next();</span>
<span class="pc bpc" id="L1855" title="3 of 6 branches missed.">			    if (reqAgg.isTimeOffRequest() &amp;&amp; toChoiceList != null &amp;&amp; toChoiceList.size() &gt; counter) {</span>
<span class="fc" id="L1856">				    toChoice = (TOChoice) toChoiceList.get(counter);</span>
<span class="fc" id="L1857">				    ((TORequest) reqAgg).setTOChoiceForValidation(toChoice);</span>
			    }
<span class="fc" id="L1859">			    ID empID = (ID) empIDTimeRangePair.getFirst();</span>
<span class="fc" id="L1860">			    TimeRange timeRange = (TimeRange) empIDTimeRangePair.getSecond();</span>
<span class="fc" id="L1861">			    Collection[] apprDenyValResults1 = new Collection[3];</span>
<span class="fc" id="L1862">			    int[] apprDenyResult1 = runAutoProcessForTimeRange(empID, timeRange,</span>
			            true, true, apprDenyValResults1, reqAgg, ruleNameToValResultsMap);

<span class="pc bpc" id="L1865" title="1 of 2 branches missed.">			    if (reqAgg.isShiftSwapRequest()) {</span>
<span class="nc" id="L1866">				    Pair empIDTimeRangePair2 = (Pair) iter.next();</span>
<span class="nc" id="L1867">				    ID empID2 = (ID) empIDTimeRangePair.getFirst();</span>
<span class="nc" id="L1868">				    TimeRange timeRange2 = (TimeRange) empIDTimeRangePair.getSecond();</span>

<span class="nc" id="L1870">				    Collection[] apprDenyValResults2 = new Collection[3];</span>
				    // run approval validators only if the earlier decision is not &quot;DO_NOT_APPROVE&quot;
				    // run denial validators only if the earlier decision is not &quot;DO_NOT_DENY&quot;
<span class="nc bnc" id="L1873" title="All 4 branches missed.">				    int[] apprDenyResult2 = runAutoProcessForTimeRange(empID2, timeRange2,</span>
				            apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] != AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_DONOT_APPROVE,
				            apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY,
				            apprDenyValResults2, reqAgg, ruleNameToValResultsMap);

<span class="nc" id="L1878">				    resolveAutoProcResults(apprDenyResult1, apprDenyResult2, apprDenyValResults1,</span>
				            apprDenyValResults2);
			    }
<span class="pc bpc" id="L1881" title="2 of 4 branches missed.">			    boolean checkForWaitlist = reqAgg.isWaitlisted() || areWaitlistPreferencesSetForRequest(reqAgg);  // will not check for Waitlist criteria if the Waitlist preferences are not set.</span>

<span class="fc" id="L1883">			    String requestStatus = getDecisionBasedOnAutProcessRuleEngineResult(reqAgg, apprDenyResult1, apprDenyValResults1, checkForWaitlist);</span>
			    /*
			   //ambiguous results Check
			   // for time off requests ignore the ambiguous results (done for the Waitlist feature)
			   if (!ignoreAmbiguousAutoProcessResults(reqAgg)) {
			       // If both approve and deny are set to true, the results are ambiguous,
			       // and no auto approval or auto denial should be done in this case.
			       if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS &amp;&amp;
			               apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {
			           m_cat.l7dInfo(RmEjbLogBundleKey.APPROVE_DENY_AMBIGUOUS, new Object[]{reqAgg.getID()});
			           return false;
			       }
			   }*/
<span class="fc" id="L1896">			    StringBuffer commentBuf = new StringBuffer(comment);</span>
<span class="pc bpc" id="L1897" title="1 of 2 branches missed.">			    if (reqAgg.isTimeOffRequest()) {</span>
<span class="fc" id="L1898">				    ((TORequest) reqAgg).setTOChoiceForValidation(null);</span>
			    }

			    // approve the request
			    //if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {
<span class="fc bfc" id="L1903" title="All 2 branches covered.">			    if (requestStatus.equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
				    // Setting status to 'approved' will trigger an exception (during status transition validation)
				    // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
				    // when  _approveRequest() is called below.
				    //reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);
<span class="pc bpc" id="L1908" title="2 of 4 branches missed.">				    if (commentBuf != null &amp;&amp; commentBuf.length() &gt; 1) {</span>
<span class="fc" id="L1909">					    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM));</span>
				    }
<span class="fc" id="L1911">				    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_APPROVED));</span>
<span class="pc bpc" id="L1912" title="1 of 2 branches missed.">				    _approveRequestWorkFlow(reqAgg, (toChoice != null ? toChoice.getID() : null), commentBuf.toString(), true, loadedFromDB);</span>
<span class="fc" id="L1913">				    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_APPROVED);</span>
<span class="fc" id="L1914">				    return retPair;</span>
<span class="pc bpc" id="L1915" title="1 of 2 branches missed.">			    } else if (requestStatus.equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc bnc" id="L1916" title="All 4 branches missed.">				    if (commentBuf != null &amp;&amp; commentBuf.length() &gt; 1) {</span>
<span class="nc" id="L1917">					    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM));</span>
				    }
<span class="nc" id="L1919">				    commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_WAITLISTED));</span>
<span class="nc bnc" id="L1920" title="All 4 branches missed.">				    if (_waitlistRequestWorkFlow(reqAgg, (toChoice != null ? toChoice.getID() : null), commentBuf.toString(), true, loadedFromDB)) {</span>
<span class="nc" id="L1921">					    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_WAITLIST);</span>
<span class="nc" id="L1922">					    return retPair;</span>
				    }
<span class="fc bfc" id="L1924" title="All 2 branches covered.">			    } else if (requestStatus.equals(RequestAuditTrail.STATUS_DENIED)) {</span>
				    // Setting status to 'denied' will trigger an exception (during status transition validation)
				    // with the message &quot;cannot change status from 'denied' to 'denied'&quot;,
				    // when  _denyRequest() is called below.
<span class="pc bpc" id="L1928" title="2 of 4 branches missed.">				    if (reqAgg.isTimeOffRequest() &amp;&amp; reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)) {</span>
<span class="nc" id="L1929">					    TOWaitlist waitlistInfo = ((TORequest) reqAgg).getWaitlistInfo();</span>
<span class="nc bnc" id="L1930" title="All 4 branches missed.">					    if (waitlistInfo != null &amp;&amp; waitlistInfo.isManuallyAdded()) {</span>
<span class="nc" id="L1931">						    m_cat.debug(&quot;Ignoring auto-deny decision because request is manually waitlisted; REQ=&quot; + reqAgg);</span>
<span class="nc" id="L1932">						    return retPair;</span>
					    }
				    }
<span class="pc bpc" id="L1935" title="1 of 2 branches missed.">				    if (counter == 0) {   //Check the Deny work flow for the First req</span>
<span class="fc" id="L1936">					    denyCommentBuff.append(&quot;\n &quot; + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_DENIED));</span>
<span class="fc bfc" id="L1937" title="All 2 branches covered.">					    for (Iterator iterator = apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator(); iterator.hasNext();) {</span>
<span class="fc" id="L1938">						    ValidationResult validationResult = (ValidationResult) iterator.next();</span>
<span class="fc" id="L1939">						    denyCommentBuff.append(&quot;&lt;BR&gt; &quot; + validationResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), vc.getTimeZoneForOrg()));</span>
<span class="fc" id="L1940">					    }</span>
<span class="fc" id="L1941">					    denyFirstTimeRangePair = true;</span>
				    }
<span class="pc bpc" id="L1943" title="1 of 2 branches missed.">				    if (processAllTimeRangePairs) {</span>
<span class="fc" id="L1944">					    continue;       // Proceed to the next TO Choice only if this one is eligible for denial .</span>
				    }
			    } else {
<span class="fc" id="L1947">				    return retPair; //keep status pending if no decision can be made and exit the loop</span>
			    }
		    }
<span class="pc bpc" id="L1950" title="1 of 2 branches missed.">		    if (denyFirstTimeRangePair) {</span>
<span class="fc" id="L1951">			    _denyRequestWorkflow(reqAgg, denyCommentBuff.toString(), true, loadedFromDB);</span>
<span class="fc" id="L1952">			    retPair.setPair(&quot;true&quot;, RequestAuditTrail.STATUS_DENIED);</span>
<span class="fc" id="L1953">			    return retPair;</span>
		    }
<span class="nc" id="L1955">		    return retPair;  //returning false, since No Decision Made neither Approve, Waitlist nor Deny.</span>
		    /*
		    return (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS ||
		        apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND);*/
<span class="nc" id="L1959">	    } catch (RmHardValidationException e) {</span>
		    //RM exceptions are always logged at the point where they are thrown.
		    //m_cat.error(e, e);

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1966">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1967">		    throw e;</span>
<span class="nc" id="L1968">	    } catch (BbmUpdateException e) {</span>
<span class="nc" id="L1969">		    m_cat.error(e, e);</span>
<span class="nc" id="L1970">		    handleException(e);</span>
<span class="nc" id="L1971">		    throw e;</span>
<span class="nc" id="L1972">	    } catch (MultiUserException e) {</span>
<span class="nc" id="L1973">		    m_cat.error(e, e);</span>
<span class="nc" id="L1974">		    handleException(e);</span>
<span class="nc" id="L1975">		    throw e;</span>
<span class="nc" id="L1976">	    }catch (Exception e) {</span>
<span class="nc" id="L1977">		    handleException(e);</span>
<span class="nc" id="L1978">		    throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
	    } finally {
<span class="pc bpc" id="L1980" title="11 of 14 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L1981">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L1983">			methodFinish();</span>
	    }
    }

    protected Pair getEmpIDTimeRangePairsForAutoProcess(RequestAggregate reqAgg) {
<span class="fc" id="L1988">        Pair pair = new Pair();</span>
<span class="pc bpc" id="L1989" title="1 of 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="pc bpc" id="L1990" title="1 of 2 branches missed.">            if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="fc" id="L1991">                pair = ((TORequest) reqAgg).getAllEmpIDTimeRangePairs();</span>
            } else {
<span class="nc" id="L1993">                pair = ((TORequest) reqAgg).getFirstEmpIDTimeRangePair();</span>
            }
        } else{
<span class="nc" id="L1996">           pair.setFirst(reqAgg.getEmpIDTimeRangePairs());</span>
        }
<span class="fc" id="L1998">        return pair;</span>
    }

    /**
     * resolves the first approvalDenialResults with the second and assigns the results
     * to the first.  Also does the corresponding updates to the first approvalDenialValidationResults.
     *
     * &lt;p&gt; Rules:
     * &lt;li&gt; if specified result1 and result2 == approve, then returned result == approve.
     * &lt;li&gt; if either result1 or result2 == deny and the other result is != DO_NOT_DENY, then deny.
     *
     * See javadoc for {@link #_autoProcess(RequestAggregate, String, boolean) _autoProcess()} for
     * a complete description of the logic used for autoprocessing.
     *
     * @param effecApprDenyResults1
     * @param effecApprDenyResults2
     * @param apprDenyValResults1
     * @param apprDenyValResults2
     */
    protected void resolveAutoProcResults(int[] apprDenyResult1, int[] apprDenyResult2,
        Collection[] apprDenyValResults1, Collection[] apprDenyValResults2) {

        //                     NO_VIOL      VIOL_FOUND    DO_NOT_APPR
        // NO_VIOL             appr         donot appr      dont appr
        // VIOL_FOUND          dont appr    donot appr      dont appr
        // DO_NOT_APPR         dont appr     dont appr      dont appr

        // if result1 == APPROVE
<span class="nc bnc" id="L2026" title="All 2 branches missed.">        if ( apprDenyResult1[0] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS ) {</span>
            // if result2 != APPROVE
<span class="nc bnc" id="L2028" title="All 2 branches missed.">            if ( apprDenyResult2[0] != AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
                // effective result == do not approve.

                // Move result from result2 to result1.
<span class="nc" id="L2032">                apprDenyResult1[0] = apprDenyResult2[0];</span>
<span class="nc" id="L2033">                apprDenyValResults1[0] = apprDenyValResults2[0];</span>
            }
        } else { //result1 == APPRCLAUSE_DO_NOT_APPROVE or APPRCLAUSE_VIOLATIONS_FOUND
            // leave as is.
        }

        //                     NO_VIOL      VIOL_FOUND    DO_NOT_DENY
        // NO_VIOL             dont deny       deny          dont deny
        // VIOL_FOUND            deny          deny          dont deny
        // DO_NOT_DENY         dont deny     dont deny       dont deny

        // if result1 == DENY and result2 != DO_NOT_DENY
<span class="nc bnc" id="L2045" title="All 4 branches missed.">        if ( apprDenyResult1[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND &amp;&amp;</span>
             apprDenyResult2[1] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY ) {

             // leave as is.

        // if result2 == DENY and result1 != DO_NOT_DENY
<span class="nc bnc" id="L2051" title="All 4 branches missed.">        } else if ( apprDenyResult2[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND &amp;&amp;</span>
            apprDenyResult1[1] != AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY ) {
            // move results from result2 to result1.
<span class="nc" id="L2054">            apprDenyResult1[1] = apprDenyResult2[1];</span>
<span class="nc" id="L2055">            apprDenyValResults1[1] = apprDenyValResults2[1];</span>
        } else {
            // this handles the case where result1 == VIOL_FOUND and result2 == DONOT_DENY.
<span class="nc bnc" id="L2058" title="All 2 branches missed.">            if (apprDenyResult2[1] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_DONOT_DENY) {</span>
                // move results from result2 to result1.
<span class="nc" id="L2060">                apprDenyResult1[1] = apprDenyResult2[1];</span>
<span class="nc" id="L2061">                apprDenyValResults1[1] = apprDenyValResults2[1];</span>
            } else {
                // leave  as is (do not deny)
            }
        }

<span class="nc" id="L2067">        m_cat.debug(&quot;final autoproc approval result considering result1 and result2 = &quot; + apprDenyResult1[0]);</span>
<span class="nc" id="L2068">        m_cat.debug(&quot;final autoproc deny result considering result1 and result2 = &quot; + apprDenyResult1[1]);</span>
<span class="nc" id="L2069">    }</span>

    /**
     * See javadoc for {@link #_autoProcess(RequestAggregate, String, boolean) _autoProcess()} for
     * a complete description of the logic used for autoprocessing.
     *
     * @param empID
     * @param timeRange
     * @param runApproval
     * @param runDenial
     * @param apprDenyValResults
     * @param reqAgg
     * @param ruleNameToValResultsMap
     * @return
     * @throws Exception
     */
    protected int[] runAutoProcessForTimeRange(ID empID, TimeRange timeRange, boolean runApproval, boolean runDenial,
        Collection[] apprDenyValResults, RequestAggregate reqAgg, Map ruleNameToValResultsMap) throws Exception {

<span class="fc" id="L2088">        ValidationCache vc = reqAgg.getValidationCache();</span>

        // get orgID for employee during timeRange.
<span class="fc" id="L2091">        ID orgId = vc.getOrgIDForEmployeeDuringPeriod(empID, timeRange.getStartDate(), timeRange.getEndDate());</span>
<span class="fc" id="L2092">        String requestType = reqAgg.getRequestType();</span>
<span class="pc bpc" id="L2093" title="1 of 2 branches missed.">        ID activityID = reqAgg.isTimeOffRequest()?reqAgg.getRequestSubType():null;</span>
        
       
<span class="fc" id="L2096">        requestType = adjustRequestTypeForAutoProcess(reqAgg, requestType);</span>
        
<span class="fc bfc" id="L2098" title="All 2 branches covered.">        if (requestType.equals(Request.REQUESTTYPE_TIMEOFF_WITHDRAW)) {</span>
<span class="fc" id="L2099">        	activityID=null;</span>
        }

<span class="fc" id="L2102">		Collection&lt;String&gt; enabledValidatorsForOrg =</span>
<span class="pc bpc" id="L2103" title="1 of 2 branches missed.">				Request.REQUESTTYPE_FLEXTIME.equals(requestType) ? vc.getValidators() : vc.getValidators(orgId, requestType,</span>
						activityID);

<span class="fc" id="L2106">        AutoProcessingRuleChecker ckr = AutoProcessingRuleCheckerHelper.getChecker(</span>
            orgId, reqAgg,activityID , timeRange, enabledValidatorsForOrg,requestType);

<span class="fc" id="L2109">        int[] apprDenyResults = ckr.autoProcess(timeRange, ruleNameToValResultsMap,</span>
            runApproval, runDenial, apprDenyValResults,requestType );
<span class="pc bpc" id="L2111" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L2112">            m_cat.debug(&quot;autoproc approval result from set of autoProc rules evaluated for empID &quot; + empID + &quot; = &quot; + apprDenyResults[0]);</span>
<span class="fc" id="L2113">            m_cat.debug(&quot;autoproc deny result from set of autoProc rules evaluated for empID &quot; + empID + &quot; = &quot; + apprDenyResults[1]);</span>
        }
<span class="fc" id="L2115">        return apprDenyResults;</span>

    }

	protected String adjustRequestTypeForAutoProcess(RequestAggregate reqAgg, String requestType) {
<span class="fc" id="L2120">		String result = requestType;</span>
<span class="pc bpc" id="L2121" title="1 of 4 branches missed.">		if (reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).isEligibleForAcceptAndRejectWithdrawAction()) {</span>
<span class="fc" id="L2122">			result = Request.REQUESTTYPE_TIMEOFF_WITHDRAW;</span>
<span class="pc bpc" id="L2123" title="2 of 4 branches missed.">		} else if (reqAgg.isTimeOffRequest() &amp;&amp; ((TORequest) reqAgg).getFlexType() == TORequest.FLEXTYPE_FLEXWITHMAKEUP) {</span>
<span class="nc" id="L2124">			result = Request.REQUESTTYPE_FLEXTIME;</span>
<span class="pc bpc" id="L2125" title="1 of 2 branches missed.">		} else if (isShiftSwapWithdrawRequest(reqAgg)) {</span>
<span class="nc" id="L2126">			result = Request.REQUESTTYPE_SHIFTSWAP_WITHDRAW;</span>
		}
<span class="fc" id="L2128">		return result;</span>
	}

    protected abstract RequestAggregate _undoTentativeApprovalByID(ID reqID,
        String objectVersionNumber, String comment) throws Exception;

    /**
     * Switches the request status to Pending from Tentatively approved, after running
     * the hard validations.  If any hard validation fails, request is marked invalid.
     *
     * @throws if any validations fail.
     */
    //TESTME undoTentativeapprovalByID
    @Override
	public void undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment)
        throws  RmHardValidationException, RmException
    {
<span class="nc" id="L2145">        String _method_ = &quot;undoTentativeApprovalByID&quot;;</span>
<span class="nc" id="L2146">        methodStart(_method_, reqID, objectVersionNumber, comment);</span>

<span class="nc" id="L2148">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2149">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2151">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2153">            _undoTentativeApprovalByID(reqID, objectVersionNumber, comment);</span>
<span class="nc" id="L2154">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2161">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2162">			throw e;</span>
<span class="nc" id="L2163">		} catch (RmException e) {</span>
<span class="nc" id="L2164">			m_cat.error(e, e);</span>
<span class="nc" id="L2165">			handleException(e);</span>
<span class="nc" id="L2166">			throw e;</span>
<span class="nc" id="L2167">        } catch (Exception e) {</span>
<span class="nc" id="L2168">            handleException(e);</span>
<span class="nc" id="L2169">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2171" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2172">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2174">            methodFinish();</span>
<span class="nc" id="L2175">        }</span>
<span class="nc" id="L2176">    }</span>

    protected abstract void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optionalUndoData) throws Exception;

    /**
     * @param reqAgg
     * @param reqAggDAO
     */
    protected void _undoRequestAndSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optionalUndoData) throws Exception {

<span class="nc bnc" id="L2188" title="All 2 branches missed.">        boolean daoAllocNeeded = (reqAggDAO == null);</span>
        try {
<span class="nc bnc" id="L2190" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(ShiftBidRequest.DL_BASIC):reqAggDAO;</span>

<span class="nc" id="L2192">            _undoSchedule(reqAgg, reqAggDAO, optionalUndoData);</span>

            //delete request.
<span class="nc bnc" id="L2195" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(ShiftBidRequest.DL_BASIC):reqAggDAO;</span>
<span class="nc" id="L2196">            reqAggDAO.deleteRequest(reqAgg.getID());</span>
        } finally {
<span class="nc bnc" id="L2198" title="All 8 branches missed.">            if (daoAllocNeeded &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L2199">				reqAggDAO.cleanUp();</span>
			}
        }
<span class="nc" id="L2202">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate)
     */
    @Override
	public void undoRequestAndSchedule(RequestAggregate reqAgg, Object[] optionalUndoData) throws RmException, RmHardValidationException
    {
<span class="nc" id="L2210">        String _method_ = &quot;undoRequestAndSchedule&quot;;</span>
<span class="nc" id="L2211">        methodStart(_method_, reqAgg);</span>
<span class="nc" id="L2212">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2213">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2215">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2217">            _undoRequestAndSchedule(reqAgg, null, optionalUndoData);</span>
<span class="nc" id="L2218">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2225">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2226">			throw e;</span>
<span class="nc" id="L2227">		} catch (RmException e) {</span>
<span class="nc" id="L2228">			m_cat.error(e, e);</span>
<span class="nc" id="L2229">			handleException(e);</span>
<span class="nc" id="L2230">			throw e;</span>
<span class="nc" id="L2231">        } catch (Exception e) {</span>
<span class="nc" id="L2232">            handleException(e);</span>
<span class="nc" id="L2233">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2235" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2236">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2238">            methodFinish();</span>
<span class="nc" id="L2239">        }</span>
<span class="nc" id="L2240">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#undoRequestAndScheduleByID(com.bluepumpkin.common.datatypes.ID)
     */
    @Override
	public void undoRequestAndScheduleByID(ID reqID) throws RmException, RmHardValidationException
    {
<span class="nc" id="L2248">        String _method_ = &quot;undoRequestAndScheduleByID&quot;;</span>
<span class="nc" id="L2249">        methodStart(_method_, reqID);</span>

<span class="nc" id="L2251">        RequestAggregateDAO reqAggDAO = null;</span>
<span class="nc" id="L2252">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2253">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2255">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

            // get the request. bypass validations by using the DAO.
<span class="nc" id="L2258">            RequestAggregate reqAgg = _getRequestByID(reqID, false, true, false, getDetailLevelForValidation());</span>

<span class="nc" id="L2260">            reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L2261">            _undoRequestAndSchedule(reqAgg, reqAggDAO, null);</span>
<span class="nc" id="L2262">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2269">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2270">			throw e;</span>
<span class="nc" id="L2271">		} catch (RmException e) {</span>
<span class="nc" id="L2272">			m_cat.error(e, e);</span>
<span class="nc" id="L2273">			handleException(e);</span>
<span class="nc" id="L2274">			throw e;</span>
<span class="nc" id="L2275">        } catch (Exception e) {</span>
<span class="nc" id="L2276">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2278" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2279">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L2281" title="All 4 branches missed.">            if (reqAggDAO != null) {</span>
<span class="nc" id="L2282">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L2284">            methodFinish();</span>
<span class="nc" id="L2285">        }</span>
<span class="nc" id="L2286">    }</span>

    /**
     * Validate the given request using hard validations and optionally with soft validations.
     * If hard validation fails, then request marked as invalid.
     *
     * @param reqAgg Request to be validated.
     * @param runSoftValids Set to true to run soft validations.  False otherwise.
     * @return returns the argument after running
     * validations.  If invoked from the EJB container, argument
     * and returned request refer to the same object.  If invoked from the web container,
     * due to marshalling, argument and returned request are different.
     */
    @Override
	public RequestAggregate _validateRequest(RequestAggregate reqAgg, boolean runSoftValids, boolean runNetStaffingSoftVal) {
        // do hard validations.  return if hard validation errors found.  hard validations
        // will be run only for **certain** states.
        //For TO Requests that are waitlisted only validate the Waitlisted Choice
<span class="pc bpc" id="L2304" title="2 of 4 branches missed.">        if(reqAgg.isTimeOffRequest()&amp;&amp;reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_WAITLIST)){</span>
<span class="nc" id="L2305">           ((TORequest)reqAgg).setTOChoiceForValidation(((TORequest)reqAgg).getWaitlistTOChoice());</span>
        }

<span class="fc" id="L2308">        ValidationResult result = doHardValidations(reqAgg, RequestUtil.METHODTYPE_FINDER, null, true);</span>
        //Clear the Validation choice since all the choices should be soft validated
<span class="pc bpc" id="L2310" title="1 of 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="fc" id="L2311">            ((TORequest) reqAgg).setTOChoiceForValidation(null);</span>
        }
<span class="pc bpc" id="L2313" title="1 of 2 branches missed.">        if ( result != null ) {</span>
<span class="nc" id="L2314">			return reqAgg;</span>
		}

        // if hard validations were not run or were successful, try soft validations.  Again soft
        // validations will **only** be run if necessary.  As part of the softValidation preprocess,
        // the TO lengths are filled.
<span class="fc bfc" id="L2320" title="All 2 branches covered.">        if (runSoftValids) {</span>
<span class="fc" id="L2321">			doSoftValidations(reqAgg, RequestUtil.METHODTYPE_FINDER, null, runNetStaffingSoftVal);</span>
		}
        
<span class="fc" id="L2324">        return reqAgg;</span>
    }
   	/**
   	 * Only applicable for Time Off Requests so this method will be overridden in TORequestManagerEJB.It  is because in hard validation rules,
   	 * we skip some hard special rules while validating request if the requests have invalid choice due to these rules viola and valid choices.
   	 * We replaced them by similar soft validation rules. Therefore, after validating all requests. All requests which have at least 1 choice violated those rules and other choices are no valid
   	 * We shoudld mark this as invalid to have consistence. In summary
   	 * The request would not be marked invalid if other choices within the request are valid, keeping the request pending, unless all the choices within the request become invalid.
   	 * */
    protected void markRequestViolateSpecialRulesAsInValidIfNeeded(RequestAggregate reqAgg,
        	RequestAggregateDAO reqAggDAO) throws Exception {

<span class="nc" id="L2336">    }</span>

    /**
     * isTransitionValid for ProcessSingleRequest and Log.
     *
     * @param reqAgg
     * @param newState
     * @return
     * @throws
     */
    protected boolean isTransitionValidForPSRAndLog(RequestAggregate reqAgg, String newState)   {
        // transition from same state --&gt; same state is not necessary when processing a single request
        // as part of group processing.  same state --&gt; same state transition only happens when a request is edited
<span class="nc" id="L2349">        String oldState = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">        if (oldState.equals(newState)) {</span>
<span class="nc" id="L2351">            m_cat.debug(&quot;Process Single Request: Not processing transition from &quot; + oldState + &quot; to &quot; + newState + &quot; not necessary&quot;);</span>
<span class="nc" id="L2352">            return false;</span>
        }

<span class="nc" id="L2355">        StateTransValResult stateTransValResult = validStateTransition(reqAgg, newState);</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">        if (!stateTransValResult.isTransitionValid()) {</span>
            //Note: prior to this message in the log, a stack trace for an RMChangeStateException with this
            // same message will be be found.  This stack trace is logged by validStateTransition() during
            // the creation of the RMChangeStateException embedded in 'stateTransResult' and is not a cause for concern.
<span class="nc" id="L2360">            m_cat.debug(&quot;Process Single Request: Not processing request: &quot; + stateTransValResult.m_RmHardValidationException.getLocalizedMessage());</span>
<span class="nc" id="L2361">            return false;</span>
        }

<span class="nc" id="L2364">        return true;</span>
    }

    /**
     * GetRequestByID And Check For HardValidationErrors
     *
     * @param reqID
     * @param runSoftValids
     * @return null if hard validation fails.  the request otherwise.
     * @throws Exception
     */
    private RequestAggregate getRequestByIDAndCheckHVE(ID reqID, boolean runSoftValids) throws Exception {
        //ValidationMethodResult result = _validateRequest(reqMgr, req);
<span class="nc" id="L2377">        RequestAggregate reqAgg =</span>
<span class="nc" id="L2378">            _getRequestByID(reqID, false, true, runSoftValids, getDetailLevelForValidation());</span>

        // if hard validation errros, return null.
<span class="nc bnc" id="L2381" title="All 2 branches missed.">        return ( reqAgg.hardValidationFailed() == null )?reqAgg:null;</span>
    }

    /**
     * Called by CommonReqMgr.ProcessRequests() to process a single request during group processing.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#processSingleRequest(com.bluepumpkin.ejb.rm.requests.common.model.Request, java.lang.String)
     *
     */
    @Override
	public RequestAggregate processSingleRequest(Request req, String reqAction)
        throws RmException, RmHardValidationException {

<span class="nc" id="L2394">        String _method_ = &quot;processSingleRequest&quot;;</span>
<span class="nc" id="L2395">        methodStart(_method_, req, reqAction);</span>

<span class="nc" id="L2397">        ID reqID = req.getID();</span>
<span class="nc" id="L2398">        String objVersionNum = req.getObjectVersionNumber();</span>
<span class="nc" id="L2399">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2400">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2402">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2404">            RequestAggregate reqAgg = null;</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">            if (reqAction.equals(CommonRequestManager.GA_APPROVE_ALL_WITHOUT_VIOL)) {</span>
<span class="nc bnc" id="L2406" title="All 2 branches missed.">                if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, true)) == null ) {</span>
<span class="nc" id="L2407">					return null;</span>
				}

                // check if transition is valid.
<span class="nc bnc" id="L2411" title="All 2 branches missed.">                if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2412">					return reqAgg;</span>
				}

                //RequestAggregate reqAgg = result.m_reqAgg;
<span class="nc bnc" id="L2416" title="All 2 branches missed.">                if (reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2417">                    reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2418">                    _approveRequestWorkFlow(reqAgg, null,</span>
<span class="nc" id="L2419">                    	RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, true);</span>
                }
<span class="nc bnc" id="L2421" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_TENT_APPROVE_ALL_WITHOUT_VIOL)) {</span>
<span class="nc bnc" id="L2422" title="All 2 branches missed.">                if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, true)) == null ) {</span>
<span class="nc" id="L2423">					return null;</span>
				}

                // check if transition is valid.
<span class="nc bnc" id="L2427" title="All 2 branches missed.">                if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L2428">					return reqAgg;</span>
				}

                //RequestAggregate reqAgg = result.m_reqAgg;
<span class="nc bnc" id="L2432" title="All 2 branches missed.">                if (reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2433">                    reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2434">                    _approveRequestTentatively(reqAgg, null,</span>
<span class="nc" id="L2435">                    	RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), true);</span>
                }
<span class="nc bnc" id="L2437" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_DENY_ALL_WITH_VIOLATIONS)) {</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">                if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, true)) == null ) {</span>
<span class="nc" id="L2439">					return null;</span>
				}

                // check if transition is valid.
<span class="nc bnc" id="L2443" title="All 2 branches missed.">                if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_DENIED)) {</span>
<span class="nc" id="L2444">					return reqAgg;</span>
				}

                //RequestAggregate reqAgg = result.m_reqAgg;
<span class="nc bnc" id="L2448" title="All 2 branches missed.">                if (!reqAgg.getValidationResults(true).isEmpty()) {</span>
<span class="nc" id="L2449">                    reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2450">                    _denyRequestWorkflow(reqAgg,</span>
<span class="nc" id="L2451">						RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, false);</span>
                }
<span class="nc bnc" id="L2453" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_CONFIRM_ALL_TENT_APPROVALS)) {</span>
                // only applies to tentative requests.
<span class="nc bnc" id="L2455" title="All 2 branches missed.">                if (req.isTentative()) {</span>
<span class="nc bnc" id="L2456" title="All 2 branches missed.">                    if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2457">						return null;</span>
					}

                    // check if transition is valid.
<span class="nc bnc" id="L2461" title="All 2 branches missed.">                    if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2462">						return reqAgg;</span>
					}

<span class="nc" id="L2465">                    reqAgg.setObjectVersionNumber(objVersionNum);</span>
<span class="nc" id="L2466">                    _approveRequestWorkFlow(reqAgg, null,</span>
<span class="nc" id="L2467">						RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, true);</span>
                }
<span class="nc bnc" id="L2469" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_REMOVE_ALL_TENT_APPROVALS)) {</span>
                // only applies to tentative requests.
<span class="nc bnc" id="L2471" title="All 2 branches missed.">                if (req.isTentative()) {</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">                    if ( (reqAgg = getRequestByIDAndCheckHVE(reqID, false)) == null ) {</span>
<span class="nc" id="L2473">						return null;</span>
					}

                    // check if transition is valid.
<span class="nc bnc" id="L2477" title="All 2 branches missed.">                    if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_PENDING)) {</span>
<span class="nc" id="L2478">						return reqAgg;</span>
					}

<span class="nc" id="L2481">                    reqAgg = _undoTentativeApprovalByID(reqID, objVersionNum,</span>
<span class="nc" id="L2482">						RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION));</span>
                }
<span class="nc bnc" id="L2484" title="All 2 branches missed.">            } else if (reqAction.equals(CommonRequestManager.GA_APPROVE_TO_CHOICE_WITHOUT_VIOL)) {</span>
<span class="nc" id="L2485">            	long detailLevel = TORequest.DL_BASIC | TORequest.DL_TIMEOFF_CHOICES | TORequest.DL_TIMEOFF_CHOICES_LENGTH;</span>
<span class="nc" id="L2486">            	reqAgg = _getRequestByID(reqID, false, true, true,detailLevel );</span>
<span class="nc bnc" id="L2487" title="All 4 branches missed.">            	if (reqAgg== null ||reqAgg.hardValidationFailed() != null) {</span>
<span class="nc" id="L2488">            		return null;</span>
            	} 
            	//Only applies to TORequest
<span class="nc bnc" id="L2491" title="All 4 branches missed.">            	if	(!(reqAgg.isTimeOffRequest()|| reqAgg.isFlexTimeRequest())){</span>
<span class="nc" id="L2492">            		return reqAgg;</span>
            	}
            	  // check if transition is valid.
<span class="nc bnc" id="L2495" title="All 2 branches missed.">                if (!isTransitionValidForPSRAndLog(reqAgg, RequestAuditTrail.STATUS_APPROVED)) {</span>
<span class="nc" id="L2496">					return reqAgg;</span>
				}
            	//Approve requests which has any choice without violations
<span class="nc" id="L2499">            	_approveRequestChoiceWorkFlow(reqAgg, null,</span>
<span class="nc" id="L2500">                    	RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GROUP_ACTION), false, true);</span>
<span class="nc" id="L2501">            } else {</span>
                //invalid value for reqAction.
<span class="nc" id="L2503">                throw RequestUtil.createIllegalArgumentException(null, m_cat);</span>
            }

<span class="nc" id="L2506">            return reqAgg;</span>
<span class="nc" id="L2507">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L2514">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2515">			throw e;</span>
<span class="nc" id="L2516">		} catch (RmException e) {</span>
<span class="nc" id="L2517">			m_cat.error(e, e);</span>
<span class="nc" id="L2518">			handleException(e);</span>
<span class="nc" id="L2519">			throw e;</span>
<span class="nc" id="L2520">        } catch (Exception e) {</span>
<span class="nc" id="L2521">            handleException(e);</span>
<span class="nc" id="L2522">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L2524" title="All 30 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2525">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2527">            methodFinish();</span>
        }
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#filterReqAggUsingReqFilter(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
     */
//    public RequestAggregate filterReqAggUsingReqFilter(RequestAggregate reqAgg, RequestFilter reqFilter) {
//        // no filtering of given reqAgg using reqFilter is necessary.
//        return reqAgg;
//    }

    /**Just a pass through; Inheriting classes need to implement this method
     * Overridden in ShiftBidReqMgr &amp; TORequestManager.
     *
     * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#applyFilterAndSortCriteriaForRequests(java.util.List, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter, int, int)
     */
    @Override
	public Pair applyFilterAndSortCriteriaForReqIDs(ID mgrEmpID, List reqIDs, RequestFilter reqFilter,
    		int sortColumn, int sortDirection, boolean inclExpired, long detailLevel,
            boolean runSoftValids, boolean runNetStaffingSoftVal) throws RmException, RmHardValidationException {

<span class="nc" id="L2549">        String _method_ = &quot;applyFilterAndSortCriteriaForReqIDs&quot;;</span>
<span class="nc" id="L2550">        methodStart(_method_, new Object[] { mgrEmpID, reqIDs, reqFilter, new Integer(sortColumn),</span>
        	new Integer(sortDirection),new Boolean(inclExpired)} );

<span class="nc" id="L2553">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L2554">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L2556">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

	        // this method must not be called when the request type in the filter is 'all'
<span class="nc" id="L2559">            String filterReqType = (String) reqFilter.getValueForKey(RequestFilter.REQUEST_TYPE_KEY);</span>
<span class="nc bnc" id="L2560" title="All 2 branches missed.">            if (Request.REQUESTTYPE_ALL.equals(filterReqType)) {</span>
<span class="nc" id="L2561">	            throw new IllegalArgumentException();</span>
	        }
<span class="nc" id="L2563">	        Set reqEmpIDSet =null; //this set holds the actual Requests for the given request ids</span>
            //Actual implementations return this as non null
<span class="nc" id="L2565">            return new Pair(reqIDs, reqEmpIDSet) ;</span>
		} finally {
<span class="nc bnc" id="L2567" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L2568">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L2570">            methodFinish();</span>
		}
    }

	/**
	 * Overridden by SSReqMgr.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#addEmployeeIDsToSet(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.util.Set)
	 */
	@Override
	public Set addEmployeeIDsToSet(RequestAggregate request, Set reqEmpIds)  {
<span class="fc" id="L2581">		reqEmpIds.add(request.getEmployeeID());</span>

<span class="fc" id="L2583">		return reqEmpIds;</span>
	}

	/**
	 * Overridden in SSReqMgr.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#restrictEmployeesByFilter(java.util.Collection, com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter)
	 */
	@Override
	public Collection restrictEmployeesByFilter(Collection empIds, RequestFilter requestFilter)  {
		// ShiftBid requests do not need to further restrict employee ids
<span class="nc" id="L2594">		return empIds;</span>
	}

    /**
     * @return
     */
    protected abstract IRequestType getRequestManager() throws Exception;

    protected abstract ValidatorDescriptor[] getHardValidatorDescriptors();

    /**
     * Returns an array of soft validators which are mandatory.  Contrast this with optional
     * softvalidators (can be turned on or off from the UI).  For example see
     * {@link com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceHasZeroLength TimeOffChoiceHasZeroLength}
     * validation rule.
     *
     * @return
     */
    protected abstract ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory();

    /**
     * Performs hard validations for the given request based on the request type &lt;br&gt;
     *
     * Hard validations are always run unlike softvalidations (which can be suppressed by setting
     * runSoftValids=false parameter to the getXXXX() methods).&lt;br&gt;
     *
     * Hard validations will be done in the following scenarios:
     * &lt;li&gt; Request create: All hard validations done as all associated data is loaded, by the createRequest() method.
     * &lt;li&gt; Request update: All hard validations done as all associated data is loaded using RequestType.getDetailLevelForValidation()
     * This prevents Null pointer exceptions due to lack of data when hard validations are run.
     * &lt;li&gt; Request fetch: Hard validations are done selectively based on data avaialbility.  The data
     * loaded with the requestr is defined by the detailLevel flag passed to the getXXXX() method.
     * Only the validations for which data exists will be run.  For instnace,
     * if the shiftbid request detailLevel lacks DL_SHIFTBID_AUCTION, then the auction related hardvalidation
     * {@link com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.validation.AuctionIsValidHV AuctionIsValidHV}
     * will not be run.
     *
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * @param methodSubType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants.
     * see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param markInvalidIfHardValFails if true, then request will be marked invalid on hard validation error.
     * If false, then request not marked invalid due to  hardval error.
     * see {@link com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprovedNotZeroLengthHV TimeOffChoiceApprovedNotZeroLengthHV}
     * for an example of this scenario.
     * @return To check if any hard validations failed, use reqAgg.getHardValidationResults()
     */
    protected ValidationResult doHardValidations(RequestAggregate reqAgg, int methodType,
        String methodSubType, boolean markInvalidIfHardValFails) {
<span class="fc" id="L2644">    	return doHardValidations(reqAgg,methodType,methodSubType,markInvalidIfHardValFails, false);</span>
    }
    /**Similar to doHardValidations as below but have one more param skipSomeHardValidationRules
     * @param skipSomeHardRulesWhenUpdate - To support for approve any choice of TO request. 1 TO Request can have multi-choices. 
     * If one of them is invalid , it should not marked as invalid=&gt; the hard validation rule should not run in this case
     * Instead of that, some rules will be replaced by similar soft validation rules
     * */
    protected ValidationResult doHardValidations(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidIfHardValFails, boolean skipSomeHardValidationRules) {

            // commented: invalid requests are validated to provide the reason for being invalid).
<span class="fc bfc" id="L2655" title="All 2 branches covered.">            if (!reqAgg.isHardValidationNeeded(methodType) ) {</span>
<span class="fc" id="L2656">    			return null;</span>
    		}
<span class="fc" id="L2658">            RequestAggregateDAO reqAggDAO = null;</span>
<span class="fc" id="L2659">            String validatorName = &quot;No hard validators run yet&quot;;</span>
            try {
<span class="fc" id="L2661">                reqAgg.clearValidationResults(true); // clear any residual validation results</span>
                // if request hasn't expired, validate
<span class="fc" id="L2663">    			ValidationResult hardValResult = null;</span>
<span class="fc" id="L2664">                ValidatorDescriptor[] hardValDescArr = getHardValidatorDescriptors();</span>
<span class="pc bpc" id="L2665" title="2 of 4 branches missed.">                boolean isTimeOffRequestOnly = reqAgg.isTimeOffRequest() &amp;&amp; !reqAgg.isFlexTimeRequest();</span>
<span class="pc bpc" id="L2666" title="1 of 4 branches missed.">                for (int i = 0; i &lt; hardValDescArr.length &amp;&amp; hardValResult == null; i++) {</span>
                    // if hard validator does not apply, continue.
<span class="fc" id="L2668">                    ValidatorDescriptor hardValDesc = hardValDescArr[i];</span>
<span class="fc" id="L2669">                    boolean  checkIfVAlidatorapplies= checkIfValidatorApplies(reqAgg, hardValDesc, methodType, methodSubType);</span>
<span class="fc" id="L2670">                    validatorName = hardValDesc.getName();                   </span>
<span class="pc bpc" id="L2671" title="4 of 6 branches missed.">                    boolean isSkipRunOnThisRule = isTimeOffRequestOnly &amp;&amp; skipSomeHardValidationRules &amp;&amp; isSpecialHardRulesForTimeOff(validatorName);</span>
                    // check if the validator applies in the current context
<span class="pc bpc" id="L2673" title="1 of 4 branches missed.">                    if (!checkIfVAlidatorapplies||isSkipRunOnThisRule) {</span>
<span class="nc" id="L2674">    					continue;</span>
    				}

<span class="fc" id="L2677">                    hardValResult= ValidationUtil.doValidation(validatorName, reqAgg, s_validatorsMap);</span>
                    
                    // if validation succeeded
<span class="pc bpc" id="L2680" title="1 of 2 branches missed.">                    if(hardValResult==null){</span>
<span class="fc" id="L2681">                        hardValResult = reqAgg.hardValidationFailed();</span>
                    } 
                   
<span class="pc bpc" id="L2684" title="3 of 4 branches missed.">                    if (  hardValResult != null &amp;&amp; markInvalidIfHardValFails ) {</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">                    	if (hardValResult.getApprove()){</span>
                    		//mark the request as approved
<span class="nc" id="L2687">                    		reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="nc" id="L2688">                    		reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);</span>
<span class="nc" id="L2689">    			            String comment = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg.getValidationCache().getTimeZoneForOrg())</span>
<span class="nc" id="L2690">    			                    + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_APPROVED);</span>
<span class="nc" id="L2691">    			            reqAggDAO.updateRequest(reqAgg, comment, RequestUtil.getBPSuperUser());</span>
<span class="nc" id="L2692">                            break;//no need to do more validations</span>
                    	} else {
<span class="nc" id="L2694">                    		markRequestAsInvalid(reqAgg, hardValResult, reqAggDAO);	</span>
    					}
                    }
                }

<span class="fc" id="L2699">                return hardValResult; //will be null.</span>
<span class="nc" id="L2700">            } catch ( Exception e ) {</span>
                // log the fact that exception is caught but not propogated.
                //
                // Note: This mode of ignoring exceptions is usually done only during bulk fetching of requests
                // (ie. usually callers of this method do bulk fetching).
                //
                // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
                // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
<span class="nc" id="L2708">                m_cat.warn(&quot;*** Following exception was caught but not propogated ***: &quot; + e);</span>
<span class="nc" id="L2709">                return ValidationUtil.setHardValidationResult(reqAgg, e, validatorName);</span>
    			//return ValidationUtil.setHardValidationResult(reqAgg, RmEjbBundleKey.REQ_UNEXPECTED_ERROR, validatorName);
            } finally {
<span class="pc bpc" id="L2712" title="5 of 6 branches missed.">                if (reqAggDAO != null) {</span>
<span class="pc" id="L2713">    				reqAggDAO.cleanUp();</span>
    			}
            }
        }
    /** It is applicable for Time Off requests only
     *  It will mark all requests except Time Off Request as invalid.
     *  It should be override in TORequestManagerEJB.java to handle Time Off requests 
     *  since a Time Off Requests can have many choices  
	 * */
    protected boolean isSpecialHardRulesForTimeOff(String validatorName) throws Exception{
<span class="nc" id="L2723">    	boolean isWorkableTimeWithinScheduleTimeOff = validatorName.equals(WorkableTimeWithinScheduleTimeOffHV.CLASS_NAME);</span>
<span class="nc" id="L2724">		boolean isAgentGoodStanding = validatorName.equals(AgentGoodStandingValidationRuleHV.CLASS_NAME);</span>
<span class="nc" id="L2725">		boolean isBidChoicePeriod = validatorName.equals(TimeOffBidPeriodPerChoiceHV.CLASS_NAME);</span>
<span class="nc bnc" id="L2726" title="All 6 branches missed.">		return isWorkableTimeWithinScheduleTimeOff || isAgentGoodStanding || isBidChoicePeriod;</span>
    }
  
    private boolean checkIfValidatorApplies(RequestAggregate reqAgg, ValidatorDescriptor valDesc,
        int methodType, String methodSubType) {

        // check if hard validator's methodType matches specified methodType.
<span class="fc bfc" id="L2733" title="All 2 branches covered.">        if (!valDesc.isEnabledForMethodType(methodType, methodSubType)) {</span>
<span class="pc bpc" id="L2734" title="1 of 2 branches missed.">            if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L2735">                m_cat.debug(&quot;Skipping validation: methodType and methodSubType do not match: &quot; +  methodType + ',' +</span>
<span class="fc" id="L2736">                    methodSubType + ',' + valDesc.getName() + ',' + valDesc.getMethodType());</span>
            }

<span class="fc" id="L2739">            return false;</span>
        }

        // All requests must have DL_BASIC set.
        // If not set, specifying HardValidatorDescriptor.m_requiredDetailLevel = DL_BASIC with the
        // intention to run the hardValidator for all detailLevels will not work and the hard validator
        // will not be run for any request.
<span class="fc" id="L2746">        reqAgg.setDetailLevel(reqAgg.getDetailLevel() | RequestDetailLevel.DL_BASIC);</span>

        // for request fetches, run validator only if validator's required detail level is
        // supported by the fetched request.  This means, some hard validators may be skipped
        // if the request's detailLevel is not adequate enough.  Done for performance reasons.
<span class="fc bfc" id="L2751" title="All 2 branches covered.">        if (valDesc.isEnabledForDetailLevel(reqAgg.getDetailLevel())) {</span>
<span class="fc" id="L2752">            m_cat.debug(&quot;Skipping validation: detailLevel does not match: &quot; + valDesc.getName() +</span>
<span class="fc" id="L2753">                ',' + valDesc.getRequiredDetailLevel() + ',' + reqAgg.getDetailLevel());</span>

<span class="fc" id="L2755">            return false;</span>
        }


<span class="fc" id="L2759">        return true;</span>
    }

    protected void markRequestAsInvalid(RequestAggregate reqAgg, ValidationResult hardValResult,
    	RequestAggregateDAO reqAggDAO) throws Exception {

		// hard validation failed. Log reason for failure
<span class="nc" id="L2766">		String hardValLocalizedMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L2767">		    		reqAgg.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L2768">		m_cat.l7dDebug(RmEjbLogBundleKey.UNLOCALIZED_MESSAGE, new Object[] { hardValLocalizedMsg} );</span>
<span class="nc" id="L2769">		m_cat.debug(&quot;Marking request (ID = &quot; + reqAgg.getID() + &quot;) as invalid due to hard validation failure&quot;);</span>

		// Mark request as invalid in **db**, except for requests being created (ID == null) or invalid to begin with.
<span class="nc bnc" id="L2772" title="All 2 branches missed.">		boolean newRequest = (reqAgg.getID() == null);</span>
<span class="nc bnc" id="L2773" title="All 4 branches missed.">		if ( newRequest || reqAgg.isInvalid() ) {</span>
<span class="nc" id="L2774">			reqAgg.setRequestStatus(RequestAuditTrail.STATUS_INVALID);</span>
		} else {
			try {
<span class="nc" id="L2777">				reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>

				// don't need to worry about msg too long for audit trail anymore because
				// RequestAuditTrail has been enhanced to use LargeString table for long messages.

<span class="nc" id="L2782">				invalidateRequestAndFireNotification(reqAgg, hardValLocalizedMsg, reqAggDAO);</span>
<span class="nc" id="L2783">			} catch (Exception e) {</span>
				// log the fact that exception is caught but not propogated.
				//
				// Note: This mode of ignoring exceptions is usually done only during bulk fetching of requests
				// (ie. usually callers of this method do bulk fetching).
				//
				// we log this with priority 'error' since only unexpected exceptions are thrown by the validation
				// rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
<span class="nc" id="L2791">				m_cat.warn(&quot;*** Following exception was caught but not propogated ***: &quot; + e);</span>
<span class="nc" id="L2792">				String validatorName = &quot;No hard validtors run yet&quot;;</span>
<span class="nc" id="L2793">				ValidationUtil.setHardValidationResult(reqAgg, e, validatorName);</span>
				//return ValidationUtil.setHardValidationResult(reqAgg, RmEjbBundleKey.REQ_UNEXPECTED_ERROR, validatorName);
			} finally {
<span class="nc bnc" id="L2796" title="All 6 branches missed.">				if (reqAggDAO != null) {</span>
<span class="nc" id="L2797">					reqAggDAO.cleanUp();</span>
				}
			}
		}
<span class="nc" id="L2801">	}</span>
  
	/**
     * Wrapper around the hardValidation logic.  Throws an exception if hard validation fails
     *
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * @param methodSubType see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @throws RmHardValidationException
     * @throws Exception
     */
    protected void doHardValidationsRaiseException(RequestAggregate reqAgg, int methodType,
        String methodSubType, boolean markInvalidOnHardValFail) throws RmHardValidationException {
<span class="fc" id="L2815">        ValidationResult result = doHardValidations(reqAgg, methodType, methodSubType, markInvalidOnHardValFail);</span>
<span class="pc bpc" id="L2816" title="1 of 2 branches missed.">        if ( result != null ) {</span>
<span class="nc" id="L2817">            throw RequestUtil.createRmHardValidationException(result, m_cat);</span>
        }
<span class="fc" id="L2819">    }</span>
    protected void doHardValidationsRaiseException(RequestAggregate reqAgg, int methodType,
            String methodSubType, boolean markInvalidOnHardValFail,boolean skipSomeHardValidationRules) throws RmHardValidationException {
<span class="fc" id="L2822">            ValidationResult result = doHardValidations(reqAgg, methodType, methodSubType, markInvalidOnHardValFail,skipSomeHardValidationRules);</span>
<span class="pc bpc" id="L2823" title="1 of 2 branches missed.">            if ( result != null ) {</span>
<span class="nc" id="L2824">                throw RequestUtil.createRmHardValidationException(result, m_cat);</span>
            }
<span class="fc" id="L2826">    }</span>

    /**
     * @param reqAgg
     * @param methodType One of the METHODTYPE_XXXX constants: see {@link #METHODTYPE_CREATOR METHODTYPE_CREATOR} and similar constants
     * see {@link ValidatorDescriptor#isEnabledForMethodType(int, String) isEnabledForMethodType}
     * for details.
     * @param methodSubType one of the constants similar to {@link RequestAuditTrail#STATUS_APPROVED STATUS_APPROVED}
     */
    private final void doSoftValidations(RequestAggregate reqAgg, int methodType, String methodSubType, boolean runNetStaffingSoftVal) {

        /* XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
         * If the validation alert for a request shows &quot;No soft validators run yet&quot;, it means
         * that an exception was thrown even before the first validator was run.  Check the log
         * for exception stack trace.
         * XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
         */
<span class="fc" id="L2843">        String validatorName = null;</span>
        try {
            // if no soft validations are necessary, simply return.
<span class="fc bfc" id="L2846" title="All 2 branches covered.">            if ( !reqAgg.isSoftValidationNeeded()) {</span>
<span class="fc" id="L2847">                return;</span>
            }
<span class="pc bpc" id="L2849" title="1 of 2 branches missed.">            if( reqAgg.isTimeOffRequest() ){</span>
<span class="fc" id="L2850">            	boolean b = true;</span>
<span class="pc bpc" id="L2851" title="1 of 2 branches missed.">            	if(b){</span>
<span class="fc" id="L2852">            		boolean c = true;</span>
            	}
            }

            // get the mandatory soft validators to be run.
<span class="fc" id="L2857">            ValidatorDescriptor[] softValDescMandArr = getSoftValidatorDescriptorsMandatory();</span>
<span class="fc bfc" id="L2858" title="All 2 branches covered.">            for (int i = 0; i &lt; softValDescMandArr.length; i++) {</span>
<span class="fc" id="L2859">                ValidatorDescriptor softValDescMand = softValDescMandArr[i];</span>
                
<span class="fc" id="L2861">                boolean validatorApplied = checkIfValidatorApplies(reqAgg, softValDescMand, methodType, methodSubType);</span>
<span class="fc bfc" id="L2862" title="All 2 branches covered.">                if (!validatorApplied) {</span>
<span class="fc" id="L2863">                    continue;</span>
                }
      
<span class="fc" id="L2866">				validatorName = softValDescMand.getName();</span>
<span class="fc" id="L2867">                ValidationUtil.doValidation(validatorName, reqAgg, s_validatorsMap);</span>
                
            }

            // get the configured validators (in the suite using the UI)
           
<span class="fc" id="L2873">            Collection validators =  reqAgg.getValidationCache().getValidators();</span>
<span class="fc bfc" id="L2874" title="All 2 branches covered.">            for (Iterator it = validators.iterator(); it.hasNext();) {</span>
            	// Run the validations
<span class="fc" id="L2876">                validatorName = (String) it.next();</span>
<span class="pc bpc" id="L2877" title="1 of 2 branches missed.">                if (validatorName.contains(&quot;NetStaffingValidationRule&quot;)) {</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">                	if (runNetStaffingSoftVal) {</span>
<span class="nc" id="L2879">                		ValidationUtil.doValidation(validatorName, reqAgg, s_validatorsMap);</span>
                	}
                } else {
<span class="fc" id="L2882">                	ValidationUtil.doValidation(validatorName, reqAgg, s_validatorsMap);</span>
                }
            }
<span class="pc bpc" id="L2885" title="2 of 4 branches missed.">            if( reqAgg.isTimeOffRequest() &amp;&amp;!reqAgg.isFlexTimeRequest()){</span>
<span class="fc" id="L2886">            	RequestAggregateDAO reqAggDAO = getDAO(RequestDetailLevel.DL_BASIC);</span>
<span class="fc" id="L2887">            	markRequestViolateSpecialRulesAsInValidIfNeeded(reqAgg,reqAggDAO);</span>
            }
<span class="nc" id="L2889">        } catch ( Exception e ) {</span>
            // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
            // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
//        	change it to info since it was cluttering the log file
<span class="nc" id="L2893">			m_cat.info(&quot;Translating Exception to Validation result: &quot; + e.getLocalizedMessage());</span>

			//exception maybe thrown even before the first soft validator is run
<span class="nc bnc" id="L2896" title="All 2 branches missed.">            ValidationUtil.setSoftValidationResult(reqAgg, e,</span>
            	(validatorName != null)?validatorName:&quot;ExceptionCaughtBeforeSoftValStart&quot;);
            //ValidationUtil.setSoftValidationResult(reqAgg, RmEjbBundleKey.REQ_UNEXPECTED_ERROR, validatorName);
<span class="fc" id="L2899">        }</span>
<span class="fc" id="L2900">    }</span>

	/**
	 * This method checks whether the user has
	 * privilege to perform this operation.
	 *
	 * @param request  The request that is being acted on.
	 * @param user     The currently logged on user.
	 * @param newState The new state of the request.
	 * @return &lt;tt&gt;true&lt;/tt&gt; if the user has the required privileges.
	 */
	protected void checkUpdatePrivilege(User userBasic, RequestAggregate reqAgg, String newState)
	  throws Exception {
<span class="pc bpc" id="L2913" title="1 of 2 branches missed.">			if (!RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L2914">				return; //if running outside container, no privilege check done.</span>
			}

<span class="fc" id="L2917">			ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(reqAgg.getEmployeeID());</span>
<span class="fc" id="L2918">			String oldState = reqAgg.getRequestStatus();</span>

<span class="fc bfc" id="L2920" title="All 2 branches covered.">			boolean stateTrans = !oldState.equals(newState);</span>

<span class="pc bpc" id="L2922" title="1 of 4 branches missed.">			if (stateTrans &amp;&amp; RequestAuditTrail.APPROVE_DENY_STATES.contains(newState)) {</span>
<span class="nc" id="L2923">				checkApproveDenyTransPriv(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="nc" id="L2924">				return;</span>
			}

<span class="fc bfc" id="L2927" title="All 4 branches covered.">			if (stateTrans &amp;&amp; newState.equals(RequestAuditTrail.STATUS_ESCALATED)) {</span>
<span class="fc" id="L2928">				checkEscalateTransPriv(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="fc" id="L2929">				return;</span>
			}

<span class="fc" id="L2932">			checkModifyPrivilege(userBasic, reqAgg, oldState, newState, orgID);</span>
<span class="fc" id="L2933">			return;</span>
	}

	/**
	 * //////////////////////////////////////////////////////////////////////
	 * SSReqMgr overrides this method with its own version
	 * //////////////////////////////////////////////////////////////////////
	 *
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkModifyPrivilege(User userBasic, RequestAggregate reqAgg, String oldState,
		String newState, ID orgID) throws Exception {

<span class="fc" id="L2951">		String userName = userBasic.getUserName();</span>
		// Need privilege to modify request, check to see if
		// it's owned by the user or not
<span class="fc bfc" id="L2954" title="All 2 branches covered.">		if (userBasic.getEmployeeID().equals(reqAgg.getEmployeeID())) {</span>
<span class="fc" id="L2955">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(</span>
<span class="fc" id="L2956">					userName, Collections.singleton(orgID), getPrivIDModifyPersonalReqs());</span>
<span class="pc bpc" id="L2957" title="1 of 2 branches missed.">			if (privFailedOrgID == null) {</span>
<span class="fc" id="L2958">				return;</span>
			}

<span class="nc" id="L2961">			throw RequestUtil.createAndLogRmHardValidationException(</span>
					RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_MODIFICATION,
					RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_MODIFICATION,
<span class="nc" id="L2964">					new Object[]{userName, reqAgg.getID(), oldState, newState},</span>
					m_cat);
		} else {  // Request doesn't belong to user, need auth to modify employee request
<span class="fc" id="L2967">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName,</span>
<span class="fc" id="L2968">				Collections.singleton(orgID), getPrivIDModifyReqsForEmp());</span>
<span class="pc bpc" id="L2969" title="1 of 2 branches missed.">			if (privFailedOrgID == null) {</span>
<span class="fc" id="L2970">				return;</span>
			}

<span class="nc" id="L2973">			throw RequestUtil.createAndLogRmHardValidationException(</span>
					RmEjbBundleKey.REQ_MANAGER_CANT_CHANGE_TO_NEGOTIATE,
					RmEjbLogBundleKey.REQ_MANAGER_CANT_CHANGE_TO_NEGOTIATE,
<span class="nc" id="L2976">					new Object[]{userName, reqAgg.getID(), oldState, newState},</span>
					m_cat);
		}
	}

	/**
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkEscalateTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
		String newState, ID orgID) throws Exception {

<span class="fc" id="L2992">		String userName = userBasic.getUserName();</span>
<span class="pc bpc" id="L2993" title="1 of 2 branches missed.">		if ((oldState.equals(RequestAuditTrail.STATUS_DENIED))) {</span>
<span class="fc" id="L2994">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID), getPrivIDEscalate());</span>
<span class="pc bpc" id="L2995" title="1 of 2 branches missed.">			if (privFailedOrgID == null) {</span>
<span class="fc" id="L2996">				return;</span>
			}

<span class="nc" id="L2999">			throw RequestUtil.createAndLogRmHardValidationException(</span>
					RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATION,
					RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATION,
<span class="nc" id="L3002">					new Object[]{userName, oldState, newState, reqAgg.getID()},</span>
					m_cat);
		}
<span class="nc" id="L3005">	}</span>

//	/**
//	 * @param user
//	 * @param reqAgg
//	 * @param oldState
//	 * @param newState
//	 * @param orgID
//	 */
//	protected abstract void checkApproveDenyTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
//		String newState, ID orgID) throws Exception;

	/**
	 * //////////////////////////////////////////////////////////////////////////
	 * SSReqMgr overrides this method with its own version.
	 * //////////////////////////////////////////////////////////////////////////
	 *
	 * @param userBasic
	 * @param reqAgg
	 * @param oldState
	 * @param newState
	 * @param orgID
	 * @throws Exception
	 */
	protected void checkApproveDenyTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
		String newState, ID orgID) throws Exception {

<span class="nc" id="L3032">		String S_P = RequestAuditTrail.STATUS_PENDING;</span>
<span class="nc" id="L3033">		String S_T = RequestAuditTrail.STATUS_TENTATIVE;</span>
<span class="nc" id="L3034">		String S_E = RequestAuditTrail.STATUS_ESCALATED;</span>

<span class="nc bnc" id="L3036" title="All 2 branches missed.">		String userName = (userBasic!=null?userBasic.getUserName():&quot;System&quot;);</span>
//			if (RequestAuditTrail.APPROVE_DENY_STATES.contains(newState)) {
		// Need privilege to approve request, check whether it is pending or escalated
<span class="nc bnc" id="L3039" title="All 4 branches missed.">		if ((oldState.equals(S_P) || oldState.equals(S_T))) {</span>
<span class="nc" id="L3040">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID),</span>
<span class="nc" id="L3041">				getPrivIDApprovePending());</span>
<span class="nc bnc" id="L3042" title="All 2 branches missed.">			if (privFailedOrgID == null) {</span>
<span class="nc" id="L3043">				return;</span>
			}

<span class="nc" id="L3046">			throw RequestUtil.createAndLogRmHardValidationException(</span>
					RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_PENDING_APPROVE,
					RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_PENDING_APPROVE,
<span class="nc" id="L3049">					new Object[]{userName, reqAgg.getID(), oldState, newState},</span>
					m_cat);
<span class="nc bnc" id="L3051" title="All 2 branches missed.">		} else if ((oldState.equals(S_E))) { // if escalated</span>
<span class="nc" id="L3052">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(orgID),</span>
<span class="nc" id="L3053">				getPrivIDApproveEscalated());</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">			if (privFailedOrgID == null) {</span>
<span class="nc" id="L3055">				return;</span>
			}

<span class="nc" id="L3058">			throw RequestUtil.createAndLogRmHardValidationException(</span>
					RmEjbBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,
					RmEjbLogBundleKey.REQ_USER_NOT_AUTHORIZED_FOR_ESCALATED_APPROVE,
<span class="nc" id="L3061">					new Object[]{userName, reqAgg.getID(), oldState, newState},</span>
					m_cat);
		}
<span class="nc" id="L3064">	}</span>

protected abstract ID getPrivIDPurge();

//	/**
//	 * @param user
//	 * @param reqAgg
//	 * @param oldState
//	 * @param newState
//	 * @param orgID
//	 */
//	protected abstract void checkEscalateTransPriv(User userBasic, RequestAggregate reqAgg, String oldState,
//		String newState, ID orgID) throws Exception;

	/**
	 * @return
	 */
	protected abstract ID getPrivIDModifyReqsForEmp();

/**
 * @return
 */
protected abstract ID getPrivIDModifyPersonalReqs();

/**
 * @return
 */
protected abstract ID getPrivIDEscalate();

	/**
	 * @return
	 */
	protected abstract ID getPrivIDApproveEscalated();

	/**
	 * @return
	 */
	protected abstract ID getPrivIDApprovePending();

//	/**
//     * Returns &lt;tt&gt;true&lt;/tt&gt; if the newState is a valid state for the type of
//     * request. Expired, Invalid, Pending, and Withdrawn are valid for any
//     * type of request. The child's implementation for check for the other
//     * states.
//     *
//     * @param newState the new state that the request will be in after
//     * changing its state.
//     * @return &lt;tt&gt;true&lt;/tt&gt; if the newState is valid.
//     */
//    abstract protected void validNewState(String newState) throws ;

    /**
     * Represents a state transition validation result.
     *
     * Title:        Blue Pumpkin Software Request Management Module
     * Copyright:    Copyright (c) 2001-2004
     * Company:      Blue Pumpkin Software, inc
     * @author       Raja Rajendran
     */
    public static class StateTransValResult {
        // invalid transistion.
        protected static final int TRANSITION_RESULT_INVALID = 1;
        // valid transistion.
        protected static final int TRANSITION_RESULT_VALID = 2;
        // no transition necessary: 'from' status and to 'status' are the same.  For instance
        // 'approved' to 'approved'.  In some cases, this is an error. In some it is not.
        protected static final int TRANSITION_RESULT_NOTRANSITIONNECESSARY = 3;

        // one of the above constants.
        int m_transitionResult;
        // if transition is invalid, an exception with a localized message describing why.
        public RmHardValidationException m_RmHardValidationException;

<span class="fc" id="L3137">        StateTransValResult(int transitionResult, RmHardValidationException e) {</span>
<span class="fc" id="L3138">            m_transitionResult = transitionResult;</span>
<span class="fc" id="L3139">            m_RmHardValidationException = e;</span>
<span class="fc" id="L3140">        }</span>

        public boolean isTransitionValid() {
<span class="pc bpc" id="L3143" title="1 of 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_VALID;</span>
        }

        public boolean isTransitionInValid() {
<span class="nc bnc" id="L3147" title="All 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_INVALID;</span>
        }

        public boolean isTransitionNotNecessary() {
<span class="nc bnc" id="L3151" title="All 2 branches missed.">            return m_transitionResult == TRANSITION_RESULT_NOTRANSITIONNECESSARY;</span>
        }
    }

    /**
     * Determines whether the transition from oldState to newState is a
     * valid state transition. The class variable &lt;tt&gt;RequestAuditTrail.VALID_TRANSITION_MAP&lt;/tt&gt;
     * is a Map: oldState -&gt; array of new states. If the newState is in the
     * array, the transition is valid.
     *
     * @param oldState the existing requeststatus
     * @param newState the new requeststatus
     * @return returns a {@link StateTransValResult StateTransValResult} object.
     */
    protected StateTransValResult validStateTransition(RequestAggregate reqAgg, String newState) {
<span class="fc" id="L3166">        ID reqID = reqAgg.getID();</span>
<span class="fc" id="L3167">		String oldState = reqAgg.getRequestStatus();</span>

        // if oldstate == newstate is handled my the state transistion change map.  For some states
        // (the non terminal states), change to the same state is not allowed. For others it is.
//        if (oldState.equals(newState)) {
//            return new StateTransValResult(
//                StateTransValResult.TRANSITION_RESULT_NOTRANSITIONNECESSARY,
//                RequestUtil.createRmHardValidationException( RmEjbBundleKey.CANNOT_TRANSITION_STATUS,
//                    new Object[] { reqID, oldState, newState}, m_cat));
//        }

<span class="pc bpc" id="L3178" title="1 of 2 branches missed.">		if (reqAgg.checkForValidState()){</span>
	        // if oldstate is a final state, can't transition
<span class="pc bpc" id="L3180" title="1 of 2 branches missed.">	        if ( RequestAuditTrail.VALID_FINAL_STATES.contains(oldState) ) {</span>
	            //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
<span class="nc" id="L3182">	            return new StateTransValResult(</span>
	                StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3184">	                RequestUtil.createAndLogRmHardValidationException(</span>
											RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
											RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
	                    new Object[] {oldState, newState, reqID},
											m_cat));
	        }
		}

<span class="pc bpc" id="L3192" title="1 of 2 branches missed.">        if ( reqAgg.hasExpired() ) {</span>
            //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
<span class="nc" id="L3194">            return new StateTransValResult(</span>
                StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3196">                RequestUtil.createAndLogRmHardValidationException(</span>
										RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
										RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
                    new Object[] {&quot;expired&quot;, newState, reqID},
										m_cat));
        }

        // if no new states are defined.
<span class="fc" id="L3204">        String[] validNextStatesArr = (String[]) RequestAuditTrail.VALID_TRANSITION_MAP.get(oldState);</span>
//        if (validNextStatesArr == null) {
        //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
//            return new StateTransitionValidationResult(
//                StateTransitionValidationResult.TRANSITION_RESULT_INVALID,
//                RequestUtil.createRmHardValidationException( RmEjbBundleKey.CANNOT_TRANSITION_STATUS,
//                    new Object[] { reqID, oldState, newState}, null));
//        }

        //If Flex Time request, remove invalid states for flex time
<span class="pc bpc" id="L3214" title="1 of 2 branches missed.">        if(reqAgg.isFlexTimeRequest()) {</span>
<span class="nc" id="L3215">        	Collection&lt;String&gt; flexTimeNewStates = new ArrayList&lt;String&gt;(Arrays.asList(validNextStatesArr));</span>
        	//Keep only possible flex time states
<span class="nc" id="L3217">        	flexTimeNewStates.retainAll(RequestAuditTrail.FT_POSSIBLE_STATES);</span>
<span class="nc" id="L3218">        	validNextStatesArr = flexTimeNewStates.toArray(new String[flexTimeNewStates.size()]);</span>
        }

        //todo: use hash for efficiency
        // search if newState is in the list of possible transitions from old state
<span class="fc" id="L3223">        int i = 0;</span>
<span class="pc bpc" id="L3224" title="2 of 4 branches missed.">        for (i = 0; validNextStatesArr != null &amp;&amp; i &lt; validNextStatesArr.length; i++) {</span>
<span class="fc bfc" id="L3225" title="All 2 branches covered.">            if (validNextStatesArr[i].equals(newState)) {</span>
<span class="fc" id="L3226">				break;</span>
			}
        }
        // if transition is not valid.
<span class="pc bpc" id="L3230" title="1 of 2 branches missed.">        if (reqAgg.checkForValidState()){</span>
<span class="pc bpc" id="L3231" title="2 of 4 branches missed.">	        if (validNextStatesArr == null || i == validNextStatesArr.length) {</span>
	            //m_cat == null to prevent exception logging.  The caller will log the exception if necessary.
<span class="nc" id="L3233">	            return new StateTransValResult(</span>
	                StateTransValResult.TRANSITION_RESULT_INVALID,
<span class="nc" id="L3235">	                RequestUtil.createAndLogRmHardValidationException(</span>
											RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,
											RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS,
	                    new Object[] {oldState, newState, reqID},
											m_cat));
	        }
        }

<span class="fc" id="L3243">        return new StateTransValResult(StateTransValResult.TRANSITION_RESULT_VALID, null);</span>
    }

//    protected void checkStateTransitionAndUpdatePrivilege(RequestAggregate reqAgg, String newState)
//            throws Exception
//    {
//        checkStateTransitionAndUpdatePrivilege(reqAgg, newState, false);
//    }
//
    protected void checkStateTransitionAndUpdatePrivilege(RequestAggregate reqAgg, String newState, boolean suppressPrivilegeChecking)
            throws Exception
    {
        // validatate state transition.
<span class="fc" id="L3256">        StateTransValResult stateTransValResult = validStateTransition(reqAgg, newState);</span>
<span class="pc bpc" id="L3257" title="1 of 2 branches missed.">        if (!stateTransValResult.isTransitionValid()) {</span>
<span class="nc" id="L3258">            throw stateTransValResult.m_RmHardValidationException;</span>
        }

        // check if user has privilege.
<span class="fc bfc" id="L3262" title="All 2 branches covered.">        if (!suppressPrivilegeChecking) {</span>
<span class="fc" id="L3263">			checkUpdatePrivilege(RequestUtil.getLoginUserBasic(m_sessionContext), reqAgg, newState);</span>
		}
<span class="fc" id="L3265">    }</span>

    protected abstract RequestAggregateDAO getDAO(long detailLevel);

    /**
     * The type of Request this manager handles.  Returns one of
     * {@link Request#REQUESTTYPE_SHIFTBID REQUESTTYPE_SHIFTBID},
     * {@link Request#REQUESTTYPE_SHIFTSWAP REQUESTTYPE_SHIFTSWAP},
     * {@link Request#REQUESTTYPE_TIMEOFF REQUESTTYPE_TIMEOFF}
     *
     * @return
     */
    protected abstract String getRequestType();

    /**
     * @param reqAgg
     */
    protected void assignDefaultsForReqAgg(RequestAggregate reqAgg) {
<span class="pc bpc" id="L3283" title="1 of 2 branches missed.">        if ( StringUtil.isEmpty(reqAgg.getRequestStatus()) ) {</span>
<span class="fc" id="L3284">			reqAgg.setRequestStatus(RequestAuditTrail.STATUS_PENDING);</span>
		}
<span class="fc" id="L3286">    }</span>

    /**
     * @return
     */
    protected long getDetailLevelForValidation()  {
<span class="fc" id="L3292">        return RequestAggregate.getDetailLevelForValidation(getRequestType());</span>
    }

    /**
     * This method should not throw any exceptions to ensure that the current transaction
     * is not aborted because notification failed.
     *
     * @param reqStatusToCheck
     * @param reqAgg
     * @param statusChangeType
     */
    protected void fireReqStatusChangeNotificationIfNecessary(String reqStatusToCheck, RequestAggregate reqAgg) {
        try {
<span class="fc bfc" id="L3305" title="All 2 branches covered.">            if (reqAgg.getRequestStatus().equals(reqStatusToCheck)) {</span>
<span class="fc" id="L3306">                m_cat.debug(&quot;Firing request change notification: reqAgg.ID, reqType, newStatus == &quot; +</span>
<span class="fc" id="L3307">                    reqAgg.getID() + ',' + reqAgg.getRequestType() + ',' + reqStatusToCheck);</span>

<span class="fc" id="L3309">                JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, reqStatusToCheck));</span>
            }
<span class="nc" id="L3311">        } catch (Exception e) {</span>
<span class="nc" id="L3312">            m_cat.l7dError(RmEjbLogBundleKey.EXCEPTION_CAUGHT_NOT_PROPOGATED, e);</span>
<span class="fc" id="L3313">        }</span>
<span class="fc" id="L3314">    }</span>

    /**
     * Default implementation if the request is associated with a single employee.
     * Exception is a SS Request which is associated with two employees.
     *
     * @param requestId
     * @param reqAggDAO
     * @return
     * @throws BbmFinderException
     * @throws BbmObjectNotFoundException
     */
    protected List getCurrentOrgIDsForReqID(ID requestId, RequestAggregateDAO reqAggDAO) throws
        BbmFinderException, BbmObjectNotFoundException {

<span class="nc" id="L3329">        RequestAggregateDAO localReqAggDAO = null;</span>
        try  {
<span class="nc" id="L3331">            long detailLevel = RequestAggregate.DL_BASIC;</span>
<span class="nc bnc" id="L3332" title="All 2 branches missed.">            localReqAggDAO = (reqAggDAO == null)?getDAO(detailLevel):reqAggDAO;</span>
<span class="nc" id="L3333">            Request req = localReqAggDAO.getRequestByID(requestId, detailLevel).getAggregatedRequest();</span>
            //TODO: move this out of TOCalc
<span class="nc" id="L3335">            ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(req.getEmployeeID());</span>

<span class="nc" id="L3337">            return Collections.singletonList(orgID);</span>
        } finally  {
<span class="nc bnc" id="L3339" title="All 4 branches missed.">            if (localReqAggDAO != null) {</span>
<span class="nc" id="L3340">				localReqAggDAO.cleanUp();</span>
			}
        }
    }

    /**
     * @param reqAgg
     * @param comment
     * @param reqAggDAO
     * @throws Exception
     */
    protected void invalidateRequestAndFireNotification(RequestAggregate reqAgg, String comment,
                                                        RequestAggregateDAO reqAggDAO) throws Exception {
<span class="nc" id="L3353">	    reqAgg.setRequestStatus(RequestAuditTrail.STATUS_INVALID);</span>
<span class="nc" id="L3354">	    reqAggDAO.updateRequest(reqAgg, comment, RequestUtil.getBPSuperUser());</span>
<span class="nc" id="L3355">	    invalidateRequestPostProcess(reqAggDAO.getDMO(), reqAgg, comment);</span>
<span class="nc" id="L3356">    }</span>

	protected  void invalidateRequestPostProcess(Jdmo jdmo, RequestAggregate reqAgg, String comment)throws BbmUpdateException{
<span class="nc" id="L3359">		fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_INVALID, reqAgg);</span>
<span class="nc" id="L3360">	}</span>

    /**
     * @param sortDir
     * @return
     */
    public String invertSortDir(String sortDir) {
<span class="nc bnc" id="L3367" title="All 6 branches missed.">        assert RequestUtil.SORTDIR_ASC.equalsIgnoreCase(sortDir) || RequestUtil.SORTDIR_DESC.equalsIgnoreCase(sortDir):</span>
            &quot;sortDir != ASC or DESC&quot;;

<span class="nc bnc" id="L3370" title="All 2 branches missed.">        return sortDir.equalsIgnoreCase(RequestUtil.SORTDIR_ASC)?RequestUtil.SORTDIR_DESC:RequestUtil.SORTDIR_ASC;</span>
    }

	@Override
	public boolean isRequestEligibleForWaitlist(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3375">		return false;</span>
	}
    //All the Request Choices are auto processed only for Time Off Requests
    public boolean isProcessAllTimeRangePairs(RequestAggregate reqAgg){
<span class="fc" id="L3379">        boolean returnVal=false;</span>
<span class="pc bpc" id="L3380" title="1 of 2 branches missed.">        if(reqAgg.isTimeOffRequest()){</span>
<span class="pc bpc" id="L3381" title="1 of 2 branches missed.">            if(reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_PENDING)){</span>
<span class="fc" id="L3382">                returnVal= true;</span>
            }
        }
<span class="fc" id="L3385">         return returnVal;</span>
    }


    @Override
	public boolean _autoProcessWithdraw(RequestAggregate reqAgg, String comment, boolean loadedFromDB)
            throws BbmUpdateException, RmHardValidationException {
<span class="fc" id="L3392">        String _method_ = &quot;_autoProcessWithdraw&quot;;</span>
<span class="fc" id="L3393">        methodStart(_method_, reqAgg, comment);</span>
        // AutoProcessing of Withdraw is currently done for Approved TO requests only.
<span class="fc" id="L3395">        TORequest toRequest = null;</span>
<span class="pc bpc" id="L3396" title="1 of 2 branches missed.">        if (reqAgg.isTimeOffRequest()) {</span>
<span class="fc" id="L3397">            toRequest = (TORequest) reqAgg;</span>
        }
        //Only TO Requests that can be Auto Rejected and Accepted will be processed.
<span class="pc bpc" id="L3400" title="2 of 4 branches missed.">        if (toRequest == null || !toRequest.isEligibleForAcceptAndRejectWithdrawAction()) {</span>
<span class="nc" id="L3401">            return false;</span>
        }
<span class="pc bpc" id="L3403" title="1 of 2 branches missed.">        comment = (comment == null) ? &quot;&quot; : comment;</span>
<span class="fc" id="L3404">        String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L3405">        boolean cacheEnabled = false;</span>
        try {
<span class="fc" id="L3407">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="fc" id="L3408">            ValidationCache vc = reqAgg.getValidationCache();</span>
<span class="fc" id="L3409">            Collection[] apprDenyValResults1 = new Collection[3];</span>
<span class="fc" id="L3410">            Map ruleNameToValResultsMap = new HashMap(19);</span>
<span class="fc" id="L3411">            TimeRange timeRange = new TimeRange(toRequest.getApprovedChoice().getStartDate(),</span>
<span class="fc" id="L3412">                                                toRequest.getApprovedChoice().getEndDate());</span>
<span class="fc" id="L3413">            int[] apprDenyResult1 = runAutoProcessForTimeRange(toRequest.getEmployeeID(), timeRange,</span>
                    true, true, apprDenyValResults1, reqAgg, ruleNameToValResultsMap);
            // If both approve and deny are set to true, the results are ambiguous,
            // and no auto approval or auto denial should be done in this case.
<span class="pc bpc" id="L3417" title="3 of 4 branches missed.">            if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS &amp;&amp;</span>
                    apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {
<span class="nc" id="L3419">                m_cat.l7dInfo(RmEjbLogBundleKey.APPROVE_DENY_AMBIGUOUS, new Object[]{reqAgg.getID()});</span>
<span class="nc" id="L3420">                return false;</span>
            }
<span class="fc" id="L3422">            StringBuffer commentBuf = new StringBuffer(comment);</span>
            // approve the request
<span class="pc bpc" id="L3424" title="1 of 2 branches missed.">            if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
                // Setting status to 'approved' will trigger an exception (during status transition validation)
                // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
                // when  _approveRequest() is called below.
                //reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);
<span class="nc" id="L3429">                commentBuf.append(RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.GEN_END_OF_SENTENCE_DELIM) +</span>
<span class="nc" id="L3430">                        RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_ACCEPTED));</span>
<span class="nc" id="L3431">                _acceptWithdrawOfApprovedRequestWorkFlow(reqAgg, null, commentBuf.toString(), true, loadedFromDB);</span>
<span class="nc" id="L3432">                return true;</span>
<span class="pc bpc" id="L3433" title="1 of 2 branches missed.">            } else if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {</span>
                // Setting status to 'denied' will trigger an exception (during status transition validation)
                // with the message &quot;cannot change status from 'denied' to 'denied'&quot;,
                // when  _denyRequest() is called below.
                //reqAgg.setRequestStatus(RequestAuditTrail.STATUS_DENIED);
<span class="nc" id="L3438">                commentBuf.append(&quot;\n &quot; + RequestUtil.getLocalizedMsgInAppDefLocale(RmEjbBundleKey.AUTOPROCESS_REJECTED));</span>
<span class="nc" id="L3439">                ValidationResult valResult = (ValidationResult) apprDenyValResults1[ARRAY_INDEX_FOR_AUTO_DENY].iterator().next();</span>
<span class="nc" id="L3440">                commentBuf.append(&quot;\n &quot; + valResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), vc.getTimeZoneForOrg()));</span>
<span class="nc" id="L3441">                _rejectWithdrawOfApprovedRequestWorkFlow(reqAgg, commentBuf.toString(), true, loadedFromDB);</span>
<span class="nc" id="L3442">                return true;</span>
            } else {
<span class="fc" id="L3444">                return false; //keep status pending if no decision can be made and exit the loop</span>
            }
<span class="nc" id="L3446">        } catch (RmHardValidationException e) {</span>
<span class="nc" id="L3447">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3448">            throw e;</span>
<span class="nc" id="L3449">        } catch (BbmUpdateException e) {</span>
<span class="nc" id="L3450">            m_cat.error(e, e);</span>
<span class="nc" id="L3451">            handleException(e);</span>
<span class="nc" id="L3452">            throw e;</span>
<span class="nc" id="L3453">        } catch (Exception e) {</span>
<span class="nc" id="L3454">            handleException(e);</span>
<span class="nc" id="L3455">            throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="pc bpc" id="L3457" title="9 of 10 branches missed.">            if (cacheEnabled) {</span>
<span class="pc" id="L3458">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L3460">            methodFinish();</span>
        }
    }

    /** applies to Withdrawal of approved Requests
     *
     * @param reqAgg
     *
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected void _acceptWithdrawOfApprovedRequestWorkFlow(RequestAggregate reqAgg, ID choiceID, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L3475" title="All 2 branches missed.">        if(_acceptWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivilegeChecking, loadedFromDB)){</span>
            //fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WITHDRAWN, reqAgg);
        }
<span class="nc" id="L3478">    }</span>

    /**applies to Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3489">        return false;</span>
    }
    protected void _rejectWithdrawOfApprovedRequestWorkFlow(RequestAggregate reqAgg, String comment,
        boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc bnc" id="L3493" title="All 2 branches missed.">        if(_rejectWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivilegeChecking, loadedFromDB)){</span>
            //fireReqStatusChangeNotificationIfNecessary(RequestAuditTrail.STATUS_WITHDRAW_REJECT, reqAgg);
        }
<span class="nc" id="L3496">    }</span>

    /**applies to rejecting Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3507">        return false;</span>
    }

    @Override
	public boolean acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws RmHardValidationException, RmException {
<span class="fc" id="L3512">		String _method_ = &quot;acceptWithdrawOfApprovedRequest&quot;;</span>
<span class="fc" id="L3513">		methodStart(_method_, reqAgg, comment);</span>
<span class="fc" id="L3514">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L3515">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L3517">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="pc bpc" id="L3518" title="1 of 2 branches missed.">			if (isEligibleForAcceptWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="fc" id="L3519">				return _acceptWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3521">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3522">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3523">			throw e;</span>
<span class="nc" id="L3524">		} catch (RmException e) {</span>
<span class="nc" id="L3525">			m_cat.error(e, e);</span>
<span class="nc" id="L3526">			handleException(e);</span>
<span class="nc" id="L3527">			throw e;</span>
<span class="nc" id="L3528">		} catch (Exception e) {</span>
<span class="nc" id="L3529">			handleException(e);</span>
<span class="nc" id="L3530">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L3532" title="5 of 6 branches missed.">			if (cacheEnabled) {</span>
<span class="pc" id="L3533">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L3535">			methodFinish();</span>
<span class="nc" id="L3536">		}</span>
<span class="nc" id="L3537">		return false;</span>
	}
    //Check if request is eligible for accepting the withdraw  overridden in TORequestManagerEJB
    protected boolean isEligibleForAcceptWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3541">        return false;</span>
    }

    //Check if request is eligible for rejecting the withdraw, overridden in TORequestManagerEJB
    protected boolean isEligibleForRejectWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3546">        return false;</span>
    }
    @Override
	public boolean rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws RmHardValidationException, RmException {
<span class="nc" id="L3550">		String _method_ = &quot;rejectWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L3551">		methodStart(_method_, reqAgg, comment);</span>
<span class="nc" id="L3552">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L3553">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L3555">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">			if (isEligibleForRejectWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="nc" id="L3557">				return _rejectWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3559">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3560">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3561">			throw e;</span>
<span class="nc" id="L3562">		} catch (RmException e) {</span>
<span class="nc" id="L3563">			m_cat.error(e, e);</span>
<span class="nc" id="L3564">			handleException(e);</span>
<span class="nc" id="L3565">			throw e;</span>
<span class="nc" id="L3566">		} catch (Exception e) {</span>
<span class="nc" id="L3567">			handleException(e);</span>
<span class="nc" id="L3568">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L3570" title="All 6 branches missed.">			if (cacheEnabled) {</span>
<span class="nc" id="L3571">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L3573">			methodFinish();</span>
<span class="nc" id="L3574">		}</span>
<span class="nc" id="L3575">		return false;</span>
	}
   @Override
public boolean requestWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws BbmUpdateException{
<span class="nc" id="L3579">       return false;</span>
   }
    //Check if request is eligible for Cancelling the withdraw, overridden in TORequestManagerEJB
    protected boolean isEligibleForCancelWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc" id="L3583">        return false;</span>
    }
   @Override
public boolean cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment) throws RmHardValidationException, RmException{
<span class="fc" id="L3587">      String _method_ = &quot;cancelWithdrawOfApprovedRequest&quot;;</span>
<span class="fc" id="L3588">		methodStart(_method_, reqAgg, comment);</span>
<span class="fc" id="L3589">		String setterID = m_className + '.' + _method_;</span>
<span class="fc" id="L3590">		boolean cacheEnabled = false;</span>
		try {
<span class="fc" id="L3592">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="pc bpc" id="L3593" title="1 of 2 branches missed.">			if (isEligibleForCancelWithdrawOfApprovedRequest(reqAgg)) {</span>
<span class="fc" id="L3594">				return _cancelWithdrawOfApprovedRequest(reqAgg, comment, false, false);</span>
			}
<span class="nc" id="L3596">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L3597">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L3598">			throw e;</span>
<span class="nc" id="L3599">		} catch (RmException e) {</span>
<span class="nc" id="L3600">			m_cat.error(e, e);</span>
<span class="nc" id="L3601">			handleException(e);</span>
<span class="nc" id="L3602">			throw e;</span>
<span class="nc" id="L3603">		} catch (Exception e) {</span>
<span class="nc" id="L3604">			handleException(e);</span>
<span class="nc" id="L3605">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc bpc" id="L3607" title="5 of 6 branches missed.">			if (cacheEnabled) {</span>
<span class="pc" id="L3608">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="pc" id="L3610">			methodFinish();</span>
<span class="nc" id="L3611">		}</span>
<span class="nc" id="L3612">		return false;</span>
   }
    /**applies to Cancelling Withdrawal of approved Requests
     * @param reqAgg
     * @param comment
     * @param suppressPrivilegeChecking
     * @param loadedFromDB
     * @throws Exception
     */
    protected  boolean _cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
                                             boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L3623">        return false;</span>
    }

    /*
    returns
    0= Pending
    1= Pending
    */
    public String getDecisionBasedOnAutProcessRuleEngineResult(RequestAggregate reqAgg, int[] apprDenyResult1, Collection[] apprDenyValResults1, boolean checkForWaitlist) throws BbmException {
<span class="fc" id="L3632">        String requestStatus = RequestAuditTrail.STATUS_PENDING;</span>
        //ambiguous results Check
        // for time off requests ignore the ambiguous results (done for the Waitlist feature)
<span class="pc bpc" id="L3635" title="1 of 2 branches missed.">        if (!ignoreAmbiguousAutoProcessResults(reqAgg)) {</span>
            // If both approve and deny are set to true, the results are ambiguous,
            // and no auto approval or auto denial should be done in this case.
<span class="pc bpc" id="L3638" title="1 of 4 branches missed.">            if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS &amp;&amp;</span>
                    apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {
<span class="nc" id="L3640">                m_cat.l7dInfo(RmEjbLogBundleKey.APPROVE_DENY_AMBIGUOUS, new Object[]{reqAgg.getID()});</span>
<span class="nc" id="L3641">                return requestStatus;</span>
            }
        }
<span class="fc bfc" id="L3644" title="All 2 branches covered.">        if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_APPROVE] == AutoProcessingRuleChecker.AUTOPROC_APPRCLAUSE_NO_VIOLATIONS) {</span>
            // Setting status to 'approved' will trigger an exception (during status transition validation)
            // with the message &quot;cannot change status from 'approved' to 'approved'&quot;,
            // when  _approveRequest() is called below.
            //reqAgg.setRequestStatus(RequestAuditTrail.STATUS_APPROVED);
<span class="fc" id="L3649">            return RequestAuditTrail.STATUS_APPROVED;</span>
          // will not check for Waitlist criteria if the Waitlist preferences are not set.
<span class="pc bpc" id="L3651" title="1 of 4 branches missed.">        } else if (checkForWaitlist&amp;&amp;canRequestBeWaitlistedBasedOnValidations(apprDenyResult1, apprDenyValResults1)) {</span>
<span class="nc" id="L3652">            return RequestAuditTrail.STATUS_WAITLIST; //this returns only if request can be waitlisted ; does not check for user preferences.</span>
<span class="fc bfc" id="L3653" title="All 2 branches covered.">        } else if (apprDenyResult1[ARRAY_INDEX_FOR_AUTO_DENY] == AutoProcessingRuleChecker.AUTOPROC_DENYCLAUSE_VIOLATIONS_FOUND) {</span>
<span class="fc" id="L3654">            return RequestAuditTrail.STATUS_DENIED;</span>
        } else {
<span class="fc" id="L3656">            return requestStatus;</span>
        }
    }
   	public TOHoursPerDayManager getTOHoursPerDayManager() throws BbmCreateException {
<span class="fc" id="L3660">        return RmManagerFactory.getInstance(true).getTOHoursPerDayManager(null, null);</span>
    }

	public TimeOffIntervalAllocationManager getTimeOffIntervalAllocationManager() throws BbmCreateException {
<span class="fc" id="L3664">        return RmManagerFactory.getInstance(true).getTimeOffIntervalAllocationManager(null, null);</span>
    }

	public TimeOffBiddingManager getTimeOffBiddingManager() throws BbmCreateException {
<span class="nc" id="L3668">        return RmManagerFactory.getInstance(true).getTimeOffBiddingManager();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>