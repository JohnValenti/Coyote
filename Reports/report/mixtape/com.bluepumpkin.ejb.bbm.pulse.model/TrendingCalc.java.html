<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TrendingCalc.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.pulse.model</a> &gt; <span class="el_source">TrendingCalc.java</span></div><h1>TrendingCalc.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.pulse.model;

import java.util.Collection;
import java.util.Date;
import java.util.Iterator;

import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;

/**
 * Trending Calculation engine
 *
 */
<span class="nc" id="L17">public class TrendingCalc {</span>
	public static final short SCALE_FACTOR = 2;
	/**
	 * Calculate Trending
	 * @param actualCube
	 * @param forecastCube
	 * @param config
	 * @param traceType
     * @param now The current time is used to split historical window and future window.
	 * @param endDate, if in TrendingConfig the application window is &quot;end of day&quot;, or &quot;end of sp week&quot;, UI just pass the exact Date
	 * @param mergedClosedPeriod, UI should pass back Closed Period for the Cube:
	 *			Campaign cpg = m_CampaignManager.getCampaignByID(campaignID);
	 *			Collection cpgHOOCol = m_CampaignManager.getCampaignHOOAssignments(campaignID, start, end);
	 *			CampaignHOOPeriod cpgPeriod = new CampaignHOOPeriod(start, end, campaignID, cpg.getTimeZone(), cpgHOOCol);
	 *			mergedClosedPeriod = cpgPeriod.getClosePeriods(start, end);
	 * @return
	 */
	public static TraceCube calTrend(TraceCube actualCube, TraceCube forecastCube, TrendingConfig config,
            short traceType, Date now, Date endDate, Collection mergedClosedPeriod) {
		// make a copy of forecast object and apply trend on top of it
<span class="nc" id="L37">		TraceCube trendCube = (TraceCube)forecastCube.clone();</span>

        // historical window size
<span class="nc" id="L40">		int histPoint = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), now)-1;</span>
<span class="nc" id="L41">		Date applyTo = endDate;</span>

		// if end window is not set or goes beyond cube's end date, allign it back
<span class="nc bnc" id="L44" title="All 4 branches missed.">		if (applyTo == null || applyTo.after(actualCube.getRawEndDate()))</span>
<span class="nc" id="L45">			applyTo = actualCube.getRawEndDate();</span>
		//Bug 91018 :Fix for the AHT trending issue
		// now calculate the deviation average in historical window first
		// figure out what's the other trace types needed for aggregation purpose
<span class="nc" id="L49">		boolean[] excPoints = new boolean[histPoint + 1];</span>
<span class="nc" id="L50">		short[] aggTypes = TraceUtil.   getAggTraceType(actualCube, forecastCube, excPoints.length, traceType);</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">		for (int i = 0; i &lt; excPoints.length; i++) {</span>
<span class="nc bnc" id="L52" title="All 4 branches missed.">			if (actualCube.getTraceValueD(traceType, i) &lt; 0 || forecastCube.getTraceValueD(traceType, i) &lt; 0) {</span>
<span class="nc" id="L53">				excPoints[i] = true;</span>
<span class="nc bnc" id="L54" title="All 2 branches missed.">			} else if (aggTypes != null) {</span>
				// Special Handling for AHT since AHT needs Connects for outbound and CV for rest of the media.
				// We also need Cv &amp; AHT combination for COMB queues
<span class="nc bnc" id="L57" title="All 2 branches missed.">				if (traceType == Trace.AHT) {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">					if (aggTypes.length == 1) {</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">						if (actualCube.getTraceValueD(aggTypes[0], i) &lt; 0 || forecastCube.getTraceValueD(aggTypes[0], i) &lt; 0) {</span>
<span class="nc" id="L60">							excPoints[i] = true;</span>
						}
					} else {
<span class="nc bnc" id="L63" title="All 4 branches missed.">						if ((actualCube.getTraceValueD(Trace.CV_VH, i) &lt; 0 || forecastCube.getTraceValueD(Trace.CV_VH, i) &lt; 0)</span>
<span class="nc bnc" id="L64" title="All 4 branches missed.">								&amp;&amp; (actualCube.getTraceValueD(Trace.CONNECTS, i) &lt; 0 || forecastCube.getTraceValueD(Trace.CONNECTS, i) &lt; 0)) {</span>
<span class="nc" id="L65">							excPoints[i] = true;</span>
						}
					}
				} else {
<span class="nc bnc" id="L69" title="All 2 branches missed.">					for (int j = 0; j &lt; aggTypes.length; j++) {</span>
						// continue check each additional aggregation type value
<span class="nc bnc" id="L71" title="All 4 branches missed.">						if (actualCube.getTraceValueD(aggTypes[j], i) &lt; 0 || forecastCube.getTraceValueD(aggTypes[j], i) &lt; 0) {</span>
<span class="nc" id="L72">							excPoints[i] = true;</span>
						}
					}
				}
			}
		}

		//take care of exclusion to start
<span class="nc" id="L80">		int s = 0;</span>
<span class="nc" id="L81">		int e = 0;</span>
<span class="nc" id="L82">		Date[] exStart = config.getExclusionToStart();</span>
<span class="nc bnc" id="L83" title="All 4 branches missed.">		if ((exStart[0] != null) &amp;&amp; (exStart[1] != null)) {</span>
<span class="nc" id="L84">			s = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), exStart[0]);</span>
<span class="nc" id="L85">			e = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), exStart[1]);</span>
<span class="nc bnc" id="L86" title="All 4 branches missed.">			for (int j=s; j&lt;=e &amp;&amp; j&lt;excPoints.length; j++) {</span>
<span class="nc" id="L87">				excPoints[j] = true;</span>
			}
		}

		// continue to consider exclusion time ranges
<span class="nc" id="L92">		Date[][] exWins = config.getExclusionWindow();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (exWins != null) {</span>
			// now remove points are not valid
<span class="nc bnc" id="L95" title="All 2 branches missed.">			for (int i=0; i&lt;exWins.length; i++) {</span>
<span class="nc" id="L96">				Date[] exWin = exWins[i];</span>
<span class="nc" id="L97">				s = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), exWin[0]);</span>
<span class="nc" id="L98">				e = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), exWin[1]);</span>
<span class="nc bnc" id="L99" title="All 4 branches missed.">				for (int j=s; j&lt;=e &amp;&amp; j&lt;excPoints.length; j++) {</span>
<span class="nc" id="L100">					excPoints[j] = true;</span>
				}
			}
		}

		// apply HOO fix
<span class="nc bnc" id="L106" title="All 4 branches missed.">		if (mergedClosedPeriod != null &amp;&amp; !mergedClosedPeriod.isEmpty())</span>
<span class="nc" id="L107">			applyHOO(excPoints, mergedClosedPeriod, actualCube.getStartDate(), actualCube.getStartOffSet());</span>

		// then calculate aggregated period's value
<span class="nc" id="L110">		double forecastAvg = TraceOperator.aggregatePeriod(forecastCube, traceType, histPoint, excPoints);</span>
<span class="nc" id="L111">		double actualAvg = TraceOperator.aggregatePeriod(actualCube, traceType, histPoint, excPoints);</span>
		// cal deviation percentage
<span class="nc" id="L113">		double avgDeviation = -1;</span>
<span class="nc bnc" id="L114" title="All 2 branches missed.">		if (forecastAvg != 0)</span>
<span class="nc" id="L115">			avgDeviation = actualAvg / forecastAvg;</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">		if (avgDeviation &gt;= 0) { //avgDeviation=0 is a valid case</span>
			// first get the affected window
<span class="nc" id="L118">			s = histPoint+1;</span>
<span class="nc" id="L119">			e = TraceUtil.gapOffSet(actualCube.getStartDate(), actualCube.getStartOffSet(), applyTo);</span>
			// now apply different trending rate
<span class="nc" id="L121">			int fVal = 0;</span>
<span class="nc" id="L122">			int points = e-s-1;</span>
<span class="nc" id="L123">		    double pctPeriod = 1.0/points;</span>
<span class="nc" id="L124">		    double pointPct = 0;</span>
		    //prepare percentage trace cube value check
<span class="nc bnc" id="L126" title="All 4 branches missed.">		    boolean isPercentageCube = (traceType == Trace.PCA || traceType == Trace.OCCUPANCY);</span>
<span class="nc bnc" id="L127" title="All 4 branches missed.">			switch (config.getTrendingRate()) {</span>
				case TrendingConfig.RATE_LINEAR_DROPOFF:
					// first point full deviation by factor, last point just deviation
<span class="nc bnc" id="L130" title="All 2 branches missed.">					for (int idx = s; idx&lt;e; idx++) {</span>
<span class="nc" id="L131">						fVal = trendCube.getTraceValue(traceType, idx);</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">						if (fVal &lt; 0)</span>
<span class="nc" id="L133">							continue;</span>
						//double factor = 1+(SCALE_FACTOR-1)*(1-pointPct);
<span class="nc" id="L135">						double factor = (1-pointPct)*avgDeviation + pointPct;</span>
<span class="nc" id="L136">						trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal*factor)), idx, true);</span>
<span class="nc" id="L137">						pointPct += pctPeriod;</span>
					}
<span class="nc" id="L139">					fVal = trendCube.getTraceValue(traceType, e);</span>
<span class="nc" id="L140">					trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal)), e, true);</span>
<span class="nc" id="L141">					break;</span>
				case TrendingConfig.RATE_CARRIED_THRU:
					// first point be used as smooth ratio
					// the base point is the first point in no drop off
					// first point full deviation by factor, last point just deviation
<span class="nc" id="L146">					double firstPointVal = 0;</span>
<span class="nc" id="L147">					double origfVal = 0;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">					for (int idx = s; idx&lt;e; idx++) {</span>
<span class="nc" id="L149">						fVal = trendCube.getTraceValue(traceType, idx);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">						if (fVal &lt; 0)</span>
<span class="nc" id="L151">							continue;</span>
						//double factor = SCALE_FACTOR-(SCALE_FACTOR-1)*(1.0/(10*(1.1-pointPct)));
<span class="nc" id="L153">						double factor = avgDeviation - ((avgDeviation - 1)*(1/(((1.1-pointPct)*10))));</span>
<span class="nc" id="L154">						double value = fVal*factor;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">						if (idx == s) {</span>
<span class="nc" id="L156">							firstPointVal = value;</span>
<span class="nc" id="L157">							origfVal = fVal;</span>
						}
<span class="nc" id="L159">						trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(value)), idx, true);</span>
<span class="nc" id="L160">						pointPct += pctPeriod;</span>
					}
<span class="nc" id="L162">					fVal = trendCube.getTraceValue(traceType, e);</span>
<span class="nc" id="L163">					trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal)), e, true);</span>
<span class="nc" id="L164">					origfVal = origfVal*avgDeviation;</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">					if (firstPointVal != 0) {</span>
<span class="nc" id="L166">						double fixRatio = origfVal / firstPointVal;</span>
<span class="nc" id="L167">						double deductRatio = (fixRatio-1)/(e-s+1);</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">						for (int idx = s; idx&lt;e; idx++) {</span>
<span class="nc" id="L169">							fVal = trendCube.getTraceValue(traceType, idx);</span>
							//BUG #90136 , Feb 2006 Sameet
							//Fix for Trend: late convergence starting too low from actual value.
<span class="nc" id="L172">							double fixingRatio = fixRatio - (deductRatio * (idx-s));  //No Deduct Ratio will be applied for the first point.</span>
<span class="nc" id="L173">							trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal*fixingRatio)), idx, true);</span>
						}
<span class="nc" id="L175">					}</span>
					break;
				case TrendingConfig.RATE_DIMINISH_QUICK:
					// last point be used as smooth ratio
					// the base point is the last point's Forecasted value
					// first point full deviation by factor, last point just deviation
<span class="nc bnc" id="L181" title="All 2 branches missed.">					for (int idx = s; idx&lt;e; idx++) {</span>
<span class="nc" id="L182">						fVal = trendCube.getTraceValue(traceType, idx);</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">						if (fVal &lt; 0)</span>
<span class="nc" id="L184">							continue;</span>
						//double factor = 1 + ((SCALE_FACTOR-1)/((pointPct+0.1)*10));
<span class="nc" id="L186">						double factor = 1 + ((avgDeviation - 1)/((pointPct + 0.1) * 10));</span>
<span class="nc" id="L187">						trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal*factor)), idx, true);</span>
<span class="nc" id="L188">						pointPct += pctPeriod;</span>
					}
<span class="nc" id="L190">					fVal = trendCube.getTraceValue(traceType, e);</span>
<span class="nc" id="L191">					trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal)), e, true);</span>
<span class="nc" id="L192">					int baseVal = forecastCube.getTraceValue(traceType, e);</span>
                    /* Fix for Bug # 80991; Pulse shows no data if show trends with Early Convergence
                       divide by zero exception being thrown when fVal=0
                       Sameet 9/12/2005
                    */
<span class="nc" id="L197">					double fixRatio=1;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">                    if(fVal!=0)</span>
                    {
<span class="nc" id="L200">                        fixRatio = baseVal / fVal;</span>
                    }
                    /* end of change by sameet 9/12/2005*/

<span class="nc" id="L204">                    double deductRatio = (fixRatio-1)/(e-s+1);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">					for (int idx = e; idx&gt;s; idx--) {</span>
<span class="nc" id="L206">						fVal = trendCube.getTraceValue(traceType, idx);</span>
<span class="nc" id="L207">						fixRatio = fixRatio - deductRatio;</span>
<span class="nc" id="L208">						trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal*fixRatio)), idx, true);</span>
					}
<span class="nc" id="L210">					break;</span>
				default:
					// no drop off
<span class="nc bnc" id="L213" title="All 2 branches missed.">					for (int idx = s; idx&lt;=e; idx++) {</span>
<span class="nc" id="L214">						fVal = trendCube.getTraceValue(traceType, idx);</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">						if (fVal &lt; 0)</span>
<span class="nc" id="L216">							continue;</span>
<span class="nc" id="L217">						trendCube.setTraceValue(traceType, fixPercentage(isPercentageCube, TraceUtil.roundDouble(fVal*avgDeviation)), idx, true);</span>
					}
			}
		}
<span class="nc" id="L221">		return trendCube;</span>
	}

	private static void applyHOO(boolean[] excPoints, Collection mergedClosedPeriod, Date startDate, short startOffSet) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">		for (Iterator it = mergedClosedPeriod.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L226">			TimePeriod period = (TimePeriod)it.next();</span>
<span class="nc" id="L227">			Date pStart = TraceUtil.snapDate(period.getStartTime());</span>
<span class="nc" id="L228">			Date pEnd = TraceUtil.snapDate(period.getEndTime());</span>
<span class="nc" id="L229">			int s = TraceUtil.gapOffSet(startDate, startOffSet, pStart);</span>
<span class="nc" id="L230">			int e = TraceUtil.gapOffSet(startDate, startOffSet, pEnd);</span>
<span class="nc bnc" id="L231" title="All 4 branches missed.">			for (int j=s; j&lt;=e &amp;&amp; j&lt;excPoints.length; j++) {</span>
<span class="nc" id="L232">				excPoints[j] = true;</span>
			}
<span class="nc" id="L234">		}</span>
<span class="nc" id="L235">	}</span>
	/**
	 * Calculate Trending
	 * @param actualCube
	 * @param forecastCube
	 * @param config
	 * @param traceType
	 * @param endDate, if in TrendingConfig the application window is &quot;end of day&quot;, or &quot;end of sp week&quot;, UI just pass the exact Date
	 * @return
	 * @deprecated
	 */
	public static TraceCube calTrend(TraceCube actualCube, TraceCube forecastCube, TrendingConfig config, short traceType, Date now, Date endDate) {
<span class="nc" id="L247">		return calTrend(actualCube, forecastCube, config, traceType, now, endDate, null);</span>
	}

	public static void mergeTrendIntoActual(TraceCube actualCube, TraceCube trendedCube, Date start, Date end, short traceType) {
<span class="nc" id="L251">		Date apply = TraceUtil.snapDate(start);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">		while (apply.before(end)) {</span>
<span class="nc" id="L253">			actualCube.setTraceValue(traceType, trendedCube.getTraceValueD(traceType, apply), apply, true);</span>
<span class="nc" id="L254">			apply.setTime(apply.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
		}
<span class="nc" id="L256">	}</span>
    
    public static void mergeTrendIntoActual(TraceCube actualCube, TraceCube trendedCube, Date start, Date end, 
            short actualTraceType, short trendTraceType) 
    {
<span class="nc" id="L261">        Date apply = TraceUtil.snapDate(start);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">        while (apply.before(end)) {</span>
<span class="nc" id="L263">            actualCube.setTraceValue(actualTraceType, trendedCube.getTraceValueD(trendTraceType, apply), apply, true);</span>
<span class="nc" id="L264">            apply.setTime(apply.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
        }
<span class="nc" id="L266">    }</span>

	private static int fixPercentage(boolean isPercentage, int value) {
<span class="nc bnc" id="L269" title="All 4 branches missed.">		if (isPercentage &amp;&amp; value &gt; 100)</span>
<span class="nc" id="L270">			return 100;</span>
<span class="nc" id="L271">		return value;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>