<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TrackingView.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.pulse.model</a> &gt; <span class="el_source">TrackingView.java</span></div><h1>TrackingView.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.pulse.model;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrForecastedTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.AggrRequiredTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;

/**
 * Title:        Blue Pumpkin Software Forecast&amp;Schedule
 * Description:  TrackingView object, a view definition object for Tracking UI
 * Copyright:    Copyright (c) 2004
 * Company:      Blue Pumpkin Software, inc
 * @author       Sheng Song
 * @version 2.0
 */

public class TrackingView extends ValueObjectBase {
	static final long serialVersionUID = -7242283145378697020L;

<span class="nc" id="L34">	public final static ID INVALID_VIEW_ID = new ID(-10000);</span>
	public final static String INVALID_VIEW_NAME = &quot;-------&quot;;

	private static TrackingView DEFAULT_VIEW;

<span class="nc" id="L39">	private static FieldInfo m_fieldInfo = new TrackingViewFieldInfo();</span>
<span class="nc" id="L40">	protected FieldInfo getFieldInfo() { return m_fieldInfo; }</span>

//	private boolean[] pickedCat = new boolean[3];

	// Each point corresponds to Trace definition, default to false
//	private boolean[] pickedType = new boolean[Trace.MAX_TYPE];
	
	protected List m_ChartList;

	protected static final String CHARTDELIMIT = &quot;|&quot;;
	
	protected TraceCube[] m_MetaTC;

	public static final short ACTUAL_CAT = 0;

	public static final short FORECASTED_CAT = 0;

	public static final short REQUIRED_CAT = 0;
	
	/**
	 * isNoPhantoms will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level, 
	 * ASA, and Dials for the same queue(s) being requested.
	 * This flag will not be serialized since it's only used currently by the Web Calendar, which does not save its 
	 * TrackingViews.
	 */
<span class="nc" id="L65">	public boolean isNoPhantoms = false;</span>

	public static TrackingView getDefaultView() {
<span class="nc" id="L68">		synchronized (TrackingView.class) {</span>
<span class="nc bnc" id="L69" title="All 2 branches missed.">			if (DEFAULT_VIEW == null) {</span>
<span class="nc" id="L70">				DEFAULT_VIEW = new TrackingView();</span>
<span class="nc" id="L71">				DEFAULT_VIEW.setID(INVALID_VIEW_ID);</span>
<span class="nc" id="L72">				DEFAULT_VIEW.setViewName(INVALID_VIEW_NAME);</span>
<span class="nc" id="L73">				DEFAULT_VIEW.setChartDefinition(new ArrayList());</span>
			}
<span class="nc" id="L75">		}</span>
<span class="nc" id="L76">		return DEFAULT_VIEW;</span>
	}

<span class="nc" id="L79">	public TrackingView() { super(); }</span>

	public ID getID() {
<span class="nc" id="L82">		return getFieldValueID(TrackingViewFieldInfo.TRACKINGVIEW_ID);</span>
	}
	public void setID(ID id) {
<span class="nc" id="L85">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_ID, id);</span>
<span class="nc" id="L86">	}</span>

	public void setUserID(ID userID)
	{
<span class="nc" id="L90">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_USERID, userID);</span>
<span class="nc" id="L91">	}</span>

	public ID getUserID() {
<span class="nc" id="L94">		return getFieldValueID(TrackingViewFieldInfo.TRACKINGVIEW_USERID);</span>
	}

	public void setViewName(String name) {
<span class="nc" id="L98">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWNAME, name);</span>
<span class="nc" id="L99">	}</span>

	public String getViewName() {
<span class="nc" id="L102">		return getFormattedFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWNAME);</span>
	}

	public void setDescription(String desc) {
<span class="nc" id="L106">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWDESC, desc);</span>
<span class="nc" id="L107">	}</span>

	public String getDescription() {
<span class="nc" id="L110">		return getFormattedFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWDESC);</span>
	}
	
	public boolean useTrending() {
<span class="nc" id="L114">		return getFieldValueBoolean(TrackingViewFieldInfo.TRACKINGVIEW_ENABLETRENDING);</span>
	}

	public void setTrending(boolean enabled) {
<span class="nc" id="L118">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_ENABLETRENDING, enabled);</span>
<span class="nc" id="L119">	}</span>

	public boolean useHOO() {
<span class="nc" id="L122">		return getFieldValueBoolean(TrackingViewFieldInfo.TRACKINGVIEW_USEHOO);</span>
	}
	
	public void setHOO(boolean useHoo) {
<span class="nc" id="L126">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_USEHOO, useHoo);</span>
<span class="nc" id="L127">	}</span>
	
	public boolean isGlobal() {
<span class="nc" id="L130">		return getFieldValueBoolean(TrackingViewFieldInfo.TRACKINGVIEW_GLOBAL);</span>
	}
	
	public void setGlobalView(boolean global) {
<span class="nc" id="L134">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_GLOBAL, global);</span>
<span class="nc" id="L135">	}</span>
	
	public List getChartDefinition() {
<span class="nc" id="L138">		return m_ChartList;</span>
	}
	
	public void setChartDefinition(List defList) {
<span class="nc" id="L142">		m_ChartList = defList;</span>
<span class="nc" id="L143">		m_MetaTC = null;</span>
<span class="nc" id="L144">	}</span>
	
	/**
	 * Utility method allow UI to detect if any existing TraceChart in the View based on Trace Type and ChartType
	 * @param tc
	 * @return
	 */
	public boolean existSameChart(TraceChart tc) {
<span class="nc bnc" id="L152" title="All 4 branches missed.">		if (m_ChartList != null &amp;&amp; !m_ChartList.isEmpty()) {</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			for (Iterator it=m_ChartList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L154">				TraceChart eTc = (TraceChart)it.next();</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">				if (eTc.getChartType() == tc.getChartType() &amp;&amp; eTc.getTraceType() == tc.getTraceType())</span>
<span class="nc" id="L156">					return true;</span>
<span class="nc" id="L157">			}</span>
		}
<span class="nc" id="L159">		return false;</span>
	}
	/**
	 * Used by persistence layer to convert def into string representation
	 * @return
	 */
	public void saveChartDef() {
<span class="nc" id="L166">		StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L167" title="All 4 branches missed.">		if (m_ChartList != null &amp;&amp; !m_ChartList.isEmpty()) {</span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">			for (Iterator it = m_ChartList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L169">				sb.append(it.next()).append(CHARTDELIMIT);</span>
			}
<span class="nc" id="L171">			setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWDEF, sb.toString());</span>
		}
<span class="nc" id="L173">		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_LASTUPDATE, new Date());</span>
<span class="nc" id="L174">	}</span>
	
	/**
	 * Used by persistence layer to convert def string into list of TraceChart objects
	 * @param defString
	 */
	public void retrieveChart() {
<span class="nc" id="L181">		String defString = getFormattedFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_VIEWDEF); 		</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">		if (defString != null) {</span>
<span class="nc" id="L183">			m_ChartList = new ArrayList();</span>
<span class="nc" id="L184">			StringTokenizer st = new StringTokenizer(defString, CHARTDELIMIT);</span>
<span class="nc bnc" id="L185" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L186">				String chartStr = st.nextToken();</span>
<span class="nc" id="L187">				TraceChart tc = new TraceChart();</span>
<span class="nc" id="L188">				tc.populate(chartStr);</span>
<span class="nc" id="L189">				m_ChartList.add(tc);</span>
<span class="nc" id="L190">			}</span>
		}	
<span class="nc" id="L192">	}</span>

	public short[] getPickedCategories() {
<span class="nc" id="L195">		return null;</span>
	}

	public void pickCategory(short cat) {
<span class="nc" id="L199">	}</span>

	public void unPickCategory(short cat) {
<span class="nc" id="L202">	}</span>

	public boolean isCategoryPicked(short cat) {
<span class="nc" id="L205">		return false;</span>
	}

	public short[] getPickedTypes() {
<span class="nc" id="L209">		return null;</span>
	}

	public void pickType(short type) {
<span class="nc" id="L213">	}</span>

	public void unPickType(short type) {
<span class="nc" id="L216">	}</span>

	public boolean isTypePicked(short type) {
<span class="nc" id="L219">		return false;</span>
	}

	public void setEmployeeID(ID empID)
	{
//		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_EMPID, empID);
<span class="nc" id="L225">	}</span>

	public ID getEmployeeID() {
//		return getFieldValueID(TrackingViewFieldInfo.TRACKINGVIEW_EMPID);
<span class="nc" id="L229">		return null;</span>
	}

	
	public boolean isDeviationView() {
<span class="nc" id="L234">		return false;</span>
	//	return this.getFieldValueBoolean(TrackingViewFieldInfo.TRACKINGVIEW_DEVIATION);
	}

	// For deviation, it is always against Actual
	public void setDeviationView(boolean deviation) {
/*		setFieldValue(TrackingViewFieldInfo.TRACKINGVIEW_DEVIATION, deviation);
		if (deviation)
			pickCategory(ACTUAL_CAT);
<span class="nc" id="L243">	*/}</span>

	public String readViewDefinition() {
<span class="nc" id="L246">		return null;</span>
	}

	public String saveViewDefinition() {
<span class="nc" id="L250">		return null;</span>
	}
	
	/**
	 * 
	 * @return
	 * @throws BbmTimeSeriesException
	 * @deprecated, use the API takes SPMODE parameter to be more precise
	 */
	public TraceCube[] getMetaTC() throws BbmTimeSeriesException  {
<span class="nc" id="L260">		return getMetaTC(true);</span>
	}

	/**
	 * API used by backend for trace retrieve
	 * @param spMode
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	public TraceCube[] getMetaTCForLoad(boolean spMode) throws BbmTimeSeriesException {
<span class="nc" id="L270">		TraceCube[] cubes = new TraceCube[5];</span>
<span class="nc" id="L271">		TraceCube[] uiCubes = getMetaTC(spMode);</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">		if (uiCubes != null) {</span>
<span class="nc" id="L273">			cubes[0] = uiCubes[0];</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">			if (uiCubes[1] != null) {</span>
<span class="nc" id="L275">				cubes[1] = ((AggrForecastedTraceCube)uiCubes[1]).getForecastTrace();</span>
<span class="nc" id="L276">				cubes[2] = ((AggrForecastedTraceCube)uiCubes[1]).getPredictTrace();</span>
			}
<span class="nc bnc" id="L278" title="All 2 branches missed.">			if (uiCubes[2] != null) {</span>
<span class="nc" id="L279">				cubes[3] = ((AggrRequiredTraceCube)uiCubes[2]).getServiceGoalTrace();</span>
<span class="nc" id="L280">				cubes[4] = ((AggrRequiredTraceCube)uiCubes[2]).getRequireTrace();</span>
			}
		}
<span class="nc" id="L283">		return cubes;</span>
	}
	
	public TraceCube[] getMetaTC(boolean spMode) throws BbmTimeSeriesException  {
<span class="nc bnc" id="L287" title="All 2 branches missed.">		if (m_MetaTC == null) {</span>
<span class="nc" id="L288">			m_MetaTC = new TraceCube[3];</span>
		}
<span class="nc" id="L290">		HashSet[] traceTypeSet = new HashSet[3];</span>
<span class="nc" id="L291">		traceTypeSet[0] = new HashSet();</span>
<span class="nc" id="L292">		traceTypeSet[1] = new HashSet();</span>
<span class="nc" id="L293">		traceTypeSet[2] = new HashSet();</span>
<span class="nc bnc" id="L294" title="All 4 branches missed.">		if (m_ChartList != null &amp;&amp; !m_ChartList.isEmpty()) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			for (Iterator it = m_ChartList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L296">				TraceChart tc = (TraceChart)it.next();</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">				if (!tc.isHidden()) {</span>
<span class="nc" id="L298">					boolean[] traceCubes = tc.needTraceCubes();</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">					for (int i=0; i&lt;traceCubes.length; i++) {</span>
<span class="nc bnc" id="L300" title="All 2 branches missed.">						if (traceCubes[i]) {</span>
<span class="nc" id="L301">							traceTypeSet[i].add(NumberFactory.newShort(tc.getTraceType()));</span>
						}
					}
				}
<span class="nc" id="L305">			}</span>
		}
		// Required Trace if has PCA or ASA, it need FCV for aggregation
<span class="nc" id="L308">		boolean needFCV = false;</span>
<span class="nc" id="L309">		int[] order = {2,0,1};</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">		for (int j=0; j&lt;order.length; j++) {</span>
<span class="nc" id="L311">			int i = order[j];</span>
<span class="nc" id="L312">			m_MetaTC[i] = null;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			if (!traceTypeSet[i].isEmpty()) {					</span>
<span class="nc" id="L314">				short[] types = new short[traceTypeSet[i].size()];</span>
<span class="nc" id="L315">				int k = 0;</span>
<span class="nc bnc" id="L316" title="All 2 branches missed.">				for (Iterator it = traceTypeSet[i].iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L317">					short type = ((Short)it.next()).shortValue();</span>
<span class="nc" id="L318">					types[k++] = type;</span>
					// Required Trace if has PCA or ASA, it need FCV for aggregation
<span class="nc bnc" id="L320" title="All 4 branches missed.">					if (type == Trace.PCA || type == Trace.ASA)</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">						needFCV = i==2;</span>
<span class="nc" id="L322">				}</span>
<span class="nc" id="L323">				m_MetaTC[i] = newMeta(i, types, isNoPhantoms);	</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">				if (needFCV) {</span>
<span class="nc" id="L325">					traceTypeSet[1].add(NumberFactory.newShort(Trace.CV));</span>
<span class="nc" id="L326">					traceTypeSet[1].add(NumberFactory.newShort(Trace.VAR));</span>
<span class="nc" id="L327">					needFCV = false;</span>
				}
<span class="nc bnc" id="L329" title="All 8 branches missed.">				if (i == 0 &amp;&amp; useTrending() &amp;&amp; spMode &amp;&amp; !traceTypeSet[0].isEmpty()) {</span>
					// if use Trending, need to add all trace types from Actual into the Forecast cube for the algorithm
<span class="nc" id="L331">					Iterator iter =traceTypeSet[0].iterator();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">					while (iter.hasNext()) {</span>
<span class="nc" id="L333">						Short typeShort = (Short) iter.next();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">						if (TraceUtil.META_AGGR_FORECAST.supportType(typeShort.shortValue())) {</span>
<span class="nc" id="L335">							traceTypeSet[1].add(typeShort);</span>
						}
<span class="nc" id="L337">					}</span>
				}
			}
		}
<span class="nc" id="L341">		return m_MetaTC;</span>
	}

	private static TraceCube newMeta(int idx, short[] types, boolean isNoPhantoms) throws BbmTimeSeriesException {
<span class="nc" id="L345">		short[] backEndTypes = TraceUtil.getAggTraceType(TraceUtil.getCmbTraceType(types));</span>
<span class="nc bnc" id="L346" title="All 4 branches missed.">		switch (idx) {</span>
			case 0:
<span class="nc" id="L348">				return new ActualTraceCube(backEndTypes);				</span>
		    case 1:
				{
<span class="nc bnc" id="L351" title="All 2 branches missed.">					if (isNoPhantoms) {</span>
						//We don't want any extra types from the No Phantom timeseries since it only has 4 types: SL, FTE, ASA, DIALS
<span class="nc" id="L353">						return new AggrForecastedTraceCube(null, null, null, types, null);</span>
					}
										
					//remove the types that are not supported by Predict &amp; Forecasted TraceCube
<span class="nc" id="L357">					ArrayList&lt;Short&gt; backEndSupportedTypes = new ArrayList(backEndTypes.length);</span>

<span class="nc" id="L359">					int j = 0;</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">					for (int i = 0; i &lt; backEndTypes.length; i++) {</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">						if (TraceUtil.META_AGGR_FORECAST.supportType(backEndTypes[i])) {</span>
<span class="nc" id="L362">							backEndSupportedTypes.add(backEndTypes[i]);</span>
						}
					}
<span class="nc" id="L365">					return new AggrForecastedTraceCube(null, null, null, TraceCube.toShortArray(backEndSupportedTypes), null);</span>
				}
		    case 2:
<span class="nc" id="L368">				ArrayList&lt;Short&gt; backEndSupportedTypes = new ArrayList(backEndTypes.length);</span>
<span class="nc" id="L369">				int j = 0;</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">				for (int i = 0; i &lt; backEndTypes.length; i++) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">					if (TraceUtil.META_AGGR_REQUIRE.supportType(backEndTypes[i])) {</span>
<span class="nc" id="L372">						backEndSupportedTypes.add(backEndTypes[i]);</span>
					}
				}
<span class="nc" id="L375">				return new AggrRequiredTraceCube(null, null, null, TraceCube.toShortArray(backEndSupportedTypes), null);</span>
		    default:
<span class="nc" id="L377">		    	return null;</span>
		}
	}	
	
	public String toString() {
<span class="nc" id="L382">		saveChartDef();</span>
<span class="nc" id="L383">		return super.toString();</span>
	}

	/**
	 * isNoPhantoms will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level, 
	 * ASA, and Dials for the same queue(s) being requested.
	 * This flag will not be serialized since it's only used currently by the Web Calendar, which does not save its 
	 * TrackingViews.
	 * @return the isNoPhantoms
	 */
	public boolean isNoPhantoms() {
<span class="nc" id="L394">		return isNoPhantoms;</span>
	}

	/**
	 * isNoPhantoms will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level, 
	 * ASA, and Dials for the same queue(s) being requested.
	 * This flag will not be serialized since it's only used currently by the Web Calendar, which does not save its 
	 * TrackingViews.
	 * @param isNoPhantoms the isIncludeNoPhantoms to set
	 */
	public void setNoPhantoms(boolean isNoPhantoms) {
<span class="nc" id="L405">		this.isNoPhantoms = isNoPhantoms;</span>
<span class="nc" id="L406">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>