<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NetStaffingValidationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.custshift.validation</a> &gt; <span class="el_source">NetStaffingValidationRule.java</span></div><h1>NetStaffingValidationRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.custshift.validation;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueueFieldInfo;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReqFieldInfo;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReqGap;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.setup.validation.ejb.ValidationRuleManager;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * &lt;p&gt;
 * Rule from UI: Minimum duration of request with a net staffing shortage: X (percent).
 * Will flag any cust shift requests that do not satisfy the minimum required net-staffing shortage in percent
 * Formula:
 * (#periods where net staffing is improved / (#periods where net staffing is improved + #periods where net staffing is worsened) )*100
 * Periods will be calculated based on 15-minute intervals, regardless of LTI. However, the 15-minute values take LTI into account.
 * We do not care about intervals where the net staffing is not changed. But we do take threshold into account. So if net staffing
 * for an interval before the request is -2, and after approval, net staffing is -1, and the threshold is 2, then this interval is
 * considered to be unchanged rather than improved, since both values fall under the threshold and are considered equivalent to 0.
 * Default value = 100%
 * Sample Error Message Shown:
 * Request violates the net staffing requirements for the requested time frame:
 * Queue(s) q1,q2 and q3:
 * From 10/10/2011 2:00 am PDT to 10/10/2011 4:00 am PDT
 * From 10/10/2011 8:00 am PDT to 10/10/2011 10:00 am PDT
 */
public class NetStaffingValidationRule implements Validator {
<span class="nc" id="L59">	private static final String className = NetStaffingValidationRule.class.getName();</span>

	static final String CS_MIN_SHORTAGE_DURATION_VALUE = &quot;CS_MIN_SHORTAGE_DURATION_VALUE&quot;;
<span class="nc" id="L62">	public static final ID RULE_ID = new ID(-194047);</span>

<span class="nc" id="L64">	public NetStaffingValidationRule() {</span>
<span class="nc" id="L65">	}</span>

	protected static TimeSeriesManager getTimeSeriesManager() throws Exception {
<span class="nc" id="L68">		return WfmManagerFactory.getTimeSeriesManager(false);</span>
	}

	@Override
	public ValidationResult validate(Validatable validatable) throws Exception {
<span class="nc" id="L73">		ValidationResult result = null;</span>
<span class="nc" id="L74">		CustShiftReq csr = (CustShiftReq) validatable;</span>
<span class="nc" id="L75">		CustShiftValidationCache cache = csr.getCache();</span>
<span class="nc" id="L76">		boolean stafingExists = cache.doesStaffingExistForPeriod(csr);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		if (!stafingExists) {</span>
<span class="nc" id="L78">			result = ValidationUtil.setSoftValidationResult(csr, RmEjbBundleKey.CS_NETSTAFF_NOT_AVAILABLE, className);</span>
<span class="nc" id="L79">			return result;</span>
		}

		// Need to consider only requested periods for net-staffing;
		// existing periods that are already published, we do not care.
		// Over / under should be calculated for requested range only.
		// Need to special handle the scenario where only extn before and extn after are requested.
		// need to calculate over / under seperately for extn before and after and then merge them.
<span class="nc" id="L87">		List&lt;TimeRange&gt; trCol = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L88">		Calendar cal = Calendar.getInstance(csr.getCache().getOrg().getTimeZone());</span>
		// add Time Range for Extn Before
<span class="nc bnc" id="L90" title="All 2 branches missed.">		if (csr.getExtBeforeID() != null) {</span>
<span class="nc" id="L91">			cal.setTime(csr.getStartTime());</span>
<span class="nc" id="L92">			cal.add(Calendar.MINUTE, csr.getExtBeforeDuration());</span>
<span class="nc" id="L93">			trCol.add(new TimeRange(csr.getStartTime(), cal.getTime()));</span>
		}
<span class="nc bnc" id="L95" title="All 2 branches missed.">		if (csr.getShiftID() != null) {</span>
<span class="nc" id="L96">			trCol.add(new TimeRange(csr.getShiftStartTime(), csr.getShiftEndTime()));</span>
		}
		// add Time Range for Extn After
<span class="nc bnc" id="L99" title="All 2 branches missed.">		if (csr.getExtAfterID() != null) {</span>
<span class="nc" id="L100">			cal.setTime(csr.getEndTime());</span>
<span class="nc" id="L101">			cal.add(Calendar.MINUTE, -1 * csr.getExtAfterDuration());</span>
<span class="nc" id="L102">			trCol.add(new TimeRange(cal.getTime(), csr.getEndTime()));</span>
		}

		// add time ranges for Ext into gaps
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L107">		Collection&lt;CustShiftReqGap&gt; gaps = csr.getChildObjects(CustShiftReqFieldInfo.CUSTREQGAP_CHILD_TYPE);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">		for (CustShiftReqGap gap : gaps) {</span>
<span class="nc" id="L109">			trCol.add(new TimeRange(gap.getExtGapStartTime(), gap.getExtGapEndTime()));</span>
<span class="nc" id="L110">		}</span>

		// merge overlapping/adjacent time ranges and sort the list
<span class="nc" id="L113">		trCol = ValidationUtil.joinAndSort(trCol);</span>

		// the Tracecubes as they would look before approval of the request.
<span class="nc" id="L116">		NetStaffingCube preNsCube = cache.getPreCSApprovalNetStaffingCube(csr, false);</span>
		// the Tracecubes as they would look after approval of the request.
<span class="nc" id="L118">		NetStaffingCube postNsCube = cache.getPostCSApprovalNetStaffingCube(csr);</span>
		// Only continue to validate when Queues Found that match the skill set of EMP (preNsCube!=null &amp;&amp; postNsCube !=null ) )
<span class="nc bnc" id="L120" title="All 4 branches missed.">		if (preNsCube != null &amp;&amp; postNsCube != null) {</span>
<span class="nc" id="L121">			HashMap&lt;ID, SPQueue&gt; spQueueMap = postNsCube.getSPQueueMap();</span>

<span class="nc" id="L123">			ArrayList&lt;TimeRange&gt; intervalsWorsened = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L124">			int numIntervalsImproved = getNumIntervalsImproved(intervalsWorsened, trCol, preNsCube, postNsCube, cache);</span>
<span class="nc" id="L125">			int numIntervalsWorsened = intervalsWorsened.size();</span>
<span class="nc" id="L126">			int numIntervalsChanged = numIntervalsImproved + numIntervalsWorsened;</span>
			// we don't care about the unchanged intervals
<span class="nc bnc" id="L128" title="All 2 branches missed.">			double percentOfIntervalsImproved = (numIntervalsChanged == 0) ? 0.0d</span>
					: (((double) (numIntervalsImproved)) / ((double) numIntervalsChanged) * 100.0d);

<span class="nc" id="L131">			ValidationRuleManager valMan = RmManagerFactory.getInstance().getValidationRuleManager();</span>
<span class="nc" id="L132">			Map&lt;String, Integer&gt; ruleParams = valMan.getValidationRuleParams(csr.getCache().getOrg().getID(), RULE_ID);</span>
<span class="nc" id="L133">			int minReqdNetStaffShortagePercent = ruleParams.get(CS_MIN_SHORTAGE_DURATION_VALUE).intValue();</span>

<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (percentOfIntervalsImproved &lt; minReqdNetStaffShortagePercent) {</span>
<span class="nc" id="L136">				StringBuilder value = new StringBuilder();</span>
<span class="nc" id="L137">				Localizer localizer = DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
<span class="nc" id="L138">				ResourceBundle bundle = localizer.getBundle(RmEjbBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L140">				TreeSet violationTreeSet = TimeRange.mergeAdjacentTimeRanges(intervalsWorsened, 60000);</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">				for (Iterator iterator = violationTreeSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L142">					TimeRange tr = (TimeRange) iterator.next();</span>
<span class="nc" id="L143">					String formatStDateTime = localizer.formatDateTime(tr.getStartDate(), cache.getOrg().getTimeZone());</span>
<span class="nc" id="L144">					String formatEnDateTime = localizer.formatDateTime(tr.getEndDate(), cache.getOrg().getTimeZone());</span>
<span class="nc" id="L145">					value.append(localizer.i18n(bundle, RmEjbBundleKey.TimePeriodFromToData,</span>
							new Object[] { formatStDateTime, formatEnDateTime }));
<span class="nc" id="L147">					value.append(&quot;&lt;BR&gt;&quot;);</span>
<span class="nc" id="L148">				}</span>

<span class="nc" id="L150">				Set qIDSet = TOHoursPerDayUtil.extractFieldSet(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueueMap.values());</span>
<span class="nc" id="L151">				String qNameSB = getQueueNameDetails(qIDSet, localizer, bundle);</span>
<span class="nc" id="L152">				result = ValidationUtil.setSoftValidationResult(csr,</span>
<span class="nc" id="L153">						RmEjbBundleKey.CS_NETSTAFF_SHORTAGE, qNameSB, value.toString(), className);</span>
			}
		}
<span class="nc" id="L156">		return result;</span>
	}

	/**
	 * Determines the number of 15-minute intervals in the requested date range in which the net staffing
	 * would be improved if the request is approved. We also keep track of the intervals that would see net staffing
	 * worsen. We need this information in order to compare the percentage of improvement versus the goal percentage
	 * for the validation rule.
	 * 
	 * @param intervalsWorsened
	 *            - In this array, we will store the 15-minute intervals in which net staffing would get
	 *            worse if the request is approved.
	 * @param trCol
	 *            - List of timeRanges for the request, in chronological order.
	 * @param preNsCube
	 *            - the NetStaffingCube prior to approving the request.
	 * @param postNsCube
	 *            - the NetStaffingCube that would exist after approving the request.
	 * @param cache
	 *            - the cache to use when getting the necessary aggregations, or any other cacheable items.
	 * @return - The number of 15-minute intervals in the requested date range that would see a net staffing improvement
	 *         were the request to be approved.
	 */
	private int getNumIntervalsImproved(ArrayList&lt;TimeRange&gt; intervalsWorsened, List&lt;TimeRange&gt; trCol, NetStaffingCube preNsCube,
			NetStaffingCube postNsCube, CustShiftValidationCache cache) {
<span class="nc" id="L181">		int numIntervalsImproved = 0;</span>

<span class="nc bnc" id="L183" title="All 4 branches missed.">		if (trCol != null &amp;&amp; !trCol.isEmpty()) {</span>
<span class="nc" id="L184">			TimeRange requestDateRange = ValidationUtil.getRequestDateRange(trCol);</span>
<span class="nc" id="L185">			Date curIntervalStart = requestDateRange.getStartDate();</span>
<span class="nc" id="L186">			Date curIntervalEnd = new Date(curIntervalStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			// for each interval of the request range
<span class="nc bnc" id="L188" title="All 2 branches missed.">			while (!curIntervalEnd.after(requestDateRange.getEndDate())) {</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">				if (ValidationUtil.isValidInterval(curIntervalStart, trCol)) {</span>
<span class="nc" id="L190">					boolean anyQueueImprovedInCurInterval = false;</span>
<span class="nc" id="L191">					boolean anyQueueWorsenedInCurInterval = false;</span>

					// For Shift Requests:
					// If ANY queue in this interval has a net staffing improvement, then this interval is considered an improvement.
					// Otherwise, if ANY queue in this interval has a net staffing worsening, then this interval is considered a worsening.
					// Otherwise, this interval is considered unchanged.
<span class="nc" id="L197">					HashMap&lt;SPQueue, Double&gt; spqIDToNSBeforeMap = ValidationUtil.getFTEDPastThreshold(preNsCube, curIntervalStart,</span>
							curIntervalEnd, &quot;PRE&quot;, cache);
<span class="nc" id="L199">					HashMap&lt;SPQueue, Double&gt; spqIDToNSAfterMap = ValidationUtil.getFTEDPastThreshold(postNsCube, curIntervalStart,</span>
							curIntervalEnd, &quot;POST&quot;, cache);

<span class="nc bnc" id="L202" title="All 2 branches missed.">					for (SPQueue spQueue : spqIDToNSBeforeMap.keySet()) {</span>
<span class="nc" id="L203">						double netStaffBefore = Math.abs(spqIDToNSBeforeMap.get(spQueue));</span>
<span class="nc" id="L204">						double netStaffAfter = Math.abs(spqIDToNSAfterMap.get(spQueue));</span>

<span class="nc bnc" id="L206" title="All 2 branches missed.">						if (netStaffAfter &lt; netStaffBefore) {</span>
<span class="nc" id="L207">							numIntervalsImproved++;</span>
<span class="nc" id="L208">							anyQueueImprovedInCurInterval = true;</span>
<span class="nc" id="L209">							break;</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">						} else if (netStaffAfter &gt; netStaffBefore) {</span>
<span class="nc" id="L211">							anyQueueWorsenedInCurInterval = true;</span>
						}
<span class="nc" id="L213">					}</span>

<span class="nc bnc" id="L215" title="All 4 branches missed.">					if (!anyQueueImprovedInCurInterval &amp;&amp; anyQueueWorsenedInCurInterval) {</span>
<span class="nc" id="L216">						intervalsWorsened.add(new TimeRange(curIntervalStart, curIntervalEnd));</span>
					}
				}
<span class="nc" id="L219">				curIntervalStart = curIntervalEnd;</span>
<span class="nc" id="L220">				curIntervalEnd = new Date(curIntervalEnd.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
		}
<span class="nc" id="L223">		return numIntervalsImproved;</span>
	}

	private String getQueueNameDetails(Set qIDSet, Localizer localizer, ResourceBundle bundle)
			throws BbmFinderException, BbmEJBCreateException, RemoteException {
<span class="nc" id="L228">		StringBuilder qNameSB = new StringBuilder();</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">		if (qIDSet != null &amp;&amp; !qIDSet.isEmpty()) {</span>
<span class="nc" id="L230">			Map queIDNameMap = WfmManagerFactory.getWorkloadManager().getQueueNamesByIDs(qIDSet);</span>

<span class="nc" id="L232">			int count = 0;</span>

<span class="nc bnc" id="L234" title="All 2 branches missed.">			for (Object o : queIDNameMap.values()) {</span>
<span class="nc" id="L235">				qNameSB.append(o);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">				if (count == queIDNameMap.size() - 2) {</span>
<span class="nc" id="L237">					qNameSB.append(&quot; &quot;).append(localizer.i18n(bundle, RmEjbBundleKey.OperatorAnd)).append(&quot; &quot;);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">				} else if (count &lt; queIDNameMap.size() - 2) {</span>
<span class="nc" id="L239">					qNameSB.append(&quot;, &quot;);</span>
				}
<span class="nc" id="L241">				count++;</span>
<span class="nc" id="L242">			}</span>
<span class="nc" id="L243">		} else {</span>
<span class="nc" id="L244">			ResourceBundle bbmBundle = localizer.getBundle(BbmEjbBundleKey.BUNDLE_NAME);</span>
<span class="nc" id="L245">			qNameSB.append(localizer.i18n(bbmBundle, BbmEjbBundleKey.QUEUE_FILTER_COMBINED));</span>
		}
<span class="nc" id="L247">		return qNameSB.toString();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>