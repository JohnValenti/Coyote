<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarTimeOffDayFacadeEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb</a> &gt; <span class="el_source">CalendarTimeOffDayFacadeEJB.java</span></div><h1>CalendarTimeOffDayFacadeEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase.NullObject;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TOPoolUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOIntervalCalendar;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.BlackoutDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.CalendarTimeOffDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignmentFieldInfo;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmployeeReferenceScheduleAssignment;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmployeeReferenceScheduleAssignmentUpdateParameters;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalAllocation;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOIntervalApprovedAndPending;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPool;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.TOPoolAssignmentsByActivityUpdateParameters;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.bluepumpkin.ejb.rm.util.TOIntervalCalendarUtil;

/**
 * Title:        CalendarTimeOffDayFacadeEJB
 * Description:  EJB for TOPool, CalendarTimeOffDay &amp; EMP-TOPool effectivity
 * Copyright:    Copyright (c) 2010
 * Company:      Verint, Inc.
 *
 * @author Sameet Joshi
 * @version 1.0
 */
<span class="nc" id="L70">public class CalendarTimeOffDayFacadeEJB extends SessionEJBBase {</span>
<span class="nc" id="L71">	private static Category m_cat = Log.initCategory(CalendarTimeOffDayFacadeEJB.class.getName());</span>
<span class="nc" id="L72">	private static final String m_className = CalendarTimeOffDayFacadeEJB.class.getName();</span>

<span class="nc" id="L74">	private EventAuditTrailManager m_auditManager = null;</span>

	{
<span class="nc" id="L77">		super.init(CalendarTimeOffDayFacadeEJB.class.getName());</span>
<span class="nc" id="L78">	}</span>

	/**
	 * override the base class to provide the appropriate logging category
	 */
	@Override
	protected Category getCategory() {
<span class="nc" id="L85">		return m_cat;</span>
	}

	@Override
	public void ejbCreate() {
		try {
<span class="nc" id="L91">			m_auditManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L92">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L93">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="nc" id="L94">		}</span>
<span class="nc" id="L95">	}</span>

	@Override
	public void ejbRemove() {
		try {
<span class="nc bnc" id="L100" title="All 2 branches missed.">			if (m_auditManager != null) {</span>
<span class="nc" id="L101">				m_auditManager.remove();</span>
			}
<span class="nc" id="L103">		} catch (Exception ignore) {</span>
<span class="nc" id="L104">			m_cat.l7dError(ignore.getMessage());</span>
<span class="nc" id="L105">		}</span>
<span class="nc" id="L106">	}</span>

	/**
	 * see {@link CalendarTimeOffDayFacade#getCalendarTimeOffDays(ID, LocalDate, LocalDate, boolean) getCalendarTimeOffDays}
	 * &lt;p/&gt;
	 * Gets the time off calendar data configured for all days for specified Month and Year.
	 *
	 * @param toPoolID - ID for the TO Pool.
	 * @param pMonth   - integer value representing month.
	 * @param pYear    - integer value representing year.
	 * @return Collection - Collection of CalendarTimeOffDay objects.
	 * @throws BbmFinderException
	 */
	public Collection getCalendarTimeOffDays(ID toPoolID, int pMonth, int pYear) 
			throws BbmFinderException {
<span class="nc" id="L121">		final String l_MethodName = &quot;getCalendarTimeOffDays&quot;;</span>
<span class="nc" id="L122">		methodStart(l_MethodName, toPoolID, NumberFactory.newInteger(pMonth), NumberFactory.newInteger(pYear));</span>
<span class="nc" id="L123">		Jdmo dmo = null;</span>
<span class="nc" id="L124">		ArrayList results = new ArrayList();</span>
		try {
<span class="nc" id="L126">			dmo = new Jdmo();</span>
<span class="nc" id="L127">			MonthRange monthRange = new MonthRange(pMonth, pYear);</span>
<span class="nc" id="L128">			Calendar c = new GregorianCalendar(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L129">			c.setTime(monthRange.startDate);</span>

			// get blackout days for this month
<span class="nc" id="L132">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="nc" id="L133">			BlackoutDay[] blackoutDays = blackoutDAO.findWithinMonth(toPoolID, monthRange);</span>

			// get timeoff allocation calendar days
<span class="nc" id="L136">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
<span class="nc" id="L137">			CalendarTimeOffDay[] timeoffCalDays = timeoffCalDAO.findWithinMonth(toPoolID, monthRange);</span>

			// now create a new collection of timeoff objects by merging the blackoutDay
			//  and timeoffCalendarDay objects retrieved from the database.
<span class="nc bnc" id="L141" title="All 2 branches missed.">			for (int i = 0; i &lt; blackoutDays.length; i++) {</span>
<span class="nc" id="L142">				CalendarTimeOffDay timeoffCalDay = timeoffCalDays[i];</span>

				// is this a blackout day?
<span class="nc bnc" id="L145" title="All 2 branches missed.">				boolean isBlackOutDay = blackoutDays[i] != null;</span>

				// if timeOffCalDay exisits, mark it as a blackout day
<span class="nc bnc" id="L148" title="All 2 branches missed.">				if (timeoffCalDay != null) {</span>
<span class="nc" id="L149">					timeoffCalDay.setBlackOutDay(isBlackOutDay);</span>
<span class="nc" id="L150">					results.add(timeoffCalDay);</span>
<span class="nc bnc" id="L151" title="All 2 branches missed.">				} else if (isBlackOutDay) {// if timeoffCal Day does not exist, create one and mark it as blackout day</span>
<span class="nc" id="L152">					timeoffCalDay = new CalendarTimeOffDay();</span>
<span class="nc" id="L153">					timeoffCalDay.setTOPoolID(toPoolID);</span>
<span class="nc" id="L154">					timeoffCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L155">					c.set(Calendar.DAY_OF_MONTH, c.getMinimum(Calendar.DAY_OF_MONTH) + i);</span>
<span class="nc" id="L156">					timeoffCalDay.setTimeOffDate(c.getTime());</span>
<span class="nc" id="L157">					results.add(timeoffCalDay);</span>
				}
			}
<span class="nc" id="L160">		} catch (Exception e) {</span>
<span class="nc" id="L161">			handleException(e);</span>
<span class="nc" id="L162">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L164" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L165">				dmo.cleanUp();</span>
			}
<span class="nc" id="L167">			methodFinish();</span>
<span class="nc" id="L168">		}</span>
<span class="nc" id="L169">		return results;</span>
	}

	/**
	 * This method combines the blackout days and timeoff cal days into one collection. It has to handle collections
	 * are sparse and figure out the overlap.
	 * &lt;p/&gt;
	 * &lt;p&gt; 3 possible scenarios:
	 * &lt;li&gt; timeoff allocation and blackout match
	 * &lt;li&gt; timeoff allocation present, blackout absent
	 * &lt;li&gt; timeoff allocation absent,  blackout present
	 */
	private Collection processBlackoutDays(Collection blackoutDays, Collection timeoffCalDays, ID pTOPoolID) {
		// if blackoutDays collection is empty, we are done. simply return the timeoffCalDays collection
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (blackoutDays.isEmpty()) {</span>
<span class="nc" id="L184">			return timeoffCalDays;</span>
		}
		// now we need to consider the blackoutDays in the date range as well. In effect,
		// we need to do the following:
		//     if blackoutDay object and timeoffCalendarDay object exist for the same day,
		//          set the blackout day flag in the timeOffCalendar object
		//     if blackoutDay object exists but timeOffCalendarDay object doesn't for a given
		//          day, create a new timeoffCalendarDay object and set the blackout day flag.
		//     if blackoutDay object doesn't exist but timeOffCalendarDay object exists for a
		//          a given day, reset the blackout day flag.

		// collection to hold timeOffCalendarDay objects
<span class="nc" id="L196">		ArrayList results = new ArrayList(timeoffCalDays.size());</span>
<span class="nc" id="L197">		Iterator boItr = blackoutDays.iterator(), ctoItr = timeoffCalDays.iterator();</span>
		// for each blackout day identify the corresponding calendarTimeOffDayData VO
		//   if it exists
		//      mark it as a blackout day.
		//   else
		//      create a new calendarTimeOffDayData VO and mark it as a blackout day.

		// Both lists are sorted and for now, assume that the date for the same day compares as equal.  They should,
		// since they get written from the same value input.  Might need to revisit that assumption later...
<span class="nc bnc" id="L206" title="All 2 branches missed.">		CalendarTimeOffDay currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
		// At the start of **each** loop itertion, if currTOCalDay != null then this calendarTimeOffDay hasn't
		// been added to the results yet.  If the loop terminates this needs to be added
		// to the results collection outside the loop.
<span class="nc bnc" id="L210" title="All 2 branches missed.">		while (boItr.hasNext()) {</span>
			// Four possibilies at this point:
			//     No current timeOffCalendarDay exists (currTOCalDay == null).
			//     currTOCalDay &lt; currBlackoutDay
			//     currTOCalDay == currBlackoutDay
			//     currTOCalDay &gt; currBlackoutDay.
<span class="nc" id="L216">			BlackoutDay currBODay = (BlackoutDay) boItr.next();</span>

			// scan until the timeOffCalendarDayData's date is &quot;equal to&quot; or after the current
			// black out day.  Add the current timeOffCalDayData to the 'results' array without marking
			// it as a 'blackout' day.
<span class="nc bnc" id="L221" title="All 4 branches missed.">			while (currTOCalDay != null &amp;&amp; currTOCalDay.getTimeOffDate().before(currBODay.getBlackoutDate())) {</span>
<span class="nc" id="L222">				results.add(currTOCalDay); // Add timeoffCalDay to results &amp; advance to the next timeOffCalendarDayData</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">				currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
			}

			// At this point, either timeoffCalDay is null (all timeoffCalDays have been processed),
			// equals the current blackout day or is after the current blackout day.
			//
			// If it is null (all timeoffCalDay objects processed) or is after
			// the current blackout day, create a new timeoffcaleandarDayData VO.
<span class="nc bnc" id="L231" title="All 4 branches missed.">			if ((currTOCalDay == null) || currTOCalDay.getTimeOffDate().after(currBODay.getBlackoutDate())) {</span>
				// create a new ValueObject (VO) &amp; mark it as a blackout day.
<span class="nc" id="L233">				CalendarTimeOffDay newTimeoffCalDay = new CalendarTimeOffDay();</span>
<span class="nc" id="L234">				newTimeoffCalDay.setTOPoolID(pTOPoolID);</span>
<span class="nc" id="L235">				newTimeoffCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L236">				newTimeoffCalDay.setTimeOffDate(currBODay.getBlackoutDate());</span>
<span class="nc" id="L237">				results.add(newTimeoffCalDay);</span>
<span class="nc" id="L238">			} else { // found timeoffCalDay object and blackoutDay object for the same day.</span>
<span class="nc" id="L239">				currTOCalDay.setBlackOutDay(true);</span>
<span class="nc" id="L240">				results.add(currTOCalDay);</span>
				// advance to the next timeOffCalendarDayData
<span class="nc bnc" id="L242" title="All 2 branches missed.">				currTOCalDay = (CalendarTimeOffDay) (ctoItr.hasNext() ? ctoItr.next() : null);</span>
			}
<span class="nc" id="L244">		}</span>
		// if the last TOCalendarDay was not added (within the above loop), add it
<span class="nc bnc" id="L246" title="All 2 branches missed.">		if (currTOCalDay != null) {</span>
<span class="nc" id="L247">			results.add(currTOCalDay);</span>
		}
		// Add any left over timeoffCalDay objects
<span class="nc bnc" id="L250" title="All 2 branches missed.">		while (ctoItr.hasNext()) {</span>
<span class="nc" id="L251">			results.add(ctoItr.next());</span>
		}
<span class="nc" id="L253">		return results;</span>
	}

	/**
	 * Gets the time off calendar data configured for all days
	 * in the given range, inclusive
	 *
	 * @param pTOPoolID            - ID for the Time-Off Pool.
	 * @param pStart               - beginning of the range
	 * @param pEnd                 - end of the range
	 * @param pIncludeBlackOutInfo - true =&gt; adds processing to set the
	 *                             black out day flags in the appropriate days,
	 *                             false =&gt; black out information is not returned.
	 * @return Collection - Collection of CalendarTimeOffDay objects, sorted in
	 *         ascending order by date.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public Collection getCalendarTimeOffDays(ID pTOPoolID, LocalDate pStart, LocalDate pEnd, boolean pIncludeBlackOutInfo)
			throws BbmFinderException {
<span class="nc" id="L273">		final String l_MethodName = &quot;getCalendarTimeOffDays&quot;;</span>
<span class="nc" id="L274">		methodStart(l_MethodName, pTOPoolID, pStart, pEnd);</span>
<span class="nc" id="L275">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L277">			dmo = new Jdmo();</span>
			// obtain the timeoffCalendarDay objects for the given date range
<span class="nc" id="L279">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
<span class="nc" id="L280">			Collection timeoffCalDays = timeoffCalDAO.findInRange(pTOPoolID, pStart, pEnd);</span>

			// if blackout information not needed, simply return the timeoffCalendarDay objects
<span class="nc bnc" id="L283" title="All 2 branches missed.">			if (!pIncludeBlackOutInfo) {</span>
<span class="nc" id="L284">				return timeoffCalDays;</span>
			}

			// obtain the blackoutDay objects in the given date range.
<span class="nc" id="L288">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="nc" id="L289">			Collection blackOutDays = blackoutDAO.findInRange(pTOPoolID, pStart, pEnd);</span>
<span class="nc" id="L290">			return processBlackoutDays(blackOutDays, timeoffCalDays, pTOPoolID);</span>
<span class="nc" id="L291">		} catch (Exception e) {</span>
<span class="nc" id="L292">			handleException(e);</span>
<span class="nc" id="L293">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L295">			methodFinish();</span>
<span class="nc bnc" id="L296" title="All 6 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L297">				dmo.cleanUp();</span>
			}
		}
	}

	/**
	 * see {@link CalendarTimeOffDayFacade#getBlackoutDays(ID, LocalDate, LocalDate) getBlackoutDays}
	 * &lt;p/&gt;
	 * Gets the time off black out day data configured for all days
	 * in the given range, inclusive
	 *
	 * @param pTOPoolID - ID for the Time-Off Pool.
	 * @param pStart    - beginning of the range
	 * @param pEnd      - end of the range
	 * @return Collection - Collection of BlackoutDay objects, sorted in
	 *         ascending order by date.
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public Collection&lt;BlackoutDay&gt; getBlackoutDays(ID pTOPoolID, LocalDate pStart, LocalDate pEnd) throws BbmFinderException {
<span class="nc" id="L317">		final String methodName = &quot;getBlackoutDays&quot;;</span>
<span class="nc" id="L318">		methodStart(methodName, pTOPoolID, pStart, pEnd);</span>
<span class="nc" id="L319">		BlackoutDayDAO dao = null;</span>
		try {
<span class="nc" id="L321">			dao = new BlackoutDayDAO();</span>
<span class="nc" id="L322">			return dao.findInRange(pTOPoolID, pStart, pEnd);</span>
<span class="nc" id="L323">		} catch (Exception e) {</span>
<span class="nc" id="L324">			handleException(e);</span>
<span class="nc" id="L325">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L327" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L328">				dao.cleanUp();</span>
			}
<span class="nc" id="L330">			methodFinish();</span>
		}
	}

	/**
	 * Gets the employee's effective blackout days for the time range.
	 *
	 * @param employeeID
	 * @param startTime
	 * @param endTime
	 *            Exclusive end time.
	 */
	public List&lt;BlackoutDay&gt; getEffectiveBlackoutDaysForEmployee(ID employeeID, Date startTime, 
			Date endTime, ID activityID) throws BbmFinderException {
<span class="nc" id="L344">		final String methodName = &quot;getEffectiveBlackoutDaysForEmployee&quot;;</span>
<span class="nc" id="L345">		methodStart(methodName, employeeID, startTime, endTime, activityID);</span>
<span class="nc" id="L346">		BlackoutDayDAO dao = null;</span>
		try {
<span class="nc" id="L348">			dao = new BlackoutDayDAO();</span>
<span class="nc" id="L349">			return dao.getEffectiveBlackoutDaysForEmployee(employeeID, startTime, endTime, activityID);</span>
<span class="nc" id="L350">		} catch (Exception e) {</span>
<span class="nc" id="L351">			handleException(e);</span>
<span class="nc" id="L352">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L354" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L355">				dao.cleanUp();</span>
			}
<span class="nc" id="L357">			methodFinish();</span>
		}
	}

	/**
	 * Save the collection of BlackoutDays. The blackhout days trickle down
	 * from the current org to its children.
	 *
	 * @param start-    Localdate start of range
	 * @param end-      Localdate end of range
	 * @param pTOPoolID - ID for the Time-Off Pool.
	 * @param delete    - whether to delet blackout days.
	 * @throws BbmFinderException
	 */
	public void saveBlackoutDaysForRange(LocalDate start, LocalDate end, ID pTOPoolID, boolean delete) throws BbmFinderException {
<span class="nc" id="L372">		final String l_MethodName = &quot;saveBlackoutDaysForRange&quot;;</span>
<span class="nc" id="L373">		methodStart(l_MethodName, start, end, pTOPoolID);</span>
<span class="nc" id="L374">		BlackoutDayDAO dao = null;</span>
		try {
<span class="nc" id="L376">			dao = new BlackoutDayDAO();</span>
<span class="nc" id="L377">			dao.saveBlackoutDaysForRange(pTOPoolID, start, end, delete);</span>
<span class="nc" id="L378">			triggerWaitlistScan(pTOPoolID, start.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)), end.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)));</span>
<span class="nc" id="L379">		} catch (Exception e) {</span>
<span class="nc" id="L380">			handleException(e);</span>
<span class="nc" id="L381">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L383" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L384">				dao.cleanUp();</span>
			}
<span class="nc" id="L386">			methodFinish();</span>
<span class="nc" id="L387">		}</span>
<span class="nc" id="L388">	}</span>

	/**
	 * Save the calendar allocated time off hours and blackout days data
	 * for an entire month. This method will not save more than one month
	 * at a time.
	 * The allocated time off hours and blackout days are stored in different
	 * table and use very different logic. The blackhout days trickle down
	 * from the current org to its children. The available time off hours
	 * are processed using information derived from the ownerOrgID.
	 *
	 * @param pTimeOffDays - Collection of CalendarTimeOffDay objects holding
	 *                     available time off hours and blackout day information.
	 * @param pTOPoolID    - ID for the Time-Off Pool.
	 * @throws BbmUpdateException
	 */
	public void saveCalendarTimeOffDays(Collection pTimeOffDays, ID pTOPoolID) throws BbmUpdateException {
<span class="nc" id="L405">		final String l_MethodName = &quot;saveCalendarTimeOffDays&quot;;</span>
<span class="nc" id="L406">		methodStart(l_MethodName, pTimeOffDays, pTOPoolID);</span>

<span class="nc" id="L408">		Calendar c = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L409">		int timeoffYear = 0;</span>
<span class="nc" id="L410">		int timeoffMonth = 0;</span>

		// convert the data from collection to a month array
<span class="nc" id="L413">		CalendarTimeOffDay[] timeoffDays = new CalendarTimeOffDay[31];</span>
<span class="nc" id="L414">		BlackoutDay[] blackoutDays = new BlackoutDay[31];</span>

		// create two month arrays, one each for timeoffDays and blackoutDays, from
		// pTimeOffDays.  Also validate the entries in pTimeOffDays.

		//store the earliest start date &amp; last end date , to be used for TOWaitlist scan
<span class="nc" id="L420">		Date earliestDate = null;</span>
<span class="nc" id="L421">		Date endDate = null;</span>
<span class="nc" id="L422">		int i = 0;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">		for (Iterator itr = pTimeOffDays.iterator(); itr.hasNext(); i++) {</span>
			// obtain
<span class="nc" id="L425">			CalendarTimeOffDay timeoffDay = (CalendarTimeOffDay) itr.next();</span>

			// if timeOffDate not specified, t_hrow exception.
<span class="nc" id="L428">			Date timeOffDate = timeoffDay.getTimeOffDate();</span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">			if (timeOffDate == null) {</span>
<span class="nc" id="L430">				throw new IllegalArgumentException(&quot;A null TimeOffDate is not allowed:\n&quot; + &quot;entryIDx=&quot; + i + &quot;;\nrecord=&quot; + timeoffDay);</span>
			}
<span class="nc" id="L432">			c.setTime(timeOffDate);</span>

			// set timeoff year and month if not set.
<span class="nc bnc" id="L435" title="All 2 branches missed.">			if (timeoffYear == 0) {</span>
<span class="nc" id="L436">				timeoffYear = c.get(Calendar.YEAR);</span>
<span class="nc" id="L437">				timeoffMonth = c.get(Calendar.MONTH);</span>
			}

			// validate that all timeoffCalendarDay objects must belong to the same year and month.
<span class="nc bnc" id="L441" title="All 4 branches missed.">			if ((timeoffYear != c.get(Calendar.YEAR)) || (timeoffMonth != c.get(Calendar.MONTH))) {</span>
<span class="nc" id="L442">				throw new IllegalArgumentException(&quot;All time off dates must be in &quot; + &quot;the same month and year:\nentryIDx=&quot; + i</span>
						+ &quot;;\nrecord=&quot; + timeoffDay);
			}

			// index into the arrays
<span class="nc" id="L447">			int dayOfMonth = c.get(Calendar.DAY_OF_MONTH) - c.getMinimum(Calendar.DAY_OF_MONTH);</span>

			// ensure that an entry at the index doesn't already exist
<span class="nc bnc" id="L450" title="All 2 branches missed.">			if (timeoffDays[dayOfMonth] != null) {</span>
<span class="nc" id="L451">				throw new IllegalArgumentException(&quot;Cannot save two separate entries &quot; + &quot;for the same day:\nentryIDx=&quot; + i</span>
						+ &quot;;\ncurrent record=&quot; + timeoffDay + &quot;\n previous record=&quot; + timeoffDays[dayOfMonth]);
			}

			// store in timeoffCalendarDays array if the entry's available hours is positive (--nonzero).
<span class="nc bnc" id="L456" title="All 2 branches missed.">			if (timeoffDay.getAllocatedHours() &gt;= 0) {</span>
<span class="nc" id="L457">				timeoffDays[dayOfMonth] = timeoffDay;</span>
<span class="nc bnc" id="L458" title="All 2 branches missed.">				if (earliestDate == null) {</span>
<span class="nc" id="L459">					earliestDate = timeOffDate;</span>
				}
<span class="nc" id="L461">				endDate = timeOffDate; //set this everytime there are available hours</span>
			}

			// store in blackoutDays array if it is a blackout day.
<span class="nc bnc" id="L465" title="All 2 branches missed.">			if (timeoffDay.isBlackOutDay()) {</span>
<span class="nc" id="L466">				blackoutDays[dayOfMonth] = new BlackoutDay();</span>
<span class="nc" id="L467">				blackoutDays[dayOfMonth].setBlackoutDate(timeoffDay.getTimeOffDate());</span>
			}
			//Logic to find date range for the waitlist scan.
<span class="nc bnc" id="L470" title="All 4 branches missed.">			if (timeoffDay.isBlackOutDay() || timeoffDay.getAllocatedHours() &gt;= 0) {</span>
<span class="nc" id="L471">				timeoffDays[dayOfMonth] = timeoffDay;</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">				if (earliestDate == null) {</span>
<span class="nc" id="L473">					earliestDate = timeOffDate;</span>
				}
<span class="nc" id="L475">				endDate = timeOffDate; //set this everytime there are available hours</span>
			}
		}
<span class="nc" id="L478">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L480">			dmo = new Jdmo();</span>
<span class="nc" id="L481">			MonthRange monthRange = new MonthRange(timeoffMonth, timeoffYear);</span>
			// save the blackoutDays object
<span class="nc" id="L483">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="nc" id="L484">			blackoutDAO.saveBlackoutDays(pTOPoolID, monthRange, blackoutDays);</span>
<span class="nc" id="L485">			CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO(dmo);</span>
			// save time off days
<span class="nc" id="L487">			timeoffCalDAO.saveTimeOffDays(pTOPoolID, monthRange, timeoffDays);</span>
			// audit time off days after the save
<span class="nc" id="L489">			auditTimeOffDays(pTOPoolID, monthRange, timeoffDays);</span>
			//scan should be triggered for end hour of the end date hence adding a day to enddate.
<span class="nc" id="L491">			triggerWaitlistScan(pTOPoolID, earliestDate, new Date(endDate.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG));</span>
<span class="nc" id="L492">		} catch (Exception e) {</span>
<span class="nc" id="L493">			handleException(e);</span>
<span class="nc" id="L494">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L496" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L497">				dmo.cleanUp();</span>
			}
<span class="nc" id="L499">			methodFinish();</span>
<span class="nc" id="L500">		}</span>
<span class="nc" id="L501">	}</span>

	/**
	 * Audit allocated hours for the time off days in the month range for the given pool.
	 * @param toPoolID pool id being audited
	 * @param monthRange start and end day range to audit
	 * @param timeOffDays data for the whole month being audited
	 * @param changedTimeoffDays saved time off allocation hours
	 *
	 */
	private void auditTimeOffDays(ID toPoolID, MonthRange monthRange, CalendarTimeOffDay[] changedTimeoffDays) {
		TOPool toPool;
		try {
<span class="nc" id="L514">			toPool = getTOPool(toPoolID);</span>
<span class="nc" id="L515">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L516">			toPool = new TOPool();</span>
<span class="nc" id="L517">			toPool.setID(toPoolID);</span>
<span class="nc" id="L518">		}</span>

<span class="nc" id="L520">		AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT,</span>
														 AuditTrailEntry.ACTION_TIME_OFF_POOL_HOURSALLOCATION,
<span class="nc" id="L522">														 toPool.getId(), toPool.getName(), monthRange.startDate,</span>
														 monthRange.endDate);
		try {
<span class="nc" id="L525">			String notifyType = TONotifyMessage.getNotifyString(TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE);</span>

<span class="nc" id="L527">			Organization toPoolOrg = CacheUtilBBM.getOrganizationByID(toPool.getOrganizationId());</span>
<span class="nc" id="L528">			String toAllocationCalendar = TOCalendarUtil.getTOAllocationCalendarForTimeOffDays(toPoolID, toPoolOrg, changedTimeoffDays,</span>
					new TimeRange(monthRange.startDate, monthRange.endDate));

<span class="nc" id="L531">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TIMEOFF_POOL, toAllocationCalendar, notifyType, false);</span>
<span class="nc" id="L532">			m_auditManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L533">		} catch (Exception e) {</span>
<span class="nc" id="L534">			m_cat.debug(&quot;unable to audit allocation hours changes for time off pool with id: &quot; + toPool.getId()</span>
<span class="nc" id="L535">					+ &quot; because of exception : &quot; + e.getMessage());</span>
<span class="nc" id="L536">		}</span>
<span class="nc" id="L537">	}</span>

	public void triggerWaitlistScan(ID pTOPoolID, Date startDate, Date endDate) throws BbmUpdateException {
<span class="nc" id="L540">		TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_TOPOOL_ALLOCATED_HRS_CHANGE);</span>
<span class="nc" id="L541">		msg.setTOPoolId(pTOPoolID);</span>
<span class="nc" id="L542">		msg.setStartDate(startDate);</span>
<span class="nc" id="L543">		msg.setEndDate(endDate);</span>
<span class="nc" id="L544">		msg.sendMessage();</span>
<span class="nc" id="L545">	}</span>

	public TOPool getTOPool(ID toPoolID) throws BbmFinderException {
<span class="nc bnc" id="L548" title="All 2 branches missed.">		if(toPoolID==null){</span>
<span class="nc" id="L549">			return null;</span>
		}
<span class="nc" id="L551">		TOPoolDAO toPoolDAO = null;</span>
<span class="nc" id="L552">		TOPool toPool = null;</span>
		try {
<span class="nc" id="L554">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L555">			toPool = (TOPool) toPoolDAO.getObjectByID(toPoolID);</span>
<span class="nc" id="L556">		} catch (Exception e) {</span>
<span class="nc" id="L557">			handleException(e);</span>
<span class="nc" id="L558">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L560" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L561">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L564">		return toPool;</span>
	}

	public Collection&lt;TOPool&gt; getTOPoolsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if (RmUtil.isCollectionNullOrEmpty(ids)) {</span>
<span class="nc" id="L569">			return Collections.emptyList();</span>
		}

<span class="nc" id="L572">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L574">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L575">			return toPoolDAO.getTOPoolsByIDs(ids);</span>
<span class="nc" id="L576">		} catch (Exception e) {</span>
<span class="nc" id="L577">			handleException(e);</span>
<span class="nc" id="L578">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L580" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L581">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public ID createTOPool(TOPool toPool) throws BbmFinderException {
<span class="nc" id="L587">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L589">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L590">			return toPoolDAO.createObject(toPool);</span>
<span class="nc" id="L591">		} catch (Exception e) {</span>
<span class="nc" id="L592">			handleException(e);</span>
<span class="nc" id="L593">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L595" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L596">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public void updateTOPool(TOPool toPool) throws BbmFinderException {
<span class="nc" id="L602">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L604">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L605">			toPoolDAO.updateObject(toPool);</span>
<span class="nc" id="L606">		} catch (Exception e) {</span>
<span class="nc" id="L607">			handleException(e);</span>
<span class="nc" id="L608">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L610" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L611">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L614">	}</span>

	public void deleteTOPool(ID toPoolID) throws BbmUpdateException {
<span class="nc" id="L617">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L619">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L620">			toPoolDAO.deleteObject(toPoolID);</span>
<span class="nc" id="L621">		} catch (Exception e) {</span>
<span class="nc" id="L622">			handleException(e);</span>
		} finally {
<span class="nc bnc" id="L624" title="All 6 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L625">				toPoolDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L628">	}</span>

	public Collection&lt;TOPool&gt; getTOPoolsForOrg(ID orgID, boolean inclParentOrgs) throws BbmFinderException {
<span class="nc" id="L631">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L633">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L634">			return toPoolDAO.getTOPoolsForOrg(orgID, inclParentOrgs);</span>
<span class="nc" id="L635">		} catch (Exception e) {</span>
<span class="nc" id="L636">			handleException(e);</span>
<span class="nc" id="L637">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L639" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L640">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public List&lt;EmpTOPoolAssignment&gt; getWorkResourceAssignmentsForTOPool(ID toPoolID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L646">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L648">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L649">			return dao.getValidEmpTOPoolAssignmentsByPool(toPoolID, null, dtStart, dtEnd, false);</span>
<span class="nc" id="L650">		} catch (Exception e) {</span>
<span class="nc" id="L651">			handleException(e);</span>
<span class="nc" id="L652">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L654" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L655">				dao.cleanUp();</span>
			}
		}
	}

	public Collection&lt;ID&gt; getEmployeeIDsForTOPool(ID toPoolID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L661">		Collection col = getWorkResourceAssignmentsForTOPool(toPoolID, dtStart, dtEnd);</span>
<span class="nc" id="L662">		return ValueObjectUtil.getFieldObjectCol(EmpTOPoolAssignmentFieldInfo.EMPTOPOOL_WORKRESOURCEID, col);</span>
	}
	
	
	// Get the default (activity = null) TOPool for one emp.
	// Return may be null
	public EmpTOPoolAssignment getDefaultEmpTOPoolAssignment(ID empID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L669">		List&lt;EmpTOPoolAssignment&gt; list = getDefaultEmpTOPoolAssignments(empID, dtStart, dtEnd);</span>
<span class="nc bnc" id="L670" title="All 4 branches missed.">		if (list != null &amp;&amp; !list.isEmpty()) {</span>
<span class="nc" id="L671">			return list.get(0);</span>
		} else {
<span class="nc" id="L673">			return null;</span>
		}
	}
	
	
	
	
	
	
	// JT. For backward compatibility.
	// This will return only the list of default (activity = null) TOPools for one emp.
	public Collection getValidEmpTOPoolAssignments(ID empID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L685">		return getDefaultEmpTOPoolAssignments(empID, dtStart, dtEnd);</span>
	}
	
	// Get the list of defaul (activity = null) TOPools for one emp.
	public List&lt;EmpTOPoolAssignment&gt; getDefaultEmpTOPoolAssignments(ID empID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L690">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L692">			dao = new EmpTOPoolAssignmentDAO();</span>
			// We want only the defaults.
<span class="nc" id="L694">			return dao.getValidEmpTOPoolAssignments(Collections.singleton(empID), dtStart, dtEnd, false, true);</span>
<span class="nc" id="L695">		} catch (Exception e) {</span>
<span class="nc" id="L696">			handleException(e);</span>
<span class="nc" id="L697">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L699" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L700">				dao.cleanUp();</span>
			}
		}
	}
	
	
	
	// Get a list of TOPool by TOPool Activity for one emp. If none, return the default (activity = null)
	public List&lt;EmpTOPoolAssignment&gt; getEmpTOPoolAssignmentsByPoolID(ID toPoolID, ID empID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L710">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L712">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L713">			return dao.getValidEmpTOPoolAssignmentsByPool(toPoolID, Collections.singleton(empID), dtStart, dtEnd, false);</span>
<span class="nc" id="L714">		} catch (Exception e) {</span>
<span class="nc" id="L715">			handleException(e);</span>
<span class="nc" id="L716">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L718" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L719">				dao.cleanUp();</span>
			}
		}
	}
	
	// Get all pools (default and activity) for employee
		// Get a list of TOPool by activity for one emp. If none, return the default
		// (activity = null)
		public List&lt;EmpTOPoolAssignment&gt; getAllEmpTOPoolAssignments(ID empID,
				Date dtStart, Date dtEnd, ID activityID) throws BbmFinderException {
<span class="nc" id="L729">			EmpTOPoolAssignmentDAO dao = null;</span>
			try {
<span class="nc" id="L731">				dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L732">				List&lt;EmpTOPoolAssignment&gt; list = dao.getValidEmpTOPoolAssignments(Collections.singleton(empID), dtStart, dtEnd, false, false);</span>
<span class="nc" id="L733">				return TOPoolUtil.filterEmpTOPoolAssignmentsForActivityAndDefault(list, activityID);</span>
<span class="nc" id="L734">			} catch (Exception e) {</span>
<span class="nc" id="L735">				handleException(e);</span>
<span class="nc" id="L736">				throw new BbmFinderException(e);</span>
			} finally {
<span class="nc bnc" id="L738" title="All 4 branches missed.">				if (dao != null) {</span>
<span class="nc" id="L739">					dao.cleanUp();</span>
				}
			}
		}
	
	// Get a list of TOPool by activity for one emp. If none, return the default (activity = null)
	public List&lt;EmpTOPoolAssignment&gt; getEmpTOPoolAssignmentsByActivity(ID empID, Date dtStart, Date dtEnd, ID activityID)
			throws BbmFinderException {
<span class="nc" id="L747">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L749">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L750">			List&lt;EmpTOPoolAssignment&gt; list = dao.getValidEmpTOPoolAssignments(Collections.singleton(empID), dtStart, dtEnd, false, false);</span>
			// Filter out the other activities OR return the default null activity
<span class="nc" id="L752">			return TOPoolUtil.filterEmpTOPoolAssignmentsForActivity(list, activityID);</span>
<span class="nc" id="L753">		} catch (Exception e) {</span>
<span class="nc" id="L754">			handleException(e);</span>
<span class="nc" id="L755">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L757" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L758">				dao.cleanUp();</span>
			}
		}
	}
	
	// Get the TOPool by activity for one emp. If none, return the default (activity = null)
	// Return may be null
	public EmpTOPoolAssignment getEmpTOPoolAssignmentByActivity(ID empID, Date dtStart, Date dtEnd, ID activityID)
			throws BbmFinderException {
<span class="nc" id="L767">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L769">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L770">			List&lt;EmpTOPoolAssignment&gt; list = dao.getValidEmpTOPoolAssignments(Collections.singleton(empID), dtStart, dtEnd, false, false);</span>
			// Filter out the other activities OR return the default null activity
<span class="nc" id="L772">			List&lt;EmpTOPoolAssignment&gt; filteredList = TOPoolUtil.filterEmpTOPoolAssignmentsForActivity(list, activityID);</span>
<span class="nc bnc" id="L773" title="All 4 branches missed.">			if (filteredList != null &amp;&amp; !filteredList.isEmpty()) {</span>
<span class="nc" id="L774">				return filteredList.get(0);</span>
			} else {
<span class="nc" id="L776">				return null;</span>
			}

<span class="nc" id="L779">		} catch (Exception e) {</span>
<span class="nc" id="L780">			handleException(e);</span>
<span class="nc" id="L781">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L783" title="All 6 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L784">				dao.cleanUp();</span>
			}
		}
	}

	
	
	/*
	 * Get the reference schedule assignments for the given employees for the specified time instance.
	 * Note that since this for one specific instance of time each employee will have only one assignment.
	 */
	public Map&lt;ID, EmployeeReferenceScheduleAssignment&gt; getReferenceScheduleForWorkResources(Collection&lt;ID&gt; employeeIds, Date dt)
			throws BbmFinderException {
<span class="nc" id="L797">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L799">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L800">			List&lt;EmployeeReferenceScheduleAssignment&gt; list = dao.getValidAssignments(employeeIds, dt);</span>
<span class="nc" id="L801">			Map&lt;ID, EmployeeReferenceScheduleAssignment&gt; map = new HashMap&lt;ID, EmployeeReferenceScheduleAssignment&gt;();</span>
<span class="nc bnc" id="L802" title="All 2 branches missed.">			for (EmployeeReferenceScheduleAssignment refSch : list) {</span>
<span class="nc" id="L803">				map.put(refSch.getWorkResourceID(), refSch);</span>
<span class="nc" id="L804">			}</span>
<span class="nc" id="L805">			return map;</span>
<span class="nc" id="L806">		} catch (Exception e) {</span>
<span class="nc" id="L807">			handleException(e);</span>
<span class="nc" id="L808">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L810" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L811">				dao.cleanUp();</span>
			}
		}
	}

	public List&lt;EmployeeReferenceScheduleAssignment&gt; getValidReferenceScheduleAssignments(Collection&lt;ID&gt; employeeIds, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="nc" id="L818">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L820">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L821">			return dao.getValidAssignments(employeeIds, dtStart, dtEnd);</span>
<span class="nc" id="L822">		} catch (Exception e) {</span>
<span class="nc" id="L823">			handleException(e);</span>
<span class="nc" id="L824">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L826" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L827">				dao.cleanUp();</span>
			}
		}
	}

	public List&lt;EmployeeReferenceScheduleAssignment&gt; getFillerAssignments(Collection&lt;ID&gt; employeeIds, Date viewDate)
			throws BbmFinderException {
<span class="nc" id="L834">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L836">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L837">			return dao.getFillerAssignments(employeeIds, viewDate);</span>
<span class="nc" id="L838">		} catch (Exception e) {</span>
<span class="nc" id="L839">			handleException(e);</span>
<span class="nc" id="L840">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L842" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L843">				dao.cleanUp();</span>
			}
		}
	}

	public boolean hasAtLeastOneCommonSchedulingPeriod(Collection&lt;ID&gt; employeeIds) throws BbmFinderException {

<span class="nc bnc" id="L850" title="All 4 branches missed.">		if (employeeIds == null || employeeIds.isEmpty()) {</span>
<span class="nc" id="L851">			return false;</span>
		}

<span class="nc" id="L854">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L856">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L857">			List&lt;ID&gt; commondIds = dao.getCommonSchedulingPeriodDEIDs(employeeIds, 1);</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">			return !commondIds.isEmpty();</span>
<span class="nc" id="L859">		} catch (Exception e) {</span>
<span class="nc" id="L860">			handleException(e);</span>
<span class="nc" id="L861">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L863" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L864">				dao.cleanUp();</span>
			}
		}
	}

	public void updateEmployeeReferenceScheduleEffectivity(Collection&lt;ID&gt; empIDs, Date asOfDate,
			EmployeeReferenceScheduleAssignmentUpdateParameters update) throws BbmFinderException {

<span class="nc" id="L872">		EmployeeReferenceScheduleAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L874">			dao = new EmployeeReferenceScheduleAssignmentDAO();</span>
<span class="nc" id="L875">			dao.updateEmployeeReferenceScheduleEffectivity(empIDs, asOfDate, update);</span>

<span class="nc" id="L877">			TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_REF_SCHEDULE_CHANGE);</span>
<span class="nc" id="L878">			msg.setEmployeeIDs(empIDs);</span>
<span class="nc" id="L879">			msg.setStartDate(asOfDate);</span>
<span class="nc" id="L880">			msg.sendMessage();</span>

<span class="nc" id="L882">		} catch (Exception e) {</span>
<span class="nc" id="L883">			handleException(e);</span>
<span class="nc" id="L884">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L886" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L887">				dao.cleanUp();</span>
			}
		}

<span class="nc" id="L891">	}</span>

	/**
	 * Gets the time off calendar data configured for all days
	 * in the given range, inclusive
	 *
	 * @param empIDs  a collection of employee ids
	 * @param dtStart - beginning of the range
	 * @param dtEnd   - end of the range
	 * @return a hashmap of (employeeid, EmpTOPoolAssignment Collection) pairs
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; getTOPoolsForWorkResources(Collection empIDs, Date dtStart, Date dtEnd) throws BbmFinderException {//NOSONAR
<span class="nc" id="L905">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L907">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L908">			return (HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt;) dao.getTOPoolsForEmployees(empIDs, dtStart, dtEnd);</span>
<span class="nc" id="L909">		} catch (Exception e) {</span>
<span class="nc" id="L910">			handleException(e);</span>
<span class="nc" id="L911">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L913" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L914">				dao.cleanUp();</span>
			}
		}
	}

	/**
	 * @param colEmployeeIDs a collection of employee ids
	 * @param dtNow:         a given time in GMT
	 * @return a hashmap of (employeeid, TOPool) pairs
	 */
	public HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; getEmployeesTOPoolsAsOfDate(Collection colEmployeeIDs, Date dtNow) throws BbmFinderException {//NOSONAR
<span class="nc" id="L925">		return getTOPoolsForWorkResources(colEmployeeIDs, dtNow, dtNow);</span>
	}

	/**
	 * Update an empoyee's Time Off Pool effective dates.
	 * @param empID        - ID of the employee
	 * @param asOfDate     - The date which we will use to get all of the employee pool set.
	 * @param newTOPoolID  - The ID of the Time Off Pool that you want to assign the given employee(s) to. Must never be null.
	 * @param newStartDate - The start date of the time off pool assignment. Can be a Date object, ValueObjectBase.NullObject, or null.
	 * 					  		a date will change the value in the database to that date
	 * 							null or a ValueObjectBase.NullObject will leave the value unchanged in the database
	 * @param newEndDate   - The end date of the time off pool assignment. Can be a Date object, ValueObjectBase.NullObject, or null.
	 * 					  		a date will change the value in the database to that date
	 * 							a ValueObjectBase.NullObject will change the value to null in the database
	 * 							null will leave the value unchanged in the database.
	 */
	public void updateEmployeeTimeOffPoolEffectivity(Collection empIDs, Date asOfDate, Object newTOPoolID, Object startDate, Object endDate)
			throws BbmFinderException {
<span class="nc" id="L943">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L945">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L946">			Date minStartDate = null;</span>
<span class="nc" id="L947">			Date maxEndDate = null;</span>
<span class="nc" id="L948">			LinkedHashSet pTOPoolSet = new LinkedHashSet();</span>
<span class="nc" id="L949">			pTOPoolSet.addAll(getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate));</span>
<span class="nc bnc" id="L950" title="All 2 branches missed.">			for (Iterator iterator = empIDs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L951">				ID empID = (ID) iterator.next();</span>
<span class="nc" id="L952">				EmpTOPoolAssignment newPoolAssign = new EmpTOPoolAssignment();</span>
<span class="nc" id="L953">				Employee emp = BbmManagerFactory.getWorkResourceManager().getEmployeeByID(empID, asOfDate,</span>
						Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);
<span class="nc" id="L955">				Date hireDate = emp.getStartTime();</span>
<span class="nc" id="L956">				Date fireDate = emp.getEndTime();</span>

<span class="nc" id="L958">				Object newStartDate = startDate;</span>
<span class="nc" id="L959">				Object newEndDate = endDate;</span>
<span class="nc" id="L960">				boolean bEndDateNoChange = false; //true menas that we should keep the current assignment's end date unchanged in the database</span>

<span class="nc bnc" id="L962" title="All 6 branches missed.">				if ((newStartDate != null) &amp;&amp; (newStartDate instanceof Date) &amp;&amp; (hireDate != null)</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">						&amp;&amp; ((Date) newStartDate).before(hireDate)) {</span>
<span class="nc" id="L964">					newStartDate = hireDate;</span>
				}

<span class="nc bnc" id="L967" title="All 2 branches missed.">				if (newEndDate == null) {</span>
<span class="nc" id="L968">					bEndDateNoChange = true;</span>
				} else {
<span class="nc bnc" id="L970" title="All 6 branches missed.">					if ((newEndDate instanceof Date) &amp;&amp; (fireDate != null) &amp;&amp; ((Date) newEndDate).after(fireDate)) {</span>
<span class="nc" id="L971">						newEndDate = fireDate;</span>
<span class="nc bnc" id="L972" title="All 2 branches missed.">					} else if (newEndDate instanceof NullObject) {</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">						if (fireDate != null) {</span>
<span class="nc" id="L974">							newEndDate = fireDate;</span>
						} else {
<span class="nc" id="L976">							newEndDate = null;</span>
						}
					}
				}

				//need to find this employee's pool assignment (if any) on the asOfDate.
				// JT: Assume default for now.
<span class="nc" id="L983">				EmpTOPoolAssignment assignment = getDefaultEmpTOPoolAssignment(empID, asOfDate, asOfDate);</span>
<span class="nc bnc" id="L984" title="All 2 branches missed.">				if (assignment != null) {</span>

<span class="nc" id="L986">					newPoolAssign = assignment;</span>

<span class="nc bnc" id="L988" title="All 4 branches missed.">					if (newStartDate == null || (newStartDate instanceof NullObject)) {</span>
<span class="nc" id="L989">						newStartDate = newPoolAssign.getStartTime(); //We want to use the current assignment's start date</span>
					}

<span class="nc bnc" id="L992" title="All 2 branches missed.">					if (bEndDateNoChange) {</span>
<span class="nc" id="L993">						newEndDate = newPoolAssign.getEndTime(); //We want to use the current assignment's end date</span>
					}

				} else {
					//no pool assignment found
<span class="nc bnc" id="L998" title="All 4 branches missed.">					if ((newStartDate == null) || (newStartDate instanceof NullObject)) {</span>
						//We want to use the current assignment's start date

						//get the previous pool assignment (if any) before the asOfDate. The previous assignment's endDate will be the new assignment's startDate.
<span class="nc" id="L1002">						Date prevPoolEnd = dao.getPreviousPoolAssignmentEnd(empID, asOfDate);</span>
<span class="nc bnc" id="L1003" title="All 2 branches missed.">						if (prevPoolEnd != null) {</span>
<span class="nc" id="L1004">							newStartDate = prevPoolEnd;</span>
						} else {
							//there was no previous pool assignment. Use the employee's hire date.
<span class="nc" id="L1007">							newStartDate = hireDate;</span>
						}
					}

<span class="nc bnc" id="L1011" title="All 2 branches missed.">					if (bEndDateNoChange) {</span>
						//We want to use the current assignment's end date

						//get the next pool assignment (if any) after the asOfDate. The next assignment's startDate will be the new assignment's endDate.
<span class="nc" id="L1015">						Date nextPoolStart = dao.getNextPoolAssignmentStart(empID, asOfDate);</span>
<span class="nc bnc" id="L1016" title="All 2 branches missed.">						if (nextPoolStart != null) {</span>
<span class="nc" id="L1017">							newEndDate = nextPoolStart;</span>
						} else {
							//there is no next pool assignment. Use the employee's fire date.
<span class="nc" id="L1020">							newEndDate = fireDate;</span>
						}
					}
				}

				//update/create the time off pool assignment in the database
<span class="nc" id="L1026">				newPoolAssign.setStartTime((Date) newStartDate);</span>
<span class="nc" id="L1027">				newPoolAssign.setEndTime((Date) newEndDate);</span>
<span class="nc" id="L1028">				newPoolAssign.setTOPoolID((ID) newTOPoolID);</span>
<span class="nc" id="L1029">				newPoolAssign.setWorkResourceID(empID);</span>
<span class="nc" id="L1030">				dao.merge(newPoolAssign);</span>
<span class="nc" id="L1031">				dao.updateNoOverlapAssignment(newPoolAssign, EmpTOPoolAssignmentFieldInfo.EMPTOPOOL_WORKRESOURCEID, -1);</span>

				//store the min/max dates for the TONotifyMessage
<span class="nc bnc" id="L1034" title="All 2 branches missed.">				minStartDate = (minStartDate == null) ? (Date) newStartDate : minDate(minStartDate, (Date) newStartDate);</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">				if (newEndDate != null) {</span>
<span class="nc bnc" id="L1036" title="All 2 branches missed.">					maxEndDate = (maxEndDate == null) ? (Date) newEndDate : maxDate(maxEndDate, (Date) newEndDate);</span>
				}
<span class="nc" id="L1038">			}</span>

			//prepare and send a TONotifyMessage
<span class="nc" id="L1041">			pTOPoolSet.addAll(getTOPoolsForEmployees(empIDs, minStartDate, maxEndDate));</span>
<span class="nc" id="L1042">			pTOPoolSet.add(getTOPool((ID) newTOPoolID));</span>
<span class="nc" id="L1043">			TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_EMP_TOPOOL_CHANGE);</span>
<span class="nc" id="L1044">			msg.setObject(pTOPoolSet);</span>
<span class="nc" id="L1045">			msg.setEmployeeIDs(empIDs);</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">			msg.setStartDate(minStartDate == null ? asOfDate : minStartDate);</span>
<span class="nc" id="L1047">			msg.setEndDate(maxEndDate);</span>
<span class="nc" id="L1048">			msg.sendMessage();</span>

<span class="nc" id="L1050">		} catch (Exception e) {</span>
<span class="nc" id="L1051">			handleException(e);</span>
<span class="nc" id="L1052">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1054" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1055">				dao.cleanUp();</span>
			}
		}
<span class="nc" id="L1058">	}</span>

	private Date minDate(Date d1, Date d2) {
<span class="nc bnc" id="L1061" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L1062">			return d2;</span>
		}
<span class="nc bnc" id="L1064" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L1065">			return d1;</span>
		}
<span class="nc bnc" id="L1067" title="All 2 branches missed.">		if (d1.before(d2)) {</span>
<span class="nc" id="L1068">			return d1;</span>
		}
<span class="nc" id="L1070">		return d2;</span>
	}

	private Date maxDate(Date d1, Date d2) {
<span class="nc bnc" id="L1074" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L1075">			return d2;</span>
		}
<span class="nc bnc" id="L1077" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L1078">			return d1;</span>
		}
<span class="nc bnc" id="L1080" title="All 2 branches missed.">		if (d1.before(d2)) {</span>
<span class="nc" id="L1081">			return d2;</span>
		}
<span class="nc" id="L1083">		return d1;</span>
	}

	public Collection&lt;ID&gt; getOrgIDsUnderTOPool(ID pTOPoolID) throws BbmFinderException {
<span class="nc" id="L1087">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1089">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1090">			return toPoolDAO.getOrgIDsUnderTOPool(pTOPoolID);</span>
<span class="nc" id="L1091">		} catch (Exception e) {</span>
<span class="nc" id="L1092">			handleException(e);</span>
<span class="nc" id="L1093">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1095" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1096">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	public Collection&lt;TOPool&gt; getTOPoolsForEmployees(Collection&lt;ID&gt; empIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L1102">		EmpTOPoolAssignmentDAO dao = null;</span>
<span class="nc" id="L1103">		TOPoolDAO toPoolDAO = null;</span>
<span class="nc" id="L1104">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1106">			dao = new EmpTOPoolAssignmentDAO(jdmo);</span>
<span class="nc" id="L1107">			toPoolDAO = new TOPoolDAO(jdmo);</span>
<span class="nc" id="L1108">			Set&lt;ID&gt; toPoolIDSet = dao.getTOPoolIDSetForEmployees(empIDs, dtStart, dtEnd);</span>
<span class="nc" id="L1109">			return toPoolDAO.getObjectsByIDs(toPoolIDSet);</span>
<span class="nc" id="L1110">		} catch (Exception e) {</span>
<span class="nc" id="L1111">			handleException(e);</span>
<span class="nc" id="L1112">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1114" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1115">				jdmo.cleanUp();</span>
			}
		}
	}

	public Collection&lt;TOPool&gt; getTOPoolsForOrgIDs(Collection&lt;ID&gt; orgIDs) throws BbmFinderException {
<span class="nc" id="L1121">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1123">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1124">			return toPoolDAO.getTOPoolsForOrgIDs(orgIDs);</span>
<span class="nc" id="L1125">		} catch (Exception e) {</span>
<span class="nc" id="L1126">			handleException(e);</span>
<span class="nc" id="L1127">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1129" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1130">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Returns collection of all TOPools in the system. Couldn't be simpler.
	 * @return Returns collection of TOPools
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *          if error occurs while reading from DB
	 */
	public Collection&lt;TOPool&gt; getAllTOPools() throws BbmFinderException {
<span class="nc" id="L1142">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1144">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1145">			return toPoolDAO.getAllTOPools();</span>
<span class="nc" id="L1146">		} catch (Exception e) {</span>
<span class="nc" id="L1147">			handleException(e);</span>
<span class="nc" id="L1148">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1150" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1151">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * get TOPool ids given their names
	 *
	 * @param setTOPoolNames a hashset of organization names
	 * @return a HashMap of (TOPoolName, TOPoolID) pairs
	 */
	public HashMap getTOPoolIDsByNames(HashSet setTOPoolNames) throws BbmFinderException {
<span class="nc" id="L1163">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1165">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1166">			return toPoolDAO.getTOPoolIDsByNames(setTOPoolNames);</span>
<span class="nc" id="L1167">		} catch (Exception e) {</span>
<span class="nc" id="L1168">			handleException(e);</span>
<span class="nc" id="L1169">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1171" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1172">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Return the end date of the last pool assignment after asOfDate for the empID.
	 * @param empID    - The employee ID that we need to find the previous pool assignment for.
	 * @param asOfDate - The date that the pool assignment must occur before.
	 * @return
	 */
	public Date getPreviousPoolAssignmentEnd(ID empID, Date asOfDate) throws BbmFinderException {
<span class="nc" id="L1184">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L1186">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L1187">			return dao.getPreviousPoolAssignmentEnd(empID, asOfDate);</span>
<span class="nc" id="L1188">		} catch (Exception e) {</span>
<span class="nc" id="L1189">			handleException(e);</span>
<span class="nc" id="L1190">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1192" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1193">				dao.cleanUp();</span>
			}
		}
	}

	/**
	 * Return the start date of the next pool assignment after asOfDate for the empID.
	 * @param empID    - The employee ID that we need to find the next pool assignment for.
	 * @param asOfDate - The date that the pool assignment must occur after.
	 * @return
	 */
	public Date getNextPoolAssignmentStart(ID empID, Date asOfDate) throws BbmFinderException {
<span class="nc" id="L1205">		EmpTOPoolAssignmentDAO dao = null;</span>
		try {
<span class="nc" id="L1207">			dao = new EmpTOPoolAssignmentDAO();</span>
<span class="nc" id="L1208">			return dao.getNextPoolAssignmentStart(empID, asOfDate);</span>
<span class="nc" id="L1209">		} catch (Exception e) {</span>
<span class="nc" id="L1210">			handleException(e);</span>
<span class="nc" id="L1211">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1213" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1214">				dao.cleanUp();</span>
			}
		}
	}

	public Collection&lt;ID&gt; getTOPoolIDsWithWaitListScanEnabled() throws BbmFinderException {
<span class="nc" id="L1220">		TOPoolDAO toPoolDAO = null;</span>
		try {
<span class="nc" id="L1222">			toPoolDAO = new TOPoolDAO();</span>
<span class="nc" id="L1223">			return toPoolDAO.getTOPoolIDsWithWaitListScanEnabled();</span>
<span class="nc" id="L1224">		} catch (Exception e) {</span>
<span class="nc" id="L1225">			handleException(e);</span>
<span class="nc" id="L1226">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1228" title="All 4 branches missed.">			if (toPoolDAO != null) {</span>
<span class="nc" id="L1229">				toPoolDAO.cleanUp();</span>
			}
		}
	}

	/**
	 * Gets the time of interval calendar for the administrator.
	 */
	public TOIntervalCalendar getTOIntervalCalendarForAdmin(Organization org, ID toPoolID, int year, int month) throws BbmFinderException {
<span class="nc" id="L1238">		return TOIntervalCalendarUtil.getTOIntervalCalendarForAdmin(org, toPoolID, year, month);</span>
	}

	/**
	 * Gets a collection of intervals within the Time off pool over the time range.
	 *
	 * @param timeOffPoolID
	 *            The TOP ID.
	 * @param startDate
	 *            The start of the range.
	 * @param endDate
	 *            The exclusive end of the range.
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Collection&lt;TOIntervalAllocation&gt; getTimeOffIntervals(ID timeOffPoolID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L1255">		methodStart(&quot;getTimeOffIntervals&quot;, timeOffPoolID, startDate, endDate);</span>

<span class="nc" id="L1257">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1259">			dmo = new Jdmo();</span>
<span class="nc" id="L1260">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1261">			return timeoffCalDAO.find(timeOffPoolID, startDate, endDate);</span>
<span class="nc" id="L1262">		} catch (Exception e) {</span>
<span class="nc" id="L1263">			handleException(e);</span>
<span class="nc" id="L1264">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1266" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1267">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1269">			methodFinish();</span>
		}
	}

	/**
	 * Get the intervals for the given entity (Employee or TOP) over the specified date range.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 *
	 * @param employeeID
	 *            If specified, intervals for the employee will be returned based on the employee's TOP assignments.
	 *            All values will be returned.
	 * @param toPoolID
	 *            If specified, the TOP intervals will be returned with allocated, approved, and pending.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @param activityID
	 * 			Activity ID for multipool fetch
	 *            
	 * @return
	 * @throws BbmFinderException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByInterval(ID employeeID, ID toPoolID, Date startTime, Date endTime, ID activityID)
			throws BbmFinderException {
<span class="nc" id="L1294">		methodStart(&quot;getApprovedAndPendingByInterval&quot;, employeeID, toPoolID, startTime, endTime);</span>

<span class="nc" id="L1296">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1298">			dmo = new Jdmo();</span>
<span class="nc" id="L1299">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1300">			return timeoffCalDAO.getApprovedAndPendingByInterval(employeeID, toPoolID, startTime, endTime, activityID);</span>
<span class="nc" id="L1301">		} catch (Exception e) {</span>
<span class="nc" id="L1302">			handleException(e);</span>
<span class="nc" id="L1303">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1305" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1306">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1308">			methodFinish();</span>
		}
	}

	/**
	 * Get the intervals for the Organization over the specified date range with the pending and approved minutes.
	 * The sproc should return a continuous set of intervals without any gaps or overlap.
	 *
	 * @param organizationID
	 *            The organization's ID.
	 * @param start
	 *            Inclusive start time.
	 * @param end
	 *            Exclusive end time.
	 * @return
	 * @throws BbmFinderException
	 */
	public List&lt;TOIntervalApprovedAndPending&gt; getApprovedAndPendingByIntervalForOrg(ID organizationID, Date startTime, Date endTime)
			throws BbmFinderException {
<span class="nc" id="L1327">		methodStart(&quot;getApprovedAndPendingByIntervalForOrg&quot;, organizationID, startTime, endTime);</span>

<span class="nc" id="L1329">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1331">			dmo = new Jdmo();</span>
<span class="nc" id="L1332">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
<span class="nc" id="L1333">			return timeoffCalDAO.getApprovedAndPendingByIntervalForOrg(organizationID, startTime, endTime);</span>
<span class="nc" id="L1334">		} catch (Exception e) {</span>
<span class="nc" id="L1335">			handleException(e);</span>
<span class="nc" id="L1336">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1338" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1339">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1341">			methodFinish();</span>
		}
	}

	/**
	 * Save the time off interval calendar data. All the data must be for a single month.
	 *
	 * @param hTimeOffIntervals - HashMap of all time off intervals per day, key is the short date, values is all intervals of that day
	 * @param pTOPoolID    - ID for the Time-Off Pool.
	 * @param tz -Organization TimeZone
	 * @throws BbmFinderException, RemoteException
	 */

	public int[] saveCalendarTimeOffIntervals(Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals, ID pTOPoolID, TimeZone tz)
			throws BbmCreateDuplicateKeyException, BbmRemoveException, BbmUpdateException {
<span class="nc" id="L1356">		final String l_MethodName = &quot;saveCalendarTimeOffIntervals&quot;;</span>
<span class="nc" id="L1357">		methodStart(l_MethodName, hTimeOffIntervals, pTOPoolID, tz);</span>
<span class="nc" id="L1358">		int[] result = { 0, 0, 0 };</span>
<span class="nc" id="L1359">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1361">			dmo = new Jdmo();</span>
<span class="nc" id="L1362">			TOIntervalAllocationDAO timeoffCalDAO = new TOIntervalAllocationDAO(dmo);</span>
			// save time off intervals
<span class="nc" id="L1364">			result = timeoffCalDAO.saveTimeOffIntervals(pTOPoolID, hTimeOffIntervals, tz);</span>
			// audit time off intervals after the save
			//may be in the FUTURE as time off days
<span class="nc" id="L1367">			triggerWaitlistScan(pTOPoolID, hTimeOffIntervals);</span>
<span class="nc" id="L1368">			return result;</span>
<span class="nc" id="L1369">		} catch (BbmCreateDuplicateKeyException e) {</span>
<span class="nc" id="L1370">			throw e;</span>
<span class="nc" id="L1371">		} catch (Exception e) {</span>
<span class="nc" id="L1372">			handleException(e);</span>
<span class="nc" id="L1373">			m_cat.debug(&quot; Debug for saveCalendarTimeOffIntervals= &quot; + e.toString());</span>
<span class="nc" id="L1374">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1376" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1377">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1379">			methodFinish();</span>
		}
	}

	/**
	 * Saves the Time-off interval calendar data.
	 */
	public void saveTimeOffIntervalCalendar(Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals, ID pTOPoolID, TimeZone tz,
			MonthRange monthRange, BlackoutDay[] blackoutDays) throws BbmUpdateException {
<span class="nc" id="L1388">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L1390">			saveCalendarTimeOffIntervals(hTimeOffIntervals, pTOPoolID, tz);</span>

<span class="nc" id="L1392">			dmo = new Jdmo();</span>
<span class="nc" id="L1393">			BlackoutDayDAO blackoutDAO = new BlackoutDayDAO(dmo);</span>
<span class="nc" id="L1394">			blackoutDAO.saveBlackoutDays(pTOPoolID, monthRange, blackoutDays);</span>
<span class="nc" id="L1395">		} catch (Exception e) {</span>
<span class="nc" id="L1396">			handleException(e);</span>
<span class="nc" id="L1397">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1399" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L1400">				dmo.cleanUp();</span>
			}
<span class="nc" id="L1402">			methodFinish();</span>
<span class="nc" id="L1403">		}</span>
<span class="nc" id="L1404">	}</span>

	private void triggerWaitlistScan(ID pTOPoolID, Map&lt;LocalDate, List&lt;TOIntervalAllocation&gt;&gt; hTimeOffIntervals) throws BbmUpdateException {
<span class="nc bnc" id="L1407" title="All 2 branches missed.">		if (hTimeOffIntervals.isEmpty()) {</span>
<span class="nc" id="L1408">			return;</span>
		}
<span class="nc" id="L1410">		Set&lt;LocalDate&gt; keys = hTimeOffIntervals.keySet();</span>
<span class="nc" id="L1411">		LocalDate startDate = keys.iterator().next();</span>
<span class="nc" id="L1412">		LocalDate endDate = startDate;</span>
<span class="nc bnc" id="L1413" title="All 2 branches missed.">		for (LocalDate date : keys) {</span>
<span class="nc bnc" id="L1414" title="All 2 branches missed.">			if (date.before(startDate)) {</span>
<span class="nc" id="L1415">				startDate = date;</span>
			}
<span class="nc bnc" id="L1417" title="All 2 branches missed.">			if (date.after(endDate)) {</span>
<span class="nc" id="L1418">				endDate = date;</span>
			}
<span class="nc" id="L1420">		}</span>
<span class="nc" id="L1421">		endDate.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1422">		triggerWaitlistScan(pTOPoolID, startDate.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)), endDate.getTime(TimeZone.getTimeZone(&quot;GMT&quot;)));</span>
<span class="nc" id="L1423">	}</span>

	public void deleteTimeOffDays(ID toPoolId, Date startDate, Date endDate) throws BbmRemoveException,BbmFinderException
	{
<span class="nc" id="L1427">		final String l_MethodName = &quot;deleteTimeOffDays&quot;;</span>
<span class="nc" id="L1428">		methodStart(l_MethodName, toPoolId, startDate, endDate);</span>
<span class="nc" id="L1429">		CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO();</span>

		try {

<span class="nc" id="L1433">			timeoffCalDAO.deleteCalendarTimeOffDays(toPoolId, startDate, endDate);</span>
<span class="nc" id="L1434">        } catch (Exception e) {</span>
<span class="nc" id="L1435">            handleException(e);</span>
<span class="nc" id="L1436">            throw new BbmRemoveException(e);</span>
        } finally {
<span class="nc" id="L1438">			timeoffCalDAO.cleanUp();</span>
<span class="nc" id="L1439">            methodFinish();</span>
<span class="nc" id="L1440">        }</span>
<span class="nc" id="L1441">    }</span>

    public void createTimeOffDays(Collection calTimeOffDays) throws BbmCreateException {
<span class="nc" id="L1444">        final String l_MethodName = &quot;createTimeOffDays&quot;;</span>
<span class="nc" id="L1445">        methodStart(l_MethodName, calTimeOffDays);</span>
<span class="nc" id="L1446">		CalendarTimeOffDayDAO timeoffCalDAO = new CalendarTimeOffDayDAO();</span>
        try {

<span class="nc" id="L1449">            timeoffCalDAO.createObjects(calTimeOffDays);</span>
<span class="nc" id="L1450">        } catch (Exception e) {</span>
<span class="nc" id="L1451">            handleException(e);</span>
<span class="nc" id="L1452">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L1454">			timeoffCalDAO.cleanUp();</span>
<span class="nc" id="L1455">            methodFinish();</span>

<span class="nc" id="L1457">        }</span>
<span class="nc" id="L1458">    }</span>
    
    
	public void updateTOPoolAssignmentsByActivity(Collection&lt;ID&gt; employeeIDs, Date asOfDate,
			List&lt;TOPoolAssignmentsByActivityUpdateParameters&gt; updateParameters)  {
    	
		
<span class="nc" id="L1465">		TOPoolDAO dao = new TOPoolDAO();</span>
		try {
<span class="nc" id="L1467">			dao.updateTOPoolAssignmentsByActivity(employeeIDs, asOfDate, updateParameters);</span>
		} finally {
<span class="nc" id="L1469">			dao.cleanUp();</span>
<span class="nc" id="L1470">		}</span>
		
		
		
   
<span class="nc" id="L1475">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>