<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeRecordManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timerecord.ejb</a> &gt; <span class="el_source">TimeRecordManagerEJB.java</span></div><h1>TimeRecordManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timerecord.ejb;

import java.rmi.ConnectException;
import java.rmi.RemoteException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.TimeZone;

import com.bluepumpkin.common.cache.Cache;
import com.bluepumpkin.common.cache.CacheFactory;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.*;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.Priority;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.JNDINames;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmTimePeriodOverlapException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeRecordException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateDuplicateKeyException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.paypolicy.ejb.PayPeriodTypeManager;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPeriod;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPolicy;
import com.bluepumpkin.ejb.bbm.payroll.util.RulesTimeSpan;
import com.bluepumpkin.ejb.bbm.payroll.util.StateChange;
import com.bluepumpkin.ejb.bbm.payroll.util.TimeSpanNarrower;
import com.bluepumpkin.ejb.bbm.timerecord.cache.TimeRecordCacheUtil;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeEntrySourceCode;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeInterval;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecordEntry;
import com.bluepumpkin.ejb.bbm.util.DateAdjustmentUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourcePayPolicy;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.User;

/**
 * Title: Blue Pumpkin Software Basic Business Model Description:
 * TimeRecordManager EJB implementation Copyright: Copyright (c) 2001 Company:
 * Blue Pumpkin Software, inc
 * 
 * @author Sheng Song
 * @version 1.0
 */

<span class="nc" id="L85">public class TimeRecordManagerEJB extends SessionEJBBase {</span>
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	// cache reference to other EJBs
	private WorkResourceManager m_WorkResourceManager;
	private UserManager m_UserManager;
	private DBConfigManager m_DBConfigManager;
	private Cache m_TimeRecordCache;
	private Cache m_LastEntryCache;
	private EventAuditTrailManager m_EventAuditTrailManager;
	private ActivityManager m_ActivityManager;

	// Retrieved from DBConfig
<span class="nc" id="L100">	private long AutoCloseTimeoutInMillis = (long) 10 * TimeZoneUtil.HOUR_IN_MILLISECONDS;</span>
	private int m_Overlap;
<span class="nc" id="L102">	private int m_LookBackMinutes = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="nc" id="L103">	private int m_CachedMilliSeconds = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="nc" id="L104">	private boolean m_DebugEnabled = false;</span>
<span class="nc" id="L105">	private long m_LookBackTimeEntryDays = 14 * TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="nc" id="L106">	private boolean m_ResetImmidiateToLastActivity = false;</span>
	// used to ignore data in the future for data filling project
<span class="nc" id="L108">	private static boolean m_ignoreFutureData = false;</span>

	// Used by Cache transition check
<span class="nc" id="L111">	private static boolean LastCheckStatus = true;</span>

	private static final int OVERLAP = 0;
	private static final int LOOKBACK = 1;
	private static final int CACHEDINTV = 2;

	private static final int MILLISECONDS_IN_MINUTE = 1000;
	private static final int MINUTES_IN_HOUR = 60;

<span class="nc" id="L120">	private final static String clsName = TimeRecordManagerEJB.class.getName();</span>
	{
<span class="nc" id="L122">		super.init(clsName);</span>
<span class="nc" id="L123">	}</span>

<span class="nc" id="L125">	private static Category m_cat = Log.initCategory(clsName);</span>

	// override the base class to provide the appropriate logging category
	protected Category getCategory() {
<span class="nc" id="L129">		return m_cat;</span>
	}

	/**
	 * Caching the ejb reference to other EJBs
	 */
	public void onEjbCreate() {
		try {
<span class="nc" id="L137">			m_DBConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L138">			m_Overlap = m_DBConfigManager.getPeriodOverlap();</span>

<span class="nc" id="L140">			String valueStr = m_DBConfigManager.getValue(ConfigKey.RESET_IMMIDIATE_TO_LAST_ACTIVITY);</span>
<span class="nc bnc" id="L141" title="All 4 branches missed.">			if (valueStr != null &amp;&amp; valueStr.equalsIgnoreCase(&quot;true&quot;)) {</span>
<span class="nc" id="L142">				m_ResetImmidiateToLastActivity = true;</span>
			} else {
<span class="nc" id="L144">				m_ResetImmidiateToLastActivity = false;</span>
			}

<span class="nc" id="L147">			String lookBackVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_LOOKBACK_INTERVAL);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			if (lookBackVal != null) {</span>
<span class="nc" id="L149">				m_LookBackMinutes = Integer.parseInt(lookBackVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
<span class="nc" id="L151">			String lookBackTimeEntryVal = m_DBConfigManager.getValue(ConfigKey.TIMEETRIES_LOOKBACK_INTERVAL);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">			if (lookBackTimeEntryVal != null) {</span>
<span class="nc" id="L153">				m_LookBackTimeEntryDays = Integer.parseInt(lookBackTimeEntryVal)</span>
						* TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;
			}
<span class="nc" id="L156">			String autoCloseVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_TIMEOUT);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (autoCloseVal != null) {</span>
<span class="nc" id="L158">				AutoCloseTimeoutInMillis = Long.parseLong(autoCloseVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
<span class="nc" id="L160">			String cacheInt = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">			if (cacheInt != null) {</span>
<span class="nc" id="L162">				m_CachedMilliSeconds = Integer.parseInt(cacheInt) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
			}
			// If cache is enabled at first, instantiate cache
<span class="nc bnc" id="L165" title="All 2 branches missed.">			if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_CACHE_USAGE)) {</span>
<span class="nc" id="L166">				m_TimeRecordCache = CacheFactory.getCache(JNDINames.BBM_TIMERECORDMANAGER_EJBHOME,</span>
<span class="nc" id="L167">						TimeRecordManagerEJB.class.getClassLoader());</span>
			} else {
<span class="nc" id="L169">				LastCheckStatus = false;</span>
			}

<span class="nc" id="L172">			m_ignoreFutureData = m_DBConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA);</span>
<span class="nc" id="L173">			TimeRecordDAO.setIgnoreFutureData(m_ignoreFutureData);</span>

			// Check if last entry cache is needed
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (cacheUsed()</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">					&amp;&amp; ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_LASTENTRYCACHE_USAGE)) {</span>
<span class="nc" id="L178">				m_LastEntryCache = CacheFactory.getCache(TimeRecordManager.TIMEENTRY_CACHE_NAME,</span>
<span class="nc" id="L179">						TimeRecordManagerEJB.class.getClassLoader());</span>
			}
			// Check debug enabled or not
<span class="nc" id="L182">			String debugUsage = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORD_CACHE_DEBUG);</span>
<span class="nc bnc" id="L183" title="All 4 branches missed.">			if (debugUsage != null &amp;&amp; debugUsage.equalsIgnoreCase(&quot;true&quot;))</span>
<span class="nc" id="L184">				m_DebugEnabled = true;</span>
<span class="nc" id="L185">			m_EventAuditTrailManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L186">			m_ActivityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L187">			m_UserManager = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L188">			m_WorkResourceManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L189">		} catch (Exception e) {</span>
<span class="nc" id="L190">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="nc" id="L191">		}</span>
<span class="nc" id="L192">	}</span>

	protected boolean cacheUsed() {
		// If Cache is null, then cache is not used
<span class="nc" id="L196">		boolean currentStatus = false;</span>
<span class="nc bnc" id="L197" title="All 2 branches missed.">		if (!m_ignoreFutureData) { // do not cache for demo mode</span>
			try {
				// If cache is never instantiated, give it a chance to get
				// initialized
				// If ConfigManager is cache aware, then always check it
				// dynamically
<span class="nc bnc" id="L203" title="All 4 branches missed.">				if (m_TimeRecordCache == null || m_DBConfigManager.cacheUsed()) {</span>
					// Access ConfigManager for the cache setting
<span class="nc bnc" id="L205" title="All 2 branches missed.">					if (ConfigCacheUtil.isCacheEnabled(m_DBConfigManager, ConfigKey.TIMERECORD_CACHE_USAGE)) {</span>
						// If Cache is null, initialize it
<span class="nc bnc" id="L207" title="All 2 branches missed.">						if (m_TimeRecordCache == null)</span>
<span class="nc" id="L208">							m_TimeRecordCache = CacheFactory.getCache(JNDINames.BBM_TIMERECORDMANAGER_EJBHOME,</span>
<span class="nc" id="L209">									TimeRecordManagerEJB.class.getClassLoader());</span>
<span class="nc" id="L210">						currentStatus = true;</span>
					} else {
<span class="nc" id="L212">						currentStatus = false;</span>
					}
				} else {
					// Or if m_TimeRecordCache is available, we think cache is
					// enabled
<span class="nc bnc" id="L217" title="All 2 branches missed.">					currentStatus = (m_TimeRecordCache != null);</span>
				}
<span class="nc" id="L219">			} catch (Exception e) {</span>
<span class="nc" id="L220">				currentStatus = false;</span>
<span class="nc" id="L221">			}</span>
			// If there is state transition, we need flush cache content
<span class="nc bnc" id="L223" title="All 2 branches missed.">			if (LastCheckStatus != currentStatus) {</span>
				// If from Cache turn on to off, or vice versa, we will flush
				// cache content
<span class="nc bnc" id="L226" title="All 2 branches missed.">				if (m_TimeRecordCache != null) {</span>
<span class="nc" id="L227">					m_TimeRecordCache.clear();</span>
				}
<span class="nc" id="L229">				LastCheckStatus = currentStatus;</span>
			}
		}
<span class="nc" id="L232">		return currentStatus;</span>
	}

	private int getConfigData(int config) {
<span class="nc bnc" id="L236" title="All 4 branches missed.">		switch (config) {</span>
		case OVERLAP:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="nc bnc" id="L240" title="All 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="nc" id="L241">					m_Overlap = m_DBConfigManager.getPeriodOverlap();</span>
				}
<span class="nc" id="L243">			} catch (Exception e) {</span>
<span class="nc" id="L244">				m_cat.debug(e);</span>
<span class="nc" id="L245">			}</span>
<span class="nc" id="L246">			return m_Overlap;</span>
		case LOOKBACK:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="nc bnc" id="L250" title="All 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="nc" id="L251">					String lookBackVal = m_DBConfigManager.getValue(ConfigKey.TIMERECORDS_LOOKBACK_INTERVAL);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">					if (lookBackVal != null) {</span>
<span class="nc" id="L253">						m_LookBackMinutes = Integer.parseInt(lookBackVal) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
					}
				}
<span class="nc" id="L256">			} catch (Exception e) {</span>
<span class="nc" id="L257">				m_cat.debug(e);</span>
<span class="nc" id="L258">			}</span>
<span class="nc" id="L259">			return m_LookBackMinutes;</span>
		case CACHEDINTV:
			// If cache is in use, DBConfig will dynamically serve request
			try {
<span class="nc bnc" id="L263" title="All 2 branches missed.">				if (m_DBConfigManager.cacheUsed()) {</span>
<span class="nc" id="L264">					String cacheInt = m_DBConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">					if (cacheInt != null) {</span>
<span class="nc" id="L266">						m_CachedMilliSeconds = Integer.parseInt(cacheInt) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
					}
				}
<span class="nc" id="L269">			} catch (Exception e) {</span>
<span class="nc" id="L270">				m_cat.debug(e);</span>
<span class="nc" id="L271">			}</span>
<span class="nc" id="L272">			return m_CachedMilliSeconds;</span>
		default:
<span class="nc" id="L274">			return -1;</span>
		}
	}

	public int getTimecordCacheInterval() {
<span class="nc" id="L279">		methodStart(&quot;getTimecordCacheInterval&quot;);</span>
		try {
<span class="nc" id="L281">			return getConfigData(CACHEDINTV);</span>
		} finally {
<span class="nc" id="L283">			methodFinish();</span>
		}
	}

	/**
	 * The current implementation may have risk to approve the version which is
	 * not shown on the current user screen
	 * 
	 * @param ID
	 *            , timerecord ID
	 * @param String
	 *            , approver
	 * @param boolean
	 * @param long, version
	 */
	public void approveTimeRecord(ID id, String approver, boolean vote, long version) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L300">		methodStart(&quot;approveTimeRecord&quot;, id, approver, JdmoParam.getObject(vote), new Long(version));</span>
<span class="nc" id="L301">		TimeRecord tr = null;</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L304" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L305">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L307">			tr = TimeRecordDAO.getTimeRecordForUpdate(id, version, false);</span>
<span class="nc bnc" id="L308" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if (tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L310" title="All 4 branches missed.">					if (!tr.validate(true) || tr.isOpenShift()) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">						if (tr.isOpenShift()) {</span>
<span class="nc" id="L312">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OPEN_SHIFT);</span>
						}
<span class="nc" id="L314">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
					}
				} else {
<span class="nc" id="L317">					return;</span>
				}
			} else {
<span class="nc bnc" id="L320" title="All 2 branches missed.">				if (tr != null) {</span>
<span class="nc" id="L321">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
				// Special handle TimeInterval
<span class="nc" id="L324">				tr = TimeRecordDAO.getTimeRecordForUpdate(id, version, true);</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">				if (tr == null || tr.getVersion() != version) {</span>
<span class="nc" id="L326">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
			}
<span class="nc" id="L329">			TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
<span class="nc" id="L330">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L331">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L332">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L333">		} catch (JdmoException e) {</span>
<span class="nc" id="L334">			handleException(e);</span>
<span class="nc" id="L335">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L336">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L337">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L338">			e.setContent(tr);</span>
<span class="nc" id="L339">			throw e;</span>
<span class="nc" id="L340">		} catch (Exception e) {</span>
<span class="nc" id="L341">			handleException(e);</span>
<span class="nc" id="L342">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L344">			methodFinish();</span>
<span class="nc" id="L345">		}</span>
<span class="nc" id="L346">	} // approveTimeRecord</span>

	/**
	 * The current implementation ignores the validation check This is mainly
	 * used by AutoApproval function
	 * 
	 * @param ID
	 *            , timerecord ID
	 * @param String
	 *            , approver
	 * @param boolean
	 */
	public void approveTimeRecord(ID id, String approver, boolean vote) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L360">		methodStart(&quot;approveTimeRecord&quot;, id, approver, JdmoParam.getObject(vote));</span>
<span class="nc" id="L361">		TimeRecord tr = null;</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L364" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L365">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L367">			tr = TimeRecordDAO.getTimeRecordByID(id);</span>
<span class="nc bnc" id="L368" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">				if (tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L370" title="All 4 branches missed.">					if (!tr.validate(true) || tr.isOpenShift()) {</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">						if (tr.isOpenShift()) {</span>
<span class="nc" id="L372">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OPEN_SHIFT);</span>
						}
<span class="nc" id="L374">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
					}
				} else {
<span class="nc" id="L377">					return;</span>
				}
			} else {
<span class="nc bnc" id="L380" title="All 2 branches missed.">				if (tr != null) {</span>
<span class="nc" id="L381">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
<span class="nc" id="L383">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
			}
<span class="nc" id="L385">			TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
<span class="nc" id="L386">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L387">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L388">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L389">		} catch (JdmoException e) {</span>
<span class="nc" id="L390">			handleException(e);</span>
<span class="nc" id="L391">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L392">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L393">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L394">			e.setContent(tr);</span>
<span class="nc" id="L395">			throw e;</span>
<span class="nc" id="L396">		} catch (Exception e) {</span>
<span class="nc" id="L397">			handleException(e);</span>
<span class="nc" id="L398">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L400">			methodFinish();</span>
<span class="nc" id="L401">		}</span>
<span class="nc" id="L402">	} // approveTimeRecord</span>

	/**
	 * Approve a day, ignoring the version, used by &quot;Approve Day&quot;
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param String
	 *            , approver
	 * @param LocalDate
	 *            , day
	 * @boolean, vote
	 * @throw BbmTimeRecordException, if there are invalid TimeRecords
	 */
	public void approveTimeRecord(ID workResourceID, String approver, LocalDate dayStart, LocalDate dayEnd, boolean vote)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L418">		methodStart(&quot;approveTimeRecord&quot;, workResourceID, dayStart.toLogString(), dayEnd.toLogString(),</span>
<span class="nc" id="L419">				JdmoParam.getObject(vote));</span>
		try {
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L422" title="All 2 branches missed.">			if (approver == null) {</span>
<span class="nc" id="L423">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L425">			Collection trCol = null;</span>
			try {
<span class="nc" id="L427">				Pair result = findTimeRecord(workResourceID, dayStart, dayEnd);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				if (((Boolean) result.getFirst()).booleanValue()) {</span>
<span class="nc" id="L429">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_PAYPERIOD_LOCK);</span>
				}
<span class="nc" id="L431">				trCol = (Collection) result.getSecond();</span>
<span class="nc" id="L432">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L433">				trCol = (Collection) e.getContent();</span>
<span class="nc" id="L434">			}</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">			if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L436">				return;</span>
			}
<span class="nc" id="L438">			boolean rethrow = false;</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">			for (Iterator it = trCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L440">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">				if (tr.getApprove() != vote &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L442" title="All 6 branches missed.">					if (tr.validate(true) &amp;&amp; !tr.getOverlap() &amp;&amp; !tr.isOpenShift()) {</span>
<span class="nc" id="L443">						TimeRecordDAO.approveTimeRecord(tr, approver, vote);</span>
					} else {
<span class="nc" id="L445">						rethrow = true;</span>
					}
				}
<span class="nc" id="L448">			}</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">			if (rethrow) {</span>
<span class="nc" id="L450">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
<span class="nc" id="L452">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L453">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L454">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L455">		} catch (JdmoException e) {</span>
<span class="nc" id="L456">			handleException(e);</span>
<span class="nc" id="L457">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L458">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L459">			handleException(e);</span>
<span class="nc" id="L460">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L462">			methodFinish();</span>
<span class="nc" id="L463">		}</span>
<span class="nc" id="L464">	}</span>

	/**
	 * Approve a PayPeriod, ignoring the version, used by &quot;Approve PayPeriod&quot;
	 *
	 * @param Collection
	 *            , Employee ID
	 * @param ID
	 *            , remarker ID
	 * @param ID
	 *            , PayPeriod ID
	 * @param boolean, vote
	 */
	public void approveTimeRecord(Collection workResourceID, String approver, ID payPeriodID, boolean vote)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L479">		methodStart(&quot;approveTimeRecord&quot;, workResourceID, payPeriodID, JdmoParam.getObject(vote));</span>
<span class="nc" id="L480">		Jdmo jdmo = null;</span>
		try {
			// cache current time for modification time stamp
<span class="nc" id="L483">			Date curTime = new Date();</span>
			// If UI cannot pass user's employee name, just use the user name
<span class="nc bnc" id="L485" title="All 2 branches missed.">			if (approver == null)</span>
<span class="nc" id="L486">				approver = m_sessionContext.getCallerPrincipal().getName();</span>
			// Need rethrow at the end flag
<span class="nc" id="L488">			boolean rethrow = false;</span>
<span class="nc" id="L489">			int overlap = getConfigData(OVERLAP);</span>
<span class="nc" id="L490">			PayPeriodTypeManager pptm = BbmManagerFactory.getPayPeriodTypeManager();</span>
<span class="nc" id="L491">			PayPeriod pp = pptm.getPayPeriod(payPeriodID);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (pp != null) {</span>
<span class="nc" id="L493">				int size = workResourceID.size();</span>
<span class="nc" id="L494">				HashMap wrMap = new HashMap(size);</span>
<span class="nc" id="L495">				HashMap wrppMap = new HashMap(size);</span>
<span class="nc" id="L496">				HashMap ppMap = new HashMap(1);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L498">					ID wrID = (ID) it.next();</span>
<span class="nc" id="L499">					Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(wrID, pp.getStartDate(),</span>
<span class="nc" id="L500">							pp.getEndDate());</span>
<span class="nc" id="L501">					wrMap.put(wrID, wraCol);</span>
<span class="nc" id="L502">					Collection wrppCol = m_WorkResourceManager.getValidWorkResourcePayPolicies(wrID, pp.getStartDate(),</span>
<span class="nc" id="L503">							pp.getEndDate());</span>
<span class="nc" id="L504">					wrppMap.put(wrID, wrppCol);</span>
<span class="nc" id="L505">					Iterator itPP = wrppCol.iterator();</span>
					// Cache the PayPolicies for all employees in m_PayPolicy
<span class="nc bnc" id="L507" title="All 2 branches missed.">					while (itPP.hasNext()) {</span>
<span class="nc" id="L508">						WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy) itPP.next();</span>
<span class="nc" id="L509">						ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc" id="L510">					}</span>
<span class="nc" id="L511">				}</span>
<span class="nc" id="L512">				LocalDate start = pp.getStartDate();</span>
<span class="nc" id="L513">				LocalDate end = pp.getEndDate();</span>
<span class="nc" id="L514">				start.add(Calendar.DATE, -1);</span>
<span class="nc" id="L515">				end.add(Calendar.DATE, 1);</span>
<span class="nc" id="L516">				HashMap trMap = null;</span>
				// Maybe the extra timerecords has overlap, or whatever
				try {
<span class="nc" id="L519">					trMap = getValidEventsForWorkResource(workResourceID, start.getTime(TimeZoneUtil.GMT_TIMEZONE),</span>
<span class="nc" id="L520">							end.getTime(TimeZoneUtil.GMT_TIMEZONE));</span>
<span class="nc" id="L521">				} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L522">					trMap = (HashMap) e.getContent();</span>
<span class="nc" id="L523">				}</span>
<span class="nc" id="L524">				start.add(Calendar.DATE, 1);</span>
<span class="nc" id="L525">				end.add(Calendar.DATE, -1);</span>
<span class="nc" id="L526">				jdmo = new Jdmo();</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L528">					ID wrID = (ID) it.next();</span>
					// Retrieve the TimeRecord, if there is no such record, skip
<span class="nc" id="L530">					Collection trCol = (Collection) trMap.get(wrID);</span>
<span class="nc bnc" id="L531" title="All 4 branches missed.">					if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L532">						continue;</span>
					}
					// If there is timerecord, get the splitted time window
<span class="nc" id="L535">					Collection wraCol = (Collection) wrMap.get(wrID);</span>
<span class="nc" id="L536">					Collection wrppCol = (Collection) wrppMap.get(wrID);</span>
<span class="nc" id="L537">					Collection tsCol = TimeSpanNarrower.payrollNarrower(wraCol, wrppCol, ppMap, null, null,</span>
<span class="nc" id="L538">							pp.getPayPeriodTypeID());</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">					for (Iterator tsIT = tsCol.iterator(); tsIT.hasNext();) {</span>
<span class="nc" id="L540">						RulesTimeSpan wra = (RulesTimeSpan) tsIT.next();</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">						for (Iterator itTR = trCol.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L542">							TimeRecord tr = (TimeRecord) itTR.next();</span>
							// check TimeRecord is in peirod or not
<span class="nc bnc" id="L544" title="All 2 branches missed.">							if (StateChange.isInPeriod(tr, wra.getStartDate(), wra.getEndDate(), overlap)) {</span>
<span class="nc bnc" id="L545" title="All 4 branches missed.">								if (!tr.isLocked() &amp;&amp; tr.getApprove() != vote) {</span>
<span class="nc bnc" id="L546" title="All 6 branches missed.">									if (tr.validate(true) &amp;&amp; !tr.getOverlap() &amp;&amp; !tr.isOpenShift()) {</span>
<span class="nc" id="L547">										tr.setApprove(vote);</span>
<span class="nc" id="L548">										tr.setLastModifiedTime(curTime);</span>
										// ingore version control, lock tr from
										// TC
<span class="nc" id="L551">										TimeRecordDAO.approveTimeRecord(tr, approver, vote, jdmo);</span>
									} else
<span class="nc" id="L553">										rethrow = true;</span>
								}
							}
<span class="nc" id="L556">						}</span>
<span class="nc" id="L557">					}</span>
<span class="nc" id="L558">				}</span>
			}
<span class="nc bnc" id="L560" title="All 2 branches missed.">			if (rethrow)</span>
<span class="nc" id="L561">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
<span class="nc" id="L562">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L563">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L564">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L565">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L566">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L567">			throw e;</span>
<span class="nc" id="L568">		} catch (Exception e) {</span>
<span class="nc" id="L569">			handleException(e);</span>
<span class="nc" id="L570">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L572">			jdmo.cleanUp();</span>
<span class="nc" id="L573">			methodFinish();</span>
<span class="nc" id="L574">		}</span>
<span class="nc" id="L575">	}</span>

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window) and
	 * aggregate them according to (ActivityType, IsPaid) attributes comb.
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Pair, [Day lock for PayPeriod in Boolean, TimeRecord (incl
	 *         TimeRecordEntry, TimeInterval)]
	 * @throw BbmTimeRecordOverlapException, if timerecord overlap with other
	 *        existing timerecord
	 * @throw BbmFinderException, if there are any exception for find process
	 * @throw BbmTimeRecordException, if there are no orgnization/paypolicy
	 *        association
	 */
	public Pair findAggregatedTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd)
			throws BbmFinderException, BbmTimeRecordException {
<span class="nc" id="L597">		methodStart(&quot;findAggregatedTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="nc" id="L598">		boolean rethrow = false;</span>
		try {
<span class="nc" id="L600">			int overlap = getConfigData(OVERLAP);</span>
<span class="nc" id="L601">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
			// If there is the user doesn't belong to any org
			// To be enhanced, will throw exception
<span class="nc bnc" id="L604" title="All 2 branches missed.">			if (wraCol.isEmpty()) {</span>
<span class="nc" id="L605">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L606">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="nc" id="L609">			dayStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L610">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L611">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L612">			Collection timeRecords = null;</span>
			try {
<span class="nc" id="L614">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="nc" id="L615">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L616">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L617">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="nc" id="L618">			}</span>
<span class="nc" id="L619">			dayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L620">			dayEnd.add(Calendar.DATE, -1);</span>
<span class="nc" id="L621">			Pair resultPair = new Pair();</span>
<span class="nc" id="L622">			resultPair.setFirst(Boolean.FALSE);</span>
<span class="nc bnc" id="L623" title="All 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="nc" id="L624">				resultPair.setSecond(Collections.emptyList());</span>
<span class="nc" id="L625">				return resultPair;</span>
			}
<span class="nc" id="L627">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">			for (Iterator it = wraCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L629">				WorkResourceAssignment rts = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L630" title="All 2 branches missed.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L631">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// Check TimeRecord is in peirod or not
					// This is based on raw time, not the rounded time
					// or it is cyclical to determine the PayPolicy
<span class="nc bnc" id="L635" title="All 2 branches missed.">					if (StateChange.isInPeriod(tr, rts.getStartTime(), rts.getEndTime(), overlap)) {</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">						if (tr.getOverlap())</span>
<span class="nc" id="L637">							rethrow = true;</span>
<span class="nc" id="L638">						tr.setOrgName(rts.getOrgName());</span>
<span class="nc" id="L639">						tr.setOrgID(rts.getOrganizationID());</span>
<span class="nc" id="L640">						tr.setTimeZone(rts.getTimeZone());</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">						if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
<span class="nc" id="L642">							tr.setType(TimeRecord.AGG_TIMEENTRY);</span>
<span class="nc" id="L643">							ArrayList entries = tr.getChild();</span>
<span class="nc" id="L644">							LinkedList newChild = new LinkedList();</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">							for (Iterator itTRE = entries.iterator(); itTRE.hasNext();) {</span>
<span class="nc" id="L646">								TimeRecordEntry tre = (TimeRecordEntry) itTRE.next();</span>
<span class="nc" id="L647">								ID actID = tre.getActivityCategoryID();</span>
<span class="nc bnc" id="L648" title="All 2 branches missed.">								if (!newChild.isEmpty()) {</span>
<span class="nc" id="L649">									TimeRecordEntry treLast = (TimeRecordEntry) newChild.getLast();</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">									if (treLast.getActivityCategoryID().equals(actID)</span>
<span class="nc bnc" id="L651" title="All 2 branches missed.">											&amp;&amp; treLast.getPaid() == tre.getPaid()) {</span>
<span class="nc" id="L652">										treLast.setEndTime(tre.getEndTime());</span>
<span class="nc" id="L653">										treLast.addNumOfEntries();</span>
										// UI will display multi creators
										// involved in the aggregated view
<span class="nc bnc" id="L656" title="All 2 branches missed.">										if (treLast.getTimeSourceCode() != tre.getTimeSourceCode())</span>
<span class="nc" id="L657">											treLast.setTimeSourceCode(TimeEntrySourceCode.MULTI);</span>
									} else {
<span class="nc" id="L659">										newChild.add(tre);</span>
									}
<span class="nc" id="L661">								} else {</span>
<span class="nc" id="L662">									newChild.add(tre);</span>
								}
<span class="nc" id="L664">							}</span>
<span class="nc" id="L665">							tr.replaceChild(new ArrayList(newChild));</span>
						}
						// Add TimeInteral directly
<span class="nc" id="L668">						fallsInTR.add(tr);</span>
					}
<span class="nc" id="L670">				}</span>
<span class="nc" id="L671">			}</span>
			// Set TimeRecord with User Name for auditing trace
<span class="nc" id="L673">			setUserName(fallsInTR);</span>
<span class="nc" id="L674">			resultPair.setSecond(fallsInTR);</span>
<span class="nc bnc" id="L675" title="All 2 branches missed.">			if (!rethrow) {</span>
<span class="nc" id="L676">				return resultPair;</span>
			}
<span class="nc" id="L678">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L679">			e.setContent(resultPair);</span>
<span class="nc" id="L680">			throw e;</span>
<span class="nc" id="L681">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L682">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L683">			throw e;</span>
<span class="nc" id="L684">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L686">			handleException(e, false);</span>
<span class="nc" id="L687">			throw e;</span>
<span class="nc" id="L688">		} catch (Exception e) {</span>
<span class="nc" id="L689">			handleException(e, false);</span>
<span class="nc" id="L690">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L692">			methodFinish();</span>
		}
	}

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window) and
	 * round the TimeRecordEntry according to the rounding method/minute in the
	 * PayPolicy in that period
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Collection, TimeRecord (incl TimeRecordEntry, TimeInterval)
	 * @throw BbmTimeRecordOverlapException, if timerecord overlap with other
	 *        existing timerecord
	 * @throw BbmFinderException, if there are any exception for find process
	 * @throw BbmTimeRecordException, if there are no orgnization/paypolicy
	 *        association
	 */
	public Collection findRoundedTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd)
			throws BbmFinderException, BbmTimeRecordException {
<span class="nc" id="L716">		methodStart(&quot;findRoundedTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="nc" id="L717">		boolean rethrow = false;</span>
		try {
<span class="nc" id="L719">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
<span class="nc" id="L720">			Collection wppCol = m_WorkResourceManager.getValidWorkResourcePayPolicies(workresourceID, dayStart, dayEnd);</span>
<span class="nc" id="L721">			HashMap payPolicyMap = new HashMap(1);</span>
<span class="nc" id="L722">			int overlap = getConfigData(OVERLAP);</span>
			// Cache the PayPolicies for employees in m_PayPolicy
<span class="nc bnc" id="L724" title="All 2 branches missed.">			for (Iterator it = wppCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L725">				WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy) it.next();</span>
<span class="nc" id="L726">				ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">				if (!payPolicyMap.containsKey(policyID)) {</span>
					// PayPolicy
					// policy=m_PayPolicyManager.getPayPolicyByID(policyID);
					// payPolicyMap.put(policyID, policy);
				}
<span class="nc" id="L732">			}</span>
			// If there is the user doesn't belong to any org, paypolicy
			// To be enhanced, will throw exception
<span class="nc bnc" id="L735" title="All 4 branches missed.">			if (wraCol.isEmpty() || wppCol.isEmpty()) {</span>
<span class="nc bnc" id="L736" title="All 4 branches missed.">				if (wraCol.isEmpty() &amp;&amp; wppCol.isEmpty()) {</span>
<span class="nc" id="L737">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG_PAYPOLICY);</span>
<span class="nc" id="L738">					throw btre;</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">				} else if (wraCol.isEmpty()) {</span>
<span class="nc" id="L740">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L741">					throw btre;</span>
				} else {
<span class="nc" id="L743">					BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_PAYPOLICY);</span>
<span class="nc" id="L744">					throw btre;</span>
				}
			}
			// Get new breakdowns of TimeSpans
<span class="nc" id="L748">			Collection rulesTS = TimeSpanNarrower.payrollNarrower(wraCol, wppCol, payPolicyMap, null, null, null);</span>
<span class="nc bnc" id="L749" title="All 2 branches missed.">			if (rulesTS.isEmpty()) {</span>
<span class="nc" id="L750">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG_PAYPOLICY);</span>
<span class="nc" id="L751">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="nc" id="L754">			dayStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L755">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L756">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L757">			Collection timeRecords = null;</span>
			try {
<span class="nc" id="L759">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="nc" id="L760">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L761">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L762">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="nc" id="L763">			}</span>
<span class="nc" id="L764">			dayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L765">			dayEnd.add(Calendar.DATE, -1);</span>
<span class="nc bnc" id="L766" title="All 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="nc" id="L767">				return Collections.emptyList();</span>
			}
<span class="nc" id="L769">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="nc bnc" id="L770" title="All 2 branches missed.">			for (Iterator it = rulesTS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L771">				RulesTimeSpan rts = (RulesTimeSpan) it.next();</span>
<span class="nc bnc" id="L772" title="All 2 branches missed.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L773">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// Check TimeRecord is in peirod or not
					// This is based on raw time, not the rounded time
					// or it is cyclical to determine the PayPolicy
<span class="nc bnc" id="L777" title="All 2 branches missed.">					if (StateChange.isInPeriod(tr, rts.getStartDate(), rts.getEndDate(), overlap)) {</span>
<span class="nc" id="L778">						tr.setOrgName(rts.getOrgName());</span>
<span class="nc" id="L779">						tr.setOrgID(rts.getOrgID());</span>
<span class="nc" id="L780">						tr.setTimeZone(rts.getTimeZoneName());</span>
						// Adjust the time of TimeRecordEntry with rounding rule
<span class="nc bnc" id="L782" title="All 2 branches missed.">						if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
							// Adjust TimeRecordEntries, so set TimeRecord recal
<span class="nc" id="L784">							tr.setNeedCal();</span>
<span class="nc" id="L785">							PayPolicy pp = (PayPolicy) payPolicyMap.get(rts.getPayPolicyID());</span>
							// If no rounding is defined;
<span class="nc bnc" id="L787" title="All 4 branches missed.">							if (pp == null || pp.getRoundingMinutes() &lt;= 1) {</span>
<span class="nc" id="L788">								continue;</span>
							}
<span class="nc" id="L790">							Collection entryCol = tr.getChildren();</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">							for (Iterator entryIt = entryCol.iterator(); entryIt.hasNext();) {</span>
<span class="nc" id="L792">								TimeRecordEntry entry = (TimeRecordEntry) entryIt.next();</span>
<span class="nc" id="L793">								entry.adjustTime(pp.getRoundingMethod(), pp.getRoundingMinutes());</span>
<span class="nc" id="L794">							}</span>
							// After adjustment check if TimeRecord belongs to
							// the period or not
<span class="nc bnc" id="L797" title="All 2 branches missed.">							if (StateChange.isInPeriod(tr, rts.getStartDate(), rts.getEndDate(), overlap)) {</span>
<span class="nc" id="L798">								fallsInTR.add(tr);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">								if (tr.getOverlap())</span>
<span class="nc" id="L800">									rethrow = true;</span>
							}
<span class="nc" id="L802">						} else {</span>
							// Add TimeInteral directly
<span class="nc" id="L804">							fallsInTR.add(tr);</span>
						}
					}
<span class="nc" id="L807">				}</span>
<span class="nc" id="L808">			}</span>
			// Set TimeRecord with User Name for auditing trace
<span class="nc" id="L810">			setUserName(fallsInTR);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">			if (!rethrow)</span>
<span class="nc" id="L812">				return fallsInTR;</span>
<span class="nc" id="L813">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L814">			e.setContent(fallsInTR);</span>
<span class="nc" id="L815">			throw e;</span>
<span class="nc" id="L816">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L817">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L818">			throw e;</span>
<span class="nc" id="L819">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L821">			handleException(e, false);</span>
<span class="nc" id="L822">			throw e;</span>
<span class="nc" id="L823">		} catch (Exception e) {</span>
<span class="nc" id="L824">			handleException(e, false);</span>
<span class="nc" id="L825">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L827">			methodFinish();</span>
		}
	}

	/**
	 * find TimeRecords in a Day period(Defined by LocalDate time window)
	 * 
	 * @param ID
	 *            , workresource ID
	 * @param LocalDate
	 *            , start date
	 * @param LocalDate
	 *            , end date
	 * @return Collection, TimeRecord (incl TimeRecordEntry, TimeInterval)
	 */
	public Pair findTimeRecord(ID workresourceID, LocalDate dayStart, LocalDate dayEnd) throws BbmFinderException {
<span class="nc" id="L843">		methodStart(&quot;findTimeRecord&quot;, workresourceID, dayStart.toLogString(), dayEnd.toLogString());</span>
<span class="nc" id="L844">		boolean rethrow = false;</span>
		try {
<span class="nc" id="L846">			Collection wraCol = m_WorkResourceManager.getValidWorkResourceAssignments(workresourceID, dayStart, dayEnd);</span>
<span class="nc" id="L847">			int overlap = getConfigData(OVERLAP);</span>
			// If there is the user doesn't belong to any org
			// To be enhanced, will throw exception
<span class="nc bnc" id="L850" title="All 2 branches missed.">			if (wraCol.isEmpty()) {</span>
<span class="nc" id="L851">				BbmTimeRecordException btre = new BbmTimeRecordException(BbmTimeRecordException.TR_NO_ORG);</span>
<span class="nc" id="L852">				throw btre;</span>
			}
			// Do a batch load first, expand the time window
<span class="nc" id="L855">			dayStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L856">			dayEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L857">			TimeZone gmtTZ = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L858">			Collection timeRecords = null;</span>
			try {
<span class="nc" id="L860">				timeRecords = getValidEventsForWorkResource(workresourceID, dayStart.getTime(gmtTZ),</span>
<span class="nc" id="L861">						dayEnd.getTime(gmtTZ));</span>
<span class="nc" id="L862">			} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L863">				timeRecords = (Collection) ((HashMap) e.getContent()).get(workresourceID);</span>
<span class="nc" id="L864">			}</span>
<span class="nc" id="L865">			dayStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L866">			dayEnd.add(Calendar.DATE, -1);</span>
			// Now check PayrollLock status
<span class="nc" id="L868">			Pair resultPair = new Pair();</span>
<span class="nc" id="L869">			resultPair.setFirst(Boolean.FALSE);</span>
<span class="nc bnc" id="L870" title="All 4 branches missed.">			if (timeRecords == null || timeRecords.isEmpty()) {</span>
<span class="nc" id="L871">				resultPair.setSecond(Collections.emptyList());</span>
<span class="nc" id="L872">				return resultPair;</span>
			}
<span class="nc" id="L874">			ArrayList fallsInTR = new ArrayList(timeRecords.size());</span>
<span class="nc" id="L875">			int dayBoundaryOffset = 0;</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">			for (Iterator it = wraCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L877">				WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">				for (Iterator itTR = timeRecords.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L879">					TimeRecord tr = (TimeRecord) itTR.next();</span>
					// check TimeRecord is in peirod or not
<span class="nc bnc" id="L881" title="All 2 branches missed.">					if (StateChange.isInPeriod(tr, wra.getStartTime(), wra.getEndTime(), overlap)) {</span>
<span class="nc" id="L882">						tr.setOrgName(wra.getOrgName());</span>
<span class="nc" id="L883">						tr.setOrgID(wra.getOrganizationID());</span>
<span class="nc" id="L884">						tr.setTimeZone(wra.getTimeZone());</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">						dayBoundaryOffset = dayBoundaryOffset == 0 ? wra.getDayBoundaryOffset() : dayBoundaryOffset;</span>
<span class="nc" id="L886">						tr.setDayBoundaryOffset(wra.getDayBoundaryOffset());</span>
<span class="nc" id="L887">						fallsInTR.add(tr);</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">						if (tr.getOverlap())</span>
<span class="nc" id="L889">							rethrow = true;</span>
					}
<span class="nc" id="L891">				}</span>
<span class="nc" id="L892">			}</span>
			// If there is DayBoundaryOffset defined on the organization,
			// we need recheck the offseted day falls in PayPeriod or not
<span class="nc bnc" id="L895" title="All 2 branches missed.">			if (dayBoundaryOffset != 0) {</span>
<span class="nc" id="L896">				dayStart.add(Calendar.MINUTE, dayBoundaryOffset);</span>
<span class="nc" id="L897">				dayEnd.add(Calendar.MINUTE, dayBoundaryOffset);</span>
<span class="nc" id="L898">				resultPair.setFirst(Boolean.FALSE);</span>
			}
			// Set TimeRecord with User Name for auditing trace
<span class="nc" id="L901">			setUserName(fallsInTR);</span>
<span class="nc" id="L902">			resultPair.setSecond(fallsInTR);</span>
<span class="nc bnc" id="L903" title="All 2 branches missed.">			if (!rethrow) {</span>
<span class="nc" id="L904">				return resultPair;</span>
			}
<span class="nc" id="L906">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException();</span>
<span class="nc" id="L907">			e.setContent(resultPair);</span>
<span class="nc" id="L908">			throw e;</span>
<span class="nc" id="L909">		} catch (BbmFinderException e) {</span>
			// Don't set tx rollback
<span class="nc" id="L911">			handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L912">			throw e;</span>
<span class="nc" id="L913">		} catch (Exception e) {</span>
<span class="nc" id="L914">			handleException(e, false);</span>
<span class="nc" id="L915">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L917">			methodFinish();</span>
		}
	}

	/**
	 * Close any Open Shift in the whole system
	 */
	public void closeOpenShift(int lookBackDays) throws BbmCreateException {
<span class="nc" id="L925">		methodStart(&quot;closeOpenShift&quot;, new Long(lookBackDays));</span>

<span class="nc" id="L927">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L929">			Date now = new Date();</span>
<span class="nc" id="L930">			long currentMilli = now.getTime();</span>

<span class="nc" id="L932">			long startMilli = 0;</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">			if (lookBackDays &gt; 0) {</span>
<span class="nc" id="L934">				long millis = (lookBackDays) * 86400000L;</span>
<span class="nc bnc" id="L935" title="All 2 branches missed.">				if (millis &lt; currentMilli) {</span>
<span class="nc" id="L936">					startMilli = currentMilli - millis;</span>
				}
			}

<span class="nc bnc" id="L940" title="All 2 branches missed.">			if (m_DebugEnabled) {</span>
<span class="nc" id="L941">				m_cat.debug(&quot;In closeOpenShift, start Millis=&quot; + startMilli + &quot; end Millis=&quot; + currentMilli);</span>
			}

<span class="nc" id="L944">			StringBuffer pStmt = new StringBuffer(300);</span>
<span class="nc" id="L945">			String tempTable = &quot;emplatest&quot;;</span>
			// From JDMO get real temp table name
<span class="nc" id="L947">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
			// Drop temp first
			try {
<span class="nc" id="L950">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L951">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L952" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L953">					m_cat.debug(e);</span>
				}
<span class="nc" id="L955">			}</span>
			// Create a new temp table
<span class="nc" id="L957">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="nc" id="L958">			strSQLCreate.append(realTempTable);</span>
<span class="nc" id="L959">			strSQLCreate.append(&quot; (UPDATETIMESTAMP decimal(17,0), EMPLOYEEID int)&quot;);</span>
<span class="nc" id="L960">			jdmo.createTempTable(strSQLCreate.toString());</span>
			// Insert data into temp table
<span class="nc" id="L962">			StringBuffer pInsert = new StringBuffer(&quot;insert into &quot;);</span>
<span class="nc" id="L963">			pInsert.append(realTempTable).append(&quot; select MAX(updatetimestamp),&quot;);</span>
<span class="nc" id="L964">			pInsert.append(&quot;b2.employeeid FROM timeentryevent b2&quot;);</span>
<span class="nc" id="L965">			pInsert.append(&quot; WHERE b2.updatetimestamp &gt;= &quot;).append(startMilli);</span>
<span class="nc" id="L966">			pInsert.append(&quot; AND b2.updatetimestamp&lt;=&quot;).append(currentMilli);</span>

<span class="nc" id="L968">			pInsert.append(&quot; GROUP BY b2.employeeid&quot;);</span>
<span class="nc" id="L969">			jdmo.executeCommand(pInsert.toString());</span>
			// now select again
<span class="nc" id="L971">			pStmt.append(&quot;select b.EMPLOYEEID, b.TIMERECORDID, b.UPDATETIMESTAMP&quot;).append(&quot; from &quot;)</span>
<span class="nc" id="L972">					.append(realTempTable).append(&quot; t, TIMEENTRYEVENT b where t.EMPLOYEEID=b.EMPLOYEEID and&quot;)</span>
<span class="nc" id="L973">					.append(&quot; b.UPDATETIMESTAMP=t.UPDATETIMESTAMP and b.ACTIVITYID!=-4001 and b.UPDATETIMESTAMP&lt;=&quot;)</span>
<span class="nc" id="L974">					.append((long) (currentMilli - AutoCloseTimeoutInMillis));</span>
<span class="nc" id="L975">			JdmoRowset rs = jdmo.createRowset(pStmt.toString(), Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L976">			ArrayList entryList = new ArrayList(1000);</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">			while (rs.next()) {</span>
				// construct new End Shift
<span class="nc" id="L979">				TimeRecordEntry entry = new TimeRecordEntry(Activity.ACTIVITY_NONE, new Date(rs.getLong(3)</span>
						+ TimeZoneUtil.MINUTE_IN_MILLISECONDS), null, TimeEntrySourceCode.AUTO_CLOSE, false, null);
<span class="nc" id="L981">				entry.setEmployeeID(rs.getID(1));</span>
<span class="nc" id="L982">				entry.setParentID(rs.getID(2));</span>
<span class="nc" id="L983">				addModTimestamp(entry);</span>
<span class="nc" id="L984">				entryList.add(entry);</span>
<span class="nc" id="L985">			}</span>
			// create in DB
<span class="nc" id="L987">			TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
			// refresh Cache
<span class="nc bnc" id="L989" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc bnc" id="L990" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L991">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L992">					TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
<span class="nc" id="L993">				}</span>
			}
<span class="nc bnc" id="L995" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L996">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L997">				updateLastEntryCache(entry);</span>
<span class="nc" id="L998">			}</span>
			// create AuditTrail
<span class="nc bnc" id="L1000" title="All 2 branches missed.">			if (!entryList.isEmpty()) {</span>
<span class="nc" id="L1001">				ArrayList auditList = new ArrayList(entryList.size());</span>
<span class="nc bnc" id="L1002" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1003">					TimeRecordEntry tre = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1004">					AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1005">							AuditTrailEntry.ACTION_DELETE_OBJECT, tre.getEmployeeID(),</span>
<span class="nc" id="L1006">							getEmployeeName(tre.getEmployeeID()), tre.getSortTime(), now);</span>
<span class="nc" id="L1007">					entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1008">							String.valueOf(Event.EVENT_TYPE_TIME_RECORD), &quot;-1&quot;, false);</span>
<span class="nc" id="L1009">					entry.setWho(&quot;autoclose&quot;);</span>
<span class="nc" id="L1010">					auditList.add(entry);</span>
<span class="nc" id="L1011">				}</span>
<span class="nc" id="L1012">				m_EventAuditTrailManager.createAuditEntry(auditList);</span>
			}
<span class="nc" id="L1014">		} catch (JdmoException e) {</span>
<span class="nc" id="L1015">			handleException(e);</span>
<span class="nc" id="L1016">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1017">		} catch (Exception e) {</span>
<span class="nc" id="L1018">			handleException(e);</span>
<span class="nc" id="L1019">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1021">			jdmo.cleanUp();</span>
<span class="nc" id="L1022">			methodFinish();</span>
<span class="nc" id="L1023">		}</span>
<span class="nc" id="L1024">	}</span>

	/**
	 * Close any Open Shift in the whole system
	 */
	public void closeOpenShift() throws BbmCreateException {
<span class="nc" id="L1030">		closeOpenShift(0);</span>
<span class="nc" id="L1031">	}</span>

	/**
	 * Used by the UI to create TimeInterval, which will creat a new TimeRecord
	 * 
	 * @param TimeRecord
	 * @return ID
	 */
	public ID createTimeInterval(TimeRecord timeRecord) throws BbmCreateException {
<span class="nc" id="L1040">		methodStart(&quot;createTimeInterval&quot;, timeRecord);</span>
		try {
<span class="nc" id="L1042">			return TimeRecordDAO.createTimeInterval(timeRecord);</span>
<span class="nc" id="L1043">		} catch (JdmoException e) {</span>
<span class="nc" id="L1044">			handleException(e);</span>
<span class="nc" id="L1045">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1046">		} catch (Exception e) {</span>
<span class="nc" id="L1047">			handleException(e);</span>
<span class="nc" id="L1048">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1050">			methodFinish();</span>
		}
	} // createTimeInterval

	/**
	 * create a new TimeRecord, which will invoke createTimeRecordEntry Cannot
	 * succeed if there is an open shift just before the current TimeRecord
	 * 
	 * @param TimeRecord
	 * @return ID
	 * @throws BbmTimeRecordException
	 *             , TR_INVALID, if TimeRecord is invalid, getContent() returns
	 *             TimeRecord itselft TR_PRV_OPEN_SHIFT, if there is an open
	 *             shift just before this TimeRecord, getContent() returns the
	 *             last Entry of the open shift
	 */
	public ID createTimeRecord(TimeRecord timeRecord) throws BbmCreateException, BbmTimeRecordException {
<span class="nc" id="L1067">		methodStart(&quot;createTimeRecord&quot;, timeRecord);</span>
		// Check if there are any existing TimeRecordEntry during this period
<span class="nc bnc" id="L1069" title="All 4 branches missed.">		if (timeRecord == null || !timeRecord.validate(true)) {</span>
<span class="nc" id="L1070">			BbmTimeRecordException e = new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
<span class="nc" id="L1071">			e.setContent(timeRecord);</span>
<span class="nc" id="L1072">			throw e;</span>
		}
<span class="nc" id="L1074">		Jdmo jdmo = null;</span>
<span class="nc" id="L1075">		Collection col = null;</span>
		try {
			// TimeCollection will create an empty TimeRecord as container
<span class="nc bnc" id="L1078" title="All 2 branches missed.">			if (timeRecord.getStartTime() != null) {</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">				if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="nc" id="L1080">					col = getEventsForWorkResource(timeRecord.getEmployeeID(), timeRecord.getStartTime(),</span>
<span class="nc" id="L1081">							timeRecord.getEndTime());</span>
<span class="nc bnc" id="L1082" title="All 4 branches missed.">					if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1083">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
					}
<span class="nc" id="L1085">					TimeRecordEntry lastEntry = TimeRecordDAO.findLastTimeEntry(timeRecord.getEmployeeID(),</span>
<span class="nc" id="L1086">							TimeZoneUtil.toTimestamp(timeRecord.getStartTime()));</span>
					// If the last Entry is not EndShift, further check must be
					// done
<span class="nc bnc" id="L1089" title="All 4 branches missed.">					if (lastEntry != null &amp;&amp; lastEntry.getActivityID() != Activity.ACTIVITY_NONE) {</span>
						// If the last Entry TimeRecord is still open, throw
						// exception saying it should be closed
<span class="nc bnc" id="L1092" title="All 2 branches missed.">						if (TimeRecordDAO.isOpenShift(lastEntry.getParentID(),</span>
<span class="nc" id="L1093">								TimeZoneUtil.toTimestamp(timeRecord.getStartTime()))) {</span>
<span class="nc" id="L1094">							BbmTimeRecordException e = new BbmTimeRecordException(</span>
									BbmTimeRecordException.TR_PRV_OPEN_SHIFT);
<span class="nc" id="L1096">							e.setContent(lastEntry);</span>
<span class="nc" id="L1097">							throw e;</span>
						}
						// Or it will overlap with that TimeRecord for sure
<span class="nc" id="L1100">						throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
					}
				}
			}
<span class="nc" id="L1104">			jdmo = new Jdmo();</span>
<span class="nc" id="L1105">			HashMap map = new HashMap();</span>
<span class="nc" id="L1106">			map.put(&quot;EMPLOYEEID&quot;, timeRecord.getEmployeeID());</span>
<span class="nc bnc" id="L1107" title="All 2 branches missed.">			if (timeRecord.getRemarkEmployeeID() != null) {</span>
<span class="nc" id="L1108">				map.put(TimeRecordDAO.REMAKERCOLNAME, timeRecord.getRemarkEmployeeID());</span>
			}
<span class="nc" id="L1110">			map.put(&quot;LASTMODIFIEDAT&quot;, TimeZoneUtil.toTimestamp(new Date()));</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">			if (timeRecord.getDescription() != null) {</span>
<span class="nc" id="L1112">				map.put(&quot;REMARK&quot;, timeRecord.getDescription());</span>
			}
<span class="nc bnc" id="L1114" title="All 2 branches missed.">			if (timeRecord.getApprove()) {</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">				if (timeRecord.getApproverName() == null) {</span>
<span class="nc" id="L1116">					map.put(TimeRecordDAO.APPROVERCOLNAME, m_sessionContext.getCallerPrincipal().getName());</span>
				} else {
<span class="nc" id="L1118">					map.put(TimeRecordDAO.APPROVERCOLNAME, timeRecord.getApproverName());</span>
				}
<span class="nc" id="L1120">				map.put(TimeRecordDAO.APPROVETIMECOLNAME, timeRecord.getApproveTime());</span>
			}
<span class="nc" id="L1122">			map.put(&quot;ISAPPROVED&quot;, JdmoParam.getObject(timeRecord.getApprove()));</span>
<span class="nc" id="L1123">			map.put(&quot;ISPOSTED&quot;, JdmoParam.getObject(timeRecord.isLocked()));</span>
<span class="nc" id="L1124">			map.put(&quot;CHANGECOUNTER&quot;, new Long(timeRecord.getVersion()));</span>
<span class="nc" id="L1125">			map.put(&quot;CHANGESTATUS&quot;, new Short(timeRecord.getSyncStatus()));</span>
<span class="nc" id="L1126">			ID id = jdmo.addBatchInsert(&quot;TIMERECORD&quot;, map);</span>
<span class="nc" id="L1127">			jdmo.executeBatch();</span>
<span class="nc" id="L1128">			timeRecord.setID(id);</span>
<span class="nc" id="L1129">			ArrayList list = timeRecord.getChild();</span>
<span class="nc bnc" id="L1130" title="All 4 branches missed.">			if (list == null || list.isEmpty()) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc bnc" id="L1132" title="All 2 branches missed.">					if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
						// Cleanest way is to reload timerecord from DB, then
						// add the record into cache
<span class="nc" id="L1135">						TimeRecordCacheUtil.createInCache(m_TimeRecordCache, timeRecord);</span>
					}
				}
<span class="nc" id="L1138">				return id;</span>
			}
<span class="nc bnc" id="L1140" title="All 2 branches missed.">			if (timeRecord.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="nc" id="L1141">				int size = list.size();</span>
<span class="nc" id="L1142">				int lastPos = 0;</span>
<span class="nc" id="L1143">				ArrayList insertEntry = new ArrayList();</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">				for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L1145">					TimeRecordEntry entry = (TimeRecordEntry) list.get(i);</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">					if (!entry.isDeleted()) {</span>
<span class="nc" id="L1147">						entry.setEmployeeID(timeRecord.getEmployeeID());</span>
<span class="nc" id="L1148">						entry.setParentID(id);</span>
<span class="nc" id="L1149">						insertEntry.add(entry);</span>
<span class="nc" id="L1150">						lastPos++;</span>
					}
				}
				// Batch insert
<span class="nc" id="L1154">				TimeRecordDAO.createTimeRecordEntry(insertEntry, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1155" title="All 2 branches missed.">				if (cacheUsed()) {</span>
					// We may need put this record into cache
<span class="nc" id="L1157">					Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="nc bnc" id="L1158" title="All 2 branches missed.">					if (TimeRecordCacheUtil.fitsInCache(timeRecord, cacheWindow[0], cacheWindow[1])) {</span>
						// Cleanest way is to reload timerecord from DB
<span class="nc" id="L1160">						TimeRecordCacheUtil.createInCache(m_TimeRecordCache, getTimeRecordByID(id));</span>
					}
				}
				// create lastEntry
<span class="nc bnc" id="L1164" title="All 2 branches missed.">				if (m_LastEntryCache != null) {</span>
<span class="nc" id="L1165">					Collections.sort(insertEntry);</span>
<span class="nc" id="L1166">					updateLastEntryCache((TimeRecordEntry) insertEntry.get(lastPos - 1));</span>
				}
				// create AuditTrail
<span class="nc" id="L1169">				AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1170">						AuditTrailEntry.ACTION_CREATE_OBJECT, timeRecord.getEmployeeID(),</span>
<span class="nc" id="L1171">						getEmployeeName(timeRecord.getEmployeeID()), timeRecord.getStartTime(), timeRecord.getEndTime());</span>
<span class="nc" id="L1172">				entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
						&quot;-1&quot;, false);
<span class="nc" id="L1174">				m_EventAuditTrailManager.createAuditEntry(entry);</span>
<span class="nc" id="L1175">			} else {</span>
<span class="nc bnc" id="L1176" title="All 2 branches missed.">				for (int i = list.size(); --i &gt;= 0;) {</span>
<span class="nc" id="L1177">					TimeInterval entry = (TimeInterval) list.get(i);</span>
<span class="nc bnc" id="L1178" title="All 2 branches missed.">					if (!entry.isDeleted()) {</span>
<span class="nc" id="L1179">						TimeRecordDAO.createTimeInterval(entry);</span>
					}
<span class="nc" id="L1181">				}</span>
			}
<span class="nc" id="L1183">			return id;</span>
<span class="nc" id="L1184">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1185">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1186">			BbmCreateException bce = new BbmCreateException(e);</span>
<span class="nc" id="L1187">			bce.setContent(timeRecord);</span>
<span class="nc" id="L1188">			throw bce;</span>
<span class="nc" id="L1189">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L1190">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L1191" title="All 2 branches missed.">			if (e.getContent() != null) {</span>
<span class="nc" id="L1192">				throw e;</span>
			}
<span class="nc bnc" id="L1194" title="All 4 branches missed.">			if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L1195">				e.setContent(col);</span>
			} else {
<span class="nc" id="L1197">				e.setContent(timeRecord);</span>
			}
<span class="nc" id="L1199">			throw e;</span>
<span class="nc" id="L1200">		} catch (JdmoException e) {</span>
<span class="nc" id="L1201">			handleException(e);</span>
<span class="nc" id="L1202">			BbmCreateException bce = new BbmCreateException(e);</span>
<span class="nc" id="L1203">			bce.setContent(timeRecord);</span>
<span class="nc" id="L1204">			throw bce;</span>
<span class="nc" id="L1205">		} catch (Exception e) {</span>
<span class="nc" id="L1206">			handleException(e);</span>
<span class="nc" id="L1207">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc bnc" id="L1209" title="All 6 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1210">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L1212">			methodFinish();</span>
		}
	} // createTimeRecord

	/**
	 * For the creation of a new TimeRecordEntry from the UI only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord createTimeRecordEntry(ID timeRecordID, int pos, TimeRecordEntry entry, long version)
			throws BbmCreateException, BbmTimeRecordException {
<span class="nc" id="L1230">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos), entry, new Long(version));</span>
<span class="nc" id="L1231">		Collection col = null;</span>
<span class="nc" id="L1232">		TimeRecord tr = null;</span>
		try {
			// Try to obtain TimeRecord based on version
<span class="nc" id="L1235">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L1236" title="All 2 branches missed.">			if (tr == null) {</span>
				// TimeRecord is null, can be two reasons:
				// 1. Version is incorrect
				// 2. TimeRecord has no entries, so retry
<span class="nc" id="L1240">				tr = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L1241" title="All 4 branches missed.">				if (tr == null || tr.getVersion() != version) {</span>
					// Really an obsolete problem
<span class="nc" id="L1243">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
			}
<span class="nc bnc" id="L1246" title="All 2 branches missed.">			if (tr.getType() == TimeRecord.TIMEENTRY) {</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">				if (tr.isLocked()) {</span>
<span class="nc" id="L1248">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
				}
<span class="nc" id="L1250">				entry.setEmployeeID(tr.getEmployeeID());</span>
<span class="nc" id="L1251">				tr.addEntry(entry, pos);</span>
				// Check within the TimeRecord
<span class="nc bnc" id="L1253" title="All 2 branches missed.">				if (tr.validate(true)) {</span>
					// Check with other TimeRecords, acquire the locks
					// If the TimeRecord has only one entry, it will null
					// So just update
<span class="nc bnc" id="L1257" title="All 2 branches missed.">					if (!tr.getStartTime().equals(tr.getEndTime())) {</span>
<span class="nc" id="L1258">						col = getEventsForWorkResource(tr.getEmployeeID(), tr.getStartTime(), tr.getEndTime());</span>
					}
					// TimeCollection rounding starttime up, so the scope is not
					// precise
					// This is prominent in TimeRecord with only one entry,
					// which may fail to find TR
					// Just update the timerecord in the special case
<span class="nc bnc" id="L1265" title="All 4 branches missed.">					if (col == null || col.size() == 1) {</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">						if (col != null) {</span>
<span class="nc" id="L1267">							Iterator it = col.iterator();</span>
<span class="nc" id="L1268">							TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">							if (!same.getID().equals(timeRecordID)) {</span>
<span class="nc" id="L1270">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
							}
						}
<span class="nc bnc" id="L1273" title="All 2 branches missed.">						if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L1274">							tr.setRemarkEmployeeID(entry.getRemarkerID());</span>
						}
<span class="nc" id="L1276">						updateTimeRecordEntry(tr, true);</span>
<span class="nc bnc" id="L1277" title="All 2 branches missed.">						if (cacheUsed()) {</span>
<span class="nc" id="L1278">							TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
						}
<span class="nc" id="L1280">						updateLastEntryCache(tr.getLastEntry());</span>
<span class="nc" id="L1281">						AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1282">								AuditTrailEntry.ACTION_CREATE_OBJECT, tr.getEmployeeID(),</span>
<span class="nc" id="L1283">								getEmployeeName(tr.getEmployeeID()), entry.getStartTime(),</span>
<span class="nc bnc" id="L1284" title="All 2 branches missed.">								(entry.getEndTime() == null) ? (new Date()) : entry.getEndTime());</span>
<span class="nc" id="L1285">						auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1286">								String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L1287">						m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L1288">						return tr;</span>
					}
<span class="nc" id="L1290">					Iterator it = col.iterator();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">					while (it.hasNext()) {</span>
<span class="nc" id="L1292">						((TimeRecord) it.next()).setOverlap(true);</span>
					}
<span class="nc" id="L1294">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
				}
				// invalid
<span class="nc" id="L1297">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
<span class="nc" id="L1299">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID_TYPE);</span>
<span class="nc" id="L1300">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1301">			Object[] param = new Object[3];</span>
<span class="nc" id="L1302">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1303">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1304">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1305">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1306">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1307">		} catch (JdmoException e) {</span>
<span class="nc" id="L1308">			handleException(e);</span>
<span class="nc" id="L1309">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1310">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1311">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1312">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1313">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1314">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L1315">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1316">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L1317">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L1318" title="All 4 branches missed.">			if (col == null || col.isEmpty()) {</span>
<span class="nc" id="L1319">				e.setContent(tr);</span>
			} else {
<span class="nc" id="L1321">				e.setContent(col);</span>
			}
<span class="nc" id="L1323">			throw e;</span>
<span class="nc" id="L1324">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1325">			handleException(e);</span>
<span class="nc" id="L1326">			throw e;</span>
<span class="nc" id="L1327">		} catch (Exception e) {</span>
<span class="nc" id="L1328">			handleException(e);</span>
<span class="nc" id="L1329">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1331">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @return ID, TimeRecordEntry ID
	 * @throws BbmTimeRecordException
	 *             , if it violates some validation check, or SyncStatus Check
	 */
	public ID createTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry) throws BbmCreateException {
<span class="nc" id="L1349">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entry);</span>
		try {
			// Then create a new TimeRecordEntry
<span class="nc" id="L1352">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1353">			addModTimestamp(entry);</span>
<span class="nc" id="L1354">			TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1355" title="All 2 branches missed.">			if (cacheUsed()) {</span>
				// Cache Task
<span class="nc" id="L1357">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
			}
<span class="nc" id="L1359">			updateLastEntryCache(entry);</span>
<span class="nc" id="L1360">			return entry.getID();</span>
<span class="nc" id="L1361">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1362">			Object[] param = new Object[3];</span>
<span class="nc" id="L1363">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1364">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1365">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1366">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1367">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1368">		} catch (JdmoException e) {</span>
<span class="nc" id="L1369">			handleException(e);</span>
<span class="nc" id="L1370">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1372">			methodFinish();</span>
		}
	}

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param ArrayList
	 *            , TimeRecordEntry List
	 * @return ArrayList, TimeRecordEntry ID List
	 */
	public ArrayList createTimeRecordEntry(ID timeRecordID, ArrayList entryList) throws BbmCreateException {
<span class="nc" id="L1388">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entryList);</span>
		try {
			// Then create a new TimeRecordEntry
<span class="nc" id="L1391">			Collections.sort(entryList);</span>
<span class="nc bnc" id="L1392" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1393">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1394">				entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1395">				addModTimestamp(entry);</span>
<span class="nc" id="L1396">			}</span>
<span class="nc" id="L1397">			ArrayList idList = TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1398" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; !entryList.isEmpty()) {</span>
<span class="nc" id="L1399">				ID empID = ((TimeRecordEntry) entryList.get(0)).getEmployeeID();</span>
<span class="nc" id="L1400">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entryList, empID, timeRecordID);</span>
			}
<span class="nc" id="L1402">			updateLastEntryCache((TimeRecordEntry) entryList.get(entryList.size() - 1));</span>
<span class="nc" id="L1403">			return idList;</span>
<span class="nc" id="L1404">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1405">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1406">		} catch (JdmoException e) {</span>
<span class="nc" id="L1407">			handleException(e);</span>
<span class="nc" id="L1408">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1410">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * TimeRecordEntry is from difference employee
	 * 
	 * @param ArrayList
	 *            , TimeRecordEntry List
	 * @return ArrayList, TimeRecordEntry ID List
	 */
	public ArrayList createTimeRecordEntry(ArrayList entryList) throws BbmCreateException {
<span class="nc" id="L1423">		methodStart(&quot;createTimeRecordEntry&quot;, entryList);</span>
		try {
<span class="nc bnc" id="L1425" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1426">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1427">				addModTimestamp(entry);</span>
<span class="nc" id="L1428">			}</span>
<span class="nc" id="L1429">			ArrayList idList = TimeRecordDAO.createTimeRecordEntry(entryList, m_ResetImmidiateToLastActivity);</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">			if (cacheUsed()) {</span>
				// Cache Task
<span class="nc bnc" id="L1432" title="All 2 branches missed.">				for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1433">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1434">					TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
<span class="nc" id="L1435">				}</span>
			}
<span class="nc bnc" id="L1437" title="All 2 branches missed.">			for (Iterator it = entryList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1438">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L1439">				updateLastEntryCache(entry);</span>
<span class="nc" id="L1440">			}</span>
<span class="nc" id="L1441">			return idList;</span>
<span class="nc" id="L1442">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1443">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1444">		} catch (JdmoException e) {</span>
<span class="nc" id="L1445">			handleException(e);</span>
<span class="nc" id="L1446">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1448">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @return ID, TimeRecordEntry ID
	 */
	public ID createTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry, boolean historical)
			throws BbmCreateException {
<span class="nc" id="L1465">		methodStart(&quot;createTimeRecordEntry&quot;, timeRecordID, entry, JdmoParam.getObject(historical));</span>
		try {
			// Then create a new TimeRecordEntry
<span class="nc" id="L1468">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1469">			addModTimestamp(entry);</span>
<span class="nc" id="L1470">			entry.setID(TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity));</span>
<span class="nc bnc" id="L1471" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L1472">				TimeRecordCacheUtil.createInCache(m_TimeRecordCache, entry);</span>
			}
<span class="nc" id="L1474">			updateLastEntryCache(entry);</span>
<span class="nc" id="L1475">			return entry.getID();</span>
<span class="nc" id="L1476">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1477">			Object[] param = new Object[3];</span>
<span class="nc" id="L1478">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1479">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1480">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1481">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1482">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1483">		} catch (JdmoException e) {</span>
<span class="nc" id="L1484">			handleException(e);</span>
<span class="nc" id="L1485">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1487">			methodFinish();</span>
		}
	} // createTimeRecordEntry

	/**
	 * For the creation of a new TimeRecordEntry without any validation check
	 * But if the manager has processed the TimeRecord, it will throw OUTOFSYNC
	 * And for Merge is to determine if need replace the existing TimeRecord
	 * ENDSHIFT to a given Activity, and append the new TimeRecordEntry after
	 * that To be used by TimeCollection only
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Date
	 *            , the last activity start date to be updated for last EndShift
	 * @return ID, TimeRecordEntry ID
	 * @throws BbmTimeRecordException
	 *             , if it violates some validation check, or SyncStatus Check
	 */
	public ID createTimeRecordEntryForMerge(ID timeRecordID, TimeRecordEntry entry, Date lastActivityStart)
			throws BbmCreateException {
<span class="nc" id="L1510">		methodStart(&quot;createTimeRecordEntryForMerge&quot;, timeRecordID, entry, lastActivityStart);</span>
		try {
			// Acquire a read lock
<span class="nc" id="L1513">			TimeRecord candidate = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID);</span>
			// If TimeRecord is gone, throw BbmCreateException
<span class="nc bnc" id="L1515" title="All 2 branches missed.">			if (candidate == null) {</span>
				// Enhancement here, if TimeRecord has no entries, should just
				// create
<span class="nc" id="L1518">				candidate = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L1519" title="All 2 branches missed.">				if (candidate == null) {</span>
<span class="nc" id="L1520">					throw new BbmCreateException(new BbmObjectNotFoundException());</span>
				}
			}
			// If timerecord doesn't have any timerecordentry, then just add it.
<span class="nc" id="L1524">			TimeRecordEntry lastEntry = candidate.getLastEntry();</span>
<span class="nc bnc" id="L1525" title="All 4 branches missed.">			if (lastEntry != null &amp;&amp; lastEntry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1526">				lastEntry.setActivityID(Activity.ACTIVITY_MERGE);</span>
<span class="nc" id="L1527">				lastEntry.setPaid((m_ActivityManager.findActivityById(Activity.ACTIVITY_MERGE)).isPaid());</span>
<span class="nc bnc" id="L1528" title="All 2 branches missed.">				if (lastActivityStart != null) {</span>
<span class="nc" id="L1529">					lastEntry.setStartTime(lastActivityStart);</span>
				}
				// We need to specify the TimeSourceCode to Auto_Merge
<span class="nc" id="L1532">				lastEntry.setTimeSourceCode(TimeEntrySourceCode.AUTO_MERGE);</span>
<span class="nc" id="L1533">				addModTimestamp(lastEntry);</span>
<span class="nc" id="L1534">				TimeRecordDAO.updateTimeRecordEntry(lastEntry, m_ResetImmidiateToLastActivity);</span>
<span class="nc" id="L1535">				updateLastEntryCache(lastEntry);</span>
				// now create audit trail for this change
<span class="nc" id="L1537">				AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L1538">						AuditTrailEntry.ACTION_CREATE_OBJECT, candidate.getEmployeeID(),</span>
<span class="nc" id="L1539">						getEmployeeName(lastEntry.getEmployeeID()), lastEntry.getStartTime(), entry.getStartTime());</span>
<span class="nc" id="L1540">				auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L1541">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L1542">				m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
			}
			// TimeCollection shouldn't have Remarker ID, but for Manual
			// EndShift it will pass this information
			// So we need upate TimeRecord if it is approved initially, or there
			// is specific remarker.
<span class="nc bnc" id="L1548" title="All 4 branches missed.">			if (candidate.getApprove() || entry.getRemarkerID() != null) {</span>
<span class="nc bnc" id="L1549" title="All 2 branches missed.">				if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L1550">					candidate.setRemarkEmployeeID(entry.getRemarkerID());</span>
				}
<span class="nc" id="L1552">				candidate.setApprove(false);</span>
<span class="nc" id="L1553">				TimeRecordDAO.updateTimeRecord(candidate, false, false);</span>
			}
			// Add the new entry
<span class="nc" id="L1556">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L1557">			addModTimestamp(entry);</span>
<span class="nc" id="L1558">			entry.setID(TimeRecordDAO.createTimeRecordEntry(entry, m_ResetImmidiateToLastActivity));</span>
<span class="nc bnc" id="L1559" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; TimeRecordCacheUtil.fitsInCache(candidate)) {</span>
				// CachTask: Add to Cache
				// Add entry to candidate first, then update the whole entry
<span class="nc" id="L1562">				candidate.addEntry(entry);</span>
<span class="nc bnc" id="L1563" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L1564">					m_cat.debug(&quot;In createTimeRecordEntryForMerge, new TimeRecord is &quot; + candidate</span>
							+ &quot; , added new entry is &quot; + entry);
				}
<span class="nc" id="L1567">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, candidate);</span>
			}
<span class="nc" id="L1569">			updateLastEntryCache(entry);</span>
<span class="nc" id="L1570">			return entry.getID();</span>
<span class="nc" id="L1571">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L1572">			Object[] param = new Object[3];</span>
<span class="nc" id="L1573">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L1574">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L1575">			param[2] = entry.getParentID();</span>
<span class="nc" id="L1576">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L1577">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1578">		} catch (JdmoException e) {</span>
<span class="nc" id="L1579">			handleException(e);</span>
<span class="nc" id="L1580">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1581">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1582">			handleException(e);</span>
<span class="nc" id="L1583">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1584">		} catch (Exception e) {</span>
<span class="nc" id="L1585">			handleException(e);</span>
<span class="nc" id="L1586">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1588">			methodFinish();</span>
		}
	}

	/**
	 * Simply update an entry to be ready for Merge
	 * 
	 * @param entryID
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntryForMerge(ID entryID) throws BbmUpdateException {
<span class="nc" id="L1600">		methodStart(&quot;updateTimeRecordEntryForMerge&quot;, entryID);</span>
<span class="nc" id="L1601">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1603">			String pStmt = &quot;update TIMEENTRYEVENT set ACTIVITYID=-4005, TIMESOURCECODE=4 where ID=?&quot;;</span>
<span class="nc" id="L1604">			jdmo.executePCommand(pStmt, new Object[] { entryID });</span>
<span class="nc" id="L1605">		} catch (JdmoException e) {</span>
<span class="nc" id="L1606">			handleException(e);</span>
<span class="nc" id="L1607">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1609">			methodFinish();</span>
<span class="nc" id="L1610">		}</span>

<span class="nc" id="L1612">	}</span>

	/**
	 * Add modification timestamp and user name information to an
	 * TimeRecordEntry
	 * 
	 * @param entry
	 */
	private void addModTimestamp(TimeRecordEntry entry) {
<span class="nc" id="L1621">		entry.setLastModifiedTime(new Date());</span>
<span class="nc" id="L1622">		entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L1623">	}</span>

	/**
	 * Returns TimeIntervals of a given time period
	 *
	 * @param Collection
	 *            , WorkResourceID
	 * @param Date
	 *            , start
	 * @param Date
	 *            , end
	 * @return HashMap
	 */
	public HashMap getTimeIntervals(Collection workResourceID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1637">		methodStart(&quot;getTimeIntervals&quot;, workResourceID, start, end);</span>
		try {
<span class="nc" id="L1639">			return TimeRecordDAO.findTimeIntervals(workResourceID, TimeZoneUtil.toTimestamp(start),</span>
<span class="nc" id="L1640">					TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L1641">		} catch (Exception e) {</span>
<span class="nc" id="L1642">			handleException(e, false);</span>
<span class="nc" id="L1643">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1645">			methodFinish();</span>
		}
	} // getTimeIntervals

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 * without close any openshift
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResourceWithOpenShift(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc" id="L1662">		HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="nc" id="L1663">		Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
<span class="nc" id="L1664">		Jdmo jdmo = null;</span>
<span class="nc" id="L1665">		JdmoRowset rs = null;</span>
<span class="nc" id="L1666">		long threadID = Thread.currentThread().getId();</span>
<span class="nc" id="L1667">		String tempTable = &quot;EMP&quot; + threadID;</span>
<span class="nc" id="L1668">		String empIDTempTable = &quot;TIMERECORDEMPID&quot; + threadID;</span>
		try {
<span class="nc" id="L1670">			jdmo = new Jdmo();</span>
			// From JDMO get real temp table name
<span class="nc" id="L1672">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
<span class="nc" id="L1673">			String realEmpIDTempTable = jdmo.getNativeTemptableName(empIDTempTable);</span>
			// Drop temp first
			try {
<span class="nc" id="L1676">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L1677">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L1678">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1680">					m_cat.debug(e);</span>
				}
<span class="nc" id="L1682">			}</span>
			// Create a new temp table
<span class="nc" id="L1684">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="nc" id="L1685">			strSQLCreate.append(realTempTable);</span>
<span class="nc" id="L1686">			strSQLCreate.append(&quot; (ID int)&quot;);</span>
<span class="nc" id="L1687">			jdmo.createTempTable(strSQLCreate.toString());</span>
			// Prepare the employee ID query portion
<span class="nc" id="L1689">			createTempTableForUniqueIntIDs(empIDTempTable, jdmo, workResourceID);</span>
<span class="nc" id="L1690">			StringBuffer pInsert = composeTimeRecordQuery(dtStart, endTime,</span>
					realTempTable, realEmpIDTempTable);
<span class="nc" id="L1692">			jdmo.executeCommand(pInsert.toString());</span>
<span class="nc" id="L1693">			StringBuffer pStmt1 = new StringBuffer(&quot;select A.ID, B.ID, A.EMPLOYEEID, A.LASTMODIFIEDAT, &quot;)</span>
<span class="nc" id="L1694">					.append(TimeRecordDAO.APPROVERCOLSTR).append(&quot;A.REMARK, A.&quot;).append(TimeRecordDAO.REMAKERCOLNAME)</span>
<span class="nc" id="L1695">					.append(&quot;, A.ISPOSTED, A.CHANGECOUNTER, A.ISAPPROVED, A.CHANGESTATUS, RAWTIMEENTRYID, &quot;)</span>
<span class="nc" id="L1696">					.append(&quot;ACTIVITYID, STARTTIME, UPDATETIMESTAMP, TIMESOURCECODE, ISPAID, DATASOURCEID, &quot;)</span>
<span class="nc" id="L1697">					.append(&quot;DESCRIPTION from TIMERECORD A, TIMEENTRYEVENT B, &quot;).append(realTempTable)</span>
<span class="nc" id="L1698">					.append(&quot; E where A.ID=B.TIMERECORDID and A.ID = E.ID&quot;);</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">			if (m_ignoreFutureData) {</span>
<span class="nc" id="L1700">				pStmt1.append(&quot; and UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime());</span>
			}
<span class="nc" id="L1702">			pStmt1.append(&quot; order by A.EMPLOYEEID, A.ID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="nc" id="L1703">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1704">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1705">			ArrayList trArray = null;</span>
<span class="nc bnc" id="L1706" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1707">				ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L1708">				trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L1709" title="All 2 branches missed.">				if (trArray == null) {</span>
<span class="nc" id="L1710">					trArray = new ArrayList();</span>
				}
<span class="nc" id="L1712">				ID key = rs.getID(1);</span>
<span class="nc" id="L1713">				TimeRecord parent = null;</span>
<span class="nc" id="L1714">				TimeRecord previous = null;</span>
<span class="nc" id="L1715">				int last = trArray.size();</span>
<span class="nc bnc" id="L1716" title="All 2 branches missed.">				if (last == 0) {</span>
<span class="nc" id="L1717">					parent = new TimeRecord(key, empID, rs.getID(TimeRecordDAO.REMAKERCOLNAME), TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L1718">							.getTimestamp(&quot;LASTMODIFIEDAT&quot;)), rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L1719">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L1720">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L1721">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L1722">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L1723">					trArray.add(parent);</span>
<span class="nc" id="L1724">					previous = parent;</span>
				} else {
<span class="nc" id="L1726">					previous = (TimeRecord) trArray.get(last - 1);</span>
				}
				// if it is a new timerecord
<span class="nc bnc" id="L1729" title="All 2 branches missed.">				if (!previous.getID().equals(key)) {</span>
<span class="nc" id="L1730">					parent = new TimeRecord(key, empID, rs.getID(TimeRecordDAO.REMAKERCOLNAME), TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L1731">							.getTimestamp(&quot;LASTMODIFIEDAT&quot;)), rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L1732">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L1733">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L1734">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L1735">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L1736">					trArray.add(parent);</span>
				} else {
					// if it is not a new timerecord
<span class="nc" id="L1739">					parent = previous;</span>
				}
<span class="nc" id="L1741">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L1742">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), rs.getID(&quot;RAWTIMEENTRYID&quot;),</span>
<span class="nc" id="L1743">						rs.getID(&quot;ACTIVITYID&quot;), rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(</span>
<span class="nc" id="L1744">								rs.getLong(&quot;UPDATETIMESTAMP&quot;)), rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(&quot;ISPAID&quot;),</span>
<span class="nc" id="L1745">						rs.getString(&quot;DESCRIPTION&quot;), parent);</span>
<span class="nc" id="L1746">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="nc bnc" id="L1748" title="All 2 branches missed.">				if (!temp.isEmpty()) {</span>
<span class="nc" id="L1749">					TimeRecordEntry lastEntry = (TimeRecordEntry) temp.get(temp.size() - 1);</span>
<span class="nc" id="L1750">					lastEntry.setEndTime(entryStart);</span>
				}
				// add the new entry directly
<span class="nc" id="L1753">				parent.addChild(entry);</span>
				// last step is to put it in the hashmap
<span class="nc" id="L1755">				timeRecords.put(empID, trArray);</span>
<span class="nc" id="L1756">			}</span>
			// Last step is to sort the TimeRecord Array, the query honors
			// TimeRecordID sequence before Start Time
<span class="nc bnc" id="L1759" title="All 2 branches missed.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1760">				ID empID = (ID) it.next();</span>
<span class="nc" id="L1761">				ArrayList trList = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L1762" title="All 2 branches missed.">				if (trList != null) {</span>
<span class="nc" id="L1763">					Collections.sort(trList);</span>
<span class="nc" id="L1764">					timeRecords.put(empID, trList);</span>
				}
<span class="nc" id="L1766">			}</span>
<span class="nc" id="L1767">			return timeRecords;</span>
<span class="nc" id="L1768">		} catch (JdmoException e) {</span>
<span class="nc" id="L1769">			handleException(e, false);</span>
<span class="nc" id="L1770">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L1772" title="All 4 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L1774">					rs.close();</span>
<span class="nc" id="L1775">				} catch (Exception e) {</span>
<span class="nc bnc" id="L1776" title="All 4 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1777">						m_cat.debug(e);</span>
					}
<span class="nc" id="L1779">				}</span>
			try {
<span class="nc" id="L1781">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L1782">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L1783">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L1784" title="All 4 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1785">					m_cat.debug(e);</span>
				}
<span class="nc" id="L1787">			}</span>
<span class="nc bnc" id="L1788" title="All 4 branches missed.">			if (jdmo != null)</span>
<span class="nc" id="L1789">				jdmo.cleanUp();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Return all changes since dateLastQuery in TimeRange format Will query
	 * EventAuditTrail, also check Cache version/DB(RealTime feed won't create
	 * AuditTrail)
	 * 
	 * @param Collection
	 *            , colEmployeeIDs, collection of employee ID objects to return
	 *            data for
	 * @param Date
	 *            , dateStart
	 * @param Date
	 *            , dateEnd
	 * @param Date
	 *            , dateLastQuery
	 * @return HashMap
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @return HashMap (EmployeeID, ArrayList of TimeRange, if TimeRange end
	 *         time is null, it means current time)
	 */
	public HashMap getPublishedChangedIntervalsForWorkResource(Collection colEmployeeIDs, Date dateStart, Date dateEnd,
			Date dateLastQuery) throws BbmFinderException {
<span class="nc" id="L1815">		methodStart(&quot;getPublishedChangedIntervalsForWorkResource&quot;, colEmployeeIDs, dateStart, dateEnd, dateLastQuery);</span>
<span class="nc" id="L1816">		Jdmo jdmo = null;</span>
		try {
			// First query EventAuditTrail for changes
<span class="nc" id="L1819">			HashMap auditMap = m_EventAuditTrailManager.getChangedIntervalsForWorkResource(colEmployeeIDs,</span>
					AuditTrailEntry.MODULE_TIMERECORD, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastQuery,
					null, m_ignoreFutureData);
<span class="nc bnc" id="L1822" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1823">				m_cat.debug(&quot;From AuditTrailManager &quot; + auditMap);</span>
			// HashMap to hold window from TimeRecord itself (from real time
			// feed)
<span class="nc" id="L1826">			HashMap eventMap = new HashMap(colEmployeeIDs.size());</span>
			// Result TimeRange HashMap
<span class="nc" id="L1828">			HashMap trMap = new HashMap(colEmployeeIDs.size());</span>
			// ask for changes from Cache and potentially DB
<span class="nc" id="L1830">			Date dbStart = null;</span>
<span class="nc" id="L1831">			Date dbEnd = null;</span>
<span class="nc bnc" id="L1832" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L1833">				Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="nc" id="L1834">				Date cacheStart = null;</span>
<span class="nc" id="L1835">				Date cacheEnd = null;</span>
				// if query window is within cache window, hit cache
<span class="nc bnc" id="L1837" title="All 2 branches missed.">				if (dateStart.after(cacheWindow[0])) {</span>
<span class="nc" id="L1838">					cacheStart = dateStart;</span>
<span class="nc" id="L1839">					cacheEnd = dateEnd;</span>
				} else {
					// if window falls before cache start, split into two parts
<span class="nc" id="L1842">					dbStart = dateStart;</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">					if (dateEnd.after(cacheWindow[0])) {</span>
<span class="nc" id="L1844">						cacheStart = cacheWindow[0];</span>
<span class="nc" id="L1845">						cacheEnd = dateEnd;</span>
<span class="nc" id="L1846">						dbEnd = cacheStart;</span>
					} else {
<span class="nc" id="L1848">						dbEnd = dateEnd;</span>
					}
				}
<span class="nc bnc" id="L1851" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1852">					m_cat.debug(&quot;Using cache from &quot; + cacheStart + &quot; to &quot; + cacheEnd);</span>
<span class="nc bnc" id="L1853" title="All 4 branches missed.">				if (cacheStart != null &amp;&amp; cacheEnd != null) {</span>
<span class="nc" id="L1854">					HashMap timeRecordMap = getEventsForWorkResourceFromCache(colEmployeeIDs, cacheStart, cacheEnd,</span>
							true);
<span class="nc bnc" id="L1856" title="All 2 branches missed.">					for (Iterator it = colEmployeeIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1857">						ID empID = (ID) it.next();</span>
<span class="nc" id="L1858">						ArrayList recordCol = (ArrayList) timeRecordMap.get(empID);</span>
						// convert cached changed entry to TimeRange
<span class="nc" id="L1860">						ArrayList affectedWindowCol = new ArrayList();</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">						if (recordCol != null) {</span>
<span class="nc bnc" id="L1862" title="All 2 branches missed.">							for (Iterator recordIt = recordCol.iterator(); recordIt.hasNext();) {</span>
<span class="nc" id="L1863">								TimeRecord record = (TimeRecord) recordIt.next();</span>
<span class="nc bnc" id="L1864" title="All 2 branches missed.">								for (Iterator entryIt = record.getChild().iterator(); entryIt.hasNext();) {</span>
<span class="nc" id="L1865">									TimeRecordEntry entry = (TimeRecordEntry) entryIt.next();</span>
									// if entry ends after lastQuery, which
									// means it is open in last check
<span class="nc bnc" id="L1868" title="All 2 branches missed.">									if (entry.getStartTime().before(dateLastQuery)</span>
<span class="nc bnc" id="L1869" title="All 4 branches missed.">											&amp;&amp; (entry.getEndTime() == null || entry.getEndTime().after(dateLastQuery))) {</span>
<span class="nc" id="L1870">										TimeRange tr = new TimeRange(dateLastQuery,</span>
<span class="nc bnc" id="L1871" title="All 2 branches missed.">												entry.getEndTime() == null ? new Date() : entry.getEndTime());</span>
<span class="nc" id="L1872">										affectedWindowCol.add(tr);</span>
<span class="nc bnc" id="L1873" title="All 2 branches missed.">										if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1874">											m_cat.debug(&quot;Find entry &quot; + entry + &quot; starts before &quot; + dateLastQuery</span>
<span class="nc" id="L1875">													+ &quot; ends after &quot; + entry.getEndTime() + &quot; create TR &quot; + tr);</span>
										}
<span class="nc bnc" id="L1877" title="All 2 branches missed.">									} else if (entry.getStartTime().after(dateLastQuery)</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">											|| (entry.getLastModifiedTime() != null &amp;&amp; entry.getLastModifiedTime()</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">													.after(dateLastQuery))) {</span>
										// if entry created or modified after,
										// add the time range
<span class="nc bnc" id="L1882" title="All 2 branches missed.">										Date end = entry.getEndTime() == null ? new Date() : entry.getEndTime();</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">										if (end.before(entry.getStartTime())) {</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">											if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1885">												m_cat.debug(&quot;Abnormal case handling when entry starts &quot;</span>
<span class="nc" id="L1886">														+ entry.getStartTime() + &quot; after end time &quot; + end);</span>
											}
<span class="nc" id="L1888">											end = new Date(entry.getStartTime().getTime()</span>
													+ TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);
										}
<span class="nc" id="L1891">										TimeRange tr = new TimeRange(entry.getStartTime(), end);</span>
<span class="nc" id="L1892">										affectedWindowCol.add(tr);</span>
<span class="nc bnc" id="L1893" title="All 2 branches missed.">										if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1894">											m_cat.debug(&quot;Find entry &quot; + entry + &quot; starts after &quot; + dateLastQuery</span>
													+ &quot; create TR &quot; + tr);
										}
									}
<span class="nc" id="L1898">								}</span>
<span class="nc" id="L1899">							}</span>
						}
<span class="nc" id="L1901">						eventMap.put(empID, affectedWindowCol);</span>
<span class="nc" id="L1902">					}</span>
				}
<span class="nc" id="L1904">			} else {</span>
<span class="nc" id="L1905">				dbStart = dateStart;</span>
<span class="nc" id="L1906">				dbEnd = DateAdjustmentUtil.adjustEndDateForDemo(dateEnd, m_ignoreFutureData);</span>
			}
			// Track employees has no entries from DB, if they are not logged
			// in, we won't return changed interval
<span class="nc" id="L1910">			HashSet empSet = new HashSet(colEmployeeIDs.size());</span>
			// if need access DB to figure out changed window, we will just
			// query TimeRecord window size
			// this is mostly to query real time aderence record, which hasn't
			// been touched by manager
			// HAA data is already reflected through event audit trail
			// No need consider AutoClose(3), as if there is autoclose, an
			// eventaudittrail will be created
			// No need consider HAA entries(6), an eventaudittrail will be
			// created covering the window
			// No need consider manual edit(1)
			// So consider RawEntry, MyTime, Schedule and AutoMerge
<span class="nc bnc" id="L1922" title="All 4 branches missed.">			if (dbStart != null &amp;&amp; dbEnd != null) {</span>
<span class="nc bnc" id="L1923" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1924">					m_cat.debug(&quot;Load from DB from &quot; + dbStart + &quot; to &quot; + dbEnd);</span>
				}
<span class="nc" id="L1926">				jdmo = new Jdmo();</span>
<span class="nc" id="L1927">				String empInClause = jdmo.createInClause(colEmployeeIDs);</span>
<span class="nc" id="L1928">				StringBuffer pStmt1 = new StringBuffer(&quot;select EMPLOYEEID, ACTIVITYID, STARTTIME&quot;)</span>
<span class="nc" id="L1929">						.append(&quot; from TIMEENTRYEVENT where EMPLOYEEID in &quot;).append(empInClause)</span>
<span class="nc" id="L1930">						.append(&quot; and TIMESOURCECODE not in (1,3,6) and UPDATETIMESTAMP&gt;=&quot;).append(dbStart.getTime())</span>
<span class="nc" id="L1931">						.append(&quot; and UPDATETIMESTAMP&lt;=&quot;).append(dbEnd.getTime()).append(&quot; and (LASTMODIFIEDAT&gt;'&quot;)</span>
<span class="nc" id="L1932">						.append(JdmoUtil.formatDBString(dateLastQuery))</span>
<span class="nc" id="L1933">						.append(&quot;' or LASTMODIFIEDAT is null) order by EMPLOYEEID, UPDATETIMESTAMP asc&quot;);</span>
<span class="nc bnc" id="L1934" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1935">					m_cat.debug(&quot;Load changed entries by &quot; + pStmt1);</span>
				}
<span class="nc" id="L1937">				JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1938">				JdmoRowset rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
				// First fetch all entries
<span class="nc" id="L1940">				HashMap entryMap = new HashMap(colEmployeeIDs.size());</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L1942">					ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L1943">					ArrayList entryCol = (ArrayList) entryMap.get(empID);</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">					if (entryCol == null) {</span>
<span class="nc" id="L1945">						entryCol = new ArrayList();</span>
					}
<span class="nc" id="L1947">					TimeRecordEntry entry = new TimeRecordEntry(rs.getID(&quot;ACTIVITYID&quot;), TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L1948">							.getTimestamp(&quot;STARTTIME&quot;)), null, 0, false, null);</span>
<span class="nc" id="L1949">					entryCol.add(entry);</span>
<span class="nc" id="L1950">					entryMap.put(empID, entryCol);</span>
<span class="nc" id="L1951">				}</span>
				// iterate the HashMap, convert modified entries to just one
				// TimeRange
<span class="nc bnc" id="L1954" title="All 2 branches missed.">				for (Iterator empIt = colEmployeeIDs.iterator(); empIt.hasNext();) {</span>
<span class="nc" id="L1955">					ID empID = (ID) empIt.next();</span>
<span class="nc" id="L1956">					ArrayList entryCol = (ArrayList) entryMap.get(empID);</span>
<span class="nc bnc" id="L1957" title="All 2 branches missed.">					if (entryCol == null) {</span>
<span class="nc" id="L1958">						empSet.add(empID);</span>
<span class="nc bnc" id="L1959" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1960">							m_cat.debug(&quot;Find no change for an employee, will check in/out status later, empID &quot;</span>
									+ empID);
						}
						continue;
					}
<span class="nc" id="L1965">					Iterator teIt = entryCol.iterator();</span>
<span class="nc" id="L1966">					TimeRecordEntry entry = (TimeRecordEntry) teIt.next();</span>
<span class="nc" id="L1967">					Date rangeStart = entry.getStartTime();</span>
<span class="nc" id="L1968">					Date rangeEnd = entry.getStartTime();</span>
<span class="nc" id="L1969">					ID lastEntryActID = entry.getActivityID();</span>
<span class="nc bnc" id="L1970" title="All 2 branches missed.">					while (teIt.hasNext()) {</span>
<span class="nc" id="L1971">						TimeRecordEntry nextEntry = (TimeRecordEntry) teIt.next();</span>
<span class="nc" id="L1972">						rangeEnd = nextEntry.getStartTime();</span>
<span class="nc" id="L1973">						lastEntryActID = nextEntry.getActivityID();</span>
<span class="nc" id="L1974">					}</span>
					// if last entry is end shift, cannot determine the effected
					// window directly
					// so specify null as end time, adherence will load all
					// entries to narrow down
					// THERE is a potential bug, case like, lastcheck happens at
					// 8:05, now it is 8:20
					// entry 1 8:00
					// entry 2 8:10
					// entry 1 ends at 8:05, but we may report 8:10 to 8:20 only
					// 8:05 to 8:10 is not reported, to solve this system has to
					// look back for the last entry before 8:05
					// but if we have cache enabled, this routine only happens
					// on historical data, which is fine
<span class="nc bnc" id="L1988" title="All 2 branches missed.">					if (lastEntryActID.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1989">						rangeEnd = null;</span>
					} else {
						// else Add one minute to start time of the last entry
						// to serve as end window
<span class="nc" id="L1993">						rangeEnd.setTime(rangeEnd.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
					}
<span class="nc bnc" id="L1995" title="All 2 branches missed.">					if (rangeEnd == null) {</span>
<span class="nc" id="L1996">						rangeEnd = new Date();</span>
<span class="nc bnc" id="L1997" title="All 2 branches missed.">						if (rangeStart.after(rangeEnd)) {</span>
<span class="nc bnc" id="L1998" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1999">								m_cat.debug(&quot;Abnormal case in deciding the TimeRange, start &quot; + rangeStart</span>
										+ &quot; is after cur time &quot; + rangeEnd);
							}
<span class="nc" id="L2002">							rangeEnd = new Date(rangeStart.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
						}
					}
<span class="nc" id="L2005">					TimeRange tr = new TimeRange(rangeStart, rangeEnd);</span>
<span class="nc" id="L2006">					ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2007">					list.add(tr);</span>
<span class="nc bnc" id="L2008" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2009">						m_cat.debug(&quot;Converted entries to &quot; + tr);</span>
					}
<span class="nc" id="L2011">					eventMap.put(empID, list);</span>
<span class="nc" id="L2012">				}</span>
			}
			// check employees without entries in/out status, for in employee,
			// guess a range
<span class="nc bnc" id="L2016" title="All 2 branches missed.">			if (!empSet.isEmpty()) {</span>
<span class="nc" id="L2017">				Collection inEmp = whoIsIn(empSet, false);</span>
<span class="nc bnc" id="L2018" title="All 2 branches missed.">				for (Iterator it = inEmp.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2019">					ID empID = (ID) it.next();</span>
					// Cannot determine the change window just add last Query to
					// curDate
<span class="nc" id="L2022">					TimeRange tr = new TimeRange(dateLastQuery, new Date());</span>
<span class="nc" id="L2023">					ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L2024">					list.add(tr);</span>
<span class="nc" id="L2025">					eventMap.put(empID, list);</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2027">						m_cat.debug(&quot;Find no change for a logged in employee, guess a tr &quot; + tr);</span>
					}
<span class="nc" id="L2029">				}</span>
			}
			// last step merge two TimeRange collection from EventAuditTrail and
			// Entry
<span class="nc bnc" id="L2033" title="All 2 branches missed.">			for (Iterator it = colEmployeeIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2034">				ID empID = (ID) it.next();</span>
				// result of merge
<span class="nc" id="L2036">				ArrayList timeRangeCol = new ArrayList();</span>
				// container to merge two lists of Time Range
<span class="nc" id="L2038">				ArrayList timeWindowCol = new ArrayList();</span>
<span class="nc" id="L2039">				ArrayList auditWindowCol = (ArrayList) auditMap.get(empID);</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">				if (auditWindowCol != null) {</span>
<span class="nc" id="L2041">					timeWindowCol.addAll(auditWindowCol);</span>
				}
<span class="nc" id="L2043">				ArrayList affectedWindowCol = (ArrayList) eventMap.get(empID);</span>
<span class="nc bnc" id="L2044" title="All 2 branches missed.">				if (affectedWindowCol != null) {</span>
<span class="nc" id="L2045">					timeWindowCol.addAll(affectedWindowCol);</span>
				}
<span class="nc bnc" id="L2047" title="All 2 branches missed.">				if (timeWindowCol.isEmpty()) {</span>
<span class="nc" id="L2048">					continue;</span>
				}
				// sort both ranges
<span class="nc" id="L2051">				Collections.sort(timeWindowCol);</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2053">					m_cat.debug(&quot;Merged tr &quot; + timeWindowCol);</span>
				// iterate the collection
<span class="nc" id="L2055">				Iterator li = timeWindowCol.iterator();</span>
<span class="nc" id="L2056">				TimeRange entry = (TimeRange) li.next();</span>
<span class="nc" id="L2057">				Date windowStart = entry.getStartDate();</span>
<span class="nc" id="L2058">				Date windowEnd = entry.getEndDate();</span>
<span class="nc bnc" id="L2059" title="All 2 branches missed.">				while (li.hasNext()) {</span>
					// get next entry
<span class="nc" id="L2061">					entry = (TimeRange) li.next();</span>
					// if existing window ends before current entry start,
					// create a range
<span class="nc bnc" id="L2064" title="All 4 branches missed.">					if (windowEnd != null &amp;&amp; windowEnd.before(entry.getStartDate())) {</span>
<span class="nc" id="L2065">						TimeRange tr = new TimeRange(windowStart, windowEnd);</span>
<span class="nc" id="L2066">						timeRangeCol.add(tr);</span>
<span class="nc" id="L2067">						windowStart = entry.getStartDate();</span>
<span class="nc" id="L2068">						windowEnd = entry.getEndDate();</span>
<span class="nc" id="L2069">					} else {</span>
						// there is overlap, if new entry end time is null, set
						// window end to null
<span class="nc bnc" id="L2072" title="All 2 branches missed.">						if (entry.getEndDate() == null) {</span>
<span class="nc" id="L2073">							windowEnd = null;</span>
						} else {
							// if window end is not null, new entry ends after
							// window end, set value
<span class="nc bnc" id="L2077" title="All 4 branches missed.">							if (windowEnd != null &amp;&amp; entry.getEndDate().after(windowEnd)) {</span>
<span class="nc" id="L2078">								windowEnd = entry.getEndDate();</span>
							}
						}
					}
				}
				// Add last window
<span class="nc bnc" id="L2084" title="All 2 branches missed.">				if (windowEnd == null) {</span>
<span class="nc" id="L2085">					windowEnd = new Date();</span>
				}
<span class="nc" id="L2087">				TimeRange tr = new TimeRange(windowStart, windowEnd);</span>
<span class="nc" id="L2088">				timeRangeCol.add(tr);</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2090">					m_cat.debug(&quot;final merged tr &quot; + timeRangeCol);</span>
				}
<span class="nc" id="L2092">				trMap.put(empID, timeRangeCol);</span>
<span class="nc" id="L2093">			}</span>
<span class="nc" id="L2094">			return trMap;</span>
<span class="nc" id="L2095">		} catch (JdmoException e) {</span>
<span class="nc" id="L2096">			handleException(e);</span>
<span class="nc" id="L2097">			throw new BbmFinderException(e);</span>
<span class="nc" id="L2098">		} catch (RemoteException e) {</span>
<span class="nc" id="L2099">			handleException(e);</span>
<span class="nc" id="L2100">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2102" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L2103">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L2105">			methodFinish();</span>
		}
	}

	/**
	 * Get the events from TimeRecord and TimeEntryEvent table Depend on
	 * needOpenShift to retrieve an open shift even before the given period It
	 * will look forward for any shift just before the starting point, even if
	 * it is an Open Shift scenario 1/2 00:00 - 1/3 00:00 if a shift starts at
	 * 2pm, with several activities happened just before 1/2 00:00 and there is
	 * no end shift yet, we will pick it up To speed up, we will push backward
	 * the Starting time of 24 hours
	 *
	 * @param Collection
	 *            , workResourceID
	 * @param Date
	 *            , dtStart
	 * @param Date
	 *            , dtEnd
	 * @param boolean, needOpenShift
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResourceFromCache(Collection workResourceIDCol, Date dtStart, Date dtEnd,
			boolean needOpenShift) throws BbmFinderException {
<span class="nc" id="L2130">		methodStart(&quot;getEventsForWorkResourceFromCache&quot;, workResourceIDCol, dtStart, dtEnd,</span>
<span class="nc" id="L2131">				JdmoParam.getObject(needOpenShift));</span>
		try {
			// First check the time window falls before oldest cached content
			// start time or not, if true, it won't hit any cache at all
			// just access DB directly
<span class="nc" id="L2136">			Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
			// If request starts after cached window, just return empty result
<span class="nc bnc" id="L2138" title="All 2 branches missed.">			if (dtStart.after(cacheWindow[1])) {</span>
<span class="nc" id="L2139">				return new HashMap(1);</span>
			}
			// If request ends before cached window, need retrieve directly from
			// DB
			// If cache is disabled, go to DB directly
<span class="nc bnc" id="L2144" title="All 4 branches missed.">			if (!cacheUsed() || dtEnd.before(cacheWindow[0])) {</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L2146">					m_cat.debug(&quot;Requested timewindow from &quot; + dtStart + &quot; to &quot; + dtEnd</span>
							+ &quot; is either way before cache window &quot; + cacheWindow[0] + &quot; or Cache is not used.&quot;);
				}
<span class="nc" id="L2149">				return getEventsForWorkResource(workResourceIDCol, dtStart, dtEnd, needOpenShift);</span>
			}
			// HashMap to hold TimeRecord for each workresource
<span class="nc" id="L2152">			HashMap empTRMap = new HashMap(workResourceIDCol.size());</span>
			// Track who is not in cache
<span class="nc" id="L2154">			ArrayList empMissedCol = new ArrayList();</span>
			// Track DB lookup timewindow
<span class="nc" id="L2156">			Date reloadStart = cacheWindow[0];</span>
			// Track end shift close date
<span class="nc" id="L2158">			Date curTime = new Date();</span>
<span class="nc bnc" id="L2159" title="All 2 branches missed.">			Date lastEntryCloseDate = curTime.after(dtEnd) ? dtEnd : curTime;</span>
			// Request time window falls in the cache window, hit cache first
			// This execution path is the most used one, especially from
			// Adherence backend
			// no need to check dtEnd.before(cacheWindow[1]) after we assume
			// there is no record in the future
<span class="nc bnc" id="L2165" title="All 2 branches missed.">			if (dtStart.after(cacheWindow[0])) {</span>
<span class="nc bnc" id="L2166" title="All 2 branches missed.">				for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2167">					ID empID = (ID) it.next();</span>
<span class="nc" id="L2168">					TimeRecord[] records = (TimeRecord[]) m_TimeRecordCache.get(empID);</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">					if (records == null) {</span>
<span class="nc bnc" id="L2170" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2171">							m_cat.debug(&quot;Cache missed for workresource id &quot; + empID + &quot; from &quot; + dtStart + &quot; to &quot;</span>
									+ dtEnd);
						}
<span class="nc" id="L2174">						empMissedCol.add(empID);</span>
					} else {
<span class="nc" id="L2176">						ArrayList trCol = TimeRecordCacheUtil.convertToArrayList(records);</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2178">							m_cat.debug(&quot;Cache contains following records &quot; + trCol + &quot; for workresource id &quot; + empID);</span>
						}
<span class="nc" id="L2180">						int curSize = records.length;</span>
<span class="nc" id="L2181">						ArrayList updateCache = TimeRecordCacheUtil.filterTimeRecords(trCol, cacheWindow[0], true);</span>
<span class="nc" id="L2182">						int filteredSize = updateCache.size();</span>
<span class="nc bnc" id="L2183" title="All 2 branches missed.">						if (curSize != filteredSize) {</span>
							// We enhance here, to purge very old timerecords
							// from cache
							// Algorithm is like: find the timerecord cross
							// starttime of
							// the cache, put back this one and records newer
							// than it into cache
							// If all timerecords are before cache startime,
							// just put back the newest record
							// This is a cache cleanup routine for TimeRecord
							// cache
							// So there is always at least one record in the
							// cache, which
							// represents last timerecord of the employee in the
							// system
							// If there is no records in cache, it implies this
							// user has
							// never been loaded.
							// 1. Filtered out obsolete records based on cache
							// window
<span class="nc" id="L2203">							TimeRecordCacheUtil.purgeCache(m_TimeRecordCache, empID, cacheWindow[0]);</span>
						}
<span class="nc bnc" id="L2205" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2206">							m_cat.debug(&quot;Put back records &quot; + updateCache + &quot; to cache for workresource id &quot; + empID);</span>
						}
						// 2. Filtered by request window, and also close open
						// time records
<span class="nc" id="L2210">						ArrayList returnedCache = TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2211">								TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate);</span>
<span class="nc" id="L2212">						empTRMap.put(empID, returnedCache);</span>
<span class="nc bnc" id="L2213" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L2214">							m_cat.debug(&quot;Return records &quot; + returnedCache + &quot; for workresource id &quot; + empID);</span>
						}
					}
<span class="nc" id="L2217">				}</span>
			} else {
				// Last scenario is start window is before cache start, we will
				// just reload full cache
<span class="nc" id="L2221">				empMissedCol = new ArrayList(workResourceIDCol);</span>
<span class="nc" id="L2222">				reloadStart = dtStart;</span>
			}
<span class="nc bnc" id="L2224" title="All 2 branches missed.">			if (!empMissedCol.isEmpty()) {</span>
<span class="nc bnc" id="L2225" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L2226">					m_cat.debug(&quot;Need load timerecords for &quot; + empMissedCol + &quot; from &quot; + reloadStart + &quot; to &quot;</span>
							+ cacheWindow[1]);
				}
				// Now we load bigger timewindow
<span class="nc" id="L2230">				Timestamp startFrom = TimeZoneUtil</span>
<span class="nc" id="L2231">						.toTimestamp(new Date(reloadStart.getTime() - getConfigData(LOOKBACK)));</span>
<span class="nc" id="L2232">				HashMap missedTRMap = getEventsForWorkResourceWithOpenShift(empMissedCol, startFrom,</span>
<span class="nc" id="L2233">						TimeZoneUtil.toTimestamp(cacheWindow[1]));</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">				for (Iterator it = empMissedCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2235">					ID empID = (ID) it.next();</span>
<span class="nc" id="L2236">					ArrayList trCol = (ArrayList) missedTRMap.get(empID);</span>
<span class="nc bnc" id="L2237" title="All 4 branches missed.">					if (trCol == null || trCol.isEmpty()) {</span>
						// put a dummy timerecord into cache, to avoid reload
						// it will be removed in any valid add timerecord
						// operation
<span class="nc bnc" id="L2241" title="All 2 branches missed.">						if (trCol == null) {</span>
<span class="nc" id="L2242">							trCol = new ArrayList(1);</span>
						}
<span class="nc" id="L2244">						trCol.add(new TimeRecord(empID));</span>
						// return empty collection
<span class="nc" id="L2246">						empTRMap.put(empID, new ArrayList(1));</span>
					} else {
						// filter out records not in request time window
<span class="nc" id="L2249">						empTRMap.put(empID, TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2250">								TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate));</span>
					}
					// put back into cache
<span class="nc" id="L2253">					m_TimeRecordCache.put(empID, TimeRecordCacheUtil.convertToArray(TimeRecordCacheUtil</span>
<span class="nc" id="L2254">							.filterTimeRecords(trCol, cacheWindow[0], true)));</span>
<span class="nc" id="L2255">				}</span>
<span class="nc" id="L2256">			} else {</span>
<span class="nc" id="L2257">				return empTRMap;</span>
			}
<span class="nc" id="L2259">			return empTRMap;</span>
<span class="nc" id="L2260">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2261">			handleException(e, false);</span>
<span class="nc" id="L2262">			throw e;</span>
<span class="nc" id="L2263">		} catch (Exception e) {</span>
<span class="nc" id="L2264">			handleException(e, false);</span>
<span class="nc" id="L2265">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2267">			methodFinish();</span>
		}
	}

	/**
	 * Explicitly refresh cache for one user
	 * 
	 * @param Collection
	 *            , WorkResourceID
	 */
	public void refreshCacheForWorkResource(Collection workResourceIDCol) throws BbmFinderException {
<span class="nc" id="L2278">		methodStart(&quot;refreshCacheForWorkResource&quot;, workResourceIDCol);</span>
<span class="nc bnc" id="L2279" title="All 2 branches missed.">		if (cacheUsed()) {</span>
			try {
<span class="nc bnc" id="L2281" title="All 2 branches missed.">				if (m_TimeRecordCache != null) {</span>
					// Now we load bigger timewindow
<span class="nc" id="L2283">					Date[] cacheWindow = TimeRecordCacheUtil.getCurrentCacheWindow(getConfigData(CACHEDINTV));</span>
<span class="nc" id="L2284">					Timestamp startFrom = TimeZoneUtil.toTimestamp(new Date(cacheWindow[0].getTime()</span>
<span class="nc" id="L2285">							- getConfigData(LOOKBACK)));</span>
<span class="nc" id="L2286">					HashMap trMap = getEventsForWorkResourceWithOpenShift(workResourceIDCol, startFrom,</span>
<span class="nc" id="L2287">							TimeZoneUtil.toTimestamp(cacheWindow[1]));</span>
<span class="nc bnc" id="L2288" title="All 2 branches missed.">					for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2289">						ID workResourceID = (ID) it.next();</span>
<span class="nc" id="L2290">						ArrayList trCol = (ArrayList) trMap.get(workResourceID);</span>
<span class="nc bnc" id="L2291" title="All 4 branches missed.">						if (trCol == null || trCol.isEmpty()) {</span>
							// put a dummy timerecord into cache, to avoid
							// reload
							// it will be removed in any valid add timerecord
							// operation
<span class="nc bnc" id="L2296" title="All 2 branches missed.">							if (trCol == null) {</span>
<span class="nc" id="L2297">								trCol = new ArrayList(1);</span>
							}
<span class="nc" id="L2299">							trCol.add(new TimeRecord(workResourceID));</span>
						}
						// put back into cache
<span class="nc" id="L2302">						m_TimeRecordCache.put(workResourceID, TimeRecordCacheUtil.convertToArray(TimeRecordCacheUtil</span>
<span class="nc" id="L2303">								.filterTimeRecords(trCol, cacheWindow[0], true)));</span>
<span class="nc" id="L2304">					}</span>
				}
<span class="nc bnc" id="L2306" title="All 2 branches missed.">				if (m_LastEntryCache != null) {</span>
<span class="nc" id="L2307">					Collection entryCol = TimeRecordDAO.findLastEntry(workResourceIDCol, new Date(),</span>
							m_LookBackTimeEntryDays);
<span class="nc bnc" id="L2309" title="All 2 branches missed.">					for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2310">						TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L2311">						m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
<span class="nc" id="L2312">						workResourceIDCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L2313">					}</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">					for (Iterator it = workResourceIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2315">						ID empID = (ID) it.next();</span>
<span class="nc" id="L2316">						m_LastEntryCache.put(empID, new TimeRecordEntry());</span>
<span class="nc" id="L2317">					}</span>
				}
<span class="nc" id="L2319">			} catch (JdmoException e) {</span>
<span class="nc" id="L2320">				handleException(e, false);</span>
<span class="nc" id="L2321">				throw new BbmFinderException(e);</span>
			} finally {
<span class="nc" id="L2323">				methodFinish();</span>
<span class="nc" id="L2324">			}</span>
		}
<span class="nc" id="L2326">	}</span>

	/**
	 * Get the events from TimeRecord and TimeEntryEvent table Depend on
	 * needOpenShift to retrieve an open shift even before the given period It
	 * will look forward for any shift just before the starting point, even if
	 * it is an Open Shift scenario 1/2 00:00 - 1/3 00:00 if a shift starts at
	 * 2pm, with several activities happened just before 1/2 00:00 and there is
	 * no end shift yet, we will pick it up To speed up, we will push backward
	 * the Starting time of 24 hours
	 *
	 * @param Collection
	 *            , workResourceID
	 * @param Date
	 *            , dtStart
	 * @param Date
	 *            , dtEnd
	 * @param boolean, needOpenShift
	 * @return HashMap
	 * @exception BbmFinderException
	 * @deprecated
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd, boolean needOpenShift)
			throws BbmFinderException {
<span class="nc" id="L2350">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd, JdmoParam.getObject(needOpenShift));</span>
		try {
<span class="nc bnc" id="L2352" title="All 2 branches missed.">			if (!needOpenShift) {</span>
<span class="nc" id="L2353">				return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2354">						TimeZoneUtil.toTimestamp(dtEnd));</span>
			}

			// We expand window 24 hours earlier
<span class="nc" id="L2358">			HashMap map = getEventsForWorkResource(workResourceID,</span>
<span class="nc" id="L2359">					TimeZoneUtil.toTimestamp(new Date(dtStart.getTime() - getConfigData(LOOKBACK))),</span>
<span class="nc" id="L2360">					TimeZoneUtil.toTimestamp(dtEnd));</span>
			// for 1/2 00:00 - 1/3 00:00, the window is 1/1 00:00 - 1/3 00:00
			// and remove those shifts will end before 1/2 00:00
			// If there is 1/1 7am-8am-9am open shift, 1/1 10pm-11pm-1/2 1am end
			// shift
			// the first open shift will still be removed,
			// coz the second is the closest cross boundary shift
<span class="nc" id="L2367">			Date curTime = new Date();</span>
<span class="nc bnc" id="L2368" title="All 2 branches missed.">			Date lastEntryCloseDate = curTime.after(dtEnd) ? dtEnd : curTime;</span>
<span class="nc bnc" id="L2369" title="All 2 branches missed.">			for (Iterator itWR = workResourceID.iterator(); itWR.hasNext();) {</span>
<span class="nc" id="L2370">				ID empID = (ID) itWR.next();</span>
<span class="nc" id="L2371">				ArrayList trCol = (ArrayList) map.get(empID);</span>
				// it doesn't care about the latest timerecord if it is totally
				// out of the timewindow
				try {
<span class="nc" id="L2375">					map.put(empID,</span>
<span class="nc" id="L2376">							TimeRecordCacheUtil.closeOpenTimeRecords(</span>
<span class="nc" id="L2377">									TimeRecordCacheUtil.filterTimeRecords(trCol, dtStart, false), lastEntryCloseDate));</span>
<span class="nc" id="L2378">				} catch (Exception e) {</span>
<span class="nc" id="L2379">					m_cat.debug(e);</span>
<span class="nc" id="L2380">				}</span>
<span class="nc" id="L2381">			}</span>
<span class="nc" id="L2382">			return map;</span>
		} finally {
<span class="nc" id="L2384">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2400">		return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2401">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param Collection
	 *            of workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return HashMap
	 * @exception BbmFinderException
	 */
	public HashMap getEventsForWorkResource(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2416">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="nc" id="L2417">		Jdmo jdmo = null;</span>
<span class="nc" id="L2418">		JdmoRowset rs = null;</span>
		try {
<span class="nc bnc" id="L2420" title="All 8 branches missed.">			if (workResourceID == null || workResourceID.isEmpty() || dtStart == null || dtEnd == null)</span>
<span class="nc" id="L2421">				return new HashMap(0);</span>
<span class="nc" id="L2422">			Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
<span class="nc" id="L2423">			HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="nc" id="L2424">			jdmo = new Jdmo();</span>
<span class="nc" id="L2425">			String empInClause = jdmo.createInClause(workResourceID);</span>
<span class="nc" id="L2426">			StringBuffer pStmt1 = new StringBuffer(</span>
					&quot;select B.TIMERECORDID, B.ID, B.EMPLOYEEID, B.DATASOURCEID, ISPAID, ACTIVITYID, STARTTIME, &quot;)
<span class="nc" id="L2428">					.append(&quot;UPDATETIMESTAMP from &quot;).append(&quot;TIMEENTRYEVENT B where B.EMPLOYEEID in &quot;)</span>
<span class="nc" id="L2429">					.append(empInClause).append(&quot; and B.UPDATETIMESTAMP&lt;=&quot;).append(endTime.getTime())</span>
<span class="nc" id="L2430">					.append(&quot; and B.UPDATETIMESTAMP&gt;=&quot;).append(dtStart.getTime())</span>
<span class="nc" id="L2431">					.append(&quot; order by B.EMPLOYEEID, B.TIMERECORDID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="nc" id="L2432">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2433">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2434">			ArrayList trArray = null;</span>
<span class="nc bnc" id="L2435" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2436">				ID empID = rs.getID(&quot;EMPLOYEEID&quot;);</span>
<span class="nc" id="L2437">				trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L2438" title="All 2 branches missed.">				if (trArray == null)</span>
<span class="nc" id="L2439">					trArray = new ArrayList();</span>
<span class="nc" id="L2440">				ID key = rs.getID(1);</span>
<span class="nc" id="L2441">				TimeRecord parent = null;</span>
<span class="nc" id="L2442">				TimeRecord previous = null;</span>
<span class="nc" id="L2443">				int last = trArray.size();</span>
<span class="nc bnc" id="L2444" title="All 2 branches missed.">				if (last == 0) {</span>
<span class="nc" id="L2445">					parent = new TimeRecord(key, empID, null, null, null, null, null, false, false);</span>
<span class="nc" id="L2446">					trArray.add(parent);</span>
<span class="nc" id="L2447">					previous = parent;</span>
				} else {
<span class="nc" id="L2449">					previous = (TimeRecord) trArray.get(last - 1);</span>
				}
				// if it is a new timerecord
<span class="nc bnc" id="L2452" title="All 2 branches missed.">				if (!previous.getID().equals(key)) {</span>
<span class="nc" id="L2453">					parent = new TimeRecord(key, empID, null, null, null, null, null, false, false);</span>
<span class="nc" id="L2454">					trArray.add(parent);</span>
				} else {
					// if it is not a new timerecord
<span class="nc" id="L2457">					parent = previous;</span>
				}
<span class="nc" id="L2459">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L2460">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), null, rs.getID(&quot;ACTIVITYID&quot;),</span>
<span class="nc" id="L2461">						rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(rs.getLong(&quot;UPDATETIMESTAMP&quot;)),</span>
<span class="nc" id="L2462">						TimeRecordEntry.RAWPUNCH, rs.getBoolean(&quot;ISPAID&quot;), null, parent);</span>
				// do this explicitly to overcome WLS serilization bug
<span class="nc" id="L2464">				entry.setEmployeeID(empID);</span>
<span class="nc" id="L2465">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="nc bnc" id="L2467" title="All 2 branches missed.">				if (!temp.isEmpty()) {</span>
<span class="nc" id="L2468">					TimeRecordEntry lastEntry = (TimeRecordEntry) temp.get(temp.size() - 1);</span>
<span class="nc" id="L2469">					lastEntry.setEndTime(entryStart);</span>
				}
				// add the new entry directly
<span class="nc" id="L2472">				parent.addChild(entry);</span>
				// last step is to put it in the hashmap
<span class="nc" id="L2474">				timeRecords.put(empID, trArray);</span>
<span class="nc" id="L2475">			}</span>
			// Last step is to iterate the TimeRecordEntries to set the open
			// shift
<span class="nc" id="L2478">			Date currentTime = new Date();</span>
<span class="nc" id="L2479">			Date closerEnd = currentTime;</span>
<span class="nc bnc" id="L2480" title="All 2 branches missed.">			if (currentTime.after(endTime)) {</span>
<span class="nc" id="L2481">				closerEnd = TimeZoneUtil.toDate(endTime);</span>
			}
<span class="nc bnc" id="L2483" title="All 2 branches missed.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2484">				ArrayList records = (ArrayList) timeRecords.get(it.next());</span>
<span class="nc bnc" id="L2485" title="All 4 branches missed.">				if (records != null &amp;&amp; !records.isEmpty()) {</span>
					// In-Memory sort is a MUST step to gurantee Open-Shift
					// closure
<span class="nc" id="L2488">					Collections.sort(records);</span>
<span class="nc" id="L2489">					TimeRecordEntry candidate = null;</span>
<span class="nc bnc" id="L2490" title="All 2 branches missed.">					for (Iterator itTR = records.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L2491">						TimeRecord tr = (TimeRecord) itTR.next();</span>
<span class="nc bnc" id="L2492" title="All 2 branches missed.">						if (candidate != null) {</span>
							// Prevention check, shouldn't adjust it to the time
							// before start time
							// This might happen if the timerecords have overlap
<span class="nc bnc" id="L2496" title="All 2 branches missed.">							if (candidate.getStartTime().before(tr.getStartTime())) {</span>
<span class="nc" id="L2497">								candidate.setEndTime(tr.getStartTime());</span>
							}
<span class="nc" id="L2499">							candidate = null;</span>
						}
<span class="nc" id="L2501">						ArrayList entries = tr.getChild();</span>
<span class="nc bnc" id="L2502" title="All 4 branches missed.">						if (entries == null || entries.isEmpty()) {</span>
<span class="nc" id="L2503">							continue;</span>
						}
						// Get last entry
<span class="nc" id="L2506">						TimeRecordEntry entry = (TimeRecordEntry) entries.get(entries.size() - 1);</span>
<span class="nc bnc" id="L2507" title="All 2 branches missed.">						if (entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L2508">							continue;</span>
						}
<span class="nc" id="L2510">						candidate = entry;</span>
<span class="nc" id="L2511">						tr.setNeedCal();</span>
<span class="nc" id="L2512">					}</span>
					// If there is an open shift, with no new shift after it
					// Adjust it to the time window's end time
<span class="nc bnc" id="L2515" title="All 2 branches missed.">					if (candidate != null) {</span>
<span class="nc bnc" id="L2516" title="All 2 branches missed.">						if (candidate.getStartTime().before(closerEnd)) {</span>
<span class="nc" id="L2517">							candidate.setEndTime(closerEnd);</span>
						}
					}
				}
<span class="nc" id="L2521">			}</span>
<span class="nc" id="L2522">			return timeRecords;</span>
<span class="nc" id="L2523">		} catch (JdmoException e) {</span>
<span class="nc" id="L2524">			handleException(e, false);</span>
<span class="nc" id="L2525">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2527" title="All 6 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L2529">					rs.close();</span>
<span class="nc" id="L2530">				} catch (Exception e) {</span>
<span class="nc bnc" id="L2531" title="All 6 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2532">						m_cat.debug(e);</span>
<span class="nc" id="L2533">				}</span>
<span class="nc bnc" id="L2534" title="All 6 branches missed.">			if (jdmo != null)</span>
<span class="nc" id="L2535">				jdmo.cleanUp();</span>
<span class="nc" id="L2536">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getEventsForWorkResource(ID workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2551">		methodStart(&quot;getEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="nc bnc" id="L2552" title="All 6 branches missed.">		if (workResourceID == null || dtStart == null || dtEnd == null)</span>
<span class="nc" id="L2553">			return Collections.emptyList();</span>
		try {
<span class="nc" id="L2555">			ArrayList array = new ArrayList(1);</span>
<span class="nc" id="L2556">			array.add(workResourceID);</span>
<span class="nc" id="L2557">			HashMap map = getEventsForWorkResource(array, dtStart, dtEnd);</span>
<span class="nc" id="L2558">			return (Collection) map.get(workResourceID);</span>
		} finally {
<span class="nc" id="L2560">			methodFinish();</span>
		}
	} // getEventsForWorkResource

	/**
	 * Gets the eventsForWorkResource attribute of the TimeRecordManager object
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L2574">		return getEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2575">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	} // getEventsForWorkResource

	/**
	 * Returns TimeRecord objects given its ID
	 *
	 * @param ID
	 *            timeRecordID
	 * @return TimeRecord
	 * @exception BbmObjectNotFoundException
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public TimeRecord getTimeRecordByID(ID timeRecordID) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L2589">		methodStart(&quot;getTimeRecordByID&quot;, timeRecordID);</span>
		try {
<span class="nc" id="L2591">			TimeRecord record = TimeRecordDAO.getTimeRecordByID(timeRecordID);</span>
<span class="nc bnc" id="L2592" title="All 2 branches missed.">			if (record != null)</span>
<span class="nc" id="L2593">				record.isOpenShift();</span>
<span class="nc" id="L2594">			return record;</span>
<span class="nc" id="L2595">		} catch (JdmoException e) {</span>
<span class="nc" id="L2596">			handleException(e, false);</span>
<span class="nc" id="L2597">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2599">			methodFinish();</span>
		}
	} // getTimeRecordByID

	/**
	 * Returns TimeRecordEntry objects given an employee ID, note the duration
	 * is always 0
	 *
	 * @param timeRecordEntryID
	 * @return TimeRecordEntry
	 * @exception BbmObjectNotFoundException
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public TimeRecordEntry getTimeRecordEntryByID(ID timeRecordEntryID) throws BbmObjectNotFoundException,
			BbmFinderException {
<span class="nc" id="L2615">		methodStart(&quot;getTimeRecordEntryByID&quot;, timeRecordEntryID);</span>
<span class="nc" id="L2616">		Jdmo jdmo = null;</span>
<span class="nc" id="L2617">		JdmoRowset rs = null;</span>
		try {
<span class="nc" id="L2619">			jdmo = new Jdmo();</span>
<span class="nc" id="L2620">			StringBuffer sb = new StringBuffer(</span>
					&quot;select A.ISPAID, A.DESCRIPTION, C.NAME, D.ID, D.NAME, RAWTIMEENTRYID, ACTIVITYID, TIMERECORDID, TIMESOURCECODE, STARTTIME, UPDATETIMESTAMP, DATASOURCEID FROM TIMEENTRYEVENT A, ACTIVITY C, ACTIVITYCATEGORY D WHERE A.ACTIVITYID = C.ID and D.ID&quot;);
<span class="nc" id="L2622">			sb.append(jdmo.getOuterJoin());</span>
<span class="nc" id="L2623">			sb.append(&quot; C.ACTIVITYCATEGORYID and A.ID=&quot;);</span>
<span class="nc" id="L2624">			sb.append(timeRecordEntryID);</span>
<span class="nc" id="L2625">			rs = jdmo.createRowset(sb.toString());</span>
<span class="nc" id="L2626">			TimeRecordEntry entry = null;</span>
<span class="nc bnc" id="L2627" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L2628">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L2629">				entry = new TimeRecordEntry(timeRecordEntryID, rs.getID(&quot;RAWTIMEENTRYID&quot;), rs.getID(&quot;ACTIVITYID&quot;),</span>
<span class="nc" id="L2630">						rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(rs.getBigDecimal(&quot;UPDATETIMESTAMP&quot;)</span>
<span class="nc" id="L2631">								.longValue()), rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(1), rs.getString(2),</span>
<span class="nc" id="L2632">						getTimeRecordByID(rs.getID(&quot;TIMERECORDID&quot;)));</span>
<span class="nc" id="L2633">				entry.setActivityName(rs.getString(3));</span>
<span class="nc" id="L2634">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="nc" id="L2635">				entry.setActivityCategoryName(rs.getString(5));</span>
			}
<span class="nc" id="L2637">			return entry;</span>
<span class="nc" id="L2638">		} catch (JdmoException e) {</span>
<span class="nc" id="L2639">			handleException(e, false);</span>
<span class="nc" id="L2640">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2642" title="All 4 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L2644">					rs.close();</span>
<span class="nc" id="L2645">				} catch (Exception e) {</span>
<span class="nc bnc" id="L2646" title="All 4 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2647">						m_cat.debug(e);</span>
<span class="nc" id="L2648">				}</span>
<span class="nc bnc" id="L2649" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L2650">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L2652">			methodFinish();</span>
		}
	} // getTimeRecordEntryByID

	/**
	 * Gets the Valid full TimeRecords for TimeRecord Export
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Date
	 *            dtStart
	 * @param Date
	 *            dtEnd
	 * @param boolean, need aggregate timerecord
	 * @param int, how to handle overlap
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public HashMap getValidEventsForTRE(Collection workResourceIDCol, Date dtStart, Date dtEnd, boolean aggregate,
			int overlap) throws BbmFinderException {
<span class="nc bnc" id="L2674" title="All 2 branches missed.">		methodStart(&quot;getValidEventsForTRE&quot;, workResourceIDCol, dtStart, dtEnd,</span>
<span class="nc" id="L2675">				aggregate ? Boolean.TRUE : Boolean.FALSE, NumberFactory.newInteger(overlap));</span>
<span class="nc" id="L2676">		HashMap trMap = null;</span>
		try {
<span class="nc" id="L2678">			trMap = getValidEventsForWorkResource(workResourceIDCol, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2679">					TimeZoneUtil.toTimestamp(dtEnd));</span>

<span class="nc" id="L2681">		} catch (BbmTimePeriodOverlapException e) {</span>
<span class="nc" id="L2682">			trMap = (HashMap) e.getContent();</span>
<span class="nc" id="L2683">		}</span>
		try {
<span class="nc bnc" id="L2685" title="All 2 branches missed.">			for (Iterator wrIt = workResourceIDCol.iterator(); wrIt.hasNext();) {</span>
<span class="nc" id="L2686">				ID wrID = (ID) wrIt.next();</span>
<span class="nc" id="L2687">				Collection trCol = (Collection) trMap.get(wrID);</span>
<span class="nc bnc" id="L2688" title="All 4 branches missed.">				if (trCol != null &amp;&amp; !trCol.isEmpty()) {</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">					for (Iterator trIt = trCol.iterator(); trIt.hasNext();) {</span>
<span class="nc" id="L2690">						TimeRecord tr = (TimeRecord) trIt.next();</span>
<span class="nc bnc" id="L2691" title="All 2 branches missed.">						if (StateChange.isInPeriod(tr, dtStart, dtEnd, overlap)) {</span>
							// if no need split TR and falls in the window based
							// on overlap rule keep the tr
<span class="nc bnc" id="L2694" title="All 2 branches missed.">							if (aggregate) {</span>
								// if need aggregate timerecord, then do it
<span class="nc" id="L2696">								tr.setType(TimeRecord.AGG_TIMEENTRY);</span>
<span class="nc" id="L2697">								ArrayList entries = tr.getChild();</span>
<span class="nc" id="L2698">								LinkedList newChild = new LinkedList();</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">								for (Iterator itTRE = entries.iterator(); itTRE.hasNext();) {</span>
<span class="nc" id="L2700">									TimeRecordEntry tre = (TimeRecordEntry) itTRE.next();</span>
<span class="nc" id="L2701">									ID actID = tre.getActivityCategoryID();</span>
<span class="nc bnc" id="L2702" title="All 2 branches missed.">									if (!newChild.isEmpty()) {</span>
<span class="nc" id="L2703">										TimeRecordEntry treLast = (TimeRecordEntry) newChild.getLast();</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">										if (treLast.getActivityCategoryID().equals(actID)</span>
<span class="nc bnc" id="L2705" title="All 2 branches missed.">												&amp;&amp; treLast.getPaid() == tre.getPaid()) {</span>
<span class="nc" id="L2706">											treLast.setEndTime(tre.getEndTime());</span>
<span class="nc" id="L2707">											treLast.addNumOfEntries();</span>
											// UI will display multi creators
											// involved in the aggregated view
<span class="nc bnc" id="L2710" title="All 2 branches missed.">											if (treLast.getTimeSourceCode() != tre.getTimeSourceCode()) {</span>
<span class="nc" id="L2711">												treLast.setTimeSourceCode(TimeEntrySourceCode.MULTI);</span>
											}
										} else {
<span class="nc" id="L2714">											newChild.add(tre);</span>
										}
<span class="nc" id="L2716">									} else {</span>
<span class="nc" id="L2717">										newChild.add(tre);</span>
									}
<span class="nc" id="L2719">								}</span>
<span class="nc" id="L2720">								tr.replaceChild(new ArrayList(newChild));</span>
<span class="nc" id="L2721">							}</span>
							continue;
						}
<span class="nc" id="L2724">						trIt.remove();</span>
<span class="nc" id="L2725">					}</span>
				}
<span class="nc" id="L2727">			}</span>
<span class="nc" id="L2728">			return trMap;</span>
		} finally {
<span class="nc" id="L2730">			methodFinish();</span>
		}
	}

	/**
	 * Gets the Valid TimeRecords for workResource
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Date
	 *            dtStart
	 * @param Date
	 *            dtEnd
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 */
	public HashMap getValidEventsForWorkResource(Collection workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2750">		return getValidEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L2751">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	}

	/**
	 * Gets the Valid TimeRecords for workResource
	 *
	 * @param Collection
	 *            workResourceID collection
	 * @param Timestamp
	 *            dtStart
	 * @param Timestamp
	 *            dtEnd
	 * @return HashMap, Keyed by WorkResourceID and associated collection of
	 *         timerecords
	 * @exception BbmFinderException
	 * @exception RemoteException
	 *                If there is such records, order by timerecordid,
	 *                starttime, which complains 202 overlap 204, wrong! 204
	 *                4/15 9:45pm 204 4/15 9:55pm 202 4/15 8:00am 202 4/15
	 *                9:00pm 203 4/15 7:00pm 203 4/15 9:30pm It shouldn't
	 *                retreive as, order by starttime, timerecordid 202 4/15
	 *                8:00am 203 4/15 7:00pm 202 4/15 9:00pm 203 4/15 9:30pm 204
	 *                4/15 9:45pm 204 4/15 9:55pm The routine has to retrieve
	 *                timerecord in group first, then sort on starttime in
	 *                memory to detect overlap.
	 */
	public HashMap getValidEventsForWorkResource(Collection workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2779">		methodStart(&quot;getValidEventsForWorkResource&quot;, workResourceID, dtStart, dtEnd);</span>
<span class="nc" id="L2780">		Jdmo jdmo = null;</span>
<span class="nc" id="L2781">		JdmoRowset rs = null;</span>
<span class="nc" id="L2782">		boolean valid = true;</span>
<span class="nc" id="L2783">		long threadID = Thread.currentThread().getId();</span>
<span class="nc" id="L2784">		String tempTable = &quot;EMP&quot; + threadID;</span>
<span class="nc" id="L2785">		String empIDTempTable = &quot;TIMERECORDEMPID&quot; + threadID;</span>
<span class="nc" id="L2786">		ArrayList overlappedTimeRecord = new ArrayList();</span>
<span class="nc" id="L2787">		Timestamp endTime = DateAdjustmentUtil.adjustEndTimeForDemo(dtEnd, m_ignoreFutureData);</span>
		try {
<span class="nc bnc" id="L2789" title="All 6 branches missed.">			if (workResourceID == null || dtStart == null || endTime == null) {</span>
<span class="nc" id="L2790">				return null;</span>
			}
			// Fetch Employee Name first
<span class="nc" id="L2793">			HashMap mapEmpNames = m_WorkResourceManager.getEmployeeNamesByIDs(workResourceID);</span>
<span class="nc" id="L2794">			HashMap timeRecords = new HashMap(workResourceID.size());</span>
<span class="nc" id="L2795">			jdmo = new Jdmo();</span>
			// From JDMO get real temp table name
<span class="nc" id="L2797">			String realTempTable = jdmo.getNativeTemptableName(tempTable);</span>
<span class="nc" id="L2798">			String realEmpIDTempTable = jdmo.getNativeTemptableName(empIDTempTable);</span>
			// Drop temp first
			try {
<span class="nc" id="L2801">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L2802">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L2803">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L2804" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2805">					m_cat.debug(e);</span>
<span class="nc" id="L2806">			}</span>
			// Create a new temp table
<span class="nc" id="L2808">			StringBuffer strSQLCreate = new StringBuffer();</span>
<span class="nc" id="L2809">			strSQLCreate.append(realTempTable).append(&quot; (ID int)&quot;);</span>
<span class="nc" id="L2810">			jdmo.createTempTable(strSQLCreate.toString());</span>
			// Prepare the employee ID query portion
<span class="nc" id="L2812">			createTempTableForUniqueIntIDs(empIDTempTable, jdmo, workResourceID);</span>
<span class="nc" id="L2813">			StringBuffer pInsert = composeTimeRecordQuery(dtStart, endTime,</span>
					realTempTable, realEmpIDTempTable);
<span class="nc" id="L2815">			jdmo.executeCommand(pInsert.toString());</span>
<span class="nc" id="L2816">			StringBuffer pStmt1 = new StringBuffer(200);</span>
<span class="nc" id="L2817">			pStmt1.append(&quot;select A.ID, B.ID, C.NAME, D.ID, D.NAME, B.ISPAID, &quot;)</span>
<span class="nc" id="L2818">					.append(&quot;B.DESCRIPTION, A.EMPLOYEEID, &quot;).append(TimeRecordDAO.APPROVERCOLSTR).append(&quot;A.&quot;)</span>
<span class="nc" id="L2819">					.append(TimeRecordDAO.REMAKERCOLNAME)</span>
<span class="nc" id="L2820">					.append(&quot;, A.CHANGECOUNTER, A.LASTMODIFIEDAT, REMARK, ISAPPROVED, ISPOSTED, &quot;)</span>
<span class="nc" id="L2821">					.append(&quot;CHANGESTATUS, RAWTIMEENTRYID, ACTIVITYID, B.STARTTIME, &quot;)</span>
<span class="nc" id="L2822">					.append(&quot;UPDATETIMESTAMP, TIMESOURCECODE, B.DATASOURCEID FROM TIMERECORD A, &quot;)</span>
<span class="nc" id="L2823">					.append(&quot;TIMEENTRYEVENT B, ACTIVITY C, ACTIVITYCATEGORY D, &quot;).append(realTempTable)</span>
<span class="nc" id="L2824">					.append(&quot; E where A.ID=B.TIMERECORDID and B.ACTIVITYID=C.ID and &quot;)</span>
<span class="nc" id="L2825">					.append(&quot;D.ID = C.ACTIVITYCATEGORYID and A.ID=E.ID&quot;);</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">			if (m_ignoreFutureData) {</span>
<span class="nc" id="L2827">				pStmt1.append(&quot; and UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime());</span>
			}
<span class="nc" id="L2829">			pStmt1.append(&quot; order by A.EMPLOYEEID, A.ID, B.UPDATETIMESTAMP asc&quot;);</span>
<span class="nc" id="L2830">			JdmoQuery jQuery1 = jdmo.createQuery(pStmt1.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2831">			rs = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L2832" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2833">				ID empID = rs.getID(8);</span>
<span class="nc" id="L2834">				ArrayList trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L2835" title="All 2 branches missed.">				if (trArray == null) {</span>
<span class="nc" id="L2836">					trArray = new ArrayList();</span>
				}
<span class="nc" id="L2838">				ID key = rs.getID(1);</span>
<span class="nc" id="L2839">				TimeRecord parent = null;</span>
<span class="nc" id="L2840">				TimeRecord previous = null;</span>
<span class="nc" id="L2841">				int last = trArray.size();</span>
<span class="nc bnc" id="L2842" title="All 2 branches missed.">				if (last == 0) {</span>
<span class="nc" id="L2843">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="nc" id="L2844">					parent = new TimeRecord(key, empID, remarkerID, TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L2845">							.getTimestamp(&quot;LASTMODIFIEDAT&quot;)), rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L2846">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L2847">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L2848">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L2849">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc bnc" id="L2850" title="All 2 branches missed.">					if (remarkerID != null) {</span>
<span class="nc" id="L2851">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="nc" id="L2852">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="nc" id="L2854">					trArray.add(parent);</span>
<span class="nc" id="L2855">					previous = parent;</span>
<span class="nc" id="L2856">				} else</span>
<span class="nc" id="L2857">					previous = (TimeRecord) trArray.get(last - 1);</span>
				// if it is a new timerecord
<span class="nc bnc" id="L2859" title="All 2 branches missed.">				if (!previous.getID().equals(key)) {</span>
<span class="nc" id="L2860">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="nc" id="L2861">					parent = new TimeRecord(key, empID, remarkerID, TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L2862">							.getTimestamp(&quot;LASTMODIFIEDAT&quot;)), rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L2863">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L2864">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L2865">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L2866">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc bnc" id="L2867" title="All 2 branches missed.">					if (remarkerID != null) {</span>
<span class="nc" id="L2868">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="nc" id="L2869">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="nc" id="L2871">					trArray.add(parent);</span>
<span class="nc" id="L2872">				} else {</span>
					// if it is not a new timerecord
<span class="nc" id="L2874">					parent = previous;</span>
				}
<span class="nc" id="L2876">				Date entryStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L2877">				TimeRecordEntry entry = new TimeRecordEntry(rs.getID(2), rs.getID(&quot;RAWTIMEENTRYID&quot;),</span>
<span class="nc" id="L2878">						rs.getID(&quot;ACTIVITYID&quot;), rs.getID(&quot;DATASOURCEID&quot;), entryStart, entryStart, new Date(rs</span>
<span class="nc" id="L2879">								.getBigDecimal(&quot;UPDATETIMESTAMP&quot;).longValue()), rs.getInt(&quot;TIMESOURCECODE&quot;),</span>
<span class="nc" id="L2880">						rs.getBoolean(&quot;ISPAID&quot;), rs.getString(7), parent);</span>
<span class="nc" id="L2881">				entry.setActivityName(rs.getString(3));</span>
<span class="nc" id="L2882">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="nc" id="L2883">				entry.setActivityCategoryName(rs.getString(5));</span>
<span class="nc" id="L2884">				ArrayList temp = parent.getChild();</span>
				// need to set the previous entry's endtime
<span class="nc bnc" id="L2886" title="All 2 branches missed.">				if (!temp.isEmpty()) {</span>
<span class="nc" id="L2887">					((TimeRecordEntry) temp.get(temp.size() - 1)).setEndTime(entryStart);</span>
				}
				// add the new entry directly
<span class="nc" id="L2890">				parent.addChild(entry);</span>
				// last step is to put it in the hashmap
<span class="nc" id="L2892">				timeRecords.put(empID, trArray);</span>
<span class="nc" id="L2893">			}</span>
<span class="nc bnc" id="L2894" title="All 2 branches missed.">			if (rs != null) {</span>
<span class="nc" id="L2895">				rs.close();</span>
			}
			// Additional step to validate timerecords the TimeRecord list
<span class="nc bnc" id="L2898" title="All 2 branches missed.">			if (!workResourceID.isEmpty()) {</span>
<span class="nc bnc" id="L2899" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
					// Get TimeRecord for each employee
<span class="nc" id="L2901">					ArrayList trCol = (ArrayList) timeRecords.get(it.next());</span>
					// If there are many(&gt;1) timerecords, should check overlap
<span class="nc bnc" id="L2903" title="All 4 branches missed.">					if (trCol != null &amp;&amp; trCol.size() &gt; 1) {</span>
						// First resort timerecord
<span class="nc" id="L2905">						Collections.sort(trCol);</span>
						// Iterate TimeRecord Collections
<span class="nc bnc" id="L2907" title="All 2 branches missed.">						for (ListIterator trIT = trCol.listIterator(); trIT.hasNext();) {</span>
<span class="nc" id="L2908">							int index = trIT.previousIndex();</span>
<span class="nc" id="L2909">							TimeRecord current = (TimeRecord) trIT.next();</span>
<span class="nc" id="L2910">							long newVal = current.getStartTime().getTime();</span>
<span class="nc bnc" id="L2911" title="All 2 branches missed.">							while (index &gt;= 0) {</span>
<span class="nc" id="L2912">								TimeRecord previous = (TimeRecord) trCol.get(index--);</span>
<span class="nc" id="L2913">								long existVal = previous.getEndTime().getTime();</span>
								// check if the entry is before the last tr's
								// endtime
<span class="nc bnc" id="L2916" title="All 2 branches missed.">								if (existVal - newVal &gt;= 0) {</span>
<span class="nc" id="L2917">									current.setOverlap(true);</span>
<span class="nc" id="L2918">									previous.setOverlap(true);</span>
<span class="nc" id="L2919">									overlappedTimeRecord.add(current);</span>
<span class="nc" id="L2920">									valid = false;</span>
								} else {
									// only if the last entry is an clean one,
									// and quit the loop
<span class="nc bnc" id="L2924" title="All 2 branches missed.">									if (!previous.getOverlap()) {</span>
<span class="nc" id="L2925">										break;</span>
									}
								}
<span class="nc" id="L2928">							}</span>
<span class="nc" id="L2929">						}</span>
					}
<span class="nc" id="L2931">				}</span>
			}
			// then load the TimeIntervals
<span class="nc" id="L2934">			StringBuffer pStmt2 = new StringBuffer(200);</span>
<span class="nc" id="L2935">			pStmt2.append(&quot;select A.ID, B.ID, C.NAME, D.ID, D.NAME, B.ISPAID, B.DESCRIPTION, A.EMPLOYEEID, B.STARTTIME, B.ENDTIME, FIRSTNAME, LASTNAME, &quot;);</span>
<span class="nc" id="L2936">			pStmt2.append(TimeRecordDAO.APPROVERCOLSTR)</span>
<span class="nc" id="L2937">					.append(TimeRecordDAO.REMAKERCOLNAME)</span>
<span class="nc" id="L2938">					.append(&quot;, A.LASTMODIFIEDAT, REMARK, ISAPPROVED, ISPOSTED, A.CHANGECOUNTER, CHANGESTATUS, ACTIVITYID, COUNTTOWARDSMINUTES, &quot;);</span>
<span class="nc" id="L2939">			pStmt2.append(&quot;TIMESOURCECODE FROM TIMERECORD A, TIMERECORDADJUSTMENT B, ACTIVITY C, ACTIVITYCATEGORY D, EMPLOYEEAM E, PERSON F where A.ID=B.TIMERECORDID and &quot;);</span>
<span class="nc" id="L2940">			pStmt2.append(&quot;B.ACTIVITYID=C.ID and A.EMPLOYEEID = E.ID and E.PERSONID = F.ID and D.ID=C.ACTIVITYCATEGORYID and A.ID in &quot;);</span>
<span class="nc" id="L2941">			pStmt2.append(&quot;(select distinct A.ID from TIMERECORD A &quot;);</span>
<span class="nc" id="L2942">			pStmt2.append(&quot; Inner Join TIMERECORDADJUSTMENT B on A.ID=B.TIMERECORDID &quot;);</span>
<span class="nc" id="L2943">			pStmt2.append(&quot; Inner Join &quot;).append(realEmpIDTempTable).append(&quot; T on T.ID = A.EMPLOYEEID &quot;);</span>
<span class="nc" id="L2944">			pStmt2.append(&quot; where B.STARTTIME&lt;? and B.ENDTIME&gt;=?) order by A.EMPLOYEEID, A.ID, B.STARTTIME asc&quot;);</span>
<span class="nc" id="L2945">			JdmoQuery jQuery2 = jdmo.createQuery(pStmt2.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2946">			jQuery2.setParTimestamp(1, endTime);</span>
<span class="nc" id="L2947">			jQuery2.setParTimestamp(2, dtStart);</span>
<span class="nc" id="L2948">			rs = jdmo.createRowset(jQuery2, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
			// Track employeeid that has new TimeInterval, need resort these
			// timerecords
<span class="nc" id="L2951">			HashSet empSort = new HashSet(10);</span>
			// used to identify first timerecord for timeinterval
<span class="nc bnc" id="L2953" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2954">				ID empID = rs.getID(8);</span>
<span class="nc" id="L2955">				ArrayList trArray = (ArrayList) timeRecords.get(empID);</span>
<span class="nc bnc" id="L2956" title="All 2 branches missed.">				if (trArray == null) {</span>
<span class="nc" id="L2957">					trArray = new ArrayList();</span>
				}
<span class="nc" id="L2959">				ID key = rs.getID(1);</span>
<span class="nc" id="L2960">				TimeRecord parent = null;</span>
<span class="nc" id="L2961">				boolean needNew = true;</span>
<span class="nc" id="L2962">				int index = 0;</span>
<span class="nc bnc" id="L2963" title="All 2 branches missed.">				for (int i = trArray.size(); --i &gt;= 0;) {</span>
<span class="nc bnc" id="L2964" title="All 2 branches missed.">					if (key.equals(((TimeRecord) trArray.get(i)).getID())) {</span>
<span class="nc" id="L2965">						needNew = false;</span>
<span class="nc" id="L2966">						index = i;</span>
<span class="nc" id="L2967">						break;</span>
					}
				}
<span class="nc bnc" id="L2970" title="All 2 branches missed.">				if (needNew) {</span>
<span class="nc" id="L2971">					ID remarkerID = rs.getID(TimeRecordDAO.REMAKERCOLNAME);</span>
<span class="nc" id="L2972">					parent = new TimeRecord(key, empID, remarkerID, TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L2973">							.getTimestamp(&quot;LASTMODIFIEDAT&quot;)), rs.getString(TimeRecordDAO.APPROVERCOLNAME),</span>
<span class="nc" id="L2974">							TimeZoneUtil.toDate(rs.getTimestamp(TimeRecordDAO.APPROVETIMECOLNAME)),</span>
<span class="nc" id="L2975">							rs.getString(&quot;REMARK&quot;), rs.getBoolean(&quot;ISAPPROVED&quot;), rs.getBoolean(&quot;ISPOSTED&quot;));</span>
<span class="nc" id="L2976">					parent.setEmpFirstName(rs.getString(&quot;FIRSTNAME&quot;));</span>
<span class="nc" id="L2977">					parent.setEmpLastName(rs.getString(&quot;LASTNAME&quot;));</span>
<span class="nc" id="L2978">					parent.setVersion(rs.getLong(&quot;CHANGECOUNTER&quot;));</span>
<span class="nc" id="L2979">					parent.setSyncStatus(rs.getShort(&quot;CHANGESTATUS&quot;));</span>
<span class="nc" id="L2980">					parent.setType(TimeRecord.TIMEINTERVAL);</span>
<span class="nc bnc" id="L2981" title="All 2 branches missed.">					if (remarkerID != null) {</span>
<span class="nc" id="L2982">						String remarkerName = getRemarkerName(remarkerID, jdmo);</span>
<span class="nc" id="L2983">						parent.setRemarkEmployeeName(remarkerName);</span>
					}
<span class="nc" id="L2985">					trArray.add(parent);</span>
<span class="nc" id="L2986">				} else {</span>
<span class="nc" id="L2987">					parent = (TimeRecord) trArray.get(index);</span>
					// the following validation allows
					// More than one TimeInterval per TimeRecord
					// if it is invalid, only if it already contains TimeEntry
<span class="nc bnc" id="L2991" title="All 2 branches missed.">					if (parent.getType() != TimeRecord.TIMEINTERVAL) {</span>
<span class="nc" id="L2992">						valid = false;</span>
					}
				}
<span class="nc" id="L2995">				TimeInterval entry = new TimeInterval(rs.getID(2), rs.getID(&quot;ACTIVITYID&quot;), TimeZoneUtil.toDate(rs</span>
<span class="nc" id="L2996">						.getTimestamp(9)), TimeZoneUtil.toDate(rs.getTimestamp(10)), rs.getInt(&quot;COUNTTOWARDSMINUTES&quot;),</span>
<span class="nc" id="L2997">						rs.getInt(&quot;TIMESOURCECODE&quot;), rs.getBoolean(6), rs.getString(7), parent);</span>
<span class="nc" id="L2998">				entry.setActivityName(rs.getString(3));</span>
<span class="nc" id="L2999">				entry.setActivityCategoryID(rs.getID(4));</span>
<span class="nc" id="L3000">				entry.setActivityCategoryName(rs.getString(5));</span>
<span class="nc" id="L3001">				parent.addChild(entry);</span>
				// Put back the TimeRecord to the HashMap
<span class="nc" id="L3003">				timeRecords.put(empID, trArray);</span>
				// Track employee that has TimeInterval
<span class="nc" id="L3005">				empSort.add(empID);</span>
<span class="nc" id="L3006">			}</span>
			// Additional step to resort the TimeRecord list
<span class="nc bnc" id="L3008" title="All 2 branches missed.">			if (!empSort.isEmpty()) {</span>
<span class="nc bnc" id="L3009" title="All 2 branches missed.">				for (Iterator it = empSort.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3010">					ArrayList trCol = (ArrayList) timeRecords.get(it.next());</span>
<span class="nc bnc" id="L3011" title="All 2 branches missed.">					if (trCol != null) {</span>
<span class="nc" id="L3012">						Collections.sort(trCol);</span>
					}
<span class="nc" id="L3014">				}</span>
			}
			// Set TimeRecord Employee names
<span class="nc bnc" id="L3017" title="All 2 branches missed.">			for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3018">				ID empID = (ID) it.next();</span>
<span class="nc" id="L3019">				EmployeeName eName = (EmployeeName) mapEmpNames.get(empID);</span>
<span class="nc" id="L3020">				Collection timeRecordCol = (Collection) timeRecords.get(empID);</span>
<span class="nc bnc" id="L3021" title="All 4 branches missed.">				if (eName == null || timeRecordCol == null) {</span>
<span class="nc" id="L3022">					continue;</span>
				}
<span class="nc bnc" id="L3024" title="All 2 branches missed.">				for (Iterator it2 = timeRecordCol.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L3025">					TimeRecord tr = (TimeRecord) it2.next();</span>
<span class="nc" id="L3026">					tr.setEmpFirstName(eName.getFirstName());</span>
<span class="nc" id="L3027">					tr.setEmpLastName(eName.getLastName());</span>
<span class="nc" id="L3028">				}</span>
<span class="nc" id="L3029">			}</span>
			// if no timerecords violate the validation rule, return it
<span class="nc bnc" id="L3031" title="All 2 branches missed.">			if (valid) {</span>
<span class="nc" id="L3032">				return timeRecords;</span>
			}
			// create the string of overlapping time record to display message
			// error
<span class="nc" id="L3036">			String strTimeRecordID = &quot;&quot;;</span>
<span class="nc" id="L3037">			int count = 0;</span>
<span class="nc bnc" id="L3038" title="All 2 branches missed.">			for (int i = 0; i &lt; overlappedTimeRecord.size(); i++) {</span>
<span class="nc" id="L3039">				TimeRecord objTimeRecord = (TimeRecord) overlappedTimeRecord.get(i);</span>
<span class="nc" id="L3040">				strTimeRecordID += objTimeRecord.getID().toString();</span>
<span class="nc bnc" id="L3041" title="All 2 branches missed.">				if (count &lt; overlappedTimeRecord.size() - 1)</span>
<span class="nc" id="L3042">					strTimeRecordID += &quot;, &quot;;</span>
<span class="nc" id="L3043">				count++;</span>
			}
<span class="nc" id="L3045">			Object[] args = new Object[1];</span>
<span class="nc" id="L3046">			args[0] = strTimeRecordID;</span>
<span class="nc" id="L3047">			BbmTimePeriodOverlapException e = new BbmTimePeriodOverlapException(BbmEjbLogBundleKey.TIME_RECORD_OVERLAP,</span>
					args);
<span class="nc" id="L3049">			e.setContent(timeRecords);</span>
<span class="nc" id="L3050">			throw e;</span>
<span class="nc" id="L3051">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3052">			handleException(e, false);</span>
<span class="nc" id="L3053">			throw e;</span>
<span class="nc" id="L3054">		} catch (Exception e) {</span>
<span class="nc" id="L3055">			handleException(e, false);</span>
<span class="nc" id="L3056">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L3058" title="All 6 branches missed.">			if (rs != null)</span>
				try {
<span class="nc" id="L3060">					rs.close();</span>
<span class="nc" id="L3061">				} catch (Exception e) {</span>
<span class="nc bnc" id="L3062" title="All 6 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L3063">						m_cat.debug(e);</span>
<span class="nc" id="L3064">				}</span>
			try {
<span class="nc" id="L3066">				jdmo.dropTempTable(tempTable);</span>
<span class="nc" id="L3067">				jdmo.dropTempTable(empIDTempTable);</span>
<span class="nc" id="L3068">			} catch (JdmoException e) {</span>
<span class="nc bnc" id="L3069" title="All 6 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3070">					m_cat.debug(e);</span>
				}
<span class="nc" id="L3072">			}</span>
<span class="nc bnc" id="L3073" title="All 6 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L3074">				jdmo.cleanUp();</span>
			}
<span class="nc" id="L3076">			methodFinish();</span>
		}
	}

	private StringBuffer composeTimeRecordQuery(Timestamp dtStart, Timestamp endTime,
												String realTempTable, String realEmpTempTable) {
		// Insert data into temp table
<span class="nc" id="L3083">		StringBuffer pInsert = new StringBuffer(&quot;insert into &quot;);</span>
<span class="nc" id="L3084">		pInsert.append(realTempTable);</span>
<span class="nc" id="L3085">		pInsert.append(&quot; select distinct A2.ID from TIMERECORD A2 &quot;);</span>
<span class="nc" id="L3086">		pInsert.append(&quot; Inner Join TIMEENTRYEVENT B2 on A2.ID=B2.TIMERECORDID&quot;);</span>
<span class="nc" id="L3087">		pInsert.append(&quot; Inner Join &quot;).append(realEmpTempTable).append(&quot; T on T.ID=B2.EmployeeID&quot;);</span>
<span class="nc" id="L3088">		pInsert.append(&quot; where B2.UPDATETIMESTAMP&lt;&quot;).append(endTime.getTime()).append(</span>
<span class="nc" id="L3089">				&quot; and B2.UPDATETIMESTAMP&gt;=&quot;).append(dtStart.getTime());</span>
<span class="nc" id="L3090">		return pInsert;</span>
	}

	/**
	 * Gets all timeentries/timeintervals for a workresourceID
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getValidEventsForWorkResource(ID workResourceID, Timestamp dtStart, Timestamp dtEnd)
			throws BbmFinderException {
<span class="nc bnc" id="L3104" title="All 6 branches missed.">		if (workResourceID != null &amp;&amp; dtStart != null &amp;&amp; dtEnd != null) {</span>
<span class="nc" id="L3105">			ArrayList array = new ArrayList(1);</span>
<span class="nc" id="L3106">			array.add(workResourceID);</span>
<span class="nc" id="L3107">			HashMap map = getValidEventsForWorkResource(array, dtStart, dtEnd);</span>
<span class="nc bnc" id="L3108" title="All 4 branches missed.">			if (map != null &amp;&amp; !map.isEmpty()) {</span>
<span class="nc" id="L3109">				return (Collection) map.get(workResourceID);</span>
			}
		}
<span class="nc" id="L3112">		return Collections.emptyList();</span>
	}

	/**
	 * Gets all timeentries/timeintervals for a workresourceID
	 *
	 * @param workResourceID
	 * @param dtStart
	 * @param dtEnd
	 * @return Collection
	 * @exception BbmFinderException
	 */
	public Collection getValidEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L3126">		return getValidEventsForWorkResource(workResourceID, TimeZoneUtil.toTimestamp(dtStart),</span>
<span class="nc" id="L3127">				TimeZoneUtil.toTimestamp(dtEnd));</span>
	}

	/**
	 * for TimeCollection merge TimeRecord operaion the logic is to check if the
	 * TimeRecord is still in raw status or modified by manager(including
	 * manager create end shift)
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @return boolean
	 * @exception BbmObjectNotFoundException
	 *                , subclass of BbmFinderException
	 * @exception BbmFinderException
	 *                , won't rollback any transaction
	 */
	public boolean isTimeRecordModified(ID timeRecordID) throws BbmFinderException {
<span class="nc" id="L3144">		methodStart(&quot;isTimeRecordModified&quot;, timeRecordID);</span>
		try {
<span class="nc" id="L3146">			return TimeRecordDAO.isTimeRecordModified(timeRecordID);</span>
<span class="nc" id="L3147">		} catch (JdmoException e) {</span>
<span class="nc" id="L3148">			handleException(e, false);</span>
<span class="nc" id="L3149">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3151">			methodFinish();</span>
		}
	}

	/**
	 * to update a TimeRecordEntry
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord updateTimeRecordEntry(ID timeRecordID, int pos, TimeRecordEntry entry, long version)
			throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3169">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos), entry, new Long(version));</span>
<span class="nc" id="L3170">		Collection col = null;</span>
<span class="nc" id="L3171">		TimeRecord tr = null;</span>
<span class="nc" id="L3172">		ArrayList auditList = new ArrayList(2);</span>
		// To fix update on a zero duration entry, like EndShift, we need define
		// new window
<span class="nc" id="L3175">		long miliEndTime = (long) entry.getEndTime().getTime() / (MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR);</span>
<span class="nc" id="L3176">		entry.setEndTime(new Date(miliEndTime * MILLISECONDS_IN_MINUTE * MINUTES_IN_HOUR));</span>
<span class="nc" id="L3177">		Date oldStart = null;</span>
		try {
<span class="nc" id="L3179">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L3180" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
				// Check if it TimeEntry type, rarely throws this Exception
<span class="nc bnc" id="L3182" title="All 2 branches missed.">				if (tr.getType() != TimeRecord.TIMEENTRY) {</span>
<span class="nc" id="L3183">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID_TYPE);</span>
				}
<span class="nc" id="L3185">				TimeRecordEntry oldEntry = (TimeRecordEntry) tr.getChild().get(pos - 1);</span>
<span class="nc bnc" id="L3186" title="All 4 branches missed.">				if (oldEntry.getDuration() == TimeRecordEntry.ENDSHIFT_DURATION || oldEntry.getDuration() == 0) {</span>
<span class="nc" id="L3187">					oldStart = oldEntry.getStartTime();</span>
				}
<span class="nc" id="L3189">				AuditTrailEntry auditOldEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3190">						AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3191">						oldEntry.getStartTime(), oldEntry.getEndTime());</span>
<span class="nc" id="L3192">				auditOldEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L3193">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc bnc" id="L3194" title="All 2 branches missed.">				if (oldStart == null) {</span>
<span class="nc" id="L3195">					auditList.add(auditOldEntry);</span>
				}
<span class="nc" id="L3197">				entry.setLastModifiedTime(new Date());</span>
<span class="nc" id="L3198">				entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L3199">				tr.updateEntry(entry, pos);</span>
				// Check within the TimeRecord
<span class="nc bnc" id="L3201" title="All 2 branches missed.">				if (tr.validate(true)) {</span>
					// Check with other TimeRecords,
					// but as there is no locking on all other records
					// (performance reason), it is guaranteed there will be no
					// overlap timerecords
<span class="nc bnc" id="L3206" title="All 2 branches missed.">					if (!tr.getStartTime().equals(tr.getEndTime())) {</span>
<span class="nc" id="L3207">						col = getEventsForWorkResource(tr.getEmployeeID(), tr.getStartTime(), tr.getEndTime());</span>
<span class="nc bnc" id="L3208" title="All 4 branches missed.">						if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc bnc" id="L3209" title="All 2 branches missed.">							if (col.size() == 1) {</span>
<span class="nc" id="L3210">								Iterator it = col.iterator();</span>
<span class="nc" id="L3211">								TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L3212" title="All 2 branches missed.">								if (!same.getID().equals(timeRecordID)) {</span>
									// Rarelly happend, but this implies the
									// TimeRecord is replaced by another one
<span class="nc" id="L3215">									throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
								}
<span class="nc" id="L3217">							} else {</span>
								// There are overlapping TimeRecords
<span class="nc" id="L3219">								Iterator it = col.iterator();</span>
<span class="nc bnc" id="L3220" title="All 2 branches missed.">								while (it.hasNext()) {</span>
<span class="nc" id="L3221">									((TimeRecord) it.next()).setOverlap(true);</span>
								}
<span class="nc" id="L3223">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
							}
						}
					}
					// TimeRecord only has one entry without EndShift
<span class="nc bnc" id="L3228" title="All 2 branches missed.">					if (entry.getRemarkerID() != null) {</span>
<span class="nc" id="L3229">						tr.setRemarkEmployeeID(entry.getRemarkerID());</span>
					}
<span class="nc" id="L3231">					updateTimeRecordEntry(tr, true);</span>
				} else {
					// invalid
<span class="nc" id="L3234">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
				}
<span class="nc" id="L3236">			} else {</span>
<span class="nc bnc" id="L3237" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3238">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
<span class="nc" id="L3240">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
			// cache task
<span class="nc bnc" id="L3243" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc" id="L3244">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
			}
			// update lastEntry
<span class="nc" id="L3247">			updateLastEntryCache(tr.getLastEntry());</span>
			// prepare audit trail
<span class="nc" id="L3249">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3250">					AuditTrailEntry.ACTION_UPDATE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3251">					entry.getStartTime(), entry.getEndTime());</span>
<span class="nc" id="L3252">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_ENTRY),</span>
					&quot;-1&quot;, false);
<span class="nc bnc" id="L3254" title="All 2 branches missed.">			if (oldStart != null) {</span>
<span class="nc bnc" id="L3255" title="All 2 branches missed.">				if (auditEntry.getImpactStart().before(oldStart))</span>
<span class="nc" id="L3256">					auditEntry.setImpactEnd(oldStart);</span>
				else
<span class="nc" id="L3258">					auditEntry.setImpactStart(oldStart);</span>
			}
<span class="nc" id="L3260">			auditList.add(auditEntry);</span>
<span class="nc" id="L3261">			m_EventAuditTrailManager.createAuditEntry(auditList);</span>
<span class="nc" id="L3262">			return tr;</span>
<span class="nc" id="L3263">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3264">			Object[] param = new Object[3];</span>
<span class="nc" id="L3265">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3266">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3267">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3268">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3269">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3270">		} catch (JdmoException e) {</span>
<span class="nc" id="L3271">			handleException(e);</span>
<span class="nc" id="L3272">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3273">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3274">			handleException(e);</span>
<span class="nc" id="L3275">			throw e;</span>
<span class="nc" id="L3276">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3277">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3278">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3279">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3280">			handleException(e);</span>
<span class="nc" id="L3281">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3282">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L3283">			handleException(Priority.INFO, e);</span>
<span class="nc bnc" id="L3284" title="All 4 branches missed.">			if (col == null || col.isEmpty())</span>
<span class="nc" id="L3285">				e.setContent(tr);</span>
			else
<span class="nc" id="L3287">				e.setContent(col);</span>
<span class="nc" id="L3288">			throw e;</span>
<span class="nc" id="L3289">		} catch (Exception e) {</span>
<span class="nc" id="L3290">			handleException(e);</span>
<span class="nc" id="L3291">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3293">			methodFinish();</span>
		}
	} // updateTimeRecordEntry

	/**
	 * to update a TimeRecordEntry from backend
	 * 
	 * @param ID
	 *            , timeRecordID
	 * @param TimeRecordEntry
	 *            , a new entry
	 */
	public void updateTimeRecordEntry(ID timeRecordID, TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3306">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, entry);</span>
		try {
<span class="nc" id="L3308">			entry.setParentID(timeRecordID);</span>
<span class="nc" id="L3309">			entry.setLastModifiedTime(new Date());</span>
<span class="nc" id="L3310">			entry.setModifier(m_sessionContext.getCallerPrincipal().getName());</span>
			// Continue only if the SyncStatus is 0
<span class="nc bnc" id="L3312" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3314" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3315">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3317">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3319">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3320">			Object[] param = new Object[3];</span>
<span class="nc" id="L3321">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3322">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3323">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3324">			handleException(BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3325">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3326">		} catch (JdmoException e) {</span>
<span class="nc" id="L3327">			handleException(e);</span>
<span class="nc" id="L3328">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3330">			methodFinish();</span>
<span class="nc" id="L3331">		}</span>
<span class="nc" id="L3332">	}</span>

	/**
	 * to update a TimeRecordEntry from backend
	 * 
	 * @param TimeRecordEntry
	 *            , an entry to be updated
	 */
	public void updateTimeRecordEntry(TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3341">		methodStart(&quot;updateTimeRecordEntry&quot;, entry);</span>
		try {
<span class="nc bnc" id="L3343" title="All 4 branches missed.">			if (entry.getParentID() == null || entry.getID() == null) {</span>
<span class="nc" id="L3344">				return;</span>
			}
			// Continue only if the SyncStatus is 0
<span class="nc bnc" id="L3347" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3349" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3350">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3352">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3354">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3355">			Object[] param = new Object[3];</span>
<span class="nc" id="L3356">			param[0] = entry.getSortTime().toString();</span>
<span class="nc" id="L3357">			param[1] = entry.getRawTimeEntryID();</span>
<span class="nc" id="L3358">			param[2] = entry.getParentID();</span>
<span class="nc" id="L3359">			handleException(Priority.INFO, BbmEjbLogBundleKey.TM_DUPLICATE_ENTRY, param, e);</span>
<span class="nc" id="L3360">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3361">		} catch (JdmoException e) {</span>
<span class="nc" id="L3362">			handleException(e);</span>
<span class="nc" id="L3363">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3365">			methodFinish();</span>
<span class="nc" id="L3366">		}</span>
<span class="nc" id="L3367">	} // updateTimeRecordEntry</span>

	/**
	 * update time record entry with a new time record ID
	 * 
	 * @param timeRecordID
	 * @param entryIDCol
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntry(ID timeRecordID, Collection entryIDCol) throws BbmUpdateException {
<span class="nc" id="L3378">		methodStart(&quot;updateTimeRecordEntry&quot;, timeRecordID, entryIDCol);</span>
<span class="nc" id="L3379">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3381">			StringBuffer pStmt = new StringBuffer(&quot;update TIMEENTRYEVENT set TIMERECORDID=&quot;);</span>
<span class="nc" id="L3382">			pStmt.append(timeRecordID).append(&quot;, TIMESOURCECODE=&quot;).append(TimeEntrySourceCode.HAAFEED)</span>
<span class="nc" id="L3383">					.append(&quot; where ID in &quot;).append(jdmo.createInClause(entryIDCol));</span>
<span class="nc" id="L3384">			jdmo.executeCommand(pStmt.toString());</span>
<span class="nc" id="L3385">		} catch (JdmoException e) {</span>
<span class="nc" id="L3386">			handleException(e);</span>
<span class="nc" id="L3387">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3389">			jdmo.cleanUp();</span>
<span class="nc" id="L3390">			methodFinish();</span>
<span class="nc" id="L3391">		}</span>
<span class="nc" id="L3392">	}</span>

	/**
	 * update time record entry with a new time record ID and change the
	 * Activity ID accordingly (most for Auto Merge)
	 * 
	 * @param timeRecordID
	 * @param entryCol
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntryActivity(ID timeRecordID, Collection entryCol) throws BbmUpdateException {
<span class="nc" id="L3404">		methodStart(&quot;updateTimeRecordEntryActivity&quot;, timeRecordID, entryCol);</span>
<span class="nc" id="L3405">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L3407" title="All 2 branches missed.">			for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3408">				TimeRecordEntry tre = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L3409">				StringBuffer pStmt = new StringBuffer(&quot;update TIMEENTRYEVENT set ACTIVITYID=&quot;);</span>
<span class="nc" id="L3410">				pStmt.append(tre.getActivityID()).append(&quot;, TIMERECORDID=&quot;).append(timeRecordID);</span>
<span class="nc" id="L3411">				pStmt.append(&quot;, TIMESOURCECODE=&quot;).append(TimeEntrySourceCode.HAAFEED).append(&quot; where ID=&quot;)</span>
<span class="nc" id="L3412">						.append(tre.getID());</span>
<span class="nc" id="L3413">				jdmo.addBatch(pStmt.toString());</span>
<span class="nc" id="L3414">			}</span>
<span class="nc" id="L3415">			jdmo.executeBatch();</span>
<span class="nc" id="L3416">		} catch (JdmoException e) {</span>
<span class="nc" id="L3417">			handleException(e);</span>
<span class="nc" id="L3418">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3420">			jdmo.cleanUp();</span>
<span class="nc" id="L3421">			methodFinish();</span>
<span class="nc" id="L3422">		}</span>
<span class="nc" id="L3423">	}</span>

	/**
	 * update time record entry with a new time record ID
	 * 
	 * @param ID
	 *            old Record ID
	 * @param ID
	 *            new Record ID
	 * @param Date
	 *            entry starts later than this date will be affected
	 * @throws BbmUpdateException
	 * @throws RemoteException
	 */
	public void updateTimeRecordEntry(ID oldRecordID, ID newRecordID, Date entryStart) throws BbmUpdateException {
<span class="nc" id="L3438">		methodStart(&quot;updateTimeRecordEntry&quot;, oldRecordID, newRecordID, entryStart);</span>
<span class="nc" id="L3439">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3441">			String pStmt = &quot;update TIMEENTRYEVENT set TIMERECORDID=? where TIMERECORDID=?&quot;;</span>
<span class="nc" id="L3442">			Object[] params = new Object[2];</span>
<span class="nc bnc" id="L3443" title="All 2 branches missed.">			if (entryStart != null) {</span>
<span class="nc" id="L3444">				pStmt += &quot; and STARTTIME&gt;=?&quot;;</span>
<span class="nc" id="L3445">				params = new Object[3];</span>
<span class="nc" id="L3446">				params[2] = entryStart;</span>
			}
<span class="nc" id="L3448">			params[0] = newRecordID;</span>
<span class="nc" id="L3449">			params[1] = oldRecordID;</span>
<span class="nc" id="L3450">			jdmo.executePCommand(pStmt, params);</span>
<span class="nc" id="L3451">		} catch (JdmoException e) {</span>
<span class="nc" id="L3452">			handleException(e);</span>
<span class="nc" id="L3453">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3455">			jdmo.cleanUp();</span>
<span class="nc" id="L3456">			methodFinish();</span>
<span class="nc" id="L3457">		}</span>
<span class="nc" id="L3458">	}</span>

	/**
	 * to update a TimeRecordEntry from backend supporting BPX quick update
	 * 
	 * @param TimeRecordEntry
	 *            , only updates ActivityID and ISPaid info
	 */
	public void quickUpdateTimeRecordEntry(TimeRecordEntry entry) throws BbmUpdateException {
<span class="nc" id="L3467">		methodStart(&quot;quickUpdateTimeRecordEntry&quot;, entry);</span>
		try {
<span class="nc bnc" id="L3469" title="All 2 branches missed.">			if (TimeRecordDAO.quickUpdateTimeRecordEntry(entry) != 0) {</span>
				// Cache Task
<span class="nc bnc" id="L3471" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc bnc" id="L3472" title="All 2 branches missed.">					if (m_DebugEnabled) {</span>
<span class="nc" id="L3473">						m_cat.debug(&quot;In quickUpdateTimeRecordEntry, new TimeEnry is &quot; + entry);</span>
					}
<span class="nc" id="L3475">					TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, entry);</span>
				}
<span class="nc" id="L3477">				updateLastEntryCache(entry);</span>
			}
<span class="nc" id="L3479">		} catch (JdmoException e) {</span>
<span class="nc" id="L3480">			handleException(e);</span>
<span class="nc" id="L3481">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3483">			methodFinish();</span>
<span class="nc" id="L3484">		}</span>
<span class="nc" id="L3485">	}</span>

	/**
	 * to update a TimeRecordEntry from backend supporting BPX quick update
	 * 
	 * @param TimeRecordEntry
	 *            , only updates ActivityID and ISPaid info
	 */
	public void quickUpdateTimeRecordEntry(Collection entryCol) throws BbmUpdateException {
<span class="nc" id="L3494">		methodStart(&quot;quickUpdateTimeRecordEntry&quot;, entryCol);</span>
<span class="nc" id="L3495">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L3497" title="All 2 branches missed.">			for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3498">				TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L3499" title="All 2 branches missed.">				if (TimeRecordDAO.quickUpdateTimeRecordEntry(entry) != 0) {</span>
					// Cache Task
<span class="nc bnc" id="L3501" title="All 2 branches missed.">					if (cacheUsed()) {</span>
<span class="nc bnc" id="L3502" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L3503">							m_cat.debug(&quot;In quickUpdateTimeRecordEntry, new TimeEnry Collection are &quot; + entryCol);</span>
						}
<span class="nc" id="L3505">						TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, entry);</span>
					}
<span class="nc" id="L3507">					updateLastEntryCache(entry);</span>
				}
<span class="nc" id="L3509">			}</span>
<span class="nc" id="L3510">		} catch (JdmoException e) {</span>
<span class="nc" id="L3511">			handleException(e);</span>
<span class="nc" id="L3512">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3514">			jdmo.cleanUp();</span>
<span class="nc" id="L3515">			methodFinish();</span>
<span class="nc" id="L3516">		}</span>
<span class="nc" id="L3517">	}</span>

	/**
	 * delete TimeRecord, which deletes all TimeRecordEntries first and remove
	 * the timerecord brutally
	 * 
	 * @param ID
	 */
	public void removeTimeRecord(ID id) throws BbmRemoveException {
<span class="nc" id="L3526">		methodStart(&quot;removeTimeRecod&quot;, id);</span>
<span class="nc" id="L3527">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Load TimeRecord, check if the PayPeriod is locked or not
<span class="nc" id="L3530">			TimeRecord tr = TimeRecordDAO.getTimeRecordByID(id);</span>
<span class="nc bnc" id="L3531" title="All 2 branches missed.">			if (tr == null) {</span>
<span class="nc" id="L3532">				return;</span>
			}
<span class="nc bnc" id="L3534" title="All 2 branches missed.">			if (tr.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
				// refresh cache
<span class="nc bnc" id="L3536" title="All 2 branches missed.">				if (cacheUsed()) {</span>
					// Cache Task, replace the existing record with new version
<span class="nc" id="L3538">					TimeRecordCacheUtil.removeInCache(m_TimeRecordCache, tr.getEmployeeID(), id);</span>
				}
<span class="nc" id="L3540">				removeLastEntryCache(tr.getEmployeeID(), id);</span>
			}
			// Force deletion
<span class="nc" id="L3543">			ArrayList idCol = new ArrayList(1);</span>
<span class="nc" id="L3544">			idCol.add(id);</span>
<span class="nc" id="L3545">			DAOUtil.deleteObjects(jdmo, &quot;TIMERECORD&quot;, idCol);</span>
			// Create AuditTrail
<span class="nc" id="L3547">			Date trEnd = tr.getEndTime();</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">			if (tr.isOpenShift()) {</span>
<span class="nc" id="L3549">				trEnd = new Date();</span>
			}
<span class="nc" id="L3551">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3552">					AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc" id="L3553">					tr.getStartTime(), trEnd);</span>
<span class="nc" id="L3554">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
					&quot;-1&quot;, false);
<span class="nc" id="L3556">			m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3557">		} catch (JdmoException e) {</span>
<span class="nc" id="L3558">			handleException(e);</span>
<span class="nc" id="L3559">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3560">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3561">			handleException(e);</span>
<span class="nc" id="L3562">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3563">		} catch (Exception e) {</span>
<span class="nc" id="L3564">			handleException(e);</span>
<span class="nc" id="L3565">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3567">			jdmo.cleanUp();</span>
<span class="nc" id="L3568">			methodFinish();</span>
<span class="nc" id="L3569">		}</span>
<span class="nc" id="L3570">	} // removeTimeRecord</span>

	/**
	 * for the creation of a new TimeRecordEntry
	 * 
	 * @param ID
	 *            , TimeRecord ID
	 * @param ID
	 *            , remarker ID
	 * @param int, pos
	 * @param TimeRecordEntry
	 *            , a new entry
	 * @param Long
	 *            , version
	 * @return TimeRecord
	 */
	public TimeRecord removeTimeRecordEntry(ID timeRecordID, ID remakerID, int pos, boolean direction, long version)
			throws BbmRemoveException {
<span class="nc" id="L3588">		methodStart(&quot;removeTimeRecordEntry&quot;, timeRecordID, NumberFactory.newInteger(pos),</span>
<span class="nc" id="L3589">				JdmoParam.getObject(direction), new Long(version));</span>
<span class="nc" id="L3590">		TimeRecord tr = null;</span>
		try {
<span class="nc" id="L3592">			tr = TimeRecordDAO.getTimeRecordForUpdate(timeRecordID, version, false);</span>
<span class="nc bnc" id="L3593" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc" id="L3594">				TimeRecordEntry entry = (TimeRecordEntry) tr.getChild().get(pos - 1);</span>
<span class="nc" id="L3595">				tr.removeEntry(pos, direction);</span>
<span class="nc bnc" id="L3596" title="All 2 branches missed.">				if (remakerID != null) {</span>
<span class="nc" id="L3597">					tr.setRemarkEmployeeID(remakerID);</span>
				}
<span class="nc" id="L3599">				updateTimeRecordEntry(tr, true);</span>
<span class="nc bnc" id="L3600" title="All 2 branches missed.">				if (cacheUsed()) {</span>
<span class="nc" id="L3601">					tr.compactChild();</span>
<span class="nc" id="L3602">					TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, tr);</span>
				}
<span class="nc" id="L3604">				removeLastEntryCache(entry);</span>
<span class="nc" id="L3605">				AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3606">						AuditTrailEntry.ACTION_DELETE_OBJECT, tr.getEmployeeID(), getEmployeeName(tr.getEmployeeID()),</span>
<span class="nc bnc" id="L3607" title="All 2 branches missed.">						entry.getStartTime(), (entry.getEndTime() == null) ? (new Date()) : entry.getEndTime());</span>
<span class="nc" id="L3608">				auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE,</span>
<span class="nc" id="L3609">						String.valueOf(Event.EVENT_TYPE_TIME_ENTRY), &quot;-1&quot;, false);</span>
<span class="nc" id="L3610">				m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3611">			} else {</span>
<span class="nc bnc" id="L3612" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3613">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
				}
<span class="nc" id="L3615">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
<span class="nc" id="L3617">			return tr;</span>
<span class="nc" id="L3618">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3619">			handleException(e);</span>
<span class="nc" id="L3620">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3621">		} catch (JdmoException e) {</span>
<span class="nc" id="L3622">			handleException(e);</span>
<span class="nc" id="L3623">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3624">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3625">			handleException(e);</span>
<span class="nc" id="L3626">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L3627">		} catch (Exception e) {</span>
<span class="nc" id="L3628">			handleException(e);</span>
<span class="nc" id="L3629">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3631">			methodFinish();</span>
		}
	} // removeTimeRecordEntry

	/**
	 * for the remove of a new TimeRecordEntry
	 * 
	 * @param Collection
	 *            , TimeRecordEntry ID List
	 */
	public void removeTimeRecordEntry(Collection timeEntryIDList) throws BbmRemoveException {
<span class="nc" id="L3642">		methodStart(&quot;removeTimeRecordEntry&quot;, timeEntryIDList);</span>
<span class="nc" id="L3643">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3645">			DAOUtil.deleteObjects(jdmo, &quot;TIMEENTRYEVENT&quot;, timeEntryIDList);</span>
<span class="nc" id="L3646">		} catch (JdmoException e) {</span>
<span class="nc" id="L3647">			handleException(e);</span>
<span class="nc" id="L3648">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3650">			jdmo.cleanUp();</span>
<span class="nc" id="L3651">			methodFinish();</span>
<span class="nc" id="L3652">		}</span>
<span class="nc" id="L3653">	}</span>

	/**
	 * for the remove of unknown events for a given window for a collection of
	 * employee
	 * 
	 * @param Collection
	 *            , employee ID List
	 * @param start
	 * @param end
	 */
	public void removeUnknownTimeRecordEntry(Collection empIDList, Date start, Date end) throws BbmRemoveException {
<span class="nc" id="L3665">		methodStart(&quot;removeTimeRecordEntry&quot;, empIDList, start, end);</span>
<span class="nc" id="L3666">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L3668">			StringBuffer remove = new StringBuffer(&quot;delete TIMEENTRYEVENT where EMPLOYEEID in &quot;).append(jdmo</span>
<span class="nc" id="L3669">					.createInClause(empIDList));</span>
<span class="nc" id="L3670">			remove.append(&quot; and STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;' and STARTTIME&gt;='&quot;)</span>
<span class="nc" id="L3671">					.append(JdmoUtil.formatDBString(start));</span>
<span class="nc" id="L3672">			remove.append(&quot;' and ACTIVITYID=&quot;).append(Activity.ACTIVITY_UNKNOWN);</span>
<span class="nc" id="L3673">			jdmo.executeCommand(remove.toString());</span>
<span class="nc" id="L3674">		} catch (JdmoException e) {</span>
<span class="nc" id="L3675">			handleException(e);</span>
<span class="nc" id="L3676">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L3678">			jdmo.cleanUp();</span>
<span class="nc" id="L3679">			methodFinish();</span>
<span class="nc" id="L3680">		}</span>
<span class="nc" id="L3681">	}</span>

	/**
	 * updateTimeRecordEntry, which will invoke updateTimeRecordOnly, used by UI
	 * routine then invoke
	 * updateTimeRecordEntry/insertTimeRecordEntry/deleteTimeRecordEntry
	 * 
	 * @param TimeRecord
	 * @param boolean, if Operation need lockTR from TC, for EndShift, Approval
	 */
	private void updateTimeRecordEntry(TimeRecord timeRecord, boolean lockTR) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc bnc" id="L3693" title="All 2 branches missed.">		if (!timeRecord.isLocked()) {</span>
			try {
<span class="nc" id="L3695">				ArrayList array = timeRecord.getChild();</span>
<span class="nc bnc" id="L3696" title="All 2 branches missed.">				if (array.isEmpty()) {</span>
<span class="nc" id="L3697">					return;</span>
				}
<span class="nc" id="L3699">				int size = array.size();</span>
				// No matter if it is dirty or not, must update the timerecord
				// 1. In order to set the correct Sync Status;
				// 2. Increase the version
<span class="nc" id="L3703">				TimeRecordDAO.updateTimeRecord(timeRecord, true, lockTR);</span>
<span class="nc bnc" id="L3704" title="All 2 branches missed.">				if (timeRecord.getType() == TimeRecord.EVENT_TYPE_TIME_ENTRY) {</span>
<span class="nc bnc" id="L3705" title="All 2 branches missed.">					for (int i = 0; i &lt; size; i++) {</span>
<span class="nc" id="L3706">						TimeRecordEntry entry = (TimeRecordEntry) array.get(i);</span>
<span class="nc bnc" id="L3707" title="All 2 branches missed.">						if (entry.getDirty()) {</span>
<span class="nc" id="L3708">							addModTimestamp(entry);</span>
<span class="nc bnc" id="L3709" title="All 2 branches missed.">							if (entry.isDeleted()) {</span>
<span class="nc bnc" id="L3710" title="All 2 branches missed.">								if (entry.isFromDB()) {</span>
<span class="nc" id="L3711">									TimeRecordDAO.removeTimeRecordEntry(entry.getID());</span>
								}
							} else {
<span class="nc bnc" id="L3714" title="All 2 branches missed.">								if (entry.isFromDB()) {</span>
<span class="nc" id="L3715">									TimeRecordDAO.updateTimeRecordEntry(entry, m_ResetImmidiateToLastActivity);</span>
								} else {
<span class="nc" id="L3717">									entry.setID(TimeRecordDAO.createTimeRecordEntry(entry,</span>
											m_ResetImmidiateToLastActivity));
								}
							}
						}
					}
				}
<span class="nc" id="L3724">			} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3725">				handleException(Priority.INFO, e);</span>
<span class="nc" id="L3726">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3727">			} catch (Exception e) {</span>
<span class="nc" id="L3728">				handleException(e);</span>
<span class="nc" id="L3729">				BbmUpdateException bue = new BbmUpdateException(e);</span>
<span class="nc" id="L3730">				bue.setContent(timeRecord);</span>
<span class="nc" id="L3731">				throw bue;</span>
<span class="nc" id="L3732">			}</span>
		}
<span class="nc" id="L3734">	}</span>

	/**
	 * Used By UI routine, new feature to refresh the whole TimeRecord
	 * 
	 * @param TimeRecord
	 *            , timeRecord
	 */
	public void updateTimeRecord(TimeRecord timeRecord) throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3743">		methodStart(&quot;updateTimeRecord&quot;, timeRecord);</span>
		try {
			// Check within the TimeRecord
<span class="nc bnc" id="L3746" title="All 2 branches missed.">			if (timeRecord.validate(true)) {</span>
				// Check with other TimeRecords,
				// but as there is no locking on all other records
				// (performance reason), it is guaranteed there will be no
				// overlap timerecords
<span class="nc" id="L3751">				Collection col = null;</span>
<span class="nc bnc" id="L3752" title="All 2 branches missed.">				if (!timeRecord.getStartTime().equals(timeRecord.getEndTime())) {</span>
<span class="nc" id="L3753">					col = getEventsForWorkResource(timeRecord.getEmployeeID(), timeRecord.getStartTime(),</span>
<span class="nc" id="L3754">							timeRecord.getEndTime());</span>
<span class="nc bnc" id="L3755" title="All 4 branches missed.">					if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc bnc" id="L3756" title="All 2 branches missed.">						if (col.size() == 1) {</span>
<span class="nc" id="L3757">							Iterator it = col.iterator();</span>
<span class="nc" id="L3758">							TimeRecord same = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L3759" title="All 2 branches missed.">							if (!same.getID().equals(timeRecord.getID())) {</span>
								// Rarelly happend, but this implies the
								// TimeRecord is replaced by another one
<span class="nc" id="L3762">								throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
							}
<span class="nc" id="L3764">						} else {</span>
							// There are overlapping TimeRecords
<span class="nc" id="L3766">							Iterator it = col.iterator();</span>
<span class="nc bnc" id="L3767" title="All 2 branches missed.">							while (it.hasNext()) {</span>
<span class="nc" id="L3768">								((TimeRecord) it.next()).setOverlap(true);</span>
							}
<span class="nc" id="L3770">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
						}
					} else {
						// the TimeRecord is adjusted to a new period
<span class="nc" id="L3774">						TimeRecordEntry lastEntry = TimeRecordDAO.findLastTimeEntry(timeRecord.getEmployeeID(),</span>
<span class="nc" id="L3775">								TimeZoneUtil.toTimestamp(timeRecord.getStartTime()));</span>
						// If the last Entry is not EndShift, further check must
						// be done
<span class="nc bnc" id="L3778" title="All 4 branches missed.">						if (lastEntry != null &amp;&amp; lastEntry.getActivityID() != Activity.ACTIVITY_NONE) {</span>
							// If the last Entry TimeRecord is still open, throw
							// exception saying it should be closed
<span class="nc bnc" id="L3781" title="All 2 branches missed.">							if (TimeRecordDAO.isOpenShift(lastEntry.getParentID(),</span>
<span class="nc" id="L3782">									TimeZoneUtil.toTimestamp(timeRecord.getStartTime()))) {</span>
<span class="nc" id="L3783">								BbmTimeRecordException e = new BbmTimeRecordException(</span>
										BbmTimeRecordException.TR_PRV_OPEN_SHIFT);
<span class="nc" id="L3785">								e.setContent(lastEntry);</span>
<span class="nc" id="L3786">								throw e;</span>
							}
							// Or it will overlap with that TimeRecord for sure
<span class="nc" id="L3789">							throw new BbmTimeRecordException(BbmTimeRecordException.TR_OVERLAP_RECORD);</span>
						}
					}
				}
<span class="nc" id="L3793">			} else {</span>
				// invalid
<span class="nc" id="L3795">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_INVALID);</span>
			}
			// First refresh the TimeRecord
<span class="nc" id="L3798">			TimeRecordDAO.refreshTimeRecord(timeRecord);</span>
			// Last step is to update timerecord, for escalate syncstatus,
			// remarker employee id
<span class="nc" id="L3801">			TimeRecordDAO.updateTimeRecord(timeRecord, true, true);</span>
			// Cache Task
<span class="nc bnc" id="L3803" title="All 2 branches missed.">			if (cacheUsed()) {</span>
<span class="nc bnc" id="L3804" title="All 2 branches missed.">				if (m_DebugEnabled) {</span>
<span class="nc" id="L3805">					m_cat.debug(&quot;In updateTimeRecord, new TimeRecord is &quot; + timeRecord);</span>
				}
<span class="nc" id="L3807">				TimeRecordCacheUtil.updateInCache(m_TimeRecordCache, timeRecord);</span>
			}
<span class="nc" id="L3809">			updateLastEntryCache(timeRecord.getLastEntry());</span>
<span class="nc" id="L3810">			AuditTrailEntry auditEntry = new AuditTrailEntry(AuditTrailEntry.MODULE_TIMERECORD,</span>
<span class="nc" id="L3811">					AuditTrailEntry.ACTION_UPDATE_OBJECT, timeRecord.getEmployeeID(),</span>
<span class="nc" id="L3812">					getEmployeeName(timeRecord.getEmployeeID()), timeRecord.getStartTime(), timeRecord.getEndTime());</span>
<span class="nc" id="L3813">			auditEntry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(Event.EVENT_TYPE_TIME_RECORD),</span>
					&quot;-1&quot;, false);
<span class="nc" id="L3815">			m_EventAuditTrailManager.createAuditEntry(auditEntry);</span>
<span class="nc" id="L3816">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3817">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3818">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3819">		} catch (JdmoException e) {</span>
<span class="nc" id="L3820">			handleException(e);</span>
<span class="nc" id="L3821">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3822">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3823">			handleException(e);</span>
<span class="nc" id="L3824">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3825">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3826">			handleException(e);</span>
<span class="nc" id="L3827">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3828">		} catch (Exception e) {</span>
<span class="nc" id="L3829">			handleException(e);</span>
<span class="nc" id="L3830">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3832">			methodFinish();</span>
<span class="nc" id="L3833">		}</span>
<span class="nc" id="L3834">	}</span>

	/**
	 * Used By UI routine, only update TimeRecord information
	 * 
	 * @param TimeRecord
	 *            , timeRecord
	 */
	public void updateTimeRecordOnly(TimeRecord timeRecord) throws BbmUpdateException, BbmTimeRecordException {
<span class="nc" id="L3843">		methodStart(&quot;updateTimeRecordOnly&quot;, timeRecord);</span>
		try {
<span class="nc bnc" id="L3845" title="All 2 branches missed.">			if (TimeRecordDAO.updateTimeRecord(timeRecord, true, false) != 0) {</span>
<span class="nc bnc" id="L3846" title="All 2 branches missed.">				if (cacheUsed()) {</span>
					// Cache task
<span class="nc bnc" id="L3848" title="All 2 branches missed.">					if (m_DebugEnabled)</span>
<span class="nc" id="L3849">						m_cat.debug(&quot;In updateTimeRecordOnly, new TimeRecord is &quot; + timeRecord);</span>
<span class="nc" id="L3850">					TimeRecordCacheUtil.refreshInCache(m_TimeRecordCache, timeRecord);</span>
				}
			}
<span class="nc" id="L3853">		} catch (SPMultiUserException e) {</span>
<span class="nc" id="L3854">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3855">			throw new BbmTimeRecordException(BbmTimeRecordException.TR_OBSOLETE);</span>
<span class="nc" id="L3856">		} catch (JdmoException e) {</span>
<span class="nc" id="L3857">			handleException(e);</span>
<span class="nc" id="L3858">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3859">		} catch (Exception e) {</span>
<span class="nc" id="L3860">			handleException(e);</span>
<span class="nc" id="L3861">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3863">			methodFinish();</span>
<span class="nc" id="L3864">		}</span>
<span class="nc" id="L3865">	}</span>

	/**
	 * to update a TimeInterval from UI
	 * 
	 * @param ID
	 *            TimeRecord ID
	 * @param TimeInterval
	 *            to-be-updated TimeInterval
	 */
	public void updateTimeInterval(ID timeRecordID, TimeInterval interval) throws BbmUpdateException,
			BbmTimeRecordException {
<span class="nc" id="L3877">		methodStart(&quot;updateTimeInterval&quot;, timeRecordID, interval);</span>
		try {
<span class="nc" id="L3879">			TimeRecord tr = TimeRecordDAO.getTimeRecordByID(timeRecordID);</span>
			// Here use pessimistic lock, acquire the TimeReocrd before update
			// Coz, for TimeInterval, only one interval for one TimeRecord
<span class="nc" id="L3882">			tr = TimeRecordDAO.getTimeRecordForUpdateOnly(timeRecordID);</span>
<span class="nc bnc" id="L3883" title="All 4 branches missed.">			if (tr != null &amp;&amp; !tr.isLocked()) {</span>
<span class="nc" id="L3884">				interval.setParentID(tr);</span>
				// Copy the remarker ID to TimeRecord for update
<span class="nc bnc" id="L3886" title="All 2 branches missed.">				if (interval.getRemarkerID() != null) {</span>
<span class="nc" id="L3887">					tr.setRemarkEmployeeID(interval.getRemarkerID());</span>
				}
<span class="nc" id="L3889">				tr.setApprove(false);</span>
<span class="nc" id="L3890">				TimeRecordDAO.updateTimeRecord(tr, false, false);</span>
<span class="nc" id="L3891">				TimeRecordDAO.updateTimeIntervalOnly(interval);</span>
			} else {
<span class="nc bnc" id="L3893" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L3894">					throw new BbmTimeRecordException(BbmTimeRecordException.TR_REMOVED);</span>
				}
<span class="nc" id="L3896">				throw new BbmTimeRecordException(BbmTimeRecordException.TR_POSTED);</span>
			}
<span class="nc" id="L3898">		} catch (JdmoDuplicateKeyException e) {</span>
<span class="nc" id="L3899">			handleException(Priority.INFO, e);</span>
<span class="nc" id="L3900">			throw new BbmUpdateDuplicateKeyException(e);</span>
<span class="nc" id="L3901">		} catch (JdmoException e) {</span>
<span class="nc" id="L3902">			handleException(e);</span>
<span class="nc" id="L3903">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L3904">		} catch (BbmTimeRecordException e) {</span>
<span class="nc" id="L3905">			handleException(e);</span>
<span class="nc" id="L3906">			throw e;</span>
<span class="nc" id="L3907">		} catch (Exception e) {</span>
<span class="nc" id="L3908">			handleException(e);</span>
<span class="nc" id="L3909">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3911">			methodFinish();</span>
<span class="nc" id="L3912">		}</span>
<span class="nc" id="L3913">	}</span>

	/**
	 * Get Agent whose shift is in Open Status, which means he/she &quot;is IN&quot;
	 * 
	 * @param Collection
	 *            empCol
	 * @return Collection empCol
	 */
	public Collection whoIsIn(Collection empCol) throws BbmFinderException {
<span class="nc" id="L3923">		methodStart(&quot;whoIsIn&quot;);</span>
		try {
<span class="nc" id="L3925">			return whoIsIn(empCol, true);</span>
<span class="nc" id="L3926">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3927">			handleException(e, false);</span>
<span class="nc" id="L3928">			throw e;</span>
		} finally {
<span class="nc" id="L3930">			methodFinish();</span>
		}
	}

	private Collection whoIsIn(Collection empCol, boolean checkActivity) throws BbmFinderException {
		try {
<span class="nc bnc" id="L3936" title="All 4 branches missed.">			if (empCol == null || empCol.isEmpty()) {</span>
<span class="nc" id="L3937">				return Collections.emptyList();</span>
			}
<span class="nc bnc" id="L3939" title="All 2 branches missed.">			if (m_DebugEnabled) {</span>
<span class="nc" id="L3940">				m_cat.debug(&quot;In WhoIsIn, we are checking &quot; + empCol);</span>
			}
			// Track who is in
<span class="nc" id="L3943">			ArrayList empInCol = new ArrayList(empCol.size());</span>
			// Track who is not in cache
<span class="nc" id="L3945">			ArrayList empMissedCol = new ArrayList();</span>
<span class="nc" id="L3946">			HashMap empActMap = new HashMap(empCol.size());</span>
<span class="nc" id="L3947">			long lastDayTime = System.currentTimeMillis() - m_LookBackMinutes;</span>
<span class="nc bnc" id="L3948" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">				for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3950">					ID empID = (ID) it.next();</span>
<span class="nc" id="L3951">					TimeRecordEntry entry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="nc bnc" id="L3952" title="All 2 branches missed.">					if (entry == null) {</span>
<span class="nc" id="L3953">						empMissedCol.add(empID);</span>
<span class="nc bnc" id="L3954" title="All 2 branches missed.">						if (m_DebugEnabled) {</span>
<span class="nc" id="L3955">							m_cat.debug(&quot;In WhoIsIn, failed to hit cache for employee &quot; + empID);</span>
						}
					} else {
<span class="nc bnc" id="L3958" title="All 4 branches missed.">						if (entry.getID() != null &amp;&amp; !entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
							// if entry starts earlier than 24 hours of curTime,
							// ignore it
<span class="nc bnc" id="L3961" title="All 2 branches missed.">							if (entry.getSortTime().getTime() &lt; lastDayTime) {</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">								if (m_DebugEnabled) {</span>
<span class="nc" id="L3963">									m_cat.debug(&quot;In WhoIsIn, employee &quot; + empID</span>
<span class="nc" id="L3964">											+ &quot; starts 24 hours earlier than now at &quot; + entry.getSortTime());</span>
								}
								continue;
							}
							// if not end shift, need further check activity
							// in/out attribute
<span class="nc" id="L3970">							empActMap.put(empID, entry.getActivityID());</span>
<span class="nc bnc" id="L3971" title="All 2 branches missed.">							if (m_DebugEnabled) {</span>
<span class="nc" id="L3972">								m_cat.debug(&quot;In WhoIsIn, employee &quot; + empID + &quot; has open shift&quot;);</span>
							}
						}
					}
<span class="nc" id="L3976">				}</span>
			} else {
<span class="nc" id="L3978">				empMissedCol = new ArrayList(empCol);</span>
			}
			// If there are employee not in cache yet, hit DB to find info
<span class="nc bnc" id="L3981" title="All 2 branches missed.">			if (!empMissedCol.isEmpty()) {</span>
<span class="nc" id="L3982">				Collection entryCol = TimeRecordDAO.findLastEntry(empMissedCol, null, m_LookBackTimeEntryDays);</span>
<span class="nc bnc" id="L3983" title="All 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3984">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc bnc" id="L3985" title="All 4 branches missed.">					if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc" id="L3986">						m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
					}
<span class="nc bnc" id="L3988" title="All 2 branches missed.">					if (!entry.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc bnc" id="L3989" title="All 2 branches missed.">						if (entry.getSortTime().getTime() &lt; lastDayTime) {</span>
<span class="nc bnc" id="L3990" title="All 2 branches missed.">							if (m_DebugEnabled) {</span>
<span class="nc" id="L3991">								m_cat.debug(&quot;In WhoIsIn, employee &quot; + entry.getEmployeeID()</span>
<span class="nc" id="L3992">										+ &quot; starts 24 hours earlier than now at &quot; + entry.getSortTime());</span>
							}
							continue;
						}
						// if not end shift, need further check activity in/out
						// attribute
<span class="nc" id="L3998">						empActMap.put(entry.getEmployeeID(), entry.getActivityID());</span>
					}
<span class="nc" id="L4000">					empMissedCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L4001">				}</span>
				// if there is still employee without entry, add dump entry
<span class="nc bnc" id="L4003" title="All 6 branches missed.">				if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; !empMissedCol.isEmpty()) {</span>
<span class="nc bnc" id="L4004" title="All 2 branches missed.">					for (Iterator it = empMissedCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4005">						ID empID = (ID) it.next();</span>
<span class="nc" id="L4006">						TimeRecordEntry dumpEntry = new TimeRecordEntry();</span>
<span class="nc" id="L4007">						m_LastEntryCache.put(empID, dumpEntry);</span>
<span class="nc" id="L4008">					}</span>
				}
			}
<span class="nc bnc" id="L4011" title="All 2 branches missed.">			if (checkActivity) {</span>
				// now check Activity attributes
<span class="nc" id="L4013">				HashSet actIDSet = new HashSet(empActMap.keySet().size());</span>
<span class="nc" id="L4014">				actIDSet.addAll(empActMap.values());</span>
<span class="nc" id="L4015">				Collection actCol = m_ActivityManager.findActivities(actIDSet);</span>
<span class="nc" id="L4016">				HashMap actMap = new HashMap(actCol.size());</span>
				// convert collection to map
<span class="nc bnc" id="L4018" title="All 2 branches missed.">				for (Iterator it = actCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4019">					Activity act = (Activity) it.next();</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">					actMap.put(act.getID(), act.isOut() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L4021">				}</span>
				// now check employee's activity
<span class="nc bnc" id="L4023" title="All 2 branches missed.">				for (Iterator it = empActMap.keySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L4024">					ID empID = (ID) it.next();</span>
<span class="nc" id="L4025">					ID actID = (ID) empActMap.get(empID);</span>
<span class="nc" id="L4026">					Boolean isIn = (Boolean) actMap.get(actID);</span>
<span class="nc bnc" id="L4027" title="All 4 branches missed.">					if (isIn != null &amp;&amp; !isIn.booleanValue()) {</span>
<span class="nc" id="L4028">						empInCol.add(empID);</span>
					}
<span class="nc" id="L4030">				}</span>
<span class="nc" id="L4031">			} else {</span>
<span class="nc" id="L4032">				empInCol.addAll(empActMap.keySet());</span>
			}
<span class="nc" id="L4034">			return empInCol;</span>
<span class="nc" id="L4035">		} catch (JdmoException e) {</span>
<span class="nc" id="L4036">			throw new BbmFinderException(e);</span>
<span class="nc" id="L4037">		} catch (RemoteException e) {</span>
<span class="nc" id="L4038">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Find last Entry for a given Employee, before a given Date
	 * 
	 * @param ID
	 *            , empID
	 * @param Date
	 *            , date
	 * @return TimeRecordEntry
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public TimeRecordEntry getLastEntry(ID empID, Date date) throws BbmFinderException, RemoteException {
<span class="nc" id="L4054">		methodStart(&quot;getLastEntry&quot;, empID, date);</span>
		try {
<span class="nc" id="L4056">			ArrayList empIDCol = new ArrayList(1);</span>
<span class="nc" id="L4057">			empIDCol.add(empID);</span>
<span class="nc" id="L4058">			HashMap entryMap = getLastEntries(empIDCol, date);</span>
<span class="nc" id="L4059">			return (TimeRecordEntry) entryMap.get(empID);</span>
		} finally {
<span class="nc" id="L4061">			methodFinish();</span>
		}
	}

	/**
	 * Find last Entry for a given Employee, before a given Date
	 * 
	 * @param Collection
	 *            , empID Collection
	 * @param Date
	 *            , date
	 * @return TimeRecordEntry
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public HashMap getLastEntries(Collection empIDCol, Date date) throws BbmFinderException, RemoteException {
<span class="nc" id="L4077">		methodStart(&quot;getLastEntries&quot;, empIDCol, date);</span>
		try {
<span class="nc" id="L4079">			HashMap entryMap = new HashMap(empIDCol.size());</span>
<span class="nc" id="L4080">			ArrayList empCol = new ArrayList(empIDCol.size());</span>
<span class="nc bnc" id="L4081" title="All 4 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc bnc" id="L4082" title="All 2 branches missed.">				for (Iterator it = empIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4083">					ID empID = (ID) it.next();</span>
<span class="nc" id="L4084">					TimeRecordEntry entry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="nc bnc" id="L4085" title="All 2 branches missed.">					if (entry != null) {</span>
<span class="nc bnc" id="L4086" title="All 2 branches missed.">						if (date == null) {</span>
							// if a dummy entry is found, it implies no entry
							// for employee at all
<span class="nc bnc" id="L4089" title="All 2 branches missed.">							if (entry.getID() != null) {</span>
<span class="nc" id="L4090">								entryMap.put(empID, entry);</span>
							}
						} else {
							// if a date is given, need check if the last Entry
							// is before that date
							// if not, need refetch from DB
<span class="nc bnc" id="L4096" title="All 2 branches missed.">							if (entry.getID() != null) {</span>
<span class="nc bnc" id="L4097" title="All 2 branches missed.">								if (entry.getStartTime().before(date)) {</span>
<span class="nc" id="L4098">									entryMap.put(empID, entry);</span>
								} else {
<span class="nc" id="L4100">									empCol.add(empID);</span>
								}
							}
						}
					} else {
<span class="nc" id="L4105">						empCol.add(empID);</span>
					}
<span class="nc" id="L4107">				}</span>
			} else {
<span class="nc" id="L4109">				empCol.addAll(empIDCol);</span>
			}
<span class="nc" id="L4111">			ArrayList empBakCol = new ArrayList();</span>
			// Need Hit DB, try load cache
<span class="nc bnc" id="L4113" title="All 6 branches missed.">			if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; !empCol.isEmpty()) {</span>
				// Load from current moment
<span class="nc" id="L4115">				Collection entryCol = TimeRecordDAO.findLastEntry(empCol, null, m_LookBackTimeEntryDays);</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4117">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L4118">					entryMap.put(entry.getEmployeeID(), entry);</span>
<span class="nc bnc" id="L4119" title="All 4 branches missed.">					if (date != null &amp;&amp; !entry.getStartTime().before(date)) {</span>
						// if last entry is after given date, need reload
<span class="nc" id="L4121">						empBakCol.add(entry.getEmployeeID());</span>
					}
<span class="nc" id="L4123">				}</span>
				// if there is still employee without entry, add dummy entry
<span class="nc bnc" id="L4125" title="All 2 branches missed.">				for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4126">					ID empID = (ID) it.next();</span>
<span class="nc" id="L4127">					Object entry = entryMap.get(empID);</span>
<span class="nc bnc" id="L4128" title="All 2 branches missed.">					if (entry != null) {</span>
<span class="nc" id="L4129">						m_LastEntryCache.put(empID, entry);</span>
					} else {
<span class="nc" id="L4131">						m_LastEntryCache.put(empID, new TimeRecordEntry());</span>
					}
<span class="nc" id="L4133">				}</span>
<span class="nc bnc" id="L4134" title="All 4 branches missed.">				if (empBakCol.isEmpty() || date == null) {</span>
<span class="nc" id="L4135">					return entryMap;</span>
				}
<span class="nc" id="L4137">			} else {</span>
<span class="nc" id="L4138">				empBakCol = empCol;</span>
			}
			// load entries before given date
<span class="nc bnc" id="L4141" title="All 2 branches missed.">			if (!empBakCol.isEmpty()) {</span>
<span class="nc" id="L4142">				Collection entryCol = TimeRecordDAO.findLastEntry(empBakCol, date);</span>
<span class="nc bnc" id="L4143" title="All 2 branches missed.">				for (Iterator it = entryCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4144">					TimeRecordEntry entry = (TimeRecordEntry) it.next();</span>
<span class="nc" id="L4145">					entryMap.put(entry.getEmployeeID(), entry);</span>
<span class="nc" id="L4146">					empBakCol.remove(entry.getEmployeeID());</span>
<span class="nc" id="L4147">				}</span>
				// in case some entries are in map, but not exist before the
				// given date, remove them
<span class="nc bnc" id="L4150" title="All 2 branches missed.">				for (Iterator it = empBakCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4151">					entryMap.remove(it.next());</span>
				}
			}
<span class="nc" id="L4154">			return entryMap;</span>
<span class="nc" id="L4155">		} catch (JdmoException e) {</span>
<span class="nc" id="L4156">			handleException(e, false);</span>
<span class="nc bnc" id="L4157" title="All 2 branches missed.">			if (e.isConnectivityException())</span>
<span class="nc" id="L4158">				throw new ConnectException(e.getMessage(), e);</span>
<span class="nc" id="L4159">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4161">			methodFinish();</span>
		}
	}

	/**
	 * Return last entry for each employee in the system, if it is created from
	 * a managed datasource or not from any datasource
	 * 
	 * @return Collection, Time Record Entry
	 * @throws BbmFinderException
	 */
	public Collection findLastEntries() throws BbmFinderException {
<span class="nc" id="L4173">		methodStart(&quot;findLastEntries&quot;);</span>
		try {
<span class="nc" id="L4175">			return TimeRecordDAO.findLastEntries();</span>
<span class="nc" id="L4176">		} catch (JdmoException e) {</span>
<span class="nc" id="L4177">			handleException(e, false);</span>
<span class="nc" id="L4178">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4180">			methodFinish();</span>
		}
	}

	/**
	 * Return last entry for given employee in the system, if it is created from
	 * a given datasource before a given date
	 * 
	 * @param Collection
	 *            , employee ID collection
	 * @param ID
	 *            , DataSource ID
	 * @param Date
	 *            , date
	 * @return Collection, Time Record Entry
	 * @throws BbmFinderException
	 */
	public Collection findLastEntries(Collection empIDCol, ID dataSourceID, Date date) throws BbmFinderException {
<span class="nc" id="L4198">		methodStart(&quot;findLastEntries&quot;, empIDCol, dataSourceID, date);</span>
		try {
<span class="nc" id="L4200">			return TimeRecordDAO.findLastEntries();</span>
<span class="nc" id="L4201">		} catch (JdmoException e) {</span>
<span class="nc" id="L4202">			handleException(e, false);</span>
<span class="nc" id="L4203">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4205">			methodFinish();</span>
		}
	}

	// for create entry or update entry, if there is no entry, it won't load
	// cache, defer loading
	private void updateLastEntryCache(TimeRecordEntry entry) {
<span class="nc bnc" id="L4212" title="All 8 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; entry != null &amp;&amp; entry.getEmployeeID() != null) {</span>
<span class="nc" id="L4213">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(entry.getEmployeeID());</span>
			// defer last entry loading
<span class="nc bnc" id="L4215" title="All 2 branches missed.">			if (lastEntry == null) {</span>
<span class="nc" id="L4216">				return;</span>
			}
<span class="nc bnc" id="L4218" title="All 2 branches missed.">			if (lastEntry.getID() == null) {</span>
<span class="nc" id="L4219">				m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
			} else {
<span class="nc bnc" id="L4221" title="All 2 branches missed.">				if (entry.getID().equals(lastEntry.getID())) {</span>
<span class="nc" id="L4222">					lastEntry.refresh(entry);</span>
<span class="nc" id="L4223">					lastEntry.setStartTime(entry.getStartTime());</span>
<span class="nc" id="L4224">					lastEntry.setSortTime(entry.getSortTime());</span>
<span class="nc" id="L4225">					m_LastEntryCache.put(entry.getEmployeeID(), lastEntry);</span>
<span class="nc bnc" id="L4226" title="All 2 branches missed.">				} else if (entry.getSortTime().after(lastEntry.getSortTime())</span>
<span class="nc bnc" id="L4227" title="All 2 branches missed.">						|| entry.getSortTime().equals(lastEntry.getSortTime())) {</span>
<span class="nc" id="L4228">					m_LastEntryCache.put(entry.getEmployeeID(), entry);</span>
				}
			}
		}
<span class="nc" id="L4232">	}</span>

	// if need remove an entry, won't do fetch for the new lastEntry, defer the
	// loading
	private void removeLastEntryCache(TimeRecordEntry entry) {
<span class="nc bnc" id="L4237" title="All 8 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null &amp;&amp; entry != null &amp;&amp; entry.getEmployeeID() != null</span>
<span class="nc bnc" id="L4238" title="All 2 branches missed.">				&amp;&amp; entry.getID() != null) {</span>
<span class="nc" id="L4239">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(entry.getEmployeeID());</span>
<span class="nc bnc" id="L4240" title="All 6 branches missed.">			if (lastEntry != null &amp;&amp; lastEntry.getID() != null &amp;&amp; entry.getID().equals(lastEntry.getID())) {</span>
<span class="nc" id="L4241">				m_LastEntryCache.remove(entry.getEmployeeID());</span>
			}
		}
<span class="nc" id="L4244">	}</span>

	// if need remove an entry, won't do fetch for the new lastEntry, defer the
	// loading
	private void removeLastEntryCache(ID empID, ID trID) {
<span class="nc bnc" id="L4249" title="All 4 branches missed.">		if (cacheUsed() &amp;&amp; m_LastEntryCache != null) {</span>
<span class="nc" id="L4250">			TimeRecordEntry lastEntry = (TimeRecordEntry) m_LastEntryCache.get(empID);</span>
<span class="nc bnc" id="L4251" title="All 6 branches missed.">			if ((lastEntry != null) &amp;&amp; lastEntry.getID() != null &amp;&amp; trID.equals(lastEntry.getTimeRecordID())) {</span>
<span class="nc" id="L4252">				m_LastEntryCache.remove(empID);</span>
			}
		}
<span class="nc" id="L4255">	}</span>

	/**
	 * internal routine to featch all user's name for day detail
	 * 
	 * @param Collection
	 *            timeRecords
	 */
	private void setUserName(Collection timeRecordCol) {
		try {
<span class="nc" id="L4265">			HashSet userID = new HashSet(10);</span>
			// First get all user ID
<span class="nc bnc" id="L4267" title="All 2 branches missed.">			for (Iterator it = timeRecordCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4268">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L4269" title="All 2 branches missed.">				if (tr.getRemarkEmployeeID() != null) {</span>
<span class="nc" id="L4270">					userID.add(tr.getRemarkEmployeeID());</span>
				}
<span class="nc" id="L4272">			}</span>
<span class="nc" id="L4273">			HashMap userName = m_UserManager.getUserNamesByUserIDs(userID);</span>
<span class="nc bnc" id="L4274" title="All 2 branches missed.">			for (Iterator it = timeRecordCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L4275">				TimeRecord tr = (TimeRecord) it.next();</span>
<span class="nc bnc" id="L4276" title="All 2 branches missed.">				if (tr.getRemarkEmployeeID() != null) {</span>
<span class="nc" id="L4277">					tr.setRemarkEmployeeName((String) userName.get(tr.getRemarkEmployeeID()));</span>
				}
<span class="nc" id="L4279">			}</span>
<span class="nc" id="L4280">		} catch (Exception e) {</span>
<span class="nc bnc" id="L4281" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L4282">				m_cat.debug(e);</span>
			}
<span class="nc" id="L4284">		}</span>
<span class="nc" id="L4285">	}</span>

	private String getEmployeeName(ID empID) throws Exception {
<span class="nc" id="L4288">		return m_WorkResourceManager.getEmployeeNameByID(empID).getDisplayName(</span>
<span class="nc" id="L4289">				DefaultLocalizationManager.getDefaultInstance().getLocalizer());</span>
	}

	private String getRemarkerName(ID modifierID, Jdmo jdmo) {
<span class="nc" id="L4293">		String strRet = &quot;&quot;;</span>
		try {
<span class="nc bnc" id="L4295" title="All 2 branches missed.">			if (modifierID != null) {</span>
<span class="nc" id="L4296">				UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L4297">				User remarker = userMgr.getUserByID(modifierID);</span>
<span class="nc" id="L4298">				ID employeeID = remarker.getEmployeeID();</span>
<span class="nc bnc" id="L4299" title="All 2 branches missed.">				if (employeeID != null) {</span>
<span class="nc" id="L4300">					Employee emp = m_WorkResourceManager.getEmployeeByID(employeeID);</span>
<span class="nc" id="L4301">					strRet = emp.getFirstName() + &quot; &quot; + emp.getLastName();</span>
				}
			}
<span class="nc" id="L4304">		} catch (Exception ex) {</span>
<span class="nc" id="L4305">			return &quot;&quot;;</span>
<span class="nc" id="L4306">		}</span>

<span class="nc" id="L4308">		return strRet;</span>
	}

	private void createTempTableForUniqueIntIDs(String empTempTableName, Jdmo jdmo, Collection&lt;ID&gt; uniqueIDs) throws JdmoException {
		try {
<span class="nc" id="L4313">			String strTemptableName = jdmo.getNativeTemptableName(empTempTableName);</span>
<span class="nc" id="L4314">			jdmo.createTempTable(strTemptableName + &quot; (ID int)&quot;);</span>
<span class="nc" id="L4315">			jdmo.execute(&quot;Create Unique clustered index &quot; + empTempTableName + &quot;_index &quot; + &quot; ON &quot; + strTemptableName + &quot; (ID)&quot;);</span>

			//for oracle and sql server, preparedStatement is more faster than Statement.
<span class="nc" id="L4318">			JdmoPCommand pc = jdmo.createPCommand(&quot;insert into &quot;+strTemptableName+&quot; values(?)&quot;);</span>
<span class="nc" id="L4319">			HashMap param = new HashMap();</span>
<span class="nc" id="L4320">			int ix = 0;</span>
<span class="nc bnc" id="L4321" title="All 2 branches missed.">			for (ID id : uniqueIDs) {</span>
<span class="nc" id="L4322">				param.clear();</span>
<span class="nc" id="L4323">				param.put(new Integer(1), new Integer(id.toInt()));</span>
<span class="nc" id="L4324">				pc.setParams(param);</span>
<span class="nc" id="L4325">				pc.addBatch();</span>
<span class="nc" id="L4326">			}</span>
<span class="nc" id="L4327">			jdmo.executeBatchPCommand(pc);</span>

<span class="nc" id="L4329">		} catch(SQLException e) {</span>
<span class="nc" id="L4330">			throw new JdmoException(e);</span>
<span class="nc" id="L4331">		}</span>
<span class="nc" id="L4332">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>