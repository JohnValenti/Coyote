<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FTValidationCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.flextime.validation</a> &gt; <span class="el_source">FTValidationCache.java</span></div><h1>FTValidationCache.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.flextime.validation;

import java.lang.Long;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.validation.FilingRuleChecker;
import com.bluepumpkin.ejb.rm.requests.common.validation.FilingRuleCheckerHelper;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.custshift.ejb.CustShiftReqMgr;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReq;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReqFieldInfo;
import com.bluepumpkin.ejb.rm.requests.custshift.model.CustShiftReqGap;
import com.bluepumpkin.ejb.rm.requests.flextime.ejb.FlexTimeRequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexReqMakeupGap;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexRequestMakeup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvaliableHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.AvoidBlackoutsValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.EmployeeHoursValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.RequestInPastValidationRule;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TOValidationCache;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffNotBeingSwappedValidationRule;
import com.bluepumpkin.ejb.rm.util.CustomShiftEJBUtil;
import com.verint.ejb.wfm.WfmManagerFactory;

public class FTValidationCache extends TOValidationCache {

<span class="nc" id="L56">	private static final Category LOG = Log.initCategory(FTValidationCache.class.getName());</span>

	private static final String FILING_RULE_CHECKER = &quot;FILING_RULE_CHECKER&quot;;

	private TORequest tor;

	public FTValidationCache(TORequest tor) {
<span class="nc" id="L63">		super(tor);</span>
<span class="nc" id="L64">		this.tor = tor;</span>
<span class="nc" id="L65">	}</span>

	private CustShiftReqMgr getCSRequestManager() throws BbmCreateException {
<span class="nc" id="L68">		return RmManagerFactory.getInstance().getCustShiftReqMgr();</span>
	}

	private WorkRuleManager getWorkRuleManager() throws BbmEJBCreateException {
<span class="nc" id="L72">		return WfmManagerFactory.getWorkRuleManager(false);</span>
	}

	@Cacheable
	public ShiftAssignment getShiftAssignmentByID(ID shiftAssignmentID) throws Exception {
		try {
<span class="nc" id="L78">			return getScheduleAccessManager().getShiftAssignmentByID(shiftAssignmentID);</span>
<span class="nc" id="L79">		} catch (BbmObjectNotFoundException e) {</span>
			// not found
<span class="nc" id="L81">			LOG.warn(&quot;Could not find shift assignment for ID=&quot; + shiftAssignmentID, e);</span>
<span class="nc" id="L82">			return null;</span>
		}
	}

	@Cacheable
	public ShiftOTExtension getShiftOTExtensionByID(ID shiftOTExtensionID) throws Exception {
		try {
<span class="nc" id="L89">			return getWorkRuleManager().getShiftOTExtensionByID(shiftOTExtensionID);</span>
<span class="nc" id="L90">		} catch (BbmObjectNotFoundException e) {</span>
			// not found
<span class="nc" id="L92">			LOG.warn(&quot;Could not find shift OT extension for ID=&quot; + shiftOTExtensionID, e);</span>
<span class="nc" id="L93">			return null;</span>
		}
	}

	@Cacheable
	public boolean isPublishedShiftInSync(ShiftAssignment sa) throws Exception {
<span class="nc" id="L99">		return CustomShiftEJBUtil.isPublishedShiftInSync(sa, getScheduleAccessManager());</span>
	}

	/**
	 * Get a filing rules checker for this request.  Subclasses may specialize this method
	 * if a different implementation from this default is required.  In such cases, the parameter
	 * 'notUsed' can be used to pass additional information.
	 *
	 * @param notUsed Not used in this implementation.  Sub classes may decide to use it when overriding this
	 * method.
	 */
	@Override
	public FilingRuleChecker getFilingRuleChecker(Object requestObject) throws Exception {
<span class="nc" id="L112">		TORequest request = (TORequest) requestObject;</span>

		// Check to see if the checker is already in the cache
<span class="nc" id="L115">		FilingRuleChecker result = (FilingRuleChecker) get(FILING_RULE_CHECKER);</span>

		// If map was in the cache, use it
<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L119">			return result;</span>
		}

<span class="nc" id="L122">		result = FilingRuleCheckerHelper.getChecker(request.getCache().getOrg(),</span>
				Request.REQUESTTYPE_FLEXTIME,
<span class="nc" id="L124">				request.getTimeOffType(),</span>
<span class="nc" id="L125">				request.getFlexTimeRequestSubType(),</span>
<span class="nc" id="L126">				getDateRange());</span>

		// Save in cache
<span class="nc" id="L129">		put(FILING_RULE_CHECKER, result);</span>

<span class="nc" id="L131">		return result;</span>
	}


	/**
	 * Returns a sorted list of makeup time ranges (without gaps - i.e working time only) for this flex request.
	 * It includes all the makeups that are before, after and within the shift gaps
	 * @return
	 * @throws Exception
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	@Cacheable
	public List&lt;TimeRange&gt; getMakeupDurations() throws Exception {
		// Find makeup durations
<span class="nc" id="L145">		List&lt;TimeRange&gt; makeupDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		for (FlexRequestMakeup flexMakeup : tor.getFlexRequestMakeupList()) {</span>
<span class="nc" id="L147">			TimeRange timeRange = getMakeupDurationBeforeShift(flexMakeup);</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">			if (timeRange != null) {</span>
<span class="nc" id="L149">				makeupDurations.add(timeRange);</span>
			}
<span class="nc" id="L151">			timeRange = getMakeupDurationAfterShift(flexMakeup);</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">			if (timeRange != null) {</span>
<span class="nc" id="L153">				makeupDurations.add(timeRange);</span>
			}
<span class="nc bnc" id="L155" title="All 2 branches missed.">			if (flexMakeup.getFlexReqMakeupGaps() != null) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">				for (FlexReqMakeupGap gap : flexMakeup.getFlexReqMakeupGaps()) {</span>
<span class="nc" id="L157">					makeupDurations.add(getMakeupDurationInGap(gap));</span>
<span class="nc" id="L158">				}</span>
			}
<span class="nc" id="L160">		}</span>
<span class="nc" id="L161">		Collections.sort(makeupDurations);</span>
<span class="nc" id="L162">		return Collections.unmodifiableList(makeupDurations);</span>
	}

	private TimeRange getMakeupDurationAfterShift(FlexRequestMakeup flexMakeup) throws Exception {
		TimeRange timeRange;
<span class="nc bnc" id="L167" title="All 2 branches missed.">		if (flexMakeup.getExtAfterActivityID() != null) {</span>
<span class="nc" id="L168">			Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc" id="L169">			cal.setTime(flexMakeup.getShiftEndTime());</span>
<span class="nc" id="L170">			cal.add(Calendar.MINUTE, flexMakeup.getExtAfterGap());</span>
<span class="nc" id="L171">			Date afterStartTime = cal.getTime();</span>
<span class="nc" id="L172">			cal.add(Calendar.MINUTE, flexMakeup.getExtAfterDuration());</span>
<span class="nc" id="L173">			Date afterEndTime = cal.getTime();</span>
<span class="nc" id="L174">			timeRange = new TimeRange(afterStartTime, afterEndTime);</span>
<span class="nc" id="L175">		} else {</span>
<span class="nc" id="L176">			timeRange = null;</span>
		}
<span class="nc" id="L178">		return timeRange;</span>
	}

	private TimeRange getMakeupDurationBeforeShift(FlexRequestMakeup flexMakeup) throws Exception {
		TimeRange timeRange;
<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (flexMakeup.getExtBeforeActivityID() != null) {</span>
<span class="nc" id="L184">			Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc" id="L185">			cal.setTime(flexMakeup.getShiftStartTime());</span>
<span class="nc" id="L186">			cal.add(Calendar.MINUTE, - (flexMakeup.getExtBeforeGap() + flexMakeup.getExtBeforeDuration()));</span>
<span class="nc" id="L187">			Date beforeStartTime = cal.getTime();</span>
<span class="nc" id="L188">			cal.add(Calendar.MINUTE, flexMakeup.getExtBeforeDuration());</span>
<span class="nc" id="L189">			Date beforeEndTime = cal.getTime();</span>
<span class="nc" id="L190">			timeRange = new TimeRange(beforeStartTime, beforeEndTime);</span>
<span class="nc" id="L191">		} else {</span>
<span class="nc" id="L192">			timeRange = null;</span>
		}
<span class="nc" id="L194">		return timeRange;</span>
	}

	private TimeRange getMakeupDurationInGap(FlexReqMakeupGap gap) throws Exception {
<span class="nc" id="L198">		Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc" id="L199">		cal.setTime(gap.getExtGapStartTime());</span>
<span class="nc" id="L200">		cal.add(Calendar.MINUTE, gap.getExtGapGap());</span>
<span class="nc" id="L201">		Date start = cal.getTime();</span>
<span class="nc" id="L202">		cal.add(Calendar.MINUTE, gap.getExtGapDuration());</span>
<span class="nc" id="L203">		Date end = cal.getTime();</span>
<span class="nc" id="L204">		return new TimeRange(start, end);</span>
	}

	/**
	 * Returns a sorted list of makeup time ranges in shift gaps for this flex request excluding the non-working time (gaps).
	 * It does not include before and after make up's
	 * @return
	 * @throws Exception
	 */
	public Collection&lt;TimeRange&gt; getMakeupInGapsDurations() throws Exception {
		// Find makeup durations
<span class="nc" id="L215">		Collection&lt;TimeRange&gt; makeupDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L216">		Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc bnc" id="L217" title="All 2 branches missed.">		for (FlexRequestMakeup flexMakeup : tor.getFlexRequestMakeupList()) {</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L219">			Collection&lt;FlexReqMakeupGap&gt; gaps = flexMakeup.getFlexReqMakeupGaps();</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">			if (gaps.size()&gt;0){</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">				for(FlexReqMakeupGap gap: gaps){</span>
<span class="nc" id="L222">					cal.setTime(gap.getExtGapStartTime());</span>
<span class="nc" id="L223">					cal.add(Calendar.MINUTE,gap.getExtGapGap());</span>
<span class="nc" id="L224">					Date gapStartTime = cal.getTime();</span>
<span class="nc" id="L225">					cal.add(Calendar.MINUTE,gap.getExtGapDuration());</span>
<span class="nc" id="L226">					makeupDurations.add(new TimeRange(gapStartTime, cal.getTime()));</span>
<span class="nc" id="L227">				}</span>
			}
<span class="nc" id="L229">		}</span>
<span class="nc" id="L230">		return makeupDurations;</span>
	}

	/**
	 * Returns a sorted list of makeup time ranges (without gaps - i.e working time only) for this flex request.
	 * It includes only before and after make up's and not the ones within the shift gaps
	 * @return
	 * @throws Exception
	 */
	public Collection&lt;TimeRange&gt; getMakeupAndGapDurationsBeforeAndAfterShift() throws Exception {
		// Find makeup durations
<span class="nc" id="L241">		Collection&lt;TimeRange&gt; makeupDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L242">		Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">		for (FlexRequestMakeup flexMakeup : tor.getFlexRequestMakeupList()) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">			if (flexMakeup.getExtBeforeActivityID() != null) {</span>
<span class="nc" id="L245">				cal.setTime(flexMakeup.getShiftStartTime());</span>
<span class="nc" id="L246">				cal.add(Calendar.MINUTE, - (flexMakeup.getExtBeforeGap() + flexMakeup.getExtBeforeDuration()));</span>
<span class="nc" id="L247">				makeupDurations.add(new TimeRange(cal.getTime(), flexMakeup.getShiftStartTime()));</span>
			}
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (flexMakeup.getExtAfterActivityID() != null) {</span>
<span class="nc" id="L250">				cal.setTime(flexMakeup.getShiftEndTime());</span>
<span class="nc" id="L251">				cal.add(Calendar.MINUTE, flexMakeup.getExtAfterGap() + flexMakeup.getExtAfterDuration());</span>
<span class="nc" id="L252">				makeupDurations.add(new TimeRange(flexMakeup.getShiftEndTime(), cal.getTime()));</span>
			}
<span class="nc" id="L254">		}</span>
<span class="nc" id="L255">		return makeupDurations;</span>
	}

	private Collection&lt;TimeRange&gt; getMakeupAndGapDurationsInShift() throws Exception {
		// Find makeup durations
<span class="nc" id="L260">		Collection&lt;TimeRange&gt; makeupDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L261">		Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">		for (FlexRequestMakeup flexMakeup : tor.getFlexRequestMakeupList()) {</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">			for (FlexReqMakeupGap gap : flexMakeup.getFlexReqMakeupGaps()) {</span>
<span class="nc" id="L264">				cal.setTime(gap.getExtGapStartTime());</span>
<span class="nc" id="L265">				cal.add(Calendar.MINUTE, gap.getExtGapGap() + gap.getExtGapDuration());</span>
<span class="nc" id="L266">				makeupDurations.add(new TimeRange(gap.getExtGapStartTime(), cal.getTime()));</span>

<span class="nc" id="L268">			}</span>
<span class="nc" id="L269">		}</span>
<span class="nc" id="L270">		return makeupDurations;</span>
	}

	public Collection&lt;TimeRange&gt; getMakeupAndGapDurations() throws Exception {
<span class="nc" id="L274">		List&lt;TimeRange&gt; makeupAndGapDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L275">		makeupAndGapDurations.addAll(getMakeupAndGapDurationsBeforeAndAfterShift());</span>
<span class="nc" id="L276">		makeupAndGapDurations.addAll(getMakeupAndGapDurationsInShift());</span>
<span class="nc" id="L277">		return makeupAndGapDurations;</span>
	}

	public int getTotalMakeupMinutes(TORequest tor) {
<span class="nc" id="L281">		int minutes = 0;</span>
<span class="nc bnc" id="L282" title="All 2 branches missed.">		for(FlexRequestMakeup flex : tor.getFlexRequestMakeupList()) {</span>
<span class="nc" id="L283">			minutes += flex.getExtBeforeDuration() + flex.getExtAfterDuration();</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">			for (FlexReqMakeupGap gap : flex.getFlexReqMakeupGaps()) {</span>
<span class="nc" id="L285">				minutes += gap.getExtGapDuration();</span>
<span class="nc" id="L286">			}</span>
<span class="nc" id="L287">		}</span>
<span class="nc" id="L288">		return minutes;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	@Cacheable
	public Collection&lt;OrganizationHOO&gt; getHOOAssignmentsDuringPeriod(TimeRange range) throws Exception {
<span class="nc" id="L294">		return Collections.unmodifiableCollection(CacheUtilBBM.getOrganizationHOO(getOrg().getID(), range.getStartDate(), range.getEndDate()));</span>
	}

	@Cacheable
	public Collection&lt;ShiftAssignment&gt; getPublishedShiftAssignments(TimeRange duration) throws Exception {
<span class="nc" id="L299">		return getShiftAssignments(duration, true);</span>
	}

	@Cacheable
	public Collection&lt;ShiftAssignment&gt; getUnPublishedShiftAssignments(TimeRange duration) throws Exception {
<span class="nc" id="L304">		return getShiftAssignments(duration, false);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Collection&lt;ShiftAssignment&gt; getShiftAssignments(TimeRange duration, boolean published) throws Exception {
		Collection&lt;PlannedEvent&gt; shifts;
<span class="nc bnc" id="L310" title="All 2 branches missed.">		if (published) {</span>
<span class="nc" id="L311">			shifts = ValidationUtil.getPublishedEventsForWorkResourceByType( Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
<span class="nc" id="L312">					tor.getEmployeeID(), duration.getStartDate(), duration.getEndDate());</span>
		} else {
<span class="nc" id="L314">			shifts = ValidationUtil.getEventsForWorkResourceByType( Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
<span class="nc" id="L315">					tor.getEmployeeID(), duration.getStartDate(), duration.getEndDate());</span>
		}

<span class="nc" id="L318">		Collection&lt;ShiftAssignment&gt; shiftAssignments = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">		for (PlannedEvent obj : shifts) {</span>
<span class="nc bnc" id="L320" title="All 2 branches missed.">			if (obj.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L321">				shiftAssignments.add((ShiftAssignment) obj);</span>
			}
<span class="nc" id="L323">		}</span>
<span class="nc" id="L324">		return Collections.unmodifiableCollection(shiftAssignments);</span>
	}

	@Cacheable
	public Collection&lt;CalendarEventAssignment&gt; getPublishedCalendarEvents(TimeRange duration) throws Exception {
<span class="nc" id="L329">		return getCalendarEvents(duration, true);</span>
	}

	@Cacheable
	public Collection&lt;CalendarEventAssignment&gt; getUnPublishedCalendarEvents(TimeRange duration) throws Exception {
<span class="nc" id="L334">		return getCalendarEvents(duration, false);</span>
	}

	/**
	 * Gen Published or Unpublished Calendar events within a time range
	 * @param duration
	 * @return
	 * @throws Exception
	 */
	private Collection&lt;CalendarEventAssignment&gt; getCalendarEvents(TimeRange duration, boolean published) throws Exception {
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc bnc" id="L345" title="All 2 branches missed.">		Collection&lt;PlannedEvent&gt; shifts = published ?</span>
<span class="nc" id="L346">				ValidationUtil.getPublishedEventsForWorkResourceByType(</span>
						Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT |
						Event.EVENT_TYPE_TIME_OFF |
						Event.EVENT_TYPE_UNAVAILABILITY,
<span class="nc" id="L350">						tor.getEmployeeID(),</span>
<span class="nc" id="L351">						duration.getStartDate(), duration.getEndDate())</span>
<span class="nc" id="L352">				: ValidationUtil.getEventsForWorkResourceByType(</span>
						Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT |
						Event.EVENT_TYPE_TIME_OFF |
						Event.EVENT_TYPE_UNAVAILABILITY,
<span class="nc" id="L356">						tor.getEmployeeID(),</span>
<span class="nc" id="L357">						duration.getStartDate(), duration.getEndDate());</span>

<span class="nc" id="L359">		Collection&lt;CalendarEventAssignment&gt; calendarEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc bnc" id="L360" title="All 2 branches missed.">		for (PlannedEvent obj : shifts) {</span>
<span class="nc" id="L361">			int eventType = obj.getEventType();</span>
<span class="nc bnc" id="L362" title="All 6 branches missed.">			if (eventType == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT || eventType == Event.EVENT_TYPE_TIME_OFF</span>
					|| eventType == Event.EVENT_TYPE_UNAVAILABILITY) {
<span class="nc" id="L364">				calendarEvents.add((CalendarEventAssignment) obj);</span>
			}
<span class="nc" id="L366">		}</span>
<span class="nc" id="L367">		return Collections.unmodifiableCollection(calendarEvents);</span>
	}

	@Cacheable
	public Collection&lt;Activity&gt; getActivitiesFromIDs(Collection&lt;ID&gt; activityIDs) throws Exception {
<span class="nc" id="L372">		ActivityManager activityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L373">		return Collections.unmodifiableCollection(activityManager.findActivities(activityIDs));</span>
	}

	@Cacheable
	public Activity getActivityByID(ID activityID) throws Exception {
<span class="nc" id="L378">		ActivityManager activityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L379">		return activityManager.findActivityById(activityID);</span>
	}

	@Override
	public Collection&lt;String&gt; getValidators() throws Exception {
<span class="nc" id="L384">		Collection&lt;String&gt; allConfiguredValidators = new ArrayList&lt;String&gt;();</span>

		//Add all enabled and applicable Time Off validators
<span class="nc" id="L387">		allConfiguredValidators.addAll(filterUnapplicableTimeOffValidators(super.getValidators()));</span>

		//Add all enabled Flex Time validators
<span class="nc" id="L390">		allConfiguredValidators.addAll(getValidators(getOrgID(), Request.REQUESTTYPE_FLEXTIME));</span>

<span class="nc" id="L392">		return allConfiguredValidators;</span>
	}

	/**
	 * Remove any Time Off validator that is not in this following list
	 * &lt;ol&gt;
	 * &lt;li&gt;Time Off Pool has available time off hours&lt;/li&gt;
	 * &lt;li&gt;Request avoids blackout days for the Time Off&lt;/li&gt;
	 * &lt;li&gt;Employee has enough time off hours&lt;/li&gt;
	 * &lt;li&gt;Requested time off is not being swapped.&lt;/li&gt;
	 * &lt;li&gt;Requested time off is for a past date.&lt;/li&gt;
	 * &lt;li&gt;Minimum duration of request with a net staffing&lt;/li&gt;
	 * &lt;/ol&gt;
	 *
	 * @param timeOffValidatorsOnFlexActivity
	 * @param flexValidators
	 * @return
	 */
	protected Collection&lt;String&gt; filterUnapplicableTimeOffValidators(
			Collection&lt;String&gt; timeOffValidatorsOnFlexActivity) {

<span class="nc" id="L413">		Collection&lt;String&gt; applicableTimeOffValidatorsOnFlexRequest = getApplicableTimeOffValidatorsOnFlexRequest();</span>
<span class="nc" id="L414">		Collection&lt;String&gt; filteredValidators = new ArrayList&lt;String&gt;(timeOffValidatorsOnFlexActivity);</span>
<span class="nc" id="L415">		filteredValidators.retainAll(applicableTimeOffValidatorsOnFlexRequest);</span>

<span class="nc" id="L417">		return filteredValidators;</span>
	}

	protected Collection&lt;String&gt; getApplicableTimeOffValidatorsOnFlexRequest() {
<span class="nc" id="L421">		return Arrays.asList(</span>
				// Validator: Time Off Pool has available time off hours.
<span class="nc" id="L423">				AvaliableHoursValidationRule.class.getName(),</span>
				// Validator: Request avoids blackout days for the Time Off
				// Pool.
<span class="nc" id="L426">				AvoidBlackoutsValidationRule.class.getName(),</span>
				// Validator: Employee has enough time off hours.
<span class="nc" id="L428">				EmployeeHoursValidationRule.class.getName(),</span>
				// Validator: Requested time off is not being swapped.
<span class="nc" id="L430">				TimeOffNotBeingSwappedValidationRule.class.getName(),</span>
				// Validator: Requested time off is for a past date.
<span class="nc" id="L432">				RequestInPastValidationRule.class.getName());</span>
	}

	public CustShiftReq createCustShiftReqFromMakeup(FlexRequestMakeup makeup, TORequest toReq) throws Exception {

		// Create an equivalent CustShiftReq from FlexRequestMakeup to re-use logic from CustShiftReqMgrEJB
<span class="nc" id="L438">		CustShiftReq custShiftReq = new CustShiftReq(CustShiftReq.getDetailLevelForValidation());</span>
<span class="nc" id="L439">		Calendar cal = Calendar.getInstance(getOrg().getTimeZone());</span>
<span class="nc" id="L440">		boolean useAdjustedShiftStartTime = false;</span>
		
		// Adjust Shift Start Time if time off selected is before the shift and
		// Extension is after the shift.
<span class="nc" id="L444">		List &lt;TOChoice&gt; toChoices = toReq.getRequestChoiceList();</span>
<span class="nc" id="L445">		TOChoice toChoice = (TOChoice)toChoices.iterator().next();</span>
<span class="nc bnc" id="L446" title="All 2 branches missed.">		if (makeup.getShiftStartTime().equals(toChoice.getStartDate()) &amp;&amp; </span>
<span class="nc bnc" id="L447" title="All 2 branches missed.">				makeup.getExtAfterActivityID() != null &amp;&amp;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">				makeup.getExtBeforeActivityID() == null) {</span>
<span class="nc" id="L449">			TimeRange range = new TimeRange(toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc" id="L450">			cal.setTime(makeup.getShiftStartTime());</span>
<span class="nc" id="L451">			cal.add(Calendar.MINUTE, Long.valueOf(range.getDurationMin()).intValue());</span>
<span class="nc" id="L452">			useAdjustedShiftStartTime = true;</span>
		}
		
		// SPID
		// STARTTIME
		// ENDTIME
		// ISOT = 0
		// SUBTYPE = 4
		// SHIFTSTARTTIME
		// SHIFTENDTIME
		// SHIFTASSIGNMENTID
<span class="nc" id="L463">		custShiftReq.setSPID(makeup.getSPID());</span>
<span class="nc" id="L464">		custShiftReq.setStartTime(makeup.getStartTime());</span>
<span class="nc" id="L465">		custShiftReq.setEndTime(makeup.getEndTime());</span>
<span class="nc" id="L466">		custShiftReq.setIsOT(false);</span>
<span class="nc" id="L467">		custShiftReq.setSubType(CustShiftReq.REQUEST_SUB_TYPE_REG_SHIFT_CHANGE.toInt());</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">		custShiftReq.setShiftStartTime(useAdjustedShiftStartTime ? cal.getTime() : makeup.getShiftStartTime());</span>
<span class="nc" id="L469">		custShiftReq.setShiftEndTime(makeup.getShiftEndTime());</span>
<span class="nc" id="L470">		custShiftReq.setShiftAssignmentID(makeup.getShiftAssignmentID());</span>

		// EXTBEFOREID
		// EXTBEFOREACTIVITYID
		// EXTBEFOREISOT = 0
		// EXTBEFOREGAP
		// EXTBEFOREDURATION
<span class="nc" id="L477">		custShiftReq.setExtBeforeID(null);</span>
<span class="nc" id="L478">		custShiftReq.setExtBeforeActivityID(makeup.getExtBeforeActivityID());</span>
<span class="nc" id="L479">		custShiftReq.setExtBeforeIsOT(false);</span>
<span class="nc" id="L480">		custShiftReq.setExtBeforeGap(makeup.getExtBeforeGap());</span>
<span class="nc" id="L481">		custShiftReq.setExtBeforeDuration(makeup.getExtBeforeDuration());</span>

		// EXTAFTERID
		// EXTAFTERACTIVITYID
		// EXTAFTERISOT = 0
		// EXTAFTERGAP
		// EXTAFTERDURATION
<span class="nc" id="L488">		custShiftReq.setExtAfterID(null);</span>
<span class="nc" id="L489">		custShiftReq.setExtAfterActivityID(makeup.getExtAfterActivityID());</span>
<span class="nc" id="L490">		custShiftReq.setExtAfterIsOT(false);</span>
<span class="nc" id="L491">		custShiftReq.setExtAfterGap(makeup.getExtAfterGap());</span>
<span class="nc" id="L492">		custShiftReq.setExtAfterDuration(makeup.getExtAfterDuration());</span>

		//Add gaps if they exist
<span class="nc" id="L495">		Collection&lt;FlexReqMakeupGap&gt; fGaps = makeup.getFlexReqMakeupGaps();</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">		if (fGaps!=null &amp;&amp; !fGaps.isEmpty()) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">			for(FlexReqMakeupGap fg: fGaps) {</span>
<span class="nc" id="L498">				CustShiftReqGap cg = new CustShiftReqGap();</span>
<span class="nc" id="L499">				cg.setExtGapActivityID(fg.getExtGapActivityID());</span>
<span class="nc" id="L500">				cg.setExtGapDuration(fg.getExtGapDuration());</span>
<span class="nc" id="L501">				cg.setExtGapStartTime(fg.getExtGapStartTime());</span>
<span class="nc" id="L502">				cg.setExtGapEndTime(fg.getExtGapEndTime());</span>
<span class="nc" id="L503">				cg.setExtGapGap(fg.getExtGapGap());</span>
<span class="nc" id="L504">				custShiftReq.createChildObject(CustShiftReqFieldInfo.CUSTREQGAP_CHILD_TYPE, cg);</span>
<span class="nc" id="L505">			}</span>
		}

<span class="nc" id="L508">		custShiftReq.setAggregatedRequest(toReq.getAggregatedRequest());</span>
<span class="nc" id="L509">		return custShiftReq;</span>
	}

	public Collection&lt;TORequest&gt; getApprovedFlexRequests(ID employeeID, TimeRange timeOffRange) throws Exception {
<span class="nc" id="L513">		Collection&lt;TORequest&gt; results = new ArrayList&lt;TORequest&gt;();</span>
<span class="nc" id="L514">		FlexTimeRequestManager mgr = RequestUtil.getFlexTimeRequestMgr(null, null);</span>
		// last boolean parameter represent if we want to pull the records with the timeOffRange included or excluded
<span class="nc" id="L516">		Collection&lt;ID&gt; requestIDs = mgr.getApprovedFlexRequestIDs(employeeID, timeOffRange, true);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">		if (!requestIDs.isEmpty()) {</span>
<span class="nc" id="L518">			Collection&lt;RequestAggregate&gt; requests = mgr.getRequestsByIDs(requestIDs, TORequest.DL_BASIC | TORequest.DL_TIMEOFF_FLEXMAKEUP);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			for (RequestAggregate request : requests) {</span>
<span class="nc" id="L520">				results.add((TORequest) request);</span>
<span class="nc" id="L521">			}</span>
		}
<span class="nc" id="L523">		return results;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>