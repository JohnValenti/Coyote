<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleViewMH.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.fs.schedule</a> &gt; <span class="el_source">ScheduleViewMH.java</span></div><h1>ScheduleViewMH.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.fs.schedule;

import java.rmi.RemoteException;
import java.util.*;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDStringPair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.FacadeException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignHOO;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignOrg;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.EmpPoolingRule;
import com.bluepumpkin.ejb.bbm.people.ejb.PeopleFacade;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.SortEvents;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.core.profile.model.UserProfile;
import com.bluepumpkin.ejb.facade.FacadeManagerFactory;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.ShiftSwapPostingManager;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.web.bbm.activity.ActivityModelHandler;
import com.bluepumpkin.web.bbm.campaign.CampaignModelHandler;
import com.bluepumpkin.web.bbm.employee.EmployeeModelHandler;
import com.bluepumpkin.web.bbm.organization.OrganizationModelHandler;
import com.bluepumpkin.web.bbm.people.PeopleMH;
import com.bluepumpkin.web.bbm.workresource.WorkResourceModelHandler;
import com.bluepumpkin.web.core.base.ModelHandler;
import com.bluepumpkin.web.core.user.profile.UserProfileManager;
import com.bluepumpkin.web.fs.Log;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.bluepumpkin.web.fs.schedule.group.GroupSchedulePM;
import com.bluepumpkin.web.fs.schedule.summary.DailyScheduleSummary;
import com.bluepumpkin.web.fs.user.preferences.UserPrefSchedPC;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;
import com.witness.web.uif.keys.UserPreferenceKeys;
import com.witness.web.uif.l10n.UIFWebBundleKey;
import com.witness.web.uif.system.RequestContext;

/**
 * Title: ScheduleViewMH Description: Handle EJB interaction for Schedule Views
 * data Copyright: Copyright (c) 2002 Company: Blue Pumpkin Software, Inc
 * Created on August 21, 2002, 4:21 PM
 * 
 * @author Pavel Bosin
 * @version 1.0
 */
<span class="nc" id="L85">public class ScheduleViewMH extends ModelHandler {</span>
<span class="nc" id="L86">	private static Category log = Log.initCategory(ScheduleViewMH.class.getName());</span>

	// keys for the hash map of page data objects
	public static final String VIEW_TYPE_KEY = &quot;VIEW_TYPE_KEY&quot;;
	public static final String USER_ORG_ID_KEY = &quot;USER_ORG_ID_KEY&quot;;
	public static final String SCHEDULE_ITEMS_KEY = &quot;SCHEDULE_ITEMS_KEY&quot;;
	public static final String DAY_SUMMARIES_KEY = &quot;DAY_SUMMARIES_KEY&quot;;
	public static final String SCHEDULE_SHIFTS_KEY = &quot;SCHEDULE_SHIFTS_KEY&quot;;
	public static final String LEGEND_ITEMS_KEY = &quot;LEGEND_ITEMS_KEY&quot;;
	public static final String PUB_PERIODS_KEY = &quot;PUB_PERIODS_KEY&quot;;
	public static final String EMPLOYEE_ALLIDS_KEY = &quot;EMPLOYEE_ALLIDS_KEY&quot;;
	public static final String EMPLOYEE_IDS_KEY = &quot;EMPLOYEE_IDS_KEY&quot;;
	public static final String EMPLOYEE_NAMES_KEY = &quot;EMPLOYEE_NAMES_KEY&quot;;
	public static final String CAMPAIGN_NAMES_BY_SP_ID_KEY = &quot;CAMPAIGN_NAMES_BY_SP_ID_KEY&quot;;
	public static final String HOLIDAYS_KEY = &quot;HOLIDAYS_KEY&quot;;
	public static final String HOOS_KEY = &quot;HOOS_KEY&quot;;
	public static final String ORGS_KEY = &quot;ORGS_KEY&quot;;
	public static final String CAMPAIGN_KEY = &quot;CAMPAIGN_KEY&quot;;
	public static final String SWAP_FLAG_KEY = &quot;SWAP_FLAG_KEY&quot;;
	public static final String SWAP_BOARD_KEY = &quot;SWAP_BOARD_KEY&quot;;
	public static final String SWAP_REQUESTS_KEY = &quot;SWAP_REQUESTS_KEY&quot;;
	public static final String ACTIVITIES_KEY = &quot;ACTIVITIES_KEY&quot;;
	public static final String ACTIVITY_MEDIAS_KEY = &quot;ACTIVITY_MEDIAS_KEY&quot;;
	public static final String ACTIVITY_QUEUES_KEY = &quot;ACTIVITY_QUEUES_KEY&quot;;
	public static final String SHOW_UNAVAILABLE_KEY = &quot;SHOW_UNAVAILABLE_KEY&quot;;
	public static final String SHOW_MY_SCHEDULE_NOTE_KEY = &quot;SHOW_MY_SCHEDULE_NOTE_KEY&quot;;
	public static final String SHOW_ORG_SCHEDULE_NOTE_KEY = &quot;SHOW_ORG_SCHEDULE_NOTE_KEY&quot;;
	public static final String SELECTED_ORG_ID_KEY = &quot;SELECTED_ORG_ID_KEY&quot;;
	public static final String SELECTED_CAMPAIGN_ID_KEY = &quot;SELECTED_CAMPAIGN_ID_KEY&quot;;
	public static final String PAGE_MESSAGE = &quot;PAGE_MESSAGE&quot;;
	public static final String GROUPVIEW_FLAG_KEY = &quot;GROUPVIEW_FLAG_KEY&quot;;
	public static final String GROUPVIEW_LIMIT_KEY = &quot;GROUPVIEW_LIMIT_KEY&quot;;
	public static final String SHOW_TIMEOFF_KEY = &quot;SHOW_TIMEOFF_KEY&quot;;

	// These constants are used to identify which warning message to show on the
	// page
	public static final String GROUPVIEW_LIMIT_OK = &quot;OK&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_1 = &quot;NOPRIV_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOORG_1 = &quot;NOORG_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOLINK_1 = &quot;NOLINK_1&quot;;
	public static final String GROUPVIEW_LIMIT_NOLINK_2 = &quot;NOLINK_2&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_2 = &quot;NOPRIV_2&quot;;
	public static final String GROUPVIEW_LIMIT_NOPRIV_3 = &quot;NOPRIV_3&quot;;
	public static final String GROUPVIEW_LIMIT_NOORG_2 = &quot;NOORG_2&quot;;
	public static final String GROUPVIEW_LIMIT_SOMEORG = &quot;SOMEORG&quot;;

	public static final int EMP_SORT_NOT_BY_NAME = -1;

	//////////////////////////////////////////////////////////////////////////////
	// Personal View
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns all the data for the Personal Schedule pages
	 * 
	 * @param employeeID
	 *            - The ID of the single employee who's schedule will be viewed
	 * @param myEmpID
	 *            - The ID of the currently logged-in user
	 */
	public static Map&lt;String, Object&gt; getPersonalData(RequestContext context, String viewType,
			TimeRange theTimeRange, ID employeeID, ID myEmpID)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L148">		boolean showNetStaffing = getShowNetStaffing(context);</span>
<span class="nc" id="L149">		return getPersonalData(context, viewType, theTimeRange, employeeID, myEmpID, showNetStaffing);</span>
	}

	/**
	 * Returns all the data for the Personal Schedule pages
	 * 
	 * @param employeeID
	 *            - The ID of the single employee who's schedule will be viewed
	 * @param myEmpID
	 *            - The ID of the currently logged-in user
	 * @param showNetStaffing
	 *            The boolean flag whether to show Net Staffing for this user. This is now being injected
	 *            because the REST APIs want this data even without the web UI's user preference setting.
	 */
	public static Map&lt;String, Object&gt; getPersonalData(RequestContext context, String viewType,
			TimeRange theTimeRange, ID employeeID, ID myEmpID, boolean showNetStaffing)
					throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L166">		log.debug(&quot;ENTER MH.getPersonalData; viewType ='&quot; + viewType);</span>

<span class="nc" id="L168">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;&gt;();</span>
<span class="nc" id="L169">		theData.put(VIEW_TYPE_KEY, viewType);</span>

<span class="nc" id="L171">		putUserOrgID(context, theData);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L173">			theTimeRange = getTimeRange(context, theData);</span>
		}

<span class="nc" id="L176">		putOrgData(context, theData, theTimeRange, employeeID);</span>
<span class="nc" id="L177">		putPersonalScheduleData(context, theData, theTimeRange, employeeID, showNetStaffing);</span>
<span class="nc" id="L178">		putActivities(context, theData, showNetStaffing);</span>
<span class="nc" id="L179">		putSwapData(context, theData);</span>
<span class="nc" id="L180">		putShowUnavailabilities(context, theData);</span>
<span class="nc" id="L181">		putShowTimeoff(context, theData);</span>

<span class="nc bnc" id="L183" title="All 2 branches missed.">		if (!viewType.equals(ScheduleViewPM.VIEW_TYPE_MY_TEXT)) {</span>
			//uses activities, which are fetched above
<span class="nc" id="L185">			Collection&lt;ID&gt; employeeIDs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L186">			employeeIDs.add(employeeID);</span>
<span class="nc" id="L187">			boolean hasSecuredTimeOffEvents = hasSecuredTimeOffEvents(context,employeeIDs,myEmpID);</span>
<span class="nc" id="L188">			putLegendData(context, theData, myEmpID, hasSecuredTimeOffEvents);</span>
		}

<span class="nc" id="L191">		log.debug(&quot;EXIT MH.getPersonalData&quot;);</span>
<span class="nc" id="L192">		return theData;</span>
	}// getPersonalData

	/**
	 * get schedule data for personal views
	 * 
	 * @param showNetStaffing
	 *            The boolean flag whether to show Net Staffing for this user. This is now being injected
	 *            because the REST APIs want this data even without the web UI's user preference setting.
	 */
	public static void putPersonalScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, ID employeeID, boolean showNetStaffing) throws RemoteException, BbmException {
<span class="nc" id="L204">		Collection&lt;SimpleEvent&gt; scheduleData = null;</span>
<span class="nc" id="L205">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		// --- load published periods for the employee, from, to
<span class="nc" id="L208">		ArrayList&lt;ID&gt; eIDs = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L209">		eIDs.add(employeeID);</span>

<span class="nc" id="L211">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = new ArrayList&lt;Collection&lt;TimeRange&gt;&gt;(1);</span>
<span class="nc" id="L212">		Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps = schedAccessManager.getPublishedPeriods(eIDs,</span>
<span class="nc" id="L213">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L214">		ppTimeRanges.add(getTimeRangesForPublishedPeriods(pubPeriodsForEmps, theData, theTimeRange, eIDs));</span>

		// --- get schedule events
<span class="nc" id="L217">		Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = new ArrayList&lt;Collection&lt;? extends Event&gt;&gt;(1);</span>
<span class="nc" id="L218">		Collection&lt;? extends Event&gt; scheduleEvents = getPersonalScheduleEvents(schedAccessManager, employeeID,</span>
				theTimeRange);
<span class="nc" id="L220">		groupSchedule.add(scheduleEvents);</span>

<span class="nc" id="L222">		Collection&lt;HOOAssignment&gt; hOOAssignments = new ArrayList&lt;HOOAssignment&gt;(1);</span>
<span class="nc" id="L223">		hOOAssignments.add((HOOAssignment) theData.get(HOOS_KEY));</span>

<span class="nc" id="L225">		Map&lt;ID, ID&gt; employeeOrgMap = OrganizationModelHandler.getEmployeeOrgMap(context, eIDs,</span>
<span class="nc" id="L226">				theTimeRange.getStartDate());</span>

<span class="nc" id="L228">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps,</span>
				eIDs, employeeOrgMap, showNetStaffing);

		// --- flatten the events on the time line
<span class="nc" id="L232">		Collection&lt;ShiftAssignment&gt; scheduleShifts = selectOnlyShiftAssignments(scheduleEvents);</span>
<span class="nc" id="L233">		theData.put(SCHEDULE_SHIFTS_KEY, scheduleShifts);</span>
<span class="nc" id="L234">		scheduleData = flattenSchedule(scheduleEvents);</span>

<span class="nc" id="L236">		putCampaignNamesBySpId(context, theData, scheduleShifts);</span>

		// --- mark events covered by shift extensions as overtime
<span class="nc" id="L239">		Collection&lt;SimpleEvent&gt; markedSchedule = markOvertimeEvents(scheduleData, scheduleShifts);</span>

<span class="nc" id="L241">		theData.put(SCHEDULE_ITEMS_KEY, markedSchedule);</span>

<span class="nc" id="L243">		debugLogCollection(&quot;getPersonalScheduleData&quot;, &quot;flattend ScheduleData&quot;, scheduleData);</span>
<span class="nc" id="L244">	}// getPersonalScheduleData</span>

	/**
	 * get collection of schedule events for the current user for the given time
	 * range
	 */
	public static Collection&lt;? extends Event&gt; getPersonalScheduleEvents(ScheduleAccessManager scheduleAccessManager,
			ID employeeID, TimeRange theTimeRange) throws RemoteException, BbmException {

		// --- load and put on time line schedule events for the employee, from,
		// to
		// mask out the imported events, since they are also considered
		// published
<span class="nc" id="L257">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;

<span class="nc" id="L260">		return getPersonalScheduleEvents(scheduleAccessManager, employeeID, theTimeRange, eventTypeMask);</span>
	}// getPersonalScheduleEvents

	/**
	 * get collection of schedule events for the current user for the given time
	 * range
	 */
	public static Collection&lt;? extends Event&gt; getPersonalScheduleEvents(ScheduleAccessManager scheduleAccessManager,
			ID employeeID, TimeRange theTimeRange, int eventTypeMask) throws RemoteException, BbmException {

		// --- load and put on time line schedule events for the employee, from,
		// to
<span class="nc" id="L272">		Collection&lt;? extends Event&gt; scheduleEvents = scheduleAccessManager.getPublishedEventsForWorkResourceByType(</span>
<span class="nc" id="L273">				eventTypeMask, employeeID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>

<span class="nc bnc" id="L275" title="All 2 branches missed.">		if (scheduleEvents != null) {</span>
<span class="nc" id="L276">			log.debug(&quot; MH.getPersonalScheduleEvents: result size=&quot; + scheduleEvents.size());</span>
		}
		else {
<span class="nc" id="L279">			log.debug(&quot; MH.getPersonalScheduleEvents: result is null&quot;);</span>
		}

<span class="nc" id="L282">		return scheduleEvents;</span>
	}// getPersonalScheduleEvents

	/**
	 * returns display name af an employee
	 */
	public static String getEmployeeDisplayName(RequestContext context, ID employeeId, Localizer localizer)
			throws RemoteException, BbmException {
<span class="nc bnc" id="L290" title="All 2 branches missed.">		if (employeeId == null) {</span>
<span class="nc" id="L291">			return &quot;&quot;;</span>
		}
<span class="nc" id="L293">		String result = &quot;&quot;;</span>
<span class="nc" id="L294">		EmployeeName eName = EmployeeModelHandler.getEmployeeNameByID(context, employeeId);</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		if (eName != null) {</span>
<span class="nc" id="L296">			result = localizer.formatFullName(eName);</span>
		}
<span class="nc" id="L298">		return result;</span>
	}// getEmployeeDisplayName

	//////////////////////////////////////////////////////////////////////////////
	// Group View
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Returns all the data for the Group Schedule pages if the IDs are known
	 * usually it works when pagination controls are used.
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; employeeIDs, boolean isSwapDataUsed)
					throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L311">		log.debug(&quot;ENTER MH.getGroupData; viewType ='&quot; + viewType);</span>
<span class="nc" id="L312">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L313">		putUserOrgID(context, theData);</span>
<span class="nc bnc" id="L314" title="All 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L315">			theTimeRange = getTimeRange(context, theData); // needs userOrgID</span>
		}
<span class="nc" id="L317">		log.debug(&quot; MH: theTimeRange =&quot; + theTimeRange.getStartDate() + &quot; - &quot; + theTimeRange.getEndDate());</span>

<span class="nc" id="L319">		theData.put(EMPLOYEE_IDS_KEY, employeeIDs);</span>
<span class="nc" id="L320">		theData.put(SELECTED_ORG_ID_KEY, orgID);</span>
<span class="nc" id="L321">		theData.put(SELECTED_CAMPAIGN_ID_KEY, campaignID);</span>
<span class="nc" id="L322">		putGroupData(context, viewType, theTimeRange, theDayRange, theData, isSwapDataUsed);</span>
<span class="nc" id="L323">		log.debug(&quot;EXIT MH.getGroupData&quot;);</span>
<span class="nc" id="L324">		return theData;</span>
	}// getGroupData

	/**
	 * Returns all the data for the Group Schedule pages if IDs are not known;
	 * get first page //QC79134
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; empIDs, int pageSize, String sortBy,
			boolean isSwapDataUsed) throws RemoteException, BbmException, FacadeException, RmHardValidationException {
<span class="nc" id="L334">		return getGroupData(context, viewType, theTimeRange, theDayRange, orgID, campaignID, empIDs, pageSize, sortBy,</span>
				isSwapDataUsed, theDayRange);
	}

	/**
	 * Returns all the data for the Group Schedule pages if IDs are not known;
	 * get first page //QC79134 added oDayRange as original time range
	 */
	public static HashMap&lt;String, Object&gt; getGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, ID orgID, ID campaignID, Collection&lt;ID&gt; empIDs, int pageSize, String sortBy,
			boolean isSwapDataUsed, TimeRange oDayRange)

	throws RemoteException, BbmException, FacadeException, RmHardValidationException {
<span class="nc" id="L347">		log.debug(&quot;ENTER MH.getGroupData; viewType ='&quot; + viewType);</span>

<span class="nc" id="L349">		HashMap&lt;String, Object&gt; theData = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L350">		ID userOrgID = putUserOrgID(context, theData);</span>
<span class="nc" id="L351">		theData.put(SELECTED_ORG_ID_KEY, orgID);</span>
<span class="nc" id="L352">		theData.put(SELECTED_CAMPAIGN_ID_KEY, campaignID);</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (userOrgID == null) {</span>
<span class="nc" id="L355">			return null;</span>
		}

<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (theTimeRange == null) {</span>
<span class="nc" id="L359">			theTimeRange = getTimeRange(context, theData); // uses userOrgID</span>
															// from theData
		}
<span class="nc" id="L362">		log.debug(&quot; MH: theTimeRange =&quot; + theTimeRange.getStartDate() + &quot; - &quot; + theTimeRange.getEndDate());</span>

		// Fetch Employee IDs based on orgID/campID if not being passed
<span class="nc" id="L365">		int sortField = makeFilterSortField(sortBy);</span>
<span class="nc bnc" id="L366" title="All 4 branches missed.">		boolean isEmpIDsProvided = (empIDs != null &amp;&amp; !empIDs.isEmpty());</span>
<span class="nc" id="L367">		Collection&lt;ID&gt; employeeIDs = Collections.emptyList();</span>

<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (isEmpIDsProvided) {</span>
<span class="nc" id="L370">			employeeIDs = empIDs; // manager already filtered ids for us. But</span>
									// not sorted yet.
		} else {
			// get ids for agent. If sortField is name, then they're sorted
			// here. Otherwise, sorted later.
<span class="nc" id="L375">			employeeIDs = getEmployeeIDs(context, theData, theTimeRange, theDayRange, orgID, campaignID, userOrgID,</span>
					sortField);
		}

		// Perform Sorting
<span class="nc bnc" id="L380" title="All 2 branches missed.">		if (sortField == EMP_SORT_NOT_BY_NAME) {</span>
			// sort agent or manager view ids by schedule
			// Use Date Range for Sorting if available so Text and Graph sorting
			// works
<span class="nc bnc" id="L384" title="All 2 branches missed.">			oDayRange = oDayRange == null ? theDayRange : oDayRange;// QC79134</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">			TimeRange tr = oDayRange == null ? theTimeRange : oDayRange;// QC79134</span>
<span class="nc" id="L386">			employeeIDs = sortEmpIDsPubEvents(context, employeeIDs, sortBy, tr);</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">		} else if (isEmpIDsProvided) {</span>
<span class="nc" id="L388">			ID userID = context.getUser().getID();</span>
<span class="nc" id="L389">			employeeIDs = sortEmpIDsByName(context, userID, employeeIDs, sortField);</span>
		}

		// At this point, employeeIDs are completely sorted
<span class="nc" id="L393">		theData.put(EMPLOYEE_ALLIDS_KEY, employeeIDs);</span>
		// Tample changed for QA 86309
<span class="nc bnc" id="L395" title="All 2 branches missed.">		theData.put(EMPLOYEE_IDS_KEY, ScheduleViewUtil.getTopCollectionPage(employeeIDs,</span>
<span class="nc" id="L396">				Math.min(pageSize &lt; 0 ? employeeIDs.size() : pageSize, employeeIDs.size())));</span>

		// Retrieve Group Data
<span class="nc" id="L399">		putGroupData(context, viewType, theTimeRange, theDayRange, theData, isSwapDataUsed);</span>

<span class="nc" id="L401">		log.debug(&quot;EXIT MH.getGroupData&quot;);</span>
<span class="nc" id="L402">		return theData;</span>
	}// getGroupData

	/**
	 * populates the HashMap with all the data for the Group Schedule pages
	 */
	private static void putGroupData(RequestContext context, String viewType, TimeRange theTimeRange,
			TimeRange theDayRange, HashMap&lt;String, Object&gt; theData, boolean isSwapDataUsed)
					throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L411">		theData.put(VIEW_TYPE_KEY, viewType);</span>

<span class="nc" id="L413">		Collection&lt;ID&gt; employeeIDs = (Collection&lt;ID&gt;) theData.get(EMPLOYEE_IDS_KEY);</span>
<span class="nc" id="L414">		putEmployeeNames(context, theData, employeeIDs);</span>

<span class="nc" id="L416">		ID employeeID = context.getUser().getEmployeeID();</span>
<span class="nc" id="L417">		putOrgData(context, theData, theTimeRange, employeeID);</span>
<span class="nc" id="L418">		putCampaignData(context, theData);</span>

<span class="nc bnc" id="L420" title="All 2 branches missed.">		if (viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_MULTI)) {</span>
<span class="nc" id="L421">			putGroupMultidayScheduleData(context, theData, theTimeRange, employeeIDs);</span>
		} else {
<span class="nc" id="L423">			Map&lt;ID, ID&gt; employeeOrgMap = OrganizationModelHandler.getEmployeeOrgMap(context, employeeIDs,</span>
<span class="nc" id="L424">					theDayRange.getStartDate());</span>
<span class="nc" id="L425">			putGroupScheduleData(context, theData, theTimeRange, theDayRange, employeeIDs, employeeOrgMap);</span>
		}

<span class="nc" id="L428">		putActivities(context, theData);</span>

<span class="nc bnc" id="L430" title="All 2 branches missed.">		if (isSwapDataUsed)</span>
<span class="nc" id="L431">			putSwapData(context, theData);</span>

<span class="nc" id="L433">		putShowUnavailabilities(context, theData);</span>
<span class="nc" id="L434">		putShowTimeoff(context, theData);</span>

<span class="nc bnc" id="L436" title="All 2 branches missed.">		if (viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_GRAPH)</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">				|| viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_PRINT)) {</span>
			//uses activities, which are fetched above
<span class="nc" id="L439">			boolean hasSecuredTimeOffEvents = hasSecuredTimeOffEvents(context,employeeIDs,employeeID);</span>
<span class="nc" id="L440">			putLegendData(context, theData, employeeID, hasSecuredTimeOffEvents);</span>
		}
<span class="nc" id="L442">	}</span>

	/**
	 * Get the first non-null orgID in the collection of DailyScheduleSummary's
	 * which intersects the specified day's range.
	 */
	public static ID getOrgID(Collection&lt;DailyScheduleSummary&gt; daySummaries, CalendarRange aDay) {
<span class="nc" id="L449">		TimeRange tr = new TimeRange(aDay.getStartDate(), aDay.getEndDate());</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (daySummaries != null) {</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">			for (Iterator&lt;DailyScheduleSummary&gt; it = daySummaries.iterator(); it.hasNext();) {</span>
<span class="nc" id="L453">				DailyScheduleSummary oneDaySchedule = it.next();</span>
<span class="nc bnc" id="L454" title="All 4 branches missed.">				if ((oneDaySchedule.getDayRange().getOverlapDuration(tr) &gt; 0) &amp;&amp; oneDaySchedule.getOrgID() != null) {</span>
<span class="nc" id="L455">					return oneDaySchedule.getOrgID();</span>
				}
<span class="nc" id="L457">			}</span>
		}
<span class="nc" id="L459">		return null;</span>
	}

	/**
	 * This method will extract the scheduling period IDs from the shift
	 * assignments (and their child shift event assignments) and look up the
	 * associated campaign names for these scheduling periods. It will create a
	 * map of SPID -&gt; campaign name and will store this map in theData using the
	 * key CAMPAIGN_NAMES_BY_SP_ID_KEY.
	 * 
	 * @param context
	 *            - the request context.
	 * @param theData
	 *            - The HashMap holding all of the data we could ever need in
	 *            order to show schedules.
	 * @param shiftAssignments
	 *            - The shift assignments contained in the schedule for the
	 *            current view period.
	 */
	public static void putCampaignNamesBySpId(RequestContext context, HashMap&lt;String, Object&gt; theData,
			Collection&lt;ShiftAssignment&gt; shiftAssignments) throws BbmException, RemoteException {
		// Get the Scheduling Period IDs off of the Shift Event Assignments
		// (which are child objects
		// of the shift assignments), if the SP ID of the shift event does not
		// match the SP ID of the
		// corresponding shift.
<span class="nc" id="L485">		HashSet&lt;ID&gt; spIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L486" title="All 4 branches missed.">		if (shiftAssignments != null &amp;&amp; shiftAssignments.isEmpty() == false) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">			for (ShiftAssignment shiftAssignment : shiftAssignments) {</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">				if (shiftAssignment.getCampaignID() != null) {</span>
<span class="nc" id="L489">					spIDs.add(shiftAssignment.getCampaignID());</span>
<span class="nc" id="L490">					Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = shiftAssignment.getChildren();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">					for (ShiftEventAssignment seAssignment : shiftEventAssignments) {</span>
						// It appears as though we are comparing the shift
						// event's SP ID to the shift's campaign ID,
						// however ShiftAssignment.getCampaignID() returns the
						// SP ID, not campaign ID.
<span class="nc bnc" id="L496" title="All 2 branches missed.">						if (seAssignment.getSPID() != null</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">								&amp;&amp; !seAssignment.getSPID().equals(shiftAssignment.getCampaignID())) {</span>
<span class="nc" id="L498">							spIDs.add(seAssignment.getSPID());</span>
						}
<span class="nc" id="L500">					}</span>
				}
<span class="nc" id="L502">			}</span>
		}

<span class="nc" id="L505">		Map&lt;ID, String&gt; retVal = CampaignModelHandler.getCampaignNamesLinkedToSPs(context, spIDs);</span>
<span class="nc" id="L506">		theData.put(CAMPAIGN_NAMES_BY_SP_ID_KEY, retVal);</span>
<span class="nc" id="L507">	}</span>

	/**
	 * get employee IDs and names
	 */
	private static void putEmployeeNames(RequestContext context, HashMap&lt;String, Object&gt; theData,
			Collection&lt;ID&gt; theEmployeeIDs) throws RemoteException, BbmException {
<span class="nc" id="L514">		HashMap&lt;ID, EmployeeName&gt; employeeNames = EmployeeModelHandler.getEmployeeNamesByIDs(context, theEmployeeIDs);</span>
<span class="nc" id="L515">		theData.put(EMPLOYEE_NAMES_KEY, employeeNames);</span>
<span class="nc" id="L516">		debugLogCollection(&quot;getEmployeeNames&quot;, &quot;employeeNames&quot;, employeeNames);</span>
<span class="nc" id="L517">	}// getEmployeeNames</span>

	/**
	 * get campaign data: name and ID and put it into the HashMap theData
	 *
	 * NOTE: theTimeRange is passed for the future needs of campaign data with
	 * effectivity
	 */
	private static void putCampaignData(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="nc" id="L527">		ID campaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>
<span class="nc" id="L528">		String name = &quot;&quot;;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">		if (campaignID != null) {</span>
<span class="nc" id="L530">			Campaign campaign = CampaignModelHandler.getCampaign(context, campaignID);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			if (campaign != null) {</span>
<span class="nc" id="L532">				name = campaign.getName();</span>
			}
		}
<span class="nc" id="L535">		IDStringPair campaignData = new IDStringPair(campaignID, name);</span>
<span class="nc" id="L536">		theData.put(CAMPAIGN_KEY, campaignData);</span>
<span class="nc" id="L537">		log.debug(&quot; MH.getCampaignData: Campaign name = &quot; + name);</span>
<span class="nc" id="L538">	}// getCampaignData</span>

	/**
	 * Return list of orgs allowed for viewing from RM OrganizationSetting for
	 * given orgID
	 */
	public static Collection&lt;ID&gt; getGroupViewOrgIDs(ID orgID) throws RemoteException, BbmException {
<span class="nc" id="L545">		Collection&lt;ID&gt; orgIdCollection = null;</span>

<span class="nc" id="L547">		RmManagerFactory rmManagerFactory = RmManagerFactory.getInstance();</span>
<span class="nc" id="L548">		OrganizationConfigManager orgConfigManager = rmManagerFactory.getOrganizationConfigManager();</span>
<span class="nc" id="L549">		OrganizationSetting orgSetting = orgConfigManager.getConfiguration(orgID);</span>
<span class="nc" id="L550">		String orgList = orgSetting.getGroupViewOrgList();</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">		if (!StringUtil.isEmpty(orgList)) {</span>
<span class="nc" id="L552">			ID ids[] = StringUtil.parseIDString(orgList);</span>
<span class="nc bnc" id="L553" title="All 4 branches missed.">			if (ids != null &amp;&amp; ids.length != 0) {</span>
<span class="nc" id="L554">				orgIdCollection = Arrays.asList(ids);</span>
			}
		}
<span class="nc" id="L557">		return orgIdCollection;</span>
	}// getOrgSetting

	/**
	 * get schedule data for group multiday view - only shifts
	 * 
	 * @param campaignIDs
	 *            - Set of unique campaign IDs that we need to lookup the
	 *            Campaign names for.
	 */
	private static void putGroupMultidayScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, Collection&lt;ID&gt; employeeIDs) throws RemoteException, BbmException {
<span class="nc" id="L569">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		// --- get schedules
<span class="nc" id="L572">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;
<span class="nc" id="L574">		List&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = schedAccessManager.getPublishedEventsForWorkResourcesByType(</span>
<span class="nc" id="L575">				eventTypeMask, employeeIDs, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L576">		debugLogCollection(&quot;getGroupMultidayScheduleData&quot;, &quot;groupSchedule&quot;, groupSchedule);</span>

<span class="nc" id="L578">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = selectGroupShifts(groupSchedule);</span>

		// Gather all shift assignments in the schedule and determine the
		// campaign names associated to
		// the scheduling period IDs of the shift/shift event assignments
<span class="nc bnc" id="L583" title="All 2 branches missed.">		if (groupShifts != null) {</span>
<span class="nc" id="L584">			Collection&lt;ShiftAssignment&gt; allShiftAssignments = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">			for (Collection&lt;ShiftAssignment&gt; shiftAssignments : groupShifts) {</span>
<span class="nc" id="L586">				allShiftAssignments.addAll(shiftAssignments);</span>
<span class="nc" id="L587">			}</span>
<span class="nc" id="L588">			putCampaignNamesBySpId(context, theData, allShiftAssignments);</span>
		}

		// --- get published periods and save to theData
<span class="nc" id="L592">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps = schedAccessManager.getPublishedPeriods(employeeIDs,</span>
<span class="nc" id="L593">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L594">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = getTimeRangesForPublishedPeriodsForGroupView(pubPeriodsForEmps,</span>
				theData, theTimeRange, employeeIDs);

		// ---get org HOO's for each selected employee
<span class="nc" id="L598">		Collection&lt;HOOAssignment&gt; hOOAssignments = getEmployeeHooAssignments(context, theTimeRange, employeeIDs);</span>

<span class="nc" id="L600">		boolean showNetStaffing = getShowNetStaffing(context);</span>
<span class="nc" id="L601">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps,</span>
				employeeIDs, null, showNetStaffing);
<span class="nc" id="L603">	}// getGroupMultidayScheduleData</span>

	/**
	 * get schedule data for group views text/graph/print
	 * 
	 * @param employeeCampAssMap
	 *            - map of employeeIDs - &gt; CampaignWorkResource assignments.
	 * @param campaignIDs
	 *            - Set of unique campaign IDs that we need to lookup the
	 *            Campaign names for.
	 */
	private static void putGroupScheduleData(RequestContext context, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, TimeRange theDayRange, Collection&lt;ID&gt; employeeIDs, Map&lt;ID, ID&gt; employeeOrgMap)
					throws RemoteException, BbmException {
<span class="nc" id="L617">		ScheduleAccessManager schedAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>

		// --- get schedules
<span class="nc" id="L620">		int eventTypeMask = Event.EVENT_TYPE_ALL_CALENDAR_EVENTS | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
				| Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT;
<span class="nc" id="L622">		Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule = schedAccessManager</span>
<span class="nc" id="L623">				.getPublishedEventsForWorkResourcesByType(eventTypeMask, employeeIDs, theDayRange.getStartDate(),</span>
<span class="nc" id="L624">						theDayRange.getEndDate());</span>
<span class="nc" id="L625">		debugLogCollection(&quot;getGroupScheduleData&quot;, &quot;groupSchedule&quot;, groupSchedule);</span>

		// --- save shifts separately
<span class="nc" id="L628">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = selectGroupShifts(groupSchedule);</span>
<span class="nc" id="L629">		theData.put(SCHEDULE_SHIFTS_KEY, groupShifts);</span>

		// --- get published periods and save to theData
<span class="nc" id="L632">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps = schedAccessManager.getPublishedPeriods(employeeIDs,</span>
<span class="nc" id="L633">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L634">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = getTimeRangesForPublishedPeriodsForGroupView(pubPeriodsForEmps,</span>
				theData, theTimeRange, employeeIDs);

		// ---get org HOO's for each selected employee
<span class="nc" id="L638">		Collection&lt;HOOAssignment&gt; hOOAssignments = getEmployeeHooAssignments(context, theTimeRange, employeeIDs);</span>

<span class="nc" id="L640">		boolean showNetStaffing = getShowNetStaffing(context);</span>
<span class="nc" id="L641">		putDaySummaries(context, theData, theTimeRange, groupSchedule, ppTimeRanges, hOOAssignments, pubPeriodsForEmps,</span>
				employeeIDs, employeeOrgMap, showNetStaffing);

		// --- flatten schedules
<span class="nc" id="L645">		Collection&lt;Collection&lt;SimpleEvent&gt;&gt; flattenedSchedule = flattenGroupSchedule(groupSchedule);</span>

		// Gather all shift assignments in the schedule and determine the
		// campaign names associated to
		// the scheduling period IDs of the shift/shift event assignments
<span class="nc bnc" id="L650" title="All 2 branches missed.">		if (groupShifts != null) {</span>
<span class="nc" id="L651">			Collection&lt;ShiftAssignment&gt; allShiftAssignments = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">			for (Collection&lt;ShiftAssignment&gt; shiftAssignments : groupShifts) {</span>
<span class="nc" id="L653">				allShiftAssignments.addAll(shiftAssignments);</span>
<span class="nc" id="L654">			}</span>
<span class="nc" id="L655">			putCampaignNamesBySpId(context, theData, allShiftAssignments);</span>
		}

		// --- mark events as overlap if they are covered by shift extensions
<span class="nc" id="L659">		Collection&lt;Collection&lt;SimpleEvent&gt;&gt; markedSchedule = markGroupOvertimeEvents(flattenedSchedule, groupShifts);</span>

<span class="nc" id="L661">		theData.put(SCHEDULE_ITEMS_KEY, markedSchedule);</span>
<span class="nc" id="L662">	}// getGroupScheduleData</span>

	/**
	 * Creates a collection containing collections of DailyScheduleSummary
	 * objects, each representing an employee's schedule for a day. This
	 * collection is stored in the universal hashmap &quot;theData&quot; which is
	 * eventually handed to the page model. The key for these objects in the map
	 * is DAY_SUMMARIES_KEY.
	 * 
	 * @param context
	 * @param theData
	 * @param theTimeRange
	 * @param groupSchedule
	 * @param groupTimeRanges
	 * @param groupHOOAssignments
	 *            A list which contains one HOOAssignment for each employee
	 * @param employeeIDs
	 *            - collection of employee IDs.
	 * @param employeeCampAssMap
	 *            - map of employeeIDs - &gt; CampaignWorkResource assignments.
	 * @param campaignIDs
	 *            - Set of unique campaign IDs that we need to lookup the
	 *            Campaign names for.
	 * @param showNetStaffing
	 *            The boolean flag whether to show Net Staffing for this user. This is now being injected
	 *            because the REST APIs want this data even without the web UI's user preference setting.
	 * @throws BbmException
	 * @throws RemoteException
	 */
	private static void putDaySummaries(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule, Collection&lt;Collection&lt;TimeRange&gt;&gt; groupTimeRanges,
			Collection&lt;HOOAssignment&gt; groupHOOAssignments, Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; groupPubPeriods,
			Collection&lt;ID&gt; employeeIDs, Map&lt;ID, ID&gt; employeeOrgMap, boolean showNetStaffing) throws RemoteException, BbmException {
		// Activities data is required to build the daily schedule summaries.
<span class="nc" id="L696">		putActivities(context, theData, showNetStaffing);</span>

		// --- get day summaries
<span class="nc" id="L699">		Collection&lt;Collection&lt;DailyScheduleSummary&gt;&gt; daySummaries = ScheduleViewUtil.makeGroupDaySummaries(context,</span>
				theTimeRange, groupSchedule, groupTimeRanges, groupHOOAssignments, groupPubPeriods, employeeIDs,
<span class="nc" id="L701">				employeeOrgMap, (Map&lt;ID, Activity&gt;) theData.get(ACTIVITIES_KEY));</span>
<span class="nc" id="L702">		debugLogCollection(&quot;getGroupMultidayScheduleData&quot;, &quot;daySummaries&quot;, daySummaries);</span>

<span class="nc" id="L704">		theData.put(DAY_SUMMARIES_KEY, daySummaries);</span>
<span class="nc" id="L705">	}</span>

	//////////////////////////////////////////////////////////////////////////////
	// Common Schedule Related Code
	//////////////////////////////////////////////////////////////////////////////

	/**
	 * Determine whether the logged-in user has the
	 * &quot;Use Accessiblity Compliance Mode&quot; preference set to true.
	 * 
	 * @return the &quot;Use Accessiblity Compliance Mode&quot; preference.
	 */
	public static boolean isAccessibilityMode(RequestContext context) {
<span class="nc" id="L718">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L719">		String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_ACCESSIBILITY_COMPLIANCE_MODE, &quot;false&quot;);</span>
<span class="nc" id="L720">		Boolean boolFlag = new Boolean(&quot;true&quot;.equals(strVal));</span>
<span class="nc" id="L721">		return boolFlag.booleanValue();</span>
	}

	/**
	 * Get the boolean flag whether to show unavailabilities for this user and
	 * saveit in the hashmap
	 */
	private static void putShowUnavailabilities(RequestContext context, HashMap&lt;String, Object&gt; theData) {
<span class="nc" id="L729">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L730">		String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_UNAVAILABLE, &quot;false&quot;);</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">		Boolean boolFlag = new Boolean(!&quot;false&quot;.equals(strVal));</span>
<span class="nc" id="L732">		theData.put(SHOW_UNAVAILABLE_KEY, boolFlag);</span>
<span class="nc" id="L733">		log.debug(&quot; MH.getShowUnavailabilities boolFlag=&quot; + boolFlag);</span>
<span class="nc" id="L734">	}// putShowUnavailabilities</span>

	/**
	 * Get the boolean flag whether to show timeoff for this user and save it in
	 * the hashmap
	 */
	private static void putShowTimeoff(RequestContext context, HashMap&lt;String, Object&gt; theData) {
<span class="nc" id="L741">		Boolean boolFlag = new Boolean(false);</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">		if (context.getUser().isAuthorized(PrivilegeKeys.FS_CONFIGURETIMEOFFEVENTSDISPLAY_ID)) {</span>
<span class="nc" id="L743">			UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L744">			String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_TIMEOFF, &quot;false&quot;);</span>
<span class="nc" id="L745">			boolFlag = new Boolean(&quot;true&quot;.equals(strVal));</span>
		}
<span class="nc" id="L747">		theData.put(SHOW_TIMEOFF_KEY, boolFlag);</span>
<span class="nc" id="L748">		log.debug(&quot; MH.getShowTimeoff boolFlag=&quot; + boolFlag);</span>
<span class="nc" id="L749">	}// putShowTimeoff</span>

	/**
	 * Get the boolean flag whether to show Net Staffing for this user.
	 */
	public static boolean getShowNetStaffing(RequestContext context) {
<span class="nc" id="L755">		Boolean boolFlag = new Boolean(false);</span>

<span class="nc bnc" id="L757" title="All 2 branches missed.">		if (context.getUser().isAuthorized(PrivilegeKeys.FS_CONFIGURENETSTAFFINGDISPLAY_ID)) {</span>
<span class="nc" id="L758">			UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L759">			String strVal = userProfile.loadProperty(UserPreferenceKeys.USER_SHOW_NETSTAFFING, &quot;false&quot;);</span>
<span class="nc" id="L760">			boolFlag = new Boolean(&quot;true&quot;.equals(strVal));</span>
		}

<span class="nc" id="L763">		log.debug(&quot; MH.getShowNetStaffing boolFlag=&quot; + boolFlag);</span>
<span class="nc" id="L764">		return boolFlag.booleanValue();</span>
	}

	/**
	 * Get the boolean flag whether to show the half-height or half-height Net
	 * Staffing ribbon for this user.
	 */
	public static boolean getNetStaffingHalfHeight(RequestContext context) {
<span class="nc" id="L772">		return true;</span>
	}

	/**
	 * Get the Net Staffing Surplus color for this user.
	 */
	public static String getNetStaffingSurplusColor(RequestContext context) {
<span class="nc" id="L779">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L780">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_SURPLUS_COLOR,</span>
				UserPrefSchedPC.DEFAULT_NS_SURPLUS_COLOR);
	}

	/**
	 * Get the Net Staffing Shortage color for this user.
	 */
	public static String getNetStaffingShortageColor(RequestContext context) {
<span class="nc" id="L788">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L789">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_SHORTAGE_COLOR,</span>
				UserPrefSchedPC.DEFAULT_NS_SHORTAGE_COLOR);
	}

	/**
	 * Get the Net Staffing Neutral color for this user.
	 */
	public static String getNetStaffingNeutralColor(RequestContext context) {
<span class="nc" id="L797">		UserProfile userProfile = UserProfileManager.getUserProfile(context);</span>
<span class="nc" id="L798">		return userProfile.loadProperty(UserPreferenceKeys.USER_NS_NEUTRAL_COLOR,</span>
				UserPrefSchedPC.DEFAULT_NS_NEUTRAL_COLOR);
	}

	/**
	 * Get the Net Staffing Cell Selection color for this user.
	 */
	public static String getNetStaffingCellSelectionColor(RequestContext context) {
<span class="nc" id="L806">		return &quot;#FFFF00&quot;;</span>
	}

	/**
	 * Get the boolean flag whether to show Net Staffing for this user.
	 * 
	 * @param isManagerPage
	 *            - pass true if the is the manager page (Tracking\Schedules).
	 *            Pass false for the agent page (My Home\My Schedule).
	 */
	public static boolean getCanCreateCustomShiftRequest(RequestContext context, boolean isManagerPage) {
<span class="nc" id="L817">		boolean returnValue = false;</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">		if (isManagerPage) {</span>
<span class="nc" id="L820">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.CS_MODIFYREQUESTSFOREMPLOYEE);</span>
		} else {
<span class="nc" id="L822">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.CS_MODIFYPERSONALREQUESTS);</span>
		}

<span class="nc" id="L825">		log.debug(&quot; getCanCreateCustomShiftRequest boolFlag=&quot; + returnValue);</span>
<span class="nc" id="L826">		return returnValue;</span>
	}

	/**
	 * Determine whether this user has the privilege to create a time off
	 * request.
	 * 
	 * @param isManagerPage
	 *            - pass true if the is the manager page (Tracking\Schedules).
	 *            Pass false for the agent page (My Home\My Schedule).
	 */
	public static boolean getCanCreateTimeOffRequest(RequestContext context, boolean isManagerPage) {
<span class="nc" id="L838">		boolean returnValue = false;</span>

<span class="nc bnc" id="L840" title="All 2 branches missed.">		if (isManagerPage) {</span>
<span class="nc" id="L841">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.TOM_MODIFYREQUESTSFOREMPLOYEE);</span>
		} else {
<span class="nc" id="L843">			returnValue = context.getUser().isAuthorized(PrivilegeKeys.TOM_MODIFYPERSONALREQUESTS);</span>
		}

<span class="nc" id="L846">		log.debug(&quot; getCanCreateTimeOffRequest boolFlag=&quot; + returnValue);</span>
<span class="nc" id="L847">		return returnValue;</span>
	}

	/**
	 * get show My Schedule Notes and save in theData map
	 * 
	 * @param orgID
	 *            - the ID of the org that you are viewing the schedule for.
	 *
	 *            private static void putShowMyScheduleNote(RequestContext
	 *            context, HashMap theData) { boolean canView =
	 *            ScheduleViewUtil.isPrivWithGenScope(context, theData,
	 *            PrivilegeKeys.FS_VIEWPERSONALSCHEDULECOMMENTS,
	 *            SHOW_MY_SCHEDULE_NOTE_KEY);
	 * 
	 *            if (!canView) { //allow user to see his own schedule if he can
	 *            view org schedules for his org
	 *            ScheduleViewUtil.isPrivWithOrgScope(context, theData,
	 *            PrivilegeKeys.FS_VIEWPERSONALSCHEDULECOMMENTS,
	 *            SHOW_MY_SCHEDULE_NOTE_KEY, false); }
	 * 
	 *            log.debug(&quot; MH.getShowMyScheduleNote &quot; +
	 *            theData.get(SHOW_MY_SCHEDULE_NOTE_KEY)); }
	 */

	/**
	 * get show My Schedule Notes and save in theData map
	 * 
	 * @param orgID
	 *            - the ID of the org that you are viewing the schedule for.
	 */
	public static boolean getShowMyScheduleNote(RequestContext context, ID orgID) {
<span class="nc" id="L879">		boolean canView = ScheduleViewUtil.isPrivWithGenScope(context, PrivilegeKeys.FS_VIEWPERSONALSCHEDULECOMMENTS);</span>

<span class="nc bnc" id="L881" title="All 2 branches missed.">		if (!canView) {</span>
			// allow user to see his own schedule if he can view org schedules
			// for his org
<span class="nc" id="L884">			canView = ScheduleViewUtil.isPrivWithOrgScope(context, PrivilegeKeys.FS_VIEWEMPLOYEESCHEDULECOMMENTS, false,</span>
					orgID);
		}

<span class="nc" id="L888">		return canView;</span>
	}

	/**
	 * get show Schedule Notes for the group view and save in theData map
	 * 
	 * @param orgID
	 *            - the ID of the org that you are viewing the schedule for.
	 *
	 *            private static void putShowOrgScheduleNote(RequestContext
	 *            context, HashMap theData) {
	 *            ScheduleViewUtil.isPrivWithOrgScope(context, theData,
	 *            PrivilegeKeys.FS_VIEWEMPLOYEESCHEDULECOMMENTS,
	 *            SHOW_ORG_SCHEDULE_NOTE_KEY, false);
	 * 
	 *            log.debug(&quot; MH.getShowOrgScheduleNote &quot; +
	 *            theData.get(SHOW_ORG_SCHEDULE_NOTE_KEY)); }
	 */

	/**
	 * get show Schedule Notes for the group view and save in theData map
	 * 
	 * @param orgID
	 *            - the ID of the org that you are viewing the schedule for.
	 */
	public static boolean getShowOrgScheduleNote(RequestContext context, ID orgID) {
<span class="nc" id="L914">		return ScheduleViewUtil.isPrivWithOrgScope(context, PrivilegeKeys.FS_VIEWEMPLOYEESCHEDULECOMMENTS, false,</span>
				orgID);
	}

	/**
	 * get swap data for personal schedule views
	 */
	private static void putSwapData(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException, RmHardValidationException {
<span class="nc" id="L923">		ID employeeID = context.getUser().getEmployeeID();</span>

<span class="nc" id="L925">		boolean swapEnabled = ScheduleViewUtil.isPrivWithGenScope(context, theData,</span>
				PrivilegeKeys.SS_READWRITETOSWAPBOARD, SWAP_FLAG_KEY);
<span class="nc" id="L927">		log.debug(&quot; MH.getSwapData swapEnabled = &quot; + swapEnabled);</span>

		// if swap is enabled then get swap board postings for employees with
		// enabled swap flag
<span class="nc bnc" id="L931" title="All 2 branches missed.">		if (swapEnabled) {</span>
<span class="nc" id="L932">			RmManagerFactory factory = RmManagerFactory.getInstance();</span>
<span class="nc" id="L933">			ShiftSwapPostingManager shiftSwapPostingManager = factory.getShiftSwapPostingManager();</span>
<span class="nc" id="L934">			Collection&lt;ShiftSwapPosting&gt; swapPostings = null;</span>
<span class="nc" id="L935">			String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="nc bnc" id="L936" title="All 2 branches missed.">			if (viewType.indexOf(&quot;GROUP&quot;) == -1) { // personal</span>
				// get swap board postings from this employeeID
<span class="nc" id="L938">				swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByEmployee(employeeID,</span>
<span class="nc" id="L939">						ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL, true).getPostings();</span>
			} else { // group
<span class="nc" id="L941">				ID selectedOrgID = (ID) theData.get(SELECTED_ORG_ID_KEY);</span>
<span class="nc" id="L942">				ID selectedCampaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>

				// No Organization or Campaign was selected then use View
				// Organization.
<span class="nc bnc" id="L946" title="All 4 branches missed.">				if (selectedOrgID == null &amp;&amp; selectedCampaignID == null) {</span>
<span class="nc" id="L947">					selectedOrgID = ((IDStringPair) theData.get(ScheduleViewMH.ORGS_KEY)).getID();</span>
				}

<span class="nc bnc" id="L950" title="All 2 branches missed.">				if (selectedOrgID != null) {</span>
<span class="nc" id="L951">					swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByOrg(selectedOrgID,</span>
<span class="nc" id="L952">							ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL).getPostings();</span>
<span class="nc bnc" id="L953" title="All 2 branches missed.">				} else if (selectedCampaignID != null) {</span>
<span class="nc" id="L954">					swapPostings = shiftSwapPostingManager.findShiftSwapPostingsByCampaign(selectedCampaignID,</span>
<span class="nc" id="L955">							ShiftSwapPosting.DL_ALL, SupportNavigation.CHUNKSIZE_ALL).getPostings();</span>
				}
			}
<span class="nc" id="L958">			theData.put(SWAP_BOARD_KEY, swapPostings);</span>
<span class="nc" id="L959">			debugLogCollection(&quot;getSwapData&quot;, &quot;swapPostings&quot;, swapPostings);</span>
		}
<span class="nc" id="L961">	}// getSwapData</span>

	/**
	 * Loads a map of all activities defined in the system (key = activity ID,
	 * value = activity) and stores this map into theData (with the key
	 * ScheduleViewMH.ACTIVITIES_KEY).
	 * 
	 * If theData already contains this map of activities, then this method will
	 * not load any additional data or modify theData.
	 *
	 * We also load the activityMedias and activityQueues if we are viewing the
	 * net staffing ribbon.
	 */
	public static void putActivities(RequestContext context, Map&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="nc" id="L976">		putActivities(context, theData, getShowNetStaffing(context));</span>
<span class="nc" id="L977">	}</span>

	/**
	 * Loads a map of all activities defined in the system (key = activity ID,
	 * value = activity) and stores this map into theData (with the key
	 * ScheduleViewMH.ACTIVITIES_KEY).
	 * 
	 * If theData already contains this map of activities, then this method will
	 * not load any additional data or modify theData.
	 *
	 * We also load the activityMedias and activityQueues if we are viewing the
	 * net staffing ribbon.
	 * 
	 * @param showNetStaffing
	 *            The boolean flag whether to show Net Staffing for this user. This is now being injected
	 *            because the REST APIs want this data even without the web UI's user preference setting.
	 */
	public static void putActivities(RequestContext context, Map&lt;String, Object&gt; theData, boolean showNetStaffing)
			throws RemoteException, BbmException {
<span class="nc bnc" id="L996" title="All 4 branches missed.">		if (!theData.containsKey(ScheduleViewMH.ACTIVITIES_KEY) || theData.get(ScheduleViewMH.ACTIVITIES_KEY) == null</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">				|| ((Map&lt;ID, Activity&gt;) theData.get(ScheduleViewMH.ACTIVITIES_KEY)).isEmpty()) {</span>
<span class="nc" id="L998">			HashMap&lt;ID, Activity&gt; activityMap = ActivityModelHandler.getAllActivitiesMap(context);</span>
<span class="nc" id="L999">			theData.put(ACTIVITIES_KEY, activityMap);</span>
<span class="nc" id="L1000">			debugLogCollection(&quot;getActivities&quot;, &quot;activityMap&quot;, activityMap);</span>

			// only the net staffing ribbons in the graph views need the
			// activityMedias and activityQueues to be loaded
<span class="nc" id="L1004">			String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">			if (viewType != null &amp;&amp; (viewType.equals(ScheduleViewPM.VIEW_TYPE_MY_GRAPH)</span>
<span class="nc bnc" id="L1006" title="All 4 branches missed.">					|| viewType.equals(ScheduleViewPM.VIEW_TYPE_GROUP_GRAPH)) &amp;&amp; showNetStaffing) {</span>
<span class="nc" id="L1007">				ActivityManager activityManager = WfmManagerFactory.getActivityManager(context.isInWhatIfMode());</span>

<span class="nc" id="L1009">				ArrayList&lt;ID&gt; activityIDs = new ArrayList&lt;ID&gt;(activityMap.keySet().size());</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">				for (ID actID : activityMap.keySet()) // for some reason,</span>
														// passing
														// activityMap.keySet()
														// to
														// findMediaForActivities
														// results in
														// ClassCastException:
														// com.bluepumpkin.common.datatypes.ID
<span class="nc" id="L1018">					activityIDs.add(actID);</span>

<span class="nc" id="L1020">				Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias = activityManager.findMediaForActivities(activityIDs);</span>
<span class="nc" id="L1021">				Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues = activityManager.findQueueForActivities(activityIDs);</span>
<span class="nc" id="L1022">				theData.put(ScheduleViewMH.ACTIVITY_MEDIAS_KEY, activityMedias);</span>
<span class="nc" id="L1023">				theData.put(ScheduleViewMH.ACTIVITY_QUEUES_KEY, activityQueues);</span>
			}
		}
<span class="nc" id="L1026">	}// getActivities</span>

	/**
	 * put org data: name and HOOs into theData
	 */
	private static void putOrgData(RequestContext context, HashMap&lt;String, Object&gt; theData, TimeRange theTimeRange,
			ID employeeID) throws RemoteException, BbmException {
<span class="nc" id="L1033">		ID selectedCampaignID = (ID) theData.get(SELECTED_CAMPAIGN_ID_KEY);</span>
<span class="nc" id="L1034">		log.debug(&quot; MH: selectedCampaignID = &quot; + selectedCampaignID);</span>
		// ===== get and store in theData: org ID and Name =====
<span class="nc" id="L1036">		ID selectedOrgID = (ID) theData.get(SELECTED_ORG_ID_KEY);</span>
<span class="nc" id="L1037">		log.debug(&quot; MH: selectedOrgID = &quot; + selectedOrgID);</span>
<span class="nc" id="L1038">		ID orgID = null;</span>
<span class="nc" id="L1039">		String orgName = &quot;&quot;;</span>
<span class="nc" id="L1040">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">		if (selectedOrgID == null) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">			if (selectedCampaignID == null) { // get org for the single employee</span>
<span class="nc" id="L1043">				Collection&lt;WorkResourceAssignment&gt; assignments = workResourceManager.getWorkResourceAssignments(</span>
<span class="nc" id="L1044">						employeeID, theTimeRange.getStartDate(), theTimeRange.getEndDate(), false);</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">				for (Iterator&lt;WorkResourceAssignment&gt; i = assignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1046">					WorkResourceAssignment assignment = i.next();</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">					if (assignment != null) {</span>
<span class="nc" id="L1048">						orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L1049">						orgName = workResourceManager.getOrganizationName(orgID);</span>
<span class="nc" id="L1050">						break; // take the first of assignments in the time</span>
								// range
					}
<span class="nc" id="L1053">				}</span>
<span class="nc" id="L1054">			} else {</span>
				// keep orgID as null and name as empty
			}
		} else { // use selected org
<span class="nc" id="L1058">			orgID = selectedOrgID;</span>
<span class="nc" id="L1059">			orgName = workResourceManager.getOrganizationName(orgID);</span>
		}
<span class="nc" id="L1061">		log.debug(&quot; MH: current Org name = &quot; + orgName);</span>
<span class="nc" id="L1062">		theData.put(ORGS_KEY, new IDStringPair(orgID, orgName));</span>
		// ===== get org hoos or campaign hoos (if only campaign ID is selected)
		// ===
<span class="nc bnc" id="L1065" title="All 2 branches missed.">		if (orgID != null) {</span>
<span class="nc" id="L1066">			HOOAssignment hOOAssignment = getOrgHOOs(context, orgID, theTimeRange);</span>
<span class="nc" id="L1067">			theData.put(HOOS_KEY, hOOAssignment);</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">		} else if (selectedCampaignID != null) {</span>
<span class="nc" id="L1069">			putCampaignHOOs(context, theData, orgID, theTimeRange);</span>
		}
<span class="nc" id="L1071">	}// getOrgData</span>

	/**
	 * get Org HOOs
	 */
	public static HOOAssignment getOrgHOOs(RequestContext context, ID orgID, TimeRange theTimeRange)
			throws RemoteException, BbmException {
<span class="nc" id="L1078">		log.debug(&quot; MH: getOrgHoos&quot;);</span>
<span class="nc" id="L1079">		Collection&lt;OrganizationHOO&gt; hooAssignments = OrganizationModelHandler.getOrganizationHOOAssignments(context,</span>
<span class="nc" id="L1080">				orgID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">		if (hooAssignments != null) {</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">			for (Iterator&lt;OrganizationHOO&gt; i = hooAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1083">				HOOAssignment hOOAssignment = i.next();</span>
<span class="nc" id="L1084">				return hOOAssignment; // use the first one</span>
			}
		}
<span class="nc" id="L1087">		return null;</span>
	}// getOrgHOOs

	/**
	 * Get the start day of the week for the employee's organization.
	 * 
	 * @return the week start day for the employye's org (ex: Calendar.FRIDAY)
	 */
	public static int getWeekStartDayForEmp(RequestContext context, ID employeeID, Organization org) {
<span class="nc" id="L1096">		int weekStartDay = Calendar.SUNDAY;</span>

		try {
<span class="nc bnc" id="L1099" title="All 2 branches missed.">			if (org != null) {</span>
<span class="nc" id="L1100">				weekStartDay = org.getWeekStartDate();</span>
			}

<span class="nc" id="L1103">		} catch (Exception ex) {</span>
<span class="nc" id="L1104">			log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="nc" id="L1105">		}</span>

<span class="nc" id="L1107">		return weekStartDay;</span>
	}// getWeekStartDayForEmp

	/**
	 * Get the employee's organization.
	 * 
	 * @return the employye's first org assignment in the current week.
	 */
	public static Organization getOrganizationForEmp(RequestContext context, ID employeeID) {
		// --- get current week start as Sunday 12:00am in the viewing TZ
<span class="nc" id="L1117">		Calendar thisWeekStart = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1118">				context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L1119">		int weekDay = thisWeekStart.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L1120">		thisWeekStart.add(Calendar.DATE, (-1) * (weekDay - 1));</span>
<span class="nc" id="L1121">		thisWeekStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L1122">		thisWeekStart.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L1123">		thisWeekStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1124">		thisWeekStart.set(Calendar.MILLISECOND, 0);</span>

<span class="nc" id="L1126">		Calendar thisWeekEnd = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1127">				context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L1128">		thisWeekEnd.setTime(thisWeekStart.getTime());</span>
<span class="nc" id="L1129">		thisWeekEnd.add(Calendar.DATE, 7);</span>
<span class="nc" id="L1130">		thisWeekEnd.add(Calendar.SECOND, -1);</span>

<span class="nc" id="L1132">		Organization org = null;</span>

		try {
<span class="nc" id="L1135">			WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc" id="L1136">			Collection&lt;WorkResourceAssignment&gt; assignments = workResourceManager.getWorkResourceAssignments(employeeID,</span>
<span class="nc" id="L1137">					thisWeekStart.getTime(), thisWeekEnd.getTime(), false);</span>

<span class="nc bnc" id="L1139" title="All 2 branches missed.">			for (Iterator&lt;WorkResourceAssignment&gt; i = assignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1140">				WorkResourceAssignment assignment = i.next();</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">				if (assignment != null) {</span>
<span class="nc" id="L1142">					ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L1143">					org = workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L1144">					break; // take the first of assignments in the time range</span>
				}
<span class="nc" id="L1146">			}</span>
<span class="nc" id="L1147">		} catch (Exception ex) {</span>
<span class="nc" id="L1148">			log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="nc" id="L1149">		}</span>

<span class="nc" id="L1151">		return org;</span>
	}//

	/**
	 * put Campaign HOOs into theData
	 */
	private static void putCampaignHOOs(RequestContext context, HashMap&lt;String, Object&gt; theData, ID campaignID,
			TimeRange theTimeRange) throws RemoteException, BbmException {
<span class="nc" id="L1159">		log.debug(&quot; MH: getCampaignHOOs&quot;);</span>
<span class="nc" id="L1160">		Collection&lt;CampaignHOO&gt; hooAssignments = CampaignModelHandler.getCampaignHOOAssignments(context, campaignID,</span>
<span class="nc" id="L1161">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc bnc" id="L1162" title="All 2 branches missed.">		if (hooAssignments != null) {</span>
<span class="nc bnc" id="L1163" title="All 2 branches missed.">			for (Iterator&lt;CampaignHOO&gt; i = hooAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1164">				HOOAssignment hOOAssignment = i.next();</span>
<span class="nc" id="L1165">				theData.put(HOOS_KEY, hOOAssignment);</span>
<span class="nc" id="L1166">				break; // use the first one</span>
			}
		}
<span class="nc" id="L1169">	}// getCampaignHOOs</span>

	/**
	 * Get a list of the org HOOAssignments, one for each employee.
	 * 
	 * @param context
	 *            The context.
	 * @param theTimeRange
	 *            This range is used to find the org that each employee is
	 *            assigned to.
	 * @param employeeIDs
	 *            The list of employees which you need HOOAssignments for.
	 * @return a list of the org HOOAssignments, one for each employee.
	 */
	private static Collection&lt;HOOAssignment&gt; getEmployeeHooAssignments(RequestContext context, TimeRange theTimeRange,
			Collection&lt;ID&gt; employeeIDs) throws RemoteException, BbmException {
<span class="nc" id="L1185">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc" id="L1186">		Collection&lt;HOOAssignment&gt; hooAssignments = new ArrayList&lt;HOOAssignment&gt;();</span>
		// used so that we only need to look up HOO's once per org
<span class="nc" id="L1188">		HashMap&lt;ID, HOOAssignment&gt; orgIdToHooMap = new HashMap&lt;ID, HOOAssignment&gt;();</span>

<span class="nc bnc" id="L1190" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; it = employeeIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1191">			ID employeeID = it.next();</span>
<span class="nc" id="L1192">			HOOAssignment hooAssignment = null;</span>
<span class="nc" id="L1193">			Collection&lt;WorkResourceAssignment&gt; orgAssignments = workResourceManager.getWorkResourceAssignments(</span>
<span class="nc" id="L1194">					employeeID, theTimeRange.getStartDate(), theTimeRange.getEndDate(), false);</span>

<span class="nc bnc" id="L1196" title="All 2 branches missed.">			for (Iterator&lt;WorkResourceAssignment&gt; i = orgAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1197">				WorkResourceAssignment orgAssignment = i.next();</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">				if (orgAssignment != null) {</span>
<span class="nc" id="L1199">					ID orgID = orgAssignment.getOrganizationID();</span>
<span class="nc" id="L1200">					hooAssignment = orgIdToHooMap.get(orgID);</span>
<span class="nc bnc" id="L1201" title="All 2 branches missed.">					if (hooAssignment == null) {</span>
<span class="nc" id="L1202">						hooAssignment = getOrgHOOs(context, orgID, theTimeRange);</span>
<span class="nc" id="L1203">						orgIdToHooMap.put(orgID, hooAssignment);</span>
					}
					break; // take the first org assignment in the time range
				}
<span class="nc" id="L1207">			}</span>
<span class="nc" id="L1208">			hooAssignments.add(hooAssignment);</span>
<span class="nc" id="L1209">		}</span>
<span class="nc" id="L1210">		return hooAssignments;</span>
	}

	/**
	 * get legend data
	 *
	 * @param myEmpID - The ID of the currently logged-in user
	 * @hasHidenTimeOffEvents: true: Not show real activity name, only show &quot;Time Off&quot;
	 */
	private static void putLegendData(RequestContext context, HashMap&lt;String, Object&gt; theData, ID myEmpID, boolean hasHidenTimeOffEvents) {
<span class="nc" id="L1220">		ArrayList theLegendData = new ArrayList();</span>
		//the schedule may be a simple collection for personal view of collection of collections
<span class="nc" id="L1222">		Collection theScheduleItems = getAllScheduleItemsFromMap(theData);</span>
<span class="nc bnc" id="L1223" title="All 4 branches missed.">		if (theScheduleItems != null &amp;&amp; theScheduleItems.size() &gt; 0) {</span>
			// get collection of activity IDs from the schedule
<span class="nc" id="L1225">			boolean bShowTimeoff = ScheduleViewPM.getBooleanFromMap(theData, ScheduleViewMH.SHOW_TIMEOFF_KEY);</span>
<span class="nc" id="L1226">			Collection activityIDs = ScheduleViewUtil.getScheduledActivityIDs(theScheduleItems, myEmpID, bShowTimeoff);</span>

			// load all activities in the schedule
<span class="nc" id="L1229">			HashMap activities = (HashMap) theData.get(ACTIVITIES_KEY);</span>

			// package activity names and colors
<span class="nc bnc" id="L1232" title="All 4 branches missed.">			if (activityIDs != null &amp;&amp; activityIDs.size() &gt; 0) {</span>

<span class="nc bnc" id="L1234" title="All 2 branches missed.">				for (Iterator it = activityIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1235">					ID activityID = (ID) it.next();</span>
<span class="nc" id="L1236">					Activity activity = (Activity) activities.get(activityID);</span>

					//timeoff activities are pre-filtered from the activities collection, but unavailabilities are not
<span class="nc" id="L1239">					boolean bShowUnavailable = ScheduleViewPM.getBooleanFromMap(theData, ScheduleViewMH.SHOW_UNAVAILABLE_KEY);</span>
<span class="nc" id="L1240">					String generalTimeOffEvent = context.getLocalizer().i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.FS_CUSTOM_TIME_OFF);</span>

<span class="nc bnc" id="L1242" title="All 2 branches missed.">					if (activity != null) {</span>
<span class="nc bnc" id="L1243" title="All 6 branches missed.">						if (activity.isTimeoff() &amp;&amp; hasHidenTimeOffEvents &amp;&amp; bShowTimeoff) {</span>
							//Not show absent reason of time off since it has hidden time off event
							//Default color of shift assignment
<span class="nc" id="L1246">							String eventColor = &quot;0000FF&quot;;</span>
<span class="nc" id="L1247">							theLegendData.add(new StringsPair(eventColor, generalTimeOffEvent));</span>
<span class="nc bnc" id="L1248" title="All 4 branches missed.">						} else if (!(activity.isUnavailability() &amp;&amp; !bShowUnavailable)) {</span>
							//Show absent reason
<span class="nc" id="L1250">							theLegendData.add(new StringsPair(activity.getColor(), activity.getName()));</span>
						}
					}
<span class="nc" id="L1253">				}</span>
			}
			// Overtime item to be added before rendering in the page model
		}
<span class="nc" id="L1257">		theData.put(LEGEND_ITEMS_KEY, theLegendData);</span>
<span class="nc" id="L1258">		debugLogCollection(&quot;putLegendData&quot;, &quot;theLegendData&quot;, theLegendData);</span>
<span class="nc" id="L1259">	}</span>

	/**
	 * get schedule items from the data map in one collection even for the group
	 * 
	 * @param theData
	 * @return
	 */
	public static Collection getAllScheduleItemsFromMap(Map&lt;String, Object&gt; theData) {
		// the schedule may be a simple collection for personal view of
		// collection of collections
		Collection theScheduleItems;
<span class="nc" id="L1271">		String viewType = (String) theData.get(VIEW_TYPE_KEY);</span>
<span class="nc bnc" id="L1272" title="All 4 branches missed.">		if (StringUtil.isEmpty(viewType) || viewType.indexOf(&quot;GROUP&quot;) != -1) {</span>
			// group - package multiple collections into one
<span class="nc" id="L1274">			theScheduleItems = getGroupScheduleItems(theData);</span>
		} else { // personal
<span class="nc" id="L1276">			theScheduleItems = (Collection) theData.get(SCHEDULE_ITEMS_KEY);</span>
		}
<span class="nc" id="L1278">		return theScheduleItems;</span>
	}// getAllScheduleItemsFromMap

	/**
	 * make one collection of schedule items from the group schedule - used for
	 * the legend
	 */
	public static Collection getGroupScheduleItems(Map&lt;String, Object&gt; theData) {
<span class="nc" id="L1286">		ArrayList scheduleItems = new ArrayList();</span>
<span class="nc" id="L1287">		Collection groupItems = (Collection) theData.get(SCHEDULE_ITEMS_KEY);</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">		if (groupItems != null) {</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">			for (Iterator it = groupItems.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1290">				Collection personItems = (Collection) it.next();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">				if (personItems != null) {</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">					for (Iterator jt = personItems.iterator(); jt.hasNext();) {</span>
<span class="nc" id="L1293">						scheduleItems.add(jt.next());</span>
					}
				}
<span class="nc" id="L1296">			}</span>
		}
<span class="nc" id="L1298">		return scheduleItems;</span>
	}// getGroupScheduleItems

	/**
	 * get time range as this week for the user org.
	 */
	private static TimeRange getTimeRange(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="nc" id="L1306">		Calendar startCal = getThisWeekStart(context, theData);</span>
<span class="nc" id="L1307">		Calendar endCal = getThisWeekEnd(context, startCal);</span>
<span class="nc" id="L1308">		TimeRange timeRange = new TimeRange(startCal.getTime(), endCal.getTime());</span>

<span class="nc" id="L1310">		context.setAttribute(RequestContext.SESSION_SCOPE, UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, timeRange);</span>
<span class="nc" id="L1311">		return timeRange;</span>
	}// getTimeRange

	//////////////////////////////////////////////////////////////////////////////
	// Shift and Sechedule Helper
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * flatten schedule for each employee in the group schedule collection
	 */
	public static Collection&lt;Collection&lt;SimpleEvent&gt;&gt; flattenGroupSchedule(
			Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule) {
<span class="nc" id="L1322">		log.debug(&quot; MH.flattenGroupSchedule&quot;);</span>
<span class="nc" id="L1323">		ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; flatSchedule = new ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;();</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">		if (groupSchedule != null) {</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">			for (Iterator&lt;Collection&lt;? extends Event&gt;&gt; i = groupSchedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1326">				flatSchedule.add(flattenSchedule(i.next()));</span>
			}
		}
<span class="nc" id="L1329">		return flatSchedule;</span>
	}// flattenGroupSchedule

	/**
	 * flatten and merge schedule collection of events
	 */
	private static Collection&lt;SimpleEvent&gt; flattenSchedule(Collection&lt;? extends Event&gt; events) {
<span class="nc" id="L1336">		Collection&lt;SimpleEvent&gt; flatSchedule = EventUtils.convertEventsToTimelineForSingleEmployee(events);</span>
<span class="nc" id="L1337">		debugLogCollection(&quot;flattenSchedule&quot;, &quot;flatSchedule&quot;, flatSchedule);</span>
<span class="nc" id="L1338">		Collection&lt;SimpleEvent&gt; mergedSchedule = EventUtils.mergeSameEvents(flatSchedule);</span>
<span class="nc" id="L1339">		return mergedSchedule;</span>
	}// flattenSchedule

	/**
	 * flatten schedule for each employee in the group schedule collection
	 */
	public static Collection&lt;Collection&lt;SimpleEvent&gt;&gt; markGroupOvertimeEvents(
			Collection&lt;Collection&lt;SimpleEvent&gt;&gt; groupSchedule, Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts) {
<span class="nc" id="L1347">		log.debug(&quot; MH.markGroupOvertimeEvents&quot;);</span>
<span class="nc" id="L1348">		ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; markedSchedule = new ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;();</span>
<span class="nc bnc" id="L1349" title="All 4 branches missed.">		if (groupSchedule != null &amp;&amp; groupShifts != null) {</span>
			// FIXME: explicit casts to lists here....the method signature was a
			// collection
<span class="nc" id="L1352">			ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt; gSched = (ArrayList&lt;Collection&lt;SimpleEvent&gt;&gt;) groupSchedule;</span>
<span class="nc" id="L1353">			ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt; gShifts = (ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt;) groupShifts;</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">			for (int i = 0; i &lt; gSched.size(); i++) {</span>
<span class="nc" id="L1355">				markedSchedule.add(markOvertimeEvents(gSched.get(i), gShifts.get(i)));</span>
			}
		}
<span class="nc" id="L1358">		return markedSchedule;</span>
	}// markGroupOvertimeEvents

	/**
	 * mark events within shift extensions as overtime
	 * 
	 * @param scheduleData
	 *            - collection of SimpleEvent objects in chronological order
	 * @param scheduleShifts
	 *            - collection of SimpleEvent shift assignments in chronological
	 *            order
	 * @return
	 */
	private static Collection&lt;SimpleEvent&gt; markOvertimeEvents(Collection&lt;SimpleEvent&gt; scheduleData,
			Collection&lt;ShiftAssignment&gt; scheduleShifts) {
<span class="nc" id="L1373">		ArrayList&lt;TimeRange&gt; overtimePeriods = (ArrayList&lt;TimeRange&gt;) findOvertimePeriods(scheduleShifts);</span>
		// if no overtime return original collection of flattened events
<span class="nc bnc" id="L1375" title="All 2 branches missed.">		if (overtimePeriods.size() &lt;= 0) {</span>
<span class="nc" id="L1376">			return scheduleData;</span>
		}
		// else repackage scheduleData collection since may have to split some
		// events
<span class="nc" id="L1380">		ArrayList&lt;SimpleEvent&gt; markedEvents = new ArrayList&lt;SimpleEvent&gt;();</span>
		// for each event in scheduleData process event
<span class="nc bnc" id="L1382" title="All 2 branches missed.">		for (Iterator&lt;SimpleEvent&gt; it = scheduleData.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1383">			markEventOvertime(overtimePeriods, it.next(), markedEvents);</span>
		}
<span class="nc" id="L1385">		return markedEvents;</span>
	}// markOvertimeEvents

	/**
	 * find shift assignments overitme periods
	 * 
	 * @param scheduleShifts
	 * @return collection of overtime TimeRanges or empty
	 */
	private static Collection&lt;TimeRange&gt; findOvertimePeriods(Collection&lt;ShiftAssignment&gt; scheduleShifts) {
<span class="nc" id="L1395">		ArrayList&lt;TimeRange&gt; overtimeRanges = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L1396" title="All 4 branches missed.">		if (scheduleShifts != null &amp;&amp; scheduleShifts.size() &gt; 0) {</span>
<span class="nc" id="L1397">			SortEvents se = new SortEvents();</span>
			// FIXME: explicit casts to lists here....the method signature was a
			// collection
<span class="nc" id="L1400">			Collections.sort((List) scheduleShifts,</span>
<span class="nc" id="L1401">					se.getEventSorter(SortEvents.SORT_BY_START, SupportNavigation.SORT_ASCENDING));</span>
<span class="nc bnc" id="L1402" title="All 2 branches missed.">			for (Iterator&lt;ShiftAssignment&gt; it = scheduleShifts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1403">				ShiftAssignment sa = it.next();</span>
<span class="nc bnc" id="L1404" title="All 2 branches missed.">				if (sa != null) {</span>
<span class="nc bnc" id="L1405" title="All 2 branches missed.">					if (sa.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L1406">						TimeRange ot = new TimeRange(sa.getStartTime(), sa.getExtensionBefore() * 60000);</span>
<span class="nc" id="L1407">						overtimeRanges.add(ot);</span>
					}
<span class="nc bnc" id="L1409" title="All 2 branches missed.">					if (sa.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L1410">						TimeRange ot = new TimeRange(</span>
<span class="nc" id="L1411">								new Date(sa.getEndTime().getTime() - sa.getExtensionAfter() * 60000), sa.getEndTime());</span>
<span class="nc" id="L1412">						overtimeRanges.add(ot);</span>
					}
				}
<span class="nc" id="L1415">			}</span>
		}
<span class="nc" id="L1417">		return overtimeRanges;</span>
	}// findOvertimePeriods

	/**
	 * process one SimpleEvent marking overtime and adding to marked collection
	 */
	private static void markEventOvertime(ArrayList&lt;TimeRange&gt; OTPeriods, SimpleEvent event,
			Collection&lt;SimpleEvent&gt; markedEvents) {
<span class="nc bnc" id="L1425" title="All 2 branches missed.">		if (OTPeriods.size() &lt;= 0) {</span>
<span class="nc" id="L1426">			markedEvents.add(event);</span>
<span class="nc" id="L1427">			return;</span>
		}
<span class="nc" id="L1429">		TimeRange overtimeRange = OTPeriods.get(0);</span>
<span class="nc" id="L1430">		TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1431">		int overlapType = eventRange.getRelativeLocationTo(overtimeRange);</span>
		// consider Overtime GAP belongs to Overtime
<span class="nc bnc" id="L1433" title="All 4 branches missed.">		if (overlapType == TimeRange.INTERVAL_IN || overlapType == TimeRange.INTERVAL_EQUALS</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">				|| event.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP) == 0) {</span>
<span class="nc" id="L1435">			event.setIsOvertime(true);</span>
<span class="nc" id="L1436">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1437" title="All 2 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_BEFORE) {</span>
			// keep the same overtime period in the future on the timeline
<span class="nc" id="L1439">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_AFTER) {</span>
			// try next overtime period recursively
<span class="nc" id="L1442">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
<span class="nc bnc" id="L1443" title="All 4 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_BEFORE_AND_IN || overlapType == TimeRange.INTERVAL_COVERS</span>
<span class="nc bnc" id="L1444" title="All 2 branches missed.">				&amp;&amp; overtimeRange.getEndDate().getTime() == eventRange.getEndDate().getTime()) {</span>
			// split event (eventStart,overtimeStart)(overtimeStart,eventEnd)
			// and mark the second overtime
<span class="nc" id="L1447">			addSplitPartOfEvent(event, null, overtimeRange.getStartDate(), false, markedEvents);</span>
			// second event is adjusted event;
<span class="nc" id="L1449">			event.setStartTime(overtimeRange.getStartDate());</span>
<span class="nc" id="L1450">			event.setIsOvertime(true);</span>
<span class="nc" id="L1451">			markedEvents.add(event);</span>
<span class="nc bnc" id="L1452" title="All 4 branches missed.">		} else if (overlapType == TimeRange.INTERVAL_AFTER_AND_IN || overlapType == TimeRange.INTERVAL_COVERS</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">				&amp;&amp; overtimeRange.getStartDate().getTime() == eventRange.getStartDate().getTime()) {</span>
			// split event (eventStart,overlapEnd) (overlapEnd,eventEnd), mark
			// first overtime and add to marked
<span class="nc" id="L1456">			addSplitPartOfEvent(event, null, overtimeRange.getEndDate(), true, markedEvents);</span>
			// try next overtime recursively with second event which is adjusted
			// event
<span class="nc" id="L1459">			event.setStartTime(overtimeRange.getEndDate());</span>
<span class="nc" id="L1460">			event.setIsOvertime(false);</span>
<span class="nc" id="L1461">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
		} else { // event covers overtime, and overtime starts after event start
					// and ends before event end
			// split event to three events
			// (eventStart,overtimeStart),(overtimeStart,overtimeEnd),(overtimeEnd,eventEnd)
			// mark second overtime, move two first to marked
<span class="nc" id="L1467">			addSplitPartOfEvent(event, null, overtimeRange.getStartDate(), false, markedEvents);</span>
<span class="nc" id="L1468">			addSplitPartOfEvent(event, overtimeRange.getStartDate(), overtimeRange.getEndDate(), true, markedEvents);</span>
			// try next overtime recursively with third event which is adjusted
			// event
<span class="nc" id="L1471">			event.setStartTime(overtimeRange.getEndDate());</span>
<span class="nc" id="L1472">			event.setIsOvertime(false);</span>
<span class="nc" id="L1473">			markEventWithNextOvertime(OTPeriods, event, markedEvents);</span>
		}
<span class="nc" id="L1475">		return;</span>
	}// markEventOvertime

	/**
	 * process one SimpleEvent marking overtime and adding to marked collection
	 * trying with consecutive overtime periods
	 */
	private static void markEventWithNextOvertime(ArrayList&lt;TimeRange&gt; OTPeriods, SimpleEvent event,
			Collection markedEvents) {
<span class="nc bnc" id="L1484" title="All 2 branches missed.">		if (OTPeriods.size() &gt; 0) {</span>
<span class="nc" id="L1485">			OTPeriods.remove(0);</span>
<span class="nc" id="L1486">			markEventOvertime(OTPeriods, event, markedEvents);</span>
		} else {// no overtime left - move second event to marked
<span class="nc" id="L1488">			markedEvents.add(event);</span>
		}
<span class="nc" id="L1490">		return;</span>
	}// markEventWithNextOvertime

	/**
	 * @param event
	 * @param startOrNull
	 * @param endOrNull
	 * @param bOvertime
	 */
	private static void addSplitPartOfEvent(SimpleEvent event, Date startOrNull, Date endOrNull, boolean bOvertime,
			Collection markedEvents) {
<span class="nc" id="L1501">		SimpleEvent newEvent = new SimpleEvent(event);</span>
<span class="nc bnc" id="L1502" title="All 2 branches missed.">		if (startOrNull != null) {</span>
<span class="nc" id="L1503">			newEvent.setStartTime(startOrNull);</span>
		}
<span class="nc bnc" id="L1505" title="All 2 branches missed.">		if (endOrNull != null) {</span>
<span class="nc" id="L1506">			newEvent.setEndTime(endOrNull);</span>
		}
<span class="nc" id="L1508">		newEvent.setIsOvertime(bOvertime);</span>
<span class="nc" id="L1509">		markedEvents.add(newEvent);</span>
<span class="nc" id="L1510">	}// addSplitPartOfEvent</span>

	/**
	 * select only shifts from each of the schedule in the group
	 */
	public static Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; selectGroupShifts(
			Collection&lt;Collection&lt;? extends Event&gt;&gt; groupSchedule) {
<span class="nc bnc" id="L1517" title="All 2 branches missed.">		if (groupSchedule == null) {</span>
<span class="nc" id="L1518">			return null;</span>
		}
<span class="nc" id="L1520">		ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt; groupShifts = new ArrayList&lt;Collection&lt;ShiftAssignment&gt;&gt;();</span>
<span class="nc bnc" id="L1521" title="All 2 branches missed.">		for (Iterator&lt;Collection&lt;? extends Event&gt;&gt; i = groupSchedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1522">			groupShifts.add(selectOnlyShiftAssignments((Collection&lt;? extends Event&gt;) i.next()));</span>
		}
<span class="nc" id="L1524">		return groupShifts;</span>
	}// selectGroupShifts

	/**
	 * select only shift assignments from all schedule events
	 */
	public static Collection&lt;ShiftAssignment&gt; selectOnlyShiftAssignments(Collection&lt;? extends Event&gt; scheduleEvents) {
<span class="nc" id="L1531">		ArrayList&lt;ShiftAssignment&gt; shifts = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc bnc" id="L1532" title="All 4 branches missed.">		if (scheduleEvents != null &amp;&amp; scheduleEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L1533" title="All 2 branches missed.">			for (Iterator&lt;? extends Event&gt; i = scheduleEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1534">				Event event = i.next();</span>
<span class="nc bnc" id="L1535" title="All 2 branches missed.">				if (event != null) {</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">					if (event.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT)</span>
<span class="nc" id="L1537">						shifts.add((ShiftAssignment) event);</span>
				}
<span class="nc" id="L1539">			}</span>
		}
<span class="nc" id="L1541">		debugLogCollection(&quot;selectOnlyShiftAssignments&quot;, &quot;shifts&quot;, shifts);</span>
<span class="nc" id="L1542">		return shifts;</span>
	}// selectOnlyShiftAssignments

	//////////////////////////////////////////////////////////////////////////////
	// Published Periods
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Get published periods
	 *
	 * @return single collection of TimeRanges
	 *
	 */
	public static Collection&lt;TimeRange&gt; getTimeRangesForPublishedPeriods(
			Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, Collection&lt;ID&gt; eIDs) throws RemoteException, BbmException {
<span class="nc" id="L1557">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="nc" id="L1559">		Collection&lt;TimeRange&gt; ppTimeRanges = null;</span>
<span class="nc bnc" id="L1560" title="All 4 branches missed.">		if (pubPeriodsForEmps != null &amp;&amp; !pubPeriodsForEmps.isEmpty()) {</span>
<span class="nc bnc" id="L1561" title="All 2 branches missed.">			for (Collection&lt;PublishingPeriod&gt; personalPeriods : pubPeriodsForEmps) {</span>
<span class="nc" id="L1562">				ppTimeRanges = makeTimeRanges(personalPeriods);</span>
<span class="nc" id="L1563">			}</span>
		}

<span class="nc" id="L1566">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;publishedPeriods&quot;, ppTimeRanges);</span>

<span class="nc" id="L1568">		theData.put(PUB_PERIODS_KEY, ppTimeRanges);</span>
<span class="nc" id="L1569">		return ppTimeRanges;</span>
	}// getTimeRangesForPublishedPeriods

	/**
	 * Get published periods
	 *
	 * @return Collection of Collections of TimeRanges for each eID
	 *
	 */
	public static Collection&lt;Collection&lt;TimeRange&gt;&gt; getTimeRangesForPublishedPeriodsForGroupView(
			Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsForEmps, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, Collection&lt;ID&gt; eIDs) throws RemoteException, BbmException {
<span class="nc" id="L1581">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="nc" id="L1583">		Collection&lt;Collection&lt;TimeRange&gt;&gt; ppTimeRanges = null;</span>
<span class="nc bnc" id="L1584" title="All 4 branches missed.">		if (pubPeriodsForEmps != null &amp;&amp; !pubPeriodsForEmps.isEmpty()) {</span>

<span class="nc" id="L1586">			int size = pubPeriodsForEmps.size();</span>
<span class="nc" id="L1587">			ppTimeRanges = new ArrayList&lt;Collection&lt;TimeRange&gt;&gt;(size);</span>

<span class="nc bnc" id="L1589" title="All 2 branches missed.">			for (Collection&lt;PublishingPeriod&gt; personalPeriods : pubPeriodsForEmps) {</span>
<span class="nc" id="L1590">				ppTimeRanges.add(makeTimeRanges(personalPeriods));</span>
<span class="nc" id="L1591">			}</span>
		}

<span class="nc" id="L1594">		debugLogCollection(&quot;getTimeRangesForPublishedPeriods&quot;, &quot;publishedPeriods&quot;, ppTimeRanges);</span>

<span class="nc" id="L1596">		theData.put(PUB_PERIODS_KEY, ppTimeRanges);</span>
<span class="nc" id="L1597">		return ppTimeRanges;</span>
	}// getTimeRangesForPublishedPeriods

	/**
	 * convert collection of PublishingPeriod objects into collection of
	 * TimeRange objects
	 */
	public static Collection&lt;TimeRange&gt; makeTimeRanges(Collection&lt;PublishingPeriod&gt; pubPeriods) {
<span class="nc bnc" id="L1605" title="All 2 branches missed.">		if (pubPeriods == null) {</span>
<span class="nc" id="L1606">			return null;</span>
		}
<span class="nc" id="L1608">		ArrayList&lt;TimeRange&gt; ranges = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">		if (pubPeriods != null) {</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">			for (Iterator&lt;PublishingPeriod&gt; i = pubPeriods.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1611">				PublishingPeriod tp = i.next();</span>
<span class="nc" id="L1612">				ranges.add(new TimeRange(tp.getStartTime(), tp.getEndTime()));</span>
<span class="nc" id="L1613">			}</span>
		}
<span class="nc" id="L1615">		return ranges;</span>
	}// maketimeRanges

	//////////////////////////////////////////////////////////////////////////////
	// User / Organization Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * put user org ID in theData
	 */
	public static ID putUserOrgID(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
<span class="nc" id="L1626">		ID userOrgID = (ID) theData.get(USER_ORG_ID_KEY);</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">		if (userOrgID == null) { // try to get from employee</span>
<span class="nc" id="L1628">			ID employeeID = context.getUser().getEmployeeID();</span>

<span class="nc bnc" id="L1630" title="All 2 branches missed.">			if (employeeID != null) {</span>
<span class="nc" id="L1631">				userOrgID = OrganizationModelHandler.getEmployeeOrgID(context, employeeID);</span>
			}
<span class="nc" id="L1633">			log.debug(&quot; MH userEmployeeID = &quot; + employeeID + &quot;\t userOrgID = &quot; + userOrgID);</span>

<span class="nc" id="L1635">			theData.put(USER_ORG_ID_KEY, userOrgID);</span>
		}
<span class="nc" id="L1637">		return userOrgID;</span>
	}// getUserOrgID

	//////////////////////////////////////////////////////////////////////////////
	// Date Time Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * get this week start for the current user/org
	 */
	public static Calendar getThisWeekStart(RequestContext context, HashMap&lt;String, Object&gt; theData)
			throws RemoteException, BbmException {
		// --- get current week start as Sunday 12:00am in the viewing TZ
<span class="nc" id="L1649">		Calendar thisWeekStart = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1650">				context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L1651">		int weekDay = thisWeekStart.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L1652">		thisWeekStart.add(Calendar.DATE, (-1) * (weekDay - 1));</span>
<span class="nc" id="L1653">		thisWeekStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L1654">		thisWeekStart.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L1655">		thisWeekStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1656">		thisWeekStart.set(Calendar.MILLISECOND, 0);</span>

		// --- get employee ID -&gt; Org ID - &gt; Org week start offset
<span class="nc" id="L1659">		ID userOrgID = (ID) theData.get(ScheduleViewMH.USER_ORG_ID_KEY);</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">		if (userOrgID != null) {</span>
<span class="nc" id="L1661">			WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc" id="L1662">			Organization org = workResourceManager.getOrganizationByID(userOrgID);</span>
<span class="nc" id="L1663">			short weekStartDate = org.getWeekStartDate();</span>
			// --- apply org weekstart offset
<span class="nc bnc" id="L1665" title="All 2 branches missed.">			int dayOffset = (weekStartDate &gt; weekDay) ? weekStartDate - 1 - 7 : weekStartDate - 1;</span>
<span class="nc" id="L1666">			thisWeekStart.add(Calendar.DATE, dayOffset);</span>
		}
<span class="nc" id="L1668">		log.debug(&quot; MH.getThisWeekStart: &quot; + thisWeekStart.getTime());</span>
<span class="nc" id="L1669">		return thisWeekStart;</span>
	}// getThisWeekStart

	/**
	 * get this week end for the current user/org based on week start
	 */
	public static Calendar getThisWeekEnd(RequestContext context, Calendar weekStart) {
<span class="nc" id="L1676">		Calendar thisWeekEnd = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L1677">				context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L1678">		thisWeekEnd.setTime(weekStart.getTime());</span>
<span class="nc" id="L1679">		thisWeekEnd.add(Calendar.DATE, 7);</span>
<span class="nc" id="L1680">		thisWeekEnd.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L1681">		return thisWeekEnd;</span>
	}// getThisWeekEnd

	//////////////////////////////////////////////////////////////////////////////
	// Filter Related
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Return employe IDS where current user has privilege to view schedule.
	 */
	public static Collection&lt;ID&gt; getEmpIDsForSchedViewing(RequestContext context, ID orgPrivID, Collection&lt;ID&gt; empIDs)
			throws Exception {
<span class="nc" id="L1692">		User user = context.getUser();</span>

		// Need to return collection in same order
<span class="nc" id="L1695">		Set authorizedEmpIDSet = PeopleMH.isAuthorizedToOrg(context, user, empIDs, orgPrivID);</span>
<span class="nc" id="L1696">		ArrayList&lt;ID&gt; result = new ArrayList&lt;ID&gt;(empIDs.size());</span>
<span class="nc bnc" id="L1697" title="All 2 branches missed.">		for (Iterator it = empIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1698">			ID empID = (ID) it.next();</span>
<span class="nc bnc" id="L1699" title="All 2 branches missed.">			if (authorizedEmpIDSet.contains(empID)) {</span>
<span class="nc" id="L1700">				result.add(empID);</span>
			}
<span class="nc" id="L1702">		}</span>

<span class="nc" id="L1704">		return result;</span>
	}

	/**
	 * get employee IDs - the full sorted collection if the sortField is
	 * EMP_SORT_NOT_BY_NAME then sorting is done outside
	 */
	private static Collection&lt;ID&gt; getEmployeeIDs(RequestContext context, HashMap&lt;String, Object&gt; theData,
			TimeRange theTimeRange, TimeRange theDayRange, ID orgID, ID campaignID, ID userOrgID, int sortField)
					throws RemoteException, BbmException {

<span class="nc" id="L1715">		log.debug(&quot;Enter MH.getEmployeeIDs&quot;);</span>
<span class="nc" id="L1716">		Collection&lt;ID&gt; eIDs = null; // to return it</span>
<span class="nc" id="L1717">		Filter filter = null;</span>
<span class="nc" id="L1718">		Filter orgFilter = null;</span>
<span class="nc" id="L1719">		Filter campaignFilter = null;</span>

		// this means that no page message will be displayed
<span class="nc" id="L1722">		String groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_OK;</span>

<span class="nc" id="L1724">		Collection&lt;ID&gt; rmOrgIDs = getGroupViewOrgIDs(userOrgID);</span>
<span class="nc" id="L1725">		debugLogCollection(&quot;getEmployeeIDs&quot;, &quot;orgIDs&quot;, eIDs);</span>

<span class="nc bnc" id="L1727" title="All 2 branches missed.">		if (orgID != null) {</span>
			// check the privs for the selected org
<span class="nc" id="L1729">			boolean groupViewEnabled = ScheduleViewUtil.isPrivWithOrgScope(context, theData,</span>
					PrivilegeKeys.FS_VIEWORGSCHEDULES, GROUPVIEW_FLAG_KEY, false, orgID);

<span class="nc bnc" id="L1732" title="All 6 branches missed.">			boolean isInRmOrgs = (rmOrgIDs != null &amp;&amp; !rmOrgIDs.isEmpty() &amp;&amp; rmOrgIDs.contains(orgID));</span>

<span class="nc bnc" id="L1734" title="All 4 branches missed.">			if (!groupViewEnabled &amp;&amp; !isInRmOrgs) {</span>
<span class="nc" id="L1735">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_1;</span>
			} else {
				// org OK
<span class="nc" id="L1738">				orgFilter = getFilterForOrg(context, theTimeRange, theDayRange, orgID);</span>
<span class="nc" id="L1739">				boolean useFilter = true;</span>
<span class="nc bnc" id="L1740" title="All 2 branches missed.">				if (campaignID != null) {</span>
					// need dual filter
<span class="nc" id="L1742">					Collection&lt;ID&gt; orgIDsInCampaign = getOrgIDsInCampaign(context, campaignID, theTimeRange);</span>
<span class="nc bnc" id="L1743" title="All 2 branches missed.">					if (!orgIDsInCampaign.contains(orgID)) {</span>
<span class="nc" id="L1744">						useFilter = false;</span>
<span class="nc" id="L1745">						groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOLINK_1;</span>
						// System.out.println(&quot;The selected organization is not
						// linked to the selected campaign for that date
						// range.&quot;);
					} else {
<span class="nc" id="L1750">						campaignFilter = getFilterForCampaign(context, theTimeRange, theDayRange, campaignID);</span>
					}
				}
<span class="nc bnc" id="L1753" title="All 2 branches missed.">				if (useFilter)</span>
<span class="nc" id="L1754">					filter = getCombinedFilter(context, orgFilter, campaignFilter);</span>
			}
<span class="nc bnc" id="L1756" title="All 2 branches missed.">		} else if (campaignID != null) {</span>
			// only campaign is selected
			// check if can view all or some orgs in the campaign
<span class="nc" id="L1759">			Collection&lt;ID&gt; orgIDsInCampaign = getOrgIDsInCampaign(context, campaignID, theTimeRange);</span>
<span class="nc bnc" id="L1760" title="All 4 branches missed.">			if (orgIDsInCampaign == null || orgIDsInCampaign.size() == 0) {</span>
<span class="nc" id="L1761">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOLINK_2;</span>
			} else {
				// Get all the orgs that are in the user's scope. We need to do
				// this in order to determine/catch
				// the employees that may belong to other organizations in the
				// user's scope but are pooled at organizations
				// linked to this SP.
<span class="nc" id="L1768">				Collection&lt;ID&gt; orgIDsInAccessRights = OrganizationModelHandler.getAllOrgIdsInUserScope(context,</span>
<span class="nc" id="L1769">						context.getUser());</span>

<span class="nc bnc" id="L1771" title="All 2 branches missed.">				if (orgIDsInAccessRights.size() == 0) {</span>
<span class="nc" id="L1772">					groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_2;</span>
				} else {
<span class="nc bnc" id="L1774" title="All 2 branches missed.">					for (ID campaignOrgID : orgIDsInCampaign) {</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">						if (orgIDsInAccessRights.contains(campaignOrgID) == false) {</span>
<span class="nc" id="L1776">							groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_3;</span>
<span class="nc" id="L1777">							break;</span>
						}
<span class="nc" id="L1779">					}</span>

<span class="nc" id="L1781">					orgIDsInCampaign = orgIDsInAccessRights;</span>
<span class="nc" id="L1782">					filter = getFilterForCampaign(context, theTimeRange, theDayRange, campaignID);</span>
<span class="nc" id="L1783">					campaignFilter = getFilterForCampaign(context, theTimeRange, theDayRange, campaignID);</span>
<span class="nc" id="L1784">					orgFilter = getFilterForOrgCollection(context, theTimeRange, theDayRange, orgIDsInCampaign);</span>
<span class="nc" id="L1785">					filter = getCombinedFilter(context, orgFilter, campaignFilter);</span>
				}
			}
<span class="nc" id="L1788">		} else {</span>
			// both org and campaign are null. Check if user can view his own
			// UserOrgID

			// check the privs for the user's org
<span class="nc" id="L1793">			boolean groupViewEnabled = ScheduleViewUtil.isPrivWithOrgScope(context, theData,</span>
					PrivilegeKeys.FS_VIEWORGSCHEDULES, GROUPVIEW_FLAG_KEY, false, userOrgID);

<span class="nc bnc" id="L1796" title="All 6 branches missed.">			boolean isInRmOrgs = (rmOrgIDs != null &amp;&amp; !rmOrgIDs.isEmpty() &amp;&amp; rmOrgIDs.contains(userOrgID));</span>

<span class="nc bnc" id="L1798" title="All 4 branches missed.">			if (!groupViewEnabled &amp;&amp; !isInRmOrgs) {</span>
<span class="nc" id="L1799">				groupViewLimit = ScheduleViewMH.GROUPVIEW_LIMIT_NOPRIV_1;</span>
				// System.out.println(&quot;You do not have a privilege to see
				// schedules from the selected organization.&quot;);
			} else {
<span class="nc" id="L1803">				filter = getFilterForOrg(context, theTimeRange, theDayRange, userOrgID);</span>
			}
		}

<span class="nc" id="L1807">		theData.put(ScheduleViewMH.GROUPVIEW_LIMIT_KEY, groupViewLimit);</span>
<span class="nc" id="L1808">		log.debug(&quot;MH.getEmployeeIDs groupViewLimit = &quot; + groupViewLimit);</span>
		// System.out.println(&quot;\n getEmployeeIDs groupViewLimit = &quot; +
		// groupViewLimit);

		// get collection of employee IDs
<span class="nc bnc" id="L1813" title="All 2 branches missed.">		if (filter != null) {</span>
			// For QA 53374 -Filters in My Schedule / Group / Campaign do not
			// appear to work correctly
			// filter.setPriviledge(null);
<span class="nc" id="L1817">			resetPrivilege(filter);</span>
<span class="nc" id="L1818">			EmployeeFilter employeeFilter = EmployeeModelHandler.getEmployeeFilter(context);</span>
<span class="nc" id="L1819">			eIDs = employeeFilter.getEmployeeIDs(filter, sortField, true, 0, Integer.MAX_VALUE);</span>
		}
<span class="nc bnc" id="L1821" title="All 2 branches missed.">		if (eIDs == null) {</span>
<span class="nc" id="L1822">			eIDs = new ArrayList&lt;ID&gt;();</span>
		}

		// Retrieve and filter out any pooled employees that do not have a
		// schedule (a published shift or shift
		// event) associated to the SPs belonging to the campaign for the given
		// date range.
<span class="nc bnc" id="L1829" title="All 4 branches missed.">		if (campaignID != null &amp;&amp; !eIDs.isEmpty()) {</span>
			// Find all applicable SPs in the campaign for the given date range
<span class="nc" id="L1831">			Collection&lt;SchedulingPeriod&gt; schedulingPeriods = CampaignModelHandler.getSchedulingPeriods(context,</span>
<span class="nc" id="L1832">					campaignID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
			// Find pooled employees in the SPs. This is tricky because
			// employees that
			// have been manually added aren't easily distinguishable
<span class="nc" id="L1836">			Collection&lt;ID&gt; pooledEmpIDs = EmployeeModelHandler.getPoolerIDs(context,</span>
<span class="nc" id="L1837">					ValueObjectUtil.getIDFromObjects(schedulingPeriods));</span>
<span class="nc" id="L1838">			Collection&lt;ID&gt; filteredPooledEmpIDs = EmployeeModelHandler.filterEmployeeIDsWithoutScheduledEventsInSP(</span>
<span class="nc" id="L1839">					context, pooledEmpIDs, campaignID, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L1840">			pooledEmpIDs.removeAll(filteredPooledEmpIDs);</span>
<span class="nc" id="L1841">			eIDs.removeAll(pooledEmpIDs);</span>
		}

<span class="nc" id="L1844">		debugLogCollection(&quot;getEmployeeIDs&quot;, &quot;eIDs&quot;, eIDs);</span>

<span class="nc" id="L1846">		log.debug(&quot;Exit MH.getEmployeeIDs&quot;);</span>
<span class="nc" id="L1847">		return eIDs;</span>
	}// getEmployeeIDs

	// For QA 53374 -Filters in My Schedule / Group / Campaign do not appear to
	// work correctly
	/*
	 * Iterates through all the sub filters and resets the filter privilege to
	 * null. This is essential because filters by default have CORE.VIEWPEOPLE
	 * privilege.
	 */
	private static void resetPrivilege(Filter filter) {
<span class="nc" id="L1858">		List&lt;String&gt; noPrivileges = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L1859">		filter.setPrivileges(noPrivileges);</span>
<span class="nc" id="L1860">		Collection colClauses = filter.getClauses();</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">		if (colClauses == null) {</span>
<span class="nc" id="L1862">			return;</span>
		}
<span class="nc bnc" id="L1864" title="All 2 branches missed.">		for (Iterator i = colClauses.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1865">			Filter filterSub = (Filter) i.next();</span>
<span class="nc" id="L1866">			filterSub.setPrivileges(noPrivileges);</span>
<span class="nc" id="L1867">		}</span>
<span class="nc" id="L1868">		return;</span>
	}

	/**
	 * get collection of Org IDs in the campaign
	 * 
	 * @param campaignID
	 * @param theTimeRange
	 */
	private static Collection&lt;ID&gt; getOrgIDsInCampaign(RequestContext context, ID campaignID, TimeRange theTimeRange)
			throws RemoteException, BbmException {
<span class="nc" id="L1879">		log.debug(&quot; MH: getOrgsInCampaign&quot;);</span>

		// @TODO: for performance optimization should be moved to the back end.
<span class="nc" id="L1882">		Collection&lt;CampaignOrg&gt; orgAssignments = CampaignModelHandler.getCampaignOrgAssignments(context, campaignID,</span>
<span class="nc" id="L1883">				theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>
<span class="nc" id="L1884">		Collection&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">		if (orgAssignments != null) {</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">			for (Iterator&lt;CampaignOrg&gt; i = orgAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1887">				CampaignOrg orgAssignment = i.next();</span>
<span class="nc" id="L1888">				orgIDs.add(orgAssignment.getOrganizationID());</span>
<span class="nc" id="L1889">			}</span>
		}
<span class="nc" id="L1891">		debugLogCollection(&quot;getOrgIDsInCampaign&quot;, &quot;orgIDs&quot;, orgIDs);</span>
<span class="nc" id="L1892">		return orgIDs;</span>
	}// getOrgIDsInCampaign

	/**
	 * make combined employee filter from two filters
	 */
	private static Filter getCombinedFilter(RequestContext context, Filter orgFilter, Filter campaignFilter) {
<span class="nc" id="L1899">		Filter filter = null;</span>
<span class="nc bnc" id="L1900" title="All 2 branches missed.">		if (campaignFilter != null) {</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">			if (orgFilter != null) {</span>
				// make combined filter
<span class="nc" id="L1903">				ArrayList&lt;Filter&gt; clauseList = new ArrayList&lt;Filter&gt;(2);</span>
<span class="nc" id="L1904">				clauseList.add(orgFilter);</span>
<span class="nc" id="L1905">				clauseList.add(campaignFilter);</span>
<span class="nc" id="L1906">				ArrayList&lt;Collection&lt;Filter&gt;&gt; params = new ArrayList&lt;Collection&lt;Filter&gt;&gt;(1);</span>
<span class="nc" id="L1907">				params.add(clauseList);</span>
<span class="nc" id="L1908">				filter = new Filter(EMP_SORT_NOT_BY_NAME, Filter.OPERATOR_AND, params);</span>
<span class="nc" id="L1909">				filter.setFilterID(null);</span>
<span class="nc" id="L1910">				filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1911">				filter.setTimePeriodType(orgFilter.getTimePeriodType());</span>
<span class="nc" id="L1912">				filter.setStartTime(orgFilter.getStartTime());</span>
<span class="nc" id="L1913">				filter.setEndTime(orgFilter.getEndTime());</span>
<span class="nc" id="L1914">			} else {</span>
<span class="nc" id="L1915">				filter = campaignFilter;</span>
			}
		} else {
<span class="nc" id="L1918">			filter = orgFilter;</span>
		}
<span class="nc" id="L1920">		return filter;</span>
	}// getCombiinedFilter

	/**
	 * get filter for Campaign ID since Filter is not Unique name we have to use
	 * full path
	 */
	private static Filter getFilterForCampaign(RequestContext context, TimeRange theTimeRange, TimeRange theDayRange,
			ID campaignID) {
<span class="nc" id="L1929">		Filter filter = null;</span>
<span class="nc bnc" id="L1930" title="All 2 branches missed.">		if (campaignID != null) {</span>
<span class="nc" id="L1931">			Collection&lt;ID&gt; colCampaigns = new LinkedList&lt;ID&gt;();</span>
<span class="nc" id="L1932">			colCampaigns.add(campaignID);</span>
<span class="nc" id="L1933">			ArrayList&lt;Collection&gt; params = new ArrayList&lt;Collection&gt;();</span>
<span class="nc" id="L1934">			params.add(colCampaigns); // filter expects nested collections</span>
<span class="nc" id="L1935">			filter = new Filter(Filter.CAMPAIGNID, Filter.OPERATOR_IN, params);</span>
<span class="nc" id="L1936">			filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1937">			filter.setStartTime(theTimeRange.getStartDate());</span>
<span class="nc" id="L1938">			filter.setEndTime(theTimeRange.getEndDate());</span>
<span class="nc" id="L1939">			filter.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>
		}
<span class="nc" id="L1941">		return filter;</span>
	}// getFilterForCampaign

	/**
	 * get filter for Org ID since Filter is not Unique name we have to use full
	 * path
	 */
	private static Filter getFilterForOrg(RequestContext context, TimeRange theTimeRange, TimeRange theDayRange,
			ID orgID) {
<span class="nc" id="L1950">		Collection&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L1951">		orgIDs.add(orgID);</span>
<span class="nc" id="L1952">		return getFilterForOrgCollection(context, theTimeRange, theDayRange, orgIDs);</span>
	}// getFilterForOrg

	/**
	 * get filter for Collection of Org IDs since Filter is not Unique name we
	 * have to use full path
	 */
	private static Filter getFilterForOrgCollection(RequestContext context, TimeRange theTimeRange,
			TimeRange theDayRange, Collection orgIDs) {
<span class="nc" id="L1961">		ArrayList&lt;Collection&gt; alParameters = new ArrayList&lt;Collection&gt;();</span>
<span class="nc" id="L1962">		alParameters.add(orgIDs);</span>
<span class="nc" id="L1963">		Filter filter = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, alParameters);</span>
<span class="nc" id="L1964">		filter.setUserID(context.getUser().getID());</span>
<span class="nc" id="L1965">		filter.setStartTime(theTimeRange.getStartDate());</span>
<span class="nc" id="L1966">		filter.setEndTime(theTimeRange.getEndDate());</span>
<span class="nc" id="L1967">		filter.setTimePeriodType(Filter.TIMEPERIODTYPE_TIMEWINDOW);</span>

<span class="nc" id="L1969">		return filter;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Employee Sorting
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * convert sortBy parameter into a filter field
	 */
	private static int makeFilterSortField(String sortBy) {
<span class="nc" id="L1979">		int result = Filter.LASTNAME;</span>

<span class="nc bnc" id="L1981" title="All 2 branches missed.">		if (!StringUtil.isEmpty(sortBy)) {</span>
<span class="nc bnc" id="L1982" title="All 2 branches missed.">			if (sortBy.equals(GroupSchedulePM.SORT_BY_FNAME)) {</span>
<span class="nc" id="L1983">				result = Filter.FIRSTNAME;</span>
<span class="nc bnc" id="L1984" title="All 2 branches missed.">			} else if (sortBy.equals(GroupSchedulePM.SORT_BY_LNAME)) {</span>
<span class="nc" id="L1985">				result = Filter.LASTNAME;</span>
			} else {
<span class="nc" id="L1987">				result = EMP_SORT_NOT_BY_NAME;</span>
			}
		}

<span class="nc" id="L1991">		return result;</span>
	}// makeFilterSortField

	/**
	 * translate Sort By parameter from the UI to the Facade string
	 */
	private static String translateSortBy(String sortUI) {
<span class="nc" id="L1998">		String result = &quot;&quot;;</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">		if (!StringUtil.isEmpty(sortUI)) {</span>
<span class="nc bnc" id="L2000" title="All 2 branches missed.">			if (sortUI.equals(GroupSchedulePM.SORT_BY_START)) {</span>
<span class="nc" id="L2001">				result = SortEvents.SORT_BY_START;</span>
<span class="nc bnc" id="L2002" title="All 2 branches missed.">			} else if (sortUI.equals(GroupSchedulePM.SORT_BY_END)) {</span>
<span class="nc" id="L2003">				result = SortEvents.SORT_BY_END;</span>
<span class="nc bnc" id="L2004" title="All 2 branches missed.">			} else if (sortUI.equals(GroupSchedulePM.SORT_BY_LENGTH)) {</span>
<span class="nc" id="L2005">				result = SortEvents.SORT_BY_LENGTH;</span>
			}
		}
<span class="nc" id="L2008">		return result;</span>
	}

	/**
	 * Sort employee IDs based on schedule
	 * 
	 * QC# 39636: Sorting schedules looks only at underlying shift and ignores
	 * timeoffs. This bug occurs because getting only the
	 * EVENT_TYPE_SHIFT_ASSIGNMENT events prevents the sort from taking time off
	 * events into consideration. But simply adding EVENT_TYPE_TIME_OFF events
	 * to the list doesn't work properly because it sorts as if the timeoffs
	 * were shifts, so if the entire day is off, it will show up at the top of
	 * the sort order (12:00 AM), rather than at the bottom with the
	 * unscheduled, unpubished, and day-off records. Another problem is that if
	 * tje &quot;Show Timeoff Events in Schedules&quot; user preference is unchecked, then
	 * the user would have no idea why these records appear at the beginning of
	 * the list, rather than at the end. To the user, the time off days (&quot;Off&quot;)
	 * are indistinguishable from the unsheduled days (&quot;Off&quot;) when the setting
	 * is unchecked.
	 * 
	 * To fix these problems, it's better to sort only by working hours, and
	 * treat timeoff time the same as unscheduled time. The fix is as follows:
	 * Before sorting, we will remove any ShiftAssignments which fall within
	 * timeoff periods from the list. If a ShiftAssignment is only partially
	 * covered by a timeoff, then we must reduce the start/end times of the
	 * shift accordingly. We must also remove the TimeOffEvents from the list
	 * before sorting.
	 */
	private static List&lt;ID&gt; sortEmpIDsPubEvents(RequestContext context, Collection&lt;ID&gt; empIDs, String sortBy,
			TimeRange theTimeRange) throws FacadeException, RemoteException, BbmException {
		try {
			// sort collection of IDs in place using schedule
<span class="nc bnc" id="L2040" title="All 2 branches missed.">			if (empIDs != null) {</span>
<span class="nc" id="L2041">				PeopleFacade facade = FacadeManagerFactory.getPeopleFacade();</span>

<span class="nc" id="L2043">				ScheduleAccessManager scheduleMgr = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L2044">				List&lt;Collection&lt;? extends Event&gt;&gt; listEvents = scheduleMgr.getPublishedEventsForWorkResourcesByType(</span>
						com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_SHIFT_ASSIGNMENT
								| com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_TIME_OFF,
<span class="nc" id="L2047">						empIDs, theTimeRange.getStartDate(), theTimeRange.getEndDate());</span>

<span class="nc bnc" id="L2049" title="All 4 branches missed.">				if (listEvents != null &amp;&amp; listEvents.size() &gt; 0) {</span>

<span class="nc" id="L2051">					ArrayList&lt;Object&gt; removeEvents = new ArrayList&lt;Object&gt;();</span>

					// BEGIN DAY LOOP
<span class="nc" id="L2054">					Calendar curDayStartCal = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L2055">							context.getLocaleContext().getRegionalFormatLocale());</span>
<span class="nc" id="L2056">					curDayStartCal.setTime(theTimeRange.getStartDate());</span>

<span class="nc" id="L2058">					Calendar curDayEndCal = Calendar.getInstance(context.getViewingTimeZone(),</span>
<span class="nc" id="L2059">							context.getLocaleContext().getRegionalFormatLocale());</span>

<span class="nc bnc" id="L2061" title="All 2 branches missed.">					while (curDayStartCal.getTime().before(theTimeRange.getEndDate())) {</span>
<span class="nc" id="L2062">						curDayEndCal.setTime(curDayStartCal.getTime());</span>
<span class="nc" id="L2063">						curDayEndCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L2064">						curDayEndCal.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L2065">						CalendarRange dayRange = new CalendarRange(curDayStartCal.getTime(), curDayEndCal.getTime(),</span>
<span class="nc" id="L2066">								context.getViewingTimeZone());</span>

						// we have a collection of collections of events
<span class="nc bnc" id="L2069" title="All 2 branches missed.">						for (Iterator it = listEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2070">							Collection listEventsSingleWorkResource = (Collection) it.next();</span>
<span class="nc bnc" id="L2071" title="All 2 branches missed.">							if (listEventsSingleWorkResource != null) {</span>
<span class="nc" id="L2072">								TimeRange reducedRange = ScheduleViewUtil.getPublishedDaySummaryType(dayRange,</span>
										listEventsSingleWorkResource, false);
<span class="nc bnc" id="L2074" title="All 2 branches missed.">								if (reducedRange == null) {</span>
									// There is either no schedule for the day,
									// or it's covered by a timeoff.
									// Remove any ShiftAssignment or
									// TimeOffEvent for this day
<span class="nc bnc" id="L2079" title="All 2 branches missed.">									if (reducedRange == null) {</span>
<span class="nc" id="L2080">										Collection shiftAssignmentEvents = ScheduleViewUtil.findShift(dayRange,</span>
												listEventsSingleWorkResource);
<span class="nc bnc" id="L2082" title="All 4 branches missed.">										if (shiftAssignmentEvents != null &amp;&amp; shiftAssignmentEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L2083" title="All 2 branches missed.">											for (Iterator saeIt = shiftAssignmentEvents.iterator(); saeIt.hasNext();) {</span>
<span class="nc" id="L2084">												Event shiftAssignmentEvent = (Event) saeIt.next();</span>
<span class="nc bnc" id="L2085" title="All 2 branches missed.">												if (shiftAssignmentEvent != null) {</span>
<span class="nc" id="L2086">													removeEvents.add(shiftAssignmentEvent);</span>
												}
<span class="nc" id="L2088">											}</span>
										}

<span class="nc" id="L2091">										Collection timeOffEvents = ScheduleViewUtil.findTimeOffEventsInRange(dayRange,</span>
												listEventsSingleWorkResource);
<span class="nc bnc" id="L2093" title="All 4 branches missed.">										if (timeOffEvents != null &amp;&amp; timeOffEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">											for (Iterator toeIt = timeOffEvents.iterator(); toeIt.hasNext();) {</span>
<span class="nc" id="L2095">												Event timeOffEvent = (Event) toeIt.next();</span>
<span class="nc bnc" id="L2096" title="All 2 branches missed.">												if (timeOffEvent != null) {</span>
<span class="nc" id="L2097">													removeEvents.add(timeOffEvent);</span>
												}
<span class="nc" id="L2099">											}</span>
										}
<span class="nc" id="L2101">									}</span>
								} else {
									// Iterate through all of the events for the
									// current employee, and find any timeoffs.
									// Also, replace original ShiftAssignments
									// with the reduced ranges
<span class="nc" id="L2107">									for (Iterator eventsIt = listEventsSingleWorkResource.iterator(); eventsIt</span>
<span class="nc bnc" id="L2108" title="All 2 branches missed.">											.hasNext();) {</span>
<span class="nc" id="L2109">										Object event = eventsIt.next();</span>
										// TBD: Do we need to consider the
										// second shift?
<span class="nc" id="L2112">										boolean foundFirstShift = false;</span>
<span class="nc bnc" id="L2113" title="All 4 branches missed.">										if (event instanceof ShiftAssignment &amp;&amp; !foundFirstShift) {</span>
<span class="nc" id="L2114">											ShiftAssignment saEventOld = (ShiftAssignment) event;</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">											if ((!saEventOld.getStartTime().equals(reducedRange.getStartDate())</span>
<span class="nc bnc" id="L2116" title="All 2 branches missed.">													|| !saEventOld.getEndTime().equals(reducedRange.getEndDate()))</span>
<span class="nc bnc" id="L2117" title="All 2 branches missed.">													&amp;&amp; !saEventOld.getStartTime().after(reducedRange.getStartDate())</span>
<span class="nc bnc" id="L2118" title="All 2 branches missed.">													&amp;&amp; !saEventOld.getEndTime().before(reducedRange.getEndDate())) {</span>
												// Reduce the ShiftAssignment's
												// range as necessary
<span class="nc" id="L2121">												saEventOld.setStartTime(reducedRange.getStartDate());</span>
<span class="nc" id="L2122">												saEventOld.setDuration((int) reducedRange.getDurationMin());</span>
											}
<span class="nc" id="L2124">											foundFirstShift = true;</span>
<span class="nc bnc" id="L2125" title="All 2 branches missed.">										} else if (event instanceof TimeOffEvent) {</span>
											// there only a timeoff on this day.
											// Remove it so we don't consider it
											// in the sort.
<span class="nc" id="L2129">											removeEvents.add(event);</span>
										}
<span class="nc" id="L2131">									}</span>
								}
							}
<span class="nc" id="L2134">						} // END DAY LOOP</span>

<span class="nc" id="L2136">						curDayStartCal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L2137">					}</span>

					// Remove the TimeOffEvents and underlying ShiftAssignment
					// events from the
					// inner collection because we don't want to sort them.
<span class="nc bnc" id="L2142" title="All 2 branches missed.">					if (removeEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L2143" title="All 2 branches missed.">						for (Iterator&lt;Object&gt; itRemove = removeEvents.iterator(); itRemove.hasNext();) {</span>
<span class="nc" id="L2144">							Object removeMe = itRemove.next();</span>

<span class="nc bnc" id="L2146" title="All 2 branches missed.">							for (Iterator outterIt = listEvents.iterator(); outterIt.hasNext();) {</span>
<span class="nc" id="L2147">								Collection listEventsSingleWorkResource = (Collection) outterIt.next();</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">								if (listEventsSingleWorkResource != null</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">										&amp;&amp; listEventsSingleWorkResource.contains(removeMe)) {</span>
<span class="nc" id="L2150">									listEventsSingleWorkResource.remove(removeMe);</span>
<span class="nc" id="L2151">									break;</span>
								}
<span class="nc" id="L2153">							}</span>
<span class="nc" id="L2154">						}</span>
					}
				}

				// Finally, sort the employee IDs corrsponding to all of the
				// remaining schedules.
				// For all of the events that we removed, the sort method will
				// automatically append
				// the employee ID's at the end if needed.
<span class="nc" id="L2163">				List&lt;ID&gt; sortedList = facade.sortEmployeeIdsByPublishedEvents(empIDs,</span>
						com.bluepumpkin.ejb.bbm.activity.model.Event.EVENT_TYPE_SHIFT_ASSIGNMENT, listEvents,
<span class="nc" id="L2165">						theTimeRange, translateSortBy(sortBy),</span>
						com.bluepumpkin.ejb.core.base.SupportNavigation.SORT_ASCENDING);

<span class="nc" id="L2168">				return sortedList;</span>
			} else {
<span class="nc" id="L2170">				return Collections.emptyList();</span>
			}
<span class="nc" id="L2172">		} catch (Exception e) {</span>
<span class="nc" id="L2173">			return null;</span>
		}
	}// sortEmpIDsPubEvents

	/**
	 * Sort Employee IDs by Name
	 */
	private static Collection&lt;ID&gt; sortEmpIDsByName(RequestContext context, ID userID, Collection&lt;ID&gt; empIDs,
			int sortField) throws RemoteException, BbmException, BbmFinderException {
<span class="nc" id="L2182">		ArrayList&lt;Collection&gt; allParams = new ArrayList&lt;Collection&gt;();</span>
<span class="nc" id="L2183">		allParams.add(empIDs);</span>

<span class="nc" id="L2185">		Filter filter = new Filter(Filter.EMPLOYEEID, Filter.OPERATOR_IN, allParams);</span>
<span class="nc" id="L2186">		filter.setUserID(userID);</span>

<span class="nc" id="L2188">		EmployeeFilter employeeFilter = EmployeeModelHandler.getEmployeeFilter(context);</span>
<span class="nc" id="L2189">		Collection&lt;Integer&gt; colSortFields = new LinkedList&lt;Integer&gt;();</span>
<span class="nc" id="L2190">		colSortFields.add(new Integer(sortField));</span>
<span class="nc bnc" id="L2191" title="All 2 branches missed.">		if (sortField == Filter.FIRSTNAME) {</span>
<span class="nc" id="L2192">			colSortFields.add(new Integer(Filter.LASTNAME));</span>
<span class="nc bnc" id="L2193" title="All 2 branches missed.">		} else if (sortField == Filter.LASTNAME) {</span>
<span class="nc" id="L2194">			colSortFields.add(new Integer(Filter.FIRSTNAME));</span>
		} else {
<span class="nc" id="L2196">			colSortFields.add(new Integer(Filter.LASTNAME));</span>
<span class="nc" id="L2197">			colSortFields.add(new Integer(Filter.FIRSTNAME));</span>
		}
<span class="nc" id="L2199">		Collection&lt;ID&gt; result = employeeFilter.getEmployeeIDs(filter, colSortFields, true, 0, Integer.MAX_VALUE);</span>

<span class="nc" id="L2201">		return result;</span>
	}

	/**
	 * Find the employee's &quot;secondary&quot; SP ID's in the aDay range. Return the SP
	 * ID collection. An employee &quot;secondary&quot; SP is one which is associated with
	 * one of the Employee's pooling Orgs, as defined in the User
	 * Managerment\Employees\Work Rules page ('Pooling Rules' section).
	 * 
	 * @param aDay
	 *            - A date range. Should be a day, but I guess it could be any
	 *            range.
	 * @param employeeID
	 *            - The ID of the employee that might be assigned to an SP in
	 *            the day range.
	 * @return A collection of the agent's &quot;primary&quot; SP ID's for the date range.
	 */
	public static Collection&lt;ID&gt; findAgentSecondarySPIDs(RequestContext context, CalendarRange aDay, ID employeeID)
			throws BbmFinderException {
<span class="nc" id="L2220">		HashSet&lt;ID&gt; secondarySPIDs = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L2221">		HashSet&lt;ID&gt; secondaryOrgIDs = new HashSet&lt;ID&gt;();</span>
		EmpWorkRuleManager ewrm;
		CampaignManager cm;
		WorkResourceManager wrm;
		try {
<span class="nc" id="L2226">			ewrm = WfmManagerFactory.getEmpWorkRuleManager(context.isInWhatIfMode());</span>
<span class="nc" id="L2227">			cm = WfmManagerFactory.getCampaignManager(context.isInWhatIfMode());</span>
<span class="nc" id="L2228">			wrm = WorkResourceModelHandler.getWorkResourceManager(context);</span>

<span class="nc bnc" id="L2230" title="All 4 branches missed.">			if (aDay != null &amp;&amp; employeeID != null) {</span>
				// Get the employee's secondary orgs
<span class="nc" id="L2232">				HashMap poolingRuleAssignments = ewrm.getPoolingRuleAssignments(Collections.singletonList(employeeID),</span>
<span class="nc" id="L2233">						aDay.getStartDate(), aDay.getEndDate());</span>
<span class="nc bnc" id="L2234" title="All 2 branches missed.">				if (poolingRuleAssignments != null) {</span>
<span class="nc" id="L2235">					for (Iterator empPoolRuleIt = poolingRuleAssignments.keySet().iterator(); empPoolRuleIt</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">							.hasNext();) {</span>
<span class="nc" id="L2237">						ID empID = (ID) empPoolRuleIt.next();</span>
<span class="nc" id="L2238">						ArrayList poolRules = (ArrayList) (poolingRuleAssignments.get(empID));</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">						if (poolRules != null) {</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">							for (Iterator prIt = poolRules.iterator(); prIt.hasNext();) {</span>
<span class="nc" id="L2241">								EmpPoolingRule poolRule = (EmpPoolingRule) prIt.next();</span>
<span class="nc" id="L2242">								secondaryOrgIDs.addAll(poolRule.getSecondaryOgs());</span>
<span class="nc" id="L2243">							}</span>
						}
<span class="nc" id="L2245">					}</span>

					// Get the SPID's for each of the secondary orgs on the day
<span class="nc bnc" id="L2248" title="All 2 branches missed.">					for (ID secondaryOrgID : secondaryOrgIDs) {</span>
<span class="nc" id="L2249">						Collection campaignOrgs = cm.getOrgCampaignAssignments(secondaryOrgID, aDay.getStartDate(),</span>
<span class="nc" id="L2250">								aDay.getEndDate());</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">						for (Iterator campOrgIt = campaignOrgs.iterator(); campOrgIt.hasNext();) {</span>
<span class="nc" id="L2252">							CampaignOrg campaignOrg = (CampaignOrg) campOrgIt.next();</span>
<span class="nc" id="L2253">							ID campaignID = campaignOrg.getCampaignID();</span>

							// Now get the SP ID's for that campaign and date
							// range
<span class="nc" id="L2257">							Collection&lt;SchedulingPeriod&gt; curSpIDs = cm.getSchedulingPeriods(campaignID, null,</span>
<span class="nc" id="L2258">									aDay.getStartDate(), aDay.getEndDate());</span>
<span class="nc bnc" id="L2259" title="All 2 branches missed.">							for (SchedulingPeriod sp : curSpIDs) {</span>
<span class="nc" id="L2260">								secondarySPIDs.add(sp.getID());</span>
<span class="nc" id="L2261">							}</span>
<span class="nc" id="L2262">						}</span>
<span class="nc" id="L2263">					}</span>
				}
			}
<span class="nc" id="L2266">		} catch (Exception ex) {</span>
<span class="nc bnc" id="L2267" title="All 2 branches missed.">			if (ex instanceof BbmFinderException) {</span>
<span class="nc" id="L2268">				throw (BbmFinderException) ex;</span>
			}
<span class="nc" id="L2270">			throw new BbmFinderException(ex);</span>
<span class="nc" id="L2271">		}</span>

<span class="nc" id="L2273">		return secondarySPIDs;</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Debug Related
	//////////////////////////////////////////////////////////////////////////////
	/** log debug message about the collection size in a specific method */
	private static void debugLogCollection(String methodName, String colName, Collection col) {
<span class="nc bnc" id="L2281" title="All 2 branches missed.">		if (col != null) {</span>
<span class="nc" id="L2282">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result size=&quot; + col.size());</span>
		} else {
<span class="nc" id="L2284">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result is null&quot;);</span>
		}
<span class="nc" id="L2286">	}</span>

	/** log debug message about the HashMap size in a specific method */
	private static void debugLogCollection(String methodName, String colName, HashMap col) {
<span class="nc bnc" id="L2290" title="All 2 branches missed.">		if (col != null) {</span>
<span class="nc" id="L2291">			debugLogCollection(methodName, colName, col.values());</span>
		} else {
<span class="nc" id="L2293">			log.debug(&quot; MH.&quot; + methodName + &quot;:&quot; + colName + &quot;: result is null&quot;);</span>
		}
<span class="nc" id="L2295">	}</span>

	/**
	 * Get the config key to indicate if the Absence reason is showed for
	 * employee's Supervisor only- For France Telecom For other customers who do
	 * not have the key, the Absent reason is showed for all people (employee's
	 * Supervisor and his colleagues) * @return boolean value for the indicator
	 * above
	 */
	public static boolean enabledAbsentReasonToOnlySupervisor() {

<span class="nc" id="L2306">		boolean result = false;</span>
		try {
<span class="nc" id="L2308">			String dbVal = BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.FS_ENABLED_SHOW_ABSENT_REASON);</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">			if (!StringUtil.isEmpty(dbVal)) {</span>
<span class="nc" id="L2310">				result = Boolean.parseBoolean(dbVal);</span>
			}
<span class="nc" id="L2312">		} catch (Exception ex) {</span>
			// ignoring any exception caught.
<span class="nc" id="L2314">		}</span>

<span class="nc" id="L2316">		return result;</span>
	}

	/**
	 * For Story 34045 -PSR 6104 - Reason for Absence viewable only by Supervisor and Employee See if the currently logged-in user is the
	 * Supervisor of the specified employee ID ..
	 *
	 * @param empID The employee ID to check.
	 * @return true if the currently logged-in user is the Supervisor of the specified employee ID .
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	protected static boolean isSupervisor(RequestContext context, ID empID, ID loggedInEmpId) {
		try {
<span class="nc" id="L2329">			ID empOrgId = OrganizationModelHandler.getEmployeeOrgID(context, empID);</span>
<span class="nc" id="L2330">			Collection&lt;ID&gt; orgIdsInScope = OrganizationModelHandler.getAllOrgIdsInUserScope(context, context.getUser());</span>
<span class="nc" id="L2331">			Employee employeeLoggIn = EmployeeModelHandler.getEmployeeByID(context, loggedInEmpId);</span>
<span class="nc bnc" id="L2332" title="All 4 branches missed.">			return employeeLoggIn.isSupervisor() &amp;&amp; orgIdsInScope.contains(empOrgId);</span>
<span class="nc" id="L2333">		} catch (Exception ex) {</span>
<span class="nc" id="L2334">			return false;</span>
		}
	}

	/**
	 * For Story 34045 -PSR 6104 - in GraphView, if detail of Time off event is not showed (just showed as Time Off), then the Legend should
	 * not show detail of TimeOff event
	 */
	private static boolean hasSecuredTimeOffEvents(RequestContext context, Collection&lt;ID&gt; employeeIDs, ID loggedInEmpId) {
<span class="nc" id="L2343">		boolean hasSecuredTimeOffEvents = false;</span>
<span class="nc" id="L2344">		boolean bEnabledAbsentReasonToOnlySupervisor = enabledAbsentReasonToOnlySupervisor();</span>
<span class="nc" id="L2345">		boolean isShowAbsentReason = true;</span>
<span class="nc bnc" id="L2346" title="All 2 branches missed.">		if (!employeeIDs.isEmpty()) {</span>
<span class="nc bnc" id="L2347" title="All 2 branches missed.">			for (ID empID : employeeIDs) {</span>
<span class="nc bnc" id="L2348" title="All 6 branches missed.">				if (bEnabledAbsentReasonToOnlySupervisor &amp;&amp; !isSupervisor(context, empID, loggedInEmpId) &amp;&amp; !loggedInEmpId.equals(empID)) {</span>
<span class="nc" id="L2349">					isShowAbsentReason = false;</span>
				}
<span class="nc bnc" id="L2351" title="All 4 branches missed.">				if (!isShowAbsentReason &amp;&amp; !hasSecuredTimeOffEvents) {</span>
<span class="nc" id="L2352">					hasSecuredTimeOffEvents = true;</span>
<span class="nc" id="L2353">					break;</span>
				}
<span class="nc" id="L2355">			}</span>
		}
<span class="nc" id="L2357">		return hasSecuredTimeOffEvents;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>