<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOAccrualLoaderForValidation.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.validation.employeehours</a> &gt; <span class="el_source">TOAccrualLoaderForValidation.java</span></div><h1>TOAccrualLoaderForValidation.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.validation.employeehours;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffAccrued;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffYearly;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOAccrual;
import com.bluepumpkin.ejb.rm.util.DateUtil;

/*
 * Returns a TOAccrual object with all the validations already done. 
 * Violations/Validation errors can be retrieved by calling TOAccrual.getViolations()/TOAccrual.getValidationResults()
 * Uses AccrualCalculatorForValidation for the accrual calculations
 */
<span class="nc" id="L35">public class TOAccrualLoaderForValidation {</span>

<span class="nc" id="L37">	private static final String CLASS_NAME = TOAccrualLoaderForValidation.class.getName();</span>
<span class="nc" id="L38">	private static Category log = Log.initCategory(CLASS_NAME);</span>

	ID lastEmployeeId;
	Date lastStart;
	Date lastEnd;
	Set&lt;ID&gt; lastActivityIds;
	Collection&lt;TOHoursPerDay&gt; lastResult;



	/*
	 * choiceHourPerDay are the hours per day for the request that we are validating
	 * 
	 * additionalChoiceHours are additional hours per day that we have to treat as scheduled hours, but which are not actually scheduled
	 * This is used when we have to approve choice groups. The additional choice hours are TOHours from the same choice group, but which
	 * are before the current request choice that we are validating.
	 */
	public TOAccrual getTOAccruedForValidation(TOHoursPerDay choiceHourPerDay,
			List&lt;TOHoursPerDay&gt; additionalChoiceHour,
			EmployeeTimeOffAccrued accruedTOFromDB,
			AccrualValidationInputs inputs,
			AccrualValidationDates validationDates) {
<span class="nc" id="L60">		TOAccrual toAccrual = null;</span>

		try {
<span class="nc" id="L63">			toAccrual = TOAccrualLoaderForValidation.getTOAccrual(accruedTOFromDB, inputs, validationDates);</span>

<span class="nc" id="L65">			toAccrual.setEmployeeTimeOffYearlyMap(getYearly(toAccrual));</span>

<span class="nc" id="L67">			Set&lt;TOHoursPerDay&gt; scheduledOrUsedTOEvents = getSchedOrUsedTOEvents(toAccrual, choiceHourPerDay, additionalChoiceHour);</span>

<span class="nc" id="L69">			AccrualCalculatorForValidation calc = new AccrualCalculatorForValidation();</span>

<span class="nc" id="L71">			toAccrual = calc.doValidations(toAccrual, scheduledOrUsedTOEvents);</span>

<span class="nc" id="L73">		} catch (Exception e) {</span>
<span class="nc" id="L74">			log.error(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L75">			throw new RmRuntimeException(RmEjbBundleKey.TO_ACCRUAL_UNKNOWN_ERROR, e);</span>
<span class="nc" id="L76">		}</span>
<span class="nc" id="L77">		return toAccrual;</span>
	}

	// Note this adjusts toAccrual.endDate
	private Set&lt;TOHoursPerDay&gt; getSchedOrUsedTOEvents(TOAccrual toAccrual, TOHoursPerDay choiceHourPerDay,
			List&lt;TOHoursPerDay&gt; additionalChoiceHours)
			throws Exception { // NOSONAR

<span class="nc bnc" id="L85" title="All 2 branches missed.">		if (toAccrual.getHrsPerDaySet() != null) {</span>
<span class="nc" id="L86">			return toAccrual.getHrsPerDaySet();</span>
		}

		//The key for hour per day is TOEvent and TOChoiceID. 
<span class="nc" id="L90">		TreeSet&lt;TOHoursPerDay&gt; schedOrUsedTOEventSet = new TreeSet&lt;TOHoursPerDay&gt;();</span>


		//why do this? if there are choice hours we go till the end of time? why?
<span class="nc bnc" id="L94" title="All 2 branches missed.">		Date endDate = choiceHourPerDay != null ? RequestUtil.MAX_DATE : toAccrual.endDate;</span>
<span class="nc" id="L95">		Collection&lt;TOHoursPerDay&gt; schedOrUsedTOEvents = getHoursPerDayForCalendar(toAccrual.getEmployeeID(), toAccrual.startDate, endDate,</span>
<span class="nc" id="L96">				toAccrual.getActivityIDs());</span>

		//Hrs Per Day need to be sorted by start time
<span class="nc" id="L99">		schedOrUsedTOEventSet.addAll(schedOrUsedTOEvents);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">		if (choiceHourPerDay != null) {</span>

<span class="nc bnc" id="L102" title="All 2 branches missed.">			if (!schedOrUsedTOEventSet.isEmpty()) {</span>

<span class="nc" id="L104">				TOHoursPerDay hoursPerDay = schedOrUsedTOEventSet.last();</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">				if (hoursPerDay.getEndTime().after(toAccrual.endDate)) {</span>
<span class="nc" id="L107">					toAccrual.endDate = new Date(hoursPerDay.getEndTime().getTime());</span>
				}

			}

<span class="nc" id="L112">			schedOrUsedTOEventSet.add(choiceHourPerDay);</span>
		}

<span class="nc" id="L115">		schedOrUsedTOEventSet.addAll(additionalChoiceHours);</span>
<span class="nc" id="L116">		return schedOrUsedTOEventSet;</span>
	}


	@SuppressWarnings(&quot;unchecked&quot;)
	private Collection&lt;TOHoursPerDay&gt; getHoursPerDayForCalendar(ID employeeId, Date startDate, Date endDate, Set&lt;ID&gt; activityIds)
			throws Exception {

<span class="nc bnc" id="L124" title="All 2 branches missed.">		if (canUseLastLoaded(employeeId, startDate, endDate, activityIds)) {</span>
<span class="nc" id="L125">			return deepCopyLastResult(startDate, endDate);</span>
		}

<span class="nc" id="L128">		lastResult = getHoursPerDayForCalendarFromManager(employeeId, startDate, endDate, activityIds);</span>

<span class="nc" id="L130">		lastEmployeeId = employeeId;</span>
<span class="nc" id="L131">		lastStart = new Date(startDate.getTime());</span>
<span class="nc" id="L132">		lastEnd = new Date(endDate.getTime());</span>
<span class="nc" id="L133">		lastActivityIds = new HashSet&lt;ID&gt;(activityIds);</span>

<span class="nc" id="L135">		return deepCopyLastResult(startDate, endDate);</span>
	}

	private boolean canUseLastLoaded(ID employeeId, Date startDate, Date endDate, Set&lt;ID&gt; activityIds) {
<span class="nc bnc" id="L139" title="All 4 branches missed.">		if (lastEmployeeId == null || !lastEmployeeId.equals(employeeId)) {</span>
<span class="nc" id="L140">			return false;</span>
		}

<span class="nc bnc" id="L143" title="All 4 branches missed.">		return DateUtil.interval1CoversInterval2(lastStart, lastEnd, startDate, endDate) &amp;&amp; lastActivityIds.equals(activityIds);</span>

	}

	private List&lt;TOHoursPerDay&gt; deepCopyLastResult(Date startDate, Date endDate) {
<span class="nc" id="L148">		List&lt;TOHoursPerDay&gt; result = new ArrayList&lt;TOHoursPerDay&gt;(lastResult.size());</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">		for (TOHoursPerDay hoursPerDay : lastResult) {</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">			if (DateUtil.intervalsIntersect(startDate, endDate, hoursPerDay.getStartTime(), hoursPerDay.getEndTime())) {</span>
<span class="nc" id="L151">				TOHoursPerDay copy = hoursPerDay.deepCopy();</span>
<span class="nc" id="L152">				result.add(copy);</span>
			}
<span class="nc" id="L154">		}</span>
<span class="nc" id="L155">		return result;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private static Collection&lt;TOHoursPerDay&gt; getHoursPerDayForCalendarFromManager(ID employeeId, Date startDate, Date endDate,
			Set&lt;ID&gt; activityIds)
			throws Exception { // NOSONAR
<span class="nc" id="L162">		TOHoursPerDayManager hoursPerDayManager = RmManagerFactory.getInstance().getTOHoursPerDayManager(null, null);</span>
<span class="nc" id="L163">		return hoursPerDayManager.getHoursPerDayForCalendar(</span>
<span class="nc" id="L164">				Collections.singletonList(employeeId),</span>
				startDate, endDate, activityIds,
				//scheduled hour per day (the one with a non-null TIMEOFFEVENTID)
				true);

	}


	private static Map&lt;String, EmployeeTimeOffYearly&gt; getYearly(TOAccrual toAccrual) {
		
<span class="nc" id="L174">		ID employeeID = toAccrual.getEmployeeID();</span>
<span class="nc" id="L175">		ID activityID = toAccrual.getActivityID();</span>
<span class="nc" id="L176">		ID activityCategoryID = toAccrual.getActivityCategoryID();</span>
		
<span class="nc" id="L178">		Calendar cal = Calendar.getInstance(toAccrual.org.getTimeZone());</span>
<span class="nc" id="L179">		cal.setTime(toAccrual.startDate);</span>
<span class="nc" id="L180">		int fromYear = cal.get(Calendar.YEAR) - 2;</span>
<span class="nc" id="L181">		cal.setTime(toAccrual.endDate);</span>
<span class="nc" id="L182">		int toYear = cal.get(Calendar.YEAR);</span>
		
<span class="nc" id="L184">		return EmployeeTimeOffYearlyCache.getEmployeeTimeOffYearly(employeeID, activityID, activityCategoryID, fromYear, toYear);</span>
	}


	private static TOAccrual getTOAccrual(EmployeeTimeOffAccrued accruedTOFromDB, AccrualValidationInputs inputs,
			AccrualValidationDates validationDates)
			throws Exception { // NOSONAR



<span class="nc bnc" id="L194" title="All 4 branches missed.">		if (!inputs.isValid() || validationDates == null) {</span>
<span class="nc" id="L195">			log.info(&quot;TimeOff Accrual Calc invalid data received&quot;);</span>
<span class="nc" id="L196">			TOAccrual toAccrual = new TOAccrual();</span>
<span class="nc" id="L197">			ValidationUtil.setHardValidationResult(toAccrual, RmEjbBundleKey.TO_ACCRUAL_INVALID_DATA, null, CLASS_NAME);</span>
<span class="nc" id="L198">			return toAccrual;</span>
		}


<span class="nc" id="L202">		ValidationResult result = null;</span>
<span class="nc bnc" id="L203" title="All 2 branches missed.">		if (inputs.activityBalance == null) {</span>
<span class="nc" id="L204">			result = ValidationUtil.getValidationResult(RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.TO_ACCRUAL_ACTIVITY_TO_BAL_NA, null,</span>
					CLASS_NAME, true);
		}


		// No Last updated balance available and No Activity Time Off Balance settings exist for this activity / act Cat. 
		//This will enforce the Max Carry Over to 0 and the Hours will be calculated from start of employee's TO Year
<span class="nc bnc" id="L211" title="All 6 branches missed.">		if (accruedTOFromDB == null &amp;&amp; inputs.activityBalance != null &amp;&amp; inputs.activityBalance.getID() == null) {</span>
<span class="nc" id="L212">			inputs.activityBalance.setMaxCarryOver(0);</span>
		}

		//accruedTOFromDB's getAccruedHours is used to set the newly created toAccrual's estimated accrual hours
		//TOAccrual's start will be set to accruedTO.getAccruedAtDate() if  accruedTOFromDB is not null.
<span class="nc" id="L217">		TOAccrual toAccrual = TOAccrual.getTOAccrualRow(</span>
				inputs.employee,
<span class="nc" id="L219">				inputs.getActivity(),</span>
<span class="nc" id="L220">				inputs.getActivityCategory(),</span>
				inputs.activityBalance,
				accruedTOFromDB,
				inputs.employeeTimeOffYearStart,
<span class="nc" id="L224">				inputs.employee.getID(),</span>
				inputs.employeeOrganization,
<span class="nc" id="L226">				validationDates.getValidationStart(),</span>
<span class="nc" id="L227">				validationDates.getValidationEnd());</span>

<span class="nc bnc" id="L229" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L230">			toAccrual.addValidationResult(result);</span>
		} else {
<span class="nc" id="L232">			toAccrual.setActivityIDs(inputs.activityIDs);</span>
		}

<span class="nc" id="L235">		return toAccrual;</span>
	}



}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>