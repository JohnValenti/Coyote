<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidAuctionManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb</a> &gt; <span class="el_source">ShiftBidAuctionManagerEJB.java</span></div><h1>ShiftBidAuctionManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb;

import static com.bluepumpkin.ejb.rm.util.DAOUtil.cleanUp;
import static com.bluepumpkin.ejb.rm.util.RmUtil.disableThreadLocalCacheIf;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignOrgFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResourceFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeType;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuctionFieldInfo;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableScheduleDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.BiddableScheduleMiscDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidderDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.bidoptionsloaderdao.BiddableScheduleLoaderDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BidOptionRow;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.BiddableScheduleRow;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidderFieldInfo;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.ShiftBidAuctionUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;

/**
 * &lt;b&gt;Serialized Auctions&lt;/b&gt;
 * &lt;p&gt;
 * Serialization Events:
 * &lt;li&gt;start or stop serialzation (from UI)
 * &lt;li&gt;current shift bidder deadline has expired (periodic poller thread)
 * &lt;li&gt;current shift bidder request approved/denied (on request submission &amp;
 * auto processing).
 *
 * &lt;p&gt;
 * Serialization implementation: &lt;br&gt;
 *
 * &lt;p&gt;
 * start serialization: &lt;br&gt;
 * 1. Rank unadded bidders.&lt;br&gt;
 * 2. Add first bidder as current bidder.&lt;br&gt;
 * 3. Notify current bidder.&lt;br&gt;
 * 4. Note current bidder in DB and set bidder's deadline.&lt;br&gt;
 *
 * &lt;p&gt;
 * current ShiftBidder's Deadline expires: &lt;br&gt;
 * Same as 'start serialization'.
 *
 * &lt;p&gt;
 * current ShiftBidder's request is submitted and processed (approved/denied).
 * &lt;br&gt;
 * Same as 'start serialization'
 *
 * &lt;p&gt;
 * DB Table: AuctionSerialization
 * &lt;li&gt;ID
 * &lt;li&gt;auctionID
 * &lt;li&gt;currentBidderID
 * &lt;li&gt;isEnabled.
 *
 * &lt;p&gt;
 * &lt;b&gt;Bonus and Score in auctions:&lt;/b&gt;
 * &lt;p&gt;
 * An auction has several bonuses specified. Following is a list of these:
 * &lt;li&gt;&quot;Accumulated bonus&quot; associated with an employee (and hence a shift
 * bidder). Used to compute the score for the bidder's shift bid request. see
 * below.
 * &lt;li&gt;&quot;No Bid bonus&quot; specified when the auction is created. This bonus is added
 * to the bidder's &quot;accumulated bonus&quot;, when the auction is closed, if the
 * bidder was unsuccessful in getting any of his bid approved.
 * &lt;li&gt;&quot;BiddableSchedule bonus&quot; assigned to biddable schedules. This bonus is
 * added to the &quot;accumulated bonus&quot; when the bidder's shift bid request is
 * approved. Bonuses from the biddable schedules for the shift bid request are
 * added to the &quot;accumulated bonus&quot;.
 * &lt;li&gt;&quot;ShiftBidder bonus&quot; assigned to shift bidders. Used in computing the
 * score for a shift bid request. This bonus is not added to the &quot;accumulated&quot;
 * bonus. See below.
 *
 * &lt;p&gt;
 * Score is a weighted sum computed using the bonus, rank and seniority of an
 * employee. The bonus used in this computation is the sum of the accumulated
 * bonus and shift bidder bonus. The score is used to compute the rank of a
 * shift bid request among the requests submitted for the same biddable
 * schedule(s) as this request.
 *
 * &lt;p&gt;
 * &quot;Auction uses scoring&quot; flag: If flag is disabled then:
 * &lt;li&gt;Shift bid requests created for the auction cannot specify &quot;use bonus&quot; for
 * score and rank computation of request
 * &lt;li&gt;Shift bid requests do have an assigned &quot;rank&quot; and &quot;score&quot;.
 * &lt;li&gt;Serialized Auctions cannot use the score to serialize shift bidders.
 *
 * &lt;p&gt;
 * Note that if &quot;Auction uses scoring&quot; flag is false for an auction does not
 * mean the auction does not use 'bonus' points. Bonuses may be used for the
 * following cases:
 * &lt;li&gt;adding bidders to serialized auctions by ranking them using their bonus.
 * This means that even for an auction with &quot;does not use scoring&quot;, &quot;bonus&quot; can
 * be used as a ranking criteria for adding bidders to the auction serially.
 * &lt;li&gt;bonuses can be assigned to shift bidders and biddable schedules. See
 * above for how these bonuses are used.
 *
 * &lt;p&gt;
 * &quot;ShiftBid Request uses bonus&quot; flag: If enabled, then the bidder's
 * &quot;accumulated bonus&quot; is used in computing the score and rank for the request.
 * If &quot;auction uses scoring&quot; is off, then this will also be automatically turned
 * off.
 *
 * &lt;p&gt;
 * &lt;b&gt;ShiftBidders in auction:&lt;/b&gt;
 * &lt;p&gt;
 * A shift bidder can participate in an auction only if he does not have any
 * shifts during the auction period. Corollaries of this rule are:
 * &lt;li&gt;ShiftBidRequest hard validation rule must check if the bidder has any
 * shifts during the auction period.
 * &lt;li&gt;On approval of a shift bid request, all other shift bid requests for the
 * same employee must be marked invalid.
 * &lt;li&gt;On approval of a shift bid request, bidder must be marked 'scheduled'. A
 * 'scheduled' bidder cannot be added to the auction.
 *
 * &lt;p&gt;
 * &lt;b&gt;ShiftBidder Status&lt;/b&gt;
 * &lt;li&gt;ADDED
 * &lt;li&gt;NOT_ADDED
 * &lt;li&gt;SCHEDULED
 * &lt;li&gt;SUBMITTED When a new shift bid request is created, state switched from
 * Added -&gt; Submitted.&lt;br&gt;
 * When shift bid request is approved, moves from submitted -&gt; scheduled.&lt;br&gt;
 * when shift bid request is denied, invalidated, withdrawn or expires, and
 * bidder state == 'submitted', then bidder state transistions from Submitted -&gt;
 * Added. If bidder state == 'unadded' or 'scheduled', then status transition is
 * not allowed.&lt;br&gt;
 *
 * &lt;p&gt;
 * Status transition validation must happen when:
 * &lt;li&gt;shiftBidder is updated from UI.
 * &lt;li&gt;shiftBidder added to auction when serializedAuction is in progress.
 *
 * Title: ShiftBidAuctionManagerEJB Description: EJB for ShiftBidAuction
 * Copyright: Copyright (c) 2002 Company: Blue Pumpkin Software, Inc.
 *
 * @author Jagdish Seelam
 * @version 1.0
 */
<span class="nc bnc" id="L194" title="All 2 branches missed.">public class ShiftBidAuctionManagerEJB extends SessionEJBBase implements IShiftBidAuctionManager { // OUTSIDE_CONTAINER</span>
	// public class ShiftBidAuctionManagerEJB extends SessionEjbBaseForTest
	// implements ShiftBidAuctionManager { //OUTSIDE_CONTAINER

<span class="nc" id="L198">	private static final String CLASS_NAME = ShiftBidAuctionManagerEJB.class.getName();</span>

<span class="nc" id="L200">	private static final Category m_cat = Log.initCategory(CLASS_NAME);</span>

<span class="nc" id="L202">	private static final Pair m_emptyCollsPair = new Pair(Collections.emptyList(), Collections.emptyList());</span>

	/**
	 * Do not access this member variable directly. Use the synchronized methods
	 * below.
	 * &lt;p&gt;
	 * Maintains a map of auction ID to last time the auction was synchronized
	 * to SP (for phantom schedule changes) using the schedule change audit
	 * trail in BBM.
	 */
<span class="nc" id="L212">	private static Map m_aucIDToLastSynchTimeUsingAuditTrailMap = new HashMap(32);</span>

	private static final short CPG_SCOPE = (short) 3;

	{ // instance initializer
<span class="nc" id="L217">		super.init(CLASS_NAME);</span>
	}

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="nc" id="L223">		return m_cat;</span>
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#createAuction(com.bluepumpkin.ejb.rm.requests.
	 * shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	@Override
	public ID createAuction(ShiftBidAuction sbAuctionVO) throws BbmCreateException, RmHardValidationException {
<span class="nc" id="L235">		String _method_ = &quot;createAuction&quot;;</span>
<span class="nc" id="L236">		methodStart(_method_, sbAuctionVO);</span>

<span class="nc" id="L238">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L239">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L240">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L241">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L243">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// get SP associated with auction
<span class="nc" id="L246">			ID spID = sbAuctionVO.getSPID();</span>
<span class="nc" id="L247">			CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L248">			SchedulingPeriod schedPeriod = campMgr.getSchedulingPeriodByID(spID);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (schedPeriod == null) {</span>
<span class="nc" id="L250">				throw RequestUtil.createRmException(RmEjbLogBundleKey.SPID_INVALID, spID, m_cat);</span>
			}

			// cache the scheduling period's start and end time in the shiftbid
			// auction VO.
<span class="nc" id="L255">			sbAuctionVO.getSetters().setSchedulingPeriodStartTime(schedPeriod.getStartTime());</span>
<span class="nc" id="L256">			sbAuctionVO.getSetters().setSchedulingPeriodEndTime(schedPeriod.getEndTime());</span>
<span class="nc" id="L257">			sbAuctionVO.getSetters().setCampaignID(schedPeriod.getCampaignID());</span>

<span class="nc" id="L259">			assignDefaultsForAuctionVO(sbAuctionVO);</span>

			// validate the auction
<span class="nc" id="L262">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L263">			bidderDAO = new ShiftBidderDAO(auctionDao.getDMO(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L264">			validateAuction(sbAuctionVO, null, RequestUtil.ACTION_CREATE, auctionDao, bidderDAO);</span>

<span class="nc" id="L266">			ID auctionID = auctionDao.createAuction(sbAuctionVO);</span>

			//create biddable schedules and populate the schedule snapshot tables
<span class="nc" id="L269">			BiddableScheduleMiscDAO.createBiddableSchedules(auctionDao.getDMO(), auctionID);</span>

			// create the shiftBidders
<span class="nc" id="L272">			Collection bidders = compileShiftBiddersForAuction(sbAuctionVO, schedPeriod, campMgr, bidderDAO);</span>
<span class="nc" id="L273">			bidderDAO.createShiftBidders(bidders);</span>

<span class="nc" id="L275">			return auctionID;</span>
<span class="nc" id="L276">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L277">			m_cat.error(e, e);</span>
<span class="nc" id="L278">			handleException(e);</span>
<span class="nc" id="L279">			throw e;</span>
<span class="nc" id="L280">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L282">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L283">			throw e;</span>
<span class="nc" id="L284">		} catch (Exception e) {</span>
<span class="nc" id="L285">			handleException(e);</span>
<span class="nc" id="L286">			throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc" id="L289">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L290">			cleanUp(bidderDAO);</span>
<span class="nc" id="L291">			cleanUp(auctionDao);</span>
<span class="nc" id="L292">			methodFinish();</span>
		}
	}

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateAuction(com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	@Override
	public void updateAuction(ShiftBidAuction auction)
			throws MultiUserException, BbmUpdateException, RmHardValidationException {

<span class="nc" id="L303">		String _method_ = &quot;updateAuction&quot;;</span>
<span class="nc" id="L304">		methodStart(_method_, auction);</span>
<span class="nc" id="L305">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L306">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L308">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L310">			_updateAuction(auction, null, null);</span>
<span class="nc" id="L311">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L312">			m_cat.error(e, e);</span>
<span class="nc" id="L313">			handleException(e);</span>
<span class="nc" id="L314">			throw e;</span>
<span class="nc" id="L315">		} catch (MultiUserException e) {</span>
<span class="nc" id="L316">			m_cat.error(e, e);</span>
<span class="nc" id="L317">			handleException(e);</span>
<span class="nc" id="L318">			throw e;</span>
<span class="nc" id="L319">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L320">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L321">			throw e;</span>
<span class="nc" id="L322">		} catch (Exception e) {</span>
<span class="nc" id="L323">			handleException(e);</span>
<span class="nc" id="L324">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L326">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L327">			methodFinish();</span>
<span class="nc" id="L328">		}</span>
<span class="nc" id="L329">	}</span>

	protected static class BiddableScheduleInstanceKey {
		protected String m_md5Hash;
		protected ID m_phantomEmpID;

		/**
		 * @param md5Hash
		 * @param phantomEmpID
		 */
<span class="nc" id="L339">		public BiddableScheduleInstanceKey(String md5Hash, ID phantomEmpID) {</span>
<span class="nc" id="L340">			m_md5Hash = md5Hash;</span>
<span class="nc" id="L341">			m_phantomEmpID = phantomEmpID;</span>
<span class="nc" id="L342">		}</span>

		/**
		 * define equals operation for instances of this class. Without this
		 * definition, using an instance of this class as a 'key' in a 'Map'
		 * will not work.
		 *
		 * @see java.lang.Object#equals(java.lang.Object)
		 */
		@Override
		public boolean equals(Object obj) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if (!(obj instanceof BiddableScheduleInstanceKey)) {</span>
<span class="nc" id="L354">				return false;</span>
			}

<span class="nc" id="L357">			BiddableScheduleInstanceKey other = (BiddableScheduleInstanceKey) obj;</span>
<span class="nc bnc" id="L358" title="All 4 branches missed.">			return (m_phantomEmpID.equals(other.m_phantomEmpID) &amp;&amp; (m_md5Hash.equals(other.m_md5Hash)));</span>
		}

		/**
		 * hashCode is redefined to satisfy the following rule (see javadoc for
		 * Object.hashCode()):
		 * &lt;li&gt;If two objects are equal according to the equals(Object) method,
		 * then calling the hashCode method on each of the two objects must
		 * produce the same integer result
		 *
		 * @see java.lang.Object#hashCode()
		 */
		@Override
		public int hashCode() {
			// m_md5Hash member of this instance is ignored when computing the
			// hashCode for simplicity.
			// This will result in the same hashCode for all instances with same
			// m_phantomID but different
			// 'm_md5Hash' values . As a result, the map performance might be
			// slightly slower.
<span class="nc" id="L378">			return m_phantomEmpID.hashCode();</span>
		}

		/*
		 * (non-Javadoc)
		 *
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
<span class="nc" id="L388">			return &quot;m_md5Hash = &quot; + m_md5Hash + &quot; m_phantomEmpID = &quot; + m_phantomEmpID;</span>
		}
	}

<span class="nc" id="L392">	static class DAOCache {</span>
		private ShiftBidAuctionDAO m_shiftBidAuctionDAO;
		private BiddableScheduleDAO m_biddableScheduleDAO;

		/**
		 * @return
		 */
		public BiddableScheduleDAO getBiddableScheduleDAO() {
<span class="nc bnc" id="L400" title="All 2 branches missed.">			m_biddableScheduleDAO = (m_biddableScheduleDAO == null) ? new BiddableScheduleDAO(BiddableSchedule.DL_BASIC)</span>
					: m_biddableScheduleDAO;

<span class="nc" id="L403">			return m_biddableScheduleDAO;</span>
		}



		/**
		 * @return
		 */
		public ShiftBidAuctionDAO getShiftBidAuctionDAO() {
<span class="nc bnc" id="L412" title="All 2 branches missed.">			m_shiftBidAuctionDAO = (m_shiftBidAuctionDAO == null) ? new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC)</span>
					: m_shiftBidAuctionDAO;

<span class="nc" id="L415">			return m_shiftBidAuctionDAO;</span>
		}

		public void cleanUp() {
<span class="nc bnc" id="L419" title="All 2 branches missed.">			if (m_shiftBidAuctionDAO != null) {</span>
<span class="nc" id="L420">				m_shiftBidAuctionDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L422" title="All 2 branches missed.">			if (m_biddableScheduleDAO != null) {</span>
<span class="nc" id="L423">				m_biddableScheduleDAO.cleanUp();</span>
			}

<span class="nc" id="L426">		}</span>
	}

	/**
	 * Return the employee types that for the given Scheduling Period SID
	 * 
	 * @param sid ID of the Scheduling Period
	 * @return A collection of employee types for the orgs associated to a scheduling period
	 * @throws Exception General Exception
	 * @throws BbmFinderException Exception if the sid is not found.
	 */
	@Override
	public Collection&lt;EmployeeType&gt; getEmployeeTypeForSPBySID(ID sid) throws Exception, BbmFinderException {
<span class="nc" id="L439">		Collection&lt;ID&gt; orgs = Collections.emptyList();</span>
<span class="nc" id="L440">		CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L441">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc" id="L443">		orgs = campMgr.getSchedulingPeriodOrgs(sid, orgs);</span>
<span class="nc" id="L444">		return wrm.getEmployeeType(orgs);</span>
	}



	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#openAuction(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void openAuction(ID auctionID) throws BbmUpdateException, RmHardValidationException {

<span class="nc" id="L458">		String _method_ = &quot;openAuction&quot;;</span>
<span class="nc" id="L459">		methodStart(_method_, auctionID);</span>
<span class="nc" id="L460">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L461">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L463">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L465">			_updateAuctionByID(auctionID, ShiftBidAuctionFieldInfo.SHIFTBIDAUCTION_N_STATUS,</span>
					new Integer(ShiftBidAuction.STATUS_OPEN_FOR_BIDDING), null);
<span class="nc" id="L467">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L468">			m_cat.error(e, e);</span>
<span class="nc" id="L469">			handleException(e);</span>
<span class="nc" id="L470">			throw e;</span>
<span class="nc" id="L471">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L473">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L474">			throw e;</span>
<span class="nc" id="L475">		} catch (Exception e) {</span>
<span class="nc" id="L476">			handleException(e);</span>
<span class="nc" id="L477">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L479">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L480">			methodFinish();</span>
<span class="nc" id="L481">		}</span>
<span class="nc" id="L482">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#closeAuction(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void closeAuction(ID auctionID, boolean addNoneApprBonus)
			throws BbmUpdateException, RmHardValidationException {

<span class="nc" id="L494">		String _method_ = &quot;closeAuction&quot;;</span>
<span class="nc" id="L495">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L497">		ShiftBidAuctionDAO sbAucDAO = null;</span>
<span class="nc" id="L498">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L499">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L500">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L502">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// now update the auction status to 'closed'.
<span class="nc bnc" id="L505" title="All 2 branches missed.">			sbAucDAO = (sbAucDAO == null) ? new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC) : sbAucDAO;</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">			if (addNoneApprBonus) {</span>
				// get IDs for bidders who submitted a bid but did not get it
				// approved.
<span class="nc bnc" id="L509" title="All 2 branches missed.">				bidderDAO = (bidderDAO == null) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>
<span class="nc" id="L510">				addNoneApprovedBonus(auctionID, sbAucDAO, bidderDAO);</span>
			}

<span class="nc" id="L513">			_updateAuctionByID(auctionID, ShiftBidAuctionFieldInfo.SHIFTBIDAUCTION_N_STATUS,</span>
					new Integer(ShiftBidAuction.STATUS_CLOSED_FOR_BIDDING), sbAucDAO);
<span class="nc" id="L515">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L516">			m_cat.error(e, e);</span>
<span class="nc" id="L517">			handleException(e);</span>
<span class="nc" id="L518">			throw e;</span>
<span class="nc" id="L519">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L521">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L522">			throw e;</span>
<span class="nc" id="L523">		} catch (Exception e) {</span>
<span class="nc" id="L524">			handleException(e);</span>
<span class="nc" id="L525">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L527">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L528">			cleanUp(bidderDAO);</span>
<span class="nc" id="L529">			cleanUp(sbAucDAO);</span>
<span class="nc" id="L530">			methodFinish();</span>
<span class="nc" id="L531">		}</span>
<span class="nc" id="L532">	}</span>

	private void addNoneApprovedBonus(ID auctionID, ShiftBidAuctionDAO sbAucDAO, ShiftBidderDAO bidderDAO)
			throws Exception {

		// get all bidders who made a bid but none of it was approved.
<span class="nc" id="L538">		List noneApprBidderIDs = bidderDAO.getShiftBidderIDsWithNoApprovedBids(auctionID);</span>

		// if we found any 'none approved' bidders
<span class="nc bnc" id="L541" title="All 2 branches missed.">		if (!noneApprBidderIDs.isEmpty()) {</span>
			// fetch the 'none approved bonus' from the auction.
<span class="nc" id="L543">			ShiftBidAuction sbAuc = sbAucDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L544">			int noneApprBonus = sbAuc.getBonusForNoBidsAccepted();</span>

			// fetch the bidder objects.
<span class="nc" id="L547">			Collection noneApprBidders = bidderDAO.getShiftBiddersByIDs(noneApprBidderIDs, false,</span>
					ShiftBidder.DL_BASIC | ShiftBidder.DL_EMPLOYEE);

			// iterate and apply 'none approved bonus'
<span class="nc bnc" id="L551" title="All 2 branches missed.">			for (Iterator noneApprBiddersIter = noneApprBidders.iterator(); noneApprBiddersIter.hasNext();) {</span>
<span class="nc" id="L552">				ShiftBidder noneApprBidder = (ShiftBidder) noneApprBiddersIter.next();</span>

<span class="nc" id="L554">				Employee bidderEmp = noneApprBidder.getOptMethods().getEmployee();</span>
<span class="nc" id="L555">				bidderEmp.setAssignedPoints(bidderEmp.getAssignedPoints() + noneApprBonus);</span>

<span class="nc" id="L557">				noneApprBidder.getSetters().updateEmployee(bidderEmp);</span>
<span class="nc" id="L558">			}</span>

			// Note: we update directly using the DAO instead of using
			// ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate()
			// since only the employee object is updated and validation of
			// shiftBidder is not necessary.
<span class="nc" id="L564">			bidderDAO.updateShiftBidders(noneApprBidders);</span>
		}
<span class="nc" id="L566">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#deleteAuctions(java.util.Collection)
	 */
	@Override
	public void deleteAuctions(Collection idsToDelete) throws BbmRemoveException, RmHardValidationException {

<span class="nc" id="L577">		String _method_ = &quot;deleteAuctions&quot;;</span>
<span class="nc" id="L578">		methodStart(_method_, idsToDelete);</span>
<span class="nc" id="L579">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L580">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L581">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L583">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L585">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L586">			auctionDao.deleteAuctions(idsToDelete);</span>
<span class="nc" id="L587">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L588">			m_cat.error(e, e);</span>
<span class="nc" id="L589">			handleException(e);</span>
<span class="nc" id="L590">			throw e;</span>
<span class="nc" id="L591">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L593">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L594">			throw e;</span>
<span class="nc" id="L595">		} catch (Exception e) {</span>
<span class="nc" id="L596">			handleException(e);</span>
<span class="nc" id="L597">			throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L599">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L600">			cleanUp(auctionDao);</span>
<span class="nc" id="L601">			methodFinish();</span>
<span class="nc" id="L602">		}</span>
<span class="nc" id="L603">	}</span>

	/**
	 * @param detailLevel
	 *            see {@link ShiftBidAuction ShiftBidAuction} for detailLevel
	 *            constants.
	 */
	@Override
	public ShiftBidAuction getAuctionByID(ID auctionID, long detailLevel)
			throws BbmFinderException, RmHardValidationException {

<span class="nc" id="L614">		String _method_ = &quot;getAuctionByID&quot;;</span>
<span class="nc" id="L615">		methodStart(_method_, auctionID, new Long(detailLevel));</span>
<span class="nc" id="L616">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L617">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L619">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L621">			return ShiftBidAuctionUtil._getAuctionByID(auctionID, detailLevel);</span>
<span class="nc" id="L622">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L623">			m_cat.error(e, e);</span>
<span class="nc" id="L624">			handleException(e);</span>
<span class="nc" id="L625">			throw e;</span>
<span class="nc" id="L626">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L628">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L629">			throw e;</span>
<span class="nc" id="L630">		} catch (Exception e) {</span>
<span class="nc" id="L631">			handleException(e); // TODO: is transaction supported</span>
<span class="nc" id="L632">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L634">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L635">			methodFinish();</span>
		}
	}

	/**
	 * @param detailLevel
	 *            see {@link ShiftBidAuction ShiftBidAuction} for detailLevel
	 *            constants.
	 */
	@Override
	public Collection getAuctionsByIDs(Collection auctionIDs, long detailLevel) throws BbmFinderException {

<span class="nc" id="L647">		String _method_ = &quot;getAuctionByID&quot;;</span>
<span class="nc" id="L648">		methodStart(_method_, auctionIDs, new Long(detailLevel));</span>
<span class="nc" id="L649">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L650">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L651">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L653">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L655">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L656">			return auctionDao.getAuctionsByIDs(auctionIDs, detailLevel);</span>
<span class="nc" id="L657">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L658">			m_cat.error(e, e);</span>
<span class="nc" id="L659">			handleException(e);</span>
<span class="nc" id="L660">			throw e;</span>
<span class="nc" id="L661">		} catch (Exception e) {</span>
<span class="nc" id="L662">			handleException(e);</span>
<span class="nc" id="L663">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L665">			cleanUp(auctionDao);</span>
<span class="nc" id="L666">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L667">			methodFinish();</span>
		}
	}

	/**
	 * Returns the list of auctions associated with campaigns for which employee
	 * has FS_VIEWCAMPAIGN privilege. Used by the webtier to retrieve a list of
	 * auctions for a manager.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getAuctionsForEmployee(com.bluepumpkin.common.datatypes.ID,
	 *      long)
	 */
	@Override
	public Collection getAuctionsForManagerEmpID(ID empID, long detailLevel)
			throws RmException, RmHardValidationException {
<span class="nc" id="L682">		String _method_ = &quot;getAuctionsForEmployee&quot;;</span>
<span class="nc" id="L683">		methodStart(_method_, empID, new Long(detailLevel));</span>
<span class="nc" id="L684">		ShiftBidAuctionDAO auctionDao = null;</span>

<span class="nc" id="L686">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L687">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L689">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L691">			Collection viewCampIDs = getCampaignsWithPrivilege(empID, PrivilegeKeys.FS_VIEWCAMPAIGN);</span>

			// if agent, then we filter by both employee ID (translated to
			// collection of SPIDs) and campaignIDs
			// if manager, we only filter by collection of campaignIDs.
<span class="nc" id="L696">			auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L697">			return auctionDao.getAuctionsForCampaignIDs(viewCampIDs, detailLevel);</span>
<span class="nc" id="L698">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L700">			handleException(e);</span>
<span class="nc" id="L701">			throw e;</span>
<span class="nc" id="L702">		} catch (RmHardValidationException e) {</span>

<span class="nc" id="L704">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L705">			throw e;</span>
<span class="nc" id="L706">		} catch (Exception e) {</span>
<span class="nc" id="L707">			handleException(e);</span>
<span class="nc" id="L708">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L710">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L711">			cleanUp(auctionDao);</span>
<span class="nc" id="L712">			methodFinish();</span>
		}
	}

	/**
	 * Return auctions for which the given employee ID is an **active** bidder
	 * (bidder added to auction).
	 *
	 * @param empID
	 * @param detailLevel
	 * @return
	 * @throws RmException
	 */
	@Override
	public Collection getAuctionsForBidderEmpID(ID empID, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L729">		String _method_ = &quot;getAuctionsForBidder&quot;;</span>
<span class="nc" id="L730">		methodStart(_method_, empID, new Long(detailLevel));</span>
<span class="nc" id="L731">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L732">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L733">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L735">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L737">			auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L738">			return auctionDao.getAuctionsForBidderEmpID(empID, detailLevel);</span>
<span class="nc" id="L739">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L748">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L749">			throw e;</span>
<span class="nc" id="L750">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L752">			handleException(e);</span>
<span class="nc" id="L753">			throw e;</span>
<span class="nc" id="L754">		} catch (Exception e) {</span>
<span class="nc" id="L755">			handleException(e);</span>
<span class="nc" id="L756">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L758">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L759">			cleanUp(auctionDao);</span>
<span class="nc" id="L760">			methodFinish();</span>
		}
	}

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#startAuctionSerialization(com.bluepumpkin.common.datatypes.ID,
	 *      int)
	 *
	 *      &lt;p&gt;
	 *      ShiftBidder's 'isSerializedAuctionBidder' flag:
	 *      &lt;li&gt;When the seriaized auction starts, this flag is set for all
	 *      unadded bidders in the auction or for all unadded bidders in the
	 *      given set of bidder IDs.
	 *      &lt;li&gt;When the serialized auction ends, this flag is reset for all
	 *      shiftBidders (ir-respective of bidder state == 'added' or 'not
	 *      added').
	 *
	 * @param rankBy
	 *            One of the possible constants defined in {@link ShiftBidder
	 *            ShiftBidder} similar to {@link ShiftBidder#RANKBY_SCORE
	 *            RANKBY_SCORE}
	 */
	// * possible state changes:&lt;br&gt;
	// * isSerAucBidder, UnAdded -&gt; isSerAucBidder, UnAdded.
	// * isSerAucBidder, UnAdded -&gt; isSerAucBidder, Added.
	// * isSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, UnAdded.
	// * isSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, Added.
	// *
	// * isSerAucBidder, Added -&gt; isSerAucBidder, UnAdded.
	// * isSerAucBidder, Added -&gt; isSerAucBidder, Added.
	// * isSerAucBidder, Added -&gt; NotIsSerAucBidder, UnAdded.
	// * isSerAucBidder, Added -&gt; NotIsSerAucBidder, Added.
	// *
	// * NotIsSerAucBidder, UnAdded -&gt; isSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, UnAdded -&gt; isSerAucBidder, Added.
	// * NotIsSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, UnAdded -&gt; NotIsSerAucBidder, Added.
	// *
	// * NotIsSerAucBidder, Added -&gt; isSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, Added -&gt; isSerAucBidder, Added.
	// * NotIsSerAucBidder, Added -&gt; NotIsSerAucBidder, UnAdded.
	// * NotIsSerAucBidder, Added -&gt; NotIsSerAucBidder, Added.
	// */
	@Override
	public void startAuctionSerialization(ID auctionID, Collection bidderIDs, int bidderTimeLimit, int rankBy)
			throws RmException, RmHardValidationException {

<span class="nc" id="L807">		String _method_ = &quot;startAuctionSerialization&quot;;</span>
<span class="nc" id="L808">		methodStart(_method_, auctionID, bidderIDs, new Integer(bidderTimeLimit), new Integer(rankBy));</span>

<span class="nc" id="L810">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="nc" id="L811">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L812">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L813">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L815">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L817">			m_cat.debug(&quot;Starting serialized auction for ID = &quot; + auctionID);</span>

			// check if auction does exist and is open.
<span class="nc" id="L820">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc bnc" id="L821" title="All 4 branches missed.">			if (sbAuction == null || !sbAuction.getIsAuctionOpen()) {</span>
<span class="nc" id="L822">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_NOT_OPEN_YET,</span>
						RmEjbLogBundleKey.AUC_NOT_OPEN_YET, new Object[] { auctionID }, m_cat);
			}

<span class="nc" id="L826">			serAucDAO = new SerializedAuctionDAO();</span>
<span class="nc" id="L827">			SerializedAuction serAuc = serAucDAO.getSerializedAuctionForAuctionID(auctionID);</span>
<span class="nc bnc" id="L828" title="All 4 branches missed.">			if (serAuc != null &amp;&amp; serAuc.getIsEnabled()) {</span>
<span class="nc" id="L829">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_SERIALIZED,</span>
						RmEjbLogBundleKey.AUC_ALREADY_SERIALIZED, new Object[] { auctionID }, m_cat);
			}

			// set flag for given bidderIDs which are yet un-added to the
			// auction(as eligible for
			// participating in the serialized auction). If null, then all
			// un-added shift bidders
			// are marked eligible.
<span class="nc" id="L838">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_EMPLOYEE);</span>
<span class="nc" id="L839">			bidderDAO.updateIsSerializedAuctionForBidderIDs(auctionID, bidderIDs, true);</span>

			// if serialized auction fetched from DB, update fetched object.
			// addNextBidderToSerAucAndNotify()
			// below will persist this object's updates in DB.
<span class="nc bnc" id="L844" title="All 2 branches missed.">			if (serAuc != null) {</span>
<span class="nc" id="L845">				serAuc.setBidderTimelimit(bidderTimeLimit);</span>
<span class="nc" id="L846">				serAuc.setRankMethod(rankBy);</span>
			} else {
				// create new serializedAuction. This object will be saved in DB
				// by
				// addNextBidderToSerAucAndNotify() method below.
<span class="nc" id="L851">				serAuc = new SerializedAuction(auctionID, bidderTimeLimit, rankBy, true);</span>
			}

<span class="nc" id="L854">			ShiftBidder addedBidder = ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(serAuc, serAucDAO, null);</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">			if (addedBidder == null) {</span>
<span class="nc" id="L856">				_stopSerializedAuction(serAuc, serAucDAO, null);</span>
			}
<span class="nc" id="L858">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L860">			handleException(e);</span>
<span class="nc" id="L861">			throw e;</span>
<span class="nc" id="L862">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L871">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L872">			throw e;</span>
<span class="nc" id="L873">		} catch (Exception e) {</span>
<span class="nc" id="L874">			handleException(e);</span>
<span class="nc" id="L875">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L877">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L878">			cleanUp(serAucDAO);</span>
<span class="nc" id="L879">			cleanUp(bidderDAO);</span>
<span class="nc" id="L880">			methodFinish();</span>
<span class="nc" id="L881">		}</span>
<span class="nc" id="L882">	}</span>

	/**
	 * Stops an auction in progress.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#stopAuctionSerialization(com.bluepumpkin.common.datatypes.ID)
	 */
	@Override
	public void stopAuctionSerialization(ID auctionID) throws RmException, RmHardValidationException {

<span class="nc" id="L892">		String _method_ = &quot;stopAuctionSerialization&quot;;</span>
<span class="nc" id="L893">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L895">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L896">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L898">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L900">			m_cat.debug(&quot;Stopping auction serialization: auctionID = &quot; + auctionID);</span>
<span class="nc" id="L901">			_stopSerializedAuction(new SerializedAuction(auctionID, 0, 0, false), null, null);</span>
<span class="nc" id="L902">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L904">			handleException(e);</span>
<span class="nc" id="L905">			throw e;</span>
<span class="nc" id="L906">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L915">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L916">			throw e;</span>
<span class="nc" id="L917">		} catch (Exception e) {</span>
<span class="nc" id="L918">			handleException(e);</span>
<span class="nc" id="L919">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L921">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L922">			methodFinish();</span>
<span class="nc" id="L923">		}</span>
<span class="nc" id="L924">	}</span>

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getSerializedAuction(com.bluepumpkin.common.
	 * datatypes.ID)
	 */
	@Override
	public SerializedAuction getSerializedAuction(ID auctionID) throws RmException, RmHardValidationException {

<span class="nc" id="L936">		String _method_ = &quot;getSerializedAuction&quot;;</span>
<span class="nc" id="L937">		methodStart(_method_, auctionID);</span>

<span class="nc" id="L939">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="nc" id="L940">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L941">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L943">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L945">			serAucDAO = new SerializedAuctionDAO();</span>
<span class="nc" id="L946">			return serAucDAO.getSerializedAuctionForAuctionID(auctionID);</span>
<span class="nc" id="L947">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L949">			handleException(e);</span>
<span class="nc" id="L950">			throw e;</span>
<span class="nc" id="L951">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L960">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L961">			throw e;</span>
<span class="nc" id="L962">		} catch (Exception e) {</span>
<span class="nc" id="L963">			handleException(e);</span>
<span class="nc" id="L964">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L966">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L967">			cleanUp(serAucDAO);</span>
<span class="nc" id="L968">			methodFinish();</span>
		}
	}

	/**
	 * Return Map with Auction ID and Auction ValueObject for the specified
	 * SerializedAuctions
	 */
	private Map getAuctionMapForSerializedAuctions(Collection serAucs) throws BbmFinderException {
<span class="nc" id="L977">		methodStart(&quot;getAuctionMapForSerializedAuctions&quot;);</span>

<span class="nc" id="L979">		ShiftBidAuctionDAO auctionDAO = null;</span>
		try {
<span class="nc bnc" id="L981" title="All 4 branches missed.">			if (serAucs == null || serAucs.isEmpty()) {</span>
<span class="nc" id="L982">				return Collections.emptyMap();</span>
			}

			// Create List of AuctionIDs
<span class="nc" id="L986">			List aucIDs = new ArrayList(serAucs.size());</span>
<span class="nc bnc" id="L987" title="All 2 branches missed.">			for (Iterator it = serAucs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L988">				SerializedAuction serAuc = (SerializedAuction) it.next();</span>
<span class="nc" id="L989">				aucIDs.add(serAuc.getAuctionID());</span>
<span class="nc" id="L990">			}</span>

			// Fetch collection of Auctions and create Map
<span class="nc" id="L993">			Map result = new HashMap();</span>
<span class="nc" id="L994">			long detailLevel = ShiftBidAuction.DL_BASIC;</span>
<span class="nc" id="L995">			auctionDAO = new ShiftBidAuctionDAO(detailLevel);</span>
<span class="nc" id="L996">			Collection auctions = auctionDAO.getAuctionsByIDs(aucIDs, detailLevel);</span>
<span class="nc bnc" id="L997" title="All 2 branches missed.">			for (Iterator it = auctions.iterator(); it.hasNext();) {</span>
<span class="nc" id="L998">				ShiftBidAuction sbAuc = (ShiftBidAuction) it.next();</span>
<span class="nc" id="L999">				result.put(sbAuc.getID(), sbAuc);</span>
<span class="nc" id="L1000">			}</span>

<span class="nc" id="L1002">			return result;</span>
		} finally {
<span class="nc" id="L1004">			cleanUp(auctionDAO);</span>
<span class="nc" id="L1005">			methodFinish();</span>
		}
	}

	@Override
	public void pollSerializedAuctions() throws RmException, RmHardValidationException {

<span class="nc" id="L1012">		String _method_ = &quot;pollSerializedAuctions&quot;;</span>
<span class="nc" id="L1013">		methodStart(_method_);</span>

<span class="nc" id="L1015">		SerializedAuctionDAO serAucDAO = null;</span>
<span class="nc" id="L1016">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L1017">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1019">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1021">			m_cat.debug(&quot;Entering pollSerializedAuctions&quot;);</span>
<span class="nc" id="L1022">			serAucDAO = new SerializedAuctionDAO();</span>
			// find enabled auctions with &quot;deadline for submission&quot; &lt; curr time
<span class="nc" id="L1024">			Collection expiredserAucs = serAucDAO.getSerializedAuctionsPastDeadline(new Date());</span>
<span class="nc" id="L1025">			Map aucIDToAuctionMap = getAuctionMapForSerializedAuctions(expiredserAucs);</span>

			// add next bidder for each such auction.
<span class="nc bnc" id="L1028" title="All 2 branches missed.">			for (Iterator expiredserAucIter = expiredserAucs.iterator(); expiredserAucIter.hasNext();) {</span>
<span class="nc" id="L1029">				SerializedAuction serAuc = (SerializedAuction) expiredserAucIter.next();</span>

				// skip closed auctions
<span class="nc" id="L1032">				ShiftBidAuction auction = (ShiftBidAuction) aucIDToAuctionMap.get(serAuc.getAuctionID());</span>
<span class="nc bnc" id="L1033" title="All 4 branches missed.">				if (auction != null &amp;&amp; auction.isStatusClosed()) {</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1035">						m_cat.debug(&quot;Auction is closed so skip it. SerializedAuction ID=&quot; + serAuc.getID());</span>
					}
					continue;
				}

				// get next bidder
<span class="nc" id="L1041">				ShiftBidder nextBidder = ShiftBidAuctionUtil.addNextBidderToSerAucUpdateAndNotify(serAuc, serAucDAO,</span>
						null);

				// if no more bidders stop auction serialization.
<span class="nc bnc" id="L1045" title="All 2 branches missed.">				if (nextBidder == null) {</span>
<span class="nc" id="L1046">					_stopSerializedAuction(serAuc, serAucDAO, null);</span>
				}
<span class="nc" id="L1048">			}</span>
<span class="nc" id="L1049">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L1051">			handleException(e);</span>
<span class="nc" id="L1052">			throw e;</span>
<span class="nc" id="L1053">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1062">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1063">			throw e;</span>
<span class="nc" id="L1064">		} catch (Exception e) {</span>
<span class="nc" id="L1065">			handleException(e);</span>
<span class="nc" id="L1066">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1068">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L1069">			cleanUp(serAucDAO);</span>
<span class="nc" id="L1070">			methodFinish();</span>
<span class="nc" id="L1071">		}</span>
<span class="nc" id="L1072">	}</span>

	/**
	 * @param empID
	 * @param privName
	 * @return
	 */
	private Collection getCampaignsWithPrivilege(ID empID, String privName) throws Exception {
<span class="nc" id="L1080">		User user = RequestUtil.getUserByEmpIDCached(empID);</span>
<span class="nc" id="L1081">		return user.getAuthorizedScopes(privName, CPG_SCOPE);</span>
	}

	protected void _stopSerializedAuction(SerializedAuction serAuc, SerializedAuctionDAO serAucDAO,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc bnc" id="L1087" title="All 2 branches missed.">		boolean serAucDAOCreateNeeded = serAucDAO == null;</span>
<span class="nc bnc" id="L1088" title="All 2 branches missed.">		boolean bidderDAOCreateNeeded = bidderDAO == null;</span>

		try {
<span class="nc bnc" id="L1091" title="All 2 branches missed.">			serAucDAO = (serAucDAOCreateNeeded) ? new SerializedAuctionDAO() : serAucDAO;</span>

<span class="nc" id="L1093">			ID auctionID = serAuc.getAuctionID();</span>

<span class="nc bnc" id="L1095" title="All 2 branches missed.">			if (serAuc.getID() == null) { // if passed serialized Auction was</span>
											// not loaded from DB by caller.
<span class="nc" id="L1097">				serAuc = serAucDAO.getSerializedAuctionForAuctionID(auctionID); // load</span>
																				// from
																				// DB
			}

<span class="nc bnc" id="L1102" title="All 4 branches missed.">			if (serAuc == null || !serAuc.getIsEnabled()) {</span>
<span class="nc" id="L1103">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_SERIALIZATION_NOT_STARTED,</span>
						RmEjbLogBundleKey.AUC_SERIALIZATION_NOT_STARTED, new Object[] { auctionID }, m_cat);
			}

			// stop auction serialization
<span class="nc" id="L1108">			serAuc.setIsEnabled(false);</span>
<span class="nc" id="L1109">			serAucDAO.updateSerializedAuction(serAuc);</span>

			// reset flag 'isSerializedAuctionBidder' for all shiftBidders in
			// the auction.
<span class="nc bnc" id="L1113" title="All 2 branches missed.">			bidderDAO = (bidderDAOCreateNeeded) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>
<span class="nc" id="L1114">			bidderDAO.updateIsSerializedAuctionForBidderIDs(auctionID, null, false);</span>
		} finally {
<span class="nc bnc" id="L1116" title="All 8 branches missed.">			if (serAucDAOCreateNeeded &amp;&amp; serAucDAO != null) {</span>
<span class="nc" id="L1117">				serAucDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L1119" title="All 8 branches missed.">			if (bidderDAOCreateNeeded &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L1120">				bidderDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1123">	}</span>

	/**
	 * @param sbAuction
	 */
	private void assignDefaultsForAuctionVO(ShiftBidAuction sbAuction) throws Exception {
<span class="nc bnc" id="L1129" title="All 4 branches missed.">		assert sbAuction.getSPID() != null : &quot;sbAuction.getSPID() != null&quot;;</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">		if (sbAuction.getCreationTime() == null) {</span>
<span class="nc" id="L1131">			sbAuction.setCreationTime(new Date());</span>
		}
<span class="nc bnc" id="L1133" title="All 2 branches missed.">		if (sbAuction.getAuctionDeadLine() == null) {</span>
<span class="nc" id="L1134">			sbAuction.setDeadlineDate(sbAuction.getStartTime());</span>
		}
<span class="nc bnc" id="L1136" title="All 4 branches missed.">		assert sbAuction.getName() != null : &quot;sbAuction.getName() != null;&quot;;</span>
		// isForSingleShifts: boolean
<span class="nc bnc" id="L1138" title="All 2 branches missed.">		if (sbAuction.getCreatorID() == null) {</span>
<span class="nc" id="L1139">			sbAuction.setCreatorID(RequestUtil.getLoginUserID(m_sessionContext));</span>
		}
		// isNativeOrganization: boolean
		// isScored: boolean
		// can't distinguish between null and 0. In either case reset it to 0.
<span class="nc bnc" id="L1144" title="All 2 branches missed.">		if (sbAuction.getBonusForNoBidsAccepted() == 0) {</span>
<span class="nc" id="L1145">			sbAuction.setBonusForNoBidsAccepted(0);</span>
		}
<span class="nc" id="L1147">		sbAuction.getSetters().setNumOfBiddableScheduleInstances(0);</span>
<span class="nc" id="L1148">		sbAuction.getSetters().setNumBidders(0);</span>
<span class="nc" id="L1149">		sbAuction.setStatus(ShiftBidAuction.STATUS_OPEN_FOR_BIDDING);</span>
<span class="nc bnc" id="L1150" title="All 4 branches missed.">		assert sbAuction.getStartTime() != null : &quot;sbAuction.getStartTime() != null&quot;;</span>
<span class="nc bnc" id="L1151" title="All 4 branches missed.">		assert sbAuction.getEndTime() != null : &quot;sbAuction.getEndTime() != null&quot;;</span>
<span class="nc bnc" id="L1152" title="All 4 branches missed.">		assert sbAuction.getOptMethods().getCampaignID() != null : &quot;sbAuction.getOptMethods().getCampaignID() != null&quot;;</span>
<span class="nc" id="L1153">	}</span>

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 * @param sbAuctionDAO
	 * @param bidderDAO
	 * @throws Exception
	 */
	private void validateAuction(ShiftBidAuction givenSBAuctionVO, ShiftBidAuction origSBAuctionFromDB, int actionType,
			ShiftBidAuctionDAO sbAuctionDAO, ShiftBidderDAO bidderDAO) throws Exception {
<span class="nc bnc" id="L1164" title="All 2 branches missed.">		boolean daoCreateNeeded = (sbAuctionDAO == null);</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">		boolean daoCreateNeeded2 = (bidderDAO == null);</span>

		try {
			// common validations
			// current time not past the auction deadline
			// TODO: BiddableSchedlues associated with auction are valid (done
			// if detail level is sufficent to validate)
			// TODO: validate cached columns such as NumOfBiddableSchedules etc,
			// SP start and SP end time
<span class="nc" id="L1174">			validateAuctionPrivilege(givenSBAuctionVO, actionType);</span>
<span class="nc" id="L1175">			validateAuctionNotExpired(givenSBAuctionVO, actionType);</span>

			// validations for create
			// an auction does not already exist for same SPID
			// an auction with same name does not already exist.
			// auction deadline must be earlier than SP start.
<span class="nc bnc" id="L1181" title="All 2 branches missed.">			if (actionType == RequestUtil.ACTION_CREATE) {</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">				if (sbAuctionDAO == null) {</span>
<span class="nc" id="L1183">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L1185" title="All 2 branches missed.">				if (bidderDAO == null) {</span>
<span class="nc" id="L1186">					bidderDAO = new ShiftBidderDAO(ShiftBidAuction.DL_BASIC);</span>
				}

<span class="nc" id="L1189">				Collection&lt;ShiftBidAuction&gt; sbAuctions = null;</span>

<span class="nc bnc" id="L1191" title="All 4 branches missed.">				if (LicenseUtil.isAdvancedRMLicense() &amp;&amp; givenSBAuctionVO.isConcurrentAuction()) {</span>
<span class="nc" id="L1192">					Collection&lt;ID&gt; orgIDs = ShiftBidAuctionUtil.getConcurrentAuctionParentChildOrgsOrSPOrgs(givenSBAuctionVO);</span>
<span class="nc" id="L1193">					sbAuctions = sbAuctionDAO.getAuctionsForSPIDORGIDEMTYSID(givenSBAuctionVO.getSPID(), orgIDs,</span>
<span class="nc" id="L1194">							ShiftBidAuctionUtil.getIDFromValue(givenSBAuctionVO.getEmployeeTypeSid()), ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1195">					validateAuctionNoOtherConcurrentAuctionForSPORGEMPTP(sbAuctions, givenSBAuctionVO, actionType);</span>
<span class="nc" id="L1196">				} else {</span>
<span class="nc" id="L1197">					sbAuctions = sbAuctionDAO.getAuctionsForSPID(givenSBAuctionVO.getSPID(), ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1198">					validateAuctionNoOtherAuctionForSP(sbAuctions, givenSBAuctionVO, actionType);</span>
				}
<span class="nc" id="L1200">				validateAuctionNotDuplicateName(givenSBAuctionVO, actionType, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>
<span class="nc" id="L1201">				validateAuctionDeadlineBeforeSPStart(sbAuctionDAO, givenSBAuctionVO, null, actionType);</span>
<span class="nc" id="L1202">				validateAuctionNoOpenRequestsForSP(bidderDAO, sbAuctions, givenSBAuctionVO, actionType, LicenseUtil.isAdvancedRMLicense());</span>
			}

			// validations on updates
			// same name auction does not exist
			// validate status transitions
			// udpated deadline must be earlier than SP start.
<span class="nc bnc" id="L1209" title="All 2 branches missed.">			if (actionType == RequestUtil.ACTION_UPDATE) {</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">				if (sbAuctionDAO == null) {</span>
<span class="nc" id="L1211">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L1213" title="All 2 branches missed.">				if (bidderDAO == null) {</span>
<span class="nc" id="L1214">					bidderDAO = new ShiftBidderDAO(ShiftBidAuction.DL_BASIC);</span>
				}
<span class="nc bnc" id="L1216" title="All 2 branches missed.">				if (origSBAuctionFromDB == null) {</span>
<span class="nc" id="L1217">					origSBAuctionFromDB = sbAuctionDAO.getAuctionByID(givenSBAuctionVO.getID(),</span>
							ShiftBidAuction.DL_BASIC);
				}

<span class="nc" id="L1221">				Collection&lt;ShiftBidAuction&gt; sbAuctions = null;</span>
<span class="nc bnc" id="L1222" title="All 4 branches missed.">				if (LicenseUtil.isAdvancedRMLicense() &amp;&amp; givenSBAuctionVO.isConcurrentAuction()) {</span>
<span class="nc" id="L1223">					Collection&lt;ID&gt; orgIDs = ShiftBidAuctionUtil.getConcurrentAuctionParentChildOrgsOrSPOrgs(givenSBAuctionVO);</span>
<span class="nc" id="L1224">					sbAuctions = sbAuctionDAO.getAuctionsForSPIDORGIDEMTYSID(givenSBAuctionVO.getSPID(), orgIDs,</span>
<span class="nc" id="L1225">							ShiftBidAuctionUtil.getIDFromValue(givenSBAuctionVO.getEmployeeTypeSid()), ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1226">				} else {</span>
<span class="nc" id="L1227">					sbAuctions = sbAuctionDAO.getAuctionsForSPID(givenSBAuctionVO.getSPID(), ShiftBidAuction.DL_BASIC);</span>
				}

<span class="nc" id="L1230">				validateAuctionNotDuplicateName(givenSBAuctionVO, actionType, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>
<span class="nc" id="L1231">				validateAuctionStateTransition(sbAuctionDAO, givenSBAuctionVO, origSBAuctionFromDB, actionType);</span>
<span class="nc" id="L1232">				validateAuctionDeadlineBeforeSPStart(sbAuctionDAO, givenSBAuctionVO, origSBAuctionFromDB, actionType);</span>
<span class="nc" id="L1233">				validateAuctionNoOpenRequestsForSP(bidderDAO, sbAuctions, givenSBAuctionVO, actionType, LicenseUtil.isAdvancedRMLicense());</span>
			}

			// validations on fetches

			// validations on deletes
		} finally {
<span class="nc bnc" id="L1240" title="All 8 branches missed.">			if (daoCreateNeeded2 &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L1241">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L1243" title="All 8 branches missed.">			if (daoCreateNeeded &amp;&amp; sbAuctionDAO != null) {</span>
<span class="nc" id="L1244">				sbAuctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1247">	}</span>

	private void validateAuctionNoOtherAuctionForSP(Collection&lt;ShiftBidAuction&gt; sbAuctions, ShiftBidAuction sbAuction,
			int actionType) throws Exception {
<span class="nc bnc" id="L1251" title="All 2 branches missed.">		if (actionType != RequestUtil.ACTION_CREATE) {</span>
<span class="nc" id="L1252">			return;</span>
		}

<span class="nc" id="L1255">		ID spID = sbAuction.getSPID();</span>

<span class="nc" id="L1257">		boolean canCreate = canCreateNewAuctionForSameSP(sbAuction, sbAuctions, LicenseUtil.isAdvancedRMLicense());</span>

<span class="nc bnc" id="L1259" title="All 2 branches missed.">		if (!canCreate) {</span>
<span class="nc" id="L1260">			throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_EXISTS_FOR_SP,</span>
					RmEjbLogBundleKey.AUC_ALREADY_EXISTS_FOR_SP, new Object[] { spID }, m_cat);
		}
<span class="nc" id="L1263">	}</span>

	private boolean canCreateNewAuctionForSameSP(ShiftBidAuction newAuction, Collection&lt;ShiftBidAuction&gt; existingAuctionsOnSameSP,
			boolean hasAdvancedRMLicense) {
		boolean canCreateNewAuction;

<span class="nc bnc" id="L1269" title="All 2 branches missed.">		if (!hasAdvancedRMLicense) {</span>
<span class="nc" id="L1270">			canCreateNewAuction = existingAuctionsOnSameSP.isEmpty();</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">		} else if (newAuction.getIsAuctionOpen()) {</span>
<span class="nc" id="L1272">			canCreateNewAuction = true;</span>
<span class="nc bnc" id="L1273" title="All 2 branches missed.">			for (ShiftBidAuction auction : existingAuctionsOnSameSP) {</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">				if (!auction.isStatusClosed()) {</span>
<span class="nc" id="L1275">					canCreateNewAuction = false;</span>
<span class="nc" id="L1276">					break;</span>
				}
<span class="nc" id="L1278">			}</span>
		} else {
<span class="nc" id="L1280">			canCreateNewAuction = true;</span>
		}

<span class="nc" id="L1283">		return canCreateNewAuction;</span>
	}

	private void validateAuctionNoOtherConcurrentAuctionForSPORGEMPTP(Collection&lt;ShiftBidAuction&gt; sbAuctions,
			ShiftBidAuction sbAuction, int actionType) throws Exception {

<span class="nc bnc" id="L1289" title="All 2 branches missed.">		if (actionType != RequestUtil.ACTION_CREATE) {</span>
<span class="nc" id="L1290">			return;</span>
		}

<span class="nc" id="L1293">		ID spID = sbAuction.getSPID();</span>

<span class="nc" id="L1295">		boolean canCreate = canCreateNewConCurrentAuctionForSameSPORGEMPTP(sbAuction, sbAuctions);</span>

<span class="nc bnc" id="L1297" title="All 2 branches missed.">		if (!canCreate) {</span>
<span class="nc" id="L1298">			throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_EXISTS_FOR_SP_ORG_EMPTYPE,</span>
					RmEjbLogBundleKey.AUC_ALREADY_EXISTS_FOR_SP_ORG_EMPTYPE, new Object[] { spID }, m_cat);
		}
<span class="nc" id="L1301">	}</span>

	private boolean canCreateNewConCurrentAuctionForSameSPORGEMPTP(ShiftBidAuction newAuction,
			Collection&lt;ShiftBidAuction&gt; existingAuctionsOnSameSP) {
<span class="nc" id="L1305">		boolean canCreateNewAuction = true;</span>

<span class="nc bnc" id="L1307" title="All 2 branches missed.">		if (!existingAuctionsOnSameSP.isEmpty()) {</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">			for (ShiftBidAuction auction : existingAuctionsOnSameSP) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">				if (!auction.isStatusClosed()) {</span>
<span class="nc" id="L1310">					canCreateNewAuction = false;</span>
<span class="nc" id="L1311">					break;</span>
				}
<span class="nc" id="L1313">			}</span>
<span class="nc bnc" id="L1314" title="All 2 branches missed.">		} else if (!newAuction.getIsAuctionOpen()) {</span>
<span class="nc" id="L1315">			canCreateNewAuction = false;</span>
		}

<span class="nc" id="L1318">		return canCreateNewAuction;</span>
	}

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 */
	private void validateAuctionNotExpired(ShiftBidAuction givenSBAuctionVO, int actionType) throws Exception {
		// if action != 'update' and given auction's deadline has expired.
		// Updates to expired
		// auctions are allowed so that the 'expiration date' can be updated.
<span class="nc bnc" id="L1329" title="All 4 branches missed.">		if (actionType != RequestUtil.ACTION_UPDATE &amp;&amp; givenSBAuctionVO.getAuctionDeadLine().before(new Date())) {</span>
<span class="nc" id="L1330">			throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_HAS_EXPIRED,</span>
					RmEjbLogBundleKey.AUC_HAS_EXPIRED,
					new Object[] {
<span class="nc" id="L1333">							givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
		}
<span class="nc" id="L1335">	}</span>

	/**
	 * @param givenSBAuctionVO
	 * @param actionType
	 */
	private void validateAuctionPrivilege(ShiftBidAuction givenSBAuctionVO, int actionType) {

<span class="nc" id="L1343">	}</span>

	/**
	 * @param sbAuctionDAO
	 * @param givenSBAuctionVO
	 * @param auctionVOBeforeUpdate
	 * @param actionType
	 */
	private void validateAuctionStateTransition(ShiftBidAuctionDAO sbAuctionDAO, ShiftBidAuction givenSBAuctionVO,
			ShiftBidAuction auctionVOBeforeUpdate, int actionType) {

<span class="nc" id="L1354">	}</span>

	/**
	 * @param sbAuctionDAO
	 * @param givenSBAuctionVO
	 * @param auctionVOBeforeUpdate
	 * @param actionType
	 */
	private void validateAuctionDeadlineBeforeSPStart(ShiftBidAuctionDAO sbAuctionDAO, ShiftBidAuction givenSBAuctionVO,
			ShiftBidAuction auctionVOBeforeUpdate, int actionType) throws Exception {
<span class="nc" id="L1364">		Date givenSBAuctionDeadline = givenSBAuctionVO.getAuctionDeadLine();</span>
<span class="nc bnc" id="L1365" title="All 2 branches missed.">		if (actionType == RequestUtil.ACTION_UPDATE) {</span>
<span class="nc bnc" id="L1366" title="All 2 branches missed.">			if (givenSBAuctionDeadline.after(auctionVOBeforeUpdate.getStartTime())) {</span>
<span class="nc" id="L1367">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_DEADLINE_AFTER_SP_START,</span>
						RmEjbLogBundleKey.AUC_DEADLINE_AFTER_SP_START,
						new Object[] {
<span class="nc" id="L1370">								givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
			}
<span class="nc bnc" id="L1372" title="All 2 branches missed.">		} else if (actionType == RequestUtil.ACTION_CREATE) {</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">			if (givenSBAuctionDeadline.after(givenSBAuctionVO.getStartTime())) {</span>
<span class="nc" id="L1374">				throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_DEADLINE_AFTER_SP_START,</span>
						RmEjbLogBundleKey.AUC_DEADLINE_AFTER_SP_START,
						new Object[] {
<span class="nc" id="L1377">								givenSBAuctionVO.getName(), givenSBAuctionVO.getID() }, m_cat);</span>
			}
		}
<span class="nc" id="L1380">	}</span>

	private void validateAuctionNotDuplicateName(ShiftBidAuction givenSBAuctionVO, int actionType,
			Collection&lt;ShiftBidAuction&gt; sbAuctions, boolean hasAdvancedRMLicense) throws RmHardValidationException {
<span class="nc bnc" id="L1384" title="All 2 branches missed.">		if (!hasAdvancedRMLicense) {</span>
<span class="nc" id="L1385">			ShiftBidAuction auctionFromDB = null;</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">			if (!sbAuctions.isEmpty()) {</span>
<span class="nc" id="L1387">				auctionFromDB = sbAuctions.iterator().next();</span>
			}

<span class="nc bnc" id="L1390" title="All 6 branches missed.">			if (!sbAuctions.isEmpty()</span>
					&amp;&amp; ((actionType == RequestUtil.ACTION_CREATE) || (actionType == RequestUtil.ACTION_UPDATE
<span class="nc bnc" id="L1392" title="All 2 branches missed.">					&amp;&amp; !auctionFromDB.getID().equals(givenSBAuctionVO.getID())))) {</span>
<span class="nc" id="L1393">				throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.AUC_WITH_SAME_NAME_EXISTS,</span>
<span class="nc" id="L1394">						givenSBAuctionVO.getName(), m_cat);</span>
			}
<span class="nc bnc" id="L1396" title="All 2 branches missed.">		} else if (givenSBAuctionVO.isStatusOpen()) {</span>
			// has Advanced RM license

			// other auctions must be closed
<span class="nc bnc" id="L1400" title="All 2 branches missed.">			for (ShiftBidAuction auction : sbAuctions) {</span>
<span class="nc bnc" id="L1401" title="All 4 branches missed.">				if (auction.isStatusOpen() &amp;&amp; !auction.getID().equals(givenSBAuctionVO.getID())) {</span>
<span class="nc" id="L1402">					throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.AUC_ALREADY_EXISTS_FOR_SP, m_cat);</span>
				}
<span class="nc" id="L1404">			}</span>
		}
<span class="nc" id="L1406">	}</span>

	/**
	 * Throws exception if there are any pending or escalated requests belong to other auctions (which are for the same SP)
	 */
	private void validateAuctionNoOpenRequestsForSP(ShiftBidderDAO bidderDAO, Collection&lt;ShiftBidAuction&gt; sbAuctions,
			ShiftBidAuction givenSBAuctionVO, int actionType, boolean hasAdvancedRMLicense)
			throws Exception {

<span class="nc bnc" id="L1415" title="All 4 branches missed.">		if (hasAdvancedRMLicense &amp;&amp; givenSBAuctionVO.isStatusOpen()) {</span>
			// Find original auction and other auction IDs from database
<span class="nc" id="L1417">			ShiftBidAuction originalAuction = null;</span>
<span class="nc" id="L1418">			Collection&lt;ID&gt; otherAuctionIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">			for (ShiftBidAuction auction : sbAuctions) {</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">				if (!auction.getID().equals(givenSBAuctionVO.getID())) {</span>
<span class="nc" id="L1421">					otherAuctionIDs.add(auction.getID());</span>
				} else {
<span class="nc" id="L1423">					originalAuction = auction;</span>
				}
<span class="nc" id="L1425">			}</span>
<span class="nc bnc" id="L1426" title="All 4 branches missed.">			if (originalAuction == null || !originalAuction.isStatusOpen()) {</span>
				// We check for pending requests when creating a new auction
				// or when an existing auction status is being updated from closed to open
<span class="nc" id="L1429">				Collection&lt;ID&gt; employeeIDs = bidderDAO.getEmployeeIDsByAuctionAndRequestStatus(otherAuctionIDs,</span>
						new String[] {
								RequestAuditTrail.STATUS_PENDING, RequestAuditTrail.STATUS_ESCALATED });

<span class="nc bnc" id="L1433" title="All 2 branches missed.">				if (!employeeIDs.isEmpty()) {</span>
<span class="nc" id="L1434">					throw RequestUtil.createAndLogRmHardValidationException(RmEjbBundleKey.AUC_PENDING_REQUESTS_FOR_SP,</span>
<span class="nc" id="L1435">							RmEjbLogBundleKey.AUC_PENDING_REQUESTS_FOR_SP, new Object[] { givenSBAuctionVO.getSPID() }, m_cat);</span>
				}
			}
		}
<span class="nc" id="L1439">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateAuction(com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction)
	 */
	protected void _updateAuction(ShiftBidAuction updatedAuctionVO, ShiftBidAuction origAuctionVO,
			ShiftBidAuctionDAO auctionDAO) throws Exception {
<span class="nc bnc" id="L1446" title="All 2 branches missed.">		boolean DAOCreateNeeded = auctionDAO == null;</span>
<span class="nc" id="L1447">		ShiftBidderDAO bidderDAO = null;</span>
		try {
<span class="nc bnc" id="L1449" title="All 2 branches missed.">			if (auctionDAO == null) {</span>
<span class="nc" id="L1450">				auctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
			}
<span class="nc" id="L1452">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L1454">			validateAuction(updatedAuctionVO, origAuctionVO, RequestUtil.ACTION_UPDATE, auctionDAO, bidderDAO);</span>

<span class="nc" id="L1456">			auctionDAO.updateAuctions(Collections.singletonList(updatedAuctionVO));</span>
		} finally {

<span class="nc" id="L1459">			cleanUp(bidderDAO);</span>

<span class="nc bnc" id="L1461" title="All 8 branches missed.">			if (auctionDAO != null &amp;&amp; DAOCreateNeeded) {</span>
<span class="nc" id="L1462">				auctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1465">	}</span>

	protected void _updateAuctionByID(ID auctionID, int fieldIndex, Object fieldValue, ShiftBidAuctionDAO auctionDAO)
			throws Exception {
<span class="nc" id="L1469">		boolean auctionDAOAllocated = false;</span>
<span class="nc" id="L1470">		ShiftBidderDAO bidderDAO = null;</span>
		try {
<span class="nc bnc" id="L1472" title="All 2 branches missed.">			if (auctionDAO == null) {</span>
<span class="nc" id="L1473">				auctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L1474">				auctionDAOAllocated = true;</span>
			}
<span class="nc" id="L1476">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L1478">			ShiftBidAuction origAuctionFromDB = auctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

<span class="nc" id="L1480">			ShiftBidAuction updatedAuction = (ShiftBidAuction) origAuctionFromDB.clone();</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if (updatedAuction == null) {</span>
<span class="nc" id="L1482">				throw RequestUtil.createRmException(RmEjbLogBundleKey.AUC_NOT_FOUND, auctionID, m_cat);</span>
			}

			// setAuctionField(auction, updateFieldDesc);
<span class="nc" id="L1486">			updatedAuction.setFieldValue(fieldIndex, fieldValue);</span>

<span class="nc" id="L1488">			validateAuction(updatedAuction, origAuctionFromDB, RequestUtil.ACTION_UPDATE, auctionDAO, bidderDAO);</span>

<span class="nc" id="L1490">			auctionDAO.updateAuctions(Collections.singletonList(updatedAuction));</span>
		} finally {

<span class="nc" id="L1493">			cleanUp(bidderDAO);</span>

<span class="nc bnc" id="L1495" title="All 8 branches missed.">			if (auctionDAO != null &amp;&amp; auctionDAOAllocated) {</span>
<span class="nc" id="L1496">				auctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L1499">	}</span>

	/**
	 * @param auction
	 * @return
	 */
	private Collection&lt;ShiftBidder&gt; compileShiftBiddersForAuction(ShiftBidAuction auction, SchedulingPeriod schedPeriod,
			CampaignManager campMgr, ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc" id="L1508">		Collection&lt;ID&gt; empIDs = null;</span>

<span class="nc bnc" id="L1510" title="All 2 branches missed.">		if (auction.isConcurrentAuction()) {</span>
<span class="nc" id="L1511">			empIDs = getEmpIDsForSP(schedPeriod.getCampaignID(), schedPeriod.getStartTime(),</span>
<span class="nc" id="L1512">					schedPeriod.getEndTime(), schedPeriod.getID(), campMgr, auction);</span>
		} else {
<span class="nc" id="L1514">			empIDs = getEmpIDsForSP(schedPeriod.getCampaignID(), schedPeriod.getStartTime(),</span>
<span class="nc" id="L1515">					schedPeriod.getEndTime(), schedPeriod.getID(), campMgr);</span>
		}

<span class="nc" id="L1518">		return compileShiftBiddersForAuction(empIDs, auction, bidderDAO);</span>
	}

	private Collection&lt;ShiftBidder&gt; compileShiftBiddersForAuction(Collection empIDs, ShiftBidAuction auction,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc" id="L1524">		ID auctionID = auction.getID();</span>

<span class="nc" id="L1526">		Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(empIDs, auction, bidderDAO);</span>

<span class="nc" id="L1528">		Collection&lt;ShiftBidder&gt; shiftBidders = new ArrayList&lt;ShiftBidder&gt;(empIDs.size());</span>
<span class="nc" id="L1529">		Collection&lt;ID&gt; addedBidders = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1530" title="All 2 branches missed.">		for (Iterator iter = empIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1531">			ID bidderEmpID = (ID) iter.next();</span>

<span class="nc" id="L1533">			ShiftBidder shiftBidder = new ShiftBidder(ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L1534">			shiftBidder.getSetters().setShiftBidAuctionID(auctionID);</span>
<span class="nc" id="L1535">			shiftBidder.setBonusThisAuction(0);</span>

<span class="nc bnc" id="L1537" title="All 2 branches missed.">			shiftBidder.getSetters().setStatus(unavailableEmpIDs.contains(bidderEmpID)</span>
					? ShiftBidder.STATUS_UNAVAILABLE : ShiftBidder.STATUS_NOT_ADDED);
<span class="nc" id="L1539">			shiftBidder.getSetters().setEmployeeID(bidderEmpID);</span>

<span class="nc" id="L1541">			shiftBidder.setDeadlineDate(auction.getAuctionDeadLine());</span>
<span class="nc" id="L1542">			shiftBidder.getSetters().setIsSerializedAuctionBidder(false);</span>

<span class="nc bnc" id="L1544" title="All 2 branches missed.">			if (!addedBidders.contains(bidderEmpID)) {</span>
<span class="nc" id="L1545">				shiftBidders.add(shiftBidder);</span>
<span class="nc" id="L1546">				addedBidders.add(bidderEmpID);</span>
			}
<span class="nc" id="L1548">		}</span>

<span class="nc" id="L1550">		return shiftBidders;</span>
	}

	private Collection&lt;ID&gt; getEmpIDsForSP(ID aucCampID, Date aucStartTime, Date aucEndTime, ID spID,
			CampaignManager campMgr) throws BbmFinderException, RemoteException, BbmEJBCreateException {

		// get employees for the given SchedulingProfile (SP)
<span class="nc bnc" id="L1557" title="All 2 branches missed.">		campMgr = (campMgr == null) ? WfmManagerFactory.getCampaignManager() : campMgr;</span>

<span class="nc" id="L1559">		Collection campWorkResources = campMgr.getCampaignWorkResourceAssignments(aucCampID, aucStartTime, aucEndTime);</span>
<span class="nc" id="L1560">		m_cat.debug(&quot;# of workresources in SP: SPID, #: &quot; + spID + ',' + campWorkResources.size());</span>

		// get list of employee IDs from CampaignWorkResource collection
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1564">		Collection&lt;ID&gt; empIDs = RequestUtil.getListOfFieldValuesFromVOBases(campWorkResources,</span>
				CampaignWorkResourceFieldInfo.CAMPAIGNWORKRESOURCE_WORKRESOURCEID);

<span class="nc" id="L1567">		return empIDs;</span>
	}

	private Collection&lt;ID&gt; getEmpIDsForSP(ID aucCampID, Date aucStartTime, Date aucEndTime, ID spID,
			CampaignManager campMgr, ShiftBidAuction auction) throws BbmFinderException, RemoteException, BbmEJBCreateException, Exception {

		// get employees for the given SchedulingProfile (SP)
<span class="nc bnc" id="L1574" title="All 2 branches missed.">		campMgr = (campMgr == null) ? WfmManagerFactory.getCampaignManager() : campMgr;</span>

<span class="nc" id="L1576">		Collection&lt;ID&gt; orgIDs = ShiftBidAuctionUtil.getConcurrentAuctionOrgs(auction);</span>

<span class="nc" id="L1578">		Collection campWorkResources = campMgr.getCampaignWorkResourceAssignments(aucCampID, aucStartTime, aucEndTime, orgIDs,</span>
<span class="nc" id="L1579">				ShiftBidAuctionUtil.getIDFromValue(auction.getEmployeeTypeSid()));</span>
<span class="nc" id="L1580">		m_cat.debug(&quot;# of workresources in SP: SPID, #: &quot; + spID + ',' + campWorkResources.size());</span>

		// get list of employee IDs from CampaignWorkResource collection
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1584">		Collection&lt;ID&gt; empIDs = RequestUtil.getListOfFieldValuesFromVOBases(campWorkResources,</span>
				CampaignWorkResourceFieldInfo.CAMPAIGNWORKRESOURCE_WORKRESOURCEID);

<span class="nc" id="L1587">		return empIDs;</span>
	}



	@Override
	public List&lt;String&gt; getTemplateNames(ID auctionID, Collection&lt;ID&gt; orgIDs, ID bidderID, boolean byEmplType) {
<span class="nc" id="L1594">		BiddableScheduleMiscDAO dao = new BiddableScheduleMiscDAO();</span>
		try {
<span class="nc" id="L1596">			return dao.getTemplateNames(auctionID, orgIDs, bidderID, byEmplType);</span>
		} finally {
<span class="nc" id="L1598">			dao.cleanUp();</span>
		}
	}

	//All the biddable schedules data needed to build the Schedule Action | Bid option page for a given bidder
	@Override
	public Pair&lt;List&lt;ID&gt;, List&lt;BidOptionRow&gt;&gt; getBidOptionsForBidder(BiddableSchedulesForAuctionParameter param) {
<span class="nc" id="L1605">		BidOptionLoader loader = new BidOptionLoader(m_sessionContext);</span>
<span class="nc" id="L1606">		return loader.getBidOptionsForBidder(param);</span>
	}

	//All the biddable schedules data needed to build the Schedule Action | Schedules page for a given auction
	@Override
	public Pair&lt;List&lt;ID&gt;, List&lt;BiddableScheduleRow&gt;&gt; getBiddableScheduleRowsForAuction(BiddableSchedulesForAuctionParameter param,
			ID managerEmployeeID) {
<span class="nc" id="L1613">		BidOptionLoader loader = new BidOptionLoader(m_sessionContext);</span>
<span class="nc" id="L1614">		return loader.getBiddableScheduleRowsForAuction(param, managerEmployeeID);</span>
	}

	@Override
	public List&lt;BiddableScheduleRow&gt; getBiddableScheduleRows(Collection&lt;ID&gt; biddableSchedueIDs) {
<span class="nc" id="L1619">		BiddableScheduleLoaderDAO dao = new BiddableScheduleLoaderDAO();</span>
		try {
<span class="nc" id="L1621">			return dao.getBiddableScheduleRows(biddableSchedueIDs);</span>
		} finally {
<span class="nc" id="L1623">			dao.cleanUp();</span>
		}
	}

	@Override
	public List&lt;BidOptionRow&gt; getBidOptionsRows(ID auctionID, ID bidderID, Collection&lt;ID&gt; biddableSchedueIDs) {

<span class="nc" id="L1630">		BiddableScheduleLoaderDAO dao = new BiddableScheduleLoaderDAO();</span>
		try {
<span class="nc" id="L1632">			return dao.getBidOptionsRows(auctionID, bidderID, biddableSchedueIDs);</span>
		} finally {
<span class="nc" id="L1634">			dao.cleanUp();</span>
		}

	}

	@Override
	public Collection&lt;ShiftAssignment&gt; getShiftAssignments(Collection&lt;ID&gt; biddableSchedueIDs) {
<span class="nc" id="L1641">		BiddableScheduleLoaderDAO dao = new BiddableScheduleLoaderDAO();</span>
		try {
<span class="nc" id="L1643">			return dao.getShiftAssignments(biddableSchedueIDs);</span>

<span class="nc" id="L1645">		} catch (JdmoException e) {</span>
<span class="nc" id="L1646">			throw new RmRuntimeException(e);</span>
		} finally {
<span class="nc" id="L1648">			dao.cleanUp();</span>
		}
	}

	/**
	 * Updates the bonus and optionally the description fields of biddable schedules
	 * For biddable schedule ID that are in the set descriptionIDs, the description field will also be updated in the database.
	 */
	@Override
	public void updateBonusAndDescriptions(Collection&lt;BiddableSchedule&gt; biddableScheds, Set&lt;ID&gt; descriptionIDs) {
<span class="nc" id="L1658">		BiddableScheduleMiscDAO dao = new BiddableScheduleMiscDAO();</span>
		try {
<span class="nc" id="L1660">			dao.updateBonusAndDescriptions(biddableScheds, descriptionIDs);</span>
		} finally {
<span class="nc" id="L1662">			dao.cleanUp();</span>
<span class="nc" id="L1663">		}</span>
<span class="nc" id="L1664">	}</span>



<span class="nc" id="L1668">	protected static class ShiftBidderComparatorByScore implements Comparator {</span>

		int m_sortDir;

<span class="nc" id="L1672">		ShiftBidderComparatorByScore(int sortDirection) {</span>
<span class="nc" id="L1673">			m_sortDir = sortDirection;</span>
<span class="nc" id="L1674">		}</span>

		/*
		 * (non-Javadoc)
		 *
		 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		@Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L1683">			ShiftBidder bidder1 = (ShiftBidder) o1;</span>
<span class="nc" id="L1684">			ShiftBidder bidder2 = (ShiftBidder) o2;</span>

<span class="nc" id="L1686">			int bidder1Score = bidder1.getOptMethods().getScoreWithBonus();</span>
<span class="nc" id="L1687">			int bidder2Score = bidder2.getOptMethods().getScoreWithBonus();</span>

<span class="nc bnc" id="L1689" title="All 2 branches missed.">			return (m_sortDir == SupportNavigation.SORT_ASCENDING) ? (bidder1Score - bidder2Score)</span>
					: (bidder2Score - bidder1Score);
		}

	}

	@Override
	public Pair getShiftBiddersForAuction(ID auctionID, ID orgID, boolean allBidders, int sortBy, int sortDirection,
			int chunkSize, ID privIDOrgScoped, long detailLevel) throws RmException, RmHardValidationException {

<span class="nc" id="L1699">		return getShiftBiddersForAuction(auctionID, orgID, allBidders, sortBy, sortDirection,</span>
				chunkSize, privIDOrgScoped, detailLevel, false);
	}

	/*
	 * &lt;p&gt; See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getShiftBiddersForAuction(com.bluepumpkin.common.
	 * datatypes.ID, com.bluepumpkin.common.datatypes.ID, int)
	 */
	@Override
	public Pair&lt;List&lt;ID&gt;, List&lt;ShiftBidder&gt;&gt; getShiftBiddersForAuction(ID auctionID, ID orgID, boolean allBidders, int sortBy,
			int sortDirection,
			int chunkSize, ID privIDOrgScoped, long detailLevel, boolean ignoreOrgsAndPrivileges) throws RmException,
			RmHardValidationException {

<span class="nc" id="L1717">		String _method_ = &quot;getShiftBiddersForAuction&quot;;</span>
<span class="nc" id="L1718">		methodStart(_method_, auctionID, orgID, new Long(detailLevel));</span>
<span class="nc" id="L1719">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1720">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L1721">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1723">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1725">			detailLevel = adjustShiftBidderDetailLevel(detailLevel, sortBy);</span>

			// check for any changes to the employees assocaited with the
			// auction's SP.
<span class="nc" id="L1729">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
			// _checkForAddedOrDeletedShiftBidders(auctionID, bidderDAO, null);

			// get the auction object
<span class="nc" id="L1733">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID,</span>
					ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_CAMPAIGN);

<span class="nc" id="L1736">			Set orgIDsForCampSet = Collections.emptySet();</span>

			// We ignore orgs when we want all orgs and employees in an auction and disregard privileges
			// This is needed to simply show the agent his approval order ranking, so we
			// Are calling this function to sort all bidders.
<span class="nc bnc" id="L1741" title="All 2 branches missed.">			if (!ignoreOrgsAndPrivileges) {</span>
				// get the orgIDs to be used for fetching bidders.
<span class="nc" id="L1743">				orgIDsForCampSet = getOrgIDsForShiftBidderFetch(privIDOrgScoped, orgID, sbAuction);</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">				if (orgIDsForCampSet.isEmpty()) {</span>
<span class="nc" id="L1745">					return m_emptyCollsPair;</span>
				}
			}

<span class="nc bnc" id="L1749" title="All 2 branches missed.">			boolean inMemSortNeeded = sortBy == ShiftBidder.SORTBY_SCORE;</span>
<span class="nc" id="L1750">			List shiftBidders = null;</span>
<span class="nc" id="L1751">			List shiftBidderIDs = null;</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">			boolean fetchAllBidders = chunkSize == Integer.MAX_VALUE;</span>

<span class="nc bnc" id="L1754" title="All 6 branches missed.">			if (fetchAllBidders || (!fetchAllBidders &amp;&amp; inMemSortNeeded)) {</span>
				// get all bidders (sort @ SQL level if possible)
<span class="nc bnc" id="L1756" title="All 2 branches missed.">				shiftBidders = (List) bidderDAO.getShiftBiddersForAuction(auctionID, orgIDsForCampSet,</span>
						(allBidders) ? -1 : ShiftBidder.STATUS_ADDED, sortBy, sortDirection, detailLevel);

				// process detail level (which may be needed for the in memory
				// sort below).
<span class="nc" id="L1761">				processShiftBidderDetailLevel(sbAuction.getID(), shiftBidders, detailLevel, bidderDAO);</span>

				// apply sorting @ java level if necessary.
<span class="nc bnc" id="L1764" title="All 2 branches missed.">				if (inMemSortNeeded) {</span>
<span class="nc" id="L1765">					sortShiftBidders(shiftBidders, sortBy, sortDirection);</span>
				}

				// get (bidderIDs, bidders) tuple.
<span class="nc" id="L1769">				shiftBidderIDs = RequestUtil.getListOfIDsFromVOBases(shiftBidders);</span>
<span class="nc bnc" id="L1770" title="All 2 branches missed.">				if (!fetchAllBidders) {</span>
<span class="nc" id="L1771">					int numOfBidders = Math.min(shiftBidders.size(), chunkSize);</span>
					// Note: the subList is backed by the original list. Which
					// means marshalling
					// the sublist back to the caller (as a return value) will
					// marshall the entire
					// original list back.
					// shiftBidders = shiftBidders.subList(0, numOfBidders);
<span class="nc" id="L1778">					shiftBidders = new ArrayList(shiftBidders.subList(0, numOfBidders));</span>
<span class="nc" id="L1779">				}</span>
			} else {
				// (chunkSize != all &amp;&amp; inMemorySortNotNeeded)
				// get bidder IDs (sort @ SQL level).
				//
				// casting with the knowledge that the returned shiftBidders
				// collection is an ArrayList.
				// If this is violated, it will be easily detected since this
				// code is in the main path of
				// execution.
<span class="nc bnc" id="L1789" title="All 2 branches missed.">				shiftBidderIDs = (List) bidderDAO.getShiftBidderIDsForAuction(auctionID, orgIDsForCampSet,</span>
						(allBidders) ? -1 : ShiftBidder.STATUS_ADDED, sortBy, sortDirection);

<span class="nc" id="L1792">				int numOfBidderIDs = Math.min(shiftBidderIDs.size(), chunkSize);</span>
				// casting with the knowledge that the returned shiftBidders
				// collection is an ArrayList.
				// A violation of this will be easily detected since this is in
				// the main path of
				// execution.
<span class="nc" id="L1798">				shiftBidders = (List) bidderDAO.getShiftBiddersByIDs(shiftBidderIDs.subList(0, numOfBidderIDs), true,</span>
						detailLevel);

<span class="nc" id="L1801">				processShiftBidderDetailLevel(sbAuction.getID(), shiftBidders, detailLevel, bidderDAO);</span>
			}

<span class="nc" id="L1804">			validateShiftBiddersForFetchActionAndUpdate(shiftBidders, sbAuction, bidderDAO);</span>

			// return the sorted list
<span class="nc" id="L1807">			return new Pair(shiftBidderIDs, shiftBidders);</span>
<span class="nc" id="L1808">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L1810">			handleException(e);</span>
<span class="nc" id="L1811">			throw e;</span>
<span class="nc" id="L1812">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1821">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1822">			throw e;</span>
<span class="nc" id="L1823">		} catch (Exception e) {</span>
<span class="nc" id="L1824">			handleException(e);</span>
<span class="nc" id="L1825">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1827">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L1828">			cleanUp(bidderDAO);</span>
<span class="nc" id="L1829">			methodFinish();</span>
		}
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.
	 * IShiftBidAuctionManager#getNextShiftBidders(java.util.Collection, long)
	 */
	@Override
	public Collection getNextShiftBidders(ID auctionID, Collection bidderIDs, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L1843">		String _method_ = &quot;getNextShiftBidders&quot;;</span>
<span class="nc" id="L1844">		methodStart(_method_, auctionID, new Integer(bidderIDs.size()), new Long(detailLevel));</span>
<span class="nc" id="L1845">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1846">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L1847">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1849">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1851">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>

			// casting with the knowledge that the returned shiftBidders
			// collection is an ArrayList.
			// A violation of this will be easily detected since this is in the
			// main path of
			// execution.
<span class="nc" id="L1858">			Collection shiftBidders = bidderDAO.getShiftBiddersByIDs(bidderIDs, true, detailLevel);</span>

<span class="nc" id="L1860">			processShiftBidderDetailLevel(auctionID, shiftBidders, detailLevel, bidderDAO);</span>

			// get the auction object
<span class="nc" id="L1863">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID,</span>
					ShiftBidAuction.DL_BASIC | ShiftBidAuction.DL_CAMPAIGN);

			// validate fetched shiftBidders
<span class="nc" id="L1867">			validateShiftBiddersForFetchActionAndUpdate(shiftBidders, sbAuction, bidderDAO);</span>

<span class="nc" id="L1869">			return shiftBidders;</span>
<span class="nc" id="L1870">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.

<span class="nc" id="L1873">			handleException(e);</span>
<span class="nc" id="L1874">			throw e;</span>
<span class="nc" id="L1875">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1884">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1885">			throw e;</span>
<span class="nc" id="L1886">		} catch (Exception e) {</span>
<span class="nc" id="L1887">			handleException(e);</span>
<span class="nc" id="L1888">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc" id="L1891">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L1892">			cleanUp(bidderDAO);</span>

<span class="nc" id="L1894">			methodFinish();</span>
		}
	}

	/**
	 * &lt;p&gt;
	 * See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getShiftBidderForEmpID(com.bluepumpkin.common.datatypes.ID,
	 *      com.bluepumpkin.common.datatypes.ID, long)
	 */
	@Override
	public ShiftBidder getShiftBidderForEmpID(ID empID, ID auctionID, long detailLevel)
			throws RmException, RmHardValidationException {

<span class="nc" id="L1910">		String _method_ = &quot;getShiftBiddersForEmpID&quot;;</span>
<span class="nc" id="L1911">		methodStart(_method_, empID, auctionID, new Long(detailLevel));</span>
<span class="nc" id="L1912">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1913">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L1914">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1916">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// check for any changes to the employees assocaited with the
			// auction's SP.
<span class="nc" id="L1920">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
			// _checkForAddedOrDeletedShiftBidders(auctionID, bidderDAO, null);

<span class="nc" id="L1923">			ShiftBidder shiftBidder = bidderDAO.getShiftBidderForEmpAndAuctionID(empID, auctionID, detailLevel);</span>
<span class="nc bnc" id="L1924" title="All 2 branches missed.">			if (shiftBidder == null) {</span>
<span class="nc" id="L1925">				return shiftBidder;</span>
			}

<span class="nc" id="L1928">			ID bidderID = shiftBidder.getID();</span>

			// get the auction object
<span class="nc" id="L1931">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
<span class="nc" id="L1935">			Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(</span>
<span class="nc" id="L1936">					Collections.singleton(shiftBidder.getEmployeeID()), sbAuction, bidderDAO);</span>

<span class="nc" id="L1938">			Set&lt;ID&gt; terminatedEmployeeIDs = ShiftBidAuctionUtil.getTerminatedEmployeeIDs(sbAuction.getAuctionDeadLine());</span>

<span class="nc bnc" id="L1940" title="All 2 branches missed.">			shiftBidder = validateShiftBidderForFetchActionAndUpdate(shiftBidder, bidderDAO, null,</span>
					unavailableEmpIDs, terminatedEmployeeIDs) ? shiftBidder : null;

<span class="nc bnc" id="L1943" title="All 2 branches missed.">			if (shiftBidder != null) {</span>
<span class="nc" id="L1944">				processShiftBidderDetailLevel(auctionID, Collections.singletonList(shiftBidder), detailLevel,</span>
						bidderDAO);
			} else {
<span class="nc" id="L1947">				m_cat.debug(&quot;Validtion failed: Removing and not returning shiftBidder: ID = &quot; + bidderID);</span>
			}

<span class="nc" id="L1950">			return shiftBidder;</span>
<span class="nc" id="L1951">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L1953">			handleException(e);</span>
<span class="nc" id="L1954">			throw e;</span>
<span class="nc" id="L1955">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L1964">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1965">			throw e;</span>
<span class="nc" id="L1966">		} catch (Exception e) {</span>
<span class="nc" id="L1967">			handleException(e);</span>
<span class="nc" id="L1968">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1970">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L1971">			cleanUp(bidderDAO);</span>

<span class="nc" id="L1973">			methodFinish();</span>
		}
	}

	/**
	 * Gets the basic ShiftBidder data for the employee and specified auctions.
	 */
	@Override
	public Collection&lt;ShiftBidder&gt; getBasicShiftBidderForEmpAndAuctions(ID employeeID, Collection&lt;ID&gt; auctionIDs)
			throws RmException {
<span class="nc" id="L1983">		String methodName = &quot;getRawShiftBidderForEmpAndAuctions&quot;;</span>
<span class="nc" id="L1984">		methodStart(methodName, employeeID, auctionIDs);</span>
<span class="nc" id="L1985">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L1986">		String setterID = CLASS_NAME + '.' + methodName;</span>
<span class="nc" id="L1987">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L1989">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L1991">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L1993">			return bidderDAO.getShiftBidderForEmpAndAuctions(employeeID, auctionIDs, ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L1994">		} catch (Exception e) {</span>
<span class="nc" id="L1995">			handleException(e);</span>
<span class="nc" id="L1996">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1998">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L1999">			cleanUp(bidderDAO);</span>
<span class="nc" id="L2000">			methodFinish();</span>
		}
	}

	/**
	 * &lt;p&gt;
	 * See {@link ShiftBidder ShiftBidder} javadoc for a mapping of UI field
	 * names (when a shift bidder is displayed) and the corr. backend concepts.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#getShiftBidderByID(com.bluepumpkin.common.datatypes.ID,
	 *      long)
	 */
	@Override
	public ShiftBidder getShiftBidderByID(ID bidderID, long detailLevel) throws RmException, RmHardValidationException {

<span class="nc" id="L2015">		String _method_ = &quot;getShiftBiddersByID&quot;;</span>
<span class="nc" id="L2016">		methodStart(_method_, bidderID, new Long(detailLevel));</span>
<span class="nc" id="L2017">		ShiftBidderDAO bidderDAO = null;</span>

<span class="nc" id="L2019">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2020">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2022">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2024">			bidderDAO = new ShiftBidderDAO(detailLevel);</span>
<span class="nc" id="L2025">			ShiftBidder shiftBidder = bidderDAO.getShiftBidderByID(bidderID, detailLevel);</span>

			// get the auction object
<span class="nc" id="L2028">			ShiftBidAuction sbAuction = ShiftBidAuctionUtil._getAuctionByID(shiftBidder.getShiftBidAuctionID(),</span>
					ShiftBidAuction.DL_BASIC);

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
<span class="nc" id="L2033">			Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(</span>
<span class="nc" id="L2034">					Collections.singleton(shiftBidder.getEmployeeID()), sbAuction, bidderDAO);</span>
<span class="nc" id="L2035">			Set&lt;ID&gt; terminatedEmployeeIDs = ShiftBidAuctionUtil.getTerminatedEmployeeIDs(sbAuction.getStartTime());</span>

<span class="nc bnc" id="L2037" title="All 2 branches missed.">			shiftBidder = validateShiftBidderForFetchActionAndUpdate(shiftBidder, bidderDAO, null,</span>
					unavailableEmpIDs, terminatedEmployeeIDs) ? shiftBidder : null;

<span class="nc bnc" id="L2040" title="All 2 branches missed.">			if (shiftBidder != null) {</span>
<span class="nc" id="L2041">				processShiftBidderDetailLevel(shiftBidder.getShiftBidAuctionID(),</span>
<span class="nc" id="L2042">						Collections.singletonList(shiftBidder), detailLevel, bidderDAO);</span>
			} else {
<span class="nc" id="L2044">				m_cat.debug(&quot;Validtion failed: Removing and not returning shiftBidder: ID = &quot; + bidderID);</span>
			}

<span class="nc" id="L2047">			return shiftBidder;</span>
<span class="nc" id="L2048">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.

<span class="nc" id="L2051">			handleException(e);</span>
<span class="nc" id="L2052">			throw e;</span>
<span class="nc" id="L2053">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2062">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2063">			throw e;</span>
<span class="nc" id="L2064">		} catch (Exception e) {</span>
<span class="nc" id="L2065">			handleException(e);</span>
<span class="nc" id="L2066">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2068">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L2069">			cleanUp(bidderDAO);</span>
<span class="nc" id="L2070">			methodFinish();</span>
		}
	}

	/**
	 * Adding shift bidders to an auction involves switching their state from
	 * {@link ShiftBidder#STATUS_NOT_ADDED STATUS_NOT_ADDED} to
	 * {@link ShiftBidder#STATUS_ADDED STATUS_ADDED}
	 *
	 * @param shiftBidderIDs
	 *            ShiftBidders to add to this auction. If 'null', all
	 *            shiftBidders who have not been already added to the auction
	 *            are added.
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#addShiftBiddersToAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection, java.util.Date)
	 */
	@Override
	public void addShiftBiddersToAuction(ID auctionID, Collection shiftBidderIDs, Date deadLine)
			throws RmException, MultiUserException, RmHardValidationException {

<span class="nc" id="L2090">		String _method_ = &quot;addShiftBiddersToAuction&quot;;</span>
<span class="nc" id="L2091">		methodStart(_method_, auctionID, shiftBidderIDs);</span>
<span class="nc" id="L2092">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L2093">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
<span class="nc" id="L2094">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2095">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2097">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// fetch the auction object from DB
<span class="nc" id="L2100">			sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2101">			ShiftBidAuction sbAuc = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>


<span class="nc" id="L2104">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L2106">			Collection updatedBidders = getShiftBidderVOsFromDBUpdateAndValidate(sbAuc, shiftBidderIDs,</span>
					ShiftBidder.STATUS_ADDED, deadLine, bidderDAO);

<span class="nc" id="L2109">			bidderDAO.updateShiftBidders(updatedBidders);</span>
<span class="nc" id="L2110">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L2112">			handleException(e);</span>
<span class="nc" id="L2113">			throw e;</span>
<span class="nc" id="L2114">		} catch (RmHardValidationException e) {</span>


			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2123">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2124">			throw e;</span>
<span class="nc" id="L2125">		} catch (MultiUserException e) {</span>
<span class="nc" id="L2126">			m_cat.error(e, e);</span>
<span class="nc" id="L2127">			handleException(e);</span>
<span class="nc" id="L2128">			throw e;</span>
<span class="nc" id="L2129">		} catch (Exception e) {</span>
<span class="nc" id="L2130">			handleException(e);</span>
<span class="nc" id="L2131">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2133">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L2134">			cleanUp(bidderDAO);</span>
<span class="nc" id="L2135">			cleanUp(sbAuctionDAO);</span>
<span class="nc" id="L2136">			methodFinish();</span>
<span class="nc" id="L2137">		}</span>
<span class="nc" id="L2138">	}</span>

	/**
	 * Updates the Shift bidder's status from {@link ShiftBidder#STATUS_ADDED
	 * STATUS_ADDED} to {@link ShiftBidder#STATUS_NOT_ADDED STATUS_NOT_ADDED}
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#removeShiftBiddersFromAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection)
	 */
	@Override
	public void removeShiftBiddersFromAuction(ID auctionID, Collection shiftBidderIDs)
			throws RmException, RmHardValidationException, MultiUserException {

<span class="nc" id="L2151">		String _method_ = &quot;removeShiftBiddersFromAuction&quot;;</span>
<span class="nc" id="L2152">		methodStart(_method_, auctionID, shiftBidderIDs);</span>
<span class="nc" id="L2153">		ShiftBidderDAO bidderDAO = null;</span>
<span class="nc" id="L2154">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
<span class="nc" id="L2155">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2156">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2158">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

			// fetch the auction object from DB
<span class="nc" id="L2161">			sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2162">			ShiftBidAuction sbAuc = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>



<span class="nc" id="L2166">			bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>

<span class="nc" id="L2168">			Collection updatedBidders = getShiftBidderVOsFromDBUpdateAndValidate(sbAuc, shiftBidderIDs,</span>
					ShiftBidder.STATUS_NOT_ADDED, null, bidderDAO);

<span class="nc" id="L2171">			bidderDAO.updateShiftBidders(updatedBidders);</span>
<span class="nc" id="L2172">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.

<span class="nc" id="L2175">			handleException(e);</span>
<span class="nc" id="L2176">			throw e;</span>
<span class="nc" id="L2177">		} catch (RmHardValidationException e) {</span>

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2185">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2186">			throw e;</span>
<span class="nc" id="L2187">		} catch (MultiUserException e) {</span>
<span class="nc" id="L2188">			m_cat.error(e, e);</span>
<span class="nc" id="L2189">			handleException(e);</span>
<span class="nc" id="L2190">			throw e;</span>
<span class="nc" id="L2191">		} catch (Exception e) {</span>
<span class="nc" id="L2192">			handleException(e);</span>
<span class="nc" id="L2193">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2195">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L2196">			cleanUp(bidderDAO);</span>
<span class="nc" id="L2197">			cleanUp(sbAuctionDAO);</span>
<span class="nc" id="L2198">			methodFinish();</span>
<span class="nc" id="L2199">		}</span>
<span class="nc" id="L2200">	}</span>

	/**
	 * @see com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.IShiftBidAuctionManager#updateShiftBiddersForAuction(com.bluepumpkin.common.datatypes.ID,
	 *      java.util.Collection)
	 */
	@Override
	public void updateShiftBiddersForAuction(ID auctionID, Collection givenBidders)
			throws RmException, RmHardValidationException, MultiUserException {

<span class="nc" id="L2210">		String _method_ = &quot;updateShiftBiddersForAuction&quot;;</span>
<span class="nc" id="L2211">		methodStart(_method_, auctionID, givenBidders);</span>
<span class="nc" id="L2212">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2213">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2215">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L2217">			ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(auctionID, givenBidders, null, null);</span>
<span class="nc" id="L2218">		} catch (RmException e) {</span>
			// RM exceptions are always logged before they are thrown.
<span class="nc" id="L2220">			handleException(e);</span>
<span class="nc" id="L2221">			throw e;</span>
<span class="nc" id="L2222">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.

			// Logged with priority 'debug' since this exception is generated by
			// RM during validations or
			// workflow processing and happens often during normal operation. If
			// logged with a different
			// priority level (like info), it may pollute the log files with
			// unwanted messages.
<span class="nc" id="L2231">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L2232">			throw e;</span>
<span class="nc" id="L2233">		} catch (MultiUserException e) {</span>
<span class="nc" id="L2234">			m_cat.error(e, e);</span>
<span class="nc" id="L2235">			handleException(e);</span>
<span class="nc" id="L2236">			throw e;</span>
<span class="nc" id="L2237">		} catch (Exception e) {</span>
<span class="nc" id="L2238">			handleException(e);</span>
<span class="nc" id="L2239">			throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L2241">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L2242">			methodFinish();</span>
<span class="nc" id="L2243">		}</span>
<span class="nc" id="L2244">	}</span>





	/**
	 * Sets number of shift bid requests,score with bonus, and score without bonus for the bidders
	 */
	private void processShiftBidderDetailLevel(ID sbAuctionID, Collection&lt;ShiftBidder&gt; shiftBidders, long detailLevel,
			ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc bnc" id="L2256" title="All 2 branches missed.">		boolean needRequestCount = (detailLevel &amp; ShiftBidder.DL_NUMBER_OF_SHIFTBIDREQUESTS) != 0;</span>
<span class="nc bnc" id="L2257" title="All 2 branches missed.">		boolean needScore = (detailLevel &amp; ShiftBidder.DL_SHIFTBIDDER_SCORE) != 0;</span>

<span class="nc bnc" id="L2259" title="All 6 branches missed.">		if (shiftBidders.isEmpty() || (!needRequestCount &amp;&amp; !needScore)) {</span>
<span class="nc" id="L2260">			return;</span>
		}

<span class="nc" id="L2263">		Map&lt;ID, Integer&gt; bidderToRequestCount = Collections.emptyMap();</span>
<span class="nc" id="L2264">		Map&lt;ID, Pair&lt;Integer, Integer&gt;&gt; bidderToScore = Collections.emptyMap();</span>
<span class="nc" id="L2265">		List&lt;ID&gt; bidderIDs = DAOUtil.valueObjectsToIdList(shiftBidders);</span>

<span class="nc bnc" id="L2267" title="All 2 branches missed.">		if (needRequestCount) {</span>
<span class="nc" id="L2268">			ShiftBidRequestDAO sbReqDAO = new ShiftBidRequestDAO(bidderDAO.getDMO(), Request.DL_BASIC);</span>
<span class="nc" id="L2269">			bidderToRequestCount = sbReqDAO.getNumOfShiftBidRequestsForBidders(bidderIDs);</span>
		}

<span class="nc bnc" id="L2272" title="All 2 branches missed.">		if (needScore) {</span>
<span class="nc" id="L2273">			bidderToScore = bidderDAO.getShiftBidderScore(sbAuctionID, null);</span>
		}

<span class="nc bnc" id="L2276" title="All 2 branches missed.">		for (ShiftBidder bidder : shiftBidders) {</span>

<span class="nc" id="L2278">			ID bidderID = bidder.getID();</span>
<span class="nc" id="L2279">			ID employeeId = bidder.getEmployeeID();</span>

<span class="nc bnc" id="L2281" title="All 2 branches missed.">			if (needRequestCount) {</span>
<span class="nc" id="L2282">				Integer numOfReqs = bidderToRequestCount.get(bidderID);</span>
<span class="nc bnc" id="L2283" title="All 2 branches missed.">				bidder.getSetters().setNumOfShiftBidRequests(numOfReqs == null ? 0 : numOfReqs);</span>
			}

<span class="nc bnc" id="L2286" title="All 2 branches missed.">			if (needScore) {</span>
<span class="nc" id="L2287">				bidder.setScores(bidderToScore.get(employeeId));</span>
			}
<span class="nc" id="L2289">		}</span>

<span class="nc" id="L2291">	}</span>

	/**
	 * &lt;li&gt;Fetch shift bidder VOs for the specified bidder IDs from the DB.
	 * &lt;li&gt;update the specified fields (status and deadline specified as
	 * parameters) for each shift bidder.
	 * &lt;li&gt;validate the updated bidder VO.
	 *
	 * @param sbAuction
	 * @param shiftBidderIDs
	 * @param newStatus
	 * @param newDeadline
	 * @param bidderDao
	 * @return
	 * @throws Exception
	 */
	private List getShiftBidderVOsFromDBUpdateAndValidate(ShiftBidAuction sbAuction, Collection shiftBidderIDs,
			int newStatus, Date newDeadline, ShiftBidderDAO bidderDao) throws Exception {
<span class="nc" id="L2309">		m_cat.debug(&quot;updating shiftBidder collection with: newStatus, newDeadline: &quot; + newStatus + ',' + newDeadline);</span>

<span class="nc" id="L2311">		ShiftBidAuctionDAO sbAuctionDAO = null;</span>
		try {
			// load the given shiftBidder IDs from the DB.
<span class="nc" id="L2314">			Collection biddersFromDB = bidderDao.getShiftBiddersByIDs(shiftBidderIDs, false,</span>
<span class="nc" id="L2315">					ShiftBidder.getDetailLevelForValidation());</span>

			// get list of employee IDs for shift Bidder VO.
<span class="nc" id="L2318">			List biddersFromDBEmpIDs = RequestUtil.getListOfFieldValuesFromVOBases(biddersFromDB,</span>
					ShiftBidderFieldInfo.SHIFTBIDDER_I_EMPLOYEEID);

			// determine which of these bidders are scheduled (ie. have shift
			// assignments in the unpub sched).
			//if the &quot;include schedule employees option is selected in the Auction,
			// then mark the employees which have approved bids in this auction as &quot;Scheduled&quot;
<span class="nc" id="L2325">			Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil</span>
<span class="nc" id="L2326">					.getUnavailableEmpIdsForAuction(biddersFromDBEmpIDs, sbAuction, bidderDao);</span>
<span class="nc" id="L2327">			Set&lt;ID&gt; terminatedEmployeeIDs = ShiftBidAuctionUtil.getTerminatedEmployeeIDs(sbAuction.getAuctionDeadLine());</span>

<span class="nc" id="L2329">			List updatedBidders = new ArrayList(biddersFromDB.size());</span>
<span class="nc bnc" id="L2330" title="All 2 branches missed.">			for (Iterator biddersFromDBIter = biddersFromDB.iterator(); biddersFromDBIter.hasNext();) {</span>
<span class="nc" id="L2331">				ShiftBidder bidderFromDB = (ShiftBidder) biddersFromDBIter.next();</span>

				// retrieve the shift bid auction for the given auctionID if
				// necessary. Assuming here that
				// all given shift bidder IDs belong to the same shift bid
				// auction.
<span class="nc bnc" id="L2337" title="All 2 branches missed.">				if (sbAuction == null) {</span>
<span class="nc" id="L2338">					sbAuctionDAO = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2339">					sbAuction = sbAuctionDAO.getAuctionByID(bidderFromDB.getShiftBidAuctionID(),</span>
							ShiftBidAuction.DL_BASIC);
				}

				// clone above does a shallow copy except for the
				// ValueObjectBase.m_arrFieldValues. This array
				// is replaced with a newly allocated array and the contents of
				// the orignal array are copied to it.
<span class="nc" id="L2347">				ShiftBidder updatedBidder = (ShiftBidder) bidderFromDB.clone();</span>
				// Note: the Integer object instance to represent 'status' in
				// ValueObjectBase.m_arrFieldValues is shared by updatedBidder
				// and bidderFromDB. The
				// call below replaces this Integer reference in updateBidder.
				// Instead of replacing, if the Integer
				// instance was modified in place, then both updateBidder and
				// bidderFromDB would be
				// referencing the same modified Integer instance which is not
				// what we want.
<span class="nc" id="L2357">				updatedBidder.getSetters().setStatus(newStatus);</span>

<span class="nc" id="L2359">				updatedBidder.setDeadlineDate(newDeadline);</span>

<span class="nc" id="L2361">				ValidationResult hardValResult = ShiftBidAuctionUtil.validateShiftBidderAndUpdate(updatedBidder,</span>
						bidderFromDB, RequestUtil.ACTION_UPDATE, sbAuction, unavailableEmpIDs, terminatedEmployeeIDs);

				// TODO: handle better. Must mark the shiftBidder as invalid if
				// failed due to employee expired.
<span class="nc bnc" id="L2366" title="All 2 branches missed.">				if (hardValResult != null) {</span>
<span class="nc bnc" id="L2367" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2368">						String valResMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L2369">								TimeZone.getDefault());</span>

<span class="nc" id="L2371">						m_cat.debug(</span>
<span class="nc" id="L2372">								&quot;Bidder not added to update list: ID, msg: &quot; + updatedBidder.getID() + ',' + valResMsg);</span>
<span class="nc" id="L2373">					}</span>
					// and do not add to the updated list.
				} else {
					// if any soft validation results exist, dump them to the
					// log.
<span class="nc bnc" id="L2378" title="All 2 branches missed.">					if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2379">						Collection valResults = updatedBidder.getValidationResults(false);</span>
<span class="nc bnc" id="L2380" title="All 2 branches missed.">						for (Iterator valResultsIter = valResults.iterator(); valResultsIter.hasNext();) {</span>
<span class="nc" id="L2381">							ValidationResult softValResult = (ValidationResult) valResultsIter.next();</span>

<span class="nc" id="L2383">							String softValResMsg = softValResult.getLocalizedMessage(</span>
<span class="nc" id="L2384">									RequestUtil.getLocalizerForAppDefLocale(), TimeZone.getDefault());</span>

<span class="nc" id="L2386">							m_cat.debug(&quot;Updated for bidder ID: &quot; + updatedBidder.getID() + ':' + softValResMsg);</span>
<span class="nc" id="L2387">						}</span>
					}

<span class="nc" id="L2390">					updatedBidders.add(updatedBidder);</span>
<span class="nc" id="L2391">					m_cat.debug(&quot;Bidder added to update list: ID: &quot; + updatedBidder.getID());</span>
				}
<span class="nc" id="L2393">			}</span>

<span class="nc" id="L2395">			return updatedBidders;</span>
		} finally {
<span class="nc" id="L2397">			cleanUp(sbAuctionDAO);</span>
		}
	}

	/**
	 * returns true, if validation succeeded. If any updates were made then the
	 * shiftBidder is either updated in the DB or added to the given update
	 * collection (see parameter descriptions). If validation fails, returns
	 * false.
	 *
	 * @param shiftBidder
	 * @param bidderDAO
	 *            if non-null, then the updated shift bidder, after validation,
	 *            will be posted to the DB. If null, ignored.
	 * @param updatedBidders
	 *            if non-null, then the updated shift bidder, after validation,
	 *            will be added to this collection. If null, ignored.
	 * @return if validation succeeds. false otherwise. Also updatedBidders
	 *         collection is modified if non-null. DB udpates are made if
	 *         bidderDAO is non null.
	 * @throws Exception
	 */
	protected boolean validateShiftBidderForFetchActionAndUpdate(ShiftBidder shiftBidder, ShiftBidderDAO bidderDAO,
			Collection updatedBidders, Collection&lt;ID&gt; unavailableEmpIDs, Set&lt;ID&gt; terminatedEmployeeIDs) throws Exception {

		// validate the shiftBidder.
<span class="nc" id="L2423">		ValidationResult hardValResult = ShiftBidAuctionUtil.validateShiftBidderAndUpdate(shiftBidder, null,</span>
				RequestUtil.ACTION_FETCH, null, unavailableEmpIDs, terminatedEmployeeIDs);

<span class="nc" id="L2426">		boolean isValid = false;</span>
		// if hard validation error.
<span class="nc bnc" id="L2428" title="All 2 branches missed.">		if (hardValResult != null) {</span>
<span class="nc" id="L2429">			String hardValMsg = hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L2430">					TimeZone.getDefault());</span>
<span class="nc" id="L2431">			m_cat.debug(&quot;Error when validating shift bidder: &quot; + hardValMsg);</span>

<span class="nc" id="L2433">			isValid = false;</span>
			// No hard validation errors.
<span class="nc" id="L2435">		} else {</span>
			// get soft validation errors
<span class="nc" id="L2437">			Collection valResults = shiftBidder.getValidationResults(false);</span>
			// if any soft validation errors were found (which resulted in a
			// bidder field update)
<span class="nc bnc" id="L2440" title="All 4 branches missed.">			boolean bidderFieldsWereUpdated = (valResults != null &amp;&amp; !valResults.isEmpty());</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2442">				logBidderValResults(shiftBidder, valResults);</span>
			}

			// post to DB if any updates were done.
<span class="nc bnc" id="L2446" title="All 4 branches missed.">			if (bidderDAO != null &amp;&amp; bidderFieldsWereUpdated) {</span>
<span class="nc" id="L2447">				bidderDAO.updateShiftBidders(Collections.singletonList(shiftBidder));</span>
			}

			// add to updated list if any updates were done
<span class="nc bnc" id="L2451" title="All 4 branches missed.">			if (updatedBidders != null &amp;&amp; bidderFieldsWereUpdated) {</span>
<span class="nc" id="L2452">				updatedBidders.add(shiftBidder);</span>
			}

<span class="nc" id="L2455">			isValid = true;</span>
		}

		// if no hard or soft validation errors
<span class="nc" id="L2459">		return isValid;</span>
	}

	private void logBidderValResults(ShiftBidder shiftBidder, Collection valResults) {
<span class="nc bnc" id="L2463" title="All 2 branches missed.">		for (Iterator valResultsIter = valResults.iterator(); valResultsIter.hasNext();) {</span>
<span class="nc" id="L2464">			ValidationResult softValResult = (ValidationResult) valResultsIter.next();</span>
<span class="nc" id="L2465">			String softValResMsg = softValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L2466">					TimeZone.getDefault());</span>

<span class="nc" id="L2468">			m_cat.debug(&quot;updating shift bidder = &quot; + shiftBidder.getID() + ':' + softValResMsg);</span>
<span class="nc" id="L2469">		}</span>
<span class="nc" id="L2470">	}</span>

	/**
	 * @param detailLevel
	 * @param sortBy
	 * @return
	 */
	private long adjustShiftBidderDetailLevel(long detailLevel, int sortBy) {
<span class="nc bnc" id="L2478" title="All 8 branches missed.">		if (sortBy == ShiftBidder.SORTBY_POINTS || sortBy == ShiftBidder.SORTBY_RANK</span>
				|| sortBy == ShiftBidder.SORTBY_SCORE || sortBy == ShiftBidder.SORTBY_SENIORITY) {
<span class="nc" id="L2480">			detailLevel |= ShiftBidder.DL_EMPLOYEE;</span>
		}

<span class="nc bnc" id="L2483" title="All 2 branches missed.">		if (sortBy == ShiftBidder.SORTBY_SCORE) {</span>
<span class="nc" id="L2484">			detailLevel |= ShiftBidder.DL_SHIFTBIDDER_SCORE;</span>
		}

<span class="nc" id="L2487">		return detailLevel;</span>
	}

	/**
	 * @param shiftBidders
	 * @param sortBy
	 * @param sortDirection
	 */
	private void sortShiftBidders(List shiftBidders, int sortBy, int sortDirection) {
		// currently no separate detailLevel is defined for computing score and
		// bonus for shift bidder.
		// sort by employee's score if requested.
<span class="nc bnc" id="L2499" title="All 4 branches missed.">		if (sortBy == ShiftBidder.SORTBY_SCORE &amp;&amp; shiftBidders.size() &gt; 1) {</span>
			// Using DAO internal implementation knowledge that the returned
			// collection is an array list.
			// Any change to this fact, within the DAO, will be detected quickly
			// since
			// this is a common path of execution.
			// Casting collection to list is much faster than using the
			// collection to build a list.
<span class="nc" id="L2507">			List shiftBiddersList = shiftBidders;</span>
<span class="nc" id="L2508">			Collections.sort(shiftBiddersList, new ShiftBidderComparatorByScore(sortDirection));</span>
		}
<span class="nc" id="L2510">	}</span>

	/**
	 * update bidder status by scanning schedule.
	 *
	 * @param shiftBidders
	 * @param sbAuction
	 * @param bidderDAO
	 * @throws Exception
	 */
	private void validateShiftBiddersForFetchActionAndUpdate(Collection shiftBidders, ShiftBidAuction sbAuction,
			ShiftBidderDAO bidderDAO) throws Exception {
		// determine which of these bidders are scheduled (ie. have shift
		// assignments in the unpub sched).
<span class="nc" id="L2524">		List bidderEmpIDs = RequestUtil.getListOfFieldValuesFromVOBases(shiftBidders,</span>
				ShiftBidderFieldInfo.SHIFTBIDDER_I_EMPLOYEEID);
<span class="nc" id="L2526">		Collection&lt;ID&gt; unavailableEmpIDs = ShiftBidAuctionUtil.getUnavailableEmpIdsForAuction(bidderEmpIDs, sbAuction, bidderDAO);</span>

<span class="nc" id="L2528">		List updatedBidders = new ArrayList(10);</span>
<span class="nc" id="L2529">		Set&lt;ID&gt; terminatedEmployeeIDs = ShiftBidAuctionUtil.getTerminatedEmployeeIDs(sbAuction.getAuctionDeadLine());</span>

<span class="nc bnc" id="L2531" title="All 2 branches missed.">		for (Iterator shiftBiddersIter = shiftBidders.iterator(); shiftBiddersIter.hasNext();) {</span>
<span class="nc" id="L2532">			ShiftBidder bidder = (ShiftBidder) shiftBiddersIter.next();</span>

			// Note: method below does not post updates to the DB since passed
			// bidderDAO is 'null'
<span class="nc" id="L2536">			boolean valSuccess = validateShiftBidderForFetchActionAndUpdate(bidder, null, updatedBidders,</span>
					unavailableEmpIDs, terminatedEmployeeIDs);
<span class="nc bnc" id="L2538" title="All 2 branches missed.">			if (!valSuccess) { // if validation failed, remove bidder.</span>
<span class="nc" id="L2539">				m_cat.debug(&quot;Error: removing invalid bidder from collection: ID = &quot; + bidder.getID());</span>
<span class="nc" id="L2540">				shiftBiddersIter.remove();</span>
			}
<span class="nc" id="L2542">		}</span>

		// if any updates during validation, post to DB.
<span class="nc bnc" id="L2545" title="All 2 branches missed.">		if (!updatedBidders.isEmpty()) {</span>
<span class="nc" id="L2546">			m_cat.debug(&quot;updating bidders in DB: size = &quot; + updatedBidders.size());</span>
<span class="nc" id="L2547">			bidderDAO.updateShiftBidders(updatedBidders);</span>
		}
<span class="nc" id="L2549">	}</span>

	/**
	 * Determines the orgIDs to be used for fetching the bidders using the
	 * specified orgID and privilege ID.
	 *
	 * @param privIDOrgScoped
	 * @param orgID
	 * @param sbAuction
	 * @return
	 * @throws Exception
	 */
	private Set getOrgIDsForShiftBidderFetch(ID privIDOrgScoped, ID orgID, ShiftBidAuction sbAuction) throws Exception {

<span class="nc" id="L2563">		ID campaignID = sbAuction.getOptMethods().getCampaignID();</span>

		// get orgIDs for which the user has the specified privilege
<span class="nc" id="L2566">		Collection orgIDsWithPriv = RequestUtil</span>
<span class="nc" id="L2567">				.getOrgIDsWithPrivForUserName(RequestUtil.getLoginUserName(m_sessionContext), privIDOrgScoped, null);</span>

		// if no orgIDs with specified priv exist, return.
<span class="nc bnc" id="L2570" title="All 2 branches missed.">		if (orgIDsWithPriv.isEmpty()) {</span>
<span class="nc" id="L2571">			m_cat.debug(&quot;Returning empty collection.  No org IDs with specified &quot; + &quot;privilege exist: privID = &quot;</span>
					+ privIDOrgScoped);
<span class="nc" id="L2573">			return Collections.emptySet();</span>
		}

		// Get Auctions Org ID
<span class="nc" id="L2577">		ID auctionOrgID = ShiftBidAuctionUtil.getIDFromValue(sbAuction.getOrganizationId());</span>

		// get org IDs assocaited with this campaign week if no orgID was
		// specified
<span class="nc" id="L2581">		Set orgIDsForCampSet = null;</span>
<span class="nc bnc" id="L2582" title="All 2 branches missed.">		if (orgID == null) {</span>
			// If Concurrent Auction and Auction Org is not null
			// get auction org plus its decendents
<span class="nc bnc" id="L2585" title="All 4 branches missed.">			if (sbAuction.isConcurrentAuction() &amp;&amp; auctionOrgID != null) {</span>
<span class="nc" id="L2586">				orgIDsForCampSet = new HashSet();</span>
<span class="nc" id="L2587">				Collection&lt;ID&gt; orgIDs = ShiftBidAuctionUtil.getConcurrentAuctionOrgs(sbAuction);</span>
<span class="nc" id="L2588">				orgIDsForCampSet.addAll(orgIDs);</span>
<span class="nc" id="L2589">			} else {</span>
<span class="nc" id="L2590">				Collection campOrgs = RequestUtil.getCampOrgAssignments(campaignID, sbAuction.getStartTime(),</span>
<span class="nc" id="L2591">						sbAuction.getEndTime(), null);</span>
<span class="nc" id="L2592">				List campOrgIDs = RequestUtil.getListOfFieldValuesFromVOBases(campOrgs,</span>
						CampaignOrgFieldInfo.CAMPAIGNORG_ORGANIZATIONID);
<span class="nc" id="L2594">				orgIDsForCampSet = RequestUtil.getSetFromCollection(campOrgIDs);</span>
<span class="nc" id="L2595">			}</span>
			// if an orgID was specified.
		} else {
			// do not use Collections.singleton() as a mutable set is needed.
<span class="nc" id="L2599">			orgIDsForCampSet = new HashSet();</span>
<span class="nc" id="L2600">			orgIDsForCampSet.add(orgID);</span>
		}

		// restrict campaign orgIDs using the privileged orgIDs.
<span class="nc" id="L2604">		orgIDsForCampSet.retainAll(orgIDsWithPriv);</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">		if (orgIDsForCampSet.isEmpty()) {</span>
<span class="nc" id="L2606">			m_cat.debug(&quot;Returning empty collection.  No org IDs for aution with specified &quot;</span>
					+ &quot;privilege exist after apply privilege constraint: privID = &quot; + privIDOrgScoped);
<span class="nc" id="L2608">			return Collections.emptySet();</span>
		}

<span class="nc" id="L2611">		return orgIDsForCampSet;</span>
	}

	/**
	* Return the pair of Id and Names of Shift Bid Auction Names in given organization Ids-employees of those organizations added to those shift bid auctions
	* @param organizationIDs
	*/
	@Override
	public Collection&lt;StringsPair&gt; getAuctionNamesInGiveOrgIds(Collection&lt;ID&gt; organizationIDs) throws BbmFinderException {
<span class="nc" id="L2620">		String _method_ = &quot;getAuctionNamesInGiveOrgIds&quot;;</span>
<span class="nc" id="L2621">		methodStart(_method_, organizationIDs);</span>
<span class="nc" id="L2622">		ShiftBidAuctionDAO auctionDao = null;</span>
<span class="nc" id="L2623">		String setterID = CLASS_NAME + '.' + _method_;</span>
<span class="nc" id="L2624">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L2626">			cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>
<span class="nc" id="L2627">			auctionDao = new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L2628">			return auctionDao.getAuctionListForFilter(organizationIDs);</span>
<span class="nc" id="L2629">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2630">			m_cat.error(e, e);</span>
<span class="nc" id="L2631">			handleException(e);</span>
<span class="nc" id="L2632">			throw e;</span>
<span class="nc" id="L2633">		} catch (Exception e) {</span>
<span class="nc" id="L2634">			handleException(e);</span>
<span class="nc" id="L2635">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {

<span class="nc" id="L2638">			cleanUp(auctionDao);</span>
<span class="nc" id="L2639">			disableThreadLocalCacheIf(cacheEnabled, setterID);</span>
<span class="nc" id="L2640">			methodFinish();</span>
		}
	}

	@Override
	public ShiftAssignment getBiddableShiftAssignment(ID biddableShiftAssignmentID) {
<span class="nc" id="L2646">		BiddableScheduleLoaderDAO dao = new BiddableScheduleLoaderDAO();</span>
		try {
<span class="nc" id="L2648">			return dao.getBiddableShiftAssignment(biddableShiftAssignmentID);</span>
<span class="nc" id="L2649">		} catch (JdmoException e) {</span>
<span class="nc" id="L2650">			throw new RmRuntimeException(e);</span>
		} finally {
<span class="nc" id="L2652">			dao.cleanUp();</span>
		}
	}

	@Override
	public List&lt;ID&gt; getSkillIdsForBiddableSchedule(ID biddableScheduleID) {
<span class="nc" id="L2658">		BiddableScheduleLoaderDAO dao = new BiddableScheduleLoaderDAO();</span>
		try {
<span class="nc" id="L2660">			return dao.getSkillIdsForBiddableSchedule(biddableScheduleID);</span>
		} finally {
<span class="nc" id="L2662">			dao.cleanUp();</span>
		}
	}

	@Override
	public Map&lt;String, String&gt; resynchronizeAuctionSchedules(ID auctionID, boolean update) {
<span class="nc" id="L2668">		BiddableScheduleMiscDAO dao = new BiddableScheduleMiscDAO();</span>
		try {
<span class="nc" id="L2670">			return dao.resynchronizeAuctionSchedules(auctionID, update);</span>
<span class="nc" id="L2671">		} catch (JdmoException e) {</span>
<span class="nc" id="L2672">			throw new RmRuntimeException(e);</span>
		} finally {
<span class="nc" id="L2674">			dao.cleanUp();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>