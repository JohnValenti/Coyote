<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeInterval.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.time</a> &gt; <span class="el_source">TimeInterval.java</span></div><h1>TimeInterval.java</h1><pre class="source lang-java linenums">/*
 * (c) 2009-2011 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.time;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;

import com.bluepumpkin.common.datatypes.TimeContext;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;

//TODO: Rick has pointed out that this would be much more usable if it did not have
// the TimeContext.  In particular you could get rid of the TimeIntervalFactory
// altogether. Methods could take the TimeContext as an argument.
// There are many legitimate clients to the methods that use the TimeContext,
// so this refactoring would be nontrivial.
/**
 * An instance of this immutable class represents a duration of time. This
 * duration is expressed as a time unit and a count.
 * 
 * The time unit must be interpreted in light of a TimeContext because of
 * considerations such as daylight saving time and campaign day boundaries.
 */
public final class TimeInterval {
	// Be wary of using these values as DST transition days do not
	// contain the same number of hours/minutes/seconds as regular days.
	public static final int MILLIS_PER_SECOND = 1000;
	public static final int SECONDS_PER_MINUTE = 60;
	public static final int MILLIS_PER_MINUTE = MILLIS_PER_SECOND * SECONDS_PER_MINUTE;
	public static final int MINUTES_PER_HOUR = 60;
	public static final int HOURS_PER_DAY = 24;
	public static final int MILLIS_PER_DAY = MILLIS_PER_MINUTE * MINUTES_PER_HOUR * HOURS_PER_DAY;
	public static final int DAYS_PER_WEEK = 7;
	public static final int MILLIS_PER_WEEK = MILLIS_PER_DAY * DAYS_PER_WEEK;

	private final TimeUnits m_units;
	private final int m_count;
	// m_size may be interpreted as a number of minutes or as the number of
	// days, weeks, or months in the interval, depending on the units. It
	// is not necessarily interpreted as m_units units.
	private final int m_size;
	// This is a scratch object used by getNextTime(). It is a
	// member variable to avoid unnecessary object creation.
	private final Calendar m_calendarForGetNextTime;

	private final TimeContext m_timeContext;

	/**
	 * An enumeration which specifies how the start of a day is to be
	 * determined. There are two options: UseDayBoundary, which uses this
	 * TimeInterval's time context to determine the start of day, and
	 * UseMidnight, which ignores the day boundary in the time context and uses
	 * Midnight.
	 *
	 * This enumeration is used in the divideBy, getIntervalSubdivisions, and
	 * getStartTime methods.
	 */
<span class="nc" id="L60">	public enum DayStartPolicy {</span>
<span class="nc" id="L61">		UseDayBoundary, UseMidnight</span>
	};

	/**
	 * Creates a time interval having the specified number of the specified
	 * units (e.g., 15 minutes, 2 weeks).
	 * 
	 * @param units
	 * @param count
	 * @param timeZone
	 *            the time zone in which this TimeInterval will use in its
	 *            internal calculations
	 * @param startDayOfWeek
	 *            the day defined to be the first day of the week for the
	 *            purposes of this TimeInterval
	 * @param dayBoundary
	 *            the time in minutes past midnight at which a day is defined to
	 *            start for the purposes of this TimeInterval
	 */
<span class="nc" id="L80">	public TimeInterval(TimeUnits units, int count, TimeContext timeContext) {</span>
<span class="nc" id="L81">		m_units = units;</span>
<span class="nc" id="L82">		m_count = count;</span>
<span class="nc" id="L83">		m_timeContext = timeContext;</span>
<span class="nc" id="L84">		m_calendarForGetNextTime = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc bnc" id="L85" title="All 6 branches missed.">		switch (units) {</span>
		case Minute:
<span class="nc" id="L87">			m_size = count;</span>
<span class="nc" id="L88">			break;</span>
		case Hour:
<span class="nc" id="L90">			m_size = count * MINUTES_PER_HOUR;</span>
<span class="nc" id="L91">			break;</span>
		case Day:
<span class="nc" id="L93">			m_size = count;</span>
<span class="nc" id="L94">			break;</span>
		case Week:
<span class="nc" id="L96">			m_size = count;</span>
<span class="nc" id="L97">			break;</span>
		case Month:
<span class="nc" id="L99">			m_size = count;</span>
<span class="nc" id="L100">			break;</span>
		default:
<span class="nc" id="L102">			throw new UnsupportedOperationException(&quot;TimeInterval does not support units &quot; + units);</span>
		}
<span class="nc" id="L104">	}</span>

	/**
	 * Creates a time interval spanning from the specified start time to
	 * immediately before the specified end time.
	 * 
	 * @param units
	 * @param startTime
	 * @param endTime
	 * @param timeZone
	 *            the time zone in which this TimeInterval will use in its
	 *            internal calculations
	 * @param startDayOfWeek
	 *            the day defined to be the first day of the week for the
	 *            purposes of this TimeInterval
	 * @param dayBoundary
	 *            the time in minutes past midnight at which a day is defined to
	 *            start for the purposes of this TimeInterval
	 */
<span class="nc" id="L123">	public TimeInterval(TimeUnits units, Date startTime, Date endTime, TimeContext timeContext) {</span>
<span class="nc" id="L124">		m_units = units;</span>
<span class="nc" id="L125">		m_timeContext = timeContext;</span>
<span class="nc" id="L126">		m_calendarForGetNextTime = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc bnc" id="L127" title="All 6 branches missed.">		switch (units) {</span>
		case Minute:
<span class="nc" id="L129">			m_size = (int) ((endTime.getTime() - startTime.getTime()) / MILLIS_PER_MINUTE);</span>
<span class="nc" id="L130">			m_count = m_size;</span>
<span class="nc" id="L131">			break;</span>
		case Hour:
<span class="nc" id="L133">			m_size = (int) ((endTime.getTime() - startTime.getTime()) / MILLIS_PER_MINUTE);</span>
<span class="nc" id="L134">			m_count = m_size / MINUTES_PER_HOUR;</span>
<span class="nc" id="L135">			break;</span>
		case Day:
<span class="nc" id="L137">			m_size = getTimeDifferenceInDays(startTime, endTime);</span>
<span class="nc" id="L138">			m_count = m_size;</span>
<span class="nc" id="L139">			break;</span>
		case Week:
<span class="nc" id="L141">			m_size = getTimeDifferenceInDays(startTime, endTime) / DAYS_PER_WEEK;</span>
<span class="nc" id="L142">			m_count = m_size;</span>
<span class="nc" id="L143">			break;</span>
		case Month:
<span class="nc" id="L145">			Calendar startAsCalendar = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc" id="L146">			startAsCalendar.setTime(startTime);</span>
<span class="nc" id="L147">			Calendar endAsCalendar = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc" id="L148">			endAsCalendar.setTime(endTime);</span>
<span class="nc" id="L149">			int differenceInYear = endAsCalendar.get(Calendar.YEAR) - startAsCalendar.get(Calendar.YEAR);</span>
<span class="nc" id="L150">			int differenceInMonth = endAsCalendar.get(Calendar.MONTH) - startAsCalendar.get(Calendar.MONTH);</span>
<span class="nc" id="L151">			int monthsInYear = startAsCalendar.getMaximum(Calendar.MONTH) + 1;</span>
<span class="nc" id="L152">			m_size = differenceInYear * monthsInYear + differenceInMonth;</span>
<span class="nc" id="L153">			m_count = m_size;</span>
<span class="nc" id="L154">			break;</span>
		default:
<span class="nc" id="L156">			throw new UnsupportedOperationException(&quot;TimeInterval does not support granularity &quot; + units);</span>
		}
<span class="nc" id="L158">	}</span>

	/**
	 * Creates a new TimeInterval that is identical to the source TimeInterval
	 * except that it is based on the specified TimeContext.
	 * 
	 * @param sourceInterval
	 * @param targetContext
	 */
	public TimeInterval(TimeInterval sourceInterval, TimeContext targetContext) {
<span class="nc" id="L168">		this(sourceInterval.m_units, sourceInterval.m_count, targetContext);</span>
<span class="nc" id="L169">	}</span>

	// TODO: Rewrite to work over DST transitions
	// This is such a rewrite, though it's unclear how we want it to behave when
	// the
	// two times are not an exact multiple of days apart.
	private int getTimeDifferenceInDays(Date startTime, Date endTime) {
<span class="nc" id="L176">		return Math.round(((float) endTime.getTime() - startTime.getTime()) / MILLIS_PER_DAY);</span>
	}

	/**
	 * Returns the time units in which this interval is measured.
	 * 
	 * @return
	 */
	public TimeUnits getUnits() {
<span class="nc" id="L185">		return m_units;</span>
	}

	/**
	 * Returns the number of this interval's time units in this interval. For
	 * instance, a three-week interval would return 3.
	 * 
	 * @return
	 */
	public int getUnitCount() {
<span class="nc" id="L195">		return m_count;</span>
	}

	/**
	 * Returns the time context within which this interval is defined.
	 * 
	 * @return
	 */
	public TimeContext getTimeContext() {
<span class="nc" id="L204">		return m_timeContext;</span>
	}

	/**
	 * Returns the duration of this interval in seconds starting at the
	 * specified reference time. The reference time is necessary because of
	 * influences such as daylight saving transitions, which can make a day
	 * longer or shorter.
	 * 
	 * @param referenceTime
	 * @return
	 */
	public long getDurationInSeconds(Date referenceTime) {
<span class="nc" id="L217">		return (getNextTime(referenceTime).getTime() - referenceTime.getTime()) / MILLIS_PER_SECOND;</span>
	}

	/**
	 * Returns a new Date, this interval after the specified date.
	 * 
	 * Note that time component of the returned Date will be set to this
	 * TimeInterval's day boundary. Optimization Applets sometimes require
	 * TimeIntervals from midnight-midnight even though the campaign's day
	 * boundary is non-midnight, and in order to overcome this limitation they
	 * create a view time context with a midnight day boundary.
	 * 
	 * @param previousTime
	 * @return
	 */
	public synchronized Date getNextTime(Date previousTime) {
		// This method is synchronized because it uses a member Calendar
		// instance
		// as a scratch object for the operation. For performance reasons we use
		// a member instead of creating a new Calendar on the fly.
<span class="nc" id="L237">		m_calendarForGetNextTime.setTimeInMillis(previousTime.getTime());</span>
<span class="nc" id="L238">		advanceTimeToNextTime(m_calendarForGetNextTime);</span>
<span class="nc" id="L239">		return m_calendarForGetNextTime.getTime();</span>
	}

	/**
	 * Modifies the specified Calendar, advancing it to this interval forward
	 * from its current value.
	 * 
	 * Careless use of this method may lead to difficult-to-track-down bugs.
	 * 
	 * @param time
	 */
	private void advanceTimeToNextTime(Calendar time) {
<span class="nc bnc" id="L251" title="All 5 branches missed.">		switch (m_units) {</span>
		case Minute:
		case Hour:
<span class="nc" id="L254">			time.add(Calendar.MINUTE, m_size);</span>
<span class="nc" id="L255">			break;</span>
		case Day:
<span class="nc" id="L257">			Calendar prevDayTime = (Calendar) time.clone();</span>
<span class="nc" id="L258">			time.add(Calendar.DAY_OF_MONTH, m_size);</span>

			/**
			 * The following code block is here due to some unfortunate behavior
			 * with the Calendar class, specifically around adding time to a
			 * calendar object such that the new time lands directly on a spring
			 * DST transition. For example, if you have a Calendar that has been
			 * set to March 12, 2011 02:00:00 and add 1 day to it (as we just
			 * did in the previous line of code) then the new date and time of
			 * this calendar will be March 13, 2011 01:00:00, exactly 23 hours
			 * ahead. This causes issues with the users of the TimeInterval API
			 * as they were expecting the new value to be March 13, 2011
			 * 03:00:00.
			 * 
			 * What we do to overcome this issue is to check and see if the
			 * number of milliseconds between the original date and the new
			 * advanced date is what we expect assuming that there is no DST
			 * transition. If the values are not what we expect AND there was no
			 * DST transition (as in the previous case, since at March 13, 2011
			 * 01:00:00 a DST transition has still not occurred), then we add an
			 * hour to the resulting time.
			 * 
			 * This hack is performed for Week intervals as well (see below).
			 * 
			 * FIXME: This hack MAY break if m_size is sufficiently large enough
			 * to cause the interval to cross two DST transitions. We don't
			 * currently use TimeIntervals in this way, but if we do it could
			 * cause problems.
			 */
<span class="nc bnc" id="L287" title="All 2 branches missed.">			if (time.getTimeInMillis() - prevDayTime.getTimeInMillis() &lt; (long) m_size * (long) MILLIS_PER_DAY</span>
<span class="nc" id="L288">					&amp;&amp; (m_timeContext.getTimeZone().inDaylightTime(prevDayTime.getTime()) == m_timeContext</span>
<span class="nc bnc" id="L289" title="All 2 branches missed.">							.getTimeZone().inDaylightTime(time.getTime()))) {</span>
<span class="nc" id="L290">				time.add(Calendar.HOUR, 1);</span>
			}

<span class="nc" id="L293">			time.setTime(this.getStartTime(time.getTime(), DayStartPolicy.UseDayBoundary));</span>
<span class="nc" id="L294">			break;</span>
		case Week:
<span class="nc" id="L296">			Calendar prevWeekTime = (Calendar) time.clone();</span>
<span class="nc" id="L297">			time.add(Calendar.DAY_OF_MONTH, m_size * DAYS_PER_WEEK);</span>

			/**
			 * Similar to the DST issue with the Day intervals, when adding a
			 * week to a calendar such that the new calendar happens to land
			 * directly on a spring DST transition, the resulting date and time
			 * of the calendar is 1 hour earlier than expected (1 hour before
			 * the transition period). We add an hour to compensate for this.
			 * 
			 * FIXME: This hack MAY break if m_size is sufficiently large enough
			 * to cause the interval to cross two DST transitions. We don't
			 * currently use TimeIntervals in this way, but if we do it could
			 * cause problems.
			 */
<span class="nc bnc" id="L311" title="All 2 branches missed.">			if (time.getTimeInMillis() - prevWeekTime.getTimeInMillis() &lt; (long) m_size * (long) MILLIS_PER_WEEK</span>
<span class="nc" id="L312">					&amp;&amp; (m_timeContext.getTimeZone().inDaylightTime(prevWeekTime.getTime()) == m_timeContext</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">							.getTimeZone().inDaylightTime(time.getTime()))) {</span>
<span class="nc" id="L314">				time.add(Calendar.HOUR, 1);</span>
			}
<span class="nc" id="L316">			time.setTime(this.getStartTime(time.getTime(), DayStartPolicy.UseDayBoundary));</span>
<span class="nc" id="L317">			break;</span>
		case Month:
<span class="nc" id="L319">			time.add(Calendar.MONTH, m_size);</span>

			/**
			 * You would think that because the calendar class has strange
			 * behavior when adding days and weeks such that the new date lands
			 * directly on a DST, that the same issue would happen when adding
			 * months as well. You'd be wrong though. The Calendar class upon
			 * adding a month will set the time of the resulting date to 3 AM if
			 * the date/time happens to land exactly on a spring DST transition.
			 * No check/hack is needed.
			 */
<span class="nc" id="L330">			time.setTime(this.getStartTime(time.getTime(), DayStartPolicy.UseDayBoundary));</span>
<span class="nc" id="L331">			break;</span>
		default:
<span class="nc" id="L333">			throw new UnsupportedOperationException(&quot;createNextTimePeriod does not support granularity &quot; + m_units);</span>
		}
<span class="nc" id="L335">	}</span>

	/**
	 * Returns the number of intervals or parts of intervals of length divisor
	 * that fit into this interval.
	 * 
	 * For instance oneDay.divideBy(now, oneMonth) would generally return 1, but
	 * could return 2 depending on the comparative time contexts of the oneDay
	 * and oneMonth intervals. oneWeek.divideBy(now, threeDays) would return 3.
	 * 
	 * This method uses the default behavior for the start of day policy which
	 * is DayStartPolicy.UseDayBoundary (in other words, it uses the
	 * TimeInterval's time context to determine the start of the day). When
	 * dividing by days, days are therefore assumed to start at the day boundary
	 * defined in the time context. If a different behavior is desired, use
	 * divideBy(Date, TimeInterval, DayStartPolicy).
	 */
	public long divideBy(Date referenceTime, TimeInterval divisor) {
<span class="nc" id="L353">		return divideBy(referenceTime, divisor, DayStartPolicy.UseDayBoundary);</span>
	}

	// TODO: Handle Daylight Savings Time.
	/**
	 * Returns the number of intervals or parts of intervals of length divisor
	 * that fit into this interval.
	 * 
	 * For instance oneDay.divideBy(now, oneMonth) would generally return 1, but
	 * could return 2 depending on the comparative time contexts of the oneDay
	 * and oneMonth intervals. oneWeek.divideBy(now, threeDays) would return 3.
	 * 
	 * @param dayStartPolicy
	 *            Used when dividing by intervals with a length of a Day.
	 *            DayStartPolicy has two options: UseDayBoundary, which uses the
	 *            TimeInterval's time context to determine the start of a day,
	 *            and UseMidnight, which ignores the time context's day boundary
	 *            and always treats days as starting at midnight. In most cases,
	 *            UseDayBoundary should be used, but optimization applets show
	 *            daily data always as Midnight-Midnight, and the related view
	 *            code requires that a UseMidnight policy be used.
	 */
	public long divideBy(Date referenceTime, TimeInterval divisor, DayStartPolicy dayStartPolicy) {
<span class="nc" id="L376">		long quotient = 0;</span>
<span class="nc" id="L377">		Calendar currentTime = Calendar.getInstance(m_timeContext.getTimeZone());</span>
		// Start with the natural starting point of a divisor interval
		// within the time context of the divisor interval.
<span class="nc" id="L380">		currentTime.setTime(divisor.getStartTime(referenceTime, dayStartPolicy));</span>
<span class="nc" id="L381">		Date endTime = getNextTime(referenceTime);</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">		while (currentTime.getTime().before(endTime)) {</span>
<span class="nc" id="L383">			quotient++;</span>
<span class="nc" id="L384">			divisor.advanceTimeToNextTime(currentTime);</span>
		}
<span class="nc" id="L386">		return quotient;</span>
	}

	public TimeInterval multiplyBy(long multiplicand) {
<span class="nc" id="L390">		return new TimeInterval(m_units, (int) (m_count * multiplicand), m_timeContext);</span>
	}

	/**
	 * Returns all the start times for intervals of length &lt;code&gt;divisor&lt;/code&gt;
	 * starting with the first interval that contains &lt;code&gt;referenceTime&lt;/code&gt;
	 * and ranging to the first interval that contains a time this interval
	 * after &lt;code&gt;referenceTime&lt;/code&gt;.
	 * 
	 * This method uses the default behavior for the start of day policy which
	 * is DayStartPolicy.UseDayBoundary (in other words, it uses the
	 * TimeInterval's time context to determine the start of the day). When
	 * dividing by days, days are therefore assumed to start at the day boundary
	 * defined in the time context. If a different behavior is desired, use
	 * getIntervalSubdivisions(Date, TimeInterval, DayStartPolicy).
	 * 
	 * @param referenceTime
	 * @param divisor
	 */
	public List&lt;Date&gt; getIntervalSubdivisions(Date referenceTime, TimeInterval divisor) {
<span class="nc" id="L410">		return getIntervalSubdivisions(referenceTime, divisor, DayStartPolicy.UseDayBoundary);</span>
	}

	/**
	 * Returns all the start times for intervals of length &lt;code&gt;divisor&lt;/code&gt;
	 * starting with the first interval that contains &lt;code&gt;referenceTime&lt;/code&gt;
	 * and ranging to the first interval that contains a time this interval
	 * after &lt;code&gt;referenceTime&lt;/code&gt;.
	 * 
	 * @param referenceTime
	 * @param divisor
	 * @param dayStartPolicy
	 *            Used when dividing by intervals with a length of a Day.
	 *            DayStartPolicy has two options: UseDayBoundary, which uses the
	 *            TimeInterval's time context to determine the start of a day,
	 *            and UseMidnight, which ignores the time context's day boundary
	 *            and always treats days as starting at midnight. In most cases,
	 *            UseDayBoundary should be used, but optimization applets show
	 *            daily data always as Midnight-Midnight, and the related view
	 *            code requires that a UseMidnight policy be used.
	 */
	public List&lt;Date&gt; getIntervalSubdivisions(Date referenceTime, TimeInterval divisor, DayStartPolicy dayStartPolicy) {
<span class="nc" id="L432">		List&lt;Date&gt; dates = new ArrayList&lt;Date&gt;();</span>
		// Start with the natural starting point of a divisor interval
		// within the time context of the divisor interval.
<span class="nc" id="L435">		Date currentTime = divisor.getStartTime(referenceTime, dayStartPolicy);</span>
<span class="nc" id="L436">		Date endTime = getNextTime(referenceTime);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">		while (currentTime.before(endTime)) {</span>
<span class="nc" id="L438">			dates.add(currentTime);</span>
<span class="nc" id="L439">			currentTime = divisor.getNextTime(currentTime);</span>
		}
<span class="nc" id="L441">		return dates;</span>
	}

	/**
	 * Returns the latest time at which an interval of this length could start
	 * and contain the specified time.
	 * 
	 * This method uses the default behavior for the start of day policy which
	 * is DayStartPolicy.UseDayBoundary (in other words, it uses the
	 * TimeInterval's time context to determine the start of the day). If a
	 * different behavior is desired, use getStartTime(Date, DayStartPolicy).
	 */
	public Date getStartTime(Date includedTime) {
<span class="nc" id="L454">		return getStartTime(includedTime, DayStartPolicy.UseDayBoundary);</span>
	}

	/**
	 * Returns the latest time at which an interval of this length could start
	 * and contain the specified time.
	 * 
	 * @param dayStartPolicy
	 *            Used when the units of this time interval are equal to
	 *            TimeUnits.Day. DayStartPolicy has two options: UseDayBoundary,
	 *            which uses the TimeInterval's time context to determine the
	 *            start of a day, and UseMidnight, which ignores the time
	 *            context's day boundary and always treats days as starting at
	 *            midnight. In most cases, UseDayBoundary should be used, but
	 *            optimization applets show daily data always as
	 *            Midnight-Midnight, and the related view code requires that a
	 *            UseMidnight policy be used.
	 * @return
	 */
	public Date getStartTime(Date includedTime, DayStartPolicy dayStartPolicy) {
		// If you call set(Calendar.MILLISECOND, 0), or seconds, or minutes on a
		// Calendar
		// that's pointing to 1am PDT on an autumn DST transition you get 1am
		// PST which is
		// an hour later.
		// For each of those two times get(Calendar.HOUR_OF_DAY) returns 1.
		// This call safely truncates includedTime to 0 milliseconds and 0
		// seconds
		// past the minute.
<span class="nc" id="L483">		Date startTime = new Date(includedTime.getTime() / (MILLIS_PER_MINUTE) * MILLIS_PER_MINUTE);</span>
<span class="nc" id="L484">		Calendar startTimeCal = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc" id="L485">		startTimeCal.setTime(startTime);</span>
<span class="nc" id="L486">		int minutesPastMidnightWallTime = startTimeCal.get(Calendar.HOUR_OF_DAY) * MINUTES_PER_HOUR</span>
<span class="nc" id="L487">				+ startTimeCal.get(Calendar.MINUTE);</span>
<span class="nc bnc" id="L488" title="All 6 branches missed.">		switch (m_units) {</span>
		case Minute:
<span class="nc" id="L490">			startTimeCal.setTime(TraceUtil.snapDate(startTimeCal.getTime()));</span>
<span class="nc" id="L491">			break;</span>
		case Hour:
<span class="nc" id="L493">			int minutesPastMidnightAbsolute = getAbsoluteMinutesPastMidnight(startTime);</span>
<span class="nc" id="L494">			boolean isEarlyPartOfHour = (minutesPastMidnightAbsolute % MINUTES_PER_HOUR) &lt; (m_timeContext</span>
<span class="nc bnc" id="L495" title="All 2 branches missed.">					.getDayBoundary() % MINUTES_PER_HOUR);</span>
<span class="nc" id="L496">			minutesPastMidnightAbsolute = (minutesPastMidnightAbsolute / MINUTES_PER_HOUR) * MINUTES_PER_HOUR</span>
<span class="nc" id="L497">					+ m_timeContext.getDayBoundary() % MINUTES_PER_HOUR;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">			if (isEarlyPartOfHour) {</span>
<span class="nc" id="L499">				minutesPastMidnightAbsolute -= MINUTES_PER_HOUR;</span>
			}
			// We don't take the normal return path here because Calendars don't
			// work
			// properly on intervals less than one hour as noted above.
<span class="nc" id="L504">			return new Date(getStartOfDayAbsolute(startTime).getTime() + MILLIS_PER_MINUTE</span>
					* minutesPastMidnightAbsolute);
		case Day:
<span class="nc bnc" id="L507" title="All 2 branches missed.">			if (minutesPastMidnightWallTime &lt; m_timeContext.getDayBoundary()) {</span>
<span class="nc" id="L508">				startTimeCal.add(Calendar.DAY_OF_MONTH, -1);</span>
			}
			// If the UseMidnight DayStartPolicy is used, then the start time of
			// a day should be set to midnight.
<span class="nc bnc" id="L512" title="All 3 branches missed.">			switch (dayStartPolicy) {</span>
			case UseMidnight:
<span class="nc" id="L514">				startTimeCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L515">				startTimeCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L516">				break;</span>
			case UseDayBoundary:
<span class="nc" id="L518">				startTimeCal.set(Calendar.HOUR_OF_DAY, m_timeContext.getDayBoundary() / MINUTES_PER_HOUR);</span>
<span class="nc" id="L519">				startTimeCal.set(Calendar.MINUTE, m_timeContext.getDayBoundary() % MINUTES_PER_HOUR);</span>
<span class="nc" id="L520">				break;</span>
			default:
<span class="nc" id="L522">				break;</span>
			}
			break;
		case Week:
<span class="nc" id="L526">			int dayOfCalendarWeek = startTimeCal.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L527">			int dayOfBusinessWeek = (dayOfCalendarWeek - m_timeContext.getStartDayOfWeek().getCalendarConstant() + DAYS_PER_WEEK)</span>
					% DAYS_PER_WEEK;
<span class="nc bnc" id="L529" title="All 4 branches missed.">			if (dayOfBusinessWeek == 0 &amp;&amp; minutesPastMidnightWallTime &lt; m_timeContext.getDayBoundary()) {</span>
<span class="nc" id="L530">				dayOfBusinessWeek = DAYS_PER_WEEK;</span>
			}
<span class="nc" id="L532">			startTimeCal.add(Calendar.DAY_OF_MONTH, -dayOfBusinessWeek);</span>
<span class="nc" id="L533">			startTimeCal.set(Calendar.HOUR_OF_DAY, m_timeContext.getDayBoundary() / MINUTES_PER_HOUR);</span>
<span class="nc" id="L534">			startTimeCal.set(Calendar.MINUTE, m_timeContext.getDayBoundary() % MINUTES_PER_HOUR);</span>
<span class="nc" id="L535">			break;</span>
		case Month:
<span class="nc bnc" id="L537" title="All 2 branches missed.">			if (startTimeCal.get(Calendar.DAY_OF_MONTH) == 1</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">					&amp;&amp; minutesPastMidnightWallTime &lt; m_timeContext.getDayBoundary()) {</span>
<span class="nc" id="L539">				startTimeCal.add(Calendar.MONTH, -1);</span>
			}
<span class="nc" id="L541">			startTimeCal.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L542">			startTimeCal.set(Calendar.HOUR_OF_DAY, m_timeContext.getDayBoundary() / MINUTES_PER_HOUR);</span>
<span class="nc" id="L543">			startTimeCal.set(Calendar.MINUTE, m_timeContext.getDayBoundary() % MINUTES_PER_HOUR);</span>
			break;
		}
<span class="nc" id="L546">		return startTimeCal.getTime();</span>
	}

	/**
	 * Returns the number of minutes past midnight represented by the specified
	 * time in this interval's time zone.
	 * 
	 * @param referenceTime
	 * @return
	 */
	private int getAbsoluteMinutesPastMidnight(Date referenceTime) {
<span class="nc" id="L557">		return (int) ((referenceTime.getTime() - getStartOfDayAbsolute(referenceTime).getTime()) / MILLIS_PER_MINUTE);</span>
	}

	/**
	 * Returns the start of the calendar day containing {@code referenceTime} in
	 * the this interval's time zone, disregarding the day boundary defined in
	 * the time context.
	 * 
	 * @param referenceTime
	 * @return
	 */
	private Date getStartOfDayAbsolute(Date referenceTime) {
<span class="nc" id="L569">		Calendar startOfDayCal = Calendar.getInstance(m_timeContext.getTimeZone());</span>
<span class="nc" id="L570">		startOfDayCal.setTime(referenceTime);</span>
<span class="nc" id="L571">		startOfDayCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L572">		startOfDayCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L573">		return startOfDayCal.getTime();</span>
	}

	/**
	 * Checks for equality.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the specified object is an instance of
	 *         &lt;code&gt;TimeInterval&lt;/code&gt;, if it uses the same time units and the
	 *         same count as this interval, and its &lt;code&gt;TimeContext&lt;/code&gt; is
	 *         equal to this instance's; otherwise &lt;code&gt;false&lt;/code&gt;.
	 */
	@Override
	public boolean equals(Object o) {
<span class="nc bnc" id="L586" title="All 2 branches missed.">		if (this == o) {</span>
<span class="nc" id="L587">			return true;</span>
		}
<span class="nc bnc" id="L589" title="All 2 branches missed.">		if (!(o instanceof TimeInterval)) {</span>
<span class="nc" id="L590">			return false;</span>
		}
<span class="nc" id="L592">		TimeInterval other = (TimeInterval) o;</span>
<span class="nc bnc" id="L593" title="All 4 branches missed.">		return this.m_units == other.m_units &amp;&amp; this.m_size == other.m_size</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">				&amp;&amp; this.m_timeContext.equals(other.m_timeContext);</span>
	}

	/**
	 * Checks for equality, ignoring &lt;code&gt;TimeContext&lt;/code&gt;.
	 * 
	 * @return &lt;code&gt;true&lt;/code&gt; if the specified &lt;code&gt;TimeInterval&lt;/code&gt; uses
	 *         the same time units and the same count as this interval;
	 *         otherwise &lt;code&gt;false&lt;/code&gt;.
	 */
	public boolean equalsIgnoreTimeContext(TimeInterval other) {
<span class="nc bnc" id="L605" title="All 4 branches missed.">		return this.m_units == other.m_units &amp;&amp; this.m_size == other.m_size;</span>
	}

	/**
	 * Return an appropriate hashcode.
	 * 
	 * Based on code from _Effective Java_ by Joshua Bloch, 1st Ed., item 8.
	 */
	@Override
	public int hashCode() {
<span class="nc" id="L615">		int result = 17;</span>
<span class="nc" id="L616">		result = 37 * result + m_units.hashCode();</span>
<span class="nc" id="L617">		result = 37 * result + m_size;</span>
<span class="nc" id="L618">		result = 37 * result + m_timeContext.hashCode();</span>
<span class="nc" id="L619">		return result;</span>
	}

	/**
	 * Return an appropriate hashcode ignoring the time context.
	 * 
	 * Based on code from _Effective Java_ by Joshua Bloch, 1st Ed., item 8.
	 */
	public int hashCodeIgnoreTimeContext() {
<span class="nc" id="L628">		int result = 17;</span>
<span class="nc" id="L629">		result = 37 * result + m_units.hashCode();</span>
<span class="nc" id="L630">		result = 37 * result + m_size;</span>
<span class="nc" id="L631">		return result;</span>
	}

	/**
	 * Returns a non-localized String representation of this time interval.
	 */
	@Override
	public String toString() {
<span class="nc" id="L639">		String value = &quot;&quot;;</span>
<span class="nc bnc" id="L640" title="All 4 branches missed.">		switch (m_units) {</span>
		case Minute:
<span class="nc" id="L642">			value += m_size;</span>
<span class="nc" id="L643">			break;</span>
		case Hour:
<span class="nc" id="L645">			value += m_size / MINUTES_PER_HOUR;</span>
<span class="nc" id="L646">			break;</span>
		case Day:
		case Week:
		case Month:
<span class="nc" id="L650">			value += m_size;</span>
			break;
		}
<span class="nc" id="L653">		value += &quot; &quot; + m_units.toString() + &quot; within &quot; + m_timeContext;</span>
<span class="nc" id="L654">		return value;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>