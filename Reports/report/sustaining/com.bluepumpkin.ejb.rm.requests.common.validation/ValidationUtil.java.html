<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ValidationUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.validation</a> &gt; <span class="el_source">ValidationUtil.java</span></div><h1>ValidationUtil.java</h1><pre class="source lang-java linenums">/*
 * ValidationUtil.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.common.validation;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtil;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsUtil;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.verint.ejb.wfm.WfmManagerFactory;


/**
 * utilities for getting data from the ejb tier for use when validating requests
 */
public class ValidationUtil {
<span class="nc" id="L67">    private static final Category m_cat = Log.initCategory(ValidationUtil.class.getName());</span>

    /** Don't construct these...static only methods */
<span class="nc" id="L70">    private ValidationUtil() {</span>
<span class="nc" id="L71">    }</span>

    /**
     * Get the employee object
     * @param employeeID id of employee
     * @param dateNow point in time to get object data
     * @return an Employee, given it's ID.
     * @throws Exception
     */
    public static Employee getEmployeeByID(ID empID, Date dateNow, long empDetailLevel)
            throws Exception {

        // if caching is enabled, force load the following detail levels which is a list of all possible
        // detail levels used in RM.
<span class="nc bnc" id="L85" title="All 2 branches missed.">        if (CacheUtil.isThreadLocalCacheEnabled()) {</span>
<span class="nc" id="L86">            long rmDetailLevel = Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFYEARLY |</span>
                    Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFDEFAULT | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEBASEDPROPERTY;

            // verify that the passed detailLevel is a subset
<span class="nc bnc" id="L90" title="All 2 branches missed.">            if ( (rmDetailLevel &amp; empDetailLevel) != empDetailLevel ) {</span>
<span class="nc" id="L91">                throw RequestUtil.createIllegalArgumentException(</span>
                        &quot;specified employee detail level is not a subset: &quot; + rmDetailLevel + ',' + empDetailLevel, m_cat);
            }

<span class="nc" id="L95">            empDetailLevel = rmDetailLevel;</span>
        }

<span class="nc" id="L98">        Employee emp = CacheUtilBBM.getEmployeeByID(empID, dateNow, empDetailLevel);</span>

<span class="nc" id="L100">        return emp;</span>
    }

    public static Collection getEmployeesByIDs(Collection empIDsWithTOEvts, Date dateNow, long empDetLevel)
            throws Exception {

<span class="nc" id="L106">        WorkResourceManager wrm = RequestUtil.getWorkResourceManager();</span>
<span class="nc" id="L107">        Collection empsWithTOEvts = wrm.getEmployeesByIDs(empIDsWithTOEvts, dateNow, empDetLevel);</span>
<span class="nc" id="L108">        return empsWithTOEvts;</span>
    }


    /**
     * Get the organization object
     * @param orgID of organization
     * @return an Organization, given it's ID.
     * @throws Exception
     */
    public static Organization getOrganizationByID(ID orgID) throws Exception {

<span class="nc" id="L120">        return RequestUtil.getOrganizationByID(orgID, null);</span>

    }

    /**
     * Get the org id for an employee during a given period.
     * @param empID the employee id
     * @param start the beginning of the period
     * @param end   the ending of the period
     * @return the orgID of the organization for the employee during the given period
     * @throws Exception
     */
    public static ID getOrgIDForEmployeeDuringPeriod(ID empID, Date start, Date end) throws Exception {


<span class="nc" id="L135">        Collection wrAssns = getWorkResAssnWithTZForWRID(empID, start, end);</span>

<span class="nc" id="L137">        WorkResourceAssignment overlappingWRAssn = null;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">        if (!wrAssns.isEmpty()) {</span>
<span class="nc" id="L139">            overlappingWRAssn = (WorkResourceAssignment) wrAssns.iterator().next();</span>
        }

        // In London, a workresouce can only have one (workResource, organization) association.  In
        // the future, this might change and an employee can have one or more
        // (workResource, organization) associations.  When it does, additional code will be needed to
        // determine which one of the associations to use.

<span class="nc bnc" id="L147" title="All 2 branches missed.">        return (overlappingWRAssn == null)?null:overlappingWRAssn.getOrganizationID();</span>
    }

    /**
     * Note: This method may return a null.
     * &lt;p&gt; Obtains the work resource assignment for the specified employee which overlaps the specified time range.
     *
     * @param empID
     * @param start
     * @param end
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     * @throws NoSuchMethodException
     * @throws BbmFinderException
     * @throws BbmEJBCreateException
     * @throws RemoteException
     */
    public static Collection getWorkResAssnWithTZForWRID(ID empID, Date start, Date end) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, BbmFinderException, BbmEJBCreateException, RemoteException {
        // accomodate 'null' for start
<span class="nc" id="L168">        Date minDate = new Date(0);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">        start = (start == null)?minDate:start;</span>
        // accomodate 'null' for end
<span class="nc" id="L171">        Date maxDate = new Date(Long.MAX_VALUE);</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">        end = (end == null)?maxDate:end;</span>

        // get work resource assignments for given employee.
<span class="nc" id="L175">        Collection wrAssns = CacheUtilBBM.getWorkResourceAssnWithTZForWRID(empID);</span>

<span class="nc" id="L177">        Collection overlappingWRAssns = new ArrayList();</span>
        // for each work resource assignment
<span class="nc bnc" id="L179" title="All 2 branches missed.">        for (Iterator iter = wrAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L180">            WorkResourceAssignment wrAssn = (WorkResourceAssignment) iter.next();</span>

            // adjust if startTime == null
<span class="nc" id="L183">            Date wrAssnStart = wrAssn.getStartTime();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">            wrAssnStart = (wrAssnStart == null)?minDate:wrAssnStart;</span>

            // adjust if endTime == null
<span class="nc" id="L187">            Date wrAssnEnd = wrAssn.getEndTime();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">            wrAssnEnd = (wrAssnEnd == null)?maxDate:wrAssnEnd;</span>

<span class="nc" id="L190">            boolean overlap = TimePeriodUtil.overlap(start, end, wrAssnStart, wrAssnEnd);</span>
            // if ranges overlap
<span class="nc bnc" id="L192" title="All 2 branches missed.">            if (overlap) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">                overlappingWRAssns = (overlappingWRAssns == null)?new ArrayList(8):overlappingWRAssns;</span>
<span class="nc" id="L194">                overlappingWRAssns.add(wrAssn);</span>
            }
<span class="nc" id="L196">        }</span>

<span class="nc bnc" id="L198" title="All 2 branches missed.">        if (overlappingWRAssns.size() == 0){</span>
            //still need a workresourceassignment: pick the first one
<span class="nc" id="L200">            WorkResourceAssignment wrAssn = (WorkResourceAssignment) wrAssns.iterator().next();</span>
<span class="nc" id="L201">            overlappingWRAssns.add(wrAssn);</span>
        }

<span class="nc bnc" id="L204" title="All 2 branches missed.">		return (overlappingWRAssns == null) ? Collections.emptyList() : overlappingWRAssns;</span>
    }

    public static Map getOrgIDsForEmployeesOnGivenDate(List empIDs, Date onDate) throws Exception {
<span class="nc" id="L208">        WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L209">        HashMap empIDToOrgIDMap = wrm.getEmployeesReportingOrgs(empIDs, onDate);</span>

<span class="nc" id="L211">        return empIDToOrgIDMap;</span>
    }

    public static Organization getOrganizationForEmployeeDuringPeriod(ID empID, Date start, Date end)
            throws Exception    {
//      try {
<span class="nc" id="L217">        return getOrganizationByID(getOrgIDForEmployeeDuringPeriod(empID, start, end));</span>
//      } c_atch (Exception e) {
//          //log.error(e);
//          t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
//      }
    }

    /**
     * Get the Collection&lt;SkillAssignment&gt; for an employee during a period.
     * @param empID - an Employee ID
     * @param start - the start time for the period
     * @param end - the end time for the period
     * @return the Collection of SkillAssignment's.
     * @throws Exception
     */
    public static Collection getSkillsForEmployeeDuringPeriod(ID empID, Date start, Date end)
            throws Exception {
<span class="nc" id="L234">        Collection cSkills = null;</span>

<span class="nc" id="L236">        SkillManager sm = WfmManagerFactory.getSkillManager();</span>
<span class="nc" id="L237">        cSkills = sm.getSkillAssignments(empID, start, end);</span>

<span class="nc" id="L239">        return cSkills;</span>
    }

    public static Collection&lt;ID&gt; getSkillsForSchedulingPeriod(Collection&lt;ID&gt; spIDs)
    	throws Exception {
<span class="nc" id="L244">		CampaignManager cm = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L245">		Collection&lt;SPQueue&gt; spQs = cm.getSPQueuesBySPIDsFixed(spIDs);</span>
<span class="nc" id="L246">		Collection&lt;ID&gt; skillIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">		for (SPQueue spQ: spQs) {</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">			if (spQ.getSkills() != null) {</span>
<span class="nc" id="L249">				skillIDs.addAll(spQ.getSkills());</span>
			}
<span class="nc" id="L251">		}</span>
<span class="nc" id="L252">		return skillIDs;</span>
	}

    /**
     * Get the name of a Skill given its ID.
     * @param id the ID for the Skill.
     * @return the name of the Skill.
     * @throws Exception
     */
    public static String getSkillName(ID id) throws Exception {
<span class="nc" id="L262">        String strSkill = &quot;deletedSkill&quot;;</span>

<span class="nc" id="L264">        SkillManager sm = WfmManagerFactory.getSkillManager();</span>
        // Note: using skillMgr.getSkillsByIDs() instead of skillMgr.getSkillByID() method
        // as it t_hrows a BbmObjectNotFoundException for a deleted skill and marks the
        // transaction as rolled back (which prevents any further access to the DB)
        // even if the skill is assigned to an employee by a 'SkillAssignment'.  Essentially the
        // 'SkillAssignment' indicates that an employee has this skill, but the actual skill
        // value object cannot be fetched as it was deleted.  Deletion of skill does
        // not delete the skill object itself (which would also delete the 'SkillAssignment')
        // in the 'skill' table but simply sets the 'deleteOnDate' column to a non-null value.
        // For further details see SQL query in SkillDAO.getSkillsByIDs() method.
<span class="nc" id="L274">        Collection skills = sm.getSkillsByIDs(Collections.singleton(id));</span>

<span class="nc bnc" id="L276" title="All 2 branches missed.">        if (!skills.isEmpty()) {</span>
<span class="nc" id="L277">            Skill skill = (Skill)skills.iterator().next();</span>
<span class="nc bnc" id="L278" title="All 2 branches missed.">            if (skill != null) {</span>
<span class="nc" id="L279">                strSkill = (skill).getName();</span>
            }
        }

<span class="nc" id="L283">        return strSkill;</span>
    }

    /**
     * Retrieve events from published schedule for a WorkResource given an
     * Event Type.
     *
     * @param eventType a type from the Event class
     * @param idWorkResource a WorkResource ID
     * @param dtStart the start Date for the period from which to retrieve events
     * @param dtEnd the end Date for the period from which to retrieve events
     * @return a Collection of Events for the input WorkResource in the input
     * time period
     * @throws Exception
     */
    public static Collection getPublishedEventsForWorkResourceByType(int eventType, ID idWorkResource,
                                                                     Date dtStart, Date dtEnd) throws Exception
    {
<span class="nc" id="L301">        String methodName = &quot;getPublishedEventsForWorkResourceByType&quot;;</span>
<span class="nc" id="L302">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Integer(eventType),</span>
                idWorkResource, dtStart, dtEnd));

<span class="nc" id="L305">        Collection events = null;</span>

<span class="nc" id="L307">        ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="nc" id="L309">        events = sam.getPublishedEventsForWorkResourceByType(eventType, idWorkResource, dtStart,</span>
                dtEnd);

<span class="nc" id="L312">        m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>
<span class="nc" id="L313">        return events;</span>
    }

    /**
     * Retrieve events from unpublished schedule for a WorkResource given an
     * Event Type.
     *
     * @param eventType a type from the Event class
     * @param idWorkResource a WorkResource ID
     * @param dtStart the start Date for the period from which to retrieve events
     * @param dtEnd the end Date for the period from which to retrieve events
     * @return a Collection of Events for the input WorkResource in the input
     * time period
     * @throws Exception
     */
    public static Collection getEventsForWorkResourceByType(int eventType, ID idWorkResource,
                                                            Date dtStart, Date dtEnd) throws Exception
    {
<span class="nc" id="L331">        String methodName = &quot;getEventsForWorkResourceByType&quot;;</span>
<span class="nc" id="L332">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Integer(eventType),</span>
                idWorkResource, dtStart, dtEnd));

<span class="nc" id="L335">        Collection events = null;</span>

<span class="nc" id="L337">        ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="nc" id="L339">        events = sam.getEventsForWorkResourceByType(eventType, idWorkResource, dtStart,</span>
                dtEnd);

<span class="nc bnc" id="L342" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L343">			m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>
		}
<span class="nc" id="L345">        return events;</span>
    }

    /**
     * Get an instance of a validator by name.
     * @param validatorName the name of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator Validator}
     * interface.
     * @param valMap a cache for Validator instances
     * @return an instance of the class whose name is validatorName
     */
    public static Validator getValidator(String validatorName, Map valMap) throws Exception {
<span class="nc" id="L357">        Validator result = (Validator) valMap.get(validatorName);</span>

<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (result == null) {</span>
<span class="nc" id="L360">            result = (Validator) Class.forName(validatorName).newInstance();</span>
<span class="nc" id="L361">            valMap.put(validatorName, result);</span>
        }
<span class="nc" id="L363">        return result;</span>
    }
    /*
     * Get an instance of a extended validator by name.
     * @param validatorName the name of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator Validator}
     * interface.
     * @param valMap a cache for Validator instances
     * @return an instance of the class whose name is validatorName 
     * */
    public static ValidatorForMultiChoice getValidatorForMultiChoice(String validatorName, Map&lt;String,ValidatorForMultiChoice&gt; valMap) throws Exception {
<span class="nc" id="L374">    	ValidatorForMultiChoice validator = valMap.get(validatorName);</span>
    	
<span class="nc bnc" id="L376" title="All 2 branches missed.">        if (validator == null) {</span>
<span class="nc" id="L377">        	validator = (ValidatorForMultiChoice) Class.forName(validatorName).newInstance();</span>
<span class="nc" id="L378">            valMap.put(validatorName, validator);</span>
        }
<span class="nc" id="L380">        return validator;</span>
    }
    /**
     * Perform a single validation
     * @param validatorClassName The name of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator Validator}
     * interface.
     * @param request An instance of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validatable Validatable}
     * interface.
     * @param validatorsMap a cache for Validator instances
     * @throws Exception
     */
	public static ValidationResult doValidation(String validatorClassName, Validatable request,
                                                Map validatorsMap) throws Exception {
<span class="nc" id="L395">        Validator val = getValidator(validatorClassName, validatorsMap);</span>

        // Check to make sure we actually constructed the validator.  If there
        // was a problem, then the error has already been logged.  Guard the
        // use of the validator against null pointer exception.
<span class="nc bnc" id="L400" title="All 2 branches missed.">        if (val != null) {</span>
<span class="nc" id="L401">			return val.validate(request);</span>
        }

<span class="nc" id="L404">		return null;</span>
    }
	public static ValidationResult doValidationForMultiChoice(String validatorClassName, Validatable request,
            Map&lt;String,ValidatorForMultiChoice&gt; validatorsMap) throws Exception {
<span class="nc" id="L408">		ValidatorForMultiChoice val = getValidatorForMultiChoice(validatorClassName, validatorsMap);</span>
		
		// Check to make sure we actually constructed the validator.  If there
		// was a problem, then the error has already been logged.  Guard the
		// use of the validator against null pointer exception.
<span class="nc bnc" id="L413" title="All 2 branches missed.">		if (val != null) {</span>
<span class="nc" id="L414">			return val.validateForMultiChoice(request);</span>
		}
		
<span class="nc" id="L417">		return null;</span>
}

    /**
     * Get the holidays for an Organization for a time period.
     *
     * @param org The {@link com.bluepumpkin.ejb.bbm.workresource.model.Organization
     * Organization} to retrieve holidays from.
     * @param tz The TimeZone of the TimeRange dates.
     * @param range A start and end date, packaged as a
     * {@link com.bluepumpkin.common.datatypes.TimeRange TimeRange}
     * &lt;p&gt;
     * @return a Collection of
     * {@link com.bluepumpkin.ejb.bbm.holiday.model.Holiday Holiday}s.
     * &lt;p&gt;
     * @throws Exception
     */
    public static Collection&lt;Holiday&gt; getHolidays(Organization org, TimeZone tz, TimeRange range)
        throws Exception
    {
<span class="nc" id="L437">        String methodName = &quot;getHolidays&quot;;</span>
<span class="nc" id="L438">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, org, tz, range));</span>

        // get the holidays for the organization during the period
<span class="nc" id="L441">        Collection&lt;Holiday&gt; holidays = </span>
<span class="nc" id="L442">            CacheUtilBBM.getHolidaysForOrg(org.getID(), range.getStartLocalDate(tz), range.getEndLocalDate(tz));</span>
<span class="nc" id="L443">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, holidays));</span>
<span class="nc" id="L444">        return holidays;</span>
    }

    /**
     * Transfer the exception information in the given ExceptionMessage to a new ValidationResult
     *
     * @param validatable
     * @param e
     * @param validatorName
     * @return
     */
    private static ValidationResult setValidationResult(boolean softValidation, Validatable validatable,
                                                        Exception e, String validatorName)
    {
        // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
        // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
        //m_cat.info(&quot;Translating Exception to Validation result: &quot; + e.getLocalizedMessage());

<span class="nc" id="L462">        RequestUtil.ExceptionMessage excMsg = RequestUtil.getMsgFromException(e);</span>

        // if bundle not specified
<span class="nc bnc" id="L465" title="All 2 branches missed.">        if (!excMsg.getUseBundle()) {</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">            return softValidation?</span>
<span class="nc" id="L467">                    setSoftValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L468">                            RmEjbBundleKey.REQ_UNEXPECTED_ERROR, new Serializable[] {excMsg.getUnLocalizedMessage()}, validatorName):</span>
<span class="nc" id="L469">                    setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L470">                            RmEjbBundleKey.REQ_UNEXPECTED_ERROR, new Serializable[] {excMsg.getUnLocalizedMessage()}, validatorName);</span>
        }

        // bundle has been specified.  Now translate Object[], from ExceptionMessage.getMsgParms(),
        // to Serializable[] for passing to ValidationResult() constructor.
<span class="nc" id="L475">        Serializable[] serArr = convertToSerializable(excMsg.getMsgParms());</span>

<span class="nc bnc" id="L477" title="All 2 branches missed.">        return ( (softValidation)?</span>
<span class="nc" id="L478">                setSoftValidationResult(validatable, excMsg.getBundleName(),</span>
<span class="nc" id="L479">                        excMsg.getMsgKey(), serArr, validatorName):</span>
<span class="nc" id="L480">                setHardValidationResult(validatable, excMsg.getBundleName(),</span>
<span class="nc" id="L481">                        excMsg.getMsgKey(), serArr, validatorName));</span>
    }

    protected static Serializable[] convertToSerializable(Object[] objArr)
    {
        //Note: from sdk doc: if any actual component of the source array from cannot be converted to the component type of
        // the destination array by assignment conversion, an ArrayStoreException is thrown
<span class="nc" id="L488">        Serializable[] serArr = null;</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">        if (objArr != null) {</span>
<span class="nc" id="L490">            serArr = new Serializable[objArr.length];</span>
<span class="nc" id="L491">            System.arraycopy(objArr, 0, serArr, 0, objArr.length);</span>
        }

<span class="nc" id="L494">        return serArr;</span>
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           Exception e, String validatorName)
    {
<span class="nc" id="L500">        return setValidationResult(false, validatable, e, validatorName);</span>
    }

    /*public static ValidationResult setHardValidationResult(Validatable validatable,
        String msg, String className)
    {
        ValidationResult result = new ValidationResult(className, false);

        result.setMessage(msg);

        validatable.addValidationResult(result);

        return result;
    }*/

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, String className)
    {
<span class="nc" id="L518">        return setHardValidationResult(validatable, msgKey, null, className);</span>
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, String className)
    {
<span class="nc" id="L524">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, String className)
    {
<span class="nc" id="L531">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3, String className)
    {
<span class="nc" id="L538">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3,
                                                           Serializable obj4, String className)
    {
<span class="nc" id="L546">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3, obj4}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3,
                                                           Serializable obj4, Serializable obj5, String className)
    {
<span class="nc" id="L554">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3, obj4, obj5}, className);
    }

    //TODO: modify all validation rules to use these methods.
    public static ValidationResult setHardValidationResult(Validatable validatable, String msgKey,
                                                           Serializable[] parms, String className)
    {
<span class="nc" id="L562">        return setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, msgKey,</span>
                parms, className);
    }

    /**
     * Set HardValidationResult to Validatable Object and Log message
     * @param validatable - Validatable Object to set Validation Result to
     * @param uiKey - RM Resource Bundle Key for UI
     * @param logKey - RM Resource Bundle Key for Logging
     * @param params - Parameters associated with the Message
     * @param className - The Class NAme
     * @return ValidationResult
     */
    public static ValidationResult setAndLogHardValidationResult(
            Validatable validatable, String uiKey, String logKey,
            Serializable[] params, String className) {
<span class="nc" id="L578">        m_cat.l7dError(logKey, params);</span>
<span class="nc" id="L579">        return setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, uiKey,</span>
                params, className);
    }


    private static ValidationResult setHardValidationResult(Validatable validatable,
                                                            String msgBundleName, String msgKey, Serializable[] parms, String className) {
<span class="nc" id="L586">        ValidationResult result = getValidationResult(msgBundleName, msgKey, parms, className, false);</span>
<span class="nc" id="L587">        validatable.addValidationResult(result);</span>
<span class="nc" id="L588">        return result;</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           Exception e, String validatorName) {
<span class="nc" id="L593">        return setValidationResult(true, validatable, e, validatorName);</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, String className) {
<span class="nc" id="L598">        return setSoftValidationResult(validatable, msgKey, null, className);</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, String className)
    {
<span class="nc" id="L604">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, String className)
    {
<span class="nc" id="L611">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3, String className)
    {
<span class="nc" id="L618">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3,
                                                           Serializable ser4, String className)
    {
<span class="nc" id="L626">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3, ser4}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3,
                                                           Serializable ser4, Serializable ser5, String className)
    {
<span class="nc" id="L634">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3, ser4, ser5}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable, String msgKey,
                                                           Serializable[] parms, String className) {
<span class="nc" id="L640">        return setSoftValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, msgKey, parms, className);</span>
    }
    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgBundleName, String msgKey, Serializable[] parms, String className) {
<span class="nc" id="L644">        ValidationResult result = getValidationResult(msgBundleName, msgKey, parms, className, true);</span>
<span class="nc" id="L645">        validatable.addValidationResult(result);</span>
<span class="nc" id="L646">        return result;</span>
    }
   

    /*public static ValidationResult getFirstValidationResult(Validatable validatable)
     {
         if ( validatable.getValidationResults() != null &amp;&amp; !validatable.getValidationResults().isEmpty() )
             return (ValidationResult) validatable.getValidationResults().iterator().next();

         return null;
     }*/

    public static String dumpEnterValidateMethod(Class validClass, Validatable val) {
<span class="nc" id="L659">        return &quot;ENTER: &quot; + validClass.getName() + &quot;.validate(&quot; + val + &quot;)&quot;;</span>
    }

    public static String dumpExitValidateMethod(Class validClass) {
<span class="nc" id="L663">        return &quot;EXIT: &quot; + validClass.getName() + &quot;.validate()&quot;;</span>
    }
    /**
     * Construct a ValidationResult.
     * @param bundle the base name of the resource bundle that contains the
     * translatable text for this message.
     * @param msgKey the resource name of the translatable text in the bundle.
     * @param parms an array of Serializable objects used to fill in parameters
     * in the message.
     * that produced this result.  Typically, this will be the fully qualified
     * classname of the validator.
     * @param isSoft true if this is a soft validation, false otherwise
     */
    public static ValidationResult getValidationResult(String bundle, String msgKey, Serializable[] parms, String className, boolean isSoft) {
<span class="nc" id="L677">        ValidationResult result = new ValidationResult(className, isSoft);</span>
<span class="nc" id="L678">        result.setMessage(bundle, msgKey, parms);</span>
<span class="nc" id="L679">        return result;</span>
    }
    
    public static Collection getSchedulingPeriods(Collection spIDs) throws Exception {
<span class="nc" id="L683">        return RequestUtil.getSchedulingPeriod(spIDs);</span>
    }

    /**
     * Get all of an employee's work patterns (a map of ShiftPatternID-&gt;ShiftPattern) for a particular date range.
     * We consider Rotations and non-Rotation work pattern assignments.
     */
    public static HashMap getEmpWorkPatterns(EmpWorkRuleManager empWorkRuleManager, WorkRuleManager workRuleManager, ID empID,
                                             Date fromDate, Date toDate) throws RemoteException, BbmFinderException
    {
<span class="nc" id="L693">        HashMap shiftPatterns = new HashMap();</span>
<span class="nc" id="L694">		HashSet&lt;ID&gt; colWorkPatternIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L695">        boolean hasRotationShiftPattern = false;</span>
<span class="nc" id="L696">        HashMap mapEmpRotationAssignments = empWorkRuleManager.getRotationAssignments(Collections.singletonList(empID)); //key = employee ID, value = collection of rotation assignments</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">        if (mapEmpRotationAssignments != null &amp;&amp; !mapEmpRotationAssignments.isEmpty())</span>
        {
<span class="nc" id="L699">            Collection rotations = (Collection)mapEmpRotationAssignments.get(empID);</span>
<span class="nc bnc" id="L700" title="All 4 branches missed.">            if (rotations != null &amp;&amp; !rotations.isEmpty())</span>
            {
<span class="nc bnc" id="L702" title="All 2 branches missed.">                for (Iterator rotIt=rotations.iterator(); rotIt.hasNext();)</span>
                {
<span class="nc" id="L704">                    WorkResourceRotation wrr = (WorkResourceRotation)rotIt.next();</span>
<span class="nc" id="L705">                    ShiftPattern pPattern = ShiftsUtil.getRotationShiftPatternForTheWeek(wrr, fromDate);</span>
<span class="nc" id="L706">                    shiftPatterns.put(pPattern.getID(), pPattern);</span>
<span class="nc" id="L707">                    hasRotationShiftPattern = true;</span>
<span class="nc" id="L708">                }</span>
            }
        }

<span class="nc bnc" id="L712" title="All 2 branches missed.">        if (!hasRotationShiftPattern)</span>
        {
            //Get all of the employee's workPatternIDs on the asOfDate (SHIFTPATTERNWORKRESOURCE)
<span class="nc" id="L715">            Collection colAssignments = empWorkRuleManager.getWorkPatternAssignmentsForEmployee(empID, fromDate, toDate);</span>
<span class="nc" id="L716">            WorkResourceWorkPattern ww= null;</span>
<span class="nc bnc" id="L717" title="All 4 branches missed.">            if (colAssignments != null &amp;&amp; !colAssignments.isEmpty())</span>
            {
<span class="nc bnc" id="L719" title="All 2 branches missed.">                for (Iterator ix = colAssignments.iterator(); ix.hasNext(); )</span>
                {
<span class="nc" id="L721">                    ww= (WorkResourceWorkPattern)ix.next();</span>
<span class="nc" id="L722">                    colWorkPatternIDs.add(ww.getWorkPatternSID());</span>
                }
            }

<span class="nc bnc" id="L726" title="All 2 branches missed.">            if (!colWorkPatternIDs.isEmpty())</span>
            {
<span class="nc" id="L728">                shiftPatterns = ValueObjectUtil.getIDObjectMap(workRuleManager.getShiftPatternsByIDs(colWorkPatternIDs));</span>
            }
        }

<span class="nc" id="L732">        return shiftPatterns;</span>
    }

	/**
	 * Get the request start and end dates, given the timeRange segments in the request.
	 * @param trCol - The timeRange segments for the request.
	 * @return A TimeRange of the request start and end dates.
	 */
	public static TimeRange getRequestDateRange(List&lt;TimeRange&gt; trCol) {
<span class="nc" id="L741">		Date requestStartDate = null;</span>
<span class="nc" id="L742">		Date requestEndDate = null;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">		for (TimeRange tr : trCol) {</span>

<span class="nc bnc" id="L745" title="All 2 branches missed.">			if (requestStartDate == null) {</span>
<span class="nc" id="L746">				requestStartDate = tr.getStartDate();</span>
<span class="nc" id="L747">				requestEndDate = tr.getEndDate();</span>
<span class="nc" id="L748">				continue;</span>
			}

<span class="nc bnc" id="L751" title="All 2 branches missed.">			if (tr.getStartDate().before(requestStartDate)) {</span>
<span class="nc" id="L752">				requestStartDate = tr.getStartDate();</span>
			}

<span class="nc bnc" id="L755" title="All 2 branches missed.">			if (tr.getEndDate().after(requestEndDate)) {</span>
<span class="nc" id="L756">				requestEndDate = tr.getEndDate();</span>
			}
<span class="nc" id="L758">		}</span>
<span class="nc" id="L759">		return new TimeRange(requestStartDate, requestEndDate);</span>
	}

	/**
	 * Determines if the given date falls within one of the given TimeRange's.
	 */
	public static boolean isValidInterval(Date curIntervalStart, List&lt;TimeRange&gt; trCol)
	{
<span class="nc bnc" id="L767" title="All 2 branches missed.">		for (TimeRange tr : trCol)</span>
		{
<span class="nc bnc" id="L769" title="All 4 branches missed.">			if (!curIntervalStart.before(tr.getStartDate()) &amp;&amp; curIntervalStart.before(tr.getEndDate()))</span>
			{
<span class="nc" id="L771">				return true;</span>
			}
<span class="nc" id="L773">		}</span>
<span class="nc" id="L774">		return false;</span>
	}

	/**
	 * Get a HashMap of SPQueue mapped to the FTE Differential value for the specified date range.
	 * If the value is below the threshold, we return 0.
	 * @param fromDate
	 * @param toDate
	 * @param cubeCacheKey - the unique identifier for this NetStaffingCube. It will be used for caching aggregations in the ValidationCache.
	 * @return
	 */
	public static HashMap&lt;SPQueue, Double&gt; getFTEDPastThreshold(NetStaffingCube nsCube, Date fromDate, Date toDate, String cubeCacheKey, ValidationCache cache)
	{
<span class="nc" id="L787">		HashMap&lt;SPQueue, Double&gt; netStaffMap = new HashMap();</span>

<span class="nc" id="L789">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L790">		cal.setTime(fromDate);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">		while (toDate.after(cal.getTime()))</span>
		{
<span class="nc bnc" id="L793" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; iterator = nsCube.getPredictTraceCubeMap().keySet().iterator(); iterator.hasNext();)</span>
			{
<span class="nc" id="L795">				ID spQID = iterator.next();</span>
<span class="nc" id="L796">				PredictTraceCube pCube = nsCube.getPredictTraceCubeMap().get(spQID);</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">				if (!pCube.fallsIn(cal.getTime())) {</span>
<span class="nc" id="L798">					continue;</span>
				}
<span class="nc" id="L800">				RequireTraceCube rCube = nsCube.getRequireTraceCubeMap().get(spQID);</span>
<span class="nc" id="L801">				SPQueue spQueue = nsCube.getSPQueueMap().get(spQID);</span>
<span class="nc" id="L802">				Campaign camp = nsCube.getCampaignMap().get(spQID);</span>
<span class="nc" id="L803">				TimeRange range = nsCube.snapDate(camp, pCube, spQueue, cal.getTime());</span>

				
<span class="nc bnc" id="L806" title="All 2 branches missed.">				if (range.getStartDate().equals(range.getEndDate())) {</span>
<span class="nc" id="L807">					continue;</span>
				}

<span class="nc" id="L810">				int pStartAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L811">				int pEndAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L812">				int rStartAbsOffset = rCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L813">				int rEndAbsOffset = rCube.getTimeOffset(range.getEndDate());</span>

<span class="nc" id="L815">				double cForFTE = cache.aggregatePeriodD(pCube, cubeCacheKey+&quot;_FOR&quot;, Trace.AFTE, pStartAbsOffset, pEndAbsOffset);</span>
<span class="nc" id="L816">				double cReqFTE = cache.aggregatePeriodD(rCube, cubeCacheKey+&quot;_REQ&quot;, Trace.FTE, rStartAbsOffset, rEndAbsOffset);</span>

<span class="nc" id="L818">				double fted = nsCube.getFTEDPastThreshold(cForFTE, cReqFTE, spQueue);</span>

<span class="nc" id="L820">				netStaffMap.put(spQueue, fted);</span>
<span class="nc" id="L821">			}</span>

<span class="nc" id="L823">			Date stDate = cal.getTime();</span>
<span class="nc" id="L824">			cal.add(Calendar.MINUTE, Trace.INTERVAL); //add 15 minutes every time regardless of LTI</span>
<span class="nc" id="L825">			Date enDate = cal.getTime();</span>
<span class="nc" id="L826">			TimeRange range = new TimeRange(stDate, enDate);</span>
<span class="nc" id="L827">		}</span>
<span class="nc" id="L828">		return netStaffMap;</span>
	}


	/**
	 * Merge overlapping/adjacent time ranges.
	 *
	 * @param timeRanges
	 * @return
	 */
	private static Collection&lt;TimeRange&gt; join(Collection&lt;TimeRange&gt; timeRanges) {
<span class="nc" id="L839">		List&lt;TimeRange&gt; joinedList = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">		for (TimeRange timeRange : timeRanges) {</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">			for (Iterator&lt;TimeRange&gt; it = joinedList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L842">				TimeRange tr = it.next();</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">				if (tr.joinWithOverlap(timeRange, 0) != null) {</span>
<span class="nc" id="L844">					it.remove();</span>
<span class="nc" id="L845">					timeRange = timeRange.joinWithOverlap(tr, 0);</span>
				}
<span class="nc" id="L847">			}</span>
<span class="nc" id="L848">			joinedList.add(timeRange);</span>
<span class="nc" id="L849">		}</span>
<span class="nc" id="L850">		return joinedList;</span>
	}

	/**
	 * Merge overlapping/adjacent time ranges and sort the result.
	 *
	 * @param timeRanges
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public static List&lt;TimeRange&gt; joinAndSort(Collection&lt;TimeRange&gt; timeRanges) {
<span class="nc" id="L861">		List&lt;TimeRange&gt; result = new ArrayList&lt;TimeRange&gt;(join(timeRanges));</span>
<span class="nc" id="L862">		Collections.sort(result);</span>
<span class="nc" id="L863">		return result;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>