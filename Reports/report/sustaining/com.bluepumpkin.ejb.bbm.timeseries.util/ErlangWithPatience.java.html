<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ErlangWithPatience.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">ErlangWithPatience.java</span></div><h1>ErlangWithPatience.java</h1><pre class="source lang-java linenums">/*
 * (c) 2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import java.util.ArrayList;
import java.util.List;

/**
 * An instance of this class may be used to perform FTE requirements calculations for
 * an immediate media type queue in which patience or abandonment is modeled.
 * &lt;p/&gt;
 * A document explaining the calculations in this class is available from Dan Morenus.
 * TODO: Once the document has been approved, put in the repository and replace the above
 * with a URL for it.
 */
public class ErlangWithPatience {
	private static final double MIN_STAFFING_VERSUS_WORKLOAD_RATIO = 1.0001;
<span class="nc" id="L19">	private static final double LN_10_POWER_16 = Math.log(10.) * 16.;</span>

<span class="nc" id="L21">	private static final ErlangWithPatience INSTANCE = new ErlangWithPatience();</span>

	public static ErlangWithPatience getInstance() {
<span class="nc" id="L24">		return INSTANCE;</span>
	}

<span class="nc" id="L27">	private ErlangWithPatience() {</span>
		// Singleton.
<span class="nc" id="L29">	}</span>

	/**
	 * Returns the largest index k at which the t(k) and p(k) values will be maximal.  The t(k) and
	 * p(k) sequences may have at most two such maximal values and they are adjacent, unless patience
	 * is infinite (alpha = 0) and numberOfServers is less than or equal to lambda/mu, in which case
	 * all t(k) for k &gt;= lambda/mu are the same, p(k) are undefined, and this function
	 * throws an exception. 
	 * 
	 * @param numberOfServers the number of people serving customers; the number of positions in the
	 * queue in which people are being served rather than waiting
	 * @param lambda the queue's arrival rate per second
	 * @param mu the queue's processing rate per second of people that do not abandon
	 * @param alpha the rate per second at which people abandon the queue
	 * @throws IllegalArgumentException if alpha is zero and numberOfServers is less than or
	 * equal to lambda/mu; this means the queue will grow without bound.
	 * @return the largest index k at which the t(k) and p(k) values will be maximal
	 */
	public static int getMaxTIndex(int numberOfServers, double lambda, double mu, double alpha) {
<span class="nc" id="L48">		double workload = lambda / mu;</span>
<span class="nc bnc" id="L49" title="All 4 branches missed.">		if (alpha == 0 &amp;&amp; numberOfServers &lt;= workload) {</span>
<span class="nc" id="L50">			throw new IllegalArgumentException(&quot;Cannot calculate max T index for infinite patience and servers less than or equal to workload.&quot;);</span>
		}
<span class="nc bnc" id="L52" title="All 2 branches missed.">		if (numberOfServers &gt;= workload) {</span>
<span class="nc" id="L53">			return (int)Math.floor(workload);</span>
		} else {
<span class="nc" id="L55">			return (int)Math.floor(numberOfServers +</span>
								   (lambda - mu*numberOfServers) / alpha);
		}
	}

	/**
	 * Calculates the leave rate and state probability tables for each modeled state of the queue.
	 * &lt;p/&gt;
	 * Both tables are calculated in a single method because the leave rate is part of the probability
	 * calculation but the probability calculation is what determines how large the tables must be
	 * in order to achieve the desired precision in the ASA calculation.
	 * 
	 * @param numberOfServers the number of people serving customers; the number of positions in the
	 * queue in which people are being served rather than waiting
	 * @param lambda the queue's arrival rate per second
	 * @param mu the queue's processing rate per second of people that do not abandon
	 * @param alpha the rate per second at which people abandon the queue
	 * @return
	 */
	private StateTables getStateTables(int numberOfServers, double lambda, double mu, double alpha) {
		// Because we initially don't know how many states we have to model to get the desired
		// precision, these arrays start out as lists.
		// The leave rate for state k is the rate at which people are served times the number of
		// people being served in state k, plus the rate at which people abandon times the number
		// of people waiting in state k.
<span class="nc" id="L80">		List&lt;Double&gt; leaveRateList = new ArrayList&lt;Double&gt;(getMaxTIndex(numberOfServers, lambda, mu, alpha) * 2);</span>
		// t(k) is a non-normalized source for the probability distribution.
		// To avoid overflow we use ln(t(k)).
<span class="nc" id="L83">		List&lt;Double&gt; lnTList = new ArrayList&lt;Double&gt;(getMaxTIndex(numberOfServers, lambda, mu, alpha) * 2);</span>
		// In order to get a total t(k) to normalize, we have to scale the sum to avoid overflow.
		// While calculating ln(t(k)) we keep track of the largest t(k) term and a range around it
		// where the terms are within 16 orders of magnitude of the largest term.  Those terms will
		// be used in the summation to normalize.  To avoid overflow we will scale everything by
		// the integer ln of the smallest t(k) in the summation.

		// This list stores the index at which the t(k) terms reach each integer power of e as they grow.
<span class="nc" id="L91">		List&lt;Integer&gt; magnitudeIndices = new ArrayList&lt;Integer&gt;();</span>
<span class="nc" id="L92">		int lastMagnitude = Integer.MIN_VALUE;</span>
<span class="nc" id="L93">		double maxTerm = 0.;</span>
<span class="nc" id="L94">		int maxComputedIndex = -1;</span>
<span class="nc" id="L95">		leaveRateList.add(0.);</span>
<span class="nc" id="L96">		lnTList.add(0.);</span>
<span class="nc" id="L97">		double previousLnT = 0.;</span>
<span class="nc" id="L98">		magnitudeIndices.add(0);</span>
<span class="nc" id="L99">		int state = 1;</span>
		while (true) {
			try {
<span class="nc" id="L102">				int inService = Math.min(state, numberOfServers);</span>
<span class="nc" id="L103">				int waiting = state - inService;</span>
<span class="nc" id="L104">				double leaveRate = inService * mu + waiting * alpha;</span>
<span class="nc" id="L105">				double lnT = previousLnT + Math.log(lambda / leaveRate);</span>
<span class="nc" id="L106">				leaveRateList.add(leaveRate);</span>
<span class="nc" id="L107">				lnTList.add(lnT);</span>
//System.out.println(&quot;t(&quot; + state + &quot;) = &quot; + Math.exp(lnT) + &quot;, ln(t(&quot; + state + &quot;)) = &quot; + lnT);
<span class="nc bnc" id="L109" title="All 2 branches missed.">				if (lnT &gt; previousLnT) {</span>
<span class="nc" id="L110">					maxTerm = lnT;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">					if ((int)lnT &gt; lastMagnitude) {</span>
<span class="nc" id="L112">						lastMagnitude = (int)lnT;</span>
<span class="nc" id="L113">						magnitudeIndices.add(state);</span>
					}
<span class="nc bnc" id="L115" title="All 2 branches missed.">				} else if (lnT &lt; maxTerm - Math.ceil(LN_10_POWER_16)) {</span>
<span class="nc" id="L116">					maxComputedIndex = state;</span>
<span class="nc" id="L117">					break;</span>
				}
<span class="nc" id="L119">				previousLnT = lnT;</span>
<span class="nc" id="L120">				state++;</span>
			}
<span class="nc" id="L122">			catch (OutOfMemoryError oome) {</span>
<span class="nc" id="L123">				System.out.println(state);</span>
<span class="nc" id="L124">				throw oome;</span>
<span class="nc" id="L125">			}</span>
		}
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (maxComputedIndex &lt; 0) {</span>
<span class="nc" id="L128">			throw new RuntimeException(&quot;Didn't reach full convergence of sum of t(k): max ln(t(k)) = &quot; + maxTerm + &quot;, last computed t(k) = &quot; + lnTList.get(lnTList.size() - 1));</span>
		}
<span class="nc" id="L130">		int numberOfIndicesBack = (int)Math.min(Math.ceil(LN_10_POWER_16), magnitudeIndices.size() - 1);</span>
<span class="nc" id="L131">		int firstSumIndex = magnitudeIndices.get(Math.max(0, magnitudeIndices.size() - numberOfIndicesBack - 1));</span>
<span class="nc" id="L132">		double baseValue = Math.min(lnTList.get(firstSumIndex), lnTList.get(maxComputedIndex));</span>
<span class="nc" id="L133">		int baseMagnitude = (int)Math.floor(baseValue);</span>
//System.out.println(&quot;Summing indices from &quot; + firstSumIndex + &quot; to &quot; + maxComputedIndex);
<span class="nc" id="L135">		double[] leaveRates = new double[leaveRateList.size()];</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">		for (int i = 0; i &lt; leaveRateList.size(); ++i) {</span>
<span class="nc" id="L137">			leaveRates[i] = leaveRateList.get(i);</span>
		}

<span class="nc" id="L140">		double totalT = 0;</span>
<span class="nc bnc" id="L141" title="All 2 branches missed.">		for (int i = firstSumIndex; i &lt;= maxComputedIndex; ++i) {</span>
<span class="nc" id="L142">			totalT += Math.exp(lnTList.get(i) - baseMagnitude);</span>
		}

		// Note that all state probabilities outside the range of indices set here are zero,
		// reflecting that their probability of occurring is zero to our precision.
<span class="nc" id="L147">		double[] distribution = new double[lnTList.size()];</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">		for (int i = firstSumIndex; i &lt;= maxComputedIndex; ++i) {</span>
<span class="nc" id="L149">			distribution[i] = Math.exp(lnTList.get(i) - baseMagnitude) / totalT;</span>
		}
<span class="nc" id="L151">		return new StateTables(leaveRates, distribution);</span>
	}

	/**
	 * Returns a table of the probabilities that a caller arriving when the queue is in a given state
	 * will abandon before being served.
	 * 
	 * @param numberOfServers the number of people serving customers; the number of positions in the
	 * queue in which people are being served rather than waiting
	 * @param alpha the rate per second at which people abandon the queue
	 * @param maxQueuePositions the maximum number of positions to be modeled in the queue.
	 * @param mu the queue's processing rate per second of people that do not abandon
	 * 
	 * @return
	 */
	private double[] getAbandonmentByState(int numberOfServers, double alpha, double[] leaveRates) {
<span class="nc" id="L167">		double[] abandonmentByState = new double[leaveRates.length];</span>

<span class="nc bnc" id="L169" title="All 2 branches missed.">		for (int i = 0; i &lt; leaveRates.length; ++i) {</span>
<span class="nc bnc" id="L170" title="All 2 branches missed.">			if (i &lt; numberOfServers) {</span>
<span class="nc" id="L171">				abandonmentByState[i] = 0.;</span>
			} else {
<span class="nc" id="L173">				double abandonNow = alpha / (alpha + leaveRates[i]);</span>
<span class="nc" id="L174">				abandonmentByState[i] = abandonNow + (1 - abandonNow) * abandonmentByState[i - 1];</span>
			}
		}

<span class="nc" id="L178">		return abandonmentByState;</span>
	}

	/**
	 * Returns the average probability that a particular customer will abandon before being served.
	 * This is the sum of the probability that a customer arriving when the queue has a particular
	 * number of people will abandon weighted by the probability that the queue will have exactly
	 * that number of people in it when the customer arrives.
	 * 
	 * @param numberOfServers
	 * @param mu
	 * @param alpha
	 * @param stateProbabilities
	 * @return
	 */
	private double getAverageAbandonmentProportion(int numberOfServers, double alpha, double[] leaveRates, double[] stateProbabilities) {
<span class="nc" id="L194">		double[] abandonmentByState = getAbandonmentByState(numberOfServers, alpha, leaveRates);</span>
<span class="nc" id="L195">		double averageAbandonment = 0;</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		for (int i = 0; i &lt; stateProbabilities.length; ++i) {</span>
<span class="nc" id="L197">			averageAbandonment += stateProbabilities[i] * abandonmentByState[i];</span>
		}
<span class="nc" id="L199">		return averageAbandonment;</span>
	}

	/**
	 * Returns the average probability that a particular customer will abandon before being served.
	 * 
	 * @param numberOfServers
	 * @param arrivalRate
	 * @param aht
	 * @param abandonRate
	 * @return
	 */
	public double getAverageAbandonmentProportion(
			int numberOfServers,
			double arrivalRate,
			double aht,
			double abandonRate) {
<span class="nc bnc" id="L216" title="All 4 branches missed.">		if (numberOfServers &lt;= 0 || numberOfServers &gt; ErlangC.DEFAULT_MAX_AGENTS) {</span>
<span class="nc" id="L217">			throw new IllegalArgumentException(&quot;Number of servers must be between 1 and &quot; + ErlangC.DEFAULT_MAX_AGENTS + &quot;, inclusive.&quot;);</span>
		}
		// If the number of servers is less than or equal to the workload and there is infinite
		// patience, the queue will grow without limit and there is no meaningful ASA.
<span class="nc bnc" id="L221" title="All 4 branches missed.">		if (numberOfServers &lt;= arrivalRate * aht &amp;&amp;</span>
				abandonRate == 0.) {
<span class="nc" id="L223">			throw new IllegalArgumentException(&quot;Cannot calculate abandonment for infinite patience and servers less than or equal to workload.&quot;);</span>
		}
		// If the number of servers is extremely close to the workload and there is infinite
		// patience, then we assume that the queue will stabilize with really bad ASA.
<span class="nc bnc" id="L227" title="All 4 branches missed.">		if (numberOfServers / (arrivalRate * aht) &lt; MIN_STAFFING_VERSUS_WORKLOAD_RATIO &amp;&amp;</span>
			abandonRate == 0.) {
<span class="nc" id="L229">			return 1;</span>
		}
<span class="nc" id="L231">		double mu = 1/aht;</span>
<span class="nc" id="L232">		StateTables tables = getStateTables(numberOfServers, arrivalRate, mu, abandonRate);</span>
<span class="nc" id="L233">		double[] leaveRates = tables.getLeaveRates();</span>
<span class="nc" id="L234">		double[] stateProbabilities = tables.getStateProbabilities();</span>
<span class="nc" id="L235">		return getAverageAbandonmentProportion(numberOfServers, abandonRate, leaveRates, stateProbabilities);</span>
	}

	/**
	 * Returns a table of the average length of time people that do not abandon will wait to be served
	 * if they arrive at the queue while it is in a given state.
	 * 
	 * @param numberOfServers the number of people serving customers; the number of positions in the
	 * queue in which people are being served rather than waiting
	 * @param alpha the rate per second at which people abandon the queue
	 * @param leaveRates the leave rate for each modeled state of the queue
	 * @return
	 */
	private double[] getTotalWaitsNoAbandonment(int numberOfServers, double alpha, double[] leaveRates) {
<span class="nc" id="L249">		double[] totalWaits = new double[leaveRates.length];</span>
<span class="nc" id="L250">		totalWaits[0] = 0;</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		for (int i = 1; i &lt; leaveRates.length; ++i) {</span>
			// The probability that a caller arriving when the queue is in state k will abandon before
			// someone in front of them leaves the queue is leaveRate[k] / (leaveRate[k] + alpha)^2
			// The totalWaits array accumulates those waits for each state.
<span class="nc bnc" id="L255" title="All 2 branches missed.">			totalWaits[i] = (i &lt; numberOfServers) ? 0 : totalWaits[i - 1] + leaveRates[i] / ((leaveRates[i] + alpha) * (leaveRates[i] + alpha));</span>
		}
<span class="nc" id="L257">		return totalWaits;</span>
	}

	/**
	 * Returns the ASA that will result from the given staffing and queue properties.
	 * &lt;p/&gt;
	 * Setting the abandon rate to zero will yield essentially identical results to
	 * the Erlang C calculations.
	 * 
	 * @param numberOfServers the number of employees available to handle traffic
	 * @param arrivalRate the traffic arrival rate per second
	 * @param aht the average time to process a customer that does not abandon
	 * @param abandonRate the rate of abandons per second
	 * 
	 * @return
	 */
	public double getAsaWithPatience(
			int numberOfServers,
			double arrivalRate,
			double aht,
			double abandonRate) {
<span class="nc bnc" id="L278" title="All 4 branches missed.">		if (numberOfServers &lt;= 0 || numberOfServers &gt; ErlangC.DEFAULT_MAX_AGENTS) return -1.0; // for compatibility</span>
		// If the number of servers is less than or equal to the workload and there is infinite
		// patience, the queue will grow without limit and there is no meaningful ASA.
<span class="nc bnc" id="L281" title="All 4 branches missed.">		if (numberOfServers &lt;= arrivalRate * aht &amp;&amp;</span>
				abandonRate == 0.) {
<span class="nc" id="L283">			throw new IllegalArgumentException(&quot;Cannot calculate ASA for infinite patience and servers less than or equal to workload.&quot;);</span>
		}
		// If the number of servers is extremely close to the workload and there is infinite
		// patience, then we assume that the queue will stabilize with really bad ASA.
<span class="nc bnc" id="L287" title="All 4 branches missed.">		if (numberOfServers / (arrivalRate * aht) &lt; MIN_STAFFING_VERSUS_WORKLOAD_RATIO &amp;&amp;</span>
			abandonRate == 0.) {
<span class="nc" id="L289">			return Integer.MAX_VALUE;</span>
		}
//System.out.println(&quot;getAsaWithPatience(&quot; + numberOfServers + &quot;, &quot; + arrivalRate + &quot;, &quot; + aht + &quot;, &quot; + abandonRate + &quot;)&quot;);
<span class="nc" id="L292">		double mu = 1/aht;</span>
<span class="nc" id="L293">		StateTables tables = getStateTables(numberOfServers, arrivalRate, mu, abandonRate);</span>
<span class="nc" id="L294">		double[] leaveRates = tables.getLeaveRates();</span>
<span class="nc" id="L295">		double[] stateProbabilities = tables.getStateProbabilities();</span>
//System.out.println(&quot;Predicted max T index = &quot; + getMaxTIndex(numberOfServers, arrivalRate, mu, abandonRate));
<span class="nc" id="L297">		double[] totalWaits = getTotalWaitsNoAbandonment(numberOfServers, abandonRate, leaveRates);</span>
<span class="nc" id="L298">		double asa = 0;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for (int i = 0; i &lt; totalWaits.length; ++i) {</span>
<span class="nc" id="L300">			asa += stateProbabilities[i] * totalWaits[i];</span>
		}
//System.out.println(&quot;ASA = &quot; + asa + &quot;, estimated rate of abandonment = &quot; + getAverageAbandonment(numberOfServers, abandonRate, leaveRates, stateProbabilities));
<span class="nc" id="L303">		return asa;</span>
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired asa (average seconds
	 * to answer).  The value returned will be zero if the arrival rate is zero; it will
	 * fall in the range [0, absoluteMaximumAgents] if the service goal could be achieved
	 * within that range; an exception is thrown if the service goal could not be met even
	 * with absoluteMaximumAgents agents.
	 * &lt;p/&gt;
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param abandonsPerSecond the rate of abandons per second per person waiting.  If patience
	 * has been specified then this is 1/patience.  Setting {@code abandonsPerSecond} to zero
	 * implies infinite patience and these calculations become equivalent to the Erlang C
	 * calculations.
	 * @param targetAsa Average seconds to answer (service target)
	 * @return the smallest value in [0, absoluteMaximumAgents] that satisfies the specified
	 * ASA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	public int getAgentsAsaWithPatience(
			double arrivalRate,
			double aht,
			double abandonsPerSecond,
			double targetAsa)
	{
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if (targetAsa &lt;= 0) {</span>
<span class="nc" id="L336">			throw new IllegalArgumentException(&quot;Tried to find FTE for non-positive target ASA&quot;);</span>
		}
<span class="nc" id="L338">		double workload = aht * arrivalRate;</span>
		// If abandonsPerSecond is nonzero then even one person staffing the queue could conceivably
		// satisfy a sufficiently poor ASA target.  If abandonsPerSecond is zero then the queue
		// must have at least as many servers as the workload or it will grow without bound.
		// Because of the way this algorithm is implemented, the result will always be at least one
		// greater than the minimum bound which is why we use truncation instead of ceiling.
<span class="nc bnc" id="L344" title="All 2 branches missed.">		return getAgentsAsaWithPatience(</span>
				arrivalRate,
				aht,
				abandonsPerSecond,
				targetAsa,
				// The .95 factor will prevent us getting more than about 5% abandons.
				// It may also give the impression that these calculations are ignoring the
				// patience setting so be aware of that.
				(abandonsPerSecond &gt; 0) ? (int)(0.95 * arrivalRate * aht) : (int)(arrivalRate * aht),
<span class="nc" id="L353">				getAgentsAsaUpperBound(workload));</span>
	}

	/**
	 * Returns a rough upper bound for the number of agents required to handle the 
	 * specified workload.  This method does not take service level into account; it
	 * returns a value that will be sufficient if the service level is set to ASA = 1 second.
	 * 
	 * For large workloads the FTE requirement falls quite close to the workload.
	 * It would be good to tune this value further, perhaps expressing it as a function
	 * of workload.
	 * 
	 * @param workload
	 * @return
	 */
	private int getAgentsAsaUpperBound(double workload)
	{
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (workload &gt; 500) {</span>
<span class="nc" id="L371">			return (int)Math.ceil(1.1 * workload);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">		} else if (workload &gt; 50) {</span>
<span class="nc" id="L373">			return (int)Math.ceil(1.4 * workload);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		} else if (workload &gt; 20) {</span>
<span class="nc" id="L375">			return (int)Math.ceil(2 * workload);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">		} else if (workload &gt; 5) {</span>
<span class="nc" id="L377">			return (int)Math.ceil(4 * workload);</span>
		} else {
<span class="nc" id="L379">			return 20;</span>
		}
	}

	/**
	 * Given traffic parameters arrival rate (lambda) and average handling time (tau),
	 * computes the number of agents required to achieve the desired asa (average seconds
	 * to answer).  The value returned will be zero if the arrival rate is zero; it will
	 * fall in the range [minAgents, maxAgents] if the service goal could be achieved
	 * within that range; an exception is thrown if the service goal could not be met even
	 * with maxAgents agents.
	 * &lt;p/&gt;
	 * Note that if the AHT is zero but the arrival rate is nonzero the method returns
	 * minAgents+1 rather than zero.
	 * 
	 * @param arrivalRate Arrival rate
	 * @param aht Average handling time
	 * @param targetAsa Average seconds to answer (service target)
	 * @param minAgents Minimum number of agents to consider
	 * @param maxAgents Maximum number of agents to consider
	 * @return the smallest value in [minAgents, maxAgents] that satisfies the specified
	 * ASA target.
	 * @throws IllegalArgumentException if the global maximum agents limit is not sufficiently large to
	 * satisfy the target.
	 */
	private int getAgentsAsaWithPatience(
			double arrivalRate,
			double aht,
			double abandonRate,
			double targetAsa,
			int minAgents,
			int maxAgents)
	{
//System.out.println(&quot;getAgentsAsaWithPatience(&quot; + arrivalRate + &quot;, &quot; + aht + &quot;, &quot; + abandonRate + &quot;, &quot; + targetAsa + &quot;, &quot; + minAgents + &quot;, &quot; + maxAgents + &quot;)&quot;);
<span class="nc bnc" id="L413" title="All 2 branches missed.">	    if (arrivalRate == 0) return 0;		// no arrivals - no agents</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">	    if (aht == 0) {</span>
<span class="nc" id="L415">	    	return minAgents + 1;		// no AHT - each agent apparently smiles and says &quot;Next!&quot;</span>
	    }

<span class="nc" id="L418">		boolean goalAchieved = false;</span>
<span class="nc" id="L419">		int min = minAgents;</span>
<span class="nc" id="L420">		int max = maxAgents;</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">		while (max - min &gt; 1)</span>
		{
<span class="nc" id="L423">			int candidateNumberOfAgents = (max + min) / 2;</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">			if (getAsaWithPatience(candidateNumberOfAgents, arrivalRate, aht, abandonRate) &gt; targetAsa)</span>
			{
<span class="nc" id="L426">				min = candidateNumberOfAgents;</span>
			}
			else
			{
<span class="nc" id="L430">				max = candidateNumberOfAgents;</span>
<span class="nc" id="L431">				goalAchieved = true;</span>
			}
<span class="nc" id="L433">		}</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">		if (max &gt; ErlangC.DEFAULT_MAX_AGENTS) {</span>
<span class="nc" id="L435">			throw new IllegalArgumentException(&quot;Global maximum employee count &quot; + ErlangC.DEFAULT_MAX_AGENTS + &quot; exceeded: agents = &quot; + max + &quot;, lambda = &quot; + arrivalRate + &quot;, tau = &quot; + aht + &quot;, target ASA = &quot; + targetAsa + &quot;.&quot;);</span>
<span class="nc bnc" id="L436" title="All 4 branches missed.">		} else if (goalAchieved || getAsaWithPatience(max, arrivalRate, aht, abandonRate) &lt;= targetAsa) {</span>
//System.out.println(&quot;FTE = &quot; + max + &quot;, probWait(&quot; + max + &quot;) = &quot; + probWait(max, lambda, tau) + &quot;, probWait(&quot; + (max-1) + &quot;) = &quot; + probWait(max-1, lambda, tau) + &quot;, probWait(&quot; + (max+1) + &quot;) = &quot; + probWait(max+1, lambda, tau));
<span class="nc" id="L438">			return max;</span>
		} else {
<span class="nc" id="L440">			throw new IllegalArgumentException(&quot;Maximum employee count &quot; + maxAgents + &quot; exceeded: lambda = &quot; + arrivalRate + &quot;, tau = &quot; + aht + &quot;, target ASA = &quot; + targetAsa + &quot;.&quot;);</span>
		}
	}

	/**
	 * Uses Little's Law to estimate the average time a client will spend in the system,
	 * whether waiting or being served.
	 * &lt;p/&gt;
	 * Loosely, Little's Law states that given a system in which people arrive, wait in some
	 * fashion to be served in some way, and then leave, if the system is in steady state then
	 * 		L = lambda*W
	 * where L is the average number of people in the system, W is the average time it takes
	 * for a person to go through the system, and lambda is the average number of people arriving
	 * in a unit of time.
	 *   
	 * @param numberOfServers
	 * @param arrivalRate
	 * @param aht
	 * @param abandonsPerSecond
	 * @return
	 */
	public double getAverageTimeInSystemUsingLittlesLaw(
			int numberOfServers,
			double arrivalRate,
			double aht,
			double abandonsPerSecond) {
<span class="nc" id="L466">		return getAverageCallsInSystem(getStateTables(numberOfServers, arrivalRate, 1./aht, abandonsPerSecond).getStateProbabilities())</span>
				/ arrivalRate;
	}

	/**
	 * 
	 * @param numberOfServers
	 * @param arrivalRate
	 * @param aht
	 * @param abandonsPerSecond alpha, or 1/patience
	 * @return
	 */
	public double getAverageTimeInSystemUsingWaitTimes(
			int numberOfServers,
			double arrivalRate,
			double aht,
			double abandonsPerSecond) {
<span class="nc" id="L483">		StateTables stateTables = getStateTables(numberOfServers, arrivalRate, 1./aht, abandonsPerSecond);</span>
<span class="nc" id="L484">		double[] leaveRates = stateTables.getLeaveRates();</span>
<span class="nc" id="L485">		int numberOfStates = leaveRates.length;</span>
<span class="nc" id="L486">		double[] totalWaitNoAbandon = getTotalWaitsNoAbandonment(numberOfServers, abandonsPerSecond, leaveRates);</span>
<span class="nc" id="L487">		double[] abandonFromHere = getAbandonmentByState(numberOfServers, abandonsPerSecond, leaveRates);</span>
<span class="nc" id="L488">		double averageTimeInSystem = 0;</span>
<span class="nc" id="L489">		double secsToAbandonFromPreviousState = 0;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">		for (int k = 0; k &lt; numberOfStates; ++k) {</span>
			double secsToAbandonFromThisState;
<span class="nc bnc" id="L492" title="All 2 branches missed.">			if (k &lt; numberOfServers) {</span>
<span class="nc" id="L493">				secsToAbandonFromThisState = 0;</span>
			} else {
<span class="nc" id="L495">				double abandonHere = abandonsPerSecond / (abandonsPerSecond + leaveRates[k]);</span>
<span class="nc" id="L496">				double secsToAbandonHere = abandonsPerSecond / ((abandonsPerSecond + leaveRates[k]) * (abandonsPerSecond + leaveRates[k]));</span>
<span class="nc" id="L497">				double secsToStepDownIfNoAbandonHere = leaveRates[k] / ((leaveRates[k] + abandonsPerSecond) * (leaveRates[k] + abandonsPerSecond));</span>
<span class="nc" id="L498">				secsToAbandonFromThisState = ((abandonHere * secsToAbandonHere)</span>
											+ (abandonFromHere[k] - abandonHere) * (secsToStepDownIfNoAbandonHere + secsToAbandonFromPreviousState))
										   / abandonFromHere[k];
<span class="nc" id="L501">				secsToAbandonFromPreviousState = secsToAbandonFromThisState;</span>
			}
<span class="nc" id="L503">			double totalTimeInSystemThisState = abandonFromHere[k] * secsToAbandonFromThisState + (1 - abandonFromHere[k]) * (totalWaitNoAbandon[k] + aht);</span>
<span class="nc" id="L504">			averageTimeInSystem += stateTables.getStateProbabilities()[k] * totalTimeInSystemThisState;</span>
		}
<span class="nc" id="L506">		return averageTimeInSystem;</span>
	}

	/**
	 * Returns an approximation of the number of calls in the system based on the number of calls
	 * in each state k (which is exactly k) times the probability of being in that state.
	 */
	private double getAverageCallsInSystem(double[] stateProbabilities) {
<span class="nc" id="L514">		double average = 0;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		for (int k = 0; k &lt; stateProbabilities.length; ++k) {</span>
<span class="nc" id="L516">			average += stateProbabilities[k] * k;</span>
		}
<span class="nc" id="L518">		return average;</span>
	}

	/**
	 * This simply stores the leave rate and state probability tables so that they can both be
	 * returned from the same method.
	 */
	private static class StateTables {
		private final double[] m_leaveRates;
		private final double[] m_stateProbabilities;

<span class="nc" id="L529">		public StateTables(double[] leaveRates, double[] stateProbabilities) {</span>
<span class="nc" id="L530">			m_leaveRates = leaveRates;</span>
<span class="nc" id="L531">			m_stateProbabilities = stateProbabilities;</span>
<span class="nc" id="L532">		}</span>

		public double[] getLeaveRates() {
<span class="nc" id="L535">			return m_leaveRates;</span>
		}

		public double[] getStateProbabilities() {
<span class="nc" id="L539">			return m_stateProbabilities;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>