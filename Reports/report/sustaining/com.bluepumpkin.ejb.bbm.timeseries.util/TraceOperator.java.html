<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceOperator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">TraceOperator.java</span></div><h1>TraceOperator.java</h1><pre class="source lang-java linenums">/*
 * (c) 2002-2014 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import com.bluepumpkin.common.datatypes.Duration;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.timeseries.model.*;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.workload.model.Media;

import java.time.ZonedDateTime;
import java.util.*;

/**
 * This static class contains utility methods for aggregating and scaling trace
 * cube values across time, and combining and distributing trace cube values
 * across queues.
 * 
 * IMPORTANT: Time intervals and index ranges in TraceCube and related classes use
 * inclusive end bounds.  This means that if you want to access all of a trace's values
 * on January 8th, your start time should be 00:00:00 on January 8th and your
 * end time should be 23:59:59 on January 8th, NOT 00:00:00 on January 9th.
 */
public class TraceOperator {

	private static final short ACTUAL_LINE = 0;
	private static final short FORECAST_LINE = 1;
	private static final short REQUIRE_LINE = 2;

<span class="nc" id="L34">	private TraceOperator() {</span>
		// static class
<span class="nc" id="L36">	}</span>

	/**
	 * Differentiate two TraceCubes,
	 *
	 * @param TraceCube,
	 *            ActualTraceCube
	 * @param TraceCube,
	 *            either AggForecastedTraceCube or AggrRequiredTraceCube
	 * @return TraceCube, difference
	 */
	public static TraceCube diffTraceInAbs(TraceCube actualCube, TraceCube targetCube)
	throws BbmTimeSeriesException {
<span class="nc bnc" id="L49" title="All 4 branches missed.">		if (actualCube == null &amp;&amp; targetCube == null) {</span>
<span class="nc" id="L50">			return null;</span>
		}
<span class="nc" id="L52">		TraceCube diffCube = null;</span>
<span class="nc bnc" id="L53" title="All 2 branches missed.">		if (targetCube != null) {</span>
<span class="nc" id="L54">			diffCube = targetCube.cloneTraceCube();</span>
		} else {
<span class="nc" id="L56">			diffCube = actualCube.cloneTraceCube();</span>
		}
<span class="nc" id="L58">		int length = diffCube.getMaximumLength(diffCube.getTraceTypes());</span>
<span class="nc" id="L59">		short[] types = diffCube.getTraceTypes();</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		for (int k = 0; k &lt; types.length; k++) {</span>
<span class="nc bnc" id="L61" title="All 2 branches missed.">			for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="nc" id="L62">				double value = Trace.TRACENA;</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">				if (targetCube != null) {</span>
<span class="nc" id="L64">					value = targetCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc" id="L66">				double actualValue = Trace.TRACENA;</span>
<span class="nc bnc" id="L67" title="All 2 branches missed.">				if (actualCube != null) {</span>
<span class="nc" id="L68">					actualValue = actualCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc bnc" id="L70" title="All 12 branches missed.">				if ((value != Trace.TRACEOFF &amp;&amp; actualValue != Trace.TRACEOFF) &amp;&amp;</span>
						(value != Trace.TRACENA &amp;&amp; actualValue != Trace.TRACENA) &amp;&amp;
						(value != Trace.TRACEINCOMP &amp;&amp; actualValue != Trace.TRACEINCOMP)) {
<span class="nc" id="L73">					value = actualValue - value;</span>
				}
<span class="nc" id="L75">				diffCube.setTraceValue(types[k], value, pos, true);</span>
			}
		}
<span class="nc" id="L78">		return diffCube;</span>
	}

	/**
	 * Differentiate two TraceCubes,
	 *
	 * @param TraceCube,
	 *            ActualTraceCube
	 * @param TraceCube,
	 *            either AggForecastedTraceCube or AggrRequiredTraceCube
	 * @return TraceCube, difference
	 */
	public static TraceCube diffTraceInAbs(TraceCube actualCube, TraceCube targetCube, boolean nullify)
	throws BbmTimeSeriesException {
<span class="nc bnc" id="L92" title="All 2 branches missed.">		if (!nullify) {</span>
<span class="nc" id="L93">			return diffTraceInAbs(actualCube, targetCube);</span>
		}
<span class="nc bnc" id="L95" title="All 4 branches missed.">		if (actualCube == null &amp;&amp; targetCube == null) {</span>
<span class="nc" id="L96">			return null;</span>
		}
<span class="nc" id="L98">		TraceCube diffCube = null;</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">		if (targetCube != null) {</span>
<span class="nc" id="L100">			diffCube = targetCube.cloneTraceCube();</span>
		} else {
<span class="nc" id="L102">			diffCube = actualCube.cloneTraceCube();</span>
		}
<span class="nc" id="L104">		int length = diffCube.getMaximumLength(diffCube.getTraceTypes());</span>
<span class="nc" id="L105">		short[] types = diffCube.getTraceTypes();</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		for (int k = 0; k &lt; types.length; k++) {</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">			for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="nc" id="L108">				double value = Trace.TRACENA;</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">				if (targetCube != null) {</span>
<span class="nc" id="L110">					value = targetCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc" id="L112">				double actualValue = Trace.TRACENA;</span>
<span class="nc bnc" id="L113" title="All 2 branches missed.">				if (actualCube != null) {</span>
<span class="nc" id="L114">					actualValue = actualCube.getTraceValueD(types[k], pos);</span>
				}
                
<span class="nc bnc" id="L117" title="All 4 branches missed.">				if (value == Trace.TRACEOFF || actualValue == Trace.TRACEOFF) {</span>
<span class="nc" id="L118">					value = Integer.MIN_VALUE;</span>
<span class="nc bnc" id="L119" title="All 8 branches missed.">				} else if ((value != Trace.TRACENA &amp;&amp; actualValue != Trace.TRACENA) &amp;&amp;</span>
						(value != Trace.TRACEINCOMP &amp;&amp; actualValue != Trace.TRACEINCOMP)) {
<span class="nc" id="L121">					value = actualValue - value;</span>
				} else {
<span class="nc" id="L123">					value = Integer.MAX_VALUE;</span>
				}

<span class="nc" id="L126">				diffCube.setTraceValue(types[k], value, pos, true);</span>
			}
		}
<span class="nc" id="L129">		return diffCube;</span>
	}

	/**
	 * Differentiate two TraceCubes, giving result in percentage
	 *
	 * @param TraceCube,
	 *            ActualTraceCube
	 * @param TraceCube,
	 *            either AggForecastedTraceCube or AggrRequiredTraceCube
	 * @return TraceCube, difference
	 */
	public static TraceCube diffTraceInPct(TraceCube actualCube, TraceCube targetCube)
	throws BbmTimeSeriesException {
<span class="nc bnc" id="L143" title="All 4 branches missed.">		if (actualCube == null &amp;&amp; targetCube == null) {</span>
<span class="nc" id="L144">			return null;</span>
		}
<span class="nc" id="L146">		TraceCube diffCube = null;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (targetCube != null) {</span>
<span class="nc" id="L148">			diffCube = targetCube.cloneTraceCube();</span>
		} else {
<span class="nc" id="L150">			diffCube = actualCube.cloneTraceCube();</span>
		}
<span class="nc" id="L152">		int length = diffCube.getMaximumLength(diffCube.getTraceTypes());</span>
<span class="nc" id="L153">		short[] types = diffCube.getTraceTypes();</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">		for (int k = 0; k &lt; types.length; k++) {</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">			for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="nc" id="L156">				double value = 0;</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">				if (targetCube != null) {</span>
<span class="nc" id="L158">					value = targetCube.getTraceValueD(types[k], pos);</span>
<span class="nc bnc" id="L159" title="All 4 branches missed.">					if ((value == Trace.TRACENA) || (value == Trace.TRACEINCOMP)) {</span>
<span class="nc" id="L160">						value = 0;</span>
					}
				}
<span class="nc" id="L163">				double actualValue = 0;</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">				if (actualCube != null) {</span>
<span class="nc" id="L165">					actualValue = actualCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc bnc" id="L167" title="All 4 branches missed.">				if (value != Trace.TRACEOFF &amp;&amp; actualValue != Trace.TRACEOFF) {</span>
<span class="nc bnc" id="L168" title="All 4 branches missed.">					if ((actualValue == Trace.TRACENA) ||(actualValue == Trace.TRACEINCOMP)) {</span>
						// we want to put -1
<span class="nc" id="L170">						value = Trace.TRACENA;</span>
					} else {
<span class="nc" id="L172">						actualValue = actualValue - value;</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">						if (value != 0) {</span>
<span class="nc" id="L174">							value = TraceUtil.roundDouble((double) actualValue * 100 / value);</span>
						} else {
							//CHANGED FROM TRACEUNB TO TRACENA. TRACEUNB is removed
<span class="nc" id="L177">							value = Trace.TRACENA;</span>
						}
					}
				}
<span class="nc" id="L181">				diffCube.setTraceValue(types[k], value, pos, true);</span>
			}
		}
<span class="nc" id="L184">		return diffCube;</span>
	}

	/**
	 * Differentiate two TraceCubes, giving result in percentage
	 *
	 * @param TraceCube,
	 *            ActualTraceCube
	 * @param TraceCube,
	 *            either AggForecastedTraceCube or AggrRequiredTraceCube
	 * @param nullify
	 * @return TraceCube, difference
	 */
	public static TraceCube diffTraceInPct(TraceCube actualCube, TraceCube targetCube, boolean nullify)
		throws BbmTimeSeriesException {
<span class="nc bnc" id="L199" title="All 2 branches missed.">		if (!nullify) {</span>
<span class="nc" id="L200">			return diffTraceInPct(actualCube, targetCube);</span>
		}
<span class="nc bnc" id="L202" title="All 4 branches missed.">		if (actualCube == null &amp;&amp; targetCube == null) {</span>
<span class="nc" id="L203">			return null;</span>
		}
<span class="nc" id="L205">		TraceCube diffCube = null;</span>
<span class="nc bnc" id="L206" title="All 2 branches missed.">		if (targetCube != null) {</span>
<span class="nc" id="L207">			diffCube = targetCube.cloneTraceCube();</span>
		} else {
<span class="nc" id="L209">			diffCube = actualCube.cloneTraceCube();</span>
		}
<span class="nc" id="L211">		int length = diffCube.getMaximumLength(diffCube.getTraceTypes());</span>
<span class="nc" id="L212">		short[] types = diffCube.getTraceTypes();</span>
<span class="nc bnc" id="L213" title="All 2 branches missed.">		for (int k = 0; k &lt; types.length; k++) {</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">			for (int pos = 0; pos &lt; length; pos++) {</span>
<span class="nc" id="L215">				double value = Trace.TRACENA;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">				if (targetCube != null) {</span>
<span class="nc" id="L217">					value = targetCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc" id="L219">				double actualValue = Trace.TRACENA;</span>
<span class="nc bnc" id="L220" title="All 2 branches missed.">				if (actualCube != null) {</span>
<span class="nc" id="L221">					actualValue = actualCube.getTraceValueD(types[k], pos);</span>
				}
<span class="nc bnc" id="L223" title="All 4 branches missed.">				if (value != Trace.TRACEOFF &amp;&amp; actualValue != Trace.TRACEOFF) {</span>
<span class="nc bnc" id="L224" title="All 8 branches missed.">					if (actualValue == Trace.TRACENA || value == Trace.TRACENA ||</span>
							actualValue == Trace.TRACEINCOMP || value == Trace.TRACEINCOMP) {
<span class="nc" id="L226">						value = Integer.MAX_VALUE;</span>
					} else {
<span class="nc" id="L228">						actualValue = actualValue - value;</span>
<span class="nc bnc" id="L229" title="All 2 branches missed.">						if (value != 0) {</span>
<span class="nc" id="L230">							value = TraceUtil.roundDouble((double) actualValue * 100 / value);</span>
						} else {
<span class="nc" id="L232">							value = Integer.MAX_VALUE;</span>
						}
					}
				} else {
<span class="nc" id="L236">					value = Integer.MIN_VALUE;</span>
				}
<span class="nc" id="L238">				diffCube.setTraceValue(types[k], value, pos, true);</span>
			}
		}
<span class="nc" id="L241">		return diffCube;</span>
	}

	// Check if value array is all NA or not
	private static boolean allNAPoints(double[] value) {
<span class="nc bnc" id="L246" title="All 2 branches missed.">		for (int i = value.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L247" title="All 4 branches missed.">			if (!(value[i] == Trace.TRACENA || value[i] == Trace.TRACEINCOMP)){</span>
<span class="nc" id="L248">				return false;</span>
			}
		}
<span class="nc" id="L251">		return true;</span>
	}
	// Check if value array is all NA or not
	private static boolean allOFFPoints(double[] value) {
<span class="nc bnc" id="L255" title="All 2 branches missed.">		for (int i = value.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (value[i] != Trace.TRACEOFF) {</span>
<span class="nc" id="L257">				return false;</span>
			}
		}
<span class="nc" id="L260">		return true;</span>
	}

	// Check if value array has at least one valid (non-negative) value.
	private static boolean hasValidValue(double[] values) {
<span class="nc bnc" id="L265" title="All 2 branches missed.">		for (int i = values.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">			if (Trace.isValidValue(values[i])){</span>
<span class="nc" id="L267">				return true;</span>
			}
		}
<span class="nc" id="L270">		return false;</span>
	}

	/**
	 * Scales the specified time interval in the trace cube
	 * to equal the specified value.  The inverse of aggregatePeriod().
	 * The range modified includes the start time and the end time.
	 * &lt;p&gt;
	 * If the end time is before the start time the trace cube will not be modified.
	 * &lt;p&gt;
	 * If there are no valid data points in the specified trace, no action is taken
	 * and no exception is thrown.
	 * 
	 * @param cube
	 * @param traceType
	 * @param targetValue
	 * @param startTime
	 * @param endTime
	 * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;startTime&lt;/code&gt; or &lt;code&gt;endTime&lt;/code&gt;
	 * falls outside the time period covered by the trace cube.
	 */
	public static void scalePeriodTrace(
			TraceCube cube,
			short traceType,
			int targetValue,
			Date startTime,
			Date endTime) {

<span class="nc" id="L298">		int startIndex = TraceUtil.gapOffSet(cube.getStartDate(), cube.getStartOffSet(), startTime);</span>
<span class="nc" id="L299">		int endIndex = TraceUtil.gapOffSet(cube.getStartDate(), cube.getStartOffSet(), endTime);</span>
		// If the specified range is empty, return without modifying the cube.
<span class="nc bnc" id="L301" title="All 2 branches missed.">		if (endIndex &lt; startIndex) {</span>
<span class="nc" id="L302">			return;</span>
		}
<span class="nc" id="L304">		scalePeriodTrace(cube, traceType, targetValue, startIndex, endIndex);</span>
<span class="nc" id="L305">	}</span>

	/**
	 * Scales the specified range of indices in the trace cube
	 * to equal the specified value.  The inverse of aggregatePeriod().
	 * The range modified includes the start index and the end index.
	 * &lt;p&gt;
	 * If the end index is before the start index the trace cube will not be modified.
	 * &lt;p&gt;
	 * If there are no valid data points in the specified trace, no action is taken
	 * and no exception is thrown.
	 * 
	 * @param cube
	 * @param traceType
	 * @param targetValue
	 * @param startIndex
	 * @param endIndex
	 * @throws ArrayIndexOutOfBoundsException if &lt;code&gt;startTime&lt;/code&gt; or &lt;code&gt;endTime&lt;/code&gt;
	 * falls outside the time period covered by the trace cube.
	 */
	private static void scalePeriodTrace(
			TraceCube cube,
			short traceType,
			int targetValue,
			int startIndex,
			int endIndex) {
<span class="nc" id="L331">		TraceDistribution distribution = getTraceDistribution(cube, traceType, startIndex, endIndex);</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">		if (distribution.isValid()) {</span>
<span class="nc" id="L333">			scalePeriodTraceWithDistribution(cube, traceType, targetValue, distribution, startIndex, endIndex);</span>
		}
<span class="nc" id="L335">	}</span>

	/**
	 * Scales a particular interval of a trace so that its aggregate value is the specified
	 * target value, using the supplied distribution.
	 * &lt;p&gt;
	 * If the distribution is invalid, no action is taken and no exception is thrown.
	 * 
	 * @param cube
	 * @param traceType
	 * @param targetValue
	 * @param distribution
	 * @param startIndex
	 * @param endIndex
	 */
	public static void scalePeriodTraceWithDistribution(
			TraceCube cube,
			short traceType,
			int targetValue,
			TraceDistribution distribution,
			int startIndex,
			int endIndex) {

<span class="nc bnc" id="L358" title="All 2 branches missed.">		if (distribution.isValid()) {</span>
			/*TODO: the TraceOperator.aggregatePeriod has the following snippet of code in it:
			 &lt;code&gt;
					if (traceType == Trace.FTE || traceType == Trace.STAFFING) {
						return result / (valueArray.length &gt; Trace.HOURPOINTS ? Trace.HOURPOINTS : valueArray.length);
					}
			 &lt;/code&gt;
			 It seems as though when we are aggregating FTE or Staffing data for display purposes,
			 the data is divided by 4 since for these data types since we want to show hourly staffing (the 15 minute
			 intervals would be summed up and then divided by 4 to get the hourly staffing).
			 
			 This was causing a problem here in the scalePeriodTraceWithDistribution method, because the hourly staffing 
			 was getting distributed to the fifteen minute intervals without taking the previously mentioned
			 code into account.  The net result of this was that the values getting distributed to the 15 minute
			 intervals were about 4 times smaller than they should be.  The code below was inserted to correct this
			 problem.  A proper long term solution would be to remove display logic from these methods entirely.
			 */
			//BEGIN FIX for FTE and STAFFING types
<span class="nc" id="L376">			int scaledTargetValue = targetValue;</span>
<span class="nc bnc" id="L377" title="All 10 branches missed.">			if (Trace.isValidValue(targetValue) &amp;&amp;</span>
			        (traceType == Trace.FTE || traceType == Trace.STAFFING || traceType == Trace.AFTE ||
							traceType == Trace.ASTAFFING)) {

<span class="nc" id="L381">				int intervalCount = (endIndex - startIndex) + 1;</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">				scaledTargetValue = targetValue * (intervalCount &gt; Trace.HOURPOINTS ? Trace.HOURPOINTS : intervalCount);</span>
			}
			//END FIX for FTE and STAFFING types
<span class="nc" id="L385">			int[] scaledValues = distribution.getScaledIntegerValues(scaledTargetValue);</span>
<span class="nc bnc" id="L386" title="All 2 branches missed.">			for (int i = 0; i &lt; scaledValues.length; ++i) {</span>
<span class="nc" id="L387">				cube.setTraceValue(traceType, scaledValues[i], startIndex + i, true);</span>
			}
		}
<span class="nc" id="L390">	}</span>

	/**
	 * Determines the weights characterizing the distribution of a trace across a 
	 * range of indices.  These weights can be used when scaling or distributing
	 * a value.
	 * 
	 * @param cube
	 * @param traceType
	 * @param startIndex
	 * @param endIndex
	 * @return a &lt;code&gt;TraceDistribution&lt;/code&gt; object that can be used for scaling or distribution,
	 * or Trace.INVALID_DISTRIBUTION if the distribution could not be calculated for any reason.
	 */
	public static TraceDistribution getTraceDistribution(TraceCube cube, short traceType, int startIndex, int endIndex) {
<span class="nc" id="L405">		return getTraceDistribution( cube,  traceType,  startIndex,  endIndex,Trace.getTraceConstraints(traceType, cube.isRequiredData())); </span>
	}
	
	/**
	 * Overloaded version of the original method getTraceDistribution(TraceCube cube, short traceType, int startIndex, int endIndex) 
	 * if the caller has the constraints available with they can be passed directly to get the TraceDisribution
	 * 
	 * @param cube
	 * @param traceType
	 * @param startIndex
	 * @param endIndex
	 * @param constraints 
	 * @return a &lt;code&gt;TraceDistribution&lt;/code&gt; object that can be used for scaling or distribution,
	 * or Trace.INVALID_DISTRIBUTION if the distribution could not be calculated for any reason.
	 */
	public static TraceDistribution getTraceDistribution(TraceCube cube, short traceType, int startIndex, int endIndex,
														 DataValueConstraints constraints) {
		
<span class="nc" id="L423">		AggregationType aggregationType = getAggregationTypeForTimeAggregation(traceType, cube.isRequiredData());</span>
<span class="nc bnc" id="L424" title="All 2 branches missed.">		if ( ! aggregationType.supportsScale() ) {</span>
<span class="nc" id="L425">			return TraceDistribution.INVALID_DISTRIBUTION;</span>
		}
<span class="nc" id="L427">		double[] sourceValues = cube.getTraceValueD(traceType, startIndex, endIndex);</span>
<span class="nc bnc" id="L428" title="All 4 branches missed.">		if (sourceValues == null || !hasValidValue(sourceValues)) {</span>
<span class="nc" id="L429">			return TraceDistribution.INVALID_DISTRIBUTION;</span>
		}
<span class="nc" id="L431">		double[][] dependentValueArrays = null;</span>
<span class="nc" id="L432">		short[] dependentTypeArray = null;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">		if (aggregationType.isWeightedAverage()) {</span>
			//TODO: replace this with actual call to get media map -OR- devise a better way to obtain
			// dependent values.
<span class="nc" id="L436">			dependentTypeArray = getDependentTypeForWeightedAvgForPeriod(traceType, null);</span>
<span class="nc" id="L437">			dependentValueArrays = new double[dependentTypeArray.length][sourceValues.length];</span>
<span class="nc bnc" id="L438" title="All 2 branches missed.">			for (int j = 0; j &lt; dependentTypeArray.length; j++) {</span>
<span class="nc" id="L439">				dependentValueArrays[j] = cube.getTraceValueD(dependentTypeArray[j], startIndex, endIndex);</span>
			}
		}
<span class="nc" id="L442">		return getArrayDistribution(sourceValues, dependentValueArrays, aggregationType,</span>
<span class="nc" id="L443">				Trace.getTraceConstraints(traceType, cube.isRequiredData()));</span>
	}

	/**
	 * Blindly duplicates the target value into the specified range of indices of the specified
	 * trace, from &lt;code&gt;startTime&lt;/code&gt; to &lt;code&gt;endTime&lt;/code&gt;, inclusive.
	 * &lt;p&gt;
	 * This method is most appropriate for replicating error values.  It will overwrite any
	 * previous values, including error values.
	 * 
	 * @param cube
	 * @param traceType
	 * @param value
	 * @param startTime
	 * @param endTime
	 */
	public static void setTraceToValueForPeriod(TraceCube cube, short traceType, int value, Date startTime, Date endTime) {
<span class="nc" id="L460">		int startIndex = TraceUtil.gapOffSet(cube.getStartDate(), cube.getStartOffSet(), startTime);</span>
<span class="nc" id="L461">		int endIndex = TraceUtil.gapOffSet(cube.getStartDate(), cube.getStartOffSet(), endTime);</span>
		// If the specified range is empty, return without modifying the cube.
<span class="nc bnc" id="L463" title="All 2 branches missed.">		if (endIndex &lt; startIndex) {</span>
<span class="nc" id="L464">			return;</span>
		}
<span class="nc bnc" id="L466" title="All 2 branches missed.">		for (int offset = startIndex; offset &lt;= endIndex; ++offset) {</span>
<span class="nc" id="L467">			cube.setTraceValue(traceType, value, offset, true);</span>
		}
<span class="nc" id="L469">	}</span>

	/**
	 * The inverse of combineQueue().  Distributes the contents of the specified trace
	 * cube across an array of constituent trace cubes at each data offset in a time interval.
	 * 
	 * @param combinedCube contains the target combined values that are to be distributed
	 * across &lt;code&gt;constituentCubes&lt;/code&gt;.
	 * @param constituentCubes the constituent cubes that are to be populated with the
	 * distributed values.
	 * @param queueMediaMap
	 * @throws BbmTimeSeriesException
	 */
	public static void distributeQueue(TraceCube combinedCube, TraceCube[] constituentCubes, short traceType,
									   Date startTime, Date endTime, Map&lt;ID,ID&gt; queueMediaMap)
			throws BbmTimeSeriesException {

<span class="nc" id="L486">		int startIndex = TraceUtil.gapOffSet(combinedCube.getStartDate(), combinedCube.getStartOffSet(), startTime);</span>
<span class="nc" id="L487">		int endIndex = TraceUtil.gapOffSet(combinedCube.getStartDate(), combinedCube.getStartOffSet(), endTime);</span>
		// If the specified range is empty, return without modifying the cube.
<span class="nc bnc" id="L489" title="All 2 branches missed.">		if (endIndex &lt; startIndex) {</span>
<span class="nc" id="L490">			return;</span>
		}
<span class="nc" id="L492">		distributeQueue(combinedCube, constituentCubes, traceType, startIndex, endIndex, queueMediaMap);</span>
<span class="nc" id="L493">	}</span>

	/**
	 * The inverse of combineQueue().  Distributes the contents of the specified trace
	 * cube and type across an array of constituent trace cubes at each data offset in a range of
	 * offsets.
	 * 
	 * @param combinedCube contains the target combined values that are to be distributed
	 * across &lt;code&gt;constituentCubes&lt;/code&gt;.
	 * @param constituentCubes the constituent cubes that are to be populated with the
	 * distributed values.
	 * @param queueMediaMap
	 * @throws BbmTimeSeriesException if the specified trace cubes differ in length or
	 * supported trace types.  Note that two trace cubes must list the same trace types
	 * &lt;em&gt;in the same order&lt;/em&gt; to count as supporting the same trace types.  This
	 * should not be a problem normally but is something to keep in mind when defining
	 * a new trace cube type.
	 */
	public static void distributeQueue(TraceCube combinedCube, TraceCube[] constituentCubes, short traceType,
									   int startIndex, int endIndex, Map&lt;ID,ID&gt; queueMediaMap)
			throws BbmTimeSeriesException {

		// Ensure that all trace cubes are compatible and at least one is non-null.
<span class="nc" id="L516">		TraceCube tc = TraceUtil.validateTraceCubes(constituentCubes);</span>
<span class="nc bnc" id="L517" title="All 2 branches missed.">		if (tc == null) {</span>
<span class="nc" id="L518">			return;</span>
		}
<span class="nc" id="L520">		short[] types = tc.getTraceTypes();</span>
		// special handle AggrRequireTraceCube
<span class="nc bnc" id="L522" title="All 2 branches missed.">		if (tc instanceof AggrRequiredTraceCube) {</span>
<span class="nc bnc" id="L523" title="All 2 branches missed.">			if (((AggrRequiredTraceCube) tc).getForecastTrace() != null) {</span>
				// Add CV &amp; VAR in addition to existing types
<span class="nc" id="L525">				short[] nTypes = new short[types.length + 2];</span>
<span class="nc" id="L526">				nTypes[0] = Trace.CV;</span>
<span class="nc" id="L527">				nTypes[1] = Trace.VAR;</span>
<span class="nc" id="L528">				System.arraycopy(types, 0, nTypes, 2, types.length);</span>
<span class="nc" id="L529">				types = nTypes;</span>
			}
		}
<span class="nc bnc" id="L532" title="All 2 branches missed.">		if (tc.getMaximumLength(types) &lt; startIndex) {</span>
			// No point in trying to distribute outside the range of the traces.
<span class="nc" id="L534">			return;</span>
		}
		// Check if combine operation required types exist or not
<span class="nc" id="L537">		HashSet&lt;ID&gt; mediaSet = new HashSet&lt;ID&gt;(queueMediaMap.values());</span>
<span class="nc bnc" id="L538" title="All 2 branches missed.">		boolean isMultiMedia = mediaSet.size() != 1;</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">		if (isMultiMedia || isTraceTypeSupportedForMedia(traceType, (ID) mediaSet.toArray()[0])) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">			if (getAggregationTypeForTimeAggregation(traceType, combinedCube.isRequiredData()) == AggregationType.SUM) {</span>
<span class="nc" id="L541">				TraceDistributionBuilder distributionBuilder =</span>
<span class="nc" id="L542">						new TraceDistributionBuilder(AggregationType.SUM, Trace.getTraceConstraints(traceType,</span>
<span class="nc" id="L543">								combinedCube.isRequiredData()));</span>
<span class="nc" id="L544">				int totalAggregate = 0;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">				for (int cubeIndex = 0; cubeIndex &lt; constituentCubes.length; ++cubeIndex) {</span>
<span class="nc" id="L546">					int cubeAggregate = TraceUtil.roundDouble(aggregatePeriod(constituentCubes[cubeIndex], traceType,</span>
							startIndex, endIndex));
<span class="nc" id="L548">					distributionBuilder.addValue(cubeAggregate, null, cubeIndex);</span>
<span class="nc" id="L549">					totalAggregate += cubeAggregate;</span>
				}
<span class="nc bnc" id="L551" title="All 2 branches missed.">				if (totalAggregate == 0) {</span>
					// When starting from zero data we use a specialized algorithm.
<span class="nc" id="L553">					distributeQueueForSumsWithNoPreviousData(</span>
							combinedCube,
							constituentCubes,
<span class="nc" id="L556">							distributionBuilder.getTraceDistribution(),</span>
							traceType,
							startIndex,
							endIndex);
					// For summed constituent cubes with no prior data we return immediately.
					// All other cases fall through to the more general algorithm.
<span class="nc" id="L562">					return;</span>
				}
			}
<span class="nc bnc" id="L565" title="All 2 branches missed.">			for (int j = startIndex; j &lt;= endIndex; j++) {</span>
<span class="nc" id="L566">				int targetValue = combinedCube.getTraceValue(traceType, j);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">				if (targetValue &gt;= 0) {</span>
<span class="nc" id="L568">					TraceDistribution distribution = getMultiQueueDistribution(constituentCubes, traceType, j);</span>
<span class="nc" id="L569">					distributeQueueFromDistribution(constituentCubes, traceType, j, distribution, targetValue);</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">				} else if (targetValue != Trace.TRACENA) {</span>
					// TRACENA would arise from a weighted value with zero weights
					// and then get redistributed to the constituent queues,
					// overwriting zeros with TRACENA.
<span class="nc" id="L574">					setTraceValueAcrossCubes(constituentCubes, traceType, j, targetValue);</span>
				}
			}
		}
<span class="nc" id="L578">	}</span>

	/**
	 * Distributes the contents of the specified trace cube and type, whose aggregation type must
	 * be summation, across an array of constituent trace cubes at each data offset in a
	 * range of offsets.  The constituent trace cubes are assumed to have no non-zero data
	 * to begin with.
	 * &lt;p&gt;
	 * To distribute a queue across constituent queues that already have data, use
	 * {@link #distributeQueue(TraceCube, TraceCube[], short, int, int, HashMap)}.
	 * 
	 * @param combinedCube a cube containing target values for each time interval
	 * @param constituentCubes
	 * @param traceType the trace type to distribute, which must aggregate using summation
	 * @param startIndex
	 * @param endIndex
	 * 
	 * @throws IllegalArgumentException if {@code traceType}'s aggregation type is anything other
	 * than {@link AggregationType#SUM}.
	 * @throws BbmTimeSeriesException if protective copying of the combined cube fails.
	 */
	private static void distributeQueueForSumsWithNoPreviousData(
			TraceCube combinedCube,
			TraceCube[] constituentCubes,
			TraceDistribution distributionAcrossCubes,
			short traceType,
			int startIndex,
			int endIndex)
				throws BbmTimeSeriesException {
<span class="nc bnc" id="L607" title="All 2 branches missed.">		if (getAggregationTypeForTimeAggregation(traceType, combinedCube.isRequiredData()) != AggregationType.SUM) {</span>
<span class="nc" id="L608">			throw new IllegalArgumentException(&quot;distributeQueueForSums may only be used on trace types that use summation. &quot;</span>
<span class="nc" id="L609">					+ &quot; Tried to use on aggregation type &quot; + getAggregationTypeForTimeAggregation(traceType,</span>
<span class="nc" id="L610">					combinedCube.isRequiredData()));</span>
		}
<span class="nc" id="L612">		TraceCube combinedCopy = combinedCube.cloneTraceCube();</span>
<span class="nc" id="L613">		combinedCopy.setTraceValue(traceType, combinedCube.getTraceValueD(traceType));</span>
		// Here we take the grand total of the new values in the combined queue and divide them between
		// the constituent queues according to their original relative totals.
<span class="nc" id="L616">		int targetAggregate = TraceUtil.roundDouble(aggregatePeriod(combinedCube, traceType, startIndex, endIndex));</span>
<span class="nc" id="L617">		int[] cubeTargets = distributionAcrossCubes.getScaledIntegerValues(targetAggregate);</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">		for (int cubeIndex = 0; cubeIndex &lt; constituentCubes.length; ++cubeIndex) {</span>
			// When distributing a combined queue from zero, we use the combined queue itself
			// to determine the shape of the resulting curve in each constituent trace.
<span class="nc" id="L621">			TraceDistribution distribution = getTraceDistribution(combinedCopy, traceType, startIndex, endIndex);</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">			if (distribution.isValid()) {</span>
				// We apply the shape of the combined queue to the value alloted to this constituent queue...
<span class="nc" id="L624">				scalePeriodTraceWithDistribution(constituentCubes[cubeIndex], traceType, cubeTargets[cubeIndex],</span>
						distribution, startIndex, endIndex);
				// ...then we subtract the result from the combined queue so that subsequent queues will fill
				// in the gaps in coverage that we left.
<span class="nc" id="L628">				subtractTrace(combinedCopy, constituentCubes[cubeIndex], traceType, startIndex, endIndex);</span>
			}
		}
<span class="nc" id="L631">	}</span>

	/**
	 * Subtracts one trace from another trace.  Each trace value of the specified type in
	 * {@code cubeToSubtract} is subtracted from the corresponding trace value in
	 * {@code totalCube}, and the result is stored in {@code totalCube}.
	 * 
	 * @param totalCube
	 * @param cubeToSubtract
	 * @param traceType
	 * @param startIndex
	 * @param endIndex
	 */
	private static void subtractTrace(
			TraceCube totalCube,
			TraceCube cubeToSubtract,
			short traceType,
			int startIndex,
			int endIndex) {
<span class="nc" id="L650">		subtractTrace(totalCube, cubeToSubtract, traceType, startIndex, endIndex, startIndex);</span>
<span class="nc" id="L651">	}</span>

	/**
	 * Subtracts one trace from another trace, where the cube to subtract may have a different
	 * start offset from the total cube.  Each trace value of the specified type in
	 * {@code cubeToSubtract} is subtracted from the corresponding trace value in
	 * {@code totalCube}, and the result is stored in {@code totalCube}.
	 * &lt;p&gt;
	 * Any intervals for which either cube has an invalid value (Trace.TRACENA, etc.) are
	 * skipped and the resulting value for that interval is the same as the original
	 * value for that interval.
	 * 
	 * @param totalCube
	 * @param cubeToSubtract
	 * @param traceType
	 * @param startOffset
	 * @param endOffset
	 * @param cubeToSubtractStartOffset
	 */
	private static void subtractTrace(
			TraceCube totalCube,
			TraceCube cubeToSubtract,
			short traceType,
			int startOffset,
			int endOffset,
			int cubeToSubtractStartOffset) {
<span class="nc bnc" id="L677" title="All 2 branches missed.">		for (int offsetIntoTotal = startOffset; offsetIntoTotal &lt;= endOffset; ++offsetIntoTotal) {</span>
<span class="nc" id="L678">			double totalValue = totalCube.getTraceValueD(traceType, offsetIntoTotal);</span>
<span class="nc" id="L679">			double valueToSubtract = cubeToSubtract.getTraceValueD(traceType, offsetIntoTotal - startOffset + cubeToSubtractStartOffset);</span>
<span class="nc bnc" id="L680" title="All 4 branches missed.">			if (Trace.isValidValue(totalValue) &amp;&amp; Trace.isValidValue(valueToSubtract)) {</span>
<span class="nc" id="L681">				totalCube.setTraceValue(traceType, totalValue - valueToSubtract, offsetIntoTotal, true);</span>
			}
		}
<span class="nc" id="L684">	}</span>

	/**
	 * Distributes the contents of the specified trace cube across the specified array
	 * of constituent trace cubes using a precomputed value distribution.
	 * &lt;p&gt;
	 * If the supplied distribution is invalid, no action is taken and no exception is
	 * thrown.
	 * 
	 * @param targetCubes
	 * @param traceType
	 * @param offset
	 * @param distribution
	 * @param targetValue
	 */
	private static void distributeQueueFromDistribution(TraceCube[] targetCubes, short traceType, int offset, TraceDistribution distribution, int targetValue) {
<span class="nc bnc" id="L700" title="All 2 branches missed.">		if (distribution.isValid()) {</span>
<span class="nc" id="L701">			int[] distributedValues = distribution.getScaledIntegerValues(targetValue);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">			for (int cubeIndex = 0; cubeIndex &lt; targetCubes.length; ++cubeIndex) {</span>
<span class="nc" id="L703">				targetCubes[cubeIndex].setTraceValue(traceType, distributedValues[cubeIndex], offset, true);</span>
			}
		}
<span class="nc" id="L706">	}</span>

	/**
	 * Blindly duplicates the target value into the specified index of the specified traces.
	 * &lt;p&gt;
	 * This method is most appropriate for replicating error values.  It will overwrite any
	 * previous values, including error values.
	 * 
	 * @param targetCubes
	 * @param traceType
	 * @param offset
	 * @param targetValue
	 */
	private static void setTraceValueAcrossCubes(TraceCube[] targetCubes, short traceType, int offset, int targetValue) {
<span class="nc bnc" id="L720" title="All 2 branches missed.">		for (int cubeIndex = 0; cubeIndex &lt; targetCubes.length; ++cubeIndex) {</span>
<span class="nc" id="L721">			targetCubes[cubeIndex].setTraceValue(traceType, targetValue, offset, true);</span>
		}
<span class="nc" id="L723">	}</span>

	/**
	 * Determines the weights characterizing the distribution of the value of a particular
	 * trace at a particular time across a collection of different trace cubes.  These
	 * weights can be used when scaling or distributing a value.
	 * 
	 * @param cubes
	 * @param traceType
	 * @param startIndex
	 * @param endIndex
	 * @return a &lt;code&gt;TraceDistribution&lt;/code&gt; object that can be used for scaling or distribution,
	 * or Trace.INVALID_DISTRIBUTION if the distribution could not be calculated for any reason.
	 */
	public static TraceDistribution getMultiQueueDistribution(TraceCube[] cubes, short traceType, int offset) {

<span class="nc" id="L739">		AggregationType aggregationType = getAggregationTypeForTimeAggregation(traceType, cubes[0].isRequiredData());</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">		if ( ! aggregationType.supportsScale() ) {</span>
<span class="nc" id="L741">			return TraceDistribution.INVALID_DISTRIBUTION;</span>
		}
<span class="nc" id="L743">		double[] sourceValues = new double[cubes.length];</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">		for (int cubeIndex = 0; cubeIndex &lt; cubes.length; ++cubeIndex) {</span>
<span class="nc" id="L745">			sourceValues[cubeIndex] = cubes[cubeIndex].getTraceValueD(traceType, offset);</span>
		}
<span class="nc bnc" id="L747" title="All 2 branches missed.">		if (!hasValidValue(sourceValues)) {</span>
<span class="nc" id="L748">			return TraceDistribution.INVALID_DISTRIBUTION;</span>
		}
<span class="nc" id="L750">		double[][] dependentValueArrays = null;</span>
<span class="nc" id="L751">		short[] dependentTypeArray = null;</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">		if (aggregationType.isWeightedAverage()) {</span>
			//TODO: replace this with actual call to get media map -OR- devise a better way to obtain
			// dependent values.
			// Media type does not appear to be necessary for correct behavior; it would
			// be more efficient to have the correct media type but using null just gets
			// us an extra dependent type for AHT that doesn't have any data, and unpopulated 
			// dependent values will simply be ignored.
<span class="nc" id="L759">			dependentTypeArray = getDependentTypeForWeightedAvgForPeriod(traceType, null);</span>
<span class="nc" id="L760">			dependentValueArrays = new double[dependentTypeArray.length][sourceValues.length];</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">			for (int dependentTypeIndex = 0; dependentTypeIndex &lt; dependentTypeArray.length; dependentTypeIndex++) {</span>
<span class="nc" id="L762">				dependentValueArrays[dependentTypeIndex] = new double[cubes.length];</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">				for (int cubeIndex = 0; cubeIndex &lt; cubes.length; ++cubeIndex) {</span>
<span class="nc" id="L764">					dependentValueArrays[dependentTypeIndex][cubeIndex] = cubes[cubeIndex].getTraceValueD(dependentTypeArray[dependentTypeIndex], offset);</span>
				}
			}
		}
<span class="nc" id="L768">		return getArrayDistribution(sourceValues, dependentValueArrays, aggregationType,</span>
<span class="nc" id="L769">				Trace.getTraceConstraints(traceType, cubes[0].isRequiredData()));</span>
	}

	/**
	 * Determines the weights characterizing the distribution of an array across its
	 * entire length.  These weights can be used when scaling or distributing
	 * a value.
	 * 
	 * @param sourceValues
	 * @param dependentValueArrays
	 * @param aggregationType
	 * @return a &lt;code&gt;TraceDistribution&lt;/code&gt; object that can be used for scaling or distribution,
	 * or Trace.INVALID_DISTRIBUTION if the distribution could not be calculated for any reason.
	 */
	private static TraceDistribution getArrayDistribution(double[] sourceValues, double[][] dependentValueArrays,
											  AggregationType aggregationType, DataValueConstraints constraints) {

<span class="nc" id="L786">		TraceDistributionBuilder builder = new TraceDistributionBuilder(aggregationType, constraints);</span>
<span class="nc" id="L787">		int sourceValueCount = sourceValues.length;</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">		for (int i = 0; i &lt; sourceValueCount; i++) {</span>
<span class="nc" id="L789">			double traceValue = sourceValues[i];</span>
<span class="nc" id="L790">			builder.addValue(traceValue, dependentValueArrays, i);</span>
		}
<span class="nc" id="L792">		return builder.getTraceDistribution();</span>
	}

	/**
	 * Return everything stored in TraceCube for specific TraceTypes, agg on 30
	 * minutes
	 *
	 * @param TraceCube,
	 *            cube
	 * @param TimeZone,
	 *            tz
	 * @param short,
	 *            type
	 * @param return
	 *            int[]
	 */
	public static double[] getHalfHourlyTraceValue(TraceCube cube, TimeZone tz,
			short type, ID mediaID, int lineType) {
<span class="nc" id="L810">		double[] value = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L812">			return null;</span>
		}
<span class="nc" id="L814">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L815" title="All 4 branches missed.">		if (start == null || tz == null) {</span>
<span class="nc" id="L816">			return null;</span>
		}
<span class="nc" id="L818">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L819">		cal.setTime(start);</span>
<span class="nc" id="L820">		int startMin = cal.get(Calendar.MINUTE);</span>
		// Get the absolute position
<span class="nc" id="L822">		int pos = startMin / 15;</span>
		// Need figure out how many half hours
<span class="nc" id="L824">		int totalLength = value.length;</span>
<span class="nc" id="L825">		int begin = 0;</span>
		// If pos is odd, which means the first half hour, it has only one point
<span class="nc" id="L827">		int end = 1 - pos % 2;</span>
<span class="nc bnc" id="L828" title="All 2 branches missed.">		int chunks = 1 + (totalLength - end - 1) / 2</span>
		+ ((totalLength - end - 1) % 2 == 0 ? 0 : 1);
		// Cal based on each half hour
<span class="nc" id="L831">		double[] result = new double[chunks];</span>
<span class="nc bnc" id="L832" title="All 2 branches missed.">		for (int i = 0; i &lt; chunks; i++) {</span>
<span class="nc" id="L833">			result[i] = TraceUtil.roundDouble(aggregatePeriod(cube, type,</span>
					begin, end, mediaID, lineType));
<span class="nc" id="L835">			begin = end + 1;</span>
<span class="nc bnc" id="L836" title="All 2 branches missed.">			if (begin &gt;= totalLength) {</span>
<span class="nc" id="L837">				break;</span>
			}
<span class="nc" id="L839">			end += 2;</span>
<span class="nc bnc" id="L840" title="All 2 branches missed.">			end = end &gt;= totalLength ? (totalLength - 1) : end;</span>
		}
<span class="nc" id="L842">		return result;</span>
	}

	/**
	 * Return everything stored in TraceCube for specific TraceTypes, agg on 30
	 * minutes
	 *
	 * @param TraceCube,
	 *            cube
	 * @param TimeZone,
	 *            tz
	 * @param short[],
	 *            types
	 * @param return
	 *            int[][]
	 */
	public static double[][] getHalfHourlyTraceValue(TraceCube cube, TimeZone tz,
			short[] types, ID mediaID, int lineType) {
<span class="nc bnc" id="L860" title="All 2 branches missed.">		if (types == null) {</span>
<span class="nc" id="L861">			return null;</span>
		}
<span class="nc" id="L863">		double[][] result = new double[types.length][];</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">		for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc" id="L865">			result[j] = getHalfHourlyTraceValue(cube, tz, types[j], mediaID, lineType);</span>
		}
<span class="nc" id="L867">		return result;</span>
	}

	/**
	 * Return everything stored in TraceCube for specific TraceTypes
	 *
	 * @param TraceCube,
	 *            cube
	 * @param TimeZone,
	 *            tz
	 * @param short[],
	 *            types
	 * @param return
	 *            int[][]
	 */
	public static double[][] getHourlyTraceValue(TraceCube cube, TimeZone tz,
			short[] types, ID mediaID, int lineType) {
<span class="nc bnc" id="L884" title="All 2 branches missed.">		if (types == null) {</span>
<span class="nc" id="L885">			return null;</span>
		}
<span class="nc" id="L887">		double[][] result = new double[types.length][];</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">		for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc" id="L889">			result[j] = getHourlyTraceValue(cube, tz, types[j], mediaID, lineType);</span>
		}
<span class="nc" id="L891">		return result;</span>
	}

	/**
	 * Return everything stored in TraceCube for specific TraceTypes, agg on
	 * Hour
	 *
	 * @param TraceCube,
	 *            cube
	 * @param TimeZone,
	 *            tz
	 * @param short,
	 *            type
	 * @param return
	 *            int[]
	 */
	public static double[] getHourlyTraceValue(TraceCube cube, TimeZone tz,
			short type, ID mediaID, int lineType) {
<span class="nc" id="L909">		double[] value = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L910" title="All 2 branches missed.">		if (value == null) {</span>
<span class="nc" id="L911">			return null;</span>
		}
<span class="nc" id="L913">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L914" title="All 4 branches missed.">		if (start == null || tz == null) {</span>
<span class="nc" id="L915">			return null;</span>
		}
<span class="nc" id="L917">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L918">		cal.setTime(start);</span>
<span class="nc" id="L919">		int startMin = cal.get(Calendar.MINUTE);</span>
<span class="nc" id="L920">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L921">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L922">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L923">		cal.add(Calendar.HOUR_OF_DAY, 1);</span>
		// Get the absolute position
<span class="nc" id="L925">		int pos = startMin / 15;</span>
		// Need figure out how many hours
<span class="nc" id="L927">		int totalLength = value.length;</span>
<span class="nc" id="L928">		totalLength -= (pos + 1);</span>
<span class="nc" id="L929">		int hours = 1;</span>
<span class="nc" id="L930">		int begin = 0;</span>
		// if end point is already 3, then firt hour only one point
<span class="nc bnc" id="L932" title="All 2 branches missed.">		int end = (3 - pos) == 0 ? 3 : (3 - pos);</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">		for (; totalLength &gt; 0; totalLength -= 4) {</span>
<span class="nc" id="L934">			hours++;</span>
		}
		// Cal each hour
<span class="nc" id="L937">		double[] result = new double[hours];</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">		for (int i = 0; i &lt; hours; i++) {</span>
<span class="nc" id="L939">			result[i] = TraceUtil.roundDouble(aggregatePeriod(cube, type,</span>
					begin, end, mediaID, lineType));
<span class="nc" id="L941">			begin = end + 1;</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">			if (begin &gt;= value.length) {</span>
<span class="nc" id="L943">				break;</span>
			}
<span class="nc" id="L945">			end += 4;</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">			end = end &gt;= value.length ? (value.length - 1) : end;</span>
		}
<span class="nc" id="L948">		return result;</span>
	}

	/**
	 * For verification of Report dump aggregation result
	 *
	 * @param TraceCube the cube from which a trace is to be aggregated
	 * @param traceType the trace to aggregate
	 * @param day the day on which the aggregation is to be performed
	 * @param start start time in minutes past midnight on &lt;code&gt;day&lt;/code&gt;
	 * @param end end time in minutes past midnight on &lt;code&gt;day&lt;/code&gt;
	 * @param tz the time zone to be used in interpreting &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;start&lt;/code&gt;,
	 * and &lt;code&gt;end&lt;/code&gt;
	 * @return double
	 */
	public static double aggregatePeriod(TraceCube cube, short traceType, Date day,	int start, int end, TimeZone tz) {
		// Get midnight first
<span class="nc" id="L965">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L966">		cal.setTime(day);</span>
<span class="nc" id="L967">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L968">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L969">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L970">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L971">		cal.add(Calendar.MINUTE, start);</span>
<span class="nc" id="L972">		Date realStart = cal.getTime();</span>
<span class="nc" id="L973">		cal.add(Calendar.MINUTE, -start);</span>
<span class="nc" id="L974">		cal.add(Calendar.MINUTE, end);</span>
<span class="nc" id="L975">		Date realEnd = cal.getTime();</span>
<span class="nc" id="L976">		int beginOffSet = TraceUtil.gapOffSet(cube.getStartDate(), cube</span>
<span class="nc" id="L977">				.getStartOffSet(), realStart);</span>
<span class="nc" id="L978">		int endOffSet = TraceUtil.gapOffSet(cube.getStartDate(), cube</span>
<span class="nc" id="L979">				.getStartOffSet(), realEnd);</span>
<span class="nc" id="L980">		return aggregatePeriod(cube, traceType, beginOffSet, endOffSet);</span>
	}



	/*
	This method will return true only if one or more cubes has missing data for
	trace type or dependent trace type for given interval.
	 will not return true if all cubes do not have data for given interval.
	*/
	public static boolean flagCombineQueue(TraceCube[] cubes, short type, int offSet,boolean isMultiMedia, Map&lt;ID,ID&gt; queueMediaMap) {
<span class="nc" id="L991">		boolean flag = false;</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">		short[] dependentType = getDependentTypeForWeightedAvgForPeriod(type, isMultiMedia ? null : queueMediaMap.get(cubes[0].getQueueID()));</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">		short[] typeArray = new short[dependentType == null ? 1 : dependentType.length + 1];</span>
<span class="nc" id="L994">		typeArray[0] = type;</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">		if (typeArray.length &gt; 1) {</span>
<span class="nc" id="L996">			System.arraycopy(dependentType, 0, typeArray, 1, dependentType.length);</span>
		}
<span class="nc bnc" id="L998" title="All 2 branches missed.">		for (int j = 0; j &lt; typeArray.length; j++) {</span>
<span class="nc" id="L999">			int missingValueCount = 0;</span>
<span class="nc" id="L1000">			int traceType = typeArray[j];</span>
<span class="nc bnc" id="L1001" title="All 4 branches missed.">			if(!isMultiMedia&amp;&amp;!isTraceTypeSupportedForMedia(traceType, queueMediaMap.get(cubes[0].getQueueID()))){</span>
<span class="nc" id="L1002">				continue;</span>
			}
<span class="nc bnc" id="L1004" title="All 2 branches missed.">			for (int i = 0; i &lt; cubes.length; i++) {</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">				if(isMultiMedia &amp;&amp;!isTraceTypeSupportedForMedia(traceType, queueMediaMap.get(cubes[i].getQueueID()))){</span>
<span class="nc" id="L1006">					continue;</span>
				}
<span class="nc" id="L1008">				double typeValue = cubes[i].getTraceValueD(typeArray[j], offSet);</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">				if (typeValue == Trace.TRACEINCOMP) {</span>
<span class="nc" id="L1010">					flag = true;</span>
<span class="nc" id="L1011">					return flag;</span>
				}
<span class="nc bnc" id="L1013" title="All 2 branches missed.">				if (!Trace.isValidValue(typeValue)) {</span>
<span class="nc" id="L1014">					missingValueCount++;</span>
				}
			}
<span class="nc bnc" id="L1017" title="All 4 branches missed.">			if (missingValueCount &gt; 0 &amp;&amp; missingValueCount != cubes.length) {</span>
<span class="nc" id="L1018">				flag = true;</span>
<span class="nc" id="L1019">				return flag;</span>
			}
		}
<span class="nc" id="L1022">		return flag;</span>
	}

	public static boolean flagPeriod(TraceCube cube, short type, int begin, int endOfPeriod, Date now, ID mediaID, int lineType) {
<span class="nc" id="L1026">		boolean flag = false;</span>
<span class="nc" id="L1027">		short[] dependentType = getDependentTypeForWeightedAvgForPeriod(type, mediaID, lineType);</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">		short[] typeArray = new short[dependentType == null ? 1 : dependentType.length + 1];</span>
<span class="nc" id="L1029">		typeArray[0] = type;</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">		if (typeArray.length &gt; 1) {</span>
<span class="nc" id="L1031">			System.arraycopy(dependentType, 0, typeArray, 1, dependentType.length);</span>
		}
		//this is done so that we will flag periods only  upto the given time (now)
<span class="nc" id="L1034">		int cutOffPoint = -1;</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">		if (cube.getEndDate().after(now)) {</span>
<span class="nc" id="L1036">			cutOffPoint = TraceUtil.gapOffSet(cube.getStartDate(), cube.getStartOffSet(), now) - 1;</span>
		} else {
			/*Fix for Bug# 92897 ;for the last day of the last week, the asterisk determination
			seems to only look at data until a certain time depending on the viewing TimeZone.*/
<span class="nc" id="L1040">			cutOffPoint = endOfPeriod;</span>
		}
<span class="nc bnc" id="L1042" title="All 2 branches missed.">		if (cutOffPoint &lt;= begin) {</span>
<span class="nc" id="L1043">			return flag;</span>
		}
<span class="nc bnc" id="L1045" title="All 4 branches missed.">		int updatedEndOfPeriod = (begin &lt; cutOffPoint &amp;&amp; cutOffPoint &lt; endOfPeriod) ? cutOffPoint : endOfPeriod;</span>
<span class="nc bnc" id="L1046" title="All 2 branches missed.">		for (int j = 0; j &lt; typeArray.length; j++) {</span>
<span class="nc" id="L1047">			double[] typeValueArray = cube.getTraceValueD(typeArray[j], begin, updatedEndOfPeriod);</span>
<span class="nc bnc" id="L1048" title="All 6 branches missed.">			if (typeValueArray == null || allNAPoints(typeValueArray) || allOFFPoints(typeValueArray)) {</span>
				//this is the Primary trace type for which we need to flag period
<span class="nc bnc" id="L1050" title="All 2 branches missed.">				if (j == 0) {</span>
<span class="nc" id="L1051">					flag = false;</span>
<span class="nc" id="L1052">					return flag;</span>
				} else {
					continue;
				}
			}
<span class="nc" id="L1057">			boolean foundMissingValue = false;</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">			for (int i = 0; i &lt; typeValueArray.length; i++) {</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">				if (typeValueArray[i] == Trace.TRACEINCOMP) {</span>
<span class="nc" id="L1060">					flag = true;</span>
<span class="nc" id="L1061">					return flag;</span>
				}
<span class="nc bnc" id="L1063" title="All 4 branches missed.">				if (!Trace.isValidValue(typeValueArray[i]) &amp;&amp; (typeValueArray[i] != Trace.TRACEOFF)) {</span>
<span class="nc" id="L1064">					foundMissingValue = true;</span>
				}
<span class="nc bnc" id="L1066" title="All 4 branches missed.">				if (foundMissingValue &amp;&amp; typeValueArray[i] &gt;= 0) {</span>
<span class="nc" id="L1067">					flag = true;</span>
<span class="nc" id="L1068">					return flag;</span>
				}
			}
			//check till the end of given trace period to see if there is any problem
<span class="nc bnc" id="L1072" title="All 4 branches missed.">			if (foundMissingValue &amp;&amp; !flag) {</span>
<span class="nc" id="L1073">				typeValueArray = cube.getTraceValueD(typeArray[j], updatedEndOfPeriod, cutOffPoint);</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">				for (int i = 0; i &lt; typeValueArray.length; i++) {</span>
<span class="nc bnc" id="L1075" title="All 4 branches missed.">					if (typeValueArray[i] == Trace.TRACEINCOMP || typeValueArray[i] &gt;= 0) {</span>
<span class="nc" id="L1076">						flag = true;</span>
<span class="nc" id="L1077">						return flag;</span>
					}
				}
			}
		}
<span class="nc" id="L1082">		return flag;</span>
	}

	public static Pair&lt;double[],boolean[]&gt; getHourlyFlags(TraceCube cube, TimeZone tz, short type, Date now, ID mediaID, int lineType) {
<span class="nc" id="L1086">		double[] typeArray = cube.getTraceValueD(type);</span>
<span class="nc" id="L1087">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L1088" title="All 6 branches missed.">		if (typeArray == null || start == null || tz == null) {</span>
<span class="nc" id="L1089">			return null;</span>
		}
<span class="nc" id="L1091">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1092">		cal.setTime(start);</span>
<span class="nc" id="L1093">		int startMin = cal.get(Calendar.MINUTE);</span>
		// Get the absolute position
<span class="nc" id="L1095">		int pos = startMin / Trace.INTERVAL;</span>
		// Need figure out how many hours
<span class="nc" id="L1097">		int hours = 1;</span>
<span class="nc" id="L1098">		int totalLength = typeArray.length - (pos + 1);</span>
<span class="nc bnc" id="L1099" title="All 2 branches missed.">		for (; totalLength &gt; 0; totalLength -= 4) {</span>
<span class="nc" id="L1100">			hours++;</span>
		}
<span class="nc" id="L1102">		int begin = 0;</span>
		// if end point is already 3, then firt hour only one point
<span class="nc bnc" id="L1104" title="All 2 branches missed.">		int end = (3 - pos) == 0 ? 3 : (3 - pos);</span>
		// Cal each hour
<span class="nc" id="L1106">		boolean[] flagArray = new boolean[hours];</span>
<span class="nc" id="L1107">		double[] valueArray = new double[hours];</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">		for (int i = 0; i &lt; hours; i++) {</span>
			//flag the period only upto given time ignore valid values after that because they are trended values.
<span class="nc" id="L1110">			flagArray[i] = flagPeriod(cube, type, begin, end, now, mediaID, lineType);</span>
<span class="nc" id="L1111">			valueArray[i] = TraceUtil.roundDouble(aggregatePeriod(cube, type, begin, end, mediaID, lineType));</span>
<span class="nc" id="L1112">			begin = end + 1;</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">			if (begin &gt;= typeArray.length) {</span>
<span class="nc" id="L1114">				break;</span>
			}
<span class="nc" id="L1116">			end += 4;</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">			end = end &gt;= typeArray.length ? (typeArray.length - 1) : end;</span>
		}
<span class="nc" id="L1119">		return new Pair&lt;double[],boolean[]&gt;(valueArray, flagArray);</span>
	}

	public static short[] getDependentTypeForWeightedAvgForPeriod(int traceType, ID mediaID) {
<span class="nc" id="L1123">		return getDependentTypeForWeightedAvgForPeriod(traceType, mediaID, FORECAST_LINE);</span>
	}

	public static int getLineType(TraceCube cube) {
<span class="nc bnc" id="L1127" title="All 2 branches missed.">		if (cube instanceof ActualTraceCube) {</span>
<span class="nc" id="L1128">			return ACTUAL_LINE;</span>
<span class="nc bnc" id="L1129" title="All 6 branches missed.">		} else if (cube instanceof ForecastTraceCube || cube instanceof PredictTraceCube || cube instanceof AggrForecastedTraceCube) {</span>
<span class="nc" id="L1130">			return FORECAST_LINE;</span>
		} else {
<span class="nc" id="L1132">			return REQUIRE_LINE;</span>
		}
	}

	/**
	 * Get the dependent trace types to use for weighted averages of the given trace type, media, and line type.
	 * @param traceType - One of the Trace.TYPES
	 * @param mediaID - The medis ID of the queue containing the statistic (traceType)
	 * @param lineType - One of the following: ACTUAL_LINE, FORECAST_LINE, REQUIRE_LINE
	 * @return an array containing the trace types to use in the weighted average formula.
	 */
	public static short[] getDependentTypeForWeightedAvgForPeriod(int traceType, ID mediaID, int lineType) {
<span class="nc bnc" id="L1144" title="All 12 branches missed.">		switch (traceType) {</span>
			case Trace.ASA:
<span class="nc bnc" id="L1146" title="All 4 branches missed.">				if (lineType == ACTUAL_LINE &amp;&amp; Media.isMediaImmediate(mediaID)) {</span>
<span class="nc" id="L1147">					return new short[]{Trace.ASA_WEIGHT};</span>
				} else {
<span class="nc" id="L1149">					return new short[]{Trace.CV, Trace.ABANDONMENT};</span>
				}
			case Trace.SERVICE_GOALS_ASA:
<span class="nc" id="L1152">				return new short[]{Trace.CV, Trace.ABANDONMENT};</span>
			case Trace.PCA:
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
				//CV for immediate media and VH for deferred
<span class="nc" id="L1157">				return new short[]{Trace.VAR};</span>
			case Trace.DEADLINE_TIME:
			case Trace.SERVICE_GOALS_DEADLINE_TIME:
<span class="nc" id="L1160">				return new short[]{Trace.CV};</span>
			case Trace.AHT:
<span class="nc bnc" id="L1162" title="All 4 branches missed.">				if (mediaID == null || mediaID.toInt() == -10) {</span>
<span class="nc" id="L1163">					return new short[]{Trace.CV_VH, Trace.CONNECTS};</span>
				} else {
<span class="nc bnc" id="L1165" title="All 2 branches missed.">					return new short[]{ Media.MEDIA_ID_PHONE_OUTBOUND.equals(mediaID)? Trace.CONNECTS : Trace.CV_VH};</span>
				}
			case Trace.OCCUPANCY:
<span class="nc" id="L1168">				return new short[]{Trace.STAFFING};</span>
			case Trace.CRATE:
<span class="nc" id="L1170">				return new short[]{Trace.DIALS};</span>
			case Trace.RPCAHT:
<span class="nc" id="L1172">				return new short[]{Trace.RPC};</span>
			case Trace.RPCRATE:
<span class="nc" id="L1174">				return new short[]{Trace.DIALS};</span>
			case Trace.FORECASTING_AHT:
<span class="nc bnc" id="L1176" title="All 4 branches missed.">				if (mediaID == null || mediaID.toInt() == -10) {</span>
<span class="nc" id="L1177">					return new short[]{Trace.CV_VH, Trace.FORECASTING_CRATE};</span>
				} else {
<span class="nc bnc" id="L1179" title="All 2 branches missed.">					return new short[]{ Media.MEDIA_ID_PHONE_OUTBOUND.equals(mediaID)? Trace.FORECASTING_CRATE : Trace.CV_VH};</span>
				}
			case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L1182">				return new short[]{Trace.FORECASTING_RPCRATE};</span>
			default:
<span class="nc" id="L1184">				return null;</span>
		}
	}

	// Can't typesafe this array because you can't create an array of a generic type.
	// It's really Set&lt;ID&gt;[].  TODO: Maybe use a list or map instead?
<span class="nc" id="L1190">	private static Object[] traceTypeMediaMatrix = null;</span>
<span class="nc" id="L1191">	private static HashMap&lt;ID,Object[]&gt; mediaTraceTypeMatrixMap = null; // UNUSED</span>

	public static Object[] getTraceTypeMediaMatrix() {
		// elingman: I added &quot;facetoface&quot;; usually same traces as &quot;phone&quot;
		/*
		 MEDIA_ID_FACETOFACE = new ID(-11);
         MEDIA_ID_OPERATIONS = new ID(-9);
         MEDIA_ID_PROJECT = new ID(-8);
         MEDIA_ID_PHONE_OUTBOUND = new ID(-7);
		 MEDIA_ID_CALLBACK = new ID(-6);
		 MEDIA_ID_FAX = new ID(-5);
		 MEDIA_ID_EMAIL = new ID(-4);
		 MEDIA_ID_CHAT = new ID(-3);
		 MEDIA_ID_VOIP = new ID(-2);
		 MEDIA_ID_PHONE = new ID(-1);
		 MEDIA_ID_SOCIAL_POST =  new ID(-14);
		*/
<span class="nc bnc" id="L1208" title="All 2 branches missed.">		if (traceTypeMediaMatrix == null) {</span>
<span class="nc" id="L1209">			traceTypeMediaMatrix = new Object[Trace.MAX_TYPE];</span>
<span class="nc" id="L1210">			mediaTraceTypeMatrixMap = new HashMap&lt;ID, Object[]&gt;();</span>
<span class="nc" id="L1211">			Map&lt;ID, Set&lt;Short&gt;&gt; mediaTraceTypeScratchMap = new HashMap&lt;ID, Set&lt;Short&gt;&gt;();</span>
<span class="nc" id="L1212">			String[] traceTypeMediaMatrixStrings = new String[Trace.MAX_TYPE];</span>
<span class="nc" id="L1213">			traceTypeMediaMatrixStrings[Trace.CV] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1214">			traceTypeMediaMatrixStrings[Trace.AHT] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1215">			traceTypeMediaMatrixStrings[Trace.PCA] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1216">			traceTypeMediaMatrixStrings[Trace.SERVICE_GOALS_PCA_IMMEDIATE] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1217">			traceTypeMediaMatrixStrings[Trace.SERVICE_GOALS_PCA_DEFERRED] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1218">			traceTypeMediaMatrixStrings[Trace.ASA] = &quot;-1,-2,-3,-4,-5,-6,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1219">			traceTypeMediaMatrixStrings[Trace.SERVICE_GOALS_ASA] = &quot;-1,-2,-3,-4,-5,-6,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1220">			traceTypeMediaMatrixStrings[Trace.ABANDONMENT] = &quot;-1,-2,-3,-7,-11&quot;;</span>
<span class="nc" id="L1221">			traceTypeMediaMatrixStrings[Trace.BACKLOG] = &quot;-4,-5,-6,-7,-9,-13,-14&quot;;</span>
<span class="nc" id="L1222">			traceTypeMediaMatrixStrings[Trace.STAFFING] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,14&quot;;</span>
<span class="nc" id="L1223">			traceTypeMediaMatrixStrings[Trace.OCCUPANCY] = &quot;-1,-2,-3,-4,-5,-6,-7,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1224">			traceTypeMediaMatrixStrings[Trace.FTE] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1225">			traceTypeMediaMatrixStrings[Trace.DIALS] = &quot;-7&quot;;</span>
<span class="nc" id="L1226">			traceTypeMediaMatrixStrings[Trace.CONNECTS] = &quot;-7&quot;;</span>
<span class="nc" id="L1227">			traceTypeMediaMatrixStrings[Trace.CRATE] = &quot;-7&quot;;</span>
<span class="nc" id="L1228">			traceTypeMediaMatrixStrings[Trace.RPC] = &quot;-7&quot;;</span>
<span class="nc" id="L1229">			traceTypeMediaMatrixStrings[Trace.RPCRATE] = &quot;-7&quot;;</span>
<span class="nc" id="L1230">			traceTypeMediaMatrixStrings[Trace.RPCAHT] = &quot;-7&quot;;</span>
<span class="nc" id="L1231">			traceTypeMediaMatrixStrings[Trace.VH] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1232">			traceTypeMediaMatrixStrings[Trace.VAR] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1233">			traceTypeMediaMatrixStrings[Trace.CV_VH] = &quot;-1,-2,-3,-4,-5,-6,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1234">			traceTypeMediaMatrixStrings[Trace.DEADLINE_TIME] = &quot;-4,-5,-6,-9,-13,-14&quot;;</span>
<span class="nc" id="L1235">			traceTypeMediaMatrixStrings[Trace.SERVICE_GOALS_DEADLINE_TIME] = &quot;-4,-5,-6,-9,-13,-14&quot;;</span>
<span class="nc" id="L1236">			traceTypeMediaMatrixStrings[Trace.FORECASTING_CRATE] = &quot;-7&quot;;</span>
<span class="nc" id="L1237">			traceTypeMediaMatrixStrings[Trace.FORECASTING_AHT] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1238">			traceTypeMediaMatrixStrings[Trace.FORECASTING_RPCRATE] = &quot;-7&quot;;</span>
<span class="nc" id="L1239">			traceTypeMediaMatrixStrings[Trace.FORECASTING_RPCAHT] = &quot;-7&quot;;</span>
<span class="nc" id="L1240">			traceTypeMediaMatrixStrings[Trace.MAX_DIALS] = &quot;-7&quot;;</span>
<span class="nc" id="L1241">			traceTypeMediaMatrixStrings[Trace.ASTAFFING] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1242">			traceTypeMediaMatrixStrings[Trace.AFTE] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1243">			traceTypeMediaMatrixStrings[Trace.NETSTAFFING] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1244">			traceTypeMediaMatrixStrings[Trace.OVER_UNDER] = &quot;-1,-2,-3,-4,-5,-6,-7,-8,-9,-11,-13,-14&quot;;</span>
<span class="nc" id="L1245">			traceTypeMediaMatrixStrings[Trace.ASA_WEIGHT] = &quot;-1,-2,-3,-4,-5,-6,-9,-11,-13&quot;;</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">			for (short i = 0; i &lt; traceTypeMediaMatrixStrings.length; i++) {</span>
<span class="nc" id="L1247">				Set&lt;ID&gt; mediaSet = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1248">				StringTokenizer st = new StringTokenizer(traceTypeMediaMatrixStrings[i], &quot;,&quot;);</span>
<span class="nc bnc" id="L1249" title="All 2 branches missed.">				while (st.hasMoreTokens()) {</span>
<span class="nc" id="L1250">					ID mediaID = new ID(Integer.parseInt(st.nextToken()));</span>
<span class="nc" id="L1251">					mediaSet.add(mediaID);</span>
<span class="nc" id="L1252">					Set&lt;Short&gt; traceTypeSet = mediaTraceTypeScratchMap.get(mediaID);</span>
<span class="nc bnc" id="L1253" title="All 2 branches missed.">					if (traceTypeSet == null) {</span>
<span class="nc" id="L1254">						traceTypeSet = new HashSet&lt;Short&gt;();</span>
<span class="nc" id="L1255">						mediaTraceTypeScratchMap.put(mediaID, traceTypeSet);</span>
					}
<span class="nc" id="L1257">					traceTypeSet.add(new Short(i));</span>
<span class="nc" id="L1258">				}</span>
<span class="nc" id="L1259">				traceTypeMediaMatrix[i] = mediaSet;</span>
			}
<span class="nc" id="L1261">			Set&lt;ID&gt; mediaSet = mediaTraceTypeScratchMap.keySet();</span>
<span class="nc bnc" id="L1262" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; iterator = mediaSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1263">				ID mediaID = iterator.next();</span>
<span class="nc" id="L1264">				Set&lt;Short&gt; traceTypeSet = mediaTraceTypeScratchMap.get(mediaID);</span>
<span class="nc" id="L1265">				mediaTraceTypeMatrixMap.put(mediaID, traceTypeSet.toArray());</span>
<span class="nc" id="L1266">			}</span>
		}
<span class="nc" id="L1268">		return traceTypeMediaMatrix;</span>
	}

	//TODO: Change traceType to short.
	public static boolean isTraceTypeSupportedForMedia(int traceType, ID mediaID) {
<span class="nc" id="L1273">		getTraceTypeMediaMatrix();</span>
		//always return true for combined media
<span class="nc bnc" id="L1275" title="All 4 branches missed.">		if (mediaID == null || mediaID.toInt() == -10) {</span>
<span class="nc" id="L1276">			return true;</span>
		}
<span class="nc" id="L1278">		return ((Set) traceTypeMediaMatrix[traceType]).contains(mediaID);</span>
	}

	public static TraceCube combineQueue(TraceCube[] cubes, boolean needAllValid, Map&lt;ID,ID&gt; queueMediaMap)
		throws BbmTimeSeriesException {
<span class="nc" id="L1283">		return combineQueue(cubes, needAllValid, queueMediaMap, FORECAST_LINE);</span>
	}

	/**
	 * Combine function to aggregate Trace values based on Trace Type for multiple
	 * queues.  Assumes all TraceCubes have the same starting point.  Used in multi-queue
	 * combined mode, mainly in Tracking/Forecast View.
	 *
	 * @param cubes the trace cubes to be combined
	 * @param needAllValid if true then at any time where any constituent value
	 *  is invalid the combined value at that time will be Trace.TRACENA.
	 * @param queueMediaMap a map from trace cube ID to media ID
	 * @return TraceCube a TraceCube whose runtime class is the same as that of the first element
	 * of the &lt;code&gt;cubes&lt;/code&gt; array, and that contains the aggregates of the traces contained
	 * in the &lt;code&gt;cubes&lt;/code&gt; array.
	 */
	public static TraceCube combineQueue(TraceCube[] cubes, boolean needAllValid, Map&lt;ID,ID&gt; queueMediaMap, int lineType)
		throws BbmTimeSeriesException {
		// Validation check and get the combined queue TraceCube
<span class="nc" id="L1302">		TraceCube tc = TraceUtil.validateTraceCubes(cubes);</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">		if (tc == null) {</span>
<span class="nc" id="L1304">			return null;</span>
		}
<span class="nc" id="L1306">		short[] types = tc.getTraceTypes();</span>
		// special handle AggrRequireTraceCube
<span class="nc bnc" id="L1308" title="All 2 branches missed.">		if (tc instanceof AggrRequiredTraceCube) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">			if (((AggrRequiredTraceCube) tc).getForecastTrace() != null) {</span>
				// Add CV &amp; VAR in addition to existing types
<span class="nc" id="L1311">				short[] nTypes = new short[types.length + 2];</span>
<span class="nc" id="L1312">				nTypes[0] = Trace.CV;</span>
<span class="nc" id="L1313">				nTypes[1] = Trace.VAR;</span>
<span class="nc" id="L1314">				System.arraycopy(types, 0, nTypes, 2, types.length);</span>
<span class="nc" id="L1315">				types = nTypes;</span>
			}
		}
		// Check if combine operation required types are existent or not
<span class="nc" id="L1319">		HashSet&lt;ID&gt; mediaSet = new HashSet&lt;ID&gt;(queueMediaMap.values());</span>
<span class="nc bnc" id="L1320" title="All 4 branches missed.">		boolean isMultiMedia = mediaSet == null || mediaSet.size() != 1;</span>
<span class="nc" id="L1321">		int size = tc.getMaximumLength(types);</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">		for (int k = 0; k &lt; types.length; k++) {</span>
<span class="nc" id="L1323">			short traceType = types[k];</span>
<span class="nc bnc" id="L1324" title="All 4 branches missed.">			if (isMultiMedia || isTraceTypeSupportedForMedia(traceType, (ID) mediaSet.toArray()[0])) {</span>
<span class="nc" id="L1325">				AggregationType aggregationType = getAggregationTypeForQueueCombination(traceType, cubes[0].isRequiredData());</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">				short[] dependentTypeArray = getDependentTypeForWeightedAvgForPeriod(traceType,</span>
<span class="nc" id="L1327">						!isMultiMedia ? (ID) mediaSet.toArray()[0] : null, lineType);</span>
<span class="nc" id="L1328">				double[] result = new double[size];</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">				if (cubes.length == 1) {</span>
<span class="nc" id="L1330">					result = cubes[0].getTraceValueD(traceType);</span>
				} else {
<span class="nc bnc" id="L1332" title="All 2 branches missed.">					for (int j = 0; j &lt; size; j++) {</span>
<span class="nc" id="L1333">						double val = combineQueue(cubes, traceType, j, needAllValid, queueMediaMap, isMultiMedia, dependentTypeArray, aggregationType);</span>
<span class="nc" id="L1334">						result[j] = TraceUtil.roundDouble(val);</span>
					}
				}
<span class="nc" id="L1337">				tc.setTraceValue(traceType, result);</span>
<span class="nc" id="L1338">			} else {</span>
<span class="nc" id="L1339">				tc.initTraceValue(traceType, Trace.TRACENA);</span>
			}
		}
<span class="nc" id="L1342">		return tc;</span>
	}

	/**
	 * this method returns true if the trace type is supported for combining indvl queues to get value for the combined queue.
	 * right now Occupancy and staffing are not supported for combining of indvl queues since they are derived from staffing calculator.
	 *
	 * @param type
	 * @return
	 */
	public static boolean isTraceTypeSupportedForCombined(short type) {
<span class="nc bnc" id="L1353" title="All 2 branches missed.">		switch (type) {</span>
			case Trace.OCCUPANCY:
				case Trace.STAFFING:
			case Trace.NETSTAFFING:
<span class="nc" id="L1357">				return false;</span>
			default:
<span class="nc" id="L1359">				return true;</span>
		}
	}

	private static double combineQueue(
			TraceCube[] cubes,
			short traceType,
			int offSet,
			boolean needAllValid,
			Map&lt;ID,ID&gt; queueMediaMap,
			boolean isMultiMedia,
			short[] dependentTypeArray,
			AggregationType aggregationType) {

		// check if the trace type is supported for combining of individual queues.
<span class="nc bnc" id="L1374" title="All 2 branches missed.">		if (!isTraceTypeSupportedForCombined(traceType)) {</span>
<span class="nc" id="L1375">			return Trace.TRACENA;</span>
		}
		// check whether the aggregation type supports combining
<span class="nc bnc" id="L1378" title="All 2 branches missed.">		if ( ! aggregationType.supportsCombine() ) {</span>
<span class="nc" id="L1379">			return Trace.TRACENA;</span>
		}
		// check for holes; i.e. missing value in one or more Queues (but not all) for given trace interval
<span class="nc bnc" id="L1382" title="All 4 branches missed.">		if (needAllValid&amp;&amp; flagCombineQueue(cubes, traceType, offSet, isMultiMedia, queueMediaMap)) {</span>
<span class="nc" id="L1383">			return Trace.TRACEINCOMP;</span>
		}
<span class="nc" id="L1385">		double result = Trace.TRACENA;</span>
<span class="nc" id="L1386">		double weightedSum = Trace.TRACENA;</span>
		// The sum of valid values
<span class="nc" id="L1388">		double sum = Trace.TRACENA;</span>
		// The number of value values
<span class="nc" id="L1390">		int counter = 0;</span>
<span class="nc" id="L1391">		double dependTypeValSum = Trace.TRACENA;</span>

<span class="nc bnc" id="L1393" title="All 2 branches missed.">		for (int i = 0; i &lt; cubes.length; i++) {</span>
<span class="nc bnc" id="L1394" title="All 4 branches missed.">			if (isMultiMedia &amp;&amp; !isTraceTypeSupportedForMedia(traceType, queueMediaMap.get(cubes[i].getQueueID()))) {</span>
<span class="nc" id="L1395">				continue;</span>
			}
<span class="nc" id="L1397">			double value = cubes[i].getTraceValueD(traceType, offSet);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">			if (!Trace.isValidValue(value)) {</span>
				// Hours of operation are defined per SP so if one queue is off at this time,
				// they'll all be off.
<span class="nc bnc" id="L1401" title="All 2 branches missed.">				if (value == Trace.TRACEOFF) {</span>
<span class="nc" id="L1402">					return Trace.TRACEOFF;</span>
<span class="nc bnc" id="L1403" title="All 2 branches missed.">				} else if (needAllValid) {</span>
<span class="nc" id="L1404">					return Trace.TRACENA;</span>
				} else {
					// where all valid points are not needed
					continue;
				}
			}

<span class="nc bnc" id="L1411" title="All 2 branches missed.">			sum = sum == Trace.TRACENA ? 0 : sum;</span>
<span class="nc" id="L1412">			counter++;</span>
<span class="nc bnc" id="L1413" title="All 4 branches missed.">			if ((aggregationType != AggregationType.SIMPLE_AVERAGE_EXCLUDE_ZEROS) || (value &gt; 0)) {</span>
<span class="nc" id="L1414">				sum += value;</span>
			}

<span class="nc bnc" id="L1417" title="All 2 branches missed.">			if (aggregationType.isWeightedAverage()) {</span>
<span class="nc" id="L1418">				double depValSum = Trace.TRACENA;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">				for (int j = 0; j &lt; dependentTypeArray.length; j++) {</span>
<span class="nc bnc" id="L1420" title="All 4 branches missed.">					if (isMultiMedia &amp;&amp; !isTraceTypeSupportedForMedia(dependentTypeArray[j], queueMediaMap.get(cubes[i].getQueueID()))) {</span>
<span class="nc" id="L1421">						continue;</span>
					}
<span class="nc" id="L1423">					double dependentVal = cubes[i].getTraceValueD(dependentTypeArray[j], offSet);</span>
<span class="nc bnc" id="L1424" title="All 2 branches missed.">					if (dependentVal &gt;= 0) {</span>
						//Special condition for ASA
<span class="nc bnc" id="L1426" title="All 8 branches missed.">						if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT ||</span>
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
<span class="nc" id="L1430">							double cv = cubes[i].getTraceValueD(Trace.CV, offSet);</span>
							//CV always need to be present
<span class="nc bnc" id="L1432" title="All 2 branches missed.">							if (cv &lt; 0) {</span>
<span class="nc" id="L1433">								return Trace.TRACENA;</span>
							}
<span class="nc bnc" id="L1435" title="All 4 branches missed.">							if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||</span>
								aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
								//Special condition for ASA where SUM (CV-ABN)*ASA/(SUM(CV-ABN)
<span class="nc" id="L1438">								double abn = cubes[i].getTraceValueD(Trace.ABANDONMENT, offSet);</span>
<span class="nc bnc" id="L1439" title="All 2 branches missed.">								depValSum = abn &lt; 0? Trace.TRACENA : cv * (100 - abn);</span>
<span class="nc" id="L1440">								break;</span>
							} else {
<span class="nc bnc" id="L1442" title="All 2 branches missed.">								depValSum = depValSum == Trace.TRACENA ? dependentVal : Math.abs(depValSum - dependentVal);</span>
								//Special condition for ASA where SUM (CV-ABN)*ASA/(SUM(CV-ABN)
							}
<span class="nc" id="L1445">						} else {</span>
							//assign val if not already intialized else sum it
<span class="nc bnc" id="L1447" title="All 2 branches missed.">							depValSum = depValSum == Trace.TRACENA ? dependentVal : (depValSum + dependentVal);</span>
						}
					}
				}
<span class="nc bnc" id="L1451" title="All 2 branches missed.">				if (!Trace.isValidValue(depValSum)) {</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">					if (needAllValid) {</span>
<span class="nc" id="L1453">						return Trace.TRACENA;</span>
					} else {
						// where all valid points are not needed
						continue;
					}
				}
<span class="nc bnc" id="L1459" title="All 2 branches missed.">				weightedSum = (weightedSum == Trace.TRACENA ? 0 : weightedSum) + (depValSum * value);</span>
<span class="nc bnc" id="L1460" title="All 2 branches missed.">				dependTypeValSum = (dependTypeValSum == Trace.TRACENA ? 0 : dependTypeValSum) + depValSum;</span>
			}
		}
<span class="nc bnc" id="L1463" title="All 2 branches missed.">		if (aggregationType.isWeightedAverage()) {</span>
<span class="nc bnc" id="L1464" title="All 4 branches missed.">			if (weightedSum &gt;= 0 &amp;&amp; dependTypeValSum &gt; 0) {</span>
<span class="nc" id="L1465">				result = weightedSum / dependTypeValSum;</span>
<span class="nc bnc" id="L1466" title="All 2 branches missed.">			} else if (dependTypeValSum &lt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L1467" title="All 4 branches missed.">					   aggregationType.isSimpleAverageIfNoWeights() &amp;&amp;</span>
					   counter &gt; 0) {
<span class="nc" id="L1469">				result = sum / counter;</span>
<span class="nc bnc" id="L1470" title="All 4 branches missed.">			} else if (weightedSum == 0 &amp;&amp; dependTypeValSum == 0){</span>
<span class="nc" id="L1471">				result = 0;</span>
			}
<span class="nc bnc" id="L1473" title="All 4 branches missed.">		} else if (aggregationType == AggregationType.SIMPLE_AVERAGE || aggregationType == AggregationType.SIMPLE_AVERAGE_EXCLUDE_ZEROS) {</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">			if (counter &gt; 0) {</span>
<span class="nc" id="L1475">				result = sum / counter;</span>
			}
<span class="nc bnc" id="L1477" title="All 2 branches missed.">		} else if (aggregationType == AggregationType.SUM) {</span>
<span class="nc" id="L1478">			result = sum;</span>
		}
<span class="nc" id="L1480">		return result;</span>
	}

	// Trace type might be represented better as an enum, and the aggregation type
	// could be queried directly from each enum value.
	public static AggregationType getAggregationTypeForQueueCombination(short traceType, boolean isRequiredData) {
<span class="nc bnc" id="L1486" title="All 8 branches missed.">		switch (traceType) {</span>
			case Trace.CV:
			case Trace.ABANDONMENT:
			case Trace.STAFFING:
			case Trace.FTE:
			case Trace.DIALS:
			case Trace.CONNECTS:
			case Trace.RPC:
			case Trace.VH:
			case Trace.VAR:
			case Trace.CV_VH:
			case Trace.BACKLOG:
			case Trace.ASTAFFING:
			case Trace.AFTE:
			case Trace.NETSTAFFING:
<span class="nc" id="L1501">				return AggregationType.SUM;</span>
			case Trace.FORECASTING_CRATE:
			case Trace.FORECASTING_RPCRATE:
<span class="nc" id="L1504">				return AggregationType.SIMPLE_AVERAGE_EXCLUDE_ZEROS;</span>
			case Trace.MAX_DIALS:	
<span class="nc" id="L1506">				return AggregationType.SIMPLE_AVERAGE;</span>
			case Trace.PCA:
			case Trace.AHT:
			case Trace.FORECASTING_AHT:
			case Trace.OCCUPANCY:
			case Trace.CRATE:
			case Trace.RPCRATE:
			case Trace.RPCAHT:
			case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L1515">				return AggregationType.WEIGHTED_AVERAGE;</span>
			case Trace.ASA:
<span class="nc bnc" id="L1517" title="All 2 branches missed.">				return isRequiredData ? AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT :</span>
										AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT;
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
			case Trace.DEADLINE_TIME:
			case Trace.SERVICE_GOALS_DEADLINE_TIME:
<span class="nc" id="L1523">				return AggregationType.WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS;</span>
			case Trace.SERVICE_GOALS_ASA:
<span class="nc bnc" id="L1525" title="All 2 branches missed.">				return isRequiredData ? AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS :</span>
										AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS;
			default:
<span class="nc" id="L1528">				return AggregationType.SUM;</span>
		}
	}

	// Trace type might be represented better as an enum, and the aggregation type
	// could be queried directly from each enum value.
	public static AggregationType getAggregationTypeForTimeAggregation(short traceType, boolean isRequiredData) {
<span class="nc bnc" id="L1535" title="All 8 branches missed.">		switch (traceType) {</span>
			case Trace.CV:
			case Trace.ABANDONMENT:
			case Trace.STAFFING:
			case Trace.FTE:
			case Trace.DIALS:
			case Trace.CONNECTS:
			case Trace.RPC:
			case Trace.VH:
			case Trace.VAR:
			case Trace.CV_VH:
			case Trace.ASTAFFING:
			case Trace.AFTE:
			case Trace.NETSTAFFING:
<span class="nc" id="L1549">				return AggregationType.SUM;</span>
			case Trace.FORECASTING_CRATE:
			case Trace.FORECASTING_RPCRATE:
			case Trace.MAX_DIALS:
<span class="nc" id="L1553">				return AggregationType.SIMPLE_AVERAGE;</span>
			case Trace.BACKLOG:
<span class="nc" id="L1555">				return AggregationType.LAST_VALID_VALUE;</span>
			case Trace.PCA:
			case Trace.AHT:
			case Trace.FORECASTING_AHT:
			case Trace.OCCUPANCY:
			case Trace.CRATE:
			case Trace.RPCRATE:
			case Trace.RPCAHT:
			case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L1564">				return AggregationType.WEIGHTED_AVERAGE;</span>
			case Trace.ASA:
<span class="nc bnc" id="L1566" title="All 2 branches missed.">				return isRequiredData ? AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT:</span>
										AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT;
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
			case Trace.DEADLINE_TIME:
			case Trace.SERVICE_GOALS_DEADLINE_TIME:
<span class="nc" id="L1572">				return AggregationType.WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS;</span>
			case Trace.SERVICE_GOALS_ASA:
<span class="nc bnc" id="L1574" title="All 2 branches missed.">				return isRequiredData ? AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:</span>
										AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS;
			default:
<span class="nc" id="L1577">				return AggregationType.SUM;</span>
		}
	}
	
	/**
	 * Returns the aggregate value of the specified trace over the specified interval.
	 * &lt;p&gt;
	 * The result is not necessarily an integer.  If an integer value is desired
	 * use TraceUtil.roundDouble to round the value to an integer.
	 *
	 * @param TraceCube cube
	 * @param traceType the trace to aggregate within the cube
	 * @param begin interval start point
	 * @param end interval end point
	 * @return the aggregate value for the specified period.  This value is not necessarily integral.  If
	 * an integer value is desired use TraceUtil.roundDouble to round the value to an integer.
	 */
	public static double aggregatePeriod(TraceCube cube, short traceType, int begin, int end) {
<span class="nc" id="L1595">		return aggregatePeriod(cube, traceType, begin, end, null, null, FORECAST_LINE);</span>
	}
	public static double aggregatePeriod(TraceCube cube, short traceType, int end, boolean[] excPoints) {
<span class="nc" id="L1598">		return aggregatePeriod(cube, traceType, 0, end, excPoints, null, FORECAST_LINE);</span>
	}
	public static double aggregatePeriod(TraceCube cube, short traceType, int begin, int end, ID mediaID, int lineType) {
<span class="nc" id="L1601">		return aggregatePeriod(cube, traceType, begin, end, null, mediaID, lineType);</span>
	}
	public static double aggregatePeriod(TraceCube cube, short traceType, int end, boolean[] excPoints,
		ID mediaID, int lineType) {
<span class="nc" id="L1605">		return aggregatePeriod(cube, traceType, 0, end, excPoints, mediaID, lineType);</span>
	}
	public static double aggregatePeriod(TraceCube cube, short traceType, int begin, int end, boolean[] excPoints) {
<span class="nc" id="L1608">		return aggregatePeriod(cube, traceType, begin, end, excPoints, null, FORECAST_LINE);</span>
	}
	public static double aggregatePeriod(TraceCube cube, short traceType, int begin, int end, boolean[] excPoints,
		ID mediaID, int lineType) {
<span class="nc bnc" id="L1612" title="All 2 branches missed.">		if (begin == end) {</span>
<span class="nc" id="L1613">			return cube.getTraceValueD(traceType, begin);</span>
		}
<span class="nc" id="L1615">		double[] valueArray = cube.getTraceValueD(traceType, begin, end);</span>
<span class="nc bnc" id="L1616" title="All 4 branches missed.">		if (valueArray == null || allNAPoints(valueArray)) {</span>
<span class="nc" id="L1617">			return Trace.TRACENA;</span>
<span class="nc bnc" id="L1618" title="All 2 branches missed.">		} else if (allOFFPoints(valueArray)) {</span>
<span class="nc" id="L1619">			return Trace.TRACEOFF;</span>
		}
<span class="nc" id="L1621">		double[][] dependentValueArrays = null;</span>
<span class="nc" id="L1622">		short[] dependentTypeArray = null;</span>
<span class="nc" id="L1623">		AggregationType aggregationType = getAggregationTypeForTimeAggregation(traceType, cube.isRequiredData());</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">		if (aggregationType.isWeightedAverage()) {</span>
<span class="nc" id="L1625">			dependentTypeArray = getDependentTypeForWeightedAvgForPeriod(traceType, mediaID, lineType);</span>
<span class="nc" id="L1626">			dependentValueArrays = new double[dependentTypeArray.length][valueArray.length];</span>
<span class="nc bnc" id="L1627" title="All 2 branches missed.">			for (int j = 0; j &lt; dependentTypeArray.length; j++) {</span>
<span class="nc" id="L1628">				dependentValueArrays[j] = cube.getTraceValueD(dependentTypeArray[j], begin, end);</span>
			}
		}
<span class="nc" id="L1631">		double result = aggregateArrayD(valueArray, aggregationType, dependentValueArrays, excPoints);</span>
		//TODO: This sort of thing belongs in the client code, not in a foundational calculation.
		// The word &quot;display&quot; in a foundation calculation is something of a red flag.
		// Special handling for Staffing &amp; FTE,
		// We need to display hourly aggregation (instead of 15 min) after summation.
		// Sum(Staffing)/4; To obtain Hourly Staffing if valueArray.length &gt;= 4,else just valueArray.length
		// This code is affecting the scalePeriodTraceWithDistribution method.  Please see the comments in that
		// method to see how it is impacted.
<span class="nc bnc" id="L1639" title="All 12 branches missed.">		if (Trace.isValidValue(result)&amp;&amp;(traceType == Trace.FTE || traceType == Trace.STAFFING||traceType == Trace.AFTE</span>
				|| traceType == Trace.ASTAFFING || traceType== Trace.NETSTAFFING)){
<span class="nc bnc" id="L1641" title="All 2 branches missed.">			return result / (valueArray.length &gt; Trace.HOURPOINTS ? Trace.HOURPOINTS : valueArray.length);</span>
		}
<span class="nc" id="L1643">		return result;</span>
	}

	/**
	 * Performs the actual work of aggregation.  This method could potentially be reused for
	 * combining queues as well.
	 *
	 * @param sourceValues
	 * @param aggregationType
	 * @param dependentValueArrays
	 * @param excPoints
	 * @return
	 */
	// TODO: There is huge duplication between this method and code in TraceDistributionBuilder.
	// Need to determine if this code is even needed any more or if we can use TraceDistributionBuilder
	// exclusively.
	public static double aggregateArray(
			int[] sourceValues,
			AggregationType aggregationType,
			int[][] dependentValueArrays,
			boolean[] excPoints) {

<span class="nc" id="L1665">		double result = Trace.TRACENA;</span>
<span class="nc" id="L1666">		double weightedSum = Trace.TRACENA;</span>
<span class="nc" id="L1667">		double sum = Trace.TRACENA;</span>
<span class="nc" id="L1668">		int counter = 0;</span>
<span class="nc" id="L1669">		double dependTypeValSum = Trace.TRACENA;</span>
<span class="nc" id="L1670">		double lastValidBacklogBucketValue = Trace.TRACENA;</span>

<span class="nc bnc" id="L1672" title="All 2 branches missed.">		for (int i = 0; i &lt; sourceValues.length; i++) {</span>
<span class="nc bnc" id="L1673" title="All 6 branches missed.">			if (!Trace.isValidValue(sourceValues[i]) || (excPoints != null &amp;&amp; excPoints[i])) {</span>
				// only aggregate for points that are valid &amp;  should not be excluded
<span class="nc" id="L1675">				continue;</span>
			}
			//always increment for valid values.
<span class="nc" id="L1678">			counter++;</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">			sum = (sum == Trace.TRACENA ? 0 : sum) + sourceValues[i];</span>
<span class="nc bnc" id="L1680" title="All 2 branches missed.">			if (aggregationType.isWeightedAverage()) {</span>
<span class="nc" id="L1681">				int depValSum = Trace.TRACENA;</span>
<span class="nc bnc" id="L1682" title="All 2 branches missed.">				for (int j = 0; j &lt; dependentValueArrays.length; j++) {</span>
<span class="nc bnc" id="L1683" title="All 4 branches missed.">					if (dependentValueArrays[j] == null || dependentValueArrays[j].length &lt; i) {</span>
<span class="nc" id="L1684">						continue;</span>
					}
<span class="nc" id="L1686">					int dependentVal = dependentValueArrays[j][i];</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">					if (!Trace.isValidValue(dependentVal)) {</span>
<span class="nc" id="L1688">						continue;</span>
					}
<span class="nc bnc" id="L1690" title="All 8 branches missed.">					if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT ||</span>
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
						//Special condition for ASA ( has CV at j=0 and ABN at J=1)
<span class="nc" id="L1695">						int cv = dependentValueArrays[0][i];</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">						if (dependentValueArrays[1] != null) {</span>
							// If abandonment is available as a time series, it is used to
							// modify volume either by subtracting absolute numbers (abandonment
							// count) or by subtracting a percentage of volume (abandonment
							// percentage).
<span class="nc" id="L1701">							int abn = dependentValueArrays[1][i];</span>
<span class="nc bnc" id="L1702" title="All 4 branches missed.">							if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||</span>
									aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
								//Special condition for ASA where SUM (CV-ABN)*ASA/(SUM(CV-ABN)
<span class="nc bnc" id="L1705" title="All 4 branches missed.">								depValSum = (cv &lt; 0 || abn &lt; 0) ? Trace.TRACENA : cv * (100 - abn);</span>
							} else {
								//ESR#4232092: Abandons don't apply to Operations media, so the aggregation should only
								// weigh on CV when ABN is null.
<span class="nc bnc" id="L1709" title="All 2 branches missed.">								abn = (abn &lt; 0) ? 0 : abn;</span>
<span class="nc bnc" id="L1710" title="All 4 branches missed.">								depValSum = (cv &lt; 0 || abn &lt; 0) ? Trace.TRACENA : cv - abn;</span>
							}
<span class="nc" id="L1712">						} else {</span>
							// If abandonment is not available as a time series, it must be
							// constant across time and therefore does not influence weighting.
<span class="nc" id="L1715">							depValSum = cv;</span>
						}
						// Because ASA weighting is handled as a special case, we break out
						// of the summation loop with an explicitly computed weight sum.
<span class="nc" id="L1719">						break;</span>
					} else {
						//assign val if not already initialized else sum it
<span class="nc bnc" id="L1722" title="All 2 branches missed.">						depValSum = depValSum == Trace.TRACENA ? dependentVal : (depValSum + dependentVal);</span>
					}
				}
				//ignore values less than Zero
<span class="nc bnc" id="L1726" title="All 2 branches missed.">				if (depValSum &lt; 0) {</span>
<span class="nc" id="L1727">					continue;</span>
				}
<span class="nc bnc" id="L1729" title="All 2 branches missed.">				weightedSum = (weightedSum == Trace.TRACENA ? 0 : weightedSum) + (depValSum * sourceValues[i]);</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">				dependTypeValSum = (dependTypeValSum == Trace.TRACENA ? 0 : dependTypeValSum) + depValSum;</span>
<span class="nc bnc" id="L1731" title="All 2 branches missed.">			} else if (aggregationType == AggregationType.LAST_VALID_VALUE) {</span>
				// Finding the last block's value. In each iteration, this value will be
				// overwritten by the new valid value. This way, we will have the last valid
				// value at the end of the iteration. Doing this step as there could invalid
				// values towards the end and we need to identify the last valid value.
<span class="nc" id="L1736">				lastValidBacklogBucketValue = sourceValues[i];</span>
			}
		}

<span class="nc" id="L1740">		result = aggregateSum(sum, weightedSum, dependTypeValSum,</span>
				lastValidBacklogBucketValue, counter, aggregationType);

<span class="nc" id="L1743">		return result;</span>
	}

	/**
	 * Returns the aggregate value of the specified trace over the specified interval, with Double precision.
	 * &lt;p&gt;
	 * The result is not necessarily an integer.  If an integer value is desired
	 * use TraceUtil.roundDouble to round the value to an integer.
	 *
	 * @param TraceCube cube
	 * @param traceType the trace to aggregate within the cube
	 * @param begin interval start point
	 * @param end interval end point
	 * @return the aggregate value for the specified period.  This value is not necessarily integral.  If
	 * an integer value is desired use TraceUtil.roundDouble to round the value to an integer.
	 */
	public static double aggregatePeriodD(TraceCube cube, short traceType, int begin, int end) {
<span class="nc" id="L1760">		return aggregatePeriod(cube, traceType, begin, end);</span>
	}
	public static double aggregatePeriodD(TraceCube cube, short traceType, int end, boolean[] excPoints) {
<span class="nc" id="L1763">		return aggregatePeriod(cube, traceType, 0, end, excPoints);</span>
	}
	public static double aggregatePeriodD(TraceCube cube, short traceType, int begin, int end, boolean[] excPoints) {
<span class="nc bnc" id="L1766" title="All 2 branches missed.">		if (begin == end) {</span>
<span class="nc" id="L1767">			return cube.getTraceValueD(traceType, begin);</span>
		}
<span class="nc" id="L1769">		double[] valueArray = cube.getTraceValueD(traceType, begin, end);</span>
<span class="nc bnc" id="L1770" title="All 4 branches missed.">		if (valueArray == null || allNAPoints(valueArray)) {</span>
<span class="nc" id="L1771">			return Trace.TRACENA;</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">		} else if (allOFFPoints(valueArray)) {</span>
<span class="nc" id="L1773">			return Trace.TRACEOFF;</span>
		}
<span class="nc" id="L1775">		double[][] dependentValueArrays = null;</span>
<span class="nc" id="L1776">		short[] dependentTypeArray = null;</span>
<span class="nc" id="L1777">		AggregationType aggregationType = getAggregationTypeForTimeAggregation(traceType, cube.isRequiredData());</span>
<span class="nc bnc" id="L1778" title="All 2 branches missed.">		if (aggregationType.isWeightedAverage()) {</span>
			// TODO: replace this with actual call to get medias
<span class="nc" id="L1780">			HashMap&lt;ID,ID&gt; queueMediaMap = new HashMap&lt;ID,ID&gt;();</span>
<span class="nc" id="L1781">			dependentTypeArray = getDependentTypeForWeightedAvgForPeriod(traceType, queueMediaMap.get(cube.getQueueID()));</span>
<span class="nc" id="L1782">			dependentValueArrays = new double[dependentTypeArray.length][valueArray.length];</span>
<span class="nc bnc" id="L1783" title="All 2 branches missed.">			for (int j = 0; j &lt; dependentTypeArray.length; j++) {</span>
<span class="nc" id="L1784">				dependentValueArrays[j] = cube.getTraceValueD(dependentTypeArray[j], begin, end);</span>
			}
		}
<span class="nc" id="L1787">		double result = aggregateArrayD(valueArray, aggregationType, dependentValueArrays, excPoints);</span>
		//TODO: This sort of thing belongs in the client code, not in a foundational calculation.
		// The word &quot;display&quot; in a foundation calculation is something of a red flag.
		// Special handling for Staffing &amp; FTE,
		// We need to display hourly aggregation (instead of 15 min) after summation.
		// Sum(Staffing)/4; To obtain Hourly Staffing if valueArray.length &gt;= 4,else just valueArray.length
		// This code is affecting the scalePeriodTraceWithDistribution method.  Please see the comments in that
		// method to see how it is impacted.
<span class="nc bnc" id="L1795" title="All 12 branches missed.">		if (Trace.isValidValue(result)&amp;&amp;(traceType == Trace.FTE || traceType == Trace.STAFFING||traceType == Trace.AFTE</span>
				|| traceType == Trace.ASTAFFING || traceType== Trace.NETSTAFFING)){
<span class="nc bnc" id="L1797" title="All 2 branches missed.">			return result / (valueArray.length &gt; Trace.HOURPOINTS ? Trace.HOURPOINTS : valueArray.length);</span>
		}
<span class="nc" id="L1799">		return result;</span>
	}

	/**
	 * Performs the actual work of aggregation with Double precision.  This method could potentially be reused for
	 * combining queues as well.
	 *
	 * @param sourceValues
	 * @param aggregationType
	 * @param dependentValueArrays
	 * @param excPoints
	 * @return
	 */
	public static double aggregateArrayD(
			double[] sourceValues,
			AggregationType aggregationType,
			double[][] dependentValueArrays,
			boolean[] excPoints) {

<span class="nc" id="L1818">		double result = Trace.TRACENA;</span>
<span class="nc" id="L1819">		double weightedSum = Trace.TRACENA;</span>
<span class="nc" id="L1820">		double sum = Trace.TRACENA;</span>
		//Number of data values
<span class="nc" id="L1822">		int counter = 0;</span>
<span class="nc" id="L1823">		double dependTypeValSum = Trace.TRACENA;</span>
<span class="nc" id="L1824">		double lastValidBacklogBucketValue = Trace.TRACENA;</span>

<span class="nc bnc" id="L1826" title="All 2 branches missed.">		for (int i = 0; i &lt; sourceValues.length; i++) {</span>
<span class="nc bnc" id="L1827" title="All 6 branches missed.">			if (!Trace.isValidValue(sourceValues[i]) || (excPoints != null &amp;&amp; excPoints[i])) {</span>
				// only aggregate for points that are valid &amp;  should not be excluded
<span class="nc" id="L1829">				continue;</span>
			}
			// always increment for valid values.
<span class="nc" id="L1832">			counter++;</span>
<span class="nc bnc" id="L1833" title="All 2 branches missed.">			sum = (sum == Trace.TRACENA ? 0 : sum) + sourceValues[i];</span>
<span class="nc bnc" id="L1834" title="All 2 branches missed.">			if (aggregationType.isWeightedAverage()) {</span>
<span class="nc" id="L1835">				double depValSum = Trace.TRACENA;</span>
<span class="nc bnc" id="L1836" title="All 2 branches missed.">				for (int j = 0; j &lt; dependentValueArrays.length; j++) {</span>
<span class="nc bnc" id="L1837" title="All 4 branches missed.">					if (dependentValueArrays[j] == null || dependentValueArrays[j].length &lt; i) {</span>
<span class="nc" id="L1838">						continue;</span>
					}
<span class="nc" id="L1840">					double dependentVal = dependentValueArrays[j][i];</span>
<span class="nc bnc" id="L1841" title="All 2 branches missed.">					if (!Trace.isValidValue(dependentVal)) {</span>
<span class="nc" id="L1842">						continue;</span>
					}
<span class="nc bnc" id="L1844" title="All 8 branches missed.">					if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT ||</span>
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||
							aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
						//Special condition for ASA ( has CV at j=0 and ABN at J=1)
<span class="nc" id="L1849">						double cv = dependentValueArrays[0][i];</span>
<span class="nc bnc" id="L1850" title="All 4 branches missed.">						if (dependentValueArrays.length &gt; 1 &amp;&amp; dependentValueArrays[1] != null) {</span>
							// If abandonment is available as a time series, it is used to
							// modify volume either by subtracting absolute numbers (abandonment
							// count) or by subtracting a percentage of volume (abandonment
							// percentage).
<span class="nc" id="L1855">							double abn = dependentValueArrays[1][i];</span>
<span class="nc bnc" id="L1856" title="All 4 branches missed.">							if (aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||</span>
									aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
								//Special condition for ASA where SUM (CV-ABN)*ASA/(SUM(CV-ABN)
<span class="nc bnc" id="L1859" title="All 4 branches missed.">								depValSum = (cv &lt; 0 || abn &lt; 0) ? Trace.TRACENA : cv * (100.0d - abn);</span>
							} else {
								//ESR#4232092: Abandons don't apply to Operations media, so the aggregation should only
								// weigh on CV when ABN is null.
<span class="nc bnc" id="L1863" title="All 2 branches missed.">								abn = (abn &lt; 0) ? 0 : abn;</span>
<span class="nc bnc" id="L1864" title="All 4 branches missed.">								depValSum = (cv &lt; 0 || abn &lt; 0) ? Trace.TRACENA : cv - abn;</span>
							}
<span class="nc" id="L1866">						} else {</span>
							// If abandonment is not available as a time series, it must be
							// constant across time and therefore does not influence weighting.
<span class="nc" id="L1869">							depValSum = cv;</span>
						}
						// Because ASA weighting is handled as a special case, we break out
						// of the summation loop with an explicitly computed weight sum.
<span class="nc" id="L1873">						break;</span>
					} else {
						//assign val if not already initialized else sum it
<span class="nc bnc" id="L1876" title="All 2 branches missed.">						depValSum = depValSum == Trace.TRACENA ? dependentVal : (depValSum + dependentVal);</span>
					}
				}
				//ignore values less than Zero
<span class="nc bnc" id="L1880" title="All 2 branches missed.">				if (depValSum &lt; 0) {</span>
<span class="nc" id="L1881">					continue;</span>
				}
<span class="nc bnc" id="L1883" title="All 2 branches missed.">				weightedSum = (weightedSum == Trace.TRACENA ? 0.0d : weightedSum) + (depValSum * sourceValues[i]);</span>
<span class="nc bnc" id="L1884" title="All 2 branches missed.">				dependTypeValSum = (dependTypeValSum == Trace.TRACENA ? 0.0d : dependTypeValSum) + depValSum;</span>
<span class="nc bnc" id="L1885" title="All 2 branches missed.">			} else if (aggregationType == AggregationType.LAST_VALID_VALUE) {</span>
				// Finding the last block's value. In each iteration, this value will be
				// overwritten by the new valid value. This way, we will have the last valid
				// value at the end of the iteration. Doing this step as there could invalid
				// values towards the end and we need to identify the last valid value.
<span class="nc" id="L1890">				lastValidBacklogBucketValue = sourceValues[i];</span>
			}
		}

<span class="nc" id="L1894">		result = aggregateSum(sum, weightedSum, dependTypeValSum, lastValidBacklogBucketValue, counter, aggregationType);</span>

<span class="nc" id="L1896">		return result;</span>
	}

	private static double aggregateSum(double sum, double weightedSum, double dependTypeValSum,
									   double lastValidBacklogBucketValue,
									   int counter, TraceOperator.AggregationType aggregationType) {
<span class="nc" id="L1902">		double result = Trace.TRACENA;</span>

<span class="nc bnc" id="L1904" title="All 6 branches missed.">		switch (aggregationType) {</span>
			case SUM:
<span class="nc" id="L1906">				result = sum;</span>
<span class="nc" id="L1907">				break;</span>
			case SIMPLE_AVERAGE:
<span class="nc bnc" id="L1909" title="All 2 branches missed.">				if (counter &gt; 0) {</span>
<span class="nc" id="L1910">					result = sum / counter;</span>
				}
				break;
			case WEIGHTED_AVERAGE:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT:
<span class="nc bnc" id="L1916" title="All 4 branches missed.">				if (weightedSum &gt;= 0 &amp;&amp; dependTypeValSum &gt; 0) {</span>
<span class="nc" id="L1917">					result = weightedSum / dependTypeValSum;</span>
<span class="nc bnc" id="L1918" title="All 4 branches missed.">				} else if (weightedSum == 0 &amp;&amp; dependTypeValSum == 0) {</span>
<span class="nc" id="L1919">					result = 0;</span>
				}
				break;
			case WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
<span class="nc bnc" id="L1925" title="All 2 branches missed.">				if (weightedSum &gt;= 0) {</span>
<span class="nc bnc" id="L1926" title="All 2 branches missed.">					if (dependTypeValSum &gt; 0) {</span>
<span class="nc" id="L1927">						result = weightedSum / dependTypeValSum;</span>
					} else {
<span class="nc" id="L1929">						result = sum / counter;</span>
					}
				}
				break;
			case LAST_VALID_VALUE:
<span class="nc" id="L1934">				result = lastValidBacklogBucketValue;</span>
<span class="nc" id="L1935">				break;</span>
			default:
<span class="nc" id="L1937">				return result;</span>
		}
<span class="nc" id="L1939">		return result;</span>
	}

	/**
	 * Averages an array of data assumed to be specified at 15-minute intervals to
	 * the specified granularity.
	 * &lt;p&gt;
	 * If {@code granularity} is 15 minutes, the input array is returned.
	 * Otherwise, a new array is returned having the same number of data
	 * points as the input array, with each point duplicated at each 15-minute interval
	 * within the specified granularity.  The specified granularity must be a multiple
	 * of 15 minutes.
	 * &lt;p&gt;
	 * The interval covered by the source array doesn't have to be an even multiple of
	 * the granularity but if it is not then it is assumed that the first element of the
	 * array is aligned with the start of an aggregation interval.
	 * 
	 * @param sourceValues
	 * @return
	 */
	public static double[] averageArrayWithGranularity(double[] sourceValues, Duration granularity) {
<span class="nc bnc" id="L1960" title="All 2 branches missed.">		if (granularity.getDurationInMinutes() == 15) {</span>
<span class="nc" id="L1961">			return sourceValues;</span>
		}
<span class="nc bnc" id="L1963" title="All 2 branches missed.">		if (granularity.getDurationInMinutes() % 15 != 0) {</span>
<span class="nc" id="L1964">			throw new IllegalArgumentException(&quot;Granularity must be a multiple of 15 minutes: &quot; + granularity);</span>
		}
<span class="nc" id="L1966">		double[] result = new double[sourceValues.length];</span>
<span class="nc" id="L1967">		int valuesPerInterval = granularity.getDurationInMinutes() / 15;</span>

<span class="nc bnc" id="L1969" title="All 2 branches missed.">		for (int intervalBase = 0; intervalBase &lt; sourceValues.length; intervalBase += valuesPerInterval) {</span>
<span class="nc" id="L1970">			double cumulativeValue = 0;</span>
<span class="nc" id="L1971">			int intervalOffset = 0;</span>
<span class="nc bnc" id="L1972" title="All 4 branches missed.">			for (intervalOffset = 0; intervalOffset &lt; valuesPerInterval &amp;&amp; intervalBase + intervalOffset &lt; sourceValues.length; intervalOffset++) {</span>
<span class="nc" id="L1973">				cumulativeValue += sourceValues[intervalBase + intervalOffset];</span>
			}
			// intervalOffset will be less than valuesPerInterval if the length of
			// sourceValues isn't an even multiple of valuesPerInterval.
<span class="nc" id="L1977">			cumulativeValue /= intervalOffset;</span>
<span class="nc bnc" id="L1978" title="All 4 branches missed.">			for (intervalOffset = 0; intervalOffset &lt; valuesPerInterval &amp;&amp; intervalBase + intervalOffset &lt; sourceValues.length; intervalOffset++) {</span>
<span class="nc" id="L1979">				result[intervalBase + intervalOffset] = cumulativeValue;</span>
			}
		}
<span class="nc" id="L1982">		return result;</span>
	}

	/**
	 * Distributes data from the parent cube to the child cubes according to the specified
	 * percentage weights.  All of the specified trace types are allocated independently
	 * of each other.
	 * &lt;p&gt;
	 * It is required that all the trace cubes have the same raw start date.
	 * TODO: Check correct handling of children from different time zones.
	 * 
	 * @param parentCube the source data to be allocated among the child cubes
	 * @param childCubes a map from each child spQueueId to the destination cube to receive
	 * the allocated data
	 * @param typesToAllocate the trace types to be allocated.  Existing child data for
	 * other trace types will be unaffected.
	 * @param allocationPercentageWeights a map from child spQueueId to weight array; the weights to
	 * apply to the data, represented as time series data.  Each weight should be a 
	 * double-precision value between 0.0 and 100.0.
	 * The sum of all weights for a given array index should be 100.0.
	 * It is the responsibility of the client code to ensure that allocation weights 
	 * are valid.
	 */
	public static void distributeParentToChildren(TraceCube parentCube, Map&lt;ID, TraceCube&gt; childCubes, short[] typesToAllocate, Map&lt;ID, double[]&gt; allocationPercentageWeights)
			throws BbmTimeSeriesException {
<span class="nc bnc" id="L2007" title="All 2 branches missed.">		for (ID childId : childCubes.keySet()) {</span>
<span class="nc" id="L2008">			TraceCube childCube = childCubes.get(childId);</span>
<span class="nc bnc" id="L2009" title="All 2 branches missed.">			if ( ! childCube.getRawStartDate().equals(parentCube.getRawStartDate())) {</span>
<span class="nc" id="L2010">				throw new IllegalArgumentException(&quot;Parent and child cube do not have the same raw start date.&quot;);</span>
			}
<span class="nc" id="L2012">		}</span>
		// Ensure that the child queues have a well-defined sequence.
<span class="nc" id="L2014">		List&lt;ID&gt; childIdList = new ArrayList&lt;ID&gt;(childCubes.keySet());</span>
<span class="nc bnc" id="L2015" title="All 2 branches missed.">		for (short traceType : typesToAllocate) {</span>
<span class="nc" id="L2016">			int parentStartOffset = parentCube.getRawStartOffset();</span>
<span class="nc" id="L2017">			TraceCube parentCopy = parentCube.cloneTraceCube();</span>
<span class="nc" id="L2018">			parentCopy.setTraceValue(traceType, parentCube.getTraceValueD(traceType));</span>
<span class="nc" id="L2019">			TraceDistributionBuilder childTargetDistributionBuilder = new TraceDistributionBuilder(AggregationType.SUM, Trace.getTraceConstraints(traceType, parentCube.isRequiredData()));</span>
<span class="nc" id="L2020">			int totalAggregate = 0;</span>
			// We use carry-over rounding when determining child aggregate values so
			// that we can be sure the total of the children is the same as the given
			// total volume.
<span class="nc" id="L2024">			double childTargetAccumulator = 0.5;</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">			for (int childIndex = 0; childIndex &lt; childIdList.size(); ++childIndex) {</span>
<span class="nc" id="L2026">				ID childId = childIdList.get(childIndex);</span>
<span class="nc" id="L2027">				TraceCube childCube = childCubes.get(childId);</span>
<span class="nc bnc" id="L2028" title="All 2 branches missed.">				for (int parentOffset = parentStartOffset, weightOffset = 0; parentOffset &lt;= parentCube.getRawEndOffset(); ++parentOffset, ++weightOffset) {</span>
<span class="nc" id="L2029">					int childOffset = parentOffset - parentStartOffset + childCube.getRawStartOffset();</span>
<span class="nc bnc" id="L2030" title="All 2 branches missed.">					if (childOffset &gt;= childCube.getRawStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">						childOffset &lt;= childCube.getRawEndOffset() &amp;&amp;</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">						parentCube.getTraceValueD(traceType, parentOffset) &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L2033" title="All 2 branches missed.">						allocationPercentageWeights.get(childId)[weightOffset] &gt;= 0) {</span>
<span class="nc" id="L2034">						childTargetAccumulator += parentCube.getTraceValueD(traceType, parentOffset) * allocationPercentageWeights.get(childId)[weightOffset] / 100.;</span>
					}
				}
<span class="nc" id="L2037">				int childTarget = (int)childTargetAccumulator;</span>
<span class="nc" id="L2038">				childTargetAccumulator %= 1.0;</span>
<span class="nc" id="L2039">				childTargetDistributionBuilder.addValue(childTarget, null, childIndex);</span>
<span class="nc" id="L2040">				totalAggregate += childTarget;</span>
			}
<span class="nc" id="L2042">			double[] residualWeights = new double[allocationPercentageWeights.get(childIdList.get(0)).length];</span>
			// To start with, every point in time has 100% of the parent volume left to allocate.
			// As each point in each child queue is allocated, the residual weight for that
			// point will be decreased by that child's weight at that point.  This allows us
			// to scale the remaining parent volume correctly.
			//Arrays.fill(residualWeights, 100.);
			// Whoops!  Since some sources are rounding allocation percentages to 2 digits to the
			// right of the decimal we can't just rely on total percentage eqaualing 100; we have
			// to calculate total percentage as the sum of the weights or else we get rounding
			// errors.
<span class="nc bnc" id="L2052" title="All 2 branches missed.">			for (int childIndex = 0; childIndex &lt; childIdList.size(); ++childIndex) {</span>
<span class="nc" id="L2053">				ID childId = childIdList.get(childIndex);</span>
<span class="nc" id="L2054">				double[] childWeights = allocationPercentageWeights.get(childId);</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">				for (int weightOffset = 0; weightOffset &lt; childWeights.length; ++weightOffset) {</span>
<span class="nc bnc" id="L2056" title="All 2 branches missed.">					if (childWeights[weightOffset] &gt; 0) {</span>
<span class="nc" id="L2057">						residualWeights[weightOffset] += childWeights[weightOffset];</span>
					}
				}
			}
<span class="nc" id="L2061">			int[] childTargets = childTargetDistributionBuilder.getTraceDistribution().getScaledIntegerValues(totalAggregate);</span>
<span class="nc bnc" id="L2062" title="All 2 branches missed.">			for (int childIndex = 0; childIndex &lt; childIdList.size(); ++childIndex) {</span>
<span class="nc" id="L2063">				ID childId = childIdList.get(childIndex);</span>
<span class="nc" id="L2064">				TraceCube childCube = childCubes.get(childId);</span>
<span class="nc" id="L2065">				double[] childWeights = allocationPercentageWeights.get(childId);</span>
				// For each child trace we build a distribution over time.
<span class="nc" id="L2067">				TraceDistributionBuilder childTraceDistributionBuilder = new TraceDistributionBuilder(AggregationType.SUM, Trace.getTraceConstraints(traceType, parentCube.isRequiredData()));</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">				for (int parentOffset = parentStartOffset, weightOffset = 0; parentOffset &lt;= parentCube.getRawEndOffset(); ++parentOffset, ++weightOffset) {</span>
<span class="nc" id="L2069">					int childOffset = parentOffset - parentStartOffset + childCube.getRawStartOffset();</span>
					// It only makes sense to allocate when we are currently within the child 
					// cube bounds and the current weight is nonnegative.
<span class="nc bnc" id="L2072" title="All 2 branches missed.">					if (childOffset &gt;= childCube.getRawStartOffset() &amp;&amp;</span>
<span class="nc bnc" id="L2073" title="All 4 branches missed.">						childOffset &lt;= childCube.getRawEndOffset() &amp;&amp;</span>
						childWeights[weightOffset] &gt;= 0 &amp;&amp;
<span class="nc bnc" id="L2075" title="All 2 branches missed.">						parentCopy.getTraceValueD(traceType, parentOffset) &gt;= 0) {</span>

						// Each point in the distribution is based on the remaining parent volume to
						// allocate at that interval and the interval's child weight as a proportion
						// of the remaining weight to allocate at the interval.
<span class="nc bnc" id="L2080" title="All 2 branches missed.">						if (childWeights[weightOffset] &gt; 0) {</span>
<span class="nc" id="L2081">							childTraceDistributionBuilder.addValue(</span>
<span class="nc" id="L2082">									parentCopy.getTraceValueD(traceType, parentOffset)</span>
										* childWeights[weightOffset]
										/ residualWeights[weightOffset],
									false,
									0);
<span class="nc" id="L2087">							residualWeights[weightOffset] -= childWeights[weightOffset];</span>
						} else {
<span class="nc" id="L2089">							childTraceDistributionBuilder.addValue(0, false, 0);</span>
						}
					} else {
<span class="nc bnc" id="L2092" title="All 2 branches missed.">						if (childWeights[weightOffset] &lt; 0) {</span>
<span class="nc" id="L2093">							childTraceDistributionBuilder.addValue(childWeights[weightOffset], false, 0);</span>
						} else {
<span class="nc" id="L2095">							childTraceDistributionBuilder.addValue(Trace.TRACENA, false, 0);</span>
						}
					}
				}
<span class="nc" id="L2099">				childCube.setTraceValue(</span>
						traceType,
<span class="nc" id="L2101">						childTraceDistributionBuilder.getTraceDistribution().getScaledIntegerValues(childTargets[childIndex]),</span>
<span class="nc" id="L2102">						childCube.getRawStartOffset());</span>
				// Child weights were subtracted piecemeal inside the loop; here we subtract
				// the child volume all at once.
<span class="nc" id="L2105">				subtractTrace(parentCopy, childCube, traceType, parentStartOffset, parentCube.getRawEndOffset(), childCube.getRawStartOffset());</span>
			}
		}
<span class="nc" id="L2108">	}</span>
	
	/**
	 * Sets TRACEOFF for each data point in an off hour
	 * @param tc
	 * @param hoo
	 * 
	 * @throws OpenHoursMissingException if there is a day in {@code tc} for which
	 * there are no open hours defined in {@code hooCol}
	 */
	public static void setOffHours(TraceCube tc, TimeZone tz, Collection&lt;? extends HOOAssignment&gt; hooCol) {
<span class="nc" id="L2119">		setOffHours(tc.getTraceTypes(), tc, tz, hooCol);</span>
<span class="nc" id="L2120">	}</span>
	
	/**
	 * Sets TRACEOFF for each data point in an off hour
	 * @param tc
	 * @param hoo
	 *
	 * @throws OpenHoursMissingException if there is a day in {@code tc} for which
	 * there are no open hours defined in {@code hooCol}
	 */
	public static void setOffHours(short[] types, TraceCube tc, TimeZone tz, Collection&lt;? extends HOOAssignment&gt; hooCol)
			throws OpenHoursMissingException {
		//FIXME:  This code shouldn't depend on time zone at all.  HOOs are defined in terms
		// of minutes after the start of the SP, which is independent of time zone.
<span class="nc" id="L2134">		Date start = tc.getRawStartDate();</span>
<span class="nc" id="L2135">		Date end = tc.getRawEndDate();</span>
<span class="nc" id="L2136">		ZonedDateTime dayBoundaryCursorCal = ZonedDateTime.ofInstant(start.toInstant(), tz.toZoneId());</span>
<span class="nc" id="L2137">		ZonedDateTime nextDayCal = ZonedDateTime.ofInstant(start.toInstant(), tz.toZoneId());</span>
<span class="nc" id="L2138">		nextDayCal = nextDayCal.plusDays(1);</span>
<span class="nc" id="L2139">		ZonedDateTime timeCursorCal = ZonedDateTime.ofInstant(start.toInstant(), tz.toZoneId());</span>
<span class="nc" id="L2140">		HOOAssignment currentHOO = null;</span>
<span class="nc bnc" id="L2141" title="All 2 branches missed.">		while (timeCursorCal.toInstant().isBefore(end.toInstant())) {</span>
<span class="nc" id="L2142">			Date timeCursor = Date.from(timeCursorCal.toInstant());</span>
			// Find Current HOO
<span class="nc bnc" id="L2144" title="All 2 branches missed.">			if (currentHOO == null</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">					|| currentHOO.getStartTime().after(timeCursor) </span>
<span class="nc bnc" id="L2146" title="All 2 branches missed.">					|| ! currentHOO.getEndTime().after(timeCursor)) {</span>
<span class="nc" id="L2147">				boolean found = false;</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">				for (HOOAssignment hoo : hooCol) {</span>
					// if timeCursor falls in the interval [getStartTime, getEndTime)...
<span class="nc bnc" id="L2150" title="All 4 branches missed.">					if (!timeCursor.before(hoo.getStartTime()) &amp;&amp; timeCursor.before(hoo.getEndTime())) {</span>
						// ...then we have found the correct HOO object.
<span class="nc" id="L2152">						currentHOO = hoo;</span>
<span class="nc" id="L2153">						found = true;</span>
<span class="nc" id="L2154">						break;</span>
					}
<span class="nc" id="L2156">				}</span>
<span class="nc bnc" id="L2157" title="All 2 branches missed.">				if (!found) {</span>
<span class="nc" id="L2158">					throw new OpenHoursMissingException(&quot;HOO not specified for date: &quot; + timeCursor, timeCursor);</span>
				}
			}

<span class="nc bnc" id="L2162" title="All 2 branches missed.">			if (!Date.from(nextDayCal.toInstant()).after(timeCursor)) {</span>
<span class="nc" id="L2163">				dayBoundaryCursorCal = nextDayCal;</span>
<span class="nc" id="L2164">				nextDayCal = nextDayCal.plusDays(1);</span>
			}

<span class="nc" id="L2167">			Date open = currentHOO.getDayOpen(Date.from(dayBoundaryCursorCal.toInstant()), tz);</span>
<span class="nc" id="L2168">			Date close = currentHOO.getDayClose(Date.from(dayBoundaryCursorCal.toInstant()), tz);</span>
<span class="nc" id="L2169">			Date nextOpen = currentHOO.getDayOpen(Date.from(nextDayCal.toInstant()), tz);</span>
<span class="nc" id="L2170">			Date nextClose = currentHOO.getDayClose(Date.from(nextDayCal.toInstant()), tz);</span>
<span class="nc" id="L2171">			boolean withinTodaysHOOs = isTimeCursorWithinHOO(timeCursor, open, close);</span>
<span class="nc" id="L2172">			boolean withinTomorrowsHOOs = isTimeCursorWithinHOO(timeCursor, nextOpen, nextClose);</span>

<span class="nc bnc" id="L2174" title="All 4 branches missed.">			if (!withinTodaysHOOs &amp;&amp; !withinTomorrowsHOOs) {</span>
<span class="nc bnc" id="L2175" title="All 2 branches missed.">				for (short type : types) {</span>
<span class="nc" id="L2176">					boolean isDirty = tc.isDirty(type);</span>
<span class="nc" id="L2177">					tc.setTraceValue(type, Trace.TRACEOFF, timeCursor, true);</span>
					//This is done here because setting the off hours
					//  has the unfortunate side effect of setting the dirty flag.  So,
					//  we will clear out the dirty flag caused by this change unless
					//  the cube was already dirty beforehand.
<span class="nc bnc" id="L2182" title="All 2 branches missed.">					if (!isDirty) {</span>
<span class="nc" id="L2183">						tc.setTypeDirty(type, false);</span>
					}
				}
			}

<span class="nc" id="L2188">			timeCursorCal = timeCursorCal.plusMinutes(Trace.INTERVAL);</span>
<span class="nc" id="L2189">		}</span>
<span class="nc" id="L2190">	}</span>

	private static boolean isTimeCursorWithinHOO(Date timeCursor, Date hooOpen, Date hooClose) {
<span class="nc bnc" id="L2193" title="All 8 branches missed.">		return hooOpen != null &amp;&amp; hooClose != null &amp;&amp; !timeCursor.before(hooOpen) &amp;&amp; timeCursor.before(hooClose);</span>
	}

	/**
	 * Applies the specified hours of operation to the given array of {@code double} values, by
	 * setting every value that falls outside the hours of operation to Trace.TRACEOFF.
	 * &lt;p&gt;
	 * This method is needed because {@link TraceCube}s don't support floating-point data, but
	 * there exists time-based data that is floating point and must adhere to hours of
	 * operation.
	 * &lt;p&gt;
	 * Except that now TraceCubes *do* support floating-point data.  But now it turns out that
	 * the time interval aggregation strategy required for the forecast allocation percentages
	 * that make up this floating point data is very unlikely to be supported in TraceCubes
	 * any time soon.
	 * 
	 * @param values the values to which hours of operation are to be applied
	 * @param queueId the queue ID associated with the values.  Only used to create
	 * a dummy {@link TraceCube} so not especially critical
	 * @param startDate the time corresponding to the first element of {@code values}
	 * @param endDate the time immediately after the last element of {@code values}
	 * @param tz the time zone in which dates are to be interpreted
	 * @param childHoo the hours of operation to be applied
	 * 
	 * @throws OpenHoursMissingException if there is a day in {@code tc} for which
	 * there are no open hours defined in {@code hooCol}
	 */
	public static void setOffHours(
			double[] values,
			ID queueId,
			Date startDate,
			Date endDate,
			TimeZone tz,
			Collection&lt;? extends HOOAssignment&gt; childHoo) {
		try {
<span class="nc" id="L2228">			short[] types =  new short[] { Trace.CV };</span>
<span class="nc" id="L2229">			ForecastTraceCube dummyCube = new ForecastTraceCube(queueId, startDate, endDate, types);</span>
<span class="nc" id="L2230">			double[] hooValues = new double[values.length];</span>
<span class="nc" id="L2231">			Arrays.fill(hooValues, 0);</span>
<span class="nc" id="L2232">			dummyCube.setTraceValue(Trace.CV, hooValues);</span>
			// Get TraceOperator to set HOOs on a dummy trace cube, then transcribe the
			// results into the given array.
<span class="nc" id="L2235">			TraceOperator.setOffHours(types, dummyCube, tz, childHoo);</span>
			// Unnecessary but inexpensive the way trace operations are done now.  Would be
			// necessary (and more expensive) if trace cubes did defensive copying.
<span class="nc" id="L2238">			hooValues = dummyCube.getTraceValueD(Trace.CV);</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">			for (int index = 0; index &lt; hooValues.length; ++index) {</span>
<span class="nc bnc" id="L2240" title="All 2 branches missed.">				if (hooValues[index] == Trace.TRACEOFF) {</span>
<span class="nc" id="L2241">					values[index] = Trace.TRACEOFF;</span>
				}
			}
<span class="nc" id="L2244">		} catch (BbmTimeSeriesException btse) {</span>
			// This exception can only originate from the constructor for ForecastTraceCube,
			// and only if ForecastTraceCube stops supporting the CV trace type.
<span class="nc" id="L2247">		}</span>
<span class="nc" id="L2248">	}</span>

	public static TimeRange[] getWeeklyRanges(TimeZone tz, Date startDate, Date endDate) {
<span class="nc" id="L2251">		TimeRange[] weekRanges = null;</span>
<span class="nc" id="L2252">		Date weekEndDate = null;</span>
<span class="nc" id="L2253">		ArrayList&lt;TimeRange&gt; aWeekRanges = new ArrayList&lt;TimeRange&gt;();</span>
		//Must use campaign TZ to determine SP weeks. The week ranges are not affected by the viewing TimeZone.
<span class="nc" id="L2255">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L2256">		Date nextStartDate = startDate;</span>
<span class="nc" id="L2257">		cal.setTime(startDate);</span>
<span class="nc" id="L2258">		int startHour = cal.get(Calendar.HOUR_OF_DAY);</span>

		do {
<span class="nc" id="L2261">			Date thisStartDate = nextStartDate;</span>
<span class="nc" id="L2262">			cal.setTime(thisStartDate);</span>
<span class="nc" id="L2263">			cal.add(Calendar.DATE, 7);</span>

			//If day boundary is 2AM, on Spring DST day, adding a week to 2AM start date will
			//result in end date at 1AM instead of 3AM. We must manually correct for this.
<span class="nc bnc" id="L2267" title="All 2 branches missed.">			if (cal.get(Calendar.HOUR_OF_DAY) &lt; startHour) {</span>
<span class="nc" id="L2268">				cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc bnc" id="L2269" title="All 2 branches missed.">			} else if (cal.get(Calendar.HOUR_OF_DAY) &gt; startHour) {</span>
				//undo our hour addition for the following week
<span class="nc" id="L2271">				cal.add(Calendar.HOUR_OF_DAY, -1);</span>
			}

<span class="nc" id="L2274">			nextStartDate = cal.getTime();</span>
<span class="nc" id="L2275">			cal.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L2276">			weekEndDate = cal.getTime();</span>
<span class="nc" id="L2277">			aWeekRanges.add(new TimeRange(thisStartDate, weekEndDate));</span>
<span class="nc bnc" id="L2278" title="All 2 branches missed.">		} while (nextStartDate.before(endDate));</span>

<span class="nc bnc" id="L2280" title="All 2 branches missed.">		if (aWeekRanges != null) {</span>
<span class="nc" id="L2281">			int numWeeks = aWeekRanges.size();</span>
<span class="nc" id="L2282">			weekRanges = new TimeRange[numWeeks];</span>
<span class="nc" id="L2283">			int w = 0;</span>
<span class="nc bnc" id="L2284" title="All 2 branches missed.">			for (Iterator&lt;TimeRange&gt; it = aWeekRanges.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2285">				TimeRange curWeek = it.next();</span>
<span class="nc" id="L2286">				weekRanges[w] = curWeek;</span>
<span class="nc" id="L2287">				w++;</span>
<span class="nc" id="L2288">			}</span>
		}
<span class="nc" id="L2290">		return weekRanges;</span>
	}
	
	/**
	 * Returns a cube that consists of data that is concatenated from the cubes in traceCubesToConcatenate.
	 * It is assumed that the cubes in traceCubesToConcatenate all have the same trace types.
	 * It is assumed that the TraceCubes being handed in are all adjacent to one another.
	 * The date range of the returned TraceCube will be the earliest raw start date and latest
	 * raw end date of the trace cubes in traceCubesToConcatenate.
	 */
	public static TraceCube concatenateTraceCubes(Collection&lt;TraceCube&gt; traceCubesToConcatenate)
			throws BbmTimeSeriesException {

<span class="nc bnc" id="L2303" title="All 4 branches missed.">		if (traceCubesToConcatenate == null || traceCubesToConcatenate.isEmpty()) {</span>
<span class="nc" id="L2304">			return null;</span>
		}
		
<span class="nc" id="L2307">		Date earliestStartDate = null;</span>
<span class="nc" id="L2308">		Date latestEndDate = null;</span>
<span class="nc" id="L2309">		TraceCube retVal = null;</span>

		//Find the earliest start / latest end dates for the cube collection.  These dates will
		//correspond to the start/end dates of the concatenated cube that will be returned
<span class="nc bnc" id="L2313" title="All 2 branches missed.">		for (TraceCube cube : traceCubesToConcatenate) {</span>
<span class="nc bnc" id="L2314" title="All 2 branches missed.">			if (earliestStartDate == null) {</span>
<span class="nc" id="L2315">				earliestStartDate = cube.getRawStartDate();</span>
			}
<span class="nc bnc" id="L2317" title="All 2 branches missed.">			if (latestEndDate == null) {</span>
<span class="nc" id="L2318">				latestEndDate = cube.getRawEndDate();</span>
			}
<span class="nc bnc" id="L2320" title="All 2 branches missed.">			if (cube.getRawStartDate().before(earliestStartDate)) {</span>
<span class="nc" id="L2321">				earliestStartDate = cube.getRawStartDate();</span>
			}
<span class="nc bnc" id="L2323" title="All 2 branches missed.">			if (cube.getRawEndDate().after(latestEndDate)) {</span>
<span class="nc" id="L2324">				latestEndDate = cube.getRawEndDate();</span>
			}
<span class="nc" id="L2326">		}</span>

		//Sort the trace cubes chronologically before concatenating
<span class="nc" id="L2329">		List&lt;TraceCube&gt; sortedTraceCubesToConcatenate = new ArrayList&lt;TraceCube&gt;(traceCubesToConcatenate);</span>
<span class="nc" id="L2330">		Collections.sort(sortedTraceCubesToConcatenate, new TraceCubeRawStartDateComparator());</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">		for (TraceCube cube : sortedTraceCubesToConcatenate) {</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">			if (cube != null) {</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">				if (retVal == null) {</span>
<span class="nc" id="L2334">					retVal = cube.newInstance(cube.getQueueID(), earliestStartDate,</span>
<span class="nc" id="L2335">							latestEndDate, cube.getTraceTypes());</span>
				}

				// We rely on cube to have accurate information about its populated trace types.
<span class="nc bnc" id="L2339" title="All 2 branches missed.">				for (short traceType : cube.getTraceTypes()) {</span>
<span class="nc bnc" id="L2340" title="All 2 branches missed.">					if (cube.getTraceValueD(traceType) != null) {</span>
<span class="nc" id="L2341">						retVal.setTraceValue(traceType, cube.getTraceValueD(traceType), cube.getRawStartDate());</span>
					}
				}
			}
<span class="nc" id="L2345">		}</span>

<span class="nc" id="L2347">		return retVal;</span>
	}
	
	/**
	 * Comparator used to sort TraceCubes chronologically by their RawStartDates.
	 */
<span class="nc" id="L2353">	private static class TraceCubeRawStartDateComparator implements Comparator&lt;TraceCube&gt; {</span>
		@Override
		public int compare(TraceCube o1, TraceCube o2) {
<span class="nc bnc" id="L2356" title="All 8 branches missed.">			if ((o1 == null || o1.getRawStartDate() == null) &amp;&amp; (o2 == null || o2.getRawStartDate() == null)) {</span>
<span class="nc" id="L2357">				return 0;</span>
			}
<span class="nc bnc" id="L2359" title="All 8 branches missed.">			if ((o1 == null || o1.getRawStartDate() == null) &amp;&amp; (o2 != null &amp;&amp; o2.getRawStartDate() != null)) {</span>
<span class="nc" id="L2360">				return -1;</span>
			}
<span class="nc bnc" id="L2362" title="All 8 branches missed.">			if ((o2 == null || o2.getRawStartDate() == null) &amp;&amp; (o1 != null &amp;&amp; o1.getRawStartDate() != null)) {</span>
<span class="nc" id="L2363">				return 1;</span>
			}
<span class="nc bnc" id="L2365" title="All 2 branches missed.">			if (o1.getRawStartDate().after(o2.getRawStartDate())) {</span>
<span class="nc" id="L2366">				return 1;</span>
			}
<span class="nc bnc" id="L2368" title="All 2 branches missed.">			if (o1.getRawStartDate().equals(o2.getRawStartDate())) {</span>
<span class="nc" id="L2369">				return 0;</span>
			}
<span class="nc" id="L2371">			return -1;</span>
		}
	}

	/**
	 * This enum captures the different kinds of aggregation.
	 * 
	 * It could be expanded to provide the actual business logic for these aggregation types.
	 */
<span class="nc" id="L2380">	public static enum AggregationType {</span>
		/** Adds constituent values together. */
<span class="nc" id="L2382">		SUM(true, true, true, false, false),</span>
		/** Averages constituent values without weighting. */
<span class="nc" id="L2384">		SIMPLE_AVERAGE(true, true, true, false, false),</span>
		/** Averages constituent values without weighting, but we exclude and 0 values from the average. */
<span class="nc" id="L2386">		SIMPLE_AVERAGE_EXCLUDE_ZEROS(true, true, true, false, false),</span>
		/** Averages constituent values using another trace type to weight each value. */
<span class="nc" id="L2388">		WEIGHTED_AVERAGE(true, true, true, true, false),</span>
		/** Takes the last valid value as the aggregate for an entire interval.  All earlier values are ignored. */
<span class="nc" id="L2390">		LAST_VALID_VALUE(false, false, false, false, false),</span>
		// The following two aggregation types reduce volume by a function of abandonment
		// to obtain a weight
<span class="nc" id="L2393">		WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT(true, true, true, true, false),</span>
<span class="nc" id="L2394">		WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT(true, true, true, true, false),</span>
		// The following three aggregation types are used for data types where for
		// some reason we want to be able to view and modify
		// aggregated weighted averages even when no weights exist.
<span class="nc" id="L2398">		WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS(true, true, true, true, true),</span>
<span class="nc" id="L2399">		WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS(true, true, true, true, true),</span>
<span class="nc" id="L2400">		WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS(true, true, true, true, true),</span>
		;

		private final boolean m_supportsCombine;
		private final boolean m_supportsScale;
		private final boolean m_supportsDistribute;
		private final boolean m_isWeightedAverage;
		private final boolean m_useSimpleAverageIfNoWeights;

		private AggregationType(boolean supportsCombine, boolean supportsScale, boolean supportsDistribute,
<span class="nc" id="L2410">								boolean isWeightedAverage, boolean useSimpleAverageIfNoWeights) {</span>

<span class="nc" id="L2412">			m_supportsCombine = supportsCombine;</span>
<span class="nc" id="L2413">			m_supportsScale = supportsScale;</span>
<span class="nc" id="L2414">			m_supportsDistribute = supportsDistribute;</span>
<span class="nc" id="L2415">			m_isWeightedAverage = isWeightedAverage;</span>
<span class="nc" id="L2416">			m_useSimpleAverageIfNoWeights = useSimpleAverageIfNoWeights;</span>
<span class="nc" id="L2417">		}</span>

		/**
		 * Returns whether traces having this aggregation type can meaningfully combine values
		 * from multiple queues.
		 * 
		 * @return
		 */
		public boolean supportsCombine() {
<span class="nc" id="L2426">			return m_supportsCombine;</span>
		}

		/**
		 * Returns whether traces having this aggregation type can meaningfully scale values
		 * across time intervals.
		 * 
		 * @return
		 */
		public boolean supportsScale() {
<span class="nc" id="L2436">			return m_supportsScale;</span>
		}

		/**
		 * Returns whether traces having this aggregation type can meaningfully distribute
		 * values across multiple queues.
		 * 
		 * @return
		 */
		public boolean supportsDistribute() {
<span class="nc" id="L2446">			return m_supportsDistribute;</span>
		}

		/**
		 * Returns whether this aggregation type averages using a separate set of weights.
		 * 
		 * @return
		 */
		public boolean isWeightedAverage() {
<span class="nc" id="L2455">			return m_isWeightedAverage;</span>
		}

		/**
		 * Returns whether this aggregation type is a weighted average that behaves like
		 * a simple average when all weights are zero or missing.
		 * 
		 * @return
		 */
		public boolean isSimpleAverageIfNoWeights() {
<span class="nc" id="L2465">			return m_useSimpleAverageIfNoWeights;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>