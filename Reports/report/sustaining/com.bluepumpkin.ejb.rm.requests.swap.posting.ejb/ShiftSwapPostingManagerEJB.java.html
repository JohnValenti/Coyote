<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftSwapPostingManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.swap.posting.ejb</a> &gt; <span class="el_source">ShiftSwapPostingManagerEJB.java</span></div><h1>ShiftSwapPostingManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.swap.posting.ejb;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;

import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.core.base.SupportNavigation;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.SSPostingCollection;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPostingFieldInfo;
import com.bluepumpkin.ejb.rm.requests.swap.posting.validation.AgentGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.swap.posting.validation.PostedShiftContainsFlexTOHV;
import com.bluepumpkin.ejb.rm.requests.swap.posting.validation.SameShiftNotAlreadyPostedHV;
import com.bluepumpkin.ejb.rm.requests.swap.posting.validation.ShiftExistValidationRule;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;


/**
 * Title:        ShiftSwapPostingManagerEJB
 * Description:  EJB for ShiftSwapPosting
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Zhibo Wang
 * @version 1.0
 */
<span class="nc" id="L55">public class ShiftSwapPostingManagerEJB extends SessionEJBBase implements IShiftSwapPostingManager //OUTSIDE_CONTAINER</span>
//public class ShiftSwapPostingManagerEJB extends SessionEjbBaseForTest implements ShiftSwapPostingManager //OUTSIDE_CONTAINER
{
<span class="nc" id="L58">    private static Category m_cat = Log.initCategory(ShiftSwapPostingManagerEJB.class.getName());</span>

    protected static final int FETCHMODE_ALLPOSTINGS = 1;
    protected static final int FETCHMODE_MYORGPOSTINGS = 2;

<span class="nc" id="L63">    private final Validator m_agentGoodStandingValidationRule = new AgentGoodStandingValidationRule();</span>
<span class="nc" id="L64">    private final Validator m_shiftExistValidationRule = new ShiftExistValidationRule();</span>
<span class="nc" id="L65">    private final Validator m_sameShiftNotAlreadyPostedHV = new SameShiftNotAlreadyPostedHV();</span>
<span class="nc" id="L66">    private final Validator m_postedShiftContainsFlexTOHV = new PostedShiftContainsFlexTOHV();</span>

    /**
     * validators run on a call to {@link #validateShiftSwapPosting(Collection, boolean) validateShiftSwapPosting}
     * method.
     */
<span class="nc" id="L72">    private final Validator[] m_validatorsForPickup = new Validator[] {</span>
            m_agentGoodStandingValidationRule, m_shiftExistValidationRule, m_postedShiftContainsFlexTOHV };

<span class="nc" id="L75">    private final Validator[] m_validatorsForUpdate = new Validator[] {</span>
        m_agentGoodStandingValidationRule, m_shiftExistValidationRule, m_postedShiftContainsFlexTOHV};

<span class="nc" id="L78">    private final Validator[] m_validatorsForCreate = new Validator[] {</span>
        m_agentGoodStandingValidationRule, m_shiftExistValidationRule, m_sameShiftNotAlreadyPostedHV, m_postedShiftContainsFlexTOHV};

    {
<span class="nc" id="L82">        super.init(ShiftSwapPostingManagerEJB.class.getName());</span>
<span class="nc" id="L83">    }</span>

    /** override the base class to provide the appropriate logging category */
    @Override
	protected Category getCategory() {
<span class="nc" id="L88">        return m_cat;</span>
    }

    /**
     * Creates a persistent ShiftSwapPosting in the DB, with a child ShiftSwapItem.
     * @param objValue  A ShiftSwapPosting object
     * @return the ID of the created object
     * @throws BbmCreateException
     */
    @Override
	public ID createShiftSwapPosting(ShiftSwapPosting ssPosting)
        throws BbmCreateException, RmHardValidationException {
<span class="nc" id="L100">        String _method_ = &quot;createShiftSwapPosting&quot;;</span>
<span class="nc" id="L101">        methodStart(_method_, ssPosting);</span>

        ID postingId;

        // make sure the posting contains a ShiftSwapItem
<span class="nc" id="L106">        ShiftSwapItem item = ssPosting.getShiftSwapItem();</span>

<span class="nc bnc" id="L108" title="All 2 branches missed.">        if (item == null) {</span>
<span class="nc" id="L109">            throw RequestUtil.createRmHardValidationException(RmEjbBundleKey.SSP_NO_ITEM, m_cat);</span>
        }

<span class="nc" id="L112">        ShiftSwapPostingDAO sspDAO = null;</span>
        try {
            //Hard Validation for posting creation
<span class="nc" id="L115">            runHardValidatorsRaiseException(ssPosting, m_validatorsForCreate );</span>
            
            //Get ShiftID and add to ShiftSwapItem
<span class="nc" id="L118">    		ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="nc" id="L119">    		ShiftSwapItem ssi = ssPosting.getShiftSwapItem();</span>
<span class="nc" id="L120">    		Collection shiftAssign = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, ssi.getEmployeeID(),</span>
<span class="nc" id="L121">    				                                                             ssi.getStartDate(), ssi.getEndDate());</span>
<span class="nc" id="L122">    		Iterator it = shiftAssign.iterator();</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">    		if (it.hasNext()) {</span>
<span class="nc" id="L124">    			ShiftAssignment sa = (ShiftAssignment)it.next();</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">    			if (sa.getShiftID() != null) {</span>
<span class="nc" id="L126">    				ssi.setShiftID(sa.getShiftID());</span>
    			}
    		}

            //create ShiftSwapPosting object in DB
<span class="nc" id="L131">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L132">            postingId = sspDAO.createObject(ssPosting, false);</span>
<span class="nc" id="L133">        } catch (BbmCreateException e) {</span>
<span class="nc" id="L134">            m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] { &quot;SHIFTSWAPPOSTING&quot; });</span>
<span class="nc" id="L135">            handleException(e);</span>
<span class="nc" id="L136">            throw e;</span>
<span class="nc" id="L137">        } catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] { &quot;SHIFTSWAPPOSTING&quot; });

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L144">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L145">			throw e;</span>
<span class="nc" id="L146">		} catch (Exception e) {</span>
<span class="nc" id="L147">        	handleException(_method_, e, true);</span>
<span class="nc" id="L148">        	throw RequestUtil.createBbmCreateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L150" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L151">            methodFinish();</span>
<span class="nc" id="L152">        }</span>

<span class="nc" id="L154">        return postingId;</span>
    }

    private void runHardValidatorsRaiseException(ShiftSwapPosting ssPosting, Validator[] validators)
        throws Exception {

<span class="nc" id="L160">        ValidationResult vr = runHardValidators(ssPosting, validators);</span>

<span class="nc bnc" id="L162" title="All 2 branches missed.">        if (vr != null) {</span>
<span class="nc" id="L163">            throw RequestUtil.createRmHardValidationException(vr, m_cat);</span>
        }
<span class="nc" id="L165">    }</span>

    /**
     * @param ssPosting
     * @param validators
     */
    private ValidationResult runHardValidators(ShiftSwapPosting ssPosting, Validator[] validators) throws Exception {
<span class="nc" id="L172">        ValidationResult vr = null;</span>

        // for each validator
<span class="nc bnc" id="L175" title="All 2 branches missed.">        for (int i = 0; i &lt; validators.length; i++) {</span>
            // run validation
<span class="nc" id="L177">            vr = validators[i].validate(ssPosting);</span>

            // stop on first validation error.
<span class="nc bnc" id="L180" title="All 2 branches missed.">            if (vr != null) {</span>
<span class="nc" id="L181">                break;</span>
            }
        }

<span class="nc" id="L185">        return vr;</span>
    }


    /**
     * Updates a ShiftSwapPosting object including its child ShiftSwapItem object
     * in the database.
     *
     * @param objValue  the object to be updated
     * @throws MultiUserException
     * @throws BbmUpdateException
     */
    @Override
	public void updateShiftSwapPosting(ShiftSwapPosting ssPosting)
        throws MultiUserException, BbmUpdateException, RmHardValidationException {
<span class="nc" id="L200">        String _method_ = &quot;updateShiftSwapPosting&quot;;</span>
<span class="nc" id="L201">        methodStart(_method_, ssPosting);</span>

<span class="nc" id="L203">        ShiftSwapPostingDAO sspDAO = null;</span>
        try {
            //Hard Validation for posting update
<span class="nc" id="L206">            runHardValidatorsRaiseException(ssPosting, m_validatorsForUpdate );</span>

<span class="nc" id="L208">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L209">            sspDAO.updateSSPosting(ssPosting);</span>
<span class="nc" id="L210">        } catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.l7dError(RmEjbLogBundleKey.CREATE_FAILURE, new String[] { &quot;SHIFTSWAPPOSTING&quot; });

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L217">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L218">			throw e;</span>
<span class="nc" id="L219">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L220">            m_cat.l7dError(RmEjbLogBundleKey.UPDATE_FAILURE, new String[] { &quot;SHIFTSWAPPOSTING&quot; });</span>
<span class="nc" id="L221">            handleException(e);</span>
<span class="nc" id="L222">            throw e;</span>
<span class="nc" id="L223">        } catch (MultiUserException e) {</span>
<span class="nc" id="L224">            m_cat.l7dError(RmEjbLogBundleKey.UPDATE_FAILURE, new String[] { &quot;SHIFTSWAPPOSTING&quot; });</span>
<span class="nc" id="L225">            handleException(e);</span>
<span class="nc" id="L226">            throw e;</span>
<span class="nc" id="L227">        } catch (Exception e) {</span>
<span class="nc" id="L228">        	handleException(e);</span>
<span class="nc" id="L229">        	throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L231" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L232">            methodFinish();</span>
<span class="nc" id="L233">        }</span>
<span class="nc" id="L234">    }</span>

    /**
     * Deletes ShiftSwapPosting objects including child ShiftSwapItems
     * from the database.
     *
     * @param colIDs collection of IDs representing ShiftSwapPosting objects
     * in the database
     * @throws BbmRemoveException
     * @throws BbmFinderException
     */
    @Override
	public void deleteShiftSwapPostings(Collection&lt;ID&gt; colIDs)
        throws BbmRemoveException, BbmFinderException, RmHardValidationException {
<span class="nc" id="L248">        String _method_ = &quot;deleteShiftSwapPostings&quot;;</span>
<span class="nc" id="L249">        methodStart(_method_, colIDs);</span>

<span class="nc" id="L251">		Collection&lt;ID&gt; itemIds = new ArrayList&lt;&gt;(colIDs.size());</span>
<span class="nc" id="L252">		Collection&lt;ShiftSwapPosting&gt; postings = new ArrayList&lt;&gt;(colIDs.size());</span>
<span class="nc" id="L253">        ShiftSwapPostingDAO sspDAO = null;</span>
<span class="nc" id="L254">        DAOBase ssItemDAO = null;</span>
        try {
            // method getObjectsByIDs is in DAOBase.
            // consequently it shallow reads the objects without retrieving
            // children. this is fine, since we only want to access the
            // ShiftSwapItemId field.
<span class="nc" id="L260">            long detailLevel = ShiftSwapPosting.DL_BASIC | ShiftSwapPosting.DL_SHIFTSWAP_ITEMS;</span>
<span class="nc" id="L261">            sspDAO = new ShiftSwapPostingDAO(detailLevel);</span>
<span class="nc" id="L262">            postings = sspDAO.findSSPostingsByIDs(colIDs, detailLevel);</span>

<span class="nc" id="L264">			Iterator&lt;ShiftSwapPosting&gt; itr = postings.iterator();</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">            while (itr.hasNext()) {</span>
<span class="nc" id="L266">				itemIds.add((ID) itr.next().getFieldValue(</span>
                        ShiftSwapPostingFieldInfo.SHIFTSWAPPOSTING_I_SHIFTSWAPITEMID));
            }

            // delete the child ShiftSwapItem objects which will
            // cascade delete the parent ShiftSwapPosting objects
<span class="nc" id="L272">            ssItemDAO = sspDAO.createChildDAO(ShiftSwapPostingFieldInfo.ITEM_CHILD_TYPE);</span>
<span class="nc" id="L273">            ssItemDAO.deleteObjects(itemIds);</span>
<span class="nc" id="L274">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L281">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L282">			throw e;</span>
<span class="nc" id="L283">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L284">            m_cat.error(e, e);</span>
<span class="nc" id="L285">        	handleException(e);</span>
<span class="nc" id="L286">            throw e;</span>
<span class="nc" id="L287">        } catch (BbmRemoveException e) {</span>
<span class="nc" id="L288">        	m_cat.error(e,e);</span>
<span class="nc" id="L289">        	handleException(e);</span>
<span class="nc" id="L290">        	throw e;</span>
<span class="nc" id="L291">        } catch (Exception e) {</span>
<span class="nc" id="L292">        	handleException(e);</span>
<span class="nc" id="L293">        	throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L295" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc bnc" id="L296" title="All 4 branches missed.">            if (ssItemDAO != null) ssItemDAO.cleanUp();</span>
<span class="nc" id="L297">            methodFinish();</span>
<span class="nc" id="L298">        }</span>
<span class="nc" id="L299">    }</span>

    /**
     * Deletes ShiftSwapPosting object from database.
     *
     * @param id the ID representing the ShiftSwapPosting object in the database.
     * @throws BbmRemoveException
     * @throws BbmFinderException
     */
    @Override
	public void deleteShiftSwapPosting(ID id)
    	throws BbmRemoveException, BbmFinderException, RmHardValidationException {
<span class="nc" id="L311">        String _method_ = &quot;deleteShiftSwapPosting&quot;;</span>
<span class="nc" id="L312">        methodStart(_method_, id);</span>

<span class="nc" id="L314">        ShiftSwapPostingDAO dao = null;</span>

        try {
<span class="nc" id="L317">            dao = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L318">            dao.deleteSSPosting(id);</span>
<span class="nc" id="L319">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L326">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L327">			throw e;</span>
<span class="nc" id="L328">        } catch (BbmRemoveException e) {</span>
<span class="nc" id="L329">        	m_cat.error(e,e);</span>
<span class="nc" id="L330">        	handleException(e);</span>
<span class="nc" id="L331">        	throw e;</span>
<span class="nc" id="L332">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L333">        	m_cat.error(e,e);</span>
<span class="nc" id="L334">        	handleException(e);</span>
<span class="nc" id="L335">        	throw e;</span>
<span class="nc" id="L336">        } catch (Exception e) {</span>
<span class="nc" id="L337">            handleException(e);</span>
<span class="nc" id="L338">            throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L340" title="All 4 branches missed.">            if (dao != null) dao.cleanUp();</span>
<span class="nc" id="L341">            methodFinish();</span>
<span class="nc" id="L342">        }</span>
<span class="nc" id="L343">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.IShiftSwapPostingManager#validateShiftSwapPosting(java.util.Collection, boolean)
     */
    @Override
	public Collection&lt;ShiftSwapPosting&gt; validateShiftSwapPostings(Collection&lt;ShiftSwapPosting&gt; ssPostings, boolean deleteIfHardValFails)
        throws RmHardValidationException, RmException {

<span class="nc" id="L352">        String _method_ = &quot;validateShiftSwapPostings&quot;;</span>
<span class="nc" id="L353">        methodStart(_method_, RmUtil.dumpIDsFromVOCollection(ssPostings));</span>

        try {
<span class="nc" id="L356">            return _validateShiftSwapPostings(ssPostings, deleteIfHardValFails, null);</span>
<span class="nc" id="L357">        } catch (RmHardValidationException e) {</span>
            //RM exceptions are always logged at the point where they are thrown.
            //m_cat.error(e, e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L364">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L365">            throw e;</span>
<span class="nc" id="L366">        } catch (RmException e) {</span>
<span class="nc" id="L367">            m_cat.error(e, e);</span>
<span class="nc" id="L368">            handleException(e);</span>
<span class="nc" id="L369">            throw e;</span>
<span class="nc" id="L370">        } catch (Exception e) {</span>
<span class="nc" id="L371">            handleException(e);</span>
<span class="nc" id="L372">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        }
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.IShiftSwapPostingManager#validateShiftSwapPostingsByIDs(java.util.Collection, boolean)
     */
    @Override
	public Collection validateShiftSwapPostingsByIDs(Collection&lt;ID&gt; ssPostingIDs, boolean deleteIfHardValFails)
        throws RmHardValidationException, RmException {

<span class="nc" id="L383">            String _method_ = &quot;validateShiftSwapPostingsByIDs&quot;;</span>
<span class="nc" id="L384">            methodStart(_method_, RmUtil.dumpCommaSeparated(ssPostingIDs, new Boolean(deleteIfHardValFails)));</span>

<span class="nc" id="L386">            ShiftSwapPostingDAO sspDAO = null;</span>
            try {
<span class="nc" id="L388">                long detailLevel = ShiftSwapPosting.DL_BASIC | ShiftSwapPosting.DL_SHIFTSWAP_ITEMS;</span>
<span class="nc" id="L389">                sspDAO = new ShiftSwapPostingDAO(detailLevel);</span>
<span class="nc" id="L390">			Collection&lt;ShiftSwapPosting&gt; ssPostings = sspDAO.findSSPostingsByIDs(ssPostingIDs, detailLevel);</span>

<span class="nc" id="L392">                return _validateShiftSwapPostings(ssPostings, deleteIfHardValFails, sspDAO);</span>
<span class="nc" id="L393">            } catch (RmHardValidationException e) {</span>
                //RM exceptions are always logged at the point where they are thrown.
                //m_cat.error(e, e);

                // Logged with priority 'debug' since this exception is generated by RM during validations or
                // workflow processing and happens often during normal operation.  If logged with a different
                // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L400">                handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L401">                throw e;</span>
<span class="nc" id="L402">            } catch (RmException e) {</span>
<span class="nc" id="L403">                m_cat.error(e, e);</span>
<span class="nc" id="L404">                handleException(e);</span>
<span class="nc" id="L405">                throw e;</span>
<span class="nc" id="L406">            } catch (Exception e) {</span>
<span class="nc" id="L407">                handleException(e);</span>
<span class="nc" id="L408">                throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
            }
    }

	private Collection&lt;ShiftSwapPosting&gt; _validateShiftSwapPostings(Collection&lt;ShiftSwapPosting&gt; ssPostings, boolean deleteIfHardValFails,
        ShiftSwapPostingDAO sspDAO) throws Exception {

<span class="nc bnc" id="L415" title="All 2 branches missed.">        boolean sspDAONeedsCreate = (sspDAO == null);</span>
        try {
<span class="nc" id="L417">			Collection&lt;ID&gt; ssPostingIDsForDel = new ArrayList&lt;&gt;(ssPostings.size());</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">			for (Iterator&lt;ShiftSwapPosting&gt; iter = ssPostings.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L419">                ShiftSwapPosting ssPosting = iter.next();</span>

                // run hard validators.  Stops at the first hard validation failure.
<span class="nc" id="L422">                ValidationResult hardValResult = runHardValidators(ssPosting, m_validatorsForPickup);</span>

                // if hard validatoin fails, posting is a candidate for deletion.
<span class="nc bnc" id="L425" title="All 2 branches missed.">                if (hardValResult != null ) {</span>
<span class="nc" id="L426">                    ssPostingIDsForDel.add(ssPosting.getID());</span>
                }
<span class="nc" id="L428">            }</span>

            // if ssPostings need to be deleted and a 'delete' operation is requested.
<span class="nc bnc" id="L431" title="All 4 branches missed.">            if ( !ssPostingIDsForDel.isEmpty() &amp;&amp; deleteIfHardValFails ) {</span>
                // instantiate DAO only if necessary.
<span class="nc bnc" id="L433" title="All 2 branches missed.">                sspDAO = (sspDAO == null)?new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC):sspDAO;</span>
<span class="nc" id="L434">                sspDAO.deleteObjects(ssPostingIDsForDel);</span>
            }

            // these might have validation results attached.
<span class="nc" id="L438">            return ssPostings;</span>
        } finally {
<span class="nc bnc" id="L440" title="All 8 branches missed.">            if (sspDAONeedsCreate &amp;&amp; sspDAO != null) sspDAO.cleanUp();</span>
        }

    }
    /**
     * &lt;B&gt;findShiftSwapPostingByID&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public ShiftSwapPosting findShiftSwapPostingById(ID postingID, long detailLevel)
        throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L455">        String _method_ = &quot;findShiftSwapPostingById&quot;;</span>
<span class="nc" id="L456">        methodStart(_method_, postingID);</span>

<span class="nc" id="L458">        ShiftSwapPostingDAO dao = null;</span>

        try {
<span class="nc" id="L461">            dao = new ShiftSwapPostingDAO(detailLevel);</span>
<span class="nc" id="L462">            ShiftSwapPosting posting = (ShiftSwapPosting) dao.getObjectByID(postingID);</span>

<span class="nc" id="L464">            return posting;</span>
<span class="nc" id="L465">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L472">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L473">			throw e;</span>
<span class="nc" id="L474">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L475">        	m_cat.error(e,e);</span>
<span class="nc" id="L476">        	handleException(e);</span>
<span class="nc" id="L477">        	throw e;</span>
<span class="nc" id="L478">        } catch (Exception e) {</span>
<span class="nc" id="L479">            handleException(e);</span>
<span class="nc" id="L480">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L482" title="All 4 branches missed.">            if (dao != null) dao.cleanUp();</span>
<span class="nc" id="L483">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingsByEmployee&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public SSPostingCollection findShiftSwapPostingsByEmployee(ID empId, long detailLevel, int chunkSize, boolean fetchPartial)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L498">        String _method_ = &quot;findShiftSwapPostingsByEmployee&quot;;</span>
<span class="nc" id="L499">        methodStart(_method_, empId, new Integer(chunkSize));</span>

<span class="nc" id="L501">        ShiftSwapPostingDAO ssPostingDAO = null;</span>

        try {
<span class="nc" id="L504">            List&lt;ID&gt; postingIDs = Collections.emptyList();</span>
<span class="nc" id="L505">            Collection&lt;ShiftSwapPosting&gt; postings = Collections.emptyList();</span>
<span class="nc" id="L506">            ssPostingDAO = new ShiftSwapPostingDAO(detailLevel);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">            boolean paginationEnabled = chunkSize != SupportNavigation.CHUNKSIZE_ALL;</span>
<span class="nc bnc" id="L508" title="All 2 branches missed.">			if (paginationEnabled) {</span>
                // first fetch posting IDs
<span class="nc" id="L510">                postingIDs = ssPostingDAO.findSSPostingIDsByEmployee(empId, fetchPartial);</span>
<span class="nc bnc" id="L511" title="All 2 branches missed.">                if (!postingIDs.isEmpty()) {</span>
					// fetch minimum(postingIDs.size(), chunkSize);
<span class="nc bnc" id="L513" title="All 2 branches missed.">					int numOfPostings = (postingIDs.size() &lt; chunkSize)?postingIDs.size():chunkSize;</span>
					// fetch the chunk of requested postings
<span class="nc" id="L515">	                postings = ssPostingDAO.findSSPostingsByIDs(postingIDs.subList(0, numOfPostings), detailLevel);</span>
<span class="nc" id="L516">                }</span>
            } else {
				// pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L519">                postings = ssPostingDAO.findSSPostingsByEmployee(empId, detailLevel, fetchPartial);</span>
            }

<span class="nc" id="L522">            return new SSPostingCollection(postingIDs, postings, chunkSize);</span>
<span class="nc" id="L523">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L530">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L531">			throw e;</span>
<span class="nc" id="L532">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L533">        	m_cat.error(e,e);</span>
<span class="nc" id="L534">        	handleException(e);</span>
<span class="nc" id="L535">        	throw e;</span>
<span class="nc" id="L536">        } catch (Exception e) {</span>
<span class="nc" id="L537">            handleException(e);</span>
<span class="nc" id="L538">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L540" title="All 4 branches missed.">            if (ssPostingDAO != null) ssPostingDAO.cleanUp();</span>
<span class="nc" id="L541">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingIDsByEmployee&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public Collection&lt;ID&gt; findShiftSwapPostingIDsByEmployee(ID empId, boolean fetchPartial)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L556">        String _method_ = &quot;findShiftSwapPostingIDsByEmployee&quot;;</span>
<span class="nc" id="L557">        methodStart(_method_, empId);</span>

<span class="nc" id="L559">        ShiftSwapPostingDAO sspDAO = null;</span>

        try {
<span class="nc" id="L562">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L563">            Collection&lt;ID&gt; postingIDs = sspDAO.findSSPostingIDsByEmployee(empId, fetchPartial);</span>

<span class="nc" id="L565">            return postingIDs;</span>
<span class="nc" id="L566">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L573">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L574">			throw e;</span>
<span class="nc" id="L575">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L576">        	m_cat.error(e,e);</span>
<span class="nc" id="L577">        	handleException(e);</span>
<span class="nc" id="L578">        	throw e;</span>
<span class="nc" id="L579">        } catch (Exception e) {</span>
<span class="nc" id="L580">            handleException(e);</span>
<span class="nc" id="L581">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L583" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L584">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingsByOrg&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public SSPostingCollection findShiftSwapPostingsByOrg(ID orgId, long detailLevel, int chunkSize)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L599">        String _method_ = &quot;findShiftSwapPostingsByOrg&quot;;</span>
<span class="nc" id="L600">        methodStart(_method_, orgId, new Integer(chunkSize));</span>

<span class="nc" id="L602">        ShiftSwapPostingDAO sspDAO = null;</span>

        try {
<span class="nc" id="L605">            List&lt;ID&gt; postingIDs = Collections.emptyList();</span>
<span class="nc" id="L606">            Collection&lt;ShiftSwapPosting&gt; postings = Collections.emptyList();</span>
<span class="nc" id="L607">            sspDAO = new ShiftSwapPostingDAO(detailLevel);</span>

            // if pagination is enabled
<span class="nc bnc" id="L610" title="All 2 branches missed.">            if (chunkSize != SupportNavigation.CHUNKSIZE_ALL) {</span>
                // first fetch posting ids
<span class="nc" id="L612">                postingIDs = sspDAO.findSSPostingIDsByOrg(orgId);</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">				if (!postingIDs.isEmpty()) {</span>
					// fetch minimum(postingIDs.size(), chunkSize);
<span class="nc bnc" id="L615" title="All 2 branches missed.">					int numOfPostings = (postingIDs.size() &lt; chunkSize)?postingIDs.size():chunkSize;</span>
					// fetch the chunk of requested postings
<span class="nc" id="L617">                	postings = sspDAO.findSSPostingsByIDs(postingIDs.subList(0, numOfPostings), detailLevel);</span>
<span class="nc" id="L618">				}</span>
            } else {
				// pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L621">                postings = sspDAO.findSSPostingsByOrg(orgId, detailLevel);</span>
            }

<span class="nc" id="L624">            return new SSPostingCollection(postingIDs, postings, chunkSize);</span>
<span class="nc" id="L625">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L632">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L633">			throw e;</span>
<span class="nc" id="L634">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L635">        	m_cat.error(e,e);</span>
<span class="nc" id="L636">        	handleException(e);</span>
<span class="nc" id="L637">        	throw e;</span>
<span class="nc" id="L638">        } catch (Exception e) {</span>
<span class="nc" id="L639">            handleException(e);</span>
<span class="nc" id="L640">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L642" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L643">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingIDsByOrg&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public Collection&lt;ID&gt; findShiftSwapPostingIDsByOrg(ID orgID)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L658">        String _method_ = &quot;findShiftSwapPostingIDsByOrg&quot;;</span>
<span class="nc" id="L659">        methodStart(_method_, orgID);</span>

<span class="nc" id="L661">        ShiftSwapPostingDAO sspDAO = null;</span>

        try {
<span class="nc" id="L664">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L665">            Collection&lt;ID&gt; postings = sspDAO.findSSPostingIDsByOrg(orgID);</span>

<span class="nc" id="L667">            return postings;</span>
<span class="nc" id="L668">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L675">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L676">			throw e;</span>
<span class="nc" id="L677">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L678">        	m_cat.error(e,e);</span>
<span class="nc" id="L679">        	handleException(e);</span>
<span class="nc" id="L680">        	throw e;</span>
<span class="nc" id="L681">        } catch (Exception e) {</span>
<span class="nc" id="L682">            handleException(e);</span>
<span class="nc" id="L683">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L685" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L686">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingsByCampaign&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public SSPostingCollection findShiftSwapPostingsByCampaign(ID campaignID, long detailLevel, int chunkSize)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L701">        String _method_ = &quot;findShiftSwapPostingsByCampaign&quot;;</span>
<span class="nc" id="L702">        methodStart(_method_, campaignID, new Integer(chunkSize));</span>

<span class="nc" id="L704">        ShiftSwapPostingDAO sspDAO = null;</span>

        try {
<span class="nc" id="L707">            List&lt;ID&gt; postingIDs = Collections.emptyList();</span>
<span class="nc" id="L708">            Collection&lt;ShiftSwapPosting&gt; postings = Collections.emptyList();</span>
<span class="nc" id="L709">            sspDAO = new ShiftSwapPostingDAO(detailLevel);</span>

			// if pagination is enabled
<span class="nc bnc" id="L712" title="All 2 branches missed.">            if (chunkSize != SupportNavigation.CHUNKSIZE_ALL) {</span>
				// first fetch posting IDs
<span class="nc" id="L714">                postingIDs = sspDAO.findSSPostingIDsByCampaign(campaignID);</span>
<span class="nc bnc" id="L715" title="All 2 branches missed.">				if (!postingIDs.isEmpty()) {</span>
					// fetch minimum(postingIDs.size(), chunkSize);
<span class="nc bnc" id="L717" title="All 2 branches missed.">					int numOfPostings = (postingIDs.size() &lt; chunkSize)?postingIDs.size():chunkSize;</span>
					// fetch the chunk of requested postings
<span class="nc" id="L719">	                postings = sspDAO.findSSPostingsByIDs(postingIDs.subList(0, numOfPostings), detailLevel);</span>
<span class="nc" id="L720">				}</span>
            } else {
				// pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L723">                postings = sspDAO.findSSPostingsByCampaign(campaignID, detailLevel);</span>
            }

<span class="nc" id="L726">            return new SSPostingCollection(postingIDs, postings, chunkSize);</span>
<span class="nc" id="L727">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L734">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L735">			throw e;</span>
<span class="nc" id="L736">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L737">        	m_cat.error(e,e);</span>
<span class="nc" id="L738">        	handleException(e);</span>
<span class="nc" id="L739">        	throw e;</span>
<span class="nc" id="L740">        } catch (Exception e) {</span>
<span class="nc" id="L741">            handleException(e);</span>
<span class="nc" id="L742">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L744" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L745">            methodFinish();</span>
        }
    }

    /**
     * &lt;B&gt;findShiftSwapPostingIDsByCampaign&lt;/B&gt;
     * &lt;P&gt;Params  ID
     * returns ShiftSwapPosting Object
     * &lt;P&gt;
     *  @return   ShiftSwapPosting Object
     *
     */
    @Override
	public Collection&lt;ID&gt; findShiftSwapPostingIDsByCampaign(ID campaignID)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L760">        String _method_ = &quot;findShiftSwapPostingIDsByCampaign&quot;;</span>
<span class="nc" id="L761">        methodStart(_method_, campaignID);</span>

<span class="nc" id="L763">        ShiftSwapPostingDAO sspDAO = null;</span>

        try {
<span class="nc" id="L766">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>
<span class="nc" id="L767">            Collection&lt;ID&gt; postings = sspDAO.findSSPostingIDsByCampaign(campaignID);</span>

<span class="nc" id="L769">            return postings;</span>
<span class="nc" id="L770">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L777">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L778">			throw e;</span>
<span class="nc" id="L779">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L780">        	m_cat.error(e,e);</span>
<span class="nc" id="L781">        	handleException(e);</span>
<span class="nc" id="L782">        	throw e;</span>
<span class="nc" id="L783">        } catch (Exception e) {</span>
<span class="nc" id="L784">            handleException(e);</span>
<span class="nc" id="L785">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L787" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L788">            methodFinish();</span>
        }
    }

    /**
     * Finds postings which belong to the specified employee's org between now and into the future.
     * Note that the employee's organization association may change with time.
     * Postings are fetched from employees in each org that the specified employee belongs to.
     *
     * @param empID
     * @param detailLevel
     * @param chunkSize
     * @param fetchMode {@link #FETCHMODE_ALLPOSTINGS FETCHMODE_ALLPOSTINGS} or {@link #FETCHMODE_MYORGPOSTINGS FETCHMODE_MYORGPOSTINGS}
     * @return
     * @throws Exception
     */
    protected SSPostingCollection findShiftSwapPostingsForEmpOrgByMode(ID empID, long detailLevel,
        int chunkSize, int fetchMode, boolean fetchPartial) throws Exception {

<span class="nc" id="L807">        ShiftSwapPostingDAO ssPostingDAO = null;</span>

        try {
<span class="nc" id="L810">            List&lt;ID&gt; postingIDs = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L811">            Collection&lt;ShiftSwapPosting&gt; postings = new ArrayList&lt;&gt;();</span>

            // Get employee-organization associations for this employee for the time interval 'now' to max time.
//            WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();
//            Collection wrAssignments = wrm.getWorkResourceAssignments(empID, new Date(), null, false);
<span class="nc" id="L816">            Collection wrAssignments = ValidationUtil.getWorkResAssnWithTZForWRID(empID, new Date(), null);</span>

<span class="nc" id="L818">            ssPostingDAO = new ShiftSwapPostingDAO(detailLevel);</span>
			// if pagination is enabled
<span class="nc bnc" id="L820" title="All 2 branches missed.">            boolean paginationEnabled = chunkSize != SupportNavigation.CHUNKSIZE_ALL;</span>
            // for each workresource assignment.
<span class="nc bnc" id="L822" title="All 2 branches missed.">			for (Iterator wrAssnsIter = wrAssignments.iterator(); wrAssnsIter.hasNext();) {</span>
<span class="nc" id="L823">                WorkResourceAssignment wrAssn = (WorkResourceAssignment) wrAssnsIter.next();</span>

                // get orgID for employee.
<span class="nc" id="L826">                ID empOrgID = wrAssn.getOrganizationID();</span>

<span class="nc" id="L828">                Collection&lt;ID&gt; swappableOrgIDs = null;</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">                if ( fetchMode == FETCHMODE_ALLPOSTINGS ) {</span>
					// get orgs this org can swap with.
<span class="nc" id="L831">                    swappableOrgIDs = ShiftSwapRequestUtil.getSwappableOrgIDsForOrg(empOrgID);</span>

                    // if this org cannot swap with any org, then continue with next emp-org association
<span class="nc bnc" id="L834" title="All 2 branches missed.">                    if ( swappableOrgIDs.isEmpty() ) continue;</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">                } else if (fetchMode == FETCHMODE_MYORGPOSTINGS) {</span>
                    // check if the organization can swap with self (fetching postings for myorg).
<span class="nc bnc" id="L837" title="All 2 branches missed.">                    if (!ShiftSwapRequestUtil.canOrg1SwapWithOrg2(empOrgID, empOrgID, null))</span>
<span class="nc" id="L838">                        continue;</span>
                } else {
<span class="nc" id="L840">                    throw new IllegalArgumentException(&quot;fetchMode = &quot;  + fetchMode);</span>
                }

                // if pagination enabled, then first fetch posting IDs
<span class="nc bnc" id="L844" title="All 2 branches missed.">                if (paginationEnabled) {</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">                    if (fetchMode == FETCHMODE_ALLPOSTINGS) {</span>
						// first fetch posting IDs
<span class="nc" id="L847">                        postingIDs.addAll(ssPostingDAO.findAllSSPostingIDsForEmp(empID, swappableOrgIDs,</span>
<span class="nc" id="L848">                            wrAssn.getStartTime(), wrAssn.getEndTime(), fetchPartial));</span>
<span class="nc bnc" id="L849" title="All 2 branches missed.">                    } else if (fetchMode == FETCHMODE_MYORGPOSTINGS) {</span>
						// first fetch posting IDs
<span class="nc" id="L851">                        postingIDs.addAll(ssPostingDAO.findSSPostingIDsForMyOrg(empID,</span>
<span class="nc" id="L852">                            empOrgID, wrAssn.getStartTime(), wrAssn.getEndTime(), fetchPartial));</span>
                    }
                } else { // if pagination not enabled, then fetch the postings (do not have to fetch the IDs).
<span class="nc bnc" id="L855" title="All 2 branches missed.">                    if (fetchMode == FETCHMODE_ALLPOSTINGS) {</span>
						// pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L857">                        postings.addAll(ssPostingDAO.findAllSSPostingsForEmp(empID, swappableOrgIDs,</span>
<span class="nc" id="L858">                            wrAssn.getStartTime(), wrAssn.getEndTime(), detailLevel, fetchPartial));</span>
<span class="nc bnc" id="L859" title="All 2 branches missed.">                    } else if (fetchMode == FETCHMODE_MYORGPOSTINGS) {</span>
						// pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L861">                        postings.addAll(ssPostingDAO.findSSPostingsForMyOrg(empID,</span>
<span class="nc" id="L862">                            empOrgID, wrAssn.getStartTime(), wrAssn.getEndTime(), detailLevel, fetchPartial));</span>
                    }
                }
<span class="nc" id="L865">            }</span>

            // if pagination is enabled, then fetch the specified chunk of requests using the IDs fetched earlier.
<span class="nc bnc" id="L868" title="All 4 branches missed.">            if (paginationEnabled &amp;&amp; !postingIDs.isEmpty()) {</span>
<span class="nc bnc" id="L869" title="All 4 branches missed.">                if (fetchMode == FETCHMODE_ALLPOSTINGS || fetchMode == FETCHMODE_MYORGPOSTINGS) {</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">					if (!postingIDs.isEmpty()) {</span>
						// fetch minimum(postingIDs.size(), chunkSize);
<span class="nc bnc" id="L872" title="All 2 branches missed.">						int numOfPostings = (postingIDs.size() &lt; chunkSize)?postingIDs.size():chunkSize;</span>
						// fetch the chunk of requested postings
<span class="nc" id="L874">	                    postings = ssPostingDAO.findSSPostingsByIDs(postingIDs.subList(0, numOfPostings), detailLevel);</span>
					}
                }
            }

<span class="nc" id="L879">            return new SSPostingCollection(postingIDs, postings, chunkSize);</span>
        } finally {
<span class="nc bnc" id="L881" title="All 4 branches missed.">            if (ssPostingDAO != null) ssPostingDAO.cleanUp();</span>
        }
    }

    /*
     * See {@link ShiftSwapPostingManager#findAllShiftSwapPostings(ID, int) findAllShiftSwapPostings(ID, int)}
     *
     * @param empID
     * @param chunkSize
     * @return
     * @throws BbmFinderException
     * @throws
     */
    @Override
	public SSPostingCollection findAllShiftSwapPostings(ID empID, long detailLevel, int chunkSize, boolean fetchPartial)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L897">        String _method_ = &quot;findAllShiftSwapPostings&quot;;</span>
<span class="nc" id="L898">        methodStart(_method_, empID, new Integer(chunkSize));</span>

        try {
<span class="nc" id="L901">            return findShiftSwapPostingsForEmpOrgByMode(empID, detailLevel, chunkSize, FETCHMODE_ALLPOSTINGS, fetchPartial);</span>
<span class="nc" id="L902">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L909">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L910">			throw e;</span>
<span class="nc" id="L911">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L912">        	m_cat.error(e,e);</span>
<span class="nc" id="L913">        	handleException(e);</span>
<span class="nc" id="L914">        	throw e;</span>
<span class="nc" id="L915">        } catch (Exception e) {</span>
<span class="nc" id="L916">            handleException(e);</span>
<span class="nc" id="L917">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc" id="L919">            methodFinish();</span>
        }
    }

    /*public Collection findShiftSwapPostingsForMyCampaign(ID empID) throws Exception
    {
    	Date now = new Date();

    	// get all campaign work resource assignments (and their effectivity periods) for the
    	// given employee starting now
    	Collection campWorkResAssnsForEmp = RequestUtil.getCampaignAssnsForWorkResDuringPeriod(
    		empID, now, null);

    	// Note: CA == campaign assocication; WR == Work resource.
    	// for each campaign
    	//    get my CA time range.
    	//    get all WRs if their CA time range overlaps my CA time range
    	//
		//    get all shift swap postings by the WRs during my CA time range.
    	//
		//    for each posting
		//       if posting time range falls within WR's CA time range, posting accepted.
		//    end for
    	// end
		for (Iterator itr = campWorkResAssnsForEmp.iterator(); itr.hasNext(); ) {
			CampaignWorkResource myCampWorkResAssn = (CampaignWorkResource) itr.next();

			TimeRange myCampAssocTR = new TimeRange(myCampWorkResAssn.getStartTime(),
				myCampWorkResAssn.getEndTime());

			Collection campWorkResAssns = getCampWorkResAssnsForCampaignDuringInterval(
				myCampWorkResAssn.getCampaignID(), myCampAssocTR);

			Collection orgWorkResAssns = getOrgWorkResAssnsForWorkResesDuringInterval(
				campWorkResAssns, myCampAssocTR);

			Collection SSPostings = findShiftSwapPostingsForEmpsDuringPeriod(
				campWorkResAssns, myCampAssocTR);
		}



    	/*
    	Set swappableEmpIDSet = (Set) RequestUtil.getEmployeesOneCanSwapWith(empID).getFirst();

    	// for ( each campaign )
    	//    get employees associated with the campaign
    	//    obtain employees which belong to both the campaign and list of employees this agent can swap with (using shift swap org setting).
    	//    obtain postings for these employees during the campaign assignment period.
    	// end for
    	for (Iterator itr = campWorkResAssnsForEmp.iterator(); itr.hasNext(); ) {
    		CampaignWorkResource campWorkRes = (CampaignWorkResource) itr.next();
    		Date campAssnStart = campWorkRes.getStartTime();
    		Date campAssnEnd = campWorkRes.getEndTime();

    		Date start = campAssnStart.after(now)?campAssnStart:now;
    		Date end = campAssnEnd.before(start)?start:campAssnEnd;

    		Collection campWorkResAssnsForCamp = RequestUtil.geWorkResAssnsForCampaignDuringPeriod(
    			campWorkRes.getCampaignID(), start, end );

			HashSet empSet = new HashSet(10);
			for (Iterator iter = campWorkResAssnsForCamp.iterator(); iter.hasNext(); ) {
                CampaignWorkResource campWorkResAssn = (CampaignWorkResource) iter.next();
				empSet.add(campWorkResAssn.getWorkResourceID());
            }

			empSet.retainAll(swappableEmpIDSet);

			findShiftSwapPostingsForEmpsDuringPeriod(empSet, start, end);
    	}* /
    }*/

	@Override
	public SSPostingCollection findShiftSwapPostingsForMyOrg(ID workResID, long detailLevel, int chunkSize, boolean fetchPartial)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L995">        String _method_ = &quot;findShiftSwapPostingsForMyOrg&quot;;</span>
<span class="nc" id="L996">        methodStart(_method_, workResID, new Integer(chunkSize));</span>

        try {
<span class="nc" id="L999">            return findShiftSwapPostingsForEmpOrgByMode(workResID, detailLevel, chunkSize, FETCHMODE_MYORGPOSTINGS, fetchPartial);</span>
<span class="nc" id="L1000">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1007">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1008">			throw e;</span>
<span class="nc" id="L1009">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L1010">        	m_cat.error(e,e);</span>
<span class="nc" id="L1011">        	handleException(_method_, e);</span>
<span class="nc" id="L1012">        	throw e;</span>
<span class="nc" id="L1013">        } catch (Exception e) {</span>
<span class="nc" id="L1014">            handleException(e);</span>
<span class="nc" id="L1015">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc" id="L1017">            methodFinish();</span>
        }
	}

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.IShiftSwapPostingManager#findShiftSwapPostingsForMyCampaign(com.bluepumpkin.common.datatypes.ID, long, int)
     */
    @Override
	public SSPostingCollection findShiftSwapPostingsForMyCampaign(ID workResID, long detailLevel, int chunkSize, boolean fetchPartial)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L1027">        String _method_ = &quot;findShiftSwapPostingsForMyCampaign&quot;;</span>
<span class="nc" id="L1028">        methodStart(_method_, workResID, new Integer(chunkSize));</span>

<span class="nc" id="L1030">        ShiftSwapPostingDAO ssPostingDAO = null;</span>
        try {
<span class="nc" id="L1032">            Date currDate = new Date();</span>

            //QC-94774 fix : passed current date to fetch the workResourceAss on current date only .
<span class="nc" id="L1035">            Collection wrAssns = ValidationUtil.getWorkResAssnWithTZForWRID(workResID, currDate, currDate);</span>

            // In London, an employee must have exactly one work resource assignment.  This code relies
            // on this fact.
<span class="nc bnc" id="L1039" title="All 2 branches missed.">            if (wrAssns.size() != 1) {</span>
<span class="nc" id="L1040">                throw new IllegalStateException(&quot;wrAssns.size() != 1 for workRes.  size, workResID = : &quot; +</span>
<span class="nc" id="L1041">                    wrAssns.size() + ',' + workResID);</span>
            }

<span class="nc" id="L1044">            ID empOrgID = ((WorkResourceAssignment)wrAssns.iterator().next()).getOrganizationID();</span>
<span class="nc" id="L1045">            Collection&lt;ID&gt; swappableOrgIDs = ShiftSwapRequestUtil.getSwappableOrgIDsForOrg(empOrgID);</span>

<span class="nc bnc" id="L1047" title="All 2 branches missed.">            if ( swappableOrgIDs.isEmpty() )</span>
<span class="nc" id="L1048">                return new SSPostingCollection(Collections.emptyList(), Collections.emptyList(), chunkSize);</span>

<span class="nc" id="L1050">            ssPostingDAO = new ShiftSwapPostingDAO(detailLevel);</span>

<span class="nc" id="L1052">            List&lt;ID&gt; postingIDs = new ArrayList&lt;&gt;(32);</span>
<span class="nc" id="L1053">            Collection&lt;ShiftSwapPosting&gt; postings = new ArrayList&lt;&gt;(32);</span>

            // if pagination enabled
<span class="nc bnc" id="L1056" title="All 2 branches missed.">            if (chunkSize != SupportNavigation.CHUNKSIZE_ALL) {</span>
                // first get all the posting IDs.
<span class="nc" id="L1058">                postingIDs.addAll(ssPostingDAO.findSSPostingIDsForMyCampaign(workResID,</span>
                    currDate, null, swappableOrgIDs, fetchPartial));

                // then retrieve the chunk of posting asked for.
<span class="nc bnc" id="L1062" title="All 2 branches missed.">                if (!postingIDs.isEmpty()) {</span>
                    // fetch minimum(postingIDs.size(), chunkSize);
<span class="nc bnc" id="L1064" title="All 2 branches missed.">                    int numOfPostings = (postingIDs.size() &lt; chunkSize)?postingIDs.size():chunkSize;</span>
					// fetch the chunk of requested postings
<span class="nc" id="L1066">                    postings = ssPostingDAO.findSSPostingsByIDs(postingIDs.subList(0, numOfPostings), detailLevel);</span>
<span class="nc" id="L1067">                }</span>
            } else { // if pagination not enabled.
                // pagination not enabled, so fetch all postings (bypass fetching of posting IDs).
<span class="nc" id="L1070">                postings.addAll(ssPostingDAO.findSSPostingsForMyCampaign(workResID,</span>
                    currDate, null, swappableOrgIDs, detailLevel, fetchPartial));
            }

<span class="nc" id="L1074">            return new SSPostingCollection(postingIDs, postings, chunkSize);</span>
<span class="nc" id="L1075">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1082">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1083">			throw e;</span>
<span class="nc" id="L1084">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L1085">        	m_cat.error(e,e);</span>
<span class="nc" id="L1086">        	handleException(e);</span>
<span class="nc" id="L1087">        	throw e;</span>
<span class="nc" id="L1088">        } catch (Exception e) {</span>
<span class="nc" id="L1089">            handleException(e);</span>
<span class="nc" id="L1090">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1092" title="All 6 branches missed.">            if (ssPostingDAO != null) ssPostingDAO.cleanUp();</span>
<span class="nc" id="L1093">            methodFinish();</span>
        }
    }

    @Override
	public List&lt;ID&gt; findShiftSwapPostingIDsFromEmps(ID empID, Collection&lt;ID&gt; postingsFromEmpIDs,
			Date start, Date end) throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L1100">        String _method_ = &quot;findShiftSwapPostingIDsFromEmps&quot;;</span>
<span class="nc" id="L1101">        methodStart(_method_, empID, postingsFromEmpIDs, start, end);</span>

<span class="nc" id="L1103">        ShiftSwapPostingDAO sspDAO = null;</span>
        try {
<span class="nc" id="L1105">            sspDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_BASIC);</span>

<span class="nc" id="L1107">            Collection&lt;WorkResourceAssignment&gt; wrAssns = ValidationUtil.getWorkResAssnWithTZForWRID(empID, start, end);</span>

<span class="nc" id="L1109">            List&lt;ID&gt; sspIDs = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            for (Iterator&lt;WorkResourceAssignment&gt; wrAssnsIter = wrAssns.iterator(); wrAssnsIter.hasNext();) {</span>
<span class="nc" id="L1111">                WorkResourceAssignment wrAssn = wrAssnsIter.next();</span>

<span class="nc" id="L1113">                Collection&lt;ID&gt; swappableOrgIDs =</span>
<span class="nc" id="L1114">                    ShiftSwapRequestUtil.getSwappableOrgIDsForOrg(wrAssn.getOrganizationID());</span>

<span class="nc bnc" id="L1116" title="All 2 branches missed.">                if (swappableOrgIDs.size() == 0) continue;</span>

<span class="nc" id="L1118">                Date effectStart = wrAssn.getStartTime();</span>
<span class="nc" id="L1119">                Date effectEnd = wrAssn.getEndTime();</span>
<span class="nc" id="L1120">                sspIDs.addAll(sspDAO.findSSPostingIDsFromSwappableEmps(empID, swappableOrgIDs,</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                    postingsFromEmpIDs, effectStart.after(start)?effectStart:start,</span>
<span class="nc bnc" id="L1122" title="All 2 branches missed.">                    effectEnd.before(end)?effectEnd:end));</span>
<span class="nc" id="L1123">            }</span>

<span class="nc" id="L1125">            return sspIDs;</span>
<span class="nc" id="L1126">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1133">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1134">			throw e;</span>
<span class="nc" id="L1135">        } catch (BbmFinderException e) {</span>
<span class="nc" id="L1136">        	m_cat.error(e,e);</span>
<span class="nc" id="L1137">        	handleException(e);</span>
<span class="nc" id="L1138">        	throw e;</span>
<span class="nc" id="L1139">        } catch (Exception e) {</span>
<span class="nc" id="L1140">            handleException(e);</span>
<span class="nc" id="L1141">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1143" title="All 4 branches missed.">            if (sspDAO != null) sspDAO.cleanUp();</span>
<span class="nc" id="L1144">            methodFinish();</span>
        }
    }

    @Override
	public Collection&lt;ShiftSwapPosting&gt; findNextShiftSwapPostings(List ssPostingIDs, long detailLevel)
			throws BbmFinderException, RmHardValidationException {
<span class="nc" id="L1151">        String _method_ = &quot;findNextShiftSwapPosting&quot;;</span>
<span class="nc" id="L1152">        methodStart(_method_, ssPostingIDs);</span>

<span class="nc" id="L1154">        ShiftSwapPostingDAO ssPostingDAO = null;</span>
        try {
<span class="nc" id="L1156">            ssPostingDAO = new ShiftSwapPostingDAO(detailLevel);</span>
<span class="nc" id="L1157">            return ssPostingDAO.findSSPostingsByIDs(ssPostingIDs, detailLevel);</span>
<span class="nc" id="L1158">		} catch (RmHardValidationException e) {</span>
			// RM exceptions are always logged before they are thrown.
			//m_cat.error(e,e);

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L1165">            handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L1166">			throw e;</span>
<span class="nc" id="L1167">        }  catch (BbmFinderException e) {</span>
<span class="nc" id="L1168">        	m_cat.error(e,e);</span>
<span class="nc" id="L1169">        	handleException(e);</span>
<span class="nc" id="L1170">        	throw e;</span>
<span class="nc" id="L1171">        } catch (Exception e) {</span>
<span class="nc" id="L1172">            handleException(e);</span>
<span class="nc" id="L1173">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L1175" title="All 4 branches missed.">            if (ssPostingDAO != null) ssPostingDAO.cleanUp();</span>
<span class="nc" id="L1176">            methodFinish();</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>