<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>BbmScheduleConflict.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">BbmScheduleConflict.java</span></div><h1>BbmScheduleConflict.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;


import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.MissingResourceException;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.verint.ejb.wfm.l10n.WfmCommonBundleKey;

/**
 * Copyright (c) 2002 Blue Pumpkin Software, inc
 * &lt;p&gt;
 * BbmScheduleConflict is an object that represents information about a hard constraint violation in the schedule, such as a
 * shift assignment that overlaps another shift assignment.
 *
 * @author Greg Fichtenholtz
 * @version 1.0
 */
public class BbmScheduleConflict implements Externalizable {
	private static final long serialVersionUID = -6701427384694969765L;

	/**
	 * shift assignment overlaps with an already existing shift assignment
	 */
	public static final int CONFLICT_OVERLAP_SHIFT = 1;

	/**
	 * one or more of the shift event assignments overlap
	 */
	public static final int CONFLICT_OVERLAP_SHIFT_EVENT = 2;

	/**
	 * shift assignment overlaps one or more calendar event assignments with the same precedence
	 */
	public static final int CONFLICT_SHIFT_OVERLAP_EVENT = 4;

	/**
	 * more than 1 shift assignment on the same org day
	 */
	public static final int CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY = 8;

	/* calendar event assignment overlaps with another calendar event assignment */
	public static final int CONFLICT_OVERLAP_EVENT = 16;

	/* recurring instance overlaps with shift assignment */
	public static final int CONFLICT_RECURRING_OVERLAP_SHIFT = 32;

	/* recurring instance overlaps with another calendar event assignment */
	public static final int CONFLICT_RECURRING_OVERLAP_EVENT = 64;

	/* recurring template overlaps with another recurring template */
	public static final int CONFLICT_OVERLAP_RECURRING = 128;

	/* one work resource cannot attend two exceptions on a day */
	public static final int CONFLICT_DUPLICATE_TEMPLATE_EXCEPTION = 256;

	/* one work resource cannot attend two exceptions on a day */
	public static final int CONFLICT_OVERLAP_RECURRING_FLOATING = 512;

	private int m_conflictType;

	/*
	 * these class members will be used to format the text of the conflict
	 * message
	 */
	private ShiftAssignment m_shiftAssignment;
	private ShiftAssignment m_shiftAssignment2;
	private CalendarEventAssignment m_calendarEvent;
	private CalendarEventAssignment m_calendarEvent2;
	private RecurringEventTemplateBase m_recEventTemplate;
	private RecurringEventTemplateBase m_recEventTemplate2;
	private Date m_orgDayStart;
	private Collection&lt;EmployeeName&gt; m_employeeNames;
	private Collection&lt;ID&gt; m_workResourceIDs;
	private Date periodStartDate;

	/**
	 * ctor
	 */
<span class="nc" id="L93">	public BbmScheduleConflict() {</span>
<span class="nc" id="L94">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L99">	public BbmScheduleConflict(ShiftAssignment shiftAssignment, CalendarEventAssignment calendarEvent) {</span>
<span class="nc" id="L100">		m_conflictType = CONFLICT_SHIFT_OVERLAP_EVENT;</span>
<span class="nc" id="L101">		m_shiftAssignment = shiftAssignment;</span>
<span class="nc" id="L102">		m_calendarEvent2 = calendarEvent;</span>
<span class="nc" id="L103">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L108">	public BbmScheduleConflict(ShiftAssignment shiftAssignment) {</span>
<span class="nc" id="L109">		m_conflictType = CONFLICT_OVERLAP_SHIFT_EVENT;</span>
<span class="nc" id="L110">		m_shiftAssignment = shiftAssignment;</span>
<span class="nc" id="L111">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L116">	public BbmScheduleConflict(ShiftAssignment shiftAssignment, ShiftAssignment shiftAssignment2) {</span>
<span class="nc" id="L117">		m_conflictType = CONFLICT_OVERLAP_SHIFT;</span>
<span class="nc" id="L118">		m_shiftAssignment = shiftAssignment;</span>
<span class="nc" id="L119">		m_shiftAssignment2 = shiftAssignment2;</span>
<span class="nc" id="L120">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L125">	public BbmScheduleConflict(ShiftAssignment shiftAssignment, ShiftAssignment shiftAssignment2, Date orgDayStart) {</span>
<span class="nc" id="L126">		m_conflictType = CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY;</span>
<span class="nc" id="L127">		m_shiftAssignment = shiftAssignment;</span>
<span class="nc" id="L128">		m_shiftAssignment2 = shiftAssignment2;</span>
<span class="nc" id="L129">		m_orgDayStart = orgDayStart;</span>
<span class="nc" id="L130">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L135">	public BbmScheduleConflict(CalendarEventAssignment calendarEvent, CalendarEventAssignment calendarEvent2) {</span>
<span class="nc" id="L136">		m_conflictType = CONFLICT_OVERLAP_EVENT;</span>
<span class="nc" id="L137">		m_calendarEvent = calendarEvent;</span>
<span class="nc" id="L138">		m_calendarEvent2 = calendarEvent2;</span>
<span class="nc" id="L139">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L144">	public BbmScheduleConflict(RecurringEventTemplateBase recEventTemplate, RecurringEventTemplateBase recEventTemplate2) {</span>
<span class="nc" id="L145">		m_conflictType = CONFLICT_OVERLAP_RECURRING;</span>
<span class="nc" id="L146">		m_recEventTemplate = recEventTemplate;</span>
<span class="nc" id="L147">		m_recEventTemplate2 = recEventTemplate2;</span>
<span class="nc" id="L148">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L153">	public BbmScheduleConflict(RecurringEventTemplateBase recEventTemplate, CalendarEventAssignment event) {</span>
<span class="nc" id="L154">		m_conflictType = CONFLICT_RECURRING_OVERLAP_EVENT;</span>
<span class="nc" id="L155">		m_recEventTemplate = recEventTemplate;</span>
<span class="nc" id="L156">		m_calendarEvent2 = event;</span>
<span class="nc" id="L157">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L162">	public BbmScheduleConflict(RecurringEventTemplateBase recEventTemplate, ShiftAssignment shift) {</span>
<span class="nc" id="L163">		m_conflictType = CONFLICT_RECURRING_OVERLAP_SHIFT;</span>
<span class="nc" id="L164">		m_recEventTemplate = recEventTemplate;</span>
<span class="nc" id="L165">		m_shiftAssignment2 = shift;</span>
<span class="nc" id="L166">	}</span>

	/**
	 * ctor
	 */
<span class="nc" id="L171">	public BbmScheduleConflict(CalendarEventAssignment event, Collection&lt;ID&gt; workResourceIDs) {</span>
<span class="nc" id="L172">		m_conflictType = CONFLICT_DUPLICATE_TEMPLATE_EXCEPTION;</span>
<span class="nc" id="L173">		m_calendarEvent = event;</span>
<span class="nc" id="L174">		m_workResourceIDs = workResourceIDs;</span>
<span class="nc" id="L175">	}</span>




	/**
	 * ctor
	 */
<span class="nc" id="L183">	public BbmScheduleConflict(RecurringEventTemplateBase recEventTemplate, Date periodStart) {</span>
<span class="nc" id="L184">		m_conflictType = CONFLICT_OVERLAP_RECURRING_FLOATING;</span>
<span class="nc" id="L185">		m_recEventTemplate = recEventTemplate;</span>
<span class="nc" id="L186">		this.periodStartDate = periodStart;</span>
<span class="nc" id="L187">	}</span>

	/**
	 * Returns an enumeration value (see above) that specifies the type of schedule conflict this object represents
	 */
	public int getConflictType() {
<span class="nc" id="L193">		return m_conflictType;</span>
	}

	/**
	 * Returns an array of possible resolutions for this conflict type. See the class BbmScheduleConflictResolutions for the
	 * definitions of the array values. Returns null if there are no possible conflict resolutions for this type of conflict
	 */
	public int[] getResolutions() {
<span class="nc bnc" id="L201" title="All 5 branches missed.">		switch (m_conflictType) {</span>
			case CONFLICT_SHIFT_OVERLAP_EVENT:
<span class="nc" id="L203">				return new int[]{BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT,</span>
						BbmScheduleConflictResolutions.RESOLUTION_REMOVE_SHIFT};

			case CONFLICT_OVERLAP_EVENT:
<span class="nc" id="L207">				return new int[]{BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT};</span>

			case CONFLICT_RECURRING_OVERLAP_EVENT:
<span class="nc" id="L210">				return new int[]{BbmScheduleConflictResolutions.RESOLUTION_REMOVE_RECURRINGINSTANCE,</span>
						BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT};

			case CONFLICT_RECURRING_OVERLAP_SHIFT:
<span class="nc" id="L214">				return new int[]{BbmScheduleConflictResolutions.RESOLUTION_REMOVE_RECURRINGINSTANCE,</span>
						BbmScheduleConflictResolutions.RESOLUTION_REMOVE_SHIFT};
			default:
<span class="nc" id="L217">				return null;</span>
		}
	}

	/**
	 * Returns the text of the schedule conflict-related message in the
	 * specified locale. The event start/end times will be displayed in the
	 * specified time zone.
	 *
	 * @deprecated by com.bluepumpkin.common.localization.Localizer public
	 *             String getLocalizedMessage(Locale locale, TimeZone tz) {
	 *             String msgID = null; Object[] params = null; SimpleDateFormat
	 *             dateFormat = new SimpleDateFormat(&quot;d MMM yyyy h:mm a&quot;,
	 *             locale); SimpleDateFormat hourOnlyFormat = new
	 *             SimpleDateFormat(&quot;h:mm a&quot;, locale); SimpleDateFormat
	 *             dayOnlyFormat = new SimpleDateFormat(&quot;d MMM yyyy&quot;, locale);
	 *             dateFormat.setTimeZone(tz); hourOnlyFormat.setTimeZone(tz);
	 *             dayOnlyFormat.setTimeZone(tz);
	 *
	 *             switch (m_conflictType) { case
	 *             CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY: msgID =
	 *             BbmEjbBundleKey
	 *             .SCHEDULE_CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY; params =
	 *             new Object[] { getEmployeeDisplayNames(locale),
	 *             dayOnlyFormat.format(m_orgDayStart)}; break;
	 *
	 *             case CONFLICT_OVERLAP_EVENT: if (m_recEventTemplate == null)
	 *             { msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_EVENT_OVERLAP;
	 *             params = new Object[] { getEmployeeDisplayNames(locale),
	 *             getEventTypeString(m_calendarEvent.getEventType(), locale),
	 *             dateFormat.format(m_calendarEvent.getStartTime()),
	 *             hourOnlyFormat.format(m_calendarEvent.getEndTime()),
	 *             getEventTypeString(m_calendarEvent2.getEventType(), locale),
	 *             dateFormat.format(m_calendarEvent2.getStartTime()),
	 *             hourOnlyFormat.format(m_calendarEvent2.getEndTime())}; } else
	 *             { msgID =
	 *             BbmEjbBundleKey.SCHEDULE_CONFLICT_RECURRING_EVENTS_OVERLAP;
	 *             params = new Object[] { getEmployeeDisplayNames(locale) }; }
	 *             break;
	 *
	 *             case CONFLICT_OVERLAP_SHIFT: msgID =
	 *             BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_OVERLAP; params = new
	 *             Object[] { getEmployeeDisplayNames(locale),
	 *             dateFormat.format(m_shiftAssignment.getStartTime()),
	 *             hourOnlyFormat.format(m_shiftAssignment.getEndTime()),
	 *             dateFormat.format(m_shiftAssignment2.getStartTime()),
	 *             hourOnlyFormat.format(m_shiftAssignment2.getEndTime())};
	 *             break;
	 *
	 *             case CONFLICT_OVERLAP_SHIFT_EVENT: msgID =
	 *             BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_EVENT_OVERLAP; params
	 *             = new Object[] { getEmployeeDisplayNames(locale),
	 *             dateFormat.format(m_shiftAssignment.getStartTime()),
	 *             hourOnlyFormat.format(m_shiftAssignment.getEndTime())};
	 *             break;
	 *
	 *             case CONFLICT_SHIFT_OVERLAP_EVENT: msgID =
	 *             BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_OVERLAP_EVENT; params
	 *             = new Object[] { getEmployeeDisplayNames(locale),
	 *             dateFormat.format(m_shiftAssignment.getStartTime()),
	 *             hourOnlyFormat.format(m_shiftAssignment.getEndTime()),
	 *             getEventTypeString(m_calendarEvent.getEventType(), locale),
	 *             dateFormat.format(m_calendarEvent.getStartTime()),
	 *             hourOnlyFormat.format(m_calendarEvent.getEndTime()) }; break;
	 *             } return StringUtil.formatMessage(BbmEjbBundleKey.BUNDLE,
	 *             locale, msgID, params); }
	 */
	/**
	 * Returns the text of the schedule conflict-related message in the specified locale. The event start/end times will be
	 * displayed in the specified time zone.
	 *
	 * @param localizer locale in which the display names are desired
	 * @param tz        TimeZone for date formatting (not sure we need it)
	 */
	public String getLocalizedMessage(Localizer localizer, TimeZone tz) {
<span class="nc" id="L292">		String msgID = null;</span>
<span class="nc" id="L293">		Object[] params = null;</span>
<span class="nc" id="L294">		Object empDispNames = null;</span>

<span class="nc bnc" id="L296" title="All 4 branches missed.">		if (m_employeeNames != null &amp;&amp; !m_employeeNames.isEmpty()) {</span>
<span class="nc" id="L297">			empDispNames = EmployeeName.getEmployeeDisplayNames(m_employeeNames, localizer);</span>
		}

<span class="nc bnc" id="L300" title="All 11 branches missed.">		switch (m_conflictType) {</span>
			case CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY:
<span class="nc" id="L302">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY;</span>
<span class="nc" id="L303">				params = new Object[]{empDispNames, localizer.formatDate(m_orgDayStart, tz, // was</span>
						// &quot;d MMM yyyy&quot;
						// before
						RegionalFormatBundleKey.MEDIUM_DATE_FORMAT)};
<span class="nc" id="L307">				break;</span>

			case CONFLICT_OVERLAP_EVENT:
<span class="nc" id="L310">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_EVENT_OVERLAP;</span>
<span class="nc" id="L311">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L313">						getEventTypeString(m_calendarEvent.getEventType(), localizer),</span>
<span class="nc" id="L314">						localizer.formatDate(m_calendarEvent.getStartTime(), tz, // was</span>
								// &quot;d MMM yyyy h:mm a&quot;
								// before
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L318">						localizer.formatDate(m_calendarEvent.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT),</span>
<span class="nc" id="L319">						getEventTypeString(m_calendarEvent2.getEventType(), localizer),</span>
<span class="nc" id="L320">						localizer.formatDate(m_calendarEvent2.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L322">						localizer.formatDate(m_calendarEvent2.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L323">				break;</span>

			case CONFLICT_OVERLAP_SHIFT:
<span class="nc" id="L326">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_OVERLAP;</span>
<span class="nc" id="L327">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L329">						localizer.formatDate(m_shiftAssignment.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L331">						localizer.formatDate(m_shiftAssignment.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT),</span>
<span class="nc" id="L332">						localizer.formatDate(m_shiftAssignment2.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L334">						localizer.formatDate(m_shiftAssignment2.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L335">				break;</span>

			case CONFLICT_OVERLAP_SHIFT_EVENT:
<span class="nc" id="L338">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_EVENT_OVERLAP;</span>
<span class="nc" id="L339">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L341">						localizer.formatDate(m_shiftAssignment.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L343">						localizer.formatDate(m_shiftAssignment.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L344">				break;</span>

			case CONFLICT_SHIFT_OVERLAP_EVENT:
<span class="nc" id="L347">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_SHIFT_OVERLAP_EVENT;</span>
<span class="nc" id="L348">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L350">						localizer.formatDate(m_shiftAssignment.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L352">						localizer.formatDate(m_shiftAssignment.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT),</span>
<span class="nc" id="L353">						getEventTypeString(m_calendarEvent2.getEventType(), localizer),</span>
<span class="nc" id="L354">						localizer.formatDate(m_calendarEvent2.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L356">						localizer.formatDate(m_calendarEvent2.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L357">				break;</span>

			case CONFLICT_OVERLAP_RECURRING:
<span class="nc" id="L360">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_RECURRING_OVERLAP;</span>
<span class="nc" id="L361">				params = new Object[]{empDispNames};</span>
<span class="nc" id="L362">				break;</span>

			case CONFLICT_OVERLAP_RECURRING_FLOATING:
<span class="nc" id="L365">				msgID = WfmCommonBundleKey.SCHEDULE_CONFLICT_RECURRING_FLOATING_OVERLAP;</span>
<span class="nc" id="L366">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L368">						localizer.formatDate(periodStartDate, tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT)};
<span class="nc" id="L370">				break;</span>

			case CONFLICT_RECURRING_OVERLAP_EVENT:
<span class="nc" id="L373">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_RECURRING_OVERLAP_EVENT;</span>
<span class="nc" id="L374">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L376">						localizer.formatDate(m_calendarEvent2.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L378">						localizer.formatDate(m_calendarEvent2.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L379">				break;</span>
			case CONFLICT_RECURRING_OVERLAP_SHIFT:
<span class="nc" id="L381">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_RECURRING_OVERLAP_SHIFT;</span>
<span class="nc" id="L382">				params = new Object[]{</span>
						empDispNames,
<span class="nc" id="L384">						localizer.formatDate(m_shiftAssignment2.getStartTime(), tz,</span>
								RegionalFormatBundleKey.MEDIUM_DATE_FORMAT, RegionalFormatBundleKey.TIME_FORMAT),
<span class="nc" id="L386">						localizer.formatDate(m_shiftAssignment2.getEndTime(), tz, RegionalFormatBundleKey.TIME_FORMAT)};</span>
<span class="nc" id="L387">				break;</span>
			case CONFLICT_DUPLICATE_TEMPLATE_EXCEPTION:
<span class="nc" id="L389">				msgID = BbmEjbBundleKey.SCHEDULE_CONFLICT_DUPLICATE_TEMPLATE_EXCEPTION;</span>
<span class="nc" id="L390">				params = new Object[]{empDispNames, localizer.formatDate(m_calendarEvent.getStartTime(), tz, // was</span>
						// &quot;d MMM yyyy&quot;
						// before
						RegionalFormatBundleKey.MEDIUM_DATE_FORMAT)};
				break;
		}
<span class="nc" id="L396">		return localizer.i18n(BbmEjbBundleKey.BUNDLE, msgID, params);</span>
		// StringUtil.formatMessage(BbmEjbBundleKey.BUNDLE, locale, msgID,
		// params);
	}

	/**
	 * This method is an internal method used by schedule conflict checkers when resolving work resource ID to employee name
	 * in order to format the conflict message. It returns the IDs of the work resources involved in the conflict.
	 */
	public Collection&lt;ID&gt; getWorkResourceIDs() {
<span class="nc" id="L406">		Collection&lt;ID&gt; listIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L407">		Collection&lt;ID&gt; workResourceIDs = null;</span>
<span class="nc" id="L408">		Collection&lt;ID&gt; workResourceIDs2 = null;</span>

<span class="nc bnc" id="L410" title="All 8 branches missed.">		switch (m_conflictType) {</span>
			case CONFLICT_OVERLAP_EVENT:
			/*
			 * two events overlap, so find the list of attendees that attend
			 * both events and return it
			 */
<span class="nc" id="L416">				workResourceIDs = m_calendarEvent.getWorkResourceIDs();</span>
<span class="nc" id="L417">				workResourceIDs2 = m_calendarEvent2.getWorkResourceIDs();</span>
<span class="nc" id="L418">				break;</span>
			case CONFLICT_OVERLAP_RECURRING:
			/*
			 * two recurring event templayes events overlap, so find the list of
			 * attendees that attend both event templates and return it
			 */
<span class="nc" id="L424">				workResourceIDs = m_recEventTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L425">				workResourceIDs2 = m_recEventTemplate2.getWorkResourceIDs();</span>
<span class="nc" id="L426">				break;</span>
			case CONFLICT_OVERLAP_RECURRING_FLOATING:
<span class="nc" id="L428">				workResourceIDs = m_recEventTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L429">				break;</span>
			case CONFLICT_RECURRING_OVERLAP_EVENT:
				// recurring instance overlap calendar event
<span class="nc" id="L432">				workResourceIDs = m_recEventTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L433">				workResourceIDs2 = m_calendarEvent2.getWorkResourceIDs();</span>
<span class="nc" id="L434">				break;</span>
			case CONFLICT_RECURRING_OVERLAP_SHIFT:
<span class="nc" id="L436">				workResourceIDs = m_recEventTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L437">				workResourceIDs2 = m_shiftAssignment2.getWorkResourceIDs();</span>
<span class="nc" id="L438">				break;</span>
			case CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY:
			case CONFLICT_OVERLAP_SHIFT:
			case CONFLICT_OVERLAP_SHIFT_EVENT:
			case CONFLICT_SHIFT_OVERLAP_EVENT:
<span class="nc" id="L443">				return m_shiftAssignment.getWorkResourceIDs();</span>
			case CONFLICT_DUPLICATE_TEMPLATE_EXCEPTION:
<span class="nc" id="L445">				workResourceIDs = m_calendarEvent.getWorkResourceIDs();</span>
<span class="nc" id="L446">				workResourceIDs2 = m_workResourceIDs;</span>
				break;
		}
<span class="nc bnc" id="L449" title="All 4 branches missed.">		if (workResourceIDs != null &amp;&amp; workResourceIDs2 != null) {</span>
			// the two event's resource should have overlap.
<span class="nc bnc" id="L451" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L452">				ID workResourceID = it.next();</span>
<span class="nc bnc" id="L453" title="All 2 branches missed.">				if (workResourceIDs2.contains(workResourceID)) {</span>
<span class="nc" id="L454">					listIDs.add(workResourceID);</span>
				}
<span class="nc" id="L456">			}</span>
		}
<span class="nc" id="L458">		return listIDs;</span>
	}

	/**
	 * This method is an internal method used by schedule conflict checkers when resolving work resource IDs to employee
	 * names in order to format the conflict message.
	 */
	public void setEmployeeNames(Collection&lt;EmployeeName&gt; names) {
<span class="nc" id="L466">		m_employeeNames = names;</span>
<span class="nc" id="L467">	}</span>

	/**
	 * Private method that returns either a single string with the employee name
	 * in a specified locale, or a collection of strings with employee names. It
	 * is used while formatting the text of the conflict message
	 *
	 * @deprecated by com.bluepumpkin.common.localization.Localizer private
	 *             Object getEmployeeDisplayNames(Locale locale) { return
	 *             EmployeeName.getEmployeeDisplayNames(m_employeeNames,
	 *             locale); }
	 */

	/**
	 * This is a method that returns an event type string given an integer event
	 * type
	 *
	 * @deprecated by com.bluepumpkin.common.localization.Localizer private
	 *             String getEventTypeString(int eventType, Locale locale) { try
	 *             { String bundleKey =
	 *             BbmEjbBundleKey.SCHEDULE_EVENT_TYPE_PREFIX + eventType;
	 *             return StringUtil.formatMessage(BbmEjbBundleKey.BUNDLE,
	 *             locale, bundleKey, null); } catch (MissingResourceException
	 *             mre) { String bundleKey =
	 *             BbmEjbLogBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE; return
	 *             StringUtil.formatMessage(BbmEjbBundleKey.BUNDLE, locale,
	 *             bundleKey, new
	 *             Object[]{NumberFactory.newInteger(eventType)}); } }
	 */

	/**
	 * This is a method that returns an event type string given an integer event type
	 */
	private String getEventTypeString(int eventType, Localizer localizer) {
		try {
<span class="nc" id="L502">			return localizer.i18n(BbmEjbBundleKey.BUNDLE, BbmEjbBundleKey.SCHEDULE_EVENT_TYPE_PREFIX + eventType);</span>
<span class="nc" id="L503">		} catch (MissingResourceException mre) {</span>
<span class="nc" id="L504">			return localizer.i18n(BbmEjbBundleKey.BUNDLE, BbmEjbBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE,</span>
<span class="nc" id="L505">					new Object[]{NumberFactory.newInteger(eventType)});</span>
		}
	}

	public ShiftAssignment getShiftAssignment() {
<span class="nc bnc" id="L510" title="All 2 branches missed.">		if (m_shiftAssignment2 != null) {</span>
<span class="nc" id="L511">			return m_shiftAssignment2;</span>
		}
<span class="nc" id="L513">		return m_shiftAssignment;</span>
	}

	public CalendarEventAssignment getCalendarEvent() {
<span class="nc bnc" id="L517" title="All 2 branches missed.">		if (m_calendarEvent2 != null) {</span>
<span class="nc" id="L518">			return m_calendarEvent2;</span>
		} else {
<span class="nc" id="L520">			return m_calendarEvent;</span>
		}
	}

	public CalendarEventAssignment getCalendarEvent2() {
<span class="nc" id="L525">		return m_calendarEvent2;</span>
	}

	public CalendarEventAssignment getCalendarEvent1() {
<span class="nc" id="L529">		return m_calendarEvent;</span>
	}


	public RecurringEventTemplateBase getRecurringTemplate() {
<span class="nc bnc" id="L534" title="All 2 branches missed.">		if (m_recEventTemplate2 != null) {</span>
<span class="nc" id="L535">			return m_recEventTemplate2;</span>
		} else {
<span class="nc" id="L537">			return m_recEventTemplate;</span>
		}
	}

	// for the convertion between this object and its corba facade object
	public Object getFirstObject() {
<span class="nc bnc" id="L543" title="All 2 branches missed.">		if (m_shiftAssignment != null) {</span>
<span class="nc" id="L544">			return m_shiftAssignment;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">		} else if (m_calendarEvent != null) {</span>
<span class="nc" id="L546">			return m_calendarEvent;</span>
<span class="nc bnc" id="L547" title="All 2 branches missed.">		} else if (m_recEventTemplate != null) {</span>
<span class="nc" id="L548">			return m_recEventTemplate;</span>
		}
<span class="nc" id="L550">		return null;</span>
	}

	public Object getSecondObject() {
<span class="nc bnc" id="L554" title="All 2 branches missed.">		if (m_shiftAssignment2 != null) {</span>
<span class="nc" id="L555">			return m_shiftAssignment2;</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">		} else if (m_calendarEvent2 != null) {</span>
<span class="nc" id="L557">			return m_calendarEvent2;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">		} else if (m_recEventTemplate2 != null) {</span>
<span class="nc" id="L559">			return m_recEventTemplate2;</span>
		}
<span class="nc" id="L561">		return null;</span>
	}

	public Date getOrgDayStart() {
<span class="nc" id="L565">		return m_orgDayStart;</span>
	}


	/**
	 * Reconstitute this object from a stream (i.e., deserialize it).
	 */
	@Override
	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="nc" id="L574">		m_conflictType = in.readInt();</span>
<span class="nc" id="L575">		m_shiftAssignment = (ShiftAssignment) in.readObject();</span>
<span class="nc" id="L576">		m_shiftAssignment2 = (ShiftAssignment) in.readObject();</span>
<span class="nc" id="L577">		m_calendarEvent = (CalendarEventAssignment) in.readObject();</span>
<span class="nc" id="L578">		m_calendarEvent2 = (CalendarEventAssignment) in.readObject();</span>
<span class="nc" id="L579">		m_recEventTemplate = (RecurringEventTemplateBase) in.readObject();</span>
<span class="nc" id="L580">		m_recEventTemplate2 = (RecurringEventTemplateBase) in.readObject();</span>
<span class="nc" id="L581">		m_orgDayStart = (Date) in.readObject();</span>
<span class="nc" id="L582">		m_employeeNames = (Collection&lt;EmployeeName&gt;) in.readObject();</span>
<span class="nc" id="L583">		periodStartDate = (Date) in.readObject();</span>
<span class="nc" id="L584">	}</span>

	/**
	 * Save the state of this object to a stream (i.e., serialize it).
	 */
	@Override
	public void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L591">		out.writeInt(m_conflictType);</span>
<span class="nc" id="L592">		out.writeObject(m_shiftAssignment);</span>
<span class="nc" id="L593">		out.writeObject(m_shiftAssignment2);</span>
<span class="nc" id="L594">		out.writeObject(m_calendarEvent);</span>
<span class="nc" id="L595">		out.writeObject(m_calendarEvent2);</span>
<span class="nc" id="L596">		out.writeObject(m_recEventTemplate);</span>
<span class="nc" id="L597">		out.writeObject(m_recEventTemplate2);</span>
<span class="nc" id="L598">		out.writeObject(m_orgDayStart);</span>
<span class="nc" id="L599">		out.writeObject(m_employeeNames);</span>
<span class="nc" id="L600">		out.writeObject(periodStartDate);</span>
<span class="nc" id="L601">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>