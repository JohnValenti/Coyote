<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FloatingEventTemplate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.model</a> &gt; <span class="el_source">FloatingEventTemplate.java</span></div><h1>FloatingEventTemplate.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.model;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Value object class that adds to the Calendar Event Template
 *               to furthur describe floating events
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.util.*;

import com.bluepumpkin.ejb.bbm.vo.FieldInfo;

<span class="nc" id="L19">public class FloatingEventTemplate extends ValueObjectAggEventTemplate {</span>
	/** meta data info. */
<span class="nc" id="L21">	private static FieldInfo m_fields = new FloatingEventTemplateFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="nc" id="L24">		return m_fields;</span>
	}

	/**
	 * this is an array that maps days of the week to the corresponding field
	 * ids in FLOATINGEVENTTABLE table that store the start/end offsets for
	 * those days
	 */
<span class="nc" id="L32">	private static final int[][] m_weekDaysToFields = new int[][] {</span>
			{ FloatingEventTemplateFields.DAY1STARTOFFSET, FloatingEventTemplateFields.DAY1ENDOFFSET },
			{ FloatingEventTemplateFields.DAY2STARTOFFSET, FloatingEventTemplateFields.DAY2ENDOFFSET },
			{ FloatingEventTemplateFields.DAY3STARTOFFSET, FloatingEventTemplateFields.DAY3ENDOFFSET },
			{ FloatingEventTemplateFields.DAY4STARTOFFSET, FloatingEventTemplateFields.DAY4ENDOFFSET },
			{ FloatingEventTemplateFields.DAY5STARTOFFSET, FloatingEventTemplateFields.DAY5ENDOFFSET },
			{ FloatingEventTemplateFields.DAY6STARTOFFSET, FloatingEventTemplateFields.DAY6ENDOFFSET },
			{ FloatingEventTemplateFields.DAY7STARTOFFSET, FloatingEventTemplateFields.DAY7ENDOFFSET } };

<span class="nc" id="L41">	private transient Collection&lt;BbmScheduleConflict&gt; conflicts = null;</span>

<span class="nc" id="L43">	private Date instanceStart = null;</span>

	public void setInstanceStart(Date date) {
<span class="nc" id="L46">		instanceStart = date;</span>
<span class="nc" id="L47">	}</span>

	public Date getInstanceStart() {
<span class="nc" id="L50">		return instanceStart;</span>
	}

	public void setConflicts(Collection&lt;BbmScheduleConflict&gt; col) {
<span class="nc" id="L54">		conflicts = col;</span>
<span class="nc" id="L55">	}</span>

	public Collection&lt;BbmScheduleConflict&gt; getConflicts() {
<span class="nc" id="L58">		return conflicts;</span>
	}

	/**
	 * Returns the type of the calendar event template object. This could be one
	 * of the int values defined as constants above: simple, floating or
	 * recurring or recurring floating
	 */
	public short getTemplateType() {
<span class="nc" id="L67">		return CalendarEventTemplate.EVENT_TEMPLATE_FLOATING;</span>
	}

	/**
	 * Returns the data structure that represents which days in the week the
	 * event can start. The data structure is an set that contains all possible
	 * days of the week when this event can start. The days of the week are
	 * enumerated using the values from the java.util.Calendar class, i.e.
	 * Calendar.SUNDAY = 1, Calendar.MONDAY = 2 and so on.
	 */
	public Set&lt;Integer&gt; getDayMap() {
<span class="nc" id="L78">		Set&lt;Integer&gt; setDayMap = new HashSet&lt;Integer&gt;();</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">		for (int i = 1; i &lt;= 7; i++) {</span>
<span class="nc bnc" id="L80" title="All 4 branches missed.">			if (isFieldValueSet(m_weekDaysToFields[i - 1][0]) &amp;&amp; !isFieldNull(m_weekDaysToFields[i - 1][0])) {</span>
<span class="nc" id="L81">				setDayMap.add(i);</span>
			}
		}
<span class="nc" id="L84">		return setDayMap;</span>
	}

	/**
	 * Sets the timezone for this floating event template
	 */
	public void setTimeZone(TimeZone tz) {
<span class="nc" id="L91">		setFieldValue(FloatingEventTemplateFields.TIMEZONE, tz);</span>
<span class="nc" id="L92">	}</span>

	/**
	 * Returns the timezone for this floating event template
	 */
	public TimeZone getTimeZone() {
<span class="nc" id="L98">		return getFieldValueTimeZone(FloatingEventTemplateFields.TIMEZONE);</span>
	}

	/**
	 * Returns the earliest time during the day for which this floating event
	 * can begin. This offset is counted in minutes in the timezone of the
	 * floating event template.
	 */
	public int getWindowDayStartOffset(int nDayOfWeek) {
<span class="nc bnc" id="L107" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L108">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L111">		return getFieldValueInt(m_weekDaysToFields[nDayOfWeek - 1][0]);</span>
	}

	/**
	 * Sets the earliest time during the day for which this floating event can
	 * begin. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public void setWindowDayStartOffset(int nDayOfWeek, int offset) {
<span class="nc bnc" id="L120" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L121">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L124">		setFieldValue(m_weekDaysToFields[nDayOfWeek - 1][0], offset);</span>
<span class="nc" id="L125">	}</span>

	/**
	 * Returns the latest time during the day for which this floating event can
	 * end. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public int getWindowDayEndOffset(int nDayOfWeek) {
<span class="nc bnc" id="L133" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L134">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L137">		return getFieldValueInt(m_weekDaysToFields[nDayOfWeek - 1][1]);</span>
	}

	/**
	 * Sets the latest time during the day for which this floating event can
	 * end. This offset is counted in minutes in the timezone of the floating
	 * event template.
	 */
	public void setWindowDayEndOffset(int nDayOfWeek, int offset) {
<span class="nc bnc" id="L146" title="All 4 branches missed.">		if (nDayOfWeek &lt; 1 || nDayOfWeek &gt; 7) {</span>
<span class="nc" id="L147">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L150">		setFieldValue(m_weekDaysToFields[nDayOfWeek - 1][1], offset);</span>
<span class="nc" id="L151">	}</span>

	/**
	 * Returns the earliest date for which this floating event can occur
	 */
	public Date getWindowStartDate() {
<span class="nc" id="L157">		return getFieldValueDate(FloatingEventTemplateFields.STARTDATE);</span>
	}

	/**
	 * Sets the earliest date for which this floating event can occur
	 */
	public void setWindowStartDate(Date dateStart) {
<span class="nc" id="L164">		setFieldValue(FloatingEventTemplateFields.STARTDATE, dateStart);</span>
<span class="nc" id="L165">	}</span>

	/**
	 * Returns the latest date for which this floating event can occur
	 */
	public Date getWindowEndDate() {
<span class="nc" id="L171">		return getFieldValueDate(FloatingEventTemplateFields.ENDDATE);</span>
	}

	/**
	 * Sets the latest date for which this floating event can occur
	 */
	public void setWindowEndDate(Date dateEnd) {
<span class="nc" id="L178">		setFieldValue(FloatingEventTemplateFields.ENDDATE, dateEnd);</span>
<span class="nc" id="L179">	}</span>

	/**
	 * @return whether or not floating event is a class
	 */
	public boolean isClass() {
<span class="nc" id="L185">		return getFieldValueBoolean(FloatingEventTemplateFields.ISCLASS);</span>
	}

	/**
	 * @param val
	 *            indicates whether or not floating event is a class
	 */
	public void setIsClass(boolean val) {
<span class="nc" id="L193">		setFieldValue(FloatingEventTemplateFields.ISCLASS, val);</span>
<span class="nc" id="L194">	}</span>

	/**
	 * @return minumum number of class sessions that must be created during the
	 *         active SP week
	 */
	public int getMinNumberOfSessions() {
<span class="nc" id="L201">		return getFieldValueInt(FloatingEventTemplateFields.MINNUMSESSIONS);</span>
	}

	/**
	 * @param val
	 *            minumum number of class sessions that must be created during
	 *            the active SP week
	 */
	public void setMinMumberOfSessions(int val) {
<span class="nc" id="L210">		setFieldValue(FloatingEventTemplateFields.MINNUMSESSIONS, val);</span>
<span class="nc" id="L211">	}</span>

	/**
	 * @return maximum number of class sessions that must be created during the
	 *         active SP week
	 */
	public int getMaxNumberOfSessions() {
<span class="nc" id="L218">		return getFieldValueInt(FloatingEventTemplateFields.MAXNUMSESSIONS);</span>
	}

	/**
	 * @param val
	 *            maximum number of class sessions that must be created during
	 *            the active SP week
	 */
	public void setMaxMumberOfSessions(int val) {
<span class="nc" id="L227">		setFieldValue(FloatingEventTemplateFields.MAXNUMSESSIONS, val);</span>
<span class="nc" id="L228">	}</span>

	/**
	 * @return minumum number of attendees that must attend a session of this
	 *         class
	 */
	public int getMinNumberOfAttendeesInSession() {
<span class="nc" id="L235">		return getFieldValueInt(FloatingEventTemplateFields.MINNUMATTENDEESINSESSION);</span>
	}

	/**
	 * @param val
	 *            minumum number of attendees that must attend a session of this
	 *            class
	 */
	public void setMinMumberOfAttendeesInSession(int val) {
<span class="nc" id="L244">		setFieldValue(FloatingEventTemplateFields.MINNUMATTENDEESINSESSION, val);</span>
<span class="nc" id="L245">	}</span>

	/**
	 * @return maximum number of attendees that must attend a session of this
	 *         class
	 */
	public int getMaxNumberOfAttendeesInSession() {
<span class="nc" id="L252">		return getFieldValueInt(FloatingEventTemplateFields.MAXNUMATTENDEESINSESSION);</span>
	}

	/**
	 * @param val
	 *            maximum number of attendees that must attend a session of this
	 *            class
	 */
	public void setMaxMumberOfAttendeesInSession(int val) {
<span class="nc" id="L261">		setFieldValue(FloatingEventTemplateFields.MAXNUMATTENDEESINSESSION, val);</span>
<span class="nc" id="L262">	}</span>

	/**
	 * @return maximum number of sessions of this class that can overlap in time
	 */
	public int getMaxSimultaneousSessions() {
<span class="nc" id="L268">		return getFieldValueInt(FloatingEventTemplateFields.MAXNUMSIMULTANEOUSSESSIONS);</span>
	}

	/**
	 * @param val
	 *            maximum number of sessions of this class that can overlap in
	 *            time
	 */
	public void setMaxSimultaneousSessions(int val) {
<span class="nc" id="L277">		setFieldValue(FloatingEventTemplateFields.MAXNUMSIMULTANEOUSSESSIONS, val);</span>
<span class="nc" id="L278">	}</span>

	/**
	 * @return is this template for only a single attendee
	 */
	public boolean getIsSingleAttendee() {
<span class="nc" id="L284">		return getFieldValueBoolean(FloatingEventTemplateFields.SINGLEATTENDEE);</span>
	}

	/**
	 * @param val
	 *            is this template for only a single attendee
	 */
	public void setIsSingleAttendee(boolean val) {
<span class="nc" id="L292">		setFieldValue(FloatingEventTemplateFields.SINGLEATTENDEE, val);</span>
<span class="nc" id="L293">	}</span>

	/**
	 * returns the name of the class
	 */
	public String getName() {
<span class="nc" id="L299">		return getFormattedFieldValue(FloatingEventTemplateFields.NAME);</span>
	}

	/**
	 * sets the name of the class
	 */
	public void setName(String val) {
<span class="nc" id="L306">		setFieldValue(FloatingEventTemplateFields.NAME, val);</span>
<span class="nc" id="L307">	}</span>

	public boolean isException() {
<span class="nc" id="L310">		return getFieldValueBoolean(FloatingEventTemplateFields.ISEXCEPTION);</span>
	}

	/**
	 * @param val
	 *            indicates whether or not floating event is a class
	 */
	public void setIsException(boolean val) {
<span class="nc" id="L318">		setFieldValue(FloatingEventTemplateFields.ISEXCEPTION, val);</span>
<span class="nc" id="L319">	}</span>

	/**
	 * Returns the earliest possible time that an instance of this floating
	 * event template may begin
	 */
	public Date getEarliestPossibleStartTime() {
		/* calculate the event start time */
<span class="nc" id="L327">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L328">		cal.setTime(getWindowStartDate());</span>
<span class="nc" id="L329">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L330">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L331">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L332">		cal.set(Calendar.MINUTE, 0);</span>

<span class="nc" id="L334">		Calendar cal2 = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L335">		cal2.setTime(getWindowEndDate());</span>
<span class="nc" id="L336">		cal2.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L337">		cal2.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L338">		cal2.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L339">		cal2.set(Calendar.MINUTE, 59);</span>

		while (true) {
<span class="nc" id="L342">			int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc bnc" id="L343" title="All 2 branches missed.">			if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc" id="L344">				cal.set(Calendar.MINUTE, getWindowDayStartOffset(dayOfWeek));</span>
<span class="nc" id="L345">				cal2.set(Calendar.MINUTE, getWindowDayStartOffset(dayOfWeek));</span>
<span class="nc bnc" id="L346" title="All 2 branches missed.">				if (cal.getTime().after(cal2.getTime())) {</span>
<span class="nc" id="L347">					break;</span>
				}
<span class="nc" id="L349">				return cal.getTime();</span>
			}
<span class="nc" id="L351">			cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L352">		}</span>
<span class="nc" id="L353">		return null;</span>
	}

	/**
	 * Returns the nth possible start time that an instance of this floating
	 * event template may begin
	 */
	public Date getStartTime(int nStartTime) {
		/* calculate the event start time */
<span class="nc" id="L362">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L363">		cal.setTime(getWindowStartDate());</span>
<span class="nc" id="L364">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L365">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L366">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L367">		cal.set(Calendar.MINUTE, 0);</span>

<span class="nc" id="L369">		Calendar cal2 = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L370">		cal2.setTime(getWindowEndDate());</span>
<span class="nc" id="L371">		cal2.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L372">		cal2.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L373">		cal2.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L374">		cal2.set(Calendar.MINUTE, 59);</span>

<span class="nc" id="L376">		int nStartMinute = nStartTime * 15;</span>

<span class="nc bnc" id="L378" title="All 2 branches missed.">		while (cal.before(cal2)) {</span>

<span class="nc" id="L380">			int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>

<span class="nc bnc" id="L382" title="All 2 branches missed.">			if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">				if (getWindowDayStartOffset(dayOfWeek) + nStartMinute &lt;= getWindowDayEndOffset(dayOfWeek)) {</span>
<span class="nc" id="L384">					cal.set(Calendar.MINUTE, getWindowDayStartOffset(dayOfWeek) + nStartMinute);</span>
<span class="nc" id="L385">					return cal.getTime();</span>
				} else {
					// this start time occurs on a future day, decrement the
					// nStartMinute
<span class="nc" id="L389">					nStartMinute -= getWindowDayEndOffset(dayOfWeek) - getWindowDayStartOffset(dayOfWeek) + 15;</span>
				}
			}
<span class="nc" id="L392">			cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L393">		}</span>
<span class="nc" id="L394">		return null;</span>
	}

	/**
	 * Return the latest possible time that some instance of this floating event
	 * template may end
	 */
	public Date getLatestPossibleStartTime() {
<span class="nc" id="L402">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L403">		cal.setTime(getWindowEndDate());</span>
<span class="nc" id="L404">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L405">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L406">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L407">		cal.set(Calendar.MINUTE, 0);</span>

<span class="nc" id="L409">		Calendar cal2 = Calendar.getInstance(getTimeZone()); // earlist start.</span>
<span class="nc" id="L410">		cal2.setTime(getWindowStartDate());</span>
<span class="nc" id="L411">		cal2.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L412">		cal2.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L413">		cal2.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L414">		cal2.set(Calendar.MINUTE, 0);</span>

		while (true) {
<span class="nc" id="L417">			int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">			if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc" id="L419">				int dayEndOffset = getWindowDayEndOffset(dayOfWeek);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">				if (dayEndOffset &gt;= 1440) {</span>
					// to fix bug 80311. Add 1440 minutes will make to next day
<span class="nc" id="L422">					dayEndOffset = 1439;</span>
				}
<span class="nc" id="L424">				cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L425">				cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L426">				cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L427">				cal.set(Calendar.MINUTE, dayEndOffset);</span>
<span class="nc" id="L428">				cal.getTime(); // force calculate</span>
<span class="nc" id="L429">				cal2.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L430">				cal2.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L431">				cal2.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L432">				cal2.set(Calendar.MINUTE, dayEndOffset);</span>
<span class="nc" id="L433">				cal2.getTime(); // force calculate</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">				if (cal2.getTime().after(cal.getTime())) {</span>
<span class="nc" id="L435">					break;</span>
				}
<span class="nc bnc" id="L437" title="All 4 branches missed.">				if (!cal.getTime().after(getWindowEndDate()) || cal.equals(cal2)) {</span>
<span class="nc" id="L438">					return cal.getTime();</span>
				}
			}
<span class="nc" id="L441">			cal.add(Calendar.DATE, -1);</span>
<span class="nc" id="L442">		}</span>
<span class="nc" id="L443">		return null;</span>
	}

	/**
	 * Return the latest possible time that some instance of this floating event
	 * template may end
	 */
	public Date getLatestPossibleEndTime() {
<span class="nc" id="L451">		Date latestStartTime = getLatestPossibleStartTime();</span>
<span class="nc bnc" id="L452" title="All 2 branches missed.">		if (latestStartTime != null) {</span>
<span class="nc" id="L453">			return new Date(latestStartTime.getTime() + getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN);</span>
		} else {
<span class="nc" id="L455">			return null;</span>
		}
	}

	/**
	 * This is a helper function that determines whether the floating event can
	 * occur on a given day of the week
	 */
	public boolean canOccurOnWeekday(int dayOfWeek) {
<span class="nc bnc" id="L464" title="All 4 branches missed.">		if (dayOfWeek &lt; 1 || dayOfWeek &gt; 7) {</span>
<span class="nc" id="L465">			throw new IllegalArgumentException();</span>
		}
<span class="nc bnc" id="L467" title="All 2 branches missed.">		return (isFieldValueSet(m_weekDaysToFields[dayOfWeek - 1][0]))</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">				&amp;&amp; (!isFieldNull(m_weekDaysToFields[dayOfWeek - 1][0]));</span>
	}

	// returns the total number of start times
	public int getStartTimeCount() {
<span class="nc" id="L473">		int nStartTimes = 0;</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">		for (int i = 1; i &lt;= 7; i++) {</span>
<span class="nc bnc" id="L475" title="All 2 branches missed.">			if (canOccurOnWeekday(i)) {</span>
<span class="nc" id="L476">				nStartTimes += 1 + (getWindowDayEndOffset(i) - getWindowDayStartOffset(i)) / 15;</span>
			}
		}
<span class="nc" id="L479">		return nStartTimes;</span>
	}

	/**
	 * Provides some rudimentary checking for validity of this event template
	 * object
	 */
	public void checkIsValid() throws java.io.InvalidObjectException {
<span class="nc" id="L487">		super.checkIsValid();</span>

		/* need to make sure that at least 1 day has a valid offset */
<span class="nc bnc" id="L490" title="All 4 branches missed.">		if ((!isFieldValueSet(FloatingEventTemplateFields.DAY1STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY1ENDOFFSET))</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY2STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY2ENDOFFSET))</span>
<span class="nc bnc" id="L492" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY3STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY3ENDOFFSET))</span>
<span class="nc bnc" id="L493" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY4STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY4ENDOFFSET))</span>
<span class="nc bnc" id="L494" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY5STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY5ENDOFFSET))</span>
<span class="nc bnc" id="L495" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY6STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY6ENDOFFSET))</span>
<span class="nc bnc" id="L496" title="All 4 branches missed.">				&amp;&amp; (!isFieldValueSet(FloatingEventTemplateFields.DAY7STARTOFFSET) || !isFieldValueSet(FloatingEventTemplateFields.DAY7ENDOFFSET))) {</span>
<span class="nc" id="L497">			throw new java.io.InvalidObjectException(&quot;windows must be set on template &quot; + toString());</span>
		}

<span class="nc bnc" id="L500" title="All 2 branches missed.">		if (isClass()) {</span>
<span class="nc" id="L501">			int[] checkFields = new int[] { FloatingEventTemplateFields.MAXNUMATTENDEESINSESSION,</span>
					FloatingEventTemplateFields.MAXNUMSESSIONS, FloatingEventTemplateFields.MAXNUMSIMULTANEOUSSESSIONS,
					FloatingEventTemplateFields.MINNUMATTENDEESINSESSION, FloatingEventTemplateFields.MINNUMSESSIONS };
<span class="nc bnc" id="L504" title="All 2 branches missed.">			for (int i = 0; i &lt; checkFields.length; i++) {</span>
<span class="nc bnc" id="L505" title="All 4 branches missed.">				if (!isFieldValueSet(checkFields[i]) || isFieldNull(checkFields[i])</span>
<span class="nc bnc" id="L506" title="All 2 branches missed.">						|| getFieldValueInt(checkFields[i]) &lt;= 0) {</span>
<span class="nc" id="L507">					throw new java.io.InvalidObjectException(&quot;class attributes must be set on template &quot; + toString());</span>
				}
			}

<span class="nc bnc" id="L511" title="All 2 branches missed.">			if (getMinNumberOfSessions() &gt; getMaxNumberOfSessions()) {</span>
<span class="nc" id="L512">				throw new java.io.InvalidObjectException(</span>
<span class="nc" id="L513">						&quot;min session must be less than or equal to max sessions on template &quot; + toString());</span>
			}

<span class="nc bnc" id="L516" title="All 2 branches missed.">			if (getMinNumberOfAttendeesInSession() &gt; getMaxNumberOfAttendeesInSession()) {</span>
<span class="nc" id="L517">				throw new java.io.InvalidObjectException(</span>
<span class="nc" id="L518">						&quot;min attendees must be less than or equal to max attendees on template &quot; + toString());</span>
			}
		}
<span class="nc" id="L521">	}</span>

	/**
	 * Returns the next available session time for a class, given the current
	 * (previous) session time. If curSessionTime is null, then returns the very
	 * first session time.
	 */
	public Date getNextSessionTime(Date curSessionTime) {
<span class="nc bnc" id="L529" title="All 2 branches missed.">		if (!isClass())</span>
<span class="nc" id="L530">			return null;</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">		if (curSessionTime == null)</span>
<span class="nc" id="L533">			return getEarliestPossibleStartTime();</span>

		// BUG 80176, port from 4.5.8 fixed by kalaivani
		// This is to terminate the loop when the latest possible end time is
		// reached
<span class="nc" id="L538">		Date latestEndTime = getLatestPossibleEndTime();</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">		if ((curSessionTime.compareTo(latestEndTime) &gt;= 0)) {</span>
<span class="nc" id="L540">			return null;</span>
		}

<span class="nc" id="L543">		Calendar cal = Calendar.getInstance(getTimeZone());</span>
<span class="nc" id="L544">		cal.setTime(curSessionTime);</span>
		// cal.add(Calendar.MINUTE, getDuration());
<span class="nc" id="L546">		cal.add(Calendar.MINUTE, 15); // I did not find a symbolic defined for</span>
										// that

<span class="nc" id="L549">		int dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc" id="L551">			int beginOffset = getWindowDayStartOffset(dayOfWeek);</span>
<span class="nc" id="L552">			int endOffset = getWindowDayEndOffset(dayOfWeek);</span>
<span class="nc" id="L553">			int curOffset = cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">			if (curOffset &lt; beginOffset) {</span>
				// must be next day, do nothing, next while loop will find next
				// session
<span class="nc bnc" id="L557" title="All 2 branches missed.">			} else if (curOffset &gt; endOffset) {</span>
				// same day, but past end offset, go to next day
<span class="nc" id="L559">				cal.add(Calendar.DATE, 1);</span>
			} else {
				// beginOffset &lt;= curOffset &lt;= endOffset - we are done
<span class="nc" id="L562">				return cal.getTime();</span>
			}
		}

<span class="nc" id="L566">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L567">		cal.set(Calendar.MINUTE, 0);</span>

<span class="nc" id="L569">		Date latestTime = getLatestPossibleStartTime();</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		while (!cal.getTime().after(latestTime)) {</span>
<span class="nc" id="L571">			dayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc bnc" id="L572" title="All 2 branches missed.">			if (canOccurOnWeekday(dayOfWeek)) {</span>
<span class="nc" id="L573">				cal.set(Calendar.MINUTE, getWindowDayStartOffset(dayOfWeek));</span>
<span class="nc" id="L574">				break;</span>
			}
<span class="nc" id="L576">			cal.add(Calendar.DATE, 1);</span>
		}
<span class="nc bnc" id="L578" title="All 2 branches missed.">		return !cal.getTime().after(latestTime) ? cal.getTime() : null;</span>
	}

	/**
	 * Reconstitute this object from a stream (i.e., deserialize it).
	 */
	public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
<span class="nc" id="L585">		super.readExternal(in);</span>
<span class="nc" id="L586">		instanceStart = (Date) in.readObject();</span>
<span class="nc" id="L587">	}</span>

	/**
	 * Save the state of this object to a stream (i.e., serialize it).
	 */
	public void writeExternal(ObjectOutput out) throws IOException {
<span class="nc" id="L593">		super.writeExternal(out);</span>
<span class="nc" id="L594">		out.writeObject(instanceStart);</span>
<span class="nc" id="L595">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>