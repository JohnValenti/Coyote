<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeSeriesManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.ejb</a> &gt; <span class="el_source">TimeSeriesManagerEJB.java</span></div><h1>TimeSeriesManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.ejb;

import java.lang.reflect.Method;
import java.rmi.RemoteException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.cache.Cache;
import com.bluepumpkin.common.cache.CacheFactory;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.JNDINames;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignDAO;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.ejb.SPQueueDAO;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignQueueFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueueFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.pulse.model.TrackingView;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.BacklogType;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastInstance;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastInterimBacklog;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTimeSeries;
import com.bluepumpkin.ejb.bbm.timeseries.model.INetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceChunk;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TimeSeriesCacheUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.bbm.forecast.ejb.ForecastProfileDAO;
import com.verint.ejb.bbm.forecast.model.ForecastProfile;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * Title:        TimeSeriesManagerEJB.java
 * Description:  TimeSeriesManager EJB implementation
 * Copyright:    Copyright (c) 2004 - 2016
 * Company:      Verint Systems, Inc.
 */

<span class="nc" id="L96">public class TimeSeriesManagerEJB extends SessionEJBBase {</span>
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
<span class="nc" id="L101">	private static final ID COMQUEID = new ID(-1);</span>
<span class="nc" id="L102">	private static final PredictTraceCube predictMetaTCNetStaff = new PredictTraceCube(new short[] { Trace.FTE, Trace.STAFFING, Trace.AFTE,</span>
			Trace.ASTAFFING, Trace.NETSTAFFING, Trace.OVER_UNDER });
<span class="nc" id="L104">	private static final RequireTraceCube requireMetaTCNetStaff = new RequireTraceCube(new short[] { Trace.FTE });</span>
<span class="nc" id="L105">	private static Category LOG = Log.initCategory(TimeSeriesManagerEJB.class.getName());</span>
	private CampaignManager m_CampaignManager;
	private TimeSeriesAuditManager m_timeSeriesAuditManager;
	private WorkloadManager m_workloadManager;
	private DBConfigManager m_dbConfigManager;
	private ActivityManager m_activityManager;
<span class="nc" id="L111">	private Cache timeSeriesCache = null;</span>
<span class="nc" id="L112">	private boolean WhatIfMode = false;</span>

	{
<span class="nc" id="L115">		super.init(TimeSeriesManagerEJB.class.getName());</span>
<span class="nc" id="L116">	}</span>

	// override the base class to provide the appropriate logging category
	@Override
	protected Category getCategory() {
<span class="nc" id="L121">		return LOG;</span>
	}

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="nc" id="L128">			Context initialContext = new InitialContext();</span>
<span class="nc" id="L129">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">			if (WIF != null) {</span>
<span class="nc" id="L131">				WhatIfMode = WIF.booleanValue();</span>
			}
<span class="nc" id="L133">			initialiseManagers();</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">			if (!WhatIfMode &amp;&amp; ConfigCacheUtil.isCacheEnabled(BbmManagerFactory.getDBConfigManager(), ConfigKey.TIMESERIES_CACHE_USAGE)) {</span>
<span class="nc" id="L135">				timeSeriesCache = CacheFactory.getCache(JNDINames.BBM_TIMESERIES_EJBHOME, TimeSeriesManagerEJB.class.getClassLoader());</span>
			}

<span class="nc" id="L138">			TimeSeriesDAO.setIgnoreFutureData(m_dbConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA));</span>
<span class="nc" id="L139">			initialiseTraceConfig();</span>
<span class="nc" id="L140">		} catch (Exception e) {</span>
<span class="nc" id="L141">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="nc" id="L142">		}</span>
<span class="nc" id="L143">	}</span>

	void initialiseManagers() throws BbmEJBCreateException {
<span class="nc" id="L146">		m_CampaignManager = WfmManagerFactory.getCampaignManager(WhatIfMode);</span>
<span class="nc" id="L147">		m_timeSeriesAuditManager = WfmManagerFactory.getTimeSeriesAuditManager(WhatIfMode);</span>
<span class="nc" id="L148">		m_workloadManager = WfmManagerFactory.getWorkloadManager(WhatIfMode);</span>
<span class="nc" id="L149">		m_dbConfigManager = BbmManagerFactory.getDBConfigManager(WhatIfMode);</span>
<span class="nc" id="L150">		m_activityManager = WfmManagerFactory.getActivityManager(WhatIfMode);</span>
<span class="nc" id="L151">	}</span>

	void initialiseTraceConfig() throws RemoteException {
<span class="nc" id="L154">		Trace.setAlwaysUseVHInsteadOfCV(m_dbConfigManager.getBooleanValue(ConfigKey.ALWAYS_USE_VOLUME_HANDLED));</span>
<span class="nc" id="L155">		setComputeSLOnIntervalHandled();</span>
<span class="nc" id="L156">		Trace.setComputeActualImmediateSLOnVHAndAbandons(m_dbConfigManager.getBooleanValue(ConfigKey.COMPUTE_ACT_IMM_SL_ON_VH_AND_ABN));</span>
<span class="nc" id="L157">	}</span>

	/**
	 * Sets Trace.setComputeSLOnIntervalHandled based on the &quot;ComputeSLOnIntervalHandled&quot; config key.
	 * If ComputeSLOnIntervalHandled is either &quot;0&quot; then the value is set to false.  In all other cases, it is set to true
	 * (to match F&amp;S thick client behavior).
	 */
	private void setComputeSLOnIntervalHandled() throws RemoteException {
<span class="nc" id="L165">		String computeSlOnIntervalHandledValue = m_dbConfigManager.getValue(ConfigKey.COMPUTE_SL_ON_INTERVAL_HANDLED);</span>
<span class="nc" id="L166">		boolean isSet = true;</span>

		try {
<span class="nc bnc" id="L169" title="All 2 branches missed.">			if (Integer.parseInt(computeSlOnIntervalHandledValue) == 0) {</span>
<span class="nc" id="L170">				isSet = false;</span>
			}
<span class="nc" id="L172">		} catch (NumberFormatException ex) {</span>
			//Do nothing here, we only diverge from the default value if the flag is present and is &quot;0&quot;
<span class="nc" id="L174">		}</span>
<span class="nc" id="L175">		Trace.setComputeSLOnIntervalHandled(isSet);</span>
<span class="nc" id="L176">	}</span>

	/**
	 * Support create Actual TimeSeries
	 *
	 * @param cube
	 * @throws BbmCreateException
	 * @throws RemoteException
	 */
	public void createTimeSeriesInCube(TraceCube cube) throws BbmCreateException {
<span class="nc" id="L186">		methodStart(&quot;createTimeSeriesInCube&quot;, cube);</span>
		try {
<span class="nc" id="L188">			TimeSeriesDAO.createTimeSeriesInCube(cube);</span>
			// if cube affect the cache, force a reload
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (timeSeriesCache != null) {</span>
<span class="nc" id="L191">				Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
				// cube cross affect the cache window
<span class="nc bnc" id="L193" title="All 4 branches missed.">				if (!cacheWindow[0].after(cube.getRawEndDate()) &amp;&amp; !cacheWindow[1].before(cube.getRawStartDate())</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">						&amp;&amp; timeSeriesCache.lock(cube.getQueueID(), -1)) {</span>
					// lock entry first, then load from DB

					try {
<span class="nc" id="L198">						Collection chunkCol = TimeSeriesDAO.getActualTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, cube.getQueueID(),</span>
								cacheWindow[0], cacheWindow[1], null);
<span class="nc" id="L200">						timeSeriesCache.put(cube.getQueueID(), chunkCol);</span>
					} finally {
<span class="nc" id="L202">						timeSeriesCache.unLock(cube.getQueueID());</span>
<span class="nc" id="L203">					}</span>

				}
			}
<span class="nc" id="L207">		} catch (JdmoException e) {</span>
<span class="nc" id="L208">			handleException(e);</span>
<span class="nc" id="L209">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L211">			methodFinish();</span>
<span class="nc" id="L212">		}</span>
<span class="nc" id="L213">	}</span>

	/**
	 * For backend usage, to create TimeSeries based on a TraceChunk
	 *
	 * @param chunk
	 */
	public void createTimeSeriesInChunk(TraceChunk chunk) throws BbmCreateException {
<span class="nc" id="L221">		methodStart(&quot;createTimeSeriesInChunk&quot;, chunk);</span>
		try {
<span class="nc" id="L223">			TimeSeriesDAO.createTimeSeriesInChunk(chunk);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">			if (timeSeriesCache != null) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">				if (timeSeriesCache.get(chunk.getQueueID()) == null) {</span>
<span class="nc" id="L226">					Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc" id="L227">					Collection chunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, chunk.getQueueID(),</span>
							cacheWindow[0], cacheWindow[1], null, false);
<span class="nc" id="L229">					timeSeriesCache.put(chunk.getQueueID(), chunkCol);</span>
<span class="nc" id="L230">				} else {</span>
<span class="nc" id="L231">					TimeSeriesCacheUtil.addInActualCache(timeSeriesCache, chunk);</span>
				}
			}
<span class="nc" id="L234">		} catch (JdmoException e) {</span>
<span class="nc" id="L235">			handleException(e);</span>
<span class="nc" id="L236">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L238">			methodFinish();</span>
<span class="nc" id="L239">		}</span>
<span class="nc" id="L240">	}</span>

	/**
	 * For backend usage, to create TimeSeries based on a TraceChunk
	 *
	 * @param chunkCol
	 */
	public void createTimeSeriesInChunks(Collection&lt;TraceChunk&gt; chunkCol) throws BbmCreateException {
<span class="nc" id="L248">		methodStart(&quot;createTimeSeriesInChunks&quot;, chunkCol);</span>
<span class="nc" id="L249">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L251">			HashMap&lt;ID, List&lt;TraceChunk&gt;&gt; queChunkMap = new HashMap&lt;ID, List&lt;TraceChunk&gt;&gt;();</span>
<span class="nc" id="L252">			HashMap&lt;ID, Date[]&gt; queWinMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">			for (TraceChunk chunk : chunkCol) {</span>
<span class="nc" id="L254">				List&lt;TraceChunk&gt; chunkList = queChunkMap.get(chunk.getQueueID());</span>
<span class="nc" id="L255">				Date[] range = queWinMap.get(chunk.getQueueID());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">				if (chunkList == null) {</span>
<span class="nc" id="L257">					chunkList = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc" id="L258">					range = new Date[2];</span>
<span class="nc" id="L259">					range[0] = chunk.getStartDate();</span>
<span class="nc" id="L260">					range[1] = chunk.getStartDate();</span>
				}
<span class="nc" id="L262">				chunkList.add(chunk);</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">				range[0] = range[0].after(chunk.getStartDate()) ? chunk.getStartDate() : range[0];</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">				range[1] = range[1].before(chunk.getStartDate()) ? chunk.getStartDate() : range[1];</span>
<span class="nc" id="L265">				queChunkMap.put(chunk.getQueueID(), chunkList);</span>
<span class="nc" id="L266">				queWinMap.put(chunk.getQueueID(), range);</span>
<span class="nc" id="L267">			}</span>
			// now work on each queue
<span class="nc bnc" id="L269" title="All 2 branches missed.">			for (ID queID : queChunkMap.keySet()) {</span>
<span class="nc" id="L270">				List&lt;TraceChunk&gt; chunkList = queChunkMap.get(queID);</span>
<span class="nc" id="L271">				Date[] range = queWinMap.get(queID);</span>
<span class="nc" id="L272">				Collection&lt;Timestamp&gt; existingTimes = TimeSeriesDAO.existingRow(queID, range[0], range[1], jdmo);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">				for (TraceChunk chunk : chunkList) {</span>
					//FIXME: This comparison will fail if the chunk's start date has non-zero
					// milliseconds.  See the Java API documentation for Timestamp for further
					// details.
<span class="nc bnc" id="L277" title="All 2 branches missed.">					if (existingTimes.contains(chunk.getStartDate())) {</span>
<span class="nc" id="L278">						TimeSeriesDAO.updateChunkForActual(chunk, jdmo);</span>
					} else {
<span class="nc" id="L280">						TimeSeriesDAO.createChunkForActual(chunk, jdmo);</span>
					}
<span class="nc" id="L282">				}</span>
<span class="nc" id="L283">			}</span>
<span class="nc" id="L284">			jdmo.executeBatch();</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">			if (timeSeriesCache != null) {</span>
<span class="nc" id="L286">				Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">				for (ID queID : queChunkMap.keySet()) {</span>
<span class="nc" id="L288">					List&lt;TraceChunk&gt; chunkList = queChunkMap.get(queID);</span>
<span class="nc" id="L289">					Date[] range = queWinMap.get(queID);</span>
					// if import range is before cache start window, just skip
<span class="nc bnc" id="L291" title="All 2 branches missed.">					if (range[1].before(cacheWindow[0])) {</span>
<span class="nc" id="L292">						continue;</span>
					}
<span class="nc bnc" id="L294" title="All 4 branches missed.">					if (timeSeriesCache.get(queID) == null || chunkList.size() &gt; 1) {</span>
<span class="nc" id="L295">						Collection loadedCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, queID, cacheWindow[0],</span>
								cacheWindow[1], null, false);
<span class="nc" id="L297">						timeSeriesCache.put(queID, loadedCol);</span>
<span class="nc" id="L298">					} else {</span>
<span class="nc" id="L299">						TimeSeriesCacheUtil.addInActualCache(timeSeriesCache, chunkList.get(0));</span>
					}
<span class="nc" id="L301">				}</span>
			}
<span class="nc" id="L303">		} catch (JdmoException e) {</span>
<span class="nc" id="L304">			handleException(e);</span>
<span class="nc" id="L305">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L307">			jdmo.cleanUp();</span>
<span class="nc" id="L308">			methodFinish();</span>
<span class="nc" id="L309">		}</span>
<span class="nc" id="L310">	}</span>

	/**
	 * Create/Update actual timeseries
	 *
	 * @param traceType
	 * @param queueIDCol
	 * @param start
	 * @param value,     given in offset
	 * @throws BbmCreateException
	 * @throws RemoteException
	 */
	public void createActualTimeSeries(short traceType, Collection queueIDCol, int value, Date start) throws BbmCreateException {
<span class="nc" id="L323">		methodStart(&quot;createActualTimeSeries&quot;, Trace.getTraceName(traceType), queueIDCol, start);</span>
		try {
<span class="nc" id="L325">			Date snappedDate = TraceUtil.snapDate(start);</span>
<span class="nc" id="L326">			TimeSeriesDAO.createActualTimeSeries(traceType, queueIDCol, value, snappedDate);</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (timeSeriesCache != null) {</span>
<span class="nc" id="L328">				Date[] window = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc bnc" id="L329" title="All 4 branches missed.">				if (!start.before(window[0]) &amp;&amp; !start.after(window[1])) {</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">					for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L331">						ID qID = (ID) it.next();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">						if (timeSeriesCache.get(qID) == null) {</span>
<span class="nc" id="L333">							Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc" id="L334">							Collection chunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, qID, cacheWindow[0],</span>
									cacheWindow[1], null, false);
<span class="nc" id="L336">							timeSeriesCache.put(qID, chunkCol);</span>
<span class="nc" id="L337">						} else {</span>
<span class="nc" id="L338">							TimeSeriesCacheUtil.addInActualCache(timeSeriesCache, qID, traceType, value, snappedDate, window);</span>
						}
<span class="nc" id="L340">					}</span>
				}
			}
<span class="nc" id="L343">		} catch (JdmoException e) {</span>
<span class="nc" id="L344">			handleException(e);</span>
<span class="nc" id="L345">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L347">			methodFinish();</span>
<span class="nc" id="L348">		}</span>
<span class="nc" id="L349">	}</span>

	/**
	 * Gets the list of months that has valid volume/aht data in the queuehistorytimeseries table
	 * @return List of month/year (Format: yyyymm)
	 * @throws BbmFinderException
	 */

	public List&lt;String&gt; getMonthYearListInActualTimeSeries(ID queueID, int nOffset) throws BbmFinderException {
<span class="nc" id="L358">		methodStart(&quot;getMonthYearListInActualTimeSeries&quot;, queueID, nOffset);</span>
		try {
<span class="nc" id="L360">			return TimeSeriesDAO.getMonthYearListInActualTimeSeries(queueID, nOffset);</span>
<span class="nc" id="L361">		} catch (JdmoException e) {</span>
<span class="nc" id="L362">			handleException(e);</span>
<span class="nc" id="L363">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L365">			methodFinish();</span>
		}
	}

	/**
	 * Gets volume/AHT from queuehistorytimeseries table that has valid data  within the data range
	 * i.e (volume/AHT &gt; 0 and wolume/AHT not null)
	 * @return ActualTraceCube
	 * @throws BbmFinderException
	 */

	public ActualTraceCube getHistoryData(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L377">		methodStart(&quot;getHistoryData&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L379">			return TimeSeriesDAO.getActualTraceCube(queueID, startDate, endDate);</span>
<span class="nc" id="L380">		} catch (final JdmoException e) {</span>
<span class="nc" id="L381">			handleException(e);</span>
<span class="nc" id="L382">			throw new BbmFinderException(e);</span>
<span class="nc" id="L383">		} catch (BbmTimeSeriesException e) {//NOSONAR</span>
<span class="nc" id="L384">			handleException(e);</span>
<span class="nc" id="L385">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L387">			methodFinish();</span>
		}
	}

	/**
	 * Gets the list of date that has valid volume/aht data in the queuehistorytimeseries table
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public List&lt;String&gt; getDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L397">		methodStart(&quot;getDayMonthYearListInActualTimeSeries&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L399">			return TimeSeriesDAO.getDayMonthYearListInActualTimeSeries(queueID, startDate, endDate);</span>
<span class="nc" id="L400">		} catch (final JdmoException e) {</span>
<span class="nc" id="L401">			handleException(e);</span>
<span class="nc" id="L402">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L404">			methodFinish();</span>
		}
	}

	/**
	 * Gets the list of week start date that has valid volume/aht data in the queuehistorytimeseries table
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public List&lt;String&gt; getWeekListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L414">		methodStart(&quot;getWeekListInActualTimeSeries&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L416">			return TimeSeriesDAO.getWeekListInActualTimeSeries(queueID, startDate, endDate);</span>

<span class="nc" id="L418">		} catch (JdmoException e) {</span>
<span class="nc" id="L419">			handleException(e);</span>
<span class="nc" id="L420">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L422">			methodFinish();</span>
		}
	}

	/**
	 * Returns a list of days (represented as dates set at 12AM GMT - only the day portion is considered) that contain
	 * history records in the QUEUEHISTORYTIMESERIES table for the given queues in the given date range.
	 */
	public List&lt;Date&gt; getDaysWithHistoryForQueues(Collection&lt;ID&gt; queueIds, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L431">		methodStart(&quot;getDaysWithHistoryForQueues&quot;, queueIds, startDate, endDate);</span>
		try {
<span class="nc" id="L433">			return TimeSeriesDAO.getDaysWithHistoryForQueues(queueIds, startDate, endDate);</span>
<span class="nc" id="L434">		} catch (JdmoException e) {</span>
<span class="nc" id="L435">			handleException(e);</span>
<span class="nc" id="L436">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L438">			methodFinish();</span>
		}
	}

	/**
	 * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
	 * with
	 * 1&gt; includeAllServiceGoalTypes set to false as the default behavior.  This means that if a service goals trace cube is expected, it will
	 * only return data for the selected service goal type even if data for multiple types exists.
	 * 2&gt; needAllValid is set to true as the default behavior.
	 * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
	 */
	public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol,
			Date start, Date end) throws BbmFinderException {
<span class="nc" id="L452">		return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, false, true);</span>
	}

	/**
	 * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
	 * with
	 * 1&gt; needAllValid is set to true as the default behavior.
	 * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
	 */
	public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol,
			Date start, Date end, boolean includeAllServiceGoalTypes) throws BbmFinderException {
<span class="nc" id="L463">		return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, includeAllServiceGoalTypes, true);</span>
	}

	/**
	 * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
	 * with
	 * 1&gt; needAllValid is set to true as the default behavior.
	 * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
	 * isNoPhantom is set to false as the default behavior.
	 */
	public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol,
			Date start, Date end, boolean includeAllServiceGoalTypes, boolean needAllValid) throws BbmFinderException {
<span class="nc" id="L475">		return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, includeAllServiceGoalTypes, true, false);</span>
	}

	/**
	 * Return TraceCube in a collection for given collection of Queue IDs for a given time range
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param needAllValid
	 * @param isNoPhantom                will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 *                                   ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol,
			Date start, Date end, boolean includeAllServiceGoalTypes, boolean needAllValid, boolean isNoPhantom) throws BbmFinderException {
<span class="nc" id="L496">		methodStart(&quot;getRawMultipleQueuesTimeSeries&quot;, metaTC, campaignID, queueIDCol, start, end);</span>
		try {
<span class="nc" id="L498">			List&lt;TraceCube&gt; cubeCol = new ArrayList&lt;TraceCube&gt;(queueIDCol.size());</span>
<span class="nc" id="L499">			short[] types = metaTC.getTraceTypes();</span>
			// build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L501">			Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueIDCol, start, end);</span>
<span class="nc" id="L502">			Map&lt;ID, Queue&gt; queMap = ValueObjectUtil.getIDObjectMap(m_workloadManager.getQueuesByIDs((Collection&lt;ID&gt;) queueIDCol));</span>
			// need special handle Predicted/Required for Queue that linked to a Campaign alone
			// it will load Predicted/Required directly from Campaign Queue

<span class="nc bnc" id="L506" title="All 4 branches missed.">			if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L507">				cubeCol = getRawMultipleQueuesTimeSeriesForPredictRequiredTC(metaTC, campaignID, queueIDCol, start, end, isNoPhantom,</span>
						types, idToSPQueueMapping, queMap);
<span class="nc bnc" id="L509" title="All 2 branches missed.">			} else if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L510">				getRawMultipleQueuesTimeSeriesForSGTC(metaTC, queueIDCol, start, end, includeAllServiceGoalTypes, cubeCol, types,</span>
						idToSPQueueMapping);
			} else {
				// dump for real queue
<span class="nc bnc" id="L514" title="All 2 branches missed.">				for (ID queueID : queueIDCol) {</span>
<span class="nc" id="L515">					Queue queue = queMap.get(queueID);</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">					if (queue == null) {</span>
<span class="nc" id="L517">						queue = m_workloadManager.getQueueByID(queueID);</span>
					}
					//for virtual queue, the actual will be read from children and combined
					//Sameet, Oct 2009, QC# 45750
<span class="nc bnc" id="L521" title="All 2 branches missed.">					if (metaTC instanceof ActualTraceCube</span>
<span class="nc bnc" id="L522" title="All 4 branches missed.">							&amp;&amp; (queue.getQueueType() == Queue.QUEUE_TYPE_VIRTUAL || queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED)) {</span>
<span class="nc" id="L523">						getRawMultipleQueuesTimeSeriesForActualTC(metaTC, start, end, needAllValid, cubeCol, types, idToSPQueueMapping,</span>
								m_workloadManager, queueID, queMap);
					} else {
<span class="nc" id="L526">						cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping,</span>
								queMap));
					}
<span class="nc" id="L529">				}</span>
			}
<span class="nc" id="L531">			return cubeCol;</span>
<span class="nc" id="L532">		} catch (Exception e) {</span>
<span class="nc" id="L533">			handleException(e);</span>
<span class="nc" id="L534">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L536">			methodFinish();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param needAllValid
	 * @param cubeCol
	 * @param types
	 * @param idToSPQueueMapping
	 * @param workloadManager
	 * @param queueID
	 * @throws Exception
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws BbmTimeSeriesException
	 */
	private void getRawMultipleQueuesTimeSeriesForActualTC(TraceCube metaTC, Date start, Date end, boolean needAllValid,
			List&lt;TraceCube&gt; cubeCol, short[] types, Map&lt;ID, SPQueue&gt; idToSPQueueMapping, WorkloadManager workloadManager, ID queueID,
			Map&lt;ID, Queue&gt; queMap) throws Exception {
		//ESR#4226602: WFM - Staffing figures not Populating for virtual Queues.
<span class="nc bnc" id="L559" title="All 4 branches missed.">		if (types.length == 1 &amp;&amp; types[0] == Trace.STAFFING) {</span>
<span class="nc" id="L560">			cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, queMap));</span>
		} else {
<span class="nc" id="L562">			Collection&lt;ID&gt; subQueIDs = workloadManager.getSubQueues(Collections.singletonList(queueID));</span>
<span class="nc bnc" id="L563" title="All 4 branches missed.">			if (subQueIDs != null &amp;&amp; !subQueIDs.isEmpty()) {</span>
<span class="nc" id="L564">				List&lt;TraceCube&gt; subCubeCol = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; i = subQueIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L566">					ID subQueueID = i.next();</span>
<span class="nc" id="L567">					subCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, subQueueID, start, end, null, idToSPQueueMapping,</span>
							queMap));
<span class="nc" id="L569">				}</span>
<span class="nc" id="L570">				TraceCube cmbCube = TraceOperatorAdapter.combineQueue(subCubeCol, needAllValid, WhatIfMode);</span>
<span class="nc" id="L571">				cmbCube.setQueueID(queueID);</span>
<span class="nc" id="L572">				cubeCol.add(cmbCube);</span>
<span class="nc" id="L573">			} else {</span>
				//add empty actual cube
<span class="nc" id="L575">				cubeCol.add(metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes()));</span>
			}
		}
<span class="nc" id="L578">	}</span>

	/**
	 * @param metaTC
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param cubeCol
	 * @param types
	 * @param idToSPQueueMapping
	 * @throws JdmoException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRawMultipleQueuesTimeSeriesForSGTC(TraceCube metaTC, Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end,
			boolean includeAllServiceGoalTypes, List&lt;TraceCube&gt; cubeCol, short[] types, Map&lt;ID, SPQueue&gt; idToSPQueueMapping)
			throws JdmoException, Exception, BbmTimeSeriesException {
		// Get skill based info and media ID
<span class="nc" id="L597">		Jdmo jdmo = new Jdmo();</span>
		// Special handling for non-skillBased
<span class="nc" id="L599">		Set&lt;ID&gt; nonSkillBasedSPSet = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L600">		List&lt;Date[]&gt; nonSkillRangeSet = new ArrayList&lt;Date[]&gt;();</span>
<span class="nc" id="L601">		String mediaDeID = null;</span>
		try {
<span class="nc" id="L603">			String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE from QUEUE A, SPQUEUE B, SP C where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? order by C.FROMDATE asc&quot;;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">			for (ID queueID : queueIDCol) {</span>
<span class="nc" id="L605">				JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L606">				jQuery1.setParID(1, queueID);</span>
<span class="nc" id="L607">				jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L608">				jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L609">				JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				while (rs1.next()) {</span>
<span class="nc" id="L611">					boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L612">					mediaDeID = rs1.getString(2);</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">					if (!skillBased) {</span>
<span class="nc" id="L614">						nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L615">						Date[] range = new Date[2];</span>
<span class="nc" id="L616">						range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L617">						range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L618">						nonSkillRangeSet.add(range);</span>
					}
<span class="nc" id="L620">				}</span>
<span class="nc" id="L621">				rs1.close();</span>
<span class="nc" id="L622">				jQuery1.close();</span>
<span class="nc" id="L623">				TraceCube sgCube = null;</span>
<span class="nc" id="L624">				Collection&lt;TraceChunk&gt; sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, queueID, start, end,</span>
						null, includeAllServiceGoalTypes);
<span class="nc bnc" id="L626" title="All 2 branches missed.">				if (!nonSkillRangeSet.isEmpty()) {</span>
					//  non skill SG is direct load
<span class="nc" id="L628">					sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(queueID, nonSkillBasedSPSet, mediaDeID, start, end, null,</span>
							includeAllServiceGoalTypes, idToSPQueueMapping);
				}
<span class="nc bnc" id="L631" title="All 4 branches missed.">				if (!sgCol.isEmpty() || sgCube == null) {</span>
					// merge
<span class="nc bnc" id="L633" title="All 2 branches missed.">					if (sgCube == null) {</span>
						// simply create a new cube
<span class="nc" id="L635">						sgCube = metaTC.newInstance(queueID, start, end, types);</span>
					}
					// merge sgCol to sgCube
<span class="nc bnc" id="L638" title="All 2 branches missed.">					for (Iterator&lt;TraceChunk&gt; itChunk = sgCol.iterator(); itChunk.hasNext();) {</span>
<span class="nc" id="L639">						TraceChunk chunk = itChunk.next();</span>
<span class="nc" id="L640">						sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="nc" id="L641">					}</span>

				}
<span class="nc" id="L644">				cubeCol.add(sgCube);</span>
<span class="nc" id="L645">			}</span>
			// need merge two cubes
		} finally {
<span class="nc" id="L648">			jdmo.cleanUp();</span>
<span class="nc" id="L649">		}</span>
<span class="nc" id="L650">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param isNoPhantom
	 * @param types
	 * @param idToSPQueueMapping
	 * @return
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmFinderException
	 * @throws BbmObjectNotFoundException
	 * @throws BbmTimeSeriesException
	 */
	@SuppressWarnings(&quot;deprecation&quot;)
	private List&lt;TraceCube&gt; getRawMultipleQueuesTimeSeriesForPredictRequiredTC(TraceCube metaTC, ID campaignID,
			Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end, boolean isNoPhantom, short[] types,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Map&lt;ID, Queue&gt; queMap) throws RemoteException, Exception, BbmFinderException,
			BbmObjectNotFoundException, BbmTimeSeriesException {
		List&lt;TraceCube&gt; cubeCol;
		// load individually as usual
		// dump for real queue
<span class="nc" id="L676">		TimeSeriesDAO.setIgnoreFutureData(m_dbConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA));</span>
		//SAmeet Loading the Timeseries cube for individual QUEUES
<span class="nc" id="L678">		Map&lt;ID, TraceCube&gt; cubeMap = TimeSeriesDAO2.getTraceCubeMapByQueueIDs(metaTC, queueIDCol, start, end, null,</span>
				idToSPQueueMapping, isNoPhantom, queMap);
		// call Campaign Manager to obtain list of SPQueueID meets this requirement, find SP only has on queue
		//Sameet get all SPs for the campaign and create a hashmap SP&lt;&gt; QUEUES for all sps
<span class="nc" id="L682">		Collection&lt;CampaignQueue&gt; cpgQueCol = m_CampaignManager.getCampaignQueueAssignmentsAndCombinedQueues(campaignID, start, end);</span>
<span class="nc" id="L683">		Map&lt;ID, List&lt;CampaignQueue&gt;&gt; spCpgQueMap = new HashMap&lt;&gt;(); //hashmap that holds SP ID&lt;--&gt; Arraylist of QUEUES for all sps</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		for (CampaignQueue cpgQue : cpgQueCol) {</span>
<span class="nc" id="L685">			ID spID = cpgQue.getSPID();</span>
<span class="nc" id="L686">			List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">			if (cpqQueList == null) {</span>
<span class="nc" id="L688">				cpqQueList = new ArrayList&lt;CampaignQueue&gt;();</span>
			}
<span class="nc" id="L690">			cpqQueList.add(cpgQue);</span>
<span class="nc" id="L691">			spCpgQueMap.put(spID, cpqQueList);</span>
<span class="nc" id="L692">		}</span>
		// find SP that only has one Queue linked
		//Sameet: if the ArrayList of queues for SP has two queues then it is definitely having only one real queue
<span class="nc" id="L695">		Map&lt;ID, CampaignQueue&gt; spQueIDMap = new HashMap&lt;ID, CampaignQueue&gt;(); //Hashmap containing  SP ID&lt;--&gt; queue for SP that have only one QUEUE</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">		for (ID spID : spCpgQueMap.keySet()) {</span>
<span class="nc" id="L697">			List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="nc bnc" id="L698" title="All 2 branches missed.">			if (cpqQueList.size() == 2) {</span>
				// if cpgQue list size is 2, check if the media is Phone or not
<span class="nc" id="L700">				CampaignQueue cpgQue1 = cpqQueList.get(0); //INDV QUEUE ; always normal queue</span>
<span class="nc" id="L701">				CampaignQueue cpgQue2 = cpqQueList.get(1); //combined queue</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">				CampaignQueue medQue = cpgQue1.getMediaID() == null ? cpgQue2 : cpgQue1; //getMediaID is always always null for cpgQue1;( real queues)</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">				CampaignQueue relQue = cpgQue1.getQueueID() == null ? cpgQue2 : cpgQue1; //getQueueID will never be null for cpgQue1</span>
				// TODO eclingman Not clear what this logic does, so we still need
				// to verify that we don't need face to face test as well as phone test
<span class="nc bnc" id="L706" title="All 4 branches missed.">				if (medQue.getMediaID().equals(Media.MEDIA_ID_PHONE) &amp;&amp; queueIDCol.contains(relQue.getQueueID())) {</span>
					// if Map has no entry for the SP ID, just put the placeholder
<span class="nc" id="L708">					spQueIDMap.put(relQue.getSPID(), relQue);</span>
				}
			}
<span class="nc" id="L711">		}</span>

		// now if SP is not empty, check SP is skill base or not.
		//If the SP is skill based then remove it from the Hashmap
<span class="nc bnc" id="L715" title="All 2 branches missed.">		if (!spQueIDMap.isEmpty()) {</span>
<span class="nc" id="L716">			Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriodsByID(spQueIDMap.keySet());</span>
<span class="nc bnc" id="L717" title="All 2 branches missed.">			for (SchedulingPeriod sp : spCol) {</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">				if (sp.getSkillBased()) {</span>
<span class="nc" id="L719">					spQueIDMap.remove(sp.getID());</span>
				}
<span class="nc" id="L721">			}</span>
			// load in one by one, then merge
<span class="nc bnc" id="L723" title="All 2 branches missed.">			if (!spQueIDMap.isEmpty()) {</span>
<span class="nc" id="L724">				TraceCube combQueCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID,</span>
<span class="nc" id="L725">						Media.MEDIA_ID_PHONE, spQueIDMap.keySet(), start, end, null, false, idToSPQueueMapping, isNoPhantom);</span>
				// merge sp by sp
<span class="nc bnc" id="L727" title="All 2 branches missed.">				for (ID spID : spQueIDMap.keySet()) {</span>
<span class="nc" id="L728">					CampaignQueue cpgQue = spQueIDMap.get(spID);</span>
<span class="nc" id="L729">					ID queID = cpgQue.getQueueID();</span>
<span class="nc" id="L730">					TraceCube queCube = cubeMap.get(queID); //get tracecube for the real queue (this cube is acquired above)</span>
<span class="nc bnc" id="L731" title="All 2 branches missed.">					if (queCube == null) {</span>
						// queue itself has no data, need create a new cube, and merge combined into it
<span class="nc" id="L733">						queCube = metaTC.newInstance(queID, start, end, metaTC.getTraceTypes());</span>
<span class="nc" id="L734">						cubeMap.put(queID, queCube);</span>
					}
					// merge data now per SP window
<span class="nc bnc" id="L737" title="All 2 branches missed.">					Date qStart = cpgQue.getStartTime().after(start) ? cpgQue.getStartTime() : start;</span>
<span class="nc bnc" id="L738" title="All 2 branches missed.">					Date qEnd = cpgQue.getEndTime().after(end) ? end : cpgQue.getEndTime();</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">					for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L740">						short type = types[i];</span>
<span class="nc" id="L741">						double[] value = combQueCube.getTraceValueD(type, qStart, qEnd);</span>
						//Note**** We return SPQUEUEID of COMBINED QUEUE instead of that of the individual queue but it is ok ***********
						//Bad hack as usual but seems fine. we pass all the data for combined queue so returning the SPQUEUEID of combined queue is also OK
<span class="nc bnc" id="L744" title="All 4 branches missed.">						if (queCube != null &amp;&amp; combQueCube != null) {</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">							if (combQueCube.getSPQueueSID() != null) {</span>
<span class="nc" id="L746">								queCube.setSPQueueSID(combQueCube.getSPQueueSID());</span>
							}
<span class="nc bnc" id="L748" title="All 2 branches missed.">							if (combQueCube.getCampaignTimeZoneID() != null) {</span>
<span class="nc" id="L749">								queCube.setCampaignTimeZoneID(combQueCube.getCampaignTimeZoneID());</span>
							}
						}
<span class="nc bnc" id="L752" title="All 2 branches missed.">						if (queCube != null) {</span>
<span class="nc" id="L753">							queCube.setTraceValue(type, value, qStart);</span>
						}
					}
<span class="nc" id="L756">				}</span>
			}
		}
		// convert map to collection
<span class="nc" id="L760">		cubeCol = new ArrayList&lt;TraceCube&gt;(cubeMap.values());</span>
<span class="nc" id="L761">		return cubeCol;</span>
	}

	/**
	 * Return TraceCube in a collection for given collection of Queue IDs for a given time range
	 *
	 * @param tv
	 * @param campaignID
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public HashMap getRefreshedRawMultipleQueuesTimeSeries(TrackingView tv, ID campaignID, Collection&lt;ID&gt; queueIDCol, Date start, Date end,
			Date lastCheck) throws BbmFinderException {
<span class="nc" id="L778">		methodStart(&quot;getRefreshedRawMultipleQueuesTimeSeries&quot;, tv, campaignID, queueIDCol, start, end);</span>
		try {
			// build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L781">			Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueIDCol, start, end);</span>
<span class="nc" id="L782">			TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L783">			HashMap queCubesMap = new HashMap(queueIDCol.size());</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">			for (int i = 0; i &lt; metaCubes.length; i++) {</span>
<span class="nc" id="L785">				TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L786" title="All 2 branches missed.">				if (metaTC == null) {</span>
<span class="nc" id="L787">					continue;</span>
				}
<span class="nc" id="L789">				ArrayList cubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc" id="L790">				short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
					// Get skill based info and media ID
<span class="nc" id="L793">					Jdmo jdmo = new Jdmo();</span>
					// Special handling for non-skillBased
<span class="nc" id="L795">					HashSet nonSkillBasedSPSet = new HashSet();</span>
<span class="nc" id="L796">					ArrayList nonSkillRangeSet = new ArrayList();</span>
<span class="nc" id="L797">					String mediaDeID = null;</span>
<span class="nc" id="L798">					ID mediaID = null;</span>
					try {
<span class="nc" id="L800">						String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE, D.SID from QUEUE A, SPQUEUE B, SP C, MEDIA D where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? and D.ID=A.MEDIAID order by C.FROMDATE asc&quot;;</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">						for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L802">							ID queueID = (ID) it.next();</span>
<span class="nc" id="L803">							JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L804">							jQuery1.setParID(1, queueID);</span>
<span class="nc" id="L805">							jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L806">							jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L807">							JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">							while (rs1.next()) {</span>
<span class="nc" id="L809">								boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L810">								mediaDeID = rs1.getString(2);</span>
<span class="nc" id="L811">								mediaID = rs1.getID(6);</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">								if (!skillBased) {</span>
<span class="nc" id="L813">									nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L814">									Date[] range = new Date[2];</span>
<span class="nc" id="L815">									range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L816">									range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L817">									nonSkillRangeSet.add(range);</span>
								}
<span class="nc" id="L819">							}</span>
<span class="nc" id="L820">							rs1.close();</span>
<span class="nc" id="L821">							jQuery1.close();</span>
<span class="nc" id="L822">							TraceCube sgCube = null;</span>
<span class="nc" id="L823">							Collection sgCol = Collections.emptyList();</span>
							// check each queue's SG trace
<span class="nc bnc" id="L825" title="All 2 branches missed.">							boolean hasChange = lastCheck == null;</span>
<span class="nc bnc" id="L826" title="All 4 branches missed.">							if (!hasChange &amp;&amp; !nonSkillRangeSet.isEmpty()) {</span>
<span class="nc" id="L827">								hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC),</span>
										start, end, lastCheck);
							}
<span class="nc bnc" id="L830" title="All 2 branches missed.">							if (!hasChange) {</span>
<span class="nc" id="L831">								hasChange = m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start,</span>
										end, lastCheck);
							}
<span class="nc bnc" id="L834" title="All 2 branches missed.">							if (hasChange) {</span>
<span class="nc" id="L835">								sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, queueID, start, end, null,</span>
										false);
<span class="nc bnc" id="L837" title="All 2 branches missed.">								if (!nonSkillRangeSet.isEmpty()) {</span>
									//  non skill SG is direct load, check campaign media queue's SG trace
<span class="nc bnc" id="L839" title="All 2 branches missed.">									if (!sgCol.isEmpty()) {</span>
<span class="nc" id="L840">										sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(queueID, nonSkillBasedSPSet, mediaDeID,</span>
												start, end, null, false, idToSPQueueMapping);
									}
								}
<span class="nc bnc" id="L844" title="All 4 branches missed.">								if (!sgCol.isEmpty() || sgCube == null) {</span>
									// merge
<span class="nc bnc" id="L846" title="All 2 branches missed.">									if (sgCube == null) {</span>
										// simply create a new cube
<span class="nc" id="L848">										sgCube = metaTC.newInstance(queueID, start, end, types);</span>
									}
									// merge sgCol to sgCube
<span class="nc bnc" id="L851" title="All 2 branches missed.">									for (Iterator itChunk = sgCol.iterator(); itChunk.hasNext();) {</span>
<span class="nc" id="L852">										TraceChunk chunk = (TraceChunk) itChunk.next();</span>
<span class="nc" id="L853">										sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="nc" id="L854">									}</span>
								}
							}
<span class="nc" id="L857">							cubeCol.add(sgCube);</span>
<span class="nc" id="L858">						}</span>
					} finally {
<span class="nc" id="L860">						jdmo.cleanUp();</span>
<span class="nc" id="L861">					}</span>
<span class="nc" id="L862">				} else {</span>
					// dump for real queue
<span class="nc bnc" id="L864" title="All 2 branches missed.">					for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L865">						ID queueID = (ID) it.next();</span>
						// for actual, we just fetch the changes
<span class="nc bnc" id="L867" title="All 2 branches missed.">						if (metaTC instanceof ActualTraceCube) {</span>
							// read from cache
<span class="nc bnc" id="L869" title="All 2 branches missed.">							if (timeSeriesCache != null) {</span>
<span class="nc" id="L870">								cubeCol.add(TimeSeriesCacheUtil.readFromActualcache(timeSeriesCache, queueID, start, end, lastCheck));</span>
							} else {
								// read from DB
<span class="nc" id="L873">								cubeCol.add(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, lastCheck,</span>
										idToSPQueueMapping));
							}
						} else {
<span class="nc bnc" id="L877" title="All 2 branches missed.">							if (lastCheck == null</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">									|| m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end,</span>
											lastCheck)) {
<span class="nc" id="L880">								cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null,</span>
										idToSPQueueMapping, null));
							}
						}
<span class="nc" id="L884">					}</span>
				}
				// final step add each queue's cube into map
<span class="nc bnc" id="L887" title="All 2 branches missed.">				for (Iterator it = cubeCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L888">					TraceCube cube = (TraceCube) it.next();</span>
<span class="nc" id="L889">					TraceCube[] realCubes = (TraceCube[]) queCubesMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L890" title="All 2 branches missed.">					if (realCubes == null) {</span>
<span class="nc" id="L891">						realCubes = new TraceCube[metaCubes.length];</span>
					}
<span class="nc" id="L893">					realCubes[i] = cube;</span>
<span class="nc" id="L894">					queCubesMap.put(cube.getQueueID(), realCubes);</span>
<span class="nc" id="L895">				}</span>
			}
			//need to do the computations here fo all trace cubes  second element = forcast &amp; third is predict
<span class="nc bnc" id="L898" title="All 2 branches missed.">			for (Iterator iterator = queCubesMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L899">				TraceCube[] queCubes = (TraceCube[]) iterator.next();</span>
<span class="nc" id="L900">				TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(queCubes);</span>
<span class="nc" id="L901">			}</span>
<span class="nc" id="L902">			return queCubesMap;</span>
<span class="nc" id="L903">		} catch (Exception e) {</span>
<span class="nc" id="L904">			handleException(e);</span>
<span class="nc" id="L905">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L907">			methodFinish();</span>
		}
	}

	/**
	 * Return HashMap of TraceCube in a collection for given collection of Queue IDs for a given time range
	 *
	 * @param tv
	 * @param campaignID
	 * @param nonRealQueueID
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public TraceCube[] getRefreshedRawNonRealQueueTimeSeries(TrackingView tv, ID campaignID, ID nonRealQueueID, int qType,
			Collection queueIDCol, Date start, Date end, Date lastCheck) throws BbmFinderException {//NOSONAR
<span class="nc" id="L927">		methodStart(&quot;getRefreshedRawNonRealQueueTimeSeries&quot;, tv, nonRealQueueID, queueIDCol, start, end);</span>
		try {
<span class="nc" id="L929">			TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L930">			HashMap queueCubeMap = new HashMap(queueIDCol.size());</span>
<span class="nc" id="L931">			boolean ForecastChanged = false;</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">			for (int i = 0; i &lt; metaCubes.length; i++) {</span>
<span class="nc" id="L933">				TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L934" title="All 2 branches missed.">				if (metaTC == null) {</span>
<span class="nc" id="L935">					continue;</span>
				}
<span class="nc" id="L937">				ArrayList cubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc" id="L938">				short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
					// Get skill based info and media ID
<span class="nc" id="L941">					Jdmo jdmo = new Jdmo();</span>
					// Special handling for non-skillBased
<span class="nc" id="L943">					HashSet nonSkillBasedSPSet = new HashSet();</span>
<span class="nc" id="L944">					ArrayList nonSkillRangeSet = new ArrayList();</span>
<span class="nc" id="L945">					String mediaDeID = null;</span>
<span class="nc" id="L946">					ID mediaID = null;</span>
					try {
<span class="nc" id="L948">						String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE, D.SID from QUEUE A, SPQUEUE B, SP C, MEDIA D where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? and D.ID=A.MEDIAID order by C.FROMDATE asc&quot;;</span>
<span class="nc" id="L949">						JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L950">						jQuery1.setParID(1, nonRealQueueID);</span>
<span class="nc" id="L951">						jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L952">						jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L953">						JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L954" title="All 2 branches missed.">						while (rs1.next()) {</span>
<span class="nc" id="L955">							boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L956">							mediaDeID = rs1.getString(2);</span>
<span class="nc" id="L957">							mediaID = rs1.getID(6);</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">							if (!skillBased) {</span>
<span class="nc" id="L959">								nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L960">								Date[] range = new Date[2];</span>
<span class="nc" id="L961">								range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L962">								range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L963">								nonSkillRangeSet.add(range);</span>
							}
<span class="nc" id="L965">						}</span>
<span class="nc" id="L966">						rs1.close();</span>
<span class="nc" id="L967">						jQuery1.close();</span>
<span class="nc" id="L968">						TraceCube sgCube = null;</span>
<span class="nc" id="L969">						Collection sgCol = Collections.emptyList();</span>
						// check each queue's SG trace
<span class="nc bnc" id="L971" title="All 2 branches missed.">						boolean hasChange = lastCheck == null;</span>
<span class="nc bnc" id="L972" title="All 4 branches missed.">						if (!hasChange &amp;&amp; !nonSkillRangeSet.isEmpty()) {</span>
<span class="nc" id="L973">							hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC), start,</span>
									end, lastCheck);
						}
<span class="nc bnc" id="L976" title="All 2 branches missed.">						if (!hasChange) {</span>
<span class="nc" id="L977">							hasChange = m_timeSeriesAuditManager.hasChange(null, null, nonRealQueueID, TraceUtil.getAreaType(metaTC),</span>
									start, end, lastCheck);
						}
<span class="nc bnc" id="L980" title="All 2 branches missed.">						if (hasChange) {</span>
<span class="nc" id="L981">							sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, nonRealQueueID, start, end, null,</span>
									false);
<span class="nc bnc" id="L983" title="All 2 branches missed.">							if (!nonSkillRangeSet.isEmpty()) {</span>
								//  non skill SG is direct load, check campaign media queue's SG trace
<span class="nc bnc" id="L985" title="All 2 branches missed.">								if (!sgCol.isEmpty()) {</span>
<span class="nc" id="L986">									sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(nonRealQueueID, nonSkillBasedSPSet, mediaDeID,</span>
											start, end, null, false,
<span class="nc" id="L988">											m_CampaignManager.getIDToSPQueueMapping(campaignID, nonRealQueueID, start, end));</span>
								}
							}
<span class="nc bnc" id="L991" title="All 4 branches missed.">							if (!sgCol.isEmpty() || sgCube == null) {</span>
								// merge
<span class="nc bnc" id="L993" title="All 2 branches missed.">								if (sgCube == null) {</span>
									// simply create a new cube
<span class="nc" id="L995">									sgCube = metaTC.newInstance(nonRealQueueID, start, end, types);</span>
								}
								// merge sgCol to sgCube
<span class="nc bnc" id="L998" title="All 2 branches missed.">								for (Iterator itChunk = sgCol.iterator(); itChunk.hasNext();) {</span>
<span class="nc" id="L999">									TraceChunk chunk = (TraceChunk) itChunk.next();</span>
<span class="nc" id="L1000">									sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="nc" id="L1001">								}</span>
							}
						}
<span class="nc bnc" id="L1004" title="All 2 branches missed.">						if (sgCube != null) {</span>
<span class="nc" id="L1005">							cubeCol.add(sgCube);</span>
						}
					} finally {
<span class="nc" id="L1008">						jdmo.cleanUp();</span>
<span class="nc" id="L1009">					}</span>
<span class="nc" id="L1010">				} else {</span>
					// dump for real queue
<span class="nc bnc" id="L1012" title="All 4 branches missed.">					if (metaTC instanceof ActualTraceCube &amp;&amp; !queueIDCol.isEmpty()) {</span>
						// for actual, we just fetch the changes
						// read from DB
<span class="nc" id="L1015">						cubeCol.addAll(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueIDCol, start, end, lastCheck));</span>
					} else {
<span class="nc bnc" id="L1017" title="All 2 branches missed.">						if (qType == Queue.QUEUE_TYPE_VIRTUAL) {</span>
							// virtual queue, direct load based on queueID for everything
<span class="nc bnc" id="L1019" title="All 2 branches missed.">							if (lastCheck == null</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">									|| m_timeSeriesAuditManager.hasChange(null, null, nonRealQueueID, TraceUtil.getAreaType(metaTC), start,</span>
											end, lastCheck)) {
<span class="nc" id="L1022">								cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, nonRealQueueID, start, end, null,</span>
<span class="nc" id="L1023">										m_CampaignManager.getIDToSPQueueMapping(campaignID, nonRealQueueID, start, end), null));</span>
							}
							// but for Predicted/Required, still may need load from Combined Media Phone
						} else {
<span class="nc" id="L1027">							boolean hasChange = false;</span>
<span class="nc bnc" id="L1028" title="All 2 branches missed.">							for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1029">								ID queueID = (ID) it.next();</span>
								// for distributed queue, load each queue individually
<span class="nc bnc" id="L1031" title="All 2 branches missed.">								if (lastCheck == null</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">										|| m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start,</span>
												end, lastCheck)) {
<span class="nc" id="L1034">									hasChange = true;</span>
								}
<span class="nc" id="L1036">							}</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">							if (hasChange) {</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">								if (i == 1) {</span>
<span class="nc" id="L1039">									ForecastChanged = true;</span>
								}
<span class="nc bnc" id="L1041" title="All 2 branches missed.">								for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1042">									ID queueID = (ID) it.next();</span>
<span class="nc" id="L1043">									cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null,</span>
<span class="nc" id="L1044">											m_CampaignManager.getIDToSPQueueMapping(campaignID, queueID, start, end), null));</span>

									/*TODO: Sameet: this needs to be changed here to accomdate
									Forcast, PredictedTimeseries and RequiredTimeseries for single queue in single campaign  scenario
									        Check this for Virtual QUEUEs &amp; DQ
									*/
<span class="nc" id="L1050">								}</span>
<span class="nc bnc" id="L1051" title="All 4 branches missed.">								if (i == 2 &amp;&amp; !ForecastChanged) {</span>
									// if Predict is changed, Forecast not changed, need reload Forecast line for combination
<span class="nc" id="L1053">									ArrayList fctCubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">									for (Iterator it = queueIDCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1055">										ID queueID = (ID) it.next();</span>
<span class="nc" id="L1056">										fctCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(TraceUtil.META_FORECAST, queueID,</span>
												start, end, null,
<span class="nc" id="L1058">												m_CampaignManager.getIDToSPQueueMapping(campaignID, nonRealQueueID, start, end), null));</span>
<span class="nc" id="L1059">									}</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">									for (Iterator it = fctCubeCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1061">										TraceCube cube = (TraceCube) it.next();</span>
<span class="nc" id="L1062">										TraceCube[] realQueCubes = (TraceCube[]) queueCubeMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">										if (realQueCubes == null) {</span>
<span class="nc" id="L1064">											realQueCubes = new TraceCube[5];</span>
										}
<span class="nc" id="L1066">										realQueCubes[i] = cube;</span>
<span class="nc" id="L1067">										queueCubeMap.put(cube.getQueueID(), realQueCubes);</span>
<span class="nc" id="L1068">									}</span>
								}
							}
						}
					}
				}
				// first save each real queue's information first
<span class="nc bnc" id="L1075" title="All 2 branches missed.">				if (cubeCol != null) {</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">					for (Iterator it = cubeCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1077">						TraceCube cube = (TraceCube) it.next();</span>
<span class="nc" id="L1078">						TraceCube[] realQueCubes = (TraceCube[]) queueCubeMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">						if (realQueCubes == null) {</span>
<span class="nc" id="L1080">							realQueCubes = new TraceCube[5];</span>
						}
<span class="nc" id="L1082">						realQueCubes[i] = cube;</span>
<span class="nc" id="L1083">						queueCubeMap.put(cube.getQueueID(), realQueCubes);</span>
<span class="nc" id="L1084">					}</span>
				}
			}

<span class="nc" id="L1088">			TraceOperatorAdapter.combineCubeMap(queueCubeMap, metaCubes, true, nonRealQueueID, true, WhatIfMode);</span>
			// need merge in Combined Staffing directly for VQ/DQ now
<span class="nc" id="L1090">			TraceCube[] nrQueCubes = (TraceCube[]) queueCubeMap.get(nonRealQueueID);</span>
<span class="nc bnc" id="L1091" title="All 4 branches missed.">			if (metaCubes[0] != null &amp;&amp; TraceUtil.containTraceType(metaCubes[0], Trace.STAFFING)) {</span>
				// need actual staffing inserted by Calc Engine.
<span class="nc" id="L1093">				Collection stfChunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL_STAFFING, nonRealQueueID, start,</span>
						end, lastCheck, false);
<span class="nc bnc" id="L1095" title="All 2 branches missed.">				if (nrQueCubes[0] == null) {</span>
<span class="nc" id="L1096">					nrQueCubes[0] = metaCubes[0].newInstance(nonRealQueueID, start, end, metaCubes[0].getTraceTypes());</span>
				}
<span class="nc bnc" id="L1098" title="All 2 branches missed.">				for (Iterator it = stfChunkCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1099">					TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc" id="L1100">					nrQueCubes[0].setTraceValue(Trace.STAFFING, TraceUtil.roundDouble(tc.getTraceValue(Trace.STAFFING)), tc.getStartDate(),</span>
							true);
<span class="nc" id="L1102">				}</span>
			}
			//need to do the computations here fo all trace cubes
<span class="nc" id="L1105">			TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(nrQueCubes);</span>
<span class="nc" id="L1106">			return nrQueCubes;</span>
<span class="nc" id="L1107">		} catch (Exception e) {</span>
<span class="nc" id="L1108">			handleException(e);</span>
<span class="nc" id="L1109">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1111">			methodFinish();</span>
		}
	}

	/**
	 * Return TraceCubes for queues associated with the combined queue definition in a given time range
	 * Combined queue ID is specified via CampaignID and MediaID combination.
	 * We use a false default valude for isNoPhantom.
	 *
	 * @param tv
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public HashMap getRefreshedRawCombinedQueuesTimeSeries(TrackingView tv, ID campaignID, ID mediaID, Date start, Date end, Date lastCheck)
			throws BbmFinderException {
<span class="nc" id="L1131">		return getRefreshedRawCombinedQueuesTimeSeries(tv, campaignID, mediaID, start, end, lastCheck, false);</span>
	}

	/**
	 * Return TraceCubes for queues associated with the combined queue definition in a given time range
	 * Combined queue ID is specified via CampaignID and MediaID combination
	 *
	 * @param tv
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public HashMap getRefreshedRawCombinedQueuesTimeSeries(TrackingView tv, ID campaignID, ID mediaID, Date start, Date end,
			Date lastCheck, boolean isNoPhantom) throws BbmFinderException {
<span class="nc" id="L1149">		methodStart(&quot;getRefreshedRawCombinedQueuesTimeSeries&quot;, tv, campaignID, mediaID, start, end);</span>
		try {
<span class="nc" id="L1151">			Collection queueAssignment = m_CampaignManager.getCampaignQueueAssignments(campaignID, mediaID, start, end);</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">			if (queueAssignment.isEmpty()) {</span>
<span class="nc" id="L1153">				return null;</span>
			}
<span class="nc" id="L1155">			HashMap spQMap = new HashMap();</span>
<span class="nc" id="L1156">			HashMap spTimeRangeMap = new HashMap();</span>
<span class="nc" id="L1157">			HashMap spSkillMap = new HashMap();</span>
<span class="nc" id="L1158">			Date spStart = null;</span>
<span class="nc" id="L1159">			Date spEnd = null;</span>
<span class="nc" id="L1160">			Set&lt;ID&gt; queueSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1161" title="All 2 branches missed.">			for (Iterator it = queueAssignment.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1162">				CampaignQueue cq = (CampaignQueue) it.next();</span>
<span class="nc" id="L1163">				ID qID = cq.getQueueID();</span>
<span class="nc" id="L1164">				queueSet.add(qID);</span>
<span class="nc" id="L1165">				ID spID = cq.getSPID();</span>
<span class="nc" id="L1166">				ArrayList qCol = (ArrayList) spQMap.get(spID);</span>
<span class="nc bnc" id="L1167" title="All 2 branches missed.">				if (qCol == null) {</span>
<span class="nc" id="L1168">					qCol = new ArrayList();</span>
				}
<span class="nc" id="L1170">				qCol.add(qID);</span>
<span class="nc" id="L1171">				spQMap.put(spID, qCol);</span>
<span class="nc" id="L1172">				Date[] timeRange = (Date[]) spTimeRangeMap.get(spID);</span>
<span class="nc bnc" id="L1173" title="All 2 branches missed.">				if (timeRange == null) {</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">					if (spStart == null || spStart.after(cq.getStartTime())) {</span>
<span class="nc" id="L1175">						spStart = cq.getStartTime();</span>
					}
<span class="nc bnc" id="L1177" title="All 4 branches missed.">					if (spEnd == null || spEnd.before(cq.getEndTime())) {</span>
<span class="nc" id="L1178">						spEnd = cq.getEndTime();</span>
					}
<span class="nc" id="L1180">					timeRange = new Date[2];</span>
<span class="nc" id="L1181">					timeRange[0] = cq.getStartTime();</span>
<span class="nc" id="L1182">					timeRange[1] = cq.getEndTime();</span>
<span class="nc" id="L1183">					spTimeRangeMap.put(spID, timeRange);</span>
				}
<span class="nc" id="L1185">			}</span>
			// Now go fetch SP skill based information
<span class="nc" id="L1187">			Collection spCol = m_CampaignManager.getSchedulingPeriods(campaignID, spStart, spEnd);</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">			for (Iterator it = spCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1189">				SchedulingPeriod sp = (SchedulingPeriod) it.next();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">				spSkillMap.put(sp.getID(), sp.getSkillBased() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L1191">			}</span>
			// build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L1193">			Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueSet, start, end);</span>
<span class="nc" id="L1194">			TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L1195">			HashMap queCubesMap = new HashMap(queueSet.size());</span>
<span class="nc bnc" id="L1196" title="All 2 branches missed.">			for (int i = 0; i &lt; metaCubes.length; i++) {</span>
<span class="nc" id="L1197">				Collection cubeCol = new ArrayList();</span>
<span class="nc" id="L1198">				TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L1199" title="All 2 branches missed.">				if (metaCubes[i] == null) {</span>
<span class="nc" id="L1200">					continue;</span>
				}
<span class="nc bnc" id="L1202" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1203">					cubeCol = getRefreshedRawCombinedQueuesTimeSeriesForSGTC(campaignID, mediaID, start, end, lastCheck, spQMap,</span>
							spTimeRangeMap, spSkillMap, queueSet, idToSPQueueMapping, cubeCol, metaTC);
				} else {
					// load directly
<span class="nc bnc" id="L1207" title="All 2 branches missed.">					for (Iterator qIt = queueSet.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1208">						ID queueID = (ID) qIt.next();</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">						if (lastCheck != null</span>
<span class="nc bnc" id="L1210" title="All 2 branches missed.">								&amp;&amp; !m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end,</span>
										lastCheck)) {
							// no change for this queue, skip it
<span class="nc" id="L1213">							qIt.remove();</span>
						}
<span class="nc" id="L1215">					}</span>
<span class="nc bnc" id="L1216" title="All 2 branches missed.">					if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1217">						getRefreshedRawCombinedQueuesTimeSeriesForActualTC(start, end, lastCheck, queueSet, idToSPQueueMapping, cubeCol,</span>
								metaTC);
					} else {
<span class="nc bnc" id="L1220" title="All 2 branches missed.">						if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1221">							getRefreshedRawCombinedQueuesTimeSeriesForPredictTC(campaignID, mediaID, start, end, lastCheck, spQMap,</span>
									queueSet, idToSPQueueMapping, i, cubeCol, metaTC, isNoPhantom);
						} else {
<span class="nc" id="L1224">							cubeCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, queueSet, spQMap, spTimeRangeMap,</span>
									start, end, lastCheck, false, idToSPQueueMapping);
						}
					}
				}
				// final step add each queue's cube into map
<span class="nc bnc" id="L1230" title="All 2 branches missed.">				for (Iterator it = cubeCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1231">					TraceCube cube = (TraceCube) it.next();</span>
<span class="nc" id="L1232">					TraceCube[] realCubes = (TraceCube[]) queCubesMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1233" title="All 2 branches missed.">					if (realCubes == null) {</span>
<span class="nc" id="L1234">						realCubes = new TraceCube[metaCubes.length];</span>
					}
<span class="nc" id="L1236">					realCubes[i] = cube;</span>
<span class="nc" id="L1237">					queCubesMap.put(cube.getQueueID(), realCubes);</span>
<span class="nc" id="L1238">				}</span>
			}
<span class="nc" id="L1240">			return queCubesMap;</span>
<span class="nc" id="L1241">		} catch (Exception e) {</span>
<span class="nc" id="L1242">			handleException(e);</span>
<span class="nc" id="L1243">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1245">			methodFinish();</span>
		}
	}

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param spQMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param i
	 * @param cubeCol
	 * @param metaTC
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRefreshedRawCombinedQueuesTimeSeriesForPredictTC(ID campaignID, ID mediaID, Date start, Date end, Date lastCheck,
			HashMap spQMap, Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping, int i, Collection cubeCol, TraceCube metaTC,
			boolean isNoPhantom) throws Exception, BbmTimeSeriesException {
		// predicted is direct load always
<span class="nc" id="L1268">		TraceCube cube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(TraceUtil.META_REPORT_PREDICT, campaignID, mediaID,</span>
<span class="nc" id="L1269">				spQMap.keySet(), start, end, lastCheck, false, idToSPQueueMapping, isNoPhantom);</span>
<span class="nc bnc" id="L1270" title="All 2 branches missed.">		if (cube != null) {</span>
<span class="nc bnc" id="L1271" title="All 2 branches missed.">			for (Iterator qIt = queueSet.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1272">				ID qID = (ID) qIt.next();</span>
<span class="nc" id="L1273">				TraceCube queCube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1274" title="All 2 branches missed.">				for (int j = 0; i &lt; metaTC.getTraceTypes().length; j++) {</span>
<span class="nc" id="L1275">					short type = metaTC.getTraceTypes()[j];</span>
<span class="nc" id="L1276">					queCube.setTraceValue(type, cube.getTraceValueD(type), 0);</span>
				}
<span class="nc" id="L1278">				cubeCol.add(queCube);</span>
<span class="nc" id="L1279">			}</span>
		}
<span class="nc" id="L1281">	}</span>

	/**
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param cubeCol
	 * @param metaTC
	 * @throws BbmTimeSeriesException
	 * @throws Exception
	 */
	private void getRefreshedRawCombinedQueuesTimeSeriesForActualTC(Date start, Date end, Date lastCheck, Set&lt;ID&gt; queueSet,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Collection cubeCol, TraceCube metaTC) throws BbmTimeSeriesException, Exception {
		// special handle actual, read from cache
<span class="nc bnc" id="L1297" title="All 2 branches missed.">		if (timeSeriesCache != null) {</span>
<span class="nc bnc" id="L1298" title="All 2 branches missed.">			for (Iterator qIt = queueSet.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1299">				ID queueID = (ID) qIt.next();</span>
<span class="nc" id="L1300">				cubeCol.add(TimeSeriesCacheUtil.readFromActualcache(timeSeriesCache, queueID, start, end, lastCheck));</span>
<span class="nc" id="L1301">			}</span>
		} else {
<span class="nc bnc" id="L1303" title="All 2 branches missed.">			for (Iterator qIt = queueSet.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1304">				ID queueID = (ID) qIt.next();</span>
				// read from DB
<span class="nc" id="L1306">				cubeCol.add(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, lastCheck, idToSPQueueMapping));</span>
<span class="nc" id="L1307">			}</span>
		}
<span class="nc" id="L1309">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param spSkillMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param cubeCol
	 * @param metaTC
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private Collection getRefreshedRawCombinedQueuesTimeSeriesForSGTC(ID campaignID, ID mediaID, Date start, Date end, Date lastCheck,
			HashMap spQMap, HashMap spTimeRangeMap, HashMap spSkillMap, Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping,
			Collection cubeCol, TraceCube metaTC) throws BbmFinderException, RemoteException, Exception, BbmTimeSeriesException {
		// Require is always direct load for individual queue						|| metaTC instanceof RequireTraceCube) {
		// Require/ServiceGoal has timeseries for non-skill based combined queue, skill based sp need aggregation
		// split SPs by Skill based info
<span class="nc" id="L1336">		HashMap n_spQMap = new HashMap();</span>
<span class="nc" id="L1337">		HashMap n_spTimeRangeMap = new HashMap();</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">		for (Iterator spIT = spSkillMap.keySet().iterator(); spIT.hasNext();) {</span>
<span class="nc" id="L1339">			ID spID = (ID) spIT.next();</span>
<span class="nc" id="L1340">			Boolean skillBased = (Boolean) spSkillMap.get(spID);</span>
<span class="nc bnc" id="L1341" title="All 4 branches missed.">			if (skillBased == null || !skillBased.booleanValue()) {</span>
<span class="nc" id="L1342">				n_spQMap.put(spID, spQMap.get(spID));</span>
<span class="nc" id="L1343">				spQMap.remove(spID);</span>
<span class="nc" id="L1344">				n_spTimeRangeMap.put(spID, spTimeRangeMap.get(spID));</span>
<span class="nc" id="L1345">				spTimeRangeMap.remove(spID);</span>
			}
<span class="nc" id="L1347">		}</span>
<span class="nc" id="L1348">		TraceCube combinedCube = null;</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">		boolean hasChange = lastCheck != null;</span>
<span class="nc bnc" id="L1350" title="All 6 branches missed.">		if (!hasChange &amp;&amp; !spQMap.isEmpty() &amp;&amp; metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1351">			HashSet qIDSet = new HashSet();</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">			for (Iterator it = spQMap.keySet().iterator(); it.hasNext();) {</span>
<span class="nc" id="L1353">				qIDSet.addAll((Collection) spQMap.get(it.next()));</span>
			}
<span class="nc bnc" id="L1355" title="All 2 branches missed.">			for (Iterator it = qIDSet.iterator(); it.hasNext();) {</span>
<span class="nc bnc" id="L1356" title="All 2 branches missed.">				if (m_timeSeriesAuditManager.hasChange(null, null, (ID) it.next(), TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
<span class="nc" id="L1357">					hasChange = true;</span>
<span class="nc" id="L1358">					break;</span>
				}
			}
		}
<span class="nc bnc" id="L1362" title="All 2 branches missed.">		if (!hasChange) {</span>
			// check the campaign queue itself
<span class="nc" id="L1364">			hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
		}
<span class="nc bnc" id="L1366" title="All 2 branches missed.">		if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L1367">			LOG.debug(&quot;In Campaign Queue mode, hasChange=&quot; + hasChange);</span>
		}
		// the timerange may cover skill/non-skill based so need add them all
		// Add non-skill based for service goal
<span class="nc" id="L1371">		HashMap queueTraceMap = new HashMap(queueSet.size());</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">		if (hasChange) {</span>
<span class="nc bnc" id="L1373" title="All 2 branches missed.">			if (!n_spQMap.isEmpty()) {</span>
				// direct load for required traces for non-skill based sps
<span class="nc" id="L1375">				combinedCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, n_spQMap.keySet(),</span>
						start, end, null, false, idToSPQueueMapping, false);
<span class="nc bnc" id="L1377" title="All 2 branches missed.">				for (Iterator qIt = queueSet.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1378">					ID qID = (ID) qIt.next();</span>
<span class="nc" id="L1379">					queueTraceMap.put(qID, metaTC.newInstance(qID, start, end, metaTC.getTraceTypes()));</span>
<span class="nc" id="L1380">				}</span>
<span class="nc" id="L1381">				short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L1382" title="All 2 branches missed.">				for (Iterator spIt = n_spQMap.keySet().iterator(); spIt.hasNext();) {</span>
<span class="nc" id="L1383">					ID spID = (ID) spIt.next();</span>
<span class="nc" id="L1384">					Collection queueIDCol = (Collection) n_spQMap.get(spID);</span>
<span class="nc" id="L1385">					Date[] timeRange = (Date[]) n_spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1386">					Date pStart = new Date(timeRange[0].getTime());</span>
					do {
<span class="nc bnc" id="L1388" title="All 4 branches missed.">						if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc" id="L1389">							double[] value = combinedCube.getTraceValueD(types, pStart);</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">							for (Iterator qIt = queueIDCol.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1391">								ID qID = (ID) qIt.next();</span>
<span class="nc" id="L1392">								TraceCube cube = (TraceCube) queueTraceMap.get(qID);</span>
<span class="nc bnc" id="L1393" title="All 2 branches missed.">								if (cube == null) {</span>
<span class="nc" id="L1394">									cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
								}
<span class="nc" id="L1396">								cube.setTraceValue(types, value, pStart);</span>
<span class="nc" id="L1397">							}</span>
						}
<span class="nc" id="L1399">						pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">					} while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1401">				}</span>
<span class="nc" id="L1402">				cubeCol = queueTraceMap.values();</span>
			}
			// Add skill based combined result
<span class="nc bnc" id="L1405" title="All 2 branches missed.">			if (!spQMap.isEmpty()) {</span>
				// combine for service goal
<span class="nc" id="L1407">				Collection cubesCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap, start,</span>
						end, null, false, idToSPQueueMapping);
<span class="nc bnc" id="L1409" title="All 2 branches missed.">				if (cubeCol != null) {</span>
					// merge skCube into existing cube, based on SPTimeRange
<span class="nc" id="L1411">					short[] sgtypes = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L1412" title="All 2 branches missed.">					for (Iterator spIt = spQMap.keySet().iterator(); spIt.hasNext();) {</span>
<span class="nc" id="L1413">						ID spID = (ID) spIt.next();</span>
<span class="nc" id="L1414">						Date[] timeRange = (Date[]) spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1415">						Date pStart = new Date(timeRange[0].getTime());</span>
						do {
<span class="nc bnc" id="L1417" title="All 4 branches missed.">							if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc bnc" id="L1418" title="All 2 branches missed.">								for (Iterator cubeIt = cubesCol.iterator(); cubeIt.hasNext();) {</span>
<span class="nc" id="L1419">									TraceCube cube = (TraceCube) cubeIt.next();</span>
<span class="nc" id="L1420">									TraceCube exCube = (TraceCube) queueTraceMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">									if (exCube == null) {</span>
<span class="nc" id="L1422">										exCube = cube;</span>
<span class="nc" id="L1423">										cubeIt.remove();</span>
									} else {
<span class="nc" id="L1425">										exCube.setTraceValue(sgtypes, cube.getTraceValueD(sgtypes, pStart), pStart);</span>
									}
<span class="nc" id="L1427">									queueTraceMap.put(cube.getQueueID(), exCube);</span>
<span class="nc" id="L1428">								}</span>
							}
<span class="nc" id="L1430">							pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1431" title="All 2 branches missed.">						} while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1432">					}</span>
<span class="nc" id="L1433">					cubeCol = queueTraceMap.values();</span>
<span class="nc" id="L1434">				} else {</span>
<span class="nc" id="L1435">					cubeCol = cubesCol;</span>
				}
			}
		}
<span class="nc" id="L1439">		return cubeCol;</span>
	}

	/**
	 * Calls getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end, boolean includeAllServiceGoalTypes, needAllValid)
	 * with
	 * &lt;ol&gt;
	 * &lt;li&gt; includeAllServiceGoalTypes set to false as the default behavior.  This means that if a service goals trace cube is expected, it will
	 * only return data for the selected service goal type even if data for multiple types exists.&lt;/li&gt;
	 * &lt;li&gt; needAllValid is set to true as the default behavior.
	 * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues&lt;/li&gt;
	 * &lt;/ol&gt;
	 */
	public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end)
			throws BbmFinderException {
<span class="nc" id="L1454">		return getRawCombinedQueuesTimeSeries(metaTC, campaignID, mediaID, start, end, false);</span>
	}

	/**
	 * Calls getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
	 * boolean includeAllServiceGoalTypes, boolean isNoPhantom)
	 * with
	 * includeAllServiceGoalTypes, false
	 */
	public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
			boolean includeAllServiceGoalTypes) throws BbmFinderException {
<span class="nc" id="L1465">		return getRawCombinedQueuesTimeSeries(metaTC, campaignID, mediaID, start, end, includeAllServiceGoalTypes, false);</span>
	}

	/**
	 * Checks to see if a non-resolution queue exists in the passed CampaignQueue collection.
	 *
	 * @param mediaID         - We only bother checking if media is null, representing the Combined-All Media queue.
	 * @param queueAssignment - Collection of CampaignQueue objects.
	 * @param queMap          - Map of Id to Queue.
	 * @return true if a non-resolution queue exists, false otherwise.
	 */
	private boolean hasNonResolutionMediaInCombinedAll(ID mediaID, Collection&lt;CampaignQueue&gt; queueAssignment, Map&lt;ID, Queue&gt; queMap) {
<span class="nc bnc" id="L1477" title="All 10 branches missed.">		if (mediaID == null &amp;&amp; queueAssignment != null &amp;&amp; queueAssignment.size() &gt; 0 &amp;&amp; queMap != null &amp;&amp; queMap.size() &gt; 0) {</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">			for (CampaignQueue cq : queueAssignment) {</span>
<span class="nc" id="L1479">				ID qID = cq.getQueueID();</span>
<span class="nc" id="L1480">				Queue queue = queMap.get(qID);</span>
<span class="nc bnc" id="L1481" title="All 2 branches missed.">				if (!Media.MEDIA_ID_RESOLUTION.equals(queue.getMediaID())) {</span>
<span class="nc" id="L1482">					return true;</span>
				}
<span class="nc" id="L1484">			}</span>
		}
<span class="nc" id="L1486">		return false;</span>
	}

	/**
	 * Return TraceCubes for queues associated with the combined queue definition in a given time range
	 * Combined queue ID is specified via CampaignID and MediaID combination
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param isNoPhantom                will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 *                                   ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
			boolean includeAllServiceGoalTypes, boolean isNoPhantom) throws BbmFinderException {
<span class="nc" id="L1507">		methodStart(&quot;getRawCombinedQueuesTimeSeries&quot;, metaTC, campaignID, mediaID, start, end);</span>
		try {
<span class="nc" id="L1509">			WorkloadManager workloadManager = WfmManagerFactory.getWorkloadManager();</span>
<span class="nc" id="L1510">			Collection&lt;CampaignQueue&gt; queueAssignment = m_CampaignManager.getCampaignQueueAssignments(campaignID, mediaID, start, end);</span>
<span class="nc bnc" id="L1511" title="All 2 branches missed.">			if (queueAssignment.isEmpty()) {</span>
<span class="nc" id="L1512">				return null;</span>
			}
<span class="nc" id="L1514">			short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1515">			Collection cubeCol = new ArrayList();</span>
<span class="nc" id="L1516">			HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1517">			HashMap&lt;ID, Date[]&gt; spTimeRangeMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1518">			Map&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1519">			Date spStart = null;</span>
<span class="nc" id="L1520">			Date spEnd = null;</span>
<span class="nc" id="L1521">			Set&lt;ID&gt; queueSet = new HashSet&lt;&gt;();</span>
<span class="nc" id="L1522">			Set&lt;ID&gt; queueIDSet = ValueObjectUtil.extractFieldSet(CampaignQueueFieldInfo.CAMPAIGNQUEUE_QUEUEID, queueAssignment);</span>
<span class="nc" id="L1523">			Map&lt;ID, Queue&gt; queMap = ValueObjectUtil.getIDObjectMap(workloadManager.getQueuesByIDs(queueIDSet));</span>

<span class="nc" id="L1525">			boolean bHasNonResolutionMedia = hasNonResolutionMediaInCombinedAll(mediaID, queueAssignment, queMap);</span>
<span class="nc bnc" id="L1526" title="All 2 branches missed.">			for (CampaignQueue cq : queueAssignment) {</span>
<span class="nc" id="L1527">				ID qID = cq.getQueueID();</span>
				//QC 90268 ; When rolling up &quot;Combined - All Media&quot;, do not include Resolution queues if there are other medias
<span class="nc" id="L1529">				Queue queue = queMap.get(qID);</span>
<span class="nc bnc" id="L1530" title="All 6 branches missed.">				if (mediaID == null &amp;&amp; Media.MEDIA_ID_RESOLUTION.equals(queue.getMediaID()) &amp;&amp; bHasNonResolutionMedia) {</span>
<span class="nc" id="L1531">					continue;</span>
				}
<span class="nc" id="L1533">				queueSet.add(qID);</span>
<span class="nc" id="L1534">				ID spID = cq.getSPID();</span>
<span class="nc" id="L1535">				List&lt;ID&gt; qCol = spQMap.get(spID);</span>
<span class="nc bnc" id="L1536" title="All 2 branches missed.">				if (qCol == null) {</span>
<span class="nc" id="L1537">					qCol = new ArrayList&lt;&gt;();</span>
				}
<span class="nc" id="L1539">				qCol.add(qID);</span>
<span class="nc" id="L1540">				spQMap.put(spID, qCol);</span>
<span class="nc" id="L1541">				Date[] timeRange = spTimeRangeMap.get(spID);</span>
<span class="nc bnc" id="L1542" title="All 2 branches missed.">				if (timeRange == null) {</span>
<span class="nc bnc" id="L1543" title="All 4 branches missed.">					if (spStart == null || spStart.after(cq.getStartTime())) {</span>
<span class="nc" id="L1544">						spStart = cq.getStartTime();</span>
					}
<span class="nc bnc" id="L1546" title="All 4 branches missed.">					if (spEnd == null || spEnd.before(cq.getEndTime())) {</span>
<span class="nc" id="L1547">						spEnd = cq.getEndTime();</span>
					}
<span class="nc" id="L1549">					timeRange = new Date[2];</span>
<span class="nc" id="L1550">					timeRange[0] = cq.getStartTime();</span>
<span class="nc" id="L1551">					timeRange[1] = cq.getEndTime();</span>
<span class="nc" id="L1552">					spTimeRangeMap.put(spID, timeRange);</span>
				}
<span class="nc" id="L1554">			}</span>
			// Now go fetch SP skill based information
<span class="nc" id="L1556">			Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriods(campaignID, spStart, spEnd);</span>
<span class="nc bnc" id="L1557" title="All 2 branches missed.">			for (SchedulingPeriod sp : spCol) {</span>
<span class="nc bnc" id="L1558" title="All 2 branches missed.">				spSkillMap.put(sp.getID(), sp.getSkillBased() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L1559">			}</span>
			// build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L1561">			Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueSet, start, end);</span>
<span class="nc bnc" id="L1562" title="All 4 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1563">				cubeCol = getRawCombinedQueuesTimeSeriesForRequiredTC(metaTC, campaignID, mediaID, start, end, includeAllServiceGoalTypes,</span>
						types, cubeCol, spQMap, spTimeRangeMap, spSkillMap, queueSet, idToSPQueueMapping);
			} else {
<span class="nc" id="L1566">				boolean hasDistributedQueue = false;</span>
<span class="nc" id="L1567">				Queue queue = null;</span>
<span class="nc" id="L1568">				Collection&lt;Queue&gt; qs = new ArrayList&lt;Queue&gt;(queueSet.size());</span>

<span class="nc bnc" id="L1570" title="All 2 branches missed.">				for (ID qID : queueSet) {</span>
<span class="nc" id="L1571">					queue = queMap.get(qID);</span>
<span class="nc bnc" id="L1572" title="All 4 branches missed.">					if (queue != null &amp;&amp; queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="nc" id="L1573">						hasDistributedQueue = true;</span>
					}
<span class="nc" id="L1575">					qs.add(queue);</span>
<span class="nc" id="L1576">				}</span>

				// load directly
<span class="nc bnc" id="L1579" title="All 2 branches missed.">				if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1580">					getRawCombinedQueuesTimeSeriesForPredictTC(metaTC, campaignID, mediaID, start, end, cubeCol, spQMap, queueSet,</span>
							idToSPQueueMapping, hasDistributedQueue, isNoPhantom, queMap);
<span class="nc bnc" id="L1582" title="All 2 branches missed.">				} else if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1583">					getRawCombinedQueuesTimeSeriesForActualTC(metaTC, start, end, cubeCol, spQMap, spTimeRangeMap, idToSPQueueMapping, qs,</span>
							queMap);

				} else {
<span class="nc" id="L1587">					cubeCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap, start, end, null,</span>
							false, idToSPQueueMapping);
				}
			}
<span class="nc" id="L1591">			return new ArrayList(cubeCol);</span>
<span class="nc" id="L1592">		} catch (Exception e) {</span>
<span class="nc" id="L1593">			handleException(e);</span>
<span class="nc" id="L1594">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1596">			methodFinish();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param cubeCol
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param idToSPQueueMapping
	 * @param qs
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRawCombinedQueuesTimeSeriesForActualTC(TraceCube metaTC, Date start, Date end, Collection cubeCol,
			HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap, HashMap&lt;ID, Date[]&gt; spTimeRangeMap, Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Collection&lt;Queue&gt; qs,
			Map&lt;ID, Queue&gt; queMap) throws BbmFinderException, RemoteException, Exception, BbmTimeSeriesException {
		//	load virtual queue's sub queue's actual and then combine since virtual queue itself doesn't have actual trace data.
<span class="nc" id="L1618">		HashSet qIDSet = new HashSet();</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">		for (Queue q : qs) {</span>
<span class="nc bnc" id="L1620" title="All 2 branches missed.">			if (q.getQueueType() == Queue.QUEUE_TYPE_VIRTUAL) {</span>
<span class="nc" id="L1621">				Collection&lt;ID&gt; subIDs = m_workloadManager.getSubQueues(Collections.singletonList(q.getID()));</span>
				//virtual queue, load subs.
<span class="nc" id="L1623">				Collection&lt;TraceCube&gt; subCubeCol = new ArrayList();</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">				for (ID queueID : subIDs) {</span>
<span class="nc" id="L1625">					subCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping,</span>
							queMap));
<span class="nc" id="L1627">				}</span>
<span class="nc bnc" id="L1628" title="All 2 branches missed.">				if (!subCubeCol.isEmpty()) {</span>
					//for virtual queue, the actual will be read from children and combined, then return
<span class="nc" id="L1630">					TraceCube cmbCube = TraceOperatorAdapter.combineQueue(subCubeCol, true, WhatIfMode);</span>
<span class="nc" id="L1631">					cmbCube.setQueueID(q.getID());</span>
<span class="nc" id="L1632">					cubeCol.add(cmbCube);</span>
<span class="nc" id="L1633">				} else {</span>
					//return empty actual cube
<span class="nc" id="L1635">					cubeCol.add(metaTC.newInstance(q.getID(), start, end, metaTC.getTraceTypes()));</span>
				}
<span class="nc" id="L1637">			} else {</span>
				//all type of queues should be loaded in combine mode later.
<span class="nc" id="L1639">				qIDSet.add(q.getID());</span>
			}
<span class="nc" id="L1641">		}</span>
<span class="nc bnc" id="L1642" title="All 2 branches missed.">		if (!qIDSet.isEmpty()) {</span>
			//load combine directly for non-virtual queues.
<span class="nc" id="L1644">			cubeCol.addAll(TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, qIDSet, spQMap, spTimeRangeMap, start, end,</span>
					null, false, idToSPQueueMapping));
		}
<span class="nc" id="L1647">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param cubeCol
	 * @param spQMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param hasDistributedQueue
	 * @throws Exception
	 */

	private void getRawCombinedQueuesTimeSeriesForPredictTC(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
			Collection cubeCol, HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap, Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping,
			boolean hasDistributedQueue, boolean isNoPhantom, Map&lt;ID, Queue&gt; queMap) throws Exception {

<span class="nc" id="L1667">		cubeCol.addAll(TimeSeriesDAO2.getTraceCubesByQueueIDs(metaTC, queueSet, start, end, null, idToSPQueueMapping,</span>
				isNoPhantom, queMap));

<span class="nc bnc" id="L1670" title="All 2 branches missed.">		if (!hasDistributedQueue) {</span>
			// predicted is direct load always
<span class="nc" id="L1672">			TraceCube cube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, spQMap.keySet(),</span>
					start, end, null, false, idToSPQueueMapping, isNoPhantom);
<span class="nc bnc" id="L1674" title="All 2 branches missed.">			if (cube != null) {</span>
				// assign combined queue -1 ID
<span class="nc" id="L1676">				cube.setQueueID(COMQUEID);</span>
<span class="nc" id="L1677">				cubeCol.add(cube);</span>
			}
		}
<span class="nc" id="L1680">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param types
	 * @param cubeCol
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param spSkillMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @return
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private Collection getRawCombinedQueuesTimeSeriesForRequiredTC(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
			boolean includeAllServiceGoalTypes, short[] types, Collection cubeCol, HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap,
			HashMap&lt;ID, Date[]&gt; spTimeRangeMap, Map&lt;ID, Boolean&gt; spSkillMap, Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping)
			throws Exception, BbmTimeSeriesException {
		// Require/ServiceGoal has timeseries for non-skill based combined queue, skill based sp need aggregation
		// split SPs by Skill based info
<span class="nc" id="L1706">		Map&lt;ID, List&lt;ID&gt;&gt; n_spQMap = new HashMap&lt;&gt;();</span>
<span class="nc" id="L1707">		Map&lt;ID, Date[]&gt; n_spTimeRangeMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L1708" title="All 2 branches missed.">		for (Iterator&lt;Map.Entry&lt;ID, List&lt;ID&gt;&gt;&gt; i = spQMap.entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L1709">			ID spID = i.next().getKey();</span>
<span class="nc" id="L1710">			Boolean skillBased = spSkillMap.get(spID);</span>
<span class="nc bnc" id="L1711" title="All 4 branches missed.">			if (skillBased == null || !skillBased) {</span>
<span class="nc" id="L1712">				n_spQMap.put(spID, spQMap.get(spID));</span>
<span class="nc" id="L1713">				i.remove();</span>
<span class="nc" id="L1714">				n_spTimeRangeMap.put(spID, spTimeRangeMap.get(spID));</span>
<span class="nc" id="L1715">				spTimeRangeMap.remove(spID);</span>
			}
<span class="nc" id="L1717">		}</span>
<span class="nc" id="L1718">		TraceCube combinedCube = null;</span>
		// the timerange may cover skill/non-skill based so need add them all
		// Add non-skill based for service goal
<span class="nc" id="L1721">		Map&lt;ID, TraceCube&gt; queueTraceMap = new HashMap&lt;&gt;(queueSet.size());</span>
<span class="nc bnc" id="L1722" title="All 2 branches missed.">		if (!n_spQMap.isEmpty()) {</span>
			// direct load for required traces for non-skill based sps
<span class="nc" id="L1724">			combinedCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, n_spQMap.keySet(),</span>
					start, end, null, includeAllServiceGoalTypes, idToSPQueueMapping, false);
<span class="nc bnc" id="L1726" title="All 2 branches missed.">			if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1727">				combinedCube.setQueueID(COMQUEID);</span>
<span class="nc" id="L1728">				queueTraceMap.put(COMQUEID, combinedCube);</span>
			} else {
<span class="nc bnc" id="L1730" title="All 2 branches missed.">				for (ID qID : queueSet) {</span>
<span class="nc" id="L1731">					queueTraceMap.put(qID, metaTC.newInstance(qID, start, end, metaTC.getTraceTypes()));</span>
<span class="nc" id="L1732">				}</span>
			}
<span class="nc bnc" id="L1734" title="All 2 branches missed.">			for (Iterator spIt = n_spQMap.keySet().iterator(); spIt.hasNext();) {</span>
<span class="nc" id="L1735">				ID spID = (ID) spIt.next();</span>
<span class="nc" id="L1736">				Collection&lt;ID&gt; queueIDCol = n_spQMap.get(spID);</span>
<span class="nc" id="L1737">				Date[] timeRange = n_spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1738">				Date pStart = new Date(timeRange[0].getTime());</span>
				do {
<span class="nc bnc" id="L1740" title="All 4 branches missed.">					if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc" id="L1741">						double[] value = combinedCube.getTraceValueD(types, pStart);</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">						for (Iterator qIt = queueIDCol.iterator(); qIt.hasNext();) {</span>
<span class="nc" id="L1743">							ID qID = (ID) qIt.next();</span>
<span class="nc" id="L1744">							TraceCube cube = queueTraceMap.get(qID);</span>
<span class="nc bnc" id="L1745" title="All 2 branches missed.">							if (cube == null) {</span>
<span class="nc" id="L1746">								cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
							}
<span class="nc" id="L1748">							cube.setTraceValue(types, value, pStart);</span>
<span class="nc" id="L1749">						}</span>
					}
<span class="nc" id="L1751">					pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1752" title="All 2 branches missed.">				} while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1753">			}</span>
<span class="nc" id="L1754">			cubeCol = queueTraceMap.values();</span>
		}
		// Add skill based combined result
<span class="nc bnc" id="L1757" title="All 2 branches missed.">		if (!spQMap.isEmpty()) {</span>
			// combine for service goal
<span class="nc" id="L1759">			Collection&lt;TraceCube&gt; cubesCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap,</span>
					start, end, null, includeAllServiceGoalTypes, idToSPQueueMapping);
<span class="nc bnc" id="L1761" title="All 2 branches missed.">			if (cubeCol != null) {</span>
				// merge skCube into existing cube, based on SPTimeRange
<span class="nc" id="L1763">				short[] sgtypes = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L1764" title="All 2 branches missed.">				for (ID spID : spQMap.keySet()) {</span>
<span class="nc" id="L1765">					Date[] timeRange = spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1766">					Date pStart = new Date(timeRange[0].getTime());</span>
					do {
<span class="nc bnc" id="L1768" title="All 4 branches missed.">						if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc bnc" id="L1769" title="All 2 branches missed.">							for (Iterator&lt;TraceCube&gt; cubeIt = cubesCol.iterator(); cubeIt.hasNext();) {</span>
<span class="nc" id="L1770">								TraceCube cube = cubeIt.next();</span>
<span class="nc" id="L1771">								TraceCube exCube = queueTraceMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1772" title="All 2 branches missed.">								if (exCube == null) {</span>
<span class="nc" id="L1773">									exCube = cube;</span>
<span class="nc" id="L1774">									cubeIt.remove();</span>
								} else {
<span class="nc" id="L1776">									exCube.setTraceValue(sgtypes, cube.getTraceValueD(sgtypes, pStart), pStart);</span>
								}
<span class="nc" id="L1778">								queueTraceMap.put(cube.getQueueID(), exCube);</span>
<span class="nc" id="L1779">							}</span>
						}
<span class="nc" id="L1781">						pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">					} while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1783">				}</span>
<span class="nc" id="L1784">				cubeCol = queueTraceMap.values();</span>
<span class="nc" id="L1785">			} else {</span>
<span class="nc" id="L1786">				cubeCol = cubesCol;</span>
			}
		}
<span class="nc" id="L1789">		return cubeCol;</span>
	}

	/**
	 * Return collection of CombinedQueueStaffing objects
	 *
	 * @param campaignID
	 * @param mediaID
	 * @param spIDSet
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 */
	public Collection getCombinedQueueStaffing(ID campaignID, ID mediaID, Set spIDSet, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1804">		methodStart(&quot;getCombinedQueueStaffing&quot;, campaignID, start, end);</span>
		try {
<span class="nc" id="L1806">			return TimeSeriesDAO.getCombinedQueueStaffing(campaignID, mediaID, spIDSet, start, end);</span>
<span class="nc" id="L1807">		} catch (JdmoException e) {</span>
<span class="nc" id="L1808">			handleException(e, false);</span>
<span class="nc" id="L1809">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1811">			methodFinish();</span>
		}
	}

	public ID saveReForecast(ID spID, Map&lt;ID, TraceCube&gt; traces, String description, Date creationDate) throws BbmCreateException {
<span class="nc" id="L1816">		boolean forecastProfileIsModified = true;</span>

<span class="nc" id="L1818">		String username = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="nc" id="L1820">		ForecastProfileDAO forecastProfileDAO = new ForecastProfileDAO();</span>
<span class="nc" id="L1821">		ForecastInstance forecastInstance = new ForecastInstance();</span>
		try {
			// Create a new forecast instance

<span class="nc" id="L1825">			forecastInstance.setSpId(spID);</span>
<span class="nc" id="L1826">			forecastInstance.setDescription(description);</span>
<span class="nc" id="L1827">			forecastInstance.setIsBase(false);</span>
<span class="nc" id="L1828">			forecastInstance.setCreated(creationDate);</span>
<span class="nc" id="L1829">			forecastInstance.setCreatedBy(username);</span>
<span class="nc" id="L1830">			forecastInstance.setID(ForecastInstanceDAO.createForecastInstance(forecastInstance));</span>

			// Get the campaign time zone
<span class="nc" id="L1833">			TimeZone campaignTimeZone = CampaignDAO.getTimeZoneBySPID(spID);</span>
<span class="nc" id="L1834">			Calendar cal = Calendar.getInstance(campaignTimeZone);</span>

			// Iterate over the map of queueIDs and trace cubes
<span class="nc bnc" id="L1837" title="All 2 branches missed.">			for (ID queueID : traces.keySet()) {</span>
<span class="nc" id="L1838">				TraceCube traceCube = traces.get(queueID);</span>

				// Find the SPQueueID that corresponds with the current queueID and spID
<span class="nc" id="L1841">				ID spQueueID = SPQueueDAO.getSPQueueID(spID, queueID);</span>

				// Create a new forecast profile, and set it to point to the new
				// forecast instance
<span class="nc" id="L1845">				ForecastProfile forecastProfile = new ForecastProfile();</span>
<span class="nc" id="L1846">				forecastProfile.setSPQueueID(spQueueID);</span>
<span class="nc" id="L1847">				forecastProfile.setForecastInstanceID(forecastInstance.getID());</span>
<span class="nc" id="L1848">				forecastProfile.setIsModified(forecastProfileIsModified);</span>
<span class="nc" id="L1849">				forecastProfile.setCreatedDate(creationDate);</span>
<span class="nc" id="L1850">				forecastProfile.setCreatedBy(username);</span>
<span class="nc" id="L1851">				forecastProfileDAO.createObject(forecastProfile);</span>

<span class="nc" id="L1853">				int numOfDaysInCube = 0;</span>
<span class="nc" id="L1854">				int traceCubeMaxLength = traceCube.getMaximumLength(new short[] { TraceCube.CV, TraceCube.AHT });</span>

<span class="nc bnc" id="L1856" title="All 2 branches missed.">				if (traceCubeMaxLength % 96 == 0) {</span>
<span class="nc" id="L1857">					numOfDaysInCube = traceCubeMaxLength / 96;</span>
				} else {
<span class="nc" id="L1859">					numOfDaysInCube = traceCubeMaxLength / 96 + 1;</span>
				}

<span class="nc" id="L1862">				cal.setTime(traceCube.getRawStartDate());</span>

<span class="nc" id="L1864">				boolean isDSTTransitionPeriod = campaignTimeZone.inDaylightTime(traceCube.getRawStartDate()) != campaignTimeZone</span>
<span class="nc bnc" id="L1865" title="All 2 branches missed.">						.inDaylightTime(traceCube.getRawEndDate());</span>
<span class="nc" id="L1866">				int currentValueIndex = 1;</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">				for (int i = 0; i &lt; numOfDaysInCube; i++) {</span>
<span class="nc" id="L1868">					Date dateTime = cal.getTime();</span>
<span class="nc" id="L1869">					Date endOfDay = new Date(dateTime.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG - 1);</span>
<span class="nc bnc" id="L1870" title="All 2 branches missed.">					boolean isDSTOut = isDSTTransitionPeriod</span>
<span class="nc bnc" id="L1871" title="All 4 branches missed.">							&amp;&amp; (campaignTimeZone.inDaylightTime(dateTime) &amp;&amp; !campaignTimeZone.inDaylightTime(endOfDay));</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">					boolean isDSTIn = isDSTTransitionPeriod</span>
<span class="nc bnc" id="L1873" title="All 4 branches missed.">							&amp;&amp; (!campaignTimeZone.inDaylightTime(dateTime) &amp;&amp; campaignTimeZone.inDaylightTime(endOfDay));</span>

					// Add new Forecast Time Series objects
<span class="nc" id="L1876">					ForecastTimeSeries forecastTimeSeries = new ForecastTimeSeries();</span>
<span class="nc" id="L1877">					forecastTimeSeries.setSpQueueId(spQueueID);</span>
<span class="nc" id="L1878">					forecastTimeSeries.setDateTime(dateTime);</span>
<span class="nc" id="L1879">					forecastTimeSeries.setCreated(creationDate);</span>
<span class="nc" id="L1880">					forecastTimeSeries.setCreatedBy(username);</span>
<span class="nc" id="L1881">					forecastTimeSeries.setForecastInstanceId(forecastInstance.getID());</span>

<span class="nc" id="L1883">					Class forecastTimeSeriesClass = forecastTimeSeries.getClass();</span>
<span class="nc" id="L1884">					Object[] setAhtArgs = new Object[1];</span>
<span class="nc" id="L1885">					Object[] setCvArgs = new Object[1];</span>
<span class="nc bnc" id="L1886" title="All 2 branches missed.">					for (int j = 1; j &lt; 97; j++, currentValueIndex++) {</span>
<span class="nc bnc" id="L1887" title="All 2 branches missed.">						if (traceCube.getTraceValueD(Trace.AHT) != null) {</span>
<span class="nc" id="L1888">							Method setAhtMethod = forecastTimeSeriesClass.getMethod(&quot;setAht&quot; + j, new Class[] { float.class });</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">							if (traceCube.getTraceValueD(Trace.AHT).length &gt;= currentValueIndex) {</span>
<span class="nc" id="L1890">								setAhtArgs[0] = Integer.valueOf((int) (traceCube.getTraceValueD(Trace.AHT)[currentValueIndex - 1]));</span>
							} else {
<span class="nc" id="L1892">								setAhtArgs[0] = Integer.valueOf(0);</span>
							}
<span class="nc" id="L1894">							setAhtMethod.invoke(forecastTimeSeries, setAhtArgs);</span>
						}
<span class="nc bnc" id="L1896" title="All 2 branches missed.">						if (traceCube.getTraceValueD(Trace.CV) != null) {</span>
<span class="nc" id="L1897">							Method setCvMethod = forecastTimeSeriesClass.getMethod(&quot;setCallVolume&quot; + j, new Class[] { float.class });</span>
<span class="nc bnc" id="L1898" title="All 2 branches missed.">							if (traceCube.getTraceValueD(Trace.CV).length &gt;= currentValueIndex) {</span>
<span class="nc" id="L1899">								setCvArgs[0] = Integer.valueOf((int) (traceCube.getTraceValueD(Trace.CV)[currentValueIndex - 1]));</span>
							} else {
<span class="nc" id="L1901">								setCvArgs[0] = Integer.valueOf(0);</span>
							}
<span class="nc" id="L1903">							setCvMethod.invoke(forecastTimeSeries, setCvArgs);</span>
						}
<span class="nc bnc" id="L1905" title="All 4 branches missed.">						if (isDSTOut || isDSTOut) {</span>
<span class="nc" id="L1906">							Date insertPoint = new Date(traceCube.getRawStartDate().getTime()</span>
									+ (Trace.INTERVAL_IN_MILLIS * (currentValueIndex - 1)));
<span class="nc" id="L1908">							Date nextPoint = new Date(traceCube.getRawStartDate().getTime()</span>
									+ (Trace.INTERVAL_IN_MILLIS * currentValueIndex));
<span class="nc bnc" id="L1910" title="All 2 branches missed.">							if (campaignTimeZone.inDaylightTime(insertPoint) != campaignTimeZone.inDaylightTime(nextPoint)) {</span>
<span class="nc" id="L1911">								int dstIntv = campaignTimeZone.getDSTSavings() / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc" id="L1912">								LOG.debug(&quot;need to manage next 4 points since DST changed at this Trace interval =&quot; + insertPoint + &quot; AND &quot;</span>
										+ nextPoint + &quot; :dstIntv=&quot; + dstIntv);
<span class="nc bnc" id="L1914" title="All 2 branches missed.">								if (isDSTIn) {//set 3 pouints to NA in forecastTimeSeries +4 th point will increment from the for loop operator</span>
									//j = j + (dstIntv-1); //DO NOT DO anything will fix it later
								} else { //ignore 4 points from trace cube
<span class="nc" id="L1917">									currentValueIndex += dstIntv;</span>
								}
							}
						}
					}
<span class="nc" id="L1922">					ForecastTimeSeriesDAO.createForecastTimeSeries(forecastTimeSeries);</span>
<span class="nc" id="L1923">					cal.add(Calendar.DATE, 1);</span>
				}

				//Storing backlog information.
				//Backlog will be set to null if the reforecast dialog has the &quot;Reforecast Backlog&quot; option disabled
<span class="nc bnc" id="L1928" title="All 2 branches missed.">				if (traceCube.getTraceValueD(Trace.BACKLOG) != null) {</span>
<span class="nc" id="L1929">					Calendar campCalendar = Calendar.getInstance(campaignTimeZone);</span>
<span class="nc" id="L1930">					Calendar traceStart = Calendar.getInstance(campaignTimeZone);</span>
<span class="nc" id="L1931">					traceStart.setTime(traceCube.getRawStartDate());</span>

<span class="nc" id="L1933">					int backlogBucket = 0;</span>
					//Converting to buckets
<span class="nc" id="L1935">					long numberOfBucket = (campCalendar.getTimeInMillis() - traceStart.getTimeInMillis()) / (1000 * 60 * 15);</span>
					//If numberOfBucket is zero, then there will be no corresponding actual value.
					//This is because, pulse will allow entering actual value for 12:00 bucket only after 12:15.
					//So for the user to enter any value in pulse, the number of Bucket should be one at least.
<span class="nc" id="L1939">					float backlogValue = -1;</span>
<span class="nc bnc" id="L1940" title="All 2 branches missed.">					if (numberOfBucket == 0) {</span>
<span class="nc" id="L1941">						backlogValue = 0;</span>
<span class="nc bnc" id="L1942" title="All 2 branches missed.">					} else if (numberOfBucket &lt; traceCube.getTraceValueD(Trace.BACKLOG).length) {</span>
<span class="nc" id="L1943">						backlogValue = (float) (traceCube.getTraceValueD(Trace.BACKLOG)[(int) numberOfBucket - 1]);</span>
<span class="nc" id="L1944">						backlogBucket = (int) numberOfBucket - 1;</span>
					} else {
						//This indicates the cube is not created correctly or there is something
						//wrong with the date conversion.
<span class="nc" id="L1948">						throw new RuntimeException(&quot;Backlog Cube do not have a bucket &quot; + numberOfBucket);//NOSONAR</span>
					}

<span class="nc bnc" id="L1951" title="All 2 branches missed.">					if (backlogValue &lt;= -1) {</span>
<span class="nc" id="L1952">						backlogValue = 0;</span>

						//Running backlog not entered in Pulse. Find the running backlog.
<span class="nc bnc" id="L1955" title="All 2 branches missed.">						for (int ny = 0; ny &lt; numberOfBucket; ny++) {</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">							if (traceCube.getTraceValueD(Trace.BACKLOG)[ny] &gt; -1) {</span>
<span class="nc" id="L1957">								backlogValue = (float) (traceCube.getTraceValueD(Trace.BACKLOG)[ny]);</span>
<span class="nc" id="L1958">								backlogBucket = ny;</span>
							}
						}
					}
<span class="nc" id="L1962">					Calendar backlogTime = (Calendar) traceStart.clone();</span>
<span class="nc" id="L1963">					backlogTime.add(Calendar.MINUTE, backlogBucket * 15);</span>

<span class="nc" id="L1965">					ForecastInterimBacklog backlog = new ForecastInterimBacklog();</span>
<span class="nc" id="L1966">					backlog.setForecastInstanceId(forecastInstance.getID());</span>
<span class="nc" id="L1967">					backlog.setSpQueueId(spQueueID);</span>
<span class="nc" id="L1968">					backlog.setInterimBacklog(backlogValue);</span>

					//Changing the current time to last bucket start time
<span class="nc" id="L1971">					campCalendar.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1972">					campCalendar.add(Calendar.MINUTE, -1 * (campCalendar.get(Calendar.MINUTE) % 15));</span>
<span class="nc" id="L1973">					campCalendar.add(Calendar.MINUTE, -15); //Moving back one more bucket as pulse shows the start time against</span>
					//each bucket. So showing the same time here also.

<span class="nc" id="L1976">					backlog.setInterimBacklogDate(backlogTime.getTime());</span>

<span class="nc" id="L1978">					ForecastInterimBacklogDAO.createForecastInterimBacklog(backlog);</span>
				}
<span class="nc" id="L1980">			}</span>
<span class="nc" id="L1981">		} catch (JdmoException e) {</span>
<span class="nc" id="L1982">			handleException(e, false);</span>
<span class="nc" id="L1983">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1984">		} catch (Exception e) {</span>
<span class="nc" id="L1985">			handleException(e, false);</span>
		} finally {
<span class="nc" id="L1987">			forecastProfileDAO.cleanUp();</span>
<span class="nc" id="L1988">			methodFinish();</span>
<span class="nc" id="L1989">		}</span>

		//getID() returns the SID, getId() returnd the ID (the DE string ID). We return the DE string Id because the Forecast applet uses
		//the string ID's for the list, and we need to be able to &quot;Save and Launch&quot; the forecast applet with this Id selected by default.
<span class="nc" id="L1993">		return forecastInstance.getId();</span>
	}

	public void deleteReForecasts(ID spId, ID spQueueId) throws BbmRemoveException {
<span class="nc" id="L1997">		methodStart(&quot;deleteReForecasts&quot;, spId, spQueueId);</span>
<span class="nc" id="L1998">		ForecastProfileDAO dao = new ForecastProfileDAO();</span>
		try {
			// Delete the forecast time series object
<span class="nc" id="L2001">			ForecastTimeSeriesDAO.deleteForecastTimeSeriesBySpQueue(spQueueId);</span>

			// Delete the forecast profile object
<span class="nc" id="L2004">			dao.deleteObjectsBySpQueueID(spQueueId);</span>

			//Delete forecast backlog
<span class="nc" id="L2007">			ForecastInterimBacklogDAO.deleteBacklogByForecastInstanceID(spId);</span>

			// Delete the forecast instance
<span class="nc" id="L2010">			ForecastInstanceDAO.deleteForecastInstanceBySpQueue(spId);</span>
<span class="nc" id="L2011">		} catch (JdmoException e) {</span>
<span class="nc" id="L2012">			handleException(e, false);</span>
<span class="nc" id="L2013">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L2015">			dao.cleanUp();</span>
<span class="nc" id="L2016">			methodFinish();</span>
<span class="nc" id="L2017">		}</span>
<span class="nc" id="L2018">	}</span>

	/**
	 * Returns a map of SPQueues with integer values specifying the starting backlog for those SPQueues.
	 * The starting backlog is determined by the target Scheduling Period that is handed in to this method.
	 * The starting backlog will either be pulled from the PREDICTEDTIMESERIES table (for forecasted backlog) or
	 * the QUEUEHISTORYTIMESERIES table (for Actual backlog).  The starting backlog will be pulled from the
	 * latest backlog value from the target SP matching the work queue from the input spQueue.  However, we will
	 * only look back 24 hours from the end date of the target SP (and queue) to find an ending backlog value.
	 * If no backlog is present during the last 24 hours of the SP then the starting backlog will be set as
	 * 0 for that spQueue.  If the targetSP does not have a matching work queue, the starting backlog for the
	 * spQueue will be set to 0.
	 *
	 * @param spQueues    SpQueues corresponding to the queues for which starting backlog is to be
	 *                    fetched.  The actual time interval covered by the associated SP is ignored.
	 * @param targetSP    this appears to be the SP &lt;em&gt;before&lt;/em&gt; the SP for which starting backlog
	 *                    is needed.
	 * @param backlogType {@link BacklogType#Actual} or {@link BacklogType#Forecasted}
	 * @return HashMap&lt;SPQueue, Integer&gt; - The SPQueue key is from the collection of spQueues handed into the method.
	 * The Integer value represents the starting backlog for that spQueue, determined by looking at the forecasted
	 * or actual ending backlog values of the targetSP for the matching work queues.
	 */
	public Map&lt;SPQueue, Integer&gt; fetchStartingBacklogForSPQueues(Collection&lt;SPQueue&gt; spQueues, SchedulingPeriod targetSP,
			BacklogType backlogType) throws BbmException {

<span class="nc" id="L2043">		Map&lt;SPQueue, Integer&gt; retVal = initBacklogMap(spQueues);</span>
<span class="nc" id="L2044">		Collection&lt;ID&gt; queueIds = ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues);</span>

<span class="nc" id="L2046">		Date adjustedSpEndDate = new Date(targetSP.getEndTime().getTime() - 1000);</span>
<span class="nc" id="L2047">		Collection&lt;TraceCube&gt; backlogData = getBacklogTraceData(targetSP.getCampaignID(), queueIds, backlogType, targetSP.getStartTime(),</span>
				adjustedSpEndDate);

		//Go through the backlog data for each queue and find the last non-zero value for each
		// trace cube (up to 24 hours prior to the end of the period, if there are no non-zero values of ending backlog
		// in the last 24 hours of the SP for the target queue then the starting backlog will be zero for
		// that queue.
<span class="nc bnc" id="L2054" title="All 2 branches missed.">		for (TraceCube cube : backlogData) {</span>
<span class="nc" id="L2055">			Calendar startDate = Calendar.getInstance();</span>
<span class="nc" id="L2056">			startDate.setTime(cube.getRawEndDate());</span>
<span class="nc" id="L2057">			startDate.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="nc" id="L2058">			double[] backlogValues = cube.getTraceValueD(Trace.BACKLOG, startDate.getTime(), cube.getRawEndDate());</span>
<span class="nc" id="L2059">			int endingBacklogValue = 0;</span>
<span class="nc bnc" id="L2060" title="All 2 branches missed.">			for (int i = backlogValues.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">				if (backlogValues[i] &gt; 0) {</span>
<span class="nc" id="L2062">					endingBacklogValue = (int) (backlogValues[i]);</span>
<span class="nc" id="L2063">					break;</span>
				}
			}

<span class="nc bnc" id="L2067" title="All 2 branches missed.">			if (endingBacklogValue &gt; 0) {</span>
<span class="nc bnc" id="L2068" title="All 2 branches missed.">				for (SPQueue spQueue : retVal.keySet()) {</span>
<span class="nc bnc" id="L2069" title="All 4 branches missed.">					if (spQueue.getQueueID() != null &amp;&amp; spQueue.getQueueID().equals(cube.getQueueID())) {</span>
<span class="nc" id="L2070">						retVal.put(spQueue, endingBacklogValue);</span>
<span class="nc" id="L2071">						break;</span>
					}
<span class="nc" id="L2073">				}</span>
			}
<span class="nc" id="L2075">		}</span>

<span class="nc" id="L2077">		return retVal;</span>
	}

	public Map&lt;SPQueue, Integer&gt; fetchActualStartingBacklogForSPQueuesAtDate(Collection&lt;SPQueue&gt; spQueues, ID campaignId, Date date)
			throws BbmException {

<span class="nc" id="L2083">		Map&lt;SPQueue, Integer&gt; retVal = initBacklogMap(spQueues);</span>
<span class="nc" id="L2084">		Collection&lt;ID&gt; queueIds = ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues);</span>

<span class="nc" id="L2086">		Collection&lt;TraceCube&gt; backlogData = getBacklogTraceData(campaignId, queueIds, BacklogType.Actual, date, date);</span>

		//Go through the backlog data for each queue and find the last non-zero value for each
		// trace cube (up to 24 hours prior to the end of the period, if there are no non-zero values of ending backlog
		// in the last 24 hours of the SP for the target queue then the starting backlog will be zero for
		// that queue.
<span class="nc bnc" id="L2092" title="All 2 branches missed.">		for (TraceCube cube : backlogData) {</span>
<span class="nc" id="L2093">			int backlogValue = cube.getTraceValue(Trace.BACKLOG, date);</span>
<span class="nc bnc" id="L2094" title="All 2 branches missed.">			for (SPQueue spQueue : retVal.keySet()) {</span>
<span class="nc bnc" id="L2095" title="All 4 branches missed.">				if (spQueue.getQueueID() != null &amp;&amp; spQueue.getQueueID().equals(cube.getQueueID())) {</span>
<span class="nc" id="L2096">					retVal.put(spQueue, backlogValue);</span>
<span class="nc" id="L2097">					break;</span>
				}
<span class="nc" id="L2099">			}</span>
<span class="nc" id="L2100">		}</span>

<span class="nc" id="L2102">		return retVal;</span>
	}

	private Map&lt;SPQueue, Integer&gt; initBacklogMap(Collection&lt;SPQueue&gt; spQueues) {
<span class="nc" id="L2106">		Map&lt;SPQueue, Integer&gt; retVal = new HashMap&lt;SPQueue, Integer&gt;();</span>

<span class="nc bnc" id="L2108" title="All 2 branches missed.">		for (SPQueue spQueue : spQueues) {</span>
<span class="nc" id="L2109">			retVal.put(spQueue, 0);</span>
<span class="nc" id="L2110">		}</span>
<span class="nc" id="L2111">		return retVal;</span>
	}

	private Collection&lt;TraceCube&gt; getBacklogTraceData(ID campaignId, Collection&lt;ID&gt; queueIDs, BacklogType backlogType, Date startDate,
			Date endDate) throws BbmFinderException {
		Collection&lt;TraceCube&gt; backlogData;
<span class="nc bnc" id="L2117" title="All 3 branches missed.">		switch (backlogType) {</span>
		case Forecasted:
<span class="nc" id="L2119">			PredictTraceCube predictMeta = new PredictTraceCube(new short[] { Trace.BACKLOG });</span>
<span class="nc" id="L2120">			backlogData = getRawMultipleQueuesTimeSeries(predictMeta, campaignId, queueIDs, startDate, endDate);</span>
<span class="nc" id="L2121">			break;</span>
		case Actual:
<span class="nc" id="L2123">			ActualTraceCube actualMeta = new ActualTraceCube(new short[] { Trace.BACKLOG });</span>
<span class="nc" id="L2124">			backlogData = getRawMultipleQueuesTimeSeries(actualMeta, campaignId, queueIDs, startDate, endDate);</span>
<span class="nc" id="L2125">			break;</span>
		default:
<span class="nc" id="L2127">			backlogData = new ArrayList&lt;&gt;();</span>
			break;
		}
<span class="nc" id="L2130">		return backlogData;</span>
	}

	private ArrayList getEmployeeSkillIDs(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L2134">		Collection empSkillAssignments = WfmManagerFactory.getSkillManager(WhatIfMode).getSkillAssignments(empID, start, end);</span>
<span class="nc" id="L2135">		ArrayList skillIDs = new ArrayList();</span>
<span class="nc bnc" id="L2136" title="All 2 branches missed.">		if (empSkillAssignments != null) {</span>
<span class="nc bnc" id="L2137" title="All 2 branches missed.">			for (Iterator iSkill = empSkillAssignments.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L2138">				skillIDs.add(((SkillAssignment) iSkill.next()).getSkillID());</span>
			}
		}
<span class="nc" id="L2141">		return skillIDs;</span>
	}

	private Map getSPSkillMap(ID campaignID, Date start, Date end) throws Exception {
<span class="nc" id="L2145">		Map&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="nc" id="L2146">		Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriods(campaignID, start, end);</span>
<span class="nc bnc" id="L2147" title="All 2 branches missed.">		for (SchedulingPeriod sp : spCol) {</span>
<span class="nc bnc" id="L2148" title="All 2 branches missed.">			spSkillMap.put(sp.getID(), sp.getSkillBased() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L2149">		}</span>
<span class="nc" id="L2150">		return spSkillMap;</span>
	}

	/**
	 * @param empID
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 */
	public INetStaffingCube getINetStaffing(ID empID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L2161">		return getNetStaffing(empID, start, end);</span>
	}

	public NetStaffingCube getNetStaffing(ID empID, Date start, Date end) throws BbmFinderException {
		try {
<span class="nc" id="L2166">			NetStaffingCube nCube = new NetStaffingCube();</span>
<span class="nc" id="L2167">			Collection returnCol = new ArrayList();</span>
			//Get the emp skills for given the date range
<span class="nc" id="L2169">			ArrayList skillIDs = getEmployeeSkillIDs(empID, start, end);</span>
			//get Campaign-work resource assignments for given the date range
<span class="nc" id="L2171">			Collection&lt;CampaignWorkResource&gt; assignments = m_CampaignManager.getWorkResourceCampaignAssignments(empID, start, end);</span>
<span class="nc bnc" id="L2172" title="All 4 branches missed.">			if (assignments == null || assignments.isEmpty()) {</span>
<span class="nc" id="L2173">				return null; // no point in showing net-staff if user is not associated to any campaign</span>
			}
			//get the queues that are relevant to emp skills for the campaigns
<span class="nc" id="L2176">			HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L2177" title="All 2 branches missed.">			for (Iterator it = assignments.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2178">				CampaignWorkResource ass = (CampaignWorkResource) it.next();</span>
<span class="nc bnc" id="L2179" title="All 2 branches missed.">				if (!spSkillMap.containsKey(ass.getSPID())) {</span>
<span class="nc" id="L2180">					spSkillMap.putAll(getSPSkillMap(ass.getCampaignID(), start, end));</span>
				}
<span class="nc" id="L2182">				Boolean isSKillSP = spSkillMap.get(ass.getSPID());</span>
<span class="nc" id="L2183">				HashMap&lt;ID, SPQueue&gt; spQueueMap = new HashMap&lt;ID, SPQueue&gt;();</span>
<span class="nc" id="L2184">				Campaign camp = m_CampaignManager.getCampaignByID(ass.getCampaignID());</span>

<span class="nc bnc" id="L2186" title="All 2 branches missed.">				if (isSKillSP) {</span>
<span class="nc" id="L2187">					Collection&lt;SPQueue&gt; spQueues = m_CampaignManager.getSPQueuesBySPID(ass.getSPID());</span>
<span class="nc bnc" id="L2188" title="All 2 branches missed.">					for (SPQueue spqueue : spQueues) {</span>
						//Filter and keep only queues that are relevant to employee Skills.
						//If unskilled then add all queues
<span class="nc bnc" id="L2191" title="All 4 branches missed.">						if (!isSKillSP || skillIDs.containsAll(spqueue.getSkills())) {</span>
<span class="nc" id="L2192">							spQueueMap.put(spqueue.getQueueID(), spqueue);</span>
						}
<span class="nc" id="L2194">					}</span>
<span class="nc" id="L2195">				} else {</span>
<span class="nc" id="L2196">					Collection&lt;SPQueue&gt; spQueues = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L2197">					SPQueue spQueue = m_CampaignManager.getCombinedSPQueue(ass.getSPID(), Media.MEDIA_ID_PHONE);</span>
<span class="nc bnc" id="L2198" title="All 2 branches missed.">					if (spQueue != null) {</span>
<span class="nc" id="L2199">						spQueues.add(spQueue);</span>
<span class="nc" id="L2200">						spQueueMap.put(Media.MEDIA_ID_PHONE, spQueue);</span>
					}
				}

<span class="nc bnc" id="L2204" title="All 4 branches missed.">				if (spQueueMap == null || spQueueMap.isEmpty()) {</span>
<span class="nc" id="L2205">					continue; //employee does not have the skills required for this campaign.</span>
				}
<span class="nc" id="L2207">				TimeRange tr = NetStaffingCube.getDateRangeForNetstaffing(camp, spQueueMap.values(), ass, start, end);</span>
<span class="nc" id="L2208">				getOverUnder(nCube, isSKillSP, camp, spQueueMap, tr.getStartDate(), tr.getEndDate());</span>
<span class="nc" id="L2209">			}</span>
<span class="nc" id="L2210">			return nCube;</span>
<span class="nc" id="L2211">		} catch (Exception e) {</span>
<span class="nc" id="L2212">			handleException(e, false);</span>
<span class="nc" id="L2213">			throw new BbmFinderException(e);</span>
		}
	}

	private void getOverUnder(NetStaffingCube nCube, boolean isSkillSP, Campaign camp, HashMap&lt;ID, SPQueue&gt; spQueueMap, Date start, Date end)
			throws Exception {
<span class="nc" id="L2219">		end = new Date(end.getTime() - 60000);//copied from Pulse UI to be consistent with the Pulse UI</span>
<span class="nc" id="L2220">		ID campID = camp.getID();</span>
<span class="nc" id="L2221">		Collection&lt;TraceCube&gt; predictCubeData = null;</span>
<span class="nc" id="L2222">		Collection&lt;TraceCube&gt; requireCubeData = null;</span>
<span class="nc bnc" id="L2223" title="All 2 branches missed.">		if (!isSkillSP) {</span>
<span class="nc" id="L2224">			predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, campID, Media.MEDIA_ID_PHONE, start, end);</span>
<span class="nc" id="L2225">			requireCubeData = getRawCombinedQueuesTimeSeries(requireMetaTCNetStaff, campID, Media.MEDIA_ID_PHONE, start, end);</span>
		} else {
<span class="nc" id="L2227">			predictCubeData = getRawMultipleQueuesTimeSeries(predictMetaTCNetStaff, campID, spQueueMap.keySet(), start, end);</span>
<span class="nc" id="L2228">			requireCubeData = getRawMultipleQueuesTimeSeries(requireMetaTCNetStaff, campID, spQueueMap.keySet(), start, end);</span>
		}
<span class="nc" id="L2230">		HashMap&lt;ID, TraceCube&gt; requireCubeMap = new HashMap&lt;ID, TraceCube&gt;();</span>
<span class="nc" id="L2231">		SPQueue spQueue = null;</span>
<span class="nc bnc" id="L2232" title="All 2 branches missed.">		for (Iterator&lt;TraceCube&gt; iterator1 = requireCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L2233">			TraceCube traceCube = iterator1.next();</span>
<span class="nc bnc" id="L2234" title="All 4 branches missed.">			if (!isSkillSP &amp;&amp; traceCube.getQueueID().toInt() &gt; 0) {</span>
<span class="nc" id="L2235">				continue; //ignore unskilled queues because we only interested in combined queue</span>
			}
<span class="nc" id="L2237">			requireCubeMap.put(traceCube.getQueueID(), traceCube);</span>
<span class="nc" id="L2238">		}</span>
<span class="nc bnc" id="L2239" title="All 2 branches missed.">		for (Iterator&lt;TraceCube&gt; iterator1 = predictCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L2240">			PredictTraceCube pCube = (PredictTraceCube) iterator1.next();</span>
<span class="nc bnc" id="L2241" title="All 4 branches missed.">			if (!isSkillSP &amp;&amp; pCube.getQueueID().toInt() &gt; 0) {</span>
<span class="nc" id="L2242">				continue; //ignore unskilled queues because we only interested in combined queue</span>
			}
<span class="nc" id="L2244">			RequireTraceCube rCube = (RequireTraceCube) requireCubeMap.get(pCube.getQueueID());</span>
<span class="nc bnc" id="L2245" title="All 2 branches missed.">			if (isSkillSP) {</span>
<span class="nc" id="L2246">				spQueue = spQueueMap.get(pCube.getQueueID());</span>
			} else {
<span class="nc bnc" id="L2248" title="All 4 branches missed.">				if (pCube == null || pCube.getSPQueueSID() == null) {</span>
					//no point in going further because there is no staffing data available  return here
<span class="nc" id="L2250">					LOG.debug(&quot;(TimeSeriesManagerEJB.getOverUnder )no point in going further because there is no staffing data available camp=&quot;</span>
							+ camp);
<span class="nc" id="L2252">					return;</span>
				}
<span class="nc" id="L2254">				spQueue = m_CampaignManager.getSPQueue(pCube.getSPQueueSID());</span>
			}
<span class="nc" id="L2256">			TraceCube[] metaCubes = new TraceCube[5];</span>
<span class="nc" id="L2257">			metaCubes[2] = pCube;</span>
<span class="nc" id="L2258">			metaCubes[4] = rCube;</span>
<span class="nc" id="L2259">			Map&lt;ID, SPQueue&gt; spQIDObjectMap = ValueObjectUtil.getIDObjectMap(spQueueMap.values());</span>
<span class="nc" id="L2260">			TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(metaCubes, spQIDObjectMap);</span>
<span class="nc" id="L2261">			nCube.addNetStaffing(camp, pCube, rCube, spQueue);</span>
<span class="nc" id="L2262">		}</span>
<span class="nc" id="L2263">	}</span>

	/**
	 * Get a map of SPID : &lt;collection of PredictTraceCube&gt;, that would exist if the specified ShiftAssignment is added/deleted,
	 * where the SPID's are the SP assignments for the given employee in the given date range, and the PredictTraceCube's are
	 * those that are relevant to the employee's skills (if a skilled SP). If skilled, the PredictTraceCube's will be for various
	 * queues (individual and/or combined).
	 * Events should at least have one shift assignment, it reflect the picture of schedule to recalc.
	 *
	 * @param traceCubesMap
	 * @param affectedTMTimeRange
	 * @param events
	 * @param shift
	 * @param isDelete
	 * @return a map of SPID : &lt;collection of PredictTraceCube&gt; that would exist if the specified ShiftAssignment is added/deleted.
	 * @throws BbmFinderException
	 */
	public Map reCalcAdjustedFTEAndStaffing(Map traceCubesMap, TimeRange affectedTMTimeRange, Collection events,
			ShiftAssignment shift, boolean isDelete) throws BbmFinderException {
<span class="nc" id="L2282">		methodStart(&quot;reCalcAdjustedFTEAndStaffing&quot;, traceCubesMap, affectedTMTimeRange, events, shift, isDelete);</span>
		try {
<span class="nc bnc" id="L2284" title="All 2 branches missed.">			if (shift == null) {</span>
<span class="nc" id="L2285">				return new HashMap(); // has nothing to recalc</span>
			}

<span class="nc bnc" id="L2288" title="All 2 branches missed.">			Date dtStart = shift.getStartTime().before(affectedTMTimeRange.getStartDate()) ? affectedTMTimeRange.getStartDate() : shift</span>
<span class="nc" id="L2289">					.getStartTime();</span>
<span class="nc bnc" id="L2290" title="All 2 branches missed.">			Date dtEnd = shift.getEndTime().after(affectedTMTimeRange.getEndDate()) ? affectedTMTimeRange.getEndDate() : shift.getEndTime();</span>
<span class="nc" id="L2291">			ID empID = shift.getWorkResourceIDs().iterator().next();</span>

<span class="nc" id="L2293">			ID spID = shift.getCampaignID();</span>
<span class="nc bnc" id="L2294" title="All 2 branches missed.">			if (spID == null) {</span>
<span class="nc" id="L2295">				return new HashMap(); //has nothing to recalc ESR'Unable to change request status' message received when trying to approve pending holidays. - ESR#4164188</span>
			}
<span class="nc" id="L2297">			Collection traceCubes = null;</span>
<span class="nc bnc" id="L2298" title="All 2 branches missed.">			if (traceCubesMap == null) {</span>
<span class="nc" id="L2299">				traceCubesMap = new HashMap();</span>
			}
<span class="nc" id="L2301">			traceCubes = (Collection) traceCubesMap.get(spID);</span>
<span class="nc bnc" id="L2302" title="All 2 branches missed.">			if (traceCubes == null) {</span>
<span class="nc" id="L2303">				traceCubesMap.putAll(getForecastedStaffingAndFTE(empID, affectedTMTimeRange.getStartDate(),</span>
<span class="nc" id="L2304">						affectedTMTimeRange.getEndDate()));</span>
<span class="nc" id="L2305">				traceCubes = (Collection) traceCubesMap.get(spID);</span>

				//the employee has no skills for his shift, so net staffing will not be affected by deleting the shift.
<span class="nc bnc" id="L2308" title="All 4 branches missed.">				if (traceCubes == null || traceCubes.size() == 0) {</span>
<span class="nc" id="L2309">					return traceCubesMap;</span>
				}
			}

<span class="nc" id="L2313">			ID key = null;</span>
<span class="nc" id="L2314">			Collection loopCubes = null;</span>
<span class="nc bnc" id="L2315" title="All 2 branches missed.">			for (Object spIDKey : traceCubesMap.keySet()) {</span>
<span class="nc" id="L2316">				key = ((ID) spIDKey);</span>
<span class="nc" id="L2317">				loopCubes = ((Collection) traceCubesMap.get(key));</span>
<span class="nc" id="L2318">				loopCubes = adjustTraceCubeForEachSP(loopCubes, dtStart, dtEnd, key, events, isDelete);</span>
<span class="nc" id="L2319">				traceCubesMap.put(key, loopCubes);</span>
<span class="nc" id="L2320">			}</span>

			//before return the trace cubes, remove the cubes that is not touched at all. only keep the updated cubes in the return list
<span class="nc" id="L2323">			Collection cubes = null;</span>
<span class="nc" id="L2324">			TraceCube cube = null;</span>

<span class="nc bnc" id="L2326" title="All 2 branches missed.">			for (Iterator iMap = traceCubesMap.values().iterator(); iMap.hasNext();) {</span>
<span class="nc" id="L2327">				cubes = (Collection) iMap.next();</span>
<span class="nc bnc" id="L2328" title="All 4 branches missed.">				if (cubes != null &amp;&amp; !cubes.isEmpty()) {</span>
<span class="nc bnc" id="L2329" title="All 2 branches missed.">					for (Iterator iCol = cubes.iterator(); iCol.hasNext();) {</span>
<span class="nc" id="L2330">						cube = (TraceCube) iCol.next();</span>
<span class="nc bnc" id="L2331" title="All 4 branches missed.">						if (!cube.isDirty(Trace.AFTE) &amp;&amp; !cube.isDirty(Trace.ASTAFFING)) {</span>
<span class="nc" id="L2332">							iCol.remove();</span>
						}
					}
				}
			}

<span class="nc" id="L2338">			return traceCubesMap;</span>
<span class="nc" id="L2339">		} catch (Exception e) {</span>
<span class="nc" id="L2340">			handleException(e);</span>
<span class="nc" id="L2341">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2343">			methodFinish();</span>
		}
	}

	public Collection adjustTraceCubeForEachSP(Collection traceCubes, Date affectedStDt, Date affectedEndDt, ID spID, Collection events,
			boolean isDelete) throws BbmFinderException {

<span class="nc" id="L2350">		TraceCube cube = null;</span>
<span class="nc" id="L2351">		TraceCube combinedCombinedCube = null;</span>

		try {
<span class="nc" id="L2354">			SchedulingPeriod sp = m_CampaignManager.getSchedulingPeriodByID(spID);</span>
<span class="nc" id="L2355">			Campaign campaign = m_CampaignManager.getCampaignByID(sp.getCampaignID());</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			Date dtStart = sp.getStartTime().after(affectedStDt) ? sp.getStartTime() : (Date) affectedStDt.clone();</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">			Date dtEnd = sp.getEndTime().before(affectedEndDt) ? sp.getEndTime() : (Date) affectedEndDt.clone();</span>

<span class="nc" id="L2359">			Map spQMap = getSPQMap(traceCubes);</span>

<span class="nc bnc" id="L2361" title="All 2 branches missed.">			if (spQMap == null) {</span>
<span class="nc" id="L2362">				return traceCubes;</span>
			}

<span class="nc" id="L2365">			SPQueue spQ = null;</span>
<span class="nc bnc" id="L2366" title="All 2 branches missed.">			for (Iterator i = traceCubes.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2367">				cube = (TraceCube) i.next();</span>
<span class="nc bnc" id="L2368" title="All 4 branches missed.">				if (cube != null &amp;&amp; cube.getSPQueueSID() != null) {</span>
<span class="nc" id="L2369">					spQ = (SPQueue) spQMap.get(cube.getSPQueueSID());</span>
<span class="nc bnc" id="L2370" title="All 6 branches missed.">					if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; spQ.getMediaID() == null) {</span>
<span class="nc" id="L2371">						combinedCombinedCube = cube;</span>
					}
				}
			}

<span class="nc bnc" id="L2376" title="All 2 branches missed.">			if (cube == null) {</span>
<span class="nc" id="L2377">				return traceCubes; //no traceCubes were found, so nothing to do.</span>
			}

			//no need to pass in activity id object map in the following call. that map is used only for set iswork flag for shift event. we don't care here.
<span class="nc" id="L2381">			Collection timelineEvents = EventUtils.convertEventsToTimelineForSingleEmployee(events, dtStart, dtEnd, null);</span>

			//for each 15 minutes, find out activities and the durations.
<span class="nc" id="L2384">			int startIndex = TraceUtil.gapOffSet(cube.getRawStartDate(), dtStart, campaign.getTimeZone(), true);</span>
<span class="nc" id="L2385">			int curIndex = startIndex;</span>
<span class="nc" id="L2386">			SimpleEvent sEvent = null;</span>
<span class="nc" id="L2387">			HashMap activityPer15m = new HashMap();</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">			for (Iterator i = timelineEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2389">				sEvent = (SimpleEvent) i.next();</span>
<span class="nc" id="L2390">				curIndex = analyzeEvent(sEvent, curIndex, activityPer15m);</span>
			}

<span class="nc" id="L2393">			Map.Entry entry = null;</span>
<span class="nc" id="L2394">			int index = 0;</span>
<span class="nc" id="L2395">			Collection activityDuration = null;</span>
<span class="nc" id="L2396">			ID idActivity = null;</span>
<span class="nc" id="L2397">			Activity activity = null;</span>
			double ratio;
<span class="nc" id="L2399">			ID mediaID = null;</span>
<span class="nc" id="L2400">			Pair pair = null;</span>
			boolean isLinkToAnyMediaOrQueue;
<span class="nc" id="L2402">			HashMap&lt;ID, HashSet&gt; activityIdMediaIDSetMap = new HashMap&lt;ID, HashSet&gt;();</span>
<span class="nc" id="L2403">			HashMap&lt;ID, Activity&gt; activitiesMap = new HashMap&lt;ID, Activity&gt;();</span>
<span class="nc" id="L2404">			HashMap&lt;ID, Collection&lt;Queue&gt;&gt; activityQueuesMap = new HashMap&lt;ID, Collection&lt;Queue&gt;&gt;();</span>
<span class="nc bnc" id="L2405" title="All 2 branches missed.">			for (Iterator i = activityPer15m.entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L2406">				isLinkToAnyMediaOrQueue = false;</span>
<span class="nc" id="L2407">				entry = (Map.Entry) i.next();</span>
<span class="nc" id="L2408">				index = (Integer) entry.getKey();</span>
<span class="nc" id="L2409">				activityDuration = (Collection) entry.getValue();</span>
<span class="nc bnc" id="L2410" title="All 2 branches missed.">				for (Iterator iActivity = activityDuration.iterator(); iActivity.hasNext();) {</span>
<span class="nc" id="L2411">					pair = (Pair) iActivity.next();</span>
<span class="nc" id="L2412">					ratio = ((Integer) (pair.getSecond())) / 15.0;</span>
<span class="nc" id="L2413">					idActivity = (ID) (pair.getFirst());</span>
<span class="nc" id="L2414">					activity = getActivity(activitiesMap, idActivity);</span>

<span class="nc bnc" id="L2416" title="All 2 branches missed.">					if (activity.isQueueHopping()) {</span>
<span class="nc" id="L2417">						isLinkToAnyMediaOrQueue = recalcForQueueHopping(traceCubes, isDelete, spQMap, index, idActivity, ratio,</span>
								isLinkToAnyMediaOrQueue, activityQueuesMap);
					} else {
<span class="nc bnc" id="L2420" title="All 2 branches missed.">						if (!activityIdMediaIDSetMap.containsKey(idActivity)) {</span>
<span class="nc" id="L2421">							activityIdMediaIDSetMap.put(idActivity, getMediaIDSetForActivityID(idActivity));</span>
						}
<span class="nc" id="L2423">						HashSet mediaIDs = activityIdMediaIDSetMap.get(idActivity);</span>
<span class="nc bnc" id="L2424" title="All 4 branches missed.">						if (mediaIDs != null &amp;&amp; !mediaIDs.isEmpty()) {</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">							for (Iterator iMedia = mediaIDs.iterator(); iMedia.hasNext();) {</span>
<span class="nc" id="L2426">								isLinkToAnyMediaOrQueue = true;</span>
<span class="nc" id="L2427">								mediaID = (ID) iMedia.next();</span>
<span class="nc" id="L2428">								recalc(traceCubes, mediaID, null, index, ratio, spQMap, isDelete);</span>
							}
						}
<span class="nc" id="L2431">					}</span>
				}
<span class="nc bnc" id="L2433" title="All 2 branches missed.">				if (isLinkToAnyMediaOrQueue) {</span>
					//for every 15m, adjust astaffing once on combinedCombinedQ if it is linked to any media or queue
<span class="nc" id="L2435">					adjustTraceValue(combinedCombinedCube, index, 0, 1, isDelete, false, true);</span>
				}
			}

<span class="nc" id="L2439">			return traceCubes;</span>
<span class="nc" id="L2440">		} catch (Exception e) {</span>
<span class="nc" id="L2441">			handleException(e);</span>
<span class="nc" id="L2442">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2444">			methodFinish();</span>
		}
	}

	/**
	* Get the queues linked to a queue-hopping activity, and adjust staffing and FTE for each matching SPQueue.
	* @return true if an adjustment was attempted for any of the activity's queues.
	*/
	private boolean recalcForQueueHopping(Collection traceCubes, boolean isDelete, Map spQMap, int index, ID idActivity, double ratio,
			boolean isLinkToAnyMediaOrQueue, Map&lt;ID, Collection&lt;Queue&gt;&gt; activityQueuesMap) throws BbmFinderException, RemoteException {
<span class="nc" id="L2454">		Collection&lt;Queue&gt; activityQueues = null;</span>
<span class="nc bnc" id="L2455" title="All 2 branches missed.">		if (activityQueuesMap.containsKey(idActivity)) {</span>
<span class="nc" id="L2456">			activityQueues = activityQueuesMap.get(idActivity);</span>
		} else {
<span class="nc" id="L2458">			Collection qIDs = m_activityManager.findQueueForActivity(idActivity);</span>
<span class="nc bnc" id="L2459" title="All 4 branches missed.">			if (qIDs != null &amp;&amp; !qIDs.isEmpty()) {</span>
<span class="nc" id="L2460">				activityQueues = m_workloadManager.getQueuesByIDs(qIDs);</span>
<span class="nc" id="L2461">				activityQueuesMap.put(idActivity, activityQueues);</span>
			}
		}
<span class="nc bnc" id="L2464" title="All 4 branches missed.">		if (activityQueues != null &amp;&amp; !activityQueues.isEmpty()) {</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">			for (Queue queue : activityQueues) {</span>
				//only recalc this queue if it is in the spQMap, indicating that it is in the SP.
<span class="nc" id="L2467">				boolean isQueueInSPQueueMap = false;</span>
<span class="nc bnc" id="L2468" title="All 2 branches missed.">				for (Iterator it = spQMap.values().iterator(); it.hasNext();) {</span>
<span class="nc" id="L2469">					SPQueue spq = (SPQueue) it.next();</span>
<span class="nc bnc" id="L2470" title="All 4 branches missed.">					if (spq.getQueueID() != null &amp;&amp; spq.getQueueID().equals(queue.getID())) {</span>
<span class="nc" id="L2471">						isQueueInSPQueueMap = true;</span>
<span class="nc" id="L2472">						break;</span>
					}
<span class="nc" id="L2474">				}</span>

<span class="nc bnc" id="L2476" title="All 2 branches missed.">				if (isQueueInSPQueueMap) {</span>
<span class="nc" id="L2477">					isLinkToAnyMediaOrQueue = true;</span>
<span class="nc" id="L2478">					recalc(traceCubes, queue.getMediaID(), queue.getID(), index, ratio, spQMap, isDelete);</span>
				}
<span class="nc" id="L2480">			}</span>
		}
<span class="nc" id="L2482">		return isLinkToAnyMediaOrQueue;</span>
	}

	private Activity getActivity(Map&lt;ID, Activity&gt; activitiesMap, ID activityID) throws Exception {
<span class="nc bnc" id="L2486" title="All 2 branches missed.">		if (activitiesMap.containsKey(activityID)) {</span>
<span class="nc" id="L2487">			return activitiesMap.get(activityID);</span>
		}
<span class="nc" id="L2489">		return m_activityManager.findActivityById(activityID);</span>
	}

	private HashSet getMediaIDSetForActivityID(ID idActivity) throws Exception {
<span class="nc" id="L2493">		HashSet mediaIDs = new HashSet();</span>
<span class="nc" id="L2494">		Collection col = m_activityManager.findMediaForActivity(idActivity);</span>
<span class="nc bnc" id="L2495" title="All 4 branches missed.">		if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="nc" id="L2496">			mediaIDs.addAll(col);</span>
		}

<span class="nc" id="L2499">		return mediaIDs;</span>
	}

	public void updateAdjustedFTEAndStaffing(Map traceCubesMap) throws BbmUpdateException {
<span class="nc" id="L2503">		methodStart(&quot;updateAdjustedFTEAndStaffing&quot;, traceCubesMap);</span>
		try {
<span class="nc bnc" id="L2505" title="All 2 branches missed.">			for (Iterator iMap = traceCubesMap.values().iterator(); iMap.hasNext();) {</span>
<span class="nc" id="L2506">				Collection traceCubes = (Collection) iMap.next();</span>
<span class="nc" id="L2507">				Map spQMap = getSPQMap(traceCubes);</span>
<span class="nc" id="L2508">				PredictTraceCube pCube = null;</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">				if (traceCubes != null) {</span>
<span class="nc bnc" id="L2510" title="All 2 branches missed.">					for (Iterator i = traceCubes.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2511">						pCube = (PredictTraceCube) i.next();</span>
						//Issue update only if , atleast one of the below Trace types is dirty
<span class="nc bnc" id="L2513" title="All 6 branches missed.">						if (pCube != null &amp;&amp; (pCube.isDirty(Trace.AFTE) || pCube.isDirty(Trace.ASTAFFING))) {</span>
<span class="nc" id="L2514">							TimeSeriesDAO</span>
<span class="nc" id="L2515">									.updatePredictTraceCube(pCube, new short[] { Trace.STAFFING, Trace.AFTE, Trace.ASTAFFING }, spQMap); //no change after recalc</span>
						}

					}
				}
<span class="nc" id="L2520">			}</span>
<span class="nc" id="L2521">		} catch (Exception e) {</span>
<span class="nc" id="L2522">			handleException(e);</span>
<span class="nc" id="L2523">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L2525">			methodFinish();</span>
<span class="nc" id="L2526">		}</span>
<span class="nc" id="L2527">	}</span>

	private Map getSPQMap(Collection traceCubes) throws Exception {
<span class="nc bnc" id="L2530" title="All 4 branches missed.">		if (traceCubes == null || traceCubes.isEmpty()) {</span>
<span class="nc" id="L2531">			return new HashMap();</span>
		}

<span class="nc" id="L2534">		TraceCube cube = null;</span>
<span class="nc" id="L2535">		Collection spQIDs = new ArrayList(traceCubes.size());</span>
<span class="nc bnc" id="L2536" title="All 2 branches missed.">		for (Iterator i = traceCubes.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2537">			cube = (TraceCube) i.next();</span>
<span class="nc bnc" id="L2538" title="All 4 branches missed.">			if (cube != null &amp;&amp; cube.getSPQueueSID() != null) {</span>
<span class="nc" id="L2539">				spQIDs.add(cube.getSPQueueSID());</span>
			}
		}

<span class="nc" id="L2543">		Collection spQs = m_CampaignManager.getSPQueuesByIDs(spQIDs);</span>
<span class="nc" id="L2544">		return ValueObjectUtil.getIDObjectMap(spQs);</span>

	}

	private void recalc(Collection oldCubes, ID mediaID, ID queueID, int index, double ratio,Map spQMap, boolean isDelete) {
		//find trace cube related to this media
<span class="nc" id="L2550">		TraceCube cube = null;</span>
<span class="nc" id="L2551">		ArrayList colQCubes = new ArrayList();</span>
<span class="nc" id="L2552">		TraceCube combinedCube = null;</span>
<span class="nc" id="L2553">		TraceCube combinedCombinedCube = null;</span>
<span class="nc" id="L2554">		SPQueue spQ = null;</span>
<span class="nc bnc" id="L2555" title="All 2 branches missed.">		for (Iterator i = oldCubes.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2556">			cube = (TraceCube) i.next();</span>
<span class="nc" id="L2557">			spQ = (SPQueue) spQMap.get(cube.getSPQueueSID());</span>
<span class="nc bnc" id="L2558" title="All 6 branches missed.">			if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; spQ.getMediaID() == null) {</span>
<span class="nc" id="L2559">				combinedCombinedCube = cube;</span>
			}
<span class="nc bnc" id="L2561" title="All 8 branches missed.">			if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; (spQ.getMediaID() != null &amp;&amp; spQ.getMediaID().equals(mediaID))) {</span>
<span class="nc" id="L2562">				combinedCube = cube;</span>
			}
<span class="nc bnc" id="L2564" title="All 4 branches missed.">			if (spQ != null &amp;&amp; spQ.getQueueID() != null) {</span>
<span class="nc bnc" id="L2565" title="All 6 branches missed.">				if (queueID == null &amp;&amp; spQ.getMediaID() != null &amp;&amp; spQ.getMediaID().equals(mediaID)) {</span>
					//diff real queue could link to same media
<span class="nc" id="L2567">					colQCubes.add(cube);</span>
<span class="nc bnc" id="L2568" title="All 4 branches missed.">				} else if (queueID != null &amp;&amp; spQ.getQueueID().equals(queueID)) {</span>
<span class="nc" id="L2569">					colQCubes.add(cube);</span>
				}
			}
		}

<span class="nc" id="L2574">		boolean isAlreadySetCombinedASTAFFING = false;</span>

<span class="nc bnc" id="L2576" title="All 4 branches missed.">		if (colQCubes.isEmpty() &amp;&amp; combinedCube != null) {</span>
			//in a non-skilled SP. We will adjust the combinedCube only
<span class="nc" id="L2578">			double ffte = combinedCube.getTraceValueD(Trace.FTE, index);</span>
<span class="nc" id="L2579">			double staff = combinedCube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="nc bnc" id="L2580" title="All 4 branches missed.">			double fteContribution = staff &gt; 0 &amp;&amp; ffte &gt; 0 ? (ffte / staff) * ratio : ratio;</span>
<span class="nc" id="L2581">			double staffContribution = 1 * ratio;</span>
<span class="nc" id="L2582">			adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, true, true);</span>
<span class="nc" id="L2583">		} else {</span>
<span class="nc bnc" id="L2584" title="All 2 branches missed.">			for (Iterator i = colQCubes.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2585">				cube = (TraceCube) i.next();</span>
				/*
					9.	To find the FTE contribution for this person/ shift use  (FFTE /FSTAFF)*CONTRIBUTION RATIO
				   10.	To find the STAFF contribution  for this person /shift use  1 * CONTRIBUTION RATIO
				   11.	Calculate the AFTE &amp; ASTAFF respectively .
				   	If you are using a flattened Timeline of shift to be deleted  then subtract the FTE &amp; STAFF contribution from AFTE &amp; ASTAFF respectively
				   	If you are using a flattened Timeline of shift to be added  then add the FTE &amp; STAFF contribution to AFTE &amp; ASTAFF respectively.
					*/
<span class="nc" id="L2593">				double ffte = cube.getTraceValueD(Trace.FTE, index);</span>
<span class="nc" id="L2594">				double staff = cube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="nc bnc" id="L2595" title="All 4 branches missed.">				double fteContribution = staff &gt; 0 &amp;&amp; ffte &gt; 0 ? (ffte / staff) * ratio : ratio;</span>
<span class="nc" id="L2596">				double staffContribution = 1 * ratio;</span>
<span class="nc" id="L2597">				adjustTraceValue(cube, index, fteContribution, staffContribution, isDelete, true, true);</span>

<span class="nc bnc" id="L2599" title="All 2 branches missed.">				if (!isAlreadySetCombinedASTAFFING) {</span>
<span class="nc" id="L2600">					isAlreadySetCombinedASTAFFING = true;</span>
<span class="nc" id="L2601">					adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, false, true);</span>
				}
				//for each queue, aggregate to combined and combined combined for FTE
<span class="nc" id="L2604">				adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, true, false);</span>
<span class="nc" id="L2605">				adjustTraceValue(combinedCombinedCube, index, fteContribution, staffContribution, isDelete, true, false);</span>
<span class="nc" id="L2606">			}</span>
		}
<span class="nc" id="L2608">	}</span>

	/*
	  * some background info here:
	  * FTE and STAFFING is orginically calculated by scheduling recalc. it is kind of the snapshot number at the time of recalculation.
	  * but after schedule changed, like adding a new shift:
	  * 1. FTE is still the snapshot number.
	  * 2. STAFFING becomes to a real time number now. but to calculate the real time staffing number, we need the staffing radio. the radio needs snapshot FTE and snapshot STAFFING
	  * to calc, then we store the snapshot STAFFING to ASTAFFING.
	  * 3. AFTE is real time number always.
	  */

	private void adjustTraceValue(TraceCube cube, int index, double fteContribution, double staffContribution, boolean isDelete,
			boolean isSetFTE, boolean isSetStaffing) {
<span class="nc bnc" id="L2622" title="All 2 branches missed.">		if (cube == null) {</span>
<span class="nc" id="L2623">			return;</span>
		}
<span class="nc" id="L2625">		double newAFTE = cube.getTraceValueD(Trace.AFTE, index);</span>
<span class="nc" id="L2626">		double newASTAFF = cube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="nc" id="L2627">		double newSTAFF = cube.getTraceValueD(Trace.STAFFING, index);</span>
<span class="nc bnc" id="L2628" title="All 2 branches missed.">		if (isDelete) {</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">			if (isSetFTE) {</span>
<span class="nc" id="L2630">				newAFTE = (newAFTE - fteContribution);</span>
			}
<span class="nc bnc" id="L2632" title="All 2 branches missed.">			if (isSetStaffing) {</span>
<span class="nc" id="L2633">				newSTAFF = (newSTAFF - staffContribution);</span>
			}
		} else {
<span class="nc bnc" id="L2636" title="All 2 branches missed.">			if (isSetFTE) {</span>
<span class="nc" id="L2637">				newAFTE = (newAFTE + fteContribution);</span>
			}
<span class="nc bnc" id="L2639" title="All 2 branches missed.">			if (isSetStaffing) {</span>
<span class="nc" id="L2640">				newSTAFF = (newSTAFF + staffContribution);</span>
			}
		}
		//if(newASTAFF&gt;0)System.out.println(&quot;index= &quot;+index+&quot;\tSTAFF=&quot;+newASTAFF + &quot;\tSPQID=&quot;+cube.getSPQueueSID());
<span class="nc" id="L2644">		cube.setTraceValue(Trace.AFTE, newAFTE, index, true);</span>
<span class="nc" id="L2645">		cube.setTraceValue(Trace.ASTAFFING, newASTAFF, index, true);</span>
<span class="nc" id="L2646">		cube.setTraceValue(Trace.STAFFING, newSTAFF, index, true);</span>
<span class="nc" id="L2647">		cube.setTypeDirty(Trace.AFTE, true);</span>
<span class="nc" id="L2648">		cube.setTypeDirty(Trace.ASTAFFING, true);//set dirty flag for later to update</span>
<span class="nc" id="L2649">		cube.setTypeDirty(Trace.STAFFING, true);//set dirty flag for later to update</span>
<span class="nc" id="L2650">	}</span>

	private int analyzeEvent(SimpleEvent event, int index, HashMap activityPer15m) {
<span class="nc" id="L2653">		int eventduration = event.getDuration();</span>
<span class="nc bnc" id="L2654" title="All 2 branches missed.">		while (eventduration &gt; 0) {</span>
<span class="nc" id="L2655">			Collection colActivityDuration = getActivityDurationList(Integer.valueOf(index), activityPer15m);</span>
<span class="nc" id="L2656">			int startOffSet = getStartOffSetForEvent(colActivityDuration);</span>
<span class="nc bnc" id="L2657" title="All 2 branches missed.">			if ((startOffSet + eventduration) &lt; 15) {</span>
<span class="nc" id="L2658">				colActivityDuration.add(new Pair(event.getActivityID(), Integer.valueOf(eventduration)));</span>
<span class="nc" id="L2659">				break;</span>
			} else {
				//startoffset + eventduration &gt;= 15 min
<span class="nc" id="L2662">				colActivityDuration.add(new Pair(event.getActivityID(), Integer.valueOf(15 - startOffSet)));</span>
<span class="nc" id="L2663">				eventduration -= 15 - startOffSet;</span>
<span class="nc" id="L2664">				index++;</span>
			}
<span class="nc" id="L2666">		}</span>
<span class="nc" id="L2667">		return index;</span>
	}

	private int getStartOffSetForEvent(Collection colActivityDuration) {
<span class="nc bnc" id="L2671" title="All 2 branches missed.">		if (colActivityDuration.isEmpty()) {</span>
<span class="nc" id="L2672">			return 0;</span>
		}

<span class="nc" id="L2675">		Iterator i = colActivityDuration.iterator();</span>
<span class="nc" id="L2676">		int offset = 0;</span>
<span class="nc bnc" id="L2677" title="All 2 branches missed.">		while (i.hasNext()) {</span>
<span class="nc" id="L2678">			offset += ((Integer) (((Pair) i.next()).getSecond())).intValue();</span>
		}
<span class="nc" id="L2680">		return offset;</span>
	}

	private Collection getActivityDurationList(int index, HashMap activityPer15m) {
<span class="nc" id="L2684">		Collection colActivityDuration = (Collection) activityPer15m.get(index);</span>
<span class="nc bnc" id="L2685" title="All 2 branches missed.">		if (colActivityDuration == null) {</span>
<span class="nc" id="L2686">			colActivityDuration = new ArrayList();</span>
<span class="nc" id="L2687">			activityPer15m.put(index, colActivityDuration);</span>
		}
<span class="nc" id="L2689">		return colActivityDuration;</span>
	}

	// ========== coded by Sameet ===========

	/**
	 * Get a map of SPID : &lt;collection of PredictTraceCube&gt;, where the SPID's are the SP assignments for the given
	 * employee in the given date range, and the PredictTraceCube's are those that are relevant to the employee's
	 * skills (if a skilled SP). If skilled, the PredictTraceCube's will be for various queues (individual and/or combined).
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @return a map of SPID -&gt; &lt;collection of PredictTraceCube&gt;
	 * @throws BbmFinderException
	 */
	private Map&lt;ID, Collection&gt; getForecastedStaffingAndFTE(ID empID, Date start, Date end) throws BbmFinderException {
		try {
<span class="nc" id="L2707">			HashMap spTraceCubeMap = new HashMap();</span>
			//Get the emp skills for given the date range
<span class="nc" id="L2709">			ArrayList skillIDs = getEmployeeSkillIDs(empID, start, end);</span>
			//get Campaign-work resource assignments for given the date range
<span class="nc" id="L2711">			Collection&lt;CampaignWorkResource&gt; assignments = m_CampaignManager.getWorkResourceCampaignAssignments(empID, start, end);</span>
<span class="nc bnc" id="L2712" title="All 4 branches missed.">			if (assignments == null || assignments.isEmpty()) {</span>
<span class="nc" id="L2713">				return null; // no point in showing net-staff if user is not associated to any campaign</span>
			}
<span class="nc bnc" id="L2715" title="All 2 branches missed.">			for (Iterator it = assignments.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2716">				CampaignWorkResource ass = (CampaignWorkResource) it.next();</span>
<span class="nc" id="L2717">				Collection retCol = getForecastedStaffingAndFTEForSP(ass, skillIDs,</span>
<span class="nc bnc" id="L2718" title="All 4 branches missed.">						start.after(ass.getStartTime()) ? start : ass.getStartTime(), end.before(ass.getEndTime()) ? end : ass.getEndTime());</span>
<span class="nc" id="L2719">				spTraceCubeMap.put(ass.getSPID(), retCol);</span>
<span class="nc" id="L2720">			}</span>
<span class="nc" id="L2721">			return spTraceCubeMap;</span>
<span class="nc" id="L2722">		} catch (Exception e) {</span>
<span class="nc" id="L2723">			handleException(e, false);</span>
<span class="nc" id="L2724">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Get a collection of PredictTraceCube's for the SP specified in the CampaignWorkResource argument and the
	 * given date range. If a skilled SP, we filter and keep only queues that are relevant to employee Skills.
	 * The TraceCube's returned can be for different queues, depending on the skills and the SP.
	 *
	 * @param ass
	 * @param skillIDs
	 * @param start
	 * @param end
	 * @return a collection of PredictTraceCube's. They can be for various queue's within the SP.
	 * @throws BbmFinderException
	 */
	private Collection getForecastedStaffingAndFTEForSP(CampaignWorkResource ass, ArrayList skillIDs, Date start, Date end)
			throws BbmFinderException {
		try {
			//get the queues that are relevant to emp skills for the campaigns
<span class="nc" id="L2744">			HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="nc" id="L2745">			Collection returnCol = new ArrayList();</span>
<span class="nc bnc" id="L2746" title="All 2 branches missed.">			if (!spSkillMap.containsKey(ass.getSPID())) {</span>
<span class="nc" id="L2747">				spSkillMap.putAll(getSPSkillMap(ass.getCampaignID(), start, end));</span>
			}
<span class="nc" id="L2749">			boolean isSKillSP = spSkillMap.get(ass.getSPID());</span>
<span class="nc" id="L2750">			Collection&lt;SPQueue&gt; spQueues = m_CampaignManager.getSPQueuesBySPID(ass.getSPID());</span>
<span class="nc" id="L2751">			Campaign camp = m_CampaignManager.getCampaignByID(ass.getCampaignID());</span>
<span class="nc" id="L2752">			Set&lt;ID&gt; mediaIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L2753">			Set&lt;ID&gt; qIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L2754" title="All 2 branches missed.">			for (SPQueue spqueue : spQueues) {</span>
				//Filter and keep only queues that are relevant to employee Skills.
<span class="nc bnc" id="L2756" title="All 2 branches missed.">				if (skillIDs.containsAll(spqueue.getSkills())) {</span>
<span class="nc" id="L2757">					mediaIDSet.add(spqueue.getMediaID());</span>
<span class="nc" id="L2758">					qIDSet.add(spqueue.getQueueID());</span>
				}
<span class="nc" id="L2760">			}</span>
<span class="nc bnc" id="L2761" title="All 6 branches missed.">			if (isSKillSP &amp;&amp; (mediaIDSet != null &amp;&amp; !mediaIDSet.isEmpty())) {</span>
<span class="nc bnc" id="L2762" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; iterator = mediaIDSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2763">					ID mediaID = iterator.next();</span>
					//This gets combined queue for a given media and underlying indvl queues as well.
<span class="nc" id="L2765">					Collection&lt;TraceCube&gt; predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, camp.getID(), mediaID,</span>
							start, end);
<span class="nc bnc" id="L2767" title="All 2 branches missed.">					for (Iterator&lt;TraceCube&gt; iterator1 = predictCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L2768">						PredictTraceCube pCube = (PredictTraceCube) iterator1.next();</span>
<span class="nc bnc" id="L2769" title="All 6 branches missed.">						if ((pCube.getQueueID() != null &amp;&amp; pCube.getQueueID().toInt() == -1) || qIDSet.contains(pCube.getQueueID())) {</span>
<span class="nc" id="L2770">							returnCol.add(pCube);</span>
						}
<span class="nc" id="L2772">					}</span>
<span class="nc" id="L2773">				}</span>
				//Only add Comb-Comb queue QC163600
<span class="nc" id="L2775">				addPredictedTraceCubes(returnCol, camp, null, start, end);</span>
			}
			//only add Combined-media queue if it is unskilled queue.
<span class="nc bnc" id="L2778" title="All 2 branches missed.">			if (!isSKillSP) {</span>
<span class="nc" id="L2779">				addPredictedTraceCubes(returnCol, camp, Media.MEDIA_ID_PHONE, start, end);</span>
			}
<span class="nc" id="L2781">			return returnCol;</span>
<span class="nc" id="L2782">		} catch (Exception e) {</span>
<span class="nc" id="L2783">			handleException(e, false);</span>
<span class="nc" id="L2784">			throw new BbmFinderException(e);</span>
		}
	}

	private void addPredictedTraceCubes(Collection returnCol, Campaign camp, ID mediaID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L2789">		Collection&lt;TraceCube&gt; predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, camp.getID(), mediaID, start, end);</span>

<span class="nc bnc" id="L2791" title="All 2 branches missed.">		if (predictCubeData != null) {</span>
<span class="nc bnc" id="L2792" title="All 2 branches missed.">			for (TraceCube pCube : predictCubeData) {</span>

<span class="nc bnc" id="L2794" title="All 4 branches missed.">				if ((pCube.getQueueID() != null) &amp;&amp; (pCube.getQueueID().toInt() == -1)) {</span>
<span class="nc" id="L2795">					returnCol.add(pCube);</span>
				}

<span class="nc" id="L2798">			}</span>
		}
<span class="nc" id="L2800">	}</span>

	/**
	 * Get the SPIDS to recalc based on Changes to Forecasted data ( checks Time of change of Forecasted data
	 * with Predicted Data to decide which SPs need recalc. Only checks for SPs that falls in the date range
	 * from today to (Today + lookfwdDays)
	 * Also returns  SPIDS that have any scheduling activity for the same range
	 *
	 * @param lookfwdDays
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public Set&lt;ID&gt; getSPIDsToReCalc(int lookfwdDays, Date lastRunTime) throws BbmFinderException {
		try {
<span class="nc" id="L2815">			return TimeSeriesDAO.getSPIDsToReCalc(lookfwdDays, lastRunTime);</span>
<span class="nc" id="L2816">		} catch (Exception e) {</span>
<span class="nc" id="L2817">			handleException(e, false);</span>
<span class="nc" id="L2818">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Checks if Forecasted staffing &amp; FTE exists for the given time range for the said employee
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @return
	 * @throws BbmFinderException
	 */

	public boolean doesStaffingExistForPeriod(ID empID, Date start, Date end) throws BbmFinderException {
		try {
<span class="nc" id="L2834">			return TimeSeriesDAO.doesStaffingExistForPeriod(empID, start, end);</span>
<span class="nc" id="L2835">		} catch (Exception e) {</span>
<span class="nc" id="L2836">			handleException(e, false);</span>
<span class="nc" id="L2837">			throw new BbmFinderException(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>