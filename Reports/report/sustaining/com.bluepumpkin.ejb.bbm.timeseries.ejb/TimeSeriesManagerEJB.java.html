<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeSeriesManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.ejb</a> &gt; <span class="el_source">TimeSeriesManagerEJB.java</span></div><h1>TimeSeriesManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.ejb;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.rmi.RemoteException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.cache.Cache;
import com.bluepumpkin.common.cache.CacheFactory;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.JNDINames;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignDAO;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.ejb.SPQueueDAO;
import com.bluepumpkin.ejb.bbm.campaign.model.*;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.pulse.model.TrackingView;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.BacklogType;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastInstance;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastInterimBacklog;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTimeSeries;
import com.bluepumpkin.ejb.bbm.timeseries.model.INetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceChunk;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.TimeSeriesCacheUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.bbm.forecast.ejb.ForecastProfileDAO;
import com.verint.ejb.bbm.forecast.model.ForecastProfile;
import com.verint.ejb.wfm.WfmManagerFactory;

import java.util.concurrent.TimeUnit;

<span class="fc" id="L85">public class TimeSeriesManagerEJB extends SessionEJBBase {</span>

	private static final long serialVersionUID = 1L;
<span class="fc" id="L88">	private static Category m_cat = Log.initCategory(TimeSeriesManagerEJB.class.getName());</span>

	static final int MINUTES_IN_BUCKET = 15;
<span class="fc" id="L91">	private static final long MILLIS_IN_BUCKET = TimeUnit.MINUTES.toMillis(MINUTES_IN_BUCKET);</span>
	private static final int BUCKETS_IN_DAY = 96;

    private CampaignManager m_CampaignManager;
    private TimeSeriesAuditManager m_timeSeriesAuditManager;
    private WorkloadManager m_workloadManager;
    private DBConfigManager m_dbConfigManager;
    private ActivityManager m_activityManager;

<span class="fc" id="L100">    private Cache m_TimeSeriesCache = null;</span>
<span class="fc" id="L101">    private static final ID comQueID = new ID(-1);</span>

	// override the base class to provide the appropriate logging category
<span class="fc" id="L104">    protected Category getCategory() { return m_cat; }</span>

    {
<span class="fc" id="L107">        super.init(TimeSeriesManagerEJB.class.getName());</span>
    }

<span class="fc" id="L110">    private boolean WhatIfMode = false;</span>

    public void ejbCreate() {
        try {
            // First query environment to get WIF setting from DD
<span class="fc" id="L115">            Context initialContext = new InitialContext();</span>
<span class="fc" id="L116">            Boolean WIF = (Boolean)initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">            if (WIF != null)</span>
<span class="fc" id="L118">                WhatIfMode = WIF.booleanValue();</span>
<span class="fc" id="L119">            m_CampaignManager = WfmManagerFactory.getCampaignManager(WhatIfMode);</span>
<span class="fc" id="L120">            m_timeSeriesAuditManager = WfmManagerFactory.getTimeSeriesAuditManager(WhatIfMode);</span>
<span class="fc" id="L121">            m_workloadManager = WfmManagerFactory.getWorkloadManager(WhatIfMode);</span>
<span class="fc" id="L122">            m_dbConfigManager = BbmManagerFactory.getDBConfigManager(WhatIfMode);</span>
<span class="fc" id="L123">            m_activityManager = WfmManagerFactory.getActivityManager(WhatIfMode);</span>
<span class="pc bpc" id="L124" title="2 of 4 branches missed.">            if (!WhatIfMode &amp;&amp; ConfigCacheUtil.isCacheEnabled(BbmManagerFactory.getDBConfigManager(), ConfigKey.TIMESERIES_CACHE_USAGE)) {</span>
<span class="nc" id="L125">                m_TimeSeriesCache = CacheFactory.getCache(JNDINames.BBM_TIMESERIES_EJBHOME, TimeSeriesManagerEJB.class.getClassLoader());</span>
            }
            
            //Set some static switches for use in time series / trace cube methods.
<span class="fc" id="L129">            TimeSeriesDAO.setIgnoreFutureData(m_dbConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA));</span>
<span class="fc" id="L130">            Trace.setAlwaysUseVHInsteadOfCV(m_dbConfigManager.getBooleanValue(ConfigKey.ALWAYS_USE_VOLUME_HANDLED));</span>
<span class="fc" id="L131">            setComputeSLOnIntervalHandled();</span>
<span class="fc" id="L132">            Trace.setComputeActualImmediateSLOnVHAndAbandons(m_dbConfigManager.getBooleanValue(ConfigKey.COMPUTE_ACT_IMM_SL_ON_VH_AND_ABN));</span>
<span class="nc" id="L133">        } catch (Exception e) {</span>
<span class="nc" id="L134">            handleException(&quot;ejbCreate&quot;, e);</span>
<span class="fc" id="L135">        }</span>
<span class="fc" id="L136">    }</span>
    
	/**
	 * Sets Trace.setComputeSLOnIntervalHandled based on the &quot;ComputeSLOnIntervalHandled&quot; config key.
	 * If ComputeSLOnIntervalHandled is either &quot;0&quot; then the value is set to false.  In all other cases, it is set to true
	 * (to match F&amp;S thick client behavior).
	 */
	private void setComputeSLOnIntervalHandled() throws RemoteException {
<span class="fc" id="L144">		String computeSlOnIntervalHandledValue = m_dbConfigManager.getValue(ConfigKey.COMPUTE_SL_ON_INTERVAL_HANDLED);</span>
<span class="fc" id="L145">		boolean isSet = true;</span>

		try {
<span class="nc bnc" id="L148" title="All 2 branches missed.">			if (Integer.parseInt(computeSlOnIntervalHandledValue) == 0) {</span>
<span class="nc" id="L149">				isSet = false;</span>
			}
<span class="fc" id="L151">		} catch (NumberFormatException ex) {</span>
			//Do nothing here, we only diverge from the default value if the flag is present and is &quot;0&quot;
<span class="nc" id="L153">		}</span>
<span class="fc" id="L154">		Trace.setComputeSLOnIntervalHandled(isSet);</span>
<span class="fc" id="L155">	}</span>

    /**
     * Support create Actual TimeSeries
     * @param cube
     * @throws BbmCreateException
     * @throws RemoteException
     */
    public void createTimeSeriesInCube(TraceCube cube) throws BbmCreateException
    {
<span class="nc" id="L165">        methodStart(&quot;createTimeSeriesInCube&quot;, cube);</span>
        try {
<span class="nc" id="L167">            TimeSeriesDAO.createTimeSeriesInCube(cube);</span>
            // if cube affect the cache, force a reload
<span class="nc bnc" id="L169" title="All 2 branches missed.">            if (m_TimeSeriesCache != null) {</span>
<span class="nc" id="L170">                Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
                // cube cross affect the cache window
<span class="nc bnc" id="L172" title="All 4 branches missed.">                if (!cacheWindow[0].after(cube.getRawEndDate()) &amp;&amp; !cacheWindow[1].before(cube.getRawStartDate())) {</span>
                    // lock entry first, then load from DB
<span class="nc bnc" id="L174" title="All 2 branches missed.">                    if (m_TimeSeriesCache.lock(cube.getQueueID(), -1)) {</span>
                        try {
<span class="nc" id="L176">                            Collection chunkCol = TimeSeriesDAO.getActualTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, cube.getQueueID(), cacheWindow[0], cacheWindow[1], null);</span>
<span class="nc" id="L177">                            m_TimeSeriesCache.put(cube.getQueueID(), chunkCol);</span>
                        } finally {
<span class="nc" id="L179">                            m_TimeSeriesCache.unLock(cube.getQueueID());</span>
<span class="nc" id="L180">                        }</span>
                    }
                }
            }
<span class="nc" id="L184">        } catch(JdmoException e) {</span>
<span class="nc" id="L185">            handleException(e);</span>
<span class="nc" id="L186">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L188">            methodFinish();</span>
<span class="nc" id="L189">        }</span>
<span class="nc" id="L190">    }</span>
    /**
     * For backend usage, to create TimeSeries based on a TraceChunk
     * @param chunk
     */
    public void createTimeSeriesInChunk(TraceChunk chunk) throws BbmCreateException
    {
<span class="nc" id="L197">        methodStart(&quot;createTimeSeriesInChunk&quot;, chunk);</span>
        try {
<span class="nc" id="L199">            TimeSeriesDAO.createTimeSeriesInChunk(chunk);</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            if (m_TimeSeriesCache != null) {</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                if (m_TimeSeriesCache.get(chunk.getQueueID()) == null) {</span>
<span class="nc" id="L202">                    Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc" id="L203">                    Collection chunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, chunk.getQueueID(), cacheWindow[0], cacheWindow[1], null, false);</span>
<span class="nc" id="L204">                    m_TimeSeriesCache.put(chunk.getQueueID(), chunkCol);</span>
<span class="nc" id="L205">                } else {</span>
<span class="nc" id="L206">                    TimeSeriesCacheUtil.addInActualCache(m_TimeSeriesCache, chunk);</span>
                }
            }
<span class="nc" id="L209">        } catch(JdmoException e) {</span>
<span class="nc" id="L210">            handleException(e);</span>
<span class="nc" id="L211">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L213">            methodFinish();</span>
<span class="nc" id="L214">        }</span>
<span class="nc" id="L215">    }</span>

    /**
     * For backend usage, to create TimeSeries based on a TraceChunk
     * @param chunkCol
     */
    public void createTimeSeriesInChunks(Collection&lt;TraceChunk&gt; chunkCol) throws BbmCreateException
    {
<span class="nc" id="L223">        methodStart(&quot;createTimeSeriesInChunks&quot;, chunkCol);</span>
<span class="nc" id="L224">        Jdmo jdmo = new Jdmo();</span>
        try {
<span class="nc" id="L226">            HashMap&lt;ID, List&lt;TraceChunk&gt;&gt; queChunkMap = new HashMap&lt;ID, List&lt;TraceChunk&gt;&gt;();</span>
<span class="nc" id="L227">            HashMap&lt;ID, Date[]&gt; queWinMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="nc bnc" id="L228" title="All 2 branches missed.">            for (TraceChunk chunk : chunkCol) {</span>
<span class="nc" id="L229">                List&lt;TraceChunk&gt; chunkList = queChunkMap.get(chunk.getQueueID());</span>
<span class="nc" id="L230">                Date[] range = queWinMap.get(chunk.getQueueID());</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">                if (chunkList == null) {</span>
<span class="nc" id="L232">                    chunkList = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc" id="L233">                    range = new Date[2];</span>
<span class="nc" id="L234">                    range[0] = chunk.getStartDate();</span>
<span class="nc" id="L235">                    range[1] = chunk.getStartDate();</span>
                }
<span class="nc" id="L237">                chunkList.add(chunk);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">                range[0] = range[0].after(chunk.getStartDate())?chunk.getStartDate():range[0];</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">                range[1] = range[1].before(chunk.getStartDate())?chunk.getStartDate():range[1];</span>
<span class="nc" id="L240">                queChunkMap.put(chunk.getQueueID(), chunkList);</span>
<span class="nc" id="L241">                queWinMap.put(chunk.getQueueID(), range);</span>
<span class="nc" id="L242">            }</span>
            // now work on each queue
<span class="nc bnc" id="L244" title="All 2 branches missed.">            for (ID queID : queChunkMap.keySet()) {</span>
<span class="nc" id="L245">                List&lt;TraceChunk&gt; chunkList = queChunkMap.get(queID);</span>
<span class="nc" id="L246">                Date[] range = queWinMap.get(queID);</span>
<span class="nc" id="L247">                Collection&lt;Timestamp&gt; existingTimes = TimeSeriesDAO.existingRow(queID, range[0], range[1], jdmo);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">                for (TraceChunk chunk : chunkList) {</span>
                    //FIXME: This comparison will fail if the chunk's start date has non-zero
                    // milliseconds.  See the Java API documentation for Timestamp for further
                    // details.
<span class="nc bnc" id="L252" title="All 2 branches missed.">                    if (existingTimes.contains(chunk.getStartDate())) {</span>
<span class="nc" id="L253">                        TimeSeriesDAO.updateChunkForActual(chunk, jdmo);</span>
                    } else {
<span class="nc" id="L255">                        TimeSeriesDAO.createChunkForActual(chunk, jdmo);</span>
                    }
<span class="nc" id="L257">                }</span>
<span class="nc" id="L258">            }</span>
<span class="nc" id="L259">            jdmo.executeBatch();</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (m_TimeSeriesCache != null) {</span>
<span class="nc" id="L261">                Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                for (ID queID : queChunkMap.keySet()) {</span>
<span class="nc" id="L263">                    List&lt;TraceChunk&gt; chunkList = queChunkMap.get(queID);</span>
<span class="nc" id="L264">                    Date[] range = queWinMap.get(queID);</span>
                    // if import range is before cache start window, just skip
<span class="nc bnc" id="L266" title="All 2 branches missed.">                    if (range[1].before(cacheWindow[0]))</span>
<span class="nc" id="L267">                        continue;</span>
<span class="nc bnc" id="L268" title="All 4 branches missed.">                    if (m_TimeSeriesCache.get(queID) == null || chunkList.size() &gt; 1) {</span>
<span class="nc" id="L269">                        Collection loadedCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, queID, cacheWindow[0], cacheWindow[1], null, false);</span>
<span class="nc" id="L270">                        m_TimeSeriesCache.put(queID, loadedCol);</span>
<span class="nc" id="L271">                    } else {</span>
<span class="nc" id="L272">                        TimeSeriesCacheUtil.addInActualCache(m_TimeSeriesCache, chunkList.get(0));</span>
                    }
<span class="nc" id="L274">                }</span>
            }
<span class="nc" id="L276">        } catch(JdmoException e) {</span>
<span class="nc" id="L277">            handleException(e);</span>
<span class="nc" id="L278">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L280">            jdmo.cleanUp();</span>
<span class="nc" id="L281">            methodFinish();</span>
<span class="nc" id="L282">        }</span>
<span class="nc" id="L283">    }</span>
    /**
     * Create/Update actual timeseries
     * @param traceType
     * @param queueIDCol
     * @param start
     * @param value, given in offset
     * @throws BbmCreateException
     * @throws RemoteException
     */
    public void createActualTimeSeries(short traceType, Collection queueIDCol, int value, Date start) throws BbmCreateException
    {
<span class="nc" id="L295">        methodStart(&quot;createActualTimeSeries&quot;, Trace.getTraceName(traceType), queueIDCol, start);</span>
        try {
<span class="nc" id="L297">            Date snappedDate = TraceUtil.snapDate(start);</span>
<span class="nc" id="L298">            TimeSeriesDAO.createActualTimeSeries(traceType, queueIDCol, value, snappedDate);</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">            if (m_TimeSeriesCache != null) {</span>
<span class="nc" id="L300">                Date[] window = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc bnc" id="L301" title="All 4 branches missed.">                if (!start.before(window[0]) &amp;&amp; !start.after(window[1])) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">                    for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L303">                        ID qID = (ID)it.next();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">                        if (m_TimeSeriesCache.get(qID) == null) {</span>
<span class="nc" id="L305">                            Date[] cacheWindow = TimeSeriesCacheUtil.getActualCacheWindow();</span>
<span class="nc" id="L306">                            Collection chunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL, qID, cacheWindow[0], cacheWindow[1], null, false);</span>
<span class="nc" id="L307">                            m_TimeSeriesCache.put(qID, chunkCol);</span>
<span class="nc" id="L308">                        } else {</span>
<span class="nc" id="L309">                            TimeSeriesCacheUtil.addInActualCache(m_TimeSeriesCache, qID, traceType, value, snappedDate, window);</span>
                        }
<span class="nc" id="L311">                    }</span>
                }
            }
<span class="nc" id="L314">        } catch(JdmoException e) {</span>
<span class="nc" id="L315">            handleException(e);</span>
<span class="nc" id="L316">            throw new BbmCreateException(e);</span>
        } finally {
<span class="nc" id="L318">            methodFinish();</span>
<span class="nc" id="L319">        }</span>
<span class="nc" id="L320">    }</span>
	/**
	 * Gets the list of months that has valid volume/aht data in the queuehistorytimeseries table
	 * @return List of month/year (Format: yyyymm)
	 * @throws BbmFinderException
	 */

	public List&lt;String&gt; getMonthYearListInActualTimeSeries(ID queueID, int nOffset) throws BbmFinderException {
<span class="nc" id="L328">		methodStart(&quot;getMonthYearListInActualTimeSeries&quot;, queueID, nOffset);</span>
		try {
<span class="nc" id="L330">			return TimeSeriesDAO.getMonthYearListInActualTimeSeries(queueID, nOffset);</span>
<span class="nc" id="L331">		} catch (JdmoException e) {</span>
<span class="nc" id="L332">			handleException(e);</span>
<span class="nc" id="L333">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L335">			methodFinish();</span>
		}
	}

	/**
	 * Gets volume/AHT from queuehistorytimeseries table that has valid data  within the data range
	 * i.e (volume/AHT &gt; 0 and wolume/AHT not null)
	 * @return ActualTraceCube
	 * @throws BbmFinderException
	 */

	public ActualTraceCube getHistoryData(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L347">		methodStart(&quot;getHistoryData&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L349">			return TimeSeriesDAO.getActualTraceCube(queueID, startDate, endDate);</span>
<span class="nc" id="L350">		} catch (final JdmoException ex) {</span>
<span class="nc" id="L351">			handleException(ex);</span>
<span class="nc" id="L352">			throw new BbmFinderException(ex);</span>
<span class="nc" id="L353">		} catch (BbmTimeSeriesException e) {</span>
<span class="nc" id="L354">			handleException(e);</span>
<span class="nc" id="L355">			throw new BbmFinderException(e);</span>
		}finally {
<span class="nc" id="L357">			methodFinish();</span>
		}
	}

	/**
	 * Gets the list of date that has valid volume/aht data in the queuehistorytimeseries table
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public List&lt;String&gt; getDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L367">		methodStart(&quot;getDayMonthYearListInActualTimeSeries&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L369">			return TimeSeriesDAO.getDayMonthYearListInActualTimeSeries(queueID, startDate, endDate);</span>
<span class="nc" id="L370">		} catch (final JdmoException e) {</span>
<span class="nc" id="L371">			handleException(e);</span>
<span class="nc" id="L372">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L374">			methodFinish();</span>
		}
	}

	/**
	 * Gets the list of week start date that has valid volume/aht data in the queuehistorytimeseries table
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public List&lt;String&gt; getWeekListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L384">		methodStart(&quot;getWeekListInActualTimeSeries&quot;, queueID, startDate, endDate);</span>
		try {
<span class="nc" id="L386">			return TimeSeriesDAO.getWeekListInActualTimeSeries(queueID, startDate, endDate);</span>

<span class="nc" id="L388">		} catch (JdmoException e) {</span>
<span class="nc" id="L389">			handleException(e);</span>
<span class="nc" id="L390">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L392">			methodFinish();</span>
		}
	}

    /**
	 * Returns a list of days (represented as dates set at 12AM GMT - only the day portion is considered) that contain
	 * history records in the QUEUEHISTORYTIMESERIES table for the given queues in the given date range.
	 */
	public List&lt;Date&gt; getDaysWithHistoryForQueues(Collection&lt;ID&gt; queueIds, Date startDate, Date endDate)
			throws BbmFinderException {
<span class="nc" id="L402">		methodStart(&quot;getDaysWithHistoryForQueues&quot;, queueIds, startDate, endDate);</span>
		try {
<span class="nc" id="L404">			return TimeSeriesDAO.getDaysWithHistoryForQueues(queueIds, startDate, endDate);</span>
<span class="nc" id="L405">		} catch (JdmoException ex) {</span>
<span class="nc" id="L406">			handleException(ex);</span>
<span class="nc" id="L407">			throw new BbmFinderException(ex);</span>
		} finally {
<span class="nc" id="L409">			methodFinish();</span>
		}
	}

	/**
     * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
     * with
     * 1&gt; includeAllServiceGoalTypes set to false as the default behavior.  This means that if a service goals trace cube is expected, it will
     * only return data for the selected service goal type even if data for multiple types exists.
     * 2&gt; needAllValid is set to true as the default behavior.
     * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
     */
    public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end) throws BbmFinderException {
<span class="fc" id="L422">        return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, false, true);</span>
    }

    /**
     * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
     * with
     * 1&gt; needAllValid is set to true as the default behavior.
     * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
     */
    public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end,boolean includeAllServiceGoalTypes) throws BbmFinderException {
<span class="fc" id="L432">        return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, includeAllServiceGoalTypes, true);</span>
    }
    
    /**
     * Calls getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection queueIDCol, Date start, Date end, boolean includeAllServiceGoalTypes,boolean needAllValid)
     * with
     * 1&gt; needAllValid is set to true as the default behavior.
     * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues
     * isNoPhantom is set to false as the default behavior.
     */
    public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end,
    		boolean includeAllServiceGoalTypes, boolean needAllValid) throws BbmFinderException {
<span class="fc" id="L444">        return getRawMultipleQueuesTimeSeries(metaTC, campaignID, queueIDCol, start, end, includeAllServiceGoalTypes, true, false);</span>
    }
    
    /**
     * Return TraceCube in a collection for given collection of Queue IDs for a given time range
     * @param metaTC
     * @param campaignID
     * @param queueIDCol
     * @param start
     * @param end
     * @param includeAllServiceGoalTypes
     * @param needAllValid
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level, 
	 * ASA, and Dials for the same queue(s) being requested. 
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public Collection&lt;TraceCube&gt; getRawMultipleQueuesTimeSeries(TraceCube metaTC, ID campaignID, Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end, 
    		boolean includeAllServiceGoalTypes, boolean needAllValid, boolean isNoPhantom ) throws BbmFinderException
    {
<span class="fc" id="L465">        methodStart(&quot;getRawMultipleQueuesTimeSeries&quot;, metaTC, campaignID, queueIDCol, start, end);</span>
        try {
<span class="fc" id="L467">            List&lt;TraceCube&gt; cubeCol = new ArrayList&lt;TraceCube&gt;(queueIDCol.size());</span>
<span class="fc" id="L468">            short[] types = metaTC.getTraceTypes();</span>
            // build a table of SPQueues by SPQueue ID for all sps
<span class="fc" id="L470">            Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueIDCol, start, end);</span>
<span class="fc" id="L471">            Map&lt;ID, Queue&gt; queMap = ValueObjectUtil.getIDObjectMap(m_workloadManager.getQueuesByIDs((Collection&lt;ID&gt;) queueIDCol));</span>
            
            // need special handle Predicted/Required for Queue that linked to a Campaign alone
            // it will load Predicted/Required directly from Campaign Queue
            
<span class="fc bfc" id="L476" title="All 4 branches covered.">            if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L477">                cubeCol = getRawMultipleQueuesTimeSeriesForPredictRequiredTC(</span>
						metaTC, campaignID, queueIDCol, start, end,
						isNoPhantom, types, idToSPQueueMapping, queMap);
<span class="fc bfc" id="L480" title="All 2 branches covered.">            } else if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="fc" id="L481">                getRawMultipleQueuesTimeSeriesForSGTC(metaTC, queueIDCol,</span>
						start, end, includeAllServiceGoalTypes, cubeCol, types,
						idToSPQueueMapping);
            } else {
                // dump for real queue
<span class="fc" id="L486">                WorkloadManager m_WorkloadManager = WfmManagerFactory.getWorkloadManager(WhatIfMode);</span>
<span class="fc bfc" id="L487" title="All 2 branches covered.">                for (ID queueID : queueIDCol) {</span>
<span class="fc" id="L488">                	Queue queue = queMap.get(queueID);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">                    if (queue == null) {</span>
<span class="nc" id="L490">                    	queue = m_workloadManager.getQueueByID(queueID);</span>
                    }
                    //for virtual queue, the actual will be read from children and combined
                    //Sameet, Oct 2009, QC# 45750
<span class="pc bpc" id="L494" title="3 of 4 branches missed.">                    if (metaTC instanceof ActualTraceCube &amp;&amp; queue.getQueueType() == Queue.QUEUE_TYPE_VIRTUAL) {</span>
<span class="nc" id="L495">						getRawMultipleQueuesTimeSeriesForActualTC(metaTC,</span>
								start, end, needAllValid, cubeCol, types,
								idToSPQueueMapping, queMap,  m_WorkloadManager, queueID);
                    } else {
<span class="fc" id="L499">                        cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, queMap));</span>
                    }
<span class="fc" id="L501">                }</span>
            }
<span class="fc" id="L503">            return cubeCol;</span>
<span class="nc" id="L504">        } catch (Exception e) {</span>
<span class="nc" id="L505">            handleException(e);</span>
<span class="nc" id="L506">            throw new BbmFinderException(e);</span>
        } finally {
<span class="pc" id="L508">            methodFinish();</span>
        }
    }

	/**
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param needAllValid
	 * @param cubeCol
	 * @param types
	 * @param idToSPQueueMapping
	 * @param m_WorkloadManager
	 * @param queueID
	 * @throws Exception
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws BbmTimeSeriesException
	 */
	private void getRawMultipleQueuesTimeSeriesForActualTC(TraceCube metaTC,
			Date start, Date end, boolean needAllValid,
			List&lt;TraceCube&gt; cubeCol, short[] types,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping,
			Map&lt;ID, Queue&gt; queMap,
			WorkloadManager m_WorkloadManager, ID queueID) throws Exception,
			BbmFinderException, RemoteException, BbmTimeSeriesException {
<span class="nc bnc" id="L534" title="All 4 branches missed.">		if (types.length==1 &amp;&amp; types[0]==Trace.STAFFING) { //ESR#4226602: WFM - Staffing figures not Populating for virtual Queues.</span>
<span class="nc" id="L535">			cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, queMap));</span>
		} else {
<span class="nc" id="L537">			Collection&lt;ID&gt; subQueIDs = m_WorkloadManager.getSubQueues(Collections.singletonList(queueID));</span>
<span class="nc bnc" id="L538" title="All 4 branches missed.">			if (subQueIDs != null &amp;&amp; !subQueIDs.isEmpty()) {</span>
<span class="nc" id="L539">				List&lt;TraceCube&gt; subCubeCol = new ArrayList&lt;TraceCube&gt;();</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; i = subQueIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L541">					ID subQueueID = i.next();</span>
<span class="nc" id="L542">					subCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, subQueueID, start, end, null, idToSPQueueMapping, queMap));</span>
<span class="nc" id="L543">				}</span>
<span class="nc" id="L544">				TraceCube cmbCube = TraceOperatorAdapter.combineQueue(subCubeCol, needAllValid, WhatIfMode);</span>
<span class="nc" id="L545">				cmbCube.setQueueID(queueID);</span>
<span class="nc" id="L546">				cubeCol.add(cmbCube);</span>
<span class="nc" id="L547">			} else {</span>
				//add empty actual cube
<span class="nc" id="L549">				cubeCol.add(metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes()));</span>
			}
		}
<span class="nc" id="L552">	}</span>

	/**
	 * @param metaTC
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param cubeCol
	 * @param types
	 * @param idToSPQueueMapping
	 * @throws JdmoException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRawMultipleQueuesTimeSeriesForSGTC(TraceCube metaTC,
			Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end,
			boolean includeAllServiceGoalTypes, List&lt;TraceCube&gt; cubeCol,
			short[] types, Map&lt;ID, SPQueue&gt; idToSPQueueMapping)
			throws JdmoException, Exception, BbmTimeSeriesException {
		// Get skill based info and media ID
<span class="fc" id="L573">		Jdmo jdmo = new Jdmo();</span>
		// Special handling for non-skillBased
<span class="fc" id="L575">		Set&lt;ID&gt; nonSkillBasedSPSet = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L576">		List&lt;Date[]&gt; nonSkillRangeSet = new ArrayList&lt;Date[]&gt;();</span>
<span class="fc" id="L577">		String mediaDeID = null;</span>
		try {
<span class="fc" id="L579">		    String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE from QUEUE A, SPQUEUE B, SP C where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? order by C.FROMDATE asc&quot;;</span>
<span class="fc bfc" id="L580" title="All 2 branches covered.">		    for (ID queueID : queueIDCol) {</span>
<span class="fc" id="L581">		        JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="fc" id="L582">		        jQuery1.setParID(1, queueID);</span>
<span class="fc" id="L583">		        jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="fc" id="L584">		        jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="fc" id="L585">		        JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="fc bfc" id="L586" title="All 2 branches covered.">		        while (rs1.next()) {</span>
<span class="fc" id="L587">		            boolean skillBased = rs1.getBoolean(1);</span>
<span class="fc" id="L588">		            mediaDeID = rs1.getString(2);</span>
<span class="fc bfc" id="L589" title="All 2 branches covered.">		            if (!skillBased) {</span>
<span class="fc" id="L590">		                nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="fc" id="L591">		                Date[] range = new Date[2];</span>
<span class="fc" id="L592">		                range[0] = rs1.getTimestamp(4);</span>
<span class="fc" id="L593">		                range[1] = rs1.getTimestamp(5);</span>
<span class="fc" id="L594">		                nonSkillRangeSet.add(range);</span>
		            }
<span class="fc" id="L596">		        }</span>
<span class="fc" id="L597">		        rs1.close();</span>
<span class="fc" id="L598">		        jQuery1.close();</span>
<span class="fc" id="L599">		        TraceCube sgCube = null;</span>
<span class="fc" id="L600">		        Collection&lt;TraceChunk&gt; sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, queueID, start, end, null, includeAllServiceGoalTypes);</span>
<span class="fc bfc" id="L601" title="All 2 branches covered.">		        if (!nonSkillRangeSet.isEmpty()) {</span>
		            //  non skill SG is direct load
<span class="fc" id="L603">		            sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(queueID, nonSkillBasedSPSet, mediaDeID, start, end, null, includeAllServiceGoalTypes, idToSPQueueMapping);</span>
		        }
<span class="fc bfc" id="L605" title="All 4 branches covered.">		        if (!sgCol.isEmpty() || sgCube == null) {</span>
		            // merge
<span class="pc bpc" id="L607" title="1 of 2 branches missed.">		            if (sgCube == null) {</span>
		                // simply create a new cube
<span class="fc" id="L609">		                sgCube = metaTC.newInstance(queueID, start, end, types);</span>
		            }
		            // merge sgCol to sgCube
<span class="fc bfc" id="L612" title="All 2 branches covered.">		            for (Iterator&lt;TraceChunk&gt; itChunk = sgCol.iterator(); itChunk.hasNext(); ) {</span>
<span class="fc" id="L613">		                TraceChunk chunk = itChunk.next();</span>
<span class="fc" id="L614">		                sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="fc" id="L615">		            }</span>

		        }
<span class="fc" id="L618">		        cubeCol.add(sgCube);</span>
<span class="fc" id="L619">		    }</span>
		    // need merge two cubes
		} finally {
<span class="pc" id="L622">		    jdmo.cleanUp();</span>
<span class="fc" id="L623">		}</span>
<span class="fc" id="L624">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param queueIDCol
	 * @param start
	 * @param end
	 * @param isNoPhantom
	 * @param types
	 * @param idToSPQueueMapping
	 * @return
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmFinderException
	 * @throws BbmObjectNotFoundException
	 * @throws BbmTimeSeriesException
	 */
	private List&lt;TraceCube&gt; getRawMultipleQueuesTimeSeriesForPredictRequiredTC(
			TraceCube metaTC, ID campaignID,
			Collection&lt;? extends ID&gt; queueIDCol, Date start, Date end,
			boolean isNoPhantom, short[] types,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Map&lt;ID, Queue&gt;queMap) throws RemoteException,
			Exception, BbmFinderException, BbmObjectNotFoundException,
			BbmTimeSeriesException {
		List&lt;TraceCube&gt; cubeCol;
		// load individually as usual
		// dump for real queue
<span class="fc" id="L652">		TimeSeriesDAO.setIgnoreFutureData(m_dbConfigManager.getBooleanValue(ConfigKey.IGNORE_FUTURE_DATA));</span>
		//SAmeet Loading the Timeseries cube for individual QUEUES
<span class="fc" id="L654">		HashMap&lt;ID, TraceCube&gt; cubeMap = new HashMap&lt;ID, TraceCube&gt;(queueIDCol.size());</span>
<span class="fc bfc" id="L655" title="All 2 branches covered.">		for (ID queueID : queueIDCol) {</span>
<span class="fc" id="L656">		    cubeMap.put(queueID, TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, queMap, isNoPhantom));</span>
<span class="fc" id="L657">		}</span>
		// call Campaign Manager to obtain list of SPQueueID meets this requirement, find SP only has on queue
		//Sameet get all SPs for the campaign and create a hashmap SP&lt;&gt; QUEUES for all sps
<span class="fc" id="L660">		Collection&lt;CampaignQueue&gt; cpgQueCol = m_CampaignManager.getCampaignQueueAssignmentsAndCombinedQueues(campaignID, start, end);</span>
<span class="fc" id="L661">		Map&lt;ID, List&lt;CampaignQueue&gt;&gt; spCpgQueMap = new HashMap&lt;ID, List&lt;CampaignQueue&gt;&gt;(); //hashmap that holds SP ID&lt;--&gt; Arraylist of QUEUES for all sps</span>
<span class="fc bfc" id="L662" title="All 2 branches covered.">		for (CampaignQueue cpgQue : cpgQueCol) {</span>
<span class="fc" id="L663">		    ID spID = cpgQue.getSPID();</span>
<span class="fc" id="L664">		    List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="fc bfc" id="L665" title="All 2 branches covered.">		    if (cpqQueList == null) {</span>
<span class="fc" id="L666">		        cpqQueList = new ArrayList&lt;CampaignQueue&gt;();</span>
		    }
<span class="fc" id="L668">		    cpqQueList.add(cpgQue);</span>
<span class="fc" id="L669">		    spCpgQueMap.put(spID, cpqQueList);</span>
<span class="fc" id="L670">		}</span>
		// find SP that only has one Queue linked
		//Sameet: if the ArrayList of queues for SP has two queues then it is definitely having only one real queue
<span class="fc" id="L673">		Map&lt;ID, CampaignQueue&gt; spQueIDMap = new HashMap&lt;ID, CampaignQueue&gt;();   //Hashmap containing  SP ID&lt;--&gt; queue for SP that have only one QUEUE</span>
<span class="fc bfc" id="L674" title="All 2 branches covered.">		for (ID spID : spCpgQueMap.keySet()) {</span>
<span class="fc" id="L675">		    List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="fc bfc" id="L676" title="All 2 branches covered.">		    if (cpqQueList.size() == 2) {</span>
		        // if cpgQue list size is 2, check if the media is Phone or not
<span class="fc" id="L678">		        CampaignQueue cpgQue1 = cpqQueList.get(0);       //INDV QUEUE ; always normal queue</span>
<span class="fc" id="L679">		        CampaignQueue cpgQue2 = cpqQueList.get(1);       //combined queue</span>
<span class="pc bpc" id="L680" title="1 of 2 branches missed.">		        CampaignQueue medQue = cpgQue1.getMediaID() == null?cpgQue2:cpgQue1; //getMediaID is always always null for cpgQue1;( real queues)</span>
<span class="pc bpc" id="L681" title="1 of 2 branches missed.">		        CampaignQueue relQue = cpgQue1.getQueueID() == null?cpgQue2:cpgQue1; //getQueueID will never be null for cpgQue1</span>
		        // TODO eclingman Not clear what this logic does, so we still need
		        // to verify that we don't need face to face test as well as phone test
<span class="fc bfc" id="L684" title="All 2 branches covered.">		        if (medQue.getMediaID().equals(Media.MEDIA_ID_PHONE)) {</span>
		            // if Map has no entry for the SP ID, just put the placeholder
<span class="fc bfc" id="L686" title="All 2 branches covered.">		            if (queueIDCol.contains(relQue.getQueueID()))</span>
<span class="fc" id="L687">		                spQueIDMap.put(relQue.getSPID(), relQue);</span>
		        }
		    }
<span class="fc" id="L690">		}</span>


		// now if SP is not empty, check SP is skill base or not.
		//If the SP is skill based then remove it from the Hashmap
<span class="fc bfc" id="L695" title="All 2 branches covered.">		if (!spQueIDMap.isEmpty()) {</span>
<span class="fc" id="L696">		    Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriodsByID(spQueIDMap.keySet());</span>
<span class="fc bfc" id="L697" title="All 2 branches covered.">		    for (SchedulingPeriod sp : spCol) {</span>
<span class="pc bpc" id="L698" title="1 of 2 branches missed.">		        if (sp.getSkillBased()) {</span>
<span class="nc" id="L699">		            spQueIDMap.remove(sp.getID());</span>
		        }
<span class="fc" id="L701">		    }</span>
		    // load in one by one, then merge
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">		    if (!spQueIDMap.isEmpty()) {</span>
<span class="fc" id="L704">		        TraceCube combQueCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, Media.MEDIA_ID_PHONE, </span>
<span class="fc" id="L705">		        		spQueIDMap.keySet(), start, end, null, false, idToSPQueueMapping, isNoPhantom);</span>
		        // merge sp by sp
<span class="fc bfc" id="L707" title="All 2 branches covered.">		        for (ID spID : spQueIDMap.keySet()) {</span>
<span class="fc" id="L708">		            CampaignQueue cpgQue = spQueIDMap.get(spID);</span>
<span class="fc" id="L709">		            ID queID = cpgQue.getQueueID();</span>
<span class="fc" id="L710">		            TraceCube queCube = cubeMap.get(queID); //get tracecube for the real queue (this cube is acquired above)</span>
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">		            if (queCube == null) {</span>
		                // queue itself has no data, need create a new cube, and merge combined into it
<span class="nc" id="L713">		                queCube = metaTC.newInstance(queID, start, end, metaTC.getTraceTypes());</span>
<span class="nc" id="L714">		                cubeMap.put(queID, queCube);</span>
		            }
		            // merge data now per SP window
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">		            Date qStart = cpgQue.getStartTime().after(start)?cpgQue.getStartTime():start;</span>
<span class="pc bpc" id="L718" title="1 of 2 branches missed.">		            Date qEnd = cpgQue.getEndTime().after(end)?end:cpgQue.getEndTime();</span>
<span class="fc bfc" id="L719" title="All 2 branches covered.">		            for (int i = 0; i &lt; types.length; i++) {</span>
<span class="fc" id="L720">		                short type = types[i];</span>
<span class="fc" id="L721">		                double[] value = combQueCube.getTraceValueD(type, qStart, qEnd);</span>
		                //Note**** We return SPQUEUEID of COMBINED QUEUE instead of that of the individual queue but it is ok ***********
		                //Bad hack as usual but seems fine. we pass all the data for combined queue so returning the SPQUEUEID of combined queue is also OK
<span class="pc bpc" id="L724" title="2 of 4 branches missed.">		                if (queCube != null &amp;&amp; combQueCube != null) {</span>
<span class="fc bfc" id="L725" title="All 2 branches covered.">		                    if (combQueCube.getSPQueueSID() != null) {</span>
<span class="fc" id="L726">		                        queCube.setSPQueueSID(combQueCube.getSPQueueSID());</span>
		                    }
<span class="fc bfc" id="L728" title="All 2 branches covered.">		                    if (combQueCube.getCampaignTimeZoneID() != null) {</span>
<span class="fc" id="L729">		                        queCube.setCampaignTimeZoneID(combQueCube.getCampaignTimeZoneID());</span>
		                    }
		                }
<span class="fc" id="L732">		                queCube.setTraceValue(type, value, qStart);</span>
		            }
<span class="fc" id="L734">		        }</span>
		    }
		}
		// convert map to collection
<span class="fc" id="L738">		cubeCol = new ArrayList&lt;TraceCube&gt;(cubeMap.values());</span>
<span class="fc" id="L739">		return cubeCol;</span>
	}

    /**
     * Return TraceCube in a collection for given collection of Queue IDs for a given time range
     * @param tv
     * @param campaignID
     * @param queueIDCol
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public HashMap getRefreshedRawMultipleQueuesTimeSeries(TrackingView tv, ID campaignID, Collection&lt;ID&gt; queueIDCol, Date start, Date end, Date lastCheck) throws BbmFinderException
    {
<span class="nc" id="L755">        methodStart(&quot;getRefreshedRawMultipleQueuesTimeSeries&quot;, tv, campaignID, queueIDCol, start, end);</span>
        try {
            // build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L758">            Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueIDCol, start, end);</span>
<span class="nc" id="L759">            TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L760">            HashMap queCubesMap = new HashMap(queueIDCol.size());</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">            for (int i=0; i&lt;metaCubes.length; i++) {</span>
<span class="nc" id="L762">                TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">                if (metaTC == null)</span>
<span class="nc" id="L764">                    continue;</span>
<span class="nc" id="L765">                ArrayList cubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc" id="L766">                short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">                if (metaTC instanceof ServiceGoalTraceCube) {</span>
                    // Get skill based info and media ID
<span class="nc" id="L769">                    Jdmo jdmo = new Jdmo();</span>
                    // Special handling for non-skillBased
<span class="nc" id="L771">                    HashSet nonSkillBasedSPSet = new HashSet();</span>
<span class="nc" id="L772">                    ArrayList nonSkillRangeSet = new ArrayList();</span>
<span class="nc" id="L773">                    String mediaDeID = null;</span>
<span class="nc" id="L774">                    ID mediaID = null;</span>
                    try {
<span class="nc" id="L776">                        String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE, D.SID from QUEUE A, SPQUEUE B, SP C, MEDIA D where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? and D.ID=A.MEDIAID order by C.FROMDATE asc&quot;;</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">                        for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L778">                            ID queueID = (ID)it.next();</span>
<span class="nc" id="L779">                            JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L780">                            jQuery1.setParID(1, queueID);</span>
<span class="nc" id="L781">                            jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L782">                            jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L783">                            JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">                            while (rs1.next()) {</span>
<span class="nc" id="L785">                                boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L786">                                mediaDeID = rs1.getString(2);</span>
<span class="nc" id="L787">                                mediaID = rs1.getID(6);</span>
<span class="nc bnc" id="L788" title="All 2 branches missed.">                                if (!skillBased) {</span>
<span class="nc" id="L789">                                    nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L790">                                    Date[] range = new Date[2];</span>
<span class="nc" id="L791">                                    range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L792">                                    range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L793">                                    nonSkillRangeSet.add(range);</span>
                                }
<span class="nc" id="L795">                            }</span>
<span class="nc" id="L796">                            rs1.close();</span>
<span class="nc" id="L797">                            jQuery1.close();</span>
<span class="nc" id="L798">                            TraceCube sgCube = null;</span>
                            Collection sgCol;
                            // check each queue's SG trace
<span class="nc bnc" id="L801" title="All 2 branches missed.">                            boolean hasChange = lastCheck == null;</span>
<span class="nc bnc" id="L802" title="All 4 branches missed.">                            if (!hasChange &amp;&amp; !nonSkillRangeSet.isEmpty()) {</span>
<span class="nc" id="L803">                                hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
                            }
<span class="nc bnc" id="L805" title="All 2 branches missed.">                            if (!hasChange) {</span>
<span class="nc" id="L806">                                hasChange = m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
                            }
<span class="nc bnc" id="L808" title="All 2 branches missed.">                            if (hasChange) {</span>
<span class="nc" id="L809">                                sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, queueID, start, end, null, false);</span>
<span class="nc bnc" id="L810" title="All 2 branches missed.">                                if (!nonSkillRangeSet.isEmpty()) {</span>
                                    //  non skill SG is direct load, check campaign media queue's SG trace
<span class="nc bnc" id="L812" title="All 2 branches missed.">                                    if (!sgCol.isEmpty()) {</span>
<span class="nc" id="L813">                                        sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(queueID, nonSkillBasedSPSet, mediaDeID, start, end, null, false, idToSPQueueMapping);</span>
                                    }
                                }
<span class="nc bnc" id="L816" title="All 4 branches missed.">                                if (!sgCol.isEmpty() || sgCube == null) {</span>
                                    // merge
<span class="nc bnc" id="L818" title="All 2 branches missed.">                                    if (sgCube == null) {</span>
                                        // simply create a new cube
<span class="nc" id="L820">                                        sgCube = metaTC.newInstance(queueID, start, end, types);</span>
                                    }
                                    // merge sgCol to sgCube
<span class="nc bnc" id="L823" title="All 2 branches missed.">                                    for (Iterator itChunk = sgCol.iterator(); itChunk.hasNext(); ) {</span>
<span class="nc" id="L824">                                        TraceChunk chunk = (TraceChunk)itChunk.next();</span>
<span class="nc" id="L825">                                        sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="nc" id="L826">                                    }</span>
                                }
                            }
<span class="nc" id="L829">                            cubeCol.add(sgCube);</span>
<span class="nc" id="L830">                        }</span>
                    } finally {
<span class="nc" id="L832">                        jdmo.cleanUp();</span>
<span class="nc" id="L833">                    }</span>
<span class="nc" id="L834">                } else {</span>
                    // dump for real queue
<span class="nc bnc" id="L836" title="All 2 branches missed.">                    for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L837">                        ID queueID = (ID)it.next();</span>
                        // for actual, we just fetch the changes
<span class="nc bnc" id="L839" title="All 2 branches missed.">                        if (metaTC instanceof ActualTraceCube) {</span>
                            // read from cache
<span class="nc bnc" id="L841" title="All 2 branches missed.">                            if (m_TimeSeriesCache != null) {</span>
<span class="nc" id="L842">                                cubeCol.add(TimeSeriesCacheUtil.readFromActualcache(m_TimeSeriesCache, queueID, start, end, lastCheck));</span>
                            } else {
                                // read from DB
<span class="nc" id="L845">                                cubeCol.add(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, lastCheck, idToSPQueueMapping));</span>
                            }
                        } else {
<span class="nc bnc" id="L848" title="All 4 branches missed.">                            if (lastCheck == null || m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
<span class="nc" id="L849">                                cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, null));</span>
                            }
                        }
<span class="nc" id="L852">                    }</span>
                }
                // final step add each queue's cube into map
<span class="nc bnc" id="L855" title="All 2 branches missed.">                for (Iterator it = cubeCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L856">                    TraceCube cube = (TraceCube)it.next();</span>
<span class="nc" id="L857">                    TraceCube[] realCubes = (TraceCube[])queCubesMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">                    if (realCubes == null) {</span>
<span class="nc" id="L859">                        realCubes = new TraceCube[metaCubes.length];</span>
                    }
<span class="nc" id="L861">                    realCubes[i] = cube;</span>
<span class="nc" id="L862">                    queCubesMap.put(cube.getQueueID(), realCubes);</span>
<span class="nc" id="L863">                }</span>
            }
            //need to do the computations here fo all trace cubes  second element = forcast &amp; third is predict
<span class="nc bnc" id="L866" title="All 2 branches missed.">            for (Iterator iterator = queCubesMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L867">                TraceCube[] queCubes = (TraceCube[]) iterator.next();</span>
<span class="nc" id="L868">                TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(queCubes);</span>
<span class="nc" id="L869">            }</span>
<span class="nc" id="L870">            return queCubesMap;</span>
<span class="nc" id="L871">        } catch(Exception e) {</span>
<span class="nc" id="L872">            handleException(e);</span>
<span class="nc" id="L873">            throw new BbmFinderException(e);</span>
        } finally {
<span class="nc" id="L875">            methodFinish();</span>
        }
    }

    /**
     * Return HashMap of TraceCube in a collection for given collection of Queue IDs for a given time range
     * @param tv
     * @param campaignID
     * @param nrQueID
     * @param queueIDCol
     * @param start
     * @param end
     * @param lastCheck
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public TraceCube[] getRefreshedRawNonRealQueueTimeSeries(TrackingView tv, ID campaignID, ID nrQueID, int qType, Collection queueIDCol, Date start, Date end, Date lastCheck) throws BbmFinderException
    {
<span class="nc" id="L894">        methodStart(&quot;getRefreshedRawNonRealQueueTimeSeries&quot;, tv, nrQueID, queueIDCol, start, end);</span>
        try {
<span class="nc" id="L896">            TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L897">            HashMap queueCubeMap = new HashMap(queueIDCol.size());</span>
<span class="nc" id="L898">            boolean ForecastChanged = false;</span>
<span class="nc bnc" id="L899" title="All 2 branches missed.">            for (int i=0; i&lt;metaCubes.length; i++) {</span>
<span class="nc" id="L900">                TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L901" title="All 2 branches missed.">                if (metaTC == null)</span>
<span class="nc" id="L902">                    continue;</span>
<span class="nc" id="L903">                ArrayList cubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc" id="L904">                short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">                if (metaTC instanceof ServiceGoalTraceCube) {</span>
                    // Get skill based info and media ID
<span class="nc" id="L907">                    Jdmo jdmo = new Jdmo();</span>
                    // Special handling for non-skillBased
<span class="nc" id="L909">                    HashSet nonSkillBasedSPSet = new HashSet();</span>
<span class="nc" id="L910">                    ArrayList nonSkillRangeSet = new ArrayList();</span>
<span class="nc" id="L911">                    String mediaDeID = null;</span>
<span class="nc" id="L912">                    ID mediaID = null;</span>
                    try {
<span class="nc" id="L914">                        String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE, D.SID from QUEUE A, SPQUEUE B, SP C, MEDIA D where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? and D.ID=A.MEDIAID order by C.FROMDATE asc&quot;;</span>
<span class="nc" id="L915">                        JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L916">                        jQuery1.setParID(1, nrQueID);</span>
<span class="nc" id="L917">                        jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L918">                        jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L919">                        JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L920" title="All 2 branches missed.">                        while (rs1.next()) {</span>
<span class="nc" id="L921">                            boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L922">                            mediaDeID = rs1.getString(2);</span>
<span class="nc" id="L923">                            mediaID = rs1.getID(6);</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">                            if (!skillBased) {</span>
<span class="nc" id="L925">                                nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L926">                                Date[] range = new Date[2];</span>
<span class="nc" id="L927">                                range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L928">                                range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L929">                                nonSkillRangeSet.add(range);</span>
                            }
<span class="nc" id="L931">                        }</span>
<span class="nc" id="L932">                        rs1.close();</span>
<span class="nc" id="L933">                        jQuery1.close();</span>
<span class="nc" id="L934">                        TraceCube sgCube = null;</span>
                        Collection sgCol;
                        // check each queue's SG trace
<span class="nc bnc" id="L937" title="All 2 branches missed.">                        boolean hasChange = lastCheck == null;</span>
<span class="nc bnc" id="L938" title="All 4 branches missed.">                        if (!hasChange &amp;&amp; !nonSkillRangeSet.isEmpty()) {</span>
<span class="nc" id="L939">                            hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
                        }
<span class="nc bnc" id="L941" title="All 2 branches missed.">                        if (!hasChange) {</span>
<span class="nc" id="L942">                            hasChange = m_timeSeriesAuditManager.hasChange(null, null, nrQueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
                        }
<span class="nc bnc" id="L944" title="All 2 branches missed.">                        if (hasChange) {</span>
<span class="nc" id="L945">                            sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, nrQueID, start, end, null, false);</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">                            if (!nonSkillRangeSet.isEmpty()) {</span>
                                //  non skill SG is direct load, check campaign media queue's SG trace
<span class="nc bnc" id="L948" title="All 2 branches missed.">                                if (!sgCol.isEmpty()) {</span>
<span class="nc" id="L949">                                    sgCube = TimeSeriesDAO.getSGTimeSeriesCubeFromLastUpdate(nrQueID, nonSkillBasedSPSet, mediaDeID, start, end, null, false, m_CampaignManager.getIDToSPQueueMapping(campaignID, nrQueID, start, end));</span>
                                }
                            }
<span class="nc bnc" id="L952" title="All 4 branches missed.">                            if (!sgCol.isEmpty() || sgCube == null) {</span>
                                // merge
<span class="nc bnc" id="L954" title="All 2 branches missed.">                                if (sgCube == null) {</span>
                                    // simply create a new cube
<span class="nc" id="L956">                                    sgCube = metaTC.newInstance(nrQueID, start, end, types);</span>
                                }
                                // merge sgCol to sgCube
<span class="nc bnc" id="L959" title="All 2 branches missed.">                                for (Iterator itChunk = sgCol.iterator(); itChunk.hasNext(); ) {</span>
<span class="nc" id="L960">                                    TraceChunk chunk = (TraceChunk)itChunk.next();</span>
<span class="nc" id="L961">                                    sgCube.setTraceValue(types, chunk.getTraceValues(types), chunk.getStartDate());</span>
<span class="nc" id="L962">                                }</span>
                            }
                        }
<span class="nc bnc" id="L965" title="All 2 branches missed.">                        if (sgCube != null)</span>
<span class="nc" id="L966">                            cubeCol.add(sgCube);</span>
                    } finally {
<span class="nc" id="L968">                        jdmo.cleanUp();</span>
<span class="nc" id="L969">                    }</span>
<span class="nc" id="L970">                } else {</span>
                    // dump for real queue
<span class="nc bnc" id="L972" title="All 4 branches missed.">                    if (metaTC instanceof ActualTraceCube &amp;&amp; !queueIDCol.isEmpty()) {</span>
                        // for actual, we just fetch the changes
                        // read from DB
<span class="nc" id="L975">                        cubeCol.addAll(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueIDCol, start, end, lastCheck));</span>
                    } else {
<span class="nc bnc" id="L977" title="All 2 branches missed.">                        if (qType == Queue.QUEUE_TYPE_VIRTUAL) {</span>
                            // virtual queue, direct load based on queueID for everything
<span class="nc bnc" id="L979" title="All 4 branches missed.">                            if (lastCheck == null || m_timeSeriesAuditManager.hasChange(null, null, nrQueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
<span class="nc" id="L980">                                cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, nrQueID, start, end, null, m_CampaignManager.getIDToSPQueueMapping(campaignID, nrQueID, start, end), null));</span>
                            }
                            // but for Predicted/Required, still may need load from Combined Media Phone
                        } else {
<span class="nc" id="L984">                            boolean hasChange = false;</span>
<span class="nc bnc" id="L985" title="All 2 branches missed.">                            for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L986">                                ID queueID = (ID)it.next();</span>
                                // for distributed queue, load each queue individually
<span class="nc bnc" id="L988" title="All 4 branches missed.">                                if (lastCheck == null || m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
<span class="nc" id="L989">                                    hasChange = true;</span>
                                }
<span class="nc" id="L991">                            }</span>
<span class="nc bnc" id="L992" title="All 2 branches missed.">                            if (hasChange) {</span>
<span class="nc bnc" id="L993" title="All 2 branches missed.">                                if (i==1) {</span>
<span class="nc" id="L994">                                    ForecastChanged = true;</span>
                                }
<span class="nc bnc" id="L996" title="All 2 branches missed.">                                for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L997">                                    ID queueID = (ID)it.next();</span>
<span class="nc" id="L998">                                    cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, m_CampaignManager.getIDToSPQueueMapping(campaignID, queueID, start, end), null));</span>

                                    /*TODO: Sameet: this needs to be changed here to accomdate
                                            Forcast, PredictedTimeseries and RequiredTimeseries for single queue in single campaign  scenario
                                            Check this for Virtual QUEUEs &amp; DQ
                                    */
<span class="nc" id="L1004">                                }</span>
<span class="nc bnc" id="L1005" title="All 4 branches missed.">                                if (i==2 &amp;&amp; !ForecastChanged) {</span>
                                    // if Predict is changed, Forecast not changed, need reload Forecast line for combination
<span class="nc" id="L1007">                                    ArrayList fctCubeCol = new ArrayList(queueIDCol.size());</span>
<span class="nc bnc" id="L1008" title="All 2 branches missed.">                                    for (Iterator it = queueIDCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1009">                                        ID queueID = (ID)it.next();</span>
<span class="nc" id="L1010">                                        fctCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(TraceUtil.META_FORECAST, queueID, start, end, null, m_CampaignManager.getIDToSPQueueMapping(campaignID, queueID, start, end), null));</span>
<span class="nc" id="L1011">                                    }</span>
<span class="nc bnc" id="L1012" title="All 2 branches missed.">                                    for (Iterator it = fctCubeCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1013">                                        TraceCube cube = (TraceCube)it.next();</span>
<span class="nc" id="L1014">                                        TraceCube[] realQueCubes = (TraceCube[])queueCubeMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">                                        if (realQueCubes == null) {</span>
<span class="nc" id="L1016">                                            realQueCubes = new TraceCube[5];</span>
                                        }
<span class="nc" id="L1018">                                        realQueCubes[i] = cube;</span>
<span class="nc" id="L1019">                                        queueCubeMap.put(cube.getQueueID(), realQueCubes);</span>
<span class="nc" id="L1020">                                    }</span>
                                }
                            }
                        }
                    }
                }
                // first save each real queue's information first
<span class="nc bnc" id="L1027" title="All 2 branches missed.">                if (cubeCol != null)</span>
                {
<span class="nc bnc" id="L1029" title="All 2 branches missed.">                    for (Iterator it = cubeCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1030">                        TraceCube cube = (TraceCube)it.next();</span>
<span class="nc" id="L1031">                        TraceCube[] realQueCubes = (TraceCube[])queueCubeMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1032" title="All 2 branches missed.">                        if (realQueCubes == null) {</span>
<span class="nc" id="L1033">                            realQueCubes = new TraceCube[5];</span>
                        }
<span class="nc" id="L1035">                        realQueCubes[i] = cube;</span>
<span class="nc" id="L1036">                        queueCubeMap.put(cube.getQueueID(), realQueCubes);</span>
<span class="nc" id="L1037">                    }</span>
                }
            }

<span class="nc" id="L1041">            TraceOperatorAdapter.combineCubeMap(queueCubeMap, metaCubes, true, nrQueID,true, WhatIfMode);</span>
            // need merge in Combined Staffing directly for VQ/DQ now
<span class="nc" id="L1043">            TraceCube[] nrQueCubes = (TraceCube[])queueCubeMap.get(nrQueID);</span>
<span class="nc bnc" id="L1044" title="All 4 branches missed.">            if (metaCubes[0] != null &amp;&amp; TraceUtil.containTraceType(metaCubes[0], Trace.STAFFING)) {</span>
                // need actual staffing inserted by Calc Engine.
<span class="nc" id="L1046">                Collection stfChunkCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_ACTUAL_STAFFING, nrQueID, start, end, lastCheck, false);</span>
<span class="nc bnc" id="L1047" title="All 2 branches missed.">                if (nrQueCubes[0] == null)</span>
<span class="nc" id="L1048">                    nrQueCubes[0] = metaCubes[0].newInstance(nrQueID, start, end, metaCubes[0].getTraceTypes());</span>
<span class="nc bnc" id="L1049" title="All 2 branches missed.">                for (Iterator it=stfChunkCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1050">                    TraceChunk tc = (TraceChunk)it.next();</span>
<span class="nc" id="L1051">                    nrQueCubes[0].setTraceValue(Trace.STAFFING, TraceUtil.roundDouble(tc.getTraceValue(Trace.STAFFING)), tc.getStartDate(), true);</span>
<span class="nc" id="L1052">                }</span>
            }
            //need to do the computations here fo all trace cubes
<span class="nc" id="L1055">            TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(nrQueCubes);</span>
<span class="nc" id="L1056">            return nrQueCubes;</span>
<span class="nc" id="L1057">        } catch(Exception e) {</span>
<span class="nc" id="L1058">            handleException(e);</span>
<span class="nc" id="L1059">            throw new BbmFinderException(e);</span>
        } finally {
<span class="nc" id="L1061">            methodFinish();</span>
        }
    }
    
    /**
     * Return TraceCubes for queues associated with the combined queue definition in a given time range
     * Combined queue ID is specified via CampaignID and MediaID combination.
     * We use a false default valude for isNoPhantom.
     * @param tv
     * @param campaignID
     * @param mediaID
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public HashMap getRefreshedRawCombinedQueuesTimeSeries(TrackingView tv, ID campaignID, ID mediaID, 
    		Date start, Date end, Date lastCheck) throws BbmFinderException {
<span class="nc" id="L1080">    	return getRefreshedRawCombinedQueuesTimeSeries(tv, campaignID, mediaID, </span>
        		start, end, lastCheck, false);
    }
    
    /**
     * Return TraceCubes for queues associated with the combined queue definition in a given time range
     * Combined queue ID is specified via CampaignID and MediaID combination
     * @param tv
     * @param campaignID
     * @param mediaID
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public HashMap getRefreshedRawCombinedQueuesTimeSeries(TrackingView tv, ID campaignID, ID mediaID, 
    		Date start, Date end, Date lastCheck, boolean isNoPhantom) throws BbmFinderException
    {
<span class="nc" id="L1099">        methodStart(&quot;getRefreshedRawCombinedQueuesTimeSeries&quot;, tv, campaignID, mediaID, start, end);</span>
        try {
<span class="nc" id="L1101">            Collection queueAssignment = m_CampaignManager.getCampaignQueueAssignments(campaignID, mediaID, start, end);</span>
<span class="nc bnc" id="L1102" title="All 2 branches missed.">            if (queueAssignment.isEmpty())</span>
<span class="nc" id="L1103">                return null;</span>
<span class="nc" id="L1104">            HashMap spQMap = new HashMap();</span>
<span class="nc" id="L1105">            HashMap spTimeRangeMap = new HashMap();</span>
<span class="nc" id="L1106">            HashMap spSkillMap = new HashMap();</span>
<span class="nc" id="L1107">            Date spStart = null;</span>
<span class="nc" id="L1108">            Date spEnd = null;</span>
<span class="nc" id="L1109">            Set&lt;ID&gt; queueSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">            for (Iterator it = queueAssignment.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1111">                CampaignQueue cq = (CampaignQueue)it.next();</span>
<span class="nc" id="L1112">                ID qID = cq.getQueueID();</span>
<span class="nc" id="L1113">                queueSet.add(qID);</span>
<span class="nc" id="L1114">                ID spID = cq.getSPID();</span>
<span class="nc" id="L1115">                ArrayList qCol = (ArrayList)spQMap.get(spID);</span>
<span class="nc bnc" id="L1116" title="All 2 branches missed.">                if (qCol == null)</span>
<span class="nc" id="L1117">                    qCol = new ArrayList();</span>
<span class="nc" id="L1118">                qCol.add(qID);</span>
<span class="nc" id="L1119">                spQMap.put(spID, qCol);</span>
<span class="nc" id="L1120">                Date[] timeRange = (Date[])spTimeRangeMap.get(spID);</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                if (timeRange == null) {</span>
<span class="nc bnc" id="L1122" title="All 4 branches missed.">                    if (spStart == null || spStart.after(cq.getStartTime()))</span>
<span class="nc" id="L1123">                        spStart = cq.getStartTime();</span>
<span class="nc bnc" id="L1124" title="All 4 branches missed.">                    if (spEnd == null || spEnd.before(cq.getEndTime()))</span>
<span class="nc" id="L1125">                        spEnd = cq.getEndTime();</span>
<span class="nc" id="L1126">                    timeRange = new Date[2];</span>
<span class="nc" id="L1127">                    timeRange[0] = cq.getStartTime();</span>
<span class="nc" id="L1128">                    timeRange[1] = cq.getEndTime();</span>
<span class="nc" id="L1129">                    spTimeRangeMap.put(spID, timeRange);</span>
                }
<span class="nc" id="L1131">            }</span>
            // Now go fetch SP skill based information
<span class="nc" id="L1133">            Collection spCol = m_CampaignManager.getSchedulingPeriods(campaignID, spStart, spEnd);</span>
<span class="nc bnc" id="L1134" title="All 2 branches missed.">            for (Iterator it = spCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1135">                SchedulingPeriod sp = (SchedulingPeriod)it.next();</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                spSkillMap.put(sp.getID(), sp.getSkillBased()?Boolean.TRUE:Boolean.FALSE);</span>
<span class="nc" id="L1137">            }</span>
            // build a table of SPQueues by SPQueue ID for all sps
<span class="nc" id="L1139">            Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueSet, start, end);</span>
<span class="nc" id="L1140">            TraceCube[] metaCubes = tv.getMetaTCForLoad(true);</span>
<span class="nc" id="L1141">            HashMap queCubesMap = new HashMap(queueSet.size());</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">            for (int i=0; i&lt;metaCubes.length; i++) {</span>
<span class="nc" id="L1143">                Collection cubeCol = new ArrayList();</span>
<span class="nc" id="L1144">                TraceCube metaTC = metaCubes[i];</span>
<span class="nc bnc" id="L1145" title="All 2 branches missed.">                if (metaCubes[i] == null)</span>
<span class="nc" id="L1146">                    continue;</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">                if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1148">                	cubeCol = getRefreshedRawCombinedQueuesTimeSeriesForSGTC(campaignID, mediaID,</span>
                			start, end, lastCheck, spQMap, spTimeRangeMap, spSkillMap, queueSet,
                			idToSPQueueMapping, cubeCol, metaTC);
                } else {
                    // load directly
<span class="nc bnc" id="L1153" title="All 2 branches missed.">                    for (Iterator qIt = queueSet.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1154">                        ID queueID = (ID)qIt.next();</span>
<span class="nc bnc" id="L1155" title="All 4 branches missed.">                        if (lastCheck != null &amp;&amp; !m_timeSeriesAuditManager.hasChange(null, null, queueID, TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
                            // no change for this queue, skip it
<span class="nc" id="L1157">                            qIt.remove();</span>
                        }
<span class="nc" id="L1159">                    }</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">                    if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1161">                        getRefreshedRawCombinedQueuesTimeSeriesForActualTC(</span>
								start, end, lastCheck, queueSet,
								idToSPQueueMapping, cubeCol, metaTC);
                    } else {
<span class="nc bnc" id="L1165" title="All 2 branches missed.">                        if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1166">                            getRefreshedRawCombinedQueuesTimeSeriesForPredictTC(</span>
									campaignID, mediaID, start, end, lastCheck,
									spQMap, queueSet, idToSPQueueMapping, i,
									cubeCol, metaTC, isNoPhantom);
                        } else {
<span class="nc" id="L1171">                            cubeCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, queueSet, spQMap, spTimeRangeMap, start, end, lastCheck, false, idToSPQueueMapping);</span>
                        }
                    }
                }
                // final step add each queue's cube into map
<span class="nc bnc" id="L1176" title="All 2 branches missed.">                for (Iterator it = cubeCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1177">                    TraceCube cube = (TraceCube)it.next();</span>
<span class="nc" id="L1178">                    TraceCube[] realCubes = (TraceCube[])queCubesMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1179" title="All 2 branches missed.">                    if (realCubes == null) {</span>
<span class="nc" id="L1180">                        realCubes = new TraceCube[metaCubes.length];</span>
                    }
<span class="nc" id="L1182">                    realCubes[i] = cube;</span>
<span class="nc" id="L1183">                    queCubesMap.put(cube.getQueueID(), realCubes);</span>
<span class="nc" id="L1184">                }</span>
            }
<span class="nc" id="L1186">            return queCubesMap;</span>
<span class="nc" id="L1187">        } catch(Exception e) {</span>
<span class="nc" id="L1188">            handleException(e);</span>
<span class="nc" id="L1189">            throw new BbmFinderException(e);</span>
        } finally {
<span class="nc" id="L1191">            methodFinish();</span>
        }
    }

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param spQMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param i
	 * @param cubeCol
	 * @param metaTC
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRefreshedRawCombinedQueuesTimeSeriesForPredictTC(
			ID campaignID, ID mediaID, Date start, Date end, Date lastCheck,
			HashMap spQMap, Set&lt;ID&gt; queueSet,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, int i, Collection cubeCol,
			TraceCube metaTC, boolean isNoPhantom) throws Exception, BbmTimeSeriesException {
		// predicted is direct load always
<span class="nc" id="L1216">		TraceCube cube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(TraceUtil.META_REPORT_PREDICT, campaignID, mediaID, spQMap.keySet(), </span>
				start, end, lastCheck, false, idToSPQueueMapping, isNoPhantom);
<span class="nc bnc" id="L1218" title="All 2 branches missed.">		if (cube != null) {</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">		    for (Iterator qIt = queueSet.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1220">		        ID qID = (ID)qIt.next();</span>
<span class="nc" id="L1221">		        TraceCube queCube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L1222" title="All 2 branches missed.">		        for (int j=0; i&lt;metaTC.getTraceTypes().length; j++) {</span>
<span class="nc" id="L1223">		            short type = metaTC.getTraceTypes()[j];</span>
<span class="nc" id="L1224">		            queCube.setTraceValue(type, cube.getTraceValueD(type), 0);</span>
		        }
<span class="nc" id="L1226">		        cubeCol.add(queCube);</span>
<span class="nc" id="L1227">		    }</span>
		}
<span class="nc" id="L1229">	}</span>

	/**
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param cubeCol
	 * @param metaTC
	 * @throws BbmTimeSeriesException
	 * @throws Exception
	 */
	private void getRefreshedRawCombinedQueuesTimeSeriesForActualTC(Date start,
			Date end, Date lastCheck, Set&lt;ID&gt; queueSet,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Collection cubeCol,
			TraceCube metaTC) throws BbmTimeSeriesException, Exception {
		// special handle actual, read from cache
<span class="nc bnc" id="L1247" title="All 2 branches missed.">		if (m_TimeSeriesCache != null) {</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">		    for (Iterator qIt = queueSet.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1249">		        ID queueID = (ID)qIt.next();</span>
<span class="nc" id="L1250">		        cubeCol.add(TimeSeriesCacheUtil.readFromActualcache(m_TimeSeriesCache, queueID, start, end, lastCheck));</span>
<span class="nc" id="L1251">		    }</span>
		} else {
<span class="nc bnc" id="L1253" title="All 2 branches missed.">		    for (Iterator qIt = queueSet.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1254">		        ID queueID = (ID)qIt.next();</span>
		        // read from DB
<span class="nc" id="L1256">		        cubeCol.add(TimeSeriesDAO.getActualTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, lastCheck, idToSPQueueMapping));</span>
<span class="nc" id="L1257">		    }</span>
		}
<span class="nc" id="L1259">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param lastCheck
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param spSkillMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param cubeCol
	 * @param metaTC
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private Collection getRefreshedRawCombinedQueuesTimeSeriesForSGTC(
			ID campaignID, ID mediaID, Date start, Date end, Date lastCheck,
			HashMap spQMap, HashMap spTimeRangeMap, HashMap spSkillMap,
			Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping,
			Collection cubeCol, TraceCube metaTC) throws BbmFinderException,
			RemoteException, Exception, BbmTimeSeriesException {
		// Require is always direct load for individual queue						|| metaTC instanceof RequireTraceCube) {
		                    // Require/ServiceGoal has timeseries for non-skill based combined queue, skill based sp need aggregation
		                    // split SPs by Skill based info
<span class="nc" id="L1289">		                    HashMap n_spQMap = new HashMap();</span>
<span class="nc" id="L1290">		                    HashMap n_spTimeRangeMap = new HashMap();</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">		                    for (Iterator spIT = spSkillMap.keySet().iterator(); spIT.hasNext(); ) {</span>
<span class="nc" id="L1292">		                        ID spID = (ID)spIT.next();</span>
<span class="nc" id="L1293">		                        Boolean skillBased = (Boolean)spSkillMap.get(spID);</span>
<span class="nc bnc" id="L1294" title="All 4 branches missed.">		                        if (skillBased == null || !skillBased.booleanValue()) {</span>
<span class="nc" id="L1295">		                            n_spQMap.put(spID, spQMap.get(spID));</span>
<span class="nc" id="L1296">		                            spQMap.remove(spID);</span>
<span class="nc" id="L1297">		                            n_spTimeRangeMap.put(spID, spTimeRangeMap.get(spID));</span>
<span class="nc" id="L1298">		                            spTimeRangeMap.remove(spID);</span>
		                        }
<span class="nc" id="L1300">		                    }</span>
		                    TraceCube combinedCube;
<span class="nc bnc" id="L1302" title="All 2 branches missed.">		                    boolean hasChange = lastCheck != null;</span>
<span class="nc bnc" id="L1303" title="All 6 branches missed.">		                    if (!hasChange &amp;&amp; !spQMap.isEmpty() &amp;&amp; metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1304">		                        HashSet qIDSet = new HashSet();</span>
<span class="nc bnc" id="L1305" title="All 2 branches missed.">		                        for (Iterator it = spQMap.keySet().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1306">		                            qIDSet.addAll((Collection)spQMap.get(it.next()));</span>
		                        }
<span class="nc bnc" id="L1308" title="All 2 branches missed.">		                        for (Iterator it = qIDSet.iterator(); it.hasNext(); ) {</span>
<span class="nc bnc" id="L1309" title="All 2 branches missed.">		                            if (m_timeSeriesAuditManager.hasChange(null, null, (ID)it.next(), TraceUtil.getAreaType(metaTC), start, end, lastCheck)) {</span>
<span class="nc" id="L1310">		                                hasChange = true;</span>
<span class="nc" id="L1311">		                                break;</span>
		                            }
		                        }
		                    }
<span class="nc bnc" id="L1315" title="All 2 branches missed.">		                    if (!hasChange) {</span>
		                        // check the campaign queue itself
<span class="nc" id="L1317">		                        hasChange = m_timeSeriesAuditManager.hasChange(campaignID, mediaID, null, TraceUtil.getAreaType(metaTC), start, end, lastCheck);</span>
		                    }
<span class="nc bnc" id="L1319" title="All 2 branches missed.">		                    if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1320">		                        m_cat.debug(&quot;In Campaign Queue mode, hasChange=&quot;+hasChange);</span>
		                    }
		                    // the timerange may cover skill/non-skill based so need add them all
		                    // Add non-skill based for service goal
<span class="nc" id="L1324">		                    HashMap queueTraceMap = new HashMap(queueSet.size());</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">		                    if (hasChange) {</span>
<span class="nc bnc" id="L1326" title="All 2 branches missed.">		                        if (!n_spQMap.isEmpty()) {</span>
		                            // direct load for required traces for non-skill based sps
<span class="nc" id="L1328">		                            combinedCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, n_spQMap.keySet(), start, end, null, false, idToSPQueueMapping, false);</span>
<span class="nc bnc" id="L1329" title="All 2 branches missed.">		                            for (Iterator qIt = queueSet.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1330">		                                ID qID = (ID)qIt.next();</span>
<span class="nc" id="L1331">		                                queueTraceMap.put(qID, metaTC.newInstance(qID, start, end, metaTC.getTraceTypes()));</span>
<span class="nc" id="L1332">		                            }</span>
<span class="nc" id="L1333">		                            short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">		                            for (Iterator spIt = n_spQMap.keySet().iterator(); spIt.hasNext(); ) {</span>
<span class="nc" id="L1335">		                                ID spID = (ID)spIt.next();</span>
<span class="nc" id="L1336">		                                Collection queueIDCol = (Collection)n_spQMap.get(spID);</span>
<span class="nc" id="L1337">		                                Date[] timeRange = (Date[])n_spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1338">		                                Date pStart = new Date(timeRange[0].getTime());</span>
		                                do {
<span class="nc bnc" id="L1340" title="All 4 branches missed.">		                                    if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc" id="L1341">		                                    	double[] value = combinedCube.getTraceValueD(types, pStart);</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">		                                        for (Iterator qIt = queueIDCol.iterator(); qIt.hasNext(); ) {</span>
<span class="nc" id="L1343">		                                            ID qID = (ID)qIt.next();</span>
<span class="nc" id="L1344">		                                            TraceCube cube = (TraceCube)queueTraceMap.get(qID);</span>
<span class="nc bnc" id="L1345" title="All 2 branches missed.">		                                            if (cube == null)</span>
<span class="nc" id="L1346">		                                                cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
<span class="nc" id="L1347">		                                            cube.setTraceValue(types, value, pStart);</span>
<span class="nc" id="L1348">		                                        }</span>
		                                    }
<span class="nc" id="L1350">		                                    pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">		                                } while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1352">		                            }</span>
<span class="nc" id="L1353">		                            cubeCol = queueTraceMap.values();</span>
		                        }
		                        // Add skill based combined result
<span class="nc bnc" id="L1356" title="All 2 branches missed.">		                        if (!spQMap.isEmpty()) {</span>
		                            // combine for service goal
<span class="nc" id="L1358">		                            Collection cubesCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap, start, end, null, false, idToSPQueueMapping);</span>
<span class="nc bnc" id="L1359" title="All 2 branches missed.">		                            if (cubeCol != null) {</span>
		                                // merge skCube into existing cube, based on SPTimeRange
<span class="nc" id="L1361">		                                short[] sgtypes = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L1362" title="All 2 branches missed.">		                                for (Iterator spIt = spQMap.keySet().iterator(); spIt.hasNext(); ) {</span>
<span class="nc" id="L1363">		                                    ID spID = (ID)spIt.next();</span>
<span class="nc" id="L1364">		                                    Date[] timeRange = (Date[])spTimeRangeMap.get(spID);</span>
<span class="nc" id="L1365">		                                    Date pStart = new Date(timeRange[0].getTime());</span>
		                                    do {
<span class="nc bnc" id="L1367" title="All 4 branches missed.">		                                        if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="nc bnc" id="L1368" title="All 2 branches missed.">		                                            for (Iterator cubeIt = cubesCol.iterator(); cubeIt.hasNext(); ) {</span>
<span class="nc" id="L1369">		                                                TraceCube cube = (TraceCube)cubeIt.next();</span>
<span class="nc" id="L1370">		                                                TraceCube exCube = (TraceCube)queueTraceMap.get(cube.getQueueID());</span>
<span class="nc bnc" id="L1371" title="All 2 branches missed.">		                                                if (exCube == null) {</span>
<span class="nc" id="L1372">		                                                    exCube = cube;</span>
<span class="nc" id="L1373">		                                                    cubeIt.remove();</span>
		                                                } else {
<span class="nc" id="L1375">		                                                    exCube.setTraceValue(sgtypes, cube.getTraceValueD(sgtypes, pStart), pStart);</span>
		                                                }
<span class="nc" id="L1377">		                                                queueTraceMap.put(cube.getQueueID(), exCube);</span>
<span class="nc" id="L1378">		                                            }</span>
		                                        }
<span class="nc" id="L1380">		                                        pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1381" title="All 2 branches missed.">		                                    } while (pStart.before(timeRange[1]));</span>
<span class="nc" id="L1382">		                                }</span>
<span class="nc" id="L1383">		                                cubeCol = queueTraceMap.values();</span>
<span class="nc" id="L1384">		                            } else {</span>
<span class="nc" id="L1385">		                                cubeCol = cubesCol;</span>
		                            }
		                        }
		                    }
<span class="nc" id="L1389">		return cubeCol;</span>
	}

    /**
     * Calls getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end, boolean includeAllServiceGoalTypes, needAllValid)
     * with
     * &lt;ol&gt;
     * &lt;li&gt; includeAllServiceGoalTypes set to false as the default behavior.  This means that if a service goals trace cube is expected, it will
     * only return data for the selected service goal type even if data for multiple types exists.&lt;/li&gt;
     * &lt;li&gt; needAllValid is set to true as the default behavior.
     * This is applicable to virtual queues only and means that it will combine only valid values for Virtual queues&lt;/li&gt;
     * &lt;/ol&gt;
     */
    public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end) throws BbmFinderException
    {
<span class="fc" id="L1404">        return getRawCombinedQueuesTimeSeries(metaTC, campaignID, mediaID, start, end, false);</span>
    }
    
    /**
     * Calls getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end, 
     * boolean includeAllServiceGoalTypes, boolean isNoPhantom)
     * with
     * includeAllServiceGoalTypes, false
     */
    public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end, 
    		boolean includeAllServiceGoalTypes) throws BbmFinderException  {
<span class="fc" id="L1415">        return getRawCombinedQueuesTimeSeries(metaTC, campaignID, mediaID, start, end, includeAllServiceGoalTypes, false);</span>
    }

    /**
     * Checks to see if a non-resolution queue exists in the passed CampaignQueue collection.
     * @param mediaID - We only bother checking if media is null, representing the Combined-All Media queue.
     * @param queueAssignment - Collection of CampaignQueue objects.
     * @param queMap - Map of Id to Queue.
     * @return true if a non-resolution queue exists, false otherwise.
     */
    private boolean hasNonResolutionMediaInCombinedAll(ID mediaID, Collection&lt;CampaignQueue&gt; queueAssignment, 
    		Map&lt;ID, Queue&gt; queMap)
    {
<span class="pc bpc" id="L1428" title="3 of 8 branches missed.">        if (mediaID==null &amp;&amp; queueAssignment != null &amp;&amp; queueAssignment.size()&gt;0 &amp;&amp;</span>
<span class="pc bpc" id="L1429" title="1 of 2 branches missed.">        		queMap != null &amp;&amp; queMap.size()&gt;0)</span>
        {
<span class="pc bpc" id="L1431" title="1 of 2 branches missed.">            for (CampaignQueue cq : queueAssignment) {</span>
<span class="fc" id="L1432">                ID qID = cq.getQueueID();</span>
<span class="fc" id="L1433">                Queue queue = queMap.get(qID);</span>
<span class="pc bpc" id="L1434" title="1 of 2 branches missed.">                if (!Media.MEDIA_ID_RESOLUTION.equals(queue.getMediaID())){</span>
<span class="fc" id="L1435">                	return true;</span>
                }
<span class="nc" id="L1437">            }</span>
        }
<span class="fc" id="L1439">        return false;</span>
    }
    
    /**
     * Return TraceCubes for queues associated with the combined queue definition in a given time range
     * Combined queue ID is specified via CampaignID and MediaID combination
     * @param metaTC
     * @param campaignID
     * @param mediaID
     * @param start
     * @param end
     * @param includeAllServiceGoalTypes
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level, 
	 * ASA, and Dials for the same queue(s) being requested. 
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public Collection&lt;TraceCube&gt; getRawCombinedQueuesTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end, 
    		boolean includeAllServiceGoalTypes, boolean isNoPhantom) throws BbmFinderException
    {
<span class="fc" id="L1460">        methodStart(&quot;getRawCombinedQueuesTimeSeries&quot;, metaTC, campaignID, mediaID, start, end);</span>
        try {
<span class="fc" id="L1462">            WorkloadManager m_WorkloadManager = WfmManagerFactory.getWorkloadManager();</span>
<span class="fc" id="L1463">            Collection&lt;CampaignQueue&gt; queueAssignment = m_CampaignManager.getCampaignQueueAssignments(campaignID, mediaID, start, end);</span>
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">            if (queueAssignment.isEmpty()) {</span>
<span class="nc" id="L1465">                return null;</span>
            }
<span class="fc" id="L1467">            short[] types = metaTC.getTraceTypes();</span>
<span class="fc" id="L1468">            Collection cubeCol = new ArrayList();</span>
<span class="fc" id="L1469">            HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap = new HashMap&lt;ID, List&lt;ID&gt;&gt;();</span>
<span class="fc" id="L1470">            HashMap&lt;ID, Date[]&gt; spTimeRangeMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="fc" id="L1471">            Map&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc" id="L1472">            Date spStart = null;</span>
<span class="fc" id="L1473">            Date spEnd = null;</span>
<span class="fc" id="L1474">            Set&lt;ID&gt; queueSet = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L1475">            Set queueIDSet = ValueObjectUtil.extractFieldSet(CampaignQueueFieldInfo.CAMPAIGNQUEUE_QUEUEID,queueAssignment);</span>
<span class="fc" id="L1476">            Map&lt;ID, Queue&gt; queMap = ValueObjectUtil.getIDObjectMap(m_WorkloadManager.getQueuesByIDs(queueIDSet));</span>
            
<span class="fc" id="L1478">            boolean bHasNonResolutionMedia = hasNonResolutionMediaInCombinedAll(mediaID, queueAssignment, queMap);</span>
<span class="fc bfc" id="L1479" title="All 2 branches covered.">            for (CampaignQueue cq : queueAssignment) {</span>
<span class="fc" id="L1480">                ID qID = cq.getQueueID();</span>
                //QC 90268 ; When rolling up &quot;Combined - All Media&quot;, do not include Resolution queues if there are other medias
<span class="fc" id="L1482">                Queue queue = queMap.get(qID);</span>
<span class="pc bpc" id="L1483" title="3 of 6 branches missed.">                if (mediaID == null &amp;&amp; Media.MEDIA_ID_RESOLUTION.equals(queue.getMediaID()) &amp;&amp; bHasNonResolutionMedia){</span>
<span class="nc" id="L1484">                    continue;</span>
                }
<span class="fc" id="L1486">                queueSet.add(qID);</span>
<span class="fc" id="L1487">                ID spID = cq.getSPID();</span>
<span class="fc" id="L1488">                List&lt;ID&gt; qCol = spQMap.get(spID);</span>
<span class="fc bfc" id="L1489" title="All 2 branches covered.">                if (qCol == null)</span>
<span class="fc" id="L1490">                    qCol = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L1491">                qCol.add(qID);</span>
<span class="fc" id="L1492">                spQMap.put(spID, qCol);</span>
<span class="fc" id="L1493">                Date[] timeRange = spTimeRangeMap.get(spID);</span>
<span class="fc bfc" id="L1494" title="All 2 branches covered.">                if (timeRange == null) {</span>
<span class="pc bpc" id="L1495" title="3 of 4 branches missed.">                    if (spStart == null || spStart.after(cq.getStartTime()))</span>
<span class="fc" id="L1496">                        spStart = cq.getStartTime();</span>
<span class="pc bpc" id="L1497" title="3 of 4 branches missed.">                    if (spEnd == null || spEnd.before(cq.getEndTime()))</span>
<span class="fc" id="L1498">                        spEnd = cq.getEndTime();</span>
<span class="fc" id="L1499">                    timeRange = new Date[2];</span>
<span class="fc" id="L1500">                    timeRange[0] = cq.getStartTime();</span>
<span class="fc" id="L1501">                    timeRange[1] = cq.getEndTime();</span>
<span class="fc" id="L1502">                    spTimeRangeMap.put(spID, timeRange);</span>
                }
<span class="fc" id="L1504">            }</span>
            // Now go fetch SP skill based information
<span class="fc" id="L1506">            Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriods(campaignID, spStart, spEnd);</span>
<span class="fc bfc" id="L1507" title="All 2 branches covered.">            for (SchedulingPeriod sp : spCol) {</span>
<span class="fc bfc" id="L1508" title="All 2 branches covered.">                spSkillMap.put(sp.getID(), sp.getSkillBased()?Boolean.TRUE:Boolean.FALSE);</span>
<span class="fc" id="L1509">            }</span>
            // build a table of SPQueues by SPQueue ID for all sps
<span class="fc" id="L1511">            Map&lt;ID, SPQueue&gt; idToSPQueueMapping = m_CampaignManager.getIDToSPQueueMapping(campaignID, queueSet, start, end);</span>
<span class="fc bfc" id="L1512" title="All 4 branches covered.">            if (metaTC instanceof ServiceGoalTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L1513">                cubeCol = getRawCombinedQueuesTimeSeriesForRequiredTC(metaTC,</span>
						campaignID, mediaID, start, end,
						includeAllServiceGoalTypes, types, cubeCol, spQMap,
						spTimeRangeMap, spSkillMap, queueSet,
						idToSPQueueMapping);
            } else {
<span class="fc" id="L1519">                boolean hasDistributedQueue = false;</span>
                Queue queue;
<span class="fc" id="L1521">                Collection&lt;Queue&gt; qs = new ArrayList&lt;Queue&gt;(queueSet.size());</span>
<span class="fc bfc" id="L1522" title="All 2 branches covered.">                for (ID qID : queueSet) {</span>
<span class="fc" id="L1523">                	queue = queMap.get(qID);</span>
<span class="pc bpc" id="L1524" title="1 of 4 branches missed.">                	if (queue != null &amp;&amp; queue.getQueueType() == Queue.QUEUE_TYPE_DISTRIBUTED) {</span>
<span class="fc" id="L1525">                		 hasDistributedQueue = true;</span>
                	}
<span class="fc" id="L1527">                	qs.add(queue);</span>
<span class="fc" id="L1528">                }</span>
                // load directly
<span class="fc bfc" id="L1530" title="All 2 branches covered.">                if (metaTC instanceof PredictTraceCube) {</span>
<span class="fc" id="L1531">                    getRawCombinedQueuesTimeSeriesForPredictTC(metaTC,</span>
							campaignID, mediaID, start, end, cubeCol, spQMap,
							queueSet, idToSPQueueMapping, hasDistributedQueue, isNoPhantom);
<span class="pc bpc" id="L1534" title="1 of 2 branches missed.">                } else if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1535">                    getRawCombinedQueuesTimeSeriesForActualTC(metaTC, start,</span>
							end, cubeCol, spQMap, spTimeRangeMap,
							idToSPQueueMapping, qs);

                } else {
<span class="fc" id="L1540">                    cubeCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap, start, end, null, false, idToSPQueueMapping);</span>
                }
            }
<span class="fc" id="L1543">            return new ArrayList(cubeCol);</span>
<span class="nc" id="L1544">        } catch(Exception e) {</span>
<span class="nc" id="L1545">            handleException(e);</span>
<span class="nc" id="L1546">            throw new BbmFinderException(e);</span>
        } finally {
<span class="pc" id="L1548">            methodFinish();</span>
        }
    }

	/**
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param cubeCol
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param idToSPQueueMapping
	 * @param qs
	 * @throws BbmFinderException
	 * @throws RemoteException
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private void getRawCombinedQueuesTimeSeriesForActualTC(TraceCube metaTC,
			Date start, Date end, Collection cubeCol,
			HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap, HashMap&lt;ID, Date[]&gt; spTimeRangeMap,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, Collection&lt;Queue&gt; qs)
			throws BbmFinderException, RemoteException, Exception,
			BbmTimeSeriesException {
		//	load virtual queue's sub queue's actual and then combine since virtual queue itself doesn't have actual trace data.
<span class="nc" id="L1573">		HashSet qIDSet = new HashSet();</span>
<span class="nc" id="L1574">		Map&lt;ID, Queue&gt; idToQueueMap = ValueObjectUtil.getIDObjectMap(qs);</span>
<span class="nc bnc" id="L1575" title="All 2 branches missed.">		for (Queue q : qs) {</span>
<span class="nc bnc" id="L1576" title="All 2 branches missed.">		    if (q.getQueueType() == Queue.QUEUE_TYPE_VIRTUAL) {</span>
<span class="nc" id="L1577">		        Collection&lt;ID&gt; subIDs = m_workloadManager.getSubQueues(Collections.singletonList(q.getID()));</span>
		        //virtual queue, load subs.
<span class="nc" id="L1579">		        Collection&lt;TraceCube&gt; subCubeCol = new ArrayList();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">		        for (ID queueID : subIDs) {</span>
<span class="nc" id="L1581">		            subCubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, idToQueueMap));</span>
<span class="nc" id="L1582">		        }</span>
<span class="nc bnc" id="L1583" title="All 2 branches missed.">		        if (!subCubeCol.isEmpty()) {</span>
		            //for virtual queue, the actual will be read from children and combined, then return
<span class="nc" id="L1585">		            TraceCube cmbCube = TraceOperatorAdapter.combineQueue(subCubeCol, true, WhatIfMode);</span>
<span class="nc" id="L1586">		            cmbCube.setQueueID(q.getID());</span>
<span class="nc" id="L1587">		            cubeCol.add(cmbCube);</span>
<span class="nc" id="L1588">		        } else {</span>
		            //return empty actual cube
<span class="nc" id="L1590">		            cubeCol.add(metaTC.newInstance(q.getID(), start, end, metaTC.getTraceTypes()));</span>
		        }
<span class="nc" id="L1592">		    } else {</span>
		        //all type of queues should be loaded in combine mode later.
<span class="nc" id="L1594">		        qIDSet.add(q.getID());</span>
		    }
<span class="nc" id="L1596">		}</span>
<span class="nc bnc" id="L1597" title="All 2 branches missed.">		if (!qIDSet.isEmpty())</span>
		    //load combine directly for non-virtual queues.
<span class="nc" id="L1599">		    cubeCol.addAll(TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, qIDSet, spQMap, spTimeRangeMap, start, end, null, false, idToSPQueueMapping));</span>
<span class="nc" id="L1600">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param cubeCol
	 * @param spQMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @param hasDistributedQueue
	 * @throws Exception
	 */
	private void getRawCombinedQueuesTimeSeriesForPredictTC(TraceCube metaTC,
			ID campaignID, ID mediaID, Date start, Date end,
			Collection cubeCol, HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap, Set&lt;ID&gt; queueSet,
			Map&lt;ID, SPQueue&gt; idToSPQueueMapping, boolean hasDistributedQueue, boolean isNoPhantom)
			throws Exception {
		//predict need to be load separately for all the children, since it is need for combine purpose.
<span class="fc bfc" id="L1621" title="All 2 branches covered.">		for (ID queueID : queueSet) {</span>
<span class="fc" id="L1622">		    cubeCol.add(TimeSeriesDAO.getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, null, idToSPQueueMapping, null, isNoPhantom));</span>
<span class="fc" id="L1623">		}</span>
<span class="pc bpc" id="L1624" title="1 of 2 branches missed.">		if (!hasDistributedQueue) {</span>
		    // predicted is direct load always
<span class="fc" id="L1626">		    TraceCube cube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, spQMap.keySet(), </span>
		    		start, end,	null, false, idToSPQueueMapping, isNoPhantom);
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">		    if (cube != null) {</span>
		    	// assign combined queue -1 ID
<span class="fc" id="L1630">		        cube.setQueueID(comQueID);</span>
<span class="fc" id="L1631">		        cubeCol.add(cube);</span>
		    }
		}
<span class="fc" id="L1634">	}</span>

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param types
	 * @param cubeCol
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param spSkillMap
	 * @param queueSet
	 * @param idToSPQueueMapping
	 * @return
	 * @throws Exception
	 * @throws BbmTimeSeriesException
	 */
	private Collection getRawCombinedQueuesTimeSeriesForRequiredTC(
			TraceCube metaTC, ID campaignID, ID mediaID, Date start, Date end,
			boolean includeAllServiceGoalTypes, short[] types,
			Collection cubeCol, HashMap&lt;ID, List&lt;ID&gt;&gt; spQMap,
			HashMap&lt;ID, Date[]&gt; spTimeRangeMap, Map&lt;ID, Boolean&gt; spSkillMap,
			Set&lt;ID&gt; queueSet, Map&lt;ID, SPQueue&gt; idToSPQueueMapping)
			throws Exception, BbmTimeSeriesException {
		// Require/ServiceGoal has timeseries for non-skill based combined queue, skill based sp need aggregation
		// split SPs by Skill based info
<span class="fc" id="L1663">		Map&lt;ID, List&lt;ID&gt;&gt; n_spQMap = new HashMap&lt;ID, List&lt;ID&gt;&gt;();</span>
<span class="fc" id="L1664">		Map&lt;ID, Date[]&gt; n_spTimeRangeMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="fc bfc" id="L1665" title="All 2 branches covered.">		for (Iterator&lt;Map.Entry&lt;ID, List&lt;ID&gt;&gt;&gt; i = spQMap.entrySet().iterator(); i.hasNext();) {</span>
<span class="fc" id="L1666">			ID spID = i.next().getKey();</span>
<span class="fc" id="L1667">		    Boolean skillBased = spSkillMap.get(spID);</span>
<span class="pc bpc" id="L1668" title="1 of 4 branches missed.">		    if (skillBased == null || !skillBased.booleanValue()) {</span>
<span class="fc" id="L1669">		        n_spQMap.put(spID, spQMap.get(spID));</span>
<span class="fc" id="L1670">		        i.remove();</span>
<span class="fc" id="L1671">		        n_spTimeRangeMap.put(spID, spTimeRangeMap.get(spID));</span>
<span class="fc" id="L1672">		        spTimeRangeMap.remove(spID);</span>
		    }
<span class="fc" id="L1674">		}</span>
		TraceCube combinedCube;
		// the timerange may cover skill/non-skill based so need add them all
		// Add non-skill based for service goal
<span class="fc" id="L1678">		Map&lt;ID, TraceCube&gt; queueTraceMap = new HashMap&lt;ID, TraceCube&gt;(queueSet.size());</span>
<span class="fc bfc" id="L1679" title="All 2 branches covered.">		if (!n_spQMap.isEmpty()) {</span>
		    // direct load for required traces for non-skill based sps
<span class="fc" id="L1681">		    combinedCube = TimeSeriesDAO.getCombinedQueueTimeSeriesCubeFromLastUpdate(metaTC, campaignID, mediaID, n_spQMap.keySet(), start, end, null, includeAllServiceGoalTypes, idToSPQueueMapping, false);</span>
<span class="fc bfc" id="L1682" title="All 2 branches covered.">		    if (metaTC instanceof RequireTraceCube) {</span>
<span class="fc" id="L1683">		        combinedCube.setQueueID(comQueID);</span>
<span class="fc" id="L1684">		        queueTraceMap.put(comQueID, combinedCube);</span>
		    } else {
<span class="fc bfc" id="L1686" title="All 2 branches covered.">		        for (ID qID : queueSet) {</span>
<span class="fc" id="L1687">		            queueTraceMap.put(qID, metaTC.newInstance(qID, start, end, metaTC.getTraceTypes()));</span>
<span class="fc" id="L1688">		        }</span>
		    }
<span class="fc bfc" id="L1690" title="All 2 branches covered.">		    for (Iterator spIt = n_spQMap.keySet().iterator(); spIt.hasNext(); ) {</span>
<span class="fc" id="L1691">		        ID spID = (ID)spIt.next();</span>
<span class="fc" id="L1692">		        Collection&lt;ID&gt; queueIDCol = n_spQMap.get(spID);</span>
<span class="fc" id="L1693">		        Date[] timeRange = n_spTimeRangeMap.get(spID);</span>
<span class="fc" id="L1694">		        Date pStart = new Date(timeRange[0].getTime());</span>
		        do {
<span class="fc bfc" id="L1696" title="All 4 branches covered.">		            if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="fc" id="L1697">		            	double[] value = combinedCube.getTraceValueD(types, pStart);</span>
<span class="fc bfc" id="L1698" title="All 2 branches covered.">		                for (Iterator qIt = queueIDCol.iterator(); qIt.hasNext(); ) {</span>
<span class="fc" id="L1699">		                    ID qID = (ID)qIt.next();</span>
<span class="fc" id="L1700">		                    TraceCube cube = queueTraceMap.get(qID);</span>
<span class="fc bfc" id="L1701" title="All 2 branches covered.">		                    if (cube == null)</span>
<span class="fc" id="L1702">		                        cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
<span class="fc" id="L1703">		                    cube.setTraceValue(types, value, pStart);</span>
<span class="fc" id="L1704">		                }</span>
		            }
<span class="fc" id="L1706">		            pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="fc bfc" id="L1707" title="All 2 branches covered.">		        } while (pStart.before(timeRange[1]));</span>
<span class="fc" id="L1708">		    }</span>
<span class="fc" id="L1709">		    cubeCol = queueTraceMap.values();</span>
		}
		// Add skill based combined result
<span class="fc bfc" id="L1712" title="All 2 branches covered.">		if (!spQMap.isEmpty()) {</span>
		    // combine for service goal
<span class="fc" id="L1714">		    Collection&lt;TraceCube&gt; cubesCol = TimeSeriesDAO.getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, spQMap, spTimeRangeMap, start, end, null, includeAllServiceGoalTypes, idToSPQueueMapping);</span>
<span class="pc bpc" id="L1715" title="1 of 2 branches missed.">		    if (cubeCol != null) {</span>
		        // merge skCube into existing cube, based on SPTimeRange
<span class="fc" id="L1717">		        short[] sgtypes = metaTC.getTraceTypes();</span>
<span class="fc bfc" id="L1718" title="All 2 branches covered.">		        for (ID spID : spQMap.keySet()) {</span>
<span class="fc" id="L1719">		            Date[] timeRange = spTimeRangeMap.get(spID);</span>
<span class="fc" id="L1720">		            Date pStart = new Date(timeRange[0].getTime());</span>
		            do {
<span class="pc bpc" id="L1722" title="2 of 4 branches missed.">		                if (!pStart.before(start) &amp;&amp; !pStart.after(end)) {</span>
<span class="fc bfc" id="L1723" title="All 2 branches covered.">		                    for (Iterator&lt;TraceCube&gt; cubeIt = cubesCol.iterator(); cubeIt.hasNext(); ) {</span>
<span class="fc" id="L1724">		                        TraceCube cube = cubeIt.next();</span>
<span class="fc" id="L1725">		                        TraceCube exCube = queueTraceMap.get(cube.getQueueID());</span>
<span class="pc bpc" id="L1726" title="1 of 2 branches missed.">		                        if (exCube == null) {</span>
<span class="fc" id="L1727">		                            exCube = cube;</span>
<span class="fc" id="L1728">		                            cubeIt.remove();</span>
		                        } else {
<span class="nc" id="L1730">		                            exCube.setTraceValue(sgtypes, cube.getTraceValueD(sgtypes, pStart), pStart);</span>
		                        }
<span class="fc" id="L1732">		                        queueTraceMap.put(cube.getQueueID(), exCube);</span>
<span class="fc" id="L1733">		                    }</span>
		                }
<span class="fc" id="L1735">		                pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="fc bfc" id="L1736" title="All 2 branches covered.">		            } while (pStart.before(timeRange[1]));</span>
<span class="fc" id="L1737">		        }</span>
<span class="fc" id="L1738">		        cubeCol = queueTraceMap.values();</span>
<span class="fc" id="L1739">		    } else {</span>
<span class="nc" id="L1740">		        cubeCol = cubesCol;</span>
		    }
		}
<span class="fc" id="L1743">		return cubeCol;</span>
	}

    /**
     * Return collection of CombinedQueueStaffing objects
     * @param campaignID
     * @param mediaID
     * @param spIDSet
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     */
    public Collection getCombinedQueueStaffing(ID campaignID, ID mediaID, Set spIDSet, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L1757">        methodStart(&quot;getCombinedQueueStaffing&quot;, campaignID, start, end);</span>
        try {
<span class="nc" id="L1759">            return TimeSeriesDAO.getCombinedQueueStaffing(campaignID, mediaID, spIDSet, start, end);</span>
<span class="nc" id="L1760">        } catch(JdmoException e) {</span>
<span class="nc" id="L1761">            handleException(e, false);</span>
<span class="nc" id="L1762">            throw new BbmFinderException(e);</span>
        } finally {
<span class="nc" id="L1764">            methodFinish();</span>
        }
    }

	public ID saveReForecast(ID spID, Map&lt;ID, TraceCube&gt; traces, String description, Date creationDate) throws BbmCreateException {
<span class="nc" id="L1769">		boolean forecastProfileIsModified = true;</span>

<span class="nc" id="L1771">		String username = m_sessionContext.getCallerPrincipal().getName();</span>

<span class="nc" id="L1773">		ForecastProfileDAO forecastProfileDAO = new ForecastProfileDAO();</span>
<span class="nc" id="L1774">		ForecastInstance forecastInstance = new ForecastInstance();</span>
		try {
			// Create a new forecast instance

<span class="nc" id="L1778">			forecastInstance.setSpId(spID);</span>
<span class="nc" id="L1779">			forecastInstance.setDescription(description);</span>
<span class="nc" id="L1780">			forecastInstance.setIsBase(false);</span>
<span class="nc" id="L1781">			forecastInstance.setCreated(creationDate);</span>
<span class="nc" id="L1782">			forecastInstance.setCreatedBy(username);</span>
<span class="nc" id="L1783">			forecastInstance.setID(ForecastInstanceDAO.createForecastInstance(forecastInstance));</span>

			// Get the campaign time zone
<span class="nc" id="L1786">			TimeZone campaignTimeZone = CampaignDAO.getTimeZoneBySPID(spID);</span>
<span class="nc" id="L1787">			Calendar cal = Calendar.getInstance(campaignTimeZone);</span>

			// Iterate over the map of queueIDs and trace cubes
<span class="nc bnc" id="L1790" title="All 2 branches missed.">			for (ID queueID : traces.keySet()) {</span>
<span class="nc" id="L1791">				TraceCube traceCube = traces.get(queueID);</span>

				// Find the SPQueueID that corresponds with the current queueID and spID
<span class="nc" id="L1794">				ID spQueueID = SPQueueDAO.getSPQueueID(spID, queueID);</span>

				// Create a new forecast profile, and set it to point to the new
				// forecast instance
<span class="nc" id="L1798">				ForecastProfile forecastProfile = new ForecastProfile();</span>
<span class="nc" id="L1799">				forecastProfile.setSPQueueID(spQueueID);</span>
<span class="nc" id="L1800">				forecastProfile.setForecastInstanceID(forecastInstance.getID());</span>
<span class="nc" id="L1801">				forecastProfile.setIsModified(forecastProfileIsModified);</span>
<span class="nc" id="L1802">				forecastProfile.setCreatedDate(creationDate);</span>
<span class="nc" id="L1803">				forecastProfile.setCreatedBy(username);</span>
<span class="nc" id="L1804">				forecastProfileDAO.createObject(forecastProfile);</span>

				int numOfDaysInCube;
<span class="nc" id="L1807">				int traceCubeMaxLength = traceCube.getMaximumLength(new short[]{TraceCube.CV, TraceCube.AHT});</span>

<span class="nc bnc" id="L1809" title="All 2 branches missed.">				if (traceCubeMaxLength % BUCKETS_IN_DAY == 0) {</span>
<span class="nc" id="L1810">					numOfDaysInCube = traceCubeMaxLength / BUCKETS_IN_DAY;</span>
				} else {
<span class="nc" id="L1812">					numOfDaysInCube = traceCubeMaxLength / BUCKETS_IN_DAY + 1;</span>
				}

<span class="nc" id="L1815">				cal.setTime(traceCube.getRawStartDate());</span>

<span class="nc" id="L1817">				boolean isDSTTransitionPeriod = campaignTimeZone.inDaylightTime(traceCube.getRawStartDate()) != campaignTimeZone</span>
<span class="nc bnc" id="L1818" title="All 2 branches missed.">						.inDaylightTime(traceCube.getRawEndDate());</span>
<span class="nc" id="L1819">				int currentValueIndex = 1;</span>
<span class="nc bnc" id="L1820" title="All 2 branches missed.">				for (int i = 0; i &lt; numOfDaysInCube; i++) {</span>
<span class="nc" id="L1821">					Date dateTime = cal.getTime();</span>
<span class="nc" id="L1822">					Date endOfDay = new Date(dateTime.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG - 1);</span>
<span class="nc bnc" id="L1823" title="All 4 branches missed.">					boolean isDSTOut = isDSTTransitionPeriod &amp;&amp; (campaignTimeZone.inDaylightTime(dateTime) &amp;&amp; !campaignTimeZone</span>
<span class="nc bnc" id="L1824" title="All 2 branches missed.">							.inDaylightTime(endOfDay));</span>
<span class="nc bnc" id="L1825" title="All 4 branches missed.">					boolean isDSTIn = isDSTTransitionPeriod &amp;&amp; (!campaignTimeZone.inDaylightTime(dateTime) &amp;&amp; campaignTimeZone</span>
<span class="nc bnc" id="L1826" title="All 2 branches missed.">							.inDaylightTime(endOfDay));</span>

					// Add new Forecast Time Series objects
<span class="nc" id="L1829">					ForecastTimeSeries forecastTimeSeries = new ForecastTimeSeries();</span>
<span class="nc" id="L1830">					forecastTimeSeries.setSpQueueId(spQueueID);</span>
<span class="nc" id="L1831">					forecastTimeSeries.setDateTime(dateTime);</span>
<span class="nc" id="L1832">					forecastTimeSeries.setCreated(creationDate);</span>
<span class="nc" id="L1833">					forecastTimeSeries.setCreatedBy(username);</span>
<span class="nc" id="L1834">					forecastTimeSeries.setForecastInstanceId(forecastInstance.getID());</span>

<span class="nc" id="L1836">					Class forecastTimeSeriesClass = forecastTimeSeries.getClass();</span>
<span class="nc" id="L1837">					Object[] setAhtArgs = new Object[1];</span>
<span class="nc" id="L1838">					Object[] setCvArgs = new Object[1];</span>
<span class="nc bnc" id="L1839" title="All 2 branches missed.">					for (int j = 1; j &lt; 97; j++, currentValueIndex++) {</span>
<span class="nc bnc" id="L1840" title="All 2 branches missed.">						if (traceCube.getTraceValueD(Trace.AHT) != null) {</span>
<span class="nc" id="L1841">							Method setAhtMethod = forecastTimeSeriesClass.getMethod(&quot;setAht&quot; + j, new Class[]{float.class});</span>
<span class="nc bnc" id="L1842" title="All 2 branches missed.">							if (traceCube.getTraceValueD(Trace.AHT).length &gt;= currentValueIndex)</span>
<span class="nc" id="L1843">								setAhtArgs[0] = new Integer((int) (traceCube.getTraceValueD(Trace.AHT)[currentValueIndex - 1]));</span>
<span class="nc" id="L1844">							else setAhtArgs[0] = new Integer(0);</span>
<span class="nc" id="L1845">							setAhtMethod.invoke(forecastTimeSeries, setAhtArgs);</span>
						}
<span class="nc bnc" id="L1847" title="All 2 branches missed.">						if (traceCube.getTraceValueD(Trace.CV) != null) {</span>
<span class="nc" id="L1848">							Method setCvMethod = forecastTimeSeriesClass.getMethod(&quot;setCallVolume&quot; + j, new Class[]{float.class});</span>
<span class="nc bnc" id="L1849" title="All 2 branches missed.">							if (traceCube.getTraceValueD(Trace.CV).length &gt;= currentValueIndex)</span>
<span class="nc" id="L1850">								setCvArgs[0] = new Integer((int) (traceCube.getTraceValueD(Trace.CV)[currentValueIndex - 1]));</span>
<span class="nc" id="L1851">							else setCvArgs[0] = new Integer(0);</span>
<span class="nc" id="L1852">							setCvMethod.invoke(forecastTimeSeries, setCvArgs);</span>
						}
<span class="nc bnc" id="L1854" title="All 4 branches missed.">						if (isDSTOut || isDSTOut) {</span>
<span class="nc" id="L1855">							Date insertPoint = new Date(traceCube.getRawStartDate().getTime() + (Trace.INTERVAL_IN_MILLIS *</span>
									(currentValueIndex - 1)));
<span class="nc" id="L1857">							Date nextPoint = new Date(traceCube.getRawStartDate().getTime() + (Trace.INTERVAL_IN_MILLIS *</span>
									currentValueIndex));
<span class="nc bnc" id="L1859" title="All 2 branches missed.">							if (campaignTimeZone.inDaylightTime(insertPoint) != campaignTimeZone.inDaylightTime(nextPoint)) {</span>
<span class="nc" id="L1860">								int dstIntv = campaignTimeZone.getDSTSavings() / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc" id="L1861">								m_cat.debug(&quot;need to manage next 4 points since DST changed at this Trace interval =&quot; + insertPoint + &quot; &quot;</span>
										+ &quot;AND &quot; + nextPoint + &quot; :dstIntv=&quot; + dstIntv);
<span class="nc bnc" id="L1863" title="All 2 branches missed.">								if (isDSTIn) {//set 3 pouints to NA in forecastTimeSeries +4 th point will increment from the for loop</span>
									// operator
									//j = j + (dstIntv-1); //DO NOT DO anything will fix it later
								} else {   //ignore 4 points from trace cube
<span class="nc" id="L1867">									currentValueIndex += dstIntv;</span>
								}
							}
						}
					}
<span class="nc" id="L1872">					ForecastTimeSeriesDAO.createForecastTimeSeries(forecastTimeSeries);</span>
<span class="nc" id="L1873">					cal.add(Calendar.DATE, 1);</span>
				}
<span class="nc" id="L1875">				forecastBacklog(traceCube, campaignTimeZone, forecastInstance.getID(), spQueueID);</span>
<span class="nc" id="L1876">			}</span>
<span class="nc" id="L1877">		} catch (JdmoException e) {</span>
<span class="nc" id="L1878">			handleException(e, false);</span>
<span class="nc" id="L1879">			throw new BbmCreateException(e);</span>
<span class="nc" id="L1880">		} catch (NoSuchMethodException e) {</span>
<span class="nc" id="L1881">			handleException(e, false);</span>
<span class="nc" id="L1882">		} catch (InvocationTargetException e) {</span>
<span class="nc" id="L1883">			handleException(e, false);</span>
<span class="nc" id="L1884">		} catch (IllegalAccessException e) {</span>
<span class="nc" id="L1885">			handleException(e, false);</span>
		} finally {
<span class="nc" id="L1887">			forecastProfileDAO.cleanUp();</span>
<span class="nc" id="L1888">			methodFinish();</span>
<span class="nc" id="L1889">		}</span>

		//getID() returns the SID, getId() returnd the ID (the DE string ID). We return the DE string Id because the Forecast applet uses
		//the string ID's for the list, and we need to be able to &quot;Save and Launch&quot; the forecast applet with this Id selected by default.
<span class="nc" id="L1893">		return forecastInstance.getId();</span>
	}

	private void forecastBacklog(TraceCube traceCube, TimeZone campaignTimeZone, ID forecastInstanceID, ID spQueueID) throws
			JdmoException {
		//Storing backlog information.
		//Backlog will be set to null if the reforecast dialog has the &quot;Reforecast Backlog&quot; option disabled
<span class="nc" id="L1900">		double[] backlogTraceValueD = traceCube.getTraceValueD(Trace.BACKLOG);</span>
<span class="nc bnc" id="L1901" title="All 2 branches missed.">		if (backlogTraceValueD != null) {</span>
<span class="nc" id="L1902">			ForecastInterimBacklogDAO.createForecastInterimBacklog(forecastInterimBacklog(backlogTraceValueD, campaignTimeZone, traceCube</span>
<span class="nc" id="L1903">					.getRawStartDate(), forecastInstanceID, spQueueID));</span>
		}
<span class="nc" id="L1905">	}</span>

	ForecastInterimBacklog forecastInterimBacklog(double[] backlogTraceValueD, TimeZone campaignTimeZone, Date traceCubeRawStartDate, ID
			forecastInstanceID, ID spQueueID) {
<span class="nc" id="L1909">		Calendar campCalendar = Calendar.getInstance(campaignTimeZone);</span>
<span class="nc" id="L1910">		Calendar traceStart = Calendar.getInstance(campaignTimeZone);</span>
<span class="nc" id="L1911">		traceStart.setTime(traceCubeRawStartDate);</span>

<span class="nc" id="L1913">		int backlogBucket = 0;</span>
		//Converting to buckets
<span class="nc" id="L1915">		int numberOfBuckets = (int) ((campCalendar.getTimeInMillis() - traceStart.getTimeInMillis()) / MILLIS_IN_BUCKET);</span>
		//If numberOfBuckets is zero, then there will be no corresponding actual value.
		//This is because, pulse will allow entering actual value for 12:00 bucket only after 12:15.
		//So for the user to enter any value in pulse, the number of Bucket should be one at least.
		float backlogValue;
<span class="nc bnc" id="L1920" title="All 2 branches missed.">		if (numberOfBuckets == 0) {</span>
<span class="nc" id="L1921">			backlogValue = 0;</span>
<span class="nc bnc" id="L1922" title="All 2 branches missed.">		} else if (numberOfBuckets &lt; backlogTraceValueD.length) {</span>
<span class="nc" id="L1923">			backlogBucket = numberOfBuckets - 1;</span>
<span class="nc" id="L1924">			backlogValue = (float) backlogTraceValueD[backlogBucket];</span>
		} else {
			//This indicates the cube is not created correctly or there is something
			//wrong with the date conversion.
<span class="nc" id="L1928">			throw new RuntimeException(&quot;Backlog Cube does not have a bucket &quot; + numberOfBuckets);</span>
		}

<span class="nc bnc" id="L1931" title="All 2 branches missed.">		if (backlogValue &lt; 0) {</span>
<span class="nc" id="L1932">			backlogValue = 0;</span>

			//Running backlog not entered in Pulse. Find the running backlog.
<span class="nc bnc" id="L1935" title="All 2 branches missed.">			for (int ny = numberOfBuckets; ny &gt;= 0; ny--) {</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">				if (backlogTraceValueD[ny] &gt; -1) {</span>
<span class="nc" id="L1937">					backlogValue = (float) backlogTraceValueD[ny];</span>
<span class="nc" id="L1938">					backlogBucket = ny;</span>
<span class="nc" id="L1939">					break;</span>
				}
			}
		}

<span class="nc" id="L1944">		ForecastInterimBacklog backlog = new ForecastInterimBacklog();</span>
<span class="nc" id="L1945">		backlog.setForecastInstanceId(forecastInstanceID);</span>
<span class="nc" id="L1946">		backlog.setSpQueueId(spQueueID);</span>
<span class="nc" id="L1947">		backlog.setInterimBacklog(backlogValue);</span>
<span class="nc" id="L1948">		Calendar backlogTime = (Calendar) traceStart.clone();</span>
<span class="nc" id="L1949">		backlogTime.add(Calendar.MINUTE, backlogBucket * MINUTES_IN_BUCKET);</span>
<span class="nc" id="L1950">		backlog.setInterimBacklogDate(backlogTime.getTime());</span>
<span class="nc" id="L1951">		return backlog;</span>
	}

    public void deleteReForecasts(ID spId, ID spQueueId) throws BbmRemoveException {
<span class="nc" id="L1955">        methodStart( &quot;deleteReForecasts&quot;, spId, spQueueId );</span>
<span class="nc" id="L1956">        ForecastProfileDAO dao = new ForecastProfileDAO();</span>
        try {
            // Delete the forecast time series object
<span class="nc" id="L1959">            ForecastTimeSeriesDAO.deleteForecastTimeSeriesBySpQueue(spQueueId);</span>

            // Delete the forecast profile object
<span class="nc" id="L1962">            dao.deleteObjectsBySpQueueID(spQueueId);</span>

            //Delete forecast backlog
<span class="nc" id="L1965">            ForecastInterimBacklogDAO.deleteBacklogByForecastInstanceID(spId);</span>

            // Delete the forecast instance
<span class="nc" id="L1968">            ForecastInstanceDAO.deleteForecastInstanceBySpQueue(spId);</span>
        }
<span class="nc" id="L1970">        catch (JdmoException e) {</span>
<span class="nc" id="L1971">            handleException(e, false);</span>
<span class="nc" id="L1972">            throw new BbmRemoveException(e);</span>
        } finally {
<span class="nc" id="L1974">            dao.cleanUp();</span>
<span class="nc" id="L1975">            methodFinish();</span>
<span class="nc" id="L1976">        }</span>
<span class="nc" id="L1977">    }</span>

    /**
     * Returns a map of SPQueues with integer values specifying the starting backlog for those SPQueues.
     * The starting backlog is determined by the target Scheduling Period that is handed in to this method.
     * The starting backlog will either be pulled from the PREDICTEDTIMESERIES table (for forecasted backlog) or
     * the QUEUEHISTORYTIMESERIES table (for Actual backlog).  The starting backlog will be pulled from the
     * latest backlog value from the target SP matching the work queue from the input spQueue.  However, we will
     * only look back 24 hours from the end date of the target SP (and queue) to find an ending backlog value.
     * If no backlog is present during the last 24 hours of the SP then the starting backlog will be set as
     * 0 for that spQueue.  If the targetSP does not have a matching work queue, the starting backlog for the
     * spQueue will be set to 0.
     *
     * @param spQueues SpQueues corresponding to the queues for which starting backlog is to be
     * fetched.  The actual time interval covered by the associated SP is ignored.
     * @param targetSP this appears to be the SP &lt;em&gt;before&lt;/em&gt; the SP for which starting backlog
     * is needed.
     * @param backlogType {@link BacklogType#Actual} or {@link BacklogType#Forecasted}
     * @return HashMap&lt;SPQueue, Integer&gt; - The SPQueue key is from the collection of spQueues handed into the method.
     * The Integer value represents the starting backlog for that spQueue, determined by looking at the forecasted
     * or actual ending backlog values of the targetSP for the matching work queues.
     */
    public Map&lt;SPQueue, Integer&gt; fetchStartingBacklogForSPQueues(Collection&lt;SPQueue&gt; spQueues,
                                                                 SchedulingPeriod targetSP, BacklogType backlogType) throws BbmException {

<span class="nc" id="L2002">		Map&lt;SPQueue, Integer&gt; retVal = initBacklogMap(spQueues);</span>
<span class="nc" id="L2003">		Collection&lt;ID&gt; queueIds = ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues);</span>

<span class="nc" id="L2005">		Date adjustedSpEndDate = new Date(targetSP.getEndTime().getTime() - 1000);</span>
<span class="nc" id="L2006">		Collection&lt;TraceCube&gt; backlogData = getBacklogTraceData(targetSP.getCampaignID(), queueIds, backlogType,</span>
<span class="nc" id="L2007">				targetSP.getStartTime(), adjustedSpEndDate);</span>

        //Go through the backlog data for each queue and find the last non-zero value for each
        // trace cube (up to 24 hours prior to the end of the period, if there are no non-zero values of ending backlog
        // in the last 24 hours of the SP for the target queue then the starting backlog will be zero for
        // that queue.
<span class="nc bnc" id="L2013" title="All 2 branches missed.">        for (TraceCube cube : backlogData) {</span>
<span class="nc" id="L2014">            Calendar startDate = Calendar.getInstance();</span>
<span class="nc" id="L2015">            startDate.setTime(cube.getRawEndDate());</span>
<span class="nc" id="L2016">            startDate.add(Calendar.DAY_OF_YEAR, -1);</span>
<span class="nc" id="L2017">            double[] backlogValues = cube.getTraceValueD(Trace.BACKLOG, startDate.getTime(), cube.getRawEndDate());</span>
<span class="nc" id="L2018">            int endingBacklogValue = 0;</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">            for (int i = backlogValues.length - 1; i &gt;= 0; i--) {</span>
<span class="nc bnc" id="L2020" title="All 2 branches missed.">                if (backlogValues[i] &gt; 0) {</span>
<span class="nc" id="L2021">                	endingBacklogValue = (int)(backlogValues[i]);</span>
<span class="nc" id="L2022">                    break;</span>
                }
            }

<span class="nc bnc" id="L2026" title="All 2 branches missed.">            if (endingBacklogValue &gt; 0) {</span>
<span class="nc bnc" id="L2027" title="All 2 branches missed.">                for (SPQueue spQueue : retVal.keySet()) {</span>
<span class="nc bnc" id="L2028" title="All 4 branches missed.">                    if (spQueue.getQueueID() != null &amp;&amp; spQueue.getQueueID().equals(cube.getQueueID())) {</span>
<span class="nc" id="L2029">                        retVal.put(spQueue, endingBacklogValue);</span>
<span class="nc" id="L2030">                        break;</span>
                    }
<span class="nc" id="L2032">                }</span>
            }
<span class="nc" id="L2034">        }</span>

<span class="nc" id="L2036">        return retVal;</span>
	}

	public Map&lt;SPQueue, Integer&gt; fetchActualStartingBacklogForSPQueuesAtDate(Collection&lt;SPQueue&gt; spQueues,
			ID campaignId, Date date) throws BbmException {

<span class="nc" id="L2042">		Map&lt;SPQueue, Integer&gt; retVal = initBacklogMap(spQueues);</span>
<span class="nc" id="L2043">		Collection&lt;ID&gt; queueIds = ValueObjectUtil.getFieldObjectCol(SPQueueFieldInfo.SPQUEUE_QUEUEID, spQueues);</span>

<span class="nc" id="L2045">		Collection&lt;TraceCube&gt; backlogData = getBacklogTraceData(campaignId, queueIds, BacklogType.Actual, date, date);</span>

		//Go through the backlog data for each queue and find the last non-zero value for each
		// trace cube (up to 24 hours prior to the end of the period, if there are no non-zero values of ending backlog
		// in the last 24 hours of the SP for the target queue then the starting backlog will be zero for
		// that queue.
<span class="nc bnc" id="L2051" title="All 2 branches missed.">		for (TraceCube cube : backlogData) {</span>
<span class="nc" id="L2052">			int backlogValue = cube.getTraceValue(Trace.BACKLOG, date);</span>
<span class="nc bnc" id="L2053" title="All 2 branches missed.">			for (SPQueue spQueue : retVal.keySet()) {</span>
<span class="nc bnc" id="L2054" title="All 4 branches missed.">				if (spQueue.getQueueID() != null &amp;&amp; spQueue.getQueueID().equals(cube.getQueueID())) {</span>
<span class="nc" id="L2055">					retVal.put(spQueue, backlogValue);</span>
<span class="nc" id="L2056">					break;</span>
				}
<span class="nc" id="L2058">			}</span>
<span class="nc" id="L2059">		}</span>

<span class="nc" id="L2061">		return retVal;</span>
	}

	private Map&lt;SPQueue, Integer&gt; initBacklogMap(Collection&lt;SPQueue&gt; spQueues) {
<span class="nc" id="L2065">		Map&lt;SPQueue, Integer&gt; retVal = new HashMap&lt;SPQueue, Integer&gt;();</span>

<span class="nc bnc" id="L2067" title="All 2 branches missed.">		for (SPQueue spQueue : spQueues) {</span>
<span class="nc" id="L2068">			retVal.put(spQueue, 0);</span>
<span class="nc" id="L2069">		}</span>
<span class="nc" id="L2070">		return retVal;</span>
	}

	private Collection&lt;TraceCube&gt; getBacklogTraceData(ID campaignId, Collection&lt;ID&gt; queueIDs, BacklogType backlogType,
			Date startDate, Date endDate) throws BbmFinderException {
		Collection&lt;TraceCube&gt; backlogData;
<span class="nc bnc" id="L2076" title="All 3 branches missed.">		switch (backlogType) {</span>
			case Forecasted:
<span class="nc" id="L2078">				PredictTraceCube predictMeta = new PredictTraceCube(new short[]{Trace.BACKLOG});</span>
<span class="nc" id="L2079">				backlogData = getRawMultipleQueuesTimeSeries(predictMeta,</span>
						campaignId, queueIDs, startDate, endDate);
<span class="nc" id="L2081">				break;</span>
			case Actual:
<span class="nc" id="L2083">				ActualTraceCube actualMeta = new ActualTraceCube(new short[]{Trace.BACKLOG});</span>
<span class="nc" id="L2084">				backlogData = getRawMultipleQueuesTimeSeries(actualMeta,</span>
						campaignId, queueIDs, startDate, endDate);
<span class="nc" id="L2086">				break;</span>
			default:
<span class="nc" id="L2088">				backlogData = new ArrayList&lt;TraceCube&gt;();</span>
				break;
		}
<span class="nc" id="L2091">		return backlogData;</span>
    }

    private ArrayList getEmployeeSkillIDs(ID empID, Date start, Date end) throws Exception {
<span class="fc" id="L2095">        Collection empSkillAssignments = WfmManagerFactory.getSkillManager(WhatIfMode).getSkillAssignments(empID, start, end);</span>
<span class="fc" id="L2096">        ArrayList skillIDs = new ArrayList();</span>
<span class="pc bpc" id="L2097" title="1 of 2 branches missed.">        if (empSkillAssignments != null) {</span>
<span class="nc bnc" id="L2098" title="All 2 branches missed.">            for (Iterator iSkill = empSkillAssignments.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L2099">                skillIDs.add(((SkillAssignment) iSkill.next()).getSkillID());</span>
            }
        }
<span class="fc" id="L2102">        return skillIDs;</span>
    }

    private HashMap getSPSkillMap(ID campaignID, Date start, Date end) throws Exception {
<span class="fc" id="L2106">        HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc" id="L2107">        Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriods(campaignID, start, end);</span>
<span class="fc bfc" id="L2108" title="All 2 branches covered.">        for (SchedulingPeriod sp : spCol) {</span>
<span class="pc bpc" id="L2109" title="1 of 2 branches missed.">            spSkillMap.put(sp.getID(), sp.getSkillBased() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="fc" id="L2110">        }</span>
<span class="fc" id="L2111">        return spSkillMap;</span>
    }

    /**
     * 
     * @param empID
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     */
    public INetStaffingCube getINetStaffing(ID empID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L2123">    	return getNetStaffing(empID, start, end);</span>
    }

    public NetStaffingCube getNetStaffing(ID empID, Date start, Date end) throws BbmFinderException {
        try {
<span class="fc" id="L2128">        	NetStaffingCube nCube = new NetStaffingCube();</span>
<span class="fc" id="L2129">            Collection returnCol = new ArrayList();</span>
            //Get the emp skills for given the date range
<span class="fc" id="L2131">            ArrayList skillIDs = getEmployeeSkillIDs(empID, start, end);</span>
            //get Campaign-work resource assignments for given the date range
<span class="fc" id="L2133">            Collection&lt;CampaignWorkResource&gt; assignments = m_CampaignManager.getWorkResourceCampaignAssignments(empID, start, end);</span>
<span class="pc bpc" id="L2134" title="2 of 4 branches missed.">            if (assignments == null || assignments.isEmpty()) {</span>
<span class="nc" id="L2135">                return null;   // no point in showing net-staff if user is not associated to any campaign</span>
            }
            //get the queues that are relevant to emp skills for the campaigns
<span class="fc" id="L2138">            HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc bfc" id="L2139" title="All 2 branches covered.">            for (Iterator it = assignments.iterator(); it.hasNext();) {</span>
<span class="fc" id="L2140">                CampaignWorkResource ass = (CampaignWorkResource) it.next();</span>
<span class="pc bpc" id="L2141" title="1 of 2 branches missed.">                if (!spSkillMap.containsKey(ass.getSPID())) {</span>
<span class="fc" id="L2142">                    spSkillMap.putAll(getSPSkillMap(ass.getCampaignID(), start, end));</span>
                }
<span class="fc" id="L2144">                Boolean isSKillSP = spSkillMap.get(ass.getSPID());</span>
<span class="fc" id="L2145">                HashMap&lt;ID, SPQueue&gt; spQueueMap = new HashMap&lt;ID, SPQueue&gt;();</span>
<span class="fc" id="L2146">                Campaign camp = m_CampaignManager.getCampaignByID(ass.getCampaignID());</span>

<span class="pc bpc" id="L2148" title="1 of 2 branches missed.">				if (isSKillSP)</span>
				{
<span class="nc" id="L2150">					Collection&lt;SPQueue&gt; spQueues = m_CampaignManager.getSPQueuesBySPID(ass.getSPID());</span>
<span class="nc bnc" id="L2151" title="All 2 branches missed.">					for (SPQueue spqueue : spQueues) {</span>
						//Filter and keep only queues that are relevant to employee Skills.
						//If unskilled then add all queues
<span class="nc bnc" id="L2154" title="All 4 branches missed.">						if (!isSKillSP || skillIDs.containsAll(spqueue.getSkills())) {</span>
<span class="nc" id="L2155">							spQueueMap.put(spqueue.getQueueID(), spqueue);</span>
						}
<span class="nc" id="L2157">					}</span>
<span class="nc" id="L2158">				}</span>
				else
				{
<span class="fc" id="L2161">					Collection&lt;SPQueue&gt; spQueues = new ArrayList&lt;SPQueue&gt;(1);</span>
<span class="fc" id="L2162">					SPQueue spQueue = m_CampaignManager.getCombinedSPQueue(ass.getSPID(), Media.MEDIA_ID_PHONE);</span>
<span class="pc bpc" id="L2163" title="1 of 2 branches missed.">					if (spQueue != null)</span>
					{
<span class="fc" id="L2165">						spQueues.add(spQueue);</span>
<span class="fc" id="L2166">						spQueueMap.put(Media.MEDIA_ID_PHONE, spQueue);</span>
					}
				}

<span class="pc bpc" id="L2170" title="2 of 4 branches missed.">                if (spQueueMap == null || spQueueMap.isEmpty()) {</span>
<span class="nc" id="L2171">                    continue;  //employee does not have the skills required for this campaign.</span>
                }
<span class="fc" id="L2173">                TimeRange tr = NetStaffingCube.getDateRangeForNetstaffing(camp, spQueueMap.values(), ass, start, end);</span>
<span class="fc" id="L2174">                getOverUnder(nCube, isSKillSP, camp, spQueueMap, tr.getStartDate(), tr.getEndDate());</span>
<span class="fc" id="L2175">            }</span>
<span class="fc" id="L2176">            return nCube;</span>
<span class="nc" id="L2177">        } catch (Exception e) {</span>
<span class="nc" id="L2178">            handleException(e, false);</span>
<span class="nc" id="L2179">            throw new BbmFinderException(e);</span>
        }
    }

<span class="fc" id="L2183">    private static final PredictTraceCube predictMetaTCNetStaff = new PredictTraceCube(new short[]{Trace.FTE, Trace.STAFFING, Trace.AFTE, Trace.ASTAFFING, Trace.NETSTAFFING, Trace.OVER_UNDER});</span>

<span class="fc" id="L2185">    private static final RequireTraceCube requireMetaTCNetStaff = new RequireTraceCube(new short[]{Trace.FTE});</span>

    private void getOverUnder(NetStaffingCube nCube, boolean isSkillSP,Campaign camp, HashMap&lt;ID, SPQueue&gt; spQueueMap, Date start, Date end) throws Exception {
<span class="fc" id="L2188">        end = new Date(end.getTime() - 60000);//copied from Pulse UI to be consistent with the Pulse UI</span>
<span class="fc" id="L2189">        ID campID =  camp.getID();</span>
        Collection&lt;TraceCube&gt; predictCubeData;
        Collection&lt;TraceCube&gt; requireCubeData;
<span class="pc bpc" id="L2192" title="1 of 2 branches missed.">        if (!isSkillSP) {</span>
<span class="fc" id="L2193">            predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, campID, Media.MEDIA_ID_PHONE, start, end);</span>
<span class="fc" id="L2194">            requireCubeData = getRawCombinedQueuesTimeSeries(requireMetaTCNetStaff, campID, Media.MEDIA_ID_PHONE, start, end);</span>
        } else {
<span class="nc" id="L2196">            predictCubeData = getRawMultipleQueuesTimeSeries(predictMetaTCNetStaff, campID, spQueueMap.keySet(), start, end);</span>
<span class="nc" id="L2197">            requireCubeData = getRawMultipleQueuesTimeSeries(requireMetaTCNetStaff, campID, spQueueMap.keySet(), start, end);</span>
        }
<span class="fc" id="L2199">        HashMap&lt;ID, TraceCube&gt; requireCubeMap = new HashMap&lt;ID, TraceCube&gt;();</span>
        SPQueue spQueue;
<span class="fc bfc" id="L2201" title="All 2 branches covered.">        for (Iterator&lt;TraceCube&gt; iterator1 = requireCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="fc" id="L2202">            TraceCube traceCube = iterator1.next();</span>
<span class="pc bpc" id="L2203" title="2 of 4 branches missed.">            if (!isSkillSP &amp;&amp; traceCube.getQueueID().toInt() &gt; 0) {</span>
<span class="nc" id="L2204">                continue; //ignore unskilled queues because we only interested in combined queue</span>
            }
<span class="fc" id="L2206">            requireCubeMap.put(traceCube.getQueueID(), traceCube);</span>
<span class="fc" id="L2207">        }</span>
<span class="fc bfc" id="L2208" title="All 2 branches covered.">        for (Iterator&lt;TraceCube&gt; iterator1 = predictCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="fc" id="L2209">            PredictTraceCube pCube = (PredictTraceCube) iterator1.next();</span>
<span class="pc bpc" id="L2210" title="1 of 4 branches missed.">            if (!isSkillSP &amp;&amp; pCube.getQueueID().toInt() &gt; 0) {</span>
<span class="fc" id="L2211">                continue; //ignore unskilled queues because we only interested in combined queue</span>
            }
<span class="fc" id="L2213">            RequireTraceCube rCube = (RequireTraceCube) requireCubeMap.get(pCube.getQueueID());</span>
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">            if (isSkillSP){</span>
<span class="nc" id="L2215">                spQueue = spQueueMap.get(pCube.getQueueID());</span>
            }else{
<span class="pc bpc" id="L2217" title="2 of 4 branches missed.">                if(pCube==null|| pCube.getSPQueueSID()==null){</span>
                    //no point in going further because there is no staffing data available  return here
<span class="nc" id="L2219">                    m_cat.debug(&quot;(TimeSeriesManagerEJB.getOverUnder )no point in going further because there is no staffing data available camp=&quot;+camp);</span>
<span class="nc" id="L2220">                    return;</span>
                }
<span class="fc" id="L2222">                spQueue= m_CampaignManager.getSPQueue(pCube.getSPQueueSID());</span>
            }
<span class="fc" id="L2224">            TraceCube[] metaCubes = new TraceCube[5];</span>
<span class="fc" id="L2225">            metaCubes[2] = pCube;</span>
<span class="fc" id="L2226">            metaCubes[4] = rCube;</span>
<span class="fc" id="L2227">            Map&lt;ID, SPQueue&gt; spQIDObjectMap = ValueObjectUtil.getIDObjectMap(spQueueMap.values());</span>
<span class="fc" id="L2228">			TraceOperatorAdapter.calcComputedValuesForAggrForcastTraceCubes(metaCubes, spQIDObjectMap);</span>
<span class="fc" id="L2229">            nCube.addNetStaffing(camp, pCube, rCube, spQueue);</span>
<span class="fc" id="L2230">        }</span>
<span class="fc" id="L2231">    }</span>

    /**
     * Get a map of SPID : &lt;collection of PredictTraceCube&gt;, that would exist if the specified ShiftAssignment is added/deleted,
     * where the SPID's are the SP assignments for the given employee in the given date range, and the PredictTraceCube's are
     * those that are relevant to the employee's skills (if a skilled SP). If skilled, the PredictTraceCube's will be for various
     * queues (individual and/or combined).
     * Events should at least have one shift assignment, it reflect the picture of schedule to recalc.
     * @param traceCubesMap
     * @param affectedTMTimeRange
     * @param events
     * @param shift
     * @param isDelete
     * @return a map of SPID : &lt;collection of PredictTraceCube&gt; that would exist if the specified ShiftAssignment is added/deleted.
     * @throws BbmFinderException
     */
    public HashMap reCalcAdjustedFTEAndStaffing(HashMap traceCubesMap, TimeRange affectedTMTimeRange, Collection events,
            ShiftAssignment shift, boolean isDelete) throws BbmFinderException {
<span class="fc" id="L2249">        methodStart(&quot;reCalcAdjustedFTEAndStaffing&quot;, traceCubesMap, affectedTMTimeRange, events, shift, isDelete);</span>
        try {
<span class="pc bpc" id="L2251" title="1 of 2 branches missed.">            if (shift == null) {</span>
<span class="nc" id="L2252">                return new HashMap(); // has nothing to recalc</span>
            }

<span class="pc bpc" id="L2255" title="1 of 2 branches missed.">            Date dtStart = shift.getStartTime().before(affectedTMTimeRange.getStartDate())?affectedTMTimeRange.getStartDate():shift.getStartTime();</span>
<span class="pc bpc" id="L2256" title="1 of 2 branches missed.">            Date dtEnd = shift.getEndTime().after(affectedTMTimeRange.getEndDate())?affectedTMTimeRange.getEndDate():shift.getEndTime();</span>
<span class="fc" id="L2257">            ID empID = shift.getWorkResourceIDs().iterator().next();</span>

<span class="fc" id="L2259">            ID spID = shift.getCampaignID();</span>
<span class="pc bpc" id="L2260" title="1 of 2 branches missed.">			if(spID == null){</span>
<span class="nc" id="L2261">				return new HashMap();</span>
			}

            Collection traceCubes;
<span class="pc bpc" id="L2265" title="1 of 2 branches missed.">            if (traceCubesMap == null) {</span>
<span class="nc" id="L2266">                traceCubesMap = new HashMap();</span>
            }
<span class="fc" id="L2268">            traceCubes = (Collection) traceCubesMap.get(spID);</span>
<span class="pc bpc" id="L2269" title="1 of 2 branches missed.">            if (traceCubes == null) {</span>
<span class="fc" id="L2270">                traceCubesMap.putAll(getForecastedStaffingAndFTE(empID, affectedTMTimeRange.getStartDate(), affectedTMTimeRange.getEndDate()));</span>
<span class="fc" id="L2271">                traceCubes = (Collection) traceCubesMap.get(spID);</span>

<span class="pc bpc" id="L2273" title="2 of 4 branches missed.">                if (traceCubes == null || traceCubes.size() == 0)</span>
<span class="nc" id="L2274">                    return traceCubesMap; //the employee has no skills for his shift, so net staffing will not be affected by deleting the shift.</span>
            }

            ID key;
            Collection loopCubes;
<span class="fc bfc" id="L2279" title="All 2 branches covered.">            for (Object spIDKey : traceCubesMap.keySet()) {</span>
<span class="fc" id="L2280">                key = (ID) spIDKey;</span>
<span class="fc" id="L2281">                loopCubes = (Collection) traceCubesMap.get(key);</span>
<span class="fc" id="L2282">                loopCubes = adjustTraceCubeForEachSP(loopCubes, dtStart, dtEnd, key, events, isDelete);</span>
<span class="fc" id="L2283">                traceCubesMap.put(key, loopCubes);</span>
<span class="fc" id="L2284">            }</span>

<span class="fc" id="L2286">            return traceCubesMap;</span>
<span class="nc" id="L2287">        } catch(Exception e) {</span>
<span class="nc" id="L2288">            handleException(e);</span>
<span class="nc" id="L2289">            throw new BbmFinderException(e);</span>
        } finally {
<span class="pc" id="L2291">            methodFinish();</span>
        }
    }

    private Collection adjustTraceCubeForEachSP(Collection traceCubes, Date affectedStDt, Date affectedEndDt, ID spID, Collection events,
            boolean isDelete) throws BbmFinderException {

<span class="fc" id="L2298">        TraceCube cube = null;</span>
<span class="fc" id="L2299">        TraceCube combinedCombinedCube = null;</span>

        try {
<span class="fc" id="L2302">            SchedulingPeriod sp = m_CampaignManager.getSchedulingPeriodByID(spID);</span>
<span class="fc" id="L2303">            Campaign campaign = m_CampaignManager.getCampaignByID(sp.getCampaignID());</span>
<span class="pc bpc" id="L2304" title="1 of 2 branches missed.">            Date dtStart = sp.getStartTime().after(affectedStDt) ? sp.getStartTime() : (Date) affectedStDt.clone();</span>
<span class="pc bpc" id="L2305" title="1 of 2 branches missed.">            Date dtEnd = sp.getEndTime().before(affectedEndDt) ? sp.getEndTime() : (Date) affectedEndDt.clone();</span>

<span class="fc" id="L2307">            HashMap spQMap = getSPQMap(traceCubes);</span>

<span class="pc bpc" id="L2309" title="1 of 2 branches missed.">            if (spQMap == null)</span>
<span class="nc" id="L2310">                return traceCubes;</span>

            SPQueue spQ;
<span class="fc bfc" id="L2313" title="All 2 branches covered.">            for (Iterator i = traceCubes.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2314">                cube = (TraceCube) i.next();</span>
<span class="pc bpc" id="L2315" title="2 of 4 branches missed.">                if (cube != null &amp;&amp; cube.getSPQueueSID() != null) {</span>
<span class="fc" id="L2316">                    spQ = (SPQueue) spQMap.get(cube.getSPQueueSID());</span>
<span class="pc bpc" id="L2317" title="3 of 6 branches missed.">                    if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; spQ.getMediaID() == null)</span>
<span class="nc" id="L2318">                        combinedCombinedCube = cube;</span>
                }
            }

<span class="pc bpc" id="L2322" title="1 of 2 branches missed.">            if (cube == null)</span>
<span class="nc" id="L2323">                return traceCubes; //no traceCubes were found, so nothing to do.</span>

            //no need to pass in activity id object map in the following call. that map is used only for set iswork flag for shift event. we don't care here.
<span class="fc" id="L2326">            Collection timelineEvents = EventUtils.convertEventsToTimelineForSingleEmployee(events, dtStart, dtEnd, null);</span>

            //for each 15 minutes, find out activities and the durations.
<span class="fc" id="L2329">            int startIndex = TraceUtil.gapOffSet(cube.getRawStartDate(), dtStart, campaign.getTimeZone(), true);</span>
<span class="fc" id="L2330">            int curIndex = startIndex;</span>
            SimpleEvent sEvent;
<span class="fc" id="L2332">            HashMap activityPer15m = new HashMap();</span>
<span class="fc bfc" id="L2333" title="All 2 branches covered.">            for (Iterator i = timelineEvents.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2334">                sEvent = (SimpleEvent) i.next();</span>
<span class="fc" id="L2335">                curIndex = analyzeEvent(sEvent, curIndex, activityPer15m);</span>
            }

            Map.Entry entry;
            int index;
            Collection activityDuration;
<span class="fc" id="L2341">            ID idActivity = null;</span>
<span class="fc" id="L2342">            Activity activity = null;</span>
<span class="fc" id="L2343">            double ratio = 0.0;</span>
            ID mediaID;
            Pair pair;
            boolean isLinkToAnyMediaOrQueue;
<span class="fc" id="L2347">            HashMap&lt;ID, HashSet&gt; activityIdMediaIDSetMap = new HashMap&lt;ID, HashSet&gt;();</span>
<span class="fc" id="L2348">            HashMap&lt;ID, Activity&gt; activitiesMap = new HashMap&lt;ID, Activity&gt;();</span>
<span class="fc" id="L2349">            HashMap&lt;ID, Collection&lt;Queue&gt;&gt; activityQueuesMap = new HashMap&lt;ID, Collection&lt;Queue&gt;&gt;();</span>

<span class="fc bfc" id="L2351" title="All 2 branches covered.">            for (Iterator i = activityPer15m.entrySet().iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2352">                isLinkToAnyMediaOrQueue = false;</span>
<span class="fc" id="L2353">                entry = (Map.Entry) i.next();</span>
<span class="fc" id="L2354">                index = (Integer) entry.getKey();</span>
<span class="fc" id="L2355">                activityDuration = (Collection) entry.getValue();</span>
<span class="fc bfc" id="L2356" title="All 2 branches covered.">                for (Iterator iActivity = activityDuration.iterator(); iActivity.hasNext(); ) {</span>
<span class="fc" id="L2357">                    pair = (Pair) iActivity.next();</span>
<span class="fc" id="L2358">                    ratio = ((Integer) (pair.getSecond())) / 15.0;</span>
<span class="fc" id="L2359">                    idActivity = (ID) (pair.getFirst());</span>
<span class="fc" id="L2360">                    activity = getActivity(activitiesMap, idActivity);</span>

<span class="pc bpc" id="L2362" title="1 of 2 branches missed.">                    if (activity.isQueueHopping()) {</span>
<span class="nc" id="L2363">                        isLinkToAnyMediaOrQueue = recalcForQueueHopping(traceCubes, isDelete, spQMap, index,</span>
                                idActivity, ratio, isLinkToAnyMediaOrQueue, activityQueuesMap);
                    } else {
<span class="fc bfc" id="L2366" title="All 2 branches covered.">                        if (!activityIdMediaIDSetMap.containsKey(idActivity)) {</span>
<span class="fc" id="L2367">                            activityIdMediaIDSetMap.put(idActivity, getMediaIDSetForActivityID(idActivity));</span>
                        }
<span class="fc" id="L2369">                        HashSet mediaIDs = activityIdMediaIDSetMap.get(idActivity);</span>
<span class="pc bpc" id="L2370" title="1 of 4 branches missed.">                        if (mediaIDs != null &amp;&amp; !mediaIDs.isEmpty()) {</span>
<span class="fc bfc" id="L2371" title="All 2 branches covered.">                            for (Iterator iMedia = mediaIDs.iterator(); iMedia.hasNext(); ) {</span>
<span class="fc" id="L2372">                                isLinkToAnyMediaOrQueue = true;</span>
<span class="fc" id="L2373">                                mediaID = (ID) iMedia.next();</span>
<span class="fc" id="L2374">                                recalc(traceCubes, mediaID, null, index, ratio, spQMap, isDelete);</span>
                            }
                        }
<span class="fc" id="L2377">                    }</span>
                }
<span class="fc bfc" id="L2379" title="All 2 branches covered.">                if (isLinkToAnyMediaOrQueue) {</span>
                    //for every 15m, adjust astaffing once on combinedCombinedQ if it is linked to any media or queue
<span class="fc" id="L2381">                    adjustTraceValue(combinedCombinedCube, index, 0, 1, isDelete, false, true);</span>
                }
            }

<span class="fc" id="L2385">            return traceCubes;</span>
<span class="nc" id="L2386">        } catch (Exception e) {</span>
<span class="nc" id="L2387">            handleException(e);</span>
<span class="nc" id="L2388">            throw new BbmFinderException(e);</span>
        } finally {
<span class="pc" id="L2390">            methodFinish();</span>
        }
    }

    /**
     * Get the queues linked to a queue-hopping activity, and adjust staffing and FTE for each matching SPQueue.
     * @return true if an adjustment was attempted for any of the activity's queues.
     */
    private boolean recalcForQueueHopping(Collection traceCubes, boolean isDelete, HashMap spQMap, int index, ID idActivity,
                double ratio, boolean isLinkToAnyMediaOrQueue, HashMap&lt;ID, Collection&lt;Queue&gt;&gt; activityQueuesMap)
            throws BbmFinderException, RemoteException {
<span class="nc" id="L2401">        Collection&lt;Queue&gt; activityQueues = null;</span>
<span class="nc" id="L2402">        boolean isAdjustmentAttemptedForActivityQueue = false;</span>
<span class="nc bnc" id="L2403" title="All 2 branches missed.">        if (activityQueuesMap.containsKey(idActivity)) {</span>
<span class="nc" id="L2404">            activityQueues = activityQueuesMap.get(idActivity);</span>
        } else {
<span class="nc" id="L2406">            Collection qIDs = m_activityManager.findQueueForActivity(idActivity);</span>
<span class="nc bnc" id="L2407" title="All 4 branches missed.">            if (qIDs != null &amp;&amp; !qIDs.isEmpty()) {</span>
<span class="nc" id="L2408">                activityQueues = m_workloadManager.getQueuesByIDs(qIDs);</span>
<span class="nc" id="L2409">                activityQueuesMap.put(idActivity, activityQueues);</span>
            }
        }
<span class="nc bnc" id="L2412" title="All 4 branches missed.">        if (activityQueues != null &amp;&amp; !activityQueues.isEmpty()) {</span>
<span class="nc bnc" id="L2413" title="All 2 branches missed.">            for (Queue queue : activityQueues) {</span>
                //only recalc this queue if it is in the spQMap, indicating that it is in the SP.
<span class="nc" id="L2415">                boolean isQueueInSPQueueMap = false;</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">                for (Iterator it = spQMap.values().iterator(); it.hasNext();) {</span>
<span class="nc" id="L2417">                    SPQueue spq = (SPQueue) it.next();</span>
<span class="nc bnc" id="L2418" title="All 4 branches missed.">                    if (spq.getQueueID() != null &amp;&amp; spq.getQueueID().equals(queue.getID())) {</span>
<span class="nc" id="L2419">                        isQueueInSPQueueMap = true;</span>
<span class="nc" id="L2420">                        break;</span>
                    }
<span class="nc" id="L2422">                }</span>

<span class="nc bnc" id="L2424" title="All 2 branches missed.">                if (isQueueInSPQueueMap) {</span>
<span class="nc" id="L2425">                    isAdjustmentAttemptedForActivityQueue = true;</span>
<span class="nc" id="L2426">                    recalc(traceCubes, queue.getMediaID(), queue.getID(), index, ratio, spQMap, isDelete);</span>
                }
<span class="nc" id="L2428">            }</span>
        }
<span class="nc bnc" id="L2430" title="All 4 branches missed.">        return isLinkToAnyMediaOrQueue || isAdjustmentAttemptedForActivityQueue;</span>
    }

    private Activity getActivity(HashMap&lt;ID, Activity&gt; activitiesMap, ID activityID) throws Exception {
<span class="pc bpc" id="L2434" title="1 of 2 branches missed.">        if (activitiesMap.containsKey(activityID)) {</span>
<span class="nc" id="L2435">            return activitiesMap.get(activityID);</span>
        }
<span class="fc" id="L2437">        return m_activityManager.findActivityById(activityID);</span>
    }

    private HashSet getMediaIDSetForActivityID(ID idActivity) throws Exception {
<span class="fc" id="L2441">        HashSet mediaIDs = new HashSet();</span>
<span class="fc" id="L2442">        Collection col = m_activityManager.findMediaForActivity(idActivity);</span>
<span class="pc bpc" id="L2443" title="1 of 4 branches missed.">        if (col != null &amp;&amp; !col.isEmpty()) {</span>
<span class="fc" id="L2444">            mediaIDs.addAll(col);</span>
        }

<span class="fc" id="L2447">        return mediaIDs;</span>
    }

    public void updateAdjustedFTEAndStaffing(HashMap traceCubesMap) throws BbmUpdateException {
<span class="fc" id="L2451">        methodStart(&quot;updateAdjustedFTEAndStaffing&quot;, traceCubesMap);</span>
        try {

<span class="fc bfc" id="L2454" title="All 2 branches covered.">            for (Iterator iMap = traceCubesMap.values().iterator(); iMap.hasNext(); ) {</span>
<span class="fc" id="L2455">                Collection traceCubes = (Collection) iMap.next();</span>
<span class="fc" id="L2456">                HashMap spQMap = getSPQMap(traceCubes);</span>
                PredictTraceCube pCube;
<span class="pc bpc" id="L2458" title="1 of 2 branches missed.">                if (traceCubes != null) {</span>
<span class="fc bfc" id="L2459" title="All 2 branches covered.">                    for (Iterator i = traceCubes.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2460">                        pCube = (PredictTraceCube) i.next();</span>
                        //Issue update only if , atleast one of the below Trace types is dirty
<span class="pc bpc" id="L2462" title="4 of 6 branches missed.">                        if (pCube != null &amp;&amp; (pCube.isDirty(Trace.AFTE) || pCube.isDirty(Trace.ASTAFFING))) {</span>
<span class="fc" id="L2463">                            TimeSeriesDAO.updatePredictTraceCube(pCube, new short[]{</span>
                                    Trace.STAFFING, Trace.AFTE, Trace.ASTAFFING}, spQMap);    //no change after recalc
                        }

                    }
                }
<span class="fc" id="L2469">            }</span>
<span class="nc" id="L2470">        } catch (Exception e) {</span>
<span class="nc" id="L2471">            handleException(e);</span>
<span class="nc" id="L2472">            throw new BbmUpdateException(e);</span>
        } finally {
<span class="pc" id="L2474">            methodFinish();</span>
<span class="fc" id="L2475">        }</span>
<span class="fc" id="L2476">    }</span>

    private HashMap getSPQMap(Collection traceCubes) throws Exception {
<span class="pc bpc" id="L2479" title="2 of 4 branches missed.">        if (traceCubes == null || traceCubes.isEmpty())</span>
<span class="nc" id="L2480">            return new HashMap();</span>

        TraceCube cube;
<span class="fc" id="L2483">        Collection spQIDs = new ArrayList(traceCubes.size());</span>
<span class="fc bfc" id="L2484" title="All 2 branches covered.">        for (Iterator i = traceCubes.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2485">            cube = (TraceCube)i.next();</span>
<span class="pc bpc" id="L2486" title="2 of 4 branches missed.">            if(cube!=null &amp;&amp;cube.getSPQueueSID()!=null) {</span>
<span class="fc" id="L2487">                spQIDs.add(cube.getSPQueueSID());</span>
            }
        }

<span class="fc" id="L2491">        Collection spQs = m_CampaignManager.getSPQueuesByIDs(spQIDs);</span>
<span class="fc" id="L2492">        return ValueObjectUtil.getIDObjectMap(spQs);</span>
    }

    private void recalc(Collection oldCubes, ID mediaID, ID queueID, int index, double ratio, HashMap spQMap, boolean isDelete) {
        //find trace cube related to this media
        TraceCube cube;
<span class="fc" id="L2498">        ArrayList colQCubes = new ArrayList();</span>
<span class="fc" id="L2499">        TraceCube combinedCube = null;</span>
<span class="fc" id="L2500">        TraceCube combinedCombinedCube = null;</span>
        SPQueue spQ;
<span class="fc bfc" id="L2502" title="All 2 branches covered.">        for (Iterator i = oldCubes.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L2503">            cube = (TraceCube)i.next();</span>
<span class="fc" id="L2504">            spQ = (SPQueue)spQMap.get(cube.getSPQueueSID());</span>
<span class="pc bpc" id="L2505" title="3 of 6 branches missed.">            if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; spQ.getMediaID() == null) {</span>
<span class="nc" id="L2506">                combinedCombinedCube = cube;</span>
            }
<span class="pc bpc" id="L2508" title="3 of 8 branches missed.">            if (spQ != null &amp;&amp; spQ.getQueueID() == null &amp;&amp; (spQ.getMediaID() != null &amp;&amp; spQ.getMediaID().equals(mediaID))) {</span>
<span class="fc" id="L2509">                combinedCube = cube;</span>
            }
<span class="pc bpc" id="L2511" title="2 of 4 branches missed.">            if (spQ!= null &amp;&amp; spQ.getQueueID() != null) {</span>
<span class="nc bnc" id="L2512" title="All 6 branches missed.">                if (queueID == null &amp;&amp; spQ.getMediaID() != null &amp;&amp; spQ.getMediaID().equals(mediaID)) {</span>
                    //diff real queue could link to same media
<span class="nc" id="L2514">                    colQCubes.add(cube);</span>
<span class="nc bnc" id="L2515" title="All 4 branches missed.">                } else if (queueID != null &amp;&amp; spQ.getQueueID().equals(queueID)) {</span>
<span class="nc" id="L2516">                    colQCubes.add(cube);</span>
                }
            }
        }

<span class="fc" id="L2521">        boolean isAlreadySetCombinedASTAFFING = false;</span>

<span class="pc bpc" id="L2523" title="1 of 4 branches missed.">		if (colQCubes.isEmpty() &amp;&amp; combinedCube!=null)</span>
		{
			//in a non-skilled SP. We will adjust the combinedCube only
<span class="fc" id="L2526">			double ffte = combinedCube.getTraceValueD(Trace.FTE, index);</span>
<span class="fc" id="L2527">			double staff = combinedCube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="pc bpc" id="L2528" title="2 of 4 branches missed.">			double fteContribution = staff &gt; 0 &amp;&amp; ffte &gt; 0 ? (ffte / staff) * ratio : ratio;</span>
<span class="fc" id="L2529">			double staffContribution = 1 * ratio;</span>
<span class="fc" id="L2530">			adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, true, true);</span>
<span class="fc" id="L2531">		}</span>
		else
		{
<span class="pc bpc" id="L2534" title="1 of 2 branches missed.">			for (Iterator i = colQCubes.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L2535">				cube = (TraceCube)i.next();</span>
				/*
					9.	To find the FTE contribution for this person/ shift use  (FFTE /FSTAFF)*CONTRIBUTION RATIO
				   10.	To find the STAFF contribution  for this person /shift use  1 * CONTRIBUTION RATIO
				   11.	Calculate the AFTE &amp; ASTAFF respectively .
				   	If you are using a flattened Timeline of shift to be deleted  then subtract the FTE &amp; STAFF contribution from AFTE &amp; ASTAFF respectively
				   	If you are using a flattened Timeline of shift to be added  then add the FTE &amp; STAFF contribution to AFTE &amp; ASTAFF respectively.
					*/
<span class="nc" id="L2543">				double ffte = cube.getTraceValueD(Trace.FTE, index);</span>
<span class="nc" id="L2544">				double staff = cube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="nc bnc" id="L2545" title="All 4 branches missed.">				double fteContribution = staff &gt; 0 &amp;&amp; ffte &gt; 0 ? (ffte / staff) * ratio : ratio;</span>
<span class="nc" id="L2546">				double staffContribution = 1 * ratio;</span>
<span class="nc" id="L2547">				adjustTraceValue(cube, index, fteContribution, staffContribution, isDelete, true, true);</span>

<span class="nc bnc" id="L2549" title="All 2 branches missed.">				if (!isAlreadySetCombinedASTAFFING) {</span>
<span class="nc" id="L2550">					isAlreadySetCombinedASTAFFING = true;</span>
<span class="nc" id="L2551">					adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, false, true);</span>
				}
				//for each queue, aggregate to combined and combined combined for FTE
<span class="nc" id="L2554">				adjustTraceValue(combinedCube, index, fteContribution, staffContribution, isDelete, true, false);</span>
<span class="nc" id="L2555">				adjustTraceValue(combinedCombinedCube, index, fteContribution, staffContribution, isDelete, true, false);</span>
<span class="nc" id="L2556">			}</span>
		}
<span class="fc" id="L2558">    }</span>
    /*
      * some background info here:
      * FTE and STAFFING is orginically calculated by scheduling recalc. it is kind of the snapshot number at the time of recalculation.
      * but after schedule changed, like adding a new shift:
      * 1. FTE is still the snapshot number.
      * 2. STAFFING becomes to a real time number now. but to calculate the real time staffing number, we need the staffing radio. the radio needs snapshot FTE and snapshot STAFFING
      * to calc, then we store the snapshot STAFFING to ASTAFFING.
      * 3. AFTE is real time number always.
      */

    private void adjustTraceValue(TraceCube cube, int index, double fteContribution, double staffContribution, boolean isDelete, boolean isSetFTE, boolean isSetStaffing) {
<span class="fc bfc" id="L2570" title="All 2 branches covered.">        if (cube == null)</span>
<span class="fc" id="L2571">            return;</span>
<span class="fc" id="L2572">        double newAFTE = cube.getTraceValueD(Trace.AFTE, index);</span>
<span class="fc" id="L2573">        double newASTAFF = cube.getTraceValueD(Trace.ASTAFFING, index);</span>
<span class="fc" id="L2574">        double newSTAFF = cube.getTraceValueD(Trace.STAFFING, index);</span>
<span class="pc bpc" id="L2575" title="1 of 2 branches missed.">        if (isDelete) {</span>
<span class="pc bpc" id="L2576" title="1 of 2 branches missed.">            if (isSetFTE)</span>
<span class="fc" id="L2577">                newAFTE = (newAFTE- fteContribution);</span>
<span class="pc bpc" id="L2578" title="1 of 2 branches missed.">            if (isSetStaffing)</span>
<span class="fc" id="L2579">                newSTAFF =( newSTAFF - staffContribution);</span>
        } else {
<span class="nc bnc" id="L2581" title="All 2 branches missed.">            if (isSetFTE)</span>
<span class="nc" id="L2582">                newAFTE = (newAFTE + fteContribution);</span>
<span class="nc bnc" id="L2583" title="All 2 branches missed.">            if (isSetStaffing)</span>
<span class="nc" id="L2584">                newSTAFF = (newSTAFF + staffContribution);</span>
        }
        //if(newASTAFF&gt;0)System.out.println(&quot;index= &quot;+index+&quot;\tSTAFF=&quot;+newASTAFF + &quot;\tSPQID=&quot;+cube.getSPQueueSID());
<span class="fc" id="L2587">        cube.setTraceValue(Trace.AFTE, newAFTE, index, true);</span>
<span class="fc" id="L2588">        cube.setTraceValue(Trace.ASTAFFING, newASTAFF, index, true);</span>
<span class="fc" id="L2589">        cube.setTraceValue(Trace.STAFFING, newSTAFF, index, true);</span>
<span class="fc" id="L2590">        cube.setTypeDirty(Trace.AFTE, true);</span>
<span class="fc" id="L2591">        cube.setTypeDirty(Trace.ASTAFFING, true);//set dirty flag for later to update</span>
<span class="fc" id="L2592">        cube.setTypeDirty(Trace.STAFFING, true);//set dirty flag for later to update</span>
<span class="fc" id="L2593">    }</span>

    private int analyzeEvent(SimpleEvent event, int index, HashMap activityPer15m) {
<span class="fc" id="L2596">        int eventduration = event.getDuration();</span>
<span class="fc bfc" id="L2597" title="All 2 branches covered.">        while (eventduration &gt;0) {</span>
<span class="fc" id="L2598">            Collection colActivityDuration = getActivityDurationList(new Integer(index), activityPer15m);</span>
<span class="fc" id="L2599">            int startOffSet = getStartOffSetForEvent(colActivityDuration);</span>
<span class="pc bpc" id="L2600" title="1 of 2 branches missed.">            if ((startOffSet + eventduration) &lt; 15) {</span>
<span class="nc" id="L2601">                colActivityDuration.add(new Pair(event.getActivityID(), new Integer(eventduration)));</span>
<span class="nc" id="L2602">                break;</span>
            } else {
                //startoffset + eventduration &gt;= 15 min
<span class="fc" id="L2605">                colActivityDuration.add(new Pair(event.getActivityID(), new Integer(15-startOffSet)));</span>
<span class="fc" id="L2606">                eventduration -= 15-startOffSet;</span>
<span class="fc" id="L2607">                index++;</span>
            }
<span class="fc" id="L2609">        }</span>
<span class="fc" id="L2610">        return index;</span>
    }

    private int getStartOffSetForEvent(Collection colActivityDuration) {
<span class="pc bpc" id="L2614" title="1 of 2 branches missed.">        if (colActivityDuration.isEmpty())</span>
<span class="fc" id="L2615">            return 0;</span>

<span class="nc" id="L2617">        Iterator i = colActivityDuration.iterator();</span>
<span class="nc" id="L2618">        int offset = 0;</span>
<span class="nc bnc" id="L2619" title="All 2 branches missed.">        while (i.hasNext()) {</span>
<span class="nc" id="L2620">            offset += ((Integer)(((Pair)i.next()).getSecond())).intValue();</span>
        }
<span class="nc" id="L2622">        return offset;</span>
    }

    private Collection getActivityDurationList(int index, HashMap activityPer15m) {
<span class="fc" id="L2626">        Collection colActivityDuration = (Collection)activityPer15m.get(index);</span>
<span class="pc bpc" id="L2627" title="1 of 2 branches missed.">        if (colActivityDuration == null) {</span>
<span class="fc" id="L2628">            colActivityDuration = new ArrayList();</span>
<span class="fc" id="L2629">            activityPer15m.put(index, colActivityDuration);</span>
        }
<span class="fc" id="L2631">        return colActivityDuration;</span>
    }

    // ========== coded by Sameet ===========

    /**
     * Get a map of SPID : &lt;collection of PredictTraceCube&gt;, where the SPID's are the SP assignments for the given
     * employee in the given date range, and the PredictTraceCube's are those that are relevant to the employee's
     * skills (if a skilled SP). If skilled, the PredictTraceCube's will be for various queues (individual and/or combined).
     * @param empID
     * @param start
     * @param end
     * @return a map of SPID -&gt; &lt;collection of PredictTraceCube&gt;
     * @throws BbmFinderException
     */
    private HashMap&lt;ID,Collection&gt; getForecastedStaffingAndFTE(ID empID, Date start, Date end) throws BbmFinderException {
        try {
<span class="fc" id="L2648">            HashMap spTraceCubeMap = new HashMap();</span>
            //Get the emp skills for given the date range
<span class="fc" id="L2650">            ArrayList skillIDs = getEmployeeSkillIDs(empID, start, end);</span>
            //get Campaign-work resource assignments for given the date range
<span class="fc" id="L2652">            Collection&lt;CampaignWorkResource&gt; assignments = m_CampaignManager.getWorkResourceCampaignAssignments(empID, start, end);</span>
<span class="pc bpc" id="L2653" title="2 of 4 branches missed.">            if (assignments == null || assignments.isEmpty()) {</span>
<span class="nc" id="L2654">                return null;   // no point in showing net-staff if user is not associated to any campaign</span>
            }
<span class="fc bfc" id="L2656" title="All 2 branches covered.">            for (Iterator it = assignments.iterator(); it.hasNext();) {</span>
<span class="fc" id="L2657">                CampaignWorkResource ass = (CampaignWorkResource) it.next();</span>
<span class="pc bpc" id="L2658" title="2 of 4 branches missed.">                Collection retCol = getForecastedStaffingAndFTEForSP(ass, skillIDs, start.after(ass.getStartTime()) ? start : ass.getStartTime(), end.before(ass.getEndTime()) ? end : ass.getEndTime());</span>
<span class="fc" id="L2659">                spTraceCubeMap.put(ass.getSPID(), retCol);</span>
<span class="fc" id="L2660">            }</span>
<span class="fc" id="L2661">            return spTraceCubeMap;</span>
<span class="nc" id="L2662">        } catch (Exception e) {</span>
<span class="nc" id="L2663">            handleException(e, false);</span>
<span class="nc" id="L2664">            throw new BbmFinderException(e);</span>
        }
    }

    /**
     * Get a collection of PredictTraceCube's for the SP specified in the CampaignWorkResource argument and the
     * given date range. If a skilled SP, we filter and keep only queues that are relevant to employee Skills.
     * The TraceCube's returned can be for different queues, depending on the skills and the SP.
     * @param ass
     * @param skillIDs
     * @param start
     * @param end
     * @return a collection of PredictTraceCube's. They can be for various queue's within the SP.
     * @throws BbmFinderException
     */
    private Collection getForecastedStaffingAndFTEForSP(CampaignWorkResource ass, ArrayList skillIDs, Date start, Date end) throws BbmFinderException {
        try {
            //get the queues that are relevant to emp skills for the campaigns
<span class="fc" id="L2682">            HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="fc" id="L2683">            Collection returnCol = new ArrayList();</span>
<span class="pc bpc" id="L2684" title="1 of 2 branches missed.">            if (!spSkillMap.containsKey(ass.getSPID())) {</span>
<span class="fc" id="L2685">                spSkillMap.putAll(getSPSkillMap(ass.getCampaignID(), start, end));</span>
            }
<span class="fc" id="L2687">            boolean isSKillSP = spSkillMap.get(ass.getSPID());</span>
<span class="fc" id="L2688">            Collection&lt;SPQueue&gt; spQueues = m_CampaignManager.getSPQueuesBySPID(ass.getSPID());</span>
<span class="fc" id="L2689">            Campaign camp = m_CampaignManager.getCampaignByID(ass.getCampaignID());</span>
<span class="fc" id="L2690">            Set&lt;ID&gt; mediaIDSet = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L2691">            Set&lt;ID&gt; qIDSet = new HashSet&lt;ID&gt;();</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">            for (SPQueue spqueue : spQueues) {</span>
                //Filter and keep only queues that are relevant to employee Skills.
<span class="pc bpc" id="L2694" title="1 of 2 branches missed.">                if (skillIDs.containsAll(spqueue.getSkills())) {</span>
<span class="fc" id="L2695">                    mediaIDSet.add(spqueue.getMediaID());</span>
<span class="fc" id="L2696">                    qIDSet.add(spqueue.getQueueID());</span>
                }
<span class="fc" id="L2698">            }</span>
<span class="pc bpc" id="L2699" title="5 of 6 branches missed.">            if (isSKillSP &amp;&amp; (mediaIDSet != null &amp;&amp; !mediaIDSet.isEmpty())) {</span>
<span class="nc bnc" id="L2700" title="All 2 branches missed.">                for (Iterator&lt;ID&gt; iterator = mediaIDSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L2701">                    ID mediaID = iterator.next();</span>
                    //This gets combined queue for a given media and underlying indvl queues as well.
<span class="nc" id="L2703">                    Collection&lt;TraceCube&gt; predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, camp.getID(), mediaID, start, end);</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">                    for (Iterator&lt;TraceCube&gt; iterator1 = predictCubeData.iterator(); iterator1.hasNext();) {</span>
<span class="nc" id="L2705">                        PredictTraceCube pCube = (PredictTraceCube) iterator1.next();</span>
<span class="nc bnc" id="L2706" title="All 6 branches missed.">                        if ((pCube.getQueueID() != null &amp;&amp; pCube.getQueueID().toInt() == -1) || qIDSet.contains(pCube.getQueueID())) {</span>
<span class="nc" id="L2707">                            returnCol.add(pCube);</span>
                        }
<span class="nc" id="L2709">                    }</span>
<span class="nc" id="L2710">                }</span>
                //Only add Comb-Comb queue
<span class="nc" id="L2712">                addPredictedTraceCubes(returnCol, camp, null, start, end);</span>
            }
            //only add Combined-media queue if it is unskilled queue.
<span class="pc bpc" id="L2715" title="1 of 2 branches missed.">            if (!isSKillSP) {</span>
<span class="fc" id="L2716">            	addPredictedTraceCubes(returnCol, camp, Media.MEDIA_ID_PHONE, start, end);</span>
            }
<span class="fc" id="L2718">            return returnCol;</span>
<span class="nc" id="L2719">        } catch (Exception e) {</span>
<span class="nc" id="L2720">            handleException(e, false);</span>
<span class="nc" id="L2721">            throw new BbmFinderException(e);</span>
        }
    }
    
    private void addPredictedTraceCubes(Collection returnCol, Campaign camp, ID mediaID, Date start, Date end)
    	    throws BbmFinderException
    	  {
<span class="fc" id="L2728">    		Collection&lt;TraceCube&gt; predictCubeData = getRawCombinedQueuesTimeSeries(predictMetaTCNetStaff, camp.getID(), mediaID, start, end);</span>
    	    
<span class="pc bpc" id="L2730" title="1 of 2 branches missed.">    	    if (predictCubeData != null)</span>
<span class="fc bfc" id="L2731" title="All 2 branches covered.">    	      for (TraceCube pCube : predictCubeData) {</span>
    	    	 
<span class="pc bpc" id="L2733" title="1 of 4 branches missed.">    	    	  if ((pCube.getQueueID() != null) &amp;&amp; (pCube.getQueueID().toInt() == -1)) {</span>
<span class="fc" id="L2734">    	    		  returnCol.add(pCube);  </span>
    	    	  }
<span class="fc" id="L2736">        }</span>
<span class="fc" id="L2737">    }</span>

    /**
     * Get the SPIDS to recalc based on Changes to Forecasted data ( checks Time of change of Forecasted data
     * with Predicted Data to decide which SPs need recalc. Only checks for SPs that falls in the date range
     * from today to (Today + lookfwdDays)
     * Also returns  SPIDS that have any scheduling activity for the same range
     * @param lookfwdDays
     * @return
     * @throws BbmFinderException
     * @throws RemoteException
     */
    public Set getSPIDsToReCalc(int lookfwdDays, Date lastRunTime) throws BbmFinderException {
        try {
<span class="nc" id="L2751">            return TimeSeriesDAO.getSPIDsToReCalc(lookfwdDays, lastRunTime);</span>
<span class="nc" id="L2752">        } catch (Exception e) {</span>
<span class="nc" id="L2753">            handleException(e, false);</span>
<span class="nc" id="L2754">            throw new BbmFinderException(e);</span>
        }
    }

    /**
     * Checks if Forecasted staffing &amp; FTE exists for the given time range for the said employee
     *
     * @param empID
     * @param start
     * @param end
     * @return
     * @throws BbmFinderException
     */

    public boolean doesStaffingExistForPeriod(ID empID, Date start, Date end) throws BbmFinderException {
        try {
<span class="fc" id="L2770">            return TimeSeriesDAO.doesStaffingExistForPeriod(empID, start, end);</span>
<span class="nc" id="L2771">        } catch (Exception e) {</span>
<span class="nc" id="L2772">            handleException(e, false);</span>
<span class="nc" id="L2773">            throw new BbmFinderException(e);</span>
        }
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>