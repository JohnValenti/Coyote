<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftSwapRequestUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">ShiftSwapRequestUtil.java</span></div><h1>ShiftSwapRequestUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Aug 20, 2003
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.util;

import java.rmi.RemoteException;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.UnavailabilityEvent;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.ejb.Timeline;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.swap.request.ejb.ShiftSwapRequestDAO;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftSwapValidationCache;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.ejb.ShiftSwapItemDAO;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.swap.CachedResultScheduleReaderWriterImpl;
import com.bluepumpkin.ejb.rm.util.swap.ScheduleReaderWriter;
import com.bluepumpkin.ejb.rm.util.swap.SwapResult;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * @author rrajendran
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
<span class="nc" id="L69">public class ShiftSwapRequestUtil {</span>
<span class="nc" id="L70">	private static Category m_cat = Log.initCategory(ShiftSwapRequestUtil.class.getName());</span>

<span class="nc" id="L72">	private static String m_className = ShiftSwapRequestUtil.class.getName();</span>

	public static Collection getCampWorkResAssnsForSSItem(ShiftSwapItem ssItem)
			throws Exception
	{
<span class="nc" id="L77">		return RequestUtil.getCampaignAssnsForWorkResDuringPeriod(ssItem.getEmployeeID(), ssItem.getStartDate(),</span>
<span class="nc" id="L78">				ssItem.getEndDate());</span>
	}

	/**
	 * Given an agent, get a list of agents he/she can swap with
	 *
	 * @param employeeID
	 * @return A Pair. First element == employee ID set; Second Element == employee List
	 * @throws Exception
	 */
	public static Pair getEmployeesOneCanSwapWith(ID empID, Date effectiveDate) throws Exception
	{
<span class="nc" id="L90">		List swappableOrgIDs = getSwappableOrgIDsForEmp(empID, effectiveDate);</span>
<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (swappableOrgIDs.isEmpty()) {</span>
<span class="nc" id="L92">			return new Pair(Collections.emptySet(), Collections.emptyList());</span>
		}

		// Obtain employees for each swappable organization.
		// for each swappable organization in list
<span class="nc" id="L97">		Collection employees = new ArrayList(100);</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		for (Iterator itr = swappableOrgIDs.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L99">			employees.addAll(RequestUtil.getEmployeesInOrganization((ID) itr.next(), false, effectiveDate, effectiveDate));</span>
		}

<span class="nc" id="L102">		HashSet empIDsSet = new HashSet(100);</span>
<span class="nc" id="L103">		ArrayList empList = new ArrayList(100);</span>
		// for each employee in collection
<span class="nc bnc" id="L105" title="All 2 branches missed.">		for (Iterator itr = employees.iterator(); itr.hasNext();) {</span>
			// get employee
<span class="nc" id="L107">			Employee emp = (Employee) itr.next();</span>

			// do not add employee we are filtering for
<span class="nc bnc" id="L110" title="All 2 branches missed.">			if (emp.getID().equals(empID)) {</span>
<span class="nc" id="L111">				continue;</span>
			}

			// add if employee doesn't exist in map.
<span class="nc bnc" id="L115" title="All 2 branches missed.">			if (!empIDsSet.contains(emp.getID())) {</span>
<span class="nc" id="L116">				empIDsSet.add(emp.getID());</span>
<span class="nc" id="L117">				empList.add(emp);</span>
			}
<span class="nc" id="L119">		}</span>

<span class="nc" id="L121">		return new Pair(empIDsSet, empList);</span>
	}

	/**
	 * &lt;p&gt; Obtain the ShiftAssignment, for the given ShiftSwapItem, from either the published or unpublished
	 * schedule.
	 *
	 * &lt;p&gt;
	 * &lt;li&gt;If no shift assignment is found, returns null.
	 * &lt;li&gt;If a shift assignment is found either returns it or returns 'null' ( for the case when SA is not aligned and parameter 'aligned' == true).
	 * &lt;li&gt;if more than one shift assignments are found, exception is raised.
	 * &lt;li&gt;if ShiftSwapItem is of type &quot;timeoff&quot;, returns null.
	 *
	 * @param ssItem
	 * @param published
	 * @param aligned Must shift be aligned with or in the same org day as the passed shift item?
	 * @param sam
	 * @return null or ShiftAssignment (see above).
	 * @throws RmException
	 * @throws BbmFinderException
	 * @throws BbmEJBCreateException
	 * @throws RemoteException
	 */
	public static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, boolean published,
			boolean aligned, ScheduleAccessManager sam, ShiftSwapValidationCache ssCache) throws Exception
	{
<span class="nc" id="L147">		return getShiftAssignForSSItem(ssItem, published, aligned, false, sam, ssCache);</span>
	}

	/**
	 * &lt;p&gt; Obtain the ShiftAssignment, for the given ShiftSwapItem, from either the published or unpublished
	 * schedule.
	 *
	 * &lt;p&gt;
	 * &lt;li&gt;If no shift assignment is found, returns null.
	 * &lt;li&gt;if more than one shift assignments are found, exception is raised.
	 *
	 * @param ssItem
	 * @param sam
	 * @param ssCache
	 * @param published
	 * @param aligned Must shift be aligned with or in the same org day as the passed shift item?
	 * @return null or ShiftAssignment (see above).
	 * @throws RmException
	 * @throws BbmFinderException
	 * @throws BbmEJBCreateException
	 * @throws RemoteException
	 */
	public static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache, boolean published,
			boolean aligned) throws Exception {
<span class="nc" id="L172">		return getShiftAssignForSSItem(ssItem, sam, ssCache, published, aligned, false, false);</span>
	}

	//Silk 80581
	//QA46082 - To consider only the shifts that start on the org day for comparision
	//The below method is added to ignore the shifts that don't start on the org day
	/**
	 * &lt;p&gt; Obtain the ShiftAssignment, for the given ShiftSwapItem, from either the published or unpublished
	 * schedule.
	 *
	 * &lt;p&gt;
	 * &lt;li&gt;If no shift assignment is found, returns null.
	 * &lt;li&gt;If a shift assignment is found either returns it or returns 'null' ( for the case when SA is not aligned and parameter 'aligned' == true).
	 * &lt;li&gt;if more than one shift assignments are found, exception is raised.
	 * &lt;li&gt;if ShiftSwapItem is of type &quot;timeoff&quot;, returns null.
	 *
	 * @param ssItem
	 * @param published
	 * @param aligned Must shift be aligned with or in the same org day as the passed shift item?
	 * @param shiftsToStartInsideBoundary if shifts returned should have starttimewithin starttime and end time
	 * @param keepOverlaps true if overlapping shifts from previous org day should be returned
	 * @param sam
	 * @return null or ShiftAssignment (see above).
	 * @throws RmException
	 * @throws BbmFinderException
	 * @throws BbmEJBCreateException
	 * @throws RemoteException
	 */
	public static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, boolean published,
			boolean aligned, boolean shiftsToStartInsideBoundary, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache) throws Exception {
		//Always enforce the a check to see if the shiftswap item is of type Shift; we do not want to return wshift for Time-off item.
<span class="nc" id="L204">		return getShiftAssignForSSItem(ssItem, published, aligned, shiftsToStartInsideBoundary, false, sam, ssCache, true);</span>
	}

	public static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, boolean published,
			boolean aligned, boolean shiftsToStartInsideBoundary, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache, boolean ssItemShiftChk) throws Exception {
		//Always enforce the a check to see if the shiftswap item is of type Shift; we do not want to return wshift for Time-off item.
<span class="nc" id="L211">		return getShiftAssignForSSItem(ssItem, published, aligned, shiftsToStartInsideBoundary, false, sam, ssCache, ssItemShiftChk);</span>
	}

	protected static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, boolean published,
			boolean aligned, boolean shiftsToStartInsideBoundary, boolean keepOverlaps, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache) throws Exception {
		//Always enforce the a check to see if the shiftswap item is of type Shift; we do not want to return wshift for Time-off item.
<span class="nc" id="L218">		return getShiftAssignForSSItem(ssItem, published, aligned, shiftsToStartInsideBoundary, keepOverlaps, sam, ssCache, false);</span>
	}

	protected static TimeRange getOrgDayBoundary(ShiftSwapItem ssItem, ShiftSwapValidationCache ssCache) throws Exception{
<span class="nc" id="L222">		Date startDate = ssItem.getStartDate();</span>
<span class="nc" id="L223">		Date endDate = ssItem.getEndDate();</span>

		// get the organization for the employee associated with SSItem.
<span class="nc" id="L226">		Organization org = null;</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">		if (ssCache != null) {</span>
<span class="nc" id="L228">			org = ssCache.getOrganizationForEmployeeDuringPeriod(ssItem.getEmployeeID(),</span>
					startDate, endDate);
		} else {
<span class="nc" id="L231">			org = ValidationUtil.getOrganizationForEmployeeDuringPeriod(ssItem.getEmployeeID(),</span>
					startDate, endDate);
		}

		// set startDate and endDate to org day start and end.
<span class="nc" id="L236">		startDate = TOCalcUtil.getDateForOrgDayStart(org, startDate);</span>
<span class="nc" id="L237">		endDate = TOCalcUtil.getDateForOrgDayEnd(org, startDate);</span>

<span class="nc" id="L239">		return new TimeRange(startDate,endDate);</span>
	}

	//QC87812 need to compare the end date of the SSItem being kept with the start date of the new shift assignment
	// to control whether to keep shifts from prev org day if they overlap
	protected static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, boolean published, boolean aligned,
			boolean shiftsToStartInsideBoundary, boolean keepOverlaps,
			ScheduleAccessManager sam, ShiftSwapValidationCache ssCache, boolean ssItemShiftChk)
			throws Exception {
		// Check this only if ssItemShiftChk=true; if SSItem.swapItemType != ShiftSwapItem.SWAPITEMTYPE_SHIFT
		//We want to also get a shift that aligns with Time-off for a tentatively approved request that needs to be approved.
		//Sameet Sept 2010 ; QC 57873
<span class="nc bnc" id="L251" title="All 4 branches missed.">		if (ssItemShiftChk &amp;&amp; !ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L252">			return null;</span>
		}

<span class="nc" id="L255">		Date startDate = ssItem.getStartDate();</span>
<span class="nc" id="L256">		Date endDate = ssItem.getEndDate();</span>
		// if searching for shifts on the same org day as ssItem and not aligned with ssItem
<span class="nc bnc" id="L258" title="All 2 branches missed.">		if (!aligned) {</span>
<span class="nc" id="L259">			TimeRange t = getOrgDayBoundary(ssItem,ssCache);</span>
<span class="nc" id="L260">			startDate=t.getStartDate();</span>
<span class="nc" id="L261">			endDate=t.getEndDate();</span>
		}

		// get the employee ID
<span class="nc" id="L265">		ID empID = ssItem.getEmployeeID();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

		// search in the published schedule.
		@SuppressWarnings(&quot;rawtypes&quot;)
<span class="nc" id="L270">		Collection shiftAssignments = null;</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">		if (published) {</span>
<span class="nc" id="L272">			shiftAssignments = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
					empID, startDate, endDate);
		} else {
<span class="nc" id="L275">			shiftAssignments = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
					empID, startDate, endDate);
		}

		// if none found, return null
<span class="nc bnc" id="L280" title="All 2 branches missed.">		if (shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L281">			return null;</span>
		}

		//Silk 80581
		//QA46082: - To consider only the shifts that start on the org day for comparision
		// if the shiftsToStartInsideBoundary flag is set and there is shift assignment
		//then we call getIsTwoOrMoreShiftStartsBetweenRange to clear the shifts that don't
		//start between start and end time
		//if shiftassignments are more than one, the existing code flow already handles
		// the shifts that don't start between start and end time
		//QC87812: remove shifts from prev org day, unless they overlap with ssItem if incOverlapFromPrevDay is true

		//QC172250 Port forward of QC 168199
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (shiftsToStartInsideBoundary) {</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">			if (!aligned) {</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">				if (keepOverlaps) {</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">					if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L298">						getIsTwoOrMoreShiftStartsBetweenRange(shiftAssignments, ssItem.getStartDate(),</span>
								startDate, endDate, true);
					} else {
<span class="nc" id="L301">						getClosestShiftMatchForOneWayShiftSwap(ssItem, shiftAssignments, startDate, endDate);</span>
					}
				} else {
<span class="nc bnc" id="L304" title="All 2 branches missed.">					if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L305">						getIsTwoOrMoreShiftStartsBetweenRange(shiftAssignments,</span>
								null, startDate, endDate, true);
					} else {
<span class="nc" id="L308">						getClosestShiftMatchForOneWayShiftSwap(ssItem, shiftAssignments, startDate, endDate);</span>
					}
				}
			} else {
<span class="nc" id="L312">				retainShiftsWhichOverlapsWithSSItemStartDate(ssItem,</span>
						shiftAssignments);
			}
		}
<span class="nc bnc" id="L316" title="All 2 branches missed.">		if (shiftAssignments.size() &gt; 1) {</span>
<span class="nc" id="L317">			retainShiftsWhichOverlapsWithSSItemStartDate(ssItem, shiftAssignments);</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">			if (shiftAssignments.size() &gt; 1) {</span>

<span class="nc" id="L320">				throw RequestUtil.createRmHardValidationException(</span>
						RmEjbBundleKey.SS_MULTIPLESHIFTS_FOR_SSITEM, startDate,
<span class="nc" id="L322">						endDate, ssCache.getEmployeeNameByID(ssItem.getEmployeeID()), m_cat);</span>
			}
		}

		// if none found, return null
<span class="nc bnc" id="L327" title="All 2 branches missed.">		if (shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L328">			return null;</span>
		}

		// retrieve first shift assignment from collection
<span class="nc" id="L332">		ShiftAssignment shiftAssign = (ShiftAssignment) shiftAssignments.iterator().next();</span>


		// if shift is to be alighed with ssItem, verify that shift hasn't moved.
<span class="nc bnc" id="L336" title="All 4 branches missed.">		if (aligned &amp;&amp; (!shiftAssign.getStartTime().equals(startDate) ||</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">				!shiftAssign.getEndTime().equals(endDate))) {</span>

			// LOCAL: Shift between {0,date} and {1,date}, for employee ID {3}, is not aligned with its associated shift swap item ID {2}.
			//
			// log the misaligned shift.
<span class="nc" id="L342">			m_cat.l7dDebug(RmEjbLogBundleKey.SS_SHIFT_NOTALIGNED_WITH_SSITEM,</span>
					new Object[] {
<span class="nc" id="L344">							startDate, endDate, empID, ssItem.getID() });</span>

<span class="nc" id="L346">			return null;</span>
		}

<span class="nc" id="L349">		return shiftAssign;</span>
	}

	protected static ShiftAssignment getShiftAssignForSSItem(ShiftSwapItem ssItem, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache,
			boolean published, boolean aligned, boolean shiftsToStartInsideBoundary,
			boolean keepOverlaps) throws Exception {
<span class="nc" id="L356">		Date startDate = ssItem.getStartDate();</span>
<span class="nc" id="L357">		Date endDate = ssItem.getEndDate();</span>
		// if searching for shifts on the same org day as ssItem and not aligned with ssItem
<span class="nc bnc" id="L359" title="All 2 branches missed.">		if (!aligned) {</span>
			// get the organization for the employee associated with SSItem.
<span class="nc" id="L361">			Organization org = null;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">			if (ssCache != null) {</span>
<span class="nc" id="L363">				org = ssCache.getOrganizationForEmployeeDuringPeriod(ssItem.getEmployeeID(),</span>
						startDate, endDate);
			} else {
<span class="nc" id="L366">				org = ValidationUtil.getOrganizationForEmployeeDuringPeriod(ssItem.getEmployeeID(),</span>
						startDate, endDate);
			}

			// set startDate and endDate to org day start and end.
<span class="nc" id="L371">			startDate = TOCalcUtil.getDateForOrgDayStart(org, startDate);</span>
<span class="nc" id="L372">			endDate = TOCalcUtil.getDateForOrgDayEnd(org, startDate);</span>
		}

		// get the employee ID
<span class="nc" id="L376">		ID empID = ssItem.getEmployeeID();</span>
<span class="nc bnc" id="L377" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

		// search in the published schedule.
<span class="nc" id="L380">		Collection shiftAssignments = null;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">		if (published) {</span>
<span class="nc" id="L382">			shiftAssignments = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
					empID, startDate, endDate);
		} else {
<span class="nc" id="L385">			shiftAssignments = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT,</span>
					empID, startDate, endDate);
		}

		// if none found, return null
<span class="nc bnc" id="L390" title="All 2 branches missed.">		if (shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L391">			return null;</span>
		}

		//Silk 80581
		//QA46082: - To consider only the shifts that start on the org day for comparision
		// if the shiftsToStartInsideBoundary flag is set and there is shift assignment
		//then we call getIsTwoOrMoreShiftStartsBetweenRange to clear the shifts that don't
		//start between start and end time
		//if shiftassignments are more than one, the existing code flow already handles
		// the shifts that don't start between start and end time
		//QC87812: remove shifts from prev org day, unless they overlap with ssItem if incOverlapFromPrevDay is true
<span class="nc bnc" id="L402" title="All 4 branches missed.">		if (shiftsToStartInsideBoundary &amp;&amp; shiftAssignments.size() == 1) {</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">			if (keepOverlaps) {</span>
<span class="nc bnc" id="L404" title="All 2 branches missed.">				if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L405">					getIsTwoOrMoreShiftStartsBetweenRange(shiftAssignments, ssItem.getStartDate(), startDate, endDate, true);</span>
				} else {
<span class="nc" id="L407">					getClosestShiftMatchForOneWayShiftSwap(ssItem, shiftAssignments, startDate, endDate);</span>
				}
			} else {
<span class="nc bnc" id="L410" title="All 2 branches missed.">				if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L411">					getIsTwoOrMoreShiftStartsBetweenRange(shiftAssignments, null, startDate, endDate, true);</span>
				} else {
<span class="nc" id="L413">					getClosestShiftMatchForOneWayShiftSwap(ssItem, shiftAssignments, startDate, endDate);</span>
				}
			}
		}
		else // A given org day can never have more than 1 shift starting on the org day; still checking just in case.
<span class="nc bnc" id="L418" title="All 2 branches missed.">		if (shiftAssignments.size() &gt; 1) {</span>
<span class="nc" id="L419">			retainShiftsWhichOverlapsWithSSItemStartDate(ssItem, shiftAssignments);</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">			if (shiftAssignments.size() &gt; 1) {</span>
				// LOCAL: More than one shift found between {1,date} and {2,date} for employee {0} .
<span class="nc" id="L423">				throw RequestUtil.createRmHardValidationException(</span>
						RmEjbBundleKey.SS_MULTIPLESHIFTS_FOR_SSITEM, startDate, endDate, empID, m_cat);
			}
		}

		// if none found, return null
<span class="nc bnc" id="L429" title="All 2 branches missed.">		if (shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L430">			return null;</span>
		}

		// retrieve first shift assignment from collection
<span class="nc" id="L434">		ShiftAssignment shiftAssign = (ShiftAssignment) shiftAssignments.iterator().next();</span>

<span class="nc" id="L436">		return shiftAssign;</span>
	}

	/**
	 * Only retain the Shift which overlaps with the ShiftSwapItem Start Time
	 * @param ssItem
	 * @param shiftAssignments
	 */
	private static void retainShiftsWhichOverlapsWithSSItemStartDate(ShiftSwapItem ssItem, Collection&lt;ShiftAssignment&gt; shiftAssignments) {

<span class="nc bnc" id="L446" title="All 2 branches missed.">		for (Iterator&lt;ShiftAssignment&gt; iter = shiftAssignments.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L447">			ShiftAssignment sa = iter.next();</span>
			
			// This sa should be removed
			// sa 10pm - 7am
			// ssitem start 7 am
			// Previous code failed to do this. End date was inclusive. It should be exclusive.
<span class="nc bnc" id="L453" title="All 2 branches missed.">			if (!DateUtil.isInRange(sa.getStartTime(), sa.getEndTime(), ssItem.getStartDate())){</span>
<span class="nc" id="L454">				iter.remove();</span>
			}
<span class="nc" id="L456">		}</span>
<span class="nc" id="L457">	}</span>

	/**
	 * Checks if all shiftAssigns start within the given date range (inclusive of boundaries).
	 *
	 * @param shiftAssignments
	 * @param ssItemStartDate If not null, do not remove a ShiftAssignment from prev org day if it overlaps with ssItem.
	 * @param startDate
	 * @param endDate
	 * @param removeNonStarts if 'true', then SAs that donot start between the given range will be
	 * removed.  Otherwise passed SAs collection is not modified.
	 * @return true if none of the SAs start outside the given range.  false if any of the SAs start
	 * outside the given range.
	 */
	private static boolean getIsTwoOrMoreShiftStartsBetweenRange(Collection shiftAssns, Date ssItemStartDate,
			Date startDate, Date endDate, boolean removeNonStarts) {

<span class="nc" id="L474">		int origSize = shiftAssns.size();</span>
		// Number of shifts that start between the given time range.
<span class="nc" id="L476">		int numOfShiftStarts = 0;</span>
		// iterate thru the given list of shift assignments
<span class="nc bnc" id="L478" title="All 2 branches missed.">		for (Iterator iter = shiftAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L479">			ShiftAssignment sa = (ShiftAssignment) iter.next();</span>

			// if shift does not start between the given range, remove from list.
			// QC87812 don't remove from list if it will be combined with overlap
<span class="nc bnc" id="L483" title="All 4 branches missed.">			boolean removeShift = ssItemStartDate == null ? true : !ssItemStartDate.before(sa.getEndTime());</span>
<span class="nc bnc" id="L484" title="All 4 branches missed.">			if (!TOCalcUtil.dateBetween(sa.getStartTime(), startDate, endDate) &amp;&amp; removeShift) {</span>
				// if 'removeNonStarts' flag is set, then remove 'non starting' ones.
<span class="nc bnc" id="L486" title="All 2 branches missed.">				if (removeNonStarts) {</span>
<span class="nc" id="L487">					iter.remove();</span>
				}
			} else {
<span class="nc" id="L490">				numOfShiftStarts++;</span>
			}
<span class="nc" id="L492">		}</span>

		// true, if no elements were removed; false if any were removed.
<span class="nc bnc" id="L495" title="All 2 branches missed.">		return (numOfShiftStarts &gt;= 2) ? true : false;</span>
	}
	
	/**
	 * Selects the shift that closest aligns with the One Way Shift Swap 
	 * 
	 * @param ssItem Requested One Way Shif Swap Item
	 * @param shiftAssns Collection of Shift Assignments
	 * @param startDate Date shifts should start after
	 * @param endDate Date shifts should end before
	 */
	private static void getClosestShiftMatchForOneWayShiftSwap(ShiftSwapItem ssItem, Collection shiftAssns, 
			Date startDate, Date endDate) {
		
<span class="nc" id="L509">		long difference = Long.MAX_VALUE;</span>
<span class="nc" id="L510">		ShiftAssignment chosenShift = null;</span>
<span class="nc" id="L511">		boolean foundAShiftWithinOrgDay = false;</span>
		
		// Cycle through the Shifts and slect the Shift that aligns closest
		// to the Shift Swap Item
<span class="nc bnc" id="L515" title="All 2 branches missed.">		for (ShiftAssignment sa: (Collection&lt;ShiftAssignment&gt;)shiftAssns) {</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">			if (TOCalcUtil.dateBetween(sa.getStartTime(), startDate, endDate)) {</span>
<span class="nc" id="L517">				foundAShiftWithinOrgDay = true;</span>
			}
			
<span class="nc bnc" id="L520" title="All 2 branches missed.">			if (sa.getStartTime().getTime() &gt;= ssItem.getEndDate().getTime()) {</span>
<span class="nc" id="L521">				long diff = sa.getStartTime().getTime() - ssItem.getEndDate().getTime();</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">				if (diff &lt; difference) {</span>
<span class="nc" id="L523">					difference = diff;</span>
<span class="nc" id="L524">					chosenShift = sa;</span>
				}
			}
			
<span class="nc bnc" id="L528" title="All 2 branches missed.">			if (sa.getEndTime().getTime() &lt;= ssItem.getStartDate().getTime()) {</span>
<span class="nc" id="L529">				long diff = ssItem.getStartDate().getTime() - sa.getEndTime().getTime();</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">				if (diff &lt; difference) {</span>
<span class="nc" id="L531">					difference = diff;</span>
<span class="nc" id="L532">					chosenShift = sa;</span>
				}
			}
<span class="nc" id="L535">		}</span>
		
		// Clear collection and add Selected Shift Assignment 
<span class="nc bnc" id="L538" title="All 2 branches missed.">		if (chosenShift != null) {</span>
<span class="nc" id="L539">			shiftAssns.clear();</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">			if (foundAShiftWithinOrgDay) {</span>
<span class="nc" id="L541">				shiftAssns.add(chosenShift);</span>
			}
		}
<span class="nc" id="L544">	}</span>
	

	/**
	 * @see ShiftSwapRequestUtil#getShiftAssignForSSItem(ShiftSwapItem, boolean, boolean, ScheduleAccessManager, ShiftSwapValidationCache)
	 */
	public static ShiftAssignment getShiftAssignForSSItemAligned(ShiftSwapItem ssItem,
			boolean published, ScheduleAccessManager sam, ShiftSwapValidationCache ssCache) throws Exception
	{
<span class="nc" id="L553">		return getShiftAssignForSSItem(ssItem, published, true, sam, ssCache);</span>
	}

	/**
	 * @see ShiftSwapRequestUtil#getShiftAssignForSSItem(ShiftSwapItem, boolean, boolean, ScheduleAccessManager, ShiftSwapValidationCache)
	 */
	public static ShiftAssignment getShiftAssignForSSItemSameOrgDay(ShiftSwapItem ssItem,
			boolean published, boolean shiftsToStartInsideBoundary, ScheduleAccessManager sam, ShiftSwapValidationCache ssCache)
			throws Exception {
		//This ends up calling getShiftAssignForSSItem with both  aligned and keepOverlaps set to false.
<span class="nc" id="L563">		boolean keepOverlaps = false;</span>
<span class="nc" id="L564">		return getShiftAssignForSSItemSameOrgDay(ssItem, published, shiftsToStartInsideBoundary, keepOverlaps, sam, ssCache);</span>
	}

	private static ShiftAssignment getShiftAssignNonAligned(ShiftSwapItem ssItem,
			boolean published, boolean shiftsToStartInsideBoundary, ScheduleAccessManager sam, ShiftSwapValidationCache ssCache)
			throws Exception {
		//This ends up calling getShiftAssignForSSItem with  aligned set to false and keepOverlaps  set to true.
<span class="nc" id="L571">		boolean keepOverlaps = true;</span>
<span class="nc" id="L572">		return getShiftAssignForSSItemSameOrgDay(ssItem, published, shiftsToStartInsideBoundary, keepOverlaps, sam, ssCache);</span>
	}

	public static ShiftAssignment getShiftAssignForSSItemSameOrgDay(ShiftSwapItem ssItem, boolean published,
			boolean shiftsToStartInsideBoundary,
			boolean keepOverlaps, ScheduleAccessManager sam, ShiftSwapValidationCache ssCache) throws Exception {
<span class="nc" id="L578">		return getShiftAssignForSSItem(ssItem, published, false, shiftsToStartInsideBoundary, keepOverlaps, sam, ssCache);</span>
	}

	public static ShiftAssignment[] getShiftAssignsForReq(ShiftSwapRequest ssr, boolean published,
			boolean aligned, ScheduleAccessManager sam) throws Exception {
<span class="nc bnc" id="L583" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

<span class="nc" id="L585">		List ssItems = ssr.getShiftSwapItems();</span>

<span class="nc" id="L587">		ShiftAssignment[] shiftAssigns = new ShiftAssignment[2];</span>

<span class="nc bnc" id="L589" title="All 2 branches missed.">		if (aligned) {</span>
<span class="nc" id="L590">			shiftAssigns[0] = getShiftAssignForSSItemAligned((ShiftSwapItem) ssItems.get(0), published, sam, ssr.getCache());</span>
<span class="nc" id="L591">			shiftAssigns[1] = getShiftAssignForSSItemAligned((ShiftSwapItem) ssItems.get(1), published, sam, ssr.getCache());</span>
		} else {
<span class="nc" id="L593">			shiftAssigns[0] = getShiftAssignNonAligned((ShiftSwapItem) ssItems.get(0), published, false, sam, ssr.getCache());</span>
<span class="nc" id="L594">			shiftAssigns[1] = getShiftAssignNonAligned((ShiftSwapItem) ssItems.get(1), published, false, sam, ssr.getCache());</span>
		}

<span class="nc" id="L597">		return shiftAssigns;</span>
	}

	public static ShiftAssignment[] getShiftAssignsForReqAligned(ShiftSwapRequest ssr, boolean published,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L603">		return getShiftAssignsForReq(ssr, published, true, sam);</span>
	}

	public static ShiftAssignment[] getShiftAssignsForReqSameOrgDay(ShiftSwapRequest ssr, boolean published,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L609">		return getShiftAssignsForReq(ssr, published, false, sam);</span>
	}

	/**
	 * Returns an array of shift assignments for the given shift swap request after the swap is
	 * completed (request must be a tentatively or permanently approved request).  The
	 * ShiftAssignment at index 'i' corresponds to the ShiftSwapItem at index i in the SSRequest
	 * (start and end time of the shiftAssignment and shiftSwapItem are equal) but the employeeIDs
	 * in the ShiftAssignment and ShiftSwapItem are different to reflect the swap (ShiftSwapItem
	 * employee ID == emp swapping out; ShiftAssignment's employee ID == employee receiving shift)
	 *
	 * @param ssr
	 * @param published
	 * @param aligned
	 * @param shiftsToStartInsideBoundary
	 * @param sam
	 * @return
	 * @throws Exception
	 */
	public static ShiftAssignment[] getSwappedShiftAssignsForReq(ShiftSwapRequest ssr, boolean published,
			boolean aligned, boolean shiftsToStartInsideBoundary, ScheduleAccessManager sam) throws Exception
	{
<span class="nc bnc" id="L631" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

<span class="nc" id="L633">		List ssItems = ssr.getShiftSwapItems();</span>
<span class="nc" id="L634">		ShiftSwapItem origSSItem1 = (ShiftSwapItem) ssItems.get(0);</span>
<span class="nc" id="L635">		ShiftSwapItem origSSItem2 = (ShiftSwapItem) ssItems.get(1);</span>

<span class="nc" id="L637">		ShiftSwapItem swappedSSItem1 = cloneShiftSwapItem(origSSItem1);</span>
<span class="nc" id="L638">		swappedSSItem1.setEmployeeID(origSSItem2.getEmployeeID());</span>

<span class="nc" id="L640">		ShiftSwapItem swappedSSItem2 = cloneShiftSwapItem(origSSItem2);</span>
<span class="nc" id="L641">		swappedSSItem2.setEmployeeID(origSSItem1.getEmployeeID());</span>

<span class="nc" id="L643">		ShiftAssignment[] shiftAssigns = new ShiftAssignment[2];</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">		if (aligned) {</span>
<span class="nc" id="L645">			shiftAssigns[0] = getShiftAssignForSSItemAligned(swappedSSItem1, published, sam, ssr.getCache());</span>
<span class="nc" id="L646">			shiftAssigns[1] = getShiftAssignForSSItemAligned(swappedSSItem2, published, sam, ssr.getCache());</span>
		} else {
<span class="nc" id="L648">			shiftAssigns[0] = getShiftAssignNonAligned(swappedSSItem1, published, shiftsToStartInsideBoundary, sam, ssr.getCache());</span>
<span class="nc" id="L649">			shiftAssigns[1] = getShiftAssignNonAligned(swappedSSItem2, published, shiftsToStartInsideBoundary, sam, ssr.getCache());</span>
		}

<span class="nc" id="L652">		return shiftAssigns;</span>

	}

	public static ShiftAssignment[] getSwappedShiftAssignsForReqAligned(ShiftSwapRequest ssr, boolean published,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L659">		return getSwappedShiftAssignsForReq(ssr, published, true, false, sam);</span>
	}

	public static ShiftAssignment[] getSwappedShiftAssignsForReqSameOrgDay(ShiftSwapRequest ssr, boolean published,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L665">		return getSwappedShiftAssignsForReq(ssr, published, false, false, sam);</span>
	}

	//Silk 80581
	//QA46082 - To consider only the shifts that start on the org day for comparision
	//The below method has the logic to get the shift swap items and obtain the shift assignments
	public static ShiftAssignment[] getSwappedSAForReqWithStartDateOnSameOrgDay(ShiftSwapRequest ssr, boolean published,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L674">		return getSwappedShiftAssignsForReq(ssr, published, false, true, sam);</span>
	}

	public static List getSwappableOrgIDsForEmp(ID employeeID, Date effectiveDate)
			throws Exception
	{
		// Get ORG ID for this employee.
<span class="nc" id="L681">		ID empOrgID = TOCalcUtil.getOrgIDForEmployeeID(employeeID, effectiveDate);</span>

<span class="nc" id="L683">		return getSwappableOrgIDsForOrg(empOrgID);</span>
	}

	public static List&lt;ID&gt; getSwappableOrgIDsForOrg(ID orgID)
			throws Exception {

<span class="nc" id="L689">		OrganizationConfigManager orgCfgMgr = RequestUtil.getOrgConfigMgr(null, null);</span>

		// Check if employee organization settings permit a swap.
		// get the Manager Factory
<span class="nc" id="L693">		OrganizationSetting orgSetting = RequestUtil.getOrgSetting(orgID, orgCfgMgr);</span>

		// if shift swap not enabled for organization, we are done.
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (!orgSetting.getEnableShiftSwap()) {</span>
<span class="nc" id="L697">			return Collections.emptyList();</span>
		}

		// Use organization settings to obtain a list of organizations
		// this employee's organization can swap with.
<span class="nc" id="L702">		String swappableOrgSetting = orgSetting.getShiftSwapOrgListOverride();</span>
<span class="nc" id="L703">		m_cat.debug(&quot;swappableOrgSetting = &quot; + swappableOrgSetting);</span>

<span class="nc" id="L705">		ID[] swappableOrgIDs = StringUtil.parseIDString(swappableOrgSetting);</span>
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (swappableOrgIDs.length == 0) {</span>
<span class="nc" id="L707">			return Collections.emptyList();</span>
		}

<span class="nc" id="L710">		List&lt;ID&gt; filteredSwappableOrgIDs = new ArrayList&lt;&gt;(10);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">		for (int i = 0; i &lt; swappableOrgIDs.length; i++) {</span>
<span class="nc" id="L712">			ID swappableOrgID = swappableOrgIDs[i];</span>

			//check if this organization in the swappable orgList can swap
			//with the given organization.  Only if the swappableOrg can swap
			//with the given org, the swappableOrg is added to the collection of
			//eligible swappable orgs.
<span class="nc bnc" id="L718" title="All 2 branches missed.">			if (canOrg1SwapWithOrg2(swappableOrgID, orgID, orgCfgMgr)) {</span>
<span class="nc" id="L719">				filteredSwappableOrgIDs.add(swappableOrgID);</span>
			}
		}
<span class="nc bnc" id="L722" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L723">			m_cat.debug(&quot;Swappable Org IDs: &quot; + RmUtil.dumpCollection(filteredSwappableOrgIDs));</span>
		}
<span class="nc" id="L725">		return filteredSwappableOrgIDs;</span>
	}

	// The clone() method for ShiftSwapItem is not implemented, instead of this method,
	// as this only does partial cloning.
	public static ShiftSwapItem cloneShiftSwapItem(ShiftSwapItem swapItem)
	{
<span class="nc" id="L732">		ShiftSwapItem newSwapItem = new ShiftSwapItem();</span>

<span class="nc" id="L734">		newSwapItem.setStartDate(swapItem.getStartDate());</span>
<span class="nc" id="L735">		newSwapItem.setEndDate(swapItem.getEndDate());</span>
<span class="nc" id="L736">		newSwapItem.setEmployeeID(swapItem.getEmployeeID());</span>
<span class="nc" id="L737">		newSwapItem.setShiftType(swapItem.getShiftType());</span>
<span class="nc" id="L738">		newSwapItem.setNegotiation(swapItem.getNegotiation());</span>
<span class="nc" id="L739">		newSwapItem.setExpirationDate(swapItem.getExpirationDate());</span>

<span class="nc" id="L741">		return newSwapItem;</span>
	}

	/**
	 * Only does partial cloning.  Not implemented as ShiftSwapRequest.clone() for this reason.
	 *
	 * @param ssReq
	 * @return
	 */
	public static ShiftSwapRequest cloneShiftSwapRequest(ShiftSwapRequest ssReq)
	{
<span class="nc" id="L752">		ShiftSwapRequest newSSReq = new ShiftSwapRequest(RequestAggregate.DL_BASIC);</span>

<span class="nc" id="L754">		newSSReq.setEmployeeID(ssReq.getEmployeeID());</span>
<span class="nc" id="L755">		newSSReq.setExpirationDate(ssReq.getExpirationDate());</span>
<span class="nc" id="L756">		newSSReq.setNegotiationComment(ssReq.getNegotiationComment());</span>
<span class="nc" id="L757">		newSSReq.setRequestStatus(ssReq.getRequestStatus());</span>
<span class="nc" id="L758">		newSSReq.setSwapType(ssReq.getSwapType());</span>

<span class="nc" id="L760">		ArrayList newSSItems = new ArrayList(2);</span>
<span class="nc" id="L761">		newSSItems.add(cloneShiftSwapItem(ssReq.getShiftSwapItems().get(0)));</span>
<span class="nc" id="L762">		newSSItems.add(cloneShiftSwapItem(ssReq.getShiftSwapItems().get(1)));</span>
<span class="nc" id="L763">		newSSReq.setShiftSwapItems(newSSItems);</span>

<span class="nc" id="L765">		return newSSReq;</span>
	}

	public static boolean canOrg1SwapWithOrg2(ID org1, ID org2, OrganizationConfigManager orgCfgMgr)
			throws Exception
	{
<span class="nc" id="L771">		OrganizationSetting orgSetting = CacheUtilRM.getOrgSetting(org1);</span>
		// if shift swap not enabled for organization, we are done.
<span class="nc bnc" id="L773" title="All 2 branches missed.">		if (!orgSetting.getEnableShiftSwap()) {</span>
<span class="nc" id="L774">			return false;</span>
		}

		// Iterate t_hrow the list of organizations this can swap with.
<span class="nc" id="L778">		ID[] swappableOrgIDs = StringUtil.parseIDString(</span>
<span class="nc" id="L779">				orgSetting.getShiftSwapOrgListOverride(), &quot;, \t\n\r\f&quot;);</span>
<span class="nc bnc" id="L780" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L781">			m_cat.debug(RmUtil.dumpCollection(Arrays.asList(swappableOrgIDs)));</span>
		}
<span class="nc bnc" id="L783" title="All 2 branches missed.">		for (int i = 0; i &lt; swappableOrgIDs.length; i++) {</span>
<span class="nc bnc" id="L784" title="All 2 branches missed.">			if (swappableOrgIDs[i].equals(org2)) {</span>
<span class="nc" id="L785">				m_cat.debug(&quot;Orgs match: &quot; + swappableOrgIDs[i] + &quot;==&quot; + org2);</span>
<span class="nc" id="L786">				return true;</span>
			}
		}

<span class="nc" id="L790">		return false;</span>
	}

	/**
	 * undo the swap done for the given shift swap request. Calling this method with a ssReq assumes
	 * that the swap has already been completed.
	 *
	 * Used to roll back schedule changes (unpublished schedule) when request was approved.
	 *
	 * @param ssReq
	 */
	//TESTME undoSwap
	public static ShiftSwapRequest undoSwap(ShiftSwapRequest givenSSReq, boolean save)
			throws Exception
	{
<span class="nc" id="L805">		m_cat.debug(&quot;Undo-ing swap done for SSReq: &quot; + givenSSReq);</span>
		// create a shiftswap request with employee IDs in the items swapped.  After this ID swap,
		// the new request represents an undo of the original approved request.

		// cloning, instead of reusing, as the passed request or its shift swap items must not be modified.
		//
		// create a request to use for the 'undo' operation.  The idea is to setup a new request, with its
		// associated swap items pointing to the 'swapped' shifts.  This request is then passed thru' the
		// 'swapping logic' to undo the swap.
<span class="nc" id="L814">		ShiftSwapRequest undoSSReq = ShiftSwapRequestUtil.cloneShiftSwapRequest(givenSSReq);</span>
<span class="nc" id="L815">		undoSSReq.setWithdrawInfo(givenSSReq.getWithdrawInfo());</span>

<span class="nc" id="L817">		List ssItems = givenSSReq.getShiftSwapItems();</span>

		//TODO; although getShiftSwapItems() returns a list, it does not preserve ordering
		// found when the items were set with setShiftSwapItems().

<span class="nc" id="L822">		ShiftSwapItem givenSSItem0 = (ShiftSwapItem) ssItems.get(0);</span>
<span class="nc" id="L823">		ShiftSwapItem givenSSItem1 = (ShiftSwapItem) ssItems.get(1);</span>

		// move employee ID from 'given item1' to 'undo item0'
<span class="nc" id="L826">		ShiftSwapItem undoSSItem0 = undoSSReq.getShiftSwapItem(givenSSItem0);</span>
<span class="nc" id="L827">		undoSSItem0.setEmployeeID(givenSSItem1.getEmployeeID());</span>
<span class="nc" id="L828">		undoSSItem0.setIsPartial(givenSSItem0.getIsPartial()); //Not copied by clone.</span>
<span class="nc" id="L829">		undoSSItem0.setID(givenSSItem0.getID());</span>

		// move employee ID from 'given item0' to 'undo item1'
<span class="nc" id="L832">		ShiftSwapItem undoSSItem1 = undoSSReq.getShiftSwapItem(givenSSItem1);</span>
<span class="nc" id="L833">		undoSSItem1.setEmployeeID(givenSSItem0.getEmployeeID());</span>
<span class="nc" id="L834">		undoSSItem1.setIsPartial(givenSSItem1.getIsPartial()); //Not copied by clone.</span>
<span class="nc" id="L835">		undoSSItem1.setID(givenSSItem1.getID());</span>

		// now perform the swap that undoes the earlier swap.

<span class="nc bnc" id="L839" title="All 2 branches missed.">		if (save){</span>
<span class="nc" id="L840">			ShiftSwapRequestUtil.performSwapAndSave(undoSSReq, true);</span>
		}
		
<span class="nc" id="L843">		return undoSSReq;</span>
	}

	public static void verifySSRequest(ID reqID) throws Exception
	{
<span class="nc" id="L848">		ShiftSwapRequestDAO ssDAO = null;</span>
		try {
			//verify request exists
<span class="nc" id="L851">			ssDAO = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
<span class="nc" id="L852">			ShiftSwapRequest dbSSReq = (ShiftSwapRequest) ssDAO.getRequestByID(reqID, ShiftSwapRequest.getDetailLevelForValidation());</span>

<span class="nc" id="L854">			RequestUtil.verifyAuditTrailOrdering(dbSSReq);</span>

			// verify expiration date
<span class="nc" id="L857">			List ssItems = dbSSReq.getShiftSwapItems();</span>
<span class="nc" id="L858">			ShiftSwapItem ssItem1 = (ShiftSwapItem) ssItems.get(0);</span>
<span class="nc" id="L859">			Date earliest = RequestUtil.getEarlierDate(ssItem1.getExpirationDate(), ssItem1.getStartDate());</span>

<span class="nc" id="L861">			ShiftSwapItem ssItem2 = (ShiftSwapItem) ssItems.get(1);</span>
<span class="nc" id="L862">			earliest = RequestUtil.getEarlierDate(earliest, ssItem2.getExpirationDate());</span>
<span class="nc" id="L863">			earliest = RequestUtil.getEarlierDate(earliest, ssItem2.getStartDate());</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">			if (!earliest.equals(dbSSReq.getExpirationDate())) {</span>
<span class="nc" id="L865">				throw RequestUtil.createRmException(RmEjbLogBundleKey.INVALID_VALUE3,</span>
<span class="nc" id="L866">						new Long(dbSSReq.getExpirationDate().getTime()), new Long(ssItem1.getExpirationDate().getTime()),</span>
<span class="nc" id="L867">						new Long(ssItem2.getExpirationDate().getTime()), m_cat);</span>
			}

			//verify shifts were swapped (approved or tentatively approved).
<span class="nc" id="L871">			String reqStatus = dbSSReq.getRequestStatus();</span>
<span class="nc bnc" id="L872" title="All 2 branches missed.">			if (reqStatus.equals(RequestAuditTrail.STATUS_APPROVED) ||</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">					reqStatus.equals(RequestAuditTrail.STATUS_TENTATIVE))</span>
			{
<span class="nc bnc" id="L875" title="All 2 branches missed.">				boolean published = reqStatus.equals(RequestAuditTrail.STATUS_APPROVED) ? true : false;</span>

<span class="nc" id="L877">				ShiftAssignment[] swappedShifts = ShiftSwapRequestUtil.getSwappedShiftAssignsForReqAligned(dbSSReq, published, null);</span>
<span class="nc" id="L878">				ShiftAssignment[] origShifts = ShiftSwapRequestUtil.getShiftAssignsForReqSameOrgDay(dbSSReq, published, null);</span>

<span class="nc bnc" id="L880" title="All 2 branches missed.">				if (dbSSReq.getSwapType().equals(ShiftSwapRequest.SHIFTSWAP_TYPE_TWOWAY)) {</span>
<span class="nc bnc" id="L881" title="All 2 branches missed.">					for (int i = 0; i &lt; ssItems.size(); i++) {</span>
<span class="nc" id="L882">						ShiftSwapItem ssItem = (ShiftSwapItem) ssItems.get(i);</span>

<span class="nc bnc" id="L884" title="All 2 branches missed.">						if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
							// verify swapped shift exists
<span class="nc bnc" id="L886" title="All 2 branches missed.">							if (swappedShifts[i] == null) {</span>
<span class="nc" id="L887">								throw RequestUtil.createRmException(RmEjbLogBundleKey.SS_SWAPPED_SHIFT_NOT_FOUND,</span>
<span class="nc" id="L888">										dbSSReq.getID(), ssItem.getID(), m_cat);</span>
							}

							// verify orig shift does not exist
<span class="nc bnc" id="L892" title="All 2 branches missed.">							if (origShifts[i] != null &amp;&amp;</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">									origShifts[i].getStartTime().equals(ssItem.getStartDate()) &amp;&amp;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">									origShifts[i].getEndTime().equals(ssItem.getEndDate())) {</span>
<span class="nc" id="L895">								throw RequestUtil.createRmException(RmEjbLogBundleKey.SS_ORIG_SHIFT_EXISTS,</span>
<span class="nc" id="L896">										new Integer(i + 1), dbSSReq.getID(), ssItem.getID(), swappedShifts[i].getID(), m_cat);</span>
							}
						}
					}
				}
			}

		} finally {
<span class="nc bnc" id="L904" title="All 4 branches missed.">			if (ssDAO != null) {</span>
<span class="nc" id="L905">				ssDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L908">	}</span>

	public static void publishSwap(ShiftSwapRequest ssReq, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L911">		m_cat.debug(&quot;Publishing schedule for ssReq: &quot; + ssReq);</span>

		// find time ranges to publish
<span class="nc" id="L914">		Timeline publishTime = new Timeline();</span>
<span class="nc bnc" id="L915" title="All 2 branches missed.">		for (ShiftSwapItem ssItem : ssReq.getShiftSwapItems()) {</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">			if (ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L917">				publishTime = publishTime.join(Timeline.newInstance(Arrays.asList(getOrgDayBoundary(ssItem, ssReq.getCache()))));</span>
			}
<span class="nc" id="L919">		}</span>

		// publish for both employees
<span class="nc bnc" id="L922" title="All 2 branches missed.">		if (publishTime.isNotEmpty()) {</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">			if (sam == null) {</span>
<span class="nc" id="L924">				sam = WfmManagerFactory.getScheduleAccessManager();</span>
			}
<span class="nc" id="L926">			ID empID1 = ssReq.getShiftSwapItems().get(0).getEmployeeID();</span>
<span class="nc" id="L927">			ID empID2 = ssReq.getShiftSwapItems().get(1).getEmployeeID();</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">			for (TimeRange range : publishTime.getTimeRanges()) {</span>
<span class="nc" id="L929">				sam.publishSchedule(Collections.singleton(empID1), range.getStartDate(), range.getEndDate());</span>
<span class="nc" id="L930">				sam.publishSchedule(Collections.singleton(empID2), range.getStartDate(), range.getEndDate());</span>
<span class="nc" id="L931">			}</span>
		}
<span class="nc" id="L933">	}</span>

	/**
	 * The returned shifts might contain gap-only shifts (shifts with one gap shift event for the whole time)
	 * for the shifts which will be deleted.
	 *
	 * @param ssReq
	 * @return
	 * @throws Exception
	 */
	public static ShiftAssignment[] getShiftsAfterSwap(final ShiftSwapRequest ssReq, final boolean usePublishedSchedule) throws Exception {
<span class="nc" id="L944">		return performSwap(ssReq, usePublishedSchedule, false, false).getResultedShifts();</span>
	}
	public static SwapResult getShiftSwapResult(final ShiftSwapRequest ssReq, final boolean usePublishedSchedule) throws Exception {
<span class="nc" id="L947">		return performSwap(ssReq, usePublishedSchedule, false, false);</span>
	}

	public static SwapResult performSwapAndSave(ShiftSwapRequest ssReq, boolean deleteUnderlyingUnavails) throws Exception {
<span class="nc" id="L951">		return performSwap(ssReq, false, deleteUnderlyingUnavails, true);</span>
	}


	/**
	 * Processes the Shift Swap request and does the actual partial shift swap.  Does not publish the
	 * schedule after swap.  Any underlying unavailabilies are deleted.
	 *
	 * Note:
	 * &lt;pre&gt;
	 *    get the IDs for both employees participating in swap.
	 *    if swap type is one way
	 *       obtain shiftassignment for employee with shift
	 *       create new shift assignment for the requesting employee
	 *       update original employees shift assignment- replace shift portion swapped withe GAP activity
	 *       post shiftassignments to database
	 *    end if
	 *    if swap type is 2 way
	 *       get the ShiftAssignment for each employee
	 *       update the shift assignment for each employee- append/superimpose partial SA
	 *       on top of the original SA
	 *       calendar evenets should not be swappped
	 *       post the ShiftAssigment objects back to the databaase.
	 *    if
	 * &lt;/pre&gt;
	 *
	 * @param fixNewShiftAssnSPID See {@link RequestUtil#createShiftAssignment(ID, ShiftAssignment, boolean, ScheduleAccessManager) createShiftAssignment} method.
	 *
	 */
	private static SwapResult performSwap(final ShiftSwapRequest ssReq, final boolean usePublishedSchedule, final boolean deleteUnderlyingUnavails, final boolean save) throws Exception
	{
<span class="nc" id="L982">		ScheduleReaderWriter readerWriter = new CachedResultScheduleReaderWriterImpl(usePublishedSchedule, save, ssReq.getCache());</span>
<span class="nc" id="L983">		ShiftSwapRequestApprovalManager manager = new ShiftSwapRequestApprovalManager(readerWriter);</span>
<span class="nc" id="L984">		SwapResult swapResult = manager.performSwap(ssReq, deleteUnderlyingUnavails);</span>
<span class="nc" id="L985">		ShiftAssignment[] newVal = swapResult.getResultedShifts();</span>

<span class="nc bnc" id="L987" title="All 2 branches missed.">		for (int i = 0; i &lt; newVal.length; i++) {</span>
<span class="nc" id="L988">			ShiftAssignment sa = newVal[i];</span>
<span class="nc bnc" id="L989" title="All 2 branches missed.">			if (sa.getDuration() &gt; 24 * 60) {</span>
<span class="nc" id="L990">				Integer iDay = new Integer(24 * 60);</span>
<span class="nc" id="L991">				ID wrID = (ID) sa.getWorkResourceIDs().toArray()[0];</span>
<span class="nc" id="L992">				throw RequestUtil.createRmHardValidationException(</span>
						RmEjbBundleKey.PSS_SHIFT_MAX_DURATION,
						iDay,
<span class="nc" id="L995">						ssReq.getValidationCache().getEmployeeNameByID(wrID),</span>
						m_cat);
			}
		}
<span class="nc" id="L999">		return swapResult;</span>
	}

	public static boolean canApproveTentatively(ShiftSwapRequest ssReq,
			ScheduleAccessManager sam) throws Exception
	{
<span class="nc" id="L1005">		boolean canApproveTentatively = true;</span>
<span class="nc" id="L1006">		ShiftSwapItem ssItem1 = ssReq.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1007">		ShiftSwapItem ssItem2 = ssReq.getShiftSwapItems().get(1);</span>

<span class="nc bnc" id="L1009" title="All 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L1010">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}

		//now get sas for the swapped portions to make sure they do not ioverlap with the items
<span class="nc" id="L1014">		ShiftAssignment[] saSwappedArr = ShiftSwapRequestUtil.getSwappedShiftAssignsForReq(ssReq, false, false, true, sam);</span>
<span class="nc" id="L1015">		ShiftAssignment shiftAssnUnpubSwap1 = saSwappedArr[0];</span>
<span class="nc" id="L1016">		ShiftAssignment shiftAssnUnpubSwap2 = saSwappedArr[1];</span>

<span class="nc bnc" id="L1018" title="All 2 branches missed.">		if (ssItem1.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_TIMEOFF)) {</span>
<span class="nc" id="L1019">			shiftAssnUnpubSwap1 = null;</span>
		}
<span class="nc bnc" id="L1021" title="All 2 branches missed.">		if (ssItem2.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_TIMEOFF)) {</span>
<span class="nc" id="L1022">			shiftAssnUnpubSwap2 = null;</span>
		}

<span class="nc bnc" id="L1025" title="All 4 branches missed.">		canApproveTentatively = shiftAssnUnpubSwap1 == null &amp;&amp;</span>
				shiftAssnUnpubSwap2 == null;
<span class="nc" id="L1027">		return canApproveTentatively;</span>
	}

	/**
	 * Delete all unavailability events underlying the given interval for the given employee.
	 *
	 * @param startDate
	 * @param endDate
	 * @return the last deleted unavailability event if any.  otherwise returns null.
	 * @throws Exception
	 */
	public static UnavailabilityEvent deleteUnderlyingUnavailabilities(ID empID, Date startDate,
			Date endDate, ScheduleAccessManager sam) throws Exception {
		// get all unavailabilites overlapping the given interval
<span class="nc" id="L1041">		Collection unavailsUnpub = sam.getEventsForWorkResourceByType(Event.EVENT_TYPE_UNAVAILABILITY,</span>
				empID, startDate, endDate);

<span class="nc" id="L1044">		UnavailabilityEvent unavailEvt = null;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">		for (Iterator unavailsIter = unavailsUnpub.iterator(); unavailsIter.hasNext();) {</span>
<span class="nc" id="L1046">			unavailEvt = (UnavailabilityEvent) unavailsIter.next();</span>

			//if this is a 'fixed' event
<span class="nc bnc" id="L1049" title="All 2 branches missed.">			if (unavailEvt.getID() != null) {</span>
				// delete the unavailability event.
<span class="nc" id="L1051">				sam.deleteCalendarEventAssignments(Collections.singleton(unavailEvt.getID()));</span>
			} else { // if event's ID == null, must be a recurring event
				// get event's template ID
<span class="nc" id="L1054">				ID evtTmplID = unavailEvt.getEventTemplateID();</span>

				// create an exception for the recurring event creation.
				//sam.createRecurringEventException(evtTmplID, Collections.singleton(empID), unavailEvt.getStartTime());
<span class="nc" id="L1058">				sam.deleteRecurringEventInstance(evtTmplID, Collections.singleton(empID), unavailEvt.getStartTime());</span>
<span class="nc" id="L1059">			}</span>
		}

<span class="nc" id="L1062">		return unavailEvt;</span>
	}

	public static ValidationResult validateApprovedRequestForWithdraw(Validatable validatable) throws Exception {
<span class="nc" id="L1066">		ValidationResult result = null;</span>
<span class="nc" id="L1067">		ShiftSwapRequest ssReq = (ShiftSwapRequest) validatable;</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">		if (ssReq.isApproved()) {</span>
			try {
<span class="nc" id="L1070">				ShiftSwapItem ssItem1 = ssReq.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1071">				ShiftSwapItem ssItem2 = ssReq.getShiftSwapItems().get(1);</span>

<span class="nc" id="L1073">				ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="nc" id="L1075">				ShiftSwapValidationCache ssReqValCache = ssReq.getCache();</span>
				//Disregard shift type. Need to verify that no shift exists for time-off as well
<span class="nc" id="L1077">				int hashCode = getShiftSwapItemHashCode(ssItem1, ssItem2.getEmployeeID(), sam, ssReqValCache);</span>

				// Partials in previous code always returned zero as hash.
				// This has been fixed, but for older db items, we have to handle zero hashcodes
<span class="nc" id="L1081">				int ssHashCode = ssItem1.getHashCode();</span>
<span class="nc bnc" id="L1082" title="All 4 branches missed.">				boolean partialZeroHash = ssItem1.getIsPartial() &amp;&amp; ssHashCode==0;</span>

<span class="nc bnc" id="L1084" title="All 4 branches missed.">				if (hashCode != ssHashCode &amp;&amp; !partialZeroHash) {</span>
<span class="nc" id="L1085">					return ValidationUtil.setHardValidationResult(ssReq, RmEjbBundleKey.SHIFTSWAP_WITHDRAW_UNDERLYING_EVENT_MISMATCH,</span>
							m_className);
				}

<span class="nc" id="L1089">				hashCode = getShiftSwapItemHashCode(ssItem2, ssItem1.getEmployeeID(), sam, ssReqValCache);</span>
<span class="nc" id="L1090">				ssHashCode = ssItem2.getHashCode();</span>
<span class="nc bnc" id="L1091" title="All 4 branches missed.">				partialZeroHash = ssItem2.getIsPartial() &amp;&amp; ssHashCode==0;</span>

<span class="nc bnc" id="L1093" title="All 4 branches missed.">				if (hashCode != ssHashCode &amp;&amp; !partialZeroHash) {</span>
<span class="nc" id="L1094">					return ValidationUtil.setHardValidationResult(ssReq, RmEjbBundleKey.SHIFTSWAP_WITHDRAW_UNDERLYING_EVENT_MISMATCH,</span>
							m_className);
				}

<span class="nc" id="L1098">			} catch (Exception e) {</span>
<span class="nc" id="L1099">				result = ValidationUtil.setHardValidationResult(ssReq, RmEjbBundleKey.SHIFTSWAP_WITHDRAW_UNDERLYING_EVENT_MISMATCH,</span>
						m_className);
<span class="nc" id="L1101">			}</span>
		}
<span class="nc" id="L1103">		return result;</span>
	}

	/**
	 * Create a shift stamp for each swap to identify swaps that change in the future. Required for withdrawal validation.
	 * @param ssReq - Shift swap request
	 * @param overlap
	 * @param sam
	 * @throws Exception
	 */
	public static void signShiftSwapItems(ShiftSwapRequest ssReq, boolean overlap, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L1114">		ShiftSwapItem ssItem1 = ssReq.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1115">		ShiftSwapItem ssItem2 = ssReq.getShiftSwapItems().get(1);</span>

<span class="nc bnc" id="L1117" title="All 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L1118">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}

<span class="nc" id="L1121">		ShiftSwapItemDAO dao = new ShiftSwapItemDAO();</span>

		try {
<span class="nc" id="L1124">			String ssItem1SwapType = ssItem1.getShiftType();</span>
<span class="nc" id="L1125">			ShiftSwapValidationCache ssReqValCache = ssReq.getCache();</span>
<span class="nc bnc" id="L1126" title="All 2 branches missed.">			if (ssItem1SwapType.equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
				//The shift is swapped, so the other employee has the shift
<span class="nc bnc" id="L1128" title="All 2 branches missed.">				int hashCode = overlap?ShiftSwapRequest.OVERLAP_HASH:getShiftSwapItemHashCode(ssItem1, ssItem2.getEmployeeID(), sam, ssReqValCache);</span>
				
			
<span class="nc" id="L1131">				ssItem1.setHashCode(hashCode);</span>
<span class="nc" id="L1132">				dao.updateObject(ssItem1);</span>
			}

<span class="nc" id="L1135">			String ssItem2SwapType = ssItem2.getShiftType();</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">			if (ssItem2SwapType.equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
				//The shift is swapped, so the other employee has the shift
<span class="nc bnc" id="L1138" title="All 2 branches missed.">				int hashCode = overlap?ShiftSwapRequest.OVERLAP_HASH:getShiftSwapItemHashCode(ssItem2, ssItem1.getEmployeeID(), sam, ssReqValCache);</span>
<span class="nc" id="L1139">				ssItem2.setHashCode(hashCode);</span>
<span class="nc" id="L1140">				dao.updateObject(ssItem2);</span>
			}
		} finally {
<span class="nc" id="L1143">			dao.cleanUp();</span>
<span class="nc" id="L1144">		}</span>
<span class="nc" id="L1145">	}</span>

	/**
	 * Get the hashcode to sign the shift swap item. Because the shift is swapped, the employeeID parameter is used
	 * to replace the Shift Swap requested item and get the schedule shift. The hascode is calculated on the shift and
	 * its shift events.
	 *
	 * @param ssi - Shift Swap Item
	 * @param employeeID - Employee ID of other shift item
	 * @param sam - Schedule Access Manager
	 * @param ssReqValCache - Shift Swap Validation Cache
	 * @return hashcode value
	 * @throws Exception
	 */
	public static int getShiftSwapItemHashCode(ShiftSwapItem ssi, ID employeeID, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssReqValCache) throws Exception {
<span class="nc" id="L1161">		ShiftSwapItem clone = (ShiftSwapItem) ssi.clone();</span>
<span class="nc" id="L1162">		clone.setEmployeeID(employeeID);</span>
		
<span class="nc bnc" id="L1164" title="All 2 branches missed.">		ShiftAssignment sa = getShiftAssignForSSItem(clone, true, !clone.getIsPartial(), false, false, sam, ssReqValCache, false);</span>
		
<span class="nc bnc" id="L1166" title="All 2 branches missed.">		if (sa == null) {</span>
<span class="nc" id="L1167">			return 0;</span>
		} else {
<span class="nc" id="L1169">			return getHashCode(sa, clone);</span>
		}
	}

	public static int getHashCode(ShiftAssignment sa, ShiftSwapItem ssi) {
<span class="nc" id="L1174">		int hashCode = ShiftsUtil.getShiftAssignmentHashCodeExtendedInRange(sa, ssi.getStartDate(), ssi.getEndDate());</span>
		//OVERLAP_HASH is a special hash that we use for overlap. So replace it.
		//Overlap means that a requested shift swap overlaps an existing shift or the receiver
<span class="nc bnc" id="L1177" title="All 2 branches missed.">		if (hashCode==ShiftSwapRequest.OVERLAP_HASH){</span>
<span class="nc" id="L1178">			hashCode^=ssi.getStartDate().hashCode();</span>
		}
<span class="nc" id="L1180">		return hashCode;</span>
	}

	public static int getHashCode(ShiftAssignment sa) {
<span class="nc" id="L1184">		return ShiftsUtil.getShiftAssignmentHashCodeExtended(sa);</span>
	}

	/**
	 * Get number of one way swaps approved for employee. The date range will take into account any
	 * shift that starts in the date range start-end.
	 * The parameters must not be null. For any null value in the params, the count will return 0.
	 *
	 * @param employeeID - Employee ID
	 * @param start - start date range
	 * @param end - end date range
	 * @return count of number of 1-way approved swaps, where the employee gives away his shift
	 * @throws Exception
	 */
	public static int getNumberOfOneWaySwapsForEmployee(ID employeeID, Date start, Date end) throws Exception {
<span class="nc" id="L1199">		int result = 0;</span>
<span class="nc bnc" id="L1200" title="All 6 branches missed.">		if (employeeID != null &amp;&amp; start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1201">			Map&lt;ID, Integer&gt; returnMap =</span>
<span class="nc" id="L1202">					getNumberOfOneWaySwapsForEmployees(Collections.singletonList(employeeID), start, end);</span>

<span class="nc bnc" id="L1204" title="All 4 branches missed.">			if (returnMap != null &amp;&amp; returnMap.containsKey(employeeID)) {</span>
<span class="nc" id="L1205">				result = returnMap.get(employeeID);</span>
			}
		}

<span class="nc" id="L1209">		return result;</span>
	}

	/**
	 * Get number of one way swaps approved for employees. The date range will take into account any
	 * shift that starts in the date range start-end.
	 * The parameters must not be null. For any null value in the params, the count will return 0.
	 *
	 * @param employeeIDs - Employee IDs
	 * @param start - start date range
	 * @param end - end date range
	 * @return Map of empID -&gt; count of number of 1-way approved swaps, where the employee gives away his shift
	 * @throws Exception
	 */
	public static Map&lt;ID, Integer&gt; getNumberOfOneWaySwapsForEmployees(Collection&lt;ID&gt; employeeIDs, Date start, Date end)
			throws Exception {
<span class="nc" id="L1225">		Map&lt;ID, Integer&gt; returnMap = null;</span>
<span class="nc" id="L1226">		ShiftSwapRequestDAO dao = null;</span>
		try {
<span class="nc" id="L1228">			dao = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
<span class="nc" id="L1229">			returnMap = dao.getNumberOfOneWaySwapsForEmployees(employeeIDs, start, end);</span>
		} finally {
<span class="nc bnc" id="L1231" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1232">				dao.cleanUp();</span>
			}
		}

<span class="nc" id="L1236">		return returnMap;</span>
	}

	/**
	 * Get number of one way swaps approved for employees. The date range will take into account any
	 * shift that starts in the date range start-end.
	 * The parameters must not be null. For any null value in the params, the count will return 0.
	 *
	 * @param employeeID - Employee ID
	 * @param org - Organization of the Employees to get Swap Count
	 * @param start - start date range
	 * @param end - end date range
	 * @return Map of empID -&gt; count of number of 1-way approved swaps, where the employee gives away his shift
	 * @throws Exception
	 */
	public static int getNormalizedNumberOfOneWaySwapsForEmployees(ID employeeID, Organization org, Date start, Date end)
			throws Exception {
<span class="nc" id="L1253">		int result = 0;</span>
<span class="nc" id="L1254">		Collection&lt;Map&lt;ID, Collection&lt;Timestamp&gt;&gt;&gt; swapDataMap = null;</span>
<span class="nc" id="L1255">		Map&lt;ID, Integer&gt; employeeSwapCountMap = null; </span>
		
<span class="nc" id="L1257">		employeeSwapCountMap = getNormalizedNumberOfOneWaySwapsForEmployees(Collections.singletonList(employeeID), org, start, end);</span>

<span class="nc bnc" id="L1259" title="All 4 branches missed.">		if (employeeSwapCountMap != null &amp;&amp; employeeSwapCountMap.containsKey(employeeID)) {</span>
<span class="nc" id="L1260">			result = employeeSwapCountMap.get(employeeID);</span>
		}
<span class="nc" id="L1262">		return result;</span>
	}

	/**
	 * Get number of one way swaps approved for employees. The date range will take into account any
	 * shift that starts in the date range start-end.
	 * The parameters must not be null. For any null value in the params, the count will return 0.
	 *
	 * @param employeeIDs - Employee IDs
	 * @param org - Organization of the Employees to get Swap Count
	 * @param start - start date range
	 * @param end - end date range
	 * @return Map of empID -&gt; count of number of 1-way approved swaps, where the employee gives away his shift
	 * @throws Exception Throw if an exception is encountered
	 */
	public static Map&lt;ID, Integer&gt; getNormalizedNumberOfOneWaySwapsForEmployees(Collection&lt;ID&gt; employeeIDs, Organization org, Date start, Date end)
			throws Exception {
<span class="nc" id="L1279">		Collection&lt;Map&lt;ID, Collection&lt;Timestamp&gt;&gt;&gt; swapDataMap = null;</span>
<span class="nc" id="L1280">		Map&lt;ID, Integer&gt; employeeSwapCountMap = null; </span>
<span class="nc" id="L1281">		ShiftSwapRequestDAO dao = null;</span>
		
		try {
<span class="nc" id="L1284">			dao = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
<span class="nc" id="L1285">			swapDataMap = dao.getNormalizedNumberOfOneWaySwapsForEmployees(employeeIDs, start, end);</span>
<span class="nc" id="L1286">			employeeSwapCountMap = createSwapCountMap(swapDataMap, org);</span>
		} finally {
<span class="nc bnc" id="L1288" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1289">				dao.cleanUp();</span>
			}
		}

<span class="nc" id="L1293">		return employeeSwapCountMap;</span>
	}
	/**
	 * Counts the number one-way shift swaps for a user.  The methods accepts a collection of maps that have an ID as the key
	 * and a collections of TimeStamps.  It subtracts the dates from the first map that are contain in the second map.  Then
	 * builds a map of ID to swap counts.
	 * 
	 * @param swapDataMap Data return from db call
	 * @param org Organization for employees
	 * @return Map containing ID to swap count Key\Data Pairs 
	 * @throws Exception Throw if an exception is encountered
	 */
	private static Map&lt;ID, Integer&gt; createSwapCountMap(Collection&lt;Map&lt;ID, Collection&lt;Timestamp&gt;&gt;&gt; swapDataMap, Organization org) throws Exception {
<span class="nc" id="L1306">		int count = 0;</span>
<span class="nc" id="L1307">		Map&lt;ID, Collection&lt;Timestamp&gt;&gt; mapSwapOff = null;</span>
<span class="nc" id="L1308">		Map&lt;ID, Collection&lt;Timestamp&gt;&gt; mapSwapOn = null;</span>
<span class="nc" id="L1309">		Map&lt;ID, Integer&gt; maps = new HashMap&lt;ID, Integer&gt;();</span>

<span class="nc" id="L1311">		mapSwapOn = (Map&lt;ID, Collection&lt;Timestamp&gt;&gt;) ((ArrayList) swapDataMap).get(0);</span>
<span class="nc" id="L1312">		mapSwapOff = (Map&lt;ID, Collection&lt;Timestamp&gt;&gt;) ((ArrayList) swapDataMap).get(1);</span>

<span class="nc bnc" id="L1314" title="All 2 branches missed.">		for (ID swapOffID : mapSwapOff.keySet()) {</span>
<span class="nc" id="L1315">			Collection&lt;Timestamp&gt; swapOffDates = mapSwapOff.get(swapOffID);</span>
<span class="nc" id="L1316">			Collection&lt;Timestamp&gt; swapOnDates = mapSwapOn.get(swapOffID);</span>
<span class="nc bnc" id="L1317" title="All 2 branches missed.">			if (swapOnDates != null) {</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">				for (Timestamp swapOffDate : swapOffDates) {</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">					for (Iterator it = swapOnDates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1320">						Timestamp swapOnDate = (Timestamp) it.next();</span>
<span class="nc bnc" id="L1321" title="All 2 branches missed.">						if (isSwapOnDateOnSwapOffDate(swapOnDate, swapOffDate, org)) {</span>
<span class="nc" id="L1322">							it.remove();</span>
<span class="nc" id="L1323">							break;</span>
						}
<span class="nc" id="L1325">					}</span>
<span class="nc" id="L1326">				}</span>
			}
<span class="nc" id="L1328">		}</span>

		// Count the Swaps for an Employee
<span class="nc bnc" id="L1331" title="All 2 branches missed.">		for (ID swapOnID : mapSwapOn.keySet()) {</span>
<span class="nc" id="L1332">			Collection&lt;Timestamp&gt; swapOnDates = mapSwapOn.get(swapOnID);</span>
<span class="nc" id="L1333">			maps.put(swapOnID, new Integer(swapOnDates.size()));</span>
<span class="nc" id="L1334">		}</span>

<span class="nc" id="L1336">		return maps;</span>
	}

	/**
	 * Compares the Swap On date overlaps a previous Swap Off date
	 * 
	 * @param swapOn Date of new Shift Swap On (Gaining a shift)
	 * @param swapOff Date of new Shift Swap Off (Losing a shift)
	 * @param org Organization of individual swapping the shift
	 * @return True is the Swap On date overlaps the Swap Off date
	 * @throws Exception
	 */
	private static boolean isSwapOnDateOnSwapOffDate(Timestamp swapOn, Timestamp swapOff, Organization org) 
			throws Exception {
<span class="nc" id="L1350">		final int TWENTY_FOUR_HOURS_IN_MINUTES = 1440;</span>
<span class="nc" id="L1351">		boolean between = false;</span>
<span class="nc" id="L1352">		int orgOffSet = org.getDayBoundaryOffset();</span>
<span class="nc" id="L1353">		Calendar swapOffCalStartDate = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L1354">		Calendar swapOffCalEndDate = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L1355">		Calendar swapOnCalDate = Calendar.getInstance(org.getTimeZone());</span>
		
		// Set the start of the day to the Organization Day Offset
<span class="nc" id="L1358">		swapOffCalStartDate.setTime((Date)swapOff);</span>
<span class="nc" id="L1359">		swapOffCalStartDate.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L1360">		swapOffCalStartDate.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L1361">		swapOffCalStartDate.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1362">		swapOffCalStartDate.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L1363">		swapOffCalStartDate.add(Calendar.MINUTE, orgOffSet);</span>
		
		// Increment the Organization Day End by 24 Hrs.
<span class="nc" id="L1366">		swapOffCalEndDate.setTime(swapOffCalStartDate.getTime());</span>
<span class="nc" id="L1367">		swapOffCalEndDate.add(Calendar.MINUTE, TWENTY_FOUR_HOURS_IN_MINUTES);</span>
		
		// Take a second from start date in case shift starts at the beginning of the
		// Organization date
<span class="nc" id="L1371">		swapOffCalStartDate.add(Calendar.SECOND, -1);</span>
		
		// Sets the Swap On Time
<span class="nc" id="L1374">		swapOnCalDate.setTime((Date)swapOn);</span>
		
<span class="nc bnc" id="L1376" title="All 4 branches missed.">		if (swapOnCalDate.after(swapOffCalStartDate) &amp;&amp; swapOnCalDate.before(swapOffCalEndDate)) {</span>
<span class="nc" id="L1377">			between = true;</span>
		}
<span class="nc" id="L1379">		return between;</span>
	}

	/**
	 * Check if the number of swaps performed on a shift is below the limit
	 *
	 * @param numberOfSwaps - limit of swaps
	 * @param ssReq - Shift Swap Request
	 * @return boolean true - below limit, false - above limit
	 * @throws Exception
	 */
	public static boolean isBelowNumberOfSwapsForShift(int numberOfSwaps, ShiftSwapRequest ssReq) throws Exception {
<span class="nc" id="L1391">		boolean result = true;</span>
<span class="nc" id="L1392">		ShiftSwapRequestDAO dao = null;</span>

<span class="nc" id="L1394">		ShiftSwapItem ssItem1 = ssReq.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1395">		ShiftSwapItem ssItem2 = ssReq.getShiftSwapItems().get(1);</span>

		try {
<span class="nc" id="L1398">			dao = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
<span class="nc" id="L1399">			String ssItem1SwapType = ssItem1.getShiftType();</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">			if (ssItem1SwapType.equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L1401">				result = dao.isBelowNumberOfSwapsForShift(numberOfSwaps, ssItem1.getEmployeeID(), ssItem1.getStartDate(),</span>
<span class="nc" id="L1402">						ssItem1.getEndDate());</span>
			}

<span class="nc" id="L1405">			String ssItem2SwapType = ssItem2.getShiftType();</span>
<span class="nc bnc" id="L1406" title="All 4 branches missed.">			if (result &amp;&amp; ssItem2SwapType.equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L1407">				result = dao.isBelowNumberOfSwapsForShift(numberOfSwaps, ssItem2.getEmployeeID(), ssItem2.getStartDate(),</span>
<span class="nc" id="L1408">						ssItem2.getEndDate());</span>
			}
		} finally {
<span class="nc" id="L1411">			dao.cleanUp();</span>
<span class="nc" id="L1412">		}</span>

<span class="nc" id="L1414">		return result;</span>
	}

	/**
	* Check if there is any approved shiftSwap for the employee received the shift swap in 1 day
	* This is for MaxHoursAndMaxAlternateHoursPerDayValidationRule
	* For debug: If 1-way swap, his shift type returned is TimeOff, If 2-way swap, his shift return is Shift
	* @param employeeId
	* @param startDate
	* @param endDate
	* @return boolean
	* */
	public static boolean employeeReceivedShiftSwapApproved(ID employeeId, Date startDate, Date endDate) throws Exception {
<span class="nc" id="L1427">		boolean result = true;</span>
<span class="nc" id="L1428">		ShiftSwapRequestDAO dao = null;</span>
		try {
<span class="nc" id="L1430">			dao = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
<span class="nc" id="L1431">			result = dao.employeeReceivedShiftSwapApproved(employeeId, startDate, endDate);</span>
		} finally {
<span class="nc" id="L1433">			dao.cleanUp();</span>
<span class="nc" id="L1434">		}</span>
<span class="nc" id="L1435">		return result;</span>
	}

	/**
	 * Get Paid Hours of A shift assignment
	 * */
	public static long getPaidTimeInShiftAssignment(ShiftAssignment shiftAssignment) throws Exception
	{
		// in milliseconds.
<span class="nc" id="L1444">		long paidTimeInMs = shiftAssignment.getEndTime().getTime() - shiftAssignment.getStartTime().getTime();</span>
<span class="nc" id="L1445">		Collection&lt;ShiftEventAssignment&gt; shiftEventAssignments = shiftAssignment.getChildren();</span>
<span class="nc bnc" id="L1446" title="All 2 branches missed.">		for (Iterator&lt;ShiftEventAssignment&gt; itrShiftEvents = shiftEventAssignments.iterator(); itrShiftEvents.hasNext();) {</span>
			//if this event is not paid, then deduct from the shift paid hours
<span class="nc" id="L1448">			ShiftEventAssignment assignment = itrShiftEvents.next();</span>
<span class="nc bnc" id="L1449" title="All 4 branches missed.">			if (assignment != null &amp;&amp; !assignment.getPaid())</span>
			{
<span class="nc" id="L1451">				paidTimeInMs -= ((long) assignment.getDuration()) * 60 * 1000; //duration is in minutes; convert to long</span>
			}
<span class="nc" id="L1453">		}</span>
<span class="nc" id="L1454">		return paidTimeInMs;</span>
	}

	/**
	 * Returns the number of partial shift swaps for a given day and shift
	 *
	 * @param ssItem Contains the data for the shift swap
	 * @param swapperEmployeeID ID of the employee to search for Shifts
	 * @param swappeeEmployeeID ID of the employee to check in list of employees
	 * @param shiftStartTime Start Time of the shift
	 * @param shiftEndTime End Time for the shift
	 * @return The number of partial shift swaps for a shift.
	 * @throws Exception Throws an exception if any occur.
	 */
	public static int getNumberOfPartialSwapsForShift(ShiftSwapItem ssItem, ID swapperEmployeeID, ID swappeeEmployeeID,
													  Date shiftStartTime, Date shiftEndTime) throws Exception { // NOSONAR
<span class="nc" id="L1470">		int result = 0;</span>
		Collection&lt;ID&gt; employeeIDs;

<span class="nc" id="L1473">		ShiftSwapRequestDAO dao = new ShiftSwapRequestDAO(ShiftSwapRequest.getDetailLevelForValidation());</span>
		try {
<span class="nc" id="L1475">			String ssItem1SwapType = ssItem.getShiftType();</span>
<span class="nc bnc" id="L1476" title="All 2 branches missed.">			if (ssItem1SwapType.equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)) {</span>
<span class="nc" id="L1477">				employeeIDs = dao.getEmployeeIDsOfPartialSwapsPerShift(swapperEmployeeID, shiftStartTime, shiftEndTime);</span>
<span class="nc bnc" id="L1478" title="All 2 branches missed.">				if (employeeIDs != null) {</span>
<span class="nc bnc" id="L1479" title="All 2 branches missed.">					if (employeeIDs.contains(swappeeEmployeeID)) {</span>
<span class="nc" id="L1480">						result = 0;</span>
					} else {
<span class="nc" id="L1482">						result = employeeIDs.size();</span>
					}
				}
			}
		} finally {
<span class="nc" id="L1487">			dao.cleanUp();</span>
<span class="nc" id="L1488">		}</span>
<span class="nc" id="L1489">		return result;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>