<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TOCalendarUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">TOCalendarUtil.java</span></div><h1>TOCalendarUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.util;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntryFieldInfo;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailProperty;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TOPoolUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.ejb.CalendarTimeOffDayFacade;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.CalendarTimeOffDay;
import com.bluepumpkin.ejb.rm.setup.calendartimeoff.model.EmpTOPoolAssignment;
import com.verint.ejb.wfm.WfmManagerFactory;

/*
 * The methods are not made static to enable caching of TO Calculator created, if needed
 */

public class TOCalendarUtil {
<span class="nc" id="L60">	private static Category m_cat = Log.initCategory(TOCalendarUtil.class.getName());</span>
	//These constants are used for storing different buckets in an Array.
	public static final int BKT_PENDING = 0;
	public static final int BKT_SCHED = 1;
	public static final int BKT_SCHED_TOPOOL = 2;

<span class="nc" id="L66">	private TOCalendarUtil() {</span>

<span class="nc" id="L68">	}</span>

	/**
	 * Called by the validation rules to find the scheduled data.
	 * For each day in the given time range and for the passed collection of time off events,
	 * the following information is returned:
	 * &lt;li&gt; the total scheduled TO hours
	 *
	 * @param org   organization for which scheduled hours per day is to be computed
	 * @param range
	 * @throws Exception
	 */
	public static DailyHoursBuckets getTOScheduledData(ID pTOPoolID, Organization org, Collection childOrgs, 
			Collection empIDs, TimeRange range, 
			Collection allotmentList, boolean inclTOHrsPerDayDetails, ID activityID) throws Exception {//NOSONAR
<span class="nc" id="L83">		TimeZone orgTimeZone = org.getTimeZone();</span>
		// orgScheduledBuckets: scheduled TO hours/day for all employees in the organization.
<span class="nc" id="L85">		DailyHoursBuckets toPoolSchedBkts = new DailyHoursBuckets(org.getDayBoundaryOffset(), orgTimeZone, range, inclTOHrsPerDayDetails);</span>
<span class="nc" id="L86">		Collection hrsPerDayCol = getHoursPerDayForRange(empIDs, range, allotmentList, true);</span>
		// fill the orgScheduled and interestSetScheduled buckets.
<span class="nc" id="L88">		TimeRange minMaxRange = getMinMaxRange(new Collection[]{hrsPerDayCol});</span>
<span class="nc bnc" id="L89" title="All 2 branches missed.">		if (minMaxRange == null) {</span>
<span class="nc" id="L90">			minMaxRange = range;</span>
		}
<span class="nc" id="L92">		Date stDate = TOCalendarUtil.getBackAyearforDate(minMaxRange.getStartDate());</span>
<span class="nc" id="L93">		Date enDate = minMaxRange.getEndDate();</span>
<span class="nc" id="L94">		HashMap wras = RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(empIDs,</span>
		        new LocalDate(stDate, orgTimeZone),
		        new LocalDate(enDate, orgTimeZone), false);
<span class="nc" id="L97">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L98">		HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap = toCalFacade.getTOPoolsForWorkResources(empIDs, stDate, enDate);</span>
		//pass intSetEmpIDs only when TOPoolID is null; i.e. in org mode only
<span class="nc bnc" id="L100" title="All 2 branches missed.">		Collection intSetEmpIDs = pTOPoolID != null ? null : empIDs;</span>
<span class="nc" id="L101">		fillSchedDailyHoursBuckets(false,pTOPoolID, hrsPerDayCol, intSetEmpIDs, null, toPoolSchedBkts, childOrgs, wras, empTOPoolAssnMap);</span>
<span class="nc" id="L102">		return toPoolSchedBkts;</span>
	}

	public static DailyHoursBuckets getTOScheduledData(ID pTOPoolID, Organization org, TimeRange range, Collection allotList, ID activityID) throws Exception {
<span class="nc" id="L106">		Date empStartDate = getBackAyearforDate(range.getStartDate()); // emp may have belonged to other time off pool/org in past, so look back a year.</span>
<span class="nc" id="L107">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L108">		Collection pTOPoolEmpIDs = toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, range.getEndDate());</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">		if (allotList == null) {</span>
<span class="nc" id="L110">			allotList = getListOfAllAllotmentActivities();</span>
		}
<span class="nc" id="L112">		return getTOScheduledData(pTOPoolID, org, Collections.emptyList(), pTOPoolEmpIDs, range, allotList, false, activityID);</span>
	}

	public static DailyHoursBuckets getTOAllocatedData(ID poolID, Organization org, TimeRange toRange) throws Exception {
<span class="nc" id="L116">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L117">		TimeZone tz = org.getTimeZone();</span>

<span class="nc" id="L119">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(orgDayOffset, tz, toRange);</span>
<span class="nc" id="L120">		Collection&lt;CalendarTimeOffDay&gt; toDailyAllocs = new ArrayList&lt;CalendarTimeOffDay&gt;();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (poolID != null) {</span>
<span class="nc" id="L122">			toDailyAllocs.addAll(getTOAllocationCalendar(poolID, org.getID(), tz, toRange));</span>
<span class="nc" id="L123">			fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, toDailyAllocs);</span>
		}
<span class="nc" id="L125">		return toAllocHrsBkts;</span>
	}

	public static String getTOAllocationCalendarForTimeOffDays(ID poolID, Organization org, CalendarTimeOffDay[] toDailyAllocs, TimeRange toRange) throws Exception {
<span class="nc" id="L129">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(org.getDayBoundaryOffset(), org.getTimeZone(), toRange);</span>
		// make toAllocHrsBkts from the toDailyAllocs
<span class="nc" id="L131">		fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, Arrays.asList(toDailyAllocs));</span>

<span class="nc" id="L133">		StringBuilder toAllocCalendar = new StringBuilder();</span>
<span class="nc" id="L134">		toAllocCalendar.append(&quot;Alloc=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(toAllocHrsBkts));</span>
<span class="nc" id="L135">		return toAllocCalendar.toString();</span>
	}

	public static String getTOCalendar(DailyHoursBuckets allocHrs, DailyHoursBuckets beforeScheduledHrs, DailyHoursBuckets afterScheduledHrs) {
<span class="nc" id="L139">		StringBuilder toCalendar = new StringBuilder();</span>
<span class="nc" id="L140">		toCalendar.append(&quot;Alloc=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(allocHrs));</span>
<span class="nc" id="L141">		toCalendar.append(&quot;\tSched(Before)=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(beforeScheduledHrs));</span>
<span class="nc" id="L142">		toCalendar.append(&quot;\tSched(After)=&quot;).append(TOHoursPerDayUtil.convertDailyBucketsToHoursPerDayString(afterScheduledHrs));</span>
<span class="nc" id="L143">		return toCalendar.toString();</span>
	}


	@SuppressWarnings(&quot;unchecked&quot;)
	public static Map&lt;Integer, List&lt;AuditTrailEntry&gt;&gt; getTOCalendarFromAudits(ID poolID, ID empID, Date auditStart, Date auditEnd, Date fromDay) {
<span class="nc" id="L149">		EventAuditTrailManager auditTrailManager = null;</span>
<span class="nc" id="L150">		Collection&lt;AuditTrailEntry&gt; auditEntries = new ArrayList&lt;AuditTrailEntry&gt;();</span>
<span class="nc" id="L151">		Collection&lt;ID&gt; workResourceIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L152">		Map&lt;ID, Collection&lt;AuditTrailEntry&gt;&gt; auditEntriesMap = new HashMap&lt;ID, Collection&lt;AuditTrailEntry&gt;&gt;();</span>

		try {
<span class="nc bnc" id="L155" title="All 2 branches missed.">			if (poolID != null) {</span>
<span class="nc" id="L156">				workResourceIDs.add(poolID);</span>
<span class="nc" id="L157">				Collection&lt;ID&gt; empsInPool = RmManagerFactory.getInstance().getTimeOffDayFacade().getEmployeeIDsForTOPool(poolID, auditStart, auditEnd);</span>
<span class="nc" id="L158">				workResourceIDs.addAll(empsInPool);</span>
			}
<span class="nc bnc" id="L160" title="All 2 branches missed.">			if (empID != null) {</span>
<span class="nc" id="L161">				workResourceIDs.add(empID);</span>
			}
<span class="nc" id="L163">			auditTrailManager = BbmManagerFactory.getEventAuditTrailManager();</span>
<span class="nc" id="L164">			auditEntriesMap = auditTrailManager.getAuditTrail(workResourceIDs, AuditTrailEntry.MODULE_RM_TIME_OFF_POOL_ASSIGNMENT, 0, auditStart, auditEnd, fromDay);</span>
<span class="nc" id="L165">		} catch (Exception e) {}</span>

		// put all audit entries in a list
<span class="nc bnc" id="L168" title="All 2 branches missed.">		for (ID auditEntryKey : auditEntriesMap.keySet()) {</span>
<span class="nc" id="L169">			Collection&lt;AuditTrailEntry&gt; entries = auditEntriesMap.get(auditEntryKey);</span>
<span class="nc" id="L170">			auditEntries.addAll(entries);</span>
<span class="nc" id="L171">		}</span>

		// get a list of audit entries grouped by their action type
<span class="nc" id="L174">		Map&lt;Integer, List&lt;AuditTrailEntry&gt;&gt; ateMap = new HashMap&lt;Integer, List&lt;AuditTrailEntry&gt;&gt;();</span>
<span class="nc bnc" id="L175" title="All 2 branches missed.">		for (AuditTrailEntry ate : auditEntries) {</span>
<span class="nc" id="L176">			Integer ateActType = new Integer(ate.getActionType());</span>

<span class="nc" id="L178">			Collection&lt;AuditTrailProperty&gt; atps = ate.getChildObjects(AuditTrailEntryFieldInfo.CHILD_PROPERTIES);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">			for (AuditTrailProperty atp : atps) {</span>
<span class="nc" id="L180">				ate.addProperty(atp.getName(), atp.getVaue(), atp.getType(), atp.isBeforeValue());</span>
<span class="nc" id="L181">			}</span>

<span class="nc" id="L183">			List&lt;AuditTrailEntry&gt; ateList = ateMap.get(ateActType);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">			if (ateList == null) {</span>
<span class="nc" id="L185">				ateList = new ArrayList&lt;AuditTrailEntry&gt;();</span>
			}
<span class="nc" id="L187">			ateList.add(ate);</span>
<span class="nc" id="L188">			ateMap.put(ateActType, ateList);</span>
<span class="nc" id="L189">		}</span>
<span class="nc" id="L190">		return ateMap;</span>
	}

	private static void fillTOAllocationCalendarForTOPool(DailyHoursBuckets allocBkts, Organization org, Collection toDailyAllocs) throws Exception {
		// use a buckets object for the available hours
<span class="nc" id="L195">		TimeZone orgTimeZone = org.getTimeZone();</span>

		// start date for the availBuckets date range expanded to the orgDayStart
<span class="nc" id="L198">		Date allocBktsStDate = allocBkts.getDHBRangeStartAsOrgDayStart();</span>

		// end date for the availBuckets date range expanded to the orgDayEnd
<span class="nc" id="L201">		Date allocBktsEnDate = allocBkts.getDHBRangeEndAsOrgDayEnd();</span>
		// Access TOAllocation calendar and find allocated hours per day, initialize available bucket array with these numbers

<span class="nc" id="L204">		Calendar cal = Calendar.getInstance(orgTimeZone);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		for (Iterator itt = toDailyAllocs.iterator(); itt.hasNext();) {</span>

<span class="nc" id="L207">			CalendarTimeOffDay toDayAlloc = (CalendarTimeOffDay) itt.next();</span>
<span class="nc bnc" id="L208" title="All 2 branches missed.">			if (toDayAlloc == null) {</span>
<span class="nc" id="L209">				continue;</span>
			}
<span class="nc" id="L211">			LocalDate toDayAllocLocalDate = toDayAlloc.getTimeOffLocalDate();</span>
			// convert local date to java.util.Date in the bucket's timezone.
<span class="nc" id="L213">			Date toDayAllocDate = toDayAllocLocalDate.getTime(allocBkts.getTimeZone());</span>
<span class="nc" id="L214">			int dayBoundaryOffset = org.getDayBoundaryOffset();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">			if (dayBoundaryOffset &gt; 0) {</span>
<span class="nc" id="L216">				cal.setTime(toDayAllocDate);</span>
				// QC 41795 / QA 95083 DST issue: standardize setting of dayBoundaryOffset
<span class="nc" id="L218">				TOCalcUtil.setCalMinsOffsetFromMidnight(cal, dayBoundaryOffset);</span>
<span class="nc" id="L219">				toDayAllocDate = cal.getTime();</span>
			}
			// if the TOAllocations date is outside the buckets range, skip this TODayAllocation.
<span class="nc bnc" id="L222" title="All 4 branches missed.">			if (toDayAllocDate.before(allocBktsStDate) || toDayAllocDate.after(allocBktsEnDate)) {</span>
<span class="nc" id="L223">				continue;</span>
			}
<span class="nc" id="L225">			allocBkts.addToBucket(toDayAllocDate, (float) toDayAlloc.getAllocatedHours());</span>
<span class="nc" id="L226">		}</span>
<span class="nc" id="L227">	}</span>


	/**
	 * Called on behalf of the manager or the agent, from the UI, to retrieve necessary data to render
	 * the TOCalendar for the manager. For each day in the given time range and for the passed interestSet
	 * of 'employees', the following information is returned:
	 * &lt;li&gt; the total scheduled TO hours
	 * &lt;li&gt; the total pending TO hours
	 * &lt;li&gt; the available (allocated) TO hours
	 * &lt;li&gt; dayType: see below.
	 * &lt;p/&gt;
	 * &lt;p/&gt;
	 * Day types in order of decreasing precedence:
	 * &lt;li&gt; Scheduled TO days (only for agent calendar).
	 * &lt;li&gt; Pending TO days (only for agent calendar).
	 * &lt;li&gt; blackout days.
	 * &lt;li&gt; paid holidays (non working holidays)
	 * &lt;li&gt; days of non operation
	 * &lt;li&gt; unpaid holidays (working holidays)
	 * &lt;li&gt; TO_HOURS_NOTAVAILABLE_DAY_TYPE / TO_HOURS_AVAILABLE_DAY_TYPE
	 * &lt;p/&gt;
	 *
	 * @param intSetEmpIDs Collection of employee IDs to display pending / sched hours only
	 * @param empIDs       collection of employee ids to display color /availability of hours
	 * @param org          org selected in left pane / or Org of the employee
	 * @return
	 * @throws Exception
	 */
	private static TOCalendarDayData[] getTOCalendar(boolean isIndvlEmp, Collection&lt;ID&gt; empIDsPendingScheduledHours, Collection&lt;ID&gt; empIDsForColorAvail, 
			ID pTOPoolID, Organization org, TimeRange toCalRange, ID activityID) throws Exception {
<span class="nc" id="L258">		long startTime = Calendar.getInstance().getTime().getTime();</span>
<span class="nc" id="L259">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L260">		TimeZone orgTimeZone = org.getTimeZone();</span>

<span class="nc" id="L262">		DailyHoursBuckets[] pendAndSchedBktArray = fillPendingAndSchedBkts(isIndvlEmp, empIDsPendingScheduledHours, empIDsForColorAvail, pTOPoolID, org, toCalRange, </span>
																			activityID);

<span class="nc" id="L265">		DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange);</span>
<span class="nc" id="L266">		ArrayList toDailyAllocs = new ArrayList();</span>
<span class="nc bnc" id="L267" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
<span class="nc" id="L268">			toDailyAllocs.addAll(getTOAllocationCalendar(pTOPoolID, org.getID(), orgTimeZone, toCalRange));</span>
<span class="nc" id="L269">			fillTOAllocationCalendarForTOPool(toAllocHrsBkts, org, toDailyAllocs);</span>
		}
		// Now, build the result array fill in its data based on the contents of the different buckets.
<span class="nc" id="L272">		TOCalendarDayData[] pTOCalDayDataArray = new TOCalendarDayData[toAllocHrsBkts.getSize()];</span>
<span class="nc" id="L273">		fillCalDayDataAndMarkDayAvailability(org, pTOPoolID, toAllocHrsBkts, pendAndSchedBktArray, pTOCalDayDataArray);</span>

		// Get the holiday data during the range
<span class="nc" id="L276">		Collection holidayCol = RequestUtil.getHolidaysDuringPeriod(org, toCalRange);</span>

		// Mark all the &quot;unpaid&quot; holidays, i.e working holidays. We'll mark the Paid holidays after handing the
		// non-operation days since Paid holidays have precedence over days of non-operation
<span class="nc" id="L280">		markHolidays(holidayCol, org, toAllocHrsBkts, pTOCalDayDataArray, true);</span>

		// Now, mark the days of non-operation
<span class="nc" id="L283">		Collection hoos = RequestUtil.getHooAssignmentsDuringPeriod(org, toCalRange);</span>

		// Loop through all the OrganizationHOO objects returned and apply any
		// non-operation days to the result array
<span class="nc" id="L287">		markNonOperationalDays(hoos, toCalRange, orgTimeZone, toAllocHrsBkts, pTOCalDayDataArray, orgDayOffset);</span>

		// Now, go through the holidays again and mark the paid holidays,  i.e. ones that are non-working
<span class="nc" id="L290">		markHolidays(holidayCol, org, toAllocHrsBkts, pTOCalDayDataArray, false);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
			// Finally, loop through the Calendar Timeoff Days read above and mark the blackout days. These have the highest precedence
<span class="nc" id="L293">			markBlackOutDays(toDailyAllocs, toAllocHrsBkts, pTOCalDayDataArray, org);</span>
		}
<span class="nc" id="L295">		markOrgBlackOutDays(holidayCol, toAllocHrsBkts, pTOCalDayDataArray, org);</span>
		// Pending and scheduled days only apply for agent's TO Calendar.
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (isIndvlEmp) {</span>
			// Note: Scheduled_DAY_TYPE has higher precedence than PENDING_DAY_TYPE
<span class="nc" id="L299">			markPendingOrScheduledDays(pTOCalDayDataArray, pendAndSchedBktArray);</span>
		}
<span class="nc" id="L301">		m_cat.debug(&quot;Time taken for loading calendar is &quot; + (startTime - Calendar.getInstance().getTime().getTime()));</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">		for(int i=0 ;i&lt;pTOCalDayDataArray.length;i++){</span>
<span class="nc" id="L303">			pTOCalDayDataArray[i].setM_org(org);</span>
		}
<span class="nc" id="L305">		return pTOCalDayDataArray;</span>
	}
	
	private static DailyHoursBuckets[] fillPendingAndSchedBkts(boolean isIndvlEmp, Collection&lt;ID&gt; empIDsOfInterest, Collection&lt;ID&gt; empIDsOrg, 
							ID pTOPoolID, Organization org, TimeRange toCalRange, ID activityID) throws Exception {
<span class="nc" id="L310">		int orgDayOffset = org.getDayBoundaryOffset();</span>
<span class="nc" id="L311">		TimeZone orgTimeZone = org.getTimeZone();</span>
		//This is for showing Scheduled Hours on Calendar. can be used in org mode or for specific TOPool
<span class="nc" id="L313">		DailyHoursBuckets intSetSchedHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange, isIndvlEmp);</span>
		//This is for showing Pending Hours on Calendar. can be used in org mode or for specific TOPool
<span class="nc" id="L315">		DailyHoursBuckets intSetPendHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange, isIndvlEmp);</span>


		// orgSchedBuckets: scheduled TO hours/day for all employees in the organization.
		// Note: orgSchedBuckets is not returned to the caller. Only used to determine the colors.
		// i.e. if a given day has exceeded/not exceeded the allocated TO hours.
		//This is for finding actual scheduled hours for the TOPool. is not applicable for Org Mode
<span class="nc" id="L322">		DailyHoursBuckets toPoolSchedHrsBkts = new DailyHoursBuckets(orgDayOffset, orgTimeZone, toCalRange);</span>
<span class="nc" id="L323">		HashSet&lt;ID&gt; allEmpIds = new HashSet&lt;ID&gt;((empIDsOrg.size() + empIDsOfInterest.size()) * 2);</span>
<span class="nc" id="L324">		allEmpIds.addAll(empIDsOrg);</span>
<span class="nc" id="L325">		allEmpIds.addAll(empIDsOfInterest);</span>

<span class="nc" id="L327">		Collection&lt;ID&gt; activityList = getListOfDailyPoolAllotmentActivities(null);</span>
<span class="nc" id="L328">		Collection[] hrsPerDayCol = getHoursPerDayForCalendar(allEmpIds, empIDsOfInterest, toCalRange, activityList);</span>
<span class="nc" id="L329">		Collection hrsPerDayPendCol = hrsPerDayCol[TOCalendarUtil.BKT_PENDING];  	//has pending data</span>
<span class="nc" id="L330">		Collection hrsPerDaySchedCol = hrsPerDayCol[TOCalendarUtil.BKT_SCHED];   //this collection has scheduled data</span>


<span class="nc" id="L333">		Collection childOrgs = new ArrayList();</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (pTOPoolID == null) {</span>
			  // get all child orgs
<span class="nc" id="L336">			childOrgs.add(org.getID()); </span>
<span class="nc" id="L337">			childOrgs.addAll(BbmManagerFactory.getWorkResourceManager().getOrganizationsChildrenByIDs(Collections.singleton(org.getID())));</span>
		}
<span class="nc" id="L339">		TimeRange minMaxRange = getMinMaxRange(hrsPerDayCol);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (minMaxRange == null) {</span>
<span class="nc" id="L341">			minMaxRange = toCalRange;</span>
		}
<span class="nc" id="L343">		Date stDate = getBackAyearforDate(minMaxRange.getStartDate());</span>
<span class="nc" id="L344">		Date enDate = minMaxRange.getEndDate();</span>

<span class="nc" id="L346">		HashMap wras = RequestUtil.getWorkResourceManager().getValidWorkResourceAssignments(allEmpIds,</span>
<span class="nc" id="L347">		        new LocalDate(stDate, org.getTimeZone()), new LocalDate(enDate, org.getTimeZone()), false);</span>
<span class="nc" id="L348">		CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L349">		HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap = toCalFacade.getTOPoolsForWorkResources(allEmpIds, stDate, enDate);</span>
		// fill the orgScheduled and interestSetScheduled buckets.
<span class="nc" id="L351">		fillSchedDailyHoursBuckets(isIndvlEmp,pTOPoolID, hrsPerDaySchedCol, empIDsOfInterest, intSetSchedHrsBkts, </span>
									toPoolSchedHrsBkts, childOrgs, wras, empTOPoolAssnMap);
<span class="nc" id="L353">		fillTOPendingDailyHoursBuckets( isIndvlEmp,pTOPoolID, hrsPerDayPendCol, empIDsOfInterest, intSetPendHrsBkts, </span>
										childOrgs, wras, empTOPoolAssnMap, activityID);
<span class="nc" id="L355">		DailyHoursBuckets[] bktArray = new DailyHoursBuckets[3];</span>
<span class="nc" id="L356">		bktArray[BKT_PENDING] = intSetPendHrsBkts;</span>
<span class="nc" id="L357">		bktArray[BKT_SCHED] = intSetSchedHrsBkts;</span>
<span class="nc" id="L358">		bktArray[BKT_SCHED_TOPOOL] = toPoolSchedHrsBkts;</span>
<span class="nc" id="L359">		return bktArray;</span>

	}


	/**
	 * @param pTOCalDayDataArr
	 */
	private static void markPendingOrScheduledDays(TOCalendarDayData[] result, DailyHoursBuckets[] pendAndSchedBktArray) {
		// scan each day of the time off calendar
<span class="nc bnc" id="L369" title="All 4 branches missed.">		if (pendAndSchedBktArray == null || pendAndSchedBktArray.length &lt; 2) {</span>
<span class="nc" id="L370">			return;  //No point in going ahead we do not have Pending and Scheduled hours</span>
		}
<span class="nc" id="L372">		DailyHoursBuckets schedBkts = pendAndSchedBktArray[BKT_SCHED];</span>
<span class="nc" id="L373">		DailyHoursBuckets pendBkts = pendAndSchedBktArray[BKT_PENDING];</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		Calendar currDayCal = schedBkts != null ? schedBkts.getFirstDay() : pendBkts.getFirstDay();</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">		Date endDate = schedBkts != null ? schedBkts.getDHBRangeEndAsOrgDayEnd() : pendBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc bnc" id="L376" title="All 4 branches missed.">		for (int i = 0; !currDayCal.getTime().after(endDate) &amp;&amp; i &lt; result.length; i++) {</span>
<span class="nc" id="L377">			Date currDay = currDayCal.getTime();</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			ArrayList toHrsPerDaySchedCol = schedBkts != null ? schedBkts.getTOHoursPerDayForDate(currDay) : null;</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">			ArrayList toHrsPerDayPendCol = pendBkts != null ? pendBkts.getTOHoursPerDayForDate(currDay) : null;</span>
			// Figure out what type of day this is.
			// At this point, we just care about whether there is a pending or scheduled Time Off that intersects this day.
			// Does not matter how many hours are accounted for that;
			// we will show it as scheduled Time-off day even if accounted hours are zero because emp has sched TO on that day.
<span class="nc bnc" id="L384" title="All 4 branches missed.">			if (toHrsPerDaySchedCol != null &amp;&amp; !toHrsPerDaySchedCol.isEmpty()) {</span>
<span class="nc" id="L385">				result[i].setDayType(TOCalendarDayData.SCHEDULED_DAY_TYPE);</span>
<span class="nc bnc" id="L386" title="All 4 branches missed.">			} else if (toHrsPerDayPendCol != null &amp;&amp; !toHrsPerDayPendCol.isEmpty()) {</span>
<span class="nc" id="L387">				result[i].setDayType(TOCalendarDayData.PENDING_DAY_TYPE);</span>
			}
<span class="nc" id="L389">			TOCalcUtil.addDaysToCalendar(currDayCal, 1);</span>
		}
<span class="nc" id="L391">	}</span>

	/**
	 * Fills the following information for each TODay in the passed TOCalendarDayData[].
	 * &lt;li&gt; allocated hours for the org
	 * &lt;li&gt; pending hours for a subset of the employees in the org
	 * &lt;li&gt; scheduled hours for a subset of the employees in the org
	 * &lt;li&gt; remaining hours for the org
	 * &lt;li&gt; Mark each day as TO_HOURS_AVAILABLE_DAY_TYPE or TO_HOURS_AVAILABLE_DAY_TYPE
	 *
	 * @param orgID
	 * @param allocatedBuckets     Contains the number of allocated hours per day for the org
	 * @param pendAndSchedBktArray contains
	 *                             scheduledBuckets  Contains the number of scheduled hours per day for a subset of the employees in the interest set
	 *                             toPoolScheduledBuckets Contains the number of scheduled hours per day for all of the employees in the TOPool
	 *                             pendingBuckets   Contains the number of pending hours per day for a subset of the employees in the interest set
	 * @param result
	 */
	private static void fillCalDayDataAndMarkDayAvailability(Organization org, ID pTOPoolID,
	                                                         DailyHoursBuckets allocatedBuckets,
	                                                         DailyHoursBuckets[] pendAndSchedBktArray,
	                                                         TOCalendarDayData[] result) {
<span class="nc" id="L413">		Calendar currDayCal = allocatedBuckets.getFirstDay();</span>
<span class="nc" id="L414">		Date dailyBktsRangeEndDate = allocatedBuckets.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">		for (int i = 0; !currDayCal.getTime().after(dailyBktsRangeEndDate); i++) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">			if (i &lt; result.length) {// #29337: Prevent array index out of bounds</span>
				// exception.
<span class="nc" id="L418">				Date dateCurrDay = currDayCal.getTime();</span>
<span class="nc" id="L419">				result[i] = new TOCalendarDayData(dateCurrDay, org, pTOPoolID);</span>
<span class="nc" id="L420">				result[i].setHourAvail(allocatedBuckets.getBucketHours(dateCurrDay));</span>
<span class="nc" id="L421">				result[i].setHourPending(pendAndSchedBktArray[BKT_PENDING].getBucketHours(dateCurrDay));</span>
<span class="nc" id="L422">				result[i].setScheduledTO(pendAndSchedBktArray[BKT_SCHED].getBucketHours(dateCurrDay));</span>

<span class="nc" id="L424">				float hoursAvailable = allocatedBuckets.getBucketHours(dateCurrDay) - pendAndSchedBktArray[BKT_SCHED_TOPOOL].getBucketHours(dateCurrDay);</span>
<span class="nc bnc" id="L425" title="All 2 branches missed.">				if (hoursAvailable &lt; 0) {</span>
<span class="nc" id="L426">					hoursAvailable = 0;</span>
				}
<span class="nc" id="L428">				result[i].setHourRemaining(hoursAvailable);</span>

				// Figure out what type of day this is. At this point, we merely figure out whether the day has available hours or
				// not. We'll add holiday, non-operation and blackout days later (see below methods). (recall they all override
				// available/non-available dayTypes)
<span class="nc bnc" id="L433" title="All 2 branches missed.">				if (allocatedBuckets.getBucketHours(dateCurrDay) &gt; pendAndSchedBktArray[BKT_SCHED_TOPOOL].getBucketHours(dateCurrDay)) {</span>
<span class="nc" id="L434">					result[i].setDayType(TOCalendarDayData.TO_HOURS_AVAILABLE_DAY_TYPE);</span>
				} else {
<span class="nc" id="L436">					result[i].setDayType(TOCalendarDayData.NO_TO_HOURS_AVAILABLE_DAY_TYPE);</span>
				}
			}
<span class="nc" id="L439">			TOCalcUtil.addDaysToCalendar(currDayCal, 1);</span>
		}
<span class="nc" id="L441">	}</span>

	/**
	 * Mark non operational days in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using the org's HOO,
	 *
	 * @param hoos
	 * @param TOCalRange
	 * @param orgTimeZone
	 * @param availableBuckets
	 * @param TOCalDayDataArr
	 */
	private static void markNonOperationalDays(Collection hoos, TimeRange TOCalRange, TimeZone orgTimeZone,
			DailyHoursBuckets availableBuckets, TOCalendarDayData[] TOCalDayDataArr, int dayBoundaryOffset) {
<span class="nc bnc" id="L455" title="All 2 branches missed.">		if (hoos == null) {</span>
<span class="nc" id="L456">			hoos = Collections.emptyList();</span>
		}

<span class="nc" id="L459">		Calendar orgTZCal = Calendar.getInstance(orgTimeZone);</span>
<span class="nc bnc" id="L460" title="All 2 branches missed.">		for (Iterator hoosIter = hoos.iterator(); hoosIter.hasNext();) {</span>
<span class="nc" id="L461">			OrganizationHOO hoo = (OrganizationHOO) hoosIter.next();</span>

			// Note: if the HOO is not defined for the entire TOCalendar range, then the TOCalendar's
			// range needs to be adjusted.
			//
			// Pick the later of TOCalendar range startDate or HOO effectivity startDate
<span class="nc" id="L467">			Date hooStartTime = hoo.getStartTime();</span>
<span class="nc" id="L468">			Date adjTOCalStart = TOCalRange.getStartDate();</span>
<span class="nc bnc" id="L469" title="All 4 branches missed.">			adjTOCalStart = ((hooStartTime != null) &amp;&amp; hooStartTime.after(adjTOCalStart)) ? hooStartTime : adjTOCalStart;</span>

			// Pick the earlier of TOCalendar range endDate or HOO effectivity endDate
<span class="nc" id="L472">			Date hooEndTime = hoo.getEndTime();</span>
<span class="nc" id="L473">			Date adjTOCalEnd = TOCalRange.getEndDate();</span>
<span class="nc bnc" id="L474" title="All 4 branches missed.">			adjTOCalEnd = ((hooEndTime != null) &amp;&amp; hooEndTime.before(adjTOCalEnd)) ? hooEndTime : adjTOCalEnd;</span>

<span class="nc" id="L476">			orgTZCal.setTime(adjTOCalStart); // reuse calendar</span>

			do {
<span class="nc" id="L479">				int day = orgTZCal.get(Calendar.DAY_OF_WEEK);</span>

<span class="nc bnc" id="L481" title="All 2 branches missed.">				if (!hoo.isActive((short) day)) {</span>
					// transalte time to day index (array index).
<span class="nc" id="L483">					int ix = availableBuckets.getIndex(orgTZCal.getTime());</span>
<span class="nc" id="L484">					TOCalDayDataArr[ix].setDayType(TOCalendarDayData.NON_OPERATION_DAY_TYPE);</span>
				}

<span class="nc" id="L487">				TOCalcUtil.addDaysToCalendar(orgTZCal, 1);</span>
<span class="nc" id="L488">				TOCalcUtil.setCalMinsOffsetFromMidnight(orgTZCal, dayBoundaryOffset);</span>
<span class="nc bnc" id="L489" title="All 2 branches missed.">			} while (!orgTZCal.getTime().after(adjTOCalEnd));</span>

			// As a corner case its possible to have TOCalendarDayData for a date that falls after the end date, adjTOCalEnd.
			// For such scenarios, make a check to see if the TOCalendarDayData is for a non-operational day.
			// For scenarios that are not this corner case, you could get an illegal argument exception when
			// accessing daily hours bucket for a date that is after its range's end date.
			// Then, there is no need to check the corner case non-operational day.
			try {
<span class="nc" id="L497">				int ix = availableBuckets.getIndex(orgTZCal.getTime());</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">				if (ix == TOCalDayDataArr.length - 1) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">					if (!hoo.isActive((short) orgTZCal.get(Calendar.DAY_OF_WEEK))) {</span>
<span class="nc" id="L500">						TOCalDayDataArr[ix].setDayType(TOCalendarDayData.NON_OPERATION_DAY_TYPE);</span>
					}
				}
<span class="nc" id="L503">			} catch (IllegalArgumentException e) {}</span>

<span class="nc" id="L505">		}</span>
<span class="nc" id="L506">	}</span>

	/**
	 * Mark blackout days in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using black out days defined in the TOAllocation calendar.
	 *
	 * @param toDayAllocs
	 * @param availableBuckets
	 * @param result
	 */
	private static void markBlackOutDays(Collection toDayAllocs, DailyHoursBuckets availBkts, TOCalendarDayData[] result, Organization org) {
<span class="nc bnc" id="L517" title="All 2 branches missed.">		if (toDayAllocs == null) {</span>
<span class="nc" id="L518">			toDayAllocs = Collections.emptyList();</span>
		}

<span class="nc" id="L521">		Date availBktsRangeStart = availBkts.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L522">		Date availBktsRangeEnd = availBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc" id="L523">		TimeZone availBktsTZ = availBkts.getTimeZone();</span>
<span class="nc" id="L524">		Calendar cal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">		for (Iterator toDayAllocsIter = toDayAllocs.iterator(); toDayAllocsIter.hasNext();) {</span>
<span class="nc" id="L526">			CalendarTimeOffDay toDailyAlloc = (CalendarTimeOffDay) toDayAllocsIter.next();</span>

<span class="nc bnc" id="L528" title="All 2 branches missed.">			if (toDailyAlloc.isBlackOutDay()) {</span>
<span class="nc" id="L529">				LocalDate toDailyAllocLocalDate = toDailyAlloc.getTimeOffLocalDate();</span>
<span class="nc" id="L530">				Date toDailyAllocDate = toDailyAllocLocalDate.getTime(availBktsTZ);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">				if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L532">					cal.setTime(toDailyAllocDate);</span>
					// QC 41795 / QA 95083 DST issue: standardize setting of dayBoundaryOffset
<span class="nc" id="L534">					TOCalcUtil.setCalMinsOffsetFromMidnight(cal, org.getDayBoundaryOffset());</span>
<span class="nc" id="L535">					toDailyAllocDate = cal.getTime();</span>
				}
				// ensure that the date for the 'dailyTOAlloc' falls within the bucket's time range.
				// Otherwise an 'illegalArgumentException' will be thrown in the next call.
<span class="nc bnc" id="L539" title="All 4 branches missed.">				if (toDailyAllocDate.before(availBktsRangeStart) || toDailyAllocDate.after(availBktsRangeEnd)) {</span>
<span class="nc" id="L540">					continue;</span>
				}
<span class="nc" id="L542">				int ix = availBkts.getIndex(toDailyAllocDate);</span>
<span class="nc" id="L543">				result[ix].setDayType(TOCalendarDayData.BLACKOUT_DAY_TYPE);</span>
			}
<span class="nc" id="L545">		}</span>
<span class="nc" id="L546">	}</span>

	private static void markOrgBlackOutDays(Collection holidayCol, DailyHoursBuckets availBkts, TOCalendarDayData[] result, Organization org) {
		//mark the blackout days only if they are enabled for the org.
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (!TORequestUtil.isBlackOutDaySettingEnabledForOrg()) {</span>
<span class="nc" id="L551">			return;</span>
		}
<span class="nc" id="L553">		Date availBucketsStartDate = availBkts.getDHBRangeStartAsOrgDayStart();</span>
<span class="nc" id="L554">		Date availBucketsEndDate = availBkts.getDHBRangeEndAsOrgDayEnd();</span>
<span class="nc" id="L555">		TimeZone availBucketsTimeZone = availBkts.getTimeZone();</span>
<span class="nc bnc" id="L556" title="All 2 branches missed.">		for (Iterator iterator = holidayCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L557">			Holiday holiday = (Holiday) iterator.next();</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">			if (!holiday.isBlackOutDay()) {</span>
<span class="nc" id="L559">				continue; //We are interested in blackout days only</span>
			}
<span class="nc" id="L561">			Date holidayStart = holiday.getStartDate().getTime(availBucketsTimeZone);</span>
<span class="nc" id="L562">			Date holidayEnd = holiday.getEndDate().getTime(availBucketsTimeZone);</span>
			// ignore any holidays with no overlap
<span class="nc" id="L564">			long overlap = RequestUtil.getOverlapLength(availBucketsStartDate, availBucketsEndDate, holidayStart, holidayEnd);</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">			if (overlap == 0) {</span>
<span class="nc" id="L566">				continue;</span>
			}
			// a holiday can start before the availableBuckets.startDate. Adjust holidayStart to beginning
			// of availableBuckets.startDate if necessary.
<span class="nc bnc" id="L570" title="All 2 branches missed.">			Date overlapHolStart = holidayStart.before(availBucketsStartDate) ? availBucketsStartDate : holidayStart;</span>

			// a holiday might end after availBuckets.endDate. In this case adjust the holidayEnd to
			// availableBuckets.endDate if necessary.
<span class="nc bnc" id="L574" title="All 2 branches missed.">			Date overlapHolEnd = holidayEnd.after(availBucketsEndDate) ? availBucketsEndDate : holidayEnd;</span>
			// The result array is indexed identically as the availableBuckets array
<span class="nc" id="L576">			int ix = availBkts.getIndex(overlapHolStart);</span>
<span class="nc" id="L577">			int overlapHolEndIdx = availBkts.getIndex(overlapHolEnd);</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">			for (; ix &lt;= overlapHolEndIdx; ix++) {</span>
<span class="nc" id="L579">				result[ix].setDayType(TOCalendarDayData.BLACKOUT_DAY_TYPE);</span>
			}
<span class="nc" id="L581">		}</span>
<span class="nc" id="L582">	}</span>

	private static TimeRange getMinMaxRange(Collection[] hrsPerDayCol) {
<span class="nc" id="L585">		Date startDate = null;</span>
<span class="nc" id="L586">		Date endDate = null;</span>
		TOHoursPerDay hoursPerDay;
<span class="nc bnc" id="L588" title="All 4 branches missed.">		for (int i = 0; hrsPerDayCol != null &amp;&amp; i &lt; hrsPerDayCol.length; i++) {</span>
<span class="nc" id="L589">			Collection toHoursPerDayCol = hrsPerDayCol[i];</span>
<span class="nc bnc" id="L590" title="All 4 branches missed.">			if (toHoursPerDayCol != null &amp;&amp; !toHoursPerDayCol.isEmpty()) {</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">				for (Iterator it = toHoursPerDayCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L592">					hoursPerDay = (TOHoursPerDay) it.next();</span>
<span class="nc bnc" id="L593" title="All 4 branches missed.">					startDate = startDate == null || startDate.after(hoursPerDay.getStartTime()) ? hoursPerDay.getStartTime() : startDate;</span>
<span class="nc bnc" id="L594" title="All 4 branches missed.">					endDate = endDate == null || endDate.before(hoursPerDay.getEndTime()) ? hoursPerDay.getEndTime() : endDate;</span>
				}
			}
		}
<span class="nc" id="L598">		TimeRange range = null;</span>
<span class="nc bnc" id="L599" title="All 4 branches missed.">		if (startDate != null &amp;&amp; endDate != null) {</span>
<span class="nc" id="L600">			range = new TimeRange(startDate, endDate);</span>
		}
<span class="nc" id="L602">		return range;</span>
	}

	/**
	 * &lt;li&gt; Fetches all published toEvents for orgEmployees during the specified time range.
	 * &lt;li&gt; for each toEvent, computes the daily hours for the event and adds it to the
	 * orgScheduledBucket and scheduledBucket (if necessary).
	 *
	 * @param interestSet
	 * @param schedBkts
	 * @param intSetSchedBkts
	 * @param empTOPoolAssnMap
	 * @throws Exception
	 */
	private static void fillSchedDailyHoursBuckets(boolean isIndvlEmp,ID pTOPoolID, Collection toHrsPerDayCol, Collection interestSet,
	                                               DailyHoursBuckets schedBkts, DailyHoursBuckets intSetSchedBkts, Collection childOrgs, 
	                                               HashMap empWrs, HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap) throws Exception {
<span class="nc bnc" id="L619" title="All 4 branches missed.">		if (toHrsPerDayCol == null || toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L620">			return;</span>
		}
<span class="nc bnc" id="L622" title="All 2 branches missed.">		for (Iterator itt = toHrsPerDayCol.iterator(); itt.hasNext();) {</span>
<span class="nc" id="L623">			TOHoursPerDay hrsPerDay = (TOHoursPerDay) itt.next();</span>
<span class="nc" id="L624">			Organization currOrg = getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc" id="L625">			TimeRange overlapTimeRange = getRelevantTimeRange(isIndvlEmp,pTOPoolID, intSetSchedBkts, childOrgs, empTOPoolAssnMap, currOrg, hrsPerDay);</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">			if(overlapTimeRange==null) {</span>
<span class="nc" id="L627">				continue;</span>
				// add the time off hours for this time off event to the org bucket(which holds the cumulative timeoff for all employees in the org)
				// using overlapStartTime and overlapEndTime to ensure that hours are processed only for the
				// overlap region to avoid IllegalArgumentException (actually IndexOutOfBoundException)
			}

			//This block is for colors or for calculating correct hours
<span class="nc bnc" id="L634" title="All 8 branches missed.">			if (intSetSchedBkts != null &amp;&amp;(pTOPoolID != null || (childOrgs.contains(currOrg.getID()) &amp;&amp; interestSet.contains(hrsPerDay.getEmployeeID())))) {</span>
<span class="nc" id="L635">				addHoursToDailyBuckets(intSetSchedBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
			}
			//This block displays the Scheduled hours
<span class="nc bnc" id="L638" title="All 6 branches missed.">			if (schedBkts != null &amp;&amp; interestSet != null &amp;&amp; interestSet.contains(hrsPerDay.getEmployeeID())) {</span>
<span class="nc" id="L639">				addHoursToDailyBuckets(schedBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
			}
<span class="nc" id="L641">		}</span>
<span class="nc" id="L642">	}</span>
	public static TimeRange getRelevantTimeRange(boolean isIndvlEmp,ID pTOPoolID, DailyHoursBuckets bkts,Collection&lt;ID&gt; childOrgs,
												Map&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap, 
												Organization currOrg, TOHoursPerDay hrsPerDay) throws Exception {
<span class="nc bnc" id="L646" title="All 2 branches missed.">		if (currOrg == null) {</span>
<span class="nc" id="L647">			m_cat.debug(&quot;ignoring TOHoursPerday because currOrg == null: HRSPERDAY :&quot; + hrsPerDay);</span>
			//employee has been terminated or has been changed org and does not belong to the current requested list
<span class="nc" id="L649">			return null; </span>
		}
<span class="nc bnc" id="L651" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
			//check if employee belongs to same TOPool on start date. if not then skip this TO Event
			
			//JT activityID
<span class="nc" id="L655">			Date hrsPerDayStartTime = hrsPerDay.getStartTime();</span>
<span class="nc" id="L656">			Date hrsPerDayEndTime = hrsPerDay.getEndTime();</span>
			
<span class="nc" id="L658">			ID hrsPerDayEmpID = hrsPerDay.getEmployeeID();</span>
<span class="nc" id="L659">			ID hrsPerDayActivityID = hrsPerDay.getActivityID();</span>
<span class="nc" id="L660">			List&lt;EmpTOPoolAssignment&gt; empTOPoolList = empTOPoolAssnMap.get(hrsPerDayEmpID);</span>
			
<span class="nc" id="L662">			ID empTOPoolID = getTOPoolIDforDate(hrsPerDayStartTime, empTOPoolList, hrsPerDayActivityID);</span>
			
<span class="nc bnc" id="L664" title="All 4 branches missed.">			if (empTOPoolID == null || !empTOPoolID.equals(pTOPoolID)) {</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">				if (!isIndvlEmp) {</span>
<span class="nc" id="L666">					m_cat.debug(&quot;ignoring TOHoursPerday because employee does not belong to this TOPOOL=&quot; + empTOPoolID + &quot;: HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L667">					return null;  // Return null because it is a TOPOOL View and this request does not belong to the given TO Pool</span>
				}
				//proceed for the user even if request does not belong to the current TOPOOL.
				// We still check if the request intersects with TOPOOL effectviity. if yes, then add it in current TOPOOL
				// because the TO has been requested in the earlier TOPOOL and has overflown into time range of this pool.
				//the time off falls in the transition zone.
				
<span class="nc" id="L674">				EmpTOPoolAssignment poolAss =  TOPoolUtil.getTOPoolAssignmentForOneEmployee(pTOPoolID, empTOPoolList, hrsPerDayActivityID);</span>
				
<span class="nc bnc" id="L676" title="All 4 branches missed.">				if (poolAss == null || !TimePeriodUtil.overlap(poolAss.getStartTime(),  poolAss.getEndTime(), hrsPerDayStartTime, hrsPerDayEndTime)) {</span>
<span class="nc" id="L677">					m_cat.debug(&quot;ignoring TOHoursPerday because TO does not belong to / intersect with this TOPOOL=&quot; + empTOPoolID + &quot;: HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L678">					return null;</span>
				}
			}
<span class="nc bnc" id="L681" title="All 4 branches missed.">		} else if (childOrgs == null || !childOrgs.contains(currOrg.getID())) {</span>
<span class="nc" id="L682">			m_cat.debug(&quot;ignoring TOHoursPerday because childOrgs == null || !childOrgs.contains(currOrg.getID()): HRSPERDAY :&quot; + hrsPerDay);</span>
<span class="nc" id="L683">			return null; //employee has been terminated or has been changed org and does not belong to the current requested list</span>
		}
<span class="nc" id="L685">		return RequestUtil.getOverlapTimeRange(hrsPerDay, bkts);</span>
	}

	public static Organization getOrgforDate(Date startDate, Collection wrs) throws Exception {
<span class="nc bnc" id="L689" title="All 2 branches missed.">		if (wrs != null) {</span>
<span class="nc" id="L690">			Iterator it = wrs.iterator();</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L692">				WorkResourceAssignment wra = (WorkResourceAssignment) it.next();</span>
<span class="nc bnc" id="L693" title="All 6 branches missed.">				if (!startDate.before(wra.getStartTime()) &amp;&amp; (wra.getEndTime() == null || startDate.before(wra.getEndTime()))) {</span>
<span class="nc" id="L694">					return ValidationUtil.getOrganizationByID(wra.getOrganizationID());</span>
				}
<span class="nc" id="L696">			}</span>
		}
<span class="nc" id="L698">		return null;</span>
	}
	
	
	public static ID getTOPoolIDforDate(Date startDate, List&lt;EmpTOPoolAssignment&gt; list, ID activityID) throws Exception {//NOSONAR
<span class="nc" id="L703">		return TOPoolUtil.getTOPoolIDforDate(startDate, list, activityID);</span>
		
	}

	public static ID adjustForPoolByActivity(ID activityID) {
<span class="nc bnc" id="L708" title="All 2 branches missed.">		return LicenseUtil.isAdvancedRMLicense() ? activityID : null;</span>
	}


	

	private static void fillTOPendingDailyHoursBuckets(boolean isIndvlEmp,ID pTOPoolID, Collection toHrsPerDayCol, Collection interestSet,
	                                                   DailyHoursBuckets pendBkts, Collection childOrgs, 
	                                                   HashMap empWrs, HashMap&lt;ID, List&lt;EmpTOPoolAssignment&gt;&gt; empTOPoolAssnMap,
	                                                   ID activityID) throws Exception {
<span class="nc bnc" id="L718" title="All 4 branches missed.">		if (toHrsPerDayCol == null || toHrsPerDayCol.isEmpty()) {</span>
<span class="nc" id="L719">			return;</span>
		}
<span class="nc bnc" id="L721" title="All 2 branches missed.">		for (Iterator itt = toHrsPerDayCol.iterator(); itt.hasNext();) {</span>
<span class="nc" id="L722">			TOHoursPerDay hrsPerDay = (TOHoursPerDay) itt.next();</span>
<span class="nc bnc" id="L723" title="All 2 branches missed.">			if (!interestSet.contains(hrsPerDay.getEmployeeID())) {</span>
<span class="nc" id="L724">				continue;</span>
			}
<span class="nc" id="L726">			Organization currOrg = getOrgforDate(hrsPerDay.getStartTime(), (Collection) empWrs.get(hrsPerDay.getEmployeeID()));</span>
<span class="nc" id="L727">			TimeRange overlapTimeRange = getRelevantTimeRange(isIndvlEmp,pTOPoolID, pendBkts, childOrgs, empTOPoolAssnMap, currOrg, hrsPerDay);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">			if (overlapTimeRange == null) {</span>
<span class="nc" id="L729">				continue;</span>
			}
			// add the time off hours for this time off event to the org bucket (which holds the cumulative timeoff for
			// all employees in the org) using overlapStartTime and overlapEndTime to ensure that hours are processed
			// only for the overlap region to avoid IllegalArgumentException (actually IndexOutOfBoundException)
<span class="nc" id="L734">			addHoursToDailyBuckets(pendBkts, hrsPerDay, overlapTimeRange, currOrg);</span>
<span class="nc" id="L735">		}</span>
<span class="nc" id="L736">	}</span>

	/**
	 * Mark working holidays in the given {@link TOCalendarDayData TOCalendarDayData}
	 * array using the holidays defined for the org.
	 *
	 * @param holidays
	 * @param orgTz
	 * @param availableBuckets
	 * @param result
	 */
	private static void markHolidays(Collection holidays, Organization org, DailyHoursBuckets availableBuckets,
	                                 TOCalendarDayData[] result, boolean markUnPaid) {
<span class="nc bnc" id="L749" title="All 2 branches missed.">		if (holidays == null) {</span>
<span class="nc" id="L750">			holidays = Collections.emptyList();</span>
		}

<span class="nc" id="L753">		Date availBucketsStartDate = availableBuckets.getRange().getStartDate();</span>
<span class="nc" id="L754">		Date availBucketsEndDate = availableBuckets.getDHBRangeEndAsOrgDayEnd();</span>

<span class="nc" id="L756">		TimeZone availBucketsTimeZone = availableBuckets.getTimeZone();</span>

<span class="nc bnc" id="L758" title="All 2 branches missed.">		for (Iterator it = holidays.iterator(); it.hasNext();) {</span>
<span class="nc" id="L759">			Holiday holiday = (Holiday) it.next();</span>
<span class="nc bnc" id="L760" title="All 8 branches missed.">			if ((markUnPaid &amp;&amp; holiday.isUnPaidHoliday()) || (holiday.isPaidHoliday() &amp;&amp; !markUnPaid)) {</span>
<span class="nc" id="L761">				Date holidayStart = holiday.getStartDate().getTime(availBucketsTimeZone);</span>
<span class="nc" id="L762">				Date holidayEnd = holiday.getEndDate().getTime(availBucketsTimeZone);</span>
				// ignore any holidays with no overlap
<span class="nc" id="L764">				long overlap = RequestUtil.getOverlapLength(availBucketsStartDate, availBucketsEndDate, holidayStart, holidayEnd);</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">				if (overlap == 0) {</span>
<span class="nc" id="L766">					continue;</span>
				}
				// a holiday can start before the availableBuckets.startDate. Adjust holidayStart to beginning
				// of availableBuckets.startDate if necessary.
<span class="nc bnc" id="L770" title="All 2 branches missed.">				Date overlapHolStart = holidayStart.before(availBucketsStartDate) ? availBucketsStartDate : holidayStart;</span>

				// a holiday might end after availBuckets.endDate. In this case adjust the holidayEnd to
				// availableBuckets.endDate if necessary.
<span class="nc bnc" id="L774" title="All 2 branches missed.">				Date overlapHolEnd = holidayEnd.after(availBucketsEndDate) ? availBucketsEndDate : holidayEnd;</span>
				// The result array is indexed identically as the availableBuckets array
<span class="nc" id="L776">				int ix = availableBuckets.getIndex(overlapHolStart);</span>
<span class="nc" id="L777">				int overlapHolEndIdx = availableBuckets.getIndex(overlapHolEnd);</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">				for (; ix &lt;= overlapHolEndIdx; ix++) {</span>
<span class="nc bnc" id="L779" title="All 2 branches missed.">					result[ix].setDayType(markUnPaid ? TOCalendarDayData.UNPAID_HOLIDAY_DAY_TYPE : TOCalendarDayData.PAID_HOLIDAY_DAY_TYPE);</span>
				}
			}
<span class="nc" id="L782">		}</span>
<span class="nc" id="L783">	}</span>


	/**
	 * Get the collection of CalendarTimeOffDay objects for the requested range for the organization
	 * Returns a collection of CalendarTimeOffDay objects.
	 */
	private static Collection getTOAllocationCalendar(ID pTOPoolID, ID orgId, TimeZone tz, TimeRange range) throws Exception {

<span class="nc" id="L792">		Calendar vCal = Calendar.getInstance(tz);</span>

		// Build the LocalDate objects that bound the range of time off calendar days
		// we need to proecess this request.
<span class="nc" id="L796">		vCal.setTime(range.getStartDate());</span>
<span class="nc" id="L797">		vCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L798">		vCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L799">		vCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L800">		vCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L801">		vCal.getTime(); // force evaluation of fields</span>
<span class="nc" id="L802">		LocalDate strt = new LocalDate(vCal);</span>
		//LocalDate strt = new LocalDate(range.getStartDate(), tz);

<span class="nc" id="L805">		vCal.setTime(range.getEndDate());</span>
<span class="nc" id="L806">		vCal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L807">		vCal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L808">		vCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L809">		vCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L810">		vCal.getTime(); // force evaluation of fields</span>
<span class="nc" id="L811">		vCal.add(Calendar.DATE, 1); // Point to the following day</span>
<span class="nc" id="L812">		LocalDate end = new LocalDate(vCal);</span>

		// Point to the following day (reason unknown; from earlier code).
		//LocalDate end = new LocalDate(new Date(range.getEndDate().getTime() + (24 * 60 * 60 * 1000L)), tz);

<span class="nc" id="L817">		CalendarTimeOffDayFacade ctodf = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>

<span class="nc" id="L819">		return ctodf.getCalendarTimeOffDays(pTOPoolID, strt, end, true); // get CTO info, including blackouts</span>

	}

	/**
	 * adds hours from the srcBuckets to the destBuckets based on pure Date only.
	 * i.e. hours for buckets from different timezones or orgs having diff day boundaries will be purely added based on
	 * actual date instead of time component.
	 * i.e. if Dest Bucket is PST TZ and SRC Bucket is EST TZ and if the Src Bucket has 12 am to 2 am EST Time off on 4th Jan then
	 * it will still show on 4th Jan when seen in TO Calendar for PST (eventhough it is actualy 9 pm to 11 pm PST on 3rd Jan.
	 * Same applies to Day boundary as well.
	 *
	 * @param destBkt
	 * @param srcBkt
	 * @param start
	 * @param end
	 * @param orgDest
	 * @param orgSrc
	 */

	private static void addHoursToDailyBuckets(DailyHoursBuckets destBkt, TOHoursPerDay hrsPerDay,
	                                           TimeRange range, Organization orgSrc) {
<span class="nc" id="L841">		DailyHoursBuckets srcBkt = TOHoursPerDayUtil.getDailyHoursBuckets(orgSrc, hrsPerDay);</span>
<span class="nc" id="L842">		Calendar cal = Calendar.getInstance(orgSrc.getTimeZone());</span>
<span class="nc" id="L843">		cal.setTime(range.getStartDate());</span>
<span class="nc" id="L844">		cal = new LocalDate(cal.get(Calendar.YEAR), cal.get(Calendar.MONTH), cal.get(Calendar.DAY_OF_MONTH)).getCal();</span>
<span class="nc" id="L845">		TOCalcUtil.addDaysToCalendar(cal, -1);  // start from earlier day to be sure.</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">		while (!srcBkt.getDHBRangeEndAsOrgDayEnd().before(cal.getTime())) {</span>
			try {
<span class="nc" id="L848">				Date srcDate = srcBkt.getOrgDayStart(cal);</span>
<span class="nc" id="L849">				Date destDate = destBkt.getOrgDayStart(cal);</span>
<span class="nc bnc" id="L850" title="All 4 branches missed.">				if (srcBkt.isDateInRange(srcDate) &amp;&amp; destBkt.isDateInRange(destDate)) {</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">					if (destBkt.isInclTOHrsPerDayDetails()) {</span>
<span class="nc" id="L852">						destBkt.addToBucket(destDate, srcBkt.getBucketHours(srcDate), hrsPerDay);</span>
					} else {
<span class="nc" id="L854">						destBkt.addToBucket(destDate, srcBkt.getBucketHours(srcDate));</span>
					}
				} else {
<span class="nc" id="L857">					m_cat.debug(&quot;dt=&quot; + cal.getTime() + &quot;\tSRC Date=&quot; + srcDate + &quot;\tSRC In Range=&quot; + srcBkt.isDateInRange(srcDate)</span>
<span class="nc" id="L858">					        + &quot;\tDestDate=&quot; + destDate + &quot;\tDest In Range=&quot; + destBkt.isDateInRange(destDate));</span>
				}
<span class="nc" id="L860">			} catch (Exception e) {</span>
<span class="nc" id="L861">				m_cat.error(&quot;Thrown exception while moving hrs between buckets in cal.getTime()=&quot; + cal.getTime(), e);</span>
<span class="nc" id="L862">			}</span>
<span class="nc" id="L863">			TOCalcUtil.addDaysToCalendar(cal, 1);</span>
		}
<span class="nc" id="L865">	}</span>


	/*This method returns the HoursPerDay to be used for Calendar.
	 * @param empIDs to get the Hours Per day for
	 * @param calRange date range all HrsPerDay contained in the range
	 * @param activityIDs is activityIDs is null or empty then return all, else only specified by the Collection
	 * @param schedOrPending, true For Scheduled &amp; used; false for Pending only
	 */
	public static Collection[] getHoursPerDayForCalendar(Collection empIDsSched, Collection empIDsPending, TimeRange calRange, Collection activityIDs) throws Exception {
<span class="nc" id="L875">		TOHoursPerDayManager hoursPerDayManager = RequestUtil.getTOHoursPerDayManager(null, null);</span>
		// QC49742-QA96869 if activityIDs is empty, all activities should not be returned
<span class="nc bnc" id="L877" title="All 2 branches missed.">		return hoursPerDayManager.getHoursPerDayForCalendar(empIDsSched, empIDsPending, calRange.getStartDate(), calRange.getEndDate(),</span>
<span class="nc bnc" id="L878" title="All 2 branches missed.">		        (activityIDs == null || activityIDs.isEmpty() ? Collections.singleton(Activity.ACTIVITY_NONE) : activityIDs));</span>
	}

	public static Collection getHoursPerDayForRange(Collection empIDs, TimeRange calRange, Collection activityIDs, boolean schedOrPending) throws Exception {
<span class="nc" id="L882">		TOHoursPerDayManager hoursPerDayManager = RequestUtil.getTOHoursPerDayManager(null, null);</span>
		// QC49742-QA96869 if activityIDs is empty, all activities should not be returned
<span class="nc bnc" id="L884" title="All 2 branches missed.">		return hoursPerDayManager.getHoursPerDayForCalendar(empIDs, calRange.getStartDate(), calRange.getEndDate(),</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">		        (activityIDs == null || activityIDs.isEmpty() ? Collections.singleton(Activity.ACTIVITY_NONE) : activityIDs),</span>
		        schedOrPending);
	}

	
	public static Collection&lt;ID&gt; getListOfAllAllotmentActivities() throws BbmFinderException {
		try {

<span class="nc" id="L893">		boolean onlyUseAllotmentAct = useOnlyAllotmentActivities();</span>
		// QC49742-QA96869 if not using allotments, then all time off activities should be returned.
<span class="nc" id="L895">		ActivityFilter filter = new ActivityFilter();</span>
<span class="nc" id="L896">		filter.setTimeoff(true);</span>

		//if only using allotment activities, get all time off activities with allotment in a list
<span class="nc bnc" id="L899" title="All 2 branches missed.">		if (onlyUseAllotmentAct) {</span>
<span class="nc" id="L900">			filter.setTimeoffWithAllotment(true);//			get all allotment time off activities</span>
		}
<span class="nc" id="L902">		return WfmManagerFactory.getActivityManager().findActivitiesIds(filter);</span>
<span class="nc" id="L903">		} catch (Exception e) {</span>
<span class="nc" id="L904">			throw new BbmFinderException(e);</span>
		}
	}

	public static Collection&lt;ID&gt; getListOfDailyPoolAllotmentActivities(ID activityID) throws BbmFinderException {

<span class="nc bnc" id="L910" title="All 2 branches missed.">		if (!LicenseUtil.isAdvancedRMLicense()) {</span>
			//if the advanced license is off then every activity is considered to be a daily pool activity 
<span class="nc" id="L912">			return getListOfAllAllotmentActivities();</span>
		}

<span class="nc" id="L915">		return getListOfExplicitDailyPoolAllotmentActivities(activityID);</span>
	}

	//similar to getListOfAllotmentActivities, however returns only activities that are explicitly checked for daily pool
	private static Collection&lt;ID&gt; getListOfExplicitDailyPoolAllotmentActivities(ID activityID) //NOSONAR
			throws BbmFinderException {

		try {
<span class="nc" id="L923">			boolean onlyUseAllotmentAct = useOnlyAllotmentActivities();</span>
<span class="nc" id="L924">			Collection&lt;ID&gt; ids = WfmManagerFactory.getActivityManager().getDailyPoolAllotmentActivityIDs(onlyUseAllotmentAct);</span>

			// We may be looking for only one activity	
<span class="nc bnc" id="L927" title="All 2 branches missed.">			if (activityID != null) {</span>
<span class="nc" id="L928">				List&lt;ID&gt; returnList = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">				for (ID id : ids) {</span>
<span class="nc bnc" id="L930" title="All 2 branches missed.">					if (activityID.toInt() == id.toInt()){</span>
<span class="nc" id="L931">						returnList.add(id);</span>
					}
<span class="nc" id="L933">				}</span>
<span class="nc" id="L934">				return returnList;</span>
			}

<span class="nc" id="L937">			return ids;</span>
<span class="nc" id="L938">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L939">			throw new BbmFinderException(e);</span>
<span class="nc" id="L940">		} catch (RemoteException e) {</span>
<span class="nc" id="L941">			throw new BbmFinderException(e);</span>
		}

	}

	public static boolean useOnlyAllotmentActivities() throws RemoteException, BbmEJBCreateException {
<span class="nc" id="L947">		return &quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(</span>
				ConfigKey.TIMEOFF_ONLY_COUNT_ACTIVITIES_WITH_ALLOTMENT));
	}

	public static Date getBackAyearforDate(Date date) {
<span class="nc" id="L952">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L953">		cal.setTime(date);</span>
<span class="nc" id="L954">		cal.add(Calendar.YEAR, -1);</span>
<span class="nc" id="L955">		return cal.getTime();</span>
	}

	/**
	 * Return an array of
	 * {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData}
	 * objects that contain time off calendar data for the given employee. The TOCalendarDayData
	 * objects contain, for each organization day in the range:
	 * - the allocated hours for the employee's organization
	 * - the pending hours (first choice only) for the employee
	 * - the hours scheduled in time off events for the employee
	 * - the hours remaining for the employee's organization =(allocated - scheduledForAllEmployees)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the
	 * Need the damn dates in a local date which is bascially only the date without time or timezone.
	 * unfortunately java does not have any data structure to hold it hence we have a LOCALDATE
	 * scheduled time off for all employees in the organization) for each day in the range.
	 *
	 * @param empID     the employee id
	 * @param startDateRange the beginning of the range.
	 * @param endDateRange   the end of the range.                                                               1
	 * @return an array of TOCalendarDayData objects
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 */
	public static TOCalendarDayData[] getTOCalendarForEmp(ID empID, Date startDateRange, Date endDateRange, boolean isTOPoolView,
			Organization currentEmpOrg, ID timeoffPoolID, ID activityID) throws BbmFinderException {
<span class="nc" id="L982">		long currentime = new Date().getTime();</span>
		try {
<span class="nc" id="L984">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L985">			TOCalendarDayData[] totalDayData = null;</span>
<span class="nc" id="L986">			Collection&lt;WorkResourceAssignment&gt; orgAssignsForEmp= RequestUtil.geOrgAssnsForWorkResDuringPeriod(empID,startDateRange,endDateRange);</span>
				//QC 179110: Employee can be assigned to different organizations which have different non-working days
				//Therefore, we should iterate for each period of work assignment instead of getting full period from date navigation as before
<span class="nc" id="L989">				boolean firstWrkAssn = true;</span>
<span class="nc" id="L990">				int counter=0;</span>
<span class="nc bnc" id="L991" title="All 2 branches missed.">				for(WorkResourceAssignment wrkAssign:orgAssignsForEmp){</span>
<span class="nc" id="L992">					counter++;</span>
<span class="nc" id="L993">					Organization wrkOrg = BbmManagerFactory.getWorkResourceManager().getOrganizationByID(wrkAssign.getOrganizationID());</span>
<span class="nc" id="L994">					Date startDate =getStartDateForWorkResourceOnCalendar(startDateRange,wrkAssign.getStartTime(),wrkOrg,currentEmpOrg,firstWrkAssn);</span>
<span class="nc" id="L995">					Date endDate = getEndDateForWorkResourceOnCalendar(endDateRange,wrkAssign.getEndTime(),wrkOrg,currentEmpOrg);</span>
					// Get the organization that the employee is in on the start date
<span class="nc" id="L997">					ID pTOPoolID = null;</span>
<span class="nc" id="L998">					Date prevEndDate = new Date(startDate.getTime());</span>
					
<span class="nc" id="L1000">					List&lt;EmpTOPoolAssignment&gt; list = Collections.emptyList();</span>
					
					
					//JT
<span class="nc bnc" id="L1004" title="All 4 branches missed.">					if(LicenseUtil.isAdvancedRMLicense() &amp;&amp; activityID!=null){</span>
<span class="nc" id="L1005">						list = toCalFacade.getAllEmpTOPoolAssignments(empID, startDate, endDate, activityID);</span>
<span class="nc" id="L1006">						list = TOPoolUtil.prioritizeActivityTypes(list, activityID);</span>
<span class="nc bnc" id="L1007" title="All 4 branches missed.">					} else if(LicenseUtil.isAdvancedRMLicense() &amp;&amp; timeoffPoolID!=null){</span>
<span class="nc" id="L1008">						list = toCalFacade.getEmpTOPoolAssignmentsByPoolID(timeoffPoolID, empID, startDate, endDate);</span>
					} else{
<span class="nc" id="L1010">						list = toCalFacade.getDefaultEmpTOPoolAssignments(empID, startDate, endDate);</span>
					}
<span class="nc bnc" id="L1012" title="All 2 branches missed.">					for (EmpTOPoolAssignment empTOAss : list) {</span>
<span class="nc bnc" id="L1013" title="All 2 branches missed.">						if(!isOverlap(empTOAss, startDate, endDate)){</span>
<span class="nc" id="L1014">							continue;</span>
						}
						
<span class="nc" id="L1017">						pTOPoolID = empTOAss.getTOPoolID();</span>
						
						
						
<span class="nc bnc" id="L1021" title="All 2 branches missed.">						if (prevEndDate.before(empTOAss.getStartTime())) {  </span>
							//fill GAPs at start or between EMP TO assignments
<span class="nc" id="L1023">							TOCalendarDayData[] temp1=getTOCalendarForRange(empID, null, prevEndDate, empTOAss.getStartTime(), isTOPoolView, activityID);</span>
<span class="nc" id="L1024">							totalDayData = appendDayData(totalDayData, temp1, prevEndDate);</span>
<span class="nc" id="L1025">							prevEndDate = new Date(empTOAss.getStartTime().getTime());</span>
						}
						//adjust end date
<span class="nc bnc" id="L1028" title="All 4 branches missed.">						Date rangeEndDate = (empTOAss.getEndTime() == null || empTOAss.getEndTime().after(endDate)) ? endDate :empTOAss.getEndTime();</span>
						//append to total array
<span class="nc bnc" id="L1030" title="All 2 branches missed.">						if (prevEndDate.before(rangeEndDate)) {</span>
<span class="nc" id="L1031">							TOCalendarDayData[] temp2=getTOCalendarForRange(empID, pTOPoolID, prevEndDate, rangeEndDate, isTOPoolView, activityID);</span>
							/*Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
							 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
							 */
<span class="nc" id="L1035">							temp2=getCorrectDaydataBeforeAppendTotalArray(temp2,prevEndDate);</span>
<span class="nc" id="L1036">							totalDayData = appendDayData(totalDayData,temp2	, prevEndDate);</span>
						}
<span class="nc" id="L1038">						prevEndDate = new Date(rangeEndDate.getTime());</span>
<span class="nc" id="L1039">					}</span>
					//gap at end
<span class="nc bnc" id="L1041" title="All 4 branches missed.">					if (prevEndDate != null &amp;&amp; prevEndDate.before(endDate)) { 	</span>
<span class="nc" id="L1042">						TOCalendarDayData[] dayData=getTOCalendarForRange(empID, null, prevEndDate, endDate, isTOPoolView, activityID);</span>
						/*Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
						 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
						*/
<span class="nc" id="L1046">						dayData=getCorrectDaydataBeforeAppendTotalArray(dayData,prevEndDate);</span>
<span class="nc" id="L1047">						totalDayData = appendDayData(totalDayData, dayData, prevEndDate);</span>
					}		
					
					//Fill gap with emptyData in the case employee ends on a day in the range(startDateRange,endDateRange)
<span class="nc bnc" id="L1051" title="All 4 branches missed.">					if(counter==orgAssignsForEmp.size()&amp;&amp;endDate.before(endDateRange)){</span>
<span class="nc" id="L1052">						TimeRange toCalRange = new TimeRange(endDate, endDateRange);</span>
<span class="nc" id="L1053">						DailyHoursBuckets toAllocHrsBkts = new DailyHoursBuckets(wrkOrg.getDayBoundaryOffset(), wrkOrg.getTimeZone(), toCalRange);</span>
		
<span class="nc" id="L1055">						TOCalendarDayData[] pTOCalDayDataArray = new TOCalendarDayData[toAllocHrsBkts.getSize()];</span>
<span class="nc" id="L1056">						Calendar cal1=  Calendar.getInstance(wrkOrg.getTimeZone());</span>
<span class="nc" id="L1057">						cal1.setTime(toCalRange.getStartDate());</span>
<span class="nc bnc" id="L1058" title="All 2 branches missed.">						for(int j=0;j&lt;pTOCalDayDataArray.length;j++){</span>
<span class="nc" id="L1059">							pTOCalDayDataArray[j]=new TOCalendarDayData(cal1.getTime(), wrkOrg, null);</span>
<span class="nc" id="L1060">							cal1.add(Calendar.DAY_OF_MONTH, 1);  </span>
						}
									
<span class="nc" id="L1063">						totalDayData = appendDayData(totalDayData, pTOCalDayDataArray, endDate);</span>
					}
<span class="nc" id="L1065">					firstWrkAssn=false;</span>
<span class="nc" id="L1066">				}//work resource assignment	</span>
<span class="nc" id="L1067">			return totalDayData;</span>
		} 
<span class="nc" id="L1069">		catch (Exception e) {</span>
<span class="nc" id="L1070">			m_cat.error(e);</span>
<span class="nc" id="L1071">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1073" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1074">				m_cat.debug(&quot;TOTAL TIME FOR CAL=&quot; + (new Date().getTime() - currentime));</span>
			}
		}
	}
	
	/*Get correct start date  based on the timezone of the organization which employee is assigned to during assignment,
	 *  not the timezone of current Org of employee*/
	public static Date getStartDateForWorkResourceOnCalendar(Date startDateRange,Date wrkAssignStartDate, Organization orgAssigned,Organization currentOrg, boolean firstWrkAssn) 
			throws BbmException, RemoteException{
<span class="nc" id="L1083">		Date adjustStartDate = null;</span>
<span class="nc bnc" id="L1084" title="All 4 branches missed.">		if(wrkAssignStartDate==null||wrkAssignStartDate.before(startDateRange)) {</span>
<span class="nc" id="L1085">			adjustStartDate = startDateRange;</span>
			//Start date will be the startDaterange which is adjusted based on the the time_zone and boundary of the organization assignment
<span class="nc bnc" id="L1087" title="All 2 branches missed.">			if(!orgAssigned.getTimeZone().equals(currentOrg.getTimeZone()) ){</span>
<span class="nc" id="L1088">				LocalDate localStartDate = new LocalDate(startDateRange,currentOrg.getTimeZone());</span>
<span class="nc" id="L1089">				adjustStartDate= TimeZoneUtil.toDate(localStartDate,orgAssigned.getTimeZone());</span>
<span class="nc" id="L1090">				int dayBoundaryOffSet= orgAssigned.getDayBoundaryOffset()-currentOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L1091">				long number=adjustStartDate.getTime();</span>
<span class="nc" id="L1092">				adjustStartDate =new Date(number+dayBoundaryOffSet*60*1000);</span>
<span class="nc" id="L1093">			}	</span>
		} else {
<span class="nc" id="L1095">			adjustStartDate = wrkAssignStartDate;</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">			if(firstWrkAssn){</span>
				//Start date will be  the startDaterange which is adjusted based on the the time_zone and boundary of the first organization assignment
<span class="nc" id="L1098">				LocalDate localStartDate = new LocalDate(startDateRange,currentOrg.getTimeZone());</span>
<span class="nc" id="L1099">				adjustStartDate= TimeZoneUtil.toDate(localStartDate,orgAssigned.getTimeZone());</span>
<span class="nc" id="L1100">				int dayBoundaryOffSet= orgAssigned.getDayBoundaryOffset()-currentOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L1101">				long number=adjustStartDate.getTime();</span>
<span class="nc" id="L1102">				adjustStartDate =new Date(number+dayBoundaryOffSet*60*1000);</span>
			}
		}
<span class="nc" id="L1105">		return adjustStartDate;</span>
	}
	/*Get correct end date  based on the timezone of the organization which employee is assigned to during assignment,
	 *  not the timezone of current Org of employee*/
	public static Date getEndDateForWorkResourceOnCalendar(Date endDateRange,Date wrkAssignEndDate, Organization orgAssigned,Organization currentOrg) 
			throws BbmException, RemoteException{
<span class="nc" id="L1111">		Date adjustEndDate = null;</span>
<span class="nc bnc" id="L1112" title="All 4 branches missed.">		if(wrkAssignEndDate==null||wrkAssignEndDate.after(endDateRange)) {</span>
<span class="nc" id="L1113">			adjustEndDate = endDateRange;</span>
			//End date wil be the endDateRange which is adjusted based on the the time_zone and boundary of the organization assignment
<span class="nc bnc" id="L1115" title="All 2 branches missed.">			if(!orgAssigned.getTimeZone().equals(currentOrg.getTimeZone()) ){</span>
<span class="nc" id="L1116">				LocalDate localEndDate = new LocalDate(endDateRange,currentOrg.getTimeZone());</span>
<span class="nc" id="L1117">				adjustEndDate= TimeZoneUtil.toDate(localEndDate,orgAssigned.getTimeZone());</span>
<span class="nc" id="L1118">				int dayBoundaryOffSet= orgAssigned.getDayBoundaryOffset()-currentOrg.getDayBoundaryOffset();</span>
<span class="nc" id="L1119">				long number=adjustEndDate.getTime();</span>
<span class="nc" id="L1120">				adjustEndDate =new Date(number+dayBoundaryOffSet*60*1000);</span>
<span class="nc" id="L1121">			}	</span>
		} else {
<span class="nc" id="L1123">			adjustEndDate = wrkAssignEndDate;</span>
		}
<span class="nc" id="L1125">		return adjustEndDate;</span>
	}
	/*Correct data to make sure the first element of dayData should not have data which is before the startDate of the range.
	 * In the case of day boundary change, The dayData array returned has the Date of first element is before the start of the range( prevEndDate,endDate) 
	*/
	private static  TOCalendarDayData[] getCorrectDaydataBeforeAppendTotalArray(TOCalendarDayData[] dayData, Date startDate){
<span class="nc" id="L1131">		int i=0;</span>
<span class="nc" id="L1132">		TOCalendarDayData[] tempDayData= dayData;</span>
<span class="nc bnc" id="L1133" title="All 4 branches missed.">		if(dayData!=null&amp;&amp;dayData.length&gt;0){</span>
<span class="nc" id="L1134">			Date dateOfFirstElement=dayData[0].getDate();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">			if(dateOfFirstElement.before(startDate)){</span>
<span class="nc" id="L1136">				int len=dayData.length-1;</span>
<span class="nc" id="L1137">				 tempDayData= new TOCalendarDayData[len]; </span>
<span class="nc bnc" id="L1138" title="All 4 branches missed.">				for (int j = 1; dayData != null &amp;&amp; j &lt; dayData.length; j++) {</span>
<span class="nc" id="L1139">					tempDayData[i++] = dayData[j];</span>
				}
			} 
		}
<span class="nc" id="L1143">		return tempDayData;</span>
	}
	
	protected static boolean isOverlap(EmpTOPoolAssignment poolAssignment, Date start, Date end) {
<span class="nc bnc" id="L1147" title="All 6 branches missed.">		if ((poolAssignment.getEndTime() == null || start.before(poolAssignment.getEndTime())) &amp;&amp; end.after(poolAssignment.getStartTime())) {</span>
<span class="nc" id="L1148">			return true;</span>
		}
<span class="nc" id="L1150">		return false;</span>
	}
	@SuppressWarnings(&quot;unchecked&quot;)
	private static TOCalendarDayData[] getTOCalendarForRange(ID empID, ID pTOPoolID, Date rangeStartDate, Date rangeEndDate,
			boolean isTOPoolView, ID activityID) throws Exception {
<span class="nc bnc" id="L1155" title="All 2 branches missed.">		if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1156">			m_cat.info(&quot;empID=&quot; + empID + &quot;,  pTOPoolID=&quot; + pTOPoolID + &quot;, rangeStart =&quot; + rangeStartDate + &quot;, rangeEnd =&quot; + rangeEndDate</span>
					+ &quot;,  isTOPoolView=&quot; + isTOPoolView);
		}
	
		//calculate date from past year, we will load time offs for all employees of the said TOPool from this date.
		// This is done to take care of employees that change TOPools before the passed start date but have a time off
		//extending into this periods. so it would be counted in this Time-Off Pool.
<span class="nc" id="L1163">		Date empStartDate = getBackAyearforDate(rangeEndDate);</span>
<span class="nc" id="L1164">		rangeEndDate = new Date(rangeEndDate.getTime() - 1); // NOSONAR</span>
		Collection&lt;ID&gt; pTOPoolEmpIDs;
<span class="nc bnc" id="L1166" title="All 2 branches missed.">		if (pTOPoolID != null) {</span>
<span class="nc" id="L1167">			pTOPoolEmpIDs = RmManagerFactory.getInstance().getTimeOffDayFacade()</span>
<span class="nc" id="L1168">					.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, rangeEndDate);</span>
		} else {
			// If no TOPOOL is found then only show pending / scheduled hours. No need to show the colors or allocations
<span class="nc" id="L1171">			pTOPoolEmpIDs = Collections.singleton(empID);</span>
		}
<span class="nc" id="L1173">		Organization org = ValidationUtil.getOrganizationByID(TOCalcUtil.getOrgIDForEmployeeID(empID, rangeStartDate));</span>
		Collection&lt;ID&gt; interestSetEmpIDs;
<span class="nc bnc" id="L1175" title="All 2 branches missed.">		if (isTOPoolView) {</span>
<span class="nc" id="L1176">			interestSetEmpIDs = pTOPoolEmpIDs;</span>
		} else {
			//for Employee's view
<span class="nc" id="L1179">			interestSetEmpIDs = Collections.singleton(empID);</span>
		}
<span class="nc" id="L1181">		TimeRange range = new TimeRange(rangeStartDate, rangeEndDate);</span>
<span class="nc bnc" id="L1182" title="All 2 branches missed.">		boolean isIndvlEmp = !isTOPoolView;</span>
<span class="nc" id="L1183">		return getTOCalendar(isIndvlEmp, interestSetEmpIDs, pTOPoolEmpIDs, pTOPoolID, org, range, activityID);</span>
	}

	//QC 95169 fix . Ported the back ported appendDayData() from V11.1
	private static TOCalendarDayData[] appendDayData(TOCalendarDayData[] totalDayData, TOCalendarDayData[] dayData, Date startDate) {
		TOCalendarDayData[] tempDayData;
<span class="nc" id="L1189">		int i = 0;</span>
		// this flag is used to deteremine if we need to ignore the first element in the new array(dayData)
		// When emp has an org change between orgs having different day boundaries.
		// QC201438_Case1 : We may ingore the last element of current array(totalDayData) instead of the first array
<span class="nc" id="L1193">		boolean ignoreFirstElem=false;</span>
		//ignore the last element of data of last assignment in case the employee changed to another organization to have timezone after the previous time zone
<span class="nc" id="L1195">		boolean ignoreLastElem=false;</span>
<span class="nc bnc" id="L1196" title="All 4 branches missed.">		if (totalDayData != null &amp;&amp; totalDayData.length&gt;0) {</span>
<span class="nc" id="L1197">			String lastDate = totalDayData[totalDayData.length - 1].getUniqueDateStr();</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">			String firstDate = (dayData.length&gt;0 &amp;&amp; dayData[0]!=null)? dayData[0].getUniqueDateStr() : null;</span>
			
			
<span class="nc" id="L1201">			int len = totalDayData.length + dayData.length;</span>
<span class="nc bnc" id="L1202" title="All 4 branches missed.">			if (lastDate!=null&amp;&amp;lastDate.equals(firstDate)) {//Ignore one element</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">				if(totalDayData[totalDayData.length - 1].getDate().before(startDate)){</span>
<span class="nc" id="L1204">					ignoreLastElem= true;</span>
				} else {
<span class="nc" id="L1206">					ignoreFirstElem=true;</span>
				}
<span class="nc" id="L1208">				len = len - 1;</span>
			}
<span class="nc" id="L1210">			tempDayData = new TOCalendarDayData[len];</span>
<span class="nc bnc" id="L1211" title="All 2 branches missed.">			int lenTotalDayData = ignoreLastElem?totalDayData.length-1:totalDayData.length;</span>
<span class="nc bnc" id="L1212" title="All 2 branches missed.">			for (i = 0; i &lt; lenTotalDayData;){</span>
<span class="nc" id="L1213">				tempDayData[i] = totalDayData[i];</span>
<span class="nc" id="L1214">				i++;</span>
			}
<span class="nc" id="L1216">		} else {</span>
<span class="nc bnc" id="L1217" title="All 4 branches missed.">			Date firstDayInDayData = (dayData.length&gt;0 &amp;&amp; dayData[0] != null) ? dayData[0].getDate(): null;</span>
<span class="nc bnc" id="L1218" title="All 4 branches missed.">			ignoreFirstElem = firstDayInDayData!=null&amp;&amp; firstDayInDayData.before(startDate);</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">			tempDayData = ignoreFirstElem ? new TOCalendarDayData[dayData.length - 1] : new TOCalendarDayData[dayData.length];</span>
		}
<span class="nc bnc" id="L1221" title="All 2 branches missed.">		if(ignoreFirstElem) {</span>
<span class="nc" id="L1222">			m_cat.info(&quot;IGNORED ROW &quot;+dayData[0]);</span>
		}
		//now add the new day data
		
<span class="nc bnc" id="L1226" title="All 6 branches missed.">		for (int j = ignoreFirstElem ? 1 : 0; dayData != null &amp;&amp; j &lt; dayData.length; j++) {</span>
<span class="nc" id="L1227">			tempDayData[i++] = dayData[j];</span>
		}
<span class="nc" id="L1229">		return tempDayData;</span>
	}

	/**
	 * Return an array of
	 * {@link com.bluepumpkin.ejb.rm.requests.timeoff.model.TOCalendarDayData TOCalendarDayData}
	 * objects that contain time off calendar data for employees in the given organization. The
	 * optional empID input is the employee id of a supervisor for the organization. If it is not
	 * null, then the interest set of employees is all employees in the organization that the
	 * given supervisor supervises. If the supervisor id is null, then the interest set is
	 * all the employees in the organization.
	 * &lt;p/&gt;
	 * The returned TOCalendarDayData objects contain, for each organization day in the range:
	 * - the allocated hours for the organization,
	 * - the pending hours (first choice only) for the employees in the interest set
	 * - the hours scheduled in time off events for the employees in the interest set
	 * - the hours remaining for the organization =(allocated - scheduled)
	 * &lt;p/&gt;
	 * The TOCalendarDayData also contains the day type (based on organization settings and the
	 * scheduled time off for all employees in the organization) for each day in the range.
	 *
	 * @param orgID     the organization id
	 * @param startDate the beginning of the range. This is the beginning of an organization day
	 *                  in the organization's local time zone.
	 * @param endDate   the end of the range.
	 * @return an array of TOCalendarDayData objects
	 * @throws BbmFinderException
	 */
	public static TOCalendarDayData[] getTOCalendarForManager(ID orgID, ID pTOPoolID, Collection orgEmpIDs, Date startDate, Date endDate)
			throws BbmFinderException {
<span class="nc" id="L1259">		long currentime = new Date().getTime();</span>
<span class="nc" id="L1260">		long empSize = 0;</span>
		try {
<span class="nc" id="L1262">			Organization org = ValidationUtil.getOrganizationByID(orgID);</span>
<span class="nc" id="L1263">			Date empStartDate = TOCalendarUtil.getBackAyearforDate(startDate);</span>
<span class="nc" id="L1264">			CalendarTimeOffDayFacade toCalFacade = RmManagerFactory.getInstance().getTimeOffDayFacade();</span>
<span class="nc" id="L1265">			Set interestSetEmpIDs = new HashSet();</span>
<span class="nc" id="L1266">			Set pTOPoolEmpIDs = new HashSet();</span>
<span class="nc bnc" id="L1267" title="All 2 branches missed.">			if (pTOPoolID != null) {</span>
<span class="nc" id="L1268">				interestSetEmpIDs.addAll(toCalFacade.getEmployeeIDsForTOPool(pTOPoolID, empStartDate, endDate));</span>
<span class="nc" id="L1269">				pTOPoolEmpIDs = interestSetEmpIDs;</span>
			} else {
<span class="nc" id="L1271">				interestSetEmpIDs.addAll(orgEmpIDs);</span>
			}
<span class="nc" id="L1273">			empSize = interestSetEmpIDs.size();</span>
<span class="nc" id="L1274">			TimeRange range = new TimeRange(startDate, endDate);</span>
<span class="nc" id="L1275">			return getTOCalendar(false, interestSetEmpIDs, pTOPoolEmpIDs, pTOPoolID, org, range, null);</span>
<span class="nc" id="L1276">		} catch (Exception e) {</span>
<span class="nc" id="L1277">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1279" title="All 4 branches missed.">			if (RequestUtil.isRMDebugEnabled()) {</span>
<span class="nc" id="L1280">				m_cat.debug(&quot;TOTAL TIME FOR CAL=&quot; + (new Date().getTime() - currentime) + &quot; : TOTAL EMPS=&quot; + empSize);</span>
			}
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>