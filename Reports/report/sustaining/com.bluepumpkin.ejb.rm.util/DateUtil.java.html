<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DateUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">DateUtil.java</span></div><h1>DateUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Oct 7, 2008
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.util;

import java.text.ParsePosition;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.Random;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.rm.DSTTransitionMode;
import com.bluepumpkin.ejb.rm.Log;

public class DateUtil {
<span class="nc" id="L27">	private static final Category LOG = Log.initCategory(DateUtil.class.getName());</span>

	public static final long HOUR_IN_MSECS = 3600000L;
	public static final long MINUTE_IN_MSECS = 60000L;
	public static final int TIME_INTERVAL = 15;
	public static final int INTERVALS_IN_HOUR = 4;
	public static final int INTERVALS_IN_DAY = INTERVALS_IN_HOUR * 24;

<span class="nc" id="L35">	private static final Random rand = new Random();</span>
<span class="nc" id="L36">	private static final int[] DAY_OF_MONTH = { 14, 15, 16, 1, 5, 30 };</span>
<span class="nc" id="L37">	private static final int[] YEARS = { 2007, 2008, 2009 };</span>
<span class="nc" id="L38">	private static final int[] MONTH = { 1, 3, 6, 9, 11, 12 };</span>
	private static final String DATEFORMAT = &quot;MM/dd/yyyy HH:mm:ss&quot;;
	private static final int TWO_WEEKS_DAYS = 14;

<span class="nc" id="L42">	private DateUtil() {</span>
<span class="nc" id="L43">	}</span>

	public static void main(String[] args) {
<span class="nc bnc" id="L46" title="All 2 branches missed.">		for (int i = 0; i &lt; 10;) {</span>
<span class="nc" id="L47">			TimeZone tz = Calendar.getInstance().getTimeZone();</span>
<span class="nc" id="L48">			Calendar start = getRandomCalendar(tz);</span>
<span class="nc" id="L49">			Calendar end = getRandomCalendar(tz);</span>
<span class="nc bnc" id="L50" title="All 2 branches missed.">			if (start.after(end)) {</span>
<span class="nc" id="L51">				continue;</span>
			}
			//getDaysInBetween(tz, start, calEnd.getTime()); // NOSONAR
			//getSemiMonthCountInBetween(tz,start, calEnd.getTime()); // NOSONAR
			//getMonthsInBetween(tz,start, calEnd.getTime()); // NOSONAR
			//getYearsInBetween(tz,start, calEnd.getTime(), 9, 15); // NOSONAR
<span class="nc" id="L57">			i++; // NOSONAR</span>
<span class="nc" id="L58">		}</span>
<span class="nc" id="L59">	}</span>

	private static Calendar getRandomCalendar(TimeZone tz) {
<span class="nc" id="L62">		int mon = MONTH[rand.nextInt(MONTH.length)];</span>
<span class="nc" id="L63">		int yr = YEARS[rand.nextInt(YEARS.length)];</span>
<span class="nc" id="L64">		int dy = DAY_OF_MONTH[rand.nextInt(DAY_OF_MONTH.length)];</span>
<span class="nc" id="L65">		Calendar ca = Calendar.getInstance(tz);</span>
<span class="nc" id="L66">		ca.set(Calendar.YEAR, yr);</span>
<span class="nc" id="L67">		ca.set(Calendar.MONTH, mon);</span>
<span class="nc" id="L68">		ca.set(Calendar.DAY_OF_MONTH, dy);</span>
<span class="nc" id="L69">		ca.set(Calendar.HOUR, 0);</span>
<span class="nc" id="L70">		ca.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L71">		ca.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L72">		return ca;</span>
	}

	public static final int getMonthCountInBetween(Calendar calStart, Calendar calEnd) {
<span class="nc" id="L76">		SimpleDateFormat dateFormat = new SimpleDateFormat(DATEFORMAT);</span>
<span class="nc" id="L77">		dateFormat.setTimeZone(calStart.getTimeZone());</span>
<span class="nc" id="L78">		Date start = calStart.getTime();</span>
<span class="nc" id="L79">		initCalendarToStartOfDay(calStart);</span>
<span class="nc" id="L80">		calStart.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L81">		int count = 0;</span>
		while (true) {
<span class="nc bnc" id="L83" title="All 4 branches missed.">			if (calStart.getTime().after(start) &amp;&amp; !calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L84">				count++;</span>
			}
<span class="nc" id="L86">			Date before = calStart.getTime();</span>
<span class="nc" id="L87">			calStart.add(Calendar.MONTH, 1);</span>
<span class="nc" id="L88">			LOG.debug(&quot;\t count= &quot; + count + &quot;;before=&quot; + dateFormat.format(before) + &quot;; after=&quot; + dateFormat.format(calStart.getTime()) +</span>
<span class="nc" id="L89">					&quot;; END DATE=&quot; + dateFormat.format(calEnd.getTime()));</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L91">				break;</span>
			}
<span class="nc" id="L93">		}</span>
<span class="nc" id="L94">		LOG.debug(&quot;FROM: &quot; + dateFormat.format(start) + &quot; - &quot; + dateFormat.format(calEnd.getTime()) + &quot; ; Month count=&quot; + count);</span>
<span class="nc" id="L95">		return count;</span>
	}

	private static void initCalendarToStartOfDay(Calendar calStart) {
<span class="nc" id="L99">		calStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L100">		calStart.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L101">		calStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L102">		calStart.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L103">	}</span>

	public static final int getDayCountInBetween(TimeZone tz, Date start, Date end) {

<span class="nc" id="L107">		Calendar calStart = Calendar.getInstance(tz);</span>
<span class="nc" id="L108">		calStart.setTime(start);</span>
<span class="nc" id="L109">		Calendar calEnd = Calendar.getInstance(tz);</span>
<span class="nc" id="L110">		calEnd.setTime(end);</span>
<span class="nc" id="L111">		return getDayCountInBetween(calStart, calEnd);</span>
	}

	public static final int getDayCountInBetween(Calendar calStart, Calendar calEnd) {
<span class="nc" id="L115">		SimpleDateFormat dateFormat = new SimpleDateFormat(DATEFORMAT);</span>
<span class="nc" id="L116">		dateFormat.setTimeZone(calStart.getTimeZone());</span>
<span class="nc" id="L117">		Date start = calStart.getTime();</span>
<span class="nc" id="L118">		initCalendarToStartOfDay(calStart);</span>
<span class="nc" id="L119">		int count = 0;</span>
		while (true) {
<span class="nc bnc" id="L121" title="All 4 branches missed.">			if (calStart.getTime().after(start) &amp;&amp; !calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L122">				count++;</span>
			}
<span class="nc" id="L124">			calStart.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">			if (calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L126">				break;</span>
			}
		}
<span class="nc" id="L129">		return count;</span>
	}

	/*
	finds out exact number of days between the start date and end date
	returns   0 if the number of days is exactly the same
			-ve number if allowedDays is less than days between the start date and end date
	        +ve number if allowedDays is greater than days between the start date and end date
	*/
	public static final long compareDayDiffWithAllowedCount(TimeZone tz, Date start, Date end, int allowedDays) {
<span class="nc" id="L139">		Calendar calStart = Calendar.getInstance(tz);</span>
<span class="nc" id="L140">		calStart.setTime(start);</span>
<span class="nc" id="L141">		calStart.add(Calendar.DAY_OF_MONTH, allowedDays);</span>
<span class="nc" id="L142">		Calendar calEnd = Calendar.getInstance(tz);</span>
<span class="nc" id="L143">		calEnd.setTime(end);</span>
<span class="nc bnc" id="L144" title="All 2 branches missed.">		if (calStart.equals(calEnd)) {</span>
<span class="nc" id="L145">			return 0;</span>
		} else {
<span class="nc bnc" id="L147" title="All 2 branches missed.">			return calStart.after(calEnd) ? -1 : 1;</span>
		}
	}

	public static final int getYearsCountInBetween(Calendar calStart, Calendar calEnd, int month, int day) {
<span class="nc" id="L152">		SimpleDateFormat dateFormat = new SimpleDateFormat(DATEFORMAT);</span>
<span class="nc" id="L153">		dateFormat.setTimeZone(calStart.getTimeZone());</span>
		//check EMP TO year start in this case
<span class="nc" id="L155">		Date start = calStart.getTime();</span>
<span class="nc" id="L156">		initCalendarToStartOfDay(calStart);</span>
<span class="nc" id="L157">		calStart.set(Calendar.MONTH, month);</span>
<span class="nc" id="L158">		calStart.set(Calendar.DAY_OF_MONTH, day);</span>

<span class="nc" id="L160">		int count = 0;</span>
		while (true) {
<span class="nc bnc" id="L162" title="All 4 branches missed.">			if (calStart.getTime().after(start) &amp;&amp; !calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L163">				count++;</span>
			}
<span class="nc" id="L165">			calStart.set(Calendar.YEAR, calStart.get(Calendar.YEAR) + 1);</span>
<span class="nc bnc" id="L166" title="All 2 branches missed.">			if (calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L167">				break;</span>
			}
		}
<span class="nc" id="L170">		return count;</span>
	}

	//Every 15th of the month
	public static final int getSemiMonthCountInBetween(Calendar calStart, Calendar calEnd) {
<span class="nc" id="L175">		SimpleDateFormat dateFormat = new SimpleDateFormat(DATEFORMAT);</span>
<span class="nc" id="L176">		dateFormat.setTimeZone(calStart.getTimeZone());</span>
<span class="nc" id="L177">		Date start = calStart.getTime();</span>
<span class="nc" id="L178">		int count = 0;</span>
<span class="nc" id="L179">		initCalendarToStartOfDay(calStart);</span>
		while (true) {
<span class="nc bnc" id="L181" title="All 4 branches missed.">			if (calStart.getTime().after(start) &amp;&amp; !calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L182">				count++;</span>
			}
<span class="nc bnc" id="L184" title="All 2 branches missed.">			if (calStart.get(Calendar.DAY_OF_MONTH) &gt;= 15) {</span>
<span class="nc" id="L185">				calStart.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L186">				calStart.add(Calendar.MONTH, 1);</span>
			} else {
<span class="nc" id="L188">				calStart.set(Calendar.DAY_OF_MONTH, 15);</span>
			}
<span class="nc bnc" id="L190" title="All 2 branches missed.">			if (calStart.getTime().after(calEnd.getTime())) {</span>
<span class="nc" id="L191">				break;</span>
			}
		}
<span class="nc" id="L194">		return count;</span>
	}

	/**
	 * Converts a date in GMT to the same clock time in toTimeZone.
	 * 2013/10/01 00:00 GMT to 2013/10/01 00:00 America/Chicago
	 * The source and returned Date instances may represent a different instant of time.
	 *
	 * See convertClockTimeToTimeZone for example.
	 *
	 * @param date
	 *            The source date that has the proper clock time.
	 * @param toTimeZone
	 *            The TimeZone for the resulting clock time.
	 * @return A new Date instance that has the same clock time as the input date but in toTimeZone.
	 */
	public static Date convertGmtClockTimeToTimeZone(Date date, TimeZone toTimeZone) {
<span class="nc" id="L211">		return convertClockTimeToTimeZone(date, TimeZoneUtil.GMT_TIMEZONE, toTimeZone);</span>
	}

	/**
	 * Converts a date in fromTimeZone to the same clock time in toTimeZone.
	 * 2013/10/01 00:00 GMT to 2013/10/01 00:00 America/Chicago
	 * The source and returned Date instances both represent a different instant of time.
	 *
	 * Example: The database stores a time relative to some entity such as an organization.
	 * The date instance is obtained from the database in GMT not the organization's TimeZone.
	 * Therefore, the date instance doesn't represent the proper instant of time.
	 * date: 2013/10/01 00:00 GMT
	 * fromTimeZone: GMT
	 * toTimeZone: America/Chicago
	 * result: 2013/10/01 00:00 America/Chicago
	 *
	 * @param date
	 *            The source date that has the proper clock time.
	 * @param fromTimeZone
	 *            The TimeZone date represents.
	 * @param toTimeZone
	 *            The TimeZone for the resulting clock time.
	 * @return A new Date instance that has the same clock time as the input date but in toTimeZone.
	 */
	public static Date convertClockTimeToTimeZone(Date date, TimeZone fromTimeZone, TimeZone toTimeZone) {
		/*
		 * Dates represent an unambiguous instant of time (ticks since epoch). They contain no TimeZone information.
		 * Calendar's set &amp; get methods will treat the values in the Calendar's time zone.
		 * We set cal1 to the localDate and tell the Calendar it is in GMT. This way when we pull out
		 * the individual pieces of the date &amp; time using the get method, they essentially won't be translated (GMT -&gt; GMT).
		 * We set cal2's date &amp; time to the specific point in time relative to localTimeZone via cal1.
		 * Therefore, the result Date instance obtained via getTime will represent the proper GMT date &amp; time.
		 */
<span class="nc" id="L244">		Calendar fromCal = Calendar.getInstance(fromTimeZone);</span>
<span class="nc" id="L245">		fromCal.setTime(date);</span>

<span class="nc" id="L247">		Calendar toCal = Calendar.getInstance(toTimeZone);</span>
<span class="nc" id="L248">		toCal.set(Calendar.DATE, fromCal.get(Calendar.DATE));</span>
<span class="nc" id="L249">		toCal.set(Calendar.MONTH, fromCal.get(Calendar.MONTH));</span>
<span class="nc" id="L250">		toCal.set(Calendar.YEAR, fromCal.get(Calendar.YEAR));</span>
<span class="nc" id="L251">		toCal.set(Calendar.HOUR_OF_DAY, fromCal.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L252">		toCal.set(Calendar.MINUTE, fromCal.get(Calendar.MINUTE));</span>
<span class="nc" id="L253">		toCal.set(Calendar.SECOND, fromCal.get(Calendar.SECOND));</span>
<span class="nc" id="L254">		toCal.set(Calendar.MILLISECOND, fromCal.get(Calendar.MILLISECOND));</span>

<span class="nc" id="L256">		return toCal.getTime();</span>
	}

	/**
	 * Returns a Calendar for the specified TimeZone and Date.
	 */
	public static Calendar getCalendar(TimeZone timeZone, Date time) {
<span class="nc" id="L263">		Calendar cal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L264">		cal.setTime(time);</span>
<span class="nc" id="L265">		return cal;</span>
	}

	public static Date roundDownToInterval(Date date) {
<span class="nc bnc" id="L269" title="All 2 branches missed.">		if(date == null) {</span>
<span class="nc" id="L270">			return null;</span>
		}
<span class="nc" id="L272">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L273">		cal.setTime(date);</span>
<span class="nc" id="L274">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L275">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L276">		cal.set(Calendar.MINUTE, roundDownToInterval(cal.get(Calendar.MINUTE)));</span>
<span class="nc" id="L277">		return cal.getTime();</span>
	}

	public static int roundDownToInterval(int minutes) {
<span class="nc" id="L281">		return minutes / TIME_INTERVAL * TIME_INTERVAL;</span>
	}

	public static Date roundUpToInterval(Date date) {
<span class="nc bnc" id="L285" title="All 2 branches missed.">		if(date == null) {</span>
<span class="nc" id="L286">			return null;</span>
		}
<span class="nc" id="L288">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L289">		cal.setTime(date);</span>
<span class="nc" id="L290">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L291">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L292">		cal.set(Calendar.MINUTE, roundUpToInterval(cal.get(Calendar.MINUTE)));</span>
<span class="nc" id="L293">		return cal.getTime();</span>
	}

	public static int roundUpToInterval(int minutes) {
<span class="nc bnc" id="L297" title="All 2 branches missed.">		if (minutes % TIME_INTERVAL &gt; 0) {</span>
<span class="nc" id="L298">			return ((minutes / TIME_INTERVAL) + 1) * TIME_INTERVAL;</span>
		}
<span class="nc" id="L300">		return minutes;</span>
	}

	/**
	 * Rounds the date to the nearest interval.
	 */
	public static Date roundToNearestInterval(Date date) {
<span class="nc" id="L307">		Date result = null;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">		if (date != null) {</span>
<span class="nc" id="L309">			Calendar aCal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L310">			aCal.setTime(date);</span>
<span class="nc" id="L311">			int min = aCal.get(Calendar.MINUTE);</span>
<span class="nc" id="L312">			int remainder = min % TIME_INTERVAL;</span>

<span class="nc bnc" id="L314" title="All 2 branches missed.">			if (remainder == 0) {</span>
<span class="nc" id="L315">				result = date;</span>
			} else {
<span class="nc bnc" id="L317" title="All 2 branches missed.">				int diff = (remainder &gt; (TIME_INTERVAL / 2)) ? (TIME_INTERVAL - remainder) : (0 - remainder);</span>
<span class="nc" id="L318">				min += diff;</span>
<span class="nc" id="L319">				aCal.set(Calendar.MINUTE, min);</span>
<span class="nc" id="L320">				result = aCal.getTime();</span>
			}
		}
<span class="nc" id="L323">		return result;</span>
	}

	public static boolean isBeforeOrEqual(Date first, Date second) {
<span class="nc bnc" id="L327" title="All 2 branches missed.">		return first.compareTo(second) &lt;= 0;</span>
	}

	public static boolean isAfterOrEqual(Date first, Date second) {
<span class="nc bnc" id="L331" title="All 2 branches missed.">		return first.compareTo(second) &gt;= 0;</span>
	}

	/**
	 * Is the instance of time in the range [start, end)?
	 * Exclusive end unlike TimeRange
	 */
	public static boolean isInRange(Date start, Date end, Date instance) {
<span class="nc bnc" id="L339" title="All 2 branches missed.">		long endTime = end == null ? Long.MAX_VALUE : end.getTime();</span>
<span class="nc" id="L340">		long at = instance.getTime();</span>
<span class="nc bnc" id="L341" title="All 4 branches missed.">		return start.getTime() &lt;= at &amp;&amp; at &lt; endTime;</span>
	}
	
	public static boolean isInRange(TimeRange r, Date instance) {
<span class="nc" id="L345">		return isInRange(r.getStartDate(), r.getEndDate(), instance);</span>
	}

	/**
	 * Does the interval [start1,end1) cover [start2,end2)?
	 * Both intervals are start inclusive and end exclusive and nulls for end means the interval is forever
	 */
	public static boolean interval1CoversInterval2(Date start1, Date end1, Date start2, Date end2) {
<span class="nc bnc" id="L353" title="All 2 branches missed.">		long endTime1 = end1 == null ? Long.MAX_VALUE : end1.getTime();</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">		long endTime2 = end2 == null ? Long.MAX_VALUE : end2.getTime();</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">		return start1.getTime() &lt;= start2.getTime() &amp;&amp; endTime1 &gt;= endTime2;</span>
	}

	/**
	 * Does the interval [start1,end1) intersect with [start2,end2)?
	 * Both intervals are start inclusive and end exclusive and nulls for end means the interval is forever
	 */
	public static boolean intervalsIntersect(Date start1, Date end1, Date start2, Date end2) {
<span class="nc bnc" id="L363" title="All 2 branches missed.">		long endTime1 = end1 == null ? Long.MAX_VALUE : end1.getTime();</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">		long endTime2 = end2 == null ? Long.MAX_VALUE : end2.getTime();</span>
<span class="nc bnc" id="L365" title="All 4 branches missed.">		return start1.getTime() &lt; endTime2 &amp;&amp; endTime1 &gt; start2.getTime();</span>
	}

	/**
	 * Does the interval [start1,end1] intersect with [start2,end2]?
	 * Both intervals are start and end inclusive.  Nulls for end means the interval is forever.
	 */
	public static boolean intersectsInclusive(Date start1, Date end1, Date start2, Date end2) {
<span class="nc bnc" id="L373" title="All 2 branches missed.">		long endTime1 = end1 == null ? Long.MAX_VALUE : end1.getTime();</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		long endTime2 = end2 == null ? Long.MAX_VALUE : end2.getTime();</span>
<span class="nc bnc" id="L375" title="All 4 branches missed.">		return start1.getTime() &lt;= endTime2 &amp;&amp; endTime1 &gt;= start2.getTime();</span>
	}

	public static boolean intersectsExclusiveEnd(Date start, Date endExclusive, Date date) {
<span class="nc bnc" id="L379" title="All 4 branches missed.">		return isBeforeOrEqual(start, date) &amp;&amp; endExclusive.after(date);</span>
	}

	/**
	 * @return
	 * The start of day for the date according to time zone set for the calendar.
	 * Note that the calendar's time is also set to the start of day.
	 */
	public static Date getDayStart(Date dt, Calendar cal) {
<span class="nc" id="L388">		cal.setTime(dt);</span>
<span class="nc" id="L389">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L390">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L391">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L392">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L393">		return cal.getTime();</span>
	}

	public static Date getDayStart(Date dt, TimeZone timeZone) {
<span class="nc" id="L397">		return getDayStart(dt, Calendar.getInstance(timeZone));</span>
	}

	/**
	 * @return
	 * The time from start of day according to the time zone set for the calendar.
	 * Note that the calendar's time is set to dt on return
	 * This function has a bug if the passed in date is on a 23 or 25 hour day
	 * A solution might be to get the start of the day and calculate the difference 
	 * between the start of day and the passed in date. 
	 * However, the client might be expecting 9*60 to be returned for 9:00am even for 23/25 hour days 
	 */
	public static int getTimeInMinutesFromStartOfDay(Date dt, Calendar cal) {
<span class="nc" id="L410">		cal.setTime(dt);</span>
<span class="nc" id="L411">		return cal.get(Calendar.HOUR_OF_DAY) * 60 + cal.get(Calendar.MINUTE);</span>
	}

	public static Calendar getCalendar(TimeZone timeZone, int year, int month, int day) {
<span class="nc" id="L415">		Calendar cal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L416">		cal.clear();</span>
<span class="nc" id="L417">		cal.set(year, month, day);</span>
<span class="nc" id="L418">		return cal;</span>
	}

	public static Date getDateGMT(int year, int month, int day, int hourOfDay, int minute) {
<span class="nc" id="L422">		return getCalendarGMT(year, month, day, hourOfDay, minute).getTime();</span>
	}

	//Copied from sfpDateUtil.java
	public static Calendar getCalendarGMT(int year, int month, int day, int hourOfDay, int minute) {
<span class="nc" id="L427">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L428">		cal.clear();</span>
<span class="nc" id="L429">		cal.set(year, month, day, hourOfDay, minute);</span>
<span class="nc" id="L430">		return cal;</span>
	}

	//Copied from sfpDateUtil.java
	public static Calendar getCalendarGMT(int year, int month, int day) {
<span class="nc" id="L435">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L436">		cal.clear();</span>
<span class="nc" id="L437">		cal.set(year, month, day);</span>
<span class="nc" id="L438">		return cal;</span>
	}

	//Copied from sfpDateUtil.java
	public static Date getDateGMT(int year, int month, int day) {
<span class="nc" id="L443">		return getCalendarGMT(year, month, day).getTime();</span>
	}

	/**
	 * Gets the DST transition between the two dates.
	 */
	public static DSTTransitionMode getDSTTransitionMode(Date startTime, Date endTime, TimeZone timeZone) {
<span class="nc" id="L450">		boolean prevIsInDst = timeZone.inDaylightTime(startTime);</span>
<span class="nc" id="L451">		boolean isInDst = timeZone.inDaylightTime(endTime);</span>
<span class="nc bnc" id="L452" title="All 4 branches missed.">		if (prevIsInDst &amp;&amp; !isInDst) {</span>
			// Fall Back / DST Ends (25 hour day)
<span class="nc" id="L454">			return DSTTransitionMode.FALLBACK;</span>
		}
<span class="nc bnc" id="L456" title="All 4 branches missed.">		if (!prevIsInDst &amp;&amp; isInDst) {</span>
			// Spring Forward / DST Starts (23 hour day)
<span class="nc" id="L458">			return DSTTransitionMode.SPRINGFORWARD;</span>
		}
<span class="nc" id="L460">		return DSTTransitionMode.NEUTRAL;</span>
	}

	/**
	 * Gets hours from the minutes value.  Null is returned if minutes is null.
	 * @param minutes
	 * @return
	 */
	public static Float getHoursFromMinutes(Float minutes) {
<span class="nc bnc" id="L469" title="All 2 branches missed.">		if (minutes == null) {</span>
<span class="nc" id="L470">			return minutes;</span>
		}
<span class="nc" id="L472">		return minutes / 60.0f;</span>
	}

	public static void toMidnight(Calendar cal) {
<span class="nc" id="L476">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L477">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L478">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L479">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L480">	}</span>

	/**
	 * Adds the specified number of days to the calendar and sets the offset.
	 */
	public static void addDays(Calendar cal, int numberOfDays, int offsetMinutes) {
<span class="nc" id="L486">		TOCalcUtil.addDaysToCalendar(cal, numberOfDays);</span>
<span class="nc" id="L487">		TOCalcUtil.setCalMinsOffsetFromMidnight(cal, offsetMinutes);</span>
<span class="nc" id="L488">	}</span>

	// Copied from sfpDateUtil.java
	public static Date addDays(Date date, int numberOfDays) {
<span class="nc" id="L492">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L493">		cal.setTime(date);</span>
<span class="nc" id="L494">		cal.add(Calendar.DATE, numberOfDays);</span>
<span class="nc" id="L495">		return cal.getTime();</span>
	}

	/**
	 * Gets the start and end times based on the date, org offset, and the time minutes.
	 */
	public static Pair&lt;Date, Date&gt; getTimes(TimeZone timeZone, int orgDayBoundaryOffset, Date date, int startTimeInMinutes,
			int endTimeInMinutes) {
<span class="nc" id="L503">		Pair&lt;Date, Date&gt; result = new Pair&lt;Date, Date&gt;();</span>
<span class="nc" id="L504">		Calendar cal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L505">		cal.setTime(date);</span>
<span class="nc" id="L506">		DateUtil.toMidnight(cal);</span>
<span class="nc" id="L507">		Date dateAtMidnight = cal.getTime();</span>
<span class="nc" id="L508">		int startHour = startTimeInMinutes / 60;</span>
<span class="nc" id="L509">		int endHour = endTimeInMinutes / 60;</span>
		// we can't add minutes here because it will go too far when passing the skipped DST hour. Use set instead.

<span class="nc bnc" id="L512" title="All 2 branches missed.">		if (orgDayBoundaryOffset &lt;= startTimeInMinutes) {</span>
			// start time is on the date
<span class="nc" id="L514">			cal.set(Calendar.HOUR_OF_DAY, startHour);</span>
<span class="nc" id="L515">			cal.set(Calendar.MINUTE, startTimeInMinutes % 60);</span>
<span class="nc" id="L516">			result.setFirst(cal.getTime());</span>

<span class="nc" id="L518">			cal.setTime(dateAtMidnight);</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">			if (endTimeInMinutes &lt;= startTimeInMinutes) {</span>
				// end is on the next date
<span class="nc" id="L521">				cal.add(Calendar.DATE, 1);</span>
			}
<span class="nc" id="L523">			cal.set(Calendar.HOUR_OF_DAY, endHour);</span>
<span class="nc" id="L524">			cal.set(Calendar.MINUTE, endTimeInMinutes % 60);</span>
<span class="nc" id="L525">			result.setSecond(cal.getTime());</span>
		} else {
			// both times are on the next day
<span class="nc" id="L528">			cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L529">			cal.set(Calendar.HOUR_OF_DAY, startHour);</span>
<span class="nc" id="L530">			cal.set(Calendar.MINUTE, startTimeInMinutes % 60);</span>
<span class="nc" id="L531">			result.setFirst(cal.getTime());</span>

<span class="nc" id="L533">			cal.setTime(dateAtMidnight);</span>
<span class="nc" id="L534">			cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L535">			cal.set(Calendar.HOUR_OF_DAY, endHour);</span>
<span class="nc" id="L536">			cal.set(Calendar.MINUTE, endTimeInMinutes % 60);</span>
<span class="nc" id="L537">			result.setSecond(cal.getTime());</span>
		}

<span class="nc" id="L540">		return result;</span>
	}

	/**
	 * This method duplicated with the WFM-RM-WEB\FormatUtils.java
	 *
	 * @param strDate
	 * @return
	 */
	public static Date iso8601SecPrecisionStringToDate(String strDate, TimeZone orgTZ) {
<span class="nc bnc" id="L550" title="All 2 branches missed.">		if (strDate != null) {</span>
<span class="nc" id="L551">			SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ss.SSS'Z'&quot;);</span>
<span class="nc" id="L552">			sdf.setTimeZone(orgTZ);</span>
<span class="nc" id="L553">			return sdf.parse(strDate, new ParsePosition(0));</span>
		} else {
<span class="nc" id="L555">			return null;</span>
		}
	}

	public static Date getFirstDateOfCurrentCalendarYear(TimeZone orgTZ) {
<span class="nc" id="L560">		Calendar cal = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L561">		cal.set(Calendar.MONTH, 0);</span>
<span class="nc" id="L562">		cal.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L563">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L564">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L565">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L566">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L567">		return cal.getTime();</span>
	}

	public static TimeRange getFiscalRange(Date firstDayOfYear, Date dateInside, int durationInMonths, TimeZone tz) {
<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (dateInside.before(firstDayOfYear)) {</span>
<span class="nc" id="L572">			return null;</span>
		}

<span class="nc" id="L575">		Calendar startPeriod = Calendar.getInstance(tz);</span>
<span class="nc" id="L576">		Calendar endPeriod = Calendar.getInstance(tz);</span>

<span class="nc" id="L578">		int monthOffset = 0;</span>
		do {
<span class="nc" id="L580">			startPeriod.setTime(firstDayOfYear);</span>
<span class="nc" id="L581">			startPeriod.add(Calendar.MONTH, monthOffset);</span>
<span class="nc" id="L582">			endPeriod.setTime(firstDayOfYear);</span>
<span class="nc" id="L583">			endPeriod.add(Calendar.MONTH, monthOffset + durationInMonths);</span>

<span class="nc bnc" id="L585" title="All 2 branches missed.">			if (startPeriod.getTime().getTime() &lt;= dateInside.getTime()</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">					&amp;&amp; endPeriod.getTime().getTime() &gt; dateInside.getTime()) {</span>
<span class="nc" id="L587">				return new TimeRange(startPeriod.getTime(), endPeriod.getTime());</span>
			}

<span class="nc" id="L590">			monthOffset += durationInMonths;</span>
<span class="nc bnc" id="L591" title="All 2 branches missed.">		} while (startPeriod.getTime().getTime() &lt; dateInside.getTime());</span>

<span class="nc" id="L593">		return null;</span>
	}

	public static TimeRange getInclusiveEnd(TimeRange range) {
<span class="nc" id="L597">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L598">		cal.setTime(range.getEndDate());</span>
<span class="nc" id="L599">		cal.add(Calendar.MILLISECOND, -1);</span>
<span class="nc" id="L600">		return new TimeRange(range.getStartDate(), cal.getTime());</span>
	}

	/**
	 * Return the minimum non-null Date.
	 */
	public static Date minOfTwoDates(Date d1, Date d2) {
<span class="nc bnc" id="L607" title="All 4 branches missed.">		if (d1 == null &amp;&amp; d2 == null) {</span>
<span class="nc" id="L608">			return null;</span>
		}

<span class="nc bnc" id="L611" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L612">			return d2;</span>
		}

<span class="nc bnc" id="L615" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L616">			return d1;</span>
		}

<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (d1.before(d2)) {</span>
<span class="nc" id="L620">			return d1;</span>
		}

<span class="nc" id="L623">		return d2;</span>
	}

	/**
	 * Return the maximum non-null Date.
	 */
	public static Date maxOfTwoDates(Date d1, Date d2) {
<span class="nc bnc" id="L630" title="All 4 branches missed.">		if (d1 == null &amp;&amp; d2 == null) {</span>
<span class="nc" id="L631">			return null;</span>
		}

<span class="nc bnc" id="L634" title="All 2 branches missed.">		if (d1 == null) {</span>
<span class="nc" id="L635">			return d2;</span>
		}

<span class="nc bnc" id="L638" title="All 2 branches missed.">		if (d2 == null) {</span>
<span class="nc" id="L639">			return d1;</span>
		}

<span class="nc bnc" id="L642" title="All 2 branches missed.">		if (d1.after(d2)) {</span>
<span class="nc" id="L643">			return d1;</span>
		}

<span class="nc" id="L646">		return d2;</span>
	}

	public static Date addDays(Date d, String timezone, int numberOfDays) {
<span class="nc" id="L650">		return addDays(d, TimeZone.getTimeZone(timezone), numberOfDays);</span>
	}

	public static Date addDays(Date d, TimeZone timezone, int numberOfDays) {
<span class="nc" id="L654">		Calendar calendar = Calendar.getInstance(timezone);</span>
<span class="nc" id="L655">		calendar.setTime(d);</span>
<span class="nc" id="L656">		calendar.add(Calendar.DATE, numberOfDays);</span>
<span class="nc" id="L657">		return calendar.getTime();</span>
	}
	
	public static Date getNearestDOWDateAfterSelectedDate(Date selectedDate, Date targetDOWDate, TimeZone timezone) {
		
<span class="nc" id="L662">		Calendar calDOW = Calendar.getInstance(timezone);</span>
<span class="nc" id="L663">		calDOW.setTime(targetDOWDate);</span>
<span class="nc" id="L664">		int targetDOW = calDOW.get(Calendar.DAY_OF_WEEK);</span>
		
<span class="nc" id="L666">		Calendar cal = Calendar.getInstance(timezone);</span>
<span class="nc" id="L667">		cal.setTime(selectedDate);</span>

<span class="nc bnc" id="L669" title="All 2 branches missed.">		while (cal.get(Calendar.DAY_OF_WEEK) != targetDOW) {</span>
<span class="nc" id="L670">			cal.add(Calendar.DATE, 1);</span>
		}

<span class="nc" id="L673">		return cal.getTime();</span>
	}
	
public static Date getNearestDOWDateBeforeSelectedDate(Date selectedDate, Date targetDOWDate, TimeZone timezone) {
		
<span class="nc" id="L678">		Calendar calDOW = Calendar.getInstance(timezone);</span>
<span class="nc" id="L679">		calDOW.setTime(targetDOWDate);</span>
<span class="nc" id="L680">		int targetDOW = calDOW.get(Calendar.DAY_OF_WEEK);</span>
		
<span class="nc" id="L682">		Calendar cal = Calendar.getInstance(timezone);</span>
<span class="nc" id="L683">		cal.setTime(selectedDate);</span>

<span class="nc bnc" id="L685" title="All 2 branches missed.">		while (cal.get(Calendar.DAY_OF_WEEK) != targetDOW) {</span>
<span class="nc" id="L686">			cal.add(Calendar.DATE, -1);</span>
		}

<span class="nc" id="L689">		return cal.getTime();</span>
	}

	public static boolean isDayOfMonthInRange(Date date, int lowerLimit, int upperLimit, TimeZone tz) {
<span class="nc bnc" id="L693" title="All 2 branches missed.">		if (date != null) {</span>
<span class="nc" id="L694">			Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L695">			cal.setTime(date);</span>
<span class="nc" id="L696">			int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);</span>
<span class="nc bnc" id="L697" title="All 4 branches missed.">			if (dayOfMonth &gt;= lowerLimit &amp;&amp; dayOfMonth &lt;= upperLimit) {</span>
<span class="nc" id="L698">				return true;</span>
			}
		}
<span class="nc" id="L701">		return false;</span>
	}
	
	public static TimeRange getBiWeeklyPeriodRange(Date startDate, Date targetDate, TimeZone tz) {
		
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if(targetDate.before(startDate)){</span>
<span class="nc" id="L707">			return null;</span>
		}
		
<span class="nc" id="L710">		Calendar calStart = Calendar.getInstance(tz);</span>
<span class="nc" id="L711">		calStart.setTime(startDate);</span>
		
<span class="nc" id="L713">		Calendar calEnd = Calendar.getInstance(tz);</span>
<span class="nc" id="L714">		calEnd.setTime(startDate);</span>
<span class="nc" id="L715">		calEnd.add(Calendar.DATE, TWO_WEEKS_DAYS);</span>
<span class="nc" id="L716">		Date endDate = calEnd.getTime();</span>
			
<span class="nc bnc" id="L718" title="All 2 branches missed.">		while (!targetDate.before(endDate)){</span>
<span class="nc" id="L719">			calStart.add(Calendar.DATE, TWO_WEEKS_DAYS);</span>
<span class="nc" id="L720">			calEnd.add(Calendar.DATE, TWO_WEEKS_DAYS);</span>
<span class="nc" id="L721">			endDate = calEnd.getTime();</span>
		}
<span class="nc" id="L723">		Date start = calStart.getTime();</span>
<span class="nc" id="L724">		Date end = calEnd.getTime();</span>
<span class="nc" id="L725">		return new TimeRange(start, end);</span>
	}
	
	public static Date adjustDateBackToPreviousEndOfDay(Date date, TimeZone tz ) {
<span class="nc" id="L729">		Calendar calendar = Calendar.getInstance(tz);</span>
<span class="nc" id="L730">		calendar.setTime(date);</span>
<span class="nc" id="L731">		calendar.add(Calendar.DATE, -1);</span>
<span class="nc" id="L732">		DateTimeUtil.adjustToDayEnd(calendar);</span>
<span class="nc" id="L733">		return calendar.getTime();</span>
	}
	
	public static Date adjustDateBackOneSecond(Date date, TimeZone tz ) {
<span class="nc" id="L737">		Calendar calendar = Calendar.getInstance(tz);</span>
<span class="nc" id="L738">		calendar.setTime(date);</span>
<span class="nc" id="L739">		calendar.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L740">		return calendar.getTime();</span>
	}
	public static Date adjustDateForwardOneSecond(Date date, TimeZone tz ) {
<span class="nc" id="L743">		Calendar calendar = Calendar.getInstance(tz);</span>
<span class="nc" id="L744">		calendar.setTime(date);</span>
<span class="nc" id="L745">		calendar.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L746">		return calendar.getTime();</span>
	}
	public static Date adjustDateForwardOneSecond(Date date) {
<span class="nc" id="L749">		Calendar calendar = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L750">		calendar.setTime(date);</span>
<span class="nc" id="L751">		calendar.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L752">		return calendar.getTime();</span>
	}
	
	/**
	 * Converts an instance of time with some date components (year, month, day, hour, minute, ...) in GMT to another instance of time 
	 * with the same date components in the given time zone
	 * For example:
	 * Given dt = &quot;2017-01-10 00:00 GMT&quot; (midnight GMT) and tz = &quot;Eastern&quot; this function would return &quot;2017-01-10 05:00 GMT&quot; (midnight Eastern)  
	 * The local in the function name refers to the fact that we are converting from a date with components that 
	 * are in the user's time zone (local) to GMT. For example, a date UI component might display 01/10/2017 and return a 
	 * date instance of &quot;2017-01-10 00:00 GMT&quot;. If the view time zone is Eastern we can't store this date instance directly.  
	 * We need to store &quot;2017-01-10 05:00 GMT&quot;  
	 */
	public static Date convertLocalDateToGMT(Date dt, TimeZone tz) { 
<span class="nc" id="L766">		LocalDate ld = new LocalDate(dt, TimeZoneUtil.GMT_TIMEZONE); </span>
<span class="nc" id="L767">		return ld.getTime(tz); </span>
	}

	/**
	 * Converts an instance of time with some date components (year, month, day, hour, minute, ...) in some time zone 
	 * to another instance of time with the same date components in GMT
	 * For example:
	 * Given dt = &quot;2017-01-10 05:00 GMT&quot; (midnight Eastern) and tz = &quot;Eastern&quot; this function would return   
	 * &quot;2017-01-10 00:00 GMT&quot; (midnight GMT) 
	 */
	public static Date convertGMTDateToLocal(Date dt, TimeZone tz) {
<span class="nc" id="L778">		LocalDate ld = new LocalDate(dt, tz);</span>
<span class="nc" id="L779">		return ld.getTime(TimeZoneUtil.GMT_TIMEZONE);</span>
	}
	/**
	 * get interval duration
	 * @return int duration in mins
	 */
	public static long getDurationMinutes(Date startDate, Date endDate) {
<span class="nc" id="L786">		long end = endDate.getTime();</span>
<span class="nc" id="L787">		long start = startDate.getTime();</span>
<span class="nc" id="L788">		return (end - start) / (1000 * 60);//NOSONAR</span>

	}

	public static Date getEarliestDate(Date dt1, Date dt2) {
<span class="nc bnc" id="L793" title="All 2 branches missed.">		if(dt1.before(dt2)){</span>
<span class="nc" id="L794">			return dt1;</span>
		}else{
<span class="nc" id="L796">			return dt2;</span>
		}
	}

	//Moved from EmpTOAccruedNotificationDetail to avoid duplicate code. 
	//This function should be rewritten, but leaving it as is for now
	//end seems to be inclusive so if point = end this function will return true
	//In most cases you probably want to use isInRange instead of this function. 
	public static boolean fallsIn(Date point, Date start, Date end) {
<span class="nc bnc" id="L805" title="All 2 branches missed.">		if (start == null) {</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">			if (end != null) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">				return !point.after(end);</span>
			}
		} else {
<span class="nc bnc" id="L810" title="All 2 branches missed.">			if (!point.before(start)) {</span>
<span class="nc bnc" id="L811" title="All 2 branches missed.">				if (end != null) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">					return !point.after(end);</span>
				}
			} else {
<span class="nc" id="L815">				return false;</span>
			}
		}
<span class="nc" id="L818">		return true;</span>
	}
	
	public static Date dateFromTimeString(String val) {
<span class="nc" id="L822">		long time = Long.parseLong(val);</span>
<span class="nc" id="L823">		return new Date(time);</span>
	}
	
	/*
	 * Given &quot;1484006400000&quot; (instance of time &quot;2017-01-10 00:00 GMT&quot; )  and time zone Eastern. 
	 * This will return &quot;2017-01-10 05:00 GMT&quot; (midnight Eastern) 
	 */
	public static Date convertLocalDateToGMT(String val, TimeZone tz) {
<span class="nc" id="L831">		return convertLocalDateToGMT(dateFromTimeString(val), tz);</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>