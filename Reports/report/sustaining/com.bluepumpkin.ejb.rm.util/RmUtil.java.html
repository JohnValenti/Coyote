<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RmUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">RmUtil.java</span></div><h1>RmUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.util;


import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.config.ConfigManager;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.rm.Log;

/**
 * Title:        RmUtil
 * Description:  Utility class for request management.
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Shailendra Sharma
 * @version      1.0
 */

<span class="nc" id="L34">public class RmUtil {</span>

    public static final String ENTERPREFIX = &quot;ENTER: &quot;;
    public static final String EXITPREFIX  = &quot;EXIT: &quot;;

<span class="nc" id="L39">    private static final Category LOG = Log.initCategory(RmUtil.class.getName());</span>

    private static final String ENTER_STR = &quot;ENTER: &quot;;
    private static final String EXIT_STR = &quot;EXIT: &quot;;
<span class="nc" id="L43">	private static int[] weekendDays=null;</span>
<span class="nc" id="L44">	private static int[] weekDays=null;</span>

    protected Category getCategory() {
<span class="nc" id="L47">        return LOG;</span>
    }

    /**
     * Create sql in clause from the collection of string values passed as argument.
     * @param pStringValuesCollection - Collection of Strings
     * @return StringBuffer - with in clause string
     * @throws JdmoException  if there is an error.
     */
    public static synchronized StringBuffer
        createInClause(Collection pStringValuesCollection) throws JdmoException {

<span class="nc" id="L59">        StringBuffer strQuery = new StringBuffer(&quot;(&quot;);</span>

<span class="nc" id="L61">        boolean lFirst = true;</span>

<span class="nc" id="L63">        Iterator lStringValuesIterator = pStringValuesCollection.iterator();</span>

<span class="nc bnc" id="L65" title="All 2 branches missed.">        while(lStringValuesIterator.hasNext() ) {</span>

<span class="nc" id="L67">            String  lStringValue = (String) lStringValuesIterator.next();</span>

<span class="nc bnc" id="L69" title="All 2 branches missed.">            if (!lFirst ) {</span>
<span class="nc" id="L70">                strQuery.append(&quot;, &quot;);</span>
            }
            else {
<span class="nc" id="L73">                lFirst = false;</span>
            }

<span class="nc" id="L76">            strQuery.append(&quot;'&quot;);</span>
<span class="nc" id="L77">            strQuery.append(lStringValue);</span>
<span class="nc" id="L78">            strQuery.append(&quot;'&quot;);</span>
<span class="nc" id="L79">        }</span>

<span class="nc" id="L81">        strQuery.append(&quot;)&quot;);</span>

<span class="nc" id="L83">        return strQuery;</span>
    }

    /*
     * Create a subquery of the following form:
     *      SSI.STARTTIME BETWEEN '20100319 09:00:00' AND '20100321 09:00:00'
     *      AND (    
     *              (    (SSI.STARTTIME&lt;WRO.ENDTIME OR WRO.ENDTIME IS NULL)
     *               AND SSI.STARTTIME&gt;=WRO.STARTTIME
     *              )
     *           OR (
     *                  ('20091014 03:37:38'&lt;WRO.ENDTIME OR WRO.ENDTIME IS NULL)
     *               AND '20091014 03:37:38'&gt;=WRO.STARTTIME
     *              )
     *          )
     */
    public static void appendRequestDateRangeClauses(StringBuffer whereClause, String prefix, String tableAlias, 
			                                         String rangeStart, String rangeEnd, String strDtNow) {
<span class="nc" id="L101">   		whereClause.append(prefix);</span>

<span class="nc" id="L103">		getCompareToDatesClause(whereClause, tableAlias, rangeStart, rangeEnd);</span>

<span class="nc" id="L105">		appendCurrentMgrRestrictions(whereClause, tableAlias + &quot;.STARTTIME&quot;, strDtNow);</span>
<span class="nc" id="L106">	}</span>
    
	private static void getCompareToDatesClause(StringBuffer buf, String tableAlias, 
            String rangeStart, String rangeEnd)
    {
<span class="nc" id="L111">		String startTime = tableAlias + &quot;.STARTTIME&quot;;</span>
		// tableAlias could be &quot;ssi&quot; or &quot;SSI2&quot;
<span class="nc bnc" id="L113" title="All 2 branches missed.">		if (tableAlias.toLowerCase().startsWith(&quot;ssi&quot;)) {</span>
<span class="nc" id="L114">			getBetweenDatesClause(buf, startTime, rangeStart, rangeEnd);</span>
		}
		else {
<span class="nc" id="L117">			String endTime = tableAlias + &quot;.ENDTIME&quot;;</span>
<span class="nc" id="L118">			buf.append(startTime).append(&quot;&lt;'&quot;).append(rangeEnd)</span>
<span class="nc" id="L119">			   .append(&quot;' AND &quot;)</span>
<span class="nc" id="L120">		       .append(endTime).append(&quot;&gt;'&quot;).append(rangeStart)</span>
<span class="nc" id="L121">		       .append(&quot;'&quot;);</span>
		}
<span class="nc" id="L123">	}</span>

	private static void getBetweenDatesClause(StringBuffer buf, String comparator, 
            String rangeStart, String rangeEnd)
    {
<span class="nc" id="L128">		buf.append(comparator)</span>
<span class="nc" id="L129">		.append(&quot; BETWEEN '&quot;)</span>
<span class="nc" id="L130">		.append(rangeStart)</span>
<span class="nc" id="L131">		.append(&quot;' AND '&quot;)</span>
<span class="nc" id="L132">		.append(rangeEnd)</span>
<span class="nc" id="L133">		.append(&quot;'&quot;);</span>
<span class="nc" id="L134">	}</span>

	public static void appendCurrentMgrRestrictions(StringBuffer whereClause, String startTimeColumn, String strDtNow) {
<span class="nc" id="L137">		whereClause.append(&quot; AND (((&quot;)</span>
<span class="nc" id="L138">		           .append(startTimeColumn)</span>
<span class="nc" id="L139">		           .append(&quot;&lt;WRO.ENDTIME OR WRO.ENDTIME IS NULL) AND &quot;)</span>
<span class="nc" id="L140">		           .append(startTimeColumn)</span>
<span class="nc" id="L141">		           .append(&quot;&gt;=WRO.STARTTIME)&quot;);</span>
<span class="nc" id="L142">		whereClause.append(&quot; OR (('&quot;)</span>
<span class="nc" id="L143">		           .append(strDtNow)</span>
<span class="nc" id="L144">		           .append(&quot;'&lt;WRO.ENDTIME OR WRO.ENDTIME IS NULL) AND '&quot;)</span>
<span class="nc" id="L145">		           .append(strDtNow)</span>
<span class="nc" id="L146">		           .append(&quot;'&gt;=WRO.STARTTIME)&quot;);</span>
<span class="nc" id="L147">		whereClause.append(&quot;) &quot;);</span>

<span class="nc" id="L149">	}</span>

   /**
     * Dump the collections's size and the ID of each element (each element which must be a 
     * {@link com.bluepumpkin.ejb.bbm.vo.ValueObjectBase ValueObjectBase}) in the collection.  Each
     * entry is delimited with a ','.
     * 
     * @param c
     * @return
     */
    public static String dumpIDsFromVOCollection(Collection c)
    {
<span class="nc bnc" id="L161" title="All 2 branches missed.">        if ( c == null ) {</span>
<span class="nc" id="L162">			return &quot;null\n&quot;;</span>
		}

<span class="nc" id="L165">        StringBuilder buf = new StringBuilder(32);</span>
<span class="nc" id="L166">        buf.append(&quot;c.size() = &quot; + c.size() + ',');</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        for (Iterator itr=c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L168">            ValueObjectBase voBase = (ValueObjectBase) itr.next();</span>
<span class="nc" id="L169">            buf.append(voBase.getID() + &quot;,&quot;);</span>
<span class="nc" id="L170">        }</span>

<span class="nc" id="L172">        return buf.toString();</span>
    }

    /**
     * Dump the collections's size and each element in the collection.  dump of each
     * entry is delimited with a newline.
     * 
     * @param c
     * @return
     */
    public static String dumpCollection(Collection c,String seperationStr)
    {
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if ( c == null ) {</span>
<span class="nc" id="L185">			return &quot;null\n&quot;;</span>
		}
<span class="nc" id="L187">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L188">        buf.append(&quot;c.size() = &quot; + c.size() + '\t');</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">        for (Iterator itr=c.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L190">            buf.append(itr.next() + seperationStr);</span>
        }
<span class="nc" id="L192">        return buf.toString();</span>
    }
     public static String dumpCollection(Collection c)
    {
<span class="nc" id="L196">       return dumpCollection(c,&quot;,&quot;);</span>
    }

    public static String dumpArray(int[] arr)
    {
<span class="nc bnc" id="L201" title="All 2 branches missed.">        if ( arr == null ){</span>
<span class="nc" id="L202">        	return &quot;null\n&quot;;</span>
        }

<span class="nc" id="L205">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L206">        buf.append(&quot;arr.length = &quot; + arr.length + '\n');</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">        for (int i=0; i &lt; arr.length; i++) {</span>
<span class="nc" id="L208">            buf.append( arr[i] + &quot;,&quot;);</span>
        }

<span class="nc" id="L211">        return buf.toString();</span>
    }

    public static String dumpMap(Map map)
    {
<span class="nc bnc" id="L216" title="All 2 branches missed.">        if ( map == null ){</span>
<span class="nc" id="L217">        	return &quot;null\n&quot;;</span>
        }

<span class="nc" id="L220">        StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L221">        buf.append(&quot;map.size() = &quot; + map.size() + '\n');</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">        for (Iterator itr=map.keySet().iterator(); itr.hasNext(); ) {</span>
<span class="nc" id="L223">            Object key = itr.next();</span>
<span class="nc" id="L224">            buf.append(key + &quot; ==&gt; &quot; + map.get(key));</span>
<span class="nc" id="L225">        }</span>

<span class="nc" id="L227">        return buf.toString();</span>
    }

    public static String dumpObj(Object obj)
    {
<span class="nc bnc" id="L232" title="All 2 branches missed.">        if (obj == null){</span>
<span class="nc" id="L233">        	return &quot;null&quot;;</span>
        }

<span class="nc bnc" id="L236" title="All 2 branches missed.">        if ( obj instanceof Collection ) {</span>
<span class="nc" id="L237">            return dumpCollection( (Collection) obj);</span>
<span class="nc bnc" id="L238" title="All 2 branches missed.">        } else if ( obj instanceof Map ) {</span>
<span class="nc" id="L239">            return dumpMap( (Map) obj);</span>
        }

<span class="nc" id="L242">        return obj.toString();</span>
    }

    public static String dumpEnterMethod(String methodName)
    {
<span class="nc" id="L247">        return dumpEnterMethod(methodName, null );</span>
    }

    public static String dumpEnterMethod(String methodName, Object obj1)
    {
<span class="nc" id="L252">        return dumpEnterMethod(methodName, new Object[] { obj1 } );</span>
    }

    public static String dumpEnterMethod(String methodName, Object obj1, Object obj2)
    {
<span class="nc" id="L257">        return dumpEnterMethod(methodName, new Object[] { obj1, obj2 } );</span>
    }

    public static String dumpEnterMethod(String methodName, Object obj1, Object obj2, Object obj3)
    {
<span class="nc" id="L262">        return dumpEnterMethod(methodName, new Object[] { obj1, obj2, obj3 } );</span>
    }

    public static String dumpEnterMethod(String methodName, Object obj1, Object obj2, Object obj3, Object obj4)
    {
<span class="nc" id="L267">        return dumpEnterMethod(methodName, new Object[] { obj1, obj2, obj3, obj4 } );</span>
    }

    public static String dumpEnterMethod(String methodName, Object[] objs)
    {
<span class="nc bnc" id="L272" title="All 2 branches missed.">        if ( !LOG.isDebugEnabled()){</span>
<span class="nc" id="L273">        	return ENTER_STR + methodName;</span>
        }

<span class="nc" id="L276">        StringBuilder buf = new StringBuilder(ENTER_STR).append(methodName).append('(');</span>

<span class="nc bnc" id="L278" title="All 4 branches missed.">        for (int i=0; objs != null &amp;&amp; i &lt; objs.length; i++) {</span>
<span class="nc" id="L279">            buf.append(dumpObj(objs[i])).append(',');</span>
        }

<span class="nc" id="L282">        buf.append(')');</span>

<span class="nc" id="L284">        return buf.toString();</span>
    }

    public static String dumpExitMethod(String methodName)
    {
<span class="nc" id="L289">        return dumpExitMethod(methodName, null );</span>
    }

    public static String dumpExitMethod(String methodName, Object obj1)
    {
<span class="nc" id="L294">        return dumpExitMethod(methodName, new Object[] { obj1 } );</span>
    }

    public static String dumpExitMethod(String methodName, Object obj1, Object obj2)
    {
<span class="nc" id="L299">        return dumpExitMethod(methodName, new Object[] { obj1, obj2 } );</span>
    }

    public static String dumpExitMethod(String methodName, Object obj1, Object obj2, Object obj3)
    {
<span class="nc" id="L304">        return dumpExitMethod(methodName, new Object[] { obj1, obj2, obj3 } );</span>
    }

    public static String dumpExitMethod(String methodName, Object obj1, Object obj2, Object obj3, Object obj4)
    {
<span class="nc" id="L309">        return dumpExitMethod(methodName, new Object[] { obj1, obj2, obj3, obj4 } );</span>
    }

    public static String dumpExitMethod(String methodName, Object[] objs)
    {
<span class="nc bnc" id="L314" title="All 2 branches missed.">        if ( !LOG.isDebugEnabled() ){</span>
<span class="nc" id="L315">        	return EXIT_STR + methodName;</span>
        }

<span class="nc" id="L318">        StringBuilder buf = new StringBuilder(EXIT_STR).append(methodName).append('(');</span>

<span class="nc bnc" id="L320" title="All 4 branches missed.">        for (int i=0; objs != null &amp;&amp; i &lt; objs.length; i++) {</span>
<span class="nc" id="L321">            buf.append(dumpObj(objs[i])).append(',');</span>
        }

<span class="nc" id="L324">        buf.append(')');</span>

<span class="nc" id="L326">        return buf.toString();</span>
    }

    /**
     * See {@link #dumpCommaSeparated(Object[]) dumpCommaSeparated()} method
     * 
     * @param obj1
     * @return
     */
    public static String dumpCommaSeparated(Object obj1) {
<span class="nc" id="L336">        return dumpCommaSeparated(new Object[] {obj1});</span>
    }

    /**
     * See {@link #dumpCommaSeparated(Object[]) dumpCommaSeparated()} method
     * 
     * @param obj1
     * @param obj2
     * @return
     */
    public static String dumpCommaSeparated(Object obj1, Object obj2) {
<span class="nc" id="L347">        return dumpCommaSeparated(new Object[] {obj1, obj2});</span>
    }

    /**
     * See {@link #dumpCommaSeparated(Object[]) dumpCommaSeparated()} method
     * 
     * @param obj1
     * @param obj2
     * @param obj3
     * @return
     */
    public static String dumpCommaSeparated(Object obj1, Object obj2, Object obj3) {
<span class="nc" id="L359">        return dumpCommaSeparated(new Object[] {obj1, obj2, obj3});</span>
    }

    /**
     * See {@link #dumpCommaSeparated(Object[]) dumpCommaSeparated()} method
     * 
     * @param obj1
     * @param obj2
     * @param obj3
     * @param obj4
     * @return
     */
    public static String dumpCommaSeparated(Object obj1, Object obj2, Object obj3, Object obj4) {
<span class="nc" id="L372">        return dumpCommaSeparated(new Object[] {obj1, obj2, obj3, obj4});</span>
    }

    /**
     * dump the given objects as a comma separated string.  If the 
     * object is a {@link Collection Collection} or {@link Map Map}
     * the elements of the collection/map are dumped as well (not recursively though;
     * ie if the collection element is a collection, it is not dumped). 
     * 
     * @param objs
     * @return
     */
    public static String dumpCommaSeparated(Object[] objs) {
<span class="nc" id="L385">        StringBuilder buf = new StringBuilder(128);</span>

<span class="nc bnc" id="L387" title="All 4 branches missed.">        for (int i=0; objs != null &amp;&amp; i &lt; objs.length; i++) {</span>
<span class="nc" id="L388">            buf.append(dumpObj(objs[i])).append(',');</span>
        }

<span class="nc" id="L391">        return buf.toString();</span>
    }


	/**
		This API returns which day a weekend starts for &quot;weekend&quot; rules in WFM.
		0-Sunday
		- Monday
		6 - Saturday
		By default, a weekend begins on Saturday.   With this feature  the user can change this &quot;globally&quot;, by adding a config key the bpconfig table.
		insert into BPCONFIG (ID, NAME, VALUE) values (2000, 'WeekendStartDay', '2')
		In this example a weekend is defined to begin on Tuesday.
		*****************IMP***********
		For Java.util.Calendar Constant Calendar.SUNDAY=1 ; so we add 1 to whatever values is recived from the DB
		* @return int[] int array of weekend days

	*/
	public static int[] getWeekEndDays() {
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (weekendDays == null) {</span>
			//Sunday and Saturday by Default
<span class="nc" id="L411">			weekendDays = new int[]{1, 7}; </span>
			try {
<span class="nc" id="L413">				DBConfigManager dbConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L414">				int weekendStartDay = dbConfigManager.getIntValue(&quot;WeekendStartDay&quot;);</span>
<span class="nc bnc" id="L415" title="All 6 branches missed.">				if (weekendStartDay != ConfigManager.NOVALUE &amp;&amp; weekendStartDay &gt;= 0 &amp;&amp; weekendStartDay &lt;= 6) {</span>
<span class="nc bnc" id="L416" title="All 2 branches missed.">					if (weekendStartDay == 6) {</span>
<span class="nc" id="L417">						weekendDays = new int[]{7, 1};</span>
					} else {
<span class="nc" id="L419">						weekendDays = new int[]{weekendStartDay + 1, weekendStartDay + 2};</span>
					}
				}
<span class="nc" id="L422">			} catch (Exception e) {</span>
<span class="nc" id="L423">				LOG.error(e.getMessage(), e);  </span>
<span class="nc" id="L424">			}</span>
		}
<span class="nc" id="L426">		return weekendDays;</span>
	}

	public static int[] getWeekDays() {
<span class="nc bnc" id="L430" title="All 2 branches missed.">		if (weekDays == null) {</span>
<span class="nc" id="L431">			weekDays = new int[5];</span>
<span class="nc" id="L432">			int count = 0;</span>
<span class="nc" id="L433">			int[] weekendDays = RmUtil.getWeekEndDays();</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">			for (int i = 1; i &lt; 8; i++) {</span>
<span class="nc bnc" id="L435" title="All 4 branches missed.">				if (i == weekendDays[0] || i == weekendDays[1]) {</span>
<span class="nc" id="L436">					continue;</span>
				} else {
<span class="nc" id="L438">					weekDays[count++] = i;</span>
				}
			}
		}
<span class="nc" id="L442">		return weekDays;</span>
	}

	public static ID getIntIDFromString(String intValue) {
<span class="nc" id="L446">		int value = Integer.parseInt(intValue);</span>
<span class="nc" id="L447">		return ID.fromInt(value);</span>
	}
	
	/**
	 * https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html#equals(java.lang.Object,%20java.lang.Object)
	 * 
	 * @param object1
	 * @param object2
	 * @return
	 * True if the arguments are equal to each other and false otherwise. Consequently, 
	 * if both arguments are null, true is returned and if exactly one argument is null, false is returned.
	 * Otherwise, equality is determined by using the equals method of the first argument.
	 * 
	 * Added since 15.1.0 is on JDK 1.6, for newer versions use java.util.Objects.equals
	 * 
	 * Name changed due to Critical Sonar error
	 */
	
	public static boolean areEqual(Object object1, Object object2) { 
<span class="nc bnc" id="L466" title="All 2 branches missed.">	    if (object1 == object2) {</span>
<span class="nc" id="L467">	        return true;</span>
	    }
<span class="nc bnc" id="L469" title="All 4 branches missed.">	    if ((object1 == null) || (object2 == null)) {</span>
<span class="nc" id="L470">	        return false;</span>
	    }
<span class="nc" id="L472">	    return object1.equals(object2);</span>
	}

	//Use Integer.compare when we get to JDK 1.7 or better
	public static int integerCompare(int x, int y) {
<span class="nc bnc" id="L477" title="All 2 branches missed.">		if (x &gt; y) {</span>
<span class="nc" id="L478">			return 1;</span>
<span class="nc bnc" id="L479" title="All 2 branches missed.">		} else if (x &lt; y) {</span>
<span class="nc" id="L480">			return -1;</span>
		}
<span class="nc" id="L482">		return 0;</span>
	}

	public static int integerCompare(Integer x, Integer y) {
<span class="nc bnc" id="L486" title="All 2 branches missed.">		int x1 = x == null ? Integer.MAX_VALUE : x;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">		int y1 = y == null ? Integer.MAX_VALUE : y;</span>
<span class="nc" id="L488">		return integerCompare(x1, y1);</span>
	}

	public static int dateCompare(Date x, Date y) {
<span class="nc bnc" id="L492" title="All 2 branches missed.">		long x1 = x == null ? Long.MAX_VALUE : x.getTime();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">		long y1 = y == null ? Long.MAX_VALUE : y.getTime();</span>
<span class="nc" id="L494">		return longCompare(x1, y1);</span>
	}

	public static int longCompare(long x, long y) {
<span class="nc bnc" id="L498" title="All 2 branches missed.">		if (x &gt; y) {</span>
<span class="nc" id="L499">			return 1;</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">		} else if (x &lt; y) {</span>
<span class="nc" id="L501">			return -1;</span>
		}
<span class="nc" id="L503">		return 0;</span>
	}

	public static int stringCompare(String x, String y) {

<span class="nc bnc" id="L508" title="All 2 branches missed.">		if (x == y) { //NOSONAR checking for the same reference and both strings being null</span>
<span class="nc" id="L509">			return 0;</span>
		}

<span class="nc bnc" id="L512" title="All 2 branches missed.">		if (x == null) {</span>
<span class="nc" id="L513">			return -1;</span>
		}

<span class="nc bnc" id="L516" title="All 2 branches missed.">		if (y == null) {</span>
<span class="nc" id="L517">			return 1;</span>
		}

<span class="nc" id="L520">		return x.compareTo(y);</span>
	}

	public static String repeat(String str, String separator, int count) {
<span class="nc" id="L524">		StringBuilder builder = new StringBuilder();</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">		for (int i = 0; i &lt; count; i++) {</span>
<span class="nc" id="L526">			builder.append(str);</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">			if (i != (count - 1)) {</span>
<span class="nc" id="L528">				builder.append(separator);</span>
			}
		}
<span class="nc" id="L531">		return builder.toString();</span>
	}

	public static Set&lt;String&gt; parseStringToCaseInsensitiveSet(String str, String delim) {
<span class="nc" id="L535">		Collection&lt;String&gt; tokens = StringUtil.parseStringToCollection(str, delim);</span>
<span class="nc" id="L536">		Set&lt;String&gt; result = new TreeSet&lt;String&gt;(String.CASE_INSENSITIVE_ORDER);</span>
<span class="nc" id="L537">		result.addAll(tokens);</span>
<span class="nc" id="L538">		return result;</span>
	}

	 public static boolean isInt(String col) {
		try {
<span class="nc" id="L543">			Integer.parseInt(col);</span>
<span class="nc" id="L544">			return true;</span>
<span class="nc" id="L545">		} catch (NumberFormatException e) {</span>
			// Invalid integer.
<span class="nc" id="L547">			return false;</span>
		}
	}

	public static int tryParseInt(String str, int defaultValue) {

<span class="nc bnc" id="L553" title="All 4 branches missed.">		if (str == null || str.isEmpty()) {</span>
<span class="nc" id="L554">			return defaultValue;</span>
		}

		try {
<span class="nc" id="L558">			return Integer.parseInt(str);</span>
<span class="nc" id="L559">		} catch (NumberFormatException nfe) {</span>
<span class="nc" id="L560">			return defaultValue;</span>
		}
	}
	
	public static void logException(Exception e){
<span class="nc" id="L565">		LOG.error(e.getMessage(), e);  </span>
<span class="nc" id="L566">	}</span>

	/// limits the value to be in the range [min,max] both min and max are inclusive
	public static int limitIntValue(int value, int min, int max) {

<span class="nc bnc" id="L571" title="All 2 branches missed.">		if (max &lt; min) {</span>
<span class="nc" id="L572">			throw new IllegalArgumentException(&quot;limitIntValue: max value cannot be smaller than min value&quot;);</span>
		}

<span class="nc bnc" id="L575" title="All 2 branches missed.">		if (value &lt; min) {</span>
<span class="nc" id="L576">			return min;</span>
		}
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (value &gt; max) {</span>
<span class="nc" id="L579">			return max;</span>
		}

<span class="nc" id="L582">		return value;</span>
	}

	public static List&lt;Integer&gt; getKeysAsIntegers(Collection&lt;StringsPair&gt; options) {
<span class="nc" id="L586">		List&lt;Integer&gt; values = new ArrayList&lt;Integer&gt;();</span>
<span class="nc bnc" id="L587" title="All 2 branches missed.">		for (StringsPair option : options) {</span>
<span class="nc" id="L588">			values.add(Integer.parseInt(option.getKey()));</span>
<span class="nc" id="L589">		}</span>
<span class="nc" id="L590">		return values;</span>
	}

	public static List&lt;String&gt; getKeys(List&lt;StringsPair&gt; options) {
<span class="nc" id="L594">		List&lt;String&gt; results = new ArrayList&lt;String&gt;();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">		for (StringsPair option : options) {</span>
<span class="nc" id="L596">			results.add(option.getKey());</span>
<span class="nc" id="L597">		}</span>
<span class="nc" id="L598">		return results;</span>
	}

	public static void disableThreadLocalCacheIf(boolean cacheEnabled, String setterID) {
<span class="nc bnc" id="L602" title="All 2 branches missed.">		if (cacheEnabled) {</span>
<span class="nc" id="L603">			ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
		}
<span class="nc" id="L605">	}</span>
	
	public static boolean isCollectionNullOrEmpty(@SuppressWarnings(&quot;rawtypes&quot;) Collection collection) {
<span class="nc bnc" id="L608" title="All 4 branches missed.">		return collection==null || collection.isEmpty();</span>
	}
	
	
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>