<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarEventAssignmentPubDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">CalendarEventAssignmentPubDAO.java</span></div><h1>CalendarEventAssignmentPubDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  DAO class for published calendar event assignments
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignmentPubFields;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAttendee;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.UnavailabilityEvent;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;

class CalendarEventAssignmentPubDAO extends EventAssignmentPubDAO&lt;CalendarEventAssignment&gt; {
	// meta data info.
<span class="nc" id="L48">	private static FieldInfo m_fieldInfo = new CalendarEventAssignmentPubFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="nc" id="L51">		return m_fieldInfo;</span>
	}

	public CalendarEventAssignmentPubDAO() {
<span class="nc" id="L55">		super();</span>
<span class="nc" id="L56">	}</span>

	public CalendarEventAssignmentPubDAO(Jdmo dmo) {
<span class="nc" id="L59">		super(dmo);</span>
<span class="nc" id="L60">	}</span>

	/** override from base class */
	protected DAOBase createChildDAO(int iType) {
<span class="nc bnc" id="L64" title="All 2 branches missed.">		if (iType == CalendarEventAssignmentFields.CHILD_ATTENDEE) {</span>
<span class="nc" id="L65">			return new CalendarEventAttendeePubDAO(m_dmo);</span>
		} else {
<span class="nc" id="L67">			return new CalendarEventProjectPubDAO(m_dmo);</span>
		}
	}

	/**
	 * This is an override of the base class function to create an appropriate
	 * type of the value object based on the event type that is stored in
	 * CALENDAREVENTASSIGNMENT record
	 */
	protected CalendarEventAssignment createValueObject(JdmoRowset rs) throws Exception {
<span class="nc bnc" id="L77" title="All 4 branches missed.">		switch (rs.getInt(&quot;EVENTTYPE&quot;)) {</span>
		case Event.EVENT_TYPE_TIME_OFF:
<span class="nc" id="L79">			return new TimeOffEvent();</span>

		case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="nc" id="L82">			return new UnavailabilityEvent();</span>

		case Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT:
<span class="nc" id="L85">			return new CalendarEvent();</span>

		default:
			/* should never happen - could probably log or throw an error here */
<span class="nc" id="L89">			return null;</span>
		}
	}

	/** This is an override of the base class function */
	protected CalendarEventAssignment createValueObject() {
		/** this flavor of createValueObject will never be called */
<span class="nc" id="L96">		return null;</span>
	}

	/**
	 * Overrides the base class to provide an instance of the DAO class that
	 * models unpublished calendar event assignments
	 */
	protected CalendarEventAssignmentDAO getUnpublishedDAO() {
<span class="nc" id="L104">		return new CalendarEventAssignmentDAO(m_dmo);</span>
	}

	/** This is an override of the base class */
	public ID createObject(CalendarEventAssignment objValue, boolean bBatched) throws BbmCreateException {
<span class="nc" id="L109">		CalendarEventAssignment event = objValue;</span>
		/*
		 * I don't really want to expose a method on CalendarEventAssignment
		 * like setEventType(), but we need to store the event type in the
		 * database table so we can know what type of event this was, so I will
		 * do this instead
		 */
<span class="nc" id="L116">		event.setFieldValue(CalendarEventAssignmentFields.EVENTTYPE, event.getEventType());</span>

<span class="nc bnc" id="L118" title="All 2 branches missed.">		if (objValue.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME)</span>
<span class="nc bnc" id="L119" title="All 2 branches missed.">				&amp;&amp; objValue.isFieldValueSet(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="nc" id="L120">			event.setFieldValue(CalendarEventAssignmentFields.ENDTIME,</span>
<span class="nc" id="L121">					new Date(event.getStartTime().getTime() + event.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}
<span class="nc" id="L123">		return super.createObject(objValue, bBatched);</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 *
	 * Note: This is an override of the base class function to provide proper
	 * SQL clause for multi-attendee events and appropriate filter on the
	 * EVENTTYPE attribute
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="nc" id="L136">		return getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd, false);</span>
	}

	protected StringBuffer getWhereClauseForGetAttendingEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="nc" id="L141">		return getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd, true);</span>
	}

	private StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd, boolean isAttendingOnly) throws JdmoException {
<span class="nc" id="L146">		StringBuffer strSQL = new StringBuffer();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (!isAttendingOnly)</span>
<span class="nc" id="L148">			strSQL.append(getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd));</span>
		else
<span class="nc" id="L150">			strSQL.append(getWhereClauseForGetAttendingEventsQuery(workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L152">		strSQL.append(&quot; AND (&quot;);</span>
<span class="nc" id="L153">		strSQL.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask));</span>
<span class="nc" id="L154">		strSQL.append(&quot; )&quot;);</span>
<span class="nc" id="L155">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 */
	@Override
	protected StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="nc" id="L165">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, false);</span>
	}

	protected StringBuffer getWhereClauseForGetAttendingEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="nc" id="L170">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, true);</span>
	}

	private StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean isAttending) throws JdmoException {
<span class="nc" id="L175">		StringBuffer strSQL = new StringBuffer(200);</span>
		// strSQL.append(m_dmo.dateAddMinutes(&quot;A.DURATION&quot;, &quot;A.STARTTIME&quot;));
<span class="nc" id="L177">		strSQL.append(&quot; A.ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L178">		strSQL.append(&quot;' AND &quot;);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">		if (dtEnd != null) {</span>
<span class="nc" id="L180">			strSQL.append(&quot; A.STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L181">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="nc" id="L183">		strSQL.append(&quot; EXISTS &quot;);</span>
<span class="nc" id="L184">		strSQL.append(&quot; (SELECT ID &quot;);</span>
<span class="nc" id="L185">		strSQL.append(&quot;  FROM CALENDAREVENTATTENDEEPUB &quot;);</span>
<span class="nc" id="L186">		strSQL.append(&quot;  WHERE WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L187">		strSQL.append(m_dmo.createInClause(workResourceIDs));</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">		if (isAttending)</span>
<span class="nc" id="L189">			strSQL.append(&quot;  AND ISATTENDING = 1 &quot;);</span>
<span class="nc" id="L190">		strSQL.append(&quot;  AND CALENDAREVENTASSIGNMENTID = A.ID) &quot;);</span>
<span class="nc" id="L191">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events that fall within the already published periods for a given set of
	 * work resources in a given time period
	 */
	@Override
	protected StringBuffer getWhereClauseForGetEventsInPublishedPeriodsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws JdmoException {
<span class="nc" id="L202">		StringBuffer strSQL = new StringBuffer(200);</span>
<span class="nc" id="L203">		strSQL.append(&quot; A.ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L204">		strSQL.append(&quot;' AND &quot;);</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (dtEnd != null) {</span>
<span class="nc" id="L206">			strSQL.append(&quot; A.STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L207">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="nc" id="L209">		strSQL.append(&quot; EXISTS (SELECT 1 &quot;);</span>
<span class="nc" id="L210">		strSQL.append(&quot; FROM PUBLISHINGPERIOD B &quot;);</span>
<span class="nc" id="L211">		strSQL.append(&quot; WHERE A.STARTTIME &lt; B.ENDTIME AND &quot;);</span>
<span class="nc" id="L212">		strSQL.append(&quot; A.ENDTIME &gt; B.STARTTIME AND &quot;);</span>
<span class="nc" id="L213">		strSQL.append(&quot; B.WORKRESOURCEID IN (SELECT WORKRESOURCEID FROM CALENDAREVENTATTENDEEPUB C WHERE C.CALENDAREVENTASSIGNMENTID=A.ID &quot;);</span>
<span class="nc" id="L214">		strSQL.append(&quot; AND C.WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L215">		strSQL.append(m_dmo.createInClause(workResourceIDs));</span>
<span class="nc" id="L216">		strSQL.append(&quot; )) &quot;);</span>

<span class="nc" id="L218">		return strSQL;</span>
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAttendingEventsForWorkResources(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="nc" id="L227">			StringBuffer strSQL = getWhereClauseForGetAttendingEventsQuery(eventTypeBitMask, workResourceIDs, dtStart,</span>
					dtEnd);

<span class="nc" id="L230">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; events = groupNFilterEvents(workResourceIDs, dtStart,</span>
<span class="nc" id="L231">					dtEnd, strSQL.toString());</span>

			// fix bug QC27152 [7.8.3-F&amp;S] - Adherence still show calendar event
			// for employees who were marked as not attending
<span class="nc" id="L235">			filterOutNotAttendingEvent(workResourceIDs, events);</span>

<span class="nc" id="L237">			return events;</span>
<span class="nc" id="L238">		} catch (JdmoException e) {</span>
<span class="nc" id="L239">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of schedule events for multiple work resources. ????
	 * is it ok to export the events after the employee has been terminated?????
	 */
	public Collection&lt;CalendarEventAssignment&gt; exportStaffingProfiles(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="nc" id="L250">			StringBuffer strSQL = getWhereClauseForGetAttendingEventsQuery(eventTypeBitMask, workResourceIDs, dtStart,</span>
					dtEnd);

<span class="nc" id="L253">			return getObjects(strSQL.toString());</span>
<span class="nc" id="L254">		} catch (JdmoException e) {</span>
<span class="nc" id="L255">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="nc" id="L265">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L267">			return ScheduleDAOUtil.groupEventsByWorkResources(getObjects(strSQL.toString()), workResourceIDs);</span>
<span class="nc" id="L268">		} catch (JdmoException e) {</span>
<span class="nc" id="L269">			throw new BbmFinderException(e);</span>
		}
	}

	// For QA 35812
	/**
	 * Deletes the entries in CalendarEventAttendeePub for the Ids passed and
	 * CalendarEventAssignmentPub is deleted only if there are no entries in
	 * CalendarEventAssignment
	 */
	public void deleteObjects(Collection&lt;ID&gt; colIDs, Collection&lt;ID&gt; idsExistingInAttendee) throws BbmRemoveException {

		try {
<span class="nc" id="L282">			StringBuffer stmt = new StringBuffer(100);</span>

<span class="nc bnc" id="L284" title="All 6 branches missed.">			if (!(idsExistingInAttendee == null || idsExistingInAttendee.isEmpty() || colIDs == null || colIDs</span>
<span class="nc bnc" id="L285" title="All 2 branches missed.">					.isEmpty())) {</span>
				// delete child records in CalendarEventAttendeePub first
<span class="nc" id="L287">				stmt.append(</span>
						&quot;DELETE CALENDAREVENTATTENDEEPUB WHERE WORKRESOURCEID IN &quot;
<span class="nc" id="L289">								+ m_dmo.createInClause(idsExistingInAttendee)).append(</span>
<span class="nc" id="L290">						&quot; AND CALENDAREVENTASSIGNMENTID IN &quot; + m_dmo.createInClause(colIDs));</span>
<span class="nc" id="L291">				m_dmo.execute(stmt.toString());</span>
			}
			// delete records in CalendarEventAssignmentPub only if no record
			// exists for the event in attendee
<span class="nc bnc" id="L295" title="All 4 branches missed.">			if (colIDs == null || colIDs.isEmpty())</span>
<span class="nc" id="L296">				return;</span>

<span class="nc" id="L298">			stmt = new StringBuffer(100);</span>
<span class="nc" id="L299">			stmt.append(&quot; SELECT CALENDAREVENTASSIGNMENTPUB.ID FROM CALENDAREVENTASSIGNMENTPUB WHERE CALENDAREVENTASSIGNMENTPUB.ID IN &quot;</span>
<span class="nc" id="L300">					+ m_dmo.createInClause(colIDs)</span>
					+ &quot; &quot;
					+ &quot; AND NOT EXISTS (SELECT 1 FROM CALENDAREVENTATTENDEEPUB WHERE CALENDAREVENTATTENDEEPUB.CALENDAREVENTASSIGNMENTID = CALENDAREVENTASSIGNMENTPUB.ID	)&quot;);
<span class="nc" id="L303">			deleteObjects(stmt.toString());</span>

<span class="nc" id="L305">		} catch (Exception ex) {</span>
<span class="nc" id="L306">			throw new BbmRemoveException(ex);</span>
<span class="nc" id="L307">		}</span>
<span class="nc" id="L308">	}</span>

	/**
	 * Checks for existing events in CalendarEventAssignmentPub. If exists, then
	 * Attendee alone is published, otherwise CalendarEventAssignmentpub entries
	 * are created. Earlier it was trying to insert/delete based on events. Now
	 * changing the logic to handle publishing based on attendee entries.
	 */
	protected Collection&lt;CalendarEventAssignment&gt; publishSchedule(Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listNewEvents,
			List&lt;CalendarEventAssignment&gt; listOldEvents, Collection&lt;ID&gt; wrkIds) throws BbmSchedulePublishingException {
<span class="nc" id="L318">		Collection&lt;CalendarEventAssignment&gt; listEventsToPublish = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc" id="L319">		Collection&lt;CalendarEventAssignment&gt; listEventsToUpdate = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc" id="L320">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEventsToInsert = new ArrayList&lt;Collection&lt;CalendarEventAssignment&gt;&gt;();</span>
		try {
			// The below code updates Pub event for new attendes if it already
			// existing
			// otherwise it creates new pub event
<span class="nc" id="L325">			Collection&lt;ID&gt; attendees = null;</span>
<span class="nc" id="L326">			boolean isFullPublish = false;</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			for (CalendarEventAssignment event : ScheduleDAOUtil.getUniqueEvents(listNewEvents)) {</span>
<span class="nc" id="L328">				attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L329">				attendees.retainAll(wrkIds);// To make sure publishing only for</span>
											// the event and work resources to
											// be published
				// To find if there is already a corresponding event exists in
				// published world
				// even after unpublishing the event requested work resources.
				// If there is a published event exists then
				// it will return published event and we will just add new
				// attendees to it and publish the event (partial publish)
				// else a new event (full publish) will be created.
<span class="nc" id="L339">				CalendarEventAssignment pubEvent = findPartialPublishedEventInSortedList(listOldEvents, event, wrkIds);</span>
                
                //When a pub event exists, update the event with the child
                // element of attendee pub
<span class="nc bnc" id="L343" title="All 2 branches missed.">                if (pubEvent != null) {</span>
<span class="nc" id="L344">                    Collection&lt;ID&gt; eligibleWrks = event.getWorkResourceIDs();</span>
<span class="nc" id="L345">                    eligibleWrks.retainAll(wrkIds);</span>
<span class="nc" id="L346">                    pubEvent.setDescription(event.getDescription());</span>
<span class="nc" id="L347">					addWorkResourcesToEvent(pubEvent, eligibleWrks, event);</span>
<span class="nc" id="L348">                    listEventsToUpdate.add(pubEvent);</span>
<span class="nc" id="L349">                    continue;</span>
                }
                
<span class="nc" id="L352">                event.clearChildObjectMap(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
                //recurring event instance attendee will be put intp created list by default. need clean here.
<span class="nc" id="L354">                event.clearCreatedChildObjectMap(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L355" title="All 2 branches missed.">                for (ID attendeeID: attendees) {</span>
<span class="nc" id="L356">                	event.addWorkResourceID(attendeeID);</span>
<span class="nc" id="L357">                }</span>
                
<span class="nc" id="L359">                Collection&lt;CalendarEventAssignment&gt; eventCollection = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc" id="L360">                eventCollection.add(event);</span>
<span class="nc" id="L361">                listEventsToInsert.add(eventCollection);</span>
<span class="nc" id="L362">            }</span>
            
            //Insert the audit trail for the updated pub events as publish action
<span class="nc bnc" id="L365" title="All 4 branches missed.">            if (listEventsToUpdate != null &amp;&amp; !listEventsToUpdate.isEmpty()) {</span>
                //Update the events to be updated
<span class="nc" id="L367">                updateObjects(listEventsToUpdate);</span>
<span class="nc" id="L368">                createAuditForPublish(wrkIds, listEventsToUpdate);</span>
<span class="nc" id="L369">                listEventsToPublish.addAll(listEventsToUpdate);</span>
            }

			// Clone and insert the new events to be published and create audit
			// trail
<span class="nc bnc" id="L374" title="All 4 branches missed.">			if (listEventsToInsert != null &amp;&amp; !listEventsToInsert.isEmpty()) {</span>
<span class="nc" id="L375">				listEventsToPublish.addAll(publishSchedule(listEventsToInsert));</span>
			}
<span class="nc" id="L377">		} catch (Exception e) {</span>
<span class="nc" id="L378">			throw new BbmSchedulePublishingException(e);</span>
<span class="nc" id="L379">		}</span>
<span class="nc" id="L380">		return listEventsToPublish;</span>
	}
	
	protected void createAuditForPublish(Collection&lt;ID&gt; wrkIds,
			Collection&lt;CalendarEventAssignment&gt; listEventsToUpdate) throws Exception {
<span class="nc" id="L385">		CachePerEJBMethod.getCache().getEventHandler().createAuditTrailEntryForPublishing(listEventsToUpdate, wrkIds, AuditTrailEntry.ACTION_PUBLISH);</span>
<span class="nc" id="L386">	}</span>

	@Override
	ScheduleChangeDetails publishSchedule(Date dtStart, Date dtEnd, boolean bPublishedPeriodsOnly,
			Collection&lt;ID&gt; workResourceIDs, Collection&lt;ID&gt; outOfSyncWrkIds, Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; eventToBePublished)
			throws BbmSchedulePublishingException {
<span class="nc" id="L392">		ScheduleChangeDetails changeDetails = null;</span>
		try {
<span class="nc bnc" id="L394" title="All 2 branches missed.">			if (!outOfSyncWrkIds.isEmpty()) {</span>
				/*
				 * retrieve the events from un-published schedule that are to be
				 * published
				 */
<span class="nc" id="L399">				CalendarEventAssignmentDAO daoUnpub = getUnpublishedDAO();</span>
<span class="nc bnc" id="L400" title="All 2 branches missed.">				if (eventToBePublished == null) {</span>
<span class="nc" id="L401">					eventToBePublished = daoUnpub.getEventsToBePublished(outOfSyncWrkIds, dtStart, dtEnd,</span>
							bPublishedPeriodsOnly);
				}

				/*
				 * delete the published schedules, if it is not exactly same as
				 * the new schedule
				 */
<span class="nc bnc" id="L409" title="All 2 branches missed.">				Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listOldEvents = bPublishedPeriodsOnly ?</span>
<span class="nc" id="L410">						getEventsForWorkResourcesInPublishedPeriodsOnly(outOfSyncWrkIds, dtStart, dtEnd) :</span>
<span class="nc" id="L411">							getEventsForWorkResources(outOfSyncWrkIds, dtStart, dtEnd);</span>

<span class="nc" id="L413">				List&lt;CalendarEventAssignment&gt; oldEvents =</span>
<span class="nc" id="L414">						new ArrayList&lt;CalendarEventAssignment&gt;(ScheduleDAOUtil.getUniqueEvents(listOldEvents));</span>
<span class="nc" id="L415">				Collections.sort(oldEvents);</span>
<span class="nc" id="L416">				unPublishSchedule(oldEvents, outOfSyncWrkIds);</span>

<span class="nc" id="L418">				Collection&lt;CalendarEventAssignment&gt; listEventsToPublish = publishSchedule(eventToBePublished, oldEvents, outOfSyncWrkIds);</span>

				/* finally return the list of schedule changes */
<span class="nc" id="L421">				changeDetails = new ScheduleChangeDetails(outOfSyncWrkIds, dtStart, dtEnd, listOldEvents,</span>
<span class="nc" id="L422">						ScheduleDAOUtil.groupEventsByWorkResources(listEventsToPublish, outOfSyncWrkIds));</span>
			}
<span class="nc" id="L424">			return changeDetails;</span>
<span class="nc" id="L425">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L426">			throw e;</span>
<span class="nc" id="L427">		} catch (Exception e) {</span>
<span class="nc" id="L428">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	/*
	 * Checking if any of the old event which has been unpublished, has the same
	 * calendar event and not all of the attendees have been unpublished, if
	 * there is an event which has been partially unpublished, with atleast one
	 * same attendee as new event and same start time, end time &amp; activity type
	 * then it will return that event else null.
	 */
	protected CalendarEventAssignment findPartialPublishedEventInSortedList(List&lt;CalendarEventAssignment&gt; listOldEvents, CalendarEventAssignment event, Collection&lt;ID&gt; attendees) throws BbmFinderException {
<span class="nc bnc" id="L440" title="All 2 branches missed.">		for (CalendarEventAssignment e : listOldEvents) {</span>
<span class="nc bnc" id="L441" title="All 4 branches missed.">			if ( isSameEvent(event, e) &amp;&amp; isEventBePartiallyPublished(e.getWorkResourceIDs(),event, attendees)) {</span>
<span class="nc" id="L442">				return e;</span>
			}
<span class="nc" id="L444">		}</span>
<span class="nc bnc" id="L445" title="All 2 branches missed.">		if (!isPublishAllAttendees(event.getWorkResourceIDs(), attendees)) {</span>
<span class="nc" id="L446">			return getPublishedEventForOtherEmployeesIfThereIs(event);</span>
		}
<span class="nc" id="L448">		return null;</span>
	}
	
	private boolean isPublishAllAttendees(Collection&lt;ID&gt; allEventAttendees, Collection&lt;ID&gt; toPubAttendees) {
<span class="nc" id="L452">		return allEventAttendees.equals(toPubAttendees);</span>
	}
	
	private boolean isSameEvent(Event event, Event e) {
<span class="nc bnc" id="L456" title="All 4 branches missed.">		return (event.getActivityID()!= null &amp;&amp; event.getActivityID().equals(e.getActivityID()))</span>
<span class="nc bnc" id="L457" title="All 4 branches missed.">        &amp;&amp;(event.getStartTime()!= null &amp;&amp; event.getStartTime().equals(e.getStartTime()))</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">        &amp;&amp; (event.getEndTime()!= null &amp;&amp; event.getEndTime().equals(e.getEndTime()));</span>
	}
	
	private CalendarEventAssignment getPublishedEventForOtherEmployeesIfThereIs(Event event) throws BbmFinderException {
<span class="nc" id="L462">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; pubEvents = getEventsForWorkResources(</span>
<span class="nc" id="L463">				event.getEventType(),</span>
<span class="nc" id="L464">        		event.getWorkResourceIDs(), </span>
<span class="nc" id="L465">        		event.getStartTime(), </span>
<span class="nc" id="L466">        		event.getEndTime());</span>
<span class="nc" id="L467">		Collection&lt;CalendarEventAssignment&gt; pubEventsForOthers = ScheduleDAOUtil.getUniqueEvents(pubEvents);</span>

<span class="nc bnc" id="L469" title="All 2 branches missed.">        for (CalendarEventAssignment pubEvent: pubEventsForOthers) {</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">            if (isSameEvent(pubEvent, event)) {</span>
<span class="nc" id="L471">            	return pubEvent;</span>
            }
<span class="nc" id="L473">        }</span>
<span class="nc" id="L474">        return null;</span>
	}
	/*
	 * This method checks, if not all attendees have been unpublished and atleast one attendee is common between old event and new event
	 */
	private boolean isEventBePartiallyPublished(Collection attendeePublished, Event eventToPub, Collection outOfSyncWRKIDs) {
		//check if it is the published event for the specific event. if the published event and unpublished event
		//has same attributes but totally different attendee set, then they could be different events
		//for instance one event for group one, one event for group two, two of them has no overlap on attendee.
<span class="nc" id="L483">		boolean isSameEvent = false;</span>
<span class="nc" id="L484">		Collection&lt;ID&gt; unpubEventAttendee = new ArrayList&lt;ID&gt;(eventToPub.getWorkResourceIDs());</span>
<span class="nc" id="L485">		unpubEventAttendee.retainAll(attendeePublished);</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">		if (!unpubEventAttendee.isEmpty()) {</span>
<span class="nc" id="L487">			isSameEvent = true;</span>
		}
		
<span class="nc" id="L490">		boolean isAllPublishedAttendeeWillBeRePublished = false;</span>
<span class="nc" id="L491">		Collection&lt;ID&gt; pubEventAttendee = new ArrayList&lt;ID&gt;(attendeePublished);</span>
<span class="nc" id="L492">		pubEventAttendee.removeAll(outOfSyncWRKIDs);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">		if (pubEventAttendee.isEmpty()) {</span>
<span class="nc" id="L494">			isAllPublishedAttendeeWillBeRePublished = true;</span>
		}
		
<span class="nc bnc" id="L497" title="All 4 branches missed.">		return (isSameEvent &amp;&amp; !isAllPublishedAttendeeWillBeRePublished);</span>
	}

    // For QA 35812
    /**
     * Adds the non existing workresource in the given list to the given event
     */
    private void addWorkResourcesToEvent(Event pubEvent, Collection&lt;ID&gt; wrks, Event unPubEvent) {
<span class="nc bnc" id="L505" title="All 2 branches missed.">        for (ID wrkrId:wrks) {</span>
<span class="nc" id="L506">            ((CalendarEventAssignment) pubEvent).addWorkResourceID(wrkrId);</span>
<span class="nc" id="L507">            ((CalendarEventAssignment) pubEvent).markWorkResourceAttending(wrkrId, ((CalendarEventAssignment) unPubEvent).isWorkResourceAttending(wrkrId));</span>
<span class="nc" id="L508">        }</span>
<span class="nc" id="L509">    }</span>

	// override the method defined in DAONode
	public void updateObject(CalendarEventAssignment objValue) throws MultiUserException, BbmUpdateException {
<span class="nc" id="L513">		CalendarEventAssignment event = objValue;</span>

<span class="nc bnc" id="L515" title="All 2 branches missed.">		if (objValue.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME)</span>
<span class="nc bnc" id="L516" title="All 2 branches missed.">				&amp;&amp; objValue.isFieldValueSet(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="nc" id="L517">			event.setFieldValue(CalendarEventAssignmentFields.ENDTIME,</span>
<span class="nc" id="L518">					new Date(event.getStartTime().getTime() + event.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}

<span class="nc" id="L521">		super.updateObject(objValue);</span>
<span class="nc" id="L522">	}</span>

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAttendingEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, String strNativeTempName) throws BbmFinderException {

<span class="nc" id="L530">		StringBuffer strSQL = new StringBuffer(200);</span>
<span class="nc" id="L531">		strSQL.append(&quot; calendareventassignmentid in (select c.id from calendareventassignmentpub c , calendareventattendeepub a, &quot;</span>
				+ strNativeTempName
				+ &quot; t where c.id = a.calendareventassignmentid and a.isattending=1 and a.workresourceid = t.workresourceid and c.starttime &lt; t.endtime and c.endtime &gt; t.starttime and (&quot;
<span class="nc" id="L534">				+ CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask) + &quot;))&quot;);</span>
<span class="nc" id="L535">		CalendarEventAttendeePubDAO dao = (CalendarEventAttendeePubDAO) createChildDAO(CalendarEventAssignmentPubFields.CHILD_ATTENDEE);</span>
<span class="nc" id="L536">		Collection&lt;CalendarEventAttendee&gt; caAttendees = dao.getObjects(strSQL.toString());</span>

<span class="nc" id="L538">		CalendarEventAttendee attendee = null;</span>
<span class="nc" id="L539">		Map&lt;ID, List&lt;CalendarEventAttendee&gt;&gt; attendeeMap = new HashMap&lt;ID, List&lt;CalendarEventAttendee&gt;&gt;();</span>
<span class="nc" id="L540">		List&lt;CalendarEventAttendee&gt; attendeeList = null;</span>
<span class="nc" id="L541">		ID eventID = null;</span>
<span class="nc bnc" id="L542" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAttendee&gt; i = caAttendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L543">			attendee = i.next();</span>
<span class="nc" id="L544">			eventID = attendee.getParentID();</span>
<span class="nc" id="L545">			attendeeList = attendeeMap.get(eventID);</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">			if (attendeeList == null) {</span>
<span class="nc" id="L547">				attendeeList = new ArrayList&lt;CalendarEventAttendee&gt;();</span>
<span class="nc" id="L548">				attendeeMap.put(eventID, attendeeList);</span>
			}
<span class="nc" id="L550">			attendeeList.add(attendee);</span>
		}

<span class="nc" id="L553">		strSQL = new StringBuffer(200);</span>
<span class="nc" id="L554">		strSQL.append(&quot; id in (select c.id from calendareventassignmentpub c , calendareventattendeepub a, &quot;</span>
				+ strNativeTempName
				+ &quot; t where c.id = a.calendareventassignmentid and a.isattending=1 and a.workresourceid = t.workresourceid and c.starttime &lt; t.endtime and c.endtime &gt; t.starttime and (&quot;
<span class="nc" id="L557">				+ CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask) + &quot;))&quot;);</span>
<span class="nc" id="L558">		Collection&lt;CalendarEventAssignment&gt; caEvents = getObjectsWithoutChild(strSQL.toString());</span>
<span class="nc" id="L559">		CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; i = caEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L561">			event = i.next();</span>
<span class="nc" id="L562">			attendeeList = attendeeMap.get(event.getID());</span>
<span class="nc bnc" id="L563" title="All 2 branches missed.">			if (attendeeList != null) {</span>
				// feed the children of event
<span class="nc bnc" id="L565" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAttendee&gt; ii = attendeeList.iterator(); ii.hasNext();)</span>
<span class="nc" id="L566">					event.fillChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, ii.next());</span>
			}
		}

<span class="nc" id="L570">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; events = ScheduleDAOUtil.groupEventsByWorkResources(caEvents, workResourceIDs);</span>

		// fix bug QC27152 [7.8.3-F&amp;S] - Adherence still show calendar event for
		// employees who were marked as not attending
<span class="nc" id="L574">		filterOutNotAttendingEvent(workResourceIDs, events);</span>
<span class="nc" id="L575">		return events;</span>
	}

	// fix bug QC27152 [7.8.3-F&amp;S] - Adherence still show calendar event for
	// employees who were marked as not attending
	private void filterOutNotAttendingEvent(Collection&lt;ID&gt; workResourceIDs, Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; allEvents) {
<span class="nc bnc" id="L581" title="All 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.size() &lt;= 1) {</span>
<span class="nc" id="L582">			return;</span>
		}
<span class="nc" id="L584">		Iterator&lt;ID&gt; itIDs = workResourceIDs.iterator();</span>
<span class="nc" id="L585">		Iterator&lt;Collection&lt;CalendarEventAssignment&gt;&gt; itEvents = allEvents.iterator();</span>
<span class="nc" id="L586">		ID workresourceID = null;</span>
<span class="nc" id="L587">		Collection&lt;CalendarEventAssignment&gt; events = null;</span>
<span class="nc" id="L588">		CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">		for (; itIDs.hasNext();) {</span>
<span class="nc" id="L590">			workresourceID = itIDs.next();</span>
<span class="nc" id="L591">			events = itEvents.next();</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">			if (events != null &amp;&amp; !events.isEmpty()) {</span>
<span class="nc bnc" id="L593" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAssignment&gt; i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L594">					event = i.next();</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">					if (!event.isWorkResourceAttending(workresourceID)) {</span>
<span class="nc" id="L596">						i.remove();</span>
					}
				}
			}
		}
<span class="nc" id="L601">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>