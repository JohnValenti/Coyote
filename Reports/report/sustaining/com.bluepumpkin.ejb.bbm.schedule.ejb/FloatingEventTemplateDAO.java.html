<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FloatingEventTemplateDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">FloatingEventTemplateDAO.java</span></div><h1>FloatingEventTemplateDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Floating Event Template DAO class
 * Copyright:    Copyright (c) 2002
 * Company:      Blue	 Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version      1.0
 */
import java.util.*;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.*;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.ejb.bbm.dao.*;
import com.bluepumpkin.ejb.bbm.schedule.model.*;
import com.bluepumpkin.ejb.bbm.vo.*;
import com.bluepumpkin.ejb.bbm.l10n.*;

class FloatingEventTemplateDAO extends AggEventTemplateDAO&lt;FloatingEventTemplate&gt;
		implements ScheduleEventRetrieval&lt;CalendarEventAssignment&gt;, ScheduleConflictChecker&lt;FloatingEventTemplate&gt; {
	// meta data info.
<span class="nc" id="L26">	private static FieldInfo m_fieldInfo = new FloatingEventTemplateFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="nc" id="L29">		return m_fieldInfo;</span>
	}

	// change bDebugPrint's value to true below to get debug tracing

	public FloatingEventTemplateDAO() {
<span class="nc" id="L35">		super();</span>
<span class="nc" id="L36">	}</span>

	public FloatingEventTemplateDAO(Jdmo dmo) {
<span class="nc" id="L39">		super(dmo);</span>
<span class="nc" id="L40">	}</span>

	/* this method is an override from the base class */
	protected FloatingEventTemplate createValueObject() {
<span class="nc" id="L44">		return new FloatingEventTemplate();</span>
	}

	/** override from base class */
	protected DAOBase createChildDAO(int iType) {
		/**
		 * should never happen since FLOATINGEVENTTEMPLATE does not have any
		 * child objects
		 */
<span class="nc" id="L53">		return null;</span>
	}

	/** @return true if need to any child objects */
	protected boolean needToLoadChildObjects() {
<span class="nc" id="L58">		return false;</span>
	}

	/**
	 * Persists a newly created object to the database
	 *
	 * For a floating event template, after persisting the event template object
	 * to the database, a single instance of the floating event assignment will
	 * be created and persisted at the earliest time it is allowed to occur
	 * according to the template rule. This is done so that the user can select
	 * this assignment in the user interface and view/edit the properties of the
	 * floating template.
	 *
	 */
	@Override
	public ID createObject(FloatingEventTemplate objValue) throws BbmCreateException {
		/* first, create the template in batched mode */
<span class="nc" id="L75">		FloatingEventTemplate eventTemplate = objValue;</span>
		/*
		 * Gal: floating events can only be calendar event assignments (e.g.
		 * they may not be time off events or unavailabilities
		 */
<span class="nc" id="L80">		CalendarEventTemplateImpl aggObj = eventTemplate.getAggregatedTemplate();</span>
<span class="nc" id="L81">		aggObj.setEventType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT);</span>

		try {
<span class="nc" id="L84">			eventTemplate.checkIsValid();</span>
<span class="nc" id="L85">		} catch (java.io.InvalidObjectException e) {</span>
<span class="nc" id="L86">			throw new BbmCreateException(e);</span>
<span class="nc" id="L87">		}</span>

<span class="nc" id="L89">		ID templateID = super.createObject(eventTemplate, true);</span>

<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (!eventTemplate.isClass()) {</span>
			/**
			 * now let's create a single calendar event assignment at the start
			 * of the template time window that includes all of the attendees of
			 * this template
			 */
<span class="nc" id="L97">			int nStartTimeCount = eventTemplate.getStartTimeCount();</span>

<span class="nc" id="L99">			CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L100">			CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">			if (eventTemplate.getInstanceStart() != null) {</span>
				// have preferred instance start time
<span class="nc" id="L103">				event = eventTemplate.getEventInstance(eventTemplate.getInstanceStart(),</span>
<span class="nc" id="L104">						eventTemplate.getWorkResourceIDs());</span>
			} else {
<span class="nc bnc" id="L106" title="All 2 branches missed.">				for (int nStartTime = 0; nStartTime &lt; nStartTimeCount; nStartTime++) {</span>
					/*
					 * find the event assignment that is a result of
					 * instantiating this template
					 */
<span class="nc" id="L111">					event = eventTemplate.getEventInstance(eventTemplate.getStartTime(nStartTime),</span>
<span class="nc" id="L112">							eventTemplate.getWorkResourceIDs());</span>
					// event is a object never saved, it is new object.
					try {
<span class="nc" id="L115">						Collection&lt;BbmScheduleConflict&gt; cConflicts = daoEvent.getConflictsForScheduleObject(event, true);</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">						if (cConflicts.isEmpty()) {</span>
<span class="nc" id="L117">							break;</span>
						}
<span class="nc" id="L119">					} catch (BbmFinderException e) {</span>
<span class="nc" id="L120">						throw new BbmCreateException(e);</span>
<span class="nc" id="L121">					}</span>
				}
			}

			/* this call will executeBatch */
<span class="nc" id="L126">			daoEvent.createObject(event);</span>
<span class="nc" id="L127">		} else {</span>
			// QA 91070 - check if the class name is already exist
			try {
<span class="nc" id="L130">				checkDuplcateClassName(eventTemplate);</span>
<span class="nc" id="L131">			} catch (BbmException e) {</span>
<span class="nc" id="L132">				throw new BbmCreateException(e);</span>
<span class="nc" id="L133">			}</span>

<span class="nc" id="L135">			Collection&lt;BbmScheduleConflict&gt; conflicts = eventTemplate.getConflicts();</span>
<span class="nc bnc" id="L136" title="All 4 branches missed.">			if (conflicts != null &amp;&amp; !conflicts.isEmpty()) {</span>
				// remove the person who has conflicts from eventTemplate
				// attendee list,
				// then the person won't be scheduled to have class
<span class="nc" id="L140">				BbmScheduleConflict obj = null;</span>
<span class="nc" id="L141">				HashSet&lt;ID&gt; set = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">				for (Iterator&lt;BbmScheduleConflict&gt; i = conflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L143">					obj = i.next();</span>
<span class="nc" id="L144">					set.addAll(obj.getWorkResourceIDs());</span>
				}
<span class="nc bnc" id="L146" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; i = set.iterator(); i.hasNext();) {</span>
<span class="nc" id="L147">					eventTemplate.removeWorkResourceID(i.next());</span>
				}
			}
<span class="nc" id="L150">			Collection&lt;CalendarEventAssignment&gt; listSessions = getClassSessions(eventTemplate);</span>
			/* this call will executeBatch */
<span class="nc" id="L152">			new CalendarEventAssignmentDAO(m_dmo).createObjects(listSessions);</span>
		}
<span class="nc" id="L154">		return templateID;</span>
	}

	/**
	 * update a value object, save its state to database
	 */
	@Override
	public void updateObject(FloatingEventTemplate objValue) throws MultiUserException, BbmUpdateException {
<span class="nc" id="L162">		FloatingEventTemplate eventTemplate = objValue;</span>
		/*
		 * Gal: floating events can only be calendar event assignments (e.g.
		 * they may not be time off events or unavailabilities
		 */
<span class="nc" id="L167">		CalendarEventTemplateImpl aggObj = eventTemplate.getAggregatedTemplate();</span>
<span class="nc" id="L168">		aggObj.setEventType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT);</span>

		// call the base class
<span class="nc" id="L171">		super.updateObject(eventTemplate);</span>

		try {
<span class="nc" id="L174">			FloatingEventTemplate eventTemplateFromDB = getObjectByID(eventTemplate.getID());</span>

<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (eventTemplateFromDB.isClass()) {</span>
				/**
				 * it was decided that to update a class template, the
				 * previously instantiated class sessions will be blown away and
				 * the new ones will be created according to the updated
				 * definition of the class template
				 */
<span class="nc" id="L183">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L184">				dao.deleteObjectsWithParentID(eventTemplate.getID());</span>
<span class="nc" id="L185">				dao.createObjects(getClassSessions(eventTemplateFromDB));</span>
<span class="nc" id="L186">			} else {</span>
				/**
				 * Need to update the calendar event assignment according to the
				 * new template field values. The easiest way to do that is to
				 * blow away the existing calendar event assignment and recreate
				 * one with new values from the template. But before we blow
				 * away the old records, we need to save the old start times,
				 * because when we re-create the event assignments we want to
				 * place them at the same time as before, since those old start
				 * times may have been optimized by the scheduler
				 */
<span class="nc" id="L197">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L198">				Collection&lt;CalendarEventAssignment&gt; listOldEvents = dao.getObjectsByParentID(eventTemplate.getID());</span>
<span class="nc" id="L199">				Date instanceStart = eventTemplate.getInstanceStart();</span>

				/*
				 * There should be one and only one such event so this for-loop
				 * will only have a single iteration
				 */
<span class="nc bnc" id="L205" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAssignment&gt; it = listOldEvents.iterator(); it.hasNext();) {</span>
<span class="nc" id="L206">					Event oldEvent = it.next();</span>
<span class="nc" id="L207">					dao.deleteObject(oldEvent.getID());</span>

					/* now re-create the new calendar event */
<span class="nc bnc" id="L210" title="All 2 branches missed.">					CalendarEventAssignment newEvent = eventTemplate.getEventInstance(</span>
<span class="nc" id="L211">							instanceStart != null ? instanceStart : oldEvent.getStartTime(),</span>
<span class="nc" id="L212">							eventTemplate.getWorkResourceIDs());</span>
<span class="nc" id="L213">					dao.createObject(newEvent);</span>
<span class="nc" id="L214">				}</span>
			}
<span class="nc" id="L216">		} catch (BbmException e) {</span>
<span class="nc" id="L217">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L218">		}</span>
<span class="nc" id="L219">	}</span>

	/**
	 * delete objects given a list of their ids
	 */
	@Override
	public void deleteObjects(Collection&lt;? extends ID&gt; objIDs) throws BbmRemoveException {
		try {
			/* create audit trail first */
<span class="nc" id="L228">			CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L229">			Collection&lt;CalendarEventAssignment&gt; listOldEvents = dao.getObjectsByParentIDs(objIDs);</span>
<span class="nc" id="L230">			Set&lt;ID&gt; listToDelete = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; i = listOldEvents.iterator(); i.hasNext();)</span>
<span class="nc" id="L232">				listToDelete.add(i.next().getID());</span>
			/* this will create an audit trail */
<span class="nc" id="L234">			dao.deleteObjects(listToDelete);</span>

			/* call the base class to delete the template */
<span class="nc" id="L237">			super.deleteObjects(objIDs);</span>
<span class="nc" id="L238">		} catch (BbmException e) {</span>
<span class="nc" id="L239">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L240">		}</span>
<span class="nc" id="L241">	}</span>

	/**
	 * Returns a collection of conflicts (schedule constraint violations) for a
	 * newly created calendar event template to make sure that the proposed
	 * change does not violate some constraint in the schedule. The returned
	 * collection contains objects of type BPScheduleConflict. If there are no
	 * conflicts caused by the proposed change the returned collection will be
	 * empty.
	 *
	 * Note: we shall ignore conflictResolutions collection for now, because
	 * there is no requirement on schedule access manager EJB to provide a
	 * method that allows one to create a floating event and resolve conflicts
	 * at the same time.
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObject(FloatingEventTemplate obj)
			throws BbmFinderException {
<span class="nc" id="L258">		return getConflictsForScheduleObject(obj, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedScheduleObject(FloatingEventTemplate obj)
			throws BbmFinderException {
<span class="nc" id="L263">		return getConflictsForScheduleObject(obj, false);</span>
	}

	private Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(FloatingEventTemplate obj, boolean isNewObject)
			throws BbmFinderException {
<span class="nc" id="L268">		Collection&lt;BbmScheduleConflict&gt; cConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="nc" id="L269">		CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L270">		FloatingEventTemplate eventTemplate = obj;</span>
<span class="nc" id="L271">		int nStartTimeCount = eventTemplate.getStartTimeCount();</span>

<span class="nc bnc" id="L273" title="All 2 branches missed.">		if (eventTemplate.getInstanceStart() != null) {</span>
			// have preferred start time, it is not floating any more, specific
			// for converting recurring floating template into instance
<span class="nc" id="L276">			CalendarEventAssignment event = eventTemplate.getEventInstance(eventTemplate.getInstanceStart(),</span>
<span class="nc" id="L277">					eventTemplate.getWorkResourceIDs());</span>
			// event is a object never saved, it is new object.
<span class="nc" id="L279">			cConflicts = daoEvent.getConflictsForScheduleObject(event, true);</span>
<span class="nc" id="L280">		} else {</span>
			// the original design was going into the db to query calendar event
			// and shift assignment table for each possible time period
			// and see it there is any conflict. if no conflict, that period is
			// good. but if there are 100 possible periods, and the 99th is
			// good, there will be 99x2 db queries. it is not good.

			/*
			 * the new design is that: 1. query out all the calendr and shift
			 * for whole week. 2. find the overlap events in memory and then
			 * check if they are overlap or not
			 */
<span class="nc" id="L292">			Date earliestStart = eventTemplate.getEarliestPossibleStartTime();</span>
<span class="nc" id="L293">			Date latestEnd = eventTemplate.getLatestPossibleEndTime();</span>

<span class="nc bnc" id="L295" title="All 4 branches missed.">			if (earliestStart == null || latestEnd == null) {</span>
<span class="nc" id="L296">				return cConflicts;</span>
			}

<span class="nc" id="L299">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = daoEvent.getAllAttendingEventsForWorkResources(</span>
<span class="nc" id="L300">					eventTemplate.getWorkResourceIDs(), earliestStart, latestEnd);</span>
<span class="nc" id="L301">			Collection&lt;CalendarEventAssignment&gt; events = ScheduleDAOUtil.getUniqueEvents(listEvents);</span>
<span class="nc" id="L302">			ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO(m_dmo);</span>
<span class="nc" id="L303">			Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; listShifts = daoShift.getEventsForWorkResources(eventTemplate.getWorkResourceIDs(),</span>
					earliestStart, latestEnd);
<span class="nc" id="L305">			Collection&lt;ShiftAssignment&gt; shifts = ScheduleDAOUtil.getUniqueEvents(listShifts);</span>

<span class="nc bnc" id="L307" title="All 4 branches missed.">			if (events.isEmpty() &amp;&amp; shifts.isEmpty())</span>
<span class="nc" id="L308">				return cConflicts;</span>

<span class="nc" id="L310">			Collection&lt;CalendarEventAssignment&gt; overlapEvents = null;</span>
<span class="nc" id="L311">			Collection&lt;ShiftAssignment&gt; overlapShifts = null;</span>
<span class="nc" id="L312">			BbmScheduleConflict conflict = null;</span>
<span class="nc bnc" id="L313" title="All 2 branches missed.">			for (int nStartTime = 0; nStartTime &lt; nStartTimeCount; nStartTime++) {</span>
<span class="nc" id="L314">				cConflicts.clear();</span>
				/*
				 * find the event assignment that is a result of instantiating
				 * this template
				 */
<span class="nc" id="L319">				Date startTime = eventTemplate.getStartTime(nStartTime);</span>
<span class="nc" id="L320">				CalendarEventAssignment event = eventTemplate.getEventInstance(startTime,</span>
<span class="nc" id="L321">						eventTemplate.getWorkResourceIDs());</span>
				try {
					// will be use later to check conflict.
<span class="nc" id="L324">					daoEvent.calcAndSetEventPrecedence(event);</span>
<span class="nc" id="L325">				} catch (Exception e) {</span>
<span class="nc" id="L326">					throw new BbmFinderException(e);</span>
<span class="nc" id="L327">				}</span>
				// event is a object never saved, it is new object.
				// cConflicts = daoEvent.getConflictsForScheduleObject(event,
				// true); - old way
<span class="nc" id="L331">				overlapEvents = ScheduleDAOUtil.findOverlap(events, event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">				if (overlapEvents != null &amp;&amp; !overlapEvents.isEmpty()) {</span>
<span class="nc" id="L333">					conflict = daoEvent.getConflict(event, overlapEvents, isNewObject);</span>
<span class="nc bnc" id="L334" title="All 2 branches missed.">					if (conflict != null)</span>
<span class="nc" id="L335">						cConflicts.add(conflict);</span>
				}
<span class="nc" id="L337">				overlapShifts = ScheduleDAOUtil.findOverlap(shifts, event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">				if (overlapShifts != null &amp;&amp; !overlapShifts.isEmpty()) {</span>
<span class="nc" id="L339">					conflict = daoEvent.getConflict(event, overlapShifts);</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">					if (conflict != null)</span>
<span class="nc" id="L341">						cConflicts.add(conflict);</span>
				}

<span class="nc bnc" id="L344" title="All 2 branches missed.">				if (cConflicts.isEmpty()) {</span>
					// find the good location, set it as preferred, so it won't
					// calculated again before creating instance
<span class="nc" id="L347">					eventTemplate.setInstanceStart(startTime);</span>
<span class="nc" id="L348">					break;</span>
				}
			}
			/**
			 * the last step is to find the find all of the employee names for
			 * all of the conflicts returned from this method call
			 */
<span class="nc" id="L355">			ScheduleDAOUtil.findEmployeeNames(cConflicts);</span>
		}
<span class="nc" id="L357">		return cConflicts;</span>
	}

	/**
	 * Returns a collection of event assignments of multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L365">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L366">		return dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
	}

	/**
	 * Returns a collection of shift assignments fo multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L374">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L375">		return dao.getEventsForWorkResources(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
	}

	/**
	 * Instantiates all sessions of the class for persistence to DB and returns
	 * them in a collection. The algorithm is as follows: 1. Get first available
	 * start time (considering max simultaneous sessions) and place a session
	 * there. 2. Start adding employees (ignoring other constraints) until min
	 * attendees are reached. 3. Go back and repeat steps 1 &amp; 2 until min
	 * sessions is reached. 4. Fill up existing sessions until max attendees is
	 * reached or there are no more required attendees. 5. Repeat steps 1, 2 &amp; 4
	 * until there are no more required attendees. private Collection
	 * getClassSessions(FloatingEventTemplate eventTemplate) throws
	 * BbmCreateException { try { return getClassSessions2(eventTemplate); }
	 * catch (Exception e) { } // create all sessions for this class ArrayList
	 * listSessions = new ArrayList();
	 * 
	 * int maxNumSessions = eventTemplate.getMaxNumberOfSessions(); int
	 * minNumSessions = eventTemplate.getMinNumberOfSessions(); int
	 * maxSimulSessions = eventTemplate.getMaxSimultaneousSessions(); int
	 * minAttendeesInSession = eventTemplate.getMinNumberOfAttendeesInSession();
	 * int maxAttendeesInSession =
	 * eventTemplate.getMaxNumberOfAttendeesInSession();
	 * 
	 * // get first available start time and place a session there with // min
	 * number of attendees ArrayList listAttendees = new ArrayList(); Iterator
	 * itAttendee = eventTemplate.getWorkResourceIDs().iterator(); Date
	 * sessionTime = eventTemplate.getNextSessionTime(null); while (sessionTime
	 * != null &amp;&amp; itAttendee.hasNext()) { while (sessionTime != null &amp;&amp;
	 * itAttendee.hasNext()) { for (int i = 0; i &lt; maxSimulSessions; i++) {
	 * listAttendees.clear(); for (int numAttendee = 0; itAttendee.hasNext() &amp;&amp;
	 * numAttendee &lt; minAttendeesInSession; numAttendee++) {
	 * listAttendees.add(itAttendee.next()); }
	 * 
	 * if (listAttendees.isEmpty()) break; // we are done
	 * 
	 * CalendarEventAssignment session =
	 * eventTemplate.getEventInstance(sessionTime, listAttendees);
	 * listSessions.add(session);
	 * 
	 * if (listSessions.size() &gt;= minNumSessions) break; }
	 * 
	 * sessionTime = eventTemplate.getNextSessionTime(sessionTime);
	 * 
	 * if (listSessions.size() &gt;= minNumSessions) break; }
	 * 
	 * for (Iterator itSession = listSessions.iterator(); itSession.hasNext() &amp;&amp;
	 * itAttendee.hasNext(); ) { CalendarEventAssignment session =
	 * (CalendarEventAssignment) itSession.next(); for (int i =
	 * session.getWorkResourceIDs().size(); itAttendee.hasNext() &amp;&amp; i &lt;
	 * maxAttendeesInSession; i++) {
	 * session.addWorkResourceID((ID)itAttendee.next()); } } }
	 * 
	 * // check that the constraints have not been violated if
	 * (itAttendee.hasNext() || listSessions.size() &lt; minNumSessions ||
	 * listSessions.size() &gt; maxNumSessions) { throw new
	 * BbmCreateException(BbmEjbBundleKey.SCHEDULE_CANNOT_CREATE_CLASS); }
	 * 
	 * return listSessions; }
	 */
	// /////////////////////////////////
	static class SessionDesign {
		long start, end; // times of the start / end
		int layer; // layer (zero based) - if simultaneous sessions allowed
<span class="nc" id="L439">		int nAvail = 0; // number of available attendees (possibly, to be</span>
						// reshuffled)
<span class="nc" id="L441">		int bScheduled = 0; // 1:already scheduled, -1 : cannot be scheduled b/c</span>
							// of conflicts;
		// 0:unknown yet
<span class="nc" id="L444">		List&lt;ID&gt; sessionList = null; // list of attendees, if actually</span>
										// scheduled

<span class="nc" id="L447">		SessionDesign(long st, long duration, int l) {</span>
<span class="nc" id="L448">			start = st;</span>
<span class="nc" id="L449">			end = st + duration;</span>
<span class="nc" id="L450">			layer = l;</span>
<span class="nc" id="L451">		}</span>

		boolean intersects(CalendarEventAssignment ev) {
<span class="nc" id="L454">			long st2 = ev.getStartTime().getTime(), e2 = ev.getEndTime().getTime();</span>
<span class="nc bnc" id="L455" title="All 4 branches missed.">			return e2 &gt; start &amp;&amp; end &gt; st2;</span>
		}

		boolean intersects(SessionDesign sd) {
<span class="nc bnc" id="L459" title="All 4 branches missed.">			return sd.end &gt; start &amp;&amp; end &gt; sd.start;</span>
		}

		long getDurationIn15() {
<span class="nc" id="L463">			return (end - start) / ShiftAssignment.MILLIS_IN_ONE_MIN;</span>
		}

		void debugPrint(long comStart) {
<span class="nc" id="L467">			String s = Long.toString((start - comStart) / ShiftAssignment.MILLIS_IN_ONE_MIN); // in</span>
																								// 15-mins
<span class="nc bnc" id="L469" title="All 2 branches missed.">			if (layer != 0) {</span>
<span class="nc" id="L470">				s += '/';</span>
<span class="nc" id="L471">				s += layer;</span>
			}
<span class="nc bnc" id="L473" title="All 2 branches missed.">			if (bScheduled != 0)</span>
<span class="nc bnc" id="L474" title="All 2 branches missed.">				s = (bScheduled &gt; 0 ? &quot;+&quot; : &quot;-&quot;) + s;</span>
<span class="nc" id="L475">			print15(s + '(' + nAvail + ')');</span>
<span class="nc" id="L476">		}</span>
	}

	static private void print15(String s) {
<span class="nc bnc" id="L480" title="All 2 branches missed.">		for (int i = 0, sz = 12 - s.length(); i &lt; sz; i++)</span>
<span class="nc" id="L481">			System.out.print(' ');</span>
<span class="nc" id="L482">		System.out.print(s);</span>
<span class="nc" id="L483">	}</span>

	static private void debugPrintSDs(List&lt;SessionDesign&gt; sds) {
<span class="nc bnc" id="L486" title="All 4 branches missed.">		if (sds == null || sds.size() == 0) {</span>
<span class="nc" id="L487">			return;</span>
		}
<span class="nc" id="L489">		long comStart = sds.get(0).start;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">		for (int i = 0, sz = sds.size(); i &lt; sz; i++) {</span>
<span class="nc" id="L491">			sds.get(i).debugPrint(comStart);</span>
		}
<span class="nc" id="L493">	}</span>

	// /////////////////////////////////
<span class="nc bnc" id="L496" title="All 2 branches missed.">	static class AttendeeDesign implements Comparator {</span>
		ID id; // id of the attendee
		boolean avail[]; // matrix of the availability; sessions to not be
							// reshuffled
<span class="nc" id="L500">		int nAvail = 0; // how many sessions are available for the attendee</span>

<span class="nc" id="L502">		AttendeeDesign(ID id, int n) {</span>
<span class="nc" id="L503">			this.id = id;</span>
<span class="nc" id="L504">			avail = new boolean[n];</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">			for (int i = 0; i &lt; n; i++)</span>
<span class="nc" id="L506">				avail[i] = true;</span>
<span class="nc" id="L507">		}</span>

		// this will mark as unavailable some elements
		void markBusy(CalendarEventAssignment ev, ArrayList ds) {
<span class="nc bnc" id="L511" title="All 4 branches missed.">			assert (ds.size() == avail.length);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">			for (int i = 0; i &lt; avail.length; i++)</span>
<span class="nc bnc" id="L513" title="All 2 branches missed.">				if (((SessionDesign) ds.get(i)).intersects(ev))</span>
<span class="nc" id="L514">					avail[i] = false;</span>
<span class="nc" id="L515">		}</span>

		void debugPrint() {
<span class="nc bnc" id="L518" title="All 2 branches missed.">			for (int i = 0; i &lt; avail.length; i++)</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">				print15(avail[i] ? &quot;ok&quot; : &quot; &quot;);</span>
<span class="nc" id="L520">		}</span>

		public int compare(Object o1, Object o2) // throws ClassCastException
		{
<span class="nc bnc" id="L524" title="All 4 branches missed.">			if (o1 instanceof AttendeeDesign &amp;&amp; o2 instanceof AttendeeDesign)</span>
<span class="nc" id="L525">				return ((AttendeeDesign) o1).nAvail - ((AttendeeDesign) o2).nAvail;</span>
<span class="nc" id="L526">			throw new ClassCastException(&quot;Cannot compare:&quot; + o1.getClass() + &quot; vs &quot; + o2.getClass());</span>
		}
	}

	static private void debugPrintMatrix(List&lt;SessionDesign&gt; sds, List&lt;AttendeeDesign&gt; sortedAttendees) {
<span class="nc" id="L531">		int sz = sortedAttendees.size();</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">		if (sz == 0) {</span>
<span class="nc" id="L533">			return;</span>
		}
<span class="nc" id="L535">		print15(&quot;\nFormat:&quot;);</span>
<span class="nc" id="L536">		System.out.print(&quot; ['+' for assigned, '-' for forbidden] Start time(avail. attnds). Duration= &quot;);</span>
<span class="nc" id="L537">		System.out.println(((SessionDesign) sds.get(0)).getDurationIn15());</span>
<span class="nc" id="L538">		print15(&quot;wrkId(avail)&quot;);</span>
<span class="nc" id="L539">		debugPrintSDs(sds);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">		for (int i = 0; i &lt; sz; i++) {</span>
<span class="nc" id="L541">			AttendeeDesign wrk = sortedAttendees.get(i);</span>
<span class="nc" id="L542">			System.out.println();</span>
<span class="nc" id="L543">			print15(wrk.id.toString() + '(' + wrk.nAvail + ')');</span>
<span class="nc" id="L544">			wrk.debugPrint();</span>
		}
<span class="nc" id="L546">		System.out.println();</span>
<span class="nc" id="L547">	}</span>

	static private void debugPrintHeader(FloatingEventTemplate eventTemplate) {
<span class="nc" id="L550">		System.out.print(&quot;*** Scheduling a class&quot; + &quot;, maxSimulSessions=&quot; + eventTemplate.getMaxSimultaneousSessions()</span>
<span class="nc" id="L551">				+ &quot;, minNSsn=&quot; + eventTemplate.getMinNumberOfSessions() + &quot;, maxNSsn=&quot;</span>
<span class="nc" id="L552">				+ eventTemplate.getMaxNumberOfSessions() + &quot;, minAttnInSsn=&quot;</span>
<span class="nc" id="L553">				+ eventTemplate.getMinNumberOfAttendeesInSession() + &quot;, maxAttnInSsn=&quot;</span>
<span class="nc" id="L554">				+ eventTemplate.getMaxNumberOfAttendeesInSession());</span>
<span class="nc" id="L555">	}</span>

	static private void debugPrintResult(List&lt;SessionDesign&gt; allPossibleSessions) {
<span class="nc" id="L558">		long comStart = 0;</span>
<span class="nc bnc" id="L559" title="All 2 branches missed.">		for (int n = 0, sz = allPossibleSessions.size(); n &lt; sz; n++) {</span>
<span class="nc" id="L560">			SessionDesign sd = allPossibleSessions.get(n);</span>
<span class="nc bnc" id="L561" title="All 2 branches missed.">			if (n == 0) {</span>
<span class="nc" id="L562">				comStart = sd.start;</span>
			}
<span class="nc bnc" id="L564" title="All 2 branches missed.">			if (sd.bScheduled == 1) {</span>
<span class="nc" id="L565">				System.out.print(&quot;Session scheduled at &quot; + (sd.start - comStart) / ShiftAssignment.MILLIS_IN_ONE_MIN);</span>
<span class="nc bnc" id="L566" title="All 2 branches missed.">				for (int i = 0, sz2 = sd.sessionList.size(); i &lt; sz2; i++) {</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">					System.out.print(i == 0 ? &quot;; Attendees:&quot; : &quot;,&quot;);</span>
<span class="nc" id="L568">					System.out.print(sd.sessionList.get(i));</span>
				}
<span class="nc" id="L570">				System.out.println();</span>
			}
		}
<span class="nc" id="L573">	}</span>

	// recalculate matrix of attendance, and
	// sorts ArrayList of AttendeeDesign in place by the number of sessions
	// available,
	// minimal first
	static private void recalcMatrAttendance(List&lt;SessionDesign&gt; sds, List&lt;AttendeeDesign&gt; ads, boolean bDebugPrint) {
<span class="nc bnc" id="L580" title="All 2 branches missed.">		for (int i = 0, sz = sds.size(); i &lt; sz; i++) {</span>
<span class="nc" id="L581">			SessionDesign sd = sds.get(i);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if (sd.bScheduled == 0) {</span>
<span class="nc" id="L583">				sd.nAvail = 0;</span>
			}
		}
<span class="nc bnc" id="L586" title="All 2 branches missed.">		for (int n = 0, sz = ads.size(); n &lt; sz; n++) {</span>
<span class="nc" id="L587">			AttendeeDesign atd = ads.get(n);</span>
<span class="nc" id="L588">			atd.nAvail = 0;</span>
<span class="nc bnc" id="L589" title="All 2 branches missed.">			for (int i = 0; i &lt; atd.avail.length; i++)</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">				if (atd.avail[i]) {</span>
<span class="nc" id="L591">					SessionDesign sd = sds.get(i);</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">					if (sd.bScheduled == 0) {</span>
<span class="nc" id="L593">						sd.nAvail++;</span>
<span class="nc" id="L594">						atd.nAvail++;</span>
					}
				}
		}
		// now sort it in place
<span class="nc" id="L599">		Object obs[] = ads.toArray();</span>
<span class="nc" id="L600">		Arrays.sort(obs, (AttendeeDesign) obs[0]);</span>
<span class="nc bnc" id="L601" title="All 2 branches missed.">		for (int i = 0; i &lt; obs.length; i++) {</span>
<span class="nc" id="L602">			ads.set(i, (AttendeeDesign) obs[i]);</span>
		}
<span class="nc bnc" id="L604" title="All 2 branches missed.">		if (bDebugPrint) {</span>
<span class="nc" id="L605">			debugPrintMatrix(sds, ads);</span>
		}
<span class="nc" id="L607">	}</span>

	// builds the matrix of availability - all possible sessions by all
	// employees.
	// returns unsorted array of AttendeeDesign, which contains the boolean
	// array
	private List&lt;AttendeeDesign&gt; buildMatrix(Collection&lt;ID&gt; attendees, Collection colOfColOfEvts, ArrayList allPossibleSessions)
			throws BbmCreateException {
<span class="nc" id="L615">		int nSlots = allPossibleSessions.size();</span>
		// now, fill up attendees
<span class="nc" id="L617">		List&lt;AttendeeDesign&gt; allAds = new ArrayList&lt;AttendeeDesign&gt;();</span>
<span class="nc bnc" id="L618" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; itA = attendees.iterator(), itc = colOfColOfEvts.iterator(); itA.hasNext();) {</span>
<span class="nc" id="L619">			ID wrk = itA.next();</span>
<span class="nc" id="L620">			AttendeeDesign ad = new AttendeeDesign(wrk, nSlots);</span>
<span class="nc" id="L621">			allAds.add(ad);</span>
<span class="nc" id="L622">			Collection colOfEvts = (Collection) itc.next();</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">			if (colOfEvts != null)</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">				for (Iterator it = colOfEvts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L625">					Object ob = it.next();</span>
<span class="nc bnc" id="L626" title="All 2 branches missed.">					if (!(ob instanceof CalendarEventAssignment))</span>
						// implementation error!
<span class="nc" id="L628">						throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_EVENT_INVALID);</span>
<span class="nc" id="L629">					CalendarEventAssignment ev = (CalendarEventAssignment) ob;</span>
<span class="nc" id="L630">					ad.markBusy(ev, allPossibleSessions);</span>
<span class="nc" id="L631">				}</span>
<span class="nc" id="L632">		}</span>
<span class="nc" id="L633">		return allAds;</span>
	}

	// /////////////////////////////

	private Collection&lt;CalendarEventAssignment&gt; getClassSessions(FloatingEventTemplate eventTemplate) throws BbmCreateException {
<span class="nc" id="L639">		final boolean bDebugPrint = false;</span>
<span class="nc" id="L640">		int maxAttendeesInSession = eventTemplate.getMaxNumberOfAttendeesInSession();</span>
		// First, all attendees
<span class="nc" id="L642">		Collection&lt;ID&gt; attendees = eventTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L643">		int nAttn = attendees.size();</span>
		if (bDebugPrint)
			debugPrintHeader(eventTemplate);
<span class="nc" id="L646">		if (// this check is already done by DE</span>
			// maxNumSessions * maxAttendeesInSession &lt; nAttn ||
<span class="nc bnc" id="L648" title="All 2 branches missed.">		eventTemplate.getMinNumberOfSessions() * eventTemplate.getMinNumberOfAttendeesInSession() &gt; nAttn)</span>
<span class="nc" id="L649">			throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_CANNOT_CREATE_CLASS);</span>
		// Second, all possible sessions
<span class="nc" id="L651">		Date dtStart = null, dtEnd = null;</span>
<span class="nc" id="L652">		ArrayList&lt;SessionDesign&gt; allPossibleSessions = new ArrayList&lt;SessionDesign&gt;();</span>
<span class="nc bnc" id="L653" title="All 2 branches missed.">		for (Date sessionTime = eventTemplate.getNextSessionTime(null); sessionTime != null; sessionTime = eventTemplate</span>
<span class="nc" id="L654">				.getNextSessionTime(sessionTime)) {</span>
<span class="nc bnc" id="L655" title="All 2 branches missed.">			if (dtStart == null)</span>
<span class="nc" id="L656">				dtStart = sessionTime;</span>
<span class="nc" id="L657">			dtEnd = sessionTime;</span>
			// if maxSimulSessions &gt; 1, create multiple SessionDesign
<span class="nc bnc" id="L659" title="All 2 branches missed.">			for (int i = 0; i &lt; eventTemplate.getMaxSimultaneousSessions(); i++)</span>
<span class="nc" id="L660">				allPossibleSessions.add(new SessionDesign(sessionTime.getTime(), eventTemplate.getDuration()</span>
						* ShiftAssignment.MILLIS_IN_ONE_MIN, i));
		}
		// need to set end time to the end of class
<span class="nc" id="L664">		dtEnd = new Date(dtEnd.getTime() + eventTemplate.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN);</span>
		// build the matrix of availability - all possible sessions by all
		// employees.
<span class="nc" id="L667">		List&lt;AttendeeDesign&gt; sortedAttendees = null;</span>
		try {
<span class="nc" id="L669">			sortedAttendees = buildMatrix(attendees,</span>
<span class="nc" id="L670">					(new CalendarEventAssignmentDAO(m_dmo)).getAllEventsForWorkResources(attendees, dtStart, dtEnd),</span>
					allPossibleSessions);
<span class="nc" id="L672">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L673">			throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_CANNOT_CREATE_CLASS);</span>
<span class="nc" id="L674">		}</span>
<span class="nc" id="L675">		int nSessions = 0; // number of sessions set up so far</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">		while (sortedAttendees.size() &gt; 0) {</span>
			// calculate how many attendees may attend the sessions
<span class="nc" id="L678">			recalcMatrAttendance(allPossibleSessions, sortedAttendees, bDebugPrint);</span>
			// select a session which is available for the attendee (&quot;wrk&quot;)
			// with the minimal number of available sessions.
<span class="nc" id="L681">			AttendeeDesign wrk = sortedAttendees.get(0);</span>
			// First, try to attach the attendee to any existing session
<span class="nc bnc" id="L683" title="All 2 branches missed.">			if (nSessions &gt;= eventTemplate.getMinNumberOfSessions() &amp;&amp;</span>
			// otherwise we are trying to set up a new session
<span class="nc bnc" id="L685" title="All 2 branches missed.">					tryToAttach(wrk, allPossibleSessions, maxAttendeesInSession)) {</span>
<span class="nc" id="L686">				sortedAttendees.remove(0);</span>
<span class="nc" id="L687">				continue;</span>
			}
			// If not - try to set up a new session for the attendee
<span class="nc" id="L690">			int best = -1; // the index of session to be set up - not found for</span>
							// now
<span class="nc" id="L692">			long dayStart = 0; // start of the first possible timeslot for the</span>
								// day; not found yet.
<span class="nc" id="L694">			boolean bBestIsMult = false; // the session starts in</span>
											// &quot;multiple of duration&quot; time?
<span class="nc bnc" id="L696" title="All 2 branches missed.">			for (int i = 0, sz = wrk.avail.length; i &lt; sz; i++) {</span>
<span class="nc" id="L697">				SessionDesign thisSd = allPossibleSessions.get(i);</span>
<span class="nc bnc" id="L698" title="All 4 branches missed.">				if (thisSd.layer == 0</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">						&amp;&amp; (i == 0 || thisSd.start - allPossibleSessions.get(i - 1).start &gt; 16 * ShiftAssignment.MILLIS_IN_ONE_MIN))</span>
<span class="nc" id="L700">					dayStart = thisSd.start;</span>
<span class="nc bnc" id="L701" title="All 4 branches missed.">				if (wrk.avail[i] &amp;&amp; thisSd.bScheduled == 0) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">					if (best &lt; 0) { // no satisfactory session found yet</span>
<span class="nc" id="L703">						best = i;</span>
<span class="nc" id="L704">						bBestIsMult = sessionTimeIsMultiple(thisSd.start, dayStart, eventTemplate.getDuration());</span>
					} else {
<span class="nc" id="L706">						int bestAv = allPossibleSessions.get(best).nAvail;</span>
						// this session will be considered as fitting better, if
						// the number of person available is closer to
						// maxAttendeesInSession
<span class="nc bnc" id="L710" title="All 12 branches missed.">						if ((thisSd.nAvail &gt; bestAv &amp;&amp; bestAv &lt; maxAttendeesInSession)</span>
								|| (thisSd.nAvail &lt; bestAv &amp;&amp; thisSd.nAvail &gt;= maxAttendeesInSession)
								// or session time is multiple of duration - it
								// is easier to schedule such ones
								|| (thisSd.nAvail == bestAv &amp;&amp; !bBestIsMult)) {
<span class="nc" id="L715">							bBestIsMult = sessionTimeIsMultiple(thisSd.start, dayStart, eventTemplate.getDuration());</span>
<span class="nc" id="L716">							best = i;</span>
						}
					}
				}
			}
<span class="nc bnc" id="L721" title="All 2 branches missed.">			if (best &gt;= 0 &amp;&amp; // ready to setup a new session</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">					nSessions &lt; eventTemplate.getMaxNumberOfSessions()) {</span>
<span class="nc" id="L723">				setUpSession(</span>
						eventTemplate, // will remove all attendees from
										// sortedAttendees
<span class="nc" id="L726">						(SessionDesign) allPossibleSessions.get(best), best, sortedAttendees,</span>
<span class="nc" id="L727">						getPreferredAttNumberPerSession(eventTemplate));</span>
				// mark all conflicting session timeslots
<span class="nc" id="L729">				markConflictingSessions(best, allPossibleSessions);</span>
<span class="nc" id="L730">				nSessions++;</span>
			} else { // we failed to find a session for the man
<span class="nc" id="L732">				sortedAttendees.remove(0);</span>
			}
<span class="nc" id="L734">		} // end while</span>
			// the work is done, we have just to persist all teh sessions
			// scheduled
		if (bDebugPrint) {
			debugPrintResult(allPossibleSessions);
		}
<span class="nc" id="L740">		ArrayList&lt;CalendarEventAssignment&gt; listSessions = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">		for (int n = 0, sz = allPossibleSessions.size(); n &lt; sz; n++) {</span>
<span class="nc" id="L742">			SessionDesign sd = (SessionDesign) allPossibleSessions.get(n);</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">			if (sd.bScheduled == 1)</span>
<span class="nc" id="L744">				listSessions.add(eventTemplate.getEventInstance(new Date(sd.start), sd.sessionList));</span>
		}
<span class="nc" id="L746">		return listSessions;</span>
	}

	private int getPreferredAttNumberPerSession(FloatingEventTemplate classTemplate) {
<span class="nc bnc" id="L750" title="All 2 branches missed.">		if (classTemplate.getMinNumberOfSessions() == 1) { // default, no</span>
															// preference on min
															// number of
															// sessions
<span class="nc" id="L754">			return (classTemplate.getMinNumberOfAttendeesInSession() + classTemplate.getMaxNumberOfAttendeesInSession()) &gt;&gt; 1;</span>
		} else {
<span class="nc" id="L756">			int attNumPerSession = classTemplate.getWorkResourceIDs().size() / classTemplate.getMinNumberOfSessions();</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">			if (classTemplate.getWorkResourceIDs().size() % classTemplate.getMinNumberOfSessions() &gt; 0)</span>
<span class="nc" id="L758">				attNumPerSession += 1;</span>
<span class="nc" id="L759">			return attNumPerSession;</span>
		}
	}

	static private boolean sessionTimeIsMultiple(long start, long dayStart, int dur) {
<span class="nc" id="L764">		long step = dur * ShiftAssignment.MILLIS_IN_ONE_MIN;</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">		for (long s = dayStart; s &lt; start + 20; s += step)</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">			if (Math.abs(start - s) &lt; 20L) // actually it will be ==. But to be</span>
											// safe...
<span class="nc" id="L768">				return true;</span>
<span class="nc" id="L769">		return false;</span>
	}

	static private void markConflictingSessions(int ix, ArrayList sds) {
<span class="nc" id="L773">		SessionDesign me = (SessionDesign) sds.get(ix);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">		for (int i = 0, sz = sds.size(); i &lt; sz; i++) {</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">			if (i == ix)</span>
<span class="nc" id="L776">				continue;</span>
<span class="nc" id="L777">			SessionDesign sd = (SessionDesign) sds.get(i);</span>
<span class="nc bnc" id="L778" title="All 6 branches missed.">			if (sd.bScheduled == 0 &amp;&amp; sd.layer == me.layer &amp;&amp; me.intersects(sd))</span>
<span class="nc" id="L779">				sd.bScheduled = -1;</span>
		}
<span class="nc" id="L781">	}</span>

	static private boolean tryToAttach(AttendeeDesign ad, ArrayList allPossibleSessions, int max) {
<span class="nc bnc" id="L784" title="All 2 branches missed.">		for (int n = 0, sz = allPossibleSessions.size(); n &lt; sz; n++) {</span>
<span class="nc" id="L785">			SessionDesign sd = (SessionDesign) allPossibleSessions.get(n);</span>
<span class="nc bnc" id="L786" title="All 6 branches missed.">			if (sd.bScheduled == 1 &amp;&amp; ad.avail[n] &amp;&amp; sd.sessionList.size() &lt; max) {</span>
<span class="nc" id="L787">				sd.sessionList.add(ad.id);</span>
<span class="nc" id="L788">				return true;</span>
			}
		}
<span class="nc" id="L791">		return false;</span>
	}

	static private void setUpSession(FloatingEventTemplate eventTemplate, SessionDesign sd, int ix,
			List&lt;AttendeeDesign&gt; sortedAttendees, int preferredAttendees) {
<span class="nc" id="L796">		List&lt;ID&gt; listAttendees = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L797" title="All 4 branches missed.">		for (int i = 0, numAttendee = 0; i &lt; sortedAttendees.size() &amp;&amp; numAttendee &lt; preferredAttendees; i++) {</span>
<span class="nc" id="L798">			AttendeeDesign wrk = sortedAttendees.get(i);</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">			if (wrk.avail[ix]) {</span>
<span class="nc" id="L800">				numAttendee++;</span>
<span class="nc" id="L801">				listAttendees.add(wrk.id);</span>
<span class="nc" id="L802">				sortedAttendees.remove(i--); // affect the iteration</span>
			}
		}
<span class="nc" id="L805">		sd.bScheduled = 1;</span>
<span class="nc" id="L806">		sd.sessionList = listAttendees;</span>
<span class="nc" id="L807">	}</span>

	public void checkDuplcateClassName(FloatingEventTemplate eventTemplate) throws BbmException {
		try {
<span class="nc" id="L811">			double cClassName = 0, cSP = 0;</span>
<span class="nc" id="L812">			StringBuffer query = new StringBuffer(400);</span>
<span class="nc" id="L813">			String seventTemplateWindowStart = JdmoUtil.formatDBString(eventTemplate.getWindowStartDate());</span>
<span class="nc" id="L814">			String seventTemplateWindowEnd = JdmoUtil.formatDBString(eventTemplate.getWindowEndDate());</span>
<span class="nc" id="L815">			ID templateID = eventTemplate.getID();</span>

<span class="nc" id="L817">			query.append(&quot;SELECT COUNT(DISTINCT FLET.ID) AS COUNTCLASSNAME, COUNT(DISTINCT SP.ID) AS COUNTSP &quot;);</span>
<span class="nc" id="L818">			query.append(&quot;FROM FLOATINGEVENTTEMPLATE FLET, CALENDAREVENTTEMPLATE CLET, &quot;);</span>
<span class="nc" id="L819">			query.append(&quot;CALENDAREVENTTEMPLATEATTENDEE CLATD, SPWORKRESOURCE SPW, SP &quot;);</span>
<span class="nc" id="L820">			query.append(&quot;WHERE FLET.ID = CLET.ID &quot;);</span>
<span class="nc" id="L821">			query.append(&quot;AND FLET.ID &lt;&gt; &quot; + templateID.toString());</span>
<span class="nc" id="L822">			query.append(&quot;AND CLET.ID = CLATD.CALENDAREVENTTEMPLATEID &quot;);</span>
<span class="nc" id="L823">			query.append(&quot;AND CLATD.WORKRESOURCEID IN (&quot;);</span>
<span class="nc" id="L824">			query.append(&quot;SELECT WORKRESOURCEID FROM SPWORKRESOURCE WHERE SPID IN (&quot;);</span>
<span class="nc" id="L825">			query.append(&quot;SELECT DISTINCT SP.ID FROM SP, SPWORKRESOURCE &quot;);</span>
<span class="nc" id="L826">			query.append(&quot;WHERE SP.FROMDATE &lt;= '&quot; + seventTemplateWindowStart);</span>
<span class="nc" id="L827">			query.append(&quot;' AND SP.TODATE &gt;= '&quot; + seventTemplateWindowEnd);</span>
<span class="nc" id="L828">			query.append(&quot;' AND SP.ID = SPWORKRESOURCE.SPID AND SPWORKRESOURCE.WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L829">			query.append(m_dmo.createInClause(eventTemplate.getWorkResourceIDs()));</span>
<span class="nc" id="L830">			query.append(&quot;)) &quot;);</span>
<span class="nc" id="L831">			query.append(&quot;AND SP.ID IN (&quot;);</span>
<span class="nc" id="L832">			query.append(&quot;SELECT DISTINCT SP.ID &quot;);</span>
<span class="nc" id="L833">			query.append(&quot;FROM SP, SPWORKRESOURCE &quot;);</span>
<span class="nc" id="L834">			query.append(&quot;WHERE SP.FROMDATE &lt;= '&quot; + seventTemplateWindowStart);</span>
<span class="nc" id="L835">			query.append(&quot;' AND &quot;);</span>
<span class="nc" id="L836">			query.append(&quot;SP.TODATE &gt;= '&quot; + seventTemplateWindowEnd);</span>
<span class="nc" id="L837">			query.append(&quot;' AND SP.ID = SPWORKRESOURCE.SPID &quot;);</span>
<span class="nc" id="L838">			query.append(&quot;AND SPWORKRESOURCE.WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L839">			query.append(m_dmo.createInClause(eventTemplate.getWorkResourceIDs()));</span>
<span class="nc" id="L840">			query.append(&quot;) AND FLET.STARTDATE = '&quot; + seventTemplateWindowStart);</span>
<span class="nc" id="L841">			query.append(&quot;' AND FLET.ENDDATE &lt;= '&quot; + seventTemplateWindowEnd);</span>
<span class="nc" id="L842">			query.append(&quot;' AND FLET.ISCLASS = 1 &quot;);</span>
<span class="nc" id="L843">			query.append(&quot;AND FLET.CLASSNAME = '&quot;);</span>
<span class="nc" id="L844">			query.append(JdmoUtil.formatDBString(eventTemplate.getName()));</span>
<span class="nc" id="L845">			query.append(&quot;'&quot;);</span>

<span class="nc" id="L847">			JdmoRowset r = m_dmo.createRowset(query.toString());</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">			if (r.next()) {</span>
<span class="nc" id="L849">				cClassName = r.getDouble(&quot;COUNTCLASSNAME&quot;);</span>
<span class="nc" id="L850">				cSP = r.getDouble(&quot;COUNTSP&quot;);</span>
			}
<span class="nc" id="L852">			r.close();</span>

<span class="nc bnc" id="L854" title="All 4 branches missed.">			if (cSP == 1 &amp;&amp; cClassName &gt; 0) {</span>
<span class="nc" id="L855">				Object[] params = new String[] { eventTemplate.getName() };</span>
<span class="nc" id="L856">				throw new BbmException(BbmEjbBundleKey.BUNDLE_NAME, BbmEjbBundleKey.SCHEDULE_DUPL_CLASS_NAME, params);</span>
			}
<span class="nc" id="L858">		} catch (BbmException e) {</span>
<span class="nc" id="L859">			throw e;</span>
<span class="nc" id="L860">		} catch (Exception e) {</span>
<span class="nc" id="L861">			throw new BbmException(e);</span>
<span class="nc" id="L862">		}</span>
<span class="nc" id="L863">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>