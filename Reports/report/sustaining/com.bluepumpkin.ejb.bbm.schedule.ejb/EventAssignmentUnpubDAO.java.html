<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EventAssignmentUnpubDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">EventAssignmentUnpubDAO.java</span></div><h1>EventAssignmentUnpubDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  An extension of EventAssignmentDAO class for unlished
 *               event assignments. This class implements the following
 *               functionality:
 *               * Multi-user support. This is esstentially the same
 *                 implementation as that of DAORoot. If Java supported
 *                 C++ style templates, I would have done something like this
 *                 template&lt;class T&gt; class DAORoot extends T
 *                 class ShiftAssignmentDAO extends DAORoot&lt;EventAssignmentDAO&gt;
 *                 class FloatingEventTemplateDAO extends DAORoot&lt;DAONode&gt;
 *                 etc.
 *                 But Java does not have templates and I cannot extend DAORoot
 *                 from my own class, thus making it a template class, so
 *                 I am forced to essentially copy the implementation of DAORoot
 *                 here.
 *               * Event Audit Trail when events are deleted
 *               * calculating of certain fields (event precedence and isWork
 *                 flag) when necessary
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version      1.0
 */
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectRoot;
import com.bluepumpkin.ejb.core.base.MultiUserException;

abstract class EventAssignmentUnpubDAO&lt;T extends ValueObjectBase &amp; PlannedEvent&gt; extends EventAssignmentDAO&lt;T&gt; {
	public EventAssignmentUnpubDAO() {
<span class="nc" id="L47">		super();</span>
<span class="nc" id="L48">	}</span>

	public EventAssignmentUnpubDAO(Jdmo dmo) {
<span class="nc" id="L51">		super(dmo);</span>
<span class="nc" id="L52">	}</span>

	protected void appendSystemFieldsToSelect(StringBuffer strSelect) {
<span class="nc" id="L55">		strSelect.append(&quot;, A.CHANGECOUNTER, A.MODIFIEDBY &quot;);</span>
<span class="nc" id="L56">	}</span>

	public T readObjectFromDB(JdmoRowset rs) throws Exception {
<span class="nc" id="L59">		ValueObjectRoot item = (ValueObjectRoot) super.readObjectFromDB(rs);</span>
<span class="nc bnc" id="L60" title="All 2 branches missed.">		if (item == null) {</span>
<span class="nc" id="L61">			return null;</span>
		}

<span class="nc" id="L64">		item.setObjectVersionNumber(Integer.toString(rs.getInt(&quot;CHANGECOUNTER&quot;)));</span>
<span class="nc" id="L65">		item.setUpdateUser(rs.getString(&quot;MODIFIEDBY&quot;));</span>

<span class="nc" id="L67">		return (T)item;</span>
	}

	/** add system column values to object serializable state */
	public HashMap getSerializableState(T objValue, boolean bNew) {
<span class="nc" id="L72">		ValueObjectRoot item = (ValueObjectRoot) objValue;</span>

<span class="nc" id="L74">		HashMap hmap = super.getSerializableState(objValue, bNew);</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">		if (hmap.isEmpty()) {</span>
			/*
			 * the parent doesn't have any changes, see if any of the children
			 * objects have changed
			 */
<span class="nc" id="L80">			HashMap mapCreated = item.getCreateMap();</span>
<span class="nc" id="L81">			HashMap mapUpdated = item.getUpdateMap();</span>
<span class="nc" id="L82">			HashMap mapDeleted = item.getDeleteMap();</span>

<span class="nc bnc" id="L84" title="All 10 branches missed.">			if ((mapCreated == null || mapCreated.isEmpty()) &amp;&amp; (mapUpdated == null || mapUpdated.isEmpty())</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">					&amp;&amp; (mapDeleted == null || mapDeleted.isEmpty())) {</span>
				/*
				 * the parent object has not changed and neither have the
				 * children objects, so the serializable state map is empty and
				 * this update operation is essentially a no-op
				 */
<span class="nc" id="L91">				return hmap;</span>
			}
		}

		// set the modified by field
<span class="nc" id="L96">		String strModifiedBy = item.getUpdateUser();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">		if (strModifiedBy == null) {</span>
			/* get the current user identity */
<span class="nc" id="L99">			CachePerEJBMethod cache = CachePerEJBMethod.getCache();</span>
<span class="nc" id="L100">			strModifiedBy = cache.getCallerIdentity();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">			if (strModifiedBy == null)</span>
<span class="nc" id="L102">				strModifiedBy = &quot;&quot;;</span>
		}
<span class="nc" id="L104">		hmap.put(&quot;MODIFIEDBY&quot;, strModifiedBy);</span>

<span class="nc bnc" id="L106" title="All 2 branches missed.">		if (!bNew) {</span>
<span class="nc" id="L107">			String strTimestamp = item.getObjectVersionNumber();</span>
<span class="nc bnc" id="L108" title="All 6 branches missed.">			if (strTimestamp != null &amp;&amp; strTimestamp.length() &gt; 0 &amp;&amp; strTimestamp.indexOf(&quot;-1&quot;) &lt; 0)</span>
<span class="nc" id="L109">				hmap.put(&quot;CHANGECOUNTER&quot;, NumberFactory.newInteger(strTimestamp));</span>
		}
<span class="nc" id="L111">		return hmap;</span>
	}

	/**
	 * This method will be implemented by the derived class to calculate and set
	 * the overlay precedence on the event object
	 */
	protected abstract void calcAndSetEventPrecedence(T objValue) throws Exception;

	/** This is an override of the base class */
	public ID createObject(T objValue, boolean bBatched) throws BbmCreateException {
		/* check that the event object is valid */
<span class="nc" id="L123">		PlannedEvent event = (PlannedEvent) objValue;</span>

		try {
<span class="nc" id="L126">			event.checkIsValid();</span>
<span class="nc" id="L127">			calcAndSetEventPrecedence(objValue);</span>
<span class="nc" id="L128">		} catch (Exception e) {</span>
<span class="nc" id="L129">			throw new BbmCreateException(e);</span>
<span class="nc" id="L130">		}</span>
<span class="nc" id="L131">		return super.createObject(objValue, bBatched);</span>
	}

	/* this is an override of the base class */
	public void updateObject(T objValue) throws MultiUserException, BbmUpdateException {
		/* check that the event object is valid */
		//PlannedEvent event = (PlannedEvent) objValue;
		try {
<span class="nc" id="L139">			calcAndSetEventPrecedence(objValue);</span>
<span class="nc" id="L140">		} catch (Exception e) {</span>
<span class="nc" id="L141">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L142">		}</span>
<span class="nc" id="L143">		super.updateObject(objValue);</span>
<span class="nc" id="L144">	}</span>

	/**
	 * This method will be overriden by the derived class to provide an instance
	 * of the DAO class that model the published event
	 */
	abstract protected EventAssignmentPubDAO&lt;T&gt; getPublishedDAO();

	/**
	 * Returns a collection of unpublished events that are to be published
	 */
	protected Collection&lt;Collection&lt;T&gt;&gt; getEventsToBePublished(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean bPublishedPeriodsOnly) throws BbmFinderException {
<span class="nc bnc" id="L157" title="All 2 branches missed.">		return bPublishedPeriodsOnly ? getEventsForWorkResourcesInPublishedPeriodsOnly(workResourceIDs, dtStart, dtEnd)</span>
<span class="nc" id="L158">				: getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
	}

	/**
	 * Takes the currently published schedule for the selected employees and
	 * time period and overwrites the current schedule with it.
	 *
	 * The method returns a collection of IDs of the newly reverted events
	 */
	public Collection&lt;ID&gt; revertToPublishedSchedule(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
		try {
			/* first' we shall delete the current schedule */
<span class="nc" id="L171">			deleteEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			/* now get all the event assignments from the published schedule */
<span class="nc" id="L174">			EventAssignmentPubDAO&lt;T&gt; daoPub = getPublishedDAO();</span>
<span class="nc" id="L175">			Collection listPublishedEvents = daoPub.getEventsToBeReverted(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * now that we've got this collection of events, go through and
			 * create copies of objects so that they can be persisted
			 */
<span class="nc" id="L181">			Collection listEventsToCreate = ScheduleDAOUtil.cloneEventsForPublishing(listPublishedEvents);</span>

			/**
			 * Now persist the given collection of published events to the
			 * current schedule
			 */
<span class="nc" id="L187">			Collection&lt;ID&gt; eventIds = createObjects(listEventsToCreate);</span>

			/**
			 * update the publishingperiod's publishtime, make it now. that
			 * means the schedule is sync with publish
			 */
<span class="nc" id="L193">			PublishingPeriodDAO daoPubPeriod = new PublishingPeriodDAO(m_dmo);</span>
<span class="nc" id="L194">			daoPubPeriod.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L196">			return eventIds;</span>
<span class="nc" id="L197">		} catch (BbmException e) {</span>
<span class="nc" id="L198">			throw new BbmSchedulePublishingException(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>