<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleAccessManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">ScheduleAccessManagerEJB.java</span></div><h1>ScheduleAccessManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title: Blue Pumpkin Software Basic Business Model Description: Schedule
 * Access Manager EJB implementation Copyright: Copyright (c) 2001-2002 Company:
 * Blue Pumpkin Software, inc
 *
 * @author Greg Fichtenholtz
 * @version 1.0
 */
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoPCommand;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.localization.LocaleContext;
import com.bluepumpkin.common.localization.LocalizationManager;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.Priority;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.*;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRule;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRuleFieldInfo;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.notifyrules.ejb.NotifyRuleManager;
import com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.*;
import com.bluepumpkin.ejb.bbm.schedule.util.ScheduleUtil;
import com.bluepumpkin.ejb.bbm.schedulelock.ejb.ScheduleLockManager;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeRecordManager;
import com.bluepumpkin.ejb.bbm.util.MonthlySPUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectEffectivity;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTemplateDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.PhantomDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.*;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager;
import com.bluepumpkin.ejb.bbm.workrules.model.Rotation;
import com.bluepumpkin.ejb.bbm.workrules.model.Shift;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;

import javax.naming.Context;
import javax.naming.InitialContext;
import java.rmi.RemoteException;
import java.util.*;
import java.util.Map.Entry;

<span class="fc" id="L82">public class ScheduleAccessManagerEJB extends SessionEJBBase {</span>
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

	/*
	 * this variable has package scope so that it can be accessed by schedule
	 * DAO classes
	 */
<span class="fc" id="L92">	static final Category m_cat = Log.initCategory(ScheduleAccessManagerEJB.class.getName());</span>

	/**
	 * this is a helper class that deals with various pre- and post- conditions
	 * to various schedule changes
	 */
	ScheduleEventHandler m_eventHandler;

	/** schedule cache-related */
	private ScheduleAccessManagerEJBCache m_scheduleCache;

	/**
	 * references to other EJBs used by the Schedule Access Manager EJB
	 */
	NotifyRuleManager m_notifyManager;

	WorkResourceManager m_workResourceManager;

	ActivityManager m_activityManager;

	DBConfigManager m_dbConfigManager;

	ScheduleLockManager m_lockManager;

	EventAuditTrailManager m_auditManager;

	CampaignManager m_pCampaignManager;

	SkillManager m_skillManager;

	EmpWorkRuleManager m_empWorkRuleManager;

	WorkRuleManager m_workRuleManager;

<span class="fc" id="L126">	public static int CHUNKSIZE = 500;</span>

	/*
	 * a flag that indicates whether or not this instance is running in what if
	 * mode
	 */
<span class="fc" id="L132">	boolean m_isWhatIf = false;</span>

	{
<span class="fc" id="L135">		super.init(ScheduleAccessManagerEJB.class.getName());</span>
<span class="fc" id="L136">	}</span>

	/**
	 * Perform one-time initialization of this EJB instance
	 */
	@Override
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L145">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L146">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">			if (WIF != null) {</span>
<span class="fc" id="L148">				m_isWhatIf = WIF.booleanValue();</span>
			}

<span class="fc" id="L151">			m_dbConfigManager = BbmManagerFactory.getDBConfigManager(m_isWhatIf);</span>
<span class="pc bpc" id="L152" title="1 of 2 branches missed.">			if (ConfigCacheUtil.isCacheEnabled(m_dbConfigManager, ConfigKey.SCHEDULE_CACHE_USAGE)) {</span>
				/*
				 * from the spec: schedule cache time window would be +x hours
				 * (last x hours) to +x hours (the next x hours), where x is the
				 * cache window used by time record manager.
				 */
				/* the default cache window size is 1 day */
<span class="fc" id="L159">				long cacheWindowSize = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="fc" id="L160">				String cacheWindowSizeStr = m_dbConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="pc bpc" id="L161" title="1 of 2 branches missed.">				if (cacheWindowSizeStr != null) {</span>
<span class="nc" id="L162">					cacheWindowSize = Long.parseLong(cacheWindowSizeStr);</span>
				}

				// Add Cache support
<span class="fc" id="L166">				m_scheduleCache = new ScheduleAccessManagerEJBCache(cacheWindowSize);</span>
			}
<span class="fc" id="L168">			m_workResourceManager = BbmManagerFactory.getWorkResourceManager(m_isWhatIf);</span>
<span class="fc" id="L169">			m_activityManager = WfmManagerFactory.getActivityManager(m_isWhatIf);</span>
<span class="fc" id="L170">			m_lockManager = WfmManagerFactory.getScheduleLockManager(m_isWhatIf);</span>
<span class="fc" id="L171">			m_auditManager = BbmManagerFactory.getEventAuditTrailManager(m_isWhatIf);</span>
<span class="fc" id="L172">			m_pCampaignManager = WfmManagerFactory.getCampaignManager(m_isWhatIf);</span>
<span class="fc" id="L173">			m_skillManager = WfmManagerFactory.getSkillManager(m_isWhatIf);</span>
<span class="fc" id="L174">			m_empWorkRuleManager = WfmManagerFactory.getEmpWorkRuleManager(m_isWhatIf);</span>
<span class="fc" id="L175">			m_workRuleManager = WfmManagerFactory.getWorkRuleManager(m_isWhatIf);</span>
<span class="fc" id="L176">			ScheduleAccessManager scheduleAccessManager = WfmManagerFactory.getScheduleAccessManager(m_isWhatIf);</span>

			/** There's no need for notifications in What-If Mode */
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">			if (!m_isWhatIf) {</span>
<span class="fc" id="L180">				m_notifyManager = BbmManagerFactory.getNotifyRuleManager();</span>
			}

<span class="fc" id="L183">			m_eventHandler = new ScheduleEventHandler(m_cat, m_lockManager, m_auditManager, scheduleAccessManager);</span>
<span class="nc" id="L184">		} catch (Exception e) {</span>
<span class="nc" id="L185">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L186">		}</span>
<span class="fc" id="L187">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L192">		return m_cat;</span>
	}

	/**
	 * returns the identity (username) of the current user this method has
	 * package scope
	 */
	String getCallerIdentify() {
<span class="fc" id="L200">		java.security.Principal principal = m_sessionContext.getCallerPrincipal();</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">		return (principal != null ? principal.getName() : null);</span>
	}

	public ImportedEvent getImportedEventByID(ID eventID) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L205">		methodStart(&quot;getImportedEventByID&quot;, eventID);</span>

<span class="nc" id="L207">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
<span class="nc" id="L209">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L210">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L212">			throw e;</span>
<span class="nc" id="L213">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L214">			handleException(e);</span>
<span class="nc" id="L215">			throw e;</span>
		} finally {
<span class="nc" id="L217">			dao.cleanUp();</span>
<span class="nc" id="L218">			methodFinish();</span>
		}
	}

	public Collection&lt;ImportedEvent&gt; getImportedEventsForWorkResource(ID workResourceID, Collection&lt;ID&gt; activityCol,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L224">		methodStart(&quot;getImportedEventsForWorkResource&quot;, workResourceID, activityCol, dtStart, dtEnd);</span>

<span class="nc" id="L226">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
<span class="nc" id="L228">			return dao.getEventsForWorkResource(workResourceID, activityCol, dtStart, dtEnd);</span>
<span class="nc" id="L229">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L230">			handleException(e);</span>
<span class="nc" id="L231">			throw e;</span>
		} finally {
<span class="nc" id="L233">			dao.cleanUp();</span>
<span class="nc" id="L234">			methodFinish();</span>
		}
	}

	public Collection getEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L239">		return (ArrayList) ((ArrayList) getEventsForWorkResources(Arrays.asList(workResourceID), dtStart, dtEnd))</span>
<span class="nc" id="L240">				.get(0);</span>
	}

	public Collection getEventsForWorkResourceByType(int eventTypeMask, ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L245">		return (ArrayList) ((ArrayList) getEventsForWorkResourcesByType(eventTypeMask, Arrays.asList(workResourceID),</span>
<span class="fc" id="L246">				dtStart, dtEnd)).get(0);</span>
	}

	public Collection getPublishedEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L251">		List&lt;ID&gt; wrIDs = new ArrayList&lt;ID&gt;(1);</span>
<span class="fc" id="L252">		wrIDs.add(workResourceID);</span>
<span class="fc" id="L253">		return (ArrayList) ((ArrayList) getPublishedEventsForWorkResources(wrIDs, dtStart, dtEnd)).get(0);</span>
	}

	public Collection getPublishedEventsForWorkResourceByType(int eventTypeMask, ID workResourceID, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="fc" id="L258">		return (ArrayList) ((ArrayList) getPublishedEventsForWorkResourcesByType(eventTypeMask,</span>
<span class="fc" id="L259">				Arrays.asList(workResourceID), dtStart, dtEnd)).get(0);</span>
	}

	public List getEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L264">		methodStart(&quot;getEventsForWorkResources&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
			/*
			 * set up an event type bitmask the covers all types of un-published
			 * events
			 */
<span class="fc" id="L271">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>

<span class="fc" id="L273">			return getEventsForWorkResourcesByType(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
		} finally {
<span class="pc" id="L275">			methodFinish();</span>
		}
	}

	public List getEventsForWorkResourcesByType(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="fc" id="L281">		methodStart(&quot;getEventsForWorkResourcesByType&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs,</span>
				dtStart, dtEnd);

<span class="fc" id="L284">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L286">			List events = new ArrayList();</span>

<span class="fc bfc" id="L288" title="All 2 branches covered.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0) {</span>
<span class="fc" id="L289">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="fc" id="L290">				events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
			}

<span class="fc bfc" id="L293" title="All 2 branches covered.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_ALL_CALENDAR_EVENTS) != 0) {</span>
<span class="fc" id="L294">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="fc" id="L295">				events.add(dao.getAllEventsForWorkResources(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>
			}
<span class="fc" id="L297">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, events);</span>
<span class="nc" id="L298">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L299">			handleException(e);</span>
<span class="nc" id="L300">			throw e;</span>
<span class="nc" id="L301">		} catch (Exception e) {</span>
<span class="nc" id="L302">			handleException(e);</span>
<span class="nc" id="L303">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L305">			dmo.cleanUp();</span>
<span class="pc" id="L306">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L312">		methodStart(&quot;getPublishedEventsForWorkResources&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
			/*
			 * set up a bit mask that represents all types of published events
			 */
<span class="fc" id="L318">			int eventTypeMask = Event.EVENT_TYPE_IMPORTED | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
					| Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;

<span class="fc" id="L321">			return getPublishedEventsForWorkResourcesByType(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
		} finally {
<span class="pc" id="L323">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResourcesByType(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L329">		methodStart(&quot;getPublishedEventsForWorkResourcesByType&quot;, NumberFactory.newInteger(eventTypeMask),</span>
				workResourceIDs, dtStart, dtEnd);

<span class="fc" id="L332">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L334">			List events = new ArrayList();</span>

<span class="fc bfc" id="L336" title="All 2 branches covered.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_IMPORTED) != 0) {</span>
<span class="fc" id="L337">				ImportedEventDAO dao = new ImportedEventDAO(dmo);</span>
<span class="fc" id="L338">				events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
			}

<span class="fc" id="L341">			String tempTableName = null;</span>
			// 50 is a number derived based on a few automated tests done on LW
			// database, Sameet , Aug 2008
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">			if ((workResourceIDs != null &amp;&amp; workResourceIDs.size() &gt; 50)) {</span>
<span class="nc" id="L345">				tempTableName = createTempTableToQueryEvents(dmo, workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="fc bfc" id="L347" title="All 2 branches covered.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0) {</span>
<span class="fc" id="L348">				ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO(dmo);</span>
<span class="pc bpc" id="L349" title="1 of 2 branches missed.">				if (tempTableName != null) {</span>
<span class="nc" id="L350">					events.add(dao.getEventsForWorkResources(workResourceIDs, tempTableName));</span>
				} else {
<span class="fc" id="L352">					events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
				}
			}

<span class="fc bfc" id="L356" title="All 2 branches covered.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_ALL_CALENDAR_EVENTS) != 0) {</span>
<span class="fc" id="L357">				CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="pc bpc" id="L358" title="1 of 2 branches missed.">				if (tempTableName != null) {</span>
<span class="nc" id="L359">					events.add(dao.getAttendingEventsForWorkResources(eventTypeMask, workResourceIDs, tempTableName));</span>
				} else {
<span class="fc" id="L361">					events.add(dao.getAttendingEventsForWorkResources(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>
				}
			}

<span class="fc" id="L365">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, events);</span>
<span class="nc" id="L366">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L367">			handleException(e);</span>
<span class="nc" id="L368">			throw e;</span>
<span class="nc" id="L369">		} catch (Exception e) {</span>
<span class="nc" id="L370">			handleException(e);</span>
<span class="nc" id="L371">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L373">			dmo.cleanUp();</span>
<span class="pc" id="L374">			methodFinish();</span>
		}
	}

	public ID createImportedEvent(ImportedEvent event) throws BbmCreateException {
<span class="nc" id="L379">		methodStart(&quot;createImportedEvent&quot;, event);</span>

<span class="nc" id="L381">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
			/* perform what is necessary before a new event gets created */
<span class="nc" id="L384">			m_eventHandler.preCreateEvent(null, event);</span>

<span class="nc" id="L386">			ID eventID = dao.createObject(event);</span>

			/* perform what is necessary when a new event gets created */
<span class="nc" id="L389">			m_eventHandler.postCreateEvent(event);</span>

<span class="nc" id="L391">			return eventID;</span>
<span class="nc" id="L392">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L393">			handleException(e);</span>
<span class="nc" id="L394">			throw e;</span>
<span class="nc" id="L395">		} catch (Exception e) {</span>
<span class="nc" id="L396">			handleException(e);</span>
<span class="nc" id="L397">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L399">			dao.cleanUp();</span>
<span class="nc" id="L400">			methodFinish();</span>
		}
	}

	public void deleteImportedEvents(Collection&lt;ID&gt; eventIDs) throws BbmRemoveException {
<span class="nc" id="L405">		methodStart(&quot;deleteImportedEvents&quot;, eventIDs);</span>

<span class="nc" id="L407">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
			/** save the objects before blowing them away */
<span class="nc" id="L410">			Collection&lt;ImportedEvent&gt; listEvents = dao.getObjectsByIDs(eventIDs);</span>

			/** perform what is necessary before events get deleted */
<span class="nc" id="L413">			m_eventHandler.preDeleteEvents(null, listEvents);</span>

<span class="nc" id="L415">			dao.deleteObjects(eventIDs);</span>

			/** perform what is necessary when events get deleted */
<span class="nc" id="L418">			m_eventHandler.postDeleteEvents(listEvents);</span>

<span class="nc" id="L420">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L421">			handleException(e);</span>
<span class="nc" id="L422">			throw e;</span>
<span class="nc" id="L423">		} catch (Exception e) {</span>
<span class="nc" id="L424">			handleException(e);</span>
<span class="nc" id="L425">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L427">			dao.cleanUp();</span>
<span class="nc" id="L428">			methodFinish();</span>
<span class="nc" id="L429">		}</span>
<span class="nc" id="L430">	}</span>

	public ID createShiftAssignment(ShiftAssignment shiftAssignment)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L434">		return createSAWithLock(null, Arrays.asList(shiftAssignment)).iterator().next();</span>
	}

	public Collection&lt;ID&gt; createShiftAssignments(Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L439">		return createShiftAssignments(null, shiftAssignments);</span>
	}

	public Collection&lt;ID&gt; createShiftAssignmentsWithLock(String lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L444">		return createSAWithLock(lockID, shiftAssignments);</span>
	}

	public Collection&lt;ID&gt; createShiftAssignments(ID lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L449">		return createSAWithLock(lockID, shiftAssignments);</span>
	}

	private Collection&lt;ID&gt; createSAWithLock(Object lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L454">		methodStart(&quot;createShiftAssignments&quot;, lockID, shiftAssignments);</span>

<span class="fc" id="L456">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
			/* perform what is necessary before the assignments are created */
<span class="fc" id="L459">			m_eventHandler.preCreateShiftAssignments(lockID, shiftAssignments);</span>

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="fc" id="L464">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForNewScheduleObjects(shiftAssignments);</span>
<span class="pc bpc" id="L465" title="1 of 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L466">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="fc" id="L469">			Collection&lt;ID&gt; listIDs = dao.createObjects(shiftAssignments);</span>

			/* perform what is necessary whenever shifts are created */
<span class="fc" id="L472">			m_eventHandler.postCreateShiftAssignments(shiftAssignments);</span>

<span class="fc" id="L474">			return listIDs;</span>
<span class="nc" id="L475">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L476">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L477">			throw e; // rethrow</span>
<span class="nc" id="L478">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L479">			handleException(e);</span>
<span class="nc" id="L480">			throw e;</span>
<span class="nc" id="L481">		} catch (MultiUserException e) {</span>
<span class="nc" id="L482">			handleException(e);</span>
<span class="nc" id="L483">			throw e;</span>
<span class="nc" id="L484">		} catch (Exception e) {</span>
<span class="nc" id="L485">			handleException(e);</span>
<span class="nc" id="L486">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L488">			dao.cleanUp();</span>
<span class="pc" id="L489">			methodFinish();</span>
		}
	}

	public ID createShiftEventAssignment(ShiftEventAssignment sea) throws BbmCreateException {
<span class="nc" id="L494">		methodStart(&quot;createShiftEventAssignment&quot;, sea);</span>
<span class="nc" id="L495">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO(new Jdmo());</span>
		try {
<span class="nc" id="L497">			return dao.createObject(sea);</span>
<span class="nc" id="L498">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L499">			handleException(e);</span>
<span class="nc" id="L500">			throw e;</span>
		} finally {
<span class="nc" id="L502">			dao.cleanUp();</span>
<span class="nc" id="L503">			methodFinish();</span>
		}
	}

	/**
	 * This method should be called when a stored procedure is to be called that
	 * first selects shift assignments that fall within the sp date range
	 * selection but having null spids. Such shift assignments are then updated
	 * @param sid scheduling period selected whose id needs to be linked to shift assignments that
	 *        fall in the sp date range and having null sp id
	 */
	public void linkShiftAssignmentsToSchedulingPeriod(ID sid) throws JdmoException {
<span class="fc" id="L515">		methodStart(&quot;linkShiftAssignmentsToSchedulingPeriod&quot;, sid);</span>
<span class="fc" id="L516">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L518">			JdmoQuery query = jdmo.createQuery(&quot;LINKSPTOSHIFTASSIGNMENTS&quot;, Jdmo.STORPROC_QUERY_NORS);</span>
<span class="fc" id="L519">			query.setParID(1, sid);</span>
<span class="fc" id="L520">			jdmo.execute(query);</span>
<span class="nc" id="L521">		} catch (JdmoException e) {</span>
<span class="nc" id="L522">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L523">			throw e;</span>
		} finally {
<span class="pc" id="L525">			jdmo.cleanUp();</span>
<span class="pc" id="L526">			methodFinish();</span>
<span class="fc" id="L527">		}</span>
<span class="fc" id="L528">	}</span>

	public void updateShiftAssignment(ShiftAssignment shiftAssignment)
			throws BbmScheduleConflictException, BbmUpdateException, BbmObjectNotFoundException, MultiUserException {
<span class="fc" id="L532">		methodStart(&quot;updateShiftAssignment&quot;, shiftAssignment);</span>

<span class="fc" id="L534">		shiftAssignment.processBeforeUpdate();</span>

<span class="fc" id="L536">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
			/* save the object before the update */
<span class="fc" id="L539">			Event oldEvent = dao.getObjectByID(shiftAssignment.getID());</span>

			/* perform what is necessary before an event gets updated */
<span class="fc" id="L542">			m_eventHandler.preUpdateEvent(null, oldEvent, shiftAssignment);</span>
<span class="fc" id="L543">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForUpdatedScheduleObject(shiftAssignment);</span>
<span class="pc bpc" id="L544" title="1 of 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L545">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="fc" id="L548">			dao.updateObject(shiftAssignment);</span>

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="fc" id="L553">			shiftAssignment = dao.getObjectByID(shiftAssignment.getID());</span>
<span class="fc" id="L554">			shiftAssignment.checkIsValid();</span>

			/* perform what is necessary whenever an event gets updated */
<span class="fc" id="L557">			m_eventHandler.postUpdateEvent(null, oldEvent, shiftAssignment);</span>
<span class="nc" id="L558">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L559">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L560">			throw e; // just rethrow</span>
<span class="nc" id="L561">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L562">			handleException(e);</span>
<span class="nc" id="L563">			throw e;</span>
<span class="nc" id="L564">		} catch (MultiUserException e) {</span>
<span class="nc" id="L565">			handleException(e);</span>
<span class="nc" id="L566">			throw e;</span>
<span class="nc" id="L567">		} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L568">			handleException(e);</span>
<span class="nc" id="L569">			throw e;</span>
<span class="nc" id="L570">		} catch (Exception e) {</span>
<span class="nc" id="L571">			handleException(e);</span>
<span class="nc" id="L572">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc bpc" id="L574" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L575">				dao.cleanUp();</span>
			}
<span class="pc" id="L577">			methodFinish();</span>
<span class="fc" id="L578">		}</span>
<span class="fc" id="L579">	}</span>

	public void updateShiftEventAssignment(ShiftEventAssignment sea) throws BbmUpdateException, MultiUserException {
<span class="nc" id="L582">		methodStart(&quot;updateShiftEventAssignment&quot;, sea);</span>
<span class="nc" id="L583">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>

		try {
<span class="nc" id="L586">			dao.updateObject(sea);</span>
<span class="nc" id="L587">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L588">			handleException(e);</span>
<span class="nc" id="L589">			throw e;</span>
<span class="nc" id="L590">		} catch (MultiUserException e) {</span>
<span class="nc" id="L591">			handleException(e);</span>
<span class="nc" id="L592">			throw e;</span>
		} finally {
<span class="nc" id="L594">			dao.cleanUp();</span>
<span class="nc" id="L595">			methodFinish();</span>
<span class="nc" id="L596">		}</span>
<span class="nc" id="L597">	}</span>

	public void deleteShiftEventAssignments(Collection&lt;ID&gt; shiftEventAssignmentIDs) throws BbmRemoveException {
<span class="nc" id="L600">		methodStart(&quot;deleteShiftEventAssignments&quot;, shiftEventAssignmentIDs);</span>

<span class="nc" id="L602">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>

		try {
<span class="nc" id="L605">			dao.deleteObjects(shiftEventAssignmentIDs);</span>
<span class="nc" id="L606">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L607">			handleException(e);</span>
<span class="nc" id="L608">			throw e;</span>
		} finally {
<span class="nc" id="L610">			dao.cleanUp();</span>
<span class="nc" id="L611">			methodFinish();</span>
<span class="nc" id="L612">		}</span>
<span class="nc" id="L613">	}</span>

	public void deleteShiftAssignments(Collection&lt;ID&gt; shiftAssignmentIDs) throws MultiUserException, BbmRemoveException {
<span class="fc" id="L616">		deleteSAWithLock(null, shiftAssignmentIDs);</span>
<span class="fc" id="L617">	}</span>

	public void deleteShiftAssignmentsWithLock(String lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L621">		deleteSAWithLock(lockID, shiftAssignmentIDs);</span>
<span class="nc" id="L622">	}</span>

	public void deleteShiftAssignments(ID lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L626">		deleteSAWithLock(lockID, shiftAssignmentIDs);</span>
<span class="nc" id="L627">	}</span>

	private void deleteSAWithLock(Object lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="fc" id="L631">		methodStart(&quot;deleteShiftAssignments&quot;, lockID, shiftAssignmentIDs);</span>

<span class="fc" id="L633">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="fc" id="L635">			Collection&lt;ShiftAssignment&gt; listEvents = dao.getObjectsByIDs(shiftAssignmentIDs);</span>

			/* perform what is necessary before events are deleted */
<span class="fc" id="L638">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* delete the shift assignments */
<span class="fc" id="L641">			dao.deleteObjects(shiftAssignmentIDs);</span>

			/* perform what is necessary whenever events are deleted */
<span class="fc" id="L644">			m_eventHandler.postDeleteEvents(listEvents);</span>

<span class="nc" id="L646">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L647">			handleException(e);</span>
<span class="nc" id="L648">			throw e;</span>
<span class="nc" id="L649">		} catch (MultiUserException e) {</span>
<span class="nc" id="L650">			handleException(e);</span>
<span class="nc" id="L651">			throw e;</span>
<span class="nc" id="L652">		} catch (Exception e) {</span>
<span class="nc" id="L653">			handleException(e);</span>
<span class="nc" id="L654">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="pc bpc" id="L656" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L657">				dao.cleanUp();</span>
			}
<span class="pc" id="L659">			methodFinish();</span>
<span class="fc" id="L660">		}</span>
<span class="fc" id="L661">	}</span>

	public void deleteShiftAssignmentsWithLockString(String lockID, Collection&lt;ID&gt; workResourceIDs, Date startTime,
			Date endTime, ID campaignID, boolean unlockedOnly) throws MultiUserException, BbmRemoveException {
		// delete by start time only
<span class="fc" id="L666">		deleteShiftAssignments(lockID, workResourceIDs, startTime, endTime, campaignID, unlockedOnly, true);</span>
<span class="fc" id="L667">	}</span>

	private void deleteShiftAssignments(String lockID, Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime,
			ID spID, boolean unlockedOnly, boolean byStartTime) throws MultiUserException, BbmRemoveException {
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">		methodStart(&quot;deleteShiftAssignmentsWithLockString&quot;, new Object[] { lockID, workResourceIDs, startTime, endTime,</span>
				spID, unlockedOnly ? Boolean.TRUE : Boolean.FALSE });
<span class="fc" id="L673">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
<span class="fc" id="L674">		Collection&lt;ShiftAssignment&gt; shifts = null;</span>
		try {
<span class="pc bpc" id="L676" title="1 of 2 branches missed.">			if (spID != null) {</span>
				// to schedule a SP, FS will call this API with 3 weeks range to
				// cover
				// the events crossing this SP, but we should not lock all the
				// events
				// in 3 weeks. here we will find the events in this SP and only
				// locks those
				// - silk 91697

				// get all the shift assignment in this SP
<span class="fc" id="L686">				shifts = dao.getShiftAssignmentInSP(spID, workResourceIDs, startTime, endTime);</span>
				// call preDelete to lock.
<span class="fc" id="L688">				m_eventHandler.preDeleteEvents(lockID, shifts);</span>

				// before delete, get the shifts will be deleted, will use them
				// to generate audit record
<span class="fc" id="L692">				shifts = dao.getShiftAssignmentInSP(spID, workResourceIDs, startTime, endTime, unlockedOnly);</span>
			} else {
				/* perform what is necessary before a schedule gets cleared */
<span class="nc" id="L695">				m_eventHandler.preClearSchedule(lockID, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L696">				Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; list = dao.getEventsForWorkResources(workResourceIDs, startTime,</span>
						endTime);
<span class="nc" id="L698">				shifts = ScheduleDAOUtil.getUniqueEvents(list);</span>
			}

<span class="fc" id="L701">			dao.deleteEventsForWorkResources(workResourceIDs, startTime, endTime, spID, unlockedOnly, byStartTime);</span>

			/* perform what is necessary whenever a schedule gets cleared */
<span class="fc" id="L704">			m_eventHandler.postClearSchedule(workResourceIDs, startTime, endTime, unlockedOnly, shifts);</span>
<span class="nc" id="L705">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L706">			handleException(e);</span>
<span class="nc" id="L707">			throw e;</span>
<span class="nc" id="L708">		} catch (MultiUserException e) {</span>
<span class="nc" id="L709">			handleException(e);</span>
<span class="nc" id="L710">			throw e;</span>
<span class="nc" id="L711">		} catch (Exception e) {</span>
<span class="nc" id="L712">			handleException(e);</span>
<span class="nc" id="L713">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="pc" id="L715">			dao.cleanUp();</span>
<span class="pc" id="L716">			methodFinish();</span>
<span class="fc" id="L717">		}</span>
<span class="fc" id="L718">	}</span>

	public void deleteShiftAssignments(Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime, ID campaignID,
			boolean unlockedOnly) throws MultiUserException, BbmRemoveException {
		// delete by start time only
<span class="nc" id="L723">		deleteShiftAssignments(null, workResourceIDs, startTime, endTime, campaignID, unlockedOnly, true);</span>
<span class="nc" id="L724">	}</span>

	public ShiftAssignment getShiftAssignmentByID(ID shiftAssignmentID) throws BbmFinderException {
<span class="fc" id="L727">		methodStart(&quot;getShiftAssignmentByID&quot;, shiftAssignmentID);</span>

<span class="fc" id="L729">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="fc" id="L731">			return dao.getObjectByID(shiftAssignmentID);</span>
<span class="nc" id="L732">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L734">			throw e;</span>
<span class="nc" id="L735">		} catch (Exception e) {</span>
<span class="nc" id="L736">			handleException(e);</span>
<span class="nc" id="L737">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L739">			dao.cleanUp();</span>
<span class="pc" id="L740">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftAssignment&gt; getShiftAssignmentsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc" id="L745">		methodStart(&quot;getShiftAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L747">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L749">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L750">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L751">			handleException(e);</span>
<span class="nc" id="L752">			throw e;</span>
		} finally {
<span class="nc" id="L754">			dao.cleanUp();</span>
<span class="nc" id="L755">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEventAssignment&gt; getShiftEventAssignmentsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc" id="L760">		methodStart(&quot;getShiftEventAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L762">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>
		try {
<span class="nc" id="L764">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L765">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L766">			handleException(e);</span>
<span class="nc" id="L767">			throw e;</span>
		} finally {
<span class="nc" id="L769">			dao.cleanUp();</span>
<span class="nc" id="L770">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftAssignment&gt; getAllShiftAssignments() throws BbmFinderException {
<span class="nc" id="L775">		methodStart(&quot;getAllShiftAssignments&quot;);</span>

<span class="nc" id="L777">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L779">			return dao.getAllObjects();</span>
<span class="nc" id="L780">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L781">			handleException(e);</span>
<span class="nc" id="L782">			throw e;</span>
		} finally {
<span class="nc" id="L784">			dao.cleanUp();</span>
<span class="nc" id="L785">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEventAssignment&gt; getAllShiftEventAssignments() throws BbmFinderException {
<span class="nc" id="L790">		methodStart(&quot;getAllShiftEventAssignments&quot;);</span>

<span class="nc" id="L792">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>
		try {
<span class="nc" id="L794">			return dao.getAllObjects();</span>
<span class="nc" id="L795">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L796">			handleException(e);</span>
<span class="nc" id="L797">			throw e;</span>
		} finally {
<span class="nc" id="L799">			dao.cleanUp();</span>
<span class="nc" id="L800">			methodFinish();</span>
		}
	}

	public ShiftEventAssignment getShiftEventAssignmentById(ID seaId) throws BbmFinderException {
<span class="nc" id="L805">		methodStart(&quot;getShiftEventAssignmentById&quot;, seaId);</span>

<span class="nc" id="L807">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO(new Jdmo());</span>
		try {
<span class="nc" id="L809">			return dao.getObjectByID(seaId);</span>
<span class="nc" id="L810">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L811">			handleException(e);</span>
<span class="nc" id="L812">			throw e;</span>
		} finally {
<span class="nc" id="L814">			dao.cleanUp();</span>
<span class="nc" id="L815">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, ShiftAssignment&gt; getLastShiftAssignments(Collection&lt;ID&gt; workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L821">		methodStart(&quot;getLastShiftAssignments&quot;, workResourceIDs);</span>

<span class="nc" id="L823">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L825">			return dao.getLastShiftAssignments(workResourceIDs);</span>
<span class="nc" id="L826">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L828">			throw e;</span>
<span class="nc" id="L829">		} catch (Exception e) {</span>
<span class="nc" id="L830">			handleException(e);</span>
<span class="nc" id="L831">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L833">			dao.cleanUp();</span>
<span class="nc" id="L834">			methodFinish();</span>
		}
	}

	public ShiftAssignment getPublishedShiftAssignmentByID(ID shiftAssignmentID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L840">		methodStart(&quot;getPublishedShiftAssignmentByID&quot;, shiftAssignmentID);</span>

<span class="nc" id="L842">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L844">			return dao.getObjectByID(shiftAssignmentID);</span>
<span class="nc" id="L845">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L847">			throw e;</span>
<span class="nc" id="L848">		} catch (Exception e) {</span>
<span class="nc" id="L849">			handleException(e);</span>
<span class="nc" id="L850">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L852">			dao.cleanUp();</span>
<span class="nc" id="L853">			methodFinish();</span>
		}
	}

	public List&lt;ShiftAssignment&gt; getPublishedShiftAssignmentByIDs(List&lt;ID&gt; shiftAssignmentIds)
			throws BbmFinderException {
<span class="nc" id="L859">		methodStart(&quot;getShiftAssignmentsInSP&quot;, shiftAssignmentIds);</span>
<span class="nc" id="L860">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L862">			return dao.getPublishedShiftAssignmentByIDs(shiftAssignmentIds);</span>
<span class="nc" id="L863">		} catch (Exception e) {</span>
<span class="nc" id="L864">			handleException(e);</span>
<span class="nc" id="L865">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L867">			dao.cleanUp();</span>
<span class="nc" id="L868">			methodFinish();</span>
		}
	}

	public List&lt;ShiftAssignment&gt; getUnpublishedShiftAssignmentByIDs(List&lt;ID&gt; shiftAssignmentIds)
			throws BbmFinderException {
<span class="nc" id="L874">		methodStart(&quot;getUnpublishedShiftAssignmentByIDs&quot;, shiftAssignmentIds);</span>
<span class="nc" id="L875">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L877">			return dao.getShiftAssignmentByIDs(shiftAssignmentIds);</span>
<span class="nc" id="L878">		} catch (Exception e) {</span>
<span class="nc" id="L879">			handleException(e);</span>
<span class="nc" id="L880">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L882">			dao.cleanUp();</span>
<span class="nc" id="L883">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, ShiftAssignment&gt; getLastPublishedShiftAssignments(Collection&lt;ID&gt; workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="fc" id="L889">		methodStart(&quot;getLastPublishedShiftAssignments&quot;, workResourceIDs);</span>

<span class="fc" id="L891">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="fc" id="L893">			return dao.getLastShiftAssignments(workResourceIDs);</span>
<span class="nc" id="L894">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L896">			throw e;</span>
<span class="nc" id="L897">		} catch (Exception e) {</span>
<span class="nc" id="L898">			handleException(e);</span>
<span class="nc" id="L899">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L901">			dao.cleanUp();</span>
<span class="pc" id="L902">			methodFinish();</span>
		}
	}

	public ID createCalendarEventAssignment(CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L908">		return createCalendarEventAssignment(null, event);</span>
	}

	public ID createCalendarEventAssignmentWithLock(String lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L913">		return createCEAWithLock(lockID, event);</span>
	}

	public ID createCalendarEventAssignment(ID lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L918">		return createCEAWithLock(lockID, event);</span>
	}

	public Collection createCalendarEventAssignments(String lockID, Collection events)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L923">		return createCEAsWithLock(lockID, events);</span>
	}

	private ID createCEAWithLock(Object lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L928">		return createCEAsWithLock(lockID, Arrays.asList(event)).iterator().next();</span>
	}

	private Collection&lt;ID&gt; createCEAsWithLock(Object lockID, Collection&lt;CalendarEventAssignment&gt; events)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L933">		methodStart(&quot;createCalendarEventAssignmentWithLock&quot;, lockID, events);</span>

<span class="fc" id="L935">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
			/* perform what is necessary before a new event gets created */
<span class="fc" id="L938">			m_eventHandler.preCreateEvents(lockID, events);</span>

			/** see if there were any conflicts as a result of this operation */
			// === do not do conflict checking if creating in batch ===
<span class="pc bpc" id="L942" title="2 of 4 branches missed.">			if (events != null &amp;&amp; events.size() &gt; 0) {</span>
<span class="pc bpc" id="L943" title="1 of 2 branches missed.">				if (events.size() == 1) {</span>
<span class="fc" id="L944">					Collection listConflicts = dao.getConflictsForNewScheduleObjects(events);</span>
<span class="pc bpc" id="L945" title="1 of 2 branches missed.">					if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L946">						throw new BbmScheduleConflictException(listConflicts);</span>
					}
<span class="fc" id="L948">				} else {</span>
					// create a list of time off events from scheduler,
					// so far no other components to create a list of any type
					// of events in batch.
					// QA94194: schedule sometimes create dup time off events,
					// so far it is not reproducible in house
					// but it happened a lot in customer production mode. here
					// we provide an adhoc-solution, e.g. ignore creating
					// dup time off event for the time off events creating from
					// scheduler.
<span class="nc" id="L958">					ArrayList sortedList = new ArrayList(events);</span>
<span class="nc" id="L959">					Collections.sort(sortedList);</span>
<span class="nc" id="L960">					Date timeRangeStart = ((Event) (sortedList.get(0))).getStartTime();</span>
<span class="nc" id="L961">					Date timeRangeEnd = ((Event) (sortedList.get(sortedList.size() - 1))).getEndTime();</span>
<span class="nc" id="L962">					HashSet uniqueIDs = new HashSet(events.size());</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">					for (Iterator i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L964">						uniqueIDs.addAll(((Event) i.next()).getWorkResourceIDs());</span>
					}
<span class="nc" id="L966">					ArrayList workResourceIDs = new ArrayList(uniqueIDs);</span>
<span class="nc" id="L967">					Collection existingEventsList = getEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF,</span>
							workResourceIDs, timeRangeStart, timeRangeEnd);
<span class="nc" id="L969">					Collection creatingEventsList = ScheduleDAOUtil.groupEventsByWorkResources(sortedList,</span>
							workResourceIDs);
<span class="nc" id="L971">					Iterator iCreate = creatingEventsList.iterator();</span>
<span class="nc" id="L972">					Iterator iExist = existingEventsList.iterator();</span>
<span class="nc" id="L973">					Collection createEvents = null;</span>
<span class="nc" id="L974">					Collection existEvents = null;</span>
<span class="nc" id="L975">					Event eventToCreate = null;</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">					for (; iExist.hasNext();) {</span>
<span class="nc" id="L977">						createEvents = (Collection) iCreate.next();</span>
<span class="nc" id="L978">						existEvents = (Collection) iExist.next();</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">						if (existEvents != null &amp;&amp; !existEvents.isEmpty()) {</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">							for (Iterator iEvent = createEvents.iterator(); iEvent.hasNext();) {</span>
<span class="nc" id="L981">								eventToCreate = (Event) iEvent.next();</span>
<span class="nc bnc" id="L982" title="All 2 branches missed.">								if (eventToCreate.getEventType() == Event.EVENT_TYPE_TIME_OFF</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">										&amp;&amp; isEventInList(eventToCreate, existEvents)) {</span>
<span class="nc" id="L984">									events.remove(eventToCreate);</span>
<span class="nc" id="L985">									m_cat.info(&quot;***************** Found Dup Time Off Event: &quot; + eventToCreate);</span>
<span class="nc" id="L986">									m_cat.info(&quot;***************** Existing events are: &quot; + existEvents);</span>
								}
							}
						}
					}
				}
			}

<span class="fc" id="L994">			Collection&lt;ID&gt; ids = dao.createObjects(events);</span>

			/* perform what is necessary after a new event gets created */
<span class="fc" id="L997">			m_eventHandler.postCreateEvents(events);</span>

<span class="fc" id="L999">			return ids;</span>
<span class="nc" id="L1000">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1001">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1002">			throw e; // just rethrow</span>
<span class="nc" id="L1003">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1004">			handleException(e);</span>
<span class="nc" id="L1005">			throw e;</span>
<span class="nc" id="L1006">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1007">			handleException(e);</span>
<span class="nc" id="L1008">			throw e;</span>
<span class="nc" id="L1009">		} catch (Exception e) {</span>
<span class="nc" id="L1010">			handleException(e);</span>
<span class="nc" id="L1011">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc bpc" id="L1013" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L1014">				dao.cleanUp();</span>
			}
<span class="pc" id="L1016">			methodFinish();</span>
		}
	}

	private boolean isEventInList(Event event, Collection eventList) {
<span class="nc" id="L1021">		boolean isInList = false;</span>
<span class="nc" id="L1022">		Event eventInList = null;</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">		for (Iterator i = eventList.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1024">			eventInList = (Event) i.next();</span>
<span class="nc bnc" id="L1025" title="All 2 branches missed.">			if (event.getEventType() == eventInList.getEventType()</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">					&amp;&amp; event.getActivityID().equals(eventInList.getActivityID())</span>
<span class="nc bnc" id="L1027" title="All 2 branches missed.">					&amp;&amp; event.getStartTime().equals(eventInList.getStartTime())) {</span>
<span class="nc" id="L1028">				return true;</span>
			}
		}

<span class="nc" id="L1032">		return isInList;</span>
	}

	public void updateCalendarEventAssignment(CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="fc" id="L1037">		updateCEAWithLock(null, event);</span>
<span class="fc" id="L1038">	}</span>

	public void updateCalendarEventAssignmentWithLock(String lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, BbmObjectNotFoundException, MultiUserException, BbmUpdateException {
<span class="nc" id="L1042">		updateCEAWithLock(lockID, event);</span>
<span class="nc" id="L1043">	}</span>

	public void updateCalendarEventAssignment(ID lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, BbmObjectNotFoundException, MultiUserException, BbmUpdateException {
<span class="nc" id="L1047">		updateCEAWithLock(lockID, event);</span>
<span class="nc" id="L1048">	}</span>

	private void updateCEAWithLock(Object lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="fc" id="L1052">		methodStart(&quot;updateCalendarEventAssignmentWithLock&quot;, lockID, event);</span>

<span class="fc" id="L1054">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L1056">			updateCEAWithLockInternal(lockID, event, dmo);</span>
<span class="nc" id="L1057">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1058">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1059">			throw e; // just rethrow</span>
<span class="nc" id="L1060">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1061">			handleException(e);</span>
<span class="nc" id="L1062">			throw e;</span>
<span class="nc" id="L1063">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1064">			handleException(e);</span>
<span class="nc" id="L1065">			throw e;</span>
<span class="nc" id="L1066">		} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L1067">			handleException(e);</span>
<span class="nc" id="L1068">			throw e;</span>
<span class="nc" id="L1069">		} catch (Exception e) {</span>
<span class="nc" id="L1070">			handleException(e);</span>
<span class="nc" id="L1071">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc" id="L1073">			dmo.cleanUp();</span>
<span class="pc" id="L1074">			methodFinish();</span>
<span class="fc" id="L1075">		}</span>
<span class="fc" id="L1076">	}</span>

	private void updateCEAWithLockInternal(Object lockID, CalendarEventAssignment event, Jdmo dmo) throws Exception {
<span class="fc" id="L1079">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
		// event is full update all the time.
		// to remove linked shift id, we have to make sure the value
		// is set to NullObject instead of null value.
		// however, whenever the calendar event is passed from applet, the
		// NullObject
		// value will be reset to null value. here we can fix it,
		// we should find better way later - angela
<span class="pc bpc" id="L1087" title="1 of 2 branches missed.">		if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="pc bpc" id="L1088" title="1 of 2 branches missed.">            if (event.getLinkedShiftAssignmentID() == null) {</span>
<span class="fc" id="L1089">                event.setFieldNull(CalendarEventAssignmentFields.SHIFTASSIGNMENTID);</span>
            }
        }

			/* save the object before the update */
<span class="fc" id="L1094">		CalendarEventAssignment oldEvent = dao.getObjectByID(event.getID());</span>

			/*
			 * perform what is necessary before an existing event gets updated
			 */
<span class="fc" id="L1099">		m_eventHandler.preUpdateEvent(lockID, oldEvent, event);</span>

		// the event object might only have updated attributes instead
		// of the whole picture. Here reset the org attendees list for
		// checking
		// schedule conflict
<span class="fc" id="L1105">		populateExistingAttendee(oldEvent, event);</span>
<span class="fc" id="L1106">		event.setOverlayPrecedence(oldEvent.getOverlayPrecedence());</span>

<span class="fc" id="L1108">		checkConflictForUpdateObject(dmo, event);</span>
<span class="fc" id="L1109">		dao.updateObject(event);</span>

		// QA 94787 - F&amp;S receives an error occurs inside publish schedule
<span class="fc" id="L1112">		ID tplID = event.getEventTemplateID();</span>
<span class="pc bpc" id="L1113" title="1 of 2 branches missed.">		if (tplID != null</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">                &amp;&amp; getCalendarEventTemplateTypeByID(tplID, dmo) == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>

            // this is an exception of recurring template
<span class="nc" id="L1117">            Collection&lt;ID&gt; createdWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1118">            Collection&lt;CalendarEventAttendee&gt; createdAttenddees = event</span>
<span class="nc" id="L1119">                    .getCreatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L1120" title="All 4 branches missed.">            if (createdAttenddees != null &amp;&amp; !createdAttenddees.isEmpty()) {</span>
<span class="nc bnc" id="L1121" title="All 2 branches missed.">                for (Iterator&lt;CalendarEventAttendee&gt; it = createdAttenddees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1122">                    createdWorkResources.add(it.next().getWorkResourceID());</span>
                }
            }

<span class="nc bnc" id="L1126" title="All 2 branches missed.">            if (!createdWorkResources.isEmpty()) {</span>
                // Update template exceptions
<span class="nc" id="L1128">                RecurringEventTemplateDAO tplDao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1129">                tplDao.deleteRecurringEventInstance(tplID, createdWorkResources, event.getStartTime());</span>
            }

<span class="nc" id="L1132">            Collection&lt;ID&gt; deleteWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1133">            Collection&lt;CalendarEventAttendee&gt; deletedAttendees = event</span>
<span class="nc" id="L1134">                    .getDeletedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L1135" title="All 4 branches missed.">            if (deletedAttendees != null &amp;&amp; !deletedAttendees.isEmpty()) {</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">                for (Iterator&lt;CalendarEventAttendee&gt; it = deletedAttendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1137">                    deleteWorkResources.add(it.next().getWorkResourceID());</span>
                }
            }

<span class="nc bnc" id="L1141" title="All 2 branches missed.">            if (!deleteWorkResources.isEmpty()) {</span>
                // Update template exceptions
<span class="nc" id="L1143">                RecurringEventTemplateDAO tplDao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1144">                RecurringEventTemplateBase recTemplate = tplDao.getObjectByID(tplID);</span>
<span class="nc" id="L1145">                tplDao.deleteRecurringEventException(recTemplate, deleteWorkResources, event.getStartTime());</span>
            }
        }
		// End #94787

		/** see if there were any conflicts as a result of this operation */
<span class="fc" id="L1151">		event = dao.getObjectByID(event.getID());</span>
<span class="fc" id="L1152">		event.checkIsValid();</span>

		/* perform what is necessary after an existing event gets updated */
<span class="fc" id="L1155">		m_eventHandler.postUpdateEvent(lockID, oldEvent, event);</span>
<span class="fc" id="L1156">	}</span>

	public void deleteCalendarEventAssignmentsWithLock(String lockID, Collection&lt;ID&gt; eventAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="fc" id="L1160">		methodStart(&quot;deleteCalendarEventAssignmentsWithLock&quot;, lockID, eventAssignmentIDs);</span>

<span class="fc" id="L1162">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(new Jdmo());</span>
		try {
			/*
			 * save the the events before deletion, we'll need them for
			 * notifications
			 */
<span class="fc" id="L1168">			Collection&lt;CalendarEventAssignment&gt; listEvents = dao.getObjectsByIDs(eventAssignmentIDs);</span>

			/* perform what is necessary before a bunch of events get deleted */
<span class="fc" id="L1171">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* perform the delete */
<span class="fc" id="L1174">			dao.deleteObjects(eventAssignmentIDs);</span>

			/* perform what is necessary after a bunch of events get deleted */
<span class="fc" id="L1177">			m_eventHandler.postDeleteEvents(listEvents);</span>
<span class="nc" id="L1178">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1179">			handleException(e);</span>
<span class="nc" id="L1180">			throw e;</span>
<span class="nc" id="L1181">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1182">			handleException(e);</span>
<span class="nc" id="L1183">			throw e;</span>
<span class="nc" id="L1184">		} catch (Exception e) {</span>
<span class="nc" id="L1185">			handleException(e);</span>
<span class="nc" id="L1186">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="pc" id="L1188">			dao.cleanUp();</span>
<span class="pc" id="L1189">			methodFinish();</span>
<span class="fc" id="L1190">		}</span>
<span class="fc" id="L1191">	}</span>

	// Tample add for QA 85638:START
	// This method is used to delete CalendarEvenAttendee first.
	// CalendarEventAssignment is only deleted when no workresourceid linked to
	// it
	public void deletePartialCalendarEventAssignments(String lockID, Collection&lt;ID&gt; eventAssignmentIDs,
			Collection&lt;ID&gt; idsExistingInAttendee) throws MultiUserException, BbmRemoveException {
<span class="nc" id="L1199">		methodStart(&quot;deletePartialCalendarEventAssignments&quot;, lockID, eventAssignmentIDs);</span>

<span class="nc" id="L1201">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(new Jdmo());</span>
		try {
			/*
			 * save the the events before deletion, we'll need them for
			 * notifications
			 */
<span class="nc" id="L1207">			Collection&lt;CalendarEventAssignment&gt; listEvents = dao.getObjectsByIDs(eventAssignmentIDs);</span>

			/* perform what is necessary before a bunch of events get deleted */
<span class="nc" id="L1210">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* perform the delete */
<span class="nc" id="L1213">			dao.deleteObjects(eventAssignmentIDs, idsExistingInAttendee);</span>

			/* perform what is necessary after a bunch of events get deleted */
<span class="nc" id="L1216">			m_eventHandler.postDeleteEvents(listEvents);</span>
<span class="nc" id="L1217">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L1218">			handleException(e);</span>
<span class="nc" id="L1219">			throw e;</span>
<span class="nc" id="L1220">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1221">			handleException(e);</span>
<span class="nc" id="L1222">			throw e;</span>
<span class="nc" id="L1223">		} catch (Exception e) {</span>
<span class="nc" id="L1224">			handleException(e);</span>
<span class="nc" id="L1225">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L1227">			dao.cleanUp();</span>
<span class="nc" id="L1228">			methodFinish();</span>
<span class="nc" id="L1229">		}</span>
<span class="nc" id="L1230">	}</span>

	// Tample add for QA 85638:END

	public void deleteCalendarEventAssignments(Collection&lt;ID&gt; eventAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="fc" id="L1236">		deleteCalendarEventAssignmentsWithLock(null, eventAssignmentIDs);</span>
<span class="fc" id="L1237">	}</span>

	public CalendarEventAssignment getCalendarEventAssignmentByID(ID eventID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="fc" id="L1241">		methodStart(&quot;getCalendarEventAssignmentByID&quot;, eventID);</span>

<span class="fc" id="L1243">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="fc" id="L1245">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L1246">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L1248">			throw e;</span>
<span class="nc" id="L1249">		} catch (Exception e) {</span>
<span class="nc" id="L1250">			handleException(e);</span>
<span class="nc" id="L1251">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1253">			dao.cleanUp();</span>
<span class="pc" id="L1254">			methodFinish();</span>
		}
	}

	public Collection&lt;CalendarEventAssignment&gt; getCalendarEventAssignmentsByIDs(Collection&lt;ID&gt; ids) throws
			BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1260">		methodStart(&quot;getCalendarEventAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L1262">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L1264">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L1265">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1266">			handleException(e);</span>
<span class="nc" id="L1267">			throw e;</span>
		} finally {
<span class="nc" id="L1269">			dao.cleanUp();</span>
<span class="nc" id="L1270">			methodFinish();</span>
		}
	}

	public Collection&lt;CalendarEventAssignment&gt; getAllCalendarEventAssignments() throws BbmObjectNotFoundException,
			BbmFinderException {
<span class="nc" id="L1276">		methodStart(&quot;getAllCalendarEventAssignments&quot;);</span>

<span class="nc" id="L1278">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L1280">			return dao.getAllObjects();</span>
<span class="nc" id="L1281">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1282">			handleException(e);</span>
<span class="nc" id="L1283">			throw e;</span>
		} finally {
<span class="nc" id="L1285">			dao.cleanUp();</span>
<span class="nc" id="L1286">			methodFinish();</span>
		}
	}

	public CalendarEventAssignment getPublishedCalendarEventAssignmentByID(ID eventID) throws BbmFinderException {
<span class="nc" id="L1291">		methodStart(&quot;getPublishedCalendarEventAssignmentByID&quot;, eventID);</span>

<span class="nc" id="L1293">		CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO();</span>
		try {
<span class="nc" id="L1295">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L1296">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L1298">			throw e;</span>
<span class="nc" id="L1299">		} catch (Exception e) {</span>
<span class="nc" id="L1300">			handleException(e);</span>
<span class="nc" id="L1301">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1303">			dao.cleanUp();</span>
<span class="nc" id="L1304">			methodFinish();</span>
		}
	}

	public ID createEventTemplateWithInstances(CalendarEventTemplate eventTemplate,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmCreateException {
<span class="fc" id="L1311">		methodStart(&quot;createEventTemplateWithInstances&quot;, eventTemplate, conflictResolutions);</span>

<span class="fc" id="L1313">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L1314">		AggEventTemplateDAO dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">			if (dao == null) {</span>
				/* should really never happen */
<span class="nc" id="L1319">				throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/*
			 * perform what is necessary before a new calendar event template
			 * gets created
			 */
<span class="fc" id="L1326">			m_eventHandler.preCreateEventTemplate(eventTemplate);</span>

<span class="fc" id="L1328">			ValueObjectBase valueObj = (ValueObjectBase) eventTemplate;</span>

			/*
			 * see if there were any conflicts created as a result of this
			 * operation
			 */
<span class="fc" id="L1334">			ScheduleConflictChecker checker = (ScheduleConflictChecker) dao;</span>
<span class="fc" id="L1335">			Collection&lt;BbmScheduleConflict&gt; listConflicts = checker.getConflictsForNewScheduleObject(valueObj);</span>

			// if has conflicts and no resolution, throws exceptions without
			// creating object
<span class="fc" id="L1339">			boolean isClass = false;</span>
<span class="pc bpc" id="L1340" title="1 of 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING) {</span>
<span class="fc" id="L1341">				isClass = ((FloatingEventTemplate) eventTemplate).isClass();</span>
			}

<span class="fc" id="L1344">			boolean needToResolve = true;</span>

<span class="pc bpc" id="L1346" title="1 of 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L1347" title="All 2 branches missed.">				if (conflictResolutions == null</span>
<span class="nc bnc" id="L1348" title="All 2 branches missed.">						|| !ScheduleDAOUtil.areConflictsResolvable(listConflicts, conflictResolutions)) {</span>
<span class="nc bnc" id="L1349" title="All 2 branches missed.">					if (isClass) {</span>
<span class="nc" id="L1350">						((FloatingEventTemplate) eventTemplate).setConflicts(listConflicts);</span>
<span class="nc" id="L1351">						needToResolve = false;</span>
					} else {
<span class="nc" id="L1353">						throw new BbmScheduleConflictException(listConflicts);</span>
					}
				}
			}

			// in case the resolution is to remove one recurring instance
			// need template id to create recurring exception
<span class="fc" id="L1360">			ID templateID = dao.createObject(valueObj);</span>
<span class="fc" id="L1361">			valueObj.setID(templateID);</span>
			// resolve the conflictions
<span class="pc bpc" id="L1363" title="3 of 4 branches missed.">			if (!listConflicts.isEmpty() &amp;&amp; needToResolve) {</span>
<span class="nc" id="L1364">				setNewlyCreatedTemplateID(templateID, listConflicts);</span>
<span class="nc" id="L1365">				ScheduleDAOUtil.resolveConflicts((ScheduleAccessManagerEJB) this, listConflicts, conflictResolutions);</span>
			}

			/*
			 * perform what is necessary after a new calendar event template
			 * gets created
			 */
<span class="pc bpc" id="L1372" title="1 of 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING</span>
<span class="pc bpc" id="L1373" title="1 of 2 branches missed.">					|| eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L1374">				m_eventHandler.postCreateEventTemplate(eventTemplate);</span>
			} else {
				// for floating event template. we will create audit on real
				// created event.
<span class="fc" id="L1378">				List&lt;ID&gt; idTemp = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L1379">				idTemp.add(templateID);</span>
<span class="fc" id="L1380">				Collection&lt;CalendarEventAssignment&gt; events = getCalendarEventAssignmentsForCalendarEventTemplate(idTemp)</span>
<span class="fc" id="L1381">						.iterator().next();</span>
<span class="pc bpc" id="L1382" title="1 of 2 branches missed.">				if (events != null) {</span>
<span class="fc bfc" id="L1383" title="All 2 branches covered.">					for (Iterator&lt;CalendarEventAssignment&gt; i = events.iterator(); i.hasNext();) {</span>
<span class="fc" id="L1384">						m_eventHandler.postCreateEvent(i.next());</span>
					}
				}
			}

<span class="fc" id="L1389">			return templateID;</span>
<span class="nc" id="L1390">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1391">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1392">			throw e; // just rethrow</span>
<span class="nc" id="L1393">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1394">			handleException(e);</span>
<span class="nc" id="L1395">			throw e;</span>
<span class="nc" id="L1396">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1397">			handleException(e);</span>
<span class="nc" id="L1398">			throw e;</span>
<span class="nc" id="L1399">		} catch (Exception e) {</span>
<span class="nc" id="L1400">			handleException(e);</span>
<span class="nc" id="L1401">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L1403">			dmo.cleanUp();</span>
<span class="pc" id="L1404">			methodFinish();</span>
		}
	}

	/**
	 * This method is specifically defined for
	 * createEventTemplateWithInstances(). the template id is only neccessory
	 * for rec template /shift or event conflict only.
	 *
	 * @param templateID
	 * @param conflicts
	 */
	private void setNewlyCreatedTemplateID(ID templateID, Collection&lt;BbmScheduleConflict&gt; conflicts) {
<span class="nc" id="L1417">		BbmScheduleConflict conflict = null;</span>
<span class="nc" id="L1418">		RecurringEventTemplateBase recTemplate = null;</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">		for (Iterator&lt;BbmScheduleConflict&gt; i = conflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1420">			conflict = i.next();</span>
<span class="nc" id="L1421">			recTemplate = conflict.getRecurringTemplate();</span>
<span class="nc bnc" id="L1422" title="All 2 branches missed.">			if (recTemplate != null) {</span>
<span class="nc" id="L1423">				recTemplate.setID(templateID);</span>
			}
		}
<span class="nc" id="L1426">	}</span>

	public void deleteEventTemplateWithInstances(ID templateID) throws MultiUserException, BbmRemoveException {
<span class="nc" id="L1429">		methodStart(&quot;deleteCalendarEventTemplateWithInstances&quot;, templateID);</span>

<span class="nc" id="L1431">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1433">			AggEventTemplateDAO dao = getDAOByEventTemplateID(templateID, dmo);</span>
<span class="nc bnc" id="L1434" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1435">				throw new BbmRemoveException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/**
			 * save the template before blowing it away for notification
			 * purposes
			 */
<span class="nc" id="L1442">			CalendarEventTemplate savedTemplate = dao.getObjectByID(templateID);</span>

			// special handle floating exception for
			// recurringfloatingeventtemplate
<span class="nc bnc" id="L1446" title="All 2 branches missed.">			if (savedTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L1447">				FloatingEventTemplateDAO floatDAO = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L1448">				Collection&lt;FloatingEventTemplate&gt; floatExceptions = floatDAO</span>
<span class="nc" id="L1449">						.getObjects(floatDAO.getFieldInfo().getParentIDFieldName() + &quot;=&quot; + savedTemplate.getID());</span>
<span class="nc bnc" id="L1450" title="All 4 branches missed.">				if (floatExceptions != null &amp;&amp; !floatExceptions.isEmpty()) {</span>
<span class="nc" id="L1451">					List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;(floatExceptions.size());</span>
<span class="nc bnc" id="L1452" title="All 2 branches missed.">					for (Iterator&lt;FloatingEventTemplate&gt; i = floatExceptions.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1453">						ids.add(i.next().getID());</span>
					}
<span class="nc" id="L1455">					floatDAO.deleteObjects(ids);</span>
				}
			}

			/*
			 * perform what is necessary after a calendar event template gets
			 * deleted
			 */
<span class="nc" id="L1463">			m_eventHandler.preDeleteEventTemplate(savedTemplate);</span>

<span class="nc" id="L1465">			dao.deleteObject(templateID);</span>

			/*
			 * perform what is necessary whenever a new calendar event template
			 * gets deleted
			 */
<span class="nc" id="L1471">			m_eventHandler.postDeleteEventTemplate(savedTemplate);</span>
<span class="nc" id="L1472">		} catch (BbmObjectNotFoundException e) {</span>
			/* they're trying to delete a non-existant object - just ignore */
<span class="nc" id="L1474">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1475">			handleException(e);</span>
<span class="nc" id="L1476">			throw e;</span>
<span class="nc" id="L1477">		} catch (Exception e) {</span>
<span class="nc" id="L1478">			handleException(e);</span>
<span class="nc" id="L1479">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L1481">			dmo.cleanUp();</span>
<span class="nc" id="L1482">			methodFinish();</span>
<span class="nc" id="L1483">		}</span>
<span class="nc" id="L1484">	}</span>

	/**
	 * @deprecated
	 * @param eventTemplate
	 * @return
	 * @throws BbmFinderException
	 */
	@Deprecated
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForCalendarEventTemplate(CalendarEventTemplate eventTemplate)
			throws BbmFinderException {
<span class="pc bpc" id="L1495" title="1 of 2 branches missed.">		if (eventTemplate.getID() == null) {</span>
<span class="fc" id="L1496">			return getConflictsForNewCalendarEventTemplate(eventTemplate);</span>
		} else {
<span class="nc" id="L1498">			return getConflictsForUpdatedCalendarEventTemplate(eventTemplate);</span>
		}
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewCalendarEventTemplate(CalendarEventTemplate eventTemplate)
			throws BbmFinderException {
<span class="fc" id="L1504">		return getConflictsForCalendarEventTemplate(eventTemplate, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedCalendarEventTemplate(
			CalendarEventTemplate eventTemplate) throws BbmFinderException {
<span class="nc" id="L1509">		return getConflictsForCalendarEventTemplate(eventTemplate, false);</span>
	}

	private Collection&lt;BbmScheduleConflict&gt; getConflictsForCalendarEventTemplate(CalendarEventTemplate eventTemplate,
			boolean isForNewObject) throws BbmFinderException {
<span class="fc" id="L1514">		methodStart(&quot;getConflictsForCalendarEventTemplate&quot;, eventTemplate);</span>

<span class="fc" id="L1516">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L1517">		DAOBase dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="pc bpc" id="L1520" title="1 of 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1521">				throw new BbmFinderException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE, null);</span>
			}

<span class="fc" id="L1524">			ValueObjectAggEventTemplate newTemp = (ValueObjectAggEventTemplate) eventTemplate;</span>
<span class="pc bpc" id="L1525" title="1 of 2 branches missed.">			if (!isForNewObject) {</span>
<span class="nc" id="L1526">				CalendarEventTemplate oldTemplate = (CalendarEventTemplate) dao.getObjectByID(eventTemplate.getID());</span>
				// the template object might only have updated attributes
				// instead
				// of the whole picture. Here reset the org attendees list for
				// checking
				// schedule conflict
<span class="nc" id="L1532">				ValueObjectAggEventTemplate oldTemp = (ValueObjectAggEventTemplate) oldTemplate;</span>

<span class="nc" id="L1534">				populateExistingAttendee(oldTemp, newTemp);</span>
<span class="nc" id="L1535">				newTemp.setOverlayPrecedence(oldTemp.getOverlayPrecedence());</span>
			}

<span class="fc" id="L1538">			Collection&lt;BbmScheduleConflict&gt; listConflicts = null;</span>
<span class="pc bpc" id="L1539" title="1 of 2 branches missed.">			if (isForNewObject) {</span>
<span class="fc" id="L1540">				listConflicts = ((ScheduleConflictChecker) dao).getConflictsForNewScheduleObject(newTemp);</span>
			} else {
<span class="nc" id="L1542">				listConflicts = ((ScheduleConflictChecker) dao).getConflictsForUpdatedScheduleObject(newTemp);</span>
			}

<span class="fc" id="L1545">			return listConflicts;</span>
<span class="nc" id="L1546">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1547">			handleException(e);</span>
<span class="nc" id="L1548">			throw e;</span>
<span class="nc" id="L1549">		} catch (Exception e) {</span>
<span class="nc" id="L1550">			handleException(e);</span>
<span class="nc" id="L1551">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L1553">			dmo.cleanUp();</span>
<span class="pc" id="L1554">			methodFinish();</span>
		}
	}

	public CalendarEventTemplate getCalendarEventTemplateByID(ID templateID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="fc" id="L1560">		methodStart(&quot;getCalendarEventTemplateByID&quot;, templateID);</span>

<span class="fc" id="L1562">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L1564">			DAOBase dao = getDAOByEventTemplateID(templateID, dmo);</span>
<span class="pc bpc" id="L1565" title="1 of 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1566">				throw new BbmFinderException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE, null);</span>
			}
<span class="fc" id="L1568">			return (CalendarEventTemplate) dao.getObjectByID(templateID);</span>
<span class="nc" id="L1569">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1570">			handleException(e);</span>
<span class="nc" id="L1571">			throw e;</span>
		} finally {
<span class="pc" id="L1573">			dmo.cleanUp();</span>
<span class="pc" id="L1574">			methodFinish();</span>
		}
	}

	public Collection getCalendarEventTemplatesByIDs(Collection&lt;ID&gt; ctemplateIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1580">		methodStart(&quot;getCalendarEventTemplatesByIDs&quot;, ctemplateIDs);</span>

<span class="nc" id="L1582">		Jdmo dmo1 = new Jdmo();</span>
		try {

<span class="nc" id="L1585">			FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo1);</span>
<span class="nc" id="L1586">			Collection cTemplates = dao1.getObjectsByIDs(ctemplateIDs);</span>
<span class="nc" id="L1587">			RecurringEventTemplateDAO dao2 = new RecurringEventTemplateDAO(dmo1);</span>
<span class="nc" id="L1588">			Collection recEvTemplates = dao2.getObjectsByIDs(ctemplateIDs);</span>
<span class="nc" id="L1589">			cTemplates.addAll(recEvTemplates);</span>
<span class="nc" id="L1590">			return cTemplates;</span>
<span class="nc" id="L1591">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1592">			handleException(e);</span>
<span class="nc" id="L1593">			throw e;</span>
		} finally {
<span class="nc" id="L1595">			dmo1.cleanUp();</span>
<span class="nc" id="L1596">			methodFinish();</span>
		}
	}

	public void updateEventTemplateWithInstances(CalendarEventTemplate eventTemplate,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1603">		methodStart(&quot;updateEventTemplateWithInstances&quot;, eventTemplate, conflictResolutions);</span>

<span class="nc" id="L1605">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1606">		DAOBase dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="nc bnc" id="L1609" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1610">				throw new BbmUpdateException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/*
			 * save the old template before updating it, since we'll need it for
			 * notifications
			 */
<span class="nc" id="L1617">			CalendarEventTemplate oldTemplate = (CalendarEventTemplate) dao.getObjectByID(eventTemplate.getID());</span>

			/*
			 * perform what is necessary before an existing calendar event
			 * template gets updated
			 */
<span class="nc" id="L1623">			m_eventHandler.preUpdateEventTemplate(oldTemplate);</span>

			// the template object might only have updated attributes instead
			// of the whole picture. Here reset the org attendees list for
			// checking
			// schedule conflict
<span class="nc" id="L1629">			ValueObjectAggEventTemplate oldTemp = (ValueObjectAggEventTemplate) oldTemplate;</span>
<span class="nc" id="L1630">			ValueObjectAggEventTemplate newTemp = (ValueObjectAggEventTemplate) eventTemplate;</span>

			// Trung Nguyen QA 83594
			// copy child objects (Recurring Event Object) to new template in
			// order to exclude
			// the RECURRING EVENT when checking conflict
<span class="nc bnc" id="L1636" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>
<span class="nc" id="L1637">				Collection childObjectsOfOld = oldTemp.getChildObjects(RecurringEventTemplateFields.CHILD_EXCEPTION);</span>
<span class="nc bnc" id="L1638" title="All 2 branches missed.">				if (childObjectsOfOld != null) {</span>
<span class="nc bnc" id="L1639" title="All 2 branches missed.">					for (Iterator i = childObjectsOfOld.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1640">						newTemp.fillChildObject(RecurringEventTemplateFields.CHILD_EXCEPTION,</span>
<span class="nc" id="L1641">								(ValueObjectBase) i.next());</span>
					}
				}
			}
<span class="nc" id="L1645">			populateExistingAttendee(oldTemp, newTemp);</span>
<span class="nc" id="L1646">			newTemp.setOverlayPrecedence(oldTemp.getOverlayPrecedence());</span>

<span class="nc" id="L1648">			ScheduleConflictChecker checker = (ScheduleConflictChecker) dao;</span>
<span class="nc" id="L1649">			Collection listConflicts = checker.getConflictsForUpdatedScheduleObject(newTemp);</span>
<span class="nc bnc" id="L1650" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L1651" title="All 2 branches missed.">				if (conflictResolutions == null</span>
<span class="nc bnc" id="L1652" title="All 2 branches missed.">						|| !ScheduleDAOUtil.areConflictsResolvable(listConflicts, conflictResolutions)) {</span>
<span class="nc" id="L1653">					throw new BbmScheduleConflictException(listConflicts);</span>
				} else {
					// resolve the conflictions
<span class="nc" id="L1656">					ScheduleDAOUtil.resolveConflicts((ScheduleAccessManagerEJB) this, listConflicts, conflictResolutions);</span>
				}
			}

			// QA 91070 - check if the class name is already exist
<span class="nc bnc" id="L1661" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING) {</span>
<span class="nc" id="L1662">				FloatingEventTemplateDAO floatingEventTemplateDAO = (FloatingEventTemplateDAO) dao;</span>
<span class="nc" id="L1663">				floatingEventTemplateDAO.checkDuplcateClassName((FloatingEventTemplate) newTemp);</span>
			}

			/* now update */
<span class="nc" id="L1667">			dao.updateObject(newTemp);</span>

			/*
			 * perform what is necessary whenever an existing calendar event
			 * template gets updated
			 */
<span class="nc" id="L1673">			m_eventHandler.postUpdateEventTemplate(oldTemplate, newTemp);</span>
<span class="nc" id="L1674">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1675">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1676">			throw e; // just rethrow</span>
<span class="nc" id="L1677">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1678">			handleException(e);</span>
<span class="nc" id="L1679">			throw e;</span>
<span class="nc" id="L1680">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1681">			handleException(e);</span>
<span class="nc" id="L1682">			throw e;</span>
<span class="nc" id="L1683">		} catch (BbmObjectNotFoundException e) {</span>
<span class="nc" id="L1684">			handleException(e);</span>
<span class="nc" id="L1685">			throw e;</span>
<span class="nc" id="L1686">		} catch (BbmException e) {</span>
<span class="nc" id="L1687">			throw new BbmUpdateException(e.getBundleName(), e.getMsgID(), e.getParamObject());</span>
<span class="nc" id="L1688">		} catch (Exception e) {</span>
<span class="nc" id="L1689">			handleException(e);</span>
<span class="nc" id="L1690">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1692">			dmo.cleanUp();</span>
<span class="nc" id="L1693">			methodFinish();</span>
<span class="nc" id="L1694">		}</span>
<span class="nc" id="L1695">	}</span>

	public CalendarEventAssignment createRecurringEventException(ID templateID, Collection workResourceIDs,
			Date exceptionDate) throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1699">		return createRecurringEventException(null, templateID, workResourceIDs, exceptionDate);</span>
	}

	public CalendarEventAssignment createRecurringEventException(ID lockID, ID templateID, Collection workResourceIDs,
			Date exceptionDate) throws MultiUserException, BbmCreateException, BbmScheduleConflictException {
<span class="nc" id="L1704">		methodStart(&quot;createRecurringEventException&quot;, lockID, templateID, workResourceIDs, exceptionDate);</span>
<span class="nc" id="L1705">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1707">			return createRecurringEventExceptionInternal(lockID, templateID, workResourceIDs, exceptionDate, dmo);</span>
<span class="nc" id="L1708">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1709">			handleException(e);</span>
<span class="nc" id="L1710">			throw e;</span>
<span class="nc" id="L1711">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1712">			handleException(e);</span>
<span class="nc" id="L1713">			throw e;</span>
<span class="nc" id="L1714">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1715">			handleException(e);</span>
<span class="nc" id="L1716">			throw e;</span>
<span class="nc" id="L1717">		} catch (Exception e) {</span>
<span class="nc" id="L1718">			handleException(e);</span>
<span class="nc" id="L1719">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1721">			dmo.cleanUp();</span>
<span class="nc" id="L1722">			methodFinish();</span>
		}
	}

	private CalendarEventAssignment createRecurringEventExceptionInternal(ID lockID, ID templateID, Collection workResourceIDs,
				Date exceptionDate, Jdmo dmo) throws Exception {
<span class="nc" id="L1728">		RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1729">		RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

<span class="nc" id="L1731">		CalendarEventAssignment eventException = (CalendarEventAssignment) dao</span>
<span class="nc" id="L1732">				.createRecurringEventException(recTemplate, workResourceIDs, exceptionDate, 0, null, null, null);</span>

		// check if the exception already created before, QC67759
<span class="nc" id="L1735">		Collection conflictWorkResources = new HashSet();</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">		for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1737">			ID workResourceID = (ID) it.next();</span>
<span class="nc bnc" id="L1738" title="All 2 branches missed.">			if (recTemplate.existsExceptionOnDate(eventException.getStartTime(), workResourceID)) {</span>
<span class="nc" id="L1739">				conflictWorkResources.add(workResourceID);</span>
			}
<span class="nc" id="L1741">		}</span>

<span class="nc" id="L1743">		Collection listConflicts = new ArrayList();</span>
<span class="nc bnc" id="L1744" title="All 2 branches missed.">		if (!conflictWorkResources.isEmpty()) {</span>
<span class="nc" id="L1745">			BbmScheduleConflict schConflict = new BbmScheduleConflict(eventException, conflictWorkResources);</span>
<span class="nc" id="L1746">			listConflicts.add(schConflict);</span>
<span class="nc" id="L1747">			ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>
		}
<span class="nc bnc" id="L1749" title="All 2 branches missed.">		if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L1750">			throw new BbmScheduleConflictException(listConflicts);</span>
		}
		// end QC67759

<span class="nc" id="L1754">		checkConflictForNewObject(dmo, eventException, templateID);</span>

		/*
		 * perform what is necessary after an exception to the recurring
		 * event template rule gets created
		 */
<span class="nc" id="L1760">		m_eventHandler.postCreateRecurringException(lockID, eventException);</span>
<span class="nc" id="L1761">		return eventException;</span>
	}

	/**
	 * Calls createRecurringEventExceptionInternal() and updateCEAWithLockInternal() with the same dmo instance, so that
	 * any conflict exception will rollback the entire transaction. This logic was moved here from the web tier (CalendarAppletRequestHandler).
	 */
	public ID createRecurringEventExceptionAndUpdateCalendarEventAssignment(ID templateID, Collection workResourceIDs, Date exceptionDate,
			String username, Collection newWorkResourceIDs, Collection&lt;ID&gt; removedWorkResourceIDs, Collection workResourceIDsFromTemplate,
			Date newStartDate, int newDuration, boolean newLocked, CalendarEventAssignment exceptionEvent)
			throws MultiUserException, BbmCreateException, BbmScheduleConflictException {

<span class="nc" id="L1773">		methodStart(&quot;createRecurringEventExceptionAndUpdateCalendarEventAssignment&quot;, templateID, workResourceIDs, exceptionDate, username);</span>

<span class="nc" id="L1775">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1777">			CalendarEventAssignment recurringEventException = createRecurringEventExceptionInternal(null,</span>
					templateID, workResourceIDs, exceptionDate, dmo);

<span class="nc" id="L1780">			newWorkResourceIDs.removeAll(removedWorkResourceIDs);  //QC56536</span>
<span class="nc" id="L1781">			Iterator itOldWRIDs = workResourceIDsFromTemplate.iterator();</span>
<span class="nc bnc" id="L1782" title="All 2 branches missed.">			while (itOldWRIDs.hasNext()) {</span>
<span class="nc" id="L1783">				ID nextID = (ID) itOldWRIDs.next();</span>
<span class="nc bnc" id="L1784" title="All 2 branches missed.">				if (!newWorkResourceIDs.contains(nextID)) {</span>
<span class="nc" id="L1785">					recurringEventException.removeWorkResourceID(nextID);</span>
				}
<span class="nc" id="L1787">			}</span>
<span class="nc" id="L1788">			Iterator itNewWRIDs = newWorkResourceIDs.iterator();</span>
<span class="nc bnc" id="L1789" title="All 2 branches missed.">			while (itNewWRIDs.hasNext()) {</span>
<span class="nc" id="L1790">				ID nextID = (ID) itNewWRIDs.next();</span>
<span class="nc bnc" id="L1791" title="All 2 branches missed.">				if (!recurringEventException.getWorkResourceIDs().contains(nextID)) {</span>
<span class="nc" id="L1792">					recurringEventException.addWorkResourceID(nextID);</span>
				}
<span class="nc" id="L1794">			}</span>
<span class="nc" id="L1795">			recurringEventException.setStartTime(newStartDate);</span>
<span class="nc" id="L1796">			recurringEventException.setDuration(newDuration);</span>
<span class="nc" id="L1797">			recurringEventException.setLocked(newLocked);</span>
<span class="nc" id="L1798">			recurringEventException.setDescription(exceptionEvent.getDescription());</span>
<span class="nc" id="L1799">			recurringEventException.setActivityID(exceptionEvent.getActivityID());</span>
<span class="nc" id="L1800">			recurringEventException.setUpdateUser(username);</span>
<span class="nc" id="L1801">			updateCEAWithLockInternal(null, recurringEventException, dmo);</span>
<span class="nc" id="L1802">			return recurringEventException.getID();</span>
<span class="nc" id="L1803">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1804">			handleException(e);</span>
<span class="nc" id="L1805">			throw e;</span>
<span class="nc" id="L1806">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1807">			handleException(e);</span>
<span class="nc" id="L1808">			throw e;</span>
<span class="nc" id="L1809">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1810">			handleException(e);</span>
<span class="nc" id="L1811">			throw e;</span>
<span class="nc" id="L1812">		} catch (Exception e) {</span>
<span class="nc" id="L1813">			handleException(e);</span>
<span class="nc" id="L1814">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1816">			dmo.cleanUp();</span>
<span class="nc" id="L1817">			methodFinish();</span>
		}
	}

	public void deleteRecurringEventInstance(ID templateID, Collection workResourceIDs, Date exceptionDate)
			throws MultiUserException, BbmCreateException {
<span class="nc" id="L1823">		methodStart(&quot;deleteRecurringEventInstance&quot;, templateID, workResourceIDs, exceptionDate);</span>

<span class="nc" id="L1825">		RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(new Jdmo());</span>
		try {
<span class="nc" id="L1827">			RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

			/** save the old event information for notification purposes */
<span class="nc" id="L1830">			Collection listEvents = recTemplate.getRecurringEventsOnDay(workResourceIDs, exceptionDate);</span>

			/*
			 * perform what is necessary before a recurring event instances get
			 * deleted
			 */
<span class="nc" id="L1836">			m_eventHandler.preDeleteRecurringEventInstance(listEvents, workResourceIDs);</span>

<span class="nc" id="L1838">			dao.deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>

			/*
			 * perform what is necessary after a recurring event instances get
			 * deleted
			 */
<span class="nc" id="L1844">			m_eventHandler.postDeleteRecurringEventInstance(templateID, listEvents, workResourceIDs);</span>
<span class="nc" id="L1845">		} catch (BbmFinderException e) {</span>
			/**
			 * this is not an error - simply the recurring event template with
			 * the given ID does not exist
			 */
<span class="nc" id="L1850">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1851">			handleException(e);</span>
<span class="nc" id="L1852">			throw e;</span>
<span class="nc" id="L1853">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1854">			handleException(e);</span>
<span class="nc" id="L1855">			throw e;</span>
<span class="nc" id="L1856">		} catch (Exception e) {</span>
<span class="nc" id="L1857">			handleException(e);</span>
<span class="nc" id="L1858">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1860">			dao.cleanUp();</span>
<span class="nc" id="L1861">			methodFinish();</span>
<span class="nc" id="L1862">		}</span>
<span class="nc" id="L1863">	}</span>

	public ID createClassSession(ID templateID, CalendarEvent event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1867">		return createClassSessionWithLock(null, templateID, event);</span>
	}

	public ID createClassSessionWithLock(String sLock, ID templateID, CalendarEvent event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1872">		methodStart(&quot;createClassSession&quot;, templateID, event);</span>

<span class="nc" id="L1874">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1875">		FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L1876">		CalendarEventAssignmentDAO dao2 = new CalendarEventAssignmentDAO(dmo);</span>
		try {
			/* first check that templateID is the ID of a class */
<span class="nc" id="L1879">			ValueObjectBase templateObj = dao1.getObjectByID(templateID);</span>
<span class="nc bnc" id="L1880" title="All 4 branches missed.">			if (!(templateObj instanceof FloatingEventTemplate) || !((FloatingEventTemplate) templateObj).isClass()) {</span>
<span class="nc" id="L1881">				throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_NOT_A_CLASS_TEMPLATE,</span>
						new Object[] { templateID });
			}

			/* perform what is necessary before a new event gets created */
			// m_eventHandler.preCreateEvent(sLock, event);
			/** see if there were any conflicts as a result of this operation */
<span class="nc" id="L1888">			Collection listConflicts = dao2.getConflictsForNewScheduleObject(event);</span>
<span class="nc bnc" id="L1889" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L1890">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="nc" id="L1893">			event.setFieldValue(CalendarEventAssignmentFields.TEMPLATEID, templateID);</span>
<span class="nc" id="L1894">			ID eventID = dao2.createObject(event);</span>

			/* perform what is necessary after a new event gets created */
<span class="nc" id="L1897">			m_eventHandler.postCreateEvent(event);</span>

<span class="nc" id="L1899">			return eventID;</span>
<span class="nc" id="L1900">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1901">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1902">			throw e; // just rethrow</span>
<span class="nc" id="L1903">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1904">			handleException(e);</span>
<span class="nc" id="L1905">			throw e;</span>
<span class="nc" id="L1906">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1907">			handleException(e);</span>
<span class="nc" id="L1908">			throw e;</span>
<span class="nc" id="L1909">		} catch (Exception e) {</span>
<span class="nc" id="L1910">			handleException(e);</span>
<span class="nc" id="L1911">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1913">			dmo.cleanUp();</span>
<span class="nc" id="L1914">			methodFinish();</span>
		}
	}

	public void lockEvents(int eventTypeMask, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmUpdateException {
<span class="fc" id="L1920">		methodStart(&quot;lockEvents&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L1921">		Jdmo dmo = new Jdmo();</span>
		try {
			/* perform what is necessary before the events are locked */
<span class="fc" id="L1924">			m_eventHandler.preLockEvents(workResourceIDs, dtStart, dtEnd);</span>

<span class="pc bpc" id="L1926" title="1 of 4 branches missed.">			if (((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0)</span>
					|| ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) != 0)) {
<span class="fc" id="L1928">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="fc" id="L1929">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, true);</span>
			}
<span class="pc bpc" id="L1931" title="1 of 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="nc" id="L1932">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L1933">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, true,</span>
<span class="nc" id="L1934">						getExtraCondition(eventTypeMask));</span>
			}

			/* perform what is necessary after the events are locked */
<span class="fc" id="L1938">			m_eventHandler.postLockEvents(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L1939">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1940">			handleException(e);</span>
<span class="nc" id="L1941">			throw e;</span>
<span class="nc" id="L1942">		} catch (Exception e) {</span>
<span class="nc" id="L1943">			handleException(e);</span>
<span class="nc" id="L1944">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="pc" id="L1946">			dmo.cleanUp();</span>
<span class="pc" id="L1947">			methodFinish();</span>
<span class="fc" id="L1948">		}</span>
<span class="fc" id="L1949">	}</span>

	public void unlockEvents(int eventTypeMask, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmUpdateException {
<span class="nc" id="L1953">		methodStart(&quot;unLockEvents&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L1954">		Jdmo dmo = new Jdmo();</span>
		try {
			/* perform what is necessary before the events are locked */
<span class="nc" id="L1957">			m_eventHandler.preUnlockEvents(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc bnc" id="L1959" title="All 4 branches missed.">			if (((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0)</span>
					|| ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) != 0)) {
<span class="nc" id="L1961">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="nc" id="L1962">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, false);</span>
			}
<span class="nc bnc" id="L1964" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="nc" id="L1965">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L1966">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, false,</span>
<span class="nc" id="L1967">						getExtraCondition(eventTypeMask));</span>
			}

			/* perform what is necessary after the events are locked */
<span class="nc" id="L1971">			m_eventHandler.postUnlockEvents(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L1972">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1973">			handleException(e);</span>
<span class="nc" id="L1974">			throw e;</span>
<span class="nc" id="L1975">		} catch (Exception e) {</span>
<span class="nc" id="L1976">			handleException(e);</span>
<span class="nc" id="L1977">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1979">			dmo.cleanUp();</span>
<span class="nc" id="L1980">			methodFinish();</span>
<span class="nc" id="L1981">		}</span>
<span class="nc" id="L1982">	}</span>

	private String getExtraCondition(int eventTypeMask) {
<span class="nc" id="L1985">		StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L1986" title="All 2 branches missed.">		if ((eventTypeMask &amp; Event.EVENT_TYPE_FLOATINGEVENTSSESSIONS) != 0) {</span>
<span class="nc" id="L1987">			sb.append(&quot; and calendareventtemplateid in (select id from floatingeventtemplate) &quot;);</span>
		}
<span class="nc bnc" id="L1989" title="All 2 branches missed.">		if ((eventTypeMask &amp; Event.EVENT_TYPE_PROJECTS) != 0) {</span>
<span class="nc" id="L1990">			sb.append(&quot; and id in (select calendareventassignmentid from calendareventproject) &quot;);</span>
		}
<span class="nc" id="L1992">		return sb.toString();</span>
	}

	/**
	 * This API is created for request manager to manage time off request. Since
	 * it will do the partial publish, we won't touch publishing period.
	 *
	 * @param workResourceIDs
	 * @param dtStart
	 * @param dtEnd
	 */
	public void publishTimeOffEvents(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="fc" id="L2005">		methodStart(&quot;publishTimeOffEvents&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="pc bpc" id="L2006" title="2 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L2007">			return;</span>
		}
<span class="fc" id="L2009">		Jdmo dmo = new Jdmo();</span>
		try {

<span class="fc" id="L2012">			boolean bNeedToNotify = false;</span>
<span class="pc bpc" id="L2013" title="1 of 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="fc" id="L2015">				bNeedToNotify = m_notifyManager</span>
<span class="fc" id="L2016">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}
<span class="fc" id="L2018">			Collection eventToUnPubGroupByEmployeeID = getPublishedEventsForWorkResourcesByType(</span>
					Event.EVENT_TYPE_TIME_OFF, workResourceIDs, dtStart, dtEnd);
<span class="fc" id="L2020">			Collection eventToUnPub = ScheduleDAOUtil.getUniqueEvents(eventToUnPubGroupByEmployeeID);</span>
<span class="fc" id="L2021">			Collection eventToPubGroupByEmployeeID = getEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF,</span>
					workResourceIDs, dtStart, dtEnd);
<span class="fc" id="L2023">			Collection eventToPub = ScheduleDAOUtil.getUniqueEvents(eventToPubGroupByEmployeeID);</span>

<span class="fc" id="L2025">			CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2026">			dao.unPublishSchedule(eventToUnPub, workResourceIDs);</span>
<span class="fc" id="L2027">			eventToPub = dao.publishSchedule(eventToPubGroupByEmployeeID, new ArrayList(eventToUnPub), workResourceIDs);</span>
<span class="fc" id="L2028">			ScheduleChangeDetails changeDetails = new ScheduleChangeDetails(new ArrayList(), dtStart, dtEnd,</span>
					new ArrayList(), new ArrayList());
<span class="fc" id="L2030">			changeDetails.addMoreDetails(</span>
					new ScheduleChangeDetails(workResourceIDs, dtStart, dtEnd, eventToUnPubGroupByEmployeeID,
<span class="fc" id="L2032">							ScheduleDAOUtil.groupEventsByWorkResources(eventToPub, workResourceIDs)));</span>
<span class="fc" id="L2033">			Event event = null;</span>
<span class="fc" id="L2034">			PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>

<span class="fc" id="L2036">			Collection ids = null;</span>
<span class="fc bfc" id="L2037" title="All 2 branches covered.">			for (Iterator i = eventToPub.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2038">				event = (Event) i.next();</span>
				/*
				 * update the PublishingPeriod table to insert a partial publish
				 * record
				 */
<span class="fc" id="L2043">				ids = event.getWorkResourceIDs();</span>
<span class="fc" id="L2044">				ids.retainAll(workResourceIDs);</span>
<span class="fc" id="L2045">				daoPeriod.publishPeriods(ids, event.getStartTime(), event.getEndTime(), true);</span>
			}
<span class="fc" id="L2047">			m_eventHandler.triggerTONotificationSynrchronized(changeDetails);</span>

<span class="pc bpc" id="L2049" title="1 of 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="fc" id="L2054">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="fc" id="L2061">			m_eventHandler.postPublishEvent(eventToPub, changeDetails);</span>

<span class="nc" id="L2063">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2064">			handleException(e);</span>
<span class="nc" id="L2065">			throw e;</span>
<span class="nc" id="L2066">		} catch (Exception e) {</span>
<span class="nc" id="L2067">			handleException(e);</span>
<span class="nc" id="L2068">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="pc" id="L2070">			dmo.cleanUp();</span>
			// QC53354/QA97533 need to publish
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="pc bpc" id="L2075" title="3 of 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="pc" id="L2076">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="pc" id="L2078">			methodFinish();</span>
<span class="fc" id="L2079">		}</span>
<span class="fc" id="L2080">	}</span>

	public void unPublishTimeOffEvents(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="fc" id="L2084">		methodStart(&quot;unPublishTimeOffEvents&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L2086">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L2087">		CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2088">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
<span class="fc" id="L2090">			Collection eventToUnPub = ScheduleDAOUtil.getUniqueEvents(getPublishedEventsForWorkResourcesByType(</span>
					Event.EVENT_TYPE_TIME_OFF, workResourceIDs, dtStart, dtEnd));
<span class="fc" id="L2092">			dao.unPublishSchedule(eventToUnPub, workResourceIDs);</span>
<span class="fc" id="L2093">			Event event = null;</span>
<span class="fc" id="L2094">			Collection ids = null;</span>
<span class="fc bfc" id="L2095" title="All 2 branches covered.">			for (Iterator i = eventToUnPub.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2096">				event = (Event) i.next();</span>
<span class="fc" id="L2097">				ids = event.getWorkResourceIDs();</span>
<span class="fc" id="L2098">				ids.retainAll(workResourceIDs);</span>
<span class="fc" id="L2099">				daoPeriod.unPublishPeriods(ids, event.getStartTime(), event.getEndTime(), true);// QA100166</span>
																								// Partially
																								// publishing
																								// PublishPeriod
			}
<span class="fc" id="L2104">			m_eventHandler.postUnPublishSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2105">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2106">			handleException(e);</span>
<span class="nc" id="L2107">			throw e;</span>
<span class="nc" id="L2108">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2109">			handleException(e);</span>
<span class="nc" id="L2110">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="pc" id="L2112">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="pc bpc" id="L2116" title="3 of 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="pc" id="L2117">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="pc" id="L2119">			methodFinish();</span>
<span class="fc" id="L2120">		}</span>
<span class="fc" id="L2121">	}</span>

	public void publishSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2125">		publishScheduleInBatch(workResourceIDs, dtStart, dtEnd, false);// always</span>
																		// set
																		// isBatchPublish
																		// =false
<span class="nc" id="L2129">	}</span>

	public void publishScheduleInBatch(Collection workResourceIDs, Date dtStart, Date dtEnd, boolean isBatchPublish)
			throws BbmSchedulePublishingException {
<span class="fc" id="L2133">		methodStart(&quot;publishSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L2134">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L2135">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2136">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2137">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
			/*
			 * this is an optimization that is used to check whether there
			 * actually are any notification rules for 'schedule changed'
			 * notifications. If not, there's no need to keep track of schedule
			 * change details
			 */
<span class="fc" id="L2145">			boolean bNeedToNotify = false;</span>
<span class="pc bpc" id="L2146" title="1 of 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="fc" id="L2148">				bNeedToNotify = m_notifyManager</span>
<span class="fc" id="L2149">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}

<span class="fc" id="L2152">			Collection cOutOfSynchWorkResourceIDs = getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs,</span>
					dtStart, dtEnd);

<span class="fc" id="L2155">			ScheduleChangeDetails changeDetails = dao1.publishSchedule(dtStart, dtEnd, false, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);

<span class="fc" id="L2158">			ScheduleChangeDetails pCalendarEventChangeDetails = dao2.publishSchedule(dtStart, dtEnd, false,</span>
					workResourceIDs, cOutOfSynchWorkResourceIDs);

			/* update the PublishingPeriod table */
<span class="fc" id="L2162">			daoPeriod.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>
			/*
			 * Fix for bug #94140 ;as per suggestions from Angela moved code
			 * here from ScheduleEventHandler to handle scenarios where
			 * changeDetails is set to null on Certain conditions, Sameet Jan
			 * 2007
			 */
<span class="pc bpc" id="L2169" title="1 of 2 branches missed.">			if (changeDetails != null) {</span>
<span class="fc" id="L2170">				changeDetails.addMoreDetails(pCalendarEventChangeDetails);</span>
<span class="fc" id="L2171">				ScheduleEventHandler.triggerTONotification(changeDetails, isBatchPublish);</span>
			}

<span class="pc bpc" id="L2174" title="1 of 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="fc" id="L2179">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="fc" id="L2186">			m_eventHandler.postPublishSchedule(workResourceIDs, dtStart, dtEnd, changeDetails);</span>
<span class="fc" id="L2187">		} catch (BbmSchedulePublishingException e) {</span>
<span class="fc" id="L2188">			handleException(e);</span>
<span class="fc" id="L2189">			throw e;</span>
<span class="nc" id="L2190">		} catch (Exception e) {</span>
<span class="nc" id="L2191">			handleException(e);</span>
<span class="nc" id="L2192">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="fc" id="L2194">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="pc bpc" id="L2198" title="2 of 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="fc" id="L2199">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="fc" id="L2201">			methodFinish();</span>
<span class="fc" id="L2202">		}</span>
<span class="fc" id="L2203">	}</span>

	public void unPublishSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2207">		methodStart(&quot;unPublishSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L2209">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2210">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2211">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2212">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
<span class="nc" id="L2214">			dao1.unPublishSchedule(workResourceIDs, dtStart, dtEnd, false);</span>
<span class="nc" id="L2215">			dao2.unPublishSchedule(workResourceIDs, dtStart, dtEnd, false);</span>

			/* update the PublishingPeriod table */
<span class="nc" id="L2218">			daoPeriod.unPublishPeriods(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets un-published
			 */
<span class="nc" id="L2224">			m_eventHandler.postUnPublishSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2225">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2226">			handleException(e);</span>
<span class="nc" id="L2227">			throw e;</span>
		} finally {
<span class="nc" id="L2229">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="nc bnc" id="L2233" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2234">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2236">			methodFinish();</span>
<span class="nc" id="L2237">		}</span>
<span class="nc" id="L2238">	}</span>

	public void revertToPublishedSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2242">		methodStart(&quot;revertToPublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2243">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2244">		ShiftAssignmentDAO dao1 = new ShiftAssignmentDAO(dmo);</span>
<span class="nc" id="L2245">		CalendarEventAssignmentDAO dao2 = new CalendarEventAssignmentDAO(dmo);</span>
		try {
			/*
			 * perform what is necessary before the schedule for the selected
			 * work resources gets reverted to published state
			 */
<span class="nc" id="L2251">			m_eventHandler.preRevertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L2253">			dao1.revertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2254">			dao2.revertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * perform what is necessary after the schedule for the selected
			 * work resources gets reverted to published state
			 */
<span class="nc" id="L2260">			m_eventHandler.postRevertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2261">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2262">			handleException(e);</span>
<span class="nc" id="L2263">			throw e;</span>
<span class="nc" id="L2264">		} catch (Exception e) {</span>
<span class="nc" id="L2265">			handleException(e);</span>
<span class="nc" id="L2266">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2268">			dmo.cleanUp();</span>
<span class="nc" id="L2269">			methodFinish();</span>
<span class="nc" id="L2270">		}</span>
<span class="nc" id="L2271">	}</span>

	public void updatePublishedSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2275">		methodStart(&quot;updatePublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2276">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2277">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2278">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2279">		PublishingPeriodDAO dao3 = new PublishingPeriodDAO(dmo);</span>
		try {
			/*
			 * this is an optimization that is used to check whether there
			 * actually are any notification rules for 'schedule changed'
			 * notifications. If not, there's no need to keep track of schedule
			 * change details
			 */
<span class="nc" id="L2287">			boolean bNeedToNotify = false;</span>
<span class="nc bnc" id="L2288" title="All 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="nc" id="L2290">				bNeedToNotify = m_notifyManager</span>
<span class="nc" id="L2291">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}

<span class="nc" id="L2294">			Collection cOutOfSynchWorkResourceIDs = getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs,</span>
					dtStart, dtEnd);

<span class="nc" id="L2297">			ScheduleChangeDetails changeDetails = dao1.publishSchedule(dtStart, dtEnd, true, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);
<span class="nc" id="L2299">			ScheduleChangeDetails moreDetails = dao2.publishSchedule(dtStart, dtEnd, true, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);

			// refresh the publish time in publishingperiods table
<span class="nc" id="L2303">			dao3.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc bnc" id="L2305" title="All 2 branches missed.">			if (changeDetails != null) {</span>
<span class="nc" id="L2306">				changeDetails.addMoreDetails(moreDetails);</span>
<span class="nc" id="L2307">				ScheduleEventHandler.triggerTONotification(changeDetails, false);</span>
			}

<span class="nc bnc" id="L2310" title="All 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="nc" id="L2315">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="nc" id="L2322">			m_eventHandler.postUpdatePublishedSchedule(workResourceIDs, dtStart, dtEnd, changeDetails);</span>
<span class="nc" id="L2323">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2324">			handleException(e);</span>
<span class="nc" id="L2325">			throw e;</span>
<span class="nc" id="L2326">		} catch (Exception e) {</span>
<span class="nc" id="L2327">			handleException(e);</span>
<span class="nc" id="L2328">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2330">			dmo.cleanUp();</span>
<span class="nc bnc" id="L2331" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2332">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2334">			methodFinish();</span>
<span class="nc" id="L2335">		}</span>
<span class="nc" id="L2336">	}</span>

	public Collection getWorkResourcesOutOfSyncWithPublishedSchedule(Collection workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmSchedulePublishingException {
<span class="fc" id="L2340">		methodStart(&quot;getWorkResourcesOutOfSyncWithPublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
<span class="fc" id="L2343">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>
<span class="fc" id="L2344">			return m_auditManager.getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs, eventTypeMask,</span>
					dtStart, dtEnd);
<span class="nc" id="L2346">		} catch (Exception e) {</span>
<span class="nc" id="L2347">			handleException(e);</span>
<span class="nc" id="L2348">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="pc" id="L2350">			methodFinish();</span>
		}
	}

	public List&lt;Collection&lt;PublishingPeriod&gt;&gt; getPublishedPeriods(Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="fc" id="L2356">		methodStart(&quot;getPublishedPeriods&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L2358">		PublishingPeriodDAO dao = new PublishingPeriodDAO();</span>
		try {
<span class="fc" id="L2360">			return dao.getPublishedPeriods(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2361">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2362">			handleException(e);</span>
<span class="nc" id="L2363">			throw e;</span>
		} finally {
<span class="pc" id="L2365">			dao.cleanUp();</span>
<span class="pc" id="L2366">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResourcesFromCache(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2372">		methodStart(&quot;getPublishedEventsForWorkResourcesFromCache&quot;, workResourceIDs, dtStart, dtEnd);</span>
		try {
			/* if not using cache, just fetch from DB */
<span class="nc bnc" id="L2375" title="All 2 branches missed.">			if (m_scheduleCache == null) {</span>
<span class="nc" id="L2376">				return getPublishedEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
			}

			/**
			 * this is where we shall store the events that we find in the cache
			 */
<span class="nc" id="L2382">			HashMap mapEvents = m_scheduleCache.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			/* find out cache misses */
<span class="nc" id="L2385">			HashSet setCacheMisses = new HashSet();</span>
<span class="nc bnc" id="L2386" title="All 2 branches missed.">			for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2387">				ID workResourceID = (ID) it.next();</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">				if (!mapEvents.containsKey(workResourceID)) {</span>
<span class="nc" id="L2389">					setCacheMisses.add(workResourceID);</span>
				}
<span class="nc" id="L2391">			}</span>

<span class="nc bnc" id="L2393" title="All 2 branches missed.">			if (!setCacheMisses.isEmpty()) {</span>
				/*
				 * we've had some cache misses, so we need to fetch those events
				 */
<span class="nc" id="L2397">				List listEvents = null;</span>
<span class="nc" id="L2398">				Date currentCacheWindowStart = m_scheduleCache.getCacheWindowStart();</span>
<span class="nc" id="L2399">				Date currentCacheWindowEnd = m_scheduleCache.getCacheWindowEnd();</span>
<span class="nc bnc" id="L2400" title="All 4 branches missed.">				if (dtStart.after(currentCacheWindowStart) &amp;&amp; dtEnd.before(currentCacheWindowEnd)) {</span>
					// inside cache time window, preload the events to the cache
					// window end
<span class="nc" id="L2403">					listEvents = getPublishedEventsForWorkResources(setCacheMisses, dtStart, currentCacheWindowEnd);</span>
					/** update the cache also */
<span class="nc" id="L2405">					m_scheduleCache.put(setCacheMisses, listEvents, dtStart, currentCacheWindowEnd);</span>
<span class="nc" id="L2406">					HashMap missedEvent = m_scheduleCache.getEventsForWorkResources(setCacheMisses, dtStart, dtEnd);</span>
<span class="nc" id="L2407">					mapEvents.putAll(missedEvent);</span>
<span class="nc" id="L2408">				} else {</span>
					// not in the cache window, load from db
<span class="nc" id="L2410">					listEvents = getPublishedEventsForWorkResources(setCacheMisses, dtStart, dtEnd);</span>
<span class="nc" id="L2411">					Iterator itWorkResource = setCacheMisses.iterator();</span>
<span class="nc" id="L2412">					Iterator itEvents = listEvents.iterator();</span>
<span class="nc bnc" id="L2413" title="All 4 branches missed.">					while (itWorkResource.hasNext() &amp;&amp; itEvents.hasNext()) {</span>
<span class="nc" id="L2414">						ID workResourceID = (ID) itWorkResource.next();</span>
<span class="nc" id="L2415">						Collection listWrkEvents = (Collection) itEvents.next();</span>
<span class="nc" id="L2416">						mapEvents.put(workResourceID, listWrkEvents);</span>
<span class="nc" id="L2417">					}</span>
					/** update the cache also */
<span class="nc" id="L2419">					m_scheduleCache.put(setCacheMisses, listEvents, dtStart, dtEnd);</span>

				}
			}

<span class="nc" id="L2424">			ArrayList listEvents = new ArrayList(workResourceIDs.size());</span>
<span class="nc bnc" id="L2425" title="All 2 branches missed.">			for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2426">				ID workResourceID = (ID) it.next();</span>
<span class="nc" id="L2427">				listEvents.add(mapEvents.get(workResourceID));</span>
<span class="nc" id="L2428">			}</span>
<span class="nc" id="L2429">			return listEvents;</span>
		} finally {
<span class="nc" id="L2431">			methodFinish();</span>
		}
	}

	public HashMap getPublishedChangedIntervalsForWorkResources(Collection workResourceIDs, Date dateStart,
			Date dateEnd, Date dateLastUpdated) throws BbmFinderException {
<span class="nc" id="L2437">		methodStart(&quot;getPublishedChangedIntervalsForWorkResources&quot;, workResourceIDs, dateStart, dateEnd,</span>
				dateLastUpdated);
		try {
			/* first, query event audit trail for changes */
<span class="nc" id="L2441">			HashMap auditMap = m_auditManager.getChangedIntervalsForWorkResource(workResourceIDs,</span>
					AuditTrailEntry.MODULE_PUBLISHING, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastUpdated,
					null);
<span class="nc" id="L2444">			return auditMap;</span>
<span class="nc" id="L2445">		} catch (Exception e) {</span>
<span class="nc" id="L2446">			handleException(e);</span>
<span class="nc" id="L2447">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2449">			methodFinish();</span>
		}
	}

	/**
	 * This method will return a HashMap keyed on workresource ID, containing a
	 * collection of TimeRange objects (for each changed unpublished interval),
	 * for each work resource.
	 *
	 * @param workResourceIDs
	 *            a collection of IDs of the employees for whom to return the
	 *            changed intervals
	 * @param dateStart
	 *            time range start to return data for
	 * @param dateEnd
	 *            time range end to return data for
	 * @param dateLastUpdated
	 *            indicates to return all changes since dateLastUpdated
	 * @return hashmap
	 * @throws BbmFinderException
	 *             if there was an error while performing database queries
	 */
	public HashMap getChangedIntervalsForWorkResources(Collection workResourceIDs, Date dateStart, Date dateEnd,
			Date dateLastUpdated) throws BbmFinderException {
<span class="nc" id="L2473">		methodStart(&quot;getChangedIntervalsForWorkResources&quot;, workResourceIDs, dateStart, dateEnd, dateLastUpdated);</span>
		try {
			/* first, query event audit trail for changes */
<span class="nc" id="L2476">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>
<span class="nc" id="L2477">			HashMap auditMap = m_auditManager.getChangedIntervalsForWorkResource(workResourceIDs,</span>
					AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastUpdated,
					null);
<span class="nc" id="L2480">			return auditMap;</span>
<span class="nc" id="L2481">		} catch (Exception e) {</span>
<span class="nc" id="L2482">			handleException(e);</span>
<span class="nc" id="L2483">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2485">			methodFinish();</span>
		}
	}

	/*
	 * @deprecated by com.bluepumpkin.common.localization.Localizer - see
	 * getConflictMessagesWithLocaleStrings instead public Collection
	 * getConflictMessages (Collection listConflicts, String localeID, String
	 * timeZoneID) { methodStart(&quot;getConflictMessages&quot;, listConflicts, localeID,
	 * timeZoneID); try { Locale locale;
	 *
	 * if (localeID != null) locale =
	 * LocalizationManager.getInstance().getLocale(localeID); else // it should
	 * use Default Language Locale, may not be JVM Locale locale =
	 * DefaultLocalizationManager
	 * .getDefaultInstance().getLocaleContext().getLanguageLocale();
	 *
	 * TimeZone tz; if (timeZoneID != null) tz =
	 * TimeZone.getTimeZone(timeZoneID); else tz = TimeZone.getDefault();
	 *
	 * ArrayList listMessages = new ArrayList(listConflicts.size()); for
	 * (Iterator it = listConflicts.iterator(); it.hasNext(); ) {
	 * BbmScheduleConflict conflict = (BbmScheduleConflict)it.next();
	 * listMessages.add(conflict.getLocalizedMessage(locale, tz)); } return
	 * listMessages; } finally { methodFinish(); } }
	 */
	/**
	 * This method is used by the C++ client to retrieve a list of localized
	 * schedule conflict messages
	 *
	 * @param listConflicts
	 *            collection of BbmScheduleConflict objects to retrieve messages
	 *            for
	 * @param langLocaleID
	 *            string language locale ID (e.g. &quot;en_US&quot;) in which to return
	 *            the conflict messages. If null, default server locale will be
	 *            used
	 * @param regionalLocaleID
	 *            string regional locale ID (e.g. &quot;en_US&quot;) in which to return
	 *            the conflict messages date and time. If null, default server
	 *            locale will be used
	 * @param timeZoneID
	 *            string time zone ID (e.g. &quot;PST&quot;) in which the times in the
	 *            conflict message will be returned
	 * @return collection of messages, one for each conflict given
	 */
	public Collection getConflictMessagesWithLocaleStrings(Collection listConflicts, String langLocaleID,
			String regionalLocaleID, String timeZoneID) {
<span class="nc" id="L2533">		methodStart(&quot;getConflictMessagesWithLocaleStrings&quot;, listConflicts, langLocaleID, regionalLocaleID, timeZoneID);</span>
		try {
			Localizer localizer;
<span class="nc bnc" id="L2536" title="All 2 branches missed.">			if (langLocaleID != null) {</span>
<span class="nc bnc" id="L2537" title="All 2 branches missed.">				if (regionalLocaleID == null) {</span>
<span class="nc" id="L2538">					regionalLocaleID = langLocaleID;</span>
				}
<span class="nc" id="L2540">				LocalizationManager locMngr = LocalizationManager.getInstance();</span>
<span class="nc" id="L2541">				LocaleContext locCtx = locMngr.getLocaleContext(locMngr.getLocale(langLocaleID),</span>
<span class="nc" id="L2542">						locMngr.getLocale(regionalLocaleID), locMngr.getLocale(langLocaleID));</span>
<span class="nc" id="L2543">				localizer = locMngr.getLocalizer(locCtx);</span>
<span class="nc" id="L2544">			} else {</span>
<span class="nc" id="L2545">				localizer = DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
			}

			TimeZone tz;
<span class="nc bnc" id="L2549" title="All 2 branches missed.">			if (timeZoneID != null) {</span>
<span class="nc" id="L2550">				tz = TimeZone.getTimeZone(timeZoneID);</span>
			} else {
<span class="nc" id="L2552">				tz = TimeZone.getDefault();</span>
			}

<span class="nc" id="L2555">			ArrayList listMessages = new ArrayList(listConflicts.size());</span>
<span class="nc bnc" id="L2556" title="All 2 branches missed.">			for (Iterator it = listConflicts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2557">				BbmScheduleConflict conflict = (BbmScheduleConflict) it.next();</span>
<span class="nc" id="L2558">				listMessages.add(conflict.getLocalizedMessage(localizer, tz));</span>
<span class="nc" id="L2559">			}</span>
<span class="nc" id="L2560">			return listMessages;</span>
		} finally {
<span class="nc" id="L2562">			methodFinish();</span>
		}
	}

	/**Get all conflicts of all shift assignments including the shift blocks
	 * 
	 * @param shiftAssignments
	 * @return
	 * @throws Exception
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObjects(
			Collection&lt;ShiftAssignment&gt; shiftAssignments) throws Exception {
<span class="nc" id="L2574">		methodStart(&quot;getConflictsForNewScheduleObjects&quot;, shiftAssignments);</span>

<span class="nc" id="L2576">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="nc" id="L2582">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForNewScheduleObjects(shiftAssignments);</span>
<span class="nc" id="L2583">			return listConflicts;</span>
		} finally {
<span class="nc" id="L2585">			dao.cleanUp();</span>
<span class="nc" id="L2586">			methodFinish();</span>
		}
	}

	private boolean intersectsEvent(Event pShiftAssignment, Collection cEvents, Organization pOrg) {
<span class="pc bpc" id="L2591" title="1 of 2 branches missed.">		if (cEvents == null) {</span>
<span class="fc" id="L2592">			return false;</span>
		}
<span class="nc bnc" id="L2594" title="All 2 branches missed.">		for (Iterator i = cEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2595">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L2596" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
<span class="nc bnc" id="L2597" title="All 2 branches missed.">					|| pEvent.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc bnc" id="L2598" title="All 2 branches missed.">				if (pShiftAssignment.getEndTime().after(pEvent.getStartTime())</span>
<span class="nc bnc" id="L2599" title="All 2 branches missed.">						&amp;&amp; pShiftAssignment.getStartTime().before(pEvent.getEndTime())) {</span>
<span class="nc" id="L2600">					return true;</span>
				}
			}
<span class="nc bnc" id="L2603" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L2604">				Calendar cStartDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L2605">				cStartDay.setTime(pShiftAssignment.getStartTime());</span>
<span class="nc" id="L2606">				cStartDay.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L2607">				cStartDay.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">				if (cStartDay.getTime().after(pShiftAssignment.getStartTime())) {</span>
<span class="nc" id="L2609">					cStartDay.add(Calendar.DATE, -1);</span>
				}
<span class="nc" id="L2611">				Calendar cEndDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L2612">				cEndDay.setTime(cStartDay.getTime());</span>
<span class="nc" id="L2613">				cEndDay.add(Calendar.DATE, 1);</span>
<span class="nc bnc" id="L2614" title="All 2 branches missed.">				if (!pEvent.getStartTime().before(cStartDay.getTime())</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">						&amp;&amp; pEvent.getStartTime().before(cEndDay.getTime())) {</span>
<span class="nc" id="L2616">					return true;</span>
				}
			}
<span class="nc" id="L2619">		}</span>
<span class="nc" id="L2620">		return false;</span>
	}

	public void copyShiftAssignments(ID idSourceSP, Date sourceWeekStart, ID idDestinationSP, Date targetWeekStart,
			boolean bClearDestinationSP) throws BbmFinderException, BbmScheduleConflictException {
<span class="pc bpc" id="L2625" title="1 of 2 branches missed.">		methodStart(&quot;copyShiftAssignments&quot;, idSourceSP, sourceWeekStart, idDestinationSP, targetWeekStart,</span>
				bClearDestinationSP ? Boolean.TRUE : Boolean.FALSE);
<span class="fc" id="L2627">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L2629">			ID idSourceSPParent = m_pCampaignManager.getParentSchedulingPeriodID(idSourceSP);</span>

			// Date sourceWeekEnd = TimeZoneUtil.addWeek(sourceWeekStart);
			// Date targetWeekEnd = TimeZoneUtil.addWeek(targetWeekStart);

<span class="fc" id="L2634">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="fc" id="L2635">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>

			// Changes start for QA96688
<span class="fc" id="L2638">			Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP.getCampaignID());</span>
<span class="fc" id="L2639">			Date sourceWeekEnd = getWeekEnd(sourceWeekStart, pSourceSP, pCampaign, false);</span>
<span class="fc" id="L2640">			Date targetWeekEnd = getWeekEnd(targetWeekStart, pDestinationSP, pCampaign, false);</span>

<span class="fc" id="L2642">			TimeZone tz = pCampaign.getTimeZone();</span>
<span class="pc bpc" id="L2643" title="1 of 2 branches missed.">			boolean isPartialWeek = pCampaign.isMonthly()</span>
<span class="nc bnc" id="L2644" title="All 2 branches missed.">					&amp;&amp; (MonthlySPUtil.isPartialWeek(tz, sourceWeekStart, sourceWeekEnd)</span>
<span class="pc bnc" id="L2645" title="All 2 branches missed.">							|| MonthlySPUtil.isPartialWeek(tz, targetWeekStart, targetWeekEnd));</span>
<span class="pc bpc" id="L2646" title="1 of 2 branches missed.">			if (isPartialWeek) {</span>
<span class="nc" id="L2647">				Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
						sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc bnc" id="L2649" title="All 2 branches missed.">				if (sourceWeekCopiableRange[0] == null) {</span>
					// there is no common range (based on days of week) to copy
					// over, exit
<span class="nc" id="L2652">					return;</span>
				}
			}
			// Changes end for QA96688

			// DST adjust for source target fix QC52704
<span class="fc" id="L2658">			sourceWeekEnd = TimeZoneUtil.getMidNightDate(sourceWeekEnd, tz);</span>

<span class="fc" id="L2660">			Collection cpAssignments = m_pCampaignManager</span>
<span class="fc" id="L2661">					.getCampaignWorkResourceAssignments(pDestinationSP.getCampaignID(), targetWeekStart, targetWeekEnd);</span>

<span class="fc" id="L2663">			HashSet cidWorkResources = new HashSet();</span>
<span class="fc bfc" id="L2664" title="All 2 branches covered.">			for (Iterator i = cpAssignments.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2665">				CampaignWorkResource pAssignment = (CampaignWorkResource) i.next();</span>
<span class="fc" id="L2666">				cidWorkResources.add(pAssignment.getWorkResourceID());</span>
<span class="fc" id="L2667">			}</span>

			// map key:workresourceid, value=array of WorkResourceAssignment
<span class="fc" id="L2670">			Map orgAssignmentWithTZ = m_workResourceManager.getWRAssignmentsWithTimeZone(cidWorkResources);</span>

			// Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP
			// .getCampaignID());

<span class="fc" id="L2675">			ArrayList aEmployeeDatePairs = new ArrayList();</span>
<span class="fc bfc" id="L2676" title="All 2 branches covered.">			for (Iterator i = cidWorkResources.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2677">				ID idEmployee = (ID) i.next();</span>
<span class="fc" id="L2678">				aEmployeeDatePairs.add(new Pair(idEmployee, sourceWeekEnd));</span>
<span class="fc" id="L2679">			}</span>
<span class="fc" id="L2680">			Collection cEmployeeOrgIDs = m_workResourceManager.getEmployeeOrganizations(aEmployeeDatePairs);</span>

<span class="fc" id="L2682">			HashSet cidOrgs = new HashSet();</span>
<span class="fc bfc" id="L2683" title="All 2 branches covered.">			for (Iterator i = cEmployeeOrgIDs.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2684">				ID idOrg = (ID) i.next();</span>
<span class="pc bpc" id="L2685" title="1 of 2 branches missed.">				if (idOrg != null) {</span>
<span class="fc" id="L2686">					cidOrgs.add(idOrg);</span>
				}
<span class="fc" id="L2688">			}</span>

<span class="fc" id="L2690">			Collection aOrgs = m_workResourceManager.getOrganizationsByIDs(cidOrgs);</span>
<span class="fc" id="L2691">			HashMap hOrgs = new HashMap();</span>
<span class="fc bfc" id="L2692" title="All 2 branches covered.">			for (Iterator i = aOrgs.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2693">				Organization pOrganization = (Organization) i.next();</span>
<span class="fc" id="L2694">				hOrgs.put(pOrganization.getID(), pOrganization);</span>
<span class="fc" id="L2695">			}</span>

<span class="pc bpc" id="L2697" title="1 of 2 branches missed.">			if (bClearDestinationSP) {</span>
				// delete by intersection
<span class="nc" id="L2699">				deleteShiftAssignments(null, cidWorkResources, targetWeekStart, targetWeekEnd, null, false, false);</span>
			}

<span class="fc" id="L2702">			int lTimeDeltaDays = getTimeDeltaDays(tz, isPartialWeek, sourceWeekStart, targetWeekStart, sourceWeekEnd,</span>
					targetWeekEnd);

			// I beleive, we are going to use GregorianCalendar only for now -
			// and
			// source uses the same timezone as destination
			// Gregorian
<span class="fc" id="L2709">			Calendar gc = Calendar.getInstance(pCampaign.getTimeZone()),</span>
<span class="fc" id="L2710">					gc2 = Calendar.getInstance(pCampaign.getTimeZone());</span>

<span class="fc" id="L2712">			String query = &quot;SELECT NAME,VALUE FROM BPCONFIG WHERE NAME = \'COPYSHIFTCHUNKSIZE\'&quot;;</span>
<span class="fc" id="L2713">			JdmoRowset r = dmo.createRowset(query);</span>
			// CHUNKSIZE is configurable. Insert 'COPYSHIFTCHUNKSIZE','size' in
			// BPCONFIG table where size is a no. like 100.
<span class="pc bpc" id="L2716" title="1 of 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L2717">				String sKey = r.getString(&quot;NAME&quot;);</span>
<span class="nc" id="L2718">				String sValue = r.getString(&quot;VALUE&quot;);</span>
<span class="nc bnc" id="L2719" title="All 2 branches missed.">				if (sValue.length() != 0) {</span>
<span class="nc" id="L2720">					CHUNKSIZE = Integer.parseInt(sValue);</span>
				}
<span class="nc" id="L2722">			}</span>
<span class="fc" id="L2723">			Iterator iterWSCol = cidWorkResources.iterator();</span>

			// Start of chunking loop
<span class="fc bfc" id="L2726" title="All 2 branches covered.">			for (int nChunk = 0; nChunk * CHUNKSIZE &lt; cidWorkResources.size(); nChunk++) {</span>
<span class="fc" id="L2727">				int nStart = nChunk * CHUNKSIZE;</span>
<span class="fc" id="L2728">				int nEnd = nStart + CHUNKSIZE;</span>

<span class="fc" id="L2730">				HashSet cidSubSetWorkResources = new HashSet();</span>
<span class="pc bpc" id="L2731" title="1 of 4 branches missed.">				while (iterWSCol.hasNext() &amp;&amp; nStart &lt; nEnd) {</span>
<span class="fc" id="L2732">					ID idEmployee = (ID) iterWSCol.next();</span>
<span class="fc" id="L2733">					cidSubSetWorkResources.add(idEmployee);</span>
<span class="fc" id="L2734">					nStart++;</span>
<span class="fc" id="L2735">				}</span>

<span class="fc" id="L2737">				Collection cNewShiftAssignments = new LinkedList();</span>
<span class="fc" id="L2738">				Collection cSourceShiftAssignments = getSourceShiftAssignments(isPartialWeek, cidSubSetWorkResources,</span>
						tz, sourceWeekStart, targetWeekStart, sourceWeekEnd, targetWeekEnd);

				// get events in future week
<span class="fc" id="L2742">				Collection cUnavailabilities = getUnavailabilities(isPartialWeek, cidSubSetWorkResources, tz,</span>
						sourceWeekStart, targetWeekStart, sourceWeekEnd, targetWeekEnd);

				// copy shift assignments which are locked, have the source SP
				// id,
				// and which don't overlap unavailability or Shift Assignments
				// increment start time on shift assignments and shift event
				// assignments
<span class="fc" id="L2750">				Iterator u = cUnavailabilities.iterator();</span>
<span class="fc" id="L2751">				Iterator o = cEmployeeOrgIDs.iterator();</span>
<span class="fc" id="L2752">				HashMap empId2termDate = null; // termination date, or &quot;undef&quot;</span>
												// if
				// unknown
<span class="fc bfc" id="L2755" title="All 2 branches covered.">				for (Iterator i = cSourceShiftAssignments.iterator(); i.hasNext();) {</span>
<span class="fc" id="L2756">					Collection cWorkResourceShiftAssignments = (Collection) i.next();</span>
<span class="fc" id="L2757">					Collection cWorkResourceUnavailabilities = (Collection) u.next();</span>
<span class="fc" id="L2758">					ID idOrganization = (ID) o.next();</span>
<span class="pc bpc" id="L2759" title="1 of 4 branches missed.">					if (cWorkResourceShiftAssignments == null || idOrganization == null) {</span>
<span class="nc" id="L2760">						continue;</span>
					}
<span class="fc bfc" id="L2762" title="All 2 branches covered.">					for (Iterator j = cWorkResourceShiftAssignments.iterator(); j.hasNext();) {</span>
<span class="fc" id="L2763">						ShiftAssignment shToCopy = (ShiftAssignment) j.next();</span>
						// couple of quick tests before cloning
<span class="fc bfc" id="L2765" title="All 2 branches covered.">						if (!shToCopy.isLocked()) {</span>
<span class="fc" id="L2766">							continue;</span>
						}
<span class="pc bpc" id="L2768" title="3 of 6 branches missed.">						if (shToCopy.getCampaignID() != null &amp;&amp; !(shToCopy.getCampaignID().equals(idSourceSP))</span>
<span class="pc bpc" id="L2769" title="1 of 2 branches missed.">								&amp;&amp; (idSourceSPParent == null || !(shToCopy.getCampaignID().equals(idSourceSPParent)))) {</span>
<span class="nc" id="L2770">							continue;</span>
						}
						// Shift Assignments should not be copied
						// if they begin after the Employee's termination date
						// Assuming there is just one workResourceID per
						// shiftAssignment
<span class="fc" id="L2776">						ID agentID = shToCopy.getWorkResourceIDs().iterator().next();</span>
<span class="fc" id="L2777">						TimeZone agentTZ = findTimeZone((Collection) (orgAssignmentWithTZ.get(agentID)),</span>
<span class="fc" id="L2778">								sourceWeekStart, pCampaign.getTimeZone());</span>
<span class="fc" id="L2779">						gc.setTimeZone(agentTZ);</span>
<span class="fc" id="L2780">						gc.setTime(shToCopy.getStartTime());</span>
<span class="fc" id="L2781">						gc.add(Calendar.DATE, lTimeDeltaDays);</span>
						// long newStartTime= shToCopy.getStartTime().getTime()
						// +
						// lTimeDelta;
<span class="fc" id="L2785">						Date newStartTime = gc.getTime();</span>
						// fix QC57855
<span class="fc" id="L2787">						int dstDelta = newStartTime.getTimezoneOffset() - shToCopy.getStartTime().getTimezoneOffset();</span>
<span class="pc bpc" id="L2788" title="1 of 2 branches missed.">						if (dstDelta != 0) {</span>
<span class="nc" id="L2789">							gc.add(Calendar.MINUTE, dstDelta);</span>
<span class="nc" id="L2790">							newStartTime = gc.getTime();</span>
						}

<span class="fc bfc" id="L2793" title="All 2 branches covered.">						if (empId2termDate == null) {</span>
<span class="fc" id="L2794">							empId2termDate = new HashMap();</span>
						}
<span class="fc" id="L2796">						Object termDateOb = empId2termDate.get(agentID);</span>
<span class="pc bpc" id="L2797" title="1 of 2 branches missed.">						if (termDateOb == null) { // not in map yet</span>
<span class="fc" id="L2798">							Employee agent = m_workResourceManager.getEmployeeByID(agentID, null, 0);</span>
<span class="fc" id="L2799">							termDateOb = agent.getEndTime(); // termination</span>
																// date,
							// can be null
<span class="pc bpc" id="L2802" title="1 of 2 branches missed.">							empId2termDate.put(agentID, termDateOb == null ? &quot;undef&quot; : termDateOb);</span>
						}
<span class="pc bpc" id="L2804" title="3 of 4 branches missed.">						if (termDateOb != null &amp;&amp; termDateOb instanceof Date</span>
<span class="nc bnc" id="L2805" title="All 2 branches missed.">								&amp;&amp; ((Date) termDateOb).before(newStartTime)) {</span>
							// out
							// due
							// to
							// the
							// end
							// of
							// employment
<span class="nc" id="L2813">							continue;</span>
						}

<span class="fc" id="L2816">						ShiftAssignment pShiftAssignment = (ShiftAssignment) shToCopy.cloneForPublishing();</span>
<span class="fc" id="L2817">						pShiftAssignment.setStartTime(newStartTime);</span>
<span class="fc" id="L2818">						gc2.setTimeZone(agentTZ);</span>
<span class="fc" id="L2819">						gc2.setTime(shToCopy.getEndTime());</span>
<span class="fc" id="L2820">						gc2.add(Calendar.DATE, lTimeDeltaDays);</span>
<span class="fc" id="L2821">						int duration = (int) ((gc2.getTime().getTime() - newStartTime.getTime())</span>
<span class="fc" id="L2822">								/ (ShiftAssignment.MILLIS_IN_ONE_MIN)), oldDuration = shToCopy.getDuration();</span>
<span class="pc bpc" id="L2823" title="1 of 2 branches missed.">						if (duration &lt;= 0) {</span>
							// transition
<span class="nc" id="L2825">							duration = oldDuration;</span>
						}
<span class="pc bpc" id="L2827" title="1 of 2 branches missed.">						if (duration != oldDuration) {</span>
<span class="nc" id="L2828">							m_cat.info(&quot;DST changed the duration from &quot; + oldDuration + &quot; to &quot; + duration + &quot; for:&quot;</span>
<span class="nc" id="L2829">									+ pShiftAssignment.toString());</span>
						}
<span class="fc" id="L2831">						pShiftAssignment.setDuration(duration);</span>
<span class="fc" id="L2832">						moveShiftEventAssignmentsToTargetWeek(lTimeDeltaDays, gc, pShiftAssignment, duration,</span>
								oldDuration);
<span class="fc" id="L2834">						setSpOfShiftEventAssignments(pShiftAssignment, idDestinationSP);</span>

<span class="pc bpc" id="L2836" title="1 of 2 branches missed.">						if (!intersectsEvent(pShiftAssignment, cWorkResourceUnavailabilities,</span>
<span class="fc" id="L2837">								(Organization) hOrgs.get(idOrganization))) {</span>
<span class="fc" id="L2838">							pShiftAssignment.setCampaignID(idDestinationSP);</span>
                            
                            //F&amp;S on the Web hangs at 64% (Saving Schedule). - ESR#4038996
<span class="fc bfc" id="L2841" title="All 2 branches covered.">                            for (ShiftEventAssignment shiftEvent : pShiftAssignment.getChildren()) {</span>
<span class="fc" id="L2842">                            	shiftEvent.setSPID(null);</span>
<span class="fc" id="L2843">                            }</span>
                            
<span class="fc" id="L2845">							cNewShiftAssignments.add(pShiftAssignment);</span>
						}
<span class="fc" id="L2847">					}</span>
<span class="fc" id="L2848">				}</span>
<span class="fc" id="L2849">				createShiftAssignments(cNewShiftAssignments);</span>
			} // end of chunking loop
<span class="nc" id="L2851">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2852">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L2853">			throw e;</span>
<span class="nc" id="L2854">		} catch (Exception e) {</span>
<span class="nc" id="L2855">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L2856">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc bpc" id="L2858" title="5 of 6 branches missed.">			if (dmo != null) {</span>
<span class="pc" id="L2859">				dmo.cleanUp();</span>
			}
<span class="pc" id="L2861">			methodFinish();</span>
<span class="fc" id="L2862">		}</span>
<span class="fc" id="L2863">	}</span>

	/**
	 * Returns the week end date for given week start date. The week end date
	 * will be the next week start date or SP end date (whichever comes first).
	 * It must be different to the given date (unless the given date is SP end
	 * date).
	 *
	 * @param weekStart
	 *            week start date
	 * @param sp
	 *            SP which this week belongs to
	 * @param campaign
	 *            campaign of this SP
	 * @param useGMTForNonMonthlySPCalculation
	 *            flag to indicate if calculation for non-monthly SP should use
	 *            GMT timezone (otherwise use campaign time zone)
	 * @return Returns the week end date for given week start date
	 */
	private Date getWeekEnd(Date weekStart, SchedulingPeriod sp, Campaign campaign,
			boolean useGMTForNonMonthlySPCalculation) {
		Date sourceWeekEnd;
<span class="pc bpc" id="L2885" title="1 of 2 branches missed.">		if (campaign.isMonthly()) {</span>
<span class="nc" id="L2886">			sourceWeekEnd = MonthlySPUtil.getWeekEndDate(campaign.getTimeZone(), weekStart,</span>
<span class="nc" id="L2887">					MonthlySPUtil.getWeekStartDay(campaign.getWeekStart()), sp.getEndTime());</span>
		} else {
<span class="fc bfc" id="L2889" title="All 2 branches covered.">			if (useGMTForNonMonthlySPCalculation) {</span>
				// TODO: Not sure why we want to use GMT time zone (maybe a
				// bug?). This logic is refactored from copyEffectiveDates()
				// method
<span class="fc" id="L2893">				sourceWeekEnd = TimeZoneUtil.addWeek(weekStart);</span>
			} else {
<span class="fc" id="L2895">				sourceWeekEnd = TimeZoneUtil.addWeek(weekStart, campaign.getTimeZone());</span>
			}
		}
<span class="fc" id="L2898">		return sourceWeekEnd;</span>
	}

	private Collection getUnavailabilities(boolean isPartialWeek, Set workResources, TimeZone tz, Date sourceWeekStart,
			Date targetWeekStart, Date sourceWeekEnd, Date targetWeekEnd) throws BbmFinderException {
		Date start;
		Date end;
<span class="pc bpc" id="L2905" title="1 of 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L2906">			Date[] targetWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, targetWeekStart,</span>
					targetWeekEnd, sourceWeekStart, sourceWeekEnd);
<span class="nc" id="L2908">			start = targetWeekCopiableRange[0];</span>
<span class="nc" id="L2909">			end = targetWeekCopiableRange[1];</span>
<span class="nc" id="L2910">		} else {</span>
<span class="fc" id="L2911">			start = targetWeekStart;</span>
<span class="fc" id="L2912">			end = targetWeekEnd;</span>
		}
		// widen the select range up and down one day.
<span class="fc" id="L2915">		Calendar gc = Calendar.getInstance(tz);</span>
<span class="fc" id="L2916">		gc.setTime(start);</span>
<span class="fc" id="L2917">		gc.add(Calendar.DATE, -1);</span>
<span class="fc" id="L2918">		start = gc.getTime();</span>
<span class="fc" id="L2919">		gc.setTime(end);</span>
<span class="fc" id="L2920">		gc.add(Calendar.DATE, 1);</span>
<span class="fc" id="L2921">		end = gc.getTime();</span>
<span class="fc" id="L2922">		Collection cUnavailabilities = getEventsForWorkResourcesByType(</span>
				Event.EVENT_TYPE_UNAVAILABILITY | Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources, start, end);
<span class="fc" id="L2924">		return cUnavailabilities;</span>
	}

	private Collection getSourceShiftAssignments(boolean isPartialWeek, Set workResources, TimeZone tz,
			Date sourceWeekStart, Date targetWeekStart, Date sourceWeekEnd, Date targetWeekEnd)
			throws BbmFinderException {
		// get source shift assignments
		Collection cSourceShiftAssignments;
<span class="pc bpc" id="L2932" title="1 of 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L2933">			Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
					sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc" id="L2935">			cSourceShiftAssignments = getEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources,</span>
					sourceWeekCopiableRange[0], sourceWeekCopiableRange[1]);
<span class="nc" id="L2937">		} else {</span>
<span class="fc" id="L2938">			cSourceShiftAssignments = getEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources,</span>
					sourceWeekStart, sourceWeekEnd);
		}
<span class="fc" id="L2941">		return cSourceShiftAssignments;</span>
	}

	private int getTimeDeltaDays(TimeZone tz, boolean isPartialWeek, Date sourceWeekStart, Date targetWeekStart,
			Date sourceWeekEnd, Date targetWeekEnd) {
		int lTimeDeltaDays;
<span class="pc bpc" id="L2947" title="1 of 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L2948">			Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
					sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc" id="L2950">			Date[] targetWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, targetWeekStart,</span>
					targetWeekEnd, sourceWeekStart, sourceWeekEnd);
<span class="nc" id="L2952">			lTimeDeltaDays = MonthlySPUtil.getDaysBetween(tz, sourceWeekCopiableRange[0], targetWeekCopiableRange[0]);</span>
<span class="nc" id="L2953">		} else {</span>
<span class="fc" id="L2954">			long lTimeDelta = targetWeekStart.getTime() - sourceWeekStart.getTime();</span>
			// we should not just use time delta b/c of DST transition.
			// If a Shift Assignment crosses the DST boundary and is cloned
			// to a future Week, the start time and end time should be
			// the same on both the week with the DST boundary and
			// the week it was cloned into. This means the duration may need to
			// change.
			// For example, a Shift Assignment starts at 1 AM and ends at 9 AM
			// on the day where there is an extra hour due to DST.
			// The Shift Assignment is 9 hours long. When cloned into another
			// week,
			// the Shift Assignment should still start at 1 AM and end at 9 AM,
			// but now is only 8 hours long.
<span class="fc" id="L2967">			lTimeDeltaDays = Math.round((float) lTimeDelta / (60 * 60 * 1000 * 24));</span>
		}
<span class="fc" id="L2969">		return lTimeDeltaDays;</span>
	}

	static void setSpOfShiftEventAssignments(ShiftAssignment shiftAssignment, ID destinationSpId) {
<span class="fc" id="L2973">		Collection&lt;ShiftEventAssignment&gt; eventAssignments = shiftAssignment</span>
<span class="fc" id="L2974">				.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="pc bpc" id="L2975" title="2 of 4 branches missed.">		if (eventAssignments != null &amp;&amp; !eventAssignments.isEmpty()) {</span>
<span class="fc bfc" id="L2976" title="All 2 branches covered.">			for (ShiftEventAssignment eventAssignment : eventAssignments) {</span>
<span class="fc" id="L2977">				eventAssignment.setSPID(destinationSpId);</span>
<span class="fc" id="L2978">			}</span>
		}
<span class="fc" id="L2980">	}</span>

	private static void moveShiftEventAssignmentsToTargetWeek(int lTimeDeltaDays, Calendar gc,
			ShiftAssignment pShiftAssignment, int duration, int oldDuration) {
<span class="pc bpc" id="L2984" title="1 of 2 branches missed.">		if (pShiftAssignment.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT) != null) {</span>
<span class="fc" id="L2985">			for (Iterator&lt;ShiftEventAssignment&gt; iter = pShiftAssignment</span>
<span class="fc bfc" id="L2986" title="All 2 branches covered.">					.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT).iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2987">				ShiftEventAssignment pShiftEventAssignment = iter.next();</span>
<span class="fc" id="L2988">				gc.setTime(pShiftEventAssignment.getStartTime());</span>
<span class="fc" id="L2989">				gc.add(Calendar.DATE, lTimeDeltaDays);</span>
<span class="fc" id="L2990">				pShiftEventAssignment.setStartTime(gc.getTime());</span>
<span class="pc bpc" id="L2991" title="1 of 2 branches missed.">				if (duration != oldDuration</span>
<span class="nc bnc" id="L2992" title="All 2 branches missed.">						&amp;&amp; (!isShiftEventContainedInShiftAssignment(pShiftEventAssignment, pShiftAssignment)</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">								|| doesEventOverlapOtherEventsInShiftAssignment(pShiftEventAssignment,</span>
										pShiftAssignment))) {
<span class="nc" id="L2995">					iter.remove();</span>
				}
<span class="fc" id="L2997">			}</span>
		}
<span class="fc" id="L2999">	}</span>

	static boolean isShiftEventContainedInShiftAssignment(ShiftEventAssignment eventToCheck,
			ShiftAssignment shiftToCheck) {
<span class="nc" id="L3003">		return TimePeriodUtil.inside(eventToCheck.getStartTime(), eventToCheck.getEndTime(),</span>
<span class="nc" id="L3004">				shiftToCheck.getStartTime(), shiftToCheck.getEndTime());</span>
	}

	static boolean doesEventOverlapOtherEventsInShiftAssignment(ShiftEventAssignment eventToCheck,
			ShiftAssignment shiftToCheck) {

<span class="nc bnc" id="L3010" title="All 2 branches missed.">		for (ShiftEventAssignment eventAssignment : (Collection&lt;ShiftEventAssignment&gt;) shiftToCheck</span>
<span class="nc" id="L3011">				.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT)) {</span>
<span class="nc bnc" id="L3012" title="All 2 branches missed.">			if (eventToCheck.getID().equals(eventAssignment.getID())) {</span>
<span class="nc" id="L3013">				continue;</span>
			}

<span class="nc bnc" id="L3016" title="All 2 branches missed.">			if (checkEventsForOverlap(eventToCheck, eventAssignment)) {</span>
<span class="nc" id="L3017">				return true;</span>
			}
<span class="nc" id="L3019">		}</span>

<span class="nc" id="L3021">		return false;</span>
	}

	/**
	 * Events are determined to overlap if their time ranges (determined by
	 * their start and end times) overlap AND they have the same overlay
	 * precedence.
	 *
	 * @param event1
	 * @param event2
	 * @return
	 */
	static boolean checkEventsForOverlap(ShiftEventAssignment event1, ShiftEventAssignment event2) {
<span class="nc bnc" id="L3034" title="All 2 branches missed.">		if (event1.getOverlayPrecedence() == event2.getOverlayPrecedence() &amp;&amp; TimePeriodUtil</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">				.overlap(event1.getStartTime(), event1.getEndTime(), event2.getStartTime(), event2.getEndTime())) {</span>
<span class="nc" id="L3036">			return true;</span>
		}
<span class="nc" id="L3038">		return false;</span>
	}

	private static TimeZone findTimeZone(Collection orgAssignments, Date timeSpot, TimeZone defaultTZ) {
<span class="pc bpc" id="L3042" title="2 of 4 branches missed.">		if (orgAssignments == null || orgAssignments.isEmpty()) {</span>
<span class="nc" id="L3043">			return defaultTZ;</span>
		}

<span class="fc" id="L3046">		WorkResourceAssignment wra = WorkResourceAssignment.getRelatedWRAssignment(orgAssignments, timeSpot);</span>
<span class="pc bpc" id="L3047" title="2 of 4 branches missed.">		if (wra == null || wra.getStartTimeZone() == null) {</span>
<span class="nc" id="L3048">			return defaultTZ;</span>
		}

<span class="fc" id="L3051">		return wra.getStartTimeZone();</span>
	}

	public void copyShiftAssignments(ID idSourceSP, ID idDestinationSP, boolean bClearDestinationSP)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L3056" title="All 2 branches missed.">		methodStart(&quot;copyShiftAssignments&quot;, idSourceSP, idDestinationSP,</span>
				bClearDestinationSP ? Boolean.TRUE : Boolean.FALSE);
		try {
<span class="nc" id="L3059">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="nc" id="L3060">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>
<span class="nc" id="L3061">			copyShiftAssignments(idSourceSP, pSourceSP.getStartTime(), idDestinationSP, pDestinationSP.getStartTime(),</span>
					bClearDestinationSP);
<span class="nc" id="L3063">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3064">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L3065">			throw e;</span>
<span class="nc" id="L3066">		} catch (Exception e) {</span>
<span class="nc" id="L3067">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L3068">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3070">			methodFinish();</span>
<span class="nc" id="L3071">		}</span>

<span class="nc" id="L3073">	}</span>

	public void unlockShiftAssignmentsByIDs(Collection cShiftAssignmentIDs, Collection cWorkResourceIDs, Date dtStart,
			Date dtEnd, boolean bUnlockShiftEventsOnly) throws BbmUpdateException {
		// Jason: this is a last minute addition to address a customer issue, it
		// should be refactored later
		// 1) the lock method should be given a similar interface
		// 2) the is in synch with published state flags/audit trail should be
		// update
		// 3) cWorkResourceIDs,dtStart, and dtEnd are only used for logging and
		// lock checking

<span class="nc bnc" id="L3085" title="All 2 branches missed.">		methodStart(&quot;unlockShiftAssignmentsByIDs&quot;, cShiftAssignmentIDs,</span>
				bUnlockShiftEventsOnly ? Boolean.TRUE : Boolean.FALSE);

<span class="nc" id="L3088">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3090">			m_eventHandler.preUnlockEvents(cWorkResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L3091">			dao.unlockShiftAssignmentsByIDs(cShiftAssignmentIDs, bUnlockShiftEventsOnly);</span>
<span class="nc" id="L3092">			m_eventHandler.postUnlockEvents(cWorkResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L3093">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3094">			handleException(e);</span>
<span class="nc" id="L3095">			throw e;</span>
<span class="nc" id="L3096">		} catch (Exception e) {</span>
<span class="nc" id="L3097">			handleException(e);</span>
<span class="nc" id="L3098">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L3100" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L3101">				dao.cleanUp();</span>
			}
<span class="nc" id="L3103">			methodFinish();</span>
<span class="nc" id="L3104">		}</span>
<span class="nc" id="L3105">	}</span>

	/**
	 * This is an internal helper method that returns the DAO class that
	 * persists event template objects of a given type
	 */
	private AggEventTemplateDAO getDAOByEventTemplateType(short templateType, Jdmo dmo) {
<span class="fc" id="L3112">		AggEventTemplateDAO dao = null;</span>
<span class="pc bpc" id="L3113" title="2 of 3 branches missed.">		switch (templateType) {</span>
		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING:
		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING:
<span class="nc" id="L3116">			dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L3117">			break;</span>

		case CalendarEventTemplate.EVENT_TEMPLATE_FLOATING:
<span class="fc" id="L3120">			dao = new FloatingEventTemplateDAO(dmo);</span>
			break;
		}
<span class="fc" id="L3123">		return dao;</span>
	}

	/**
	 * This is an internal helper method that returns the Calendar Event
	 * Template Type persists event template objects of a given ID
	 */
	private short getCalendarEventTemplateTypeByID(ID templateID, Jdmo dmo) throws BbmFinderException {
<span class="fc" id="L3131">		CalendarEventTemplateDAO dao = new CalendarEventTemplateDAO(dmo);</span>
<span class="fc" id="L3132">		return dao.getTemplateTypeByID(templateID);</span>
	}

	/**
	 * This is an internal helper method that returns the DAO class that
	 * persists event template objects of a given ID
	 */
	private AggEventTemplateDAO getDAOByEventTemplateID(ID templateID, Jdmo dmo) throws BbmFinderException {
<span class="fc" id="L3140">		return getDAOByEventTemplateType(getCalendarEventTemplateTypeByID(templateID, dmo), dmo);</span>
	}

	/**
	 * This is an override of the base class method to initialize the per-EJB
	 * method cache
	 */
	@Override
	protected void methodStartHelper(String methodName, Object[] params) {
		/** @todo: maybe add the value of m_isWhatIf to each log message ? */
		/* call the base class */
<span class="fc" id="L3151">		super.methodStartHelper(methodName, params);</span>
		/*
		 * initialize the per-method cache only if we are the first method on
		 * the stack trace
		 */
<span class="fc bfc" id="L3156" title="All 2 branches covered.">		if (m_stackTrace.size() == 1) {</span>
<span class="fc" id="L3157">			CachePerEJBMethod cache = CachePerEJBMethod.newCache(this);</span>
		}
<span class="fc" id="L3159">	}</span>

	/**
	 * This is an override of the base class method to clean up the per-EJB
	 * method cache
	 */
	@Override
	protected void methodFinish() {
		/* call the base class */
<span class="fc" id="L3168">		super.methodFinish();</span>
		/*
		 * destroy the cash, we no longer need it since we are exiting the
		 * method
		 */
<span class="fc bfc" id="L3173" title="All 2 branches covered.">		if (m_stackTrace.isEmpty()) {</span>
<span class="fc" id="L3174">			CachePerEJBMethod.deleteCache();</span>
		}
<span class="fc" id="L3176">	}</span>

	/**
	 * These methods has package scope
	 */
	WorkResourceManager getWorkResourceManager() {
<span class="fc" id="L3182">		return m_workResourceManager;</span>
	}

	ActivityManager getActivityManager() {
<span class="fc" id="L3186">		return m_activityManager;</span>
	}

	EventAuditTrailManager getEventAuditTrailManager() {
<span class="nc" id="L3190">		return m_auditManager;</span>
	}

	ScheduleEventHandler getEventHandler() {
<span class="fc" id="L3194">		return m_eventHandler;</span>
	}

	/**
	 * Returns a list (an ordered collection) of collections of event templates
	 * for multiple workresources from their current (non-published) schedules.
	 * For each work resource ID in the method argument, there will be a
	 * corresponding collection of events in the return collection - maybe,
	 * empty, if there is no event template associated with that ID. The
	 * returned collections of events will be in the same order as the
	 * workresource IDs in the 1st method argument.
	 *
	 * @param workResourceIDs
	 *            IDs of the workresources
	 * @param dtStart
	 *            start of the desired time interval
	 * @param dtEnd
	 *            end of the desired time interval
	 * @return collection of ArrayLists of event templates
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List getEventTemplatesForWorkResourceIDs(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L3218">		methodStart(&quot;getEventTemplatesForWorkResourceIDs&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3219">		Jdmo dmo1 = new Jdmo(), dmo2 = new Jdmo(); // not sure if we can use the</span>
		// same dmo for two selects
		try {
<span class="fc" id="L3222">			FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo1);</span>
<span class="fc" id="L3223">			Collection flEvTemplates = dao1.getAllEventTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3224">			RecurringEventTemplateDAO dao2 = new RecurringEventTemplateDAO(dmo2);</span>
<span class="fc" id="L3225">			Collection recEvTemplates = dao2.getAllEventTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3226">			return ScheduleDAOUtil.combineTemplateCollections(workResourceIDs, flEvTemplates, recEvTemplates);</span>
<span class="nc" id="L3227">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3228">			handleException(e);</span>
<span class="nc" id="L3229">			throw e;</span>
		} finally {
<span class="pc" id="L3231">			dmo1.cleanUp();</span>
<span class="pc" id="L3232">			dmo2.cleanUp();</span>
<span class="pc" id="L3233">			methodFinish();</span>
		}
	} /* end of getEventTemplatesForWorkResourceIDs */

	/**
	 * Returns a list (an ordered collection) of collections of calendar event
	 * assignments for multiple event templates. For each calendar event
	 * template ID in the method argument, there will be a corresponding
	 * collection of calendar event assignments in the return collection -
	 * maybe, empty, if there is no assignment associated with that ID. The
	 * returned collections of events will be in the same order as the calendar
	 * event template IDs in the method argument.
	 *
	 * @param cidEventTemplates
	 *            IDs of the calendar event templates
	 * @return collection of ArrayLists of calendar event assignments
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getCalendarEventAssignmentsForCalendarEventTemplate(
			Collection&lt;ID&gt; cidEventTemplates) throws BbmFinderException {
<span class="fc" id="L3254">		methodStart(&quot;getCalendarEventAssignmentsForCalendarEventTemplate&quot;, cidEventTemplates);</span>
<span class="fc" id="L3255">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L3257">			CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="fc" id="L3258">			StringBuffer strSQL = new StringBuffer(100);</span>
<span class="fc" id="L3259">			strSQL.append(&quot; A.CALENDAREVENTTEMPLATEID IN &quot;);</span>
			try {
<span class="fc" id="L3261">				strSQL.append(dao.getDMO().createInClause(cidEventTemplates));</span>
<span class="fc" id="L3262">				Collection&lt;CalendarEventAssignment&gt; events = dao.getObjects(strSQL.toString());</span>
<span class="fc" id="L3263">				return ScheduleDAOUtil.reorderEventsByTemplateIds(cidEventTemplates, events);</span>
<span class="nc" id="L3264">			} catch (JdmoException e) {</span>
<span class="nc" id="L3265">				throw new BbmFinderException(e);</span>
			}
<span class="nc" id="L3267">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3268">			handleException(e);</span>
<span class="nc" id="L3269">			throw e;</span>
		} finally {
<span class="pc" id="L3271">			dmo.cleanUp();</span>
<span class="pc" id="L3272">			methodFinish();</span>
		}
	} /* end of getCalendarEventAssignmentsForCalendarEventTemplate */

	/**
	 * Returns a list of all RecurringEventTemplates for multiple workresources
	 * from their current (non-published) schedules.
	 *
	 * @param workResourceIDs
	 *            IDs of the workresources
	 * @param dtStart
	 *            start of the desired time interval
	 * @param dtEnd
	 *            end of the desired time interval
	 * @return collection of RecurringEventTemplates
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List getAllRecurringEventTemplatesForPostMigration(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L3292">		RecurringEventTemplateDAO daoTemplate = new RecurringEventTemplateDAO();</span>
		try {
<span class="nc" id="L3294">			Collection res = daoTemplate.getAllEventTemplatesForWorkResourcesForPostMigration(workResourceIDs, dtStart,</span>
					dtEnd);
			// should be a list already, so it is just casting, not a copying
<span class="nc bnc" id="L3297" title="All 2 branches missed.">			return res instanceof List ? (List) res : new ArrayList(res);</span>
		} finally {
<span class="nc" id="L3299">			daoTemplate.cleanUp();</span>
		}
	}

	public void unlinkShiftAssignmentFromCampaign(Collection workResourceIDs, ID spID)
			throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3305">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, workResourceIDs, spID);</span>
<span class="nc" id="L3306">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3308">			dao.unlinkShiftAssignmentFromCampaign(workResourceIDs, spID);</span>
<span class="nc" id="L3309">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3310">			handleException(e);</span>
<span class="nc" id="L3311">			throw e;</span>
<span class="nc" id="L3312">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3313">			handleException(e);</span>
<span class="nc" id="L3314">			throw e;</span>
<span class="nc" id="L3315">		} catch (Exception e) {</span>
<span class="nc" id="L3316">			handleException(e);</span>
<span class="nc" id="L3317">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3319">			dao.cleanUp();</span>
<span class="nc" id="L3320">			methodFinish();</span>
<span class="nc" id="L3321">		}</span>
<span class="nc" id="L3322">	}</span>

	public void unlinkShiftAssignmentFromCampaign(Collection shiftAssignmentIDs)
			throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3326">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, shiftAssignmentIDs);</span>
<span class="nc" id="L3327">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3329">			dao.unlinkShiftAssignmentFromCampaign(shiftAssignmentIDs);</span>
<span class="nc" id="L3330">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3331">			handleException(e);</span>
<span class="nc" id="L3332">			throw e;</span>
<span class="nc" id="L3333">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3334">			handleException(e);</span>
<span class="nc" id="L3335">			throw e;</span>
<span class="nc" id="L3336">		} catch (Exception e) {</span>
<span class="nc" id="L3337">			handleException(e);</span>
<span class="nc" id="L3338">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3340">			dao.cleanUp();</span>
<span class="nc" id="L3341">			methodFinish();</span>
<span class="nc" id="L3342">		}</span>
<span class="nc" id="L3343">	}</span>

	public void unlinkShiftAssignmentFromCampaign(ID orgID, ID spID) throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3346">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, orgID, spID);</span>
<span class="nc" id="L3347">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3349">			dao.unlinkShiftAssignmentFromCampaign(orgID, spID);</span>
<span class="nc" id="L3350">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3351">			handleException(e);</span>
<span class="nc" id="L3352">			throw e;</span>
<span class="nc" id="L3353">		} catch (MultiUserException e) {</span>
<span class="nc" id="L3354">			handleException(e);</span>
<span class="nc" id="L3355">			throw e;</span>
<span class="nc" id="L3356">		} catch (Exception e) {</span>
<span class="nc" id="L3357">			handleException(e);</span>
<span class="nc" id="L3358">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3360">			dao.cleanUp();</span>
<span class="nc" id="L3361">			methodFinish();</span>
<span class="nc" id="L3362">		}</span>
<span class="nc" id="L3363">	}</span>

	public void unlinkShiftAssignmentFromCampaign(ID spID) throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3366">		unlinkShiftAssignmentFromCampaign((ID) null, spID);</span>
<span class="nc" id="L3367">	}</span>

	// private static int Phantom_Name_ID = 1;

	/*
	 * importedEvents is a two elements array list, first element is a hashmap
	 * of employeeid and skill assignments list pair; second elements are the
	 * list of sorted events - sorted by starttime;
	 */

	public boolean importStaffingProfiles(ID orgID, ID campaignID, ArrayList importedEvents, Date start, Date end)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3379">		methodStart(&quot;importStaffingProfiles&quot;, orgID, campaignID, importedEvents);</span>
		// reset static counters
		// Template_Name_ID = 1;
<span class="nc" id="L3382">		Phantom_Name = 1;</span>
		try {
			// get existing employee templates for the specific org including
			// skill assignments
<span class="nc" id="L3386">			Collection templates = getEmployeeTemplatesInOrg(orgID);</span>

			// refactor importedEvents map, replace skill assignment list to
			// template id.
<span class="nc" id="L3390">			HashMap skillMap = (HashMap) importedEvents.get(0);</span>
<span class="nc" id="L3391">			replaceSkillSetWithTemplateID(skillMap, orgID, templates);</span>

			// get campaign weeks linked to the specified org during the start
			// and end
<span class="nc" id="L3395">			Collection weeks = m_pCampaignManager.getSchedulingPeriods(campaignID, orgID, start, end);</span>
<span class="nc" id="L3396">			Collections.sort((ArrayList) weeks);</span>

<span class="nc" id="L3398">			ArrayList events = (ArrayList) importedEvents.get(1);</span>
<span class="nc" id="L3399">			Collections.sort(events);</span>

<span class="nc" id="L3401">			int ix = 0;</span>
<span class="nc" id="L3402">			int sizeOfEvents = events.size();</span>
<span class="nc" id="L3403">			Event event = null;</span>
<span class="nc" id="L3404">			HashMap workResourcePhantomIDMap = new HashMap();</span>
<span class="nc" id="L3405">			Collection attendees = null;</span>
<span class="nc" id="L3406">			Collection phantomIDs = null;</span>
<span class="nc" id="L3407">			ID id = null;</span>
<span class="nc" id="L3408">			ShiftAssignment shift = null;</span>
<span class="nc" id="L3409">			SchedulingPeriod sp = null;</span>
			// Note: both sp list and events list are sorted by start time asc
<span class="nc bnc" id="L3411" title="All 2 branches missed.">			for (Iterator i = weeks.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3412">				sp = (SchedulingPeriod) i.next();</span>
				// clear all profiles in the campaign week that have an Org ID
				// that was present in the export file
<span class="nc" id="L3415">				deletePhantomsWithoutDeleteChildlessTemplate(orgID, sp.getID());</span>

				// get events in this campain week
<span class="nc bnc" id="L3418" title="All 2 branches missed.">				while (ix &lt; sizeOfEvents) {</span>
<span class="nc" id="L3419">					event = (Event) events.get(ix++);</span>
<span class="nc" id="L3420">					tagEventUsingPhantomIDs(event, skillMap, workResourcePhantomIDMap);</span>
<span class="nc bnc" id="L3421" title="All 2 branches missed.">					if (event instanceof ShiftAssignment) {</span>
						// special handle shiftEventAssignment
<span class="nc" id="L3423">						shift = (ShiftAssignment) event;</span>
<span class="nc" id="L3424">						shift.setLocked(true);</span>
<span class="nc" id="L3425">						Collection shiftEvents = shift.getChildren();</span>
<span class="nc bnc" id="L3426" title="All 4 branches missed.">						if (shiftEvents != null &amp;&amp; !shiftEvents.isEmpty()) {</span>
<span class="nc bnc" id="L3427" title="All 2 branches missed.">							for (Iterator ise = shiftEvents.iterator(); ise.hasNext();) {</span>
<span class="nc" id="L3428">								ShiftEventAssignment shiftEvent = (ShiftEventAssignment) ise.next();</span>
<span class="nc" id="L3429">								shiftEvent.setLocked(true);</span>
<span class="nc" id="L3430">								tagEventUsingPhantomIDs(shiftEvent, skillMap, workResourcePhantomIDMap);</span>
<span class="nc" id="L3431">							}</span>
						}
<span class="nc" id="L3433">						createShiftAssignment(shift);</span>
<span class="nc bnc" id="L3434" title="All 2 branches missed.">					} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3435">						((CalendarEventAssignment) event).setLocked(true);</span>
<span class="nc" id="L3436">						createCalendarEventAssignment((CalendarEventAssignment) event);</span>
<span class="nc bnc" id="L3437" title="All 2 branches missed.">					} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3438">						((ImportedEvent) event).setLocked(true);</span>
<span class="nc" id="L3439">						createImportedEvent((ImportedEvent) event);</span>
					}

<span class="nc bnc" id="L3442" title="All 2 branches missed.">					if (ix &lt; sizeOfEvents) {</span>
<span class="nc" id="L3443">						Event nextEvent = (Event) events.get(ix);</span>
<span class="nc bnc" id="L3444" title="All 2 branches missed.">						if (nextEvent.getStartTime().after(sp.getEndTime())) {</span>
<span class="nc" id="L3445">							break;</span>
						}
<span class="nc" id="L3447">					}</span>
				}
				// link phantoms to the current sp
<span class="nc" id="L3450">				m_pCampaignManager.linkWorkResourcesToSchedulingPeriod(sp.getDEID(), workResourcePhantomIDMap.values());</span>
				// belong to next sp.
				// clean up phantom map since phantom only belong to single sp
<span class="nc" id="L3453">				workResourcePhantomIDMap = new HashMap();</span>
			}

			// delete hidden employee template that has no phantoms under it.
			// since this API will leave a lot of
			// garbage employee templates if we don't delete them. By the way,
			// only this code generate hidden
			// employee template for now, so delete them here is safe - 1/10/10
<span class="nc" id="L3461">			deleteChildlessHiddenEmployeeTemplate();</span>

<span class="nc" id="L3463">		} catch (Exception e) {</span>
<span class="nc" id="L3464">			handleException(e);</span>
<span class="nc" id="L3465">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L3467">			methodFinish();</span>
<span class="nc" id="L3468">		}</span>

<span class="nc" id="L3470">		return true;</span>
	}

	private void tagEventUsingPhantomIDs(Event event, HashMap skillMap, HashMap workResourcePhantomIDMap)
			throws Exception {
<span class="nc" id="L3475">		Collection attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L3476">		ArrayList phantomIDs = new ArrayList(attendees.size());</span>
<span class="nc" id="L3477">		ID wkrsID = null;</span>
<span class="nc bnc" id="L3478" title="All 2 branches missed.">		for (Iterator i = attendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3479">			wkrsID = (ID) i.next();</span>
			// i.remove();
<span class="nc" id="L3481">			phantomIDs.add(getOrCreatePhantom(wkrsID, skillMap, workResourcePhantomIDMap));</span>
		}

<span class="nc" id="L3484">		cleanOldAttendees(event);</span>

<span class="nc" id="L3486">		ID phantomID = null;</span>
<span class="nc bnc" id="L3487" title="All 2 branches missed.">		for (Iterator i = phantomIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3488">			phantomID = (ID) i.next();</span>
<span class="nc bnc" id="L3489" title="All 2 branches missed.">			if (event instanceof ShiftAssignment) {</span>
<span class="nc" id="L3490">				((ShiftAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3491" title="All 2 branches missed.">			} else if (event instanceof ShiftEventAssignment) {</span>
<span class="nc" id="L3492">				((ShiftEventAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3493" title="All 2 branches missed.">			} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3494">				((CalendarEventAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">			} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3496">				((ImportedEvent) event).addWorkResourceID(phantomID);</span>
			}
		}
<span class="nc" id="L3499">	}</span>

	// should add removeWorkResourceID into event interface, but it might have
	// too much
	// affect to other areas if we change it now, maybe later.
	private void cleanOldAttendees(Event event) {
<span class="nc" id="L3505">		Collection attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L3506">		ID wkrsID = null;</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">		for (Iterator i = attendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3508">			wkrsID = (ID) i.next();</span>
<span class="nc bnc" id="L3509" title="All 2 branches missed.">			if (event instanceof ShiftAssignment) {</span>
<span class="nc" id="L3510">				((ShiftAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3511" title="All 2 branches missed.">			} else if (event instanceof ShiftEventAssignment) {</span>
<span class="nc" id="L3512">				((ShiftEventAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3513" title="All 2 branches missed.">			} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3514">				((CalendarEventAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">			} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3516">				((ImportedEvent) event).removeWorkResourceID(wkrsID);</span>
			}
		}
<span class="nc" id="L3519">	}</span>

	/**
	 * Phantom naming rule: the first name is the name set in Phantom object the
	 * last name is the template name of phantom.
	 */
<span class="fc" id="L3525">	private static int Phantom_Name = 1;</span>

	private ID getOrCreatePhantom(ID wkrsID, Map skillMap, Map workResourcePhantomIDMap) throws Exception {
<span class="nc" id="L3528">		Object obj = workResourcePhantomIDMap.get(wkrsID);</span>
<span class="nc bnc" id="L3529" title="All 2 branches missed.">		if (obj != null) {</span>
			// phantom has been created in this sp
<span class="nc" id="L3531">			return (ID) obj;</span>
		}

<span class="nc" id="L3534">		ID empTemplateID = (ID) skillMap.get(wkrsID);</span>
<span class="nc" id="L3535">		Phantom phantom = new Phantom();</span>
<span class="nc" id="L3536">		phantom.setEmployeeTemplateID(empTemplateID);</span>
<span class="nc" id="L3537">		phantom.setName(&quot;&quot; + Phantom_Name++);</span>
<span class="nc" id="L3538">		ID phantomID = createPhantom(phantom);</span>
<span class="nc" id="L3539">		workResourcePhantomIDMap.put(wkrsID, phantomID);</span>
<span class="nc" id="L3540">		return phantomID;</span>
	}

	private void replaceSkillSetWithTemplateID(HashMap skillSet, ID orgID, Collection existingTemplates)
			throws Exception {
<span class="nc" id="L3545">		Map.Entry entry = null;</span>
<span class="nc" id="L3546">		Collection skillAssignments = null;</span>
<span class="nc" id="L3547">		ID empTemplateID = null;</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">		for (Iterator i = skillSet.entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L3549">			entry = (Map.Entry) i.next();</span>
			// skill assignments
<span class="nc" id="L3551">			skillAssignments = (Collection) entry.getValue();</span>
<span class="nc" id="L3552">			empTemplateID = findOrCreateEmpTemplate(orgID, skillAssignments, existingTemplates);</span>
<span class="nc" id="L3553">			entry.setValue(empTemplateID);</span>
		}
<span class="nc" id="L3555">	}</span>

	/*
	 * Jason said: a. Check if a Hidden Employee Template exists for the
	 * Employee's skills and Orgs by calling a WorkResourceManager function b.
	 * If no Hidden Employee Template exists, create one by calling a
	 * WorkResourceManager method
	 *
	 * Note: there is no isHidden in emptemplate object any more, add it back? -
	 * Angela
	 */
	private ID findOrCreateEmpTemplate(ID orgID, Collection skillAssignments, Collection existingTemplates)
			throws Exception {
<span class="nc" id="L3568">		EmployeeTemplate empTemplate = null;</span>
<span class="nc" id="L3569">		List templateSkills = null;</span>
<span class="nc bnc" id="L3570" title="All 2 branches missed.">		for (Iterator i = existingTemplates.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3571">			empTemplate = (EmployeeTemplate) i.next();</span>
<span class="nc bnc" id="L3572" title="All 2 branches missed.">			if (!empTemplate.getFieldValueBoolean(EmployeeTemplateFieldInfo.EMPTEMPLATE_ISHIDDEN)) {</span>
<span class="nc" id="L3573">				continue;</span>
			}
<span class="nc" id="L3575">			templateSkills = empTemplate.getSkillAssignments();</span>
<span class="nc" id="L3576">			int skillSize = skillAssignments.size();</span>
<span class="nc bnc" id="L3577" title="All 2 branches missed.">			if (templateSkills.size() == skillAssignments.size()) {</span>
<span class="nc" id="L3578">				SkillAssignment skillAssignment = null;</span>
<span class="nc bnc" id="L3579" title="All 2 branches missed.">				for (Iterator ii = skillAssignments.iterator(); ii.hasNext();) {</span>
<span class="nc" id="L3580">					skillAssignment = (SkillAssignment) ii.next();</span>
<span class="nc bnc" id="L3581" title="All 2 branches missed.">					if (isInTemplateSkill(templateSkills, skillAssignment)) {</span>
<span class="nc" id="L3582">						skillSize -= 1;</span>
					}
				}
			}
<span class="nc bnc" id="L3586" title="All 2 branches missed.">			if (skillSize == 0) {</span>
<span class="nc" id="L3587">				return empTemplate.getID();</span>
			}
<span class="nc" id="L3589">		}</span>

		// can not find one in existing template, create one here
<span class="nc" id="L3592">		return createEmpTemplateWithSkills(orgID, skillAssignments);</span>
	}

	private boolean isInTemplateSkill(List templateSkills, SkillAssignment skillAssignment) {
<span class="nc" id="L3596">		SkillAssignment templateSkill = null;</span>
<span class="nc bnc" id="L3597" title="All 2 branches missed.">		for (Iterator i = templateSkills.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3598">			templateSkill = (SkillAssignment) i.next();</span>
<span class="nc bnc" id="L3599" title="All 2 branches missed.">			if (templateSkill.getSkillID().equals(skillAssignment.getSkillID())</span>
<span class="nc bnc" id="L3600" title="All 2 branches missed.">					&amp;&amp; templateSkill.getPriority() == skillAssignment.getPriority()</span>
<span class="nc bnc" id="L3601" title="All 2 branches missed.">					&amp;&amp; templateSkill.getProficiency() == skillAssignment.getProficiency()</span>
<span class="nc bnc" id="L3602" title="All 2 branches missed.">					&amp;&amp; templateSkill.isReserve() == skillAssignment.isReserve()) {</span>
<span class="nc" id="L3603">				return true;</span>
			}
		}
<span class="nc" id="L3606">		return false;</span>
	}

	/*
	 * To create an employee template, here is the non-nullable field: orgID,
	 * name
	 */
	// private static int Template_Name_ID = 1;

	private ID createEmpTemplateWithSkills(ID orgID, Collection skillAssignments) throws Exception {
<span class="nc" id="L3616">		EmployeeTemplate empTemplate = new EmployeeTemplate();</span>
		// template name should be &lt;orgname&gt;-&lt;id&gt;
<span class="nc" id="L3618">		String templateName = m_workResourceManager.getOrganizationName(orgID); // QA95771</span>
																				// +
																				// '-'
																				// +
																				// Template_Name_ID++;
<span class="nc" id="L3623">		empTemplate.setOrganizationID(orgID);</span>
<span class="nc" id="L3624">		empTemplate.setName(templateName);</span>
<span class="nc" id="L3625">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_WAGE, 0.0);</span>
<span class="nc" id="L3626">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_PROFICIENCY, 1.0);</span>
<span class="nc" id="L3627">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_ISHIDDEN, true);</span>
<span class="nc" id="L3628">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CREATED, new Date());</span>
<span class="nc" id="L3629">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CREATEDBY, &quot;imported&quot;);</span>
<span class="nc" id="L3630">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CONNECTIONID, 0);</span>
<span class="nc" id="L3631">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_BPTIMESTAMP, 0);</span>
<span class="nc" id="L3632">		empTemplate.setChatSessions(1); // QC66597</span>
<span class="nc" id="L3633">		empTemplate.setSkillAssignments(skillAssignments);</span>
<span class="nc" id="L3634">		return createEmployeeTemplate(empTemplate);</span>
	}

	public Collection exportStaffingProfiles(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L3639">		methodStart(&quot;exportStaffingProfiles&quot;, workResourceIDs, dtStart, dtEnd);</span>

		/* set up a bit mask that represents all types of published events */
<span class="nc" id="L3642">		int eventTypeMask = Event.EVENT_TYPE_IMPORTED | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
				| Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;

<span class="nc" id="L3645">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L3647">			ArrayList events = new ArrayList();</span>

<span class="nc" id="L3649">			ImportedEventDAO importedDao = new ImportedEventDAO(dmo);</span>
<span class="nc" id="L3650">			events.addAll(importedDao.exportStaffingProfiles(workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3652">			ShiftAssignmentPubDAO shiftDao = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L3653">			events.addAll(shiftDao.exportStaffingProfiles(workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3655">			CalendarEventAssignmentPubDAO ceaDao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L3656">			events.addAll(ceaDao.exportStaffingProfiles(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3658">			Collections.sort(events);</span>
<span class="nc" id="L3659">			return events;</span>
		} finally {
<span class="nc" id="L3661">			dmo.cleanUp();</span>
<span class="nc" id="L3662">			methodFinish();</span>
		}
	}

	public HashMap getLastPublishedShiftAssignmentStartTime(Collection workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L3668">		methodStart(&quot;getLastPublishedShiftAssignmentStartTime&quot;, workResourceIDs);</span>

<span class="nc" id="L3670">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L3672">			return dao.getLastPublishedShiftAssignmentStartTime(workResourceIDs);</span>
<span class="nc" id="L3673">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3674">			throw ex;</span>
<span class="nc" id="L3675">		} catch (Exception e) {</span>
<span class="nc" id="L3676">			handleException(e);</span>
<span class="nc" id="L3677">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3679">			dao.cleanUp();</span>
<span class="nc" id="L3680">			methodFinish();</span>
		}
	}

	public HashMap getLastShiftAssignmentStartTime(Collection workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L3686">		methodStart(&quot;getLastShiftAssignmentStartTime&quot;, workResourceIDs);</span>

<span class="nc" id="L3688">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3690">			return dao.getLastShiftAssignmentStartTime(workResourceIDs);</span>
<span class="nc" id="L3691">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3692">			throw ex;</span>
<span class="nc" id="L3693">		} catch (Exception e) {</span>
<span class="nc" id="L3694">			handleException(e);</span>
<span class="nc" id="L3695">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3697">			dao.cleanUp();</span>
<span class="nc" id="L3698">			methodFinish();</span>
		}
	}

	public FloatingEventTemplate createRecurringFloatingEventException(ID templateID, Collection workResourceIDs,
			Date instanceStart, int duration, Date floatingStart, Date floatingEnd, boolean isLocked)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3705">		return createRecurringFloatingEventExceptionWithLock(null, templateID, workResourceIDs, instanceStart, duration,</span>
				floatingStart, floatingEnd, isLocked);
	}

	public FloatingEventTemplate createRecurringFloatingEventExceptionWithLock(String lockID, ID templateID,
			Collection workResourceIDs, Date instanceStart, int duration, Date floatingStart, Date floatingEnd,
			boolean isLocked) throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3712">		methodStart(&quot;createRecurringFloatingEventExceptionWithLock&quot;, lockID, templateID, workResourceIDs,</span>
				instanceStart);

<span class="nc" id="L3715">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L3717">			RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L3718">			RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

<span class="nc" id="L3720">			Date exceptionOnDate = instanceStart;</span>

<span class="nc" id="L3722">			FloatingEventTemplate eventException = (FloatingEventTemplate) dao.createRecurringEventException(</span>
					recTemplate, workResourceIDs, exceptionOnDate, duration, instanceStart, floatingStart, floatingEnd);

			// find the exception instance
<span class="nc" id="L3726">			CalendarEventAssignmentDAO ceaDAO = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L3727">			CalendarEventAssignment cea = (ceaDAO.getObjectsByParentID(eventException.getID()).iterator().next());</span>
<span class="nc bnc" id="L3728" title="All 2 branches missed.">			if (isLocked) {</span>
<span class="nc" id="L3729">				cea.setLocked(isLocked);</span>
<span class="nc" id="L3730">				ceaDAO.updateObject(cea);</span>
			}
<span class="nc" id="L3732">			checkConflictForNewObject(dmo, cea, templateID);</span>

			// check if it can not be created because the schedule has been
			// locked
<span class="nc bnc" id="L3736" title="All 2 branches missed.">			if (lockID != null) {</span>
<span class="nc" id="L3737">				m_eventHandler.preCreateEvent(lockID, cea);</span>
			}

<span class="nc" id="L3740">			return eventException;</span>
<span class="nc" id="L3741">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L3742">			handleException(e);</span>
<span class="nc" id="L3743">			throw e;</span>
<span class="nc" id="L3744">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L3745">			handleException(e);</span>
<span class="nc" id="L3746">			throw e;</span>
<span class="nc" id="L3747">		} catch (Exception e) {</span>
<span class="nc" id="L3748">			handleException(e);</span>
<span class="nc" id="L3749">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L3751">			dmo.cleanUp();</span>
<span class="nc" id="L3752">			methodFinish();</span>
		}
	}

	// for recurring floating event template only
	public ID createFloatingEventTemplateWithInstances(CalendarEventTemplate eventTemplate, Date instanceStartTime,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmCreateException {
<span class="nc" id="L3760">		FloatingEventTemplate floatTemp = (FloatingEventTemplate) eventTemplate;</span>
<span class="nc" id="L3761">		floatTemp.setInstanceStart(instanceStartTime);</span>
<span class="nc" id="L3762">		return createEventTemplateWithInstances(floatTemp, conflictResolutions);</span>
	}

	// Copy Employee Min/Max Hour Assignments, Skill Assignments, and Work
	// Pattern Assignments, have to think about multiweek.
	public void copyEffectiveDates(ID idSourceSP, Date sourceWeekStart, ID idDestinationSP, Date targetWeekStart)
			throws BbmFinderException {
<span class="fc" id="L3769">		methodStart(&quot;copyEffectiveDates&quot;, idSourceSP, sourceWeekStart, idDestinationSP, targetWeekStart);</span>
		try {
<span class="fc" id="L3771">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="fc" id="L3772">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>
<span class="fc" id="L3773">			Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP.getCampaignID());</span>

<span class="fc" id="L3775">			Date sourceWeekEnd = getWeekEnd(sourceWeekStart, pSourceSP, pCampaign, true);</span>
<span class="fc" id="L3776">			Date targetWeekEnd = getWeekEnd(targetWeekStart, pDestinationSP, pCampaign, true);</span>

			// get workresources in the destination sp
<span class="fc" id="L3779">			Collection&lt;CampaignWorkResource&gt; cpAssignments = m_pCampaignManager</span>
<span class="fc" id="L3780">					.getCampaignWorkResourceAssignments(pDestinationSP.getCampaignID(), targetWeekStart, targetWeekEnd);</span>

<span class="fc" id="L3782">			HashSet&lt;ID&gt; cidWorkResources = new HashSet();</span>
<span class="fc bfc" id="L3783" title="All 2 branches covered.">			for (CampaignWorkResource pAssignment : cpAssignments) {</span>
<span class="fc" id="L3784">				cidWorkResources.add(pAssignment.getWorkResourceID());</span>
<span class="fc" id="L3785">			}</span>

			// get effective dates in source sp: minmax assignment, skill
			// assignment and work pattern assignment

			// widen the select range up and down one day.
<span class="fc" id="L3791">			Calendar gc = Calendar.getInstance(pCampaign.getTimeZone());</span>
<span class="fc" id="L3792">			gc.setTime(pSourceSP.getStartTime());</span>
<span class="fc" id="L3793">			gc.add(Calendar.DATE, -1);</span>
<span class="fc" id="L3794">			Date start = gc.getTime();</span>
<span class="fc" id="L3795">			gc.setTime(pSourceSP.getEndTime());</span>
<span class="fc" id="L3796">			gc.add(Calendar.DATE, 1);</span>
<span class="fc" id="L3797">			Date end = gc.getTime();</span>

			// effecivity period: find effectivity value at source week start
			// and extending 24 hours before and after to absorb time zone diff
<span class="fc" id="L3801">			Date effStart = TimeZoneUtil.previousDay(sourceWeekStart);</span>
<span class="fc" id="L3802">			Date effEnd = TimeZoneUtil.nextDay(sourceWeekStart);</span>
<span class="fc" id="L3803">			Map&lt;ID, Collection&lt;EmployeeMinMaxMinutes&gt;&gt; minMaxAssignments = m_workResourceManager</span>
<span class="fc" id="L3804">					.getMinMaxMinutesAssignmentsInPeriodAndOnSpotOnly(cidWorkResources, effStart, effEnd, null);</span>
<span class="fc" id="L3805">			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; workPatternAssignments = m_empWorkRuleManager</span>
<span class="fc" id="L3806">					.getWorkPatternAssignmentsInPeriodAndOnSpotOnly(cidWorkResources, effStart, effEnd, null);</span>
<span class="fc" id="L3807">			Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; skillAssignments = m_skillManager</span>
<span class="fc" id="L3808">					.getSkillAssignmentInPeriodAndOnSpotOnly(cidWorkResources, effStart, effEnd, null);</span>

<span class="fc" id="L3810">			Date targetEffStart = TimeZoneUtil.previousDay(targetWeekStart);</span>
<span class="fc" id="L3811">			Date targetEffEnd = TimeZoneUtil.nextDay(targetWeekStart);</span>
<span class="fc" id="L3812">			Map&lt;ID, Collection&lt;EmployeeMinMaxMinutes&gt;&gt; curTargetMinMaxAssignments = m_workResourceManager</span>
<span class="fc" id="L3813">					.getMinMaxMinutesAssignmentsInPeriodAndOnSpotOnly(cidWorkResources, targetEffStart, targetEffEnd,</span>
							null);
<span class="fc" id="L3815">			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; curTargetWorkPatternAssignments = m_empWorkRuleManager</span>
<span class="fc" id="L3816">					.getWorkPatternAssignmentsInPeriodAndOnSpotOnly(cidWorkResources, targetEffStart, targetEffEnd,</span>
							null);
<span class="fc" id="L3818">			Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; curTargetSkillAssignments = m_skillManager</span>
<span class="fc" id="L3819">					.getSkillAssignmentInPeriodAndOnSpotOnly(cidWorkResources, targetEffStart, targetEffEnd, null);</span>

<span class="fc" id="L3821">			Map&lt;ID, Collection&lt;WorkResourceAssignment&gt;&gt; workResourceAssignments = m_workResourceManager</span>
<span class="fc" id="L3822">					.getValidWorkResourceAssignments(cidWorkResources, new LocalDate(start, pCampaign.getTimeZone()),</span>
<span class="fc" id="L3823">							new LocalDate(end, pCampaign.getTimeZone()));</span>
<span class="fc" id="L3824">			List&lt;EmployeeMinMaxMinutes&gt; minMaxAssignmentsInDSP = new ArrayList(minMaxAssignments.size());</span>
<span class="fc" id="L3825">			List&lt;WorkResourceWorkPattern&gt; workPatternAssignmentsInDSP = new ArrayList(workPatternAssignments.size());</span>
<span class="fc" id="L3826">			List&lt;SkillAssignment&gt; skillAssignmentsInDSP = new ArrayList(skillAssignments.size());</span>
<span class="fc" id="L3827">			Collection&lt;WorkResourceAssignment&gt; orgAssignments = null;</span>
<span class="fc bfc" id="L3828" title="All 2 branches covered.">			for (ID wrsID : cidWorkResources) {</span>
<span class="fc" id="L3829">				orgAssignments = workResourceAssignments.get(wrsID);</span>
<span class="fc" id="L3830">				minMaxAssignmentsInDSP.addAll(moveToDestinationSP(pCampaign, minMaxAssignments.get(wrsID),</span>
<span class="fc" id="L3831">						curTargetMinMaxAssignments.get(wrsID), new Pair&lt;Date, Date&gt;(sourceWeekStart, sourceWeekEnd),</span>
<span class="fc" id="L3832">						new Pair&lt;Date, Date&gt;(targetWeekStart, targetWeekEnd), pCampaign.getTimeZone()));</span>
<span class="fc" id="L3833">				workPatternAssignmentsInDSP.addAll(moveToDestinationSP(pCampaign, workPatternAssignments.get(wrsID),</span>
<span class="fc" id="L3834">						curTargetWorkPatternAssignments.get(wrsID),</span>
						new Pair&lt;Date, Date&gt;(sourceWeekStart, sourceWeekEnd),
<span class="fc" id="L3836">						new Pair&lt;Date, Date&gt;(targetWeekStart, targetWeekEnd), pCampaign.getTimeZone()));</span>
<span class="fc" id="L3837">				skillAssignmentsInDSP.addAll(moveToDestinationSP(pCampaign, fixProficiency(skillAssignments.get(wrsID)),</span>
<span class="fc" id="L3838">						fixProficiency(curTargetSkillAssignments.get(wrsID)),</span>
						new Pair&lt;Date, Date&gt;(sourceWeekStart, sourceWeekEnd),
<span class="fc" id="L3840">						new Pair&lt;Date, Date&gt;(targetWeekStart, targetWeekEnd), pCampaign.getTimeZone()));</span>
<span class="fc" id="L3841">			}</span>

<span class="pc bpc" id="L3843" title="1 of 2 branches missed.">			if (!minMaxAssignmentsInDSP.isEmpty()) {</span>
<span class="nc bnc" id="L3844" title="All 2 branches missed.">				for (EmployeeMinMaxMinutes empMinMax : minMaxAssignmentsInDSP) {</span>
<span class="nc" id="L3845">					m_workResourceManager.createMinMaxMinutesAssignment(empMinMax);</span>
<span class="nc" id="L3846">				}</span>
			}
<span class="pc bpc" id="L3848" title="1 of 2 branches missed.">			if (!workPatternAssignmentsInDSP.isEmpty()) {</span>
<span class="nc bnc" id="L3849" title="All 2 branches missed.">				for (WorkResourceWorkPattern wp : workPatternAssignmentsInDSP) {</span>
<span class="nc" id="L3850">					m_empWorkRuleManager.createWorkPatternAssignment(wp);</span>
<span class="nc" id="L3851">				}</span>
			}
<span class="pc bpc" id="L3853" title="1 of 2 branches missed.">			if (!skillAssignmentsInDSP.isEmpty()) {</span>
<span class="nc bnc" id="L3854" title="All 2 branches missed.">				for (SkillAssignment skillAss : skillAssignmentsInDSP) {</span>
<span class="nc" id="L3855">					m_skillManager.createSkillAssignment(skillAss);</span>
<span class="nc" id="L3856">				}</span>
			}

<span class="nc" id="L3859">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3860">			handleException(&quot;copyEffectiveDates&quot;, e);</span>
<span class="nc" id="L3861">			throw e;</span>
<span class="nc" id="L3862">		} catch (Exception e) {</span>
<span class="nc" id="L3863">			handleException(&quot;copyEffectiveDates&quot;, e);</span>
<span class="nc" id="L3864">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L3866">			methodFinish();</span>
<span class="fc" id="L3867">		}</span>
<span class="fc" id="L3868">	}</span>

	private &lt;T extends ValueObjectEffectivity&gt; Collection&lt;T&gt; moveToDestinationSP(Campaign campaign,
			Collection&lt;T&gt; assignments, Collection&lt;T&gt; curTargetAssignments, Pair&lt;Date, Date&gt; sourceWeek,
			Pair&lt;Date, Date&gt; targetWeek, TimeZone campaignTimeZone) throws Exception {

<span class="fc" id="L3874">		Date sourceWeekStart = sourceWeek.getFirst();</span>
<span class="fc" id="L3875">		Date sourceWeekEnd = sourceWeek.getSecond();</span>
<span class="fc" id="L3876">		Date targetWeekStart = targetWeek.getFirst();</span>
<span class="fc" id="L3877">		Date targetWeekEnd = targetWeek.getSecond();</span>

<span class="pc bpc" id="L3879" title="1 of 4 branches missed.">		if (assignments == null || assignments.isEmpty()) {</span>
<span class="fc" id="L3880">			return Collections.EMPTY_LIST; // return empty list</span>
		}

<span class="pc bpc" id="L3883" title="1 of 2 branches missed.">		if (curTargetAssignments == null) {</span>
<span class="nc" id="L3884">			curTargetAssignments = new ArrayList();</span>
		}

<span class="fc" id="L3887">		List&lt;T&gt; sortedAssignments = new ArrayList&lt;T&gt;(assignments);</span>
<span class="fc" id="L3888">		Collections.sort(sortedAssignments);</span>

<span class="fc" id="L3890">		int deltaInMinutes = (int) ((targetWeekStart.getTime() - sourceWeekStart.getTime())</span>
				/ TimeZoneUtil.MINUTE_IN_MILLISECONDS);
<span class="fc" id="L3892">		Calendar calendar = Calendar.getInstance();</span>
<span class="fc" id="L3893">		List&lt;T&gt; list = new ArrayList&lt;T&gt;(sortedAssignments.size());</span>
<span class="fc bfc" id="L3894" title="All 2 branches covered.">		for (T obj : sortedAssignments) {</span>
<span class="pc bpc" id="L3895" title="1 of 2 branches missed.">			if (obj.getStartTime().before(sourceWeekEnd)</span>
<span class="pc bpc" id="L3896" title="3 of 4 branches missed.">					&amp;&amp; (obj.getEndTime() == null || obj.getEndTime().after(sourceWeekStart))) {</span>

<span class="pc bpc" id="L3898" title="1 of 2 branches missed.">				if (campaign.isMonthly()</span>
<span class="nc bnc" id="L3899" title="All 2 branches missed.">						&amp;&amp; (MonthlySPUtil.isPartialWeek(campaignTimeZone, sourceWeekStart, sourceWeekEnd)</span>
<span class="nc bnc" id="L3900" title="All 2 branches missed.">								|| MonthlySPUtil.isPartialWeek(campaignTimeZone, targetWeekStart, targetWeekEnd))) {</span>
<span class="nc" id="L3901">					Date[] newAssignmentRange = MonthlySPUtil.relocateRangeFromOldWeekToNewWeek(campaignTimeZone,</span>
<span class="nc" id="L3902">							obj.getStartTime(), obj.getEndTime(), sourceWeekStart, sourceWeekEnd, targetWeekStart,</span>
							targetWeekEnd);
<span class="nc bnc" id="L3904" title="All 2 branches missed.">					if (newAssignmentRange[0] != null) {</span>
<span class="nc" id="L3905">						obj.setStartTime(newAssignmentRange[0]);</span>
<span class="nc" id="L3906">						obj.setEndTime(newAssignmentRange[1]);</span>
					} else {
						// nothing to copy, so skip it
						continue;
					}
<span class="nc" id="L3911">				} else {</span>
					// within time period of source sp, and then cut the extra
<span class="pc bpc" id="L3913" title="1 of 2 branches missed.">					if (obj.getStartTime().before(sourceWeekStart)) {</span>
<span class="fc" id="L3914">						obj.setStartTime(sourceWeekStart);</span>
					}
<span class="pc bpc" id="L3916" title="3 of 4 branches missed.">					if (obj.getEndTime() == null || obj.getEndTime().after(sourceWeekEnd)) {</span>
<span class="fc" id="L3917">						obj.setEndTime(sourceWeekEnd);</span>
					}

					// add delta
<span class="fc" id="L3921">					calendar.setTime(obj.getStartTime());</span>
<span class="fc" id="L3922">					calendar.add(Calendar.MINUTE, deltaInMinutes);</span>
<span class="fc" id="L3923">					obj.setStartTime(calendar.getTime());</span>

<span class="fc" id="L3925">					calendar.setTime(obj.getEndTime());</span>
<span class="fc" id="L3926">					calendar.add(Calendar.MINUTE, deltaInMinutes);</span>
<span class="fc" id="L3927">					obj.setEndTime(calendar.getTime());</span>
				}

				// check if the new assignment is in current target already
<span class="pc bpc" id="L3931" title="1 of 2 branches missed.">				if (isNewAssignment(curTargetAssignments, obj)) {</span>
<span class="nc" id="L3932">					list.add(obj);</span>
				}
			}
<span class="fc" id="L3935">		}</span>
<span class="fc" id="L3936">		return list;</span>
	}

	private &lt;T extends ValueObjectEffectivity&gt; boolean isNewAssignment(Collection&lt;T&gt; curTargetAssignments,
			ValueObjectEffectivity obj) {
<span class="fc" id="L3941">		boolean isUpdated = true;</span>
<span class="fc bfc" id="L3942" title="All 2 branches covered.">		for (T curTargetObj : curTargetAssignments) {</span>
<span class="pc bpc" id="L3943" title="2 of 4 branches missed.">			if (curTargetObj.effectivityValueEqual(obj) &amp;&amp; !curTargetObj.getStartTime().after(obj.getStartTime())</span>
<span class="pc bpc" id="L3944" title="3 of 4 branches missed.">					&amp;&amp; (curTargetObj.getEndTime() == null || !curTargetObj.getEndTime().before(obj.getEndTime()))) {</span>
<span class="fc" id="L3945">				isUpdated = false;</span>
			}
<span class="fc" id="L3947">		}</span>
<span class="fc" id="L3948">		return isUpdated;</span>
	}

	private Collection&lt;SkillAssignment&gt; fixProficiency(Collection&lt;SkillAssignment&gt; skillAssignments) {
<span class="pc bpc" id="L3952" title="3 of 4 branches missed.">		if (skillAssignments != null &amp;&amp; !skillAssignments.isEmpty()) {</span>
			// handle proficiency, should multiply 10 here - should fix with
			// laurie later
<span class="nc bnc" id="L3955" title="All 2 branches missed.">			for (SkillAssignment sa : skillAssignments) {</span>
<span class="nc" id="L3956">				sa.setProficiency(sa.getProficiency() * 10);</span>
<span class="nc" id="L3957">			}</span>
		} else {
<span class="fc" id="L3959">			return Collections.EMPTY_LIST;</span>
		}
<span class="nc" id="L3961">		return skillAssignments;</span>
	}

	public void updateCalendarEventAssignments(String lockID, Collection events)
			throws BbmScheduleConflictException, MultiUserException, BbmUpdateException {
<span class="nc" id="L3966">		methodStart(&quot;updateCalendarEventAssignments&quot;, lockID, events);</span>

<span class="nc" id="L3968">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
			/* save the object before the update */
<span class="nc bnc" id="L3971" title="All 4 branches missed.">			if (events == null || events.isEmpty()) {</span>
<span class="nc" id="L3972">				return;</span>
			}

<span class="nc" id="L3975">			Iterator i = null;</span>
<span class="nc" id="L3976">			ArrayList ids = new ArrayList();</span>
<span class="nc bnc" id="L3977" title="All 2 branches missed.">			for (i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3978">				ids.add(((Event) i.next()).getID());</span>
			}
<span class="nc" id="L3980">			Collection oldEvents = dao.getObjectsByIDs(ids);</span>
			// build id-event map
<span class="nc" id="L3982">			HashMap idEvent = new HashMap();</span>
<span class="nc" id="L3983">			CalendarEventAssignment event = null;</span>
<span class="nc bnc" id="L3984" title="All 2 branches missed.">			for (i = oldEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3985">				event = (CalendarEventAssignment) i.next();</span>
<span class="nc" id="L3986">				idEvent.put(event.getID(), event);</span>
			}

			/*
			 * perform what is necessary before an existing event gets updated
			 */
<span class="nc" id="L3992">			m_eventHandler.preUpdateEvents(lockID, oldEvents, events);</span>

<span class="nc" id="L3994">			CalendarEventAssignment oldEvent = null;</span>
<span class="nc bnc" id="L3995" title="All 2 branches missed.">			for (i = events.iterator(); i.hasNext();) {</span>
				// the event object might only have updated attributes instead
				// of the whole picture. Here reset the org attendees list for
				// checking
				// schedule conflict
<span class="nc" id="L4000">				event = (CalendarEventAssignment) i.next();</span>
<span class="nc" id="L4001">				oldEvent = (CalendarEventAssignment) idEvent.get(event.getID());</span>

<span class="nc" id="L4003">				populateExistingAttendee(oldEvent, event);</span>

<span class="nc" id="L4005">				event.setOverlayPrecedence(oldEvent.getOverlayPrecedence());</span>
			}
			/*
			 * === ignore conflict check for now === Collection listConflicts =
			 * dao .getConflictsForUpdatedScheduleObject(event); if
			 * (!listConflicts.isEmpty()) { throw new
			 * BbmScheduleConflictException(listConflicts); }
			 */

<span class="nc" id="L4014">			dao.updateObjects(events);</span>

			/** see if there were any conflicts as a result of this operation */
			/*
			 * db constrain checked already. event = (CalendarEventAssignment)
			 * dao.getObjectByID(event.getID()); event.checkIsValid();
			 */

			/* perform what is necessary after an existing event gets updated */
<span class="nc" id="L4023">			m_eventHandler.postUpdateEvents(lockID, events, idEvent);</span>
<span class="nc" id="L4024">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L4025">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L4026">			throw e; // just rethrow</span>
<span class="nc" id="L4027">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L4028">			handleException(e);</span>
<span class="nc" id="L4029">			throw e;</span>
<span class="nc" id="L4030">		} catch (MultiUserException e) {</span>
<span class="nc" id="L4031">			handleException(e);</span>
<span class="nc" id="L4032">			throw e;</span>
<span class="nc" id="L4033">		} catch (Exception e) {</span>
<span class="nc" id="L4034">			handleException(e);</span>
<span class="nc" id="L4035">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L4037">			dao.cleanUp();</span>
<span class="nc" id="L4038">			methodFinish();</span>
<span class="nc" id="L4039">		}</span>
<span class="nc" id="L4040">	}</span>

	/**
	 * This API is initially created for importing schedule from bpfx. Usually
	 * before importing, there should not be any event created in that time
	 * priod. the reason why we still need this API is because the customer
	 * might want to import schedule again under some situation Since importing
	 * schedule only imports shift and calendar event. here this API will only
	 * delete calendar event but not including recurring and floating event
	 * instance.
	 */
	// TODO REMOVE THIS METHOD ONCE THE PLUGIN STOPS USING THEM
	@Deprecated
	public void deleteCalendarEventAssignments(Collection colWorkResourceIDs, Date start, Date end)
			throws BbmRemoveException {
<span class="nc" id="L4055">		methodStart(&quot;deleteCalendarEventAssignments&quot;, colWorkResourceIDs, start, end);</span>

<span class="nc" id="L4057">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L4059">			dao.deleteCalendarEventAssignments(colWorkResourceIDs, start, end, null);</span>
<span class="nc" id="L4060">		} catch (Exception e) {</span>
<span class="nc" id="L4061">			handleException(e);</span>
<span class="nc" id="L4062">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L4064">			dao.cleanUp();</span>
<span class="nc" id="L4065">			methodFinish();</span>
<span class="nc" id="L4066">		}</span>
<span class="nc" id="L4067">	}</span>

	// TODO REMOVE THIS METHOD ONCE THE PLUGIN STOPS USING THEM
	@Deprecated
	public void deleteCalendarEventAssignmentsForSelectedActivities(Collection colWorkResourceIDs, Date start, Date end,
			Collection activityIDs) throws BbmRemoveException {
<span class="nc" id="L4073">		methodStart(&quot;deleteCalendarEventAssignmentsForSelectedActivities&quot;, colWorkResourceIDs, start, end, activityIDs);</span>

<span class="nc" id="L4075">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L4077">			dao.deleteCalendarEventAssignments(colWorkResourceIDs, start, end, activityIDs);</span>
<span class="nc" id="L4078">		} catch (Exception e) {</span>
<span class="nc" id="L4079">			handleException(e);</span>
<span class="nc" id="L4080">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L4082">			dao.cleanUp();</span>
<span class="nc" id="L4083">			methodFinish();</span>
<span class="nc" id="L4084">		}</span>
<span class="nc" id="L4085">	}</span>

	public Collection&lt;ID&gt; getCalendarEventAssignmentsForSelectedActivities(Collection colWorkResourceIDs, Date start,
			Date end, Collection activityIDs) throws BbmFinderException {
<span class="nc" id="L4089">		methodStart(&quot;getCalendarEventAssignmentsForSelectedActivities&quot;, colWorkResourceIDs, start, end, activityIDs);</span>

<span class="nc" id="L4091">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L4093">			return dao.getCalendarEventAssignmentsForSelectedActivities(colWorkResourceIDs, start, end, activityIDs);</span>
<span class="nc" id="L4094">		} catch (Exception e) {</span>
<span class="nc" id="L4095">			handleException(e);</span>
<span class="nc" id="L4096">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4098">			dao.cleanUp();</span>
<span class="nc" id="L4099">			methodFinish();</span>
		}
	}

	private void populateExistingAttendee(CalendarEventAssignment oldEvent, CalendarEventAssignment newEvent) {
<span class="pc bpc" id="L4104" title="1 of 2 branches missed.">		if (oldEvent == null) {</span>
<span class="nc" id="L4105">			return;</span>
		}

<span class="fc" id="L4108">		HashMap&lt;Integer, Map&lt;Integer, CalendarEventAttendee&gt;&gt; childrenMap = oldEvent.getChildObjectMap();</span>
<span class="pc bpc" id="L4109" title="1 of 2 branches missed.">		if (childrenMap == null) {</span>
<span class="nc" id="L4110">			return;</span>
		}

		// if the new event already has its updated child attendees populated,
		// do not copy child attendees from the
		// old event to the new event, as that would override the already
		// updated child attendees on the new event.
<span class="fc" id="L4117">		Collection&lt;CalendarEventAttendee&gt; newEventUpdatedChildObjects = newEvent</span>
<span class="fc" id="L4118">				.getUpdatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>

<span class="pc bpc" id="L4120" title="3 of 4 branches missed.">		if (newEventUpdatedChildObjects != null &amp;&amp; !newEventUpdatedChildObjects.isEmpty()) {</span>
<span class="nc" id="L4121">			return;</span>
		}

<span class="fc" id="L4124">		Map&lt;Integer, CalendarEventAttendee&gt; orgAttendees = childrenMap</span>
<span class="fc" id="L4125">				.get(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>

<span class="pc bpc" id="L4127" title="2 of 4 branches missed.">		if (orgAttendees != null &amp;&amp; !orgAttendees.isEmpty()) {</span>
<span class="fc bfc" id="L4128" title="All 2 branches covered.">			for (CalendarEventAttendee orgAttendee : orgAttendees.values()) {</span>
<span class="fc" id="L4129">				newEvent.fillChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, orgAttendee);</span>
<span class="fc" id="L4130">			}</span>
		}
<span class="fc" id="L4132">	}</span>

	private void populateExistingAttendee(ValueObjectAggEventTemplate oldTemplate,
			ValueObjectAggEventTemplate newTemplate) {
<span class="nc bnc" id="L4136" title="All 2 branches missed.">		if (oldTemplate == null) {</span>
<span class="nc" id="L4137">			return;</span>
		}
<span class="nc" id="L4139">		HashMap childrenMap = oldTemplate.getAggregatedTemplate().getChildObjectMap();</span>
<span class="nc bnc" id="L4140" title="All 2 branches missed.">		if (childrenMap != null) {</span>
<span class="nc" id="L4141">			Object orgAttendees = childrenMap.get(NumberFactory.newInteger(CalendarEventTemplateFields.CHILD_ATTENDEE));</span>
<span class="nc bnc" id="L4142" title="All 4 branches missed.">			if (orgAttendees != null &amp;&amp; !((HashMap) orgAttendees).isEmpty()) {</span>
<span class="nc" id="L4143">				Collection objs = ((HashMap) orgAttendees).values();</span>
<span class="nc bnc" id="L4144" title="All 2 branches missed.">				for (Iterator i = objs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4145">					newTemplate.getAggregatedTemplate().fillChildObject(CalendarEventTemplateFields.CHILD_ATTENDEE,</span>
<span class="nc" id="L4146">							(ValueObjectBase) i.next());</span>
				}
			}
		}
<span class="nc" id="L4150">	}</span>

	private void checkConflictForNewObject(Jdmo dmo, CalendarEventAssignment event, ID templateEventID)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc" id="L4154">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L4155">		Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForScheduleObject(event, true, templateEventID);</span>
<span class="nc" id="L4156">		throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(dmo, listConflicts);</span>
<span class="nc" id="L4157">	}</span>

	private void checkConflictForUpdateObject(Jdmo dmo, CalendarEventAssignment event)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="fc" id="L4161">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="fc" id="L4162">		Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForUpdatedScheduleObject(event);</span>
<span class="fc" id="L4163">		throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(dmo, listConflicts);</span>
<span class="fc" id="L4164">	}</span>

	private void throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(Jdmo dmo, Collection&lt;BbmScheduleConflict&gt; listConflicts)
			throws BbmObjectNotFoundException, BbmFinderException, BbmScheduleConflictException {
<span class="pc bpc" id="L4168" title="1 of 2 branches missed.">		if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L4169" title="All 2 branches missed.">			for (BbmScheduleConflict conflict : listConflicts) {</span>
<span class="nc" id="L4170">				CalendarEventAssignment cea2 = conflict.getCalendarEvent2();</span>
<span class="nc" id="L4171">				CalendarEventAssignment cea1 = conflict.getCalendarEvent1();</span>
<span class="nc bnc" id="L4172" title="All 2 branches missed.">				ID eventTemplateID = cea2.getEventTemplateID() != null ? cea2.getEventTemplateID() : cea1.getEventTemplateID();</span>
<span class="nc" id="L4173">				throwConflictExceptionUnlessTemplateIsARecurringFloatingEvent(dmo, listConflicts, eventTemplateID);</span>
<span class="nc" id="L4174">			}</span>
		}
<span class="fc" id="L4176">	}</span>

	private void throwConflictExceptionUnlessTemplateIsARecurringFloatingEvent(Jdmo dmo, 
			Collection&lt;BbmScheduleConflict&gt; listConflicts, ID eventTemplateID)
			throws BbmObjectNotFoundException, BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L4181" title="All 2 branches missed.">		if (eventTemplateID != null) {</span>
			//calendar event belongs to floating or recurring floating
<span class="nc" id="L4183">			RecurringEventTemplateDAO recEventTemplateDAO = new RecurringEventTemplateDAO(dmo);</span>
			try {
<span class="nc" id="L4185">				RecurringEventTemplateBase ret = recEventTemplateDAO.getObjectByID(eventTemplateID);</span>
<span class="nc bnc" id="L4186" title="All 2 branches missed.">				if (ret.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L4187">					return;</span>
				} else {
					//recurring event so throw conflict
<span class="nc" id="L4190">					throw new BbmScheduleConflictException(listConflicts);</span>
				}
<span class="nc" id="L4192">			} catch(BbmFinderException bfe) {</span>
<span class="nc" id="L4193">				FloatingEventTemplateDAO floatingEventTemplateDAO = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L4194">				FloatingEventTemplate fet = floatingEventTemplateDAO.getObjectByID(eventTemplateID);</span>
<span class="nc bnc" id="L4195" title="All 2 branches missed.">				if (fet.getParentID() != null) {</span>
<span class="nc" id="L4196">					return;</span>
				} else {
<span class="nc" id="L4198">					throw new BbmScheduleConflictException(listConflicts);</span>
				}
			}
		} else {
<span class="nc" id="L4202">			throw new BbmScheduleConflictException(listConflicts);</span>
		}
	}

	/**
	 * @param wrkResIds
	 *            Collections of the emp IDs that is being published or
	 *            un-published
	 * @param isPublish
	 *            indcates if the event is publish(true) or un-published (false)
	 * @throws BbmUpdateException
	 */

	public void notifyPublishComplete(Collection wrkResIds, Date startDate, Date endDate, boolean isPublish)
			throws BbmUpdateException {
<span class="fc" id="L4217">		methodStart(&quot;notifyPublishComplete&quot;, wrkResIds, startDate, endDate);</span>
		try {
<span class="fc" id="L4219">			m_eventHandler.triggerTONotification(wrkResIds, startDate, endDate, isPublish);</span>
<span class="nc" id="L4220">		} catch (Exception ex) {</span>
<span class="nc" id="L4221">			handleException(ex, true);</span>
<span class="nc" id="L4222">			throw new BbmUpdateException(ex.getMessage());</span>
		} finally {
<span class="pc" id="L4224">			methodFinish();</span>
<span class="fc" id="L4225">		}</span>
<span class="fc" id="L4226">	}</span>

	private String createTempTableToQueryEvents(Jdmo dmo, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException, Exception {
		// create temp table to hold workresource, start and end, later it will
		// join with event tables to get the events
<span class="nc" id="L4232">		StringBuffer strSQL = new StringBuffer();</span>
<span class="nc" id="L4233">		String strTableName = &quot;WORKRESOURCETIMERANGE&quot;;</span>
<span class="nc" id="L4234">		String strNativeTempName = dmo.getNativeTemptableName(strTableName);</span>

		// drop temp table just in case
		try {
<span class="nc" id="L4238">			dmo.dropTempTable(strTableName);</span>
<span class="nc" id="L4239">		} catch (Exception e) {</span>
			// do nothing
<span class="nc" id="L4241">		}</span>
<span class="nc" id="L4242">		strSQL.append(strNativeTempName);</span>
<span class="nc" id="L4243">		strSQL.append(&quot; (workresourceid int, starttime datetime, endtime datetime )&quot;);</span>
<span class="nc" id="L4244">		dmo.createTempTable(strSQL.toString());</span>

<span class="nc" id="L4246">		JdmoPCommand pc = dmo.createPCommand(&quot;insert into &quot; + strNativeTempName + &quot; values (?,?,?)&quot;);</span>
<span class="nc" id="L4247">		HashMap param = new HashMap();</span>

		// get employee terminated date if he/she has
<span class="nc" id="L4250">		HashMap terminateDate = new HashMap(workResourceIDs.size());</span>
<span class="nc" id="L4251">		JdmoRowset rs = dmo</span>
<span class="nc" id="L4252">				.createRowset(&quot;select id, endtime from employeeam where id in &quot; + dmo.createInClause(workResourceIDs));</span>
<span class="nc bnc" id="L4253" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L4254">			terminateDate.put(rs.getID(1), rs.getTimestamp(2));</span>
		}

<span class="nc" id="L4257">		Date dTerminate = null;</span>
<span class="nc" id="L4258">		Date adjustedEnd = null;</span>
<span class="nc bnc" id="L4259" title="All 2 branches missed.">		for (Iterator iter = workResourceIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L4260">			ID id = (ID) iter.next();</span>
<span class="nc" id="L4261">			dTerminate = (Date) terminateDate.get(id);</span>
<span class="nc" id="L4262">			adjustedEnd = dtEnd;</span>
<span class="nc bnc" id="L4263" title="All 2 branches missed.">			if (dTerminate != null) {</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">				if (dTerminate.before(dtStart)) {</span>
<span class="nc" id="L4265">					continue; // has been terminated, no events</span>
				}
<span class="nc bnc" id="L4267" title="All 2 branches missed.">				if (dTerminate.before(dtEnd)) {</span>
<span class="nc" id="L4268">					adjustedEnd = dTerminate;</span>
				}
			}
<span class="nc" id="L4271">			param.clear();</span>
<span class="nc" id="L4272">			param.put(new Integer(1), new Integer(id.toInt()));</span>
<span class="nc" id="L4273">			param.put(new Integer(2), dtStart);</span>
<span class="nc" id="L4274">			param.put(new Integer(3), adjustedEnd);</span>
<span class="nc" id="L4275">			pc.setParams(param);</span>
<span class="nc" id="L4276">			pc.addBatch();</span>
<span class="nc" id="L4277">		}</span>

<span class="nc" id="L4279">		dmo.executeBatchPCommand(pc);</span>
<span class="nc" id="L4280">		return strNativeTempName;</span>
	}

	public HashMap getEmployeeWorkHours(Collection employeeIds, Date startTime, Date endTime, boolean bPublished)
			throws BbmFinderException {
<span class="nc" id="L4285">		methodStart(&quot;getEmployeeWorkHours&quot;, employeeIds, startTime, endTime, new Boolean(bPublished));</span>
<span class="nc" id="L4286">		HashMap mapEmpWorkHours = new HashMap(employeeIds.size());</span>
<span class="nc" id="L4287">		Date periodStart = startTime;</span>
<span class="nc bnc" id="L4288" title="All 2 branches missed.">		Date periodEnd = endTime != null ? TimeZoneUtil.addDay(endTime) : null; // retrieve</span>
																				// one
																				// day
																				// extra
																				// suggested
																				// by
																				// Laurie

<span class="nc" id="L4296">		Jdmo dmo = new Jdmo();</span>
		try {
			// retrieve employee org assignment timezone history and org day
			// boundary
<span class="nc" id="L4300">			Map orgAssignmentHistory = m_workResourceManager.getWRAssignmentsWithTimeZone(employeeIds);</span>
<span class="nc" id="L4301">			HashMap mapIDOrg = new HashMap(); // cache orgs to save some calls</span>
												// to workresource manager

<span class="nc" id="L4304">			StringBuffer sb = new StringBuffer(1000);</span>
<span class="nc" id="L4305">			String nullFunc = dmo.getNullFunctionName();</span>
<span class="nc bnc" id="L4306" title="All 2 branches missed.">			if (!bPublished) {</span>
<span class="nc" id="L4307">				sb.append(</span>
						&quot; select sa.workresourceid, sa.starttime, sa.duration-isnull(sa.EXTENSIONBEFORE,0)-isnull(sa.EXTENSIONAFTER,0)-&quot;)
<span class="nc" id="L4309">						.append(dmo.getNullFunctionName()).append(&quot;(notpaid.totalnotpaid,0) as realduration &quot;);</span>
<span class="nc" id="L4310">				sb.append(&quot; from &quot;);</span>
<span class="nc" id="L4311">				sb.append(</span>
						&quot; (select shiftassignment.id as id, shiftassignment.workresourceid, shiftassignment.starttime, shiftassignment.duration, &quot;)
<span class="nc" id="L4313">						.append(nullFunc).append(&quot;(shiftassignment.extensionbefore,0) as extensionbefore, &quot;)</span>
<span class="nc" id="L4314">						.append(nullFunc)</span>
<span class="nc" id="L4315">						.append(&quot;(shiftassignment.extensionafter,0) as extensionafter from shiftassignment where &quot;);</span>
<span class="nc" id="L4316">				sb.append(&quot; shiftassignment.workresourceid in &quot;).append(dmo.createInClause(employeeIds));</span>
<span class="nc" id="L4317">				sb.append(&quot; and shiftassignment.endtime &gt; '&quot;).append(JdmoUtil.formatDBString(periodStart)).append(&quot;' &quot;);</span>
<span class="nc bnc" id="L4318" title="All 2 branches missed.">				if (endTime != null) {</span>
<span class="nc" id="L4319">					sb.append(&quot; and shiftassignment.starttime &lt; '&quot;).append(JdmoUtil.formatDBString(periodEnd))</span>
<span class="nc" id="L4320">							.append(&quot;' &quot;);</span>
				}
<span class="nc" id="L4322">				sb.append(&quot; ) sa &quot;);</span>
<span class="nc" id="L4323">				sb.append(&quot; left join &quot;);</span>
<span class="nc" id="L4324">				sb.append(</span>
						&quot; (select shift.id as shiftassignmentid, sum(event.DURATION) as totalnotpaid from SHIFTEVENTASSIGNMENT event, SHIFTASSIGNMENT shift where shift.ID = event.SHIFTASSIGNMENTID and event.ISPAID = 0 and event.overtimegaptype=0 and ((&quot;)
<span class="nc" id="L4326">						.append(nullFunc).append(&quot;(shift.extensionbefore,0)=0 and &quot;).append(nullFunc)</span>
<span class="nc" id="L4327">						.append(&quot;(shift.extensionafter,0)=0) or (event.starttime &gt;= dateadd(minute, &quot;).append(nullFunc)</span>
<span class="nc" id="L4328">						.append(&quot;(shift.extensionbefore,0), shift.starttime) and dateadd(minute, event.duration , event.starttime) &lt;= dateadd(minute, -&quot;)</span>
<span class="nc" id="L4329">						.append(nullFunc).append(&quot;(extensionafter,0), shift.endtime))) group by shift.ID) notpaid &quot;);</span>
<span class="nc" id="L4330">				sb.append(&quot; on sa.id = notpaid.shiftassignmentid&quot;);</span>
<span class="nc" id="L4331">				sb.append(&quot; order by sa.workresourceid, sa.starttime&quot;);</span>
			} else {
<span class="nc" id="L4333">				sb.append(</span>
						&quot; select sa.workresourceid, sa.starttime, sa.duration-isnull(sa.EXTENSIONBEFORE,0)-isnull(sa.EXTENSIONAFTER,0)-&quot;)
<span class="nc" id="L4335">						.append(dmo.getNullFunctionName()).append(&quot;(notpaid.totalnotpaid,0) as realduration &quot;);</span>
<span class="nc" id="L4336">				sb.append(&quot; from &quot;);</span>
<span class="nc" id="L4337">				sb.append(</span>
						&quot; (select shiftassignmentpub.id as id, shiftassignmentpub.workresourceid, shiftassignmentpub.starttime, shiftassignmentpub.duration, &quot;)
<span class="nc" id="L4339">						.append(nullFunc).append(&quot;(shiftassignmentpub.extensionbefore,0) as extensionbefore, &quot;)</span>
<span class="nc" id="L4340">						.append(nullFunc)</span>
<span class="nc" id="L4341">						.append(&quot;(shiftassignmentpub.extensionafter,0) as extensionafter from shiftassignmentpub where &quot;);</span>
<span class="nc" id="L4342">				sb.append(&quot; shiftassignmentpub.workresourceid in &quot;).append(dmo.createInClause(employeeIds));</span>
<span class="nc" id="L4343">				sb.append(&quot; and shiftassignmentpub.endtime &gt; '&quot;).append(JdmoUtil.formatDBString(periodStart))</span>
<span class="nc" id="L4344">						.append(&quot;' &quot;);</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">				if (endTime != null) {</span>
<span class="nc" id="L4346">					sb.append(&quot; and shiftassignmentpub.starttime &lt; '&quot;).append(JdmoUtil.formatDBString(periodEnd))</span>
<span class="nc" id="L4347">							.append(&quot;' &quot;);</span>
				}
<span class="nc" id="L4349">				sb.append(&quot; ) sa &quot;);</span>
<span class="nc" id="L4350">				sb.append(&quot; left join &quot;);</span>
<span class="nc" id="L4351">				sb.append(</span>
						&quot; (select shift.id as shiftassignmentid, sum(event.DURATION) as totalnotpaid from SHIFTEVENTASSIGNMENTPUB event, SHIFTASSIGNMENTPUB shift where shift.ID = event.SHIFTASSIGNMENTID and event.ISPAID = 0 and event.overtimegaptype=0 and ((&quot;)
<span class="nc" id="L4353">						.append(nullFunc).append(&quot;(shift.extensionbefore,0)=0 and &quot;).append(nullFunc)</span>
<span class="nc" id="L4354">						.append(&quot;(shift.extensionafter,0)=0) or (event.starttime &gt;= dateadd(minute, &quot;).append(nullFunc)</span>
<span class="nc" id="L4355">						.append(&quot;(extensionbefore,0), shift.starttime) and dateadd(minute, event.duration , event.starttime) &lt;= dateadd(minute, -&quot;)</span>
<span class="nc" id="L4356">						.append(nullFunc).append(&quot;(extensionafter,0), shift.endtime))) group by shift.ID) notpaid &quot;);</span>
<span class="nc" id="L4357">				sb.append(&quot; on sa.id = notpaid.shiftassignmentid&quot;);</span>
<span class="nc" id="L4358">				sb.append(&quot; order by sa.workresourceid, sa.starttime&quot;);</span>
			}

<span class="nc" id="L4361">			JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc" id="L4362">			ID previousWKRSID = null;</span>
<span class="nc" id="L4363">			ID wkrsID = null;</span>
<span class="nc" id="L4364">			Date previousDayStart = null;</span>
<span class="nc" id="L4365">			Date currentDayStart = null;</span>
<span class="nc" id="L4366">			Date shiftStart = null;</span>
<span class="nc" id="L4367">			int workHourPerDay = 0;</span>
<span class="nc" id="L4368">			ArrayList workHourPerDayList = null;</span>
<span class="nc" id="L4369">			Date endOrgDayStartInGMT = null;</span>
<span class="nc bnc" id="L4370" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4371">				wkrsID = rs.getID(1);</span>
<span class="nc" id="L4372">				shiftStart = rs.getTimestamp(2);</span>
<span class="nc" id="L4373">				workHourPerDay = rs.getInt(3);</span>
				// prepare new employee data reading
<span class="nc bnc" id="L4375" title="All 4 branches missed.">				if (previousWKRSID == null || !previousWKRSID.equals(wkrsID)) { // start</span>
																				// new
																				// employee
																				// reading
<span class="nc" id="L4379">					endOrgDayStartInGMT = getOrgDayStartInGMT(periodEnd, (Collection) orgAssignmentHistory.get(wkrsID),</span>
							mapIDOrg);
<span class="nc bnc" id="L4381" title="All 2 branches missed.">					if (previousWKRSID != null) {</span>
						// the beginning of next employee data reading, also the
						// end of previous employee reading
<span class="nc bnc" id="L4384" title="All 2 branches missed.">						while (!previousDayStart.after(endOrgDayStartInGMT)) {</span>
<span class="nc" id="L4385">							workHourPerDayList.add(new Integer(0));</span>
							// previousDayStart =
							// TimeZoneUtil.addDay(previousDayStart);
<span class="nc" id="L4388">							previousDayStart = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg,</span>
									previousDayStart);
							// previousDayStart =
							// getOrgDayStartInGMT(previousDayStart,
							// (Collection)orgAssignmentHistory.get(wkrsID),
							// mapIDOrg);
						}
					}
<span class="nc" id="L4396">					previousDayStart = getOrgDayStartInGMT(startTime, (Collection) orgAssignmentHistory.get(wkrsID),</span>
							mapIDOrg);
<span class="nc" id="L4398">					workHourPerDayList = (ArrayList) (mapEmpWorkHours.get(wkrsID));</span>
<span class="nc bnc" id="L4399" title="All 2 branches missed.">					if (workHourPerDayList == null) {</span>
<span class="nc" id="L4400">						workHourPerDayList = new ArrayList();</span>
<span class="nc" id="L4401">						mapEmpWorkHours.put(wkrsID, workHourPerDayList);</span>
					}
				}

<span class="nc" id="L4405">				currentDayStart = getOrgDayStartInGMT(shiftStart, (Collection) orgAssignmentHistory.get(wkrsID),</span>
						mapIDOrg);
				// handle the days before the current shift
<span class="nc bnc" id="L4408" title="All 2 branches missed.">				while (previousDayStart.before(currentDayStart)</span>
<span class="nc bnc" id="L4409" title="All 2 branches missed.">						&amp;&amp; TimeZoneUtil.numberOfMinutes(previousDayStart, currentDayStart) &gt; 60) { // for</span>
																									// DST
																									// date,
																									// one
																									// hour
																									// diff
																									// should
																									// not
																									// be
																									// considered
																									// diff
																									// day.
																									// fix
																									// QC52470
<span class="nc" id="L4423">					workHourPerDayList.add(new Integer(0));</span>
					// previousDayStart = TimeZoneUtil.addDay(previousDayStart);
<span class="nc" id="L4425">					previousDayStart = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg,</span>
							previousDayStart);
					// previousDayStart = getOrgDayStartInGMT(previousDayStart,
					// (Collection)orgAssignmentHistory.get(wkrsID), mapIDOrg);
				}
<span class="nc" id="L4430">				previousDayStart = currentDayStart; // just in case DST or time</span>
													// zone changed.
<span class="nc" id="L4432">				workHourPerDayList.add(new Integer(workHourPerDay)); // handle</span>
																		// the
																		// current
																		// shift
				// previousDayStart = TimeZoneUtil.addDay(previousDayStart);
				// //move to next day
<span class="nc" id="L4438">				previousDayStart = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg,</span>
						previousDayStart);
				// previousDayStart = getOrgDayStartInGMT(previousDayStart,
				// (Collection)orgAssignmentHistory.get(wkrsID), mapIDOrg);
<span class="nc" id="L4442">				previousWKRSID = wkrsID;</span>
			}
			// for last employee, may need to append 0s
<span class="nc bnc" id="L4445" title="All 2 branches missed.">			if (previousWKRSID != null) {</span>
				// the beginning of next employee data reading, also the end of
				// previous employee reading
<span class="nc bnc" id="L4448" title="All 2 branches missed.">				while (!previousDayStart.after(endOrgDayStartInGMT)) {</span>
<span class="nc" id="L4449">					workHourPerDayList.add(new Integer(0));</span>
					// previousDayStart = TimeZoneUtil.addDay(previousDayStart);
<span class="nc" id="L4451">					previousDayStart = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg,</span>
							previousDayStart);
					// previousDayStart = getOrgDayStartInGMT(previousDayStart,
					// (Collection)orgAssignmentHistory.get(wkrsID), mapIDOrg);
				}
			}
<span class="nc" id="L4457">			return mapEmpWorkHours;</span>
<span class="nc" id="L4458">		} catch (Exception e) {</span>
<span class="nc" id="L4459">			handleException(e);</span>
<span class="nc" id="L4460">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L4462" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L4463">				dmo.cleanUp();</span>
			}
<span class="nc" id="L4465">			methodFinish();</span>
		}
	}

	private Date addOneOrgDay(Collection orgAssignmentHistory, Map mapIDOrg, Date timeSpot) {
<span class="nc" id="L4470">		WorkResourceAssignment assignment = WorkResourceAssignment.getRelatedWRAssignment(orgAssignmentHistory,</span>
<span class="nc" id="L4471">				TimeZoneUtil.addDay(timeSpot)); // add one day to the spot to</span>
												// get org to avoid day boundary
												// problem
<span class="nc bnc" id="L4474" title="All 2 branches missed.">		if (assignment == null) {</span>
			// employee has not started or been terminated at the timespot,
			// return the first one
<span class="nc" id="L4477">			assignment = (WorkResourceAssignment) orgAssignmentHistory.iterator().next();</span>
		}
<span class="nc" id="L4479">		ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4480">		Organization org = (Organization) mapIDOrg.get(orgID);</span>

		try {
<span class="nc bnc" id="L4483" title="All 2 branches missed.">			if (org == null) {</span>
<span class="nc" id="L4484">				org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L4485">				mapIDOrg.put(orgID, org);</span>
			}
<span class="nc" id="L4487">		} catch (Exception e) {</span>
<span class="nc" id="L4488">		}</span>

<span class="nc" id="L4490">		TimeZone orgTimeZone = org.getTimeZone();</span>
<span class="nc" id="L4491">		Calendar calendar = Calendar.getInstance(orgTimeZone);</span>
<span class="nc" id="L4492">		calendar.setTime(timeSpot);</span>
<span class="nc" id="L4493">		calendar.add(Calendar.DATE, 1);</span>

<span class="nc" id="L4495">		return calendar.getTime();</span>
	}

	private Date getOrgDayStartInGMT(Date timeSpotInGMT, Collection orgAssignmentHistory, HashMap mapIDOrg)
			throws Exception {
<span class="nc" id="L4500">		WorkResourceAssignment assignment = WorkResourceAssignment.getRelatedWRAssignment(orgAssignmentHistory,</span>
<span class="nc" id="L4501">				TimeZoneUtil.addDay(timeSpotInGMT)); // add one day to the spot</span>
														// to get org to avoid
														// day boundary problem
<span class="nc bnc" id="L4504" title="All 2 branches missed.">		if (assignment == null) {</span>
			// employee has not started or been terminated at the timespot,
			// return the first one
<span class="nc" id="L4507">			assignment = (WorkResourceAssignment) orgAssignmentHistory.iterator().next();</span>
		}
<span class="nc" id="L4509">		ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4510">		Organization org = (Organization) mapIDOrg.get(orgID);</span>
<span class="nc bnc" id="L4511" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L4512">			org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L4513">			mapIDOrg.put(orgID, org);</span>
		}
<span class="nc" id="L4515">		int dayBoundaryInMinute = org.getDayBoundaryOffset();</span>
<span class="nc" id="L4516">		Calendar gmt = Calendar.getInstance(TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L4517">		gmt.setTime(timeSpotInGMT);</span>

<span class="nc" id="L4519">		Calendar orgCalendar = Calendar.getInstance(assignment.getStartTimeZone());</span>
<span class="nc" id="L4520">		orgCalendar.set(Calendar.YEAR, gmt.get(Calendar.YEAR));</span>
<span class="nc" id="L4521">		orgCalendar.set(Calendar.MONTH, gmt.get(Calendar.MONTH));</span>
<span class="nc" id="L4522">		orgCalendar.set(Calendar.DAY_OF_MONTH, gmt.get(Calendar.DAY_OF_MONTH));</span>
<span class="nc" id="L4523">		orgCalendar.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L4524">		orgCalendar.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L4525">		orgCalendar.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L4526">		orgCalendar.add(Calendar.MINUTE, dayBoundaryInMinute);</span>
<span class="nc" id="L4527">		return orgCalendar.getTime();</span>
	}

	public void setSPIDLockCustomizedShifts(ID spID, Collection idShiftsToSetSPID, Collection idShiftsToLock)
			throws BbmUpdateException {
<span class="nc" id="L4532">		methodStart(&quot;setCampaignIDLockCustomizedShifts&quot;, spID, idShiftsToSetSPID, idShiftsToLock);</span>

<span class="nc" id="L4534">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L4536" title="All 4 branches missed.">			if (idShiftsToSetSPID != null &amp;&amp; !idShiftsToSetSPID.isEmpty()) {</span>
<span class="nc" id="L4537">				StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L4538">				sb.append(&quot;update shiftassignment set spid = &quot;).append(spID).append(&quot; where id in &quot;)</span>
<span class="nc" id="L4539">						.append(dmo.createInClause(idShiftsToSetSPID));</span>
<span class="nc" id="L4540">				dmo.execute(sb.toString());</span>
			}
<span class="nc bnc" id="L4542" title="All 4 branches missed.">			if (idShiftsToLock != null &amp;&amp; !idShiftsToLock.isEmpty()) {</span>
<span class="nc" id="L4543">				StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L4544">				sb.append(&quot;update shiftassignment set islocked = 1 where id in &quot;)</span>
<span class="nc" id="L4545">						.append(dmo.createInClause(idShiftsToLock));</span>
				// sb.append(&quot;;&quot;);
				// sb.append(&quot;update shifteventassignment set islocked = 1 where
				// shiftassignmentid
				// in&quot;).append(dmo.createInClause(idShiftsToLock));
<span class="nc" id="L4550">				dmo.execute(sb.toString());</span>
			}
<span class="nc" id="L4552">		} catch (Exception e) {</span>
<span class="nc" id="L4553">			handleException(e);</span>
<span class="nc" id="L4554">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L4556" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L4557">				dmo.cleanUp();</span>
			}
<span class="nc" id="L4559">			methodFinish();</span>
<span class="nc" id="L4560">		}</span>
<span class="nc" id="L4561">	}</span>

	/**
	 * Create a complete overtime shift, which is implemented as a shift
	 * assignment with a main shift of zero length, and only an OT Extension
	 * after the shift.
	 *
	 * @param workResourceID
	 * @param startTime
	 * @param oteID
	 * @throws BbmCreateException
	 */
	public void createOTShiftAssignment(ID workResourceID, Date startTime, ID oteID) throws BbmCreateException {
<span class="nc" id="L4574">		methodStart(&quot;createOTShiftAssignment&quot;, startTime, oteID);</span>
		try {
<span class="nc" id="L4576">            ArrayList&lt;ID&gt; list = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L4577">			list.add(oteID);</span>
<span class="nc" id="L4578">			ShiftOTExtension ote = (ShiftOTExtension) m_workRuleManager.getShiftOTExtensionsByIDs(list).iterator().next();</span>
<span class="nc" id="L4579">			ShiftAssignment sa = new ShiftAssignment();</span>
<span class="nc" id="L4580">			sa.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L4581">			sa.setStartTime(startTime);</span>
<span class="nc" id="L4582">			sa.setDuration(0);</span>
<span class="nc" id="L4583">			sa.setActivityID(ote.getActivityID());</span>

<span class="nc" id="L4585">			ScheduleUtil.addOTE(sa, ote, false, true, true);</span>
<span class="nc" id="L4586">			createShiftAssignment(sa);</span>
<span class="nc" id="L4587">		} catch (Exception e) {</span>
<span class="nc" id="L4588">			handleException(e);</span>
<span class="nc" id="L4589">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L4591">			methodFinish();</span>
<span class="nc" id="L4592">		}</span>
<span class="nc" id="L4593">	}</span>

	// ====== new APIs for creating phantom on web calendar ============
	public HashMap getPhantomsOrganizations(Collection phantomIDs) throws BbmFinderException {
<span class="fc" id="L4597">		methodStart(&quot;getPhantomsOrganizations&quot;, phantomIDs);</span>
<span class="fc" id="L4598">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4600">			return dao.getPhantomsOrganizations(new HashSet(phantomIDs));</span>
<span class="nc" id="L4601">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4602">			handleException(e);</span>
<span class="nc" id="L4603">			throw e;</span>
<span class="nc" id="L4604">		} catch (Exception e) {</span>
<span class="nc" id="L4605">			handleException(e);</span>
<span class="nc" id="L4606">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L4608">			dao.cleanUp();</span>
<span class="pc" id="L4609">			methodFinish();</span>
		}
	}

	/**
	 * get phantom names given their IDs
	 *
	 * @return hashmap of (idPhantom, phantomName)
	 */
	public HashMap getPhantomEmployeeNamesByIDs(Collection colIDs) throws BbmFinderException {
<span class="fc" id="L4619">		methodStart(&quot;getPhantomEmployeeNamesByIDs&quot;, colIDs);</span>
<span class="fc" id="L4620">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4622">			return dao.getPhantomEmployeeNamesByIDs(colIDs);</span>
<span class="nc" id="L4623">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4624">			handleException(e, false);</span>
<span class="nc" id="L4625">			throw e;</span>
		} finally {
<span class="pc" id="L4627">			dao.cleanUp();</span>
<span class="pc" id="L4628">			methodFinish();</span>
		}
	}

	public ID createPhantom(ID empID, ID spID, Date start, Date end) throws BbmCreateException {
<span class="nc" id="L4633">		return (ID) createPhantoms(Arrays.asList(empID), spID, start, end).iterator().next();</span>
	}

	// start and end are in GMT
	public Collection createPhantoms(Collection empIDs, ID spID, Date start, Date end) throws BbmCreateException {
<span class="nc" id="L4638">		methodStart(&quot;createPhantoms&quot;, empIDs, start, end);</span>
<span class="nc" id="L4639">		ArrayList ids = new ArrayList(empIDs.size());</span>
<span class="nc" id="L4640">		PhantomDAO dao = new PhantomDAO();</span>
<span class="nc" id="L4641">		ArrayList phantoms = new ArrayList(empIDs.size());</span>
<span class="nc" id="L4642">		HashMap empPhantomIDMap = new HashMap(empIDs.size());</span>
<span class="nc" id="L4643">		HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; empIDShiftAssignmentMap = new HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt;(</span>
<span class="nc" id="L4644">				empIDs.size());</span>
<span class="nc" id="L4645">		HashMap nextPhantomNameMap = new HashMap(empIDs.size());</span>
<span class="nc" id="L4646">		HashMap&lt;ID, Employee&gt; employeeNameByID = new HashMap&lt;ID, Employee&gt;(empIDs.size());</span>
		try {
<span class="nc" id="L4648">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT;</span>
<span class="nc" id="L4649">			Collection empShiftAssignments = getEventsForWorkResourcesByType(eventTypeMask, empIDs, start, end);</span>
<span class="nc" id="L4650">			Collection employees = m_workResourceManager.getEmployeesByIDs(empIDs, start,</span>
					Employee.DETAIL_LEVEL_EMPLOYEE_TIMEBASEDPROPERTY);

<span class="nc" id="L4653">			ID workResourceID = null;</span>
<span class="nc" id="L4654">			Collection empShifts = null;</span>

<span class="nc" id="L4656">			Iterator iEmpID = empIDs.iterator();</span>
<span class="nc" id="L4657">			Iterator iEmpShift = empShiftAssignments.iterator();</span>
<span class="nc bnc" id="L4658" title="All 2 branches missed.">			for (; iEmpID.hasNext();) {</span>
<span class="nc" id="L4659">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4660">				empShifts = (Collection) iEmpShift.next();</span>
<span class="nc" id="L4661">				empIDShiftAssignmentMap.put(workResourceID, empShifts);</span>
<span class="nc bnc" id="L4662" title="All 4 branches missed.">				if (empShifts == null || empShifts.isEmpty()) {</span>
					// if employee doesn't have a schedule, skip it.
<span class="nc" id="L4664">					iEmpID.remove();</span>
<span class="nc" id="L4665">					continue;</span>
				}
			}

<span class="nc" id="L4669">			Iterator iEmployees = employees.iterator();</span>
<span class="nc bnc" id="L4670" title="All 2 branches missed.">			for (; iEmployees.hasNext();) {</span>
<span class="nc" id="L4671">				Employee emp = (Employee) iEmployees.next();</span>
<span class="nc" id="L4672">				employeeNameByID.put(emp.getID(), emp);</span>

<span class="nc" id="L4674">			}</span>

<span class="nc" id="L4676">			HashMap complexWorkRules = m_empWorkRuleManager.getComplexWorkRuleAssignments(empIDs);</span>
<span class="nc" id="L4677">			HashMap rotationWorkRules = m_empWorkRuleManager.getRotationAssignments(empIDs);</span>

			// QC120615: taking out database calls from for-loop to improve
			// performance

<span class="nc" id="L4682">			TimeZone gmtTZ = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
<span class="nc" id="L4683">			HashMap&lt;ID, Collection&lt;WorkResourceAssignment&gt;&gt; orgAssignmentsForEmployees = getWorkResourceManager()</span>
<span class="nc" id="L4684">					.getValidWorkResourceAssignments(empIDs, new LocalDate(start, TimeZone.getTimeZone(&quot;GMT&quot;)),</span>
<span class="nc" id="L4685">							new LocalDate(end, TimeZone.getTimeZone(&quot;GMT&quot;)));</span>

<span class="nc" id="L4687">			HashMap&lt;ID, Collection&lt;SkillAssignment&gt;&gt; employeesSkillAssignments = m_skillManager</span>
<span class="nc" id="L4688">					.getSkillAssignmentInPeriodAndOnSpotOnly(empIDs, start, end, start);</span>
<span class="nc" id="L4689">			HashMap&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; employeesWorkPatterns = m_empWorkRuleManager</span>
<span class="nc" id="L4690">					.getWorkPatternAssignments(empIDs, start, end);</span>
<span class="nc" id="L4691">			HashMap&lt;ID, Collection&lt;ShiftPattern&gt;&gt; shiftPatternByWorkUnitID = new HashMap&lt;ID, Collection&lt;ShiftPattern&gt;&gt;();</span>

<span class="nc" id="L4693">			HashMap&lt;ID, Collection&lt;Skill&gt;&gt; employeesSkills = m_skillManager.getSkillsForWorkResources(empIDs, start,</span>
					end);

<span class="nc" id="L4696">			HashMap&lt;ID, String&gt; derivedNameByID = derivePhantomNamesForEmployees(empIDShiftAssignmentMap, spID, start,</span>
					end, employeesSkills, employeeNameByID);

<span class="nc" id="L4699">			iEmpID = empIDs.iterator();</span>

<span class="nc bnc" id="L4701" title="All 2 branches missed.">			for (; iEmpID.hasNext();) {</span>
<span class="nc" id="L4702">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4703">				Employee emp = employeeNameByID.get(workResourceID);</span>

<span class="nc" id="L4705">				Collection&lt;WorkResourceAssignment&gt; orgAssignments = orgAssignmentsForEmployees.get(workResourceID);</span>
<span class="nc" id="L4706">				WorkResourceAssignment assignment = orgAssignments.iterator().next();</span>

<span class="nc" id="L4708">				ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4709">				int proficiency = emp.getProficiency();</span>

<span class="nc" id="L4711">				Collection skills = employeesSkills.get(workResourceID);</span>
<span class="nc" id="L4712">				Collection skillDEIDs = new ArrayList();</span>
<span class="nc bnc" id="L4713" title="All 2 branches missed.">				if (skills != null) {</span>
<span class="nc bnc" id="L4714" title="All 2 branches missed.">					for (Iterator iSkill = skills.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L4715">						skillDEIDs.add(new ID(((Skill) iSkill.next()).getIDStr()));</span>
					}
				}

				// get the Employees Work Patterns to be used for finding
				// employeeTemplate
<span class="nc" id="L4721">				ArrayList shiftPatternIDs = new ArrayList();</span>
<span class="nc" id="L4722">				Collection empRotationWorkRules = (Collection) rotationWorkRules.get(workResourceID);</span>
<span class="nc" id="L4723">				WorkResourceRotation empRotationWorkRule = null;</span>
<span class="nc" id="L4724">				ID complexWorkRuleID = null;</span>
<span class="nc" id="L4725">				Rotation rotationWorkRule = null;</span>

<span class="nc bnc" id="L4727" title="All 4 branches missed.">				if (empRotationWorkRules != null &amp;&amp; !empRotationWorkRules.isEmpty()) {</span>
					/*
					 * 3/1/10 angela: san diego team has to make
					 * WorkResourceComplexWorkRule object return SID of complext
					 * work rule then we can work on this code.
					 */
<span class="nc" id="L4733">					ID curShiftPatternID = null;</span>
<span class="nc bnc" id="L4734" title="All 2 branches missed.">					for (Iterator iComplextWorkRules = empRotationWorkRules.iterator(); iComplextWorkRules.hasNext();) {</span>
<span class="nc" id="L4735">						empRotationWorkRule = (WorkResourceRotation) iComplextWorkRules.next();</span>
<span class="nc" id="L4736">						rotationWorkRule = empRotationWorkRule.getRotation();</span>

<span class="nc" id="L4738">						Collection shiftPatterns = rotationWorkRule.getShiftPatterns();</span>
<span class="nc bnc" id="L4739" title="All 4 branches missed.">						if (shiftPatterns != null &amp;&amp; !shiftPatterns.isEmpty()) {</span>
<span class="nc" id="L4740">							curShiftPatternID = getRotationCurrentShiftPatternID(workResourceID, orgID,</span>
									empRotationWorkRule, rotationWorkRule, shiftPatterns, start);
<span class="nc bnc" id="L4742" title="All 2 branches missed.">							if (curShiftPatternID != null) {</span>
<span class="nc" id="L4743">								shiftPatternIDs.add(curShiftPatternID);</span>
							}
						}
<span class="nc" id="L4746">					}</span>
<span class="nc" id="L4747">				} else {</span>
					// no rotation rule, use employee shift pattern
<span class="nc" id="L4749">					Collection&lt;WorkResourceWorkPattern&gt; shiftPatternAssignments = employeesWorkPatterns</span>
<span class="nc" id="L4750">							.get(workResourceID);</span>
<span class="nc bnc" id="L4751" title="All 4 branches missed.">					if (shiftPatternAssignments != null &amp;&amp; !shiftPatternAssignments.isEmpty()) {</span>
<span class="nc" id="L4752">						for (Iterator&lt;WorkResourceWorkPattern&gt; iShiftPatterns = shiftPatternAssignments</span>
<span class="nc bnc" id="L4753" title="All 2 branches missed.">								.iterator(); iShiftPatterns.hasNext();) {</span>
<span class="nc" id="L4754">							shiftPatternIDs.add((iShiftPatterns.next()).getWorkPatternSID());</span>
						}
					}
				}

<span class="nc" id="L4759">				Collection empSkillAssignments = employeesSkillAssignments.get(workResourceID);</span>
<span class="nc" id="L4760">				String phantomLastName = derivedNameByID.get(workResourceID);</span>
				// looking for existing matching emp template based on skill and
				// shift pattern
<span class="nc" id="L4763">				EmployeeTemplate empTemplate = FindHiddenEmpTemplateWithAttributes(dao.getDMO(), orgID, phantomLastName,</span>
<span class="nc" id="L4764">						emp.getWage(), skillDEIDs, shiftPatternIDs, proficiency);</span>
<span class="nc bnc" id="L4765" title="All 2 branches missed.">				if (empTemplate == null) {</span>
					// create a new template
<span class="nc" id="L4767">					empTemplate = new EmployeeTemplate();</span>
<span class="nc" id="L4768">					empTemplate.setOrganizationID(orgID);</span>
<span class="nc" id="L4769">					empTemplate.setName(phantomLastName);</span>
<span class="nc" id="L4770">					empTemplate.setWage(emp.getWage());</span>
<span class="nc" id="L4771">					empTemplate.setChatSessions(1); // todo, should get chat</span>
													// sessions from
													// workresourcemedia table
													// later.
<span class="nc" id="L4775">					empTemplate.setIsHidden(true);</span>
<span class="nc" id="L4776">					empTemplate.setProficiency(proficiency / 10.0);</span>
<span class="nc bnc" id="L4777" title="All 4 branches missed.">					if (empSkillAssignments != null &amp;&amp; !empSkillAssignments.isEmpty()) {</span>
<span class="nc" id="L4778">						empTemplate.setSkillAssignments(empSkillAssignments);</span>
					}
<span class="nc bnc" id="L4780" title="All 4 branches missed.">					if (shiftPatternIDs != null &amp;&amp; !shiftPatternIDs.isEmpty()) {</span>
<span class="nc" id="L4781">						empTemplate.setShiftPatterns(shiftPatternIDs);</span>
					}
<span class="nc" id="L4783">					ID empTemplateSID = this.createEmployeeTemplate(empTemplate);</span>
<span class="nc" id="L4784">					empTemplate.setID(empTemplateSID);</span>
				}
				// have template now and create phantom
<span class="nc" id="L4787">				Phantom phantom = new Phantom();</span>
<span class="nc" id="L4788">				phantom.setEmployeeTemplateID(empTemplate.getID());</span>
<span class="nc" id="L4789">				phantom.setName(getPhantomFirstName(dao.getDMO(), empTemplate.getID(), nextPhantomNameMap));</span>
<span class="nc" id="L4790">				phantoms.add(phantom);</span>
<span class="nc" id="L4791">			} // end of for loop</span>

<span class="nc" id="L4793">			Collection phantomIDs = dao.createPhantoms(phantoms);</span>
<span class="nc" id="L4794">			iEmpID = empIDs.iterator();</span>
<span class="nc" id="L4795">			Iterator iPhantomID = phantomIDs.iterator();</span>
<span class="nc" id="L4796">			ArrayList phantomShifts = new ArrayList();</span>
<span class="nc" id="L4797">			ArrayList phantomComplexWorkRules = new ArrayList();</span>
<span class="nc" id="L4798">			ID phantomID = null;</span>
<span class="nc bnc" id="L4799" title="All 2 branches missed.">			while (iEmpID.hasNext()) {</span>
<span class="nc" id="L4800">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4801">				phantomID = (ID) iPhantomID.next();</span>
<span class="nc" id="L4802">				empShifts = empIDShiftAssignmentMap.get(workResourceID);</span>
<span class="nc" id="L4803">				phantomShifts.addAll(reassignShiftAssignmentToPhantom(spID, workResourceID, phantomID, empShifts));</span>
<span class="nc" id="L4804">				phantomComplexWorkRules.addAll(reassignComplexWorkRuleToPhantom(workResourceID, phantomID,</span>
<span class="nc" id="L4805">						(Collection) complexWorkRules.get(workResourceID), dao.getDMO()));</span>
			}
<span class="nc" id="L4807">			createShiftAssignments(phantomShifts);</span>
<span class="nc" id="L4808">			deleteShiftAssignments(empIDs, start, end, spID, false);</span>

<span class="nc bnc" id="L4810" title="All 2 branches missed.">			if (!phantomComplexWorkRules.isEmpty()) {</span>
<span class="nc" id="L4811">				m_empWorkRuleManager.createComplexWorkRuleAssignments(phantomComplexWorkRules);</span>
			}

			// link just created phantoms to the sp
<span class="nc" id="L4815">			Jdmo dmo = dao.getDMO();</span>
<span class="nc" id="L4816">			JdmoRowset rs = dmo.createRowset(&quot;select id from sp where sid = &quot; + spID);</span>
<span class="nc" id="L4817">			String deSPID = null;</span>
<span class="nc bnc" id="L4818" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4819">				deSPID = rs.getString(1);</span>
			}
<span class="nc bnc" id="L4821" title="All 6 branches missed.">			if (deSPID != null &amp;&amp; phantomIDs != null &amp;&amp; !phantomIDs.isEmpty()) {</span>
<span class="nc" id="L4822">				HashMap nameValues = new HashMap(2);</span>
<span class="nc bnc" id="L4823" title="All 2 branches missed.">				for (Iterator i = phantomIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4824">					nameValues.put(&quot;SPID&quot;, deSPID);</span>
<span class="nc" id="L4825">					nameValues.put(&quot;WORKRESOURCEID&quot;, i.next());</span>
<span class="nc" id="L4826">					dmo.addBatchInsert(&quot;SPWORKRESOURCE&quot;, nameValues);</span>
				}
<span class="nc" id="L4828">				dmo.executeBatch();</span>
			}

<span class="nc" id="L4831">			return phantomIDs;</span>
<span class="nc" id="L4832">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L4833">			handleException(e);</span>
<span class="nc" id="L4834">			throw e;</span>
<span class="nc" id="L4835">		} catch (Exception e) {</span>
<span class="nc" id="L4836">			handleException(e);</span>
<span class="nc" id="L4837">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L4839">			dao.cleanUp();</span>
<span class="nc" id="L4840">			methodFinish();</span>
		}
	}

	public ID createPhantom(Phantom objValue) throws BbmCreateException {
<span class="nc" id="L4845">		return createPhantoms(new ArrayList(Arrays.asList(objValue))).iterator().next();</span>
	}

	public Collection&lt;ID&gt; createPhantoms(Collection objValues) throws BbmCreateException {
<span class="fc" id="L4849">		methodStart(&quot;createPhantoms&quot;, objValues);</span>
<span class="fc" id="L4850">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4852">			return dao.createPhantoms(objValues);</span>
<span class="nc" id="L4853">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L4854">			handleException(e);</span>
<span class="nc" id="L4855">			throw e;</span>
		} finally {
<span class="pc" id="L4857">			dao.cleanUp();</span>
<span class="pc" id="L4858">			methodFinish();</span>
		}
	}

	public void deletePhantoms(Collection colPhantomIDs) throws BbmRemoveException {
<span class="nc" id="L4863">		methodStart(&quot;deletePhantoms&quot;, colPhantomIDs);</span>
<span class="nc" id="L4864">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4866">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4867">			dao.deletePhantoms(colPhantomIDs);</span>
<span class="nc" id="L4868">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4869">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4870">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4871">			handleException(e);</span>
<span class="nc" id="L4872">			throw e;</span>
		} finally {
<span class="nc" id="L4874">			dmo.cleanUp();</span>
<span class="nc" id="L4875">			methodFinish();</span>
<span class="nc" id="L4876">		}</span>
<span class="nc" id="L4877">	}</span>

	public void deletePhantomsByEmployeeTemplateID(ID empTemplateID) throws BbmRemoveException {
<span class="nc" id="L4880">		methodStart(&quot;deletePhantomsByEmployeeTemplateID&quot;, empTemplateID);</span>
<span class="nc" id="L4881">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4883">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4884">			dao.deletePhantomsByEmployeeTemplate(empTemplateID);</span>
<span class="nc" id="L4885">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4886">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4887">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4888">			handleException(e);</span>
<span class="nc" id="L4889">			throw e;</span>
		} finally {
<span class="nc" id="L4891">			dmo.cleanUp();</span>
<span class="nc" id="L4892">			methodFinish();</span>
<span class="nc" id="L4893">		}</span>
<span class="nc" id="L4894">	}</span>

	public Phantom getPhantomByID(ID idPhantom) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L4897">		return (Phantom) getPhantomsByIDs(Arrays.asList(idPhantom)).iterator().next();</span>
	}

	public Collection getPhantomsByIDs(Collection colIDs) throws BbmFinderException {
<span class="fc" id="L4901">		methodStart(&quot;getPhantomsByIDs&quot;, colIDs);</span>
<span class="fc" id="L4902">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4904">			return dao.getPhantoms(colIDs, null);</span>
<span class="nc" id="L4905">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4906">			handleException(e);</span>
<span class="nc" id="L4907">			throw e;</span>
		} finally {
<span class="pc" id="L4909">			dao.cleanUp();</span>
<span class="pc" id="L4910">			methodFinish();</span>
		}
	}

	/**
	 * get phantom employees for a given scheduling period
	 */
	public Collection getPhantoms(ID idSchedulingPeriod) throws BbmFinderException {
<span class="fc" id="L4918">		methodStart(&quot;getPhantoms&quot;, idSchedulingPeriod);</span>
<span class="fc" id="L4919">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4921">			return dao.getPhantoms(null, idSchedulingPeriod);</span>
<span class="nc" id="L4922">		} catch (Exception e) {</span>
<span class="nc" id="L4923">			handleException(e);</span>
<span class="nc" id="L4924">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L4926">			dao.cleanUp();</span>
<span class="pc" id="L4927">			methodFinish();</span>
		}
	}

	/**
	 * delete phantoms given scheduling period id
	 */
	public void deletePhantomsBySchedulingPeriod(ID idSchedulingPeriod) throws BbmRemoveException {
<span class="nc" id="L4935">		methodStart(&quot;deletePhantomsBySchedulingPeriod&quot;, idSchedulingPeriod);</span>
<span class="nc" id="L4936">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4938">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4939">			dao.deletePhantomsBySchedulingPeriod(idSchedulingPeriod);</span>
<span class="nc" id="L4940">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4941">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4942">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4943">			handleException(e);</span>
<span class="nc" id="L4944">			throw e;</span>
		} finally {
<span class="nc" id="L4946">			dmo.cleanUp();</span>
<span class="nc" id="L4947">			methodFinish();</span>
<span class="nc" id="L4948">		}</span>
<span class="nc" id="L4949">	}</span>

	public void deletePhantoms(ID idOrg, ID idSchedulingPeriod) throws BbmRemoveException {
<span class="nc" id="L4952">		methodStart(&quot;deletePhantoms&quot;, idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4953">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4955">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4956">			dao.deletePhantoms(idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4957">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4958">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4959">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4960">			handleException(e);</span>
<span class="nc" id="L4961">			throw e;</span>
		} finally {
<span class="nc" id="L4963">			dmo.cleanUp();</span>
<span class="nc" id="L4964">			methodFinish();</span>
<span class="nc" id="L4965">		}</span>
<span class="nc" id="L4966">	}</span>

	public void deletePhantomsWithoutDeleteChildlessTemplate(ID idOrg, ID idSchedulingPeriod)
			throws BbmRemoveException {
<span class="nc" id="L4970">		methodStart(&quot;deletePhantoms&quot;, idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4971">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4973">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4974">			dao.deletePhantoms(idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4975">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4976">			handleException(e);</span>
<span class="nc" id="L4977">			throw e;</span>
		} finally {
<span class="nc" id="L4979">			dmo.cleanUp();</span>
<span class="nc" id="L4980">			methodFinish();</span>
<span class="nc" id="L4981">		}</span>
<span class="nc" id="L4982">	}</span>

	public void updatePhantom(Phantom objValue) throws MultiUserException, BbmUpdateException {
<span class="nc" id="L4985">		updatePhantoms(Arrays.asList(objValue));</span>
<span class="nc" id="L4986">	}</span>

	public void updatePhantoms(Collection objValues) throws MultiUserException, BbmUpdateException {
<span class="fc" id="L4989">		methodStart(&quot;updatePhantoms&quot;, objValues);</span>
<span class="fc" id="L4990">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4992">			dao.updateObjects(objValues);</span>
		} finally {
<span class="pc bpc" id="L4994" title="3 of 4 branches missed.">			if (dao != null) {</span>
<span class="pc" id="L4995">				dao.cleanUp();</span>
			}
<span class="pc" id="L4997">			methodFinish();</span>
<span class="fc" id="L4998">		}</span>
<span class="fc" id="L4999">	}</span>

	/**
	 * Filters the phantom IDs out of the collection of work resource IDs,
	 * returning only the non-phantom IDs.
	 */
	public Collection&lt;ID&gt; filterPhantomIDsFromWorkResourceIDList(Collection&lt;ID&gt; workResourceIDs)
			throws BbmFinderException {
<span class="fc" id="L5007">		methodStart(&quot;filterPhantomIDsFromWorkResourceIDList&quot;, workResourceIDs);</span>
<span class="pc bpc" id="L5008" title="2 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.size() == 0) {</span>
<span class="nc" id="L5009">			return new ArrayList&lt;ID&gt;();</span>
		}
<span class="fc" id="L5011">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L5013">			Collection&lt;ID&gt; phantomIDs = dao.retrievePhantomIDsFromWorkResourceIDList(workResourceIDs);</span>
<span class="fc" id="L5014">			workResourceIDs.removeAll(phantomIDs);</span>
		} finally {
<span class="pc" id="L5016">			dao.cleanUp();</span>
<span class="pc" id="L5017">			methodFinish();</span>
<span class="fc" id="L5018">		}</span>
<span class="fc" id="L5019">		return workResourceIDs;</span>
	}

	private HashMap&lt;ID, String&gt; derivePhantomNamesForEmployees(
			HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; empIDShiftAssignmentMap, ID spID, Date start, Date end,
			HashMap&lt;ID, Collection&lt;Skill&gt;&gt; empIDSkillMap, HashMap&lt;ID, Employee&gt; employeeNameByID) throws Exception {
<span class="nc" id="L5025">		Iterator entries = empIDShiftAssignmentMap.entrySet().iterator();</span>
<span class="nc" id="L5026">		HashMap&lt;ID, ID&gt; empIDWorkPatternIdMap = new HashMap&lt;ID, ID&gt;(empIDShiftAssignmentMap.size());</span>
<span class="nc" id="L5027">		HashMap&lt;ID, ID&gt; empIDShiftIdMap = new HashMap&lt;ID, ID&gt;(empIDShiftAssignmentMap.size());</span>

<span class="nc bnc" id="L5029" title="All 2 branches missed.">		while (entries.hasNext()) {</span>
<span class="nc" id="L5030">			Entry&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; thisEntry = (Entry) entries.next();</span>
<span class="nc" id="L5031">			ID workResourceID = thisEntry.getKey();</span>
<span class="nc" id="L5032">			Collection&lt;ShiftAssignment&gt; sas = thisEntry.getValue();</span>

<span class="nc" id="L5034">			ShiftAssignment sa = null;</span>
<span class="nc bnc" id="L5035" title="All 2 branches missed.">			for (Iterator i = sas.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5036">				sa = (ShiftAssignment) i.next();</span>
<span class="nc bnc" id="L5037" title="All 4 branches missed.">				if (sa.getCampaignID() != null &amp;&amp; sa.getCampaignID().equals(spID)) {</span>
<span class="nc bnc" id="L5038" title="All 2 branches missed.">					if (sa.getWorkPatternID() != null) {</span>
						// add the workpatternId
<span class="nc" id="L5040">						empIDWorkPatternIdMap.put(workResourceID, sa.getWorkPatternID());</span>
<span class="nc" id="L5041">						break;</span>
<span class="nc bnc" id="L5042" title="All 2 branches missed.">					} else if (sa.getShiftID() != null) {</span>
						// if no shift pattern, try to use shift name
<span class="nc" id="L5044">						empIDShiftIdMap.put(workResourceID, sa.getShiftID());</span>
<span class="nc" id="L5045">						break;</span>
					}
				}
			}
<span class="nc" id="L5049">		}</span>
<span class="nc" id="L5050">		HashMap&lt;ID, String&gt; workResourceIDNameMap = new HashMap&lt;ID, String&gt;(empIDShiftAssignmentMap.size());</span>

<span class="nc bnc" id="L5052" title="All 2 branches missed.">		if (!empIDWorkPatternIdMap.isEmpty()) {</span>
<span class="nc" id="L5053">			Collection&lt;ShiftPattern&gt; shiftPatterns = m_workRuleManager</span>
<span class="nc" id="L5054">					.getShiftPatternsByIDs(empIDWorkPatternIdMap.values());</span>
<span class="nc" id="L5055">			Iterator&lt;ShiftPattern&gt; it = shiftPatterns.iterator();</span>
<span class="nc" id="L5056">			HashMap&lt;ID, ShiftPattern&gt; shiftIDMap = new HashMap&lt;ID, ShiftPattern&gt;();</span>
<span class="nc bnc" id="L5057" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L5058">				ShiftPattern sp = it.next();</span>
<span class="nc" id="L5059">				shiftIDMap.put(sp.getID(), sp);</span>
<span class="nc" id="L5060">			}</span>

<span class="nc" id="L5062">			Iterator&lt;ID&gt; empIDIt = empIDWorkPatternIdMap.keySet().iterator();</span>
<span class="nc bnc" id="L5063" title="All 2 branches missed.">			while (empIDIt.hasNext()) {</span>
<span class="nc" id="L5064">				ID id = empIDIt.next();</span>
<span class="nc" id="L5065">				workResourceIDNameMap.put(id, shiftIDMap.get(empIDWorkPatternIdMap.get(id)).getName());</span>
<span class="nc" id="L5066">			}</span>
		}

<span class="nc bnc" id="L5069" title="All 2 branches missed.">		if (!empIDShiftIdMap.isEmpty()) {</span>
<span class="nc" id="L5070">			Collection&lt;Shift&gt; shifts = m_workRuleManager.getShiftsByIDs(empIDShiftIdMap.values());</span>
<span class="nc" id="L5071">			Iterator&lt;Shift&gt; it = shifts.iterator();</span>
<span class="nc" id="L5072">			HashMap&lt;ID, Shift&gt; shiftIDMap = new HashMap&lt;ID, Shift&gt;();</span>
<span class="nc bnc" id="L5073" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L5074">				Shift sp = it.next();</span>
<span class="nc" id="L5075">				shiftIDMap.put(sp.getID(), sp);</span>
<span class="nc" id="L5076">			}</span>

<span class="nc" id="L5078">			Iterator&lt;ID&gt; empIDIt = empIDShiftIdMap.keySet().iterator();</span>
<span class="nc bnc" id="L5079" title="All 2 branches missed.">			while (empIDIt.hasNext()) {</span>
<span class="nc" id="L5080">				ID id = empIDIt.next();</span>
<span class="nc" id="L5081">				workResourceIDNameMap.put(id, shiftIDMap.get(empIDShiftIdMap.get(id)).getName());</span>
<span class="nc" id="L5082">			}</span>
		}

		// append skill name if there is any skill linked to emp
<span class="nc" id="L5086">		Iterator&lt;ID&gt; idIt = empIDShiftAssignmentMap.keySet().iterator();</span>
<span class="nc bnc" id="L5087" title="All 2 branches missed.">		while (idIt.hasNext()) {</span>
<span class="nc" id="L5088">			ID workResourceID = idIt.next();</span>
<span class="nc" id="L5089">			Collection&lt;Skill&gt; empSkills = empIDSkillMap.get(workResourceID);</span>
<span class="nc bnc" id="L5090" title="All 2 branches missed.">			String name = workResourceIDNameMap.get(workResourceID) == null ? &quot;&quot;</span>
<span class="nc" id="L5091">					: workResourceIDNameMap.get(workResourceID);</span>
<span class="nc bnc" id="L5092" title="All 2 branches missed.">			if (empSkills != null) {</span>
<span class="nc bnc" id="L5093" title="All 2 branches missed.">				for (Iterator iSkill = empSkills.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L5094">					name += (&quot; - &quot; + ((Skill) iSkill.next()).getName());</span>
				}
			}

			// if still name string is empty, use employee last name
<span class="nc bnc" id="L5099" title="All 2 branches missed.">			if (name.length() == 0) {</span>
<span class="nc" id="L5100">				name = employeeNameByID.get(workResourceID).getLastName();</span>
			}
<span class="nc bnc" id="L5102" title="All 2 branches missed.">			name = name.length() &gt; 30 ? name.substring(0, 30) : name; // 30</span>
																		// characters
																		// long
<span class="nc" id="L5105">			workResourceIDNameMap.put(workResourceID, name);</span>
<span class="nc" id="L5106">		}</span>
<span class="nc" id="L5107">		return workResourceIDNameMap;</span>
	}

	private Collection reassignComplexWorkRuleToPhantom(ID workResourceID, ID phantomID, Collection empComplexWorkRule,
			Jdmo dmo) throws Exception {
<span class="nc" id="L5112">		ArrayList list = new ArrayList();</span>
<span class="nc bnc" id="L5113" title="All 4 branches missed.">		if (empComplexWorkRule == null || empComplexWorkRule.isEmpty()) {</span>
<span class="nc" id="L5114">			return list;</span>
		}

<span class="nc" id="L5117">		WorkResourceComplexWorkRule workRuleAssignment = null;</span>
<span class="nc bnc" id="L5118" title="All 2 branches missed.">		for (Iterator i = empComplexWorkRule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5119">			workRuleAssignment = (WorkResourceComplexWorkRule) i.next();</span>
<span class="nc" id="L5120">			workRuleAssignment.setID(null);</span>
<span class="nc" id="L5121">			workRuleAssignment.setFieldValue(WorkResourceComplexWorkRuleFieldInfo.COMPLEXWORKRULEWORKRESOURCE_ID,</span>
<span class="nc" id="L5122">					new ID(DAOUtil.getDEID(dmo)));</span>
<span class="nc" id="L5123">			workRuleAssignment.setWorkResourceID(phantomID);</span>
<span class="nc" id="L5124">			list.add(workRuleAssignment);</span>
		}

<span class="nc" id="L5127">		return list;</span>
	}

	private Collection reassignShiftAssignmentToPhantom(ID spID, ID empID, ID phantomID, Collection shiftAssignments)
			throws Exception {
<span class="nc bnc" id="L5132" title="All 4 branches missed.">		if (shiftAssignments == null || shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L5133">			return new ArrayList();</span>
		}
<span class="nc" id="L5135">		ShiftAssignment shiftAssignment = null;</span>
<span class="nc" id="L5136">		ShiftEventAssignment event = null;</span>
<span class="nc bnc" id="L5137" title="All 2 branches missed.">		for (Iterator i = shiftAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5138">			shiftAssignment = (ShiftAssignment) i.next();</span>
<span class="nc bnc" id="L5139" title="All 2 branches missed.">			if (!shiftAssignment.getCampaignID().equals(spID)) {</span>
<span class="nc" id="L5140">				i.remove(); // only reassign the shifts in this campaign to</span>
							// phantom
<span class="nc" id="L5142">				continue;</span>
			}
<span class="nc" id="L5144">			shiftAssignment.setID(null);</span>
<span class="nc" id="L5145">			shiftAssignment.removeWorkResourceID(empID);</span>
<span class="nc" id="L5146">			shiftAssignment.addWorkResourceID(phantomID);</span>
<span class="nc" id="L5147">			Collection children = shiftAssignment.getChildren();</span>
<span class="nc bnc" id="L5148" title="All 4 branches missed.">			if (children != null &amp;&amp; !children.isEmpty()) {</span>
<span class="nc bnc" id="L5149" title="All 2 branches missed.">				for (Iterator iChildren = children.iterator(); iChildren.hasNext();) {</span>
<span class="nc" id="L5150">					event = (ShiftEventAssignment) iChildren.next();</span>
<span class="nc" id="L5151">					event.setID(null);</span>
<span class="nc" id="L5152">					event.addWorkResourceID(phantomID);</span>
<span class="nc" id="L5153">					shiftAssignment.createChildObject(ShiftAssignmentFields.CHILD_SHIFT_EVENT, event);</span>
				}
<span class="nc" id="L5155">				shiftAssignment.clearChildObjectMap(); // move the event list</span>
														// from persisted list
														// to create list
			}
<span class="nc" id="L5159">		}</span>
<span class="nc" id="L5160">		return shiftAssignments;</span>
	}

	private String getPhantomFirstName(Jdmo dmo, ID empTemplateSID, HashMap nextPhantomNameMap) throws Exception {
<span class="nc" id="L5164">		String nextPhantomName = (String) nextPhantomNameMap.get(empTemplateSID);</span>
<span class="nc" id="L5165">		int next = 1;</span>
<span class="nc bnc" id="L5166" title="All 2 branches missed.">		if (nextPhantomName != null) {</span>
<span class="nc" id="L5167">			next = Integer.parseInt(nextPhantomName) + 1;</span>
<span class="nc" id="L5168">			nextPhantomNameMap.put(empTemplateSID, String.valueOf(next));</span>
<span class="nc" id="L5169">			return nextPhantomName;</span>
		}
<span class="nc" id="L5171">		StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L5172">		sb.append(&quot;select max(cast(name as int)) from phantom where EMPTEMPLATEID = &quot;).append(empTemplateSID);</span>
<span class="nc" id="L5173">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L5174" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L5175">			int curMax = rs.getInt(1);</span>
<span class="nc" id="L5176">			nextPhantomName = String.valueOf(curMax + 1);</span>
<span class="nc" id="L5177">			next = curMax + 2;</span>
<span class="nc" id="L5178">			nextPhantomNameMap.put(empTemplateSID, String.valueOf(next));</span>
<span class="nc" id="L5179">			return nextPhantomName;</span>
		}
<span class="nc" id="L5181">		return String.valueOf(1);</span>
	}

	/**************************************************************************
	 * functions for employee templates
	 **************************************************************************/
	public ID createEmployeeTemplate(EmployeeTemplate objValue) throws BbmCreateException {
<span class="fc" id="L5188">		methodStart(&quot;createEmployeeTemplate&quot;, objValue);</span>
<span class="fc" id="L5189">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="fc" id="L5191">			return dao.createEmployeeTemplate(objValue);</span>
<span class="nc" id="L5192">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L5193">			handleException(e);</span>
<span class="nc" id="L5194">			throw e;</span>
		} finally {
<span class="pc" id="L5196">			dao.cleanUp();</span>
<span class="pc" id="L5197">			methodFinish();</span>
		}
	}

	public void updateEmployeeTemplate(EmployeeTemplate objValue)
			throws BbmException, BbmUpdateException, MultiUserException {
<span class="fc" id="L5203">		updateEmployeeTemplates(Arrays.asList(objValue));</span>
<span class="fc" id="L5204">	}</span>

	public void updateEmployeeTemplates(Collection&lt;EmployeeTemplate&gt; ETCol)
			throws BbmException, BbmUpdateException, MultiUserException {
<span class="fc" id="L5208">		methodStart(&quot;updateEmployeeTemplates&quot;, ETCol);</span>
<span class="fc" id="L5209">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="fc" id="L5211">			dao.updateEmployeeTemplates(ETCol);</span>
<span class="nc" id="L5212">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L5213">			handleException(e);</span>
<span class="nc" id="L5214">			throw e;</span>
<span class="nc" id="L5215">		} catch (BbmException e) {</span>
<span class="nc" id="L5216">			handleException(e);</span>
<span class="nc" id="L5217">			throw e;</span>
<span class="nc" id="L5218">		} catch (MultiUserException e) {</span>
<span class="nc" id="L5219">			handleException(e);</span>
<span class="nc" id="L5220">			throw e;</span>
		} finally {
<span class="pc" id="L5222">			dao.cleanUp();</span>
<span class="pc" id="L5223">			methodFinish();</span>
<span class="fc" id="L5224">		}</span>
<span class="fc" id="L5225">	}</span>

	public void deleteEmployeeTemplates(Collection colEmpTemplateIDs) throws BbmRemoveException {
<span class="fc" id="L5228">		methodStart(&quot;deleteEmployeeTemplates&quot;, colEmpTemplateIDs);</span>
<span class="fc" id="L5229">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L5231">			EmployeeTemplateDAO dao = new EmployeeTemplateDAO(dmo);</span>
<span class="fc" id="L5232">			dao.deleteEmployeeTemplates(colEmpTemplateIDs);</span>
<span class="nc" id="L5233">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5234">			handleException(e);</span>
<span class="nc" id="L5235">			throw e;</span>
		} finally {
<span class="pc" id="L5237">			dmo.cleanUp();</span>
<span class="pc" id="L5238">			methodFinish();</span>
<span class="fc" id="L5239">		}</span>
<span class="fc" id="L5240">	}</span>

	public void copyEmployeeTemplates(Collection&lt;ID&gt; empTemplateIDs, boolean isOrgMode, ID ownerID,
			LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L5245">		methodStart(&quot;copyEmployeeTemplates&quot;, empTemplateIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L5246">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>

		try {
<span class="nc" id="L5249">			dao.copyEmployeeTemplates(empTemplateIDs, isOrgMode, ownerID, localeContext,</span>
<span class="nc" id="L5250">					m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L5251">		} catch (BbmCreateException ex) {</span>
<span class="nc" id="L5252">			handleException(ex);</span>
<span class="nc" id="L5253">			throw ex;</span>
<span class="nc" id="L5254">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L5255">			handleException(ex);</span>
<span class="nc" id="L5256">			throw ex;</span>
		} finally {
<span class="nc" id="L5258">			dao.cleanUp();</span>
<span class="nc" id="L5259">			methodFinish();</span>
<span class="nc" id="L5260">		}</span>
<span class="nc" id="L5261">	}</span>

	/**
	 * get employee templates in a given organization
	 */
	public EmployeeTemplate getEmployeeTemplateByID(ID idEmpTemplate)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L5268">		return (EmployeeTemplate) (getEmployeeTemplatesByIDs(Arrays.asList(idEmpTemplate)).iterator().next());</span>
	}

	/**
	 * get employee templates in a given organization
	 */
	public Collection getEmployeeTemplatesByIDs(Collection colIDs) throws BbmFinderException {
<span class="fc" id="L5275">		methodStart(&quot;getEmployeeTemplatesByIDs&quot;, colIDs);</span>
<span class="fc" id="L5276">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="fc" id="L5278">			return dao.getEmployeeTemplatesByIDs(colIDs);</span>
<span class="nc" id="L5279">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5280">			handleException(e);</span>
<span class="nc" id="L5281">			throw e;</span>
		} finally {
<span class="pc" id="L5283">			dao.cleanUp();</span>
<span class="pc" id="L5284">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a given organization
	 */
	public Collection getEmployeeTemplatesInOrg(ID idOrg) throws BbmFinderException {
<span class="fc" id="L5292">		return getEmployeeTemplatesInOrgs(Arrays.asList(idOrg));</span>
	}

	/*
	 * Returns employee templates using the give shift pattern id
	 */
	public Collection getEmployeeTemplatesUsingShiftPattern(Collection&lt;ID&gt; shiftPatternIds) {
<span class="fc" id="L5299">		methodStart(&quot;getEmployeeTemplatesUsingShiftPattern&quot;, shiftPatternIds);</span>
<span class="fc" id="L5300">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="fc" id="L5302">			return dao.getEmployeeTemplatesUsingShiftPattern(shiftPatternIds);</span>
<span class="nc" id="L5303">		} catch (Exception e) {</span>
<span class="nc" id="L5304">			handleException(e);</span>
<span class="nc" id="L5305">			return Collections.EMPTY_LIST;</span>
		} finally {
<span class="pc" id="L5307">			dao.cleanUp();</span>
<span class="pc" id="L5308">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a given SP
	 */
	public Collection getEmployeeTemplatesInSP(ID spID) throws BbmFinderException {
<span class="nc" id="L5316">		methodStart(&quot;getEmployeeTemplatesInSP&quot;, spID);</span>
<span class="nc" id="L5317">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5319">			return dao.getEmployeeTemplatesInSP(spID);</span>
<span class="nc" id="L5320">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5321">			handleException(e);</span>
<span class="nc" id="L5322">			throw e;</span>
		} finally {
<span class="nc" id="L5324">			dao.cleanUp();</span>
<span class="nc" id="L5325">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a set of given organizations
	 */
	public Collection getEmployeeTemplatesInOrgs(Collection colOrgIDs) throws BbmFinderException {
<span class="fc" id="L5333">		methodStart(&quot;getEmployeeTemplatesInOrgs&quot;, colOrgIDs);</span>
<span class="fc" id="L5334">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="fc" id="L5336">			return dao.getEmployeeTemplatesInOrgs(colOrgIDs);</span>
<span class="nc" id="L5337">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5338">			handleException(e);</span>
<span class="nc" id="L5339">			throw e;</span>
		} finally {
<span class="pc" id="L5341">			dao.cleanUp();</span>
<span class="pc" id="L5342">			methodFinish();</span>
		}
	}

	private void deleteChildlessHiddenEmployeeTemplate() throws BbmRemoveException {
<span class="nc" id="L5347">		methodStart(&quot;deleteChildlessHiddenEmployeeTemplate&quot;);</span>
<span class="nc" id="L5348">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5350">			dao.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L5351">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5352">			handleException(e);</span>
<span class="nc" id="L5353">			throw e;</span>
		} finally {
<span class="nc" id="L5355">			dao.cleanUp();</span>
<span class="nc" id="L5356">			methodFinish();</span>
<span class="nc" id="L5357">		}</span>
<span class="nc" id="L5358">	}</span>

	private EmployeeTemplate FindHiddenEmpTemplateWithAttributes(Jdmo dmo, ID orgID, String phantomLastName,
			double wage, Collection skillIDs, Collection shiftPatternIDs, int proficiency) throws Exception {
<span class="nc" id="L5362">		StringBuffer sb = new StringBuffer(300);</span>
<span class="nc" id="L5363">		sb.append(&quot; SELECT A.SID FROM EMPTEMPLATE A&quot;);</span>
<span class="nc" id="L5364">		sb.append(&quot; WHERE A.ISHIDDEN = 1 AND ORGANIZATIONID =  &quot;).append(orgID);</span>
<span class="nc" id="L5365">		sb.append(&quot; AND WAGE = &quot;).append(wage).append(&quot; AND PROFICIENCY = &quot;).append((float) proficiency / 10);</span>
<span class="nc" id="L5366">		sb.append(&quot; AND NAME LIKE &quot;).append(JdmoUtil.asSqlLiteral(phantomLastName));</span>
<span class="nc bnc" id="L5367" title="All 2 branches missed.">		if (!skillIDs.isEmpty()) {</span>
<span class="nc" id="L5368">			sb.append(&quot; AND (SELECT COUNT(ID) FROM EMPTEMPLATESKILL WHERE EMPTEMPLATEID = A.ID AND SKILLID IN (&quot;)</span>
<span class="nc" id="L5369">					.append(getStringIDList(skillIDs)).append(&quot;)) = &quot;).append(skillIDs.size());</span>
		}
<span class="nc bnc" id="L5371" title="All 2 branches missed.">		if (!shiftPatternIDs.isEmpty()) {</span>
			// shift pattern not SID, here we have
			// SID.
<span class="nc" id="L5374">			sb.append(</span>
					&quot; AND (SELECT COUNT(ID) FROM SHIFTPATTERNEMPTEMPLATE WHERE EMPTEMPLATEID = A.ID AND SHIFTPATTERNID IN (Select ID from SHIFTPATTERN where SID in (&quot;)
<span class="nc" id="L5376">					.append(getStringIDList(shiftPatternIDs)).append(&quot;))) = &quot;).append(shiftPatternIDs.size());</span>
		}
<span class="nc" id="L5378">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L5379" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L5380">			return getEmployeeTemplateByID(rs.getID(1));</span>
		}

<span class="nc" id="L5383">		return null;</span>
	}

	private ID getRotationCurrentShiftPatternID(ID workResourceID, ID orgID, WorkResourceRotation empRotationWorkRule,
			Rotation rotationWorkRule, Collection shiftPatterns, Date viewStartInGMT) throws Exception {
<span class="nc" id="L5388">		int currentWeekIndex = GetCurrentWeekOfRotation(workResourceID, orgID, empRotationWorkRule, rotationWorkRule,</span>
				viewStartInGMT);

<span class="nc" id="L5391">		ShiftPattern[] aShiftPattern = new ShiftPattern[shiftPatterns.size()];</span>
<span class="nc" id="L5392">		aShiftPattern = (ShiftPattern[]) shiftPatterns.toArray(aShiftPattern);</span>
<span class="nc" id="L5393">		return aShiftPattern[currentWeekIndex].getID();</span>
	}

	private int GetCurrentWeekOfRotation(ID workResourceID, ID orgID, WorkResourceRotation empRotationWorkRule,
			Rotation rotationWorkRule, Date startInGMT) throws Exception {
<span class="nc" id="L5398">		Organization org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L5399">		TimeZone orgTZ = org.getTimeZone();</span>

		// find the week start
<span class="nc" id="L5402">		Calendar calendar = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L5403">		calendar.setTime(startInGMT);</span>
<span class="nc" id="L5404">		int viewWeekOffset = (calendar.get(Calendar.DAY_OF_WEEK) - 1) * 24 * 60</span>
<span class="nc" id="L5405">				+ calendar.get(Calendar.HOUR_OF_DAY) * 60 + calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L5406">		int weekBoundary = org.getWeekStartDate() * 24 * 60 + org.getDayBoundaryOffset();</span>
		// move back to sunday
<span class="nc" id="L5408">		calendar.add(Calendar.MINUTE, -viewWeekOffset);</span>
		// add week boundary defined in org
<span class="nc" id="L5410">		calendar.add(Calendar.MINUTE, weekBoundary);</span>
<span class="nc" id="L5411">		Date weekStartOrgT = calendar.getTime();</span>

<span class="nc" id="L5413">		int offsetInDays = TimeZoneUtil.numberOfDays(</span>
<span class="nc" id="L5414">				rotationWorkRule.getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE),</span>
<span class="nc" id="L5415">				TimeZoneUtil.toGMT(weekStartOrgT));</span>
<span class="nc" id="L5416">		return (offsetInDays / 7) % empRotationWorkRule.getNumWeeksInRotation();</span>
	}

	private String getStringIDList(Collection sIDs) {
<span class="nc" id="L5420">		StringBuffer sb = new StringBuffer(100);</span>
<span class="nc bnc" id="L5421" title="All 2 branches missed.">		for (Iterator i = sIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5422">			sb.append(JdmoUtil.asSqlLiteral(i.next()));</span>
<span class="nc bnc" id="L5423" title="All 2 branches missed.">			if (i.hasNext()) {</span>
<span class="nc" id="L5424">				sb.append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L5427">		return sb.toString();</span>
	}

	public boolean isTemplatesUsedInExistingSchedule(Collection empTemplateIds) throws BbmFinderException {
<span class="fc" id="L5431">		methodStart(&quot;isTemplatesUsedInExistingSchedule&quot;, empTemplateIds);</span>
<span class="fc" id="L5432">		boolean isTemplatesUsedInExistingSchedule =false;</span>
<span class="fc" id="L5433">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L5435">			isTemplatesUsedInExistingSchedule = dao.isTemplatesUsedInExistingSchedule(empTemplateIds);</span>
		} finally {
<span class="pc" id="L5437">			dao.cleanUp();</span>
<span class="pc" id="L5438">			methodFinish();</span>
<span class="fc" id="L5439">		}</span>
<span class="fc" id="L5440">		return isTemplatesUsedInExistingSchedule;</span>
	}

	public void updateStatusForScheduleRun(ID sid, int status, String user) throws BbmException {
<span class="fc" id="L5444">		methodStart(&quot;updateStatusForScheduleRun&quot;);</span>
<span class="fc" id="L5445">		ScheduleRunStatusDAO dao = new ScheduleRunStatusDAO();</span>
		try {
<span class="fc" id="L5447">			dao.updateStatusForScheduleRun(sid, status, user);</span>
		} finally {
<span class="pc" id="L5449">			dao.cleanUp();</span>
<span class="pc" id="L5450">			methodFinish();</span>
<span class="fc" id="L5451">		}</span>
<span class="fc" id="L5452">	}</span>
	
	public void linkWorkResourcesToSchedulingPeriod(ID sid, Collection employeeIds) 
		throws BbmCreateException
	{
<span class="fc" id="L5457">		methodStart(&quot;linkWorkResourcesToSchedulingPeriod&quot;, sid, employeeIds);</span>
		try
		{			
<span class="fc" id="L5460">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(sid);</span>
<span class="fc" id="L5461">			m_pCampaignManager.linkWorkResourcesToSchedulingPeriod(pSourceSP.getDEID(), employeeIds);</span>
		}
<span class="nc" id="L5463">		catch (Exception e)</span>
		{
<span class="nc" id="L5465">			handleException(e);</span>
<span class="nc" id="L5466">			throw new BbmCreateException(e);</span>
		}
		finally
		{
<span class="pc" id="L5470">			methodFinish();</span>
<span class="fc" id="L5471">		}		</span>
<span class="fc" id="L5472">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>