<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftSwapRequestManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.swap.request.ejb</a> &gt; <span class="el_source">ShiftSwapRequestManagerEJB.java</span></div><h1>ShiftSwapRequestManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * ShiftSwapRequestManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.swap.request.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.Iterator;
import java.util.List;
import java.util.Set;

import org.apache.log4j.Level;
import org.apache.log4j.Priority;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.threadlocal.ThreadLocalForCacheManagerHelper;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.RequestNotificationDetail;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestDAO;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.model.ValidatorDescriptor;
import com.bluepumpkin.ejb.rm.requests.common.validation.RequestNotExpiredOnCreateHV;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.RequestFilter;
import com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.ShiftSwapPostingDAO;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequest;
import com.bluepumpkin.ejb.rm.requests.swap.request.model.ShiftSwapRequestItem;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.AgentsGoodStandingValidationRule;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.NoShiftsOnReceivedShiftOrgDayHV;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftExistValidationRule;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.SwappedShiftContainsFlexTOHV;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.SwappedShiftContainsGapHV;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.SwappedShiftContainsOTExtensionHV;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.TentativeRequestHardValidationRule;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.requests.swap.withdraw.model.ShiftSwapWithdraw;
import com.bluepumpkin.ejb.rm.requests.swap.withdraw.validation.FilingRuleComplianceValidationRule;
import com.bluepumpkin.ejb.rm.security.RmSecurityManager;
import com.bluepumpkin.ejb.rm.util.DAOUtil;
import com.bluepumpkin.ejb.rm.util.RmFilterUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;
import com.bluepumpkin.ejb.rm.util.swap.SwapResult;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.PrivilegeKeys;
import com.witness.ejb.core.security.model.User;


/**
 * EJB for ShiftSwapRequest
 * &lt;p&gt;
 * Caveats:
 * &lt;p&gt; If a series of interface methods are invoked, then any method that accepts a request,
 * instead of a request ID, needs to be used with caution.  For instance if after calling createRequest(),
 * the same request is passed to ApproveRequest(), it will still have the deleteAllChildren flag set.
 * Although this flag was reset during
 * the backend processing of the request during createRequest(), the updated request is not marshalled
 * back to the webtier and hence the request in the webtier still retains it.
 *
 */
<span class="nc" id="L97">public class ShiftSwapRequestManagerEJB extends RequestAggregateManager {</span>
<span class="nc" id="L98">    private static final String m_className = ShiftSwapRequestManagerEJB.class.getName();</span>
<span class="nc" id="L99">    private static final Category m_cat = Log.initCategory(m_className);</span>

    /**
     * Array of hard validation classes
     */
<span class="nc" id="L104">    protected final static ValidatorDescriptor[] m_hardValidatorDescriptorArr = {</span>
<span class="nc" id="L105">        new ValidatorDescriptor(RequestNotExpiredOnCreateHV.class.getName(), RequestUtil.METHODTYPE_CREATOR, null,</span>
            ShiftSwapRequest.DL_BASIC | ShiftSwapRequest.DL_SHIFTSWAP_ITEMS),
<span class="nc" id="L107">        new ValidatorDescriptor(ShiftExistValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
        	ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L109">		new ValidatorDescriptor(NoShiftsOnReceivedShiftOrgDayHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
			ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L111">        new ValidatorDescriptor(AgentsGoodStandingValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
        	ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L113">        new ValidatorDescriptor(TentativeRequestHardValidationRule.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
        	ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L115">    	new ValidatorDescriptor(SwappedShiftContainsGapHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            	ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L117">    	new ValidatorDescriptor(SwappedShiftContainsFlexTOHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            	ShiftSwapRequest.DL_BASIC),
<span class="nc" id="L119">    	new ValidatorDescriptor(SwappedShiftContainsOTExtensionHV.class.getName(), RequestUtil.METHODTYPE_ALL, null,</span>
            	ShiftSwapRequest.DL_BASIC),
    };

<span class="nc" id="L123">    private static final ValidatorDescriptor[] m_softValidatorDescMandArr = { };</span>



    {
<span class="nc" id="L128">        super.init(ShiftSwapRequestManagerEJB.class.getName());</span>
<span class="nc" id="L129">    }</span>

    /** override the base class to provide the appropriate logging category */
    @Override
	protected Category getCategory() {
<span class="nc" id="L134">        return m_cat;</span>
    }



    /**
     * Return the possible states for a request of this type.
     * @return a List of the possible states for requests of this type.
     */
    @Override
	public List getPossibleStates() {
<span class="nc" id="L145">        return RequestAuditTrail.SS_POSSIBLE_STATES_EXCLUDE_NEG;</span>
    }

    @Override
	protected ValidatorDescriptor[] getHardValidatorDescriptors() {
<span class="nc" id="L150">        return m_hardValidatorDescriptorArr;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getSoftValidatorDescriptorsMandatory()
     */
    @Override
	protected ValidatorDescriptor[] getSoftValidatorDescriptorsMandatory() {
<span class="nc" id="L158">        return m_softValidatorDescMandArr;</span>
    }



    @Override
	protected RequestAggregateDAO getDAO(long detailLevel) {
<span class="nc" id="L165">        return new ShiftSwapRequestDAO(detailLevel);</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestManager()
     */
    @Override
	protected IRequestType getRequestManager() throws Exception {
<span class="nc" id="L173">        return RequestUtil.getSSRequestMgr(null, null);</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestType()
     */
    @Override
	protected String getRequestType() {
<span class="nc" id="L181">        return Request.REQUESTTYPE_SHIFTSWAP;</span>
    }

    /**
    /* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#createRequestPreProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO)
     */
    @Override
	protected void createRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO) throws Exception
    {
<span class="nc" id="L191">        super.createRequestPreProcess(reqAgg, reqAggDAO);</span>

<span class="nc" id="L193">        ShiftSwapRequest ssr = (ShiftSwapRequest) reqAgg;</span>

        // status can only be PENDING or NEGOTIATION for creation
<span class="nc" id="L196">        String status = reqAgg.getRequestStatus();</span>
<span class="nc bnc" id="L197" title="All 6 branches missed.">        if ( (status == null) || !(reqAgg.isNegotiation() || reqAgg.isPending()) ) {</span>
<span class="nc" id="L198">            reqAgg.setRequestStatus(RequestAuditTrail.STATUS_NEGOTIATION);</span>
        }

        // Get ShiftSwap Items associated with this request
<span class="nc" id="L202">        List items = ssr.getShiftSwapItems();</span>

		//Get ShiftID and add to ShiftSwapItem
<span class="nc" id="L205">		ScheduleAccessManager sam = RequestUtil.getScheduleAccessManager();</span>
<span class="nc" id="L206">		ShiftSwapItem ssi = (ShiftSwapItem)items.get(0); //ssPosting.getShiftSwapItem();</span>
<span class="nc" id="L207">		Collection shiftAssign = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, ssi.getEmployeeID(),</span>
<span class="nc" id="L208">			ssi.getStartDate(), ssi.getEndDate());</span>
<span class="nc" id="L209">		Iterator it = shiftAssign.iterator();</span>
<span class="nc bnc" id="L210" title="All 2 branches missed.">		if (it.hasNext()) {</span>
<span class="nc" id="L211">			ShiftAssignment sa = (ShiftAssignment)it.next();</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">			if (sa.getShiftID() != null) {</span>
<span class="nc" id="L213">				ssi.setShiftID(sa.getShiftID());</span>
			}
		}

        // Set the employee id of the request with the employee id of
        // the first item if found.
<span class="nc" id="L219">        ssr.setEmployeeID(ssr.getFirstEmployeeID());</span>

<span class="nc" id="L221">        updateExpirationDateAndItemOrder(ssr, ssr.getShiftSwapItems());</span>
<span class="nc" id="L222">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getRequestPostProcess(java.util.Collection)
     */
    @Override
	protected void getRequestPostProcess(Collection reqAggs, long detailLevel) throws Exception {
<span class="nc bnc" id="L229" title="All 2 branches missed.">    	for (Iterator iter = reqAggs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L230">			ShiftSwapRequest ssReq = (ShiftSwapRequest) iter.next();</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (ssReq.isApprovedWithdrawStatusInProgress()</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">					&amp;&amp; isEligibleForRequestWithdrawOfApprovedRequest(ssReq).getFirst().booleanValue()) {</span>
<span class="nc" id="L233">					runSoftValidationsForApprovedSSWithdrawRequest(ssReq);</span>
			}
<span class="nc" id="L235">		}</span>
<span class="nc" id="L236">    }</span>

    //TODO: use the parameter loadedFromDB.
    @Override
	protected RequestAggregate updateRequestPreProcess(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        boolean loadedFromDB) throws Exception
    {
<span class="nc bnc" id="L243" title="All 2 branches missed.">        boolean needToAllocDAO = (reqAggDAO == null);</span>
        try  {
<span class="nc" id="L245">            ShiftSwapRequest ssr = (ShiftSwapRequest)reqAgg;</span>

            // ID must be set in objValue
<span class="nc bnc" id="L248" title="All 2 branches missed.">            if (ssr.getID() == null) {</span>
<span class="nc" id="L249">                throw new IllegalArgumentException();</span>
            }

            // obtain old request
<span class="nc" id="L253">            long detailLevel = ShiftSwapRequest.DL_BASIC | ShiftSwapRequest.DL_SHIFTSWAP_ITEMS;</span>
<span class="nc" id="L254">            ShiftSwapRequest ssrFromDB = null;</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(detailLevel):reqAggDAO;</span>
<span class="nc" id="L256">            ssrFromDB = (ShiftSwapRequest) reqAggDAO.getRequestByID(ssr.getID(), detailLevel);</span>

            // Validate that the request is not changing EmployeeFor
<span class="nc bnc" id="L259" title="All 2 branches missed.">            if (!ssr.getEmployeeID().equals(ssrFromDB.getEmployeeID())) {</span>
<span class="nc" id="L260">                throw RequestUtil.createRmException(RmEjbLogBundleKey.CANNOT_CHANGE_SSR_EMPLOYEEID,</span>
<span class="nc" id="L261">                    ssr.getID(), ssr.getEmployeeID(),ssrFromDB.getEmployeeID(), m_cat);</span>
            }

<span class="nc" id="L264">            List ssrItems = ssr.getShiftSwapItems();</span>

            //TODO: necessary only when deleteAllChildObjectsFlag() is set.
<span class="nc" id="L267">            updateExpirationDateAndItemOrder(ssr, ssrItems);</span>

            // If stautus is not set or empty, it is an error
<span class="nc" id="L270">            String status = ssr.getRequestStatus();</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">            if (!StringUtil.isEmpty(status) &amp;&amp; !RequestAuditTrail.SS_POSSIBLE_STATES.contains(status)) {</span>
<span class="nc" id="L272">                throw RequestUtil.createRmException(</span>
                    RmEjbLogBundleKey.INVALID_REQUEST_STATUS, new Object[] { status }, m_cat);
            }

            // if negotiation comment is null, then replace with comment in DB
<span class="nc bnc" id="L277" title="All 2 branches missed.">            if (ssr.getNegotiationComment() == null) {</span>
<span class="nc" id="L278">                ssr.setNegotiationComment(ssrFromDB.getNegotiationComment());</span>
            }

            // webtier modifies the expiration date and IsNegotiationRequired flag of the associated SSItems
            // in the persisted child list.  Move them to the updated child list.
<span class="nc bnc" id="L283" title="All 2 branches missed.">            if (ssr.getUpdateAllShiftSwapItems()) {</span>
<span class="nc" id="L284">                ssr.moveChildrenFromPersistedToUpdated();</span>
<span class="nc" id="L285">                ssr.setUpdateAllShiftSwapItems(false);</span>
            }

<span class="nc" id="L288">            return ssr;</span>
        } finally  {
<span class="nc bnc" id="L290" title="All 8 branches missed.">            if (needToAllocDAO &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L291">				reqAggDAO.cleanUp();</span>
			}
        }
    }

    /**
     * Note: This overrides RequestAggregateManager.changeRequestStateByID() and does not call
     * the overridden method.  Instead it calls _changeRequestStateByID() directly (which is also
     * called by ReqAggMgr.changeRequestStateByID()).
     *
     * Runs the request status modification and autoprocess in separate transactions.
     * TODO: change transaction attribute to Required (currently NotRequired).
     *
     * {@link com.bluepumpkin.ejb.rm.requests.commonrequestmanager.model.IRequestType#changeRequestStateByID(ID, String, String, String) changeRequestStateByID}
     */
	@Override
	public void changeRequestStateByID(ID reqID, String newState, String objVerNum, String comment)
			throws Exception {
<span class="nc" id="L309">        String _method_ = &quot;changeRequestStateByID&quot;;</span>
<span class="nc" id="L310">        methodStart(_method_, reqID, newState, objVerNum, comment);</span>

<span class="nc" id="L312">        ShiftSwapRequestDAO ssDAO = null;</span>
<span class="nc" id="L313">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L314">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L316">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L318">            ShiftSwapRequestManager ssReqMgr = RequestUtil.getSSRequestMgr(null, null);</span>
<span class="nc" id="L319">			checkChangeRequestStatePrivilege(reqID, newState);</span>

            // call ReqAggMgr._changeRequestByID instead of ReqAggMgr.changeRequestByID().
            // ReqAggMgr.changeRequestByID() internally calls ReqAggMgr._changeRequestByID().
            // In effect this is the same as this overriding method calling the overridden method for
            // code reuse.
            // ********** Note: bracketed by its own transaction. *************
            // ********* Note: This takes care of notifications as well **********
<span class="nc" id="L327">            ssReqMgr._changeRequestStateByID(reqID, newState, objVerNum, comment);</span>

            // if new state is pending, do auto processing.
<span class="nc bnc" id="L330" title="All 4 branches missed.">            if ((newState != null) &amp;&amp; newState.equals(RequestAuditTrail.STATUS_PENDING)) {</span>
                // After creation, refetch to refresh ValueObjectRoot.objectVersionNumber.  Otherwise
                // a MultiUserException will be thrown during auto processing approve or deny.
                //TODO: this runs bare without a transaction
<span class="nc" id="L334">                long detailLevel = getDetailLevelForValidation(); //ShiftSwapRequest.DL_BASIC | ShiftSwapRequest.DL_SHIFTSWAP_ITEMS;</span>
<span class="nc" id="L335">                ssDAO = new ShiftSwapRequestDAO(detailLevel);</span>
<span class="nc" id="L336">                ShiftSwapRequest ssr = (ShiftSwapRequest) ssDAO.getRequestByID(reqID, detailLevel);</span>

                //verify again, in case request marked invalid by _changeRequestStateByID() above.
<span class="nc bnc" id="L339" title="All 2 branches missed.">                if (ssr.isPending()) {</span>
                    // this is bracketed by its own transaction.
<span class="nc" id="L341">                    ssReqMgr._autoProcess(ssr, comment, true);</span>
                }
            }
<span class="nc" id="L344">        } catch (RmHardValidationException e) {</span>

            // Logged with priority 'debug' since this exception is generated by RM during validations or
            // workflow processing and happens often during normal operation.  If logged with a different
            // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L349">            handleException(Priority.DEBUG, e, false);</span>
<span class="nc" id="L350">            throw e;</span>
<span class="nc" id="L351">		} catch (RmException e) {</span>
<span class="nc" id="L352">			handleException(e, false); //not a transaction participant</span>
<span class="nc" id="L353">			throw e;</span>
<span class="nc" id="L354">        } catch (Exception e) {</span>
<span class="nc" id="L355">            handleException(e, false); //not a transaction participant</span>
<span class="nc" id="L356">            throw RequestUtil.createRmExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L358" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L359">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L361" title="All 4 branches missed.">            if ( ssDAO != null) {</span>
<span class="nc" id="L362">				ssDAO.cleanUp();</span>
			}
<span class="nc" id="L364">            methodFinish();</span>
<span class="nc" id="L365">        }</span>
<span class="nc" id="L366">    }</span>

    @Override
	protected void _approveRequest(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
            boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception
    {
<span class="nc" id="L372">        String methodName = &quot;_approveRequest&quot;;</span>
<span class="nc" id="L373">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, choiceIDs, comment,</span>
            new Boolean(suppressPrivilegeChecking)));

<span class="nc" id="L376">        ShiftSwapPostingDAO ssPostingDAO = null;</span>
        try {
<span class="nc" id="L378">            ShiftSwapRequest ssReq = (ShiftSwapRequest) reqAgg;</span>

            // perform status transistion validation, privilege checking, hard validations and then
            // update request status to approved.
<span class="nc" id="L382">            String oldStatus = ssReq.getRequestStatus();</span>
<span class="nc" id="L383">            _updateRequest(ssReq, RequestAuditTrail.STATUS_APPROVED, comment,</span>
                RequestAuditTrail.STATUS_APPROVED, suppressPrivilegeChecking, loadedFromDB);

            // if request status != tentatively approved, swap shifts in unpublished schedule
<span class="nc" id="L387">            ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
            final boolean overlap;
<span class="nc bnc" id="L389" title="All 2 branches missed.">            if ( RequestAuditTrail.STATUS_TENTATIVE.equals(oldStatus) ) {</span>
                // calculate overlap value using published schedule
<span class="nc" id="L391">                overlap = ShiftSwapRequestUtil.getShiftSwapResult(ssReq, true).isOverlap();</span>
            } else {
                // swap unpublished schedule and get overlap attribute
<span class="nc" id="L394">                SwapResult swapResult = ShiftSwapRequestUtil.performSwapAndSave(ssReq, true);</span>
<span class="nc" id="L395">                overlap = swapResult.isOverlap();</span>
            }
<span class="nc" id="L397">            ShiftSwapRequestUtil.publishSwap(ssReq, sam);</span>

            //Create a shift stamp for each swap to identify swaps that change in the future.
            //required for withdrawal validation
<span class="nc" id="L401">            ShiftSwapRequestUtil.signShiftSwapItems(ssReq, overlap, sam);</span>

<span class="nc" id="L403">            Collection allPostings = new ArrayList();</span>

            // remove any swap postings which correspond to the swap items.
            // sr# 28260 use DL_SHIFTSWAP_ITEMS detail level
<span class="nc" id="L407">            ssPostingDAO = new ShiftSwapPostingDAO(ShiftSwapPosting.DL_SHIFTSWAP_ITEMS);</span>
<span class="nc" id="L408">            Collection ssPostingsForReq = ssPostingDAO.findSSPostingsForSSItems(</span>
<span class="nc" id="L409">                ssReq.getShiftSwapItems(), ShiftSwapPosting.DL_BASIC);</span>

<span class="nc bnc" id="L411" title="All 4 branches missed.">            if (ssPostingsForReq!=null &amp;&amp; !ssPostingsForReq.isEmpty()) {</span>
<span class="nc" id="L412">            	allPostings.addAll(ssPostingsForReq);</span>
            }

            /*  QC 159431: Also find day off postings for 2-way swap- Agent A want to swap the Day Off on Day X to Day Off on Day Y of Agent B
             *  since there  is adjustment of shifttype, start date, end date before creating shift swap items
             *  so that  system actually swaps the shift of Agent B on Day X(the Day off of Agent A) and the shift of agent A Day Y (the Day off of Agent B)
             * */

<span class="nc bnc" id="L420" title="All 2 branches missed.">            if (ssReq.getSwapType().equals(ShiftSwapRequest.SHIFTSWAP_TYPE_TWOWAY)){</span>
<span class="nc" id="L421">            	Collection ssDayOffPosting = ssPostingDAO.findSSDayOffPostingsForSSItems(</span>
<span class="nc" id="L422">                        ssReq.getShiftSwapItems(), ShiftSwapPosting.DL_BASIC);</span>
<span class="nc bnc" id="L423" title="All 4 branches missed.">            	if(ssDayOffPosting!=null &amp;&amp; !ssDayOffPosting.isEmpty()){</span>
<span class="nc" id="L424">            		allPostings.addAll(ssDayOffPosting);</span>
            	}
            }
            // if found, delete postings corresponding to the the ssItems.
            // and delete posting of employees since time off swap item is converted to shift
<span class="nc bnc" id="L429" title="All 2 branches missed.">            if (!allPostings.isEmpty()) {</span>
<span class="nc" id="L430">                Collection ssPostingIDs = RequestUtil.getListOfIDsFromVOBases(allPostings);</span>
<span class="nc" id="L431">                ssPostingDAO.deleteSSPostings(ssPostingIDs);</span>
            }

<span class="nc" id="L434">            m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
        } finally {
<span class="nc bnc" id="L436" title="All 4 branches missed.">            if (ssPostingDAO != null) {</span>
<span class="nc" id="L437">				ssPostingDAO.cleanUp();</span>
			}
        }
<span class="nc" id="L440">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_approveRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.common.datatypes.ID, java.lang.String)
     */
    @Override
	protected void _approveRequestPostProcess(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment) {
<span class="nc" id="L447">    }</span>

    //
    @Override
	protected void _approveRequestTentatively(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceID, String comment, boolean loadedFromDB)
        throws Exception
    {
<span class="nc" id="L454">        String methodName = &quot;_approveRequestTentatively&quot;;</span>
<span class="nc" id="L455">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, choiceID, comment));</span>

		// perform status change validation, privilege checking, hard validations and then update
		// status to tentatively approved.
<span class="nc" id="L459">		_updateRequest(reqAgg, RequestAuditTrail.STATUS_TENTATIVE, comment,</span>
				RequestAuditTrail.STATUS_TENTATIVE, false, loadedFromDB);

        // perform the swap in the unpublished schedule
<span class="nc" id="L463">        ShiftSwapRequest ssReq = (ShiftSwapRequest) reqAgg;</span>

<span class="nc" id="L465">		ShiftSwapRequestUtil.performSwapAndSave(ssReq, true);</span>


<span class="nc" id="L468">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L469">    }</span>

    //TESTME one and 2 way swap
    @Override
	protected void _denyRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
        boolean loadedFromDB) throws Exception
    {
<span class="nc" id="L476">        String methodName = &quot;_denyRequest&quot;;</span>
<span class="nc" id="L477">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment,</span>
            new Boolean(suppressPrivilegeChecking)));

        // update status to denied (after status transistion validation, privilege checking and
        // hard validations).
<span class="nc" id="L482">        String oldStatus = reqAgg.getRequestStatus();</span>
<span class="nc" id="L483">        _updateRequest(reqAgg, RequestAuditTrail.STATUS_DENIED, comment, null, suppressPrivilegeChecking, loadedFromDB);</span>

        // if denying tentatively approved request, revert shift swap done.
<span class="nc bnc" id="L486" title="All 2 branches missed.">        if (oldStatus.equals(RequestAuditTrail.STATUS_TENTATIVE)) {</span>
<span class="nc" id="L487">			ShiftSwapRequestUtil.undoSwap((ShiftSwapRequest) reqAgg, true);</span>
		}

<span class="nc" id="L490">        m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
<span class="nc" id="L491">    }</span>

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_denyRequestPostProcess(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, java.lang.String)
     */
    @Override
	protected void _denyRequestPostProcess(RequestAggregate reqAgg, String comment) {
<span class="nc" id="L498">    }</span>

    @Override
	protected RequestAggregate _undoTentativeApprovalByID(ID reqID, String objectVersionNumber, String comment)
        throws Exception
    {
<span class="nc" id="L504">        String methodName = &quot;_undoTentativeApprovalByID&quot;;</span>
<span class="nc" id="L505">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqID, objectVersionNumber, comment));</span>

<span class="nc" id="L507">        RequestAggregate reqAgg = _getRequestByID(reqID, false, false, false,</span>
<span class="nc" id="L508">            ShiftSwapRequest.getDetailLevelForValidation());</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">        if ( objectVersionNumber != null ) {</span>
<span class="nc" id="L511">			reqAgg.setObjectVersionNumber(objectVersionNumber);</span>
		}
<span class="nc" id="L513">        _updateRequest( reqAgg, RequestAuditTrail.STATUS_PENDING, comment, null, false, true);</span>

        // undo swap before reverting status to 'pending' as otherwise undoSwap() method will fail (checks
        // if status is tentative before undoing).
<span class="nc" id="L517">        ShiftSwapRequestUtil.undoSwap( (ShiftSwapRequest) reqAgg, true);</span>

<span class="nc" id="L519">        m_cat.debug(RmUtil.dumpExitMethod(methodName, reqAgg));</span>
<span class="nc" id="L520">        return reqAgg;</span>
    }

    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#_undoRequestAndSchedule(com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate, com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateDAO, java.lang.Object[])
     */
    @Override
	protected void _undoSchedule(RequestAggregate reqAgg, RequestAggregateDAO reqAggDAO,
        Object[] optionalUndoData) throws Exception {

<span class="nc" id="L530">        ShiftSwapRequest ssReq = (ShiftSwapRequest) reqAgg;</span>

        //undo changes to the schedule.
<span class="nc bnc" id="L533" title="All 4 branches missed.">        if (reqAgg.isApproved() || reqAgg.isTentative()) {</span>
<span class="nc" id="L534">            ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L535">            ShiftSwapRequestUtil.undoSwap(ssReq, true);</span>

            // if swap request was approved, then undo the published schedule as well.
<span class="nc bnc" id="L538" title="All 2 branches missed.">            if (reqAgg.isApproved()) {</span>
<span class="nc" id="L539">				ShiftSwapRequestUtil.publishSwap(ssReq, sam);</span>
			}
        }

<span class="nc" id="L543">    }</span>

    @Override
	protected List getCurrentOrgIDsForReqID(ID requestId, RequestAggregateDAO reqAggDAO) throws
            BbmFinderException, BbmObjectNotFoundException {

<span class="nc bnc" id="L549" title="All 2 branches missed.">        boolean needToAllocDAO = (reqAggDAO == null);</span>
        try   {
<span class="nc" id="L551">            long detailLevel = ShiftSwapRequest.DL_BASIC | ShiftSwapRequest.DL_SHIFTSWAP_ITEMS;</span>
<span class="nc bnc" id="L552" title="All 2 branches missed.">            reqAggDAO = (reqAggDAO == null)?getDAO(detailLevel):reqAggDAO;</span>
<span class="nc" id="L553">            ShiftSwapRequest  ssReq = (ShiftSwapRequest) reqAggDAO.getRequestByID(requestId,</span>
                detailLevel);

<span class="nc" id="L556">            List orgIDs = new ArrayList();</span>
            //Presently we implement only a 2 way swap
            //TODO: move this out of TOCalc
<span class="nc" id="L559">            orgIDs.add(TOCalcUtil.getCurrentOrgIDForEmployeeID( ssReq.getFirstEmployeeID() ));</span>
<span class="nc" id="L560">            orgIDs.add(TOCalcUtil.getCurrentOrgIDForEmployeeID( ssReq.getSecondEmployeeID() ));</span>

<span class="nc" id="L562">            return orgIDs;</span>
        } finally  {
<span class="nc bnc" id="L564" title="All 8 branches missed.">            if (needToAllocDAO &amp;&amp; reqAggDAO != null) {</span>
<span class="nc" id="L565">				reqAggDAO.cleanUp();</span>
			}
        }
    }


    /**
     * Compute the expiration date given a list of swap items.
     * The expiration date will be the minimum of the individual expiration
     * dates.
     */
    //TODO: expiration date must be the earlier of the item expirations and shift assignment start
    //TODO: Negotiaation required/not required flag of ShiftSwapRequest doesn't seem to work.
    //TESTME: expiration date must be the earlier of the item expirations and shift assignment start
    protected static void updateExpirationDateAndItemOrder(ShiftSwapRequest ssReq, Collection items) {
<span class="nc" id="L580">        ssReq.updateReqAndItemExpirationDates(items);</span>

        // TODO: seems shift swap items must preserve order.  After migrating to the DAO framework, do they?
        // Note: can't replace ssReq.getChildObjects(ShiftSwapRequestFieldInfo.REQUESTITEM_CHILD_TYPE) with
        // ssReq.getShiftSwapItems() as the returned object types are different.
<span class="nc" id="L585">        int i = 0;</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">        for (Iterator itr = ssReq.getShiftSwapRequestItems().iterator(); itr.hasNext(); i++) {</span>
<span class="nc" id="L587">            ( (ShiftSwapRequestItem)itr.next() ).setItemOrder(i);</span>
        }
<span class="nc" id="L589">    }</span>



    /* (non-Javadoc)
     * @see com.bluepumpkin.ejb.rm.requests.common.ejb.RequestAggregateManager#getPrivIDPurge()
     */
    @Override
	protected ID getPrivIDPurge() {
<span class="nc" id="L598">        return PrivilegeKeys.SS_PURGEREQUESTS_ID;</span>
    }

    /**
     * Given a request object, add any associated employees to the input set and return the
     * updated set.  The methods that build a list of requests also return a map of employee
     * ids to EmployeeName objects.  In order to support that operation, the CommonRequestManager
     * needs to know the ids of every employee associated with a request.  Since there may be
     * several and the ids may be in the non-common portion of the request object, this method
     * will be called to add any employee ids to the set being built.
     *
     * @param reqAgg the request to examine.
     * @param reqEmpIds the set of employee ids so far.  This method will add all employee ids
     * in request to this set.
     * @return the updated set
     */

    @Override
	public Set addEmployeeIDsToSet(RequestAggregate reqAgg, Set reqEmpIds) {
<span class="nc" id="L617">        ShiftSwapRequest ssr = (ShiftSwapRequest) reqAgg;</span>

<span class="nc" id="L619">        reqEmpIds.add(ssr.getEmployeeID());</span>
<span class="nc" id="L620">        reqEmpIds.addAll(ssr.getEmployees());</span>

<span class="nc" id="L622">        return reqEmpIds;</span>
    }


    /**
     * Add columns necessary to process a query governed by the given filter.  The caller has already
     * added columns from the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.  Columns from
     * new tables should start with D as a column synonym.  See
     * {@link #addToFromClause addToFromClause} for how the from clause is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Columns added by this
     * method should insert a leading comma.
     * @param selectClause the string buffer being constructed, the generic columns have already been
     * added, this method should append its columns.
     * @param requestFilter the request filter
     */
    @Override
	public void addToSelectColumns(StringBuffer selectClause, RequestFilter requestFilter, int sortColumn ){
        // Allow sorting by swap type
<span class="nc" id="L643">        selectClause.append(&quot;, SSR.SWAPTYPE, SSI1.STARTTIME, SSI1.SHIFTTYPE &quot;);</span>
<span class="nc" id="L644">    }</span>

    /**
     * Add tables necessary to process a query governed by the given filter.  The caller has already
     * added the REQUEST (as A), EMPLOYEE (as B) and PERSON (as C) tables.
     * New tables should start with D as a column synonym.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Tables added by this
     * method should insert a leading comma.
     * @param fromClause the string buffer being constructed, the generic tables have already been
     * added, this method should append its tables with a leading comma and start with D as a synonym.
     * @param requestFilter the request filter
     */
    @Override
	public void addToFromClause(StringBuffer fromClause, RequestFilter requestFilter, int sortColumn) {
        // In addition to the shift swap type, we need to include the items
        // and identify the first item as a sort-by column, so we include
        // the items table twice.  But, since the order is only in the
        // SHIFTSWAPREQUESTITEM table, we need that one twice also.  Tables
        // E and F are only for the first item.
    	/* QA95168: refactor query to remove IN (employeeList) clause
    	 * previously a separate query was used to limit skills
    	 */
<span class="nc" id="L670">        fromClause.append(</span>
         &quot;, SHIFTSWAPREQUEST SSR, SHIFTSWAPREQUESTITEM SSRI1, SHIFTSWAPITEM SSI1, SHIFTSWAPREQUESTITEM SSRI2, SHIFTSWAPITEM SSI2 &quot;);

<span class="nc bnc" id="L673" title="All 2 branches missed.">		if (RequestAuditTrail.isRequestForWithdrawalStates((String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY))) {</span>
<span class="nc" id="L674">			fromClause.append(&quot;, SHIFTSWAPWITHDRAWALREQUEST SSWR &quot;);</span>
		}

    	/* QA95168: refactor query to remove IN (employeeList) clause
    	 * previously a separate query was used to limit skills
    	 */
<span class="nc bnc" id="L680" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.SWAP_SKILLS_KEY)) {</span>
<span class="nc" id="L681">            fromClause.append(&quot;, SKILL SK, WORKRESOURCESKILL WKRSK &quot;);</span>
        }
        // END QA 95168
<span class="nc" id="L684">    }</span>

    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added the generic where conditions.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addOrderByClause addOrderByClause} for how the order by clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     * @param whereClause the string buffer being constructed, the generic where clauses have already been
     * added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     */
    @Override
	public void addToWhereClause(StringBuffer whereClause, RequestFilter requestFilter, int sortColumn) {
    	// QA 95047 - Unable to Load Data in Request module - java.lang.NullPointerException
    	// if agent was assigned to more than 1 Organization during the time window
//    	whereClause.append(&quot; AND SSI1.STARTTIME &gt;= WRO.STARTTIME and (WRO.ENDTIME IS NULL OR SSI1.STARTTIME &lt; WRO.ENDTIME) &quot;);

<span class="nc" id="L705">        whereClause.append(&quot; AND SSR.ID=REQ.ID &quot;) // join to REQUEST</span>
<span class="nc" id="L706">        .append(&quot; AND SSRI1.SHIFTSWAPREQUESTID=REQ.ID &quot;).append(&quot; AND SSRI1.SHIFTSWAPITEMID=SSI1.ID &quot;)</span>
<span class="nc" id="L707">             .append(&quot; AND SSRI1.ITEMORDER=0 &quot;).append(&quot; AND SSRI2.SHIFTSWAPREQUESTID=REQ.ID &quot;).append(&quot; AND SSRI2.SHIFTSWAPITEMID=SSI2.ID &quot;);</span>

        // Handle swap type
<span class="nc bnc" id="L710" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.SWAP_TYPE_KEY)) {</span>
<span class="nc" id="L711">            String swapTypeFromFilter = (String) requestFilter.getValueForKey(RequestFilter.SWAP_TYPE_KEY);</span>
<span class="nc" id="L712">            whereClause.append(&quot; AND SSR.SWAPTYPE='&quot;).append(swapTypeFromFilter).append(&quot;' &quot;);</span>
        }

        // Handle shift date type
<span class="nc bnc" id="L716" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.REQUEST_DATE_RANGE_KEY)) {</span>
            //dmo = new Jdmo();
        	// QA 95168
<span class="nc" id="L719">        	StringsPair dates = RmFilterUtil.getStartAndEndDates(requestFilter, RequestFilter.REQUEST_DATE_RANGE_KEY);</span>
<span class="nc" id="L720">            String rangeStart = dates.getKey();</span>
<span class="nc" id="L721">            String rangeEnd = dates.getValue();</span>

<span class="nc" id="L723">            Date dtNow = new Date();</span>
<span class="nc" id="L724">    		String strDtNow = JdmoUtil.formatDBString(dtNow);</span>

            // QA 95168: fix date restrictions in query
<span class="nc" id="L727">		    whereClause.append(&quot;AND &quot;);</span>
<span class="nc" id="L728">		    RmUtil.appendRequestDateRangeClauses(whereClause, &quot;&quot;, &quot;SSI2&quot;, rangeStart, rangeEnd, strDtNow);</span>
<span class="nc" id="L729">		    whereClause.append(&quot; &quot;);</span>
            // END QA 95168

        }

<span class="nc" id="L734">		String filterStatus = (String) requestFilter.getValueForKey(RequestFilter.STATUS_KEY);</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">		if (RequestAuditTrail.isRequestForWithdrawalStates(filterStatus)) { // include the Join to the WIthdrawal request tabel</span>
																			// only if the withdraw states are queried.
<span class="nc" id="L737">			whereClause.append(&quot; AND SSWR.SHIFTSWAPREQUESTID = REQ.ID &quot;);</span>
<span class="nc" id="L738">			whereClause.append(&quot; AND SSWR.REQUESTSTATUS='&quot;).append(filterStatus).append(&quot;' &quot;);</span>
		}

        // QA 95168: refactor query to remove IN (employeeList) clause
        // this replaces method restrictEmployeesByFilter
<span class="nc bnc" id="L743" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.SWAP_SKILLS_KEY)) {</span>
<span class="nc" id="L744">        	Jdmo dmo = null;</span>

        	try {
<span class="nc" id="L747">            	dmo = new Jdmo();</span>

<span class="nc" id="L749">            	String skillIDsInClauseList = dmo.createInClause(</span>
<span class="nc" id="L750">                    (Collection) requestFilter.getValueForKey(RequestFilter.SWAP_SKILLS_KEY));</span>

<span class="nc" id="L752">        		whereClause.append(&quot; AND SK.ID IN &quot;).append(skillIDsInClauseList)</span>
<span class="nc" id="L753">        		.append(&quot; AND SK.ID = WKRSK.SKILLID &quot;)</span>
<span class="nc" id="L754">        		.append(&quot; AND WKRSK.WORKRESOURCEID = WRO.WORKRESOURCEID &quot;);</span>
<span class="nc" id="L755">        	} catch (Exception e) {</span>
<span class="nc" id="L756">                throw RequestUtil.createRunTimeException(e.getMessage(), e, m_cat);</span>
        	} finally {
<span class="nc bnc" id="L758" title="All 4 branches missed.">        		if (dmo != null) {</span>
<span class="nc" id="L759">					dmo.cleanUp();</span>
				}
        	}
        }
        // END QA 95168
<span class="nc" id="L764">    }</span>

    /**
     * Add conditions necessary to process a query governed by the given filter.  The caller has already
     * added everthing but the order by clause.  See
     * {@link #addToSelectColumns addToSelectColumns} for how the column list is modified,
     * {@link #addToFromClause addToFromClause} for how the from clause is modified, and
     * {@link #addToWhereClause addToWhereClause} for how the where clause is modified by
     * a request manager to reflect type-specific filtered queries.
     * Conditions added by this
     * method should insert a leading comma.
     * @param query the string buffer being constructed, the generic where clauses have already been
     * added, this method should append its conditions with a leading AND and both front and rear pad with a space.
     * @param requestFilter the request filter
     * @param sortColumn identifies the column to use to sort the requests.
     * The constants that define the expected values are in
     * {@link com.bluepumpkin.ejb.rm.requests.common.model.Request Request}
     * @param sortDir This string is either &quot; ASC &quot; or &quot; DESC &quot; depending on whether or not the
     * sort is ascending or descending.  (Note spaces around values for convenience.)
     */
    @Override
	public void addOrderByClause(StringBuffer query, RequestFilter requestFilter, int sortColumn,
        String sortDir) {
<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (sortColumn == Request.SORT_SWAP_TYPE) {</span>
<span class="nc" id="L788">            query.append(&quot; ORDER BY SSR.SWAPTYPE&quot;).append(sortDir);</span>
        }

<span class="nc bnc" id="L791" title="All 2 branches missed.">        if (sortColumn == Request.SORT_SWAP_FIRST_START) {</span>
<span class="nc" id="L792">            query.append(&quot; ORDER BY SSI1.STARTTIME&quot;).append(sortDir);</span>
        }

<span class="nc bnc" id="L795" title="All 2 branches missed.">        if (sortColumn == Request.SORT_SWAP_SHIFT_TYPE) {</span>
<span class="nc" id="L796">            query.append(&quot; ORDER BY SSI1.SHIFTTYPE&quot;).append(sortDir);</span>
        }
<span class="nc" id="L798">    }</span>

    /**
     * Given a set of EmployeeIds, further restrict the set based on the content of the passed
     * in filter.  Return the restricted set.
     * @param empIds a collection of employeeIds
     * @param requestFilter a request filter that specifies the request manager's type of request and
     * possibly other conditions that would dictate that the set of employee ids be further restricted.
     * @return the restricted set of employee ids.  This may be empty, but not null.
     * @deprecated QA 95168
     */
    @Deprecated
	@Override
	public Collection restrictEmployeesByFilter(Collection empIds, RequestFilter requestFilter) {
<span class="nc" id="L812">        Collection result = empIds;</span>

        // If the SKILLs filter is specified, then reduce the set of employees to just those
        // that have the requested skills
<span class="nc bnc" id="L816" title="All 2 branches missed.">        if (requestFilter.isKeySet(RequestFilter.SWAP_SKILLS_KEY)) {</span>
<span class="nc" id="L817">            Jdmo dmo = null;</span>
            try {
<span class="nc" id="L819">                dmo = new Jdmo();</span>

                // Query the database for the subset of empIds who are currently assigned
                // at least one of the skills in the list from the filter.
                //DIRECT_DB_ACCESS
<span class="nc" id="L824">                String empIDsInClauseList = dmo.createInClause(empIds);</span>
<span class="nc" id="L825">                String skillIDsInClauseList = dmo.createInClause(</span>
<span class="nc" id="L826">                        (Collection) requestFilter.getValueForKey(RequestFilter.SWAP_SKILLS_KEY));</span>

<span class="nc" id="L828">                StringBuilder query = new StringBuilder(4096);</span>
<span class="nc" id="L829">                query.append(&quot;SELECT DISTINCT EMPLOYEEAM.ID &quot;)</span>
<span class="nc" id="L830">                .append(&quot; FROM SKILL, WORKRESOURCESKILL WKRSK, EMPLOYEEAM &quot;)</span>
<span class="nc" id="L831">                .append(&quot; WHERE SKILL.SID IN &quot;).append(skillIDsInClauseList)</span>
<span class="nc" id="L832">                .append(&quot; AND SKILL.ID = WKRSK.SKILLID &quot;)</span>
<span class="nc" id="L833">                .append(&quot; AND WKRSK.WORKRESOURCEID IN &quot;).append(empIDsInClauseList);</span>

<span class="nc" id="L835">                result = DAOUtil.getIDsUsingSQLQuery(dmo, query.toString());</span>

<span class="nc" id="L837">            } catch (Exception e) {</span>
<span class="nc" id="L838">                throw RequestUtil.createRunTimeException(e.getMessage(), e, m_cat);</span>
            } finally {
<span class="nc bnc" id="L840" title="All 4 branches missed.">                if (dmo != null) {</span>
<span class="nc" id="L841">                    dmo.cleanUp();</span>
                }
            }
        }

<span class="nc" id="L846">        return result;</span>
    }

    /*
     * Given an agent, get a list of agents he/she can swap with
     */
    public Collection getEmployeesOneCanSwapWith(ID employeeID, Date effectiveDate)
            throws BbmFinderException
    {
<span class="nc" id="L855">        String _method_ = &quot;getEmployeesOneCanSwapWith&quot;;</span>
<span class="nc" id="L856">        methodStart(_method_, employeeID);</span>
<span class="nc" id="L857">        String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L858">        boolean cacheEnabled = false;</span>
        try {
<span class="nc" id="L860">            cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L862">            return (Collection) ShiftSwapRequestUtil.getEmployeesOneCanSwapWith(employeeID, effectiveDate).getSecond();</span>
<span class="nc" id="L863">		} catch ( BbmFinderException e ) {</span>
<span class="nc" id="L864">			m_cat.error(e, e);</span>
<span class="nc" id="L865">			handleException(e);</span>
<span class="nc" id="L866">			throw e;</span>
<span class="nc" id="L867">        } catch ( Exception e ) {</span>
<span class="nc" id="L868">            handleException(e);</span>
<span class="nc" id="L869">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        } finally {
<span class="nc bnc" id="L871" title="All 4 branches missed.">            if (cacheEnabled) {</span>
<span class="nc" id="L872">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc" id="L874">            methodFinish();</span>
        }
    }

    @Override
	public void deleteRequestsByStartDateRange(ID organizationId, boolean isForBranch, TimeRange range, ID subType)
    throws BbmRemoveException, RmHardValidationException
	{
<span class="nc" id="L882">		String _method_ = &quot;deleteRequestsByDateRange&quot;;</span>
<span class="nc" id="L883">		methodStart(_method_, organizationId, new Boolean(isForBranch), range, subType);</span>

<span class="nc" id="L885">		ShiftSwapRequestDAO toReqDao = null;</span>
<span class="nc" id="L886">		String setterID = m_className + '.' + _method_;</span>
<span class="nc" id="L887">		boolean cacheEnabled = false;</span>
		try {
<span class="nc" id="L889">		    cacheEnabled = ThreadLocalForCacheManagerHelper.enableThreadLocalCacheIfNecess(setterID);</span>

<span class="nc" id="L891">		    String userName = RequestUtil.getLoginUserName(m_sessionContext);</span>

<span class="nc" id="L893">			ID privFailedOrgID = RequestUtil.checkPrivilegeForOrgs(userName, Collections.singleton(organizationId), getPrivIDPurge());</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">			if (privFailedOrgID != null) {</span>
<span class="nc" id="L895">				throw createAndLogHardValForUnathToPurge(userName, privFailedOrgID, m_cat);</span>
			}

<span class="nc" id="L898">		    toReqDao =  new ShiftSwapRequestDAO(ShiftSwapRequest.DL_SHIFTSWAP_ITEMS);</span>
<span class="nc" id="L899">		    toReqDao.deleteRequestsByStartDateRange(organizationId, isForBranch, range, subType);</span>
<span class="nc" id="L900">		} catch (RmHardValidationException e) {</span>
			//RM exceptions are always logged at the point where they are thrown.
			//m_cat.error(e, e);

		    // Logged with priority 'debug' since this exception is generated by RM during validations or
		    // workflow processing and happens often during normal operation.  If logged with a different
		    // priority level (like info), it may pollute the log files with unwanted messages.
<span class="nc" id="L907">		    handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L908">			throw e;</span>
<span class="nc" id="L909">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L910">			m_cat.error(e, e);</span>
<span class="nc" id="L911">			handleException(e);</span>
<span class="nc" id="L912">			throw e;</span>
<span class="nc" id="L913">		} catch (Exception e) {</span>
<span class="nc" id="L914">		    handleException(e);</span>
<span class="nc" id="L915">		    throw RequestUtil.createBbmRemoveExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L917" title="All 4 branches missed.">		    if (cacheEnabled) {</span>
<span class="nc" id="L918">				ThreadLocalForCacheManagerHelper.disableThreadLocalCache(setterID);</span>
			}
<span class="nc bnc" id="L920" title="All 4 branches missed.">		    if ( toReqDao != null ) {</span>
<span class="nc" id="L921">				toReqDao.cleanUp();</span>
			}
<span class="nc" id="L923">		    methodFinish();</span>
<span class="nc" id="L924">		}</span>
<span class="nc" id="L925">	}</span>

    public Pair&lt;Boolean, String&gt; isEligibleForRequestWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException, RemoteException{
<span class="nc" id="L928">    	Pair&lt;Boolean, String&gt; pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;true&quot;), null);</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">		if (reqAgg.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED)) {</span>
			try {
<span class="nc" id="L931">				ValidationResult result = ShiftSwapRequestUtil.validateApprovedRequestForWithdraw(reqAgg);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">				if (result != null) {</span>
<span class="nc" id="L933">					String hardValLocalizedMsg = result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L934">					        reqAgg.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L935">					pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;false&quot;), hardValLocalizedMsg);</span>
<span class="nc" id="L936">				} else {</span>
<span class="nc" id="L937">					pair = runHardValidationForWithdraw(reqAgg);</span>
				}
<span class="nc" id="L939">			} catch (Exception e) {</span>
<span class="nc" id="L940">				m_cat.error(e, e);</span>
<span class="nc" id="L941">			}</span>
		}
<span class="nc" id="L943">		return pair;</span>
    }

    /**
     * Run hard validations on swap that reverses direction for withdrawal
     * @param reqAgg
     * @return Pair
     * @throws Exception
     */
    private Pair&lt;Boolean, String&gt; runHardValidationForWithdraw(RequestAggregate reqAgg) throws Exception{
<span class="nc" id="L953">    	Pair&lt;Boolean, String&gt; pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;true&quot;), null);</span>
<span class="nc" id="L954">		ShiftSwapRequest ssReq = (ShiftSwapRequest) reqAgg;</span>

<span class="nc" id="L956">    	ShiftSwapRequest undoSSReq = ShiftSwapRequestUtil.cloneShiftSwapRequest(ssReq);</span>

<span class="nc" id="L958">		List ssItems = ssReq.getShiftSwapItems();</span>

<span class="nc" id="L960">		ShiftSwapItem givenSSItem0 = (ShiftSwapItem) ssItems.get(0);</span>
<span class="nc" id="L961">		ShiftSwapItem givenSSItem1 = (ShiftSwapItem) ssItems.get(1);</span>

		// move employee ID from 'given item1' to 'undo item0'
<span class="nc" id="L964">		ShiftSwapItem undoSSItem0 = undoSSReq.getShiftSwapItem(givenSSItem0);</span>
<span class="nc" id="L965">		undoSSItem0.setEmployeeID(givenSSItem1.getEmployeeID());</span>
<span class="nc" id="L966">		undoSSItem0.setIsPartial(true);</span>

		// move employee ID from 'given item0' to 'undo item1'
<span class="nc" id="L969">		ShiftSwapItem undoSSItem1 = undoSSReq.getShiftSwapItem(givenSSItem1);</span>
<span class="nc" id="L970">		undoSSItem1.setEmployeeID(givenSSItem0.getEmployeeID());</span>
<span class="nc" id="L971">		undoSSItem1.setIsPartial(true);</span>

<span class="nc" id="L973">		undoSSReq.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>

<span class="nc" id="L975">		ValidationResult result = doHardValidations(undoSSReq, RequestUtil.METHODTYPE_CREATOR, null, false);</span>
<span class="nc bnc" id="L976" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L977">			String hardValLocalizedMsg = result.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(),</span>
<span class="nc" id="L978">			        reqAgg.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L979">			pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;false&quot;), hardValLocalizedMsg);</span>
<span class="nc" id="L980">		} else {</span>
			// hard validation rules didn't trigger errors, check the giver shift has gap for the swap duration
<span class="nc" id="L982">			SwapResult swapResult = ShiftSwapRequestUtil.getShiftSwapResult(undoSSReq, false);</span>
<span class="nc bnc" id="L983" title="All 2 branches missed.">			if (swapResult.isOverlap()) {</span>
<span class="nc" id="L984">				ValidationResult result1 = ValidationUtil.setHardValidationResult(reqAgg, RmEjbBundleKey.SHIFTSWAP_WITHDRAW_UNDERLYING_EVENT_MISMATCH, m_className);</span>
<span class="nc" id="L985">				String hardValLocalizedMsg = result1.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), reqAgg.getValidationCache().getTimeZoneForOrg());</span>
<span class="nc" id="L986">				pair = new Pair&lt;Boolean, String&gt;(new Boolean(&quot;false&quot;), hardValLocalizedMsg);</span>
			}
		}

<span class="nc" id="L990">		return pair;</span>
    }

	public boolean requestWithdrawOfApprovedRequestNegotiation(RequestAggregate reqAgg, String comment)
			throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L995">		String methodName = &quot;requestWithdrawOfApprovedRequestNegotiation&quot;;</span>
<span class="nc" id="L996">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L998">			ShiftSwapRequest request = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L999">			ShiftSwapWithdraw withdraw = new ShiftSwapWithdraw();</span>
<span class="nc" id="L1000">			withdraw.setShiftSwapRequestID(request.getID());</span>
<span class="nc" id="L1001">			withdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_NEGOTIATION);</span>
<span class="nc" id="L1002">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L1003">			withdraw.setCreatorID(user.getID());</span>
<span class="nc" id="L1004">			withdraw.setCreationDate(new Date());</span>
<span class="nc" id="L1005">			request.setWithdrawInfo(withdraw);</span>

			//Reuse negotiation field in ShiftSwapItem. Set current employee to true and swap employee to false.
<span class="nc" id="L1008">			ShiftSwapItem ssItem1 = request.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1009">			ShiftSwapItem ssItem2 = request.getShiftSwapItems().get(1);</span>
<span class="nc bnc" id="L1010" title="All 2 branches missed.">			if (ssItem1.getEmployeeID().compareTo(user.getEmployeeID())==0){</span>
<span class="nc" id="L1011">				ssItem1.setNegotiation(true);</span>
<span class="nc" id="L1012">				ssItem2.setNegotiation(false);</span>
			} else {
<span class="nc" id="L1014">				ssItem1.setNegotiation(false);</span>
<span class="nc" id="L1015">				ssItem2.setNegotiation(true);</span>
			}

<span class="nc" id="L1018">			request.setUpdateAllShiftSwapItems(true);</span>
<span class="nc" id="L1019">			setAuditTrail(reqAgg, comment, withdraw.getRequestStatus(), true);</span>
<span class="nc" id="L1020">			_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false);</span>
<span class="nc" id="L1021">			reqAgg = getRequestByID(reqAgg.getID(), false, false, reqAgg.getDetailLevel());</span>
<span class="nc" id="L1022">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, withdraw.getRequestStatus()));</span>
<span class="nc" id="L1023">			_autoProcess(reqAgg, &quot;&quot;, true);</span>
<span class="nc" id="L1024">			return true;</span>
<span class="nc" id="L1025">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L1026">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1027">			throw e;</span>
<span class="nc" id="L1028">		} catch (Exception e) {</span>
<span class="nc" id="L1029">			handleException(e);</span>
<span class="nc" id="L1030">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1032">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

    @Override
    protected RequestAggregate _autoProcessPreValidation(RequestAggregate reqAgg) throws BbmUpdateException{
<span class="nc" id="L1038">    	String methodName = &quot;_autoProcessPreValidation&quot;;</span>
<span class="nc" id="L1039">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg));</span>
    	try{
<span class="nc bnc" id="L1041" title="All 2 branches missed.">	    	if (isShiftSwapWithdrawRequest(reqAgg)) {</span>
<span class="nc" id="L1042">	    		return ShiftSwapRequestUtil.undoSwap((ShiftSwapRequest)reqAgg,false);</span>
	    	} else {
<span class="nc" id="L1044">	    		return reqAgg;</span>
	    	}
<span class="nc" id="L1046">    	} catch (Exception e) {</span>
<span class="nc" id="L1047">    		handleException(e);</span>
<span class="nc" id="L1048">    		throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
    	} finally {
<span class="nc" id="L1050">    		m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
    	}
    }

    @Override
	public boolean requestWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment)
			throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L1057">		String methodName = &quot;requestWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L1058">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L1060">			ShiftSwapRequest request = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L1061">			ShiftSwapWithdraw withdraw = new ShiftSwapWithdraw();</span>
<span class="nc" id="L1062">			withdraw.setShiftSwapRequestID(request.getID());</span>
<span class="nc" id="L1063">			withdraw.setRequestStatus(RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>
<span class="nc" id="L1064">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L1065">			withdraw.setCreatorID(user.getID());</span>
<span class="nc" id="L1066">			withdraw.setCreationDate(new Date());</span>
<span class="nc" id="L1067">			request.setWithdrawInfo(withdraw);</span>
<span class="nc" id="L1068">			setAuditTrail(reqAgg, comment, withdraw.getRequestStatus(), true);</span>
<span class="nc" id="L1069">			_updateRequest(reqAgg, reqAgg.getRequestStatus(), comment, null, false, false);</span>
<span class="nc" id="L1070">			reqAgg = getRequestByID(reqAgg.getID(), false, false, reqAgg.getDetailLevel());</span>
<span class="nc" id="L1071">			JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, withdraw.getRequestStatus()));</span>
<span class="nc" id="L1072">			_autoProcess(reqAgg, &quot;&quot;, true);</span>
<span class="nc" id="L1073">			return true;</span>
<span class="nc" id="L1074">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L1075">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1076">			throw e;</span>
<span class="nc" id="L1077">		} catch (Exception e) {</span>
<span class="nc" id="L1078">			handleException(e);</span>
<span class="nc" id="L1079">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1081">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	@Override
	protected boolean isEligibleForCancelWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L1087" title="All 4 branches missed.">		return reqAgg.isShiftSwapRequest() &amp;&amp; ((ShiftSwapRequest) reqAgg).isEligibleForCancelWithdrawAction();</span>
	}

	/**
	 * applies to Cancelling Withdrawal of approved Requests
	 *
	 * @param reqAgg
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected boolean _cancelWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment,
	                                                   boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1102">		String methodName = &quot;_cancelWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L1103">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L1105">			updateSSWithdrawRequest(reqAgg,comment,reqAgg.getRequestStatus(),RequestAuditTrail.STATUS_WITHDRAW_CANCEL, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L1106">			return true;</span>
<span class="nc" id="L1107">		} catch (Exception e) {</span>
<span class="nc" id="L1108">			handleException(e);</span>
<span class="nc" id="L1109">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1111">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

    private void updateSSWithdrawRequest(RequestAggregate reqAgg, String comment, String status, String withdrawStatus,
    		boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {
<span class="nc" id="L1117">    	User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
		// leave the original Shift Swap Request unchanged ; just update the comments
<span class="nc" id="L1119">		ShiftSwapRequest ssRequest = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L1120">		ssRequest.setUpdateAllShiftSwapItems(true);</span>
<span class="nc" id="L1121">		ShiftSwapWithdraw ssWithdraw = ssRequest.getWithdrawInfo();</span>
<span class="nc" id="L1122">		ssWithdraw.setRequestStatus(withdrawStatus);</span>
<span class="nc" id="L1123">		ssWithdraw.setLastModifiedDate(new Date());</span>
<span class="nc bnc" id="L1124" title="All 2 branches missed.">		if (user != null) {</span>
<span class="nc" id="L1125">			ssWithdraw.setModifierID(user.getID());</span>
		}
<span class="nc" id="L1127">		setAuditTrail(reqAgg, comment, ssWithdraw.getRequestStatus(), true);</span>
<span class="nc" id="L1128">		_updateRequest(reqAgg, status, comment, null, suppressPrivilegeChecking, loadedFromDB);</span>
<span class="nc" id="L1129">        JMSNotifyUtil.notifyOnUserAction(new RequestNotificationDetail(reqAgg, withdrawStatus));</span>
<span class="nc" id="L1130">    }</span>


	public void setAuditTrail(RequestAggregate request, String comment, String status, boolean setAuditTrailState) throws Exception {
<span class="nc" id="L1134">		User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L1135">		RequestAuditTrail raTrail = RequestDAO.createAuditTrailObject(status, new Date(), comment, RmEjbBundleKey.UPDATED, user.getID());</span>
<span class="nc" id="L1136">		raTrail.setIsStatusChange(true);</span>
<span class="nc" id="L1137">		request.setAuditTrail(raTrail);</span>
<span class="nc" id="L1138">		request.setAuditTrailSet(setAuditTrailState);</span>
<span class="nc" id="L1139">	}</span>

	@Override
	public boolean isEligibleForAcceptWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L1143" title="All 4 branches missed.">		return reqAgg.isShiftSwapRequest() &amp;&amp; ((ShiftSwapRequest) reqAgg).isEligibleForAcceptWithdrawAction();</span>
	}

	@Override
	protected void _approveRequestWorkFlow(RequestAggregate reqAgg, Collection&lt;ID&gt; choiceIDs, String comment,
			boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception {

<span class="nc bnc" id="L1150" title="All 2 branches missed.">		if (isShiftSwapWithdrawRequest(reqAgg)) {</span>
<span class="nc" id="L1151">			_acceptWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivilegeChecking, loadedFromDB);</span>
		} else {
<span class="nc" id="L1153">			super._approveRequestWorkFlow(reqAgg, choiceIDs, comment, suppressPrivilegeChecking, loadedFromDB);</span>
		}
<span class="nc" id="L1155">	}</span>

	@Override
	protected void _denyRequestWorkflow(RequestAggregate reqAgg, String comment, boolean suppressPrivChecking,
			boolean loadedFromDB) throws Exception {

<span class="nc bnc" id="L1161" title="All 2 branches missed.">		if (isShiftSwapWithdrawRequest(reqAgg)) {</span>
<span class="nc" id="L1162">			_rejectWithdrawOfApprovedRequest(reqAgg, comment, suppressPrivChecking, loadedFromDB);</span>
		} else {
<span class="nc" id="L1164">			super._denyRequestWorkflow(reqAgg, comment, suppressPrivChecking, loadedFromDB);</span>
		}
<span class="nc" id="L1166">	}</span>

	/**applies to Withdrawal of approved Requests
	 * @param reqAgg
	 * @param comment
	 * @param suppressPrivilegeChecking
	 * @param loadedFromDB
	 * @throws Exception
	 */
	@Override
	protected  boolean _acceptWithdrawOfApprovedRequest(RequestAggregate reqAgg,String comment,
			boolean suppressPrivilegeChecking, boolean loadedFromDB) throws Exception{
<span class="nc" id="L1178">		String methodName = &quot;_acceptWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L1179">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L1181">			_undoSchedule(reqAgg, null, null);</span>
<span class="nc" id="L1182">			updateSSWithdrawRequest(reqAgg,comment,RequestAuditTrail.STATUS_WITHDRAWN, RequestAuditTrail.STATUS_WITHDRAW_ACCEPT, suppressPrivilegeChecking, loadedFromDB);</span>
			//SSNotifyMessageClient.scanSSWaitlist(ssRequest, apprChoice); TODO: do we need this?
<span class="nc" id="L1184">			return true;</span>
<span class="nc" id="L1185">		} catch (Exception e) {</span>
<span class="nc" id="L1186">			handleException(e);</span>
<span class="nc" id="L1187">			throw  e;</span>
		} finally {
<span class="nc" id="L1189">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	//Check if request is eligible for rejecting the withdraw
	@Override
	public boolean isEligibleForRejectWithdrawOfApprovedRequest(RequestAggregate reqAgg) throws BbmFinderException {
<span class="nc bnc" id="L1196" title="All 4 branches missed.">		return reqAgg.isShiftSwapRequest() &amp;&amp; ((ShiftSwapRequest) reqAgg).isEligibleForRejectWithdrawAction();</span>
	}

	@Override
	protected boolean _rejectWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment, boolean suppressPrivilegeChecking,
			boolean loadedFromDB) throws Exception {
<span class="nc" id="L1202">		String methodName = &quot;_rejectWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L1203">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
		try {
<span class="nc" id="L1205">			updateSSWithdrawRequest(reqAgg, comment, reqAgg.getRequestStatus(), RequestAuditTrail.STATUS_WITHDRAW_REJECT,</span>
					suppressPrivilegeChecking, loadedFromDB);
<span class="nc" id="L1207">			return true;</span>
<span class="nc" id="L1208">		} catch (Exception e) {</span>
<span class="nc" id="L1209">			handleException(e);</span>
<span class="nc" id="L1210">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L1212">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	/**
	 * Confirmation of a withdrawal request by employee that did not request the withdrawal
	 * @param reqAgg
	 * @param comment
	 * @return boolean - true - update occurred, false - update didn't occur because not required.
	 * @throws BbmUpdateException
	 */
	public boolean confirmWithdrawOfApprovedRequest(RequestAggregate reqAgg, String comment)
			throws BbmUpdateException, RmHardValidationException {
<span class="nc" id="L1225">		String methodName = &quot;confirmWithdrawOfApprovedRequest&quot;;</span>
<span class="nc" id="L1226">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, reqAgg, comment));</span>
<span class="nc" id="L1227">		RequestAggregateDAO reqAggDAO = null;</span>
		try {
<span class="nc" id="L1229">			ShiftSwapRequest request = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L1230">			User user = RequestUtil.getLoginUserBasic(m_sessionContext);</span>
<span class="nc" id="L1231">			RmSecurityManager secMgr = RmSecurityManager.create(reqAgg);</span>
<span class="nc" id="L1232">			secMgr.assertCanModifyRequest(user, reqAgg, RequestAuditTrail.STATUS_WITHDRAW_REQUEST);</span>

			//Set negotiation field if it is waiting for approval and then update status
<span class="nc" id="L1235">			ShiftSwapItem ssItem1 = request.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1236">			ShiftSwapItem ssItem2 = request.getShiftSwapItems().get(1);</span>
<span class="nc" id="L1237">			boolean isNegotiationRequired = false;</span>
<span class="nc bnc" id="L1238" title="All 4 branches missed.">			if (ssItem1.getEmployeeID().compareTo(user.getEmployeeID())==0 &amp;&amp; !ssItem1.getNegotiation()){</span>
<span class="nc" id="L1239">				ssItem1.setNegotiation(true);</span>
<span class="nc" id="L1240">				isNegotiationRequired=true;</span>
			}

<span class="nc bnc" id="L1243" title="All 4 branches missed.">			if (ssItem2.getEmployeeID().compareTo(user.getEmployeeID())==0 &amp;&amp; !ssItem2.getNegotiation()){</span>
<span class="nc" id="L1244">				ssItem2.setNegotiation(true);</span>
<span class="nc" id="L1245">				isNegotiationRequired=true;</span>
			}
<span class="nc bnc" id="L1247" title="All 2 branches missed.">			if (isNegotiationRequired){</span>
<span class="nc" id="L1248">				updateSSWithdrawRequest(reqAgg,comment,reqAgg.getRequestStatus(),RequestAuditTrail.STATUS_WITHDRAW_REQUEST, false, false);</span>

<span class="nc" id="L1250">				long detailLevelForVal = getDetailLevelForValidation() | RequestDetailLevel.DL_SHIFTSWAP_WITHDRAW;</span>
<span class="nc" id="L1251">				reqAggDAO = getDAO(detailLevelForVal);</span>
<span class="nc" id="L1252">				request = (ShiftSwapRequest) reqAggDAO.getRequestByID(reqAgg.getID(), detailLevelForVal);</span>
<span class="nc" id="L1253">				requestWithdrawOfApprovedRequest(request, comment);</span>
<span class="nc" id="L1254">				return true;</span>
			}
			else {
				//This means nothing changed because approval was not required
<span class="nc" id="L1258">				return false;</span>
			}
<span class="nc" id="L1260">		} catch (RmHardValidationException e) {</span>
<span class="nc" id="L1261">			handleException(Level.DEBUG, e);</span>
<span class="nc" id="L1262">			throw e;</span>
<span class="nc" id="L1263">		} catch (Exception e) {</span>
<span class="nc" id="L1264">			handleException(e);</span>
<span class="nc" id="L1265">			throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L1267" title="All 6 branches missed.">			if (reqAggDAO != null) {</span>
<span class="nc" id="L1268">				reqAggDAO.cleanUp();</span>
			}
<span class="nc" id="L1270">			m_cat.debug(RmUtil.dumpExitMethod(methodName));</span>
		}
	}

	private void runSoftValidationsForApprovedSSWithdrawRequest(ShiftSwapRequest ssRequest) throws BbmException {
<span class="nc" id="L1275">		String methodName = &quot;runSoftValidationsForSSWithdrawRequest&quot;;</span>
<span class="nc" id="L1276">		m_cat.debug(RmUtil.dumpEnterMethod(methodName, ssRequest));</span>
		try {
<span class="nc" id="L1278">			ShiftSwapItem ssItem1 = ssRequest.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1279">			ShiftSwapItem ssItem2 = ssRequest.getShiftSwapItems().get(1);</span>

			//run the FilingRule validation per item, since it's the only validation rule that checks only one item.
<span class="nc" id="L1282">			ValidationResult vr = runFilingRuleSoftValidationForApprovedSSWithdrawRequestItem(ssRequest, ssItem1);</span>
			//only check the second item if the first item succeeded
<span class="nc bnc" id="L1284" title="All 2 branches missed.">			if (vr == null) {</span>
<span class="nc" id="L1285">				runFilingRuleSoftValidationForApprovedSSWithdrawRequestItem(ssRequest, ssItem2);</span>
			}

			//run all the other validation rules
<span class="nc" id="L1289">			runNonFilingRuleSoftValidationsForApprovedSSWithdrawRequest(ssRequest);</span>

<span class="nc" id="L1291">		} catch (Exception e) {</span>
			// Log and ignore exceptions form soft rules, and use PSSShiftGapConditions to show icon (instead of showing exception name on the UI)
<span class="nc" id="L1293">			handleException(e, false);</span>
<span class="nc" id="L1294">			ValidationUtil.setSoftValidationResult(ssRequest, e, &quot;com.bluepumpkin.ejb.rm.requests.swap.request.validation.PSSShiftGapConditions&quot;);</span>
		} finally {
<span class="nc" id="L1296">			m_cat.debug(RmUtil.dumpExitMethod(methodName, ssRequest));</span>
<span class="nc" id="L1297">		}</span>
<span class="nc" id="L1298">	}</span>

	 private ValidationResult runFilingRuleSoftValidationForApprovedSSWithdrawRequestItem(ShiftSwapRequest ssRequest,ShiftSwapItem ssItem) throws Exception{
<span class="nc" id="L1301">		 String validatorName = null;</span>
<span class="nc bnc" id="L1302" title="All 4 branches missed.">		 if (ssItem!=null &amp;&amp; ssItem.getShiftType().equals(ShiftSwapItem.SWAPITEMTYPE_SHIFT)){</span>
<span class="nc" id="L1303">			 ValidationCache vc = ssRequest.getValidationCache();</span>
<span class="nc" id="L1304">			 ID orgId = vc.getOrgIDForEmployeeDuringPeriod(ssRequest.getEmployeeID(),</span>
<span class="nc" id="L1305">					 ssItem.getStartDate(),</span>
<span class="nc" id="L1306">					 ssItem.getEndDate());</span>
<span class="nc" id="L1307">			 String requestType = Request.REQUESTTYPE_SHIFTSWAP_WITHDRAW;</span>
<span class="nc" id="L1308">			 Collection validators = vc.getValidators(orgId, requestType);</span>
			 //Set start/end range for specific swap item
<span class="nc" id="L1310">			 ssRequest.getWithdrawInfo().setValidationTimeRange(ssItem.getStartDate(), ssItem.getEndDate());</span>
<span class="nc" id="L1311">			 ssRequest.getWithdrawInfo().setValidationItem(ssItem);</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">			 for (Iterator it = validators.iterator(); it.hasNext();) {</span>
				 // Run the validations
<span class="nc" id="L1314">				 validatorName = (String) it.next();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">				 if (validatorName.equals(FilingRuleComplianceValidationRule.class.getName())) {</span>
<span class="nc" id="L1316">					return ValidationUtil.doValidation(validatorName, ssRequest, validatorMap);</span>
				 }
			 }
		 }
<span class="nc" id="L1320">		 return null;</span>
	 }

	private void runNonFilingRuleSoftValidationsForApprovedSSWithdrawRequest(ShiftSwapRequest ssRequest) throws Exception {
<span class="nc" id="L1324">		ShiftSwapItem ssItem1 = ssRequest.getShiftSwapItems().get(0);</span>
<span class="nc" id="L1325">		ID emp1ID = ssItem1.getEmployeeID();</span>
<span class="nc" id="L1326">		ShiftSwapItem ssItem2 = ssRequest.getShiftSwapItems().get(1);</span>
<span class="nc" id="L1327">		ID emp2ID = ssItem2.getEmployeeID();</span>

		//swap the employee ID's, since they are still assigned to their original schedules (before the original swap).
<span class="nc" id="L1330">		ssItem1.setEmployeeID(emp2ID);</span>
<span class="nc" id="L1331">		ssItem2.setEmployeeID(emp1ID);</span>

		try {
<span class="nc" id="L1334">			ValidationCache vc = ssRequest.getValidationCache();</span>
<span class="nc" id="L1335">			Collection&lt;String&gt; validators = vc.getValidators();</span>

<span class="nc bnc" id="L1337" title="All 2 branches missed.">			for (String validatorName : validators) {</span>
<span class="nc bnc" id="L1338" title="All 2 branches missed.">				if (!validatorName.equals(FilingRuleComplianceValidationRule.class.getName())) {</span>
<span class="nc" id="L1339">				ValidationUtil.doValidation(validatorName, ssRequest, validatorMap);</span>
				}
<span class="nc" id="L1341">			}</span>
		} finally {

			//swap the employee ID's back
<span class="nc" id="L1345">			ssItem1.setEmployeeID(emp1ID);</span>
<span class="nc" id="L1346">			ssItem2.setEmployeeID(emp2ID);</span>

<span class="nc" id="L1348">		}</span>
<span class="nc" id="L1349">	 }</span>

	/**
	 * Determine if a request is a shift swap withdrawl request.
	 */
	 @Override
	public boolean isShiftSwapWithdrawRequest(RequestAggregate reqAgg) {
<span class="nc" id="L1356">		ShiftSwapRequest ssr = (ShiftSwapRequest) reqAgg;</span>
<span class="nc" id="L1357">		ShiftSwapWithdraw ssw = ssr.getWithdrawInfo();</span>
<span class="nc bnc" id="L1358" title="All 4 branches missed.">		if (ssw != null &amp;&amp; ssw.getRequestStatus().equals(RequestAuditTrail.STATUS_WITHDRAW_REQUEST)) {</span>
<span class="nc" id="L1359">			return true;</span>
		}
<span class="nc" id="L1361">		return false;</span>
	}


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>