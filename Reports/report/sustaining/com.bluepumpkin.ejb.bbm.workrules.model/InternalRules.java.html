<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>InternalRules.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.workrules.model</a> &gt; <span class="el_source">InternalRules.java</span></div><h1>InternalRules.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.workrules.model;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeOfDay;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.empworkrule.model.TimePeriodOfDay;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkUnit;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkUnit.WorkUnitType;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;

import java.text.MessageFormat;
import java.util.*;

/**
 * Copyright (c) 2001 Blue Pumpkin Software, Inc
 *
 * @author
 * @version 1.0
 */
<span class="nc" id="L26">public class InternalRules {</span>

	static final int HOURS_IN_DAY = 24;
	static final int MINUTES_IN_HOUR = 60;
	static final int SECONDS_IN_MINUTE = 60;
	static final int MILLISECONDS_IN_SECOND = 1000;
	public static final int DAYS_IN_WEEK = 7;

	//validation methods
	static boolean isMaxHoursValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L38" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 2) {</span>
<span class="nc" id="L39">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}

<span class="nc" id="L42">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>

<span class="nc" id="L44">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L45">		double dMax = ((WorkRuleParameter) w.next()).getDoubleValue();</span>
<span class="nc" id="L46">		double dUpperBound = ((WorkRuleParameter) w.next()).getDoubleValue();</span>
<span class="nc" id="L47">		int nPeriodDays = WorkRuleUtil.getPeriodInDays(ePeriodType, nPeriodLength);</span>

<span class="nc bnc" id="L49" title="All 2 branches missed.">		if (dMax &gt; nPeriodDays * HOURS_IN_DAY) {</span>
<span class="nc" id="L50">			Object[] aArgs = {new Double(dMax), new Integer(nPeriodDays)};</span>
<span class="nc" id="L51">			sMessage.append(</span>
<span class="nc" id="L52">					MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_DAYS_DAY), aArgs));</span>
<span class="nc" id="L53">			return false;</span>
		}

<span class="nc bnc" id="L56" title="All 2 branches missed.">		if (dUpperBound &lt;= dMax) {</span>
<span class="nc" id="L57">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_MUST_BE_GREATER));</span>
<span class="nc" id="L58">			return false;</span>
		}

<span class="nc bnc" id="L61" title="All 4 branches missed.">		if (dUpperBound &lt; 0.0 || dMax &lt; 0.0) {</span>
<span class="nc" id="L62">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L63">			return false;</span>
		}
<span class="nc" id="L65">		return true;</span>
	}

	//validation methods
	static boolean isWorkValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc" id="L72">		int nPeriodDays = WorkRuleUtil.getPeriodInDays(ePeriodType, nPeriodLength);</span>

<span class="nc" id="L74">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>

<span class="nc" id="L76">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L77">		int nClause = ((WorkRuleParameter) w.next()).getClauseValue();</span>
<span class="nc" id="L78">		int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L79">		int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>

<span class="nc bnc" id="L81" title="All 2 branches missed.">		if (nMax &lt; nMin) {</span>
<span class="nc" id="L82">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_MUST_BE_GREATER));</span>
<span class="nc" id="L83">			return false;</span>
		}

<span class="nc bnc" id="L86" title="All 4 branches missed.">		if (nMin &lt; 0.0 || nMax &lt; 0.0) {</span>
<span class="nc" id="L87">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L88">			return false;</span>
		}

<span class="nc bnc" id="L91" title="All 2 branches missed.">		if (nClause == 1) {</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">			if (pWorkRuleParameters.size() != 5) {</span>
<span class="nc" id="L93">				throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
			}

<span class="nc" id="L96">			int nElement = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (nElement == 1) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">				if (nMin &gt; nPeriodDays * 24) {</span>
<span class="nc" id="L99">					Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L100">					sMessage.append(</span>
<span class="nc" id="L101">							MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_HOURS_DAY), aArgs));</span>
<span class="nc" id="L102">					return false;</span>
				}
<span class="nc bnc" id="L104" title="All 2 branches missed.">			} else if (nElement == 2) {</span>
<span class="nc bnc" id="L105" title="All 2 branches missed.">				if (nMin &gt; nPeriodDays) {</span>
<span class="nc" id="L106">					Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L107">					sMessage.append(</span>
<span class="nc" id="L108">							MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_DAYS_DAY), aArgs));</span>
<span class="nc" id="L109">					return false;</span>
				}
			} else {
<span class="nc bnc" id="L112" title="All 2 branches missed.">				if (nMin &gt; nPeriodDays / 7) {</span>
<span class="nc" id="L113">					Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L114">					sMessage.append(</span>
<span class="nc" id="L115">							MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_WEEKENDS_DAY), aArgs));</span>
<span class="nc" id="L116">					return false;</span>
				}
			}
<span class="nc bnc" id="L119" title="All 2 branches missed.">		} else if (nClause == 2) {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">			if (pWorkRuleParameters.size() != 5) {</span>
<span class="nc" id="L121">				throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
			}

<span class="nc bnc" id="L124" title="All 2 branches missed.">			if (nMin &gt; nPeriodDays / 7) {</span>
<span class="nc" id="L125">				Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L126">				sMessage.append(</span>
<span class="nc" id="L127">						MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_WEEKDAYS_DAY), aArgs));</span>
<span class="nc" id="L128">				return false;</span>
			}
		} else {
<span class="nc bnc" id="L131" title="All 2 branches missed.">			if (pWorkRuleParameters.size() != 4) {</span>
<span class="nc" id="L132">				throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
			}

<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (nMin &gt; nPeriodDays) {</span>
<span class="nc" id="L136">				Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L137">				sMessage.append(</span>
<span class="nc" id="L138">						MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_SHIFTS_DAY), aArgs));</span>
<span class="nc" id="L139">				return false;</span>
			}
		}
<span class="nc" id="L142">		return true;</span>
	}

	static boolean isHaveOffValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L148" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 5) {</span>
<span class="nc" id="L149">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}
<span class="nc" id="L151">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>

<span class="nc" id="L153">		int nPeriodDays = WorkRuleUtil.getPeriodInDays(ePeriodType, nPeriodLength);</span>

<span class="nc" id="L155">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L156">		int nClause = ((WorkRuleParameter) w.next()).getClauseValue();</span>
<span class="nc" id="L157">		int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L158">		int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>

<span class="nc bnc" id="L160" title="All 2 branches missed.">		if (nMax &lt; nMin) {</span>
<span class="nc" id="L161">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_MUST_BE_GREATER));</span>
<span class="nc" id="L162">			return false;</span>
		}

<span class="nc bnc" id="L165" title="All 4 branches missed.">		if (nMin &lt; 0.0 || nMax &lt; 0.0) {</span>
<span class="nc" id="L166">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L167">			return false;</span>
		}

<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (nClause == 1) {</span>
<span class="nc" id="L171">			int nElement = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc bnc" id="L172" title="All 2 branches missed.">			if (nElement == 1) {</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">				if (nMin &gt; nPeriodDays) {</span>
<span class="nc" id="L174">					Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L175">					sMessage.append(</span>
<span class="nc" id="L176">							MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_HO_MT_X_DAYS_DAY), aArgs));</span>
<span class="nc" id="L177">					return false;</span>
				}
			} else {
<span class="nc bnc" id="L180" title="All 2 branches missed.">				if (nMin &gt; nPeriodDays / 7) {</span>
<span class="nc" id="L181">					Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L182">					sMessage.append(</span>
<span class="nc" id="L183">							MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_HO_MT_X_WEEKENDS_DAY), aArgs));</span>
<span class="nc" id="L184">					return false;</span>
				}
			}
<span class="nc" id="L187">		} else {</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			if (nMin &gt; nPeriodDays / 7) {</span>
<span class="nc" id="L189">				Object[] aArgs = {new Integer(nMin), new Integer(nPeriodDays)};</span>
<span class="nc" id="L190">				sMessage.append(</span>
<span class="nc" id="L191">						MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_HO_MT_X_WEEKDAYS_DAY), aArgs));</span>
<span class="nc" id="L192">				return false;</span>
			}
		}

<span class="nc" id="L196">		return true;</span>
	}

	static boolean isConsecutiveValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L202" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 4) {</span>
<span class="nc" id="L203">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}

<span class="nc" id="L206">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>

<span class="nc" id="L208">		Iterator w = pWorkRuleParameters.iterator();</span>

<span class="nc" id="L210">		int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L211">		int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>

<span class="nc bnc" id="L213" title="All 2 branches missed.">		if (nMax &lt; nMin) {</span>
<span class="nc" id="L214">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_MUST_BE_GREATER));</span>
<span class="nc" id="L215">			return false;</span>
		}

<span class="nc bnc" id="L218" title="All 4 branches missed.">		if (nMin &lt; 0.0 || nMax &lt; 0.0) {</span>
<span class="nc" id="L219">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L220">			return false;</span>
		}
<span class="nc" id="L222">		return true;</span>
	}


	static boolean isMinPaidHoursValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L229" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 2) {</span>
<span class="nc" id="L230">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}
<span class="nc" id="L232">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>

<span class="nc" id="L234">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L235">		double dLowerBound = ((WorkRuleParameter) w.next()).getDoubleValue();</span>
<span class="nc" id="L236">		double dMin = ((WorkRuleParameter) w.next()).getDoubleValue();</span>

<span class="nc bnc" id="L238" title="All 2 branches missed.">		if (dLowerBound &gt; HOURS_IN_DAY) {</span>
<span class="nc" id="L239">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_24_HOURS_DAY));</span>
<span class="nc" id="L240">			return false;</span>
		}

<span class="nc bnc" id="L243" title="All 2 branches missed.">		if (dMin &lt;= dLowerBound) {</span>
<span class="nc" id="L244">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_AT_LEAST_MUST_BE_GREATER));</span>
<span class="nc" id="L245">			return false;</span>
		}
<span class="nc bnc" id="L247" title="All 4 branches missed.">		if (dLowerBound &lt; 0.0 || dMin &lt; 0.0) {</span>
<span class="nc" id="L248">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L249">			return false;</span>
		}
<span class="nc" id="L251">		return true;</span>
	}

	static boolean isTimeOfDayValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L257" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 2) {</span>
<span class="nc" id="L258">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}

<span class="nc" id="L261">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>
<span class="nc" id="L262">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L263">		TimeOfDay tStart = ((WorkRuleParameter) w.next()).getTimeValue();</span>
<span class="nc" id="L264">		TimeOfDay tEnd = ((WorkRuleParameter) w.next()).getTimeValue();</span>

<span class="nc bnc" id="L266" title="All 2 branches missed.">		if (tStart.equals(tEnd)) {</span>
<span class="nc" id="L267">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_TWO_DIFFERENT_TIMES));</span>
<span class="nc" id="L268">			return false;</span>
		}

<span class="nc" id="L271">		return true;</span>
	}

	static boolean isWeekDayValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L277" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 4) {</span>
<span class="nc" id="L278">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}

<span class="nc" id="L281">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>
<span class="nc" id="L282">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L283">		int nWeekDayStart = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
<span class="nc" id="L284">		TimeOfDay tStart = ((WorkRuleParameter) w.next()).getTimeValue();</span>
<span class="nc" id="L285">		int nWeekDayEnd = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
<span class="nc" id="L286">		TimeOfDay tEnd = ((WorkRuleParameter) w.next()).getTimeValue();</span>

<span class="nc bnc" id="L288" title="All 4 branches missed.">		if (nWeekDayStart == nWeekDayEnd &amp;&amp; tStart.equals(tEnd)) {</span>
<span class="nc" id="L289">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_TWO_DIFFERENT_WEEKDAYS));</span>
<span class="nc" id="L290">			return false;</span>
		}

<span class="nc" id="L293">		return true;</span>
	}

	static boolean isConsecutiveDaysValid(Collection pWorkRuleParameters, int ePeriodType, int nPeriodLength,
			Locale locale, StringBuffer sMessage)
			throws WorkRuleException {
<span class="nc bnc" id="L299" title="All 2 branches missed.">		if (pWorkRuleParameters.size() != 4) {</span>
<span class="nc" id="L300">			throw new WorkRuleException(&quot;Incorrect number of parameters&quot;);</span>
		}

<span class="nc" id="L303">		ResourceBundle rs = ResourceBundle.getBundle(BbmEjbBundleKey.BUNDLE, locale);</span>
<span class="nc" id="L304">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L305">		int nMaxConsecutive = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L306">		int nUpperBoundConsecutive = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L307">		double dMaxDuration = ((WorkRuleParameter) w.next()).getDoubleValue();</span>
<span class="nc" id="L308">		double dUpperBoundDuration = ((WorkRuleParameter) w.next()).getDoubleValue();</span>

<span class="nc" id="L310">		int nPeriodDays = WorkRuleUtil.getPeriodInDays(ePeriodType, nPeriodLength);</span>

<span class="nc bnc" id="L312" title="All 2 branches missed.">		if (dMaxDuration &gt; HOURS_IN_DAY) {</span>
<span class="nc" id="L313">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_24_HOURS_DAY));</span>
<span class="nc" id="L314">			return false;</span>
		}

<span class="nc bnc" id="L317" title="All 4 branches missed.">		if (ePeriodType != WorkRule.NOPERIOD &amp;&amp; nMaxConsecutive &gt; nPeriodDays) {</span>
<span class="nc" id="L318">			Object[] aArgs = {nMaxConsecutive, nPeriodDays};</span>
<span class="nc" id="L319">			sMessage.append(</span>
<span class="nc" id="L320">					MessageFormat.format(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_CONSEC), aArgs));</span>
<span class="nc" id="L321">			return false;</span>
		}

<span class="nc bnc" id="L324" title="All 8 branches missed.">		if (nMaxConsecutive &lt; 0 || nUpperBoundConsecutive &lt; 0 || dMaxDuration &lt; 0.0 || dUpperBoundDuration &lt; 0.0) {</span>
<span class="nc" id="L325">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_GREATER_THAN_0));</span>
<span class="nc" id="L326">			return false;</span>
		}

<span class="nc bnc" id="L329" title="All 2 branches missed.">		if (nMaxConsecutive &gt;= nUpperBoundConsecutive) {</span>
<span class="nc" id="L330">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_CONSEC_MUST));</span>
<span class="nc" id="L331">			return false;</span>
		}

<span class="nc bnc" id="L334" title="All 2 branches missed.">		if (dMaxDuration &gt;= dUpperBoundDuration) {</span>
<span class="nc" id="L335">			sMessage.append(rs.getString(BbmEjbBundleKey.WORKRULE_MT_X_HOURS_MUST_BE_GREATER));</span>
<span class="nc" id="L336">			return false;</span>
		}

<span class="nc" id="L339">		return true;</span>
	}


// validation methods

	static Collection getMaxHoursConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {

		//Employees who work between 40 and 60 hours each 1 Week are paid OT1...

<span class="nc" id="L352">		List pNewConflicts = new LinkedList();</span>
<span class="nc" id="L353">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L354">		int nMax = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>
<span class="nc" id="L355">		int nUpperBound = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>

<span class="nc" id="L357">		int nOldCount = 0;</span>
<span class="nc" id="L358">		int nTotalCount = 0;</span>
		//iterate over the event collection
<span class="nc bnc" id="L360" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L361">			Event pEvent = (Event) i.next();</span>

<span class="nc bnc" id="L363" title="All 2 branches missed.">			if (nOldCount &gt; nUpperBound) {</span>
<span class="nc" id="L364">				break;</span>
			}
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L367" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>


<span class="nc" id="L370">				int nDuration = pEvent.getDuration() - WorkRuleUtil.GetUnpaidDuration(pEvent, pConflicts, nPriority);</span>

<span class="nc" id="L372">				nTotalCount = nOldCount + nDuration;</span>
<span class="nc bnc" id="L373" title="All 2 branches missed.">				if (nTotalCount &gt; nMax) {</span>
					//there is an exception here
<span class="nc" id="L375">					int nExceptionStart = nMax;</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">					if (nOldCount &gt; nMax) {</span>
<span class="nc" id="L377">						nExceptionStart = nOldCount;</span>
					}
<span class="nc" id="L379">					int nExceptionEnd = nTotalCount;</span>
<span class="nc" id="L380">					int nExceptionOffset = 0;</span>
<span class="nc bnc" id="L381" title="All 2 branches missed.">					if (nTotalCount &gt; nUpperBound) {</span>
<span class="nc" id="L382">						nExceptionOffset = nExceptionEnd - nUpperBound;</span>
<span class="nc" id="L383">						nExceptionEnd = nUpperBound;</span>
					}
					//we need to create a new exception to the end of the event or to nUpperBound
<span class="nc" id="L386">					int nExceptionDuration = nExceptionEnd - nExceptionStart;</span>

<span class="nc" id="L388">					Date dtViolationStart = new Date(pEvent.getEndTime().getTime() - ((nExceptionDuration + nExceptionOffset) * 60 * 1000));</span>
<span class="nc" id="L389">					Date dtViolationEnd = new Date(pEvent.getEndTime().getTime() - (nExceptionOffset * 60 * 1000));</span>

<span class="nc" id="L391">					Collection pSplitConflicts =</span>
<span class="nc" id="L392">							WorkRuleUtil.SplitConflicts(pEvent, pConflicts, nPriority, dtViolationStart, dtViolationEnd, true);</span>
<span class="nc" id="L393">					pNewConflicts.addAll(pSplitConflicts);</span>
				}
			}
<span class="nc" id="L396">			nOldCount = nTotalCount;</span>
<span class="nc" id="L397">		}</span>
<span class="nc" id="L398">		return pNewConflicts;</span>
	}

	static Collection getMinPaidHoursConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {
		//Employees who work shifts of at least 0 hours and fewer than 4 hours are paid OT1...

<span class="nc" id="L407">		List&lt;CommonConflict&gt; pNewConflicts = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L408">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L409">		int nLowerBound = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>
<span class="nc" id="L410">		int nMin = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>

<span class="nc bnc" id="L412" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L413">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L414" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>
				//XXX assume 1 event a day
<span class="nc" id="L416">				int nDuration = pEvent.getDuration() - WorkRuleUtil.GetUnpaidDuration(pEvent, pConflicts, nPriority);</span>

<span class="nc bnc" id="L418" title="All 4 branches missed.">				if (nDuration &lt;= nMin &amp;&amp; nDuration &gt; nLowerBound) {</span>
<span class="nc" id="L419">					Date dtViolationEnd = new Date(pEvent.getEndTime().getTime() + (nMin - nDuration) * 1000 * 60);</span>
<span class="nc" id="L420">					CommonConflict pException = new CommonConflict(pEvent.getEndTime(), dtViolationEnd, pEvent.getID());</span>
<span class="nc" id="L421">					pNewConflicts.add(pException);</span>
				}
			}
<span class="nc" id="L424">		}</span>
<span class="nc" id="L425">		return pNewConflicts;</span>
	}

	static Collection getTimeOfDayConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {
		//Employees who work between 1:00AM and  5:00AM hours are paid OT1...

<span class="nc" id="L434">		List pNewConflicts = new LinkedList();</span>
<span class="nc" id="L435">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L436">		TimeOfDay tStart = ((WorkRuleParameter) w.next()).getTimeValue();</span>
<span class="nc" id="L437">		TimeOfDay tEnd = ((WorkRuleParameter) w.next()).getTimeValue();</span>

<span class="nc" id="L439">		Calendar cRuleStart1 = Calendar.getInstance();</span>
<span class="nc" id="L440">		cRuleStart1.setTimeZone(pOrganization.getTimeZone());</span>
<span class="nc" id="L441">		Calendar cRuleEnd1 = Calendar.getInstance();</span>
<span class="nc" id="L442">		cRuleEnd1.setTimeZone(pOrganization.getTimeZone());</span>

		//probably want to convert these from &quot;local&quot; to GMT
<span class="nc" id="L445">		int nRuleStartHour = tStart.getHours();</span>
<span class="nc" id="L446">		int nRuleEndHour = tEnd.getHours();</span>

		//iterate over the event collection
<span class="nc bnc" id="L449" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L450">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L451" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>
				//check for timespans where a parent event violates the rule
<span class="nc" id="L453">				TimeSpan pEventTimeSpan = new TimeSpan(pEvent.getStartTime(), pEvent.getEndTime());</span>

<span class="nc" id="L455">				cRuleStart1.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L456">				cRuleStart1.set(Calendar.HOUR_OF_DAY, nRuleStartHour);</span>

<span class="nc" id="L458">				cRuleEnd1.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L459">				cRuleEnd1.set(Calendar.HOUR_OF_DAY, nRuleEndHour);</span>

<span class="nc bnc" id="L461" title="All 2 branches missed.">				if (nRuleEndHour &lt; nRuleStartHour) {</span>
<span class="nc" id="L462">					cRuleEnd1.add(Calendar.DATE, -1);</span>
				}

<span class="nc" id="L465">				TimeSpan pRulePeriod1 = new TimeSpan(cRuleStart1.getTime(), cRuleEnd1.getTime());</span>

				//lets check if it intersects on the following day as well...
<span class="nc" id="L468">				cRuleStart1.add(Calendar.DATE, 1);</span>
<span class="nc" id="L469">				cRuleEnd1.add(Calendar.DATE, 1);</span>

<span class="nc" id="L471">				TimeSpan pRulePeriod2 = new TimeSpan(cRuleStart1.getTime(), cRuleEnd1.getTime());</span>

<span class="nc" id="L473">				LinkedList apRulePeriods = new LinkedList();</span>
<span class="nc" id="L474">				apRulePeriods.add(pRulePeriod1);</span>
<span class="nc" id="L475">				apRulePeriods.add(pRulePeriod2);</span>
<span class="nc" id="L476">				Collection pViolatingTimeSpans = WorkRuleUtil.getOverlap(pEventTimeSpan, apRulePeriods);</span>

<span class="nc bnc" id="L478" title="All 2 branches missed.">				for (Iterator c = pViolatingTimeSpans.iterator(); c.hasNext(); ) {</span>
<span class="nc" id="L479">					TimeSpan pTimeSpan = (TimeSpan) c.next();</span>
<span class="nc" id="L480">					Collection pSplitConflicts =</span>
<span class="nc" id="L481">							WorkRuleUtil.SplitConflicts(pEvent, pConflicts, nPriority, pTimeSpan.dtSpanStart, pTimeSpan.dtSpanEnd, false);</span>
<span class="nc" id="L482">					pNewConflicts.addAll(pSplitConflicts);</span>
<span class="nc" id="L483">				}</span>
			}
<span class="nc" id="L485">		}</span>
<span class="nc" id="L486">		return pNewConflicts;</span>
	}

	//GQ: How do I create an assignment rule that will call this method? Is this method obsolete??
	static Collection getWeekDayConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {
		//Employees who work between Friday 10:00PM and Saturday 10:00PM are paid OT1...


<span class="nc" id="L497">		LinkedList pNewConflicts = new LinkedList();</span>
<span class="nc" id="L498">		Iterator w = pWorkRuleParameters.iterator();</span>
		//GQ: probably need to add 1 here
<span class="nc" id="L500">		int eWeekDayStart = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
<span class="nc" id="L501">		TimeOfDay tStart = ((WorkRuleParameter) w.next()).getTimeValue();</span>
		//GQ: probably need to add 1 here
<span class="nc" id="L503">		int eWeekDayEnd = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
<span class="nc" id="L504">		TimeOfDay tEnd = ((WorkRuleParameter) w.next()).getTimeValue();</span>

<span class="nc" id="L506">		int nRuleStartHour = tStart.getHours();</span>
<span class="nc" id="L507">		int nRuleEndHour = tEnd.getHours();</span>

<span class="nc" id="L509">		Calendar cEvent = Calendar.getInstance();</span>
<span class="nc" id="L510">		cEvent.setTimeZone(pOrganization.getTimeZone());</span>

		//iterate over the event collection
<span class="nc bnc" id="L513" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L514">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>
<span class="nc" id="L516">				boolean bViolation = false;</span>
				//probably want to convert these to local from GMT
<span class="nc" id="L518">				cEvent.setTime(pEvent.getStartTime());</span>

<span class="nc bnc" id="L520" title="All 2 branches missed.">				if (eWeekDayStart == eWeekDayEnd) {</span>
<span class="nc bnc" id="L521" title="All 4 branches missed.">					if (cEvent.get(Calendar.DAY_OF_WEEK) == eWeekDayEnd &amp;&amp; cEvent.get(Calendar.HOUR_OF_DAY) &gt;= nRuleStartHour &amp;&amp;</span>
<span class="nc bnc" id="L522" title="All 2 branches missed.">							cEvent.get(Calendar.HOUR_OF_DAY) &lt; nRuleEndHour) {</span>
<span class="nc" id="L523">						bViolation = true;</span>
					}
				} else {
<span class="nc bnc" id="L526" title="All 4 branches missed.">					if (cEvent.get(Calendar.DAY_OF_WEEK) == eWeekDayStart &amp;&amp; cEvent.get(Calendar.HOUR_OF_DAY) &gt;= nRuleStartHour) {</span>
<span class="nc" id="L527">						bViolation = true;</span>
<span class="nc bnc" id="L528" title="All 4 branches missed.">					} else if (cEvent.get(Calendar.DAY_OF_WEEK) == eWeekDayEnd &amp;&amp; cEvent.get(Calendar.HOUR_OF_DAY) &lt; nRuleEndHour) {</span>
<span class="nc" id="L529">						bViolation = true;</span>
					} else {
<span class="nc" id="L531">						int nWeekDaysInRule = eWeekDayEnd - eWeekDayStart;</span>
<span class="nc bnc" id="L532" title="All 2 branches missed.">						if (nWeekDaysInRule &lt; 0) {</span>
<span class="nc" id="L533">							nWeekDaysInRule += 7;</span>
						}
<span class="nc" id="L535">						int nWeekDaysAhead = cEvent.get(Calendar.DAY_OF_WEEK) - eWeekDayStart;</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">						if (nWeekDaysAhead &lt; 0) {</span>
<span class="nc" id="L537">							nWeekDaysAhead += 7;</span>
						}
<span class="nc bnc" id="L539" title="All 4 branches missed.">						if (nWeekDaysAhead &gt; 0 &amp;&amp; nWeekDaysAhead &lt; nWeekDaysInRule) {</span>
<span class="nc" id="L540">							bViolation = true;</span>
						}
					}
				}
<span class="nc bnc" id="L544" title="All 2 branches missed.">				if (bViolation) {</span>
<span class="nc" id="L545">					Collection pSplitConflicts =</span>
<span class="nc" id="L546">							WorkRuleUtil.SplitConflicts(pEvent, pConflicts, nPriority, pEvent.getStartTime(), pEvent.getEndTime(), false);</span>
<span class="nc" id="L547">					pNewConflicts.addAll(pSplitConflicts);</span>
				}
			}
<span class="nc" id="L550">		}</span>
<span class="nc" id="L551">		return pNewConflicts;</span>
	}

	static Collection getConsecutiveDaysConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {

		//Employees who work between 7 and 10 days with 0 to 8 hours each day are paid OT1

<span class="nc" id="L561">		List pNewConflicts = new LinkedList();</span>
<span class="nc" id="L562">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L563">		int nMaxConsecutive = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L564">		int nUpperBoundConsecutive = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L565">		int nMaxDuration = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>
<span class="nc" id="L566">		int nUpperBoundDuration = (int) (60.0 * ((WorkRuleParameter) w.next()).getDoubleValue());</span>

<span class="nc" id="L568">		int nConsecutiveDays = 0;</span>
		//this is quite inefficient, I only need to iterate from the first day with an event to the last
<span class="nc" id="L570">		for (Date dtCurrentDay = new Date(dtStartDate.getTime());</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">			 dtCurrentDay.before(dtEndDate);</span>
<span class="nc" id="L572">			 dtCurrentDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND)) {</span>

			//find an event on the current day
			//this is quite inefficient, I don't need to look through events which have already been &quot;found&quot;
			//XXX assuming one event per day
			//TBD what about vacation days???
<span class="nc" id="L578">			Date dtEndDay = new Date();</span>
<span class="nc" id="L579">			dtEndDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND);</span>
<span class="nc" id="L580">			Event pEvent = null;</span>
<span class="nc bnc" id="L581" title="All 2 branches missed.">			for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L582">				Event pEvent1 = (Event) i.next();</span>
<span class="nc bnc" id="L583" title="All 2 branches missed.">				if (WorkRuleUtil.isInPeriodAndApproved(pEvent1, dtCurrentDay, dtEndDay, eOverlap)) {</span>
<span class="nc" id="L584">					pEvent = pEvent1;</span>
<span class="nc" id="L585">					break;</span>
				}
<span class="nc" id="L587">			}</span>

			//found an event
<span class="nc bnc" id="L590" title="All 2 branches missed.">			if (pEvent != null) {</span>
<span class="nc" id="L591">				nConsecutiveDays++;</span>
<span class="nc bnc" id="L592" title="All 4 branches missed.">				if (nConsecutiveDays &gt;= nMaxConsecutive &amp;&amp; nConsecutiveDays &lt; nUpperBoundConsecutive) {</span>
<span class="nc" id="L593">					int nDuration = pEvent.getDuration() - WorkRuleUtil.GetUnpaidDuration(pEvent, pConflicts, nPriority);</span>

<span class="nc bnc" id="L595" title="All 2 branches missed.">					if (nDuration &gt;= nMaxDuration) {</span>
						//there is an exception here
<span class="nc" id="L597">						int nExceptionStart = nMaxDuration;</span>
<span class="nc" id="L598">						int nExceptionEnd = nDuration;</span>
<span class="nc" id="L599">						int nExceptionOffset = 0;</span>
<span class="nc bnc" id="L600" title="All 2 branches missed.">						if (nDuration &gt; nUpperBoundDuration) {</span>
<span class="nc" id="L601">							nExceptionOffset = nExceptionEnd - nUpperBoundDuration;</span>
<span class="nc" id="L602">							nExceptionEnd = nUpperBoundDuration;</span>
						}

						//we need to create a new exception to the end of the event or to nUpperBound
<span class="nc" id="L606">						int nExceptionDuration = nExceptionEnd - nExceptionStart;</span>

<span class="nc" id="L608">						Date dtViolationStart = new Date(pEvent.getEndTime().getTime() - ((nExceptionDuration + nExceptionOffset) * 60 * 1000));</span>
<span class="nc" id="L609">						Date dtViolationEnd = new Date(pEvent.getEndTime().getTime() - (nExceptionOffset * 60 * 1000));</span>

<span class="nc" id="L611">						Collection pSplitConflicts =</span>
<span class="nc" id="L612">								WorkRuleUtil.SplitConflicts(pEvent, pConflicts, nPriority, dtViolationStart, dtViolationEnd, true);</span>
<span class="nc" id="L613">						pNewConflicts.addAll(pSplitConflicts);</span>
					}
<span class="nc" id="L615">				}</span>
			} else {
<span class="nc" id="L617">				nConsecutiveDays = 0;</span>
			}
		}
<span class="nc" id="L620">		return pNewConflicts;</span>
	}

	// assignment rule validation methods
	static Collection getMustWorkConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts, WorkRule workRule)
			throws WorkRuleException {
		//Employees must work...

<span class="nc" id="L630">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L631">		int nClause = ((WorkRuleParameter) w.next()).getClauseValue();</span>

		//System.out.println(&quot;\n\n getMustWorkConflicts(): CLAUSE = &quot; + nClause + &quot; ****************\n\n&quot;);

<span class="nc" id="L635">		int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L636">		int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>

		//An nMin or nMax value of -1 means that there is no limit.
<span class="nc bnc" id="L639" title="All 2 branches missed.">		if (nMin &lt; 0) {</span>
<span class="nc" id="L640">			nMin = 0;</span>
		}

<span class="nc bnc" id="L643" title="All 2 branches missed.">		if (nMax &lt; 0) {</span>
<span class="nc" id="L644">			nMax = Integer.MAX_VALUE;</span>
		}

<span class="nc bnc" id="L647" title="All 2 branches missed.">		if (nMin &gt; nMax) {</span>
<span class="nc" id="L648">			nMin = nMax;</span>
		}

<span class="nc" id="L651">		TimePeriodOfDay tpOfDay = null;</span>
<span class="nc bnc" id="L652" title="All 2 branches missed.">		if (workRule.m_complexWorkRule != null) {</span>
<span class="nc" id="L653">			tpOfDay = workRule.m_complexWorkRule.getWorkUnit().getTimePeriodOfDay();</span>
		}

<span class="nc bnc" id="L656" title="All 2 branches missed.">		if (nClause == 1) {</span>
			//Work unit type
<span class="nc" id="L658">			int nWorkUnitType = ((WorkRuleParameter) w.next()).getIntValue();</span>

			//nElement, WORKUNITTYPE Employee's time period unit of work is day(1), day of week (2), partial weekend (5), full weekend (4)
<span class="nc bnc" id="L661" title="All 2 branches missed.">			if (nWorkUnitType == WorkUnitType.AnyDay.ordinal()) {</span>
<span class="nc" id="L662">				return getDaysConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.Hours.ordinal()) {</span>
<span class="nc" id="L664">				return getHoursConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L665" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.FullWeekend.ordinal()) {</span>
<span class="nc" id="L666">				return getFullWeekendConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.PartialWeekend.ordinal()) {</span>
<span class="nc" id="L668">				return getPartialWeekendConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L669" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.MustStart.ordinal()) {</span>
<span class="nc" id="L670">				return getSameStartConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents, workRule.m_complexWorkRule.getTolerance());</span>
<span class="nc bnc" id="L671" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.ConsecutiveDay.ordinal()) {</span>
<span class="nc" id="L672">				return getConsecutiveDayConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.Activity.ordinal()) {</span>
<span class="nc" id="L674">				return getActivityConflicts(nMin, nMax, pOrganization, dtStartDate, dtEndDate, pEvents, workRule);</span>
			} else {
<span class="nc" id="L676">				return new ArrayList();</span>
			}
<span class="nc bnc" id="L678" title="All 2 branches missed.">		} else if (nClause == 2) { //day of week(2)</span>
<span class="nc" id="L679">			int nWeekDay = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
<span class="nc" id="L680">			return getWeekDayConflicts(nMin, nMax, nWeekDay, tpOfDay, -1, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
		} else { //nClause == 3
<span class="nc" id="L682">			ID idShift = ((WorkRuleParameter) w.next()).getShiftIDValue();</span>
<span class="nc" id="L683">			return getShiftConflicts(nMin, nMax, idShift, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
		}
	}

	static int CountDaysInPeriod(Date dtStart, Date dtEnd, Organization pOrg) {
<span class="nc" id="L688">		return TimeZoneUtil.numberOfDaysRound(dtStart, dtEnd, pOrg.getTimeZone());</span>
	}

	/**
	 * Count the number of times the given weekday appears in the date range. The dtEnd day itself is excluded.
	 *
	 * @param eWeekDay - A Java Calendar day of week (SUNDAY=1, MONDAY=2,..SATURDAY=7)
	 */
	static int CountWeekDaysInPeriod(Date dtStart, Date dtEnd, int eWeekDay, Organization pOrg) {
<span class="nc" id="L697">		int nDays = 0;</span>
<span class="nc" id="L698">		Calendar cCalendar = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L699">		for (cCalendar.setTime(dtStart);</span>
<span class="nc bnc" id="L700" title="All 2 branches missed.">			 cCalendar.getTime().before(dtEnd);</span>
<span class="nc" id="L701">			 cCalendar.add(Calendar.DAY_OF_MONTH, 1)) {</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">			if (cCalendar.get(Calendar.DAY_OF_WEEK) == eWeekDay) {</span>
<span class="nc" id="L703">				nDays++;</span>
			}
		}
<span class="nc" id="L706">		return nDays;</span>
	}

	static Collection getMustHaveOffConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts, WorkRule workRule)
			throws WorkRuleException {
		//Employees must have off...

<span class="nc" id="L715">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L716">		int nClause = ((WorkRuleParameter) w.next()).getClauseValue();</span>

<span class="nc" id="L718">		int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L719">		int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>

<span class="nc" id="L721">		int nWorkUnitType = 0;</span>
<span class="nc" id="L722">		int nWeekDay = Calendar.SATURDAY;</span>

<span class="nc bnc" id="L724" title="All 2 branches missed.">		if (nClause == 1) {</span>
			//the workUnitType
<span class="nc" id="L726">			nWorkUnitType = ((WorkRuleParameter) w.next()).getIntValue();</span>
			//weekend start stored in bpconfig from 0-Sunday to 6-Sat, but java calendar is 1-Sunday, 7-sat
<span class="nc" id="L728">			nWeekDay = pOrganization.getWeekendStart();</span>
		} else {
			//the getWeekDayValue
<span class="nc" id="L731">			nWeekDay = ((WorkRuleParameter) w.next()).getWeekDayValue();</span>
		}

<span class="nc" id="L734">		TimePeriodOfDay tpOfDay = null;</span>
<span class="nc bnc" id="L735" title="All 2 branches missed.">		if (workRule.m_complexWorkRule != null) {</span>
<span class="nc" id="L736">			tpOfDay = workRule.m_complexWorkRule.getWorkUnit().getTimePeriodOfDay();</span>
		}

<span class="nc" id="L739">		int nDaysInPeriod = 0;</span>
<span class="nc bnc" id="L740" title="All 4 branches missed.">		if ((nClause == 1) &amp;&amp; (nWorkUnitType == WorkUnitType.AnyDay.ordinal())) {</span>
<span class="nc" id="L741">			nDaysInPeriod = CountDaysInPeriod(dtStartDate, dtEndDate, pOrganization);</span>
		} else {
<span class="nc" id="L743">			nDaysInPeriod = CountWeekDaysInPeriod(dtStartDate, dtEndDate, nWeekDay + 1, pOrganization);</span>
		}

		//An nMin or nMax value of -1 means that there is no limit.
<span class="nc bnc" id="L747" title="All 2 branches missed.">		if (nMin &lt; 0) {</span>
<span class="nc" id="L748">			nMin = 0;</span>
		}

<span class="nc bnc" id="L751" title="All 2 branches missed.">		if (nMin &gt; nDaysInPeriod) {</span>
<span class="nc" id="L752">			nMin = nDaysInPeriod;</span>
		}

<span class="nc" id="L755">		int nDaysInPeriodAllowed = nDaysInPeriod - nMin;</span>

<span class="nc bnc" id="L757" title="All 4 branches missed.">		if (nMax &gt; nDaysInPeriod || nMax &lt; 0) {</span>
<span class="nc" id="L758">			nMax = nDaysInPeriod;</span>
		}

<span class="nc bnc" id="L761" title="All 2 branches missed.">		if (nMin &gt; nMax) {</span>
<span class="nc" id="L762">			nMin = nMax;</span>
		}

<span class="nc" id="L765">		int tempMin = nMin;</span>
<span class="nc" id="L766">		int tempMax = nMax;</span>
<span class="nc" id="L767">		nMin = nDaysInPeriod - nMax;</span>
<span class="nc" id="L768">		nMax = nDaysInPeriod - tempMin;</span>

<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (nClause == 1) {</span>

<span class="nc bnc" id="L772" title="All 2 branches missed.">			if (nWorkUnitType == WorkUnitType.AnyDay.ordinal()) {</span>
<span class="nc" id="L773">				return getDaysConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L774" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.Weekend.ordinal()) {</span>
<span class="nc" id="L775">				return getWeekendConflicts(nMin, nMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
<span class="nc bnc" id="L776" title="All 2 branches missed.">			} else if (nWorkUnitType == WorkUnitType.FullWeekend.ordinal()) {</span>
				//I realize this sounds wrong, but &quot;FullWeekend&quot; here means &quot;must have off partial weekend&quot; rule
<span class="nc" id="L778">				return getPartialWeekendConflicts(tempMin, tempMax, tpOfDay, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
			} else {
				//Team rules and fairness rules are not supported on the web (93662)
<span class="nc" id="L781">				return new ArrayList();</span>
			}
		} else {
<span class="nc" id="L784">			return getWeekDayConflicts(nMin, nMax, nWeekDay, tpOfDay, nDaysInPeriodAllowed, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
		}
	}

	static Collection getConsecutiveConflicts(Collection pWorkRuleParameters, int nPriority,
			Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents, Collection pConflicts)
			throws WorkRuleException {
		//Employees must work consecutive...

<span class="nc" id="L794">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L795">		int nClause = ((WorkRuleParameter) w.next()).getClauseValue();</span>

<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (nClause == 1) {</span>
<span class="nc" id="L798">			int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L799">			int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L800">			int nElement = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">			if (nElement == 1) {</span>
<span class="nc" id="L802">				return getConsecutiveDaysConflicts(nMin, nMax, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
			} else {
<span class="nc" id="L804">				return getConsecutiveDaysOffConflicts(nMin, nMax, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
			}
		} else {
<span class="nc" id="L807">			int nMin = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L808">			int nMax = ((WorkRuleParameter) w.next()).getIntValue();</span>
<span class="nc" id="L809">			ID idShift = ((WorkRuleParameter) w.next()).getShiftIDValue();</span>
<span class="nc" id="L810">			return getConsecutiveShiftConflicts(nMin, nMax, idShift, pOrganization, dtStartDate, dtEndDate, pEvents);</span>
		}
	}

	static Collection getHoursConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L817">		nMin *= 60;</span>

<span class="nc bnc" id="L819" title="All 2 branches missed.">		if (nMax == -1) {</span>
<span class="nc" id="L820">			nMax = Integer.MAX_VALUE;</span>
		}

		//nMax has been set to Max Integer, if times 60, it will be -60. --WFM - 19963 &amp;#150; Invalid Warning messages on assignment rule violation - ESR#4318142
<span class="nc bnc" id="L824" title="All 2 branches missed.">		if (nMax != Integer.MAX_VALUE) {</span>
<span class="nc" id="L825">			nMax *= 60;</span>
		}

<span class="nc" id="L828">		int nTotalDuration = 0;</span>
<span class="nc" id="L829">		List aNewConflicts = new ArrayList();</span>

		//iterate over the event collection
<span class="nc bnc" id="L832" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L833">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L835" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L836">				nTotalDuration += pEvent.getDuration() - WorkRuleUtil.GetUnpaidDuration(pEvent);</span>
			}
<span class="nc" id="L838">		}</span>
<span class="nc bnc" id="L839" title="All 2 branches missed.">		if (nTotalDuration &lt; nMin) {</span>
<span class="nc" id="L840">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nTotalDuration - nMin) / 60.0, CommonConflict.HOURS));</span>
<span class="nc bnc" id="L841" title="All 2 branches missed.">		} else if (nTotalDuration &gt; nMax) {</span>
<span class="nc" id="L842">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nTotalDuration - nMax) / 60.0, CommonConflict.HOURS));</span>
		}

<span class="nc" id="L845">		return aNewConflicts;</span>
	}

	static Collection getDaysConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L851">		int nTotalDays = 0;</span>
<span class="nc" id="L852">		List aNewConflicts = new ArrayList();</span>

		//iterate over the event collection
<span class="nc bnc" id="L855" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L856">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L858" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L859">				nTotalDays++;</span>
			}
<span class="nc" id="L861">		}</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">		if (nTotalDays &lt; nMin) {</span>
<span class="nc" id="L863">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMin, CommonConflict.DAYS));</span>
<span class="nc bnc" id="L864" title="All 4 branches missed.">		} else if (nMax &gt; 0 &amp;&amp; nTotalDays &gt; nMax) {</span>
<span class="nc" id="L865">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMax, CommonConflict.DAYS));</span>
		}

<span class="nc" id="L868">		return aNewConflicts;</span>
	}

	static Collection getFullWeekendConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L874">		int nTotalWeekends = 0;</span>
<span class="nc" id="L875">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L876">		Event pPreviousEvent = null;</span>
<span class="nc" id="L877">		Calendar cCalendar = Calendar.getInstance(pOrganization.getTimeZone());</span>
<span class="nc" id="L878">		Event pPreviousSundayEvent = null;</span>

		//iterate over the event collection
<span class="nc bnc" id="L881" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L882">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L884" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L885">				cCalendar.setTime(pEvent.getStartTime());</span>

<span class="nc bnc" id="L887" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart()) % DAYS_IN_WEEK)) {</span>
<span class="nc bnc" id="L888" title="All 4 branches missed.">					if (pPreviousSundayEvent != null &amp;&amp; WorkRuleUtil.isPreviousWeekButOne(pPreviousSundayEvent.getStartTime(), pEvent.getStartTime(), pOrganization)) {</span>
<span class="nc" id="L889">						nTotalWeekends++;</span>
<span class="nc" id="L890">						pPreviousSundayEvent = null;</span>
					}
				}

<span class="nc bnc" id="L894" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart() + 1) % DAYS_IN_WEEK)) {</span>
<span class="nc bnc" id="L895" title="All 4 branches missed.">					if (pPreviousEvent != null &amp;&amp; WorkRuleUtil.isPreviousDay(pPreviousEvent.getStartTime(), pEvent.getStartTime(), pOrganization)) {</span>
<span class="nc" id="L896">						nTotalWeekends++;</span>
					} else {
<span class="nc" id="L898">						pPreviousSundayEvent = pEvent;</span>
					}
				}

<span class="nc" id="L902">				pPreviousEvent = pEvent;</span>
			}
<span class="nc" id="L904">		}</span>
<span class="nc bnc" id="L905" title="All 2 branches missed.">		if (nTotalWeekends &lt; nMin) {</span>
<span class="nc" id="L906">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalWeekends - nMin, CommonConflict.WEEKENDS));</span>
<span class="nc bnc" id="L907" title="All 2 branches missed.">		} else if (nTotalWeekends &gt; nMax) {</span>
<span class="nc" id="L908">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalWeekends - nMax, CommonConflict.WEEKENDS));</span>
		}

<span class="nc" id="L911">		return aNewConflicts;</span>
	}

	static Collection getWeekendConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L917">		int nTotalWeekends = 0;</span>
<span class="nc" id="L918">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L919">		Event pPreviousEvent = null;</span>
<span class="nc" id="L920">		Calendar cCalendar = Calendar.getInstance(pOrganization.getTimeZone());</span>

		//iterate over the event collection
<span class="nc bnc" id="L923" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L924">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L926" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L927">				cCalendar.setTime(pEvent.getStartTime());</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart()) % DAYS_IN_WEEK)) {</span>
<span class="nc" id="L929">					nTotalWeekends++;</span>
				}

<span class="nc bnc" id="L932" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart() + 1) % DAYS_IN_WEEK)) {</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">					if (pPreviousEvent == null || !WorkRuleUtil.isPreviousDay(pPreviousEvent.getStartTime(), pEvent.getStartTime(), pOrganization)) {</span>
						//avoid double counting
<span class="nc" id="L935">						nTotalWeekends++;</span>
					}
				}

<span class="nc" id="L939">				pPreviousEvent = pEvent;</span>
			}
<span class="nc" id="L941">		}</span>
<span class="nc bnc" id="L942" title="All 2 branches missed.">		if (nTotalWeekends &lt; nMin) {</span>
<span class="nc" id="L943">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalWeekends - nMin, CommonConflict.PARTIALS));</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">		} else if (nTotalWeekends &gt; nMax) {</span>
<span class="nc" id="L945">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalWeekends - nMax, CommonConflict.PARTIALS));</span>
		}

<span class="nc" id="L948">		return aNewConflicts;</span>
	}

	/**
	 * GQ: This might not work for multi-week SP's, since I think we pass the entire SP's date range, and the partial weekend
	 * assignment rule should only be applied to one week at a time.
	 */
	static Collection getPartialWeekendConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L958">		int nTotalWeekends = 0;</span>
<span class="nc" id="L959">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L960">		Event pPreviousEvent = null;</span>
<span class="nc" id="L961">		Calendar cCalendar = Calendar.getInstance(pOrganization.getTimeZone());</span>
<span class="nc" id="L962">		boolean isShiftInWeekend = false;</span>

		//iterate over the event collection
<span class="nc bnc" id="L965" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L966">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L968" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L969">				cCalendar.setTime(pEvent.getStartTime());</span>

				//weekend start stored in bpconfig from 0-Sunday to 6-Sat, but java calendar is 1-Sunday, 7-sat
<span class="nc bnc" id="L972" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart()) % DAYS_IN_WEEK)) {</span>
<span class="nc" id="L973">					isShiftInWeekend = true;</span>
<span class="nc" id="L974">					nTotalWeekends++;</span>
				}

<span class="nc bnc" id="L977" title="All 2 branches missed.">				if (cCalendar.get(Calendar.DAY_OF_WEEK) - 1 == ((pOrganization.getWeekendStart() + 1) % DAYS_IN_WEEK)) {</span>
<span class="nc" id="L978">					isShiftInWeekend = true;</span>
<span class="nc bnc" id="L979" title="All 4 branches missed.">					if (pPreviousEvent == null || !WorkRuleUtil.isPreviousDay(pPreviousEvent.getStartTime(), pEvent.getStartTime(), pOrganization)) {</span>
						//avoid double counting
<span class="nc" id="L981">						nTotalWeekends++;</span>
					} else {
						//don't count weekeds which both days are worked
<span class="nc" id="L984">						nTotalWeekends--;</span>
					}
				}

<span class="nc" id="L988">				pPreviousEvent = pEvent;</span>
			}
<span class="nc" id="L990">		}</span>

<span class="nc bnc" id="L992" title="All 4 branches missed.">		if (isShiftInWeekend &amp;&amp; nTotalWeekends &lt; nMin) {</span>
<span class="nc" id="L993">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nMin - nTotalWeekends, CommonConflict.PARTIALS));</span>
<span class="nc bnc" id="L994" title="All 2 branches missed.">		} else if (nTotalWeekends &gt; nMax) {</span>
<span class="nc" id="L995">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalWeekends - nMax, CommonConflict.PARTIALS));</span>
		}

<span class="nc" id="L998">		return aNewConflicts;</span>
	}

	static Collection getSameStartConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents, float tolerance) {
<span class="nc" id="L1003">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L1004">		Calendar cCalendar = Calendar.getInstance(pOrganization.getTimeZone());</span>
<span class="nc" id="L1005">		int nShiftAssignmentSameStart = -1;</span>
<span class="nc" id="L1006">		Date dtViolationSEAStart = null;</span>
<span class="nc" id="L1007">		HashMap hm = new HashMap();</span>
<span class="nc" id="L1008">		HashMap&lt;Integer, List&lt;Event&gt;&gt; startTimeForEvents = new HashMap&lt;&gt;();</span>
		List listEvents;
<span class="nc" id="L1010">		int maxSize = 0;</span>

		//iterate over the event collection
<span class="nc bnc" id="L1013" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1014">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L1016" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L1017">				cCalendar.setTime(pEvent.getStartTime());</span>

<span class="nc" id="L1019">				int nStarttimeEvent = (cCalendar.get(Calendar.HOUR_OF_DAY) * MINUTES_IN_HOUR) + cCalendar.get(Calendar.MINUTE);</span>

<span class="nc bnc" id="L1021" title="All 2 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc bnc" id="L1022" title="All 2 branches missed.">					if (null == startTimeForEvents.get(nStarttimeEvent)) {</span>
<span class="nc" id="L1023">						listEvents = new ArrayList();</span>
<span class="nc" id="L1024">						listEvents.add(pEvent);</span>
<span class="nc" id="L1025">						startTimeForEvents.put(nStarttimeEvent, listEvents);</span>
						//to maintain counts
<span class="nc bnc" id="L1027" title="All 2 branches missed.">						if (maxSize == 0) {</span>
<span class="nc" id="L1028">							maxSize = 1;</span>
<span class="nc" id="L1029">							nShiftAssignmentSameStart = nStarttimeEvent;</span>
						}
					} else {
<span class="nc" id="L1032">						startTimeForEvents.get(nStarttimeEvent).add(pEvent);</span>
<span class="nc" id="L1033">						int size = startTimeForEvents.get(nStarttimeEvent).size();</span>
<span class="nc bnc" id="L1034" title="All 2 branches missed.">						if (size &gt; maxSize) {</span>
<span class="nc" id="L1035">							maxSize = size;</span>
<span class="nc" id="L1036">							nShiftAssignmentSameStart = nStarttimeEvent;</span>
						}
					}
				}
<span class="nc bnc" id="L1040" title="All 4 branches missed.">				if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT &amp;&amp; nMin == 1) {</span>
<span class="nc" id="L1041">					ShiftEventAssignment shiftEventAssignment = (ShiftEventAssignment) pEvent;</span>
<span class="nc" id="L1042">					ID idShiftEvent = shiftEventAssignment.getShiftEventID();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">					if (!hm.containsKey(idShiftEvent)) {</span>
<span class="nc" id="L1044">						hm.put(idShiftEvent, new Integer(nStarttimeEvent));</span>
					} else {
<span class="nc" id="L1046">						Integer iObj = (Integer) hm.get(idShiftEvent);</span>
<span class="nc" id="L1047">						int nShiftEventAssignmentSameStart = iObj.intValue();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">						if (Math.abs(nStarttimeEvent - nShiftEventAssignmentSameStart) &gt; 0) {</span>
<span class="nc" id="L1049">							dtViolationSEAStart = pEvent.getStartTime();</span>
						}

					}

				}
			}
<span class="nc" id="L1056">		}</span>
<span class="nc" id="L1057">		int tol = Math.round(tolerance);</span>

<span class="nc bnc" id="L1059" title="All 2 branches missed.">		for (Map.Entry&lt;Integer, List&lt;Event&gt;&gt; entry : startTimeForEvents.entrySet()) {</span>
<span class="nc" id="L1060">			int startTime = entry.getKey();</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">			if (nShiftAssignmentSameStart != startTime) {</span>
				//if within tolerance limit then continue
<span class="nc bnc" id="L1063" title="All 4 branches missed.">				if ((nShiftAssignmentSameStart + tol) &gt;= startTime &amp;&amp;</span>
						(nShiftAssignmentSameStart - tol) &lt;= startTime) {
<span class="nc" id="L1065">					continue;</span>
				} else {
<span class="nc bnc" id="L1067" title="All 2 branches missed.">					for (Event event : entry.getValue()) {</span>
<span class="nc" id="L1068">						aNewConflicts.add(new CommonConflict(event.getStartTime(), event.getStartTime(), 0, CommonConflict.CONSISTENTSHIFTS));</span>
<span class="nc" id="L1069">					}</span>
				}
			}
<span class="nc" id="L1072">		}</span>

<span class="nc bnc" id="L1074" title="All 2 branches missed.">		if (dtViolationSEAStart != null) {</span>
<span class="nc" id="L1075">			aNewConflicts.add(new CommonConflict(dtViolationSEAStart, dtViolationSEAStart, 0, CommonConflict.CONSISTENTSHIFTSANDSHIFTEVENTS));</span>
		}
<span class="nc" id="L1077">		return aNewConflicts;</span>
	}


	static Collection getConsecutiveDayConflicts(int nMin, int nMax, TimePeriodOfDay nPartOfDay,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {
<span class="nc" id="L1083">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L1084">		HashMap&lt;Date, Boolean&gt; eventDateInPartOfDay = new HashMap&lt;&gt;();</span>

		//iterate over the event collection
<span class="nc bnc" id="L1087" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1088">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L1089" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1090">				eventDateInPartOfDay.put(pEvent.getStartTime(), WorkRuleUtil.isShiftInPartOfDay(pEvent, pOrganization, nPartOfDay));</span>
			}
<span class="nc" id="L1092">		}</span>

		//get keys and sort
<span class="nc" id="L1095">		Set&lt;Date&gt; datesSet = eventDateInPartOfDay.keySet();</span>
<span class="nc" id="L1096">		List&lt;Date&gt; dates = new ArrayList&lt;&gt;(datesSet);</span>
<span class="nc" id="L1097">		Collections.sort(dates);</span>

<span class="nc" id="L1099">		int nConsecutive = 0;</span>
<span class="nc" id="L1100">		Date startDateConsecutive = null;</span>
<span class="nc" id="L1101">		Date nextDay = null;</span>
<span class="nc" id="L1102">		List&lt;Pair&lt;Date, Date&gt;&gt; violationsPairs = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1104" title="All 2 branches missed.">		for (Date d : dates) {</span>
			//event is in correct partofday
<span class="nc bnc" id="L1106" title="All 2 branches missed.">			if (eventDateInPartOfDay.get(d)) {</span>
<span class="nc bnc" id="L1107" title="All 4 branches missed.">				if (nextDay != null &amp;&amp; !d.after(nextDay)) {</span>
<span class="nc" id="L1108">					nConsecutive++;</span>
				} else {
<span class="nc" id="L1110">					nConsecutive = 1;</span>
<span class="nc" id="L1111">					startDateConsecutive = d;</span>
				}
				//if nConsecitive is greater than nMin then check for nMax 
<span class="nc bnc" id="L1114" title="All 2 branches missed.">				if (nConsecutive &gt; nMin) {</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">					if (nConsecutive &gt; nMax) {</span>
<span class="nc" id="L1116">						Pair&lt;Date, Date&gt; violatingpair = new Pair(startDateConsecutive, d);</span>
<span class="nc" id="L1117">						violationsPairs.add(violatingpair);</span>
<span class="nc" id="L1118">						startDateConsecutive = d;</span>
					}
				}
				//add 24 hrs
<span class="nc" id="L1122">				nextDay = new Date(d.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND);</span>
<span class="nc" id="L1123">				continue;</span>
			}

			//if current date is not consecutive then check if the prev consecutive day is over the nMin
<span class="nc bnc" id="L1127" title="All 4 branches missed.">			if (nConsecutive &gt; 0 &amp;&amp; nConsecutive &lt; nMin) {</span>
<span class="nc" id="L1128">				Pair&lt;Date, Date&gt; violatingpair = new Pair(startDateConsecutive, d);</span>
<span class="nc" id="L1129">				violationsPairs.add(violatingpair);</span>
			}
<span class="nc" id="L1131">			nextDay = null;</span>
<span class="nc" id="L1132">			nConsecutive = 0;</span>
<span class="nc" id="L1133">			startDateConsecutive = null;</span>
<span class="nc" id="L1134">		}</span>

		//boundary issue when there is no break in consecutivity of shifts then minimum rule must be tested outside the loop.
<span class="nc bnc" id="L1137" title="All 4 branches missed.">		if (nConsecutive &gt; 0 &amp;&amp; startDateConsecutive != null) {</span>
<span class="nc bnc" id="L1138" title="All 4 branches missed.">			if (nConsecutive &gt; 0 &amp;&amp; nConsecutive &lt; nMin) {</span>
<span class="nc" id="L1139">				Pair&lt;Date, Date&gt; violatingpair = new Pair(startDateConsecutive, dates.get(dates.size() - 1));</span>
<span class="nc" id="L1140">				violationsPairs.add(violatingpair);</span>
			}
		}

<span class="nc bnc" id="L1144" title="All 2 branches missed.">		for (Pair&lt;Date, Date&gt; pair : violationsPairs) {</span>
<span class="nc bnc" id="L1145" title="All 4 branches missed.">			if (!pair.getFirst().before(dtStart) &amp;&amp; pair.getFirst().before(dtEnd)) {</span>
<span class="nc" id="L1146">				aNewConflicts.add(new CommonConflict(pair.getFirst(), pair.getFirst(), 0, CommonConflict.CONSISTENTSHIFTS));</span>
<span class="nc bnc" id="L1147" title="All 4 branches missed.">			} else if (!pair.getSecond().before(dtStart) &amp;&amp; pair.getSecond().before(dtEnd)) {</span>
<span class="nc" id="L1148">				aNewConflicts.add(new CommonConflict(pair.getSecond(), pair.getSecond(), 0, CommonConflict.CONSISTENTSHIFTS));</span>
			}
<span class="nc" id="L1150">		}</span>
<span class="nc" id="L1151">		return aNewConflicts;</span>
	}


	static Collection getWeekDayConflicts(int nMin, int nMax, int nWeekday, TimePeriodOfDay nPartOfDay, int nDaysAllowedInPeriod,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L1158">		int nTotalDays = 0;</span>
<span class="nc" id="L1159">		List aNewConflicts = new ArrayList();</span>
<span class="nc" id="L1160">		Calendar cCal = Calendar.getInstance(pOrganization.getTimeZone());</span>

		//iterate over the event collection
<span class="nc bnc" id="L1163" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1164">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L1166" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, nPartOfDay)) {</span>
<span class="nc" id="L1167">				cCal.setTime(pEvent.getStartTime());</span>
				//fix 82496: Calendar sunday from 1, our nWeekDay's sunday is from 0
<span class="nc bnc" id="L1169" title="All 2 branches missed.">				if (cCal.get(Calendar.DAY_OF_WEEK) == (nWeekday + 1)) {</span>
<span class="nc" id="L1170">					nTotalDays++;</span>
				}
			}
<span class="nc" id="L1173">		}</span>

<span class="nc bnc" id="L1175" title="All 2 branches missed.">		if (nTotalDays &lt; nMin) {</span>
<span class="nc" id="L1176">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMin, CommonConflict.WEEKDAYS));</span>
<span class="nc bnc" id="L1177" title="All 4 branches missed.">		} else if (nMax &gt; 0 &amp;&amp; nTotalDays &gt; nMax) {</span>
<span class="nc" id="L1178">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMax, CommonConflict.WEEKDAYS));</span>
<span class="nc bnc" id="L1179" title="All 4 branches missed.">		} else if (nDaysAllowedInPeriod &gt;= 0 &amp;&amp; nTotalDays &gt; nDaysAllowedInPeriod) {</span>
<span class="nc" id="L1180">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nDaysAllowedInPeriod, CommonConflict.WEEKDAYS));</span>
		}

<span class="nc" id="L1183">		return aNewConflicts;</span>
	}

	static Collection getShiftConflicts(int nMin, int nMax, ID idShift,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L1189">		int nTotalDays = 0;</span>
<span class="nc" id="L1190">		List aNewConflicts = new ArrayList();</span>

		//iterate over the event collection
<span class="nc bnc" id="L1193" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1194">			Event pEvent = (Event) i.next();</span>
			//if the event is in the period, increment the hours count
<span class="nc bnc" id="L1196" title="All 2 branches missed.">			if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, null)) {</span>
<span class="nc" id="L1197">				ID shiftID = ((ShiftAssignment) pEvent).getShiftID();</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">				if (shiftID != null &amp;&amp; shiftID.equals(idShift)) //custom shift has no shift id.</span>
				{
<span class="nc" id="L1200">					nTotalDays++;</span>
				}
			}
<span class="nc" id="L1203">		}</span>
<span class="nc bnc" id="L1204" title="All 2 branches missed.">		if (nTotalDays &lt; nMin) {</span>
<span class="nc" id="L1205">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMin, CommonConflict.SHIFTS));</span>
<span class="nc bnc" id="L1206" title="All 4 branches missed.">		} else if (nMax &gt; 0 &amp;&amp; nTotalDays &gt; nMax) //if no max limit, nMax = -1</span>
		{
<span class="nc" id="L1208">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalDays - nMax, CommonConflict.SHIFTS));</span>
		}

<span class="nc" id="L1211">		return aNewConflicts;</span>
	}


	/**
	 * Get conflicts involving &quot;Shift Events Of Activity ___&quot; clauses.
	 */
	static Collection getActivityConflicts(int nMin, int nMax,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection saEvents, WorkRule workRule) {

<span class="nc" id="L1221">		int nTotalShiftEvents = 0;</span>
<span class="nc" id="L1222">		List aNewConflicts = new ArrayList();</span>

<span class="nc bnc" id="L1224" title="All 2 branches missed.">		if (workRule != null) {</span>
<span class="nc" id="L1225">			ComplexWorkRule cwr = workRule.m_complexWorkRule;</span>
<span class="nc bnc" id="L1226" title="All 2 branches missed.">			if (cwr != null) {</span>
<span class="nc" id="L1227">				Collection cwrRelatedObjs = cwr.getRelatedObjects(ComplexWorkRule.WORKUNIT_RELATIONSHIP_KEY);</span>
<span class="nc bnc" id="L1228" title="All 4 branches missed.">				if (cwrRelatedObjs != null &amp;&amp; !cwrRelatedObjs.isEmpty()) {</span>
<span class="nc" id="L1229">					WorkUnit workUnit = (WorkUnit) cwrRelatedObjs.iterator().next();</span>
<span class="nc" id="L1230">					List&lt;Activity&gt; activities = workUnit.getActivities();</span>

<span class="nc bnc" id="L1232" title="All 4 branches missed.">					if (activities != null &amp;&amp; !activities.isEmpty()) {</span>
						//iterate over the event collection
<span class="nc bnc" id="L1234" title="All 2 branches missed.">						for (Iterator saIt = saEvents.iterator(); saIt.hasNext(); ) {</span>
<span class="nc" id="L1235">							Event pEvent = (Event) saIt.next();</span>
							//if the event is in the period, increment the hours count
<span class="nc bnc" id="L1237" title="All 2 branches missed.">							if (WorkRuleUtil.isShiftInPeriod(pEvent, pOrganization, dtStart, dtEnd, null)) {</span>
<span class="nc" id="L1238">								ShiftAssignment sa = (ShiftAssignment) pEvent;</span>
<span class="nc" id="L1239">								Collection shiftEvents = sa.getChildren();</span>
<span class="nc bnc" id="L1240" title="All 4 branches missed.">								if (shiftEvents != null &amp;&amp; shiftEvents.size() &gt; 0) {</span>
<span class="nc bnc" id="L1241" title="All 2 branches missed.">									for (Iterator seIt = shiftEvents.iterator(); seIt.hasNext(); ) {</span>
<span class="nc" id="L1242">										Event shiftEvent = (Event) seIt.next();</span>
<span class="nc bnc" id="L1243" title="All 2 branches missed.">										if (isActivityInList(shiftEvent.getActivityID(), activities)) {</span>
<span class="nc" id="L1244">											nTotalShiftEvents++;</span>
										}
<span class="nc" id="L1246">									}</span>
								}
							}
<span class="nc" id="L1249">						}</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">						if (nTotalShiftEvents &lt; nMin) {</span>
<span class="nc" id="L1251">							aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalShiftEvents - nMin, CommonConflict.SHIFTEVENTS));</span>
<span class="nc bnc" id="L1252" title="All 4 branches missed.">						} else if (nMax &gt; 0 &amp;&amp; nTotalShiftEvents &gt; nMax) {</span>
							//if no max limit, nMax = -1
<span class="nc" id="L1254">							aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nTotalShiftEvents - nMax, CommonConflict.SHIFTEVENTS));</span>
						}
					}
				}
			}
		}
<span class="nc" id="L1260">		return aNewConflicts;</span>
	}

	static boolean isActivityInList(ID activityID, List&lt;Activity&gt; activities) {
<span class="nc bnc" id="L1264" title="All 6 branches missed.">		if (activityID != null &amp;&amp; activities != null &amp;&amp; !activities.isEmpty()) {</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">			for (Activity act : activities) {</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">				if (act.getID().equals(activityID)) {</span>
<span class="nc" id="L1267">					return true;</span>
				}
<span class="nc" id="L1269">			}</span>
		}
<span class="nc" id="L1271">		return false;</span>
	}

	static Collection getConsecutiveShiftConflicts(int nMin, int nMax, ID idShift,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L1277">		List aNewConflicts = new ArrayList();</span>

<span class="nc" id="L1279">		int nConsecutiveDays = 0;</span>
		//this is quite inefficient, I only need to iterate from the first day with an event to the last
<span class="nc" id="L1281">		for (Date dtCurrentDay = new Date(dtStart.getTime());</span>
<span class="nc bnc" id="L1282" title="All 2 branches missed.">			 dtCurrentDay.before(dtEnd);</span>
<span class="nc" id="L1283">			 dtCurrentDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND)) {</span>

			//find an event on the current day
			//this is quite inefficient, I don't need to look through events which have already been &quot;found&quot;
<span class="nc" id="L1287">			Date dtEndDay = new Date();</span>
<span class="nc" id="L1288">			dtEndDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND);</span>
<span class="nc" id="L1289">			Event pEvent = null;</span>
<span class="nc bnc" id="L1290" title="All 2 branches missed.">			for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1291">				Event pEvent1 = (Event) i.next();</span>
<span class="nc bnc" id="L1292" title="All 2 branches missed.">				if (WorkRuleUtil.isShiftInPeriod(pEvent1, pOrganization, dtCurrentDay, dtEndDay, null)) {</span>
<span class="nc bnc" id="L1293" title="All 2 branches missed.">					if (((ShiftAssignment) pEvent1).getShiftID().equals(idShift)) {</span>
<span class="nc" id="L1294">						pEvent = pEvent1;</span>
<span class="nc" id="L1295">						break;</span>
					}
				}
<span class="nc" id="L1298">			}</span>

			//found an event
<span class="nc bnc" id="L1301" title="All 2 branches missed.">			if (pEvent != null) {</span>
<span class="nc" id="L1302">				nConsecutiveDays++;</span>
<span class="nc bnc" id="L1303" title="All 2 branches missed.">				if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1304">					aNewConflicts.add(new CommonConflict(pEvent.getStartTime(), pEvent.getEndTime()));</span>
				}
			} else {
<span class="nc bnc" id="L1307" title="All 4 branches missed.">				if (nConsecutiveDays &gt; 0 &amp;&amp; nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1308">					aNewConflicts.add(new CommonConflict(dtCurrentDay, null));</span>
				}
<span class="nc" id="L1310">				nConsecutiveDays = 0;</span>
			}
		}

<span class="nc bnc" id="L1314" title="All 2 branches missed.">		if (nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1315">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nConsecutiveDays - nMin), CommonConflict.SHIFTS));</span>
<span class="nc bnc" id="L1316" title="All 2 branches missed.">		} else if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1317">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nConsecutiveDays - nMax), CommonConflict.SHIFTS));</span>
		}

<span class="nc" id="L1320">		return aNewConflicts;</span>
	}

	static Collection getConsecutiveDaysConflicts(int nMin, int nMax,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L1326">		List aNewConflicts = new ArrayList();</span>

<span class="nc" id="L1328">		int nConsecutiveDays = 0;</span>
		//this is quite inefficient, I only need to iterate from the first day with an event to the last
<span class="nc" id="L1330">		for (Date dtCurrentDay = new Date(dtStart.getTime());</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">			 dtCurrentDay.before(dtEnd);</span>
<span class="nc" id="L1332">			 dtCurrentDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND)) {</span>

			//find an event on the current day
			//this is quite inefficient, I don't need to look through events which have already been &quot;found&quot;
<span class="nc" id="L1336">			Date dtEndDay = new Date();</span>
<span class="nc" id="L1337">			dtEndDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND);</span>
<span class="nc" id="L1338">			Event pEvent = null;</span>
<span class="nc bnc" id="L1339" title="All 2 branches missed.">			for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1340">				Event pEvent1 = (Event) i.next();</span>
<span class="nc bnc" id="L1341" title="All 2 branches missed.">				if (WorkRuleUtil.isShiftInPeriod(pEvent1, pOrganization, dtCurrentDay, dtEndDay, null)) {</span>

<span class="nc" id="L1343">					pEvent = pEvent1;</span>
<span class="nc" id="L1344">					break;</span>
				}
<span class="nc" id="L1346">			}</span>

			//found an event
<span class="nc bnc" id="L1349" title="All 2 branches missed.">			if (pEvent != null) {</span>
<span class="nc" id="L1350">				nConsecutiveDays++;</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">				if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1352">					aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nMax - nConsecutiveDays), CommonConflict.DAYS));</span>
				}
			} else {
<span class="nc bnc" id="L1355" title="All 4 branches missed.">				if (nConsecutiveDays &gt; 0 &amp;&amp; nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1356">					aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nConsecutiveDays - nMax), CommonConflict.DAYS));</span>
				}
<span class="nc" id="L1358">				nConsecutiveDays = 0;</span>
			}
		}

<span class="nc bnc" id="L1362" title="All 2 branches missed.">		if (nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1363">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nConsecutiveDays - nMin), CommonConflict.DAYS));</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">		} else if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1365">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, (nConsecutiveDays - nMax), CommonConflict.DAYS));</span>
		}

<span class="nc" id="L1368">		return aNewConflicts;</span>
	}

	static Collection getConsecutiveDaysOffConflicts(int nMin, int nMax,
			Organization pOrganization, Date dtStart, Date dtEnd, Collection pEvents) {

<span class="nc" id="L1374">		List aNewConflicts = new ArrayList();</span>

<span class="nc" id="L1376">		int nConsecutiveDays = 0;</span>
		//this is quite inefficient, I only need to iterate from the first day with an event to the last
<span class="nc" id="L1378">		for (Date dtCurrentDay = new Date(dtStart.getTime());</span>
<span class="nc bnc" id="L1379" title="All 2 branches missed.">			 dtCurrentDay.before(dtEnd);</span>
<span class="nc" id="L1380">			 dtCurrentDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND)) {</span>

			//find an event on the current day
			//this is quite inefficient, I don't need to look through events which have already been &quot;found&quot;
<span class="nc" id="L1384">			Date dtEndDay = new Date();</span>
<span class="nc" id="L1385">			dtEndDay.setTime(dtCurrentDay.getTime() + HOURS_IN_DAY * MINUTES_IN_HOUR * SECONDS_IN_MINUTE * MILLISECONDS_IN_SECOND);</span>
<span class="nc" id="L1386">			Event pEvent = null;</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">			for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1388">				Event pEvent1 = (Event) i.next();</span>
<span class="nc bnc" id="L1389" title="All 2 branches missed.">				if (WorkRuleUtil.isShiftInPeriod(pEvent1, pOrganization, dtCurrentDay, dtEndDay, null)) {</span>
<span class="nc" id="L1390">					pEvent = pEvent1;</span>
<span class="nc" id="L1391">					break;</span>
				}
<span class="nc" id="L1393">			}</span>

			//found no event
<span class="nc bnc" id="L1396" title="All 2 branches missed.">			if (pEvent == null) {</span>
<span class="nc" id="L1397">				nConsecutiveDays++;</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">				if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1399">					aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nConsecutiveDays - nMax, CommonConflict.DAYS));</span>
				}
			} else {
<span class="nc bnc" id="L1402" title="All 4 branches missed.">				if (nConsecutiveDays &gt; 0 &amp;&amp; nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1403">					aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nConsecutiveDays - nMin, CommonConflict.DAYS));</span>
				}
<span class="nc" id="L1405">				nConsecutiveDays = 0;</span>
			}
		}

<span class="nc bnc" id="L1409" title="All 2 branches missed.">		if (nConsecutiveDays &lt; nMin) {</span>
<span class="nc" id="L1410">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nConsecutiveDays - nMin, CommonConflict.DAYS));</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">		} else if (nConsecutiveDays &gt; nMax) {</span>
<span class="nc" id="L1412">			aNewConflicts.add(new CommonConflict(dtStart, dtEnd, nConsecutiveDays - nMax, CommonConflict.DAYS));</span>
		}
<span class="nc" id="L1414">		return aNewConflicts;</span>
	}

	static Collection getSpacingConflicts(Collection pWorkRuleParameters, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents)
			throws WorkRuleException {
		//Employees must have at least X hours between shifts...

<span class="nc" id="L1422">		Iterator w = pWorkRuleParameters.iterator();</span>
<span class="nc" id="L1423">		int nMinSpacing = (int) (((WorkRuleParameter) w.next()).getDoubleValue() * 60);</span>

<span class="nc" id="L1425">		ArrayList aConflicts = new ArrayList();</span>

<span class="nc" id="L1427">		Date dtPreviousEnd = null;</span>
<span class="nc bnc" id="L1428" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1429">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L1430" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>
				//check for timespans where a parent event violates the rule
<span class="nc" id="L1432">				Date dtStart = pEvent.getStartTime();</span>
<span class="nc bnc" id="L1433" title="All 2 branches missed.">				if (dtPreviousEnd != null) {</span>
<span class="nc" id="L1434">					int nSpacing = (int) ((dtStart.getTime() - dtPreviousEnd.getTime()) / (1000 * 60));</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">					if (nSpacing &lt; nMinSpacing) {</span>
<span class="nc" id="L1436">						aConflicts.add(new CommonConflict(dtPreviousEnd, dtStart, (nMinSpacing - nSpacing) / 60.0, CommonConflict.HOURS));</span>
					}
				}
<span class="nc" id="L1439">				dtPreviousEnd = pEvent.getEndTime();</span>
			}
<span class="nc" id="L1441">		}</span>
<span class="nc" id="L1442">		return aConflicts;</span>
	}

	static Collection getCrossDayConflicts(Organization pOrganization, int eOverlap,
			Date dtStartDate, Date dtEndDate, Collection pEvents)
			throws WorkRuleException {
		//Employees can not work shifts which cross the day boundary...
<span class="nc" id="L1449">		List&lt;CommonConflict&gt; aConflicts = new ArrayList&lt;&gt;();</span>

<span class="nc bnc" id="L1451" title="All 2 branches missed.">		for (Iterator i = pEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1452">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L1453" title="All 2 branches missed.">			if (WorkRuleUtil.isInPeriodAndApproved(pEvent, dtStartDate, dtEndDate, eOverlap)) {</span>
				//check to make sure it doesn't cross the boundary on the day or day after it starts

<span class="nc" id="L1456">				Calendar cBoundaryTime = Calendar.getInstance(pOrganization.getTimeZone());</span>
<span class="nc" id="L1457">				cBoundaryTime.setTime(pEvent.getStartTime());</span>
<span class="nc" id="L1458">				cBoundaryTime.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L1459">				cBoundaryTime.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L1460">				cBoundaryTime.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1461">				cBoundaryTime.add(Calendar.MINUTE, pOrganization.getDayBoundaryOffset());</span>

<span class="nc bnc" id="L1463" title="All 2 branches missed.">				if (pEvent.getStartTime().before(cBoundaryTime.getTime()) &amp;&amp;</span>
<span class="nc bnc" id="L1464" title="All 2 branches missed.">						pEvent.getEndTime().after(cBoundaryTime.getTime())) {</span>
<span class="nc" id="L1465">					aConflicts.add(new CommonConflict(pEvent.getStartTime(), pEvent.getEndTime(), 1, CommonConflict.DAYS));</span>
				} else {
<span class="nc" id="L1467">					cBoundaryTime.add(Calendar.DATE, 1);</span>
<span class="nc bnc" id="L1468" title="All 2 branches missed.">					if (pEvent.getStartTime().before(cBoundaryTime.getTime()) &amp;&amp;</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">							pEvent.getEndTime().after(cBoundaryTime.getTime())) {</span>
<span class="nc" id="L1470">						aConflicts.add(new CommonConflict(pEvent.getStartTime(), pEvent.getEndTime(), 1, CommonConflict.DAYS));</span>
					}
				}
			}
<span class="nc" id="L1474">		}</span>
<span class="nc" id="L1475">		return aConflicts;</span>
	}
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>