<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RTAAManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.rtaamanager.ejb</a> &gt; <span class="el_source">RTAAManagerEJB.java</span></div><h1>RTAAManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.rtaamanager.ejb;

import java.rmi.RemoteException;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.DecimalFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.Map;
import java.util.TimeZone;
import java.util.TreeSet;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.transaction.UserTransaction;

import org.apache.commons.io.IOUtils;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoFinal;
import com.bluepumpkin.common.jdmo.JdmoPCommand;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.localization.LocaleContext;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.PersonNameUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.config.model.BPConfigData;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.holiday.ejb.HolidayManager;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.ActivityAdheranceStatusSummary;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.AdheranceStatusData;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.EmployeeAdheranceStatus;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.EmployeeData;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.RTAAData;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.ReportDumpStatistic;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.UniqueEventID;
import com.bluepumpkin.ejb.bbm.rtaaservice.ejb.RTAAService;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.AdheranceOverride;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.EmployeeDataIn;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.RTAADataIn;
import com.bluepumpkin.ejb.bbm.rtaaservice.model.RTAAException;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffCalculatorException;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffHoursManagerBridge;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeRecordManager;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.util.AdherenceSummaryUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.cdf.ChangeNotifier;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.base.CoreFinderException;
import com.witness.ejb.core.gcr.ejb.GCRManager;
import com.witness.ejb.core.gcr.model.GCREntry;
import com.witness.ejb.core.licensing.LicenseKeys;
import com.witness.ejb.core.licensing.ejb.LicenseManager;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.User;

@SuppressWarnings(&quot;serial&quot;)
<span class="nc" id="L106">public class RTAAManagerEJB extends SessionEJBBase {</span>
	public static final int INC_EMPLOYEE_NAME = 0x0001;
	public static final int INC_PLANNED_EVENTS = 0x0002;
	public static final int INC_ACTUAL_EVENTS = 0x0004;
	public static final int INC_ADHERANCE_VIOLATIONS = 0x0008;
	public static final int INC_NONADHERANCE_DURATION = 0x0010;
	public static final int INC_ACTIVITIES = 0x0020;
	public static final int INC_APPROVAL_STATUS = 0x0040;
	public static final int INC_ALL = 0x004f;
	public static final int INC_UNPUBLISHED_PLANNED_EVENTS = 0x0080;
	public static final int SORT_WORKING_STARTTIME = 100;
	public static final int SORT_WORKING_ENDTIME = 101;
	public static final int SORT_PLANNED_STARTTIME = 102;
	public static final int SORT_PLANNED_ENDTIME = 103;
	public static final int SORT_ADHERANCE_STATUS = 104;
	public static final int SORT_APPROVAL_STATUS = 105;
	public static final int SORT_EMPLOYEE_NAME = 106;
	public static final int SORT_NONE = -1;
	public static final int QUICK_VIEW_LOOKBACK_LIMIT = 1000 * 60 * 60 * 16;
	public static final int DEBUG_LEVEL = 5;
	public static final int TIMEZONEAM_YEARS_DUMPRANGE = 40;
	private static final String STATUS_FIELD = &quot;STATUS&quot;;
	private static final int STATUS_COMPLETE= 2;
	private static final int PCT_DONE = 100;
	private static final int OVERLAY_PRECEDENCE_10 = 10;
	private static final int MILISECONDS_PER_MINUTE = 60000;
	private static final long MILISECONDS_PER_DAY = 1000L * 60L * 60L * 24L;
	public static final String DST_KEY = &quot;reportdump/dstchanged&quot;;
	protected Localizer m_localizer;
	private EmployeeFilter m_employeeFilter;
	private RTAAService m_rtaaService;
	private ScheduleAccessManager m_scheduleAccessManager;
	private TimeRecordManager m_timeRecordManager;
	private WorkResourceManager m_workResourceManager;
	private ActivityManager m_activityManager;
	private HolidayManager m_holidayManager;
	private DBConfigManager m_dbConfigManager;
	private GCRManager m_gcrManager;
	private LicenseManager m_licenseManager;
	private UserManager m_userManager;
<span class="nc" id="L146">	private Collection m_colFailedEmployeeIDs = null;</span>
<span class="nc" id="L147">	private Collection m_colFailedEmployeeFilterIDs = null;</span>
<span class="nc" id="L148">	HashMap m_hmLastShiftAssignments = null;</span>
<span class="nc" id="L149">	private static Category m_cat = Log.initCategory(RTAAManagerEJB.class.getName());</span>
<span class="nc" id="L150">	private static int REPORTDUMP_MAX_RETRY = 10;</span>
<span class="nc" id="L151">	private static int USERTRANSACTION_TIMEOUT = 600;</span>
<span class="nc" id="L152">	private Collection dumpedEmpFilterIDs = null;</span>
<span class="nc" id="L153">	private static Map&lt;Integer,ID&gt; lockMap = new HashMap&lt;Integer,ID&gt;();</span>
<span class="nc" id="L154">	private final HashMap m_threadIDsFromThreadNames = new HashMap();</span>

<span class="nc" id="L156">	private boolean whatIfMode = false;</span>

<span class="nc" id="L158">	private final ReportDumpStatistic statistic = new ReportDumpStatistic();</span>
<span class="nc" id="L159">	private static DecimalFormat decFormat = new DecimalFormat(&quot;#.#&quot;);</span>

<span class="nc" id="L161">	public static HashSet failed = null;</span>
	
	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="nc" id="L166">		return m_cat;</span>
	}

	{
<span class="nc" id="L170">		super.init(RTAAManagerEJB.class.getName());</span>
	}

	@Override
	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="nc" id="L177">			Context initialContext = new InitialContext();</span>
<span class="nc" id="L178">			Boolean wif = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="nc bnc" id="L179" title="All 2 branches missed.">			if (wif != null)</span>
<span class="nc" id="L180">				whatIfMode = wif.booleanValue();</span>
<span class="nc" id="L181">			m_employeeFilter = BbmManagerFactory.getEmployeeFilter(whatIfMode);</span>
<span class="nc" id="L182">			m_rtaaService = BbmManagerFactory.getRTAAService();</span>
<span class="nc" id="L183">			m_timeRecordManager = WfmManagerFactory.getTimeRecordManager();</span>
<span class="nc" id="L184">			m_scheduleAccessManager = WfmManagerFactory</span>
<span class="nc" id="L185">					.getScheduleAccessManager(whatIfMode);</span>
<span class="nc" id="L186">			m_workResourceManager = BbmManagerFactory</span>
<span class="nc" id="L187">					.getWorkResourceManager(whatIfMode);</span>
<span class="nc" id="L188">			m_activityManager = WfmManagerFactory</span>
<span class="nc" id="L189">					.getActivityManager(whatIfMode);</span>
<span class="nc" id="L190">			m_holidayManager = BbmManagerFactory.getHolidayManager(whatIfMode);</span>
<span class="nc" id="L191">			m_dbConfigManager = BbmManagerFactory</span>
<span class="nc" id="L192">					.getDBConfigManager(whatIfMode);</span>
<span class="nc" id="L193">			m_gcrManager = CoreManagerFactory.getGCRManagerRemote(whatIfMode);</span>
<span class="nc" id="L194">			m_licenseManager = CoreManagerFactory.getLicenseManager();</span>
<span class="nc" id="L195">			m_userManager = CoreManagerFactory.getUserManager(whatIfMode);</span>
<span class="nc" id="L196">		} catch (Exception e) {</span>
<span class="nc" id="L197">			handleException(e, false);</span>
<span class="nc" id="L198">		}</span>
<span class="nc" id="L199">	}</span>

	private class CompareEmployeeData implements Comparator {
		private final int m_nSortField;
		private final boolean m_bIsAscending;
		private final LocaleContext m_localeContext;

		public CompareEmployeeData(int nSortField, boolean bIsAscending,
<span class="nc" id="L207">				LocaleContext localeContext) {</span>
<span class="nc" id="L208">			m_nSortField = nSortField;</span>
<span class="nc" id="L209">			m_bIsAscending = bIsAscending;</span>
<span class="nc" id="L210">			m_localeContext = localeContext;</span>
<span class="nc" id="L211">		}</span>

		@Override
		public int compare(Object o1, Object o2) {
<span class="nc" id="L215">			EmployeeData employeeData1 = (EmployeeData) o1;</span>
<span class="nc" id="L216">			EmployeeData employeeData2 = (EmployeeData) o2;</span>
<span class="nc" id="L217">			int nResult = 0;</span>
<span class="nc bnc" id="L218" title="All 8 branches missed.">			switch (m_nSortField) {</span>
				case SORT_WORKING_STARTTIME:
<span class="nc" id="L220">					nResult = employeeData1.getActualMinTime().compareTo(employeeData2.getActualMinTime());</span>
<span class="nc" id="L221">					break;</span>
				case SORT_WORKING_ENDTIME:
<span class="nc" id="L223">					nResult = employeeData1.getActualMaxTime().compareTo(employeeData2.getActualMaxTime());</span>
<span class="nc" id="L224">					break;</span>
				case SORT_PLANNED_STARTTIME:
<span class="nc" id="L226">					nResult = employeeData1.getPlannedMinTime().compareTo(employeeData2.getPlannedMinTime());</span>
<span class="nc" id="L227">					break;</span>
				case SORT_PLANNED_ENDTIME:
<span class="nc" id="L229">					nResult = employeeData1.getPlannedMaxTime().compareTo(employeeData2.getPlannedMaxTime());</span>
<span class="nc" id="L230">					break;</span>
				case SORT_EMPLOYEE_NAME:
<span class="nc" id="L232">					break;</span>
				case SORT_ADHERANCE_STATUS:
<span class="nc bnc" id="L234" title="All 2 branches missed.">					if (employeeData1.getNonAdheranceDuration() &lt; employeeData2.getNonAdheranceDuration()) {</span>
<span class="nc" id="L235">						nResult = 1;</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">					} else if (employeeData1.getNonAdheranceDuration() &gt; employeeData2.getNonAdheranceDuration()) {</span>
<span class="nc" id="L237">						nResult = -1;</span>
					} else {
<span class="nc" id="L239">						nResult = 0;</span>
					}
<span class="nc" id="L241">					break;</span>
				case SORT_APPROVAL_STATUS:
<span class="nc bnc" id="L243" title="All 2 branches missed.">					if (employeeData1.isApproved()) {</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">						if (employeeData2.isApproved()) {</span>
<span class="nc" id="L245">							nResult = 0;</span>
						} else {
<span class="nc" id="L247">							nResult = 1;</span>
						}
					} else {
<span class="nc bnc" id="L250" title="All 2 branches missed.">						if (!employeeData2.isApproved()) {</span>
<span class="nc" id="L251">							nResult = 0;</span>
						} else {
<span class="nc" id="L253">							nResult = -1;</span>
						}
					}
					break;
			}
<span class="nc bnc" id="L258" title="All 2 branches missed.">			if (nResult == 0) {</span>
<span class="nc" id="L259">				nResult = PersonNameUtil.compare(employeeData1.getEmployeeName(), employeeData2.getEmployeeName(), m_localeContext);</span>
			}
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if (!m_bIsAscending) {</span>
<span class="nc" id="L262">				nResult *= -1;</span>
			}
<span class="nc" id="L264">			return nResult;</span>
		}
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, int nDetailLevel) throws BbmFinderException {
<span class="nc" id="L270">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd, nDetailLevel,</span>
				SORT_NONE, false, 0, Integer.MAX_VALUE);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nDetailLevel) throws BbmFinderException {
<span class="nc" id="L277">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStartPlanned, dateEndPlanned, SORT_NONE, false, 0,
				Integer.MAX_VALUE, null, false);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated, boolean showUnavailable)
			throws BbmFinderException {
<span class="nc" id="L286">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd, dateStart,</span>
				dateEnd, nSortField, bIsAscending, nOffset, nMaxEmployees,
				dateLastUpdated, false, showUnavailable);
	}

	// this API is used by report dump only
	private RTAAData getRTAADataLocal(Date dateCurrent,
			Collection colEmployeeIDs, Date dateStart, Date dateEnd,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeTimeRecordMap) throws BbmFinderException {
<span class="nc" id="L297">		return getRTAAData(dateCurrent, colEmployeeIDs, dateStart, dateEnd,</span>
				dateStart, dateEnd, nSortField, bIsAscending, nOffset,
				nMaxEmployees, dateLastUpdated, bIncludeTimeRecordMap, true, // showUnavailable
				false, // excludeAdherenceExceptionsCalculation
				false); // isLoadScheduleFromCache
	}

	// this API is used by Scorecards!
	public RTAAData getRTAADataLocal(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeTimeRecordMap,
			boolean excludeAdherenceExceptionsCalculation)
			throws BbmFinderException {
<span class="nc" id="L311">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStart, // dateStartPlanned
				dateEnd, // dateEndPlanned
				nSortField, bIsAscending, nOffset, nMaxEmployees,
				dateLastUpdated, true, // bIncludeExtraDumpData
				bIncludeTimeRecordMap, // showUnavailable
				excludeAdherenceExceptionsCalculation); // excludeAdherenceExceptionsCalculation
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, int nDetailLevel, int nSortField,
			boolean bIsAscending, int nOffset, int nMaxEmployees)
			throws BbmFinderException {
<span class="nc" id="L324">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd, dateStart,</span>
				dateEnd, nSortField, bIsAscending, nOffset, nMaxEmployees,
				null, false);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nDetailLevel, int nSortField, boolean bIsAscending,
			int nOffset, int nMaxEmployees) throws BbmFinderException {
<span class="nc" id="L333">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStartPlanned, dateEndPlanned, nSortField, bIsAscending,
				nOffset, nMaxEmployees, null, false);
	}

	private Collection computeAdheranceOverridesChangedIntervals(
			Collection colAdheranceOverrides, Date dateLastUpdated) {
<span class="nc" id="L340">		Collection colAdheranceOverridesChangedIntervals = new LinkedList();</span>
<span class="nc" id="L341">		for (Iterator itAdheranceOverride = colAdheranceOverrides.iterator(); itAdheranceOverride</span>
<span class="nc bnc" id="L342" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L343">			AdheranceOverride adheranceOverride = (AdheranceOverride) itAdheranceOverride</span>
<span class="nc" id="L344">					.next();</span>
<span class="nc" id="L345">			Date dateLastModified = adheranceOverride.getLastModifiedTime();</span>
<span class="nc bnc" id="L346" title="All 6 branches missed.">			if (dateLastModified != null &amp;&amp; dateLastUpdated != null &amp;&amp; adheranceOverride.getLastModifiedTime().after(</span>
					dateLastUpdated)) {
<span class="nc" id="L348">				colAdheranceOverridesChangedIntervals.add(new TimeRange(adheranceOverride.getStartTime(), adheranceOverride.getEndTime()));</span>
			}
<span class="nc" id="L350">		}</span>
<span class="nc" id="L351">		return colAdheranceOverridesChangedIntervals;</span>
	}

	boolean doActivitiesRequireRefresh(Collection colActivityIDs,
			HashMap hmActivities, Date dateLastUpdated, Date dateCurrent) {
<span class="nc bnc" id="L356" title="All 2 branches missed.">		if (colActivityIDs == null)</span>
<span class="nc" id="L357">			return false;</span>
<span class="nc" id="L358">		for (Iterator itActivityID = colActivityIDs.iterator(); itActivityID</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L360">			ID idActivity = (ID) itActivityID.next();</span>
<span class="nc" id="L361">			Activity activity = (Activity) hmActivities.get(idActivity);</span>
<span class="nc" id="L362">			Date dateLastModified = activity.getLastModifiedDate();</span>
<span class="nc bnc" id="L363" title="All 4 branches missed.">			if (dateLastModified != null &amp;&amp; dateLastUpdated != null) {</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">				if (dateLastModified.after(dateLastUpdated)</span>
<span class="nc bnc" id="L365" title="All 2 branches missed.">						&amp;&amp; dateLastModified.before(dateCurrent)) {</span>
<span class="nc" id="L366">					m_cat.info(&quot;ACTIVITY&quot; + activity.getName()</span>
							+ &quot;, dateLastModified = &quot; + dateLastModified
							+ &quot;, dateLastUpdated = &quot; + dateLastUpdated);
<span class="nc" id="L369">					return true;</span>
				}
			}
<span class="nc" id="L372">		}</span>
		/*
		 * don't need to special handle no_activity, it is in the pass-in list.
		 * Activity activity = (Activity)
		 * hmActivities.get(Activity.ACTIVITY_NONE); Date dateLastModified =
		 * activity.getLastModifiedDate();
		 *
		 * if (dateLastModified != null &amp;&amp; dateLastUpdated != null) { if
		 * (dateLastModified.after(dateLastUpdated) &amp;&amp;
		 * dateLastModified.before(getCurrentTime())) {
		 * m_cat.info(&quot;ACTIVITY_NONE, dateLastModified = &quot; + dateLastModified +
		 * &quot;, dateLastUpdated = &quot; + dateLastUpdated); return true; } }
		 */
<span class="nc" id="L385">		return false;</span>
	}

	/**
	 * Return the current system time. Only call this at the beginning of your
	 * dump/adherence code to make sure everthing in in-sync.
	 */
	Date getCurrentTime() {
<span class="nc" id="L393">		return Calendar.getInstance().getTime();</span>
	}

	Collection computeAdheranceChangedIntervals(Date dateStart, Date dateEnd,
			Collection colPlannedEvents, Collection colPlannedChangedIntervals,
			Collection colActualChangedIntervals,
			Collection colAdheranceOverrides, Collection colPlannedActivityIDs,
			HashMap hmActivities, Date dateLastUpdated, Date dateCurrent) {
<span class="nc bnc" id="L401" title="All 2 branches missed.">		if (colPlannedActivityIDs == null)</span>
<span class="nc" id="L402">			colPlannedActivityIDs = new LinkedList();</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">		if (colAdheranceOverrides == null)</span>
<span class="nc" id="L404">			colAdheranceOverrides = new LinkedList();</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (colActualChangedIntervals == null)</span>
<span class="nc" id="L406">			colActualChangedIntervals = new LinkedList();</span>
<span class="nc bnc" id="L407" title="All 2 branches missed.">		if (colPlannedChangedIntervals == null)</span>
<span class="nc" id="L408">			colPlannedChangedIntervals = new LinkedList();</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">		if (colPlannedEvents == null)</span>
<span class="nc" id="L410">			colPlannedEvents = new LinkedList();</span>

<span class="nc" id="L412">		Collection colChangedIntervals = new LinkedList();</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">		if (dateLastUpdated == null</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">				|| doActivitiesRequireRefresh(colPlannedActivityIDs,</span>
						hmActivities, dateLastUpdated, dateCurrent)) {
<span class="nc bnc" id="L417" title="All 2 branches missed.">			if (dateCurrent.after(dateStart))</span>
<span class="nc" id="L418">				colChangedIntervals.add(new TimeRange(dateStart, dateCurrent));</span>
<span class="nc" id="L419">			return colChangedIntervals;</span>
		}

<span class="nc" id="L422">		Activity activityNone = (Activity) hmActivities</span>
<span class="nc" id="L423">				.get(Activity.ACTIVITY_NONE);</span>
<span class="nc" id="L424">		int nMaxActivityTolerance = activityNone.getAdherenceTolerance();</span>

<span class="nc" id="L426">		Collection colAdheranceOverridesChangedIntervals = null;</span>
<span class="nc" id="L427">		colAdheranceOverridesChangedIntervals = computeAdheranceOverridesChangedIntervals(</span>
				colAdheranceOverrides, dateLastUpdated);
<span class="nc bnc" id="L429" title="All 2 branches missed.">		if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L430">			m_cat.debug(&quot;Adherance Overrides Changed Intervals = &quot;</span>
					+ colAdheranceOverridesChangedIntervals);

<span class="nc" id="L433">		for (Iterator itActivityID = colPlannedActivityIDs.iterator(); itActivityID</span>
<span class="nc bnc" id="L434" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L435">			ID idActivity = (ID) itActivityID.next();</span>
<span class="nc" id="L436">			Activity activity = (Activity) hmActivities.get(idActivity);</span>
<span class="nc bnc" id="L437" title="All 2 branches missed.">			if (activity.getAdherenceTolerance() &gt; nMaxActivityTolerance)</span>
<span class="nc" id="L438">				nMaxActivityTolerance = activity.getAdherenceTolerance();</span>
<span class="nc" id="L439">		}</span>

<span class="nc" id="L441">		colChangedIntervals.add(new TimeRange(dateLastUpdated, dateCurrent));</span>

<span class="nc" id="L443">		colChangedIntervals.addAll(colPlannedChangedIntervals);</span>
<span class="nc" id="L444">		colChangedIntervals.addAll(colActualChangedIntervals);</span>
<span class="nc" id="L445">		colChangedIntervals.addAll(colAdheranceOverridesChangedIntervals);</span>
<span class="nc" id="L446">		colChangedIntervals = EventUtils.getUnionOfChangedIntervals(</span>
				colChangedIntervals, nMaxActivityTolerance + 1, dateStart,
				dateEnd);
<span class="nc bnc" id="L449" title="All 2 branches missed.">		if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L450">			m_cat.debug(&quot;Union Changed Intervals = &quot; + colChangedIntervals);</span>
<span class="nc" id="L451">		return colChangedIntervals;</span>

	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeExtraDumpData) throws BbmFinderException {
<span class="nc" id="L460">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStartPlanned, dateEndPlanned, nSortField, bIsAscending,
				nOffset, nMaxEmployees, dateLastUpdated, bIncludeExtraDumpData,
				true);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeExtraDumpData, boolean showUnavailable)
			throws BbmFinderException {
<span class="nc" id="L472">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStartPlanned, dateEndPlanned, nSortField, bIsAscending,
				nOffset, nMaxEmployees, dateLastUpdated, bIncludeExtraDumpData,
				showUnavailable, false, true);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeExtraDumpData, boolean showUnavailable,
			boolean excludeAdherenceExceptionsCalculation)
			throws BbmFinderException {

<span class="nc" id="L486">		return getRTAAData(colEmployeeIDs, dateStart, dateEnd,</span>
				dateStartPlanned, dateEndPlanned, nSortField, bIsAscending,
				nOffset, nMaxEmployees, dateLastUpdated, bIncludeExtraDumpData,
				showUnavailable, excludeAdherenceExceptionsCalculation, true);
	}

	public RTAAData getRTAAData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateStartPlanned, Date dateEndPlanned,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, Date dateLastUpdated,
			boolean bIncludeExtraDumpData, boolean showUnavailable,
			boolean excludeAdherenceExceptionsCalculation,
			boolean isLoadScheduleFromCache) throws BbmFinderException {
<span class="nc" id="L499">		return getRTAAData(getCurrentTime(), colEmployeeIDs, dateStart,</span>
				dateEnd, dateStartPlanned, dateEndPlanned, nSortField,
				bIsAscending, nOffset, nMaxEmployees, dateLastUpdated,
				bIncludeExtraDumpData, showUnavailable,
				excludeAdherenceExceptionsCalculation, isLoadScheduleFromCache);
	}

	public RTAAData getRTAAData(Date dateCurrent,
			Collection&lt;ID&gt; colEmployeeIDs, Date dateStart, Date dateEnd,
			Date dateStartPlanned, Date dateEndPlanned, int nSortField,
			boolean bIsAscending, int nOffset, int nMaxEmployees,
			Date dateLastUpdated, boolean bIncludeExtraDumpData,
			boolean showUnavailable,
			boolean excludeAdherenceExceptionsCalculation,
			boolean isLoadScheduleFromCache) throws BbmFinderException {
<span class="nc" id="L514">		methodStart(&quot;getRTAAData&quot;, colEmployeeIDs, dateStart, dateEnd, dateLastUpdated);</span>
<span class="nc" id="L515">		HashMap hmAllActualEvents = null;</span>
<span class="nc" id="L516">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L518">			Date dateMin = dateEnd;</span>
<span class="nc" id="L519">			Date dateMax = dateStart;</span>
<span class="nc" id="L520">			HashMap hmParentEvents = null;</span>
<span class="nc bnc" id="L521" title="All 2 branches missed.">			if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L522">				hmParentEvents = new HashMap();</span>
			}
<span class="nc" id="L524">			HashSet&lt;ID&gt; tsActivitiesToLoad = new HashSet&lt;&gt;();</span>
<span class="nc" id="L525">			tsActivitiesToLoad.add(Activity.ACTIVITY_NONE);</span>
<span class="nc" id="L526">			Map&lt;ID, EmployeeDataIn&gt; hmEmployeeDataIn = initEmployeeDataInMap(colEmployeeIDs);</span>

<span class="nc" id="L528">			HashMap&lt;ID, EmployeeName&gt; hmEmployeeNames = null;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (dateLastUpdated == null) {</span>
<span class="nc" id="L530">				hmEmployeeNames = m_workResourceManager.getEmployeeNamesByIDs(colEmployeeIDs);</span>
			}

<span class="nc" id="L533">			Map&lt;ID, EmployeeData&gt; hmEmployeeData = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L534" title="All 2 branches missed.">			for (ID idEmployee : colEmployeeIDs) {</span>
<span class="nc" id="L535">				EmployeeData employeeData = new EmployeeData(idEmployee);</span>
<span class="nc" id="L536">				employeeData.setIsApproved(true);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">				if (hmEmployeeNames != null) {</span>
<span class="nc" id="L538">					employeeData.setEmployeeName(hmEmployeeNames</span>
<span class="nc" id="L539">							.get(idEmployee));</span>
				}
<span class="nc" id="L541">				hmEmployeeData.put(idEmployee, employeeData);</span>
<span class="nc" id="L542">			}</span>

<span class="nc" id="L544">			HashSet hsTerminatedEmployees = getTerminatedEmployees(colEmployeeIDs, new Timestamp(dateStartPlanned.getTime()), jdmo);</span>
			{
<span class="nc" id="L546">				Collection colPlannedEventsPerEmployee = null;</span>
				// Productivity Reports showing incorrect data. - ESR#3943648
				// Schedule is missing from cache sometime, but don't know how to reproduce. it is more safer and efficient for
				// report dump to read from db since cache only covers 48 hour data the most.
<span class="nc bnc" id="L550" title="All 2 branches missed.">				if (isLoadScheduleFromCache) {</span>
<span class="nc" id="L551">					colPlannedEventsPerEmployee = m_scheduleAccessManager</span>
<span class="nc" id="L552">							.getPublishedEventsForWorkResourcesFromCache(colEmployeeIDs, dateStartPlanned, dateEndPlanned);</span>
				} else {
<span class="nc" id="L554">					colPlannedEventsPerEmployee = m_scheduleAccessManager</span>
<span class="nc" id="L555">							.getPublishedEventsForWorkResources(colEmployeeIDs, dateStartPlanned, dateEndPlanned);</span>
				}
<span class="nc" id="L557">				Collection colUnpublishedPlannedEventsPerEmployee = null;</span>
<span class="nc bnc" id="L558" title="All 2 branches missed.">				if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L559">					colUnpublishedPlannedEventsPerEmployee = m_scheduleAccessManager</span>
<span class="nc" id="L560">							.getEventsForWorkResources(colEmployeeIDs, dateStartPlanned, dateEndPlanned);</span>
				}

<span class="nc" id="L563">				HashMap hmChangedIntervals = null;</span>
<span class="nc" id="L564">				HashMap hmUnpublishedChangedIntervals = null;</span>
<span class="nc bnc" id="L565" title="All 2 branches missed.">				if (dateLastUpdated != null) {</span>
<span class="nc" id="L566">					hmChangedIntervals = m_scheduleAccessManager</span>
<span class="nc" id="L567">							.getPublishedChangedIntervalsForWorkResources(colEmployeeIDs, dateStart, dateEnd, dateLastUpdated);</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">					if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L570">						hmUnpublishedChangedIntervals = m_scheduleAccessManager</span>
<span class="nc" id="L571">								.getChangedIntervalsForWorkResources(colEmployeeIDs, dateStart, dateEnd, dateLastUpdated);</span>
					}
				}
<span class="nc" id="L574">				Iterator itEmployee = colEmployeeIDs.iterator();</span>
<span class="nc" id="L575">				Iterator itUnpublishedEvents = null;</span>
<span class="nc bnc" id="L576" title="All 2 branches missed.">				if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L577">					itUnpublishedEvents = colUnpublishedPlannedEventsPerEmployee.iterator();</span>
				}
<span class="nc bnc" id="L579" title="All 2 branches missed.">				for (Iterator itEvents = colPlannedEventsPerEmployee.iterator(); itEvents.hasNext();) {</span>
<span class="nc" id="L580">					Collection colPlannedEvents = (Collection) itEvents.next();</span>
<span class="nc" id="L581">					ID idEmployee = (ID) itEmployee.next();</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">					if (hsTerminatedEmployees.contains(idEmployee)) {</span>
<span class="nc" id="L584">						colPlannedEvents = null;</span>
					}

<span class="nc bnc" id="L587" title="All 2 branches missed.">					if (!showUnavailable) {</span>
<span class="nc" id="L588">						colPlannedEvents = filterUnavailableEvents(colPlannedEvents);</span>
					}

<span class="nc" id="L591">					Collection colUnpublishedPlannedEvents = null;</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">					if (colPlannedEvents == null) {</span>
<span class="nc" id="L593">						colPlannedEvents = new LinkedList();</span>
					}
<span class="nc bnc" id="L595" title="All 2 branches missed.">					if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L596">						colUnpublishedPlannedEvents = (Collection) itUnpublishedEvents.next();</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">						if (hsTerminatedEmployees.contains(idEmployee)) {</span>
<span class="nc" id="L598">							colUnpublishedPlannedEvents = null;</span>
						}
<span class="nc bnc" id="L600" title="All 2 branches missed.">						if (colUnpublishedPlannedEvents == null) {</span>
<span class="nc" id="L601">							colUnpublishedPlannedEvents = new LinkedList();</span>
						}
<span class="nc" id="L603">						EmployeeData employeeData = (EmployeeData) hmEmployeeData.get(idEmployee);</span>
<span class="nc" id="L604">						employeeData.setOriginalUnpublishedPlannedEvents(colUnpublishedPlannedEvents);</span>
<span class="nc" id="L605">						employeeData.setOriginalPublishedPlannedEvents(colPlannedEvents);</span>
					}

<span class="nc" id="L608">					Collection colChangedIntervals = null;</span>
<span class="nc" id="L609">					Collection colUnpublishedChangedIntervals = null;</span>
<span class="nc bnc" id="L610" title="All 4 branches missed.">					if (dateLastUpdated == null || hsTerminatedEmployees.contains(idEmployee)) {</span>
<span class="nc" id="L611">						colChangedIntervals = new LinkedList();</span>
<span class="nc" id="L612">						colChangedIntervals.add(new TimeRange(dateStart, dateEnd));</span>
<span class="nc bnc" id="L613" title="All 2 branches missed.">						if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L614">							colUnpublishedChangedIntervals = new LinkedList();</span>
<span class="nc" id="L615">							colUnpublishedChangedIntervals.add(new TimeRange(dateStart, dateEnd));</span>
						}
					} else {
<span class="nc" id="L618">						colChangedIntervals = (Collection) hmChangedIntervals.get(idEmployee);</span>
<span class="nc bnc" id="L619" title="All 2 branches missed.">						if (colChangedIntervals == null)</span>
<span class="nc" id="L620">							colChangedIntervals = new LinkedList();</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">						if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L622">							colUnpublishedChangedIntervals = (Collection) hmUnpublishedChangedIntervals.get(idEmployee);</span>
<span class="nc bnc" id="L623" title="All 2 branches missed.">							if (colUnpublishedChangedIntervals == null)</span>
<span class="nc" id="L624">								colUnpublishedChangedIntervals = new LinkedList();</span>
						}
<span class="nc bnc" id="L626" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L627">							m_cat.debug(&quot;Planned Changed Intervals  for employee &quot; + idEmployee + &quot; = &quot; + colChangedIntervals);</span>
<span class="nc" id="L628">							m_cat.debug(&quot;Unpublished Planned Changed Intervals  for employee &quot; + idEmployee + &quot; = &quot; +</span>
									colUnpublishedChangedIntervals);
						}
					}

<span class="nc" id="L633">					Collection colActivityIDs = getActivityIDsToLoad(colPlannedEvents);</span>
<span class="nc" id="L634">					tsActivitiesToLoad.addAll(colActivityIDs);</span>
<span class="nc" id="L635">					EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn.get(idEmployee);</span>
<span class="nc" id="L636">					employeeDataIn.setPlannedActivityIDs(colActivityIDs);</span>
<span class="nc bnc" id="L637" title="All 2 branches missed.">					if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L638">						Collection colUnpublishedActivityIDs = getActivityIDsToLoad(colUnpublishedPlannedEvents);</span>
<span class="nc" id="L639">						tsActivitiesToLoad.addAll(colUnpublishedActivityIDs);</span>
<span class="nc" id="L640">						employeeDataIn.setUnpublishedPlannedActivityIDs(colUnpublishedActivityIDs);</span>
					}
					{
<span class="nc" id="L643">						EmployeeData employeeData = (EmployeeData) hmEmployeeData.get(idEmployee);</span>
<span class="nc" id="L644">						employeeData.setPlannedMinTime(dateEndPlanned);</span>
<span class="nc" id="L645">						employeeData.setPlannedMaxTime(dateStartPlanned);</span>
<span class="nc bnc" id="L646" title="All 2 branches missed.">						for (Iterator itEvent = colPlannedEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L647">							Event event = (Event) itEvent.next();</span>
							// Ignoring the unavailablity events while adding datemin and date max
							// For QA54797 - Adherence sorting on Scheduled times is sorting on unavailable
<span class="nc bnc" id="L650" title="All 2 branches missed.">							if (event.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc" id="L651">								continue;</span>
							}

<span class="nc bnc" id="L654" title="All 2 branches missed.">							if (event.getStartTime().before(dateMin)) {</span>
<span class="nc" id="L655">								dateMin = event.getStartTime();</span>
							}
<span class="nc bnc" id="L657" title="All 2 branches missed.">							if (event.getEndTime().after(dateMax)) {</span>
<span class="nc" id="L658">								dateMax = event.getEndTime();</span>
							}
							// QC 45506
<span class="nc" id="L661">							setPlannedMinAndMaxTimes(employeeData, event);</span>
<span class="nc bnc" id="L662" title="All 2 branches missed.">							if (hmParentEvents != null) {</span>
<span class="nc" id="L663">								hmParentEvents.put(new UniqueEventID(event, false), event);</span>
							}
<span class="nc" id="L665">						}</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">						if (bIncludeExtraDumpData) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">							if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L668">								m_cat.debug(&quot;Unpublished Planned Events (in) for employee: &quot; + idEmployee + &quot; = &quot;</span>
<span class="nc" id="L669">										+ EventUtils.flattenEvents(colUnpublishedPlannedEvents));</span>
							}

<span class="nc bnc" id="L672" title="All 2 branches missed.">							for (Iterator itEvent = colUnpublishedPlannedEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L673">								Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">								if (hmParentEvents != null &amp;&amp; event.getID() != null) {</span>
<span class="nc" id="L675">									hmParentEvents.put(new UniqueEventID(event), event);</span>
								}
<span class="nc" id="L677">							}</span>
						}
<span class="nc" id="L679">						employeeData.setPlannedEvents(colPlannedEvents);</span>
<span class="nc" id="L680">						employeeData.setUnpublishedPlannedEvents(colUnpublishedPlannedEvents);</span>
<span class="nc bnc" id="L681" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L682">							m_cat.debug(&quot;Planned Events (in) for employee: &quot; + idEmployee + &quot; = &quot; + colPlannedEvents);</span>
						}

						{
<span class="nc" id="L686">							Collection colFlattenedEvents = EventUtils.flattenEvents(colPlannedEvents);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">							for (Iterator itEvent = colFlattenedEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L688">								Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L689" title="All 2 branches missed.">								if (event.getActivityID() == null) {</span>
<span class="nc" id="L690">									m_cat.info(&quot;Null ActivityID detected on Published event: &quot; + event);</span>
								}
<span class="nc" id="L692">							}</span>
<span class="nc" id="L693">							colFlattenedEvents = EventUtils.flattenEvents(colUnpublishedPlannedEvents);</span>
<span class="nc bnc" id="L694" title="All 2 branches missed.">							for (Iterator itEvent = colFlattenedEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L695">								Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">								if (event.getActivityID() == null) {</span>
<span class="nc" id="L697">									m_cat.info(&quot;Null ActivityID detected on Unpublished event: &quot; + event);</span>
								}
<span class="nc" id="L699">							}</span>
						}
<span class="nc" id="L701">						employeeDataIn.setPlannedEvents(colPlannedEvents);</span>
<span class="nc" id="L702">						employeeDataIn.setPlannedChangedIntervals(colChangedIntervals);</span>
<span class="nc" id="L703">						employeeDataIn.setUnpublishedPlannedChangedIntervals(colChangedIntervals);</span>
					}
<span class="nc" id="L705">				}</span>
			}
			{
<span class="nc" id="L708">				Date dateWinEnd = dateEnd;</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">				if (dateWinEnd.after(dateCurrent))</span>
<span class="nc" id="L710">					dateWinEnd = dateCurrent;</span>
<span class="nc" id="L711">				hmAllActualEvents = m_timeRecordManager</span>
<span class="nc" id="L712">						.getEventsForWorkResourceFromCache(colEmployeeIDs,</span>
								dateStart, dateWinEnd, true);

<span class="nc" id="L715">				HashMap hmChangedIntervals = null;</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">				if (dateLastUpdated != null) {</span>
<span class="nc" id="L717">					hmChangedIntervals = m_timeRecordManager</span>
<span class="nc" id="L718">							.getPublishedChangedIntervalsForWorkResource(</span>
									colEmployeeIDs, dateStart, dateEnd,
									dateLastUpdated);
				}

<span class="nc" id="L723">				for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L724" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L725">					ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L726">					Collection colActualEvents = (Collection) hmAllActualEvents</span>
<span class="nc" id="L727">							.get(idEmployee);</span>
<span class="nc bnc" id="L728" title="All 2 branches missed.">					if (colActualEvents == null)</span>
<span class="nc" id="L729">						colActualEvents = new LinkedList();</span>
<span class="nc bnc" id="L730" title="All 2 branches missed.">					if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L731">						m_cat.debug(&quot;Actual Events (in) for employee: &quot;</span>
								+ idEmployee + &quot; = &quot; + colActualEvents);
<span class="nc" id="L733">					Collection colChangedIntervals = null;</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">					if (dateLastUpdated == null) {</span>
<span class="nc" id="L735">						colChangedIntervals = new LinkedList();</span>
<span class="nc" id="L736">						colChangedIntervals.add(new TimeRange(dateStart,</span>
								dateEnd));
					} else {
<span class="nc" id="L739">						colChangedIntervals = (Collection) hmChangedIntervals</span>
<span class="nc" id="L740">								.get(idEmployee);</span>
<span class="nc bnc" id="L741" title="All 2 branches missed.">						if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L742">							m_cat.debug(&quot;Actual Changed Intervals  for employee &quot;</span>
									+ idEmployee + &quot; = &quot; + colChangedIntervals);
					}
<span class="nc bnc" id="L745" title="All 2 branches missed.">					if (colChangedIntervals == null)</span>
<span class="nc" id="L746">						colChangedIntervals = new LinkedList();</span>

<span class="nc" id="L748">					Collection colActivityIDs = getActivityIDsToLoad(colActualEvents);</span>
<span class="nc" id="L749">					tsActivitiesToLoad.addAll(colActivityIDs);</span>
<span class="nc" id="L750">					EmployeeDataIn employeeDataIn = hmEmployeeDataIn</span>
<span class="nc" id="L751">							.get(idEmployee);</span>
<span class="nc" id="L752">					employeeDataIn.setActualActivityIDs(colActivityIDs);</span>
					{
<span class="nc" id="L754">						EmployeeData employeeData = hmEmployeeData</span>
<span class="nc" id="L755">								.get(idEmployee);</span>
<span class="nc" id="L756">						employeeData.setActualMinTime(dateEnd);</span>
<span class="nc" id="L757">						employeeData.setActualMaxTime(dateStart);</span>
<span class="nc" id="L758">						for (Iterator itEvent = colActualEvents.iterator(); itEvent</span>
<span class="nc bnc" id="L759" title="All 2 branches missed.">								.hasNext();) {</span>
<span class="nc" id="L760">							Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">							if (event.getStartTime().before(dateMin))</span>
<span class="nc" id="L762">								dateMin = event.getStartTime();</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">							if (event.getEndTime().after(dateMax))</span>
<span class="nc" id="L764">								dateMax = event.getEndTime();</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">							if (event.getStartTime().before(</span>
<span class="nc" id="L766">									employeeData.getActualMinTime()))</span>
<span class="nc" id="L767">								employeeData.setActualMinTime(event</span>
<span class="nc" id="L768">										.getStartTime());</span>
<span class="nc bnc" id="L769" title="All 2 branches missed.">							if (event.getEndTime().after(</span>
<span class="nc" id="L770">									employeeData.getActualMaxTime()))</span>
<span class="nc" id="L771">								employeeData.setActualMaxTime(event</span>
<span class="nc" id="L772">										.getEndTime());</span>
<span class="nc bnc" id="L773" title="All 2 branches missed.">							if (event instanceof TimeRecord) {</span>
<span class="nc" id="L774">								TimeRecord timeRecord = (TimeRecord) event;</span>
<span class="nc bnc" id="L775" title="All 2 branches missed.">								if (timeRecord.getApprove() == false)</span>
<span class="nc" id="L776">									employeeData.setIsApproved(false);</span>

							}
<span class="nc" id="L779">						}</span>

<span class="nc" id="L781">						employeeData.setActualEvents(colActualEvents);</span>
						// Note, this must happen before flattening.
<span class="nc bnc" id="L783" title="All 2 branches missed.">						if (hmParentEvents != null) {</span>
<span class="nc" id="L784">							for (Iterator itEvent = colActualEvents.iterator(); itEvent</span>
<span class="nc bnc" id="L785" title="All 2 branches missed.">									.hasNext();) {</span>
<span class="nc" id="L786">								Event eventActual = (Event) itEvent.next();</span>
<span class="nc" id="L787">								hmParentEvents.put(new UniqueEventID(</span>
										eventActual), eventActual);
<span class="nc" id="L789">							}</span>
						}
<span class="nc" id="L791">						employeeDataIn.setActualEvents(colActualEvents);</span>
<span class="nc" id="L792">						employeeDataIn</span>
<span class="nc" id="L793">								.setActualChangedIntervals(colChangedIntervals);</span>

						{
<span class="nc" id="L796">							Collection colFlattenedEvents = EventUtils</span>
<span class="nc" id="L797">									.flattenEvents(colActualEvents);</span>
<span class="nc" id="L798">							for (Iterator itEvent = colFlattenedEvents</span>
<span class="nc bnc" id="L799" title="All 2 branches missed.">									.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L800">								Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L801" title="All 2 branches missed.">								if (event.getActivityID() == null)</span>
<span class="nc" id="L802">									m_cat.info(&quot;Null ActivityID detected on Actual event: &quot;</span>
											+ event);
<span class="nc" id="L804">							}</span>
						}

					}
<span class="nc" id="L808">				}</span>
			}
<span class="nc" id="L810">			HashMap hmActivities = loadActivities(tsActivitiesToLoad);</span>
<span class="nc" id="L811">			HashMap hmActivityMappings = m_rtaaService</span>
<span class="nc" id="L812">					.loadActivityMappings(tsActivitiesToLoad);</span>

			// TODO: use max of dateWinStart/dateWinEnd (over all employees) instead.
<span class="nc" id="L815">			HashMap hmAdheranceOverrides = m_rtaaService.getAdheranceOverrides(colEmployeeIDs, dateStart, dateEnd);</span>

<span class="nc bnc" id="L817" title="All 2 branches missed.">			for (ID idEmployee : colEmployeeIDs) {</span>
<span class="nc" id="L818">				EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn.get(idEmployee);</span>
<span class="nc" id="L819">				EmployeeData employeeData = (EmployeeData) hmEmployeeData.get(idEmployee);</span>

<span class="nc" id="L821">				employeeDataIn.setPlannedEvents(EventUtils.flattenEvents(employeeDataIn.getPlannedEvents(), dateStart, dateEnd, false));</span>
<span class="nc" id="L822">				employeeDataIn.setActualEvents(EventUtils.flattenEvents(employeeDataIn.getActualEvents(), dateStart, dateEnd, false));</span>

<span class="nc" id="L824">				Collection colAdheranceOverrides = (Collection) hmAdheranceOverrides.get(idEmployee);</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">				if (colAdheranceOverrides == null) {</span>
<span class="nc" id="L826">					colAdheranceOverrides = new LinkedList();</span>
				}
<span class="nc bnc" id="L828" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L829">					m_cat.debug(&quot;Adherance Overrides for employee: &quot; + idEmployee + &quot; = &quot; + colAdheranceOverrides);</span>
				}

<span class="nc" id="L832">				Collection colChangedIntervals = computeAdheranceChangedIntervals(</span>
<span class="nc" id="L833">						dateStart, dateEnd, employeeDataIn.getPlannedEvents(),</span>
<span class="nc" id="L834">						employeeDataIn.getPlannedChangedIntervals(),</span>
<span class="nc" id="L835">						employeeDataIn.getActualChangedIntervals(),</span>
						colAdheranceOverrides,
<span class="nc" id="L837">						employeeDataIn.getPlannedActivityIDs(), hmActivities,</span>
						dateLastUpdated, dateCurrent);

<span class="nc bnc" id="L840" title="All 2 branches missed.">				if (doActivitiesRequireRefresh(</span>
<span class="nc" id="L841">						employeeDataIn.getActualActivityIDs(), hmActivities,</span>
						dateLastUpdated, dateCurrent)) {
<span class="nc" id="L843">					Collection col = new LinkedList();</span>
<span class="nc" id="L844">					col.add(new TimeRange(dateStart, dateEnd));</span>
<span class="nc" id="L845">					employeeDataIn.setActualChangedIntervals(col);</span>
				}
<span class="nc bnc" id="L847" title="All 2 branches missed.">				if (doActivitiesRequireRefresh(</span>
<span class="nc" id="L848">						employeeDataIn.getPlannedActivityIDs(), hmActivities,</span>
						dateLastUpdated, dateCurrent)) {
<span class="nc" id="L850">					Collection col = new LinkedList();</span>
<span class="nc" id="L851">					col.add(new TimeRange(dateStart, dateEnd));</span>
<span class="nc" id="L852">					employeeDataIn.setPlannedChangedIntervals(col);</span>
				}
<span class="nc bnc" id="L854" title="All 2 branches missed.">				if (doActivitiesRequireRefresh(</span>
<span class="nc" id="L855">						employeeDataIn.getUnpublishedPlannedActivityIDs(),</span>
						hmActivities, dateLastUpdated, dateCurrent)) {
<span class="nc" id="L857">					Collection col = new LinkedList();</span>
<span class="nc" id="L858">					col.add(new TimeRange(dateStart, dateEnd));</span>
<span class="nc" id="L859">					employeeDataIn.setUnpublishedPlannedChangedIntervals(col);</span>
				}

<span class="nc" id="L862">				employeeDataIn.setExceptionChangedIntervals(colChangedIntervals);</span>

<span class="nc" id="L864">				Collection colPlannedEvents = employeeData.getPlannedEvents();</span>
<span class="nc" id="L865">				colPlannedEvents.addAll(</span>
<span class="nc" id="L866">						EventUtils.getTruncateEventsForChangedIntervals(idEmployee, employeeDataIn.getPlannedChangedIntervals(),</span>
								dateStart, dateEnd));
<span class="nc bnc" id="L868" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L869">					m_cat.debug(&quot;Planned Events to convert for employee: &quot; + idEmployee + &quot; = &quot; +</span>
<span class="nc" id="L870">							EventUtils.flattenEvents(colPlannedEvents));</span>
<span class="nc" id="L871">					m_cat.debug(&quot;Hashmap to convert for employee: &quot; + idEmployee + &quot; = &quot; + hmActivities);</span>
				}

<span class="nc" id="L874">				colPlannedEvents = EventUtils.convertEventsToTimelineForSingleEmployee(colPlannedEvents, dateStart, dateEnd, hmActivities);</span>

<span class="nc" id="L876">				employeeData.setPlannedEvents(colPlannedEvents);</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">				if (bIncludeExtraDumpData) {</span>
<span class="nc" id="L878">					Collection colUnpublishedPlannedEvents = employeeData.getUnpublishedPlannedEvents();</span>
<span class="nc" id="L879">					colUnpublishedPlannedEvents.addAll(</span>
<span class="nc" id="L880">							EventUtils.getTruncateEventsForChangedIntervals(</span>
<span class="nc" id="L881">									idEmployee, employeeDataIn.getUnpublishedPlannedChangedIntervals(), dateStart, dateEnd));</span>
<span class="nc" id="L882">					colUnpublishedPlannedEvents = EventUtils.convertEventsToTimelineForSingleEmployee(</span>
							colUnpublishedPlannedEvents, dateStart, dateEnd, hmActivities);
<span class="nc" id="L884">					employeeData.setUnpublishedPlannedEvents(colUnpublishedPlannedEvents);</span>
				}

<span class="nc" id="L887">				Collection colActualEvents = employeeData.getActualEvents();</span>
<span class="nc bnc" id="L888" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L889">					m_cat.debug(&quot;ActualEvents (before trunc) for employee (out): &quot; + idEmployee + &quot; = &quot; + colActualEvents);</span>
				}

<span class="nc" id="L892">				Collection colInverseChangedIntervals =</span>
<span class="nc" id="L893">						EventUtils.getInverseOfTimeRanges(employeeDataIn.getActualChangedIntervals(), dateStart, dateEnd);</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L895">					m_cat.debug(&quot;InverseChangedIntervals for employee (out): &quot; + idEmployee + &quot; = &quot; + colInverseChangedIntervals);</span>
				}

<span class="nc" id="L898">				Collection colTruncEvents = EventUtils.getTruncateEventsForChangedIntervals(</span>
<span class="nc" id="L899">						idEmployee, employeeDataIn.getActualChangedIntervals(), dateStart, dateEnd);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L901">					m_cat.debug(&quot;ActualTruncEvents for employee (out): &quot; + idEmployee + &quot; = &quot; + colTruncEvents);</span>
				}

<span class="nc" id="L904">				colActualEvents.addAll(colTruncEvents);</span>
<span class="nc" id="L905">				colActualEvents = EventUtils.convertEventsToTimelineForSingleEmployee(colActualEvents, dateStart, dateEnd, hmActivities);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">				if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L907">					m_cat.debug(&quot;ActualEvents (after trunc) for employee (out): &quot; + idEmployee + &quot; = &quot; + colActualEvents);</span>
				}
<span class="nc" id="L909">				employeeData.setActualEvents(colActualEvents);</span>
<span class="nc" id="L910">				employeeDataIn.setAdheranceOverrides(colAdheranceOverrides);</span>
<span class="nc" id="L911">			}</span>

<span class="nc" id="L913">			Date dateWinEnd = dateEnd;</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">			if (dateWinEnd.after(dateCurrent)) {</span>
<span class="nc" id="L915">				dateWinEnd = dateCurrent;</span>
			}

<span class="nc bnc" id="L918" title="All 2 branches missed.">			if (!excludeAdherenceExceptionsCalculation) {</span>
<span class="nc" id="L919">				RTAADataIn rtaaDataIn =</span>
						new RTAADataIn(colEmployeeIDs, (HashMap) hmEmployeeDataIn, hmActivityMappings, hmActivities, dateStart, dateWinEnd);
<span class="nc" id="L921">				Collection&lt;Collection&lt;RTAAException&gt;&gt; colAllAdherenceViolations =</span>
<span class="nc" id="L922">						m_rtaaService.getAdheranceExceptionsForEmployees(rtaaDataIn);</span>

<span class="nc" id="L924">				Iterator&lt;Collection&lt;RTAAException&gt;&gt; itAdheranceViolations = colAllAdherenceViolations.iterator();</span>
<span class="nc bnc" id="L925" title="All 2 branches missed.">				for (ID employeeId : colEmployeeIDs) {</span>
<span class="nc" id="L926">					processEmployeeNonAdherenceAndViolations(employeeId, hmEmployeeData.get(employeeId), hmEmployeeDataIn.get(employeeId),</span>
<span class="nc" id="L927">							itAdheranceViolations.next(), dateStart, dateEnd);</span>
<span class="nc" id="L928">				}</span>
			}
<span class="nc" id="L930">			LinkedList llEmployeeData = null;</span>
<span class="nc bnc" id="L931" title="All 2 branches missed.">			if (nSortField == SORT_NONE) {</span>
<span class="nc" id="L932">				llEmployeeData = new LinkedList();</span>
<span class="nc bnc" id="L933" title="All 2 branches missed.">				for (ID idEmployee : colEmployeeIDs) {</span>
<span class="nc" id="L934">					EmployeeData employeeData = (EmployeeData) hmEmployeeData.get(idEmployee);</span>
<span class="nc" id="L935">					llEmployeeData.add(employeeData);</span>
<span class="nc" id="L936">				}</span>
			} else {
<span class="nc" id="L938">				LocaleContext localeContext = DefaultLocalizationManager.getDefaultInstance().getLocaleContext();</span>
<span class="nc" id="L939">				llEmployeeData = new LinkedList(hmEmployeeData.values());</span>
<span class="nc" id="L940">				Collections.sort(llEmployeeData, new CompareEmployeeData(nSortField, bIsAscending, localeContext));</span>
			}
<span class="nc" id="L942">			Collection colEmployeeDataPage = new LinkedList();</span>
<span class="nc" id="L943">			colEmployeeIDs = new LinkedList();</span>
<span class="nc" id="L944">			int nIndex = 0;</span>
<span class="nc bnc" id="L945" title="All 2 branches missed.">			for (Iterator itEmployeeData = llEmployeeData.iterator(); itEmployeeData.hasNext();) {</span>
<span class="nc" id="L946">				EmployeeData employeeData = (EmployeeData) itEmployeeData.next();</span>
<span class="nc" id="L947">				colEmployeeIDs.add(employeeData.getEmployeeID());</span>
<span class="nc bnc" id="L948" title="All 4 branches missed.">				if (nIndex &gt;= nOffset &amp;&amp; nIndex &lt; nOffset + nMaxEmployees) {</span>
<span class="nc" id="L949">					colEmployeeDataPage.add(employeeData);</span>
				}
<span class="nc" id="L951">			}</span>

<span class="nc" id="L953">			RTAAData rtaaData = new RTAAData(colEmployeeDataPage, hmActivities, dateMin, dateMax, hmParentEvents, hmActivityMappings);</span>
<span class="nc" id="L954">			rtaaData.setEmployeeIDs(colEmployeeIDs);</span>

<span class="nc bnc" id="L956" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L957">				Collection colEmployeeData = rtaaData.getEmployeeData();</span>
<span class="nc bnc" id="L958" title="All 2 branches missed.">				for (Iterator itEmployeeData = colEmployeeData.iterator(); itEmployeeData.hasNext();) {</span>
<span class="nc" id="L959">					EmployeeData employeeData = (EmployeeData) itEmployeeData.next();</span>
<span class="nc" id="L960">					ID idEmployee = employeeData.getEmployeeID();</span>
<span class="nc" id="L961">					Collection colActualEvents = employeeData.getActualEvents();</span>
<span class="nc" id="L962">					Collection colPlannedEvents = employeeData.getPlannedEvents();</span>
<span class="nc" id="L963">					Collection colAdheranceViolations = employeeData.getAdheranceViolations();</span>

<span class="nc" id="L965">					m_cat.debug(&quot;ActualEvents for employee (final out): &quot; + idEmployee + &quot; = &quot; + colActualEvents);</span>
<span class="nc" id="L966">					m_cat.debug(&quot;PlannedEvents for employee (final out): &quot; + idEmployee + &quot; = &quot; + colPlannedEvents);</span>
<span class="nc" id="L967">					m_cat.debug(&quot;AdheranceViolations for employee (final out): &quot; + idEmployee + &quot; = &quot; + colAdheranceViolations);</span>
<span class="nc" id="L968">				}</span>
<span class="nc" id="L969">				m_cat.debug(&quot;ParentEventsMap (final out): &quot; + rtaaData.getParentEventsMap());</span>
			}
<span class="nc" id="L971">			return rtaaData;</span>
<span class="nc" id="L972">		} catch (Exception e) {</span>
<span class="nc" id="L973">			m_cat.info(&quot;Exception occur on employees&quot; + colEmployeeIDs</span>
					+ &quot; Start: &quot; + dateStart + &quot; End: &quot; + dateEnd
					+ &quot; LastUpdated: &quot; + dateLastUpdated);
<span class="nc bnc" id="L976" title="All 2 branches missed.">			if (hmAllActualEvents != null) {</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">				for (ID idEmployee : colEmployeeIDs) {</span>
<span class="nc" id="L978">					Collection colActualEvents = (Collection) hmAllActualEvents.get(idEmployee);</span>
<span class="nc" id="L979">					m_cat.info(&quot;Actual Events (in) for employee: &quot; + idEmployee + &quot; = &quot; + colActualEvents);</span>
<span class="nc" id="L980">				}</span>
			} else {
<span class="nc" id="L982">				m_cat.info(&quot;hmAllActualEvents is null&quot;);</span>
			}
<span class="nc" id="L984">			handleException(e, false);</span>
<span class="nc" id="L985">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L987">			methodFinish();</span>
<span class="nc" id="L988">			jdmo.cleanUp();</span>
<span class="nc" id="L989">			jdmo = null;</span>
		}
	}

	private Map&lt;ID, EmployeeDataIn&gt; initEmployeeDataInMap(
			Collection&lt;ID&gt; employeeIds) {
<span class="nc" id="L995">		Map&lt;ID, EmployeeDataIn&gt; retVal = new HashMap&lt;ID, EmployeeDataIn&gt;();</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">		for (ID employeeId : employeeIds) {</span>
<span class="nc" id="L997">			EmployeeDataIn employeeDataIn = new EmployeeDataIn(employeeId);</span>
<span class="nc" id="L998">			retVal.put(employeeId, employeeDataIn);</span>
<span class="nc" id="L999">		}</span>
<span class="nc" id="L1000">		return retVal;</span>
	}

	/**
	 * Calculates the number of minutes out of adherence for the given employee
	 * and determines the adherence violations. This data is set on the
	 * employeeData object. Warning: This method modifies colAdherenceViolations
	 * and employeeData!
	 */
	private void processEmployeeNonAdherenceAndViolations(ID idEmployee,
			EmployeeData employeeData, EmployeeDataIn employeeDataIn,
			Collection&lt;RTAAException&gt; colAdherenceViolations, Date dateStart,
			Date dateEnd) {

<span class="nc" id="L1014">		int EVENTTYPE_CREATEEXCEPTION = -3;</span>
<span class="nc" id="L1015">		int EVENTTYPE_CREATEDELETEDEXCEPTION = -4;</span>

<span class="nc" id="L1017">		Collection colEventsIntersect = new LinkedList();</span>
<span class="nc" id="L1018">		int nNonAdheringMinutes = 0;</span>

<span class="nc bnc" id="L1020" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1021">			m_cat.debug(&quot;AdheranceViolations &quot; + idEmployee + &quot; = &quot;</span>
					+ colAdherenceViolations);
		}

<span class="nc" id="L1025">		for (Iterator&lt;RTAAException&gt; itException = colAdherenceViolations</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">				.iterator(); itException.hasNext();) {</span>
<span class="nc" id="L1027">			RTAAException rtaaException = itException.next();</span>
<span class="nc" id="L1028">			String strDesc = &quot;&quot;;</span>

<span class="nc bnc" id="L1030" title="All 2 branches missed.">			if (rtaaException.getApproveBy() != null) {</span>
<span class="nc" id="L1031">				strDesc += rtaaException.getApproveBy();</span>
			}
<span class="nc bnc" id="L1033" title="All 2 branches missed.">			if (rtaaException.getComment() != null) {</span>
<span class="nc" id="L1034">				strDesc += &quot;--&quot; + rtaaException.getComment();</span>
			}
<span class="nc" id="L1036">			colEventsIntersect.add(new SimpleEvent(</span>
<span class="nc" id="L1037">					rtaaException.getStartTime(), rtaaException.getEndTime(), rtaaException.getPlannedActivityID(),</span>
<span class="nc" id="L1038">					rtaaException.isApproved(), OVERLAY_PRECEDENCE_10, EVENTTYPE_CREATEEXCEPTION, strDesc));</span>
<span class="nc bnc" id="L1039" title="All 4 branches missed.">			if (!rtaaException.isDeleted() &amp;&amp; !rtaaException.isApproved()) {</span>
<span class="nc" id="L1040">				long lDuration = rtaaException.getEndTime().getTime() - rtaaException.getStartTime().getTime();</span>
<span class="nc" id="L1041">				long lDurationMins = lDuration / MILISECONDS_PER_MINUTE;</span>
<span class="nc" id="L1042">				nNonAdheringMinutes += lDurationMins;</span>
			}
<span class="nc" id="L1044">		}</span>

<span class="nc" id="L1046">		Collection colExceptionChangedIntervals = employeeDataIn</span>
<span class="nc" id="L1047">				.getExceptionChangedIntervals();</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1049">			m_cat.debug(&quot;Exception Changed Intervals &quot; + idEmployee + &quot; = &quot;</span>
					+ colExceptionChangedIntervals);
		}
<span class="nc" id="L1052">		Collection colTruncEvents = EventUtils</span>
<span class="nc" id="L1053">				.getTruncateEventsForChangedIntervals(idEmployee,</span>
						colExceptionChangedIntervals, dateStart, dateEnd);
<span class="nc bnc" id="L1055" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1056">			m_cat.debug(&quot;TruncEvents for exceptions &quot; + idEmployee + &quot; = &quot;</span>
					+ colTruncEvents);
		}
<span class="nc" id="L1059">		colEventsIntersect.addAll(colTruncEvents);</span>
<span class="nc" id="L1060">		for (Iterator itTimeRange = colExceptionChangedIntervals.iterator(); itTimeRange</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L1062">			TimeRange timeRange = (TimeRange) itTimeRange.next();</span>
<span class="nc" id="L1063">			colEventsIntersect.add(new SimpleEvent(timeRange.getStartDate(),</span>
<span class="nc" id="L1064">					timeRange.getEndDate(), Activity.ACTIVITY_DELETED, false,</span>
					1, EVENTTYPE_CREATEDELETEDEXCEPTION, null));
<span class="nc" id="L1066">		}</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1068">			m_cat.debug(&quot;Exception events intersect (1) &quot; + idEmployee + &quot; = &quot;</span>
					+ colEventsIntersect);
		}

<span class="nc" id="L1072">		colEventsIntersect = EventUtils</span>
<span class="nc" id="L1073">				.convertEventsToTimelineForSingleEmployee(colEventsIntersect,</span>
						dateStart, dateEnd, null, false);
<span class="nc bnc" id="L1075" title="All 2 branches missed.">		if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L1076">			m_cat.debug(&quot;Exception events intersect (2) &quot; + idEmployee + &quot; = &quot;</span>
					+ colEventsIntersect);
		}

<span class="nc" id="L1080">		colAdherenceViolations.clear();</span>
<span class="nc" id="L1081">		for (Iterator itEvent = colEventsIntersect.iterator(); itEvent</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L1083">			SimpleEvent simpleEvent = (SimpleEvent) itEvent.next();</span>
<span class="nc bnc" id="L1084" title="All 2 branches missed.">			if (simpleEvent.getEventType() == EVENTTYPE_CREATEDELETEDEXCEPTION) {</span>
<span class="nc" id="L1085">				colAdherenceViolations.add(new RTAAException(idEmployee,</span>
<span class="nc" id="L1086">						simpleEvent.getStartTime(), simpleEvent.getEndTime(),</span>
						Activity.ACTIVITY_DELETED, false, true));
<span class="nc bnc" id="L1088" title="All 2 branches missed.">			} else if (simpleEvent.getEventType() == EVENTTYPE_CREATEEXCEPTION) {</span>
<span class="nc" id="L1089">				int n = simpleEvent.getDescription().indexOf(&quot;--&quot;);</span>
				String strApprovedBy;
<span class="nc" id="L1091">				String strComment = null;</span>
<span class="nc bnc" id="L1092" title="All 2 branches missed.">				if (n == -1) {</span>
<span class="nc" id="L1093">					strApprovedBy = simpleEvent.getDescription();</span>
				} else {
<span class="nc" id="L1095">					strApprovedBy = simpleEvent.getDescription()</span>
<span class="nc" id="L1096">							.substring(0, n);</span>
<span class="nc" id="L1097">					strComment = simpleEvent.getDescription().substring(n + 2);</span>
				}
<span class="nc" id="L1099">				colAdherenceViolations.add(new RTAAException(idEmployee, simpleEvent.getStartTime(), simpleEvent.getEndTime(),</span>
<span class="nc" id="L1100">					simpleEvent.getPlannedActivityID(), simpleEvent.isApproved(), false, strApprovedBy, strComment));</span>
			}
<span class="nc" id="L1102">		}</span>

<span class="nc" id="L1104">		employeeData.setNonAdheranceDuration(nNonAdheringMinutes);</span>
<span class="nc" id="L1105">		employeeData.setAdheranceViolations(colAdherenceViolations);</span>
<span class="nc" id="L1106">	}</span>

	/**
	 * QC 45506 Take NO_ACTIVITY at start and end of shift into account to
	 * determine the min and max times for shift assignments.
	 *
	 * @see com.bluepumpkin.ejb.facade.people.ejb.PeopleFacadeEJB.adjustShiftBoundaries
	 * @see com.bluepumpkin.web.fs.schedule.ScheduleViewUtil.eventDisplayRange
	 * @see com.bluepumpkin.web.fs.schedule.ScheduleViewUtil.getDisplayStartTime
	 * @see com.bluepumpkin.web.fs.schedule.ScheduleViewUtil.getDisplayEndTime
	 * @see com.bluepumpkin.web.fs.schedule.ScheduleViewUtil.eventDisplayDuration
	 * @see com.bluepumpkin.web.bbm.shift.ShiftUtil.makeEventPeriodString
	 */
	private void setPlannedMinAndMaxTimes(EmployeeData employeeData, Event event) {
<span class="nc" id="L1120">		Date dtStart = event.getStartTime();</span>
<span class="nc" id="L1121">		Date dtEnd = event.getEndTime();</span>
<span class="nc" id="L1122">		int iDuration = event.getDuration();</span>

<span class="nc bnc" id="L1124" title="All 2 branches missed.">		if (event.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L1125">			ShiftAssignment sa = (ShiftAssignment) event;</span>

<span class="nc" id="L1127">			Collection shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">			for (Iterator it = shiftEventAssignments.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1129">				ShiftEventAssignment sea = (ShiftEventAssignment) it.next();</span>

<span class="nc bnc" id="L1131" title="All 2 branches missed.">				if (sea.getActivityID().equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L1132">					Date dtSeaEnd = sea.getEndTime();</span>

					// if ACTIVITY_NONE starts at same time as shift start, use
					// ShiftEventAssignment end time
<span class="nc bnc" id="L1136" title="All 2 branches missed.">					if (sea.getStartTime().equals(dtStart)) {</span>
<span class="nc" id="L1137">						dtStart = dtSeaEnd;</span>
<span class="nc" id="L1138">						iDuration -= sea.getDuration();</span>
					}
					// if ACTIVITY_NONE ends at same time as shift end, adjust
					// duration
<span class="nc bnc" id="L1142" title="All 2 branches missed.">					else if (dtSeaEnd.equals(dtEnd)) {</span>
<span class="nc" id="L1143">						iDuration -= sea.getDuration();</span>
					}
				}
<span class="nc" id="L1146">			}</span>

<span class="nc" id="L1148">			Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L1149">			cal.setTime(dtStart);</span>
<span class="nc" id="L1150">			cal.add(Calendar.MINUTE, iDuration);</span>
<span class="nc" id="L1151">			dtEnd = cal.getTime();</span>
		}

<span class="nc bnc" id="L1154" title="All 2 branches missed.">		if (dtStart.before(employeeData.getPlannedMinTime()))</span>
<span class="nc" id="L1155">			employeeData.setPlannedMinTime(dtStart);</span>
<span class="nc bnc" id="L1156" title="All 2 branches missed.">		if (dtEnd.after(employeeData.getPlannedMaxTime()))</span>
<span class="nc" id="L1157">			employeeData.setPlannedMaxTime(dtEnd);</span>
<span class="nc" id="L1158">	}</span>

	private Collection filterUnavailableEvents(Collection events) {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">		if (events == null)</span>
<span class="nc" id="L1162">			return null;</span>

<span class="nc" id="L1164">		Collection newEvents = new ArrayList(events.size());</span>
<span class="nc bnc" id="L1165" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L1166">			Event event = (Event) eventIter.next();</span>

<span class="nc bnc" id="L1168" title="All 2 branches missed.">			if (event.getEventType() != Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc" id="L1169">				newEvents.add(event);</span>
			}
<span class="nc" id="L1171">		}</span>
<span class="nc" id="L1172">		return newEvents;</span>
	}

	public Collection getActivityIDsToLoad(Collection colEvents) {
<span class="nc" id="L1176">		Collection colActivityIDsToLoad = new HashSet();</span>
<span class="nc bnc" id="L1177" title="All 2 branches missed.">		if (colEvents == null)</span>
<span class="nc" id="L1178">			return colActivityIDsToLoad;</span>
		// Get activities to load
<span class="nc bnc" id="L1180" title="All 2 branches missed.">		for (Iterator itEvent = colEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L1181">			Event event = (Event) itEvent.next();</span>
<span class="nc" id="L1182">			ID idActivity = event.getActivityID();</span>
<span class="nc bnc" id="L1183" title="All 2 branches missed.">			if (idActivity != null)</span>
<span class="nc" id="L1184">				colActivityIDsToLoad.add(idActivity);</span>
<span class="nc bnc" id="L1185" title="All 2 branches missed.">			if (event instanceof ShiftAssignment) {</span>
<span class="nc" id="L1186">				ShiftAssignment shiftAssignment = (ShiftAssignment) event;</span>
<span class="nc bnc" id="L1187" title="All 2 branches missed.">				if (shiftAssignment.getExtensionBefore() &gt; 0) {</span>
<span class="nc" id="L1188">					ID idActivityBefore = shiftAssignment</span>
<span class="nc" id="L1189">							.getOTExtensionBeforeActivityID();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">					if (idActivityBefore != null)</span>
<span class="nc" id="L1191">						colActivityIDsToLoad.add(idActivityBefore);</span>

				}
<span class="nc bnc" id="L1194" title="All 2 branches missed.">				if (shiftAssignment.getExtensionAfter() &gt; 0) {</span>
<span class="nc" id="L1195">					ID idActivityAfter = shiftAssignment</span>
<span class="nc" id="L1196">							.getOTExtensionAfterActivityID();</span>
<span class="nc bnc" id="L1197" title="All 2 branches missed.">					if (idActivityAfter != null)</span>
<span class="nc" id="L1198">						colActivityIDsToLoad.add(idActivityAfter);</span>
				}
			}

<span class="nc" id="L1202">			for (Iterator itChildEvent = event.getChildren().iterator(); itChildEvent</span>
<span class="nc bnc" id="L1203" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L1204">				Event eventChild = (Event) itChildEvent.next();</span>
<span class="nc" id="L1205">				ID idActivityChild = eventChild.getActivityID();</span>
<span class="nc bnc" id="L1206" title="All 2 branches missed.">				if (idActivityChild != null)</span>
<span class="nc" id="L1207">					colActivityIDsToLoad.add(idActivityChild);</span>
<span class="nc" id="L1208">			}</span>
<span class="nc" id="L1209">		}</span>
<span class="nc" id="L1210">		return colActivityIDsToLoad;</span>
	}

	public HashMap loadActivities(Collection&lt;ID&gt; colActivityIDsToLoad)
			throws BbmFinderException, BbmException, RemoteException {
<span class="nc" id="L1215">		colActivityIDsToLoad.add(Activity.ACTIVITY_NONE);</span>
<span class="nc" id="L1216">		colActivityIDsToLoad = new HashSet(colActivityIDsToLoad); // remove the</span>
																	// duplicate
																	// item if
																	// it exists
<span class="nc" id="L1220">		HashMap hmActivities = ValueObjectUtil.getIDObjectMap(m_activityManager</span>
<span class="nc" id="L1221">				.findActivities(colActivityIDsToLoad));</span>

<span class="nc" id="L1223">		colActivityIDsToLoad.removeAll(hmActivities.keySet());</span>
<span class="nc bnc" id="L1224" title="All 2 branches missed.">		if (!colActivityIDsToLoad.isEmpty())</span>
<span class="nc" id="L1225">			throw new BbmException(&quot;Activity Not found, ID = &quot;</span>
					+ colActivityIDsToLoad);

<span class="nc" id="L1228">		return hmActivities;</span>
	}

	/*
	 * private HashMap loadActivities(Collection colActivityIDs) throws
	 * BbmFinderException, BbmException, RemoteException { HashMap hmActivities
	 * = new HashMap(); Collection colActivityIDsToLoad = new LinkedList(); for
	 * (Iterator i = colActivityIDs.iterator(); i.hasNext(); ) { ID idActivity =
	 * (ID) i.next(); if (!hmActivities.containsKey(idActivity))
	 * colActivityIDsToLoad.add(idActivity);
	 *
	 *
	 * } Collection colActivities =
	 * m_activityManager.findActivities(colActivityIDsToLoad);
	 *
	 * for (Iterator i2 = colActivities.iterator(); i2.hasNext(); ) { Activity
	 * activity = (Activity) i2.next(); hmActivities.put(activity.getId(),
	 * activity); }
	 *
	 * return hmActivities; }
	 */

	public Collection dumpReportDataTestWithResult(Collection colEmployeeIDs,
			int threadID, Date dateStart, Date dateEnd) throws BbmException {
<span class="nc" id="L1252">		failed = new HashSet();</span>
<span class="nc" id="L1253">		dumpReportDataTest(colEmployeeIDs, threadID, dateStart, dateEnd);</span>
<span class="nc" id="L1254">		return failed;</span>
	}

	public void dumpReportDataTest(Collection colEmployeeIDs, int threadID,
			Date dateStart, Date dateEnd) throws BbmException {
<span class="nc" id="L1259">		Date dateCurrent = dateStart;</span>
<span class="nc" id="L1260">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1262">			updateDumpTimelineLastUpdatedDate(colEmployeeIDs, new Timestamp(0),</span>
<span class="nc" id="L1263">					new Timestamp(new Date(&quot;01/01/20 08:00:00&quot;).getTime()),</span>
<span class="nc" id="L1264">					jdmo, new Date(dateStart.getTime() - MILISECONDS_PER_DAY));</span>

<span class="nc bnc" id="L1266" title="All 2 branches missed.">			for (Date date = new Date(dateStart.getTime()); date.before(dateEnd);) {</span>
<span class="nc" id="L1267">				dateCurrent = date;</span>
<span class="nc" id="L1268">				m_cat.info(&quot;Stats begin: dumpReportData, current time = &quot; + dateCurrent);</span>
<span class="nc" id="L1269">				dumpReportData(colEmployeeIDs, threadID, false, dateCurrent);</span>
<span class="nc" id="L1270">				date.setTime(date.getTime() + MILISECONDS_PER_DAY);</span>
			}
<span class="nc" id="L1272">		} catch (Exception e) {</span>
<span class="nc" id="L1273">			handleException(e, false);</span>
<span class="nc" id="L1274">			throw new BbmException(e);</span>
		} finally {
<span class="nc" id="L1276">			jdmo.cleanUp();</span>
<span class="nc" id="L1277">			jdmo = null;</span>
<span class="nc" id="L1278">		}</span>
<span class="nc" id="L1279">	}</span>

	// for nightly report dump call from bpfx
	public void dumpReportData(Collection ids, int threadID)
			throws BbmException {
<span class="nc" id="L1284">		dumpReportData(ids, threadID, true, getCurrentTime());</span>
<span class="nc" id="L1285">	}</span>

	public Collection dumpReportDataWithResult(Collection ids, int threadID)
			throws BbmException {
<span class="nc" id="L1289">		failed = new HashSet();</span>
<span class="nc" id="L1290">		double failedMargin = dumpReportData(ids, threadID, true,</span>
<span class="nc" id="L1291">				getCurrentTime());</span>
<span class="nc" id="L1292">		failed.add(new Double(failedMargin));</span>
<span class="nc" id="L1293">		return failed;</span>
	}

	private Double dumpReportData(Collection ids, int threadID,
			boolean bDumpAll, Date dateCurrent) throws BbmException {
<span class="nc" id="L1298">		methodStart(&quot;dumpReportData&quot;, ids, new Integer(threadID), new Boolean(</span>
				bDumpAll));
<span class="nc" id="L1300">		Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L1301">		Jdmo jdmoWarehouse = null;</span>

<span class="nc" id="L1303">		Date dateStartTimer = Calendar.getInstance().getTime();</span>
<span class="nc" id="L1304">		Date dateStart = null;</span>
<span class="nc" id="L1305">		Date dateEnd = null;</span>
<span class="nc" id="L1306">		String state = &quot;&quot;;</span>

		try {
			// m_cat.info(&quot;ENTER: dumpReportData&quot;);

<span class="nc" id="L1311">			m_colFailedEmployeeIDs = new LinkedList();</span>
<span class="nc" id="L1312">			m_colFailedEmployeeFilterIDs = new LinkedList();</span>

			// re-init the statistic map
<span class="nc" id="L1315">			statistic.clear();</span>

<span class="nc" id="L1317">			String threadName = Thread.currentThread().getName();</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">			if(m_threadIDsFromThreadNames.get(threadName) == null)</span>
<span class="nc" id="L1319">				m_threadIDsFromThreadNames.put(threadName, threadID);</span>

<span class="nc" id="L1321">			Collection colEmployeeIDs = null;</span>
<span class="nc bnc" id="L1322" title="All 2 branches missed.">			if (ids == null)</span>
				// dump all employees
<span class="nc" id="L1324">				colEmployeeIDs = m_employeeFilter.getEmployeeIDs(</span>
<span class="nc" id="L1325">						Filter.createAllFilter(User.SUPER_USERID), -1, true, 0,</span>
						Integer.MAX_VALUE);
			else
<span class="nc" id="L1328">				colEmployeeIDs = ids;</span>

<span class="nc" id="L1330">			int nReportMaxDataRefreshLookbackDays = 30;</span>
			try {
<span class="nc" id="L1332">				nReportMaxDataRefreshLookbackDays = m_dbConfigManager</span>
<span class="nc" id="L1333">						.getIntValue(ConfigKey.CRYSTAL_REPORTS_MAX_DATA_REFRESH_LOOKBACK_DAYS);</span>
<span class="nc bnc" id="L1334" title="All 2 branches missed.">				if (nReportMaxDataRefreshLookbackDays &lt; 0)</span>
<span class="nc" id="L1335">					nReportMaxDataRefreshLookbackDays = 30;</span>
<span class="nc" id="L1336">			} catch (Exception e) {</span>
<span class="nc" id="L1337">			}</span>

			try {
<span class="nc" id="L1340">				int nUserTransactionTimeOut = m_dbConfigManager</span>
<span class="nc" id="L1341">						.getIntValue(ConfigKey.REPORTDUMP_USER_TRANSACTION_TIMEOUT);</span>
<span class="nc bnc" id="L1342" title="All 4 branches missed.">				if (nUserTransactionTimeOut &gt;= 120</span>
						&amp;&amp; nUserTransactionTimeOut &lt;= 1200)
<span class="nc" id="L1344">					USERTRANSACTION_TIMEOUT = nUserTransactionTimeOut;</span>
<span class="nc" id="L1345">			} catch (Exception e) {</span>
<span class="nc" id="L1346">			}</span>

			try {
<span class="nc" id="L1349">				int nReportDumpMaxRetry = m_dbConfigManager</span>
<span class="nc" id="L1350">						.getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_MAX_RETRY);</span>
<span class="nc bnc" id="L1351" title="All 2 branches missed.">				if (nReportDumpMaxRetry &gt; 0)</span>
<span class="nc" id="L1352">					REPORTDUMP_MAX_RETRY = nReportDumpMaxRetry;</span>
<span class="nc" id="L1353">			} catch (Exception e) {</span>
<span class="nc" id="L1354">			}</span>

<span class="nc" id="L1356">			dateStart = new Date(</span>
<span class="nc" id="L1357">					dateCurrent.getTime()</span>
							- (1000L * 60L * 60L * 24L * nReportMaxDataRefreshLookbackDays));
			// 30 days
			// Date dateEnd = new Date(getCurrentTime().getTime() + (1000L * 60L
			// * 60L * 24L * 365 * 2));
<span class="nc" id="L1362">			dateEnd = new Date(dateCurrent.getTime()</span>
					+ (1000L * 60L * 60L * 24L * 31L * 2L));
			// 30 days
			// dateEnd = new Date((dateEnd.getTime() / (1000L * 60L * 60L *
			// 365L)) * (1000L * 60L * 60L * 365L));
			// dateEnd = new Date((dateEnd.getTime() / (1000L * 60L * 60L *
			// 31L)) * (1000L * 60L * 60L * 31L));
<span class="nc bnc" id="L1369" title="All 2 branches missed.">			if (m_dbConfigManager.isTemporarilyStopReportDump())</span>
<span class="nc" id="L1370">				return 0.0;</span>
<span class="nc" id="L1371">			dumpReportData(colEmployeeIDs, dateStart, dateEnd, jdmo, true);</span>

			// m_cat.info(&quot;ENTER: updateOrganizationDays&quot;);
<span class="nc" id="L1374">			Date dateStartTimer3 = Calendar.getInstance().getTime();</span>
<span class="nc bnc" id="L1375" title="All 4 branches missed.">			if (bDumpAll &amp;&amp; threadID == 1)</span>
<span class="nc" id="L1376">				updateOrganizationDays(jdmo);</span>

<span class="nc" id="L1378">			Date dateEndTimer3 = Calendar.getInstance().getTime();</span>
			// m_lTimeSpentPerCatUpdateOrganizationDays =
			// dateEndTimer3.getTime() - dateStartTimer3.getTime();
<span class="nc" id="L1381">			statistic.add(&quot;m_lTimeSpentPerCatUpdateOrganizationDays&quot;,</span>
<span class="nc" id="L1382">					dateEndTimer3.getTime() - dateStartTimer3.getTime());</span>

			// m_cat.info(&quot;ENTER: updateTimeZones&quot;);
<span class="nc bnc" id="L1385" title="All 4 branches missed.">			if (bDumpAll &amp;&amp; threadID == 1)</span>
<span class="nc" id="L1386">				updateTimeZones(jdmo);</span>
			// m_cat.info(&quot;ENTER: updateEmployeeFilters&quot;);
<span class="nc" id="L1388">			Date dateStartTimer2 = Calendar.getInstance().getTime();</span>

<span class="nc" id="L1390">			int numOfFilters = 0;</span>
<span class="nc bnc" id="L1391" title="All 4 branches missed.">			if (bDumpAll &amp;&amp; threadID == 1) {</span>
<span class="nc" id="L1392">				jdmoWarehouse = getWarehouseJdmo();</span>
<span class="nc" id="L1393">				numOfFilters = updateFilteredEmployees(jdmo, jdmoWarehouse);</span>
<span class="nc" id="L1394">				updateCoachingSessionImpact(jdmo, jdmoWarehouse);</span>
<span class="nc" id="L1395">				dumpedEmpFilterIDs = null; // clean out</span>
			}

<span class="nc" id="L1398">			Date dateEndTimer2 = Calendar.getInstance().getTime();</span>
			// m_lTimeSpentPerCatUpdateEmployeeFilters = dateEndTimer2.getTime()
			// - dateStartTimer2.getTime();
<span class="nc" id="L1401">			statistic.add(&quot;m_lTimeSpentPerCatUpdateOrganizationDays&quot;,</span>
<span class="nc" id="L1402">					dateEndTimer2.getTime() - dateStartTimer2.getTime());</span>

<span class="nc" id="L1404">			Date dateEndTimer = Calendar.getInstance().getTime();</span>
<span class="nc" id="L1405">			long lTotalTime = dateEndTimer.getTime() - dateStartTimer.getTime();</span>

<span class="nc bnc" id="L1407" title="All 2 branches missed.">			if (threadID == 1)</span>
<span class="nc" id="L1408">				m_dbConfigManager.calculateNumOfSeatInUse();</span>

<span class="nc" id="L1410">			m_cat.info(&quot;REPORT DUMP STATS for thread # &quot;</span>
					+ threadID
					+ &quot;: TIME SPENT IN EACH SECTION: TOTAL TIME=&quot;
					+ (lTotalTime / 60000)
					+ &quot; Mins - starttime=&quot;
					+ dateStartTimer
					+ &quot;\n\t\tInitialize: &quot;
<span class="nc" id="L1417">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1418">							.get(&quot;m_lTimeSpentPerCatInitialize&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tChangedIntervals: &quot;
<span class="nc" id="L1420">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1421">							.get(&quot;m_lTimeSpentPerCatChangedIntervals&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tGetRTAAData: &quot;
<span class="nc" id="L1423">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1424">							.get(&quot;m_lTimeSpentPerCatGetRTAAData&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tTimeoffCalculation: &quot;
<span class="nc" id="L1426">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1427">							.get(&quot;m_lTimeSpentPerCatTimeoffCalculation&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tUpdateRTAAData: &quot;
<span class="nc" id="L1429">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1430">							.get(&quot;m_lTimeSpentPerCatUpdateRTAAData&quot;) / (double) lTotalTime) * 100.0)</span>
					// + &quot;\n\t\tUpdateRTAADataStitching: &quot; +
					// decFormat.format(((double)
					// statistic.get(&quot;m_lTimeSpentPerCatUpdateRTAADataStitching&quot;)
					// / (double) lTotalTime) * 100.0)
					+ &quot;\n\t\tUpdateEmployeeFilters: &quot;
<span class="nc" id="L1436">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1437">							.get(&quot;m_lTimeSpentPerCatUpdateEmployeeFilters&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t\tUpdateOrganizationDays: &quot;
<span class="nc" id="L1439">					+ decFormat.format(((double) statistic</span>
<span class="nc" id="L1440">							.get(&quot;m_lTimeSpentPerCatUpdateOrganizationDays&quot;) / (double) lTotalTime) * 100.0)</span>
					+ &quot;\n\t# Inserts: &quot;
					+ &quot;\n\t\t PublishedPlannedEvents: &quot;
					+ new Long(statistic
<span class="nc" id="L1444">							.get(&quot;m_lTotalPublishedPlannedEventsDumped&quot;))</span>
					+ &quot;\n\t\t UnpublishedPlannedEvents: &quot;
					+ new Long(statistic
<span class="nc" id="L1447">							.get(&quot;m_lTotalUnpublishedPlannedEventsDumped&quot;))</span>
					+ &quot;\n\t\t ActualEvents: &quot;
<span class="nc" id="L1449">					+ new Long(statistic.get(&quot;m_lTotalActualEventsDumped&quot;))</span>
					+ &quot;\n\t\t Adherence Exceptions: &quot;
					+ new Long(statistic
<span class="nc" id="L1452">							.get(&quot;m_lTotalAdherenceExceptionsDumped&quot;))</span>
					+ &quot;\n\t\t Total: &quot;
					+ new Long(
							statistic
<span class="nc" id="L1456">									.get(&quot;m_lTotalPublishedPlannedEventsDumped&quot;)</span>
									+ statistic
<span class="nc" id="L1458">											.get(&quot;m_lTotalUnpublishedPlannedEventsDumped&quot;)</span>
									+ statistic
<span class="nc" id="L1460">											.get(&quot;m_lTotalActualEventsDumped&quot;)</span>
									+ statistic
<span class="nc" id="L1462">											.get(&quot;m_lTotalAdherenceExceptionsDumped&quot;))</span>
					+ &quot;\n\tERRORS: &quot; + &quot;\n\t\tFAILED EMPLOYEES: &quot;
					+ m_colFailedEmployeeIDs
					+ &quot;\n\t\tFAILED EMPLOYEE FILTERS: &quot;
					+ m_colFailedEmployeeFilterIDs);

<span class="nc bnc" id="L1468" title="All 2 branches missed.">			if (!m_colFailedEmployeeIDs.isEmpty())</span>
<span class="nc" id="L1469">				throw new BbmException(&quot;Report dump has errors: &quot;</span>
<span class="nc" id="L1470">						+ m_colFailedEmployeeIDs.size() + &quot; employees and &quot;</span>
<span class="nc" id="L1471">						+ m_colFailedEmployeeIDs.size()</span>
						+ &quot; failed to dump. Please check log for details&quot;);

<span class="nc" id="L1474">			double failedMargin = 0;</span>
<span class="nc bnc" id="L1475" title="All 2 branches missed.">			if (!m_colFailedEmployeeFilterIDs.isEmpty()) {</span>
<span class="nc" id="L1476">				failedMargin = m_colFailedEmployeeFilterIDs.size() * 1.0</span>
						/ numOfFilters;
			}
<span class="nc" id="L1479">			state = &quot;Succeeded&quot;;</span>
<span class="nc" id="L1480">			return failedMargin;</span>
<span class="nc" id="L1481">		} catch (RemoteException e) {</span>
<span class="nc" id="L1482">			handleException(e, false);</span>
<span class="nc" id="L1483">			state = &quot;Failed&quot;;</span>
<span class="nc" id="L1484">			throw new BbmException(e);</span>
<span class="nc" id="L1485">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1486">			handleException(e, false);</span>
<span class="nc" id="L1487">			state = &quot;Failed&quot;;</span>
<span class="nc" id="L1488">			throw new BbmException(e);</span>
<span class="nc" id="L1489">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1490">			handleException(e, false);</span>
<span class="nc" id="L1491">			state = &quot;Failed&quot;;</span>
<span class="nc" id="L1492">			throw new BbmException(e);</span>
<span class="nc" id="L1493">		} catch (JdmoException e) {</span>
<span class="nc" id="L1494">			handleException(e, false);</span>
<span class="nc" id="L1495">			state = &quot;Failed&quot;;</span>
<span class="nc" id="L1496">			throw new BbmException(e);</span>
<span class="nc" id="L1497">		} catch (Exception e) {</span>
<span class="nc" id="L1498">			handleException(e, false);</span>
<span class="nc" id="L1499">			state = &quot;Failed&quot;;</span>
<span class="nc" id="L1500">			throw new BbmException(e);</span>
		} finally {
<span class="nc" id="L1502">			methodFinish();</span>
<span class="nc" id="L1503">			jdmo.cleanUp();</span>
<span class="nc" id="L1504">			jdmo = null;</span>
<span class="nc" id="L1505">			cleanupWarehouseJdmo(jdmoWarehouse);</span>
			// m_cat.info(&quot;EXIT: dumpReportData&quot;);

<span class="nc" id="L1508">			AuditTrailEntry entry = new AuditTrailEntry(</span>
					AuditTrailEntry.MODULE_ADAPTER,
					AuditTrailEntry.ACTION_RTAA_THREAD_FINISH,
					new ID(0),
					&quot;RTAA Thread &quot;+threadID,
					dateStart, dateEnd);

<span class="nc" id="L1515">			SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM/dd/yyyy HH:mm:ss&quot;);</span>
<span class="nc" id="L1516">			Date dateEndTimer = Calendar.getInstance().getTime();</span>
<span class="nc" id="L1517">			long lTotalTime = dateEndTimer.getTime() - dateStartTimer.getTime();</span>

<span class="nc" id="L1519">			entry.addProperty(&quot;Start Time&quot;, sdf.format(dateStartTimer), &quot;datetime&quot;, false);</span>
<span class="nc" id="L1520">			entry.addProperty(&quot;End Time&quot;, sdf.format(dateEndTimer), &quot;datetime&quot;, false);</span>
<span class="nc" id="L1521">			entry.addProperty(&quot;Thread&quot;, &quot;&quot;+threadID, &quot;int&quot;, false);</span>
<span class="nc" id="L1522">			entry.addProperty(&quot;Total Time&quot;, &quot;&quot;+lTotalTime / 60000, &quot;minutes&quot;, false);</span>
<span class="nc" id="L1523">			entry.addProperty(&quot;Time in Initialize&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatInitialize&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1524">			entry.addProperty(&quot;Time in ChangedIntervals&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatChangedIntervals&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1525">			entry.addProperty(&quot;Time in GetRTAAData&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatGetRTAAData&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1526">			entry.addProperty(&quot;Time in TimeoffCalculation&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatTimeoffCalculation&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1527">			entry.addProperty(&quot;Time in UpdateRTAAData&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatUpdateRTAAData&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1528">			entry.addProperty(&quot;Time in UpdateEmployeeFilters&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatUpdateEmployeeFilters&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1529">			entry.addProperty(&quot;Time in UpdateOrganizationDays&quot;, decFormat.format(((double) statistic.get(&quot;m_lTimeSpentPerCatUpdateOrganizationDays&quot;) / (double) lTotalTime) * 100.0), &quot;minutes&quot;, false);</span>
<span class="nc" id="L1530">			entry.addProperty(&quot;Total Inserts&quot;, &quot;&quot;+statistic.get(&quot;m_lTotalPublishedPlannedEventsDumped&quot;) + statistic.get(&quot;m_lTotalUnpublishedPlannedEventsDumped&quot;) + statistic.get(&quot;m_lTotalActualEventsDumped&quot;) + statistic.get(&quot;m_lTotalAdherenceExceptionsDumped&quot;), &quot;int&quot;, false);</span>
<span class="nc" id="L1531">			entry.addProperty(&quot;PublishedPlannedEvents&quot;, &quot;&quot;+statistic.get(&quot;m_lTotalPublishedPlannedEventsDumped&quot;), &quot;int&quot;, false);</span>
<span class="nc" id="L1532">			entry.addProperty(&quot;UnpublishedPlannedEvents&quot;, &quot;&quot;+statistic.get(&quot;m_lTotalUnpublishedPlannedEventsDumped&quot;), &quot;int&quot;, false);</span>
<span class="nc" id="L1533">			entry.addProperty(&quot;ActualEvents&quot;, &quot;&quot;+statistic.get(&quot;m_lTotalActualEventsDumped&quot;), &quot;int&quot;, false);</span>
<span class="nc" id="L1534">			entry.addProperty(&quot;Adherence Exceptions&quot;, &quot;&quot;+statistic.get(&quot;m_lTotalAdherenceExceptionsDumped&quot;), &quot;int&quot;, false);</span>
<span class="nc" id="L1535">			entry.addProperty(&quot;FAILED EMPLOYEES&quot;, &quot;&quot;+m_colFailedEmployeeIDs, &quot;int&quot;, false);</span>
<span class="nc" id="L1536">			entry.addProperty(&quot;FAILED EMPLOYEE FILTERS&quot;, &quot;&quot;+m_colFailedEmployeeFilterIDs, &quot;int&quot;, false);</span>
<span class="nc" id="L1537">			entry.addProperty(&quot;State&quot;, state, &quot;int&quot;, false);</span>

			try
			{
<span class="nc" id="L1541">				BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(entry);</span>
			}
<span class="nc" id="L1543">			catch (Exception e)</span>
			{
<span class="nc" id="L1545">				m_cat.warn(&quot;Exception occurred during audit of RTAA Thread.&quot;);</span>
<span class="nc" id="L1546">			}</span>
<span class="nc" id="L1547">		}</span>
		// m_cat.info(&quot;Completed: dumpReportData&quot;);
	}

	public void dumpTodaysReportDataForEmployees(Collection colEmployeeIDs)
			throws BbmException {
<span class="nc" id="L1553">		methodStart(&quot;dumpTodaysReportDataForEmployees&quot;, colEmployeeIDs);</span>

		try {
<span class="nc" id="L1556">			Date dateEnd = new Date();</span>
<span class="nc" id="L1557">			Date dateStart = new Date(dateEnd.getTime()</span>
					- TimeZoneUtil.DAY_IN_MILLISECONDS); // 1 days
<span class="nc" id="L1559">			dumpReportDataForEmployees(colEmployeeIDs, dateStart, dateEnd);</span>
		} finally {
<span class="nc" id="L1561">			methodFinish();</span>
<span class="nc" id="L1562">		}</span>
<span class="nc" id="L1563">	}</span>

	public void dumpReportDataForEmployees(Collection colEmployeeIDs,
			Date dateStart, Date dateEnd) throws BbmException {
<span class="nc" id="L1567">		methodStart(&quot;dumpReportDataForEmployees&quot;, colEmployeeIDs, dateStart,</span>
				dateEnd);
<span class="nc" id="L1569">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1571">			failed = new HashSet();</span>
			;
<span class="nc" id="L1573">			dumpReportData(colEmployeeIDs, dateStart, dateEnd, jdmo, false);</span>
<span class="nc" id="L1574">			m_cat.info(&quot;ENTER: updateOrganizationDays&quot;);</span>
<span class="nc" id="L1575">			updateOrganizationDays(jdmo);</span>
<span class="nc" id="L1576">		} catch (Exception e) {</span>
<span class="nc" id="L1577">			handleException(e, false);</span>
<span class="nc" id="L1578">			throw new BbmException(e);</span>
		} finally {
<span class="nc" id="L1580">			methodFinish();</span>
<span class="nc" id="L1581">			jdmo.cleanUp();</span>
<span class="nc" id="L1582">		}</span>
<span class="nc" id="L1583">	}</span>

	/**
	 * 1) dump employeeids for the given filter id 2) dump the adherence data
	 * for these employees if bDumpAdherenceData = true
	 */
	public void dumpReportDataForEmployees(ID idFilter, Date dateStart, Date dateEnd, boolean bDumpAdherenceData) throws BbmException {
<span class="nc" id="L1590">		methodStart(&quot;dumpReportDataForEmployees&quot;);</span>

<span class="nc" id="L1592">		Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L1593">		Jdmo jdmoWarehouse = null;</span>
		try {
<span class="nc" id="L1595">			Filter filter = m_employeeFilter.getFilterByID(idFilter);</span>
<span class="nc" id="L1596">			m_cat.info(&quot;dumpReportDataForEmployees: idFilter = &quot;</span>
<span class="nc" id="L1597">					+ idFilter.toString());</span>
<span class="nc bnc" id="L1598" title="All 2 branches missed.">			if (filter == null) {</span>
				// no need to dump
<span class="nc" id="L1600">				return;</span>
			}
<span class="nc" id="L1602">			Collection colEmployeeIDs = m_employeeFilter.getEmployeeIDs(filter, -1, true, 0, Integer.MAX_VALUE);</span>
<span class="nc" id="L1603">			jdmoWarehouse = getWarehouseJdmo();</span>
<span class="nc" id="L1604">			updateFilteredEmployees(jdmo, jdmoWarehouse, idFilter, colEmployeeIDs);</span>

<span class="nc bnc" id="L1606" title="All 2 branches missed.">			if (bDumpAdherenceData) {</span>
<span class="nc" id="L1607">				dumpReportData(colEmployeeIDs, dateStart, dateEnd, jdmo, false);</span>
			}
<span class="nc" id="L1609">		} catch (Exception e) {</span>
<span class="nc" id="L1610">			handleException(e, false);</span>
<span class="nc" id="L1611">			throw new BbmException(e);</span>
		} finally {
<span class="nc" id="L1613">			jdmo.cleanUp();</span>
<span class="nc" id="L1614">			cleanupWarehouseJdmo(jdmoWarehouse);</span>
<span class="nc" id="L1615">			methodFinish();</span>
<span class="nc" id="L1616">		}</span>
<span class="nc" id="L1617">	}</span>

	public void dumpReportDataChunk(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Date dateLastUpdated, Jdmo jdmo, Date dateCurrent)
			throws BbmFinderException, BbmUpdateException, JdmoException,
			BbmException, RemoteException, TimeOffCalculatorException {
<span class="nc" id="L1623">		methodStart(&quot;dumpReportDataChunk&quot;);</span>

<span class="nc" id="L1625">		Date dateStartTiming = Calendar.getInstance().getTime();</span>

<span class="nc" id="L1627">		Timestamp tsStart = new Timestamp(dateStart.getTime());</span>
<span class="nc" id="L1628">		Timestamp tsEnd = new Timestamp(dateEnd.getTime());</span>
<span class="nc" id="L1629">		jdmo.cleanUp();</span>
<span class="nc" id="L1630">		RTAAData rtaaData = getRTAADataLocal(dateCurrent, colEmployeeIDs,</span>
				dateStart, dateEnd, -1, true, 0, Integer.MAX_VALUE,
				dateLastUpdated, true);

<span class="nc" id="L1634">		Date dateEndTiming = Calendar.getInstance().getTime();</span>
		// m_lTimeSpentPerCatGetRTAAData += dateEndTiming.getTime() -
		// dateStartTiming.getTime();
<span class="nc" id="L1637">		statistic.add(&quot;m_lTimeSpentPerCatGetRTAAData&quot;, dateEndTiming.getTime()</span>
<span class="nc" id="L1638">				- dateStartTiming.getTime());</span>

<span class="nc" id="L1640">		Date dateStartTiming2 = Calendar.getInstance().getTime();</span>

<span class="nc" id="L1642">		Collection colAdheranceExceptions = new LinkedList();</span>
<span class="nc" id="L1643">		HashMap hmPlannedEventTimelines = new HashMap();</span>
<span class="nc" id="L1644">		HashMap hmUnpublishedPlannedEventTimelines = new HashMap();</span>
<span class="nc" id="L1645">		Collection colActualEventsTimeline = new LinkedList();</span>
<span class="nc" id="L1646">		Collection colEmployeeData = rtaaData.getEmployeeData();</span>
<span class="nc" id="L1647">		int nNumEmployeesInBatch = 0;</span>

		// HashMap hmLastUnpublishedShiftAssignments =
		// m_scheduleAccessManager.getLastShiftAssignmentStartTime(colEmployeeIDs);
		// if (m_cat.isDebugEnabled())
		// m_cat.debug(&quot;Last Shift Assignments&quot; +
		// hmLastUnpublishedShiftAssignments);
		{
<span class="nc" id="L1655">			Collection colEmptyEmployeeIDs = new LinkedList();</span>
<span class="nc" id="L1656">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L1657" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L1658">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">				if (m_hmLastShiftAssignments.get(idEmployee) == null)</span>
<span class="nc" id="L1660">					colEmptyEmployeeIDs.add(idEmployee);</span>
<span class="nc" id="L1661">			}</span>
<span class="nc" id="L1662">			HashMap hmLastShiftAssignments = m_scheduleAccessManager</span>
<span class="nc" id="L1663">					.getLastPublishedShiftAssignmentStartTime(colEmptyEmployeeIDs);</span>
<span class="nc" id="L1664">			for (Iterator itEmployeeID = colEmptyEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L1665" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L1666">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L1667">				Date dateLast = (Date) hmLastShiftAssignments.get(idEmployee);</span>
<span class="nc bnc" id="L1668" title="All 2 branches missed.">				if (dateLast == null)</span>
<span class="nc" id="L1669">					m_hmLastShiftAssignments.put(idEmployee, new Date(</span>
							1000L * 60L * 24L * 50L));
				else
<span class="nc" id="L1672">					m_hmLastShiftAssignments.put(idEmployee, dateLast);</span>
<span class="nc" id="L1673">			}</span>
		}

<span class="nc" id="L1676">		Collection colEmployeeIDsRequiringTimeoffCalc = new LinkedList();</span>
<span class="nc" id="L1677">		Date dateEarliestLastShiftAssignment = dateEnd;</span>
<span class="nc" id="L1678">		for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L1679" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L1680">			ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L1681">			Date dateLast = (Date) m_hmLastShiftAssignments.get(idEmployee);</span>
<span class="nc" id="L1682">			Date dateLastUnpublished = dateLast;</span>
			// (Date) hmLastUnpublishedShiftAssignments.get(idEmployee);
<span class="nc" id="L1684">			Date dateEarlierSAEnd = null;</span>
<span class="nc bnc" id="L1685" title="All 2 branches missed.">			if (dateLast != null) {</span>
<span class="nc" id="L1686">				dateEarlierSAEnd = dateLast;</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">				if (dateLastUnpublished != null) {</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">					if (dateLastUnpublished.before(dateEarlierSAEnd))</span>
<span class="nc" id="L1689">						dateEarlierSAEnd = dateLastUnpublished;</span>
				}
			} else {
<span class="nc bnc" id="L1692" title="All 2 branches missed.">				if (dateLastUnpublished != null)</span>
<span class="nc" id="L1693">					dateEarlierSAEnd = dateLastUnpublished;</span>
			}
<span class="nc bnc" id="L1695" title="All 2 branches missed.">			if (dateEarlierSAEnd != null) {</span>
<span class="nc bnc" id="L1696" title="All 2 branches missed.">				if (dateEarlierSAEnd.before(dateEarliestLastShiftAssignment))</span>
<span class="nc" id="L1697">					dateEarliestLastShiftAssignment = dateEarlierSAEnd;</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">				if (dateEarlierSAEnd.before(dateEnd))</span>
<span class="nc" id="L1699">					colEmployeeIDsRequiringTimeoffCalc.add(idEmployee);</span>
			}
<span class="nc" id="L1701">		}</span>

<span class="nc" id="L1703">		Map hmWorkResourceAssignments = m_workResourceManager</span>
<span class="nc" id="L1704">				.getWRAssignmentsWithTimeZone(colEmployeeIDsRequiringTimeoffCalc);</span>
<span class="nc" id="L1705">		HashMap hmOrganizations = new HashMap();</span>
<span class="nc" id="L1706">		for (Iterator itEmployeeID = colEmployeeIDsRequiringTimeoffCalc</span>
<span class="nc bnc" id="L1707" title="All 2 branches missed.">				.iterator(); itEmployeeID.hasNext();) {</span>
<span class="nc" id="L1708">			ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L1709">			Collection colWorkResourceAssignments = (Collection) hmWorkResourceAssignments</span>
<span class="nc" id="L1710">					.get(idEmployee);</span>
<span class="nc bnc" id="L1711" title="All 2 branches missed.">			if (colWorkResourceAssignments != null) {</span>
<span class="nc" id="L1712">				for (Iterator itWorkResourceAssignment = colWorkResourceAssignments</span>
<span class="nc bnc" id="L1713" title="All 2 branches missed.">						.iterator(); itWorkResourceAssignment.hasNext();) {</span>
<span class="nc" id="L1714">					WorkResourceAssignment workResourceAssignment = (WorkResourceAssignment) itWorkResourceAssignment</span>
<span class="nc" id="L1715">							.next();</span>
<span class="nc" id="L1716">					ID idOrganization = workResourceAssignment</span>
<span class="nc" id="L1717">							.getOrganizationID();</span>
<span class="nc bnc" id="L1718" title="All 2 branches missed.">					if (!hmOrganizations.containsKey(idOrganization))</span>
<span class="nc" id="L1719">						hmOrganizations.put(idOrganization, null);</span>
<span class="nc" id="L1720">				}</span>
			}
<span class="nc" id="L1722">		}</span>
<span class="nc" id="L1723">		Collection colOrganizationIDs = hmOrganizations.keySet();</span>
<span class="nc" id="L1724">		Collection colOrganizations = m_workResourceManager</span>
<span class="nc" id="L1725">				.getOrganizationsByIDs(colOrganizationIDs);</span>

<span class="nc" id="L1727">		for (Iterator itOrganization = colOrganizations.iterator(); itOrganization</span>
<span class="nc bnc" id="L1728" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L1729">			Organization organization = (Organization) itOrganization.next();</span>
<span class="nc" id="L1730">			ID idOrganization = organization.getID();</span>
<span class="nc" id="L1731">			hmOrganizations.put(idOrganization, organization);</span>
<span class="nc" id="L1732">		}</span>

<span class="nc" id="L1734">		Date dateWinStart = dateEarliestLastShiftAssignment;</span>
<span class="nc bnc" id="L1735" title="All 2 branches missed.">		if (dateWinStart.before(dateStart))</span>
<span class="nc" id="L1736">			dateWinStart = dateStart;</span>

<span class="nc" id="L1738">		HashMap hmOrganizationHOOAssignments = m_workResourceManager</span>
<span class="nc" id="L1739">				.getOrganizationHOOAssignments(colOrganizationIDs,</span>
						dateWinStart, dateEnd);
<span class="nc" id="L1741">		TimeZone tzGMT = TimeZoneUtil.GMT_TIMEZONE;</span>
<span class="nc" id="L1742">		HashMap hmOrganizationHolidays = m_holidayManager.getHolidays(</span>
				colOrganizationIDs, new LocalDate(dateWinStart, tzGMT),
				new LocalDate(dateEnd, tzGMT));

<span class="nc" id="L1746">		for (Iterator itEmployeeData = colEmployeeData.iterator(); itEmployeeData</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">				.hasNext();) {</span>
<span class="nc" id="L1748">			EmployeeData employeeData = (EmployeeData) itEmployeeData.next();</span>
<span class="nc" id="L1749">			colAdheranceExceptions</span>
<span class="nc" id="L1750">					.addAll(employeeData.getAdheranceViolations());</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">			if (!employeeData.getPlannedEvents().isEmpty()) {</span>
<span class="nc" id="L1752">				Collection colPlannedEvents = employeeData.getPlannedEvents();</span>

<span class="nc" id="L1754">				ID idEmployee = employeeData.getEmployeeID();</span>
<span class="nc" id="L1755">				Date dateLast = (Date) m_hmLastShiftAssignments.get(idEmployee);</span>
<span class="nc" id="L1756">				ShiftAssignment shiftAssignmentLast = new ShiftAssignment();</span>
<span class="nc" id="L1757">				shiftAssignmentLast.setStartTime(dateLast);</span>

<span class="nc bnc" id="L1759" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1760">					m_cat.debug(&quot;Planned Events (before apply timeoff) for employee: &quot;</span>
							+ idEmployee + &quot; = &quot; + colPlannedEvents);

<span class="nc" id="L1763">				applyTimeoffModificationsToEvents(idEmployee,</span>
<span class="nc" id="L1764">						employeeData.getOriginalPublishedPlannedEvents(),</span>
						colPlannedEvents, shiftAssignmentLast,
<span class="nc" id="L1766">						(Collection) hmWorkResourceAssignments.get(idEmployee),</span>
						hmOrganizations, hmOrganizationHOOAssignments,
						hmOrganizationHolidays, dateStart, dateEnd);
				{
<span class="nc" id="L1770">					Collection colFlattenedEvents = EventUtils</span>
<span class="nc" id="L1771">							.flattenEvents(colPlannedEvents);</span>
<span class="nc" id="L1772">					for (Iterator itEvent = colFlattenedEvents.iterator(); itEvent</span>
<span class="nc bnc" id="L1773" title="All 2 branches missed.">							.hasNext();) {</span>
<span class="nc" id="L1774">						Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L1775" title="All 2 branches missed.">						if (event.getActivityID() == null)</span>
<span class="nc" id="L1776">							m_cat.info(&quot;Null ActivityID detected (after apply Timeoff) on Published event: &quot;</span>
									+ event);
<span class="nc" id="L1778">					}</span>
				}

<span class="nc bnc" id="L1781" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1782">					m_cat.debug(&quot;Planned Events (after apply timeoff1) for employee: &quot;</span>
							+ idEmployee + &quot; = &quot; + colPlannedEvents);

<span class="nc" id="L1785">				colPlannedEvents = EventUtils</span>
<span class="nc" id="L1786">						.convertEventsToTimelineForSingleEmployee(</span>
								colPlannedEvents, dateStart, dateEnd,
<span class="nc" id="L1788">								rtaaData.getActivities());</span>

<span class="nc bnc" id="L1790" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1791">					m_cat.debug(&quot;Planned Events (after apply timeoff2) for employee: &quot;</span>
							+ idEmployee + &quot; = &quot; + colPlannedEvents);

<span class="nc bnc" id="L1794" title="All 2 branches missed.">				if (!colPlannedEvents.isEmpty())</span>
<span class="nc" id="L1795">					hmPlannedEventTimelines.put(idEmployee, colPlannedEvents);</span>
			}
<span class="nc bnc" id="L1797" title="All 2 branches missed.">			if (!employeeData.getUnpublishedPlannedEvents().isEmpty()) {</span>
<span class="nc" id="L1798">				ID idEmployee = employeeData.getEmployeeID();</span>
<span class="nc" id="L1799">				Collection colUnpublishedPlannedEvents = employeeData</span>
<span class="nc" id="L1800">						.getUnpublishedPlannedEvents();</span>
<span class="nc" id="L1801">				hmUnpublishedPlannedEventTimelines.put(idEmployee,</span>
						colUnpublishedPlannedEvents);
			}
<span class="nc bnc" id="L1804" title="All 2 branches missed.">			if (!employeeData.getActualEvents().isEmpty()) {</span>
<span class="nc" id="L1805">				Collection colActualEvents = employeeData.getActualEvents();</span>
<span class="nc" id="L1806">				colActualEventsTimeline.addAll(colActualEvents);</span>
			}
<span class="nc" id="L1808">		}</span>

<span class="nc" id="L1810">		Date dateEndTiming2 = Calendar.getInstance().getTime();</span>
		// m_lTimeSpentPerCatTimeoffCalculation += dateEndTiming2.getTime() -
		// dateStartTiming2.getTime();
<span class="nc" id="L1813">		statistic.add(&quot;m_lTimeSpentPerCatTimeoffCalculation&quot;,</span>
<span class="nc" id="L1814">				dateEndTiming2.getTime() - dateStartTiming2.getTime());</span>

<span class="nc" id="L1816">		UserTransaction userTransaction = m_sessionContext.getUserTransaction();</span>
		try {
<span class="nc" id="L1818">			userTransaction.setTransactionTimeout(1000);</span>
<span class="nc" id="L1819">			userTransaction.begin();</span>
<span class="nc" id="L1820">		} catch (Exception e) {</span>
<span class="nc" id="L1821">			handleException(e);</span>
<span class="nc" id="L1822">			throw new BbmException(e.getMessage());</span>
<span class="nc" id="L1823">		}</span>

		try {
<span class="nc" id="L1826">			boolean bAdhocDumpEnabled = true;</span>
			try {
<span class="nc" id="L1828">				String strBool = m_dbConfigManager</span>
<span class="nc" id="L1829">						.getValue(ConfigKey.CRYSTAL_REPORTS_ENABLE_ADHOC_DUMP);</span>
				// m_cat.info(&quot;ConfigKey.CRYSTAL_REPORTS_ENABLE_ADHOC_DUMP = &quot; +
				// strBool );

<span class="nc bnc" id="L1833" title="All 2 branches missed.">				if (strBool.compareTo(new String(&quot;false&quot;)) == 0)</span>
<span class="nc" id="L1834">					bAdhocDumpEnabled = false;</span>
<span class="nc" id="L1835">			} catch (Exception e) {</span>
<span class="nc" id="L1836">			}</span>

			// update plannedeventimeline, acutaleventtimeline and
			// adherenceexception tables
<span class="nc" id="L1840">			long startUpdateRTAA = System.currentTimeMillis();</span>
			// first get org day and sp day list
<span class="nc" id="L1842">			OrganizationDayDAO orgDayDAO = new OrganizationDayDAO(jdmo);</span>

			// move back one day
<span class="nc" id="L1845">			Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L1846">			calendar.setTime(tsStart);</span>
<span class="nc" id="L1847">			calendar.add(Calendar.DATE, -1);</span>
<span class="nc" id="L1848">			Date orgDayStart = calendar.getTime();</span>
			// move forward one day
<span class="nc" id="L1850">			calendar = Calendar.getInstance();</span>
<span class="nc" id="L1851">			calendar.setTime(tsEnd);</span>
<span class="nc" id="L1852">			calendar.add(Calendar.DATE, 1);</span>
<span class="nc" id="L1853">			Date orgDayEnd = calendar.getTime();</span>

<span class="nc" id="L1855">			HashMap orgDaysPerWKRS = orgDayDAO.getOrgDaysPerWorkResource(</span>
					colEmployeeIDs, orgDayStart, orgDayEnd);
<span class="nc" id="L1857">			HashMap spDaysPerWKRS = orgDayDAO.getSPDaysPerWorkResource(</span>
					colEmployeeIDs, orgDayStart, orgDayEnd);

			// update plannedeventtimeline table : must dump published first.
<span class="nc" id="L1861">			colEmployeeIDs = new ArrayList(colEmployeeIDs);</span>
<span class="nc" id="L1862">			Collections.sort((ArrayList) colEmployeeIDs);</span>
<span class="nc" id="L1863">			PlannedEventTimeLineDAO plannedDAO = new PlannedEventTimeLineDAO(</span>
					jdmo);
<span class="nc" id="L1865">			long start = System.currentTimeMillis();</span>
<span class="nc" id="L1866">			HashMap pubPlannedEvents = plannedDAO.updatePlannedEventsTimeline(</span>
					colEmployeeIDs, hmPlannedEventTimelines,
<span class="nc" id="L1868">					rtaaData.getActivities(), rtaaData.getParentEventsMap(),</span>
					orgDaysPerWKRS, spDaysPerWKRS, tsStart, tsEnd, false,
					bAdhocDumpEnabled);
<span class="nc" id="L1871">			long end = System.currentTimeMillis();</span>
<span class="nc bnc" id="L1872" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1873">				m_cat.debug(&quot;update published planned event timeline &quot;</span>
						+ &quot; for employees: &quot; + colEmployeeIDs + &quot; cost:&quot;
						+ (end - start));
<span class="nc" id="L1876">			statistic.add(&quot;m_lTotalPublishedPlannedEventsDumped&quot;,</span>
<span class="nc" id="L1877">					RTAAUtil.getNumberOfValues(pubPlannedEvents));</span>

<span class="nc" id="L1879">			start = System.currentTimeMillis();</span>
<span class="nc" id="L1880">			HashMap unPubPlannedEvents = plannedDAO</span>
<span class="nc" id="L1881">					.updatePlannedEventsTimeline(colEmployeeIDs,</span>
							hmUnpublishedPlannedEventTimelines,
<span class="nc" id="L1883">							rtaaData.getActivities(),</span>
<span class="nc" id="L1884">							rtaaData.getParentEventsMap(), orgDaysPerWKRS,</span>
							spDaysPerWKRS, tsStart, tsEnd, true,
							bAdhocDumpEnabled);
<span class="nc" id="L1887">			end = System.currentTimeMillis();</span>
<span class="nc bnc" id="L1888" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1889">				m_cat.debug(&quot;update unplanned event timeline &quot;</span>
						+ &quot; for employees: &quot; + colEmployeeIDs + &quot; cost:&quot;
						+ (end - start));
<span class="nc" id="L1892">			statistic.add(&quot;m_lTotalUnpublishedPlannedEventsDumped&quot;,</span>
<span class="nc" id="L1893">					RTAAUtil.getNumberOfValues(unPubPlannedEvents));</span>
			// we can only dump action and exception till the report dump start
			// time
<span class="nc bnc" id="L1896" title="All 2 branches missed.">			if (TimeZoneUtil.numberOfDays(dateStart, dateEnd) == 14</span>
<span class="nc bnc" id="L1897" title="All 2 branches missed.">					&amp;&amp; dateEnd.after(new Date(System.currentTimeMillis())))</span>
<span class="nc" id="L1898">				return;</span>

			// cut off future actual and exception if there is
<span class="nc bnc" id="L1901" title="All 2 branches missed.">			for (Iterator i = colAdheranceExceptions.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1902">				RTAAException exception = (RTAAException) i.next();</span>
<span class="nc bnc" id="L1903" title="All 2 branches missed.">				if (!exception.getStartTime().before(dateCurrent))</span>
<span class="nc" id="L1904">					i.remove();</span>
				else {
<span class="nc bnc" id="L1906" title="All 2 branches missed.">					if (exception.getEndTime().after(dateCurrent))</span>
<span class="nc" id="L1907">						i.remove();</span>
				}
<span class="nc" id="L1909">			}</span>

<span class="nc bnc" id="L1911" title="All 2 branches missed.">			for (Iterator i = colActualEventsTimeline.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1912">				Event event = (Event) i.next();</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">				if (!event.getStartTime().before(dateCurrent))</span>
<span class="nc" id="L1914">					i.remove();</span>
				else {
<span class="nc bnc" id="L1916" title="All 2 branches missed.">					if (event.getEndTime().after(dateCurrent))</span>
<span class="nc" id="L1917">						i.remove();</span>
				}
<span class="nc" id="L1919">			}</span>

			// update adherenceexception table, need to link to
			// plannedeventtimeline
<span class="nc" id="L1923">			AdherenceExceptionDAO exceptionDAO = new AdherenceExceptionDAO(jdmo);</span>
<span class="nc" id="L1924">			start = System.currentTimeMillis();</span>
<span class="nc" id="L1925">			HashMap exceptionEvents = exceptionDAO.updateAdheranceExceptions(</span>
					colEmployeeIDs, colAdheranceExceptions, pubPlannedEvents,
					tsStart, tsEnd, bAdhocDumpEnabled);
<span class="nc" id="L1928">			end = new Date().getTime();</span>
<span class="nc bnc" id="L1929" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1930">				m_cat.debug(&quot;update adherence exception &quot; + &quot; for employees: &quot;</span>
						+ colEmployeeIDs + &quot; cost:&quot; + (end - start));
<span class="nc" id="L1932">			statistic.add(&quot;m_lTotalAdherenceExceptionsDumped&quot;,</span>
<span class="nc" id="L1933">					RTAAUtil.getNumberOfValues(exceptionEvents));</span>

			// update actualEvent table
<span class="nc" id="L1936">			ActualEventDAO actualDAO = new ActualEventDAO(jdmo);</span>
<span class="nc" id="L1937">			start = System.currentTimeMillis();</span>
<span class="nc" id="L1938">			HashMap actualEvents = actualDAO.updateActualEventsTimeline(</span>
					colEmployeeIDs, colActualEventsTimeline,
<span class="nc" id="L1940">					rtaaData.getParentEventsMap(), orgDaysPerWKRS,</span>
					spDaysPerWKRS, exceptionEvents, tsStart, tsEnd,
					bAdhocDumpEnabled);
<span class="nc" id="L1943">			end = System.currentTimeMillis();</span>
<span class="nc bnc" id="L1944" title="All 2 branches missed.">			if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L1945">				m_cat.debug(&quot;update actual event timeline &quot;</span>
						+ &quot; for employees: &quot; + colEmployeeIDs + &quot; cost:&quot;
						+ (end - start));
<span class="nc" id="L1948">			statistic.add(&quot;m_lTotalActualEventsDumped&quot;,</span>
<span class="nc" id="L1949">					RTAAUtil.getNumberOfValues(actualEvents));</span>
<span class="nc" id="L1950">			statistic.add(&quot;m_lTimeSpentPerCatUpdateRTAAData&quot;,</span>
					(end - startUpdateRTAA));
<span class="nc" id="L1952">		} catch (Exception e) {</span>
			try {
<span class="nc" id="L1954">				userTransaction.rollback();</span>
<span class="nc" id="L1955">			} catch (Exception e2) {</span>
<span class="nc" id="L1956">				handleException(e2);</span>
<span class="nc" id="L1957">			}</span>
<span class="nc" id="L1958">			handleException(e);</span>
<span class="nc" id="L1959">			throw new BbmException(e.getMessage());</span>
<span class="nc" id="L1960">		}</span>
		try {
<span class="nc" id="L1962">			userTransaction.commit();</span>
<span class="nc" id="L1963">		} catch (Exception e) {</span>
<span class="nc" id="L1964">			handleException(e);</span>
<span class="nc" id="L1965">			throw new BbmException(e.getMessage());</span>
		} finally {
<span class="nc" id="L1967">			methodFinish();</span>
<span class="nc" id="L1968">		}</span>
<span class="nc" id="L1969">	}</span>

	private class OrganizationInfo {
		public OrganizationInfo(Organization organization,
				Collection colOrganizationHOOAssignments,
<span class="nc" id="L1974">				Collection colOrganizationHolidays) {</span>
<span class="nc" id="L1975">			m_organization = organization;</span>
<span class="nc" id="L1976">			m_colOrganizationHOOAssignments = colOrganizationHOOAssignments;</span>
<span class="nc" id="L1977">			m_colOrganizationHolidays = colOrganizationHolidays;</span>
<span class="nc" id="L1978">		}</span>

		public Organization getOrganization() {
<span class="nc" id="L1981">			return m_organization;</span>
		}

		public Collection getOrganizationHOOAssignments() {
<span class="nc" id="L1985">			return m_colOrganizationHOOAssignments;</span>
		}

		public Collection getOrganizationHolidays() {
<span class="nc" id="L1989">			return m_colOrganizationHolidays;</span>
		}

		private final Organization m_organization;
		private final Collection m_colOrganizationHOOAssignments;
		private final Collection m_colOrganizationHolidays;
	}

	private void applyTimeoffModificationsToEvents(ID idEmployee,
			Collection colOriginalEvents, Collection colEvents,
			ShiftAssignment shiftAssignmentLast,
			Collection colWorkResourceAssignments, HashMap hmOrganizations,
			HashMap hmOrganizationHOOAssignments,
			HashMap hmOrganizationHolidays, Date dateStart, Date dateEnd)
			throws TimeOffCalculatorException {
<span class="nc" id="L2004">		methodStart(&quot;applyTimeoffModificationsToEvents&quot;, idEmployee,</span>
				shiftAssignmentLast, colWorkResourceAssignments, dateStart,
				dateEnd);
		try {
<span class="nc" id="L2008">			TimeOffHoursManagerBridge bridge = getTimeOffHoursManagerBridge();</span>

<span class="nc bnc" id="L2010" title="All 2 branches missed.">			if (colWorkResourceAssignments == null)</span>
<span class="nc" id="L2011">				return;</span>
<span class="nc bnc" id="L2012" title="All 2 branches missed.">			if (shiftAssignmentLast != null) {</span>
<span class="nc bnc" id="L2013" title="All 2 branches missed.">				if (!shiftAssignmentLast.getStartTime().before(dateEnd))</span>
<span class="nc" id="L2014">					return; // nothing to do</span>
			}
<span class="nc" id="L2016">			TimeZone timeZone = null;</span>
<span class="nc" id="L2017">			int nWeekStartDay = 0;</span>
<span class="nc" id="L2018">			HashMap hmOrganizationInfo = new HashMap();</span>
<span class="nc bnc" id="L2019" title="All 2 branches missed.">			for (Iterator itWorkResourceAssignment = colWorkResourceAssignments.iterator(); itWorkResourceAssignment.hasNext();) {</span>
<span class="nc" id="L2020">				WorkResourceAssignment workResourceAssignment = (WorkResourceAssignment) itWorkResourceAssignment.next();</span>
<span class="nc" id="L2021">				ID idOrganization = workResourceAssignment.getOrganizationID();</span>
<span class="nc" id="L2022">				OrganizationInfo organizationInfo = new OrganizationInfo(</span>
<span class="nc" id="L2023">						(Organization) hmOrganizations.get(idOrganization),</span>
<span class="nc" id="L2024">						(Collection) hmOrganizationHOOAssignments.get(idOrganization),</span>
<span class="nc" id="L2025">						(Collection) hmOrganizationHolidays.get(idOrganization));</span>
<span class="nc" id="L2026">				hmOrganizationInfo.put(idOrganization, organizationInfo);</span>
				// hack, assumes only one affective organization
<span class="nc" id="L2028">				timeZone = organizationInfo.getOrganization().getTimeZone();</span>
<span class="nc" id="L2029">				nWeekStartDay = organizationInfo.getOrganization().getWeekStartDate();</span>
<span class="nc" id="L2030">			}</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">			if (timeZone == null) {</span>
<span class="nc" id="L2032">				return;</span>
			}
<span class="nc" id="L2034">			Date dateWinStart = dateStart;</span>
<span class="nc bnc" id="L2035" title="All 4 branches missed.">			if (shiftAssignmentLast != null &amp;&amp; shiftAssignmentLast.getStartTime().after(dateWinStart)) {</span>
<span class="nc" id="L2036">				TimeZone tzLocal = timeZone;</span>
<span class="nc" id="L2037">				Calendar calLocalWeek = new GregorianCalendar();</span>
<span class="nc" id="L2038">				Calendar calLocalDay = new GregorianCalendar();</span>
<span class="nc" id="L2039">				Date date = shiftAssignmentLast.getStartTime();</span>
<span class="nc" id="L2040">				calLocalDay.setTimeZone(tzLocal);</span>
<span class="nc" id="L2041">				calLocalDay.setTime(date);</span>

<span class="nc" id="L2043">				int nDayOfWeek = calLocalDay.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L2044">				calLocalWeek.setTimeZone(tzLocal);</span>
<span class="nc" id="L2045">				calLocalWeek.setTime(date);</span>

<span class="nc" id="L2047">				calLocalWeek.add(Calendar.DATE, nWeekStartDay - nDayOfWeek);</span>
<span class="nc bnc" id="L2048" title="All 2 branches missed.">				if (calLocalWeek.before(calLocalDay))</span>
<span class="nc" id="L2049">					calLocalWeek.add(Calendar.DATE, 7);</span>

<span class="nc" id="L2051">				dateWinStart = calLocalWeek.getTime();</span>
<span class="nc bnc" id="L2052" title="All 2 branches missed.">				if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2053">					m_cat.debug(&quot;LastShiftAssignment StartTime = &quot;</span>
<span class="nc" id="L2054">							+ shiftAssignmentLast.getStartTime().toString()</span>
							+ &quot;Next Work Week StartTime = &quot;
<span class="nc" id="L2056">							+ dateWinStart.toString());</span>

			}
<span class="nc bnc" id="L2059" title="All 2 branches missed.">			if (!dateWinStart.before(dateEnd)) {</span>
				// nothing to do
<span class="nc" id="L2061">				return;</span>
			}
<span class="nc" id="L2063">			Collection colTimeOffEvents = new LinkedList();</span>
<span class="nc" id="L2064">			Collection colUnavailabilities = new LinkedList();</span>
<span class="nc" id="L2065">			Date dateCalcStart = dateWinStart;</span>
<span class="nc" id="L2066">			Date dateCalcEnd = dateEnd;</span>
<span class="nc bnc" id="L2067" title="All 2 branches missed.">			for (Iterator itEvent = colOriginalEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L2068">				Event event = (Event) itEvent.next();</span>
<span class="nc bnc" id="L2069" title="All 2 branches missed.">				if (event.getEndTime().after(dateWinStart)) {</span>
<span class="nc bnc" id="L2070" title="All 3 branches missed.">					switch (event.getEventType()) {</span>
					case Event.EVENT_TYPE_TIME_OFF:
<span class="nc" id="L2072">						colTimeOffEvents.add(event);</span>
<span class="nc bnc" id="L2073" title="All 2 branches missed.">						if (event.getStartTime().before(dateCalcStart)) {</span>
<span class="nc" id="L2074">							dateCalcStart = event.getStartTime();</span>
						}
<span class="nc bnc" id="L2076" title="All 2 branches missed.">						if (event.getEndTime().after(dateCalcEnd)) {</span>
<span class="nc" id="L2077">							dateCalcEnd = event.getEndTime();</span>
						}
<span class="nc bnc" id="L2079" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2080">							m_cat.debug(&quot;Adding timeoff event: Start = &quot;</span>
<span class="nc" id="L2081">									+ event.getStartTime().toString()</span>
<span class="nc" id="L2082">									+ &quot; End = &quot; + event.getEndTime().toString()</span>
									+ &quot;ActivityID = &quot;
<span class="nc" id="L2084">									+ event.getActivityID().toString());</span>
						}
						break;
					case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="nc" id="L2088">						colUnavailabilities.add(event);</span>
						break;
					}
				}
<span class="nc" id="L2092">			}</span>
<span class="nc" id="L2093">			OrganizationInfo organizationInfo = (OrganizationInfo) hmOrganizationInfo.values().iterator().next();</span>

<span class="nc bnc" id="L2095" title="All 2 branches missed.">			for (Iterator itTimeOffEvent = colTimeOffEvents.iterator(); itTimeOffEvent.hasNext();) {</span>
<span class="nc" id="L2096">				Event eventTimeOff = (Event) itTimeOffEvent.next();</span>
<span class="nc" id="L2097">				Date dateTimeOffStart = eventTimeOff.getStartTime();</span>
<span class="nc" id="L2098">				Date dateTimeOffEnd = eventTimeOff.getEndTime();</span>

<span class="nc" id="L2100">				Date dayStartDateWin = DateTimeUtil.getDayStart(dateWinStart, timeZone);</span>
<span class="nc" id="L2101">				Date dayEndDayEnd = DateTimeUtil.getDayEnd(dateEnd, timeZone);</span>
<span class="nc bnc" id="L2102" title="All 2 branches missed.">				Date toPeriodStart = dateTimeOffStart.before(dayStartDateWin) ? dayStartDateWin : dateTimeOffStart;</span>
<span class="nc bnc" id="L2103" title="All 2 branches missed.">				Date toPeriodEnd = dateTimeOffEnd.after(dayEndDayEnd) ? dayEndDayEnd : dateTimeOffEnd;</span>
<span class="nc" id="L2104">				DailyHoursBuckets dailyHoursBuckets = null;</span>

<span class="nc" id="L2106">				dailyHoursBuckets = bridge.getDailyHoursBucketsForDateRange(</span>
						idEmployee, (TimeOffEvent) eventTimeOff,
<span class="nc" id="L2108">						organizationInfo.getOrganization(), toPeriodStart,</span>
						toPeriodEnd);
<span class="nc bnc" id="L2110" title="All 2 branches missed.">				for (Date date = new Date((toPeriodStart).getTime()); date.before(toPeriodEnd); date.setTime(date.getTime()</span>
						+ (1000L * 60L * 60L * 24))) {
<span class="nc" id="L2112">					Date dateEventStart = new Date(date.getTime());</span>
<span class="nc" id="L2113">					Date dateEventEnd = new Date(date.getTime() + (long) (dailyHoursBuckets.getBucketHours(date) * 60.0 * 60.0 * 1000.0));</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">					if (dateEventEnd.after(dateEventStart)) {</span>
<span class="nc bnc" id="L2115" title="All 2 branches missed.">						if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L2116">							m_cat.debug(&quot;Adding virtual SA: Start = &quot;</span>
<span class="nc" id="L2117">									+ dateEventStart.toString() + &quot; End = &quot;</span>
<span class="nc" id="L2118">									+ dateEventEnd.toString() + &quot;ActivityID = &quot;</span>
<span class="nc" id="L2119">									+ eventTimeOff.getActivityID().toString());</span>
						}

<span class="nc" id="L2122">						SimpleEvent simpleEvent = new SimpleEvent(null,</span>
								Event.EVENT_TYPE_SHIFT_ASSIGNMENT,
								&quot;Shift Assignment Approx for Timeoff Events&quot;,
								dateEventStart, dateEventEnd,
<span class="nc" id="L2126">								eventTimeOff.getActivityID(), false, true,</span>
<span class="nc" id="L2127">								true, eventTimeOff.getWorkResourceIDs(), null);</span>
<span class="nc" id="L2128">						simpleEvent.setOverlayPrecedence(1);</span>
<span class="nc" id="L2129">						colEvents.add(simpleEvent);</span>
					}
				}
<span class="nc" id="L2132">			}</span>
<span class="nc" id="L2133">		} catch (Exception ex) {</span>
<span class="nc" id="L2134">			handleException(ex);</span>
		} finally {
<span class="nc" id="L2136">			methodFinish();</span>
<span class="nc" id="L2137">		}</span>
<span class="nc" id="L2138">	}</span>

	public Collection getModifiedEmployeeIDs(Collection colEmployeeIDsIn,
			Date dateStart, Date dateEnd, Date dateLastUpdated)
			throws JdmoException {
<span class="nc" id="L2143">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L2145">			return getModifiedEmployeeIDs(colEmployeeIDsIn, dateStart, dateEnd,</span>
<span class="nc" id="L2146">					dateLastUpdated, jdmo, getCurrentTime());</span>
		} finally {
<span class="nc" id="L2148">			jdmo.cleanUp();</span>
		}
	}

	private Collection getModifiedEmployeeIDs(Collection colEmployeeIDsIn,
			Date dateStart, Date dateEnd, Date dateLastUpdated, Jdmo jdmo,
			Date dateCurrent) throws JdmoException {
<span class="nc" id="L2155">		methodStart(&quot;getModifiedEmployeeIDs&quot;, colEmployeeIDsIn, dateStart,</span>
				dateEnd);

<span class="nc" id="L2158">		Collection colUniqueEmployeeIDs = new HashSet(colEmployeeIDsIn);</span>
<span class="nc" id="L2159">		Timestamp tsStart = new Timestamp(dateStart.getTime());</span>
<span class="nc" id="L2160">		Timestamp tsEnd = new Timestamp(dateEnd.getTime());</span>
<span class="nc" id="L2161">		Timestamp tsLastUpdated = new Timestamp(dateLastUpdated.getTime());</span>
<span class="nc" id="L2162">		Timestamp tsCurrent = new Timestamp(dateCurrent.getTime());</span>

<span class="nc" id="L2164">		String inputEmpIDsTempTableName = null;</span>
<span class="nc" id="L2165">		String distinctOutputEmpIDsTempTableName = null;</span>
		try {

<span class="nc" id="L2168">			Collection colModifiedEmployeeIDs = new LinkedList();</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">			if (colUniqueEmployeeIDs.isEmpty()) {</span>
<span class="nc" id="L2170">				return colModifiedEmployeeIDs;</span>
			}

<span class="nc" id="L2173">			inputEmpIDsTempTableName = createTempTableForUniqueIntIDs(&quot;emp&quot;, jdmo, colUniqueEmployeeIDs);</span>
<span class="nc" id="L2174">			distinctOutputEmpIDsTempTableName = createTempTableForUniqueIntIDs(&quot;uEmp&quot;, jdmo, new ArrayList());</span>
			{
<span class="nc" id="L2176">				String strQuery = &quot; insert into &quot; + distinctOutputEmpIDsTempTableName + &quot; (ID) &quot;</span>
						+ &quot; select PRIMARYOBJECTID &quot;
						+ &quot; from AUDITTRAILENTRY A &quot;
						+ &quot; inner join &quot; + inputEmpIDsTempTableName + &quot; T on A.PRIMARYOBJECTID = T.ID&quot;
						+ &quot; where ATWHEN &gt; &quot;
<span class="nc" id="L2181">						+ formatDBString(tsLastUpdated, jdmo)</span>
<span class="nc" id="L2182">						+ &quot; and ATWHEN &lt; &quot; + formatDBString(tsCurrent, jdmo)</span>
<span class="nc" id="L2183">						+ &quot; and IMPACTEND &gt; &quot; + formatDBString(tsStart, jdmo)</span>
<span class="nc" id="L2184">						+ &quot; and IMPACTSTART &lt; &quot; + formatDBString(tsEnd, jdmo)</span>
						+ &quot; and MODULEID in (1, 2) &quot;; // 1 - scheduling model; 2
														// - publishing model
<span class="nc" id="L2187">				jdmo.execute(strQuery);</span>
			}
			{
<span class="nc" id="L2190">				String strQuery = &quot; insert into &quot; + distinctOutputEmpIDsTempTableName + &quot; (ID) &quot;</span>
						+ &quot; select EMPLOYEEID from TIMEENTRYEVENT TEE &quot;
						+ &quot; inner join &quot; + inputEmpIDsTempTableName + &quot; T on TEE.EMPLOYEEID = T.ID&quot;
						+ &quot; where UPDATETIMESTAMP between &quot;
<span class="nc" id="L2194">						+ tsStart.getTime()</span>
						+ &quot; and &quot;
<span class="nc" id="L2196">						+ tsEnd.getTime()</span>
						+ &quot; and LASTMODIFIEDAT &gt; &quot;
<span class="nc" id="L2198">						+ formatDBString(tsLastUpdated, jdmo)</span>
						+ &quot; and LASTMODIFIEDAT &lt; &quot;
<span class="nc" id="L2200">						+ formatDBString(tsCurrent, jdmo);</span>
<span class="nc" id="L2201">				jdmo.execute(strQuery);</span>
			}

			{
<span class="nc" id="L2205">				String strQuery = &quot; insert into &quot; + distinctOutputEmpIDsTempTableName + &quot; (ID) &quot;</span>
						+ &quot; select EMPLOYEEID from ADHERENCEOVERRIDE A &quot;
						+ &quot; inner join &quot; + inputEmpIDsTempTableName + &quot; T on A.EMPLOYEEID = T.ID&quot;
						+ &quot; where ENDTIME &gt; &quot;
<span class="nc" id="L2209">						+ formatDBString(tsStart, jdmo)</span>
						+ &quot; and STARTTIME &lt; &quot;
<span class="nc" id="L2211">						+ formatDBString(tsEnd, jdmo)</span>
						+ &quot; and LASTMODIFIEDAT &gt; &quot;
<span class="nc" id="L2213">						+ formatDBString(tsLastUpdated, jdmo)</span>
						+ &quot; and LASTMODIFIEDAT &lt; &quot;
<span class="nc" id="L2215">						+ formatDBString(tsCurrent, jdmo);</span>
<span class="nc" id="L2216">				jdmo.execute(strQuery);</span>
			}
<span class="nc" id="L2218">			JdmoRowset r = jdmo.createRowset(&quot;select ID from &quot; + distinctOutputEmpIDsTempTableName + &quot; order by ID&quot;);</span>
<span class="nc bnc" id="L2219" title="All 2 branches missed.">			while (r.next())</span>
			{
<span class="nc" id="L2221">				ID idEmployee = r.getID(&quot;ID&quot;);</span>
<span class="nc" id="L2222">				colModifiedEmployeeIDs.add(idEmployee);</span>
<span class="nc" id="L2223">			}</span>

<span class="nc" id="L2225">			return colModifiedEmployeeIDs;</span>
		} finally {
<span class="nc bnc" id="L2227" title="All 6 branches missed.">			if (inputEmpIDsTempTableName != null)</span>
<span class="nc" id="L2228">				jdmo.execute(&quot;IF (OBJECT_ID('tempdb..&quot;+ inputEmpIDsTempTableName + &quot;')) IS NOT NULL DROP TABLE &quot;+ inputEmpIDsTempTableName + &quot; ;&quot;);</span>
<span class="nc bnc" id="L2229" title="All 6 branches missed.">			if (distinctOutputEmpIDsTempTableName != null)</span>
<span class="nc" id="L2230">				jdmo.execute(&quot;IF (OBJECT_ID('tempdb..&quot;+ distinctOutputEmpIDsTempTableName + &quot;')) IS NOT NULL DROP TABLE &quot;+ distinctOutputEmpIDsTempTableName + &quot; ;&quot;);</span>
<span class="nc" id="L2231">			jdmo.cleanUp();</span>
<span class="nc" id="L2232">			methodFinish();</span>
		}
	}

	private String createTempTableForUniqueIntIDs(String prefix, Jdmo jdmo, Collection&lt;ID&gt; uniqueIDs) throws JdmoException {
		try {
<span class="nc" id="L2238">			String origName = prefix + &quot;GetModifiedEmployeeTempTable&quot;;</span>
<span class="nc" id="L2239">			String strTemptableName = jdmo.getNativeTemptableName(origName);</span>
<span class="nc" id="L2240">			jdmo.createTempTable(strTemptableName + &quot; (ID int)&quot;);</span>
<span class="nc" id="L2241">			jdmo.execute(&quot;CREATE UNIQUE CLUSTERED INDEX index&quot; + origName + &quot; ON &quot; + strTemptableName + &quot; (ID) with ignore_dup_key&quot;);</span>

			//for oracle and sql server, preparedStatement is more faster than Statement.
<span class="nc" id="L2244">			JdmoPCommand pc = jdmo.createPCommand(&quot;insert into &quot;+strTemptableName+&quot; values(?)&quot;);</span>
<span class="nc" id="L2245">			HashMap param = new HashMap();</span>
<span class="nc" id="L2246">			int ix = 0;</span>
<span class="nc bnc" id="L2247" title="All 2 branches missed.">			for (ID id : uniqueIDs) {</span>
<span class="nc" id="L2248">				param.clear();</span>
<span class="nc" id="L2249">				param.put(new Integer(1), new Integer(id.toInt()));</span>
<span class="nc" id="L2250">				pc.setParams(param);</span>
<span class="nc" id="L2251">				pc.addBatch();</span>
<span class="nc" id="L2252">			}</span>
<span class="nc" id="L2253">			jdmo.executeBatchPCommand(pc);</span>

<span class="nc" id="L2255">			return strTemptableName;</span>
<span class="nc" id="L2256">		} catch(SQLException e) {</span>
<span class="nc" id="L2257">			throw new JdmoException(e);</span>
		}
	}

	String getDateString(Date date) {
<span class="nc bnc" id="L2262" title="All 2 branches missed.">		if (date == null)</span>
<span class="nc" id="L2263">			return &quot;null&quot;;</span>
<span class="nc" id="L2264">		return date.toString();</span>
	}

	static private class EmployeeLastUpdatedGroup {
<span class="nc" id="L2268">		private final Collection m_colEmployeeIDs = new LinkedList();</span>
<span class="nc" id="L2269">		private Date m_dateLastUpdated = null;</span>

<span class="nc" id="L2271">		public EmployeeLastUpdatedGroup(Date dateLastUpdated) {</span>
<span class="nc" id="L2272">			m_dateLastUpdated = dateLastUpdated;</span>
<span class="nc" id="L2273">		}</span>

		public void updateLastUpdatedDate(Date dateLastUpdated) {
<span class="nc bnc" id="L2276" title="All 2 branches missed.">			if (dateLastUpdated != null</span>
<span class="nc bnc" id="L2277" title="All 2 branches missed.">					&amp;&amp; dateLastUpdated.before(m_dateLastUpdated))</span>
<span class="nc" id="L2278">				m_dateLastUpdated = dateLastUpdated;</span>
<span class="nc" id="L2279">		}</span>

		public Date getLastUpdatedDate() {
<span class="nc" id="L2282">			return m_dateLastUpdated;</span>
		}

		public void addEmployee(ID idEmployee) {
<span class="nc" id="L2286">			m_colEmployeeIDs.add(idEmployee);</span>
<span class="nc" id="L2287">		}</span>

		public Collection getEmployeeIDs() {
<span class="nc" id="L2290">			return m_colEmployeeIDs;</span>
		}
	}

	private Collection dumpReportDataInner(Collection colEmployeeIDs,
			Date dateStart, Date dateEnd, Date dateLastUpdated, Jdmo jdmo,
			Date dateCurrent) throws BbmFinderException, BbmUpdateException,
			BbmException, JdmoException, BbmException, RemoteException {
<span class="nc" id="L2298">		return dumpReportDataInner(colEmployeeIDs, dateStart, dateEnd,</span>
				dateLastUpdated, jdmo, false, dateCurrent);
	}

	private Collection dumpReportDataInner(Collection colEmployeeIDs,
			Date dateStart, Date dateEnd, Date dateLastUpdated, Jdmo jdmo,
			boolean isDumpNoAuditEntryButHasShiftEmployee, Date dateCurrent)
			throws BbmFinderException, BbmUpdateException, BbmException,
			JdmoException, BbmException, RemoteException {
<span class="nc" id="L2307">		methodStart(&quot;dumpReportDataInner&quot;, colEmployeeIDs, dateStart, dateEnd,</span>
				dateLastUpdated);
		// m_cat.info(&quot;begin: dumpReportDataInner (&quot; + colEmployeeIDs.size() +
		// &quot;) start = &quot; + dateStart + &quot;, end = &quot; + dateEnd + &quot;, LastUpdated = &quot;
		// + dateLastUpdated);

<span class="nc" id="L2313">		Date dateStartTimer = Calendar.getInstance().getTime();</span>
<span class="nc" id="L2314">		Collection colEmployeeIDsFailed = new LinkedList();</span>
<span class="nc" id="L2315">		Collection colModifiedEmployeeIDs = null;</span>

		try {

			// Collection colModifiedEmployeeIDs =
			// getModifiedEmployeeIDs(colEmployeeIDs, dateStart, dateEnd,
			// dateLastUpdated, jdmo);
<span class="nc" id="L2322">			int nRetry = 0;</span>
<span class="nc bnc" id="L2323" title="All 2 branches missed.">			for (; !m_dbConfigManager.isTemporarilyStopReportDump(); nRetry++) {</span>
				try {
<span class="nc" id="L2325">					colModifiedEmployeeIDs = getModifiedEmployeeIDs(</span>
							colEmployeeIDs, dateStart, dateEnd,
							dateLastUpdated, jdmo, dateCurrent);
<span class="nc bnc" id="L2328" title="All 4 branches missed.">					if (isDumpNoAuditEntryButHasShiftEmployee || whatIfMode) {</span>
<span class="nc" id="L2329">						ArrayList doubleCheckEmployeeIDs = new ArrayList(colEmployeeIDs);</span>
<span class="nc" id="L2330">						doubleCheckEmployeeIDs.removeAll(colModifiedEmployeeIDs);</span>
<span class="nc bnc" id="L2331" title="All 2 branches missed.">						if (!doubleCheckEmployeeIDs.isEmpty()) {</span>
<span class="nc" id="L2332">							StringBuffer sb = new StringBuffer(200);</span>
<span class="nc bnc" id="L2333" title="All 2 branches missed.">							sb.append(&quot; select distinct workresourceid from &quot;)</span>
<span class="nc" id="L2334">									.append(whatIfMode ? &quot;shiftassignment&quot; : &quot;shiftassignmentpub&quot;)</span>
<span class="nc" id="L2335">									.append(&quot; where workresourceid in &quot;)</span>
<span class="nc" id="L2336">									.append(jdmo.createInClause(doubleCheckEmployeeIDs));</span>
<span class="nc" id="L2337">							sb.append(&quot; and starttime &lt; '&quot;)</span>
<span class="nc" id="L2338">									.append(JdmoUtil.formatDBString(dateEnd))</span>
<span class="nc" id="L2339">									.append(&quot;'&quot;);</span>
<span class="nc" id="L2340">							sb.append(&quot; and &quot;)</span>
<span class="nc" id="L2341">									.append(jdmo.dateAddMinutes(&quot;DURATION&quot;,</span>
											&quot;STARTTIME&quot;));
<span class="nc" id="L2343">							sb.append(</span>
<span class="nc" id="L2344">									&quot; &gt; '&quot; + JdmoUtil.formatDBString(dateStart))</span>
<span class="nc" id="L2345">									.append(&quot;'&quot;);</span>

<span class="nc" id="L2347">							JdmoRowset rs = jdmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">							while (rs.next()) {</span>
<span class="nc" id="L2349">								colModifiedEmployeeIDs.add(rs.getID(1));</span>
							}
						}
					}
<span class="nc" id="L2353">				} catch (JdmoException e) {</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">					if (nRetry &lt; REPORTDUMP_MAX_RETRY)</span>
<span class="nc" id="L2355">						continue;</span>
<span class="nc" id="L2356">					m_cat.info(&quot;Report Dump fails to getModifiedEmployeeIDs after retrying &quot;</span>
							+ nRetry + &quot; times&quot;);
<span class="nc" id="L2358">					throw e;</span>
<span class="nc" id="L2359">				}</span>
				break;
			}

			// Collections.sort((List)colModifiedEmployeeIDs);

<span class="nc bnc" id="L2365" title="All 2 branches missed.">			if (colModifiedEmployeeIDs.isEmpty())</span>
<span class="nc" id="L2366">				return colEmployeeIDsFailed;</span>

<span class="nc" id="L2368">			colEmployeeIDsFailed.addAll(dumpReportDataInnerInner(</span>
					colModifiedEmployeeIDs, dateStart, dateEnd, jdmo,
					dateCurrent));
<span class="nc" id="L2371">			m_colFailedEmployeeIDs.addAll(colEmployeeIDsFailed);</span>
<span class="nc" id="L2372">			colModifiedEmployeeIDs.removeAll(colEmployeeIDsFailed);</span>
<span class="nc" id="L2373">			m_cat.info(&quot;Stats: Inner Chunk dumped - Total: &quot;</span>
<span class="nc" id="L2374">					+ colEmployeeIDs.size() + &quot;, Modified: &quot;</span>
<span class="nc" id="L2375">					+ colModifiedEmployeeIDs.size() + &quot;, Failed: &quot;</span>
<span class="nc" id="L2376">					+ colEmployeeIDsFailed.size() + &quot;, Start: &quot; + dateStart</span>
					+ &quot;, End: &quot; + dateEnd + &quot;, LastUpdated: &quot; + dateLastUpdated);
<span class="nc" id="L2378">			return colEmployeeIDsFailed;</span>

		} finally {
<span class="nc" id="L2381">			String threadID = &quot;[unknown]&quot;;</span>
<span class="nc" id="L2382">			String threadName = Thread.currentThread().getName();</span>
<span class="nc bnc" id="L2383" title="All 6 branches missed.">			if(m_threadIDsFromThreadNames.get(threadName) != null)</span>
<span class="nc" id="L2384">					threadID = &quot;&quot; + m_threadIDsFromThreadNames.get(threadName);</span>
<span class="nc" id="L2385">			AuditTrailEntry entry = new AuditTrailEntry(</span>
					AuditTrailEntry.MODULE_ADAPTER,
					AuditTrailEntry.ACTION_RTAA_CHUNK_FINISH,
					new ID(0),
					&quot;RTAA Thread &quot;+threadID,
					dateStart, dateEnd);
			
<span class="nc" id="L2392">			SimpleDateFormat sdf = new SimpleDateFormat(&quot;MM/dd/yyyy HH:mm:ss&quot;);</span>
<span class="nc" id="L2393">			Date dateEndTimer = Calendar.getInstance().getTime();</span>
			
<span class="nc" id="L2395">			entry.addProperty(&quot;Start Time&quot;, sdf.format(dateStartTimer), &quot;datetime&quot;, false);</span>
<span class="nc" id="L2396">			entry.addProperty(&quot;End Time&quot;, sdf.format(dateEndTimer), &quot;datetime&quot;, false);</span>
<span class="nc" id="L2397">			entry.addProperty(&quot;Total&quot;, &quot;&quot;+colEmployeeIDs.size(), &quot;int&quot;, false);</span>
<span class="nc bnc" id="L2398" title="All 6 branches missed.">			if(colModifiedEmployeeIDs != null)</span>
<span class="nc" id="L2399">				entry.addProperty(&quot;Modified&quot;, &quot;&quot;+colModifiedEmployeeIDs.size(), &quot;int&quot;, false);</span>
			else
<span class="nc" id="L2401">				entry.addProperty(&quot;Modified&quot;, &quot;0&quot;, &quot;int&quot;, false);</span>
<span class="nc" id="L2402">			entry.addProperty(&quot;Failed&quot;, &quot;&quot;+colEmployeeIDsFailed.size(), &quot;int&quot;, false);</span>
<span class="nc" id="L2403">			entry.addProperty(&quot;Impact Start&quot;, sdf.format(dateStart), &quot;datetime&quot;, false);</span>
<span class="nc" id="L2404">			entry.addProperty(&quot;Impact End&quot;, sdf.format(dateEnd), &quot;datetime&quot;, false);</span>
<span class="nc" id="L2405">			entry.addProperty(&quot;LastUpdated&quot;, sdf.format(dateLastUpdated), &quot;datetime&quot;, false);</span>
			
			try
			{
<span class="nc" id="L2409">				BbmManagerFactory.getEventAuditTrailManager().createAuditEntry(entry);</span>
			}
<span class="nc" id="L2411">			catch (Exception e)</span>
			{
<span class="nc" id="L2413">				m_cat.warn(&quot;Exception occurred during audit of RTAA Thread.&quot;);</span>
			}
			finally
			{
<span class="nc" id="L2417">				jdmo.cleanUp();</span>
<span class="nc" id="L2418">				methodFinish();</span>
<span class="nc" id="L2419">			}</span>
<span class="nc" id="L2420">		}</span>
	}

	private void dumpReportData(Collection colEmployeeIDs, Date dateStart,
			Date dateEnd, Jdmo jdmo, boolean bFullDump)
			throws BbmFinderException, BbmUpdateException, BbmException,
			JdmoException, BbmException, RemoteException {
<span class="nc" id="L2427">		methodStart(&quot;dumpReportData&quot;, colEmployeeIDs, dateStart, dateEnd);</span>

<span class="nc" id="L2429">		int nReportDumpChunkSize2 = 14;</span>
		/*
		 * try { nReportDumpChunkSize2 =
		 * m_dbConfigManager.getIntValue(ConfigKey.
		 * CRYSTAL_REPORTS_DUMP_CHUNK_SIZE2); if (nReportDumpChunkSize2 &lt; 0)
		 * nReportDumpChunkSize2 = 14; } catch (Exception e) { }
		 */

		// m_cat.info(&quot;Begin: dumpReportData (&quot; + colEmployeeIDs.size() +
		// &quot;) , WinStart: &quot; + dateStart + &quot; WinEnd: &quot; + dateEnd +
		// &quot;, TimeChunkSize(days) = &quot; + new Integer(nReportDumpChunkSize2));
		try {
<span class="nc" id="L2441">			Date dateAbsEnd = new Date(((dateEnd.getTime() + (1000L * 60L * 60L</span>
					* 24L * 365L * 2L)) / (1000L * 60L * 60L * 24L * 365L))
					* (1000L * 60L * 60L * 24L * 365L));
<span class="nc" id="L2444">			m_hmLastShiftAssignments = new HashMap();</span>
<span class="nc" id="L2445">			m_colFailedEmployeeIDs = new LinkedList();</span>
<span class="nc" id="L2446">			m_colFailedEmployeeFilterIDs = new LinkedList();</span>

<span class="nc" id="L2448">			Date dateCurrent = getCurrentTime();</span>
<span class="nc" id="L2449">			Date dateStartTiming = Calendar.getInstance().getTime();</span>

<span class="nc" id="L2451">			Collection colTerminatedEmployeeIDs = getTerminatedEmployees(</span>
<span class="nc" id="L2452">					colEmployeeIDs, new Timestamp(dateStart.getTime()), jdmo);</span>

<span class="nc" id="L2454">			Collection colTerminatedEmployeesWithoutPlannedEvents = getEmployeesWithoutPlannedEvents(</span>
					// flag -- could it timeout?
					colTerminatedEmployeeIDs,
<span class="nc" id="L2457">					new Timestamp(dateStart.getTime()),</span>
<span class="nc" id="L2458">					new Timestamp(dateEnd.getTime()), jdmo);</span>

<span class="nc" id="L2460">			colEmployeeIDs</span>
<span class="nc" id="L2461">					.removeAll(colTerminatedEmployeesWithoutPlannedEvents);</span>

<span class="nc" id="L2463">			initializeDumpTimelineLastUpdatedDate(colEmployeeIDs, jdmo);</span>

<span class="nc" id="L2465">			Collection colActivityIDs = m_activityManager</span>
<span class="nc" id="L2466">					.findActivitiesIds(new ActivityFilter(</span>
							ActivityFilter.FILTER_NONE));
<span class="nc" id="L2468">			HashMap hmActivities = loadActivities(colActivityIDs);</span>

<span class="nc" id="L2470">			Date dateEndTiming = Calendar.getInstance().getTime();</span>
			// m_lTimeSpentPerCatInitialize += dateEndTiming.getTime() -
			// dateStartTiming.getTime();
<span class="nc" id="L2473">			statistic.add(&quot;m_lTimeSpentPerCatInitialize&quot;,</span>
<span class="nc" id="L2474">					dateEndTiming.getTime() - dateStartTiming.getTime());</span>
<span class="nc" id="L2475">			Collection colFailedEmployeeIDs = new LinkedList();</span>

<span class="nc" id="L2477">			HashMap hmLastUpdatedWindows = getDumpTimelineLastUpdatedWindows(</span>
<span class="nc" id="L2478">					colEmployeeIDs, new Timestamp(dateStart.getTime()),</span>
<span class="nc" id="L2479">					new Timestamp(dateEnd.getTime()), jdmo);</span>

<span class="nc" id="L2481">			HashMap hmEmployeeLastUpdatedGroups = new HashMap();</span>
<span class="nc" id="L2482">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L2483" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L2484">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L2485">				LastUpdatedWindow lastUpdatedWindow = (LastUpdatedWindow) hmLastUpdatedWindows</span>
<span class="nc" id="L2486">						.get(idEmployee);</span>

<span class="nc" id="L2488">				Date dateLastUpdated = null;</span>
<span class="nc bnc" id="L2489" title="All 2 branches missed.">				if (lastUpdatedWindow != null)</span>
<span class="nc" id="L2490">					dateLastUpdated = lastUpdatedWindow.getLastUpdatedDate();</span>
				else {
<span class="nc" id="L2492">					m_cat.info(&quot;lastUpdatedWindow = null for employeeid: &quot;</span>
							+ idEmployee);
				}

<span class="nc bnc" id="L2496" title="All 2 branches missed.">				if (dateLastUpdated == null) {</span>
<span class="nc" id="L2497">					m_cat.info(&quot;dateLastUpdated = null for employeeid: &quot;</span>
							+ idEmployee);
<span class="nc" id="L2499">					dateLastUpdated = new Date(0);</span>
				}
<span class="nc" id="L2501">				Date dateEmployeeLastUpdatedGroupKey = null;</span>
<span class="nc" id="L2502">				dateEmployeeLastUpdatedGroupKey = new Date(</span>
<span class="nc" id="L2503">						(dateLastUpdated.getTime() / (1000 * 60 * 60 * 12))</span>
								* (1000 * 60 * 60 * 12));
				// floor to five minute interval

<span class="nc" id="L2507">				EmployeeLastUpdatedGroup employeeLastUpdatedGroup = null;</span>
<span class="nc" id="L2508">				if (hmEmployeeLastUpdatedGroups</span>
<span class="nc bnc" id="L2509" title="All 2 branches missed.">						.containsKey(dateEmployeeLastUpdatedGroupKey)) {</span>
<span class="nc" id="L2510">					employeeLastUpdatedGroup = (EmployeeLastUpdatedGroup) hmEmployeeLastUpdatedGroups</span>
<span class="nc" id="L2511">							.get(dateEmployeeLastUpdatedGroupKey);</span>
<span class="nc" id="L2512">					employeeLastUpdatedGroup</span>
<span class="nc" id="L2513">							.updateLastUpdatedDate(dateLastUpdated);</span>

				} else {
<span class="nc" id="L2516">					employeeLastUpdatedGroup = new EmployeeLastUpdatedGroup(</span>
							dateLastUpdated);
<span class="nc" id="L2518">					hmEmployeeLastUpdatedGroups.put(</span>
							dateEmployeeLastUpdatedGroupKey,
							employeeLastUpdatedGroup);
				}
<span class="nc" id="L2522">				employeeLastUpdatedGroup.addEmployee(idEmployee);</span>
<span class="nc" id="L2523">			}</span>

<span class="nc" id="L2525">			Collection colEmployeeIDsFailed = new LinkedList();</span>
<span class="nc" id="L2526">			Collection colEmployeeLastUpdatedGroupKeys = hmEmployeeLastUpdatedGroups</span>
<span class="nc" id="L2527">					.keySet();</span>

<span class="nc" id="L2529">			for (Iterator itEmployeeLastUpdatedGroupKey = colEmployeeLastUpdatedGroupKeys</span>
<span class="nc bnc" id="L2530" title="All 2 branches missed.">					.iterator(); itEmployeeLastUpdatedGroupKey.hasNext();) {</span>
<span class="nc" id="L2531">				Date dateEmployeeLastUpdatedGroupKey = (Date) itEmployeeLastUpdatedGroupKey</span>
<span class="nc" id="L2532">						.next();</span>
<span class="nc" id="L2533">				EmployeeLastUpdatedGroup employeeLastUpdatedGroup = (EmployeeLastUpdatedGroup) hmEmployeeLastUpdatedGroups</span>
<span class="nc" id="L2534">						.get(dateEmployeeLastUpdatedGroupKey);</span>
<span class="nc" id="L2535">				Collection colEmployeeIDsWithSameLastUpdatedDate = employeeLastUpdatedGroup</span>
<span class="nc" id="L2536">						.getEmployeeIDs();</span>

<span class="nc" id="L2538">				Collection colEmployeeIDsChunk = colEmployeeIDsWithSameLastUpdatedDate;</span>
<span class="nc" id="L2539">				Date dateLastUpdated = employeeLastUpdatedGroup</span>
<span class="nc" id="L2540">						.getLastUpdatedDate();</span>

				/*
				 * Changes for QA98412 To fix the issue when DumpReportData
				 * servlet is ignoring End Date value and dumping to the current
				 * day instead
				 */

<span class="nc bnc" id="L2548" title="All 4 branches missed.">				if (dateEnd != null &amp;&amp; dateCurrent.after(dateEnd)) {</span>
<span class="nc bnc" id="L2549" title="All 2 branches missed.">					if (m_dbConfigManager.isTemporarilyStopReportDump())</span>
<span class="nc" id="L2550">						return;</span>
<span class="nc" id="L2551">					m_cat.info(&quot;As endDate is not null, it will be dumping only data for specified startDate &amp; EndDate and no&quot; +</span>
						&quot; incremental and future dump&quot;);
<span class="nc" id="L2553">					colFailedEmployeeIDs.addAll(dumpReportDataInner(</span>
							colEmployeeIDsChunk, dateStart, dateEnd,
							new Date(0), jdmo, dateCurrent));

<span class="nc" id="L2557">					m_cat.info(&quot;Stats: Size = &quot;</span>
<span class="nc" id="L2558">							+ new Integer(colEmployeeIDsChunk.size())</span>
							+ &quot;, Failed = &quot;
<span class="nc" id="L2560">							+ new Integer(colFailedEmployeeIDs.size()));</span>
<span class="nc" id="L2561">					return;</span>
				}
				// Changes End for QA98412

<span class="nc" id="L2565">				Collection dumpToCur = new ArrayList(colEmployeeIDsChunk);</span>
				// if default time off hour count changed, it has to be full
				// dump here
<span class="nc" id="L2568">				Collection empDefaultTimeOffHourCountChanged = getEmployeesWhosDefaultTimeOffHourCountChanged(</span>
						dumpToCur, dateLastUpdated, jdmo);
<span class="nc bnc" id="L2570" title="All 2 branches missed.">				if (!empDefaultTimeOffHourCountChanged.isEmpty()) {</span>
<span class="nc" id="L2571">					m_cat.info(&quot;Time Off hours have changed, full dump to current time&quot;);</span>
<span class="nc" id="L2572">					colFailedEmployeeIDs.addAll(dumpReportDataInner(</span>
							empDefaultTimeOffHourCountChanged, dateStart,
							dateCurrent, dateLastUpdated, jdmo, dateCurrent));
<span class="nc" id="L2575">					dumpToCur.removeAll(empDefaultTimeOffHourCountChanged);</span>
				}

<span class="nc" id="L2578">				Date dateLast = dateLastUpdated;</span>
<span class="nc bnc" id="L2579" title="All 2 branches missed.">				if (dateLast.before(dateStart)) {</span>
<span class="nc" id="L2580">					dateLast = dateStart;</span>
				}

<span class="nc bnc" id="L2583" title="All 2 branches missed.">				if (dateLast.before(dateCurrent)) {</span>
<span class="nc" id="L2584">					m_cat.info(&quot;Begin incremental dump to current time: &quot;);</span>
					// special handle this period, for the employee who has no
					// audit event, but has shift scheduled, his events
					// should be redump here to create adherence exception.
<span class="nc" id="L2588">					colFailedEmployeeIDs.addAll(dumpReportDataInner(dumpToCur,</span>
							dateLast, dateCurrent, dateLastUpdated, jdmo, true,
							dateCurrent));
				}
<span class="nc" id="L2592">				for (Date date = new Date(dateLast.getTime()); date</span>
<span class="nc bnc" id="L2593" title="All 2 branches missed.">						.after(dateStart);) {</span>
<span class="nc" id="L2594">					Date dateWinEnd = new Date(date.getTime());</span>
<span class="nc" id="L2595">					date.setTime(date.getTime()</span>
							- (1000l * 60l * 60l * 24l * nReportDumpChunkSize2)); // dump
																							// backward
																							// 14
																							// days
																							// a
																							// chuck
																							// to
																							// the
																							// specified
																							// start
																							// date
<span class="nc" id="L2607">					Date dateWinStart = date;</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">					if (dateWinStart.before(dateStart)) {</span>
<span class="nc" id="L2609">						dateWinStart = dateStart;</span>
					}
<span class="nc" id="L2611">					colFailedEmployeeIDs.addAll(dumpReportDataInner(dumpToCur,</span>
							dateWinStart, dateWinEnd, dateLastUpdated, jdmo,
							dateCurrent));
<span class="nc" id="L2614">				}</span>

<span class="nc" id="L2616">				m_cat.info(&quot;Begin incremental dump from current time to future&quot;);</span>
<span class="nc" id="L2617">				for (Date date = new Date(dateCurrent.getTime()); date</span>
<span class="nc bnc" id="L2618" title="All 2 branches missed.">						.before(dateEnd);) {</span>
<span class="nc" id="L2619">					Date dateWinStart = new Date(date.getTime());</span>
<span class="nc" id="L2620">					date.setTime(date.getTime()</span>
							+ (1000l * 60l * 60l * 24l * nReportDumpChunkSize2));
<span class="nc" id="L2622">					Date dateWinEnd = date;</span>
<span class="nc bnc" id="L2623" title="All 2 branches missed.">					if (dateWinEnd.after(dateEnd))</span>
<span class="nc" id="L2624">						dateWinEnd = dateEnd;</span>

<span class="nc" id="L2626">					colFailedEmployeeIDs.addAll(dumpReportDataInner(</span>
							colEmployeeIDsChunk, dateWinStart, dateWinEnd,
							dateLastUpdated, jdmo, dateCurrent));
<span class="nc" id="L2629">				}</span>
<span class="nc bnc" id="L2630" title="All 2 branches missed.">				if (bFullDump) {</span>
<span class="nc" id="L2631">					colFailedEmployeeIDs.addAll(dumpReportDataInner(</span>
							colEmployeeIDsChunk, dateEnd, dateAbsEnd,
							dateLastUpdated, jdmo, dateCurrent));
				}

<span class="nc" id="L2636">				m_cat.info(&quot;Stats: Last updated group passed - lastUpdated = &quot;</span>
						+ dateLastUpdated + &quot;, Size = &quot;
<span class="nc" id="L2638">						+ new Integer(colEmployeeIDsChunk.size())</span>
						+ &quot;, Failed = &quot;
<span class="nc" id="L2640">						+ new Integer(colFailedEmployeeIDs.size()));</span>
<span class="nc" id="L2641">			}</span>
<span class="nc bnc" id="L2642" title="All 2 branches missed.">			if (bFullDump) {</span>

				try {

<span class="nc" id="L2646">					Collection colPassedEmployeeIDs = new LinkedList(</span>
							colEmployeeIDs);
<span class="nc" id="L2648">					colPassedEmployeeIDs.removeAll(colFailedEmployeeIDs);</span>
<span class="nc" id="L2649">					updateDumpTimelineLastUpdatedDate(colPassedEmployeeIDs,</span>
<span class="nc" id="L2650">							new Timestamp(dateStart.getTime()), new Timestamp(</span>
<span class="nc" id="L2651">									dateAbsEnd.getTime()), jdmo, dateCurrent);// QA101543</span>
																				// setting
																				// lastmodifiedat
																				// to
																				// the
																				// start
																				// of
																				// report
																				// dump
<span class="nc" id="L2660">				} catch (Exception e) {</span>
<span class="nc" id="L2661">					m_cat.info(&quot;ERROR: failed to update reportdump timestamp&quot;);</span>
<span class="nc" id="L2662">				}</span>
				// execute a stored procedure to delete data
			}

		}

		finally {
<span class="nc" id="L2669">			methodFinish();</span>
<span class="nc" id="L2670">		}</span>

		// group employees based on latest modified date.

		// for each employee group,
		// sub group employees into those who have changes before their last
		// modified
		// date and those who have changes after last modified date

		// call inner dumpReport data for subgroup
		// dateStart = earliest changed
<span class="nc" id="L2681">	}</span>

	private Collection dumpReportDataInnerInner(Collection colEmployeeIDs,
			Date dateStart, Date dateEnd, Jdmo jdmo, Date dateCurrent)
			throws BbmFinderException, BbmUpdateException, JdmoException,
			BbmException {
<span class="nc" id="L2687">		methodStart(&quot;dumpReportDataInnerInner&quot;, colEmployeeIDs, dateStart,</span>
				dateEnd);
		// m_cat.info(&quot;Begin Dump Employee Group(&quot; + colEmployeeIDs.size() +
		// &quot;) , WinStart: &quot; + dateStart + &quot; WinEnd: &quot; + dateEnd);

		// for now just refresh union of changed intervals for all employees in
		// group.
		// more optimization could be done but....
<span class="nc" id="L2695">		int nReportDumpChunkSize1 = 100;</span>
		try {
<span class="nc" id="L2697">			nReportDumpChunkSize1 = m_dbConfigManager</span>
<span class="nc" id="L2698">					.getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_CHUNK_SIZE1);</span>
<span class="nc bnc" id="L2699" title="All 2 branches missed.">			if (nReportDumpChunkSize1 &lt; 0) {// not set</span>
<span class="nc" id="L2700">				int i_reportDumpThreads = m_dbConfigManager</span>
<span class="nc" id="L2701">						.getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_NUM_OF_THREAD);</span>
<span class="nc bnc" id="L2702" title="All 2 branches missed.">				if (i_reportDumpThreads &gt; 1) // for mutithreading, default is 50</span>
<span class="nc" id="L2703">					nReportDumpChunkSize1 = 50;</span>
				else
<span class="nc" id="L2705">					nReportDumpChunkSize1 = 100;</span>
			}
<span class="nc" id="L2707">		} catch (Exception e) {</span>
<span class="nc" id="L2708">		}</span>

		try {

<span class="nc" id="L2712">			Collection colEmployeeIDsChunk = new LinkedList();</span>
<span class="nc" id="L2713">			Collection colEmployeeIDsFailed = new LinkedList();</span>

<span class="nc" id="L2715">			int nTotalEmployees = colEmployeeIDs.size();</span>
<span class="nc" id="L2716">			int nNumEmployeesDumped = 0;</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">			for (Iterator i2 = colEmployeeIDs.iterator(); i2.hasNext();) {</span>
<span class="nc" id="L2718">				ID idEmployee = (ID) i2.next();</span>
<span class="nc" id="L2719">				colEmployeeIDsChunk.add(idEmployee);</span>
<span class="nc bnc" id="L2720" title="All 2 branches missed.">				if (colEmployeeIDsChunk.size() &lt; nReportDumpChunkSize1</span>
<span class="nc bnc" id="L2721" title="All 2 branches missed.">						&amp;&amp; i2.hasNext())</span>
<span class="nc" id="L2722">					continue;</span>
<span class="nc" id="L2723">				int nMaxRetry = REPORTDUMP_MAX_RETRY;</span>
<span class="nc" id="L2724">				int nRetry = 0;</span>
<span class="nc" id="L2725">				for (; true; nRetry++) {</span>
					// m_cacheChunkLock.lock(&quot;Chunk&quot;, 60000);
					try {
<span class="nc" id="L2728">						dumpReportDataChunk(colEmployeeIDsChunk, dateStart,</span>
								dateEnd, null, jdmo, dateCurrent);
<span class="nc" id="L2730">					} catch (Exception e) {</span>
<span class="nc" id="L2731">						handleException(e);</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">						if (nRetry &lt; nMaxRetry) {</span>
<span class="nc bnc" id="L2733" title="All 2 branches missed.">							if (m_cat.isDebugEnabled())</span>
<span class="nc" id="L2734">								m_cat.debug(&quot;Exception in dumpReportDataChunk: retry count = &quot;</span>
										+ new Integer(nRetry));
<span class="nc" id="L2736">							continue;</span>
						}

<span class="nc" id="L2739">						colEmployeeIDsFailed.addAll(colEmployeeIDsChunk);</span>
<span class="nc" id="L2740">						m_cat.info(&quot;ReportChunk failed for EmployeeIDs: &quot;</span>
								+ colEmployeeIDsChunk);
<span class="nc" id="L2742">					} finally {</span>
						// m_cacheChunkLock.unLock(&quot;Chunk&quot;);
<span class="nc" id="L2744">					}</span>

<span class="nc" id="L2746">					break;</span>
				}
<span class="nc bnc" id="L2748" title="All 2 branches missed.">				if (nRetry &lt; nMaxRetry)</span>
<span class="nc" id="L2749">					nNumEmployeesDumped += colEmployeeIDsChunk.size();</span>

<span class="nc" id="L2751">				failed.addAll(colEmployeeIDsFailed);</span>
<span class="nc" id="L2752">				m_cat.info(&quot;Stats: Chunk Dumped, Size = &quot;</span>
						+ new Integer(nTotalEmployees) + &quot;Dumped: &quot;
						+ new Integer(nNumEmployeesDumped) + &quot; Failed: &quot;
<span class="nc" id="L2755">						+ new Integer(colEmployeeIDsFailed.size()));</span>
<span class="nc" id="L2756">				colEmployeeIDsChunk.clear();</span>
<span class="nc" id="L2757">			}</span>

<span class="nc" id="L2759">			return colEmployeeIDsFailed;</span>

		} finally {
<span class="nc" id="L2762">			jdmo.cleanUp();</span>
<span class="nc" id="L2763">			methodFinish();</span>
		}
	}

	private String formatDBString(Timestamp timeStamp, Jdmo jdmo) {
<span class="nc" id="L2768">		return &quot;'&quot; + JdmoUtil.formatDBString(timeStamp) + &quot;'&quot;;</span>
	}

<span class="nc" id="L2771">	static private class LastUpdatedWindow {</span>
		private final ID m_idEmployee;
		private final Date m_dateLastUpdated;

<span class="nc" id="L2775">		public LastUpdatedWindow(ID idEmployee, Date dateLastUpdated) {</span>
<span class="nc" id="L2776">			m_idEmployee = idEmployee;</span>
<span class="nc" id="L2777">			m_dateLastUpdated = dateLastUpdated;</span>
<span class="nc" id="L2778">		}</span>

		public Date getLastUpdatedDate() {
<span class="nc" id="L2781">			return m_dateLastUpdated;</span>
		}

		ID getEmployeeID() {
<span class="nc" id="L2785">			return m_idEmployee;</span>
		}
	}

	private HashMap getDumpTimelineLastUpdatedWindows(
			Collection colEmployeeIDs, Timestamp tsStart, Timestamp tsEnd,
			Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2792">		methodStart(&quot;getDumpTimelineLastUpdatedDate&quot;, colEmployeeIDs, tsStart,</span>
				tsEnd);
		// m_cat.info(&quot;Begin: getDumpTimelineLastUpdatedWindows(&quot; +
		// colEmployeeIDs.size() + &quot;) Start: &quot; + tsStart + &quot;, End: &quot; + tsEnd);
		try {
<span class="nc" id="L2797">			HashMap hmLastUpdatedWindows = new HashMap();</span>
<span class="nc bnc" id="L2798" title="All 2 branches missed.">			if (colEmployeeIDs.isEmpty())</span>
<span class="nc" id="L2799">				return hmLastUpdatedWindows;</span>

<span class="nc" id="L2801">			String strQuery = &quot;select WORKRESOURCEID, LASTMODIFIEDAT from REPORTDUMPLASTUPDATED&quot;</span>
					+ &quot; where (STARTDATE &lt;= &quot;
<span class="nc" id="L2803">					+ formatDBString(tsStart, jdmo)</span>
					+ &quot; or STARTDATE is null)&quot;
					+ &quot; and (ENDDATE &gt; &quot;
<span class="nc" id="L2806">					+ formatDBString(tsEnd, jdmo) + &quot; or ENDDATE is null)&quot;;</span>
			// m_cat.info(&quot;strQuery: &quot; + strQuery);
<span class="nc" id="L2808">			strQuery += &quot; and WORKRESOURCEID in &quot;</span>
<span class="nc" id="L2809">					+ jdmo.createInClause(colEmployeeIDs);</span>
<span class="nc" id="L2810">			JdmoRowset r = jdmo.createRowset(strQuery);</span>

<span class="nc bnc" id="L2812" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L2813">				ID idEmployee = r.getID(&quot;WORKRESOURCEID&quot;);</span>
<span class="nc" id="L2814">				Date dateLastModified = r.getTimestamp(&quot;LASTMODIFIEDAT&quot;);</span>
<span class="nc" id="L2815">				LastUpdatedWindow lastUpdatedWindow = new LastUpdatedWindow(</span>
						idEmployee, dateLastModified);
<span class="nc" id="L2817">				hmLastUpdatedWindows.put(idEmployee, lastUpdatedWindow);</span>
<span class="nc" id="L2818">			}</span>
			// m_cat.info(&quot;End: getDumpTimelineLastUpdatedWindows&quot;);
<span class="nc" id="L2820">			return hmLastUpdatedWindows;</span>
		} finally {
<span class="nc" id="L2822">			jdmo.cleanUp();</span>
<span class="nc" id="L2823">			methodFinish();</span>
		}
	}

	private Collection getEmployeesWithoutPlannedEvents(
			Collection colEmployeeIDs, Timestamp tsStart, Timestamp tsEnd,
			Jdmo jdmo) throws JdmoException {

<span class="nc" id="L2831">		methodStart(&quot;getEmployeesWithoutPlannedEvents&quot;, colEmployeeIDs,</span>
				tsStart, tsEnd);
<span class="nc" id="L2833">		m_cat.info(&quot;Begin: getEmployeesWithoutPlannedEvents(&quot;</span>
<span class="nc" id="L2834">				+ colEmployeeIDs.size() + &quot;) Start: &quot; + tsStart + &quot;, End: &quot;</span>
				+ tsEnd);
<span class="nc" id="L2836">		Collection colEmployeeIDsWithoutPlannedEvents = new LinkedList();</span>
		try {
<span class="nc bnc" id="L2838" title="All 2 branches missed.">			if (colEmployeeIDs.isEmpty())</span>
<span class="nc" id="L2839">				return colEmployeeIDsWithoutPlannedEvents;</span>
<span class="nc" id="L2840">			String arrFieldNames[] = new String[] { &quot;ID&quot; };</span>

<span class="nc" id="L2842">			String strQuery =</span>
			/*
			 * &quot;	select EMPLOYEEAM.ID from EMPLOYEEAM &quot; + &quot;	left join &quot; +
			 * &quot;		PLANNEDEVENTTIMELINE &quot; +
			 * &quot;	on	PLANNEDEVENTTIMELINE.WORKRESOURCEID = EMPLOYEEAM.ID AND PLANNEDEVENTTIMELINE.ACTIVITYID &lt;&gt; -4001 &quot;
			 * + &quot;		and (PLANNEDEVENTTIMELINE.ENDTIME &gt; &quot; +
			 * formatDBString(tsStart, jdmo) +
			 * &quot;			or PLANNEDEVENTTIMELINE.ENDTIME is null) &quot; +
			 * &quot;		and (PLANNEDEVENTTIMELINE.STARTTIME &lt; &quot; +
			 * formatDBString(tsEnd, jdmo) +
			 * &quot;			or PLANNEDEVENTTIMELINE.STARTTIME is null) &quot; +
			 * &quot; where EMPLOYEEAM.ID in &quot; + jdmo.createInClause(colEmployeeIDs)
			 * + &quot; and PLANNEDEVENTTIMELINE.ID is null&quot;;
			 */
			&quot;	select EMPLOYEEAM.ID from EMPLOYEEAM &quot;
					+ &quot;	where   EMPLOYEEAM.ID in &quot;
<span class="nc" id="L2858">					+ jdmo.createInClause(colEmployeeIDs)</span>
					+ &quot;  and not exists &quot;
					+ &quot;		( select 1 from PLANNEDEVENTTIMELINE &quot;
					+ &quot;			where PLANNEDEVENTTIMELINE.WORKRESOURCEID = EMPLOYEEAM.ID&quot;
					+ &quot; 		AND PLANNEDEVENTTIMELINE.ACTIVITYID &lt;&gt; -4001 &quot;
					+ &quot;			and (PLANNEDEVENTTIMELINE.ENDTIME &gt; &quot;
<span class="nc" id="L2864">					+ formatDBString(tsStart, jdmo)</span>
					+ &quot;			or PLANNEDEVENTTIMELINE.ENDTIME is null) &quot;
					+ &quot;			and (PLANNEDEVENTTIMELINE.STARTTIME &lt; &quot;
<span class="nc" id="L2867">					+ formatDBString(tsEnd, jdmo)</span>
					+ &quot;			or PLANNEDEVENTTIMELINE.STARTTIME is null) &quot;
					+ &quot;     ) &quot;;

<span class="nc" id="L2871">			JdmoRowset r = jdmo.createRowset(strQuery);</span>

<span class="nc bnc" id="L2873" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L2874">				ID idEmployee = r.getID(&quot;ID&quot;);</span>
<span class="nc" id="L2875">				colEmployeeIDsWithoutPlannedEvents.add(idEmployee);</span>
<span class="nc" id="L2876">			}</span>
<span class="nc" id="L2877">			m_cat.info(&quot;End: getEmployeesWithoutPlannedEvents(&quot;</span>
<span class="nc" id="L2878">					+ colEmployeeIDsWithoutPlannedEvents.size() + &quot;)&quot;);</span>
<span class="nc" id="L2879">			return colEmployeeIDsWithoutPlannedEvents;</span>
		} finally {
<span class="nc" id="L2881">			jdmo.cleanUp();</span>
<span class="nc" id="L2882">			methodFinish();</span>
		}
	}

	private HashSet getTerminatedEmployees(Collection colEmployeeIDs,
			Timestamp tsStart, Jdmo jdmo) throws BbmFinderException,
			RemoteException {
<span class="nc" id="L2889">		Collection ids = m_workResourceManager</span>
<span class="nc" id="L2890">				.getTerminatedEmployeeIDs(tsStart);</span>
<span class="nc" id="L2891">		ids.retainAll(colEmployeeIDs);</span>
<span class="nc" id="L2892">		return new HashSet(ids);</span>
	}

	private void initializeDumpTimelineLastUpdatedDate(
			Collection colEmployeeIDs, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2897">		m_cat.info(&quot;Begin: initializeDumpTimelineLastUpdatedDate(&quot;</span>
<span class="nc" id="L2898">				+ colEmployeeIDs.size() + &quot;)&quot;);</span>
<span class="nc" id="L2899">		Collection colEmployeeIDsToDel = new LinkedList();</span>

<span class="nc" id="L2901">		String strQuery = &quot;select WORKRESOURCEID, count(1) CNT, max(LASTMODIFIEDAT) MAXLASTMODIFIEDAT from &quot; +</span>
<span class="nc" id="L2902">			&quot;REPORTDUMPLASTUPDATED where WORKRESOURCEID in &quot; + jdmo.createInClause(colEmployeeIDs)</span>
				+ &quot; group by WORKRESOURCEID having count(1) &gt; 1&quot;;

<span class="nc" id="L2905">		ArrayList colFieldValues = new ArrayList();</span>

<span class="nc" id="L2907">		JdmoRowset r = jdmo.createRowset(strQuery);</span>
<span class="nc bnc" id="L2908" title="All 2 branches missed.">		while (r.next()) {</span>
<span class="nc" id="L2909">			ID idEmployee = r.getID(&quot;WORKRESOURCEID&quot;);</span>
<span class="nc" id="L2910">			int nCnt = r.getInt(&quot;CNT&quot;);</span>
<span class="nc" id="L2911">			Timestamp tsLastUpdated = r.getTimestamp(&quot;MAXLASTMODIFIEDAT&quot;);</span>
<span class="nc bnc" id="L2912" title="All 2 branches missed.">			if (nCnt &gt; 1) {</span>
<span class="nc" id="L2913">				colEmployeeIDsToDel.add(idEmployee);</span>
<span class="nc" id="L2914">				Object arrFieldValues[] = new Object[] { null, idEmployee,</span>
						null, null, tsLastUpdated };
<span class="nc" id="L2916">				colFieldValues.add(arrFieldValues);</span>
			}
<span class="nc" id="L2918">		}</span>
<span class="nc bnc" id="L2919" title="All 2 branches missed.">		if (!colEmployeeIDsToDel.isEmpty()) {</span>
<span class="nc" id="L2920">			String arrFieldNames[] = new String[] { &quot;ID&quot;, &quot;WORKRESOURCEID&quot;,</span>
					&quot;STARTDATE&quot;, &quot;ENDDATE&quot;, &quot;LASTMODIFIEDAT&quot; };
<span class="nc" id="L2922">			int arrFieldTypes[] = { Types.INTEGER, Types.INTEGER,</span>
					Types.TIMESTAMP, Types.TIMESTAMP, Types.TIMESTAMP };
<span class="nc" id="L2924">			m_cat.info(&quot;REPORTDUMPLASTUPDATED was reset for the following employees: &quot;</span>
					+ colEmployeeIDsToDel);
<span class="nc" id="L2926">			strQuery = &quot;delete from REPORTDUMPLASTUPDATED &quot;</span>
					+ &quot; where WORKRESOURCEID in &quot;
<span class="nc" id="L2928">					+ jdmo.createInClause(colEmployeeIDsToDel);</span>
<span class="nc" id="L2929">			jdmo.addBatch(strQuery);</span>
<span class="nc" id="L2930">			jdmo.executeBatch();</span>
<span class="nc" id="L2931">			jdmo.insertBatchAndExecute(&quot;REPORTDUMPLASTUPDATED&quot;, arrFieldNames,</span>
					arrFieldTypes, colFieldValues);
		}

<span class="nc" id="L2935">		m_cat.info(&quot;End: initializeDumpTimelineLastUpdatedDate(&quot;</span>
<span class="nc" id="L2936">				+ colFieldValues.size() + &quot;)&quot;);</span>

<span class="nc" id="L2938">	}</span>

	private void updateDumpTimelineLastUpdatedDate(Collection colEmployeeIDs,
			Timestamp tsStart, Timestamp tsEnd, Jdmo jdmo, Date dateModifiedAt)
			throws JdmoException {
<span class="nc" id="L2943">		Timestamp tsModifiedAt = new Timestamp(dateModifiedAt.getTime());</span>
<span class="nc" id="L2944">		methodStart(&quot;updateDumpTimelineLastUpdatedDate&quot;, colEmployeeIDs,</span>
				tsStart, tsEnd, tsModifiedAt);
		try {

<span class="nc" id="L2948">			String strEmployeeIDsInClause = jdmo.createInClause(colEmployeeIDs);</span>

<span class="nc" id="L2950">			ArrayList colFieldValues = new ArrayList();</span>

<span class="nc" id="L2952">			String strQuery = &quot;delete from REPORTDUMPLASTUPDATED &quot;</span>
					+ &quot;where WORKRESOURCEID in &quot; + strEmployeeIDsInClause;
<span class="nc" id="L2954">			jdmo.addBatch(strQuery);</span>
<span class="nc" id="L2955">			jdmo.executeBatch();</span>

			// clear out events that fall within window
<span class="nc" id="L2958">			String arrFieldNames[] = new String[] { &quot;ID&quot;, &quot;WORKRESOURCEID&quot;,</span>
					&quot;STARTDATE&quot;, &quot;ENDDATE&quot;, &quot;LASTMODIFIEDAT&quot; };
<span class="nc" id="L2960">			int arrFieldTypes[] = { Types.INTEGER, Types.INTEGER,</span>
					Types.TIMESTAMP, Types.TIMESTAMP, Types.TIMESTAMP };

<span class="nc" id="L2963">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L2964" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L2965">				ID idEmployee = (ID) itEmployeeID.next();</span>

<span class="nc" id="L2967">				Object arrFieldValues[] = new Object[] { null, idEmployee,</span>
						tsStart, tsEnd, tsModifiedAt, };
<span class="nc" id="L2969">				colFieldValues.add(arrFieldValues);</span>
<span class="nc" id="L2970">			}</span>
<span class="nc" id="L2971">			jdmo.insertBatchAndExecute(&quot;REPORTDUMPLASTUPDATED&quot;, arrFieldNames,</span>
					arrFieldTypes, colFieldValues);
		} finally {
<span class="nc" id="L2974">			jdmo.cleanUp();</span>
<span class="nc" id="L2975">			methodFinish();</span>
<span class="nc" id="L2976">		}</span>

<span class="nc" id="L2978">	}</span>

	private void populateEmployeeIDs(Collection colEmployeeIDs, Jdmo jdmo)
			throws JdmoException {
		try {
<span class="nc" id="L2983">			String strQuery = &quot;delete from ADHOC_DUMP_EMPLOYEEIDS&quot;;</span>
<span class="nc" id="L2984">			jdmo.addBatch(strQuery);</span>
<span class="nc" id="L2985">			jdmo.executeBatch();</span>

			// use insertBatchAndExecute
<span class="nc" id="L2988">			String arrFieldNames[] = new String[] { &quot;ID&quot; };</span>
<span class="nc" id="L2989">			int arrFieldTypes[] = { Types.INTEGER, };</span>

<span class="nc" id="L2991">			ArrayList colFieldValues = new ArrayList();</span>
<span class="nc" id="L2992">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L2993" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L2994">				ID idEmployee = (ID) itEmployeeID.next();</span>

<span class="nc" id="L2996">				Object arrFieldValues[] = new Object[] { idEmployee };</span>
<span class="nc" id="L2997">				colFieldValues.add(arrFieldValues);</span>
<span class="nc" id="L2998">			}</span>

<span class="nc" id="L3000">			jdmo.insertBatchAndExecute(&quot;ADHOC_DUMP_EMPLOYEEIDS&quot;, arrFieldNames,</span>
					arrFieldTypes, colFieldValues);

		} finally {
<span class="nc" id="L3004">			jdmo.cleanUp();</span>
<span class="nc" id="L3005">			methodFinish();</span>
<span class="nc" id="L3006">		}</span>
<span class="nc" id="L3007">	}</span>

	public int updateFilteredEmployees(Jdmo jdmo, Jdmo jdmoWarehouse)
			throws JdmoException, BbmFinderException, RemoteException {
<span class="nc" id="L3011">		methodStart(&quot;updateFilteredEmployees&quot;);</span>
<span class="nc" id="L3012">		Collection&lt;Filter&gt; employeeFilters = null;</span>
		try {
<span class="nc" id="L3014">			UserTransaction ut = m_sessionContext.getUserTransaction();</span>
<span class="nc" id="L3015">			int nRetry = 0;</span>
<span class="nc" id="L3016">			for (; true; nRetry++) {</span>
				try {
<span class="nc" id="L3018">					ut.setTransactionTimeout(USERTRANSACTION_TIMEOUT);</span>
<span class="nc" id="L3019">					ut.begin();</span>
					// see if on demand dump employee filter, if not load all as before
<span class="nc bnc" id="L3021" title="All 2 branches missed.">					boolean isOnDemandDump = m_dbConfigManager.getIntValue(ConfigKey.CRYSTAL_REPORTS_EMPLOYEEFILTER_DUMP_ONDEMAND) == 1;</span>
<span class="nc bnc" id="L3022" title="All 2 branches missed.">					if (isOnDemandDump) {</span>
<span class="nc bnc" id="L3023" title="All 4 branches missed.">						if (dumpedEmpFilterIDs != null &amp;&amp; !dumpedEmpFilterIDs.isEmpty()) {</span>
<span class="nc" id="L3024">							employeeFilters = m_employeeFilter.getFilters(dumpedEmpFilterIDs);</span>
						}
					} else {
<span class="nc" id="L3027">						employeeFilters = m_employeeFilter.getAllFiltersForDump();</span>
					}
<span class="nc" id="L3029">					ut.commit();</span>
<span class="nc" id="L3030">				} catch (Exception e) {</span>
<span class="nc bnc" id="L3031" title="All 2 branches missed.">					if (nRetry &lt; REPORTDUMP_MAX_RETRY) {</span>
<span class="nc" id="L3032">						handleException(e);</span>
<span class="nc" id="L3033">						ut.rollback();</span>
<span class="nc" id="L3034">						continue;</span>
					}
<span class="nc" id="L3036">					ut.rollback();</span>
<span class="nc" id="L3037">					m_cat.info(&quot;Report Dump fails to getFilters after retrying &quot; + nRetry + &quot; times&quot;);</span>
<span class="nc" id="L3038">					handleException(e);</span>
<span class="nc bnc" id="L3039" title="All 2 branches missed.">					if (e instanceof BbmFinderException) {</span>
<span class="nc" id="L3040">						throw (BbmFinderException) e;</span>
					} else {
<span class="nc" id="L3042">						throw (RemoteException) e;</span>
					}
<span class="nc" id="L3044">				}</span>
				break;
			}
<span class="nc bnc" id="L3047" title="All 4 branches missed.">			if (employeeFilters == null || employeeFilters.isEmpty()) {</span>
				// no need to dump any filter
<span class="nc" id="L3049">				return 0;</span>
			}

			// first prep the BPWAREHOUSEDB for this employee filter ID
<span class="nc" id="L3053">			prepBpwarehousedb(jdmoWarehouse, employeeFilters);</span>
<span class="nc bnc" id="L3054" title="All 2 branches missed.">			if (jdmoWarehouse != null) {</span>
<span class="nc" id="L3055">				dumpEmpFilters(jdmoWarehouse, employeeFilters);</span>
			}
<span class="nc" id="L3057">			dumpEmpFilters(jdmo, employeeFilters);</span>
<span class="nc" id="L3058">		} catch (Exception e) {</span>
<span class="nc" id="L3059">			jdmo.cleanUp();</span>
<span class="nc" id="L3060">			cleanupWarehouseJdmo(jdmoWarehouse);</span>
<span class="nc" id="L3061">			handleException(e);</span>
<span class="nc" id="L3062">			m_cat.info(&quot;Failed to dump employee filters&quot;);</span>
		} finally {
<span class="nc" id="L3064">			methodFinish();</span>
<span class="nc" id="L3065">		}</span>
<span class="nc bnc" id="L3066" title="All 2 branches missed.">		return (employeeFilters == null ? 0 : employeeFilters.size());</span>
	}

	private void dumpEmpFilters(Jdmo jdmo, Collection colFilters) throws JdmoException {
<span class="nc" id="L3070">		m_cat.info(&quot;Begin dumping &quot; + colFilters.size() + &quot; Employee Filters&quot;);</span>
<span class="nc" id="L3071">		int nNumDumped = 0;</span>
<span class="nc bnc" id="L3072" title="All 2 branches missed.">		for (Iterator iFilter = colFilters.iterator(); iFilter.hasNext();) {</span>
<span class="nc" id="L3073">			Filter filter = (Filter) iFilter.next();</span>
			try {
<span class="nc" id="L3075">				Collection colEmployeeIDs = m_employeeFilter.getEmployeeIDs(filter, -1, true, 0, Integer.MAX_VALUE);</span>
<span class="nc" id="L3076">				insertEmployeeFilterWorkresource(jdmo, filter, colEmployeeIDs);</span>
<span class="nc" id="L3077">				nNumDumped++;</span>
<span class="nc bnc" id="L3078" title="All 2 branches missed.">				if (nNumDumped % 50 == 0) {</span>
<span class="nc" id="L3079">					m_cat.info(nNumDumped + &quot; Employee Filters dumped successfully&quot;);</span>
				}
<span class="nc" id="L3081">			} catch (Exception e) {</span>
<span class="nc" id="L3082">				jdmo.cleanUp();</span>
<span class="nc" id="L3083">				handleException(e);</span>
<span class="nc" id="L3084">				m_cat.info(&quot;Failed to dump Employee Filter: Name = &quot; + filter.getFilterName() + &quot;, ID = &quot; + filter.getFilterID());</span>
<span class="nc" id="L3085">				m_colFailedEmployeeFilterIDs.add(filter.getFilterID());</span>
<span class="nc" id="L3086">			}</span>
<span class="nc" id="L3087">		}</span>
<span class="nc" id="L3088">	}</span>

	private void insertEmployeeFilterWorkresource(Jdmo jdmo, Filter filter, Collection colEmployeeIDs) throws JdmoException {
<span class="nc" id="L3091">		String empIDListTempTableName = jdmo.getNativeTemptableName(jdmo.createTempTableFromCollectionOfIds(colEmployeeIDs));</span>
<span class="nc" id="L3092">		JdmoQuery query = jdmo.createQuery(&quot;SP_EMPFILTERWORKRES_DEL_INS&quot;, Jdmo.STORPROC_QUERY_NORS);</span>
<span class="nc" id="L3093">		query.setParID(1, filter.getFilterID());</span>
<span class="nc" id="L3094">		query.setParString(2, empIDListTempTableName);</span>
<span class="nc" id="L3095">		jdmo.execute(query);</span>
<span class="nc" id="L3096">	}</span>

	public void updateFilteredEmployees(Jdmo jdmo, Jdmo jdmoWarehouse, ID idFilter, Collection colEmployeeIDs)
			throws JdmoException, BbmFinderException, RemoteException, CoreFinderException {
<span class="nc" id="L3100">		Filter filter = m_employeeFilter.getFilterByID(idFilter);</span>
		
		// first prep the BPWAREHOUSEDB for this employee filter ID
<span class="nc" id="L3103">		Collection&lt;Filter&gt; employeeFilters = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L3104">		employeeFilters.add(filter);</span>
<span class="nc" id="L3105">		prepBpwarehousedb(jdmoWarehouse, employeeFilters);</span>

<span class="nc" id="L3107">		m_cat.info(&quot;updateFilteredEmployees(Jdmo jdmo, Jdmo jdmoWarehouse: colEmployeeIDs.size() = &quot; + colEmployeeIDs.size());</span>
<span class="nc" id="L3108">		insertEmployeeFilterWorkresource(jdmo, filter, colEmployeeIDs);		</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">		if (jdmoWarehouse != null) {</span>
<span class="nc" id="L3110">			insertEmployeeFilterWorkresource(jdmoWarehouse, filter, colEmployeeIDs);</span>
		}
<span class="nc" id="L3112">	}</span>

	private void prepBpwarehousedb(Jdmo jdmoWarehouse, Collection&lt;Filter&gt; employeeFilters) {

<span class="nc bnc" id="L3116" title="All 2 branches missed.">		if (jdmoWarehouse != null) {</span>
<span class="nc" id="L3117">			Collection&lt;ID&gt; employeeFilterIDs = new LinkedList&lt;&gt;();</span>
<span class="nc" id="L3118">			employeeFilters.forEach((employeeFilter) -&gt; {</span>
<span class="nc" id="L3119">				employeeFilterIDs.add(employeeFilter.getFilterID());</span>
<span class="nc" id="L3120">			});</span>

			try {
<span class="nc" id="L3123">				String strQuery = &quot;delete from EMPLOYEEFILTERWORKRESOURCE where EMPLOYEEFILTERID in &quot;</span>
<span class="nc" id="L3124">						+ jdmoWarehouse.createInClause(employeeFilterIDs);</span>
<span class="nc" id="L3125">				jdmoWarehouse.addBatch(strQuery);</span>
<span class="nc" id="L3126">				jdmoWarehouse.executeBatch();</span>

<span class="nc" id="L3128">				strQuery = &quot;delete from EMPLOYEEFILTER where ID in &quot; + jdmoWarehouse.createInClause(employeeFilterIDs);</span>
<span class="nc" id="L3129">				jdmoWarehouse.addBatch(strQuery);</span>
<span class="nc" id="L3130">				jdmoWarehouse.executeBatch();</span>

<span class="nc bnc" id="L3132" title="All 2 branches missed.">				for (Filter employeeFilter : employeeFilters) {</span>
<span class="nc" id="L3133">					HashMap hm = new HashMap();</span>
<span class="nc" id="L3134">					hm.put(&quot;NAME&quot;, employeeFilter.getFilterName());</span>
<span class="nc" id="L3135">					hm.put(&quot;BPUSERID&quot;, employeeFilter.getUserID());</span>
<span class="nc" id="L3136">					User u = (User) m_userManager.getUserByID(employeeFilter.getUserID());</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">					if (u != null) {</span>
<span class="nc" id="L3138">						hm.put(&quot;USERNAME&quot;, u.getUserName());</span>
					}
<span class="nc" id="L3140">					hm.put(&quot;ID&quot;, employeeFilter.getFilterID());</span>

<span class="nc bnc" id="L3142" title="All 2 branches missed.">					if (m_employeeFilter.isRunContext(employeeFilter.getFilterID())) {</span>
<span class="nc" id="L3143">						hm.put(&quot;ISREPORTCONTEXT&quot;, true);</span>
					} else {
<span class="nc" id="L3145">						hm.put(&quot;ISREPORTCONTEXT&quot;, false);</span>
					}
<span class="nc" id="L3147">					jdmoWarehouse.addBatchInsert(&quot;EMPLOYEEFILTER&quot;, hm);</span>
<span class="nc" id="L3148">					synchronized (getIdLock(employeeFilter.getFilterID())) {</span>
<span class="nc" id="L3149">						jdmoWarehouse.executeBatch();</span>
<span class="nc" id="L3150">					}</span>
<span class="nc" id="L3151">				}</span>
<span class="nc" id="L3152">			} catch (Exception e) {</span>
<span class="nc" id="L3153">				handleException(e);</span>
<span class="nc" id="L3154">				m_cat.info(&quot;Failed to prep BPWAREHOUSEDB EMPLOYEEFILTERWORKRESOURCE and EMPLOYEEFILTER tables&quot;);</span>
<span class="nc" id="L3155">			}</span>
		}
<span class="nc" id="L3157">	}</span>

	/**
	 * Return an ID object to use as a lock for thread-safe update operations. For the same id value, returns the same ID object, so we can
	 * ensure that only 1 thread can do updates for a given id at a given time.
	 *
	 */
	private ID getIdLock(ID id) {
<span class="nc" id="L3165">		synchronized (lockMap) {</span>
<span class="nc" id="L3166">			ID lock = lockMap.get(id.toInt());</span>
<span class="nc bnc" id="L3167" title="All 2 branches missed.">			if (lock == null) {</span>
<span class="nc" id="L3168">				lock = id;</span>
<span class="nc" id="L3169">				lockMap.put(id.toInt(), lock);</span>
			}
<span class="nc" id="L3171">			return lock;</span>
<span class="nc" id="L3172">		}</span>
	}

	public void updateCoachingSessionImpact(Jdmo jdmo, Jdmo jdmoWarehouse)
			throws JdmoException, BbmFinderException, RemoteException {
<span class="nc" id="L3177">		methodStart(&quot;updateCoachingSessionImpact&quot;);</span>
		try {
<span class="nc" id="L3179">			String strQuery = &quot;select * from sys.tables where name = \'COACHINGSESSIONIMPACT\'&quot;;</span>
<span class="nc" id="L3180">			JdmoRowset rs = jdmoWarehouse.createRowset(strQuery);</span>
<span class="nc bnc" id="L3181" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L3182">				strQuery = &quot;delete from COACHINGSESSIONIMPACT&quot;;</span>
<span class="nc" id="L3183">				jdmoWarehouse.addBatch(strQuery);</span>
<span class="nc" id="L3184">				jdmoWarehouse.executeBatch();</span>
				/*As the query was too big for maintenance purpose, placing it in the sql file within resources and reading it here
				 About the query, as the left join with or condition was causing performance issue,
				 we modified it to be union all of inner joins (for or conditions) and left over records of left join. */
<span class="nc" id="L3188">				strQuery = IOUtils.toString(this.getClass().getResourceAsStream(&quot;/com/verint/ejb/wfm/sql/COACHINGSESSIONIMPACTQUERY.sql&quot;), &quot;UTF-8&quot;);</span>
<span class="nc" id="L3189">				rs = jdmo.createRowset(strQuery);</span>
				StringBuffer sb;
<span class="nc bnc" id="L3191" title="All 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L3192">					sb = new StringBuffer(500);</span>
<span class="nc" id="L3193">					sb.append(&quot;insert into COACHINGSESSIONIMPACT values(&quot;);</span>
<span class="nc" id="L3194">					sb.append(rs.getString(&quot;COACHINGSESSIONID&quot;));</span>
<span class="nc" id="L3195">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3196">					sb.append(rs.getString(&quot;EMPLOYEEID&quot;));</span>
<span class="nc" id="L3197">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3198">					sb.append(rs.getString(&quot;COACHID&quot;));</span>
<span class="nc" id="L3199">					sb.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3200" title="All 2 branches missed.">					if (rs.getString(&quot;SCHEDULEDDATE&quot;) != null) {</span>
<span class="nc" id="L3201">						sb.append(&quot;\'&quot;).append(rs.getString(&quot;SCHEDULEDDATE&quot;)).append(&quot;\'&quot;);</span>
					} else {
<span class="nc" id="L3203">						sb.append(&quot;null&quot;);</span>
					}
<span class="nc" id="L3205">					sb.append(&quot;, &quot;);</span>
<span class="nc bnc" id="L3206" title="All 2 branches missed.">					if (rs.getString(&quot;COMPLETIONDATE&quot;) != null) {</span>
<span class="nc" id="L3207">						sb.append(&quot;\'&quot;).append(rs.getString(&quot;COMPLETIONDATE&quot;)).append(&quot;\'&quot;);</span>
					} else {
<span class="nc" id="L3209">						sb.append(&quot;null&quot;);</span>
					}
<span class="nc" id="L3211">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3212">					sb.append(rs.getString(&quot;STATUSID&quot;));</span>
<span class="nc" id="L3213">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3214">					sb.append(rs.getString(&quot;RESULTID&quot;));</span>
<span class="nc" id="L3215">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3216">					sb.append(rs.getString(&quot;SESSIONTYPEID&quot;));</span>
<span class="nc" id="L3217">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3218">					sb.append(rs.getString(&quot;KPIID&quot;));</span>
<span class="nc" id="L3219">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3220">					sb.append(rs.getString(&quot;PERIODICITYID&quot;));</span>
<span class="nc" id="L3221">					sb.append(&quot;, &quot;);</span>
<span class="nc" id="L3222">					sb.append(rs.getString(&quot;COACHINGTOPICID&quot;));</span>
<span class="nc" id="L3223">					sb.append(&quot;)&quot;);</span>
<span class="nc" id="L3224">					jdmoWarehouse.addBatch(sb.toString());</span>
				}
<span class="nc" id="L3226">				jdmoWarehouse.executeBatch();</span>
			}
<span class="nc" id="L3228">		} catch (Exception e) {</span>
<span class="nc" id="L3229">			jdmo.cleanUp();</span>
<span class="nc" id="L3230">			cleanupWarehouseJdmo(jdmoWarehouse);</span>
<span class="nc" id="L3231">			handleException(e);</span>
<span class="nc" id="L3232">			m_cat.info(&quot;Failed to dump coaching session impact&quot;);</span>
		} finally {
<span class="nc" id="L3234">			methodFinish();</span>
<span class="nc" id="L3235">		}</span>
<span class="nc" id="L3236">	}</span>

	public void updateTimeZones(Jdmo jdmo) throws JdmoException {
<span class="nc" id="L3239">		methodStart(&quot;updateTimeZones&quot;);</span>
		try {
<span class="nc" id="L3241">			String strQuery = &quot;SELECT ID FROM TIMEZONEAM&quot;;</span>
<span class="nc" id="L3242">			JdmoRowset r = jdmo.createRowset(strQuery);</span>
<span class="nc bnc" id="L3243" title="All 2 branches missed.">			if (r.next()) {</span>
<span class="nc" id="L3244">				return; // has already been updated</span>
			}

			// jdmo.addBatch(&quot;delete from TIMEZONEAM&quot;);
<span class="nc" id="L3248">			String straTimeZoneIDs[] = TimeZone.getAvailableIDs();</span>
<span class="nc" id="L3249">			HashMap hmTimeZones = new HashMap();</span>
<span class="nc bnc" id="L3250" title="All 2 branches missed.">			for (int n = 0; n &lt; straTimeZoneIDs.length; n++) {</span>
<span class="nc" id="L3251">				String strTimeZoneID = straTimeZoneIDs[n];</span>
<span class="nc" id="L3252">				TimeZone timeZone = TimeZone.getTimeZone(strTimeZoneID);</span>
<span class="nc" id="L3253">				hmTimeZones.put(strTimeZoneID, timeZone);</span>
			}
			//Look back 40 Years and Look forward 80 years for dump range
<span class="nc" id="L3256">			insertIntoTimeZoneTableForGivenTimeZoneIDS(jdmo, straTimeZoneIDs, (-RTAAManagerEJB.TIMEZONEAM_YEARS_DUMPRANGE), </span>
				(RTAAManagerEJB.TIMEZONEAM_YEARS_DUMPRANGE * 2));


<span class="nc" id="L3260">			String timezoneUpdateTime = Long.toString(System.currentTimeMillis());</span>

			// Notify changes to UUM sync adapter and update the value in the DB
			// Notify changes to UUM sync adapter
<span class="nc bnc" id="L3264" title="All 2 branches missed.">			if (ChangeNotifier.getInstance() != null) {</span>
<span class="nc" id="L3265">				ChangeNotifier.getInstance().notify(null,</span>
						new BPConfigData(RTAAManagerEJB.DST_KEY, timezoneUpdateTime), true);
			}
<span class="nc" id="L3268">			BbmManagerFactory.getDBConfigManager().setValue(RTAAManagerEJB.DST_KEY, timezoneUpdateTime);</span>
<span class="nc" id="L3269">		} catch (Exception e) {</span>
<span class="nc" id="L3270">			handleException(e);</span>
		} finally {
<span class="nc" id="L3272">			methodFinish();</span>
<span class="nc" id="L3273">		}</span>

<span class="nc" id="L3275">	}</span>

	void insertIntoTimeZoneTableForGivenTimeZoneIDS(Jdmo jdmo, String[] straTimeZoneIDs,int startYear, int endYear) throws JdmoException {


<span class="nc bnc" id="L3280" title="All 2 branches missed.">		for (int n = 0; n &lt; straTimeZoneIDs.length; n++) {</span>
<span class="nc" id="L3281">			String strTimeZoneID = straTimeZoneIDs[n];</span>
<span class="nc" id="L3282">			TimeZone timeZone = TimeZone.getTimeZone(strTimeZoneID);</span>
			/*
			 * if (!timeZone.useDaylightTime()) { HashMap hm = new
			 * HashMap(); hm.put( &quot;TIMEZONE&quot;, strTimeZoneID); hm.put(
			 * &quot;BIAS&quot;, new Integer(timeZone.getRawOffset() / (1000 * 60)));
			 * jdmo.addBatchInsert(&quot;TIMEZONEAM&quot;, hm); }
			 */
<span class="nc" id="L3289">			Calendar calStart = getDateInPastOrFutureYearWithSameMonthAndSameDayAsToday(timeZone, startYear);</span>
<span class="nc" id="L3290">			Calendar calEnd = getDateInPastOrFutureYearWithSameMonthAndSameDayAsToday(timeZone, endYear);</span>

<span class="nc" id="L3292">			int nBias = Integer.MAX_VALUE;</span>
<span class="nc" id="L3293">			Date dateLastBiasChange = null;</span>
<span class="nc" id="L3294">			Calendar cal = calStart;</span>
<span class="nc" id="L3295">			HashMap&lt;String,Object&gt; hm = null;</span>
<span class="nc" id="L3296">			HashMap&lt;String,Object&gt; previousEntry = null;</span>
<span class="nc bnc" id="L3297" title="All 2 branches missed.">			for (; cal.before(calEnd); cal.add(Calendar.HOUR_OF_DAY, 1)) {</span>

<span class="nc" id="L3299">				Date date = cal.getTime();</span>
				int nCurrentBias;

<span class="nc bnc" id="L3302" title="All 2 branches missed.">				if (timeZone.inDaylightTime(date)) {</span>
<span class="nc" id="L3303">					nCurrentBias = cal.get(Calendar.ZONE_OFFSET)</span>
<span class="nc" id="L3304">							+ cal.get(Calendar.DST_OFFSET);</span>
				} else {
<span class="nc" id="L3306">					nCurrentBias = cal.get(Calendar.ZONE_OFFSET);</span>
				}

<span class="nc bnc" id="L3309" title="All 2 branches missed.">				if (nCurrentBias != nBias) {</span>
<span class="nc bnc" id="L3310" title="All 4 branches missed.">					if (dateLastBiasChange != null &amp;&amp; RTAAUtil.isDSTTransitionGreaterThanMonthApart(date, dateLastBiasChange)) {</span>
<span class="nc" id="L3311">						hm = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L3312">						hm.put(&quot;TIMEZONE&quot;, strTimeZoneID);</span>
<span class="nc" id="L3313">						hm.put(&quot;STARTTIME&quot;, JdmoUtil</span>
<span class="nc" id="L3314">								.formatDBString(new Timestamp(</span>
<span class="nc" id="L3315">										dateLastBiasChange.getTime())));</span>
<span class="nc" id="L3316">						hm.put(&quot;ENDTIME&quot;, JdmoUtil</span>
<span class="nc" id="L3317">								.formatDBString(new Timestamp(date</span>
<span class="nc" id="L3318">										.getTime())));</span>
<span class="nc" id="L3319">						hm.put(&quot;BIAS&quot;, new Integer(nBias / (1000 * 60)));</span>

<span class="nc bnc" id="L3321" title="All 2 branches missed.">						if (previousEntry != null) {</span>
<span class="nc" id="L3322">							adjustPreviousEntryEndTimeToMatchCurrentEntryStartTimeToEnsureContinuousPeriodOfDSTTransistions(previousEntry, dateLastBiasChange);</span>
<span class="nc" id="L3323">							jdmo.addBatchInsert(&quot;TIMEZONEAM&quot;, previousEntry);</span>
<span class="nc" id="L3324">							m_cat.debug(&quot;TimeZoneID : &quot; + strTimeZoneID + &quot; Starttime: &quot; + previousEntry.get(&quot;STARTTIME&quot;) </span>
<span class="nc" id="L3325">								+ &quot; Endtime: &quot; + previousEntry.get(&quot;ENDTIME&quot;));</span>
<span class="nc" id="L3326">							previousEntry = hm;</span>
						}

<span class="nc bnc" id="L3329" title="All 2 branches missed.">						if (previousEntry == null) {</span>
<span class="nc" id="L3330">							previousEntry = hm;</span>
						}
					}
<span class="nc" id="L3333">					nBias = nCurrentBias;</span>
<span class="nc" id="L3334">					dateLastBiasChange = date;</span>
				}
			}

<span class="nc bnc" id="L3338" title="All 2 branches missed.">			if (hm != null) {</span>
<span class="nc" id="L3339">				jdmo.addBatchInsert(&quot;TIMEZONEAM&quot;, hm);</span>
<span class="nc" id="L3340">				m_cat.debug(&quot;TimeZoneID : &quot; + strTimeZoneID + &quot; Starttime: &quot; + hm.get(&quot;STARTTIME&quot;) + &quot; Endtime: &quot; + hm.get(&quot;ENDTIME&quot;));</span>
			}
<span class="nc bnc" id="L3342" title="All 4 branches missed.">			if (dateLastBiasChange != null &amp;&amp; RTAAUtil.isDSTTransitionGreaterThanMonthApart(cal.getTime(), dateLastBiasChange)) {</span>
<span class="nc" id="L3343">				Date date = cal.getTime();</span>
<span class="nc" id="L3344">				hm = new HashMap&lt;String, Object&gt;();</span>
<span class="nc" id="L3345">				hm.put(&quot;TIMEZONE&quot;, strTimeZoneID);</span>
<span class="nc" id="L3346">				hm.put(&quot;STARTTIME&quot;, JdmoUtil.formatDBString(new Timestamp(</span>
<span class="nc" id="L3347">						dateLastBiasChange.getTime())));</span>
<span class="nc" id="L3348">				hm.put(&quot;ENDTIME&quot;, JdmoUtil.formatDBString(new Timestamp(</span>
<span class="nc" id="L3349">						date.getTime())));</span>
<span class="nc" id="L3350">				hm.put(&quot;BIAS&quot;, new Integer(nBias / (1000 * 60)));</span>
<span class="nc" id="L3351">				jdmo.addBatchInsert(&quot;TIMEZONEAM&quot;, hm);</span>
<span class="nc" id="L3352">				m_cat.debug(&quot;TimeZoneID : &quot; + strTimeZoneID+&quot; Starttime: &quot; + JdmoUtil.formatDBString(new Timestamp(</span>
<span class="nc" id="L3353">						dateLastBiasChange.getTime())) + &quot; Endtime: &quot; + JdmoUtil.formatDBString(new Timestamp(</span>
<span class="nc" id="L3354">						date.getTime())));</span>
			}
		}

<span class="nc" id="L3358">		jdmo.executeBatch();</span>
<span class="nc" id="L3359">	}</span>

	/**
	 * This method adjusts the Previous Entry Endtime to match with the Current Entry's Start Time .
	 * This scenario occurs when there is an error in tzdata provided by iana.org and more than one DST is avaiable within the same month.
	 * @param previousEntry - represents the previous transition in TIMEZONEAM table for this timezone
	 * @param currentTransistionStart - current DST transition details
	 */
	private void adjustPreviousEntryEndTimeToMatchCurrentEntryStartTimeToEnsureContinuousPeriodOfDSTTransistions(
			Map&lt;String, Object&gt; previousEntry, Date currentTransistionStart){

<span class="nc bnc" id="L3370" title="All 2 branches missed.">		if (!previousEntry.get(&quot;ENDTIME&quot;).equals(JdmoUtil</span>
<span class="nc" id="L3371">				.formatDBString(new Timestamp(</span>
<span class="nc" id="L3372">						currentTransistionStart.getTime())))) {</span>

<span class="nc" id="L3374">			previousEntry.put(&quot;ENDTIME&quot;,JdmoUtil</span>
<span class="nc" id="L3375">					.formatDBString(new Timestamp(</span>
<span class="nc" id="L3376">							currentTransistionStart.getTime())));</span>
		}

<span class="nc" id="L3379">	}</span>


	/**
	 * As of the day when TIMEZONEAM  data is dumped , this method gets the same day in  noOfYearsFromCurrentYear 
	 * (this can be past '-' value or in future)
	 * with reference to the Current Year
	 * @param timeZone
	 * @param noOfYearsFromCurrentYear
	 * @return
	 */
	protected Calendar getDateInPastOrFutureYearWithSameMonthAndSameDayAsToday(TimeZone timeZone, int noOfYearsFromCurrentYear) {
<span class="nc" id="L3391">		Calendar cal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L3392">		cal.add(Calendar.YEAR, noOfYearsFromCurrentYear);</span>
<span class="nc" id="L3393">		cal.set(cal.get(Calendar.YEAR),</span>
<span class="nc" id="L3394">                cal.get(Calendar.MONTH),</span>
<span class="nc" id="L3395">                cal.get(Calendar.DATE), 0, 0, 0);</span>
<span class="nc" id="L3396">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L3397">		return cal;</span>
	}

	public AdheranceStatusData getAdheranceStatusData(Collection colEmployeeIDs)
			throws BbmFinderException {
<span class="nc" id="L3402">		return getAdheranceStatusData(colEmployeeIDs, new LinkedList(),</span>
				SORT_NONE, false, 0, Integer.MAX_VALUE, true);
	}

	public AdheranceStatusData getAdheranceStatusData(
			Collection colEmployeeIDs, Collection colPushedEmployeeIDs,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, TimeZone tz) throws BbmFinderException {
<span class="nc" id="L3410">		return getAdheranceStatusData(colEmployeeIDs, colPushedEmployeeIDs,</span>
				nSortField, bIsAscending, nOffset, nMaxEmployees, tz, true);

	}

	public AdheranceStatusData getAdheranceStatusData(
			Collection colEmployeeIDs, Collection colPushedEmployeeIDs,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, boolean bContinuousNonAdherance)
			throws BbmFinderException {
<span class="nc" id="L3420">		return getAdheranceStatusData(colEmployeeIDs, colPushedEmployeeIDs,</span>
				nSortField, bIsAscending, nOffset, nMaxEmployees, null,
				bContinuousNonAdherance);

	}

	public AdheranceStatusData getAdheranceStatusData(
			Collection colEmployeeIDs, Collection colPushedEmployeeIDs,
			int nSortField, boolean bIsAscending, int nOffset, int nMaxEmployees)
			throws RemoteException, BbmFinderException {
<span class="nc" id="L3430">		return getAdheranceStatusData(colEmployeeIDs, colPushedEmployeeIDs,</span>
				nSortField, bIsAscending, nOffset, nMaxEmployees, null, true);
	}

	/**
	 * Get the Adherence Status Data for the Quick View page. This includes the
	 * Status Summary data, the Day Data, and the Employee Adherence Information
	 * for each employee in the collection.
	 *
	 * @param colEmployeeIDs
	 * @param colPushedEmployeeIDs
	 * @param nSortField
	 * @param bIsAscending
	 * @param nOffset
	 * @param nMaxEmployees
	 * @param userTimeZone
	 *            Pass the user preference TimeZone of the person viewing the
	 *            Quick View only if you want Day Summary data.
	 * @param bContinuousNonAdherance
	 * @return the Adherence Status Data for the Quick View page.
	 * @throws BbmFinderException
	 */
	public AdheranceStatusData getAdheranceStatusData(
			Collection colEmployeeIDs, Collection colPushedEmployeeIDs,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, TimeZone userTimeZone,
			boolean bContinuousNonAdherance) throws BbmFinderException {
<span class="nc" id="L3457">		methodStart(&quot;getAdheranceStatusData&quot;, colEmployeeIDs);</span>
		try {
<span class="nc" id="L3459">			Date dateCurrent = getCurrentTime();</span>
<span class="nc" id="L3460">			Date dateStartWin = new Date(dateCurrent.getTime()</span>
					- (QUICK_VIEW_LOOKBACK_LIMIT + 60000));

<span class="nc" id="L3463">			HashMap hmAdheranceOverrides = m_rtaaService.getAdheranceOverrides(</span>
					colEmployeeIDs, dateStartWin, dateCurrent);

<span class="nc" id="L3466">			HashMap hmEmployeeDataIn = new HashMap();</span>
<span class="nc" id="L3467">			HashSet tsActivitiesToLoad = new HashSet();</span>
<span class="nc" id="L3468">			HashSet tsActivityMappingsToLoad = new HashSet();</span>
<span class="nc" id="L3469">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L3470" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L3471">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L3472">				EmployeeDataIn employeeDataIn = new EmployeeDataIn(idEmployee);</span>
<span class="nc" id="L3473">				hmEmployeeDataIn.put(idEmployee, employeeDataIn);</span>

<span class="nc" id="L3475">				Collection colAdheranceOverrides = (Collection) hmAdheranceOverrides</span>
<span class="nc" id="L3476">						.get(idEmployee);</span>
<span class="nc bnc" id="L3477" title="All 2 branches missed.">				if (colAdheranceOverrides == null)</span>
<span class="nc" id="L3478">					colAdheranceOverrides = new LinkedList();</span>
<span class="nc" id="L3479">				employeeDataIn.setAdheranceOverrides(colAdheranceOverrides);</span>

<span class="nc" id="L3481">			}</span>
<span class="nc" id="L3482">			HashMap hmEmployeeAdheranceStatus = new HashMap();</span>

<span class="nc" id="L3484">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L3486">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L3487">				EmployeeAdheranceStatus employeeAdheranceStatus = new EmployeeAdheranceStatus(</span>
						idEmployee);
<span class="nc" id="L3489">				hmEmployeeAdheranceStatus.put(idEmployee,</span>
						employeeAdheranceStatus);
<span class="nc" id="L3491">			}</span>

<span class="nc" id="L3493">			HashMap hmEmployeeNames = m_workResourceManager</span>
<span class="nc" id="L3494">					.getEmployeeNamesByIDs(colEmployeeIDs);</span>

			// Collection colEmployees =
			// m_workResourceManager.getEmployeesByIDs(colEmployeeIDs, null,
			// Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);
<span class="nc" id="L3499">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L3500" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L3501">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L3502">				EmployeeName employeeName = (EmployeeName) hmEmployeeNames</span>
<span class="nc" id="L3503">						.get(idEmployee);</span>
<span class="nc" id="L3504">				EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) hmEmployeeAdheranceStatus</span>
<span class="nc" id="L3505">						.get(idEmployee);</span>
<span class="nc" id="L3506">				employeeAdheranceStatus.setEmployeeName(employeeName);</span>
<span class="nc" id="L3507">			}</span>

<span class="nc" id="L3509">			Collection colAllPlannedEvents = m_scheduleAccessManager</span>
<span class="nc" id="L3510">					.getPublishedEventsForWorkResourcesFromCache(</span>
							colEmployeeIDs, dateStartWin, dateCurrent);
			{
<span class="nc" id="L3513">				Iterator itEmployeeID = colEmployeeIDs.iterator();</span>
<span class="nc" id="L3514">				for (Iterator itPlannedEvents = colAllPlannedEvents.iterator(); itPlannedEvents</span>
<span class="nc bnc" id="L3515" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L3516">					Collection colPlannedEvents = (Collection) itPlannedEvents</span>
<span class="nc" id="L3517">							.next();</span>
<span class="nc" id="L3518">					ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc bnc" id="L3519" title="All 2 branches missed.">					if (colPlannedEvents == null)</span>
<span class="nc" id="L3520">						continue;</span>
<span class="nc" id="L3521">					colPlannedEvents = EventUtils</span>
<span class="nc" id="L3522">							.convertEventsToTimelineForSingleEmployee(colPlannedEvents);</span>
<span class="nc" id="L3523">					Event eventPlanned = null;</span>
					// This is a hack to get the top most event. It relies on
					// order of collection.
<span class="nc" id="L3526">					for (Iterator i2 = colPlannedEvents.iterator(); i2</span>
<span class="nc bnc" id="L3527" title="All 2 branches missed.">							.hasNext();) {</span>
<span class="nc" id="L3528">						Event eventPlannedTemp = (Event) i2.next();</span>

<span class="nc bnc" id="L3530" title="All 2 branches missed.">						if (eventPlannedTemp.getStartTime().after(dateCurrent))</span>
<span class="nc" id="L3531">							break;</span>
<span class="nc" id="L3532">						tsActivityMappingsToLoad.add(eventPlannedTemp</span>
<span class="nc" id="L3533">								.getActivityID());</span>
<span class="nc bnc" id="L3534" title="All 2 branches missed.">						if (eventPlannedTemp.getEndTime().before(dateCurrent))</span>
<span class="nc" id="L3535">							continue;</span>
<span class="nc bnc" id="L3536" title="All 2 branches missed.">						if (!eventPlannedTemp.getActivityID().equals(</span>
								Activity.ACTIVITY_NONE))
<span class="nc" id="L3538">							eventPlanned = eventPlannedTemp;</span>
<span class="nc" id="L3539">					}</span>

<span class="nc" id="L3541">					EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn</span>
<span class="nc" id="L3542">							.get(idEmployee);</span>
<span class="nc" id="L3543">					employeeDataIn.setPlannedEvents(colPlannedEvents);</span>

<span class="nc bnc" id="L3545" title="All 2 branches missed.">					if (eventPlanned == null)</span>
<span class="nc" id="L3546">						continue;</span>
<span class="nc" id="L3547">					ID idPlannedActivity = eventPlanned.getActivityID();</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">					if (idPlannedActivity != null</span>
							&amp;&amp; !idPlannedActivity
<span class="nc bnc" id="L3550" title="All 2 branches missed.">									.equals(Activity.ACTIVITY_DELETED)</span>
							&amp;&amp; !idPlannedActivity
<span class="nc bnc" id="L3552" title="All 2 branches missed.">									.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L3553">						EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) hmEmployeeAdheranceStatus</span>
<span class="nc" id="L3554">								.get(idEmployee);</span>
<span class="nc" id="L3555">						employeeAdheranceStatus</span>
<span class="nc" id="L3556">								.setPlannedActivityID(idPlannedActivity);</span>
<span class="nc" id="L3557">						tsActivitiesToLoad.add(idPlannedActivity);</span>
					}
<span class="nc" id="L3559">				}</span>
			}
<span class="nc" id="L3561">			HashMap hmAllActualEvents = m_timeRecordManager</span>
<span class="nc" id="L3562">					.getEventsForWorkResourceFromCache(colEmployeeIDs,</span>
							dateStartWin, dateCurrent, true);
<span class="nc" id="L3564">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L3565" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L3566">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L3567">				Collection colActualEvents = (Collection) hmAllActualEvents</span>
<span class="nc" id="L3568">						.get(idEmployee);</span>
<span class="nc bnc" id="L3569" title="All 2 branches missed.">				if (colActualEvents == null)</span>
<span class="nc" id="L3570">					continue;</span>
<span class="nc" id="L3571">				EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn</span>
<span class="nc" id="L3572">						.get(idEmployee);</span>
<span class="nc" id="L3573">				employeeDataIn.setActualEvents(colActualEvents);</span>
				// Get last event.
<span class="nc" id="L3575">				Event eventActual = null;</span>
<span class="nc bnc" id="L3576" title="All 2 branches missed.">				for (Iterator i2 = colActualEvents.iterator(); i2.hasNext();)</span>
<span class="nc" id="L3577">					eventActual = (Event) i2.next();</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">				if (eventActual == null)</span>
<span class="nc" id="L3579">					continue;</span>
<span class="nc" id="L3580">				Collection colTimeEntries = eventActual.getChildren();</span>
<span class="nc bnc" id="L3581" title="All 2 branches missed.">				for (Iterator i2 = colTimeEntries.iterator(); i2.hasNext();) {</span>
<span class="nc" id="L3582">					eventActual = (Event) i2.next();</span>
<span class="nc bnc" id="L3583" title="All 2 branches missed.">					if (eventActual.getEndTime().after(dateCurrent))</span>
<span class="nc" id="L3584">						break;</span>
				}

<span class="nc" id="L3587">				ID idActualActivity = eventActual.getActivityID();</span>
<span class="nc bnc" id="L3588" title="All 2 branches missed.">				if (idActualActivity != null</span>
<span class="nc bnc" id="L3589" title="All 2 branches missed.">						&amp;&amp; !idActualActivity.equals(Activity.ACTIVITY_DELETED)</span>
<span class="nc bnc" id="L3590" title="All 2 branches missed.">						&amp;&amp; !idActualActivity.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L3591">					int nSecondsInState = (int) ((dateCurrent.getTime() - eventActual</span>
<span class="nc" id="L3592">							.getStartTime().getTime()) / 1000);</span>
<span class="nc" id="L3593">					EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) hmEmployeeAdheranceStatus</span>
<span class="nc" id="L3594">							.get(idEmployee);</span>
<span class="nc" id="L3595">					employeeAdheranceStatus.setSecondsInState(nSecondsInState);</span>
<span class="nc" id="L3596">					employeeAdheranceStatus</span>
<span class="nc" id="L3597">							.setActualActivityID(idActualActivity);</span>
<span class="nc" id="L3598">					tsActivitiesToLoad.add(idActualActivity);</span>
				}
<span class="nc" id="L3600">			}</span>

<span class="nc" id="L3602">			HashMap hmActivityMappings = m_rtaaService</span>
<span class="nc" id="L3603">					.loadActivityMappings(tsActivityMappingsToLoad);</span>
<span class="nc" id="L3604">			tsActivityMappingsToLoad.addAll(tsActivitiesToLoad);</span>
<span class="nc" id="L3605">			HashMap hmActivities = loadActivities(tsActivityMappingsToLoad);</span>

<span class="nc" id="L3607">			RTAADataIn rtaaDataIn = new RTAADataIn(colEmployeeIDs,</span>
					hmEmployeeDataIn, hmActivityMappings, hmActivities,
					dateStartWin, dateCurrent);

<span class="nc" id="L3611">			Collection colAllAdheranceViolations = m_rtaaService</span>
<span class="nc" id="L3612">					.getAdheranceExceptionsForEmployees(rtaaDataIn);</span>
<span class="nc" id="L3613">			Iterator i2 = colAllAdheranceViolations.iterator();</span>
<span class="nc bnc" id="L3614" title="All 2 branches missed.">			for (Iterator i = colEmployeeIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3615">				ID idEmployee = (ID) i.next();</span>
<span class="nc" id="L3616">				Collection colAdheranceViolations = (Collection) i2.next();</span>
<span class="nc" id="L3617">				EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) hmEmployeeAdheranceStatus</span>
<span class="nc" id="L3618">						.get(idEmployee);</span>
<span class="nc" id="L3619">				int nNonAdheringSeconds = 0;</span>
<span class="nc" id="L3620">				Date dateEndLastException = null;</span>
<span class="nc" id="L3621">				ID idPlannedActivityLastException = null;</span>
<span class="nc" id="L3622">				for (Iterator i3 = colAdheranceViolations.iterator(); i3</span>
<span class="nc bnc" id="L3623" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L3624">					RTAAException rtaaException = (RTAAException) i3.next();</span>
<span class="nc" id="L3625">					long lDuration = rtaaException.getEndTime().getTime()</span>
<span class="nc" id="L3626">							- rtaaException.getStartTime().getTime();</span>
<span class="nc" id="L3627">					long lDurationSeconds = lDuration / 1000;</span>
<span class="nc bnc" id="L3628" title="All 2 branches missed.">					if (dateEndLastException != null) {</span>
<span class="nc bnc" id="L3629" title="All 2 branches missed.">						if (rtaaException.isDeleted()</span>
<span class="nc bnc" id="L3630" title="All 2 branches missed.">								|| rtaaException.isApproved()</span>
<span class="nc bnc" id="L3631" title="All 2 branches missed.">								|| rtaaException.getStartTime().after(</span>
										dateEndLastException))
<span class="nc" id="L3633">							nNonAdheringSeconds = 0;</span>
<span class="nc bnc" id="L3634" title="All 2 branches missed.">						if (!bContinuousNonAdherance</span>
<span class="nc" id="L3635">								&amp;&amp; !rtaaException.getPlannedActivityID()</span>
<span class="nc bnc" id="L3636" title="All 2 branches missed.">										.equals(idPlannedActivityLastException))</span>
<span class="nc" id="L3637">							nNonAdheringSeconds = 0;</span>
					}
<span class="nc bnc" id="L3639" title="All 4 branches missed.">					if (rtaaException.isDeleted() || rtaaException.isApproved())</span>
<span class="nc" id="L3640">						continue;</span>
<span class="nc" id="L3641">					nNonAdheringSeconds += lDurationSeconds;</span>
<span class="nc" id="L3642">					dateEndLastException = rtaaException.getEndTime();</span>
<span class="nc" id="L3643">					idPlannedActivityLastException = rtaaException</span>
<span class="nc" id="L3644">							.getPlannedActivityID();</span>
<span class="nc" id="L3645">				}</span>
<span class="nc bnc" id="L3646" title="All 2 branches missed.">				if (dateEndLastException != null) {</span>
<span class="nc bnc" id="L3647" title="All 2 branches missed.">					if (!dateEndLastException.before(dateCurrent))</span>
<span class="nc" id="L3648">						employeeAdheranceStatus</span>
<span class="nc" id="L3649">								.setSecondsOutOfAdherance(nNonAdheringSeconds);</span>
				}
<span class="nc" id="L3651">			}</span>
<span class="nc" id="L3652">			HashMap hmActivitySummaries = new HashMap();</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">			for (Iterator i = tsActivitiesToLoad.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3654">				ID idActivity = (ID) i.next();</span>
<span class="nc" id="L3655">				Activity activity = (Activity) hmActivities.get(idActivity);</span>
<span class="nc" id="L3656">				ActivityAdheranceStatusSummary activityAdheranceStatusSummary = new ActivityAdheranceStatusSummary(</span>
<span class="nc" id="L3657">						idActivity, activity.getName(), activity.getColor(),</span>
<span class="nc" id="L3658">						activity.getColorCode());</span>
<span class="nc" id="L3659">				hmActivitySummaries.put(idActivity,</span>
						activityAdheranceStatusSummary);
<span class="nc" id="L3661">			}</span>
<span class="nc" id="L3662">			int nNumOutOfAdherance = 0;</span>
<span class="nc" id="L3663">			int nTotalSecondsOutOfAdherance = 0;</span>
<span class="nc" id="L3664">			int nNumTooLongInState = 0;</span>
<span class="nc" id="L3665">			int nTotalSecondsTooLongInState = 0;</span>
<span class="nc" id="L3666">			int nTotalScheduled = 0;</span>
<span class="nc" id="L3667">			int nTotalWorking = 0;</span>

			// get org assignment for activity overrides
<span class="nc" id="L3670">			boolean hasActivityOverrideLicense = hasActivityOverrideLicense();</span>
<span class="nc" id="L3671">			Map mapWrAssignments = null;</span>
<span class="nc" id="L3672">			TimeOffHoursManagerBridge bridge = null;</span>

<span class="nc bnc" id="L3674" title="All 2 branches missed.">			if (hasActivityOverrideLicense) {</span>
<span class="nc" id="L3675">				mapWrAssignments = m_workResourceManager</span>
<span class="nc" id="L3676">						.getWRAssignmentsWithTimeZone(colEmployeeIDs);</span>
<span class="nc" id="L3677">				bridge = getTimeOffHoursManagerBridge();</span>
			}

<span class="nc bnc" id="L3680" title="All 2 branches missed.">			for (Iterator i = colEmployeeIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3681">				ID idEmployee = (ID) i.next();</span>
<span class="nc" id="L3682">				EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) hmEmployeeAdheranceStatus</span>
<span class="nc" id="L3683">						.get(idEmployee);</span>

<span class="nc" id="L3685">				ID idPlannedActivity = employeeAdheranceStatus</span>
<span class="nc" id="L3686">						.getPlannedActivityID();</span>
<span class="nc bnc" id="L3687" title="All 2 branches missed.">				if (idPlannedActivity != null) {</span>
<span class="nc" id="L3688">					ActivityAdheranceStatusSummary aassPlanned = (ActivityAdheranceStatusSummary) hmActivitySummaries</span>
<span class="nc" id="L3689">							.get(idPlannedActivity);</span>
<span class="nc" id="L3690">					aassPlanned</span>
<span class="nc" id="L3691">							.setNumScheduled(aassPlanned.getNumScheduled() + 1);</span>
<span class="nc" id="L3692">					nTotalScheduled++;</span>
<span class="nc bnc" id="L3693" title="All 2 branches missed.">					if (employeeAdheranceStatus.getSecondsOutOfAdherance() &gt; 0) {</span>
<span class="nc" id="L3694">						aassPlanned.setNumSecondsOutOfAdherance(aassPlanned</span>
<span class="nc" id="L3695">								.getNumSecondsOutOfAdherance()</span>
								+ employeeAdheranceStatus
<span class="nc" id="L3697">										.getSecondsOutOfAdherance());</span>
					}
				}
<span class="nc bnc" id="L3700" title="All 2 branches missed.">				if (employeeAdheranceStatus.getSecondsOutOfAdherance() &gt; 0) {</span>
<span class="nc" id="L3701">					nNumOutOfAdherance++;</span>
<span class="nc" id="L3702">					nTotalSecondsOutOfAdherance += employeeAdheranceStatus</span>
<span class="nc" id="L3703">							.getSecondsOutOfAdherance();</span>
				}

<span class="nc" id="L3706">				ID idActualActivity = employeeAdheranceStatus</span>
<span class="nc" id="L3707">						.getActualActivityID();</span>
<span class="nc bnc" id="L3708" title="All 2 branches missed.">				if (idActualActivity != null) {</span>
<span class="nc" id="L3709">					Activity activityActual = (Activity) hmActivities</span>
<span class="nc" id="L3710">							.get(idActualActivity);</span>
<span class="nc bnc" id="L3711" title="All 2 branches missed.">					if (!activityActual.isOut())</span>
<span class="nc" id="L3712">						nTotalWorking++;</span>
<span class="nc" id="L3713">					ActivityAdheranceStatusSummary aassActual = (ActivityAdheranceStatusSummary) hmActivitySummaries</span>
<span class="nc" id="L3714">							.get(idActualActivity);</span>
<span class="nc" id="L3715">					aassActual.setNumWorking(aassActual.getNumWorking() + 1);</span>
<span class="nc" id="L3716">					int nActualActivityMaxDuration = getMaxDuration(</span>
							activityActual, dateStartWin,
							hasActivityOverrideLicense, mapWrAssignments,
							idEmployee, bridge) * 60;

<span class="nc" id="L3721">					aassActual.setNumSecondsInState(aassActual</span>
<span class="nc" id="L3722">							.getNumSecondsInState()</span>
<span class="nc" id="L3723">							+ employeeAdheranceStatus.getSecondsInState());</span>

<span class="nc bnc" id="L3725" title="All 4 branches missed.">					if (employeeAdheranceStatus.getSecondsInState() &gt; nActualActivityMaxDuration</span>
							&amp;&amp; nActualActivityMaxDuration &gt;= 0) {
<span class="nc" id="L3727">						int nSecondsViolatingMaxDuration = employeeAdheranceStatus</span>
<span class="nc" id="L3728">								.getSecondsInState()</span>
								- nActualActivityMaxDuration;
<span class="nc" id="L3730">						employeeAdheranceStatus</span>
<span class="nc" id="L3731">								.setSecondsViolatingMaxDuration(nSecondsViolatingMaxDuration);</span>
<span class="nc" id="L3732">						aassActual</span>
<span class="nc" id="L3733">								.setNumSecondsOfMaxDurationViolation(aassActual</span>
<span class="nc" id="L3734">										.getNumSecondsOfMaxDurationViolation()</span>
										+ nSecondsViolatingMaxDuration);
<span class="nc" id="L3736">						aassActual.setNumViolatingMaxDuration(aassActual</span>
<span class="nc" id="L3737">								.getNumViolatingMaxDuration() + 1);</span>
<span class="nc" id="L3738">						nNumTooLongInState++;</span>
<span class="nc" id="L3739">						nTotalSecondsTooLongInState += nSecondsViolatingMaxDuration;</span>
					}
				}
<span class="nc" id="L3742">			}</span>
<span class="nc" id="L3743">			AdheranceStatusData adheranceStatusData = new AdheranceStatusData(</span>
					new LinkedList(colEmployeeIDs), hmEmployeeAdheranceStatus,
					hmActivitySummaries, nNumOutOfAdherance,
					nTotalSecondsOutOfAdherance, nNumTooLongInState,
					nTotalSecondsTooLongInState, nTotalScheduled, nTotalWorking);

			// Add Quick View Day Summary information if user timezone is
			// specified
<span class="nc bnc" id="L3751" title="All 2 branches missed.">			if (userTimeZone != null)</span>
<span class="nc" id="L3752">				addDaySummaryData(adheranceStatusData, nSortField,</span>
						bIsAscending, nOffset, nMaxEmployees, userTimeZone);

			LocaleContext localeContext = DefaultLocalizationManager
<span class="nc" id="L3756">					.getDefaultInstance().getLocaleContext();</span>
<span class="nc" id="L3757">			adheranceStatusData.sortEmployees(colPushedEmployeeIDs, nSortField,</span>
					bIsAscending, localeContext);
<span class="nc" id="L3759">			Collection colEmployeeAdheranceStatus = adheranceStatusData</span>
<span class="nc" id="L3760">					.getEmployeeAdheranceStatusCol();</span>

<span class="nc" id="L3762">			Collection colEmployeeAdheranceStatusPage = new LinkedList();</span>
<span class="nc" id="L3763">			int nIndex = 0;</span>
<span class="nc" id="L3764">			for (Iterator i = colEmployeeAdheranceStatus.iterator(); i</span>
<span class="nc bnc" id="L3765" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L3766">				EmployeeAdheranceStatus employeeAdheranceStatus = (EmployeeAdheranceStatus) i</span>
<span class="nc" id="L3767">						.next();</span>
<span class="nc bnc" id="L3768" title="All 4 branches missed.">				if (nIndex &gt;= nOffset &amp;&amp; nIndex &lt; nOffset + nMaxEmployees)</span>
<span class="nc" id="L3769">					colEmployeeAdheranceStatusPage.add(employeeAdheranceStatus);</span>
<span class="nc" id="L3770">				nIndex++;</span>
<span class="nc" id="L3771">			}</span>
<span class="nc" id="L3772">			adheranceStatusData</span>
<span class="nc" id="L3773">					.setEmployeeAdheranceStatusCol(colEmployeeAdheranceStatusPage);</span>
<span class="nc" id="L3774">			return adheranceStatusData;</span>
<span class="nc" id="L3775">		} catch (RemoteException e) {</span>
<span class="nc" id="L3776">			handleException(e);</span>
<span class="nc" id="L3777">			throw new BbmFinderException(e);</span>
<span class="nc" id="L3778">		} catch (BbmException e) {</span>
<span class="nc" id="L3779">			handleException(e);</span>
<span class="nc" id="L3780">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3782">			methodFinish();</span>
		}
	}

	/**
	 * Get the Maximum Time In Activity setting (AKA Max Duration Threshold) for
	 * an activity. If the &quot;SpecialActivityOverrides&quot; license is present, we
	 * check the special activity duration value from the ORGANIZATIONCONFIG
	 * table. These settings are specified on the &quot;App Admin \ Activities \
	 * Special Activities&quot; page.
	 */
	private int getMaxDuration(Activity activity, Date start,
			boolean hasActivityOverrideLicense, Map mapWrAssignments, ID empID,
			TimeOffHoursManagerBridge bridge) throws RemoteException,
			BbmFinderException {
<span class="nc" id="L3797">		int nActualActivityMaxDuration = activity.getMaxDurationThreshold();</span>

<span class="nc bnc" id="L3799" title="All 2 branches missed.">		if (hasActivityOverrideLicense) {</span>
			// get employee org assignment at dateStartWin
<span class="nc" id="L3801">			Collection wrAssignments = (Collection) mapWrAssignments.get(empID);</span>
<span class="nc" id="L3802">			WorkResourceAssignment assignment = null;</span>

<span class="nc bnc" id="L3804" title="All 2 branches missed.">			for (Iterator iInner = wrAssignments.iterator(); iInner.hasNext();) {</span>
<span class="nc" id="L3805">				assignment = (WorkResourceAssignment) iInner.next();</span>
<span class="nc bnc" id="L3806" title="All 2 branches missed.">				if (!assignment.getStartTime().after(start)</span>
<span class="nc bnc" id="L3807" title="All 2 branches missed.">						&amp;&amp; ((assignment.getEndTime() == null) || assignment</span>
<span class="nc bnc" id="L3808" title="All 2 branches missed.">								.getEndTime().after(start)))</span>
<span class="nc" id="L3809">					break;</span>
			}

<span class="nc bnc" id="L3812" title="All 2 branches missed.">			if (assignment == null) {</span>
				// take the first one
<span class="nc" id="L3814">				assignment = (WorkResourceAssignment) wrAssignments.iterator()</span>
<span class="nc" id="L3815">						.next();</span>
			}

			// find max duration override
<span class="nc" id="L3819">			nActualActivityMaxDuration = bridge.getMaxDurationOverride(</span>
<span class="nc" id="L3820">					assignment.getOrganizationID(), activity.getID());</span>
		}

<span class="nc" id="L3823">		return nActualActivityMaxDuration;</span>
	}

	/**
	 * Add the Day Summary data to the AdheranceStatusData. the Day Summary data
	 * includes the scheduled and exceptions millisecond values for each
	 * employee, and overall.
	 *
	 * @param adheranceStatusData
	 *            - contains all the standard status summary info. We will add
	 *            the Day Summary data.
	 * @param nSortField
	 * @param bIsAscending
	 * @param nOffset
	 * @param nMaxEmployees
	 * @param userTimeZone
	 *            The user preference TimeZone of the person viewing the Quick
	 *            View page.
	 */
	private void addDaySummaryData(AdheranceStatusData adheranceStatusData,
			int nSortField, boolean bIsAscending, int nOffset,
			int nMaxEmployees, TimeZone userTimeZone) throws BbmFinderException {
<span class="nc" id="L3845">		Collection empIDs = adheranceStatusData.getEmployeeIDs();</span>
<span class="nc" id="L3846">		Calendar cal = Calendar.getInstance(userTimeZone);</span>
		// right now
<span class="nc" id="L3848">		Date end = cal.getTime();</span>
<span class="nc" id="L3849">		AdherenceSummaryUtil.adjustToDayStart(cal);</span>
		// midnight this morning in view timezone
<span class="nc" id="L3851">		Date start = cal.getTime();</span>

		// does it matter?
<span class="nc" id="L3854">		boolean showUnavailable = true;</span>
<span class="nc" id="L3855">		RTAAData rtaaData = getRTAAData(empIDs, start, end, nSortField,</span>
				bIsAscending, nOffset, nMaxEmployees, null, showUnavailable);
<span class="nc" id="L3857">		HashMap hmActivityMappings = rtaaData.getActivityMappings();</span>

<span class="nc" id="L3859">		HashMap empAdheranceStatusMap = adheranceStatusData</span>
<span class="nc" id="L3860">				.getEmployeeAdheranceStatus();</span>
<span class="nc" id="L3861">		CalendarRange aDay = new CalendarRange(start, end);</span>
<span class="nc" id="L3862">		Collection colEmployeeData = rtaaData.getEmployeeData();</span>
		// Changing type to long from int (for totalScheduledTime &amp;
		// totalExceptionTime) for QA-96175 to avoid int overflow issue.
<span class="nc" id="L3865">		long totalScheduledTime = 0;</span>
<span class="nc" id="L3866">		long totalExceptionTime = 0;</span>
<span class="nc bnc" id="L3867" title="All 2 branches missed.">		for (Iterator it = colEmployeeData.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3868">			EmployeeData employeeData = (EmployeeData) it.next();</span>
<span class="nc" id="L3869">			ID empID = employeeData.getEmployeeID();</span>
<span class="nc" id="L3870">			EmployeeAdheranceStatus empAdheranceStatus = (EmployeeAdheranceStatus) empAdheranceStatusMap</span>
<span class="nc" id="L3871">					.get(empID);</span>

<span class="nc bnc" id="L3873" title="All 2 branches missed.">			if (empAdheranceStatus != null) {</span>
				// Collection of SimpleEvents
<span class="nc" id="L3875">				Collection plannedEvents = employeeData.getPlannedEvents();</span>
				// Collection of RTAAExceptions
<span class="nc" id="L3877">				Collection rtaaExceptions = employeeData.getAdheranceViolations();</span>
				//Collection of SimpleEvents
				int totals[];
<span class="nc" id="L3880">				totals = AdherenceSummaryUtil.calculateDaySummaryData(aDay,</span>
						plannedEvents, rtaaExceptions, hmActivityMappings);
<span class="nc" id="L3882">				int scheduled = totals[2];</span>
<span class="nc" id="L3883">				int exceptions = totals[3];</span>
<span class="nc" id="L3884">				totalScheduledTime += scheduled;</span>
<span class="nc" id="L3885">				totalExceptionTime += exceptions;</span>

<span class="nc" id="L3887">				empAdheranceStatus.setNumSummaryScheduled(scheduled);</span>
<span class="nc" id="L3888">				empAdheranceStatus.setNumSummaryExceptions(exceptions);</span>
<span class="nc" id="L3889">				float percentage = AdherenceSummaryUtil.getPercentage(</span>
						scheduled, exceptions);
<span class="nc" id="L3891">				empAdheranceStatus.setNumSummaryPercentage(percentage);</span>
			}
<span class="nc" id="L3893">		}</span>
<span class="nc" id="L3894">		adheranceStatusData.setNumSummaryScheduled(totalScheduledTime);</span>
<span class="nc" id="L3895">		adheranceStatusData.setNumSummaryExceptions(totalExceptionTime);</span>
<span class="nc" id="L3896">		float totalPercentage = AdherenceSummaryUtil.getPercentage(</span>
				totalScheduledTime, totalExceptionTime);
<span class="nc" id="L3898">		adheranceStatusData.setNumSummaryPercentage(totalPercentage);</span>
<span class="nc" id="L3899">	}</span>

	public void addOrganizationDays(ID idOrganization, ID idSP,
			String strTimeZoneID, int nDayBoundaryOffset, int nWeekStartDay,
			Jdmo jdmo, ArrayList&lt;Object[]&gt; colFieldValues, Date dateStart, Date dateEnd)
			throws JdmoException {

<span class="nc" id="L3906">		TimeZone tzLocal = TimeZone.getTimeZone(strTimeZoneID);</span>
<span class="nc" id="L3907">		Calendar calStart = Calendar.getInstance(tzLocal);</span>
<span class="nc" id="L3908">		calStart.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L3909">		calStart.set(Calendar.MINUTE, nDayBoundaryOffset);</span>
<span class="nc" id="L3910">		calStart.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L3911">		calStart.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L3912">		calStart.add(Calendar.YEAR, -10);</span>
<span class="nc" id="L3913">		Calendar calEnd = (Calendar) calStart.clone();</span>
<span class="nc" id="L3914">		calEnd.add(Calendar.YEAR, 10 * 2);</span>

<span class="nc" id="L3916">		Calendar calLocalDay = new GregorianCalendar();</span>
<span class="nc" id="L3917">		calLocalDay.setTimeZone(tzLocal);</span>
<span class="nc" id="L3918">		Calendar calLocalWeek = new GregorianCalendar();</span>
<span class="nc" id="L3919">		calLocalWeek.setTimeZone(tzLocal);</span>

<span class="nc bnc" id="L3921" title="All 2 branches missed.">		if (dateStart != null) {</span>
<span class="nc" id="L3922">			calStart.setTime(dateStart);</span>
		}
<span class="nc bnc" id="L3924" title="All 2 branches missed.">		if (dateEnd != null) {</span>
<span class="nc" id="L3925">			calEnd.setTime(dateEnd);</span>
		}

<span class="nc" id="L3928">		int counter = 0;</span>
<span class="nc" id="L3929">		Date nextStart = calStart.getTime();</span>
<span class="nc" id="L3930">		Date start = calStart.getTime();</span>
<span class="nc" id="L3931">		Date end = calEnd.getTime();</span>
<span class="nc bnc" id="L3932" title="All 2 branches missed.">		while (nextStart.before(end)) {</span>
			// calc current day from the start
			// day start
<span class="nc" id="L3935">			calStart.setTime(start);</span>
<span class="nc" id="L3936">			calStart.add(Calendar.DAY_OF_YEAR, counter++);</span>
<span class="nc" id="L3937">			Timestamp tsStart = new Timestamp(calStart.getTimeInMillis());</span>
<span class="nc" id="L3938">			Date date = calStart.getTime();</span>

			// day end
<span class="nc" id="L3941">			calEnd.setTime(start);</span>
<span class="nc" id="L3942">			calEnd.add(Calendar.DAY_OF_YEAR, counter);</span>
<span class="nc" id="L3943">			Date dateIntervalEnd = calEnd.getTime();</span>
<span class="nc" id="L3944">			Timestamp tsEnd = new Timestamp(dateIntervalEnd.getTime());</span>

<span class="nc" id="L3946">			calLocalDay.setTime(calStart.getTime());</span>

<span class="nc" id="L3948">			LocalDate localDateDay = new LocalDate(</span>
<span class="nc" id="L3949">					calLocalDay.get(Calendar.YEAR),</span>
<span class="nc" id="L3950">					calLocalDay.get(Calendar.MONTH),</span>
<span class="nc" id="L3951">					calLocalDay.get(Calendar.DATE), 0, 0);</span>
<span class="nc" id="L3952">			Timestamp tsLocalDay = new Timestamp(localDateDay.getTime(</span>
<span class="nc" id="L3953">					TimeZone.getTimeZone(&quot;GMT&quot;)).getTime());</span>

<span class="nc" id="L3955">			int nDayOfWeek = calLocalDay.get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L3956">			calLocalWeek.setTime(date);</span>

<span class="nc" id="L3958">			calLocalWeek.add(Calendar.DATE, nWeekStartDay - nDayOfWeek);</span>
<span class="nc bnc" id="L3959" title="All 2 branches missed.">			if (calLocalWeek.after(calLocalDay)) {</span>
<span class="nc" id="L3960">				calLocalWeek.add(Calendar.DATE, -7);</span>
			}

<span class="nc" id="L3963">			LocalDate localDateWeek = new LocalDate(</span>
<span class="nc" id="L3964">					calLocalWeek.get(Calendar.YEAR),</span>
<span class="nc" id="L3965">					calLocalWeek.get(Calendar.MONTH),</span>
<span class="nc" id="L3966">					calLocalWeek.get(Calendar.DATE), 0, 0);</span>
<span class="nc" id="L3967">			Timestamp tsLocalWeek = new Timestamp(localDateWeek.getTime(</span>
<span class="nc" id="L3968">					TimeZone.getTimeZone(&quot;GMT&quot;)).getTime());</span>

<span class="nc" id="L3970">			Object arrFieldValues[] = new Object[] { null, idOrganization,</span>
<span class="nc" id="L3971">					idSP, formatDBString(tsStart),</span>
<span class="nc" id="L3972">					formatDBString(tsEnd),</span>
<span class="nc" id="L3973">					formatDBString(tsLocalDay),</span>
<span class="nc" id="L3974">					formatDBString(tsLocalWeek) };</span>
<span class="nc" id="L3975">			colFieldValues.add(arrFieldValues);</span>
<span class="nc" id="L3976">			nextStart = dateIntervalEnd;</span>
<span class="nc" id="L3977">		}</span>
<span class="nc" id="L3978">	}</span>

	public Collection getEmployeesInWrongActivity(Collection colEmployeeIDs,
			Collection colPlannedActivityIDs, Collection colActualActivityIDs)
			throws BbmFinderException {
<span class="nc" id="L3983">		methodStart(&quot;getEmployeesInWrongActivity&quot;, colEmployeeIDs,</span>
				colPlannedActivityIDs, colActualActivityIDs);

<span class="nc" id="L3986">		Collection colEmployeesNotWorkingPlannedActivity = new LinkedList();</span>
<span class="nc" id="L3987">		Date dateCurrentTime = Calendar.getInstance().getTime();</span>
<span class="nc" id="L3988">		Date dateStartWin = new Date(dateCurrentTime.getTime() - 1000);</span>
		try {
<span class="nc" id="L3990">			Collection colAllPlannedEvents = m_scheduleAccessManager</span>
<span class="nc" id="L3991">					.getPublishedEventsForWorkResourcesFromCache(</span>
							colEmployeeIDs, dateStartWin, dateCurrentTime);

			{
<span class="nc" id="L3995">				Iterator itEmployeeID = colEmployeeIDs.iterator();</span>
<span class="nc" id="L3996">				for (Iterator itPlannedEvents = colAllPlannedEvents.iterator(); itPlannedEvents</span>
<span class="nc bnc" id="L3997" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L3998">					Collection colPlannedEvents = (Collection) itPlannedEvents</span>
<span class="nc" id="L3999">							.next();</span>
<span class="nc" id="L4000">					ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc bnc" id="L4001" title="All 2 branches missed.">					if (colPlannedEvents == null)</span>
<span class="nc" id="L4002">						colPlannedEvents = new LinkedList();</span>
					ID idActualActivity;
<span class="nc" id="L4004">					Event eventLastActivity = m_timeRecordManager.getLastEntry(</span>
							idEmployee, null);
<span class="nc bnc" id="L4006" title="All 2 branches missed.">					if (eventLastActivity == null)</span>
<span class="nc" id="L4007">						idActualActivity = Activity.ACTIVITY_NONE;</span>
					else
<span class="nc" id="L4009">						idActualActivity = eventLastActivity.getActivityID();</span>
<span class="nc bnc" id="L4010" title="All 2 branches missed.">					if (colActualActivityIDs != null</span>
<span class="nc bnc" id="L4011" title="All 2 branches missed.">							&amp;&amp; !colActualActivityIDs.isEmpty()</span>
<span class="nc bnc" id="L4012" title="All 2 branches missed.">							&amp;&amp; !colActualActivityIDs.contains(idActualActivity))</span>
<span class="nc" id="L4013">						continue;</span>
<span class="nc" id="L4014">					ID idPlannedActivity = Activity.ACTIVITY_NONE;</span>
<span class="nc" id="L4015">					colPlannedEvents = EventUtils</span>
<span class="nc" id="L4016">							.convertEventsToTimelineForSingleEmployee(colPlannedEvents);</span>
					// This is a hack to get the top most event. It relies on
					// order of collection.
<span class="nc" id="L4019">					for (Iterator i2 = colPlannedEvents.iterator(); i2</span>
<span class="nc bnc" id="L4020" title="All 2 branches missed.">							.hasNext();) {</span>
<span class="nc" id="L4021">						Event eventPlanned = (Event) i2.next();</span>

<span class="nc bnc" id="L4023" title="All 2 branches missed.">						if (eventPlanned.getStartTime().after(dateCurrentTime))</span>
<span class="nc" id="L4024">							break;</span>
<span class="nc bnc" id="L4025" title="All 2 branches missed.">						if (eventPlanned.getEndTime().before(dateCurrentTime))</span>
<span class="nc" id="L4026">							continue;</span>
<span class="nc" id="L4027">						idPlannedActivity = eventPlanned.getActivityID();</span>
<span class="nc" id="L4028">					}</span>
<span class="nc bnc" id="L4029" title="All 2 branches missed.">					if (colPlannedActivityIDs != null</span>
<span class="nc bnc" id="L4030" title="All 2 branches missed.">							&amp;&amp; !colPlannedActivityIDs.isEmpty()</span>
							&amp;&amp; !colPlannedActivityIDs
<span class="nc bnc" id="L4032" title="All 2 branches missed.">									.contains(idPlannedActivity))</span>
<span class="nc" id="L4033">						continue;</span>

<span class="nc bnc" id="L4035" title="All 2 branches missed.">					if (m_rtaaService.isAdheringTo(idActualActivity,</span>
							idPlannedActivity))
<span class="nc" id="L4037">						colEmployeesNotWorkingPlannedActivity.add(idEmployee);</span>
<span class="nc" id="L4038">				}</span>
			}
<span class="nc" id="L4040">			return colEmployeesNotWorkingPlannedActivity;</span>
<span class="nc" id="L4041">		} catch (RemoteException e) {</span>
<span class="nc" id="L4042">			handleException(e);</span>
<span class="nc" id="L4043">			throw new BbmFinderException(e);</span>
<span class="nc" id="L4044">		} catch (BbmException e) {</span>
<span class="nc" id="L4045">			handleException(e);</span>
<span class="nc" id="L4046">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4048">			methodFinish();</span>
		}

	}

	public HashMap getAdheranceStatusForEmployees(Collection colEmployeeIDs,
			int nLookbackMinutes, boolean bContinuousNonAdherance)
			throws BbmFinderException {
<span class="nc" id="L4056">		methodStart(&quot;getAdheranceStatusForEmployees&quot;, colEmployeeIDs);</span>
		try {
<span class="nc" id="L4058">			HashMap hmEmployeesAdheranceStatus = new HashMap();</span>

<span class="nc" id="L4060">			Date dateCurrent = getCurrentTime();</span>
<span class="nc" id="L4061">			Date dateLookbackTime = dateCurrent;</span>
<span class="nc" id="L4062">			Date dateStartWin = new Date(dateCurrent.getTime()</span>
					- (QUICK_VIEW_LOOKBACK_LIMIT + 60000));

<span class="nc bnc" id="L4065" title="All 2 branches missed.">			if (nLookbackMinutes &gt; 0) {</span>
<span class="nc" id="L4066">				Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L4067">				cal.setTime(dateCurrent);</span>
<span class="nc" id="L4068">				cal.add(Calendar.MINUTE, -nLookbackMinutes);</span>
<span class="nc" id="L4069">				dateLookbackTime = cal.getTime();</span>
			}

<span class="nc" id="L4072">			HashMap hmAdheranceOverrides = m_rtaaService.getAdheranceOverrides(</span>
					colEmployeeIDs, dateStartWin, dateCurrent);
<span class="nc" id="L4074">			HashMap hmEmployeeDataIn = new HashMap();</span>
<span class="nc" id="L4075">			TreeSet tsActivitiesToLoad = new TreeSet();</span>
<span class="nc" id="L4076">			TreeSet tsActivityMappingsToLoad = new TreeSet();</span>

<span class="nc" id="L4078">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L4079" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L4080">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L4081">				EmployeeDataIn employeeDataIn = new EmployeeDataIn(idEmployee);</span>
<span class="nc" id="L4082">				hmEmployeeDataIn.put(idEmployee, employeeDataIn);</span>

<span class="nc" id="L4084">				Collection colAdheranceOverrides = (Collection) hmAdheranceOverrides</span>
<span class="nc" id="L4085">						.get(idEmployee);</span>
<span class="nc bnc" id="L4086" title="All 2 branches missed.">				if (colAdheranceOverrides == null)</span>
<span class="nc" id="L4087">					colAdheranceOverrides = new LinkedList();</span>
<span class="nc" id="L4088">				employeeDataIn.setAdheranceOverrides(colAdheranceOverrides);</span>

<span class="nc" id="L4090">			}</span>

<span class="nc" id="L4092">			HashMap hmEmployeeNames = m_workResourceManager</span>
<span class="nc" id="L4093">					.getEmployeeNamesByIDs(colEmployeeIDs);</span>

<span class="nc" id="L4095">			Collection colAllPlannedEvents = m_scheduleAccessManager</span>
<span class="nc" id="L4096">					.getPublishedEventsForWorkResourcesFromCache(</span>
							colEmployeeIDs, dateStartWin, dateCurrent);
			{
<span class="nc" id="L4099">				Iterator itEmployeeID = colEmployeeIDs.iterator();</span>
<span class="nc" id="L4100">				for (Iterator itPlannedEvents = colAllPlannedEvents.iterator(); itPlannedEvents</span>
<span class="nc bnc" id="L4101" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L4102">					Collection colPlannedEvents = (Collection) itPlannedEvents</span>
<span class="nc" id="L4103">							.next();</span>
<span class="nc" id="L4104">					ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc bnc" id="L4105" title="All 2 branches missed.">					if (colPlannedEvents == null)</span>
<span class="nc" id="L4106">						continue;</span>
<span class="nc" id="L4107">					colPlannedEvents = EventUtils</span>
<span class="nc" id="L4108">							.convertEventsToTimelineForSingleEmployee(colPlannedEvents);</span>

<span class="nc" id="L4110">					EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn</span>
<span class="nc" id="L4111">							.get(idEmployee);</span>
<span class="nc" id="L4112">					employeeDataIn.setPlannedEvents(colPlannedEvents);</span>
					// This is a hack to get the top most event. It relies on
					// order of collection.
<span class="nc" id="L4115">					for (Iterator i2 = colPlannedEvents.iterator(); i2</span>
<span class="nc bnc" id="L4116" title="All 2 branches missed.">							.hasNext();) {</span>
<span class="nc" id="L4117">						Event eventPlannedTemp = (Event) i2.next();</span>

<span class="nc bnc" id="L4119" title="All 2 branches missed.">						if (eventPlannedTemp.getStartTime().after(dateCurrent))</span>
<span class="nc" id="L4120">							break;</span>
<span class="nc" id="L4121">						tsActivityMappingsToLoad.add(eventPlannedTemp</span>
<span class="nc" id="L4122">								.getActivityID());</span>
<span class="nc bnc" id="L4123" title="All 2 branches missed.">						if (eventPlannedTemp.getEndTime().before(dateCurrent))</span>
<span class="nc" id="L4124">							continue;</span>
<span class="nc" id="L4125">					}</span>

<span class="nc" id="L4127">				}</span>
			}

<span class="nc" id="L4130">			HashMap hmAllActualEvents = m_timeRecordManager</span>
<span class="nc" id="L4131">					.getEventsForWorkResourceFromCache(colEmployeeIDs,</span>
							dateStartWin, dateCurrent, true);
<span class="nc" id="L4133">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID</span>
<span class="nc bnc" id="L4134" title="All 2 branches missed.">					.hasNext();) {</span>
<span class="nc" id="L4135">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="nc" id="L4136">				Collection colActualEvents = (Collection) hmAllActualEvents</span>
<span class="nc" id="L4137">						.get(idEmployee);</span>
<span class="nc bnc" id="L4138" title="All 2 branches missed.">				if (colActualEvents == null)</span>
<span class="nc" id="L4139">					continue;</span>
<span class="nc" id="L4140">				EmployeeDataIn employeeDataIn = (EmployeeDataIn) hmEmployeeDataIn</span>
<span class="nc" id="L4141">						.get(idEmployee);</span>
<span class="nc" id="L4142">				employeeDataIn.setActualEvents(colActualEvents);</span>
				// Get event has the end time after look back time and before
				// current time.
<span class="nc" id="L4145">				Event eventActual = null;</span>
<span class="nc bnc" id="L4146" title="All 2 branches missed.">				for (Iterator i2 = colActualEvents.iterator(); i2.hasNext();) {</span>
<span class="nc" id="L4147">					eventActual = (Event) i2.next();</span>
<span class="nc bnc" id="L4148" title="All 2 branches missed.">					if (eventActual == null)</span>
<span class="nc" id="L4149">						continue;</span>

<span class="nc bnc" id="L4151" title="All 2 branches missed.">					if (eventActual.getEndTime().after(dateLookbackTime)) {</span>
<span class="nc" id="L4152">						ID idActualActivity = eventActual.getActivityID();</span>
<span class="nc bnc" id="L4153" title="All 2 branches missed.">						if (idActualActivity != null</span>
								&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4155" title="All 2 branches missed.">										.equals(Activity.ACTIVITY_DELETED)</span>
								&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4157" title="All 2 branches missed.">										.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L4158">							tsActivitiesToLoad.add(idActualActivity);</span>
						}
					}

<span class="nc" id="L4162">					Collection colTimeEntries = eventActual.getChildren();</span>
<span class="nc bnc" id="L4163" title="All 2 branches missed.">					for (Iterator i3 = colTimeEntries.iterator(); i3.hasNext();) {</span>
<span class="nc" id="L4164">						eventActual = (Event) i3.next();</span>
<span class="nc bnc" id="L4165" title="All 2 branches missed.">						if (eventActual.getEndTime().after(dateCurrent))</span>
<span class="nc" id="L4166">							break;</span>

<span class="nc bnc" id="L4168" title="All 2 branches missed.">						if (eventActual.getEndTime().after(dateLookbackTime)) {</span>
<span class="nc" id="L4169">							ID idActualActivity = eventActual.getActivityID();</span>
<span class="nc bnc" id="L4170" title="All 2 branches missed.">							if (idActualActivity != null</span>
									&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4172" title="All 2 branches missed.">											.equals(Activity.ACTIVITY_DELETED)</span>
									&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4174" title="All 2 branches missed.">											.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L4175">								tsActivitiesToLoad.add(idActualActivity);</span>
							}
<span class="nc" id="L4177">						}</span>
					}
<span class="nc" id="L4179">				}</span>

<span class="nc" id="L4181">			}</span>

<span class="nc" id="L4183">			HashMap hmActivityMappings = m_rtaaService</span>
<span class="nc" id="L4184">					.loadActivityMappings(tsActivityMappingsToLoad);</span>
<span class="nc" id="L4185">			tsActivityMappingsToLoad.addAll(tsActivitiesToLoad);</span>
<span class="nc" id="L4186">			HashMap hmActivities = loadActivities(tsActivityMappingsToLoad);</span>

<span class="nc" id="L4188">			RTAADataIn rtaaDataIn = new RTAADataIn(colEmployeeIDs,</span>
					hmEmployeeDataIn, hmActivityMappings, hmActivities,
					dateStartWin, dateCurrent);

<span class="nc" id="L4192">			Collection colAllAdheranceViolations = m_rtaaService</span>
<span class="nc" id="L4193">					.getAdheranceExceptionsForEmployees(rtaaDataIn);</span>
<span class="nc" id="L4194">			Iterator i2 = colAllAdheranceViolations.iterator();</span>
<span class="nc bnc" id="L4195" title="All 2 branches missed.">			for (Iterator i = colEmployeeIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4196">				ID idEmployee = (ID) i.next();</span>
<span class="nc" id="L4197">				EmployeeName employeeName = (EmployeeName) hmEmployeeNames</span>
<span class="nc" id="L4198">						.get(idEmployee);</span>

<span class="nc" id="L4200">				Collection colAdheranceViolations = (Collection) i2.next();</span>
<span class="nc" id="L4201">				Collection colEmployeeAdheranceStatus = new LinkedList();</span>

<span class="nc" id="L4203">				int nNonAdheringSeconds = 0;</span>
<span class="nc" id="L4204">				Date dateEndLastException = null;</span>
<span class="nc" id="L4205">				ID idPlannedActivityLastException = null;</span>
<span class="nc" id="L4206">				for (Iterator i3 = colAdheranceViolations.iterator(); i3</span>
<span class="nc bnc" id="L4207" title="All 2 branches missed.">						.hasNext();) {</span>
<span class="nc" id="L4208">					RTAAException rtaaException = (RTAAException) i3.next();</span>

					// break if exception end time is before look back time
<span class="nc bnc" id="L4211" title="All 2 branches missed.">					if (rtaaException.getEndTime().before(dateLookbackTime))</span>
<span class="nc" id="L4212">						continue;</span>

<span class="nc" id="L4214">					long lDuration = rtaaException.getEndTime().getTime()</span>
<span class="nc" id="L4215">							- rtaaException.getStartTime().getTime();</span>
<span class="nc" id="L4216">					long lDurationSeconds = lDuration / 1000;</span>

<span class="nc bnc" id="L4218" title="All 2 branches missed.">					if (dateEndLastException != null) {</span>
<span class="nc bnc" id="L4219" title="All 2 branches missed.">						if (rtaaException.isDeleted()</span>
<span class="nc bnc" id="L4220" title="All 2 branches missed.">								|| rtaaException.isApproved()</span>
<span class="nc bnc" id="L4221" title="All 2 branches missed.">								|| rtaaException.getStartTime().after(</span>
										dateEndLastException))
<span class="nc" id="L4223">							nNonAdheringSeconds = 0;</span>
<span class="nc bnc" id="L4224" title="All 2 branches missed.">						if (!bContinuousNonAdherance</span>
<span class="nc" id="L4225">								&amp;&amp; !rtaaException.getPlannedActivityID()</span>
<span class="nc bnc" id="L4226" title="All 2 branches missed.">										.equals(idPlannedActivityLastException))</span>
<span class="nc" id="L4227">							nNonAdheringSeconds = 0;</span>
					}
<span class="nc bnc" id="L4229" title="All 4 branches missed.">					if (rtaaException.isDeleted() || rtaaException.isApproved())</span>
<span class="nc" id="L4230">						continue;</span>
<span class="nc" id="L4231">					nNonAdheringSeconds += lDurationSeconds;</span>
<span class="nc" id="L4232">					dateEndLastException = rtaaException.getEndTime();</span>
<span class="nc" id="L4233">					idPlannedActivityLastException = rtaaException</span>
<span class="nc" id="L4234">							.getPlannedActivityID();</span>

<span class="nc" id="L4236">					EmployeeAdheranceStatus employeeAdheranceStatus = new EmployeeAdheranceStatus(</span>
							idEmployee);

<span class="nc" id="L4239">					employeeAdheranceStatus.setEmployeeName(employeeName);</span>
<span class="nc" id="L4240">					employeeAdheranceStatus</span>
<span class="nc" id="L4241">							.setSecondsOutOfAdherance(nNonAdheringSeconds);</span>
<span class="nc" id="L4242">					employeeAdheranceStatus.setPlannedActivityID(rtaaException</span>
<span class="nc" id="L4243">							.getPlannedActivityID());</span>

					// set actual eventid
<span class="nc" id="L4246">					Collection colActualEvents = (Collection) hmAllActualEvents</span>
<span class="nc" id="L4247">							.get(idEmployee);</span>
<span class="nc bnc" id="L4248" title="All 2 branches missed.">					if (colActualEvents != null) {</span>
						// Get event belongs to the exception period.
<span class="nc" id="L4250">						Event eventActual = null;</span>
<span class="nc" id="L4251">						loop4: for (Iterator i4 = colActualEvents.iterator(); i4</span>
<span class="nc bnc" id="L4252" title="All 2 branches missed.">								.hasNext();) {</span>
<span class="nc" id="L4253">							Event eventTemp1 = (Event) i4.next();</span>

<span class="nc" id="L4255">							Collection colTimeEntries = eventTemp1</span>
<span class="nc" id="L4256">									.getChildren();</span>
<span class="nc" id="L4257">							for (Iterator i5 = colTimeEntries.iterator(); i5</span>
<span class="nc bnc" id="L4258" title="All 2 branches missed.">									.hasNext();) {</span>
<span class="nc" id="L4259">								Event eventTemp2 = (Event) i5.next();</span>
<span class="nc bnc" id="L4260" title="All 2 branches missed.">								if (eventTemp2.getEndTime().equals(</span>
<span class="nc" id="L4261">										rtaaException.getEndTime())</span>
<span class="nc bnc" id="L4262" title="All 2 branches missed.">										|| (eventTemp2.getEndTime().after(</span>
<span class="nc" id="L4263">												rtaaException.getEndTime()) &amp;&amp; eventTemp2</span>
<span class="nc bnc" id="L4264" title="All 2 branches missed.">												.getStartTime().before(</span>
														rtaaException
<span class="nc" id="L4266">																.getEndTime()))) {</span>
<span class="nc" id="L4267">									eventActual = eventTemp2;</span>
<span class="nc" id="L4268">									break loop4;</span>
								}
<span class="nc" id="L4270">							}</span>

<span class="nc bnc" id="L4272" title="All 2 branches missed.">							if (eventTemp1.getEndTime().equals(</span>
<span class="nc" id="L4273">									rtaaException.getEndTime())</span>
<span class="nc bnc" id="L4274" title="All 2 branches missed.">									|| (eventTemp1.getEndTime().after(</span>
<span class="nc" id="L4275">											rtaaException.getEndTime()) &amp;&amp; eventTemp1</span>
<span class="nc bnc" id="L4276" title="All 2 branches missed.">											.getStartTime().before(</span>
<span class="nc" id="L4277">													rtaaException.getEndTime()))) {</span>
<span class="nc" id="L4278">								eventActual = eventTemp1;</span>
<span class="nc" id="L4279">								break;</span>
							}
<span class="nc" id="L4281">						}</span>

<span class="nc bnc" id="L4283" title="All 2 branches missed.">						if (eventActual != null) {</span>
<span class="nc" id="L4284">							ID idActualActivity = eventActual.getActivityID();</span>
<span class="nc bnc" id="L4285" title="All 2 branches missed.">							if (idActualActivity != null</span>
									&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4287" title="All 2 branches missed.">											.equals(Activity.ACTIVITY_DELETED)</span>
									&amp;&amp; !idActualActivity
<span class="nc bnc" id="L4289" title="All 2 branches missed.">											.equals(Activity.ACTIVITY_NONE)) {</span>
<span class="nc" id="L4290">								employeeAdheranceStatus</span>
<span class="nc" id="L4291">										.setActualActivityID(idActualActivity);</span>
							}
						}
					}
<span class="nc" id="L4295">					colEmployeeAdheranceStatus.add(employeeAdheranceStatus);</span>
<span class="nc" id="L4296">				}</span>
<span class="nc" id="L4297">				hmEmployeesAdheranceStatus.put(idEmployee,</span>
						colEmployeeAdheranceStatus);
<span class="nc" id="L4299">			}</span>

<span class="nc" id="L4301">			return hmEmployeesAdheranceStatus;</span>
<span class="nc" id="L4302">		} catch (RemoteException e) {</span>
<span class="nc" id="L4303">			handleException(e);</span>
<span class="nc" id="L4304">			throw new BbmFinderException(e);</span>
<span class="nc" id="L4305">		} catch (BbmException e) {</span>
<span class="nc" id="L4306">			handleException(e);</span>
<span class="nc" id="L4307">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4309">			methodFinish();</span>
		}
	}

	public void updateOrganizationDays(Jdmo jdmo) throws JdmoException {
<span class="nc" id="L4314">		methodStart(&quot;updateOrganizationDays&quot;);</span>
		try {
<span class="nc" id="L4316">			ArrayList colFieldValues = new ArrayList();</span>

<span class="nc" id="L4318">			Collection colOrganizationIDsWithoutData = new LinkedList();</span>
<span class="nc" id="L4319">			String strQuery = &quot;select ID, TIMEZONE, DAYBOUNDARYOFFSET, WEEKSTARTDAY from ORGANIZATION&quot;;</span>
<span class="nc" id="L4320">			strQuery += &quot; where ID not in (SELECT distinct ORGANIZATIONID FROM ORGANIZATIONDAY WHERE ORGANIZATIONID is not null)&quot;;</span>

			// use jdmo insertBatchAndExcute

<span class="nc" id="L4324">			JdmoRowset r = jdmo.createRowset(strQuery);</span>

<span class="nc bnc" id="L4326" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L4327">				ID idOrganization = r.getID(&quot;ID&quot;);</span>
<span class="nc" id="L4328">				String strTimeZoneID = r.getString(&quot;TIMEZONE&quot;);</span>
<span class="nc" id="L4329">				int nDayBoundaryOffset = r.getInt(&quot;DAYBOUNDARYOFFSET&quot;);</span>
<span class="nc" id="L4330">				int nWeekStartDay = r.getInt(&quot;WEEKSTARTDAY&quot;);</span>
<span class="nc" id="L4331">				addOrganizationDays(idOrganization, null, strTimeZoneID,</span>
						nDayBoundaryOffset, nWeekStartDay, jdmo,
						colFieldValues, null, null);

<span class="nc" id="L4335">				String arrFieldNames[] = new String[] { &quot;ID&quot;, &quot;ORGANIZATIONID&quot;,</span>
						&quot;SPID&quot;, &quot;STARTTIME&quot;, &quot;ENDTIME&quot;, &quot;LOCALDAY&quot;, &quot;LOCALWEEK&quot; };
<span class="nc" id="L4337">				int arrFieldTypes[] = { Types.INTEGER, Types.INTEGER,</span>
						Types.INTEGER, Types.TIMESTAMP, Types.TIMESTAMP,
						Types.TIMESTAMP, Types.TIMESTAMP };

<span class="nc" id="L4341">				jdmo.insertBatchAndExecute(&quot;ORGANIZATIONDAY&quot;, arrFieldNames,</span>
						arrFieldTypes, colFieldValues);
<span class="nc" id="L4343">				colFieldValues.clear();</span>

<span class="nc" id="L4345">			}</span>
<span class="nc" id="L4346">			strQuery = &quot;select SP.SID ID, FROMDATE, TODATE, JAVATZIDENT TIMEZONE, CAMPAIGN.WEEKSTART from &quot;</span>
					+ &quot;SP, CAMPAIGN, TIMEZONE, TIMEZONEMAP where CAMPAIGN.ID = SP.CAMPAIGNID &quot;
					+ &quot;and TIMEZONE.ID = CAMPAIGN.TIMEZONEID and TIMEZONEMAP.WINTZSTDNAME = TIMEZONE.STANDARDNAME&quot;;

<span class="nc" id="L4350">			strQuery += &quot; and SP.SID not in (select distinct SPID from ORGANIZATIONDAY where SPID is not null)&quot;;</span>

<span class="nc" id="L4352">			r = jdmo.createRowset(strQuery);</span>

<span class="nc bnc" id="L4354" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L4355">				ID idSP = r.getID(&quot;ID&quot;);</span>
<span class="nc" id="L4356">				String strTimeZoneID = r.getString(&quot;TIMEZONE&quot;);</span>
<span class="nc" id="L4357">				Timestamp tsStartDate = r.getTimestamp(&quot;FROMDATE&quot;);</span>
<span class="nc" id="L4358">				Timestamp tsEndDate = r.getTimestamp(&quot;TODATE&quot;);</span>

<span class="nc" id="L4360">				int nWeekStart = r.getInt(&quot;WEEKSTART&quot;);</span>
<span class="nc" id="L4361">				int nDayBoundaryOffset = nWeekStart % (60 * 24);</span>
<span class="nc" id="L4362">				int nWeekStartDay = (nWeekStart / (60 * 24)) + 1;</span>
<span class="nc" id="L4363">				addOrganizationDays(null, idSP, strTimeZoneID,</span>
						nDayBoundaryOffset, nWeekStartDay, jdmo,
						colFieldValues, tsStartDate, tsEndDate);
<span class="nc" id="L4366">				String arrFieldNames[] = new String[] { &quot;ID&quot;, &quot;ORGANIZATIONID&quot;,</span>
						&quot;SPID&quot;, &quot;STARTTIME&quot;, &quot;ENDTIME&quot;, &quot;LOCALDAY&quot;, &quot;LOCALWEEK&quot; };
<span class="nc" id="L4368">				int arrFieldTypes[] = { Types.INTEGER, Types.INTEGER,</span>
						Types.INTEGER, Types.TIMESTAMP, Types.TIMESTAMP,
						Types.TIMESTAMP, Types.TIMESTAMP };

<span class="nc" id="L4372">				jdmo.insertBatchAndExecute(&quot;ORGANIZATIONDAY&quot;, arrFieldNames,</span>
						arrFieldTypes, colFieldValues);
<span class="nc" id="L4374">				colFieldValues.clear();</span>
<span class="nc" id="L4375">			}</span>
		} finally {
<span class="nc" id="L4377">			methodFinish();</span>
<span class="nc" id="L4378">		}</span>
<span class="nc" id="L4379">	}</span>

	private Jdmo getWarehouseJdmo() {
<span class="nc" id="L4382">		Jdmo jdmoWarehouse = new Jdmo(JdmoFinal.JDMO_JNDI_ADVISORWAREHOUSE_DSN,</span>
				true);
		try {
<span class="nc" id="L4385">			jdmoWarehouse.createRowset(&quot;Select 1 from DBVERSION&quot;);</span>
<span class="nc" id="L4386">		} catch (Exception e) {</span>
<span class="nc" id="L4387">			jdmoWarehouse = null;</span>
<span class="nc" id="L4388">		}</span>
<span class="nc" id="L4389">		return jdmoWarehouse;</span>
	}

	private void cleanupWarehouseJdmo(Jdmo jdmoWarehouse) {
<span class="nc bnc" id="L4393" title="All 2 branches missed.">		if (jdmoWarehouse != null) {</span>
<span class="nc" id="L4394">			jdmoWarehouse.cleanUp();</span>
<span class="nc" id="L4395">			jdmoWarehouse = null;</span>
		}
<span class="nc" id="L4397">	}</span>

	private Collection getEmployeesWhosDefaultTimeOffHourCountChanged(
			Collection colEmployeeIDsChunk, Date dateLastUpdated, Jdmo dmo)
			throws JdmoException {
<span class="nc" id="L4402">		ArrayList ids = new ArrayList();</span>

<span class="nc" id="L4404">		StringBuffer sb = new StringBuffer(500);</span>
<span class="nc" id="L4405">		sb.append(&quot; select distinct primaryobjectid from audittrailentry entry &quot;);</span>
<span class="nc" id="L4406">		sb.append(&quot; where entry.moduleid = 4 and &quot;);</span>
<span class="nc" id="L4407">		sb.append(&quot; entry.atwhen &gt; '&quot;)</span>
<span class="nc" id="L4408">				.append(JdmoUtil.formatDBString(dateLastUpdated))</span>
<span class="nc" id="L4409">				.append(&quot;' and &quot;);</span>
<span class="nc" id="L4410">		sb.append(&quot; primaryobjectid in &quot;)</span>
<span class="nc" id="L4411">				.append(dmo.createInClause(colEmployeeIDsChunk))</span>
<span class="nc" id="L4412">				.append(&quot; and &quot;);</span>
<span class="nc" id="L4413">		sb.append(&quot; exists(select 1 from audittrailproperty prop where  entry.id = prop.audittrailentryid and prop.containertype = 'EMPLOYEETIMEOFF')&quot;);</span>

<span class="nc" id="L4415">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L4416" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L4417">			ids.add(rs.getID(1));</span>
		}
<span class="nc" id="L4419">		return ids;</span>
	}

	public void setEmployeeFiltersNeedToBeDump(Collection filterIDs) {
<span class="nc" id="L4423">		dumpedEmpFilterIDs = filterIDs;</span>
<span class="nc" id="L4424">	}</span>

<span class="nc" id="L4426">	private static HashMap lastDumpTimeByUserID = new HashMap();</span>

	public void dumpEmployeeFiltersByUserID(ID idUser) throws RemoteException,
			BbmFinderException, JdmoException {
<span class="nc" id="L4430">		methodStart(&quot;dumpEmployeeFiltersByUserID&quot;, idUser);</span>
<span class="nc" id="L4431">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4433">			boolean isOnDemandDump = m_dbConfigManager</span>
<span class="nc bnc" id="L4434" title="All 2 branches missed.">					.getIntValue(ConfigKey.CRYSTAL_REPORTS_EMPLOYEEFILTER_DUMP_ONDEMAND) == 1 ? true</span>
					: false;
<span class="nc bnc" id="L4436" title="All 2 branches missed.">			if (!isOnDemandDump)</span>
<span class="nc" id="L4437">				return;</span>
<span class="nc" id="L4438">			Date lastDumpTime = (Date) lastDumpTimeByUserID.get(idUser);</span>
<span class="nc" id="L4439">			Date cur = new Date();</span>
<span class="nc bnc" id="L4440" title="All 2 branches missed.">			if (lastDumpTime == null</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">					|| cur.after(TimeZoneUtil.addDay(lastDumpTime))) {</span>
				// out of 24 hours window, need redump
<span class="nc" id="L4443">				Collection filters = this.m_employeeFilter</span>
<span class="nc" id="L4444">						.getFiltersByUserID(idUser);</span>
<span class="nc" id="L4445">				dumpEmpFilters(jdmo, filters);</span>
<span class="nc" id="L4446">				lastDumpTimeByUserID.put(idUser, cur);</span>
			}
		} finally {
<span class="nc" id="L4449">			jdmo.cleanUp();</span>
<span class="nc" id="L4450">			methodFinish();</span>
<span class="nc" id="L4451">		}</span>
<span class="nc" id="L4452">	}</span>

	/**
	 * Sync Data to What If DB.
	 *
	 * @throws JdmoException
	 * @throws BbmException
	 * @throws RemoteException
	 */
	public void syncWhatIfDB() throws JdmoException, BbmException,
			RemoteException {
<span class="nc" id="L4463">		methodStart(&quot;syncWhatIfDB&quot;);</span>
<span class="nc" id="L4464">		Jdmo jdmo = new Jdmo(&quot;jdbc/bpmaindb_wif&quot;, false);</span>
		try {
<span class="nc" id="L4466">			JdmoQuery query = jdmo.createQuery(&quot;dbo.BP_COPYTABLES_RS&quot;,</span>
					Jdmo.STORPROC_QUERY_NORS);
<span class="nc" id="L4468">			jdmo.execute(query);</span>
<span class="nc" id="L4469">		} catch (JdmoException e) {</span>
<span class="nc" id="L4470">			handleException(e);</span>
<span class="nc" id="L4471">			throw e;</span>
		} finally {
<span class="nc" id="L4473">			jdmo.cleanUp();</span>
<span class="nc" id="L4474">			methodFinish();</span>
<span class="nc" id="L4475">		}</span>
<span class="nc" id="L4476">	}</span>

	/**
	 * get What If status
	 *
	 * @return 2 -- synchronizing 1 -- users in what-if mode 0 -- OK to Sync
	 *
	 * @throws JdmoException
	 */
	public int getWhatIfStatus() throws JdmoException {
<span class="nc" id="L4486">		methodStart(&quot;getWhatIfStatus&quot;);</span>
<span class="nc" id="L4487">		Jdmo jdmo = getJdmoForWIFOperation();</span>
		try {
<span class="nc" id="L4489">			JdmoQuery query = jdmo.createQuery(&quot;dbo.GETWHATIFSTATUS&quot;,</span>
					Jdmo.STORPROC_QUERY_NORS);
<span class="nc" id="L4491">			query.regParInt(1);</span>
<span class="nc" id="L4492">			jdmo.execute(query);</span>
<span class="nc" id="L4493">			return query.getParInt(1);</span>

<span class="nc" id="L4495">		} catch (JdmoException e) {</span>
<span class="nc" id="L4496">			handleException(e);</span>
<span class="nc" id="L4497">			throw e;</span>
		} finally {
<span class="nc" id="L4499">			jdmo.cleanUp();</span>
<span class="nc" id="L4500">			methodFinish();</span>
		}
	}

	public boolean isWIFSyncCanceledBefore() throws JdmoException {
<span class="nc" id="L4505">		methodStart(&quot;isWIFSyncCanceledBefore&quot;);</span>
<span class="nc" id="L4506">		Jdmo jdmo = getJdmoForWIFOperation();</span>
		try {
<span class="nc" id="L4508">			JdmoRowset rs = jdmo</span>
<span class="nc" id="L4509">					.createRowset(&quot;SELECT ISCOPYCANCELLED, STATUS FROM dbo.WHATIFSTATUS&quot;);</span>
<span class="nc" id="L4510">			int isCancelled = -1;</span>
<span class="nc" id="L4511">			int status = -1;</span>
<span class="nc bnc" id="L4512" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4513">				isCancelled = Integer.parseInt(rs.getString(&quot;ISCOPYCANCELLED&quot;));</span>
<span class="nc" id="L4514">				status = Integer.parseInt(rs.getString(STATUS_FIELD));</span>
				break;
			}
<span class="nc bnc" id="L4517" title="All 4 branches missed.">			return !(isCancelled == 0 &amp;&amp; status != 0);</span>
<span class="nc" id="L4518">		} catch (JdmoException e) {</span>
<span class="nc" id="L4519">			handleException(e);</span>
<span class="nc" id="L4520">			throw e;</span>
		} finally {
<span class="nc" id="L4522">			jdmo.cleanUp();</span>
<span class="nc" id="L4523">			methodFinish();</span>
		}
	}

	public void cancelWIFSync() {
<span class="nc" id="L4528">		methodStart(&quot;cancelWIFSync&quot;);</span>
<span class="nc" id="L4529">		Jdmo jdmo = getJdmoForWIFOperation();</span>
		try {
<span class="nc" id="L4531">			jdmo.execute(&quot;UPDATE dbo.WHATIFSTATUS SET ISCOPYCANCELLED = 1 WHERE STATUS &lt;&gt; 2 AND PCTTABLESDONE &lt;&gt; 100&quot;);</span>
<span class="nc" id="L4532">		} catch (JdmoException e) {</span>
			// don't to throw exception, if cancel failed --&gt; let if be, just
			// handle the exception
<span class="nc" id="L4535">			handleException(e);</span>
		} finally {
<span class="nc" id="L4537">			jdmo.cleanUp();</span>
<span class="nc" id="L4538">			methodFinish();</span>
<span class="nc" id="L4539">		}</span>
<span class="nc" id="L4540">	}</span>

	public boolean isWIFSynchonizing() {
<span class="nc" id="L4543">		methodStart(&quot;isWIFSynchonizing&quot;);</span>
<span class="nc" id="L4544">		Jdmo jdmo = getJdmoForWIFOperation();</span>
<span class="nc" id="L4545">		boolean result = false;</span>
		try {
<span class="nc" id="L4547">			JdmoRowset rs = jdmo</span>
<span class="nc" id="L4548">					.createRowset(&quot;SELECT ISCOPYCANCELLED, STATUS FROM dbo.WHATIFSTATUS&quot;);</span>

<span class="nc bnc" id="L4550" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc bnc" id="L4551" title="All 2 branches missed.">				result = (Integer.parseInt(rs.getString(&quot;STATUS&quot;)) == 1)</span>
<span class="nc bnc" id="L4552" title="All 2 branches missed.">						&amp;&amp; (Integer.parseInt(rs.getString(&quot;ISCOPYCANCELLED&quot;)) == 0);</span>
				break;
			}
<span class="nc" id="L4555">		} catch (JdmoException e) {</span>
			// don't to throw exception, if query value failed
<span class="nc" id="L4557">			handleException(e);</span>
		} finally {
<span class="nc" id="L4559">			jdmo.cleanUp();</span>
<span class="nc" id="L4560">			methodFinish();</span>
<span class="nc" id="L4561">		}</span>
<span class="nc" id="L4562">		return result;</span>
	}

	/**
	 *
	 * @return 0..100 --&gt; percent done but not complete -1 -- complete
	 */
	public int getWIFSyncPct() {
<span class="nc" id="L4570">		methodStart(&quot;getWIFSyncPct&quot;);</span>
<span class="nc" id="L4571">		Jdmo jdmo = getJdmoForWIFOperation();</span>
<span class="nc" id="L4572">		int status = 0;</span>
<span class="nc" id="L4573">		int pctDone = 0;</span>

		try {
<span class="nc" id="L4576">			JdmoRowset rs = jdmo</span>
<span class="nc" id="L4577">					.createRowset(&quot;SELECT PCTTABLESDONE, STATUS FROM dbo.WHATIFSTATUS&quot;);</span>

<span class="nc bnc" id="L4579" title="All 2 branches missed.">			while (rs.next()) {</span>
				try {
<span class="nc" id="L4581">					pctDone = rs.getShort(&quot;PCTTABLESDONE&quot;);</span>
<span class="nc" id="L4582">				} catch (NumberFormatException ex) {</span>
<span class="nc" id="L4583">					m_cat.debug(&quot;getWIFSyncPct(): An error occurred converting the value of PCTTABLESDONE to an int.  This is a safeguard if the value in the DB was null.  0 will be returned as the result.&quot;);</span>
<span class="nc" id="L4584">				}</span>
<span class="nc" id="L4585">				status = rs.getShort(STATUS_FIELD);</span>
				break;
			}

<span class="nc bnc" id="L4589" title="All 4 branches missed.">			if (pctDone == PCT_DONE &amp;&amp; status == STATUS_COMPLETE) {</span>
				// Sync Completed
<span class="nc" id="L4591">				pctDone = -1;</span>
			}
<span class="nc" id="L4593">		} catch (JdmoException e) {</span>
			// don't to throw exception, if cancel failed --&gt; let if be, just
			// handle the exception
<span class="nc" id="L4596">			handleException(e);</span>
		} finally {
<span class="nc" id="L4598">			jdmo.cleanUp();</span>
<span class="nc" id="L4599">			methodFinish();</span>
<span class="nc" id="L4600">		}</span>

<span class="nc" id="L4602">		return pctDone;</span>
	}

	Jdmo getJdmoForWIFOperation() {
<span class="nc" id="L4606">		return new Jdmo(JdmoFinal.JDMO_JNDI_DEFAULT_STDDSN, false);</span>
	}

	/**
	 * Dump the Remaining and Carryover hours into the EmployeeTimeOffAllotment
	 * table for Time Off Summary reports. This method breaks the employee ids
	 * into chunks, so that each chunk can be updated in its own transaction. If
	 * the chunkSize, lookBack or lookForward parameters are -1, then their
	 * value is gotten from a BPCONFIG setting.
	 *
	 * @param ids
	 *            - a collection of employee id's to dump the data for.
	 * @param threadID
	 *            - The thread number. Employees are dumped in multiple threads,
	 *            and each thread is given a number, starting with 1.
	 * @param lookBack
	 *            - How manay years back to dump. Pass -1 to get the value from
	 *            the BPCONFIG table.
	 * @param lookForward
	 *            - How manay years forward to dump. Pass -1 to get the value
	 *            from the BPCONFIG table.
	 * @param start
	 *            - Used to determine the lookBack. If not null, this date
	 *            overrides lookBack.
	 * @param end
	 *            - Used to determine the lookForward. If not null, this date
	 *            overrides lookForward.
	 */
	public Collection dumpTOReportDataWithResult(Collection ids, int threadID,
			int lookBack, int lookForward, Date start, Date end) {
<span class="nc" id="L4636">		methodStart(&quot;dumpTOReportDataWithResult&quot;, ids, new Integer(threadID),</span>
				new Integer(lookBack), new Integer(lookForward));
<span class="nc" id="L4638">		Collection failed = null;</span>
		try {
<span class="nc" id="L4640">			TimeOffHoursManagerBridge bridge = getTimeOffHoursManagerBridge();</span>

<span class="nc" id="L4642">			failed = bridge.dumpTOReportDataWithResult(ids, threadID, lookBack,</span>
					lookForward, start, end);
<span class="nc" id="L4644">		} catch (Exception e) {</span>
<span class="nc" id="L4645">			e.printStackTrace();</span>
<span class="nc" id="L4646">			System.out.println(e.getStackTrace());</span>
		} finally {
<span class="nc" id="L4648">			methodFinish();</span>
<span class="nc" id="L4649">		}</span>
<span class="nc" id="L4650">		return failed;</span>
	}

	private TimeOffHoursManagerBridge getTimeOffHoursManagerBridge()
			throws BbmException {
		try {
<span class="nc" id="L4656">			String gcrType = &quot;TIMEOFFHOURSMANAGER_BRIDGE&quot;;</span>
<span class="nc" id="L4657">			Collection entries = m_gcrManager.getGCREntryOfType(gcrType);</span>
<span class="nc" id="L4658">			Class clazz = Class</span>
<span class="nc" id="L4659">					.forName(((GCREntry) (entries.iterator().next())).getHook());</span>
<span class="nc" id="L4660">			TimeOffHoursManagerBridge bridge = (TimeOffHoursManagerBridge) clazz</span>
<span class="nc" id="L4661">					.newInstance();</span>
<span class="nc" id="L4662">			return bridge;</span>
<span class="nc" id="L4663">		} catch (Exception ex) {</span>
<span class="nc" id="L4664">			throw new BbmException(ex);</span>
		}
	}

	private boolean hasActivityOverrideLicense() throws RemoteException {
<span class="nc" id="L4669">		return m_licenseManager</span>
<span class="nc" id="L4670">				.isLicensed(LicenseKeys.SPECIAL_ACTIVITY_OVERRIDES);</span>
	}

	/**
	 * This method is a simple wrapper around JdmoUtil.formatDBString.
	 * It is here so that we can override the behavior for unit testing, without
	 * mocking JdmoUtil (which is difficult to mock without using PowerMock which
	 * is undesirable).
	 */
	String formatDBString(Timestamp timestamp) {
<span class="nc" id="L4680">		return JdmoUtil.formatDBString(timestamp);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>