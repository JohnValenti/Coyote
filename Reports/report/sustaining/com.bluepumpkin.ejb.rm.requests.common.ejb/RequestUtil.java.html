<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RequestUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.ejb</a> &gt; <span class="el_source">RequestUtil.java</span></div><h1>RequestUtil.java</h1><pre class="source lang-java linenums">/*
 * RequestUtil.java
 *
 * Created on January 31, 2003, 6:58 PM
 */

package com.bluepumpkin.ejb.rm.requests.common.ejb;

import java.io.StringWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.BitSet;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.ResourceBundle;
import java.util.Set;
import java.util.TimeZone;

import javax.ejb.EJBContext;
import javax.xml.parsers.DocumentBuilder;

import org.apache.log4j.Priority;
import org.apache.xml.serialize.OutputFormat;
import org.apache.xml.serialize.XMLSerializer;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;

import com.bluepumpkin.common.base.BPException;
import com.bluepumpkin.common.base.PersonName;
import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.PrimitiveTypes;
import com.bluepumpkin.common.datatypes.StringsPair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.employeefilter.ejb.EmployeeFilter;
import com.bluepumpkin.ejb.bbm.employeefilter.model.Filter;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceMinMaxHour;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.UnavailabilityEvent;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsConflict;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeMap;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffCalculatorException;
import com.bluepumpkin.ejb.bbm.vo.FieldInfoEntry;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectNode;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignmentFieldInfo;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.base.RmHardValidationException;
import com.bluepumpkin.ejb.rm.cache.CacheUtilRM;
import com.bluepumpkin.ejb.rm.l10n.ResourceBundleKeyWrapper;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.l10n.UnlocalizedStringWrapper;
import com.bluepumpkin.ejb.rm.notification.util.NotificationUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.commonrequestmanager.ejb.CommonRequestManager;
import com.bluepumpkin.ejb.rm.requests.flextime.ejb.FlexTimeRequestManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidRequestManager;
import com.bluepumpkin.ejb.rm.requests.swap.posting.ejb.ShiftSwapPostingManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.ejb.ShiftSwapRequestManager;
import com.bluepumpkin.ejb.rm.requests.swap.request.validation.ShiftSwapValidationCache;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.requests.timeoff.ejb.TORequestManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.ejb.TOHoursPerDayManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.hoursperday.model.TOHoursPerDay;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.ejb.TOWaitlistManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.ejb.TOWithdrawManager;
import com.bluepumpkin.ejb.rm.security.RmPrivilegeKeys;
import com.bluepumpkin.ejb.rm.setup.filingrules.model.RequestFilingRule;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.bluepumpkin.ejb.rm.util.ShiftSwapRequestUtil;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.SuperUserFacade;
import com.witness.ejb.core.security.model.User;
import com.witness.web.uif.l10n.UIFWebBundleKey;

/**
 *
 * @author RRajendran
 */
<span class="nc bnc" id="L149" title="All 2 branches missed.">@SuppressWarnings(&quot;deprecation&quot;)</span>
<span class="nc" id="L150">public class RequestUtil {</span>
	// controls the priority of tracing information written by RM subsystem.
	// Setting it to
	// INFO, instead of DEBUG, allows RM trace to be viewed without being
	// cluttered with DMO
	// trace (with priority DEBUG).
<span class="nc" id="L156">	public static Priority m_defaultTracePriority = Priority.DEBUG;</span>

	public static final int METHODTYPE_CREATOR = 1;
	public static final int METHODTYPE_FINDER = 2;
	public static final int METHODTYPE_MODIFIER = 4;
	public static final int METHODTYPE_PURGER = 8;
	public static final int METHODTYPE_ALL = METHODTYPE_CREATOR | METHODTYPE_FINDER | METHODTYPE_MODIFIER
			| METHODTYPE_PURGER;
	public static final int METHODTYPE_ALL_EXCEPT_FINDER = METHODTYPE_CREATOR | METHODTYPE_MODIFIER | METHODTYPE_PURGER;

	public static final String DAYRANGE_ALL_DAYS = RequestFilingRule.DAYRANGE_ALL_DAYS;
	public static final String DAYRANGE_DAY_TYPE = RequestFilingRule.DAYRANGE_DAY_TYPE;
	public static final String DAYRANGE_DATES = RequestFilingRule.DAYRANGE_DATES;

	public static final String DATECOMPARISION_ON_DATE = RequestFilingRule.DATECOMPARISION_ON_DATE;
	public static final String DATECOMPARISION_BEFORE_DATE = RequestFilingRule.DATECOMPARISION_BEFORE_DATE;
	public static final String DATECOMPARISION_AFTER_DATE = RequestFilingRule.DATECOMPARISION_AFTER_DATE;

	public static final String INTERVALTYPE_LESSTHAN = RequestFilingRule.INTERVALTYPE_LESSTHAN;
	public static final String INTERVALTYPE_EQUALTO = RequestFilingRule.INTERVALTYPE_EQUALTO;
	public static final String INTERVALTYPE_MORETHAN = RequestFilingRule.INTERVALTYPE_MORETHAN;

	public static final String TIMETYPE_BYDATE = RequestFilingRule.TIMETYPE_BYDATE;
	public static final String TIMETYPE_INTERVAL = RequestFilingRule.TIMETYPE_INTERVAL;

<span class="nc" id="L181">	private static Category m_cat = Log.initCategory(RequestUtil.class.getName());</span>

<span class="nc" id="L183">	protected static RmManagerFactory m_rmMgrFactory = null;</span>

<span class="nc" id="L185">	private static User m_bpSuperUser = null;</span>

<span class="nc" id="L187">	private static Boolean rmDebugEnabled = null;</span>

	// used only in test mode.
	// private static User m_bpSuperUserForTest;

<span class="nc" id="L192">	private static float MINUTE_IN_MILLIS = 60.0f * 1000.0f;</span>

	public static final int ACTION_CREATE = 1;
	public static final int ACTION_UPDATE = 2;
	public static final int ACTION_DELETE = 3;
	public static final int ACTION_FETCH = 4;

	public static final String DAYS = &quot;days&quot;;
	public static final String HOURS = &quot;hours&quot;;
	public static final String MINUTES = &quot;minutes&quot;;

	/** Jan 1st 2070 */
<span class="nc" id="L204">	public static final Date MAX_DATE = new Date(3155760000000L);</span>

	/**
	 * new Date(0)
	 */
<span class="nc" id="L209">	public static final Date DATE_MIN = new Date(0);</span>
	/**
	 * Date corresponding to Long.MAX_VALUE;
	 */
<span class="nc" id="L213">	public static final Date DATE_MAX = new Date(Long.MAX_VALUE);</span>



	public static final String SORTDIR_ASC = &quot; ASC &quot;;
	public static final String SORTDIR_DESC = &quot; DESC &quot;;
	public static final String ALL_FILTER = &quot;ALL_FILTER&quot;;
	public static final String DEFAULT_FILTER = &quot;default filter&quot;;
	public static final String WAITLIST_FILTER = &quot;WAITLIST_FILTER&quot;;

	public static final String TABLE_EMPLOYEEAM_ALIAS = &quot;EMPAM&quot;;
	public static final String TABLE_TOWAITLIST_ALIAS = &quot;TOW&quot;;
<span class="nc" id="L225">	private static final Map m_empIDorNameToUserCache = new HashMap(32);</span>

	private static final short ORG_SCOPE = Organization.SCOPE_TYPE;

<span class="nc" id="L229">	public static class ExceptionMessage {</span>
		protected boolean m_useBundle;
		protected String m_bundleName;
		protected String m_msgKey;
		protected Object[] m_parms;
		protected String m_msg;

<span class="nc" id="L236">		public ExceptionMessage(String nonLocalizedMsg) {</span>
<span class="nc" id="L237">			m_useBundle = false;</span>
<span class="nc" id="L238">			m_msg = nonLocalizedMsg;</span>
<span class="nc" id="L239">		}</span>

<span class="nc" id="L241">		public ExceptionMessage(String bundleName, String msgKey, Object[] parms) {</span>
<span class="nc" id="L242">			m_useBundle = true;</span>
<span class="nc" id="L243">			m_bundleName = bundleName;</span>
<span class="nc" id="L244">			m_msgKey = msgKey;</span>
<span class="nc" id="L245">			m_parms = parms;</span>
<span class="nc" id="L246">		}</span>

		public String getUnLocalizedMessage() {
			// Error, if message is localized already
<span class="nc bnc" id="L250" title="All 2 branches missed.">			if (m_useBundle) {</span>
				// just log the error and continue.
<span class="nc" id="L252">				RequestUtil.createRmException(RmEjbLogBundleKey.ERROR_MSG_LOCALIZED, m_cat);</span>
			}

<span class="nc" id="L255">			return m_msg;</span>
		}

		public String getBundleName() {
<span class="nc" id="L259">			return m_bundleName;</span>
		}

		public String getMsgKey() {
<span class="nc" id="L263">			return m_msgKey;</span>
		}

		public Object[] getMsgParms() {
<span class="nc" id="L267">			return m_parms;</span>
		}

		public boolean getUseBundle() {
<span class="nc" id="L271">			return m_useBundle;</span>
		}

	}

	/**
	 * Uses field names of a class to initialize the metadata array
	 * (FieldInfoEntry). Given a list of all fields of a class (static and
	 * instance) obtained thruough reflection, this list is filtered by the
	 * given field prefix to obtain the list of entires that describe the
	 * metadata (columns of the database)
	 *
	 * @param fieldEntries
	 *            array of FieldInfoEntries to be initialized
	 * @param classFields
	 *            array of Fields that describe the static and private instance
	 *            variables of a java class (obtained using Reflection).
	 * @param prefix
	 *            prefix to filter above field names.
	 */
	public final static void initFieldInfoEntries(FieldInfoEntry[] fieldEntries, Class classObj, String prefix,
			int numOfExpectedEntries) {
<span class="nc" id="L293">		int prefixLength = prefix.length();</span>
		// obtain all fields for the class.
<span class="nc" id="L295">		Field[] classFields = classObj.getDeclaredFields();</span>
		// number of entries extracted from the passed class object (classObj).
<span class="nc" id="L297">		int numOfExtractedEntries = 0;</span>
		// for each field in class
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for (int i = 0; i &lt; classFields.length; i++) {</span>
			// process only public fields as the Java Reflection API prevents
			// access
			// to protected or private fields
<span class="nc bnc" id="L303" title="All 2 branches missed.">			if (!Modifier.isPublic(classFields[i].getModifiers())) {</span>
<span class="nc" id="L304">				continue;</span>
			}

			// does field name start with prefix? we are looking for field names
			// coded
			// in the format 'prefix_type_name'
<span class="nc" id="L310">			String fieldName = classFields[i].getName(); // get field name</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">			if (!fieldName.startsWith(prefix)) {</span>
<span class="nc" id="L312">				continue;</span>
			}

			// obtain the integer value of the field. This integer value is used
			// as an index
			// into FieldInfo.m_arrFieldInfo[] and
			// ValueObjectBase.m_arrFieldValues[]
<span class="nc" id="L319">			int fieldEntryIndex = 0;</span>
			try {
<span class="nc" id="L321">				fieldEntryIndex = classFields[i].getInt(null); // if field is an</span>
																// integer (must
																// be), get
																// value
<span class="nc" id="L325">			} catch (Exception e) { // field is not an integer type. move on.</span>
				// This only logs the exception. This exception is not thrown
				// since a throws declaration cannot be added
				// to the method signature (method called by static initializer
				// by value object classes).
<span class="nc" id="L330">				RmException rmExcept = createRmExceptionWrapper(e, m_cat);</span>
<span class="nc" id="L331">				throw new IllegalArgumentException(</span>
						&quot;classFields[i].getInt(null) failed. Check log file for exception details&quot;);
<span class="nc" id="L333">			}</span>

			// now extract 'name' component from the coded field name:
			// prefix_type_name
<span class="nc bnc" id="L337" title="All 4 branches missed.">			assert (fieldEntryIndex &lt; fieldEntries.length) : &quot;(fieldEntryIndex &lt; fieldEntries.length): &quot;</span>
					+ fieldEntryIndex + ',' + fieldEntries.length;
<span class="nc bnc" id="L339" title="All 2 branches missed.">			if (fieldEntryIndex &lt; fieldEntries.length) {</span>
<span class="nc" id="L340">				int fieldType = PrimitiveTypes.STRING;</span>
<span class="nc bnc" id="L341" title="All 8 branches missed.">				switch (fieldName.charAt(prefixLength)) { // obtain the 'type'</span>
															// code from field
															// name
				case 'I':
<span class="nc" id="L345">					fieldType = PrimitiveTypes.ID;</span>
<span class="nc" id="L346">					break;</span>
				case 'B':
<span class="nc" id="L348">					fieldType = PrimitiveTypes.BOOLEAN;</span>
<span class="nc" id="L349">					break;</span>
				case 'S':
<span class="nc" id="L351">					fieldType = PrimitiveTypes.STRING;</span>
<span class="nc" id="L352">					break;</span>
				case 'D':
<span class="nc" id="L354">					fieldType = PrimitiveTypes.DATE;</span>
<span class="nc" id="L355">					break;</span>
				case 'N':
<span class="nc" id="L357">					fieldType = PrimitiveTypes.INT;</span>
<span class="nc" id="L358">					break;</span>
				case 'F':
<span class="nc" id="L360">					fieldType = PrimitiveTypes.FLOAT;</span>
<span class="nc" id="L361">					break;</span>
				case 'd':
<span class="nc" id="L363">					fieldType = PrimitiveTypes.DOUBLE;</span>
<span class="nc" id="L364">					break;</span>
				
				default:
<span class="nc" id="L367">					throw new IllegalArgumentException(</span>
<span class="nc" id="L368">							&quot;Invalid fieldName.charAt(prefixLength): &quot; + fieldName.charAt(prefixLength));</span>
				}

				// store the 'name' part and type from the coded field name in
				// the fieldEntry array
<span class="nc" id="L373">				fieldEntries[fieldEntryIndex] = new FieldInfoEntry(fieldName.substring(prefixLength + 2), fieldType);</span>

<span class="nc" id="L375">				numOfExtractedEntries++;</span>
			}
		} // for (....)

<span class="nc bnc" id="L379" title="All 4 branches missed.">		assert (numOfExpectedEntries == numOfExtractedEntries) : &quot;( numOfExpectedEntries != numOfExtractedEntries ): &quot;</span>
				+ numOfExpectedEntries + ',' + numOfExtractedEntries;
<span class="nc" id="L381">	}</span>
	
	/**
	 * Finds employee IDs for the given organization node only and not the for
	 * the node and its subnodes Uses an EmployeeFilter to filter by an
	 * organizationID.
	 *
	 * @param orgID
	 *            the ID of an organization.
	 * @return A Collection of employee IDs
	 * @throws BbmFinderException
	 */
	public static Collection getEmployeeIDsByOrgNodeAndDates(ID orgID, int timePeriodType, Date dtStart, Date dtEnd)
			throws Exception {

		// todo: this is done thru' AM. Can't we utilize the
		// WORKRESOURCEORGANIZATION table instead.
<span class="nc" id="L398">		Collection empIDs = Collections.emptyList();</span>

		// Not using Collections.singleton()since called method modifies list.
<span class="nc" id="L401">		List orgIDList = new ArrayList(1);</span>
<span class="nc" id="L402">		orgIDList.add(orgID);</span>

		// construct the employee filter
<span class="nc" id="L405">		ArrayList filterParms = new ArrayList(1);</span>
<span class="nc" id="L406">		filterParms.add(orgIDList);</span>
<span class="nc" id="L407">		Filter filter = new Filter(Filter.ORGANIZATIONID, Filter.OPERATOR_IN, filterParms);</span>
		// QC53354/QA97533
<span class="nc" id="L409">		filter.setTimePeriodType(timePeriodType);</span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">		if (timePeriodType == Filter.TIMEPERIODTYPE_TIMEWINDOW) {</span>
<span class="nc" id="L411">			filter.setStartTime(dtStart);</span>
<span class="nc" id="L412">			filter.setEndTime(dtEnd);</span>
		}
		// filter.setUserID(getLoginUserID());
		// TODO: privilege checking disabled for employee filter.
<span class="nc" id="L416">		filter.setPriviledge(null);</span>

		// use the EmployeeFiltering object to obtain a list of employees.
<span class="nc" id="L419">		Collection colSortFields = Collections.emptyList();</span>
<span class="nc" id="L420">		EmployeeFilter eFilter = BbmManagerFactory.getEmployeeFilter();</span>
<span class="nc" id="L421">		empIDs = eFilter.getEmployeeIDs(filter, getBPSuperUser(), colSortFields, true, 0, Integer.MAX_VALUE);</span>

<span class="nc" id="L423">		return empIDs;</span>
	}

	/**
	 * Get the collection of employees that define the set whose requests should
	 * be purged.
	 *
	 * @param organizationID
	 *            the organization id
	 * @param isForBranch
	 *            true=&gt; the whole branch, all sub orgs, false =&gt; just the
	 *            referenced organization
	 * @param dtStart
	 *            the start date of the date range
	 * @param dtEnd
	 *            the end date of the date range
	 * @return a Collection of Employees
	 * @throws BbmException
	 */
	// QC53354/QA97533 take organizational effectivity into account when getting
	// employeeIDs
	@SuppressWarnings(&quot;unchecked&quot;)
	public static Collection&lt;ID&gt; getEmployeeIDsInOrganization(ID organizationID, boolean isForBranch, Date dtStart,
			Date dtEnd) throws Exception {
		Collection&lt;ID&gt; ids;

<span class="nc" id="L449">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc bnc" id="L451" title="All 2 branches missed.">		if (isForBranch) {</span>
			// QC53354/QA97533 add dtStart and dtEnd
<span class="nc" id="L453">			Collection&lt;Employee&gt; emps = wrm.getEmployees(organizationID, dtStart, dtEnd, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>

<span class="nc" id="L455">			ids = new ArrayList&lt;ID&gt;(emps.size());</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">			for (Employee emp : emps) {</span>
<span class="nc" id="L457">				ids.add(emp.getID());</span>
<span class="nc" id="L458">			}</span>
<span class="nc" id="L459">		} else {</span>
			// QC53354/QA97533
<span class="nc" id="L461">			ids = getEmployeeIDsByOrgNodeAndDates(organizationID, Filter.TIMEPERIODTYPE_TIMEWINDOW, dtStart, dtEnd);</span>
		}

<span class="nc bnc" id="L464" title="All 2 branches missed.">		return (ids == null) ? Collections.emptyList() : ids;</span>
	}

	/**
	 * Get the collection of employees that define the set whose requests should
	 * be purged.
	 *
	 * @param organizationID
	 *            the organization id
	 * @param isForBranch
	 *            true=&gt; the whole branch, all sub orgs, false =&gt; just the
	 *            referenced organization
	 */
	public static Collection getEmployeesInOrganization(ID organizationID, boolean isForBranch, Date start, Date end) throws Exception {

<span class="nc" id="L479">		Collection wrmc = Collections.emptyList();</span>
		
<span class="nc" id="L481">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc bnc" id="L483" title="All 2 branches missed.">		if (isForBranch) {</span>
<span class="nc" id="L484">			wrmc = wrm.getEmployees(organizationID, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
		} else { 
			// not ForBranch..only get employee under the orgID nod
			// QC53354/QA97533 getEmployeeIDsByOrgNodeOnly changed to use effectivity
			
<span class="nc" id="L489">			int timeperiod = Filter.TIMEPERIODTYPE_CURRENT;</span>
<span class="nc bnc" id="L490" title="All 4 branches missed.">			if(start != null &amp;&amp; end != null){</span>
<span class="nc" id="L491">				timeperiod = Filter.TIMEPERIODTYPE_TIMEWINDOW;</span>
			}
<span class="nc" id="L493">			Collection ids = getEmployeeIDsByOrgNodeAndDates(organizationID, timeperiod, start, end);</span>
<span class="nc" id="L494">			wrmc = wrm.getEmployeesByIDs(ids, new Date(), Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
		}
		

<span class="nc" id="L498">		return wrmc;</span>
	}

	public static Collection geWorkResAssnsForCampaignDuringPeriod(ID campaignID, Date start, Date end)
			throws Exception {
<span class="nc" id="L503">		CampaignManager cmpMgr = getCampaignManager();</span>

<span class="nc" id="L505">		return cmpMgr.getCampaignWorkResourceAssignments(campaignID, start, end);</span>
	}

	/**
	 * Get the start and end dates for this and next time off year for the given
	 * employee.
	 *
	 * @param empID
	 *            the id of the employee
	 * @return a two-element array of TimeRange objects. The first contains the
	 *         time off begin and end dates for this year, the second contains
	 *         the begin and end dates for next year.
	 */
	public static TimeRange[] getEmployeeTimeOffYearDates(ID empID, ID orgID) throws Exception {
<span class="nc" id="L519">		TimeRange[] result = null;</span>

<span class="nc" id="L521">		int[] startMonthDay = getEmployeeTimeOffYearStart(empID, orgID);</span>

		// Get the time zone for the employee's organization
<span class="nc" id="L524">		TimeZone tz = getTimezoneCurrentForEmployeeID(empID);</span>

		// Get the current time in the organization's timezone
<span class="nc" id="L527">		Calendar now = Calendar.getInstance(tz);</span>

<span class="nc" id="L529">		Date thisYearStart = null, thisYearEnd = null, nextYearStart = null, nextYearEnd = null;</span>

		// get the start date of the employee's time off year in the current
		// calendar year.
<span class="nc" id="L533">		Calendar start = getCalendar(now.get(Calendar.YEAR), startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L534">		Calendar end = getCalendarForwardOneYear(now.get(Calendar.YEAR), startMonthDay[0], startMonthDay[1], tz);</span>

		// Is employee start date for this year past today's date?
<span class="nc bnc" id="L537" title="All 2 branches missed.">		if (now.before(start)) {</span>
			// start is the beginning of next year.
<span class="nc" id="L539">			nextYearStart = start.getTime();</span>
<span class="nc" id="L540">			nextYearEnd = end.getTime();</span>

			// Compute this year's start and end
<span class="nc" id="L543">			start = getCalendar(now.get(Calendar.YEAR) - 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L544">			end = getCalendarForwardOneYear(now.get(Calendar.YEAR) - 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L545">			thisYearStart = start.getTime();</span>
<span class="nc" id="L546">			thisYearEnd = end.getTime();</span>
		} else { // Emplyee's start date for this year is before today's date.
			// start is the beginning of this year
<span class="nc" id="L549">			thisYearStart = start.getTime();</span>
<span class="nc" id="L550">			thisYearEnd = end.getTime();</span>

			// Compute next year's start and end
<span class="nc" id="L553">			start = getCalendar(now.get(Calendar.YEAR) + 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L554">			end = getCalendarForwardOneYear(now.get(Calendar.YEAR) + 1, startMonthDay[0], startMonthDay[1], tz);</span>
<span class="nc" id="L555">			nextYearStart = start.getTime();</span>
<span class="nc" id="L556">			nextYearEnd = end.getTime();</span>
		}

<span class="nc" id="L559">		result = new TimeRange[] { new TimeRange(thisYearStart, thisYearEnd),</span>
				new TimeRange(nextYearStart, nextYearEnd), };

<span class="nc" id="L562">		return result;</span>
	}

	/**
	 * Get the time off year month and day for an employee
	 *
	 * @param emp
	 *            the employee
	 * @param org
	 *            the organization for the employee
	 * @return a two-element array of int. The first element is the month, the
	 *         second is the day.
	 */
	public static int[] getEmployeeTimeOffYearStart(Employee emp, Organization org) throws Exception {
<span class="nc" id="L576">		int[] result = new int[2];</span>
<span class="nc" id="L577">		OrganizationSetting settings = CacheUtilRM.getOrgSetting(org.getID());</span>

<span class="nc bnc" id="L579" title="All 4 branches missed.">		if ((settings != null) &amp;&amp; settings.getUseEmployeeFixedDate()) {</span>
			// The organization is using fixed date (Month and day)
<span class="nc" id="L581">			result[0] = settings.getEmployeeFixedDateMonth();</span>
<span class="nc" id="L582">			result[1] = settings.getEmployeeFixedDateDay();</span>
		} else {
			// organization uses employee anniversary date
			// obtain time zone for organization and start date for employee
<span class="nc" id="L586">			Calendar startDate = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L587">			startDate.setTime(emp.getStartTime());</span>
			// retrieve month and date
<span class="nc" id="L589">			result[0] = startDate.get(Calendar.MONTH);</span>
<span class="nc" id="L590">			result[1] = startDate.get(Calendar.DAY_OF_MONTH);</span>
		}
<span class="nc" id="L592">		return result;</span>
	}

	/**
	 * Get the time off year month and day for an employee
	 *
	 * @param empID
	 *            the id of the employee
	 * @param orgID
	 *            the organization id for the employee
	 * @return a two-element array of int. The first element is the month, the
	 *         second is the day.
	 */
	public static int[] getEmployeeTimeOffYearStart(ID empID, ID orgID) throws Exception {
<span class="nc" id="L606">		int[] result = new int[2];</span>

<span class="nc" id="L608">		OrganizationSetting settings = CacheUtilRM.getOrgSetting(orgID);</span>

<span class="nc bnc" id="L610" title="All 4 branches missed.">		if ((settings != null) &amp;&amp; settings.getUseEmployeeFixedDate()) {</span>
			// The organization is using fixed date
<span class="nc" id="L612">			result[0] = settings.getEmployeeFixedDateMonth();</span>
<span class="nc" id="L613">			result[1] = settings.getEmployeeFixedDateDay();</span>
		} else {
			// The organization uses employee anniversary
			// obtain work resource manager

			// obtain time zone for organization and start date for employee
<span class="nc" id="L619">			Calendar startDate = Calendar.getInstance(CacheUtilBBM.getOrganizationByID(orgID).getTimeZone());</span>
<span class="nc" id="L620">			startDate.setTime(</span>
<span class="nc" id="L621">					ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC).getStartTime());</span>

			// retrieve month and date
<span class="nc" id="L624">			result[0] = startDate.get(Calendar.MONTH);</span>
<span class="nc" id="L625">			result[1] = startDate.get(Calendar.DAY_OF_MONTH);</span>
		}
<span class="nc" id="L627">		return result;</span>
	}

	/**
	 * @param empID
	 * @return
	 */
	// public static User getUserForEmpID(ID empID) throws Exception {
	// UserManager um = BbmManagerFactory.getUserManager();
	// return um.getUserByEmployeeID(empID);
	// }
	//

	public static User getUserByEmpIDCached(ID empID) throws Exception {
<span class="nc" id="L641">		synchronized (m_empIDorNameToUserCache) {</span>
<span class="nc" id="L642">			User user = (User) m_empIDorNameToUserCache.get(empID);</span>

			// if not found in cache
<span class="nc bnc" id="L645" title="All 2 branches missed.">			if (user == null) {</span>
				// fetch from user manager
<span class="nc" id="L647">				UserManager um = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L648">				user = um.getUserByEmployeeID(empID);</span>

				// // store in cache.
				// m_empIDorNameToUserCache.put(empID, user);
				// m_empIDorNameToUserCache.put(user.getUserName().toLowerCase(),
				// user);
			}

			// return user.
<span class="nc" id="L657">			return user;</span>
<span class="nc" id="L658">		}</span>
	}

	public static User getUserByNameCached(String name) throws Exception {
<span class="nc" id="L662">		synchronized (m_empIDorNameToUserCache) {</span>
<span class="nc" id="L663">			User user = (User) m_empIDorNameToUserCache.get(name.toLowerCase());</span>

			// if not found in cache
<span class="nc bnc" id="L666" title="All 2 branches missed.">			if (user == null) {</span>
				// fetch from user manager
<span class="nc" id="L668">				UserManager um = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L669">				user = um.getUserByName(name);</span>

				// // store in cache.
				// m_empIDorNameToUserCache.put(name.toLowerCase(), user);
				// m_empIDorNameToUserCache.put(user.getEmployeeID(), user);
			}

			// return user.
<span class="nc" id="L677">			return user;</span>
<span class="nc" id="L678">		}</span>
	}

	public static String getLoginUserName(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L682">		String principalName = null;</span>
<span class="nc bnc" id="L683" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L684">			principalName = ejbCtx.getCallerPrincipal().getName();</span>
		} else {
<span class="nc" id="L686">			principalName = &quot;WSuperUser&quot;;</span>
		}

<span class="nc" id="L689">		return principalName;</span>
	}

	/**
	 * Finds the login user id from the EJB SessionContext.
	 *
	 * @param sessionContext
	 *            The SessionContext from the EJB.
	 * @return The ID of the logged in user.
	 * @throws BbmFinderException
	 */
	public static User getLoginUser(EJBContext ejbCtx) throws Exception {
		// get user secure fields
		User loginUser;

<span class="nc bnc" id="L704" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L705">			String principalName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L706">			loginUser = RequestUtil.getUserByNameCached(principalName);</span>
<span class="nc" id="L707">		} else {</span>
<span class="nc" id="L708">			loginUser = getBPSuperUser();</span>
		}

<span class="nc" id="L711">		return loginUser;</span>
	}

	public static ID getLoginUserID(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L715">		ID loginUserID = null;</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L718">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L719">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L720">			User user = userMgr.getUserByName(loginUserName);</span>
			// User user = userMgr.getUserByName(loginUserName);

<span class="nc" id="L723">			loginUserID = user.getID();</span>
<span class="nc" id="L724">		} else {</span>
<span class="nc" id="L725">			loginUserID = getBPSuperUser().getID();</span>
		}

<span class="nc" id="L728">		return loginUserID;</span>
	}

	public static ID getLoginUserEmpID(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L732">		ID loginUserEmpID = null;</span>
<span class="nc bnc" id="L733" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L734">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L735">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L736">			User loginUser = userMgr.getUserByName(loginUserName);</span>
			// User loginUser = userMgr.getUserByName(loginUserName);
<span class="nc" id="L738">			loginUserEmpID = loginUser.getEmployeeID();</span>
<span class="nc" id="L739">		} else {</span>
<span class="nc" id="L740">			loginUserEmpID = getBPSuperUser().getEmployeeID();</span>
		}

<span class="nc" id="L743">		return loginUserEmpID;</span>
	}

	public static User getLoginUserBasic(EJBContext ejbCtx) throws Exception {
<span class="nc" id="L747">		User loginUser = null;</span>

<span class="nc bnc" id="L749" title="All 2 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs) {</span>
<span class="nc" id="L750">			String loginUserName = ejbCtx.getCallerPrincipal().getName();</span>
<span class="nc" id="L751">			UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>
<span class="nc" id="L752">			loginUser = userMgr.getUserByName(loginUserName);</span>
			// User loginUser = userMgr.getUserByName(loginUserName);
<span class="nc" id="L754">		} else {</span>
<span class="nc" id="L755">			loginUser = getBPSuperUser();</span>
		}

<span class="nc" id="L758">		return loginUser;</span>
	}

	public static synchronized User getBPSuperUser() throws Exception {

<span class="nc bnc" id="L763" title="All 2 branches missed.">		if (m_bpSuperUser == null) {</span>
<span class="nc" id="L764">			m_bpSuperUser = new SuperUserFacade();</span>
		}

<span class="nc" id="L767">		return m_bpSuperUser;</span>
	}

	public static Set getOrgIDsWithViewReqPrivilegesForEmpID(ID empID) throws Exception {
<span class="nc" id="L771">		UserManager userMgr = CoreManagerFactory.getUserManager(false);</span>

		// Now get the set of organizations for which the manager has the
		// priviliage to view requests. This is slightly problematic since
		// it is possible that a manager could be given the privilage to
		// view time off requests for an organization, but not shift swap
		// requests. Coding to handle that would be very complicated, though,
		// and this is already pretty complicated. I'm going to make the
		// simplificiation that the priviliage to view one type of request
		// gives you to privilage to view any requests in the list. Operations
		// on the individual requests will still use the finer grained
		// privilage.
<span class="nc" id="L783">		Set orgs = new HashSet();</span>

<span class="nc bnc" id="L785" title="All 2 branches missed.">		for (Iterator it = RmPrivilegeKeys.MGR_VIEW_REQS_PRIVIDS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L786">			ID privID = (ID) it.next();</span>
<span class="nc" id="L787">			Collection i_orgs = RequestUtil.getOrgIDsWithPrivForEmpID(empID, privID, userMgr);</span>
<span class="nc" id="L788">			orgs.addAll(i_orgs);</span>
<span class="nc" id="L789">		}</span>

		// also get orgs over which the user has privs to view his own requests:
		// this is
		// required for the case when an agent is trying to view pending
		// requests through the
		// calendar drilldown
<span class="nc bnc" id="L796" title="All 2 branches missed.">		for (Iterator it = RmPrivilegeKeys.AGENT_VIEW_REQS_PRIVIDS.iterator(); it.hasNext();) {</span>
<span class="nc" id="L797">			ID privID = (ID) it.next();</span>
<span class="nc" id="L798">			Collection i_orgs = RequestUtil.getOrgIDsWithPrivForEmpID(empID, privID, userMgr);</span>
<span class="nc" id="L799">			orgs.addAll(i_orgs);</span>
<span class="nc" id="L800">		}</span>

<span class="nc" id="L802">		return orgs;</span>
	}

	public static Collection getOrgIDsWithPrivForEmpID(ID empID, ID privID, UserManager userMgr) throws Exception {
<span class="nc bnc" id="L806" title="All 2 branches missed.">		userMgr = (userMgr == null) ? CoreManagerFactory.getUserManager(false) : userMgr;</span>
<span class="nc" id="L807">		User user = userMgr.getUserByEmployeeID(empID);</span>
<span class="nc" id="L808">		Collection orgIDs = user.getAuthorizedScopes(privID, ORG_SCOPE);</span>

<span class="nc" id="L810">		return orgIDs;</span>

	}

	/**
	 * @param userName
	 * @param privID
	 * @param object
	 * @return
	 */
	public static Collection&lt;ID&gt; getOrgIDsWithPrivForUserName(String userName, ID privID, UserManager userMgr)
			throws Exception {

<span class="nc bnc" id="L823" title="All 2 branches missed.">		userMgr = (userMgr == null) ? CoreManagerFactory.getUserManager(false) : userMgr;</span>

<span class="nc" id="L825">		User user = userMgr.getUserByName(userName);</span>
<span class="nc" id="L826">		Collection&lt;ID&gt; orgIDs = user.getAuthorizedScopes(privID, ORG_SCOPE);</span>
<span class="nc" id="L827">		return orgIDs;</span>
	}

	/**
	 * Returns 'null' if user has privilege for all the given orgIDs. A non-null
	 * orgID, for the which the user does not have the requested privilege, is
	 * returned otherwise.
	 *
	 * @param userName
	 * @param orgIDs
	 * @param privID
	 * @param raiseException
	 * @return
	 * @throws Exception
	 */
	public static ID checkPrivilegeForOrgs(String userName, Collection&lt;ID&gt; orgIDs, ID privID) throws Exception {
<span class="nc" id="L843">		UserManager userMgr = null;</span>
<span class="nc" id="L844">		return checkPrivilegeForOrgs(userName, orgIDs, privID, userMgr);</span>
	}

	/**
	 * Returns 'null' if user has privilege for all the given orgIDs. A non-null
	 * orgID, for the which the user does not have the requested privilege, is
	 * returned otherwise.
	 *
	 * @param userName
	 * @param orgIDs
	 * @param privID
	 * @param raiseException
	 * @return
	 * @throws Exception
	 */
	public static ID checkPrivilegeForOrgs(String userName, Collection&lt;ID&gt; orgIDs, ID privID, UserManager userMgr) throws Exception {
		// get the orgs for which the user has the specified privilege
<span class="nc" id="L861">		Collection&lt;ID&gt; privilegedOrgIDs = RequestUtil.getOrgIDsWithPrivForUserName(userName, privID, userMgr);</span>

<span class="nc bnc" id="L863" title="All 2 branches missed.">		for (ID orgID : orgIDs) {</span>
			// check if given orgID is in the collection of privileged orgs.
<span class="nc bnc" id="L865" title="All 2 branches missed.">			if (!privilegedOrgIDs.contains(orgID)) {</span>
				// employee does not have specified privilege for this org
<span class="nc" id="L867">				return orgID;</span>
			}
<span class="nc" id="L869">		}</span>

		// employee has specified privilege for all orgs in the given collection of orgIDs
<span class="nc" id="L872">		return null;</span>
	}

	/**
	 * Get the timezone for the current organization for an employee
	 *
	 * @param emplID
	 *            the employee id of the request to check
	 * @throws BbmFinderException
	 *             when organization id cannot be found
	 */
	public static TimeZone getTimezoneCurrentForEmployeeID(ID empID) throws Exception {

<span class="nc" id="L885">		TimeZone tz = null;</span>
		// if 'useRemoteRefs' or (dontUseRemoteRefs &amp;&amp; empID != null)
<span class="nc bnc" id="L887" title="All 6 branches missed.">		if (RmManagerFactory.m_useEJBRemoteRefs || (!RmManagerFactory.m_useEJBRemoteRefs &amp;&amp; empID != null)) {</span>
			// Get the current organization for the employee
<span class="nc" id="L889">			ID orgID = TOCalcUtil.getCurrentOrgIDForEmployeeID(empID);</span>

			// todo: can the wrm be cached.
			// tz =
			// BbmManagerFactory.getWorkResourceManager().getOrganizationByID(orgID).getTimeZone();
<span class="nc" id="L894">			tz = CacheUtilBBM.getOrganizationByID(orgID).getTimeZone();</span>

			// Check to see that we got an org id
<span class="nc bnc" id="L897" title="All 2 branches missed.">			if (tz == null) {</span>
<span class="nc" id="L898">				throw createRmException(RmEjbLogBundleKey.CANNOT_FIND_TZ_FOR_ORG, new Object[] { orgID }, m_cat);</span>
			}
<span class="nc" id="L900">		} else { // dontUseRemoteRefs and empID == null</span>
<span class="nc" id="L901">			tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);</span>
		}

<span class="nc" id="L904">		return tz;</span>
	}

	/**
	 * @param date
	 * @param mgrTZ
	 * @return
	 */
	public static Calendar getCalendar(Date date, TimeZone tz) {
<span class="nc" id="L913">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L914">		cal.setTime(date);</span>
<span class="nc" id="L915">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L917">		return cal;</span>
	}

	/**
	 * Given a year, time zone and month/day, return a calendar set to that date
	 * or Feb 28 if it is Feb 29 during the given year.
	 */
	public static Calendar getCalendar(int year, int month, int day, TimeZone tz) {
		// Valid if leap year, if date is Feb 29th
<span class="nc bnc" id="L926" title="All 4 branches missed.">		if ((month == Calendar.FEBRUARY) &amp;&amp; (day == 29)) {</span>
<span class="nc" id="L927">			GregorianCalendar gc = new GregorianCalendar();</span>

<span class="nc bnc" id="L929" title="All 2 branches missed.">			if (!gc.isLeapYear(year)) {</span>
				// Use the 28th in non-leap years
<span class="nc" id="L931">				day = 28;</span>
			}
		}

		// create a calendar for the given day, month and year.
<span class="nc" id="L936">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L937">		cal.set(year, month, day, 0, 0, 0);</span>
<span class="nc" id="L938">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L939">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L941">		return cal;</span>
	}

	public static Calendar getEmployeeTimeOffYearStart(Date date, Organization org, int[] empTOYrStArr) {
<span class="nc" id="L945">		Calendar startCal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L946">		startCal.setTime(date);</span>
<span class="nc" id="L947">		startCal = RequestUtil.getCalendar(startCal.get(Calendar.YEAR), empTOYrStArr[0], empTOYrStArr[1],</span>
<span class="nc" id="L948">				org.getTimeZone());</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">		if (org.getDayBoundaryOffset() != 0) {</span>
<span class="nc" id="L950">			startCal.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
		}

<span class="nc bnc" id="L953" title="All 2 branches missed.">		if (startCal.getTime().after(date)) {</span>
<span class="nc" id="L954">			startCal.add(Calendar.YEAR, -1);</span>
		}
<span class="nc" id="L956">		return startCal;</span>
	}

	public static Calendar getEmployeeTimeOffYearEnd(Date date, Organization org, int[] empTOYrStArr) {
<span class="nc" id="L960">		Calendar empTOYearEndCal = getEmployeeTimeOffYearStart(date, org, empTOYrStArr);</span>
<span class="nc" id="L961">		empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
<span class="nc bnc" id="L962" title="All 2 branches missed.">		if (!empTOYearEndCal.getTime().after(date)) {</span>
			// QC 82218; fix for leap year
<span class="nc" id="L964">			empTOYearEndCal.add(Calendar.MILLISECOND, 1);</span>
<span class="nc" id="L965">			empTOYearEndCal.set(Calendar.YEAR, empTOYearEndCal.get(Calendar.YEAR) + 1);</span>
<span class="nc" id="L966">			empTOYearEndCal.add(Calendar.MILLISECOND, -1);</span>
		}
<span class="nc" id="L968">		return empTOYearEndCal;</span>
	}

	/**
	 * Given the start date for the time off year, return a calendar object set
	 * to the last day of the time off year.
	 */
	public static Calendar getCalendarForwardOneYear(int year, int month, int day, TimeZone tz) {
		// get the start date for the next year
<span class="nc" id="L977">		Calendar end = getCalendar(year + 1, month, day, tz);</span>

		// now subtract one second
<span class="nc" id="L980">		end.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L981">		end.getTime();</span>

<span class="nc" id="L983">		return end;</span>
	}

	public static Calendar getCalendarForDayStart(Date startTime, TimeZone tz) {
<span class="nc" id="L987">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc" id="L989">		cal.setTime(startTime);</span>
<span class="nc" id="L990">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L991">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L992">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L993">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L994">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L996">		return cal;</span>
	}

	public static Calendar getCalendarForDayEnd(Date time, TimeZone tz) {
<span class="nc" id="L1000">		Calendar cal = Calendar.getInstance(tz);</span>

<span class="nc" id="L1002">		cal.setTime(time);</span>
<span class="nc" id="L1003">		cal.set(Calendar.HOUR_OF_DAY, 23);</span>
<span class="nc" id="L1004">		cal.set(Calendar.MINUTE, 59);</span>
<span class="nc" id="L1005">		cal.set(Calendar.SECOND, 59);</span>
<span class="nc" id="L1006">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L1007">		cal.getTime(); // force evaluation of fields</span>

<span class="nc" id="L1009">		return cal;</span>
	}

	public static Date getDateForDayStart(Date date, TimeZone tz) {
<span class="nc" id="L1013">		return getCalendarForDayStart(date, tz).getTime();</span>
	}

	public static Date getDateForDayEnd(Date date, TimeZone tz) {
<span class="nc" id="L1017">		return getCalendarForDayEnd(date, tz).getTime();</span>
	}

	public static Date getDateForYMDHMS(int year, int month, int day, int hour, int minute, int second, TimeZone tz) {
<span class="nc" id="L1021">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1022">		cal.set(year, month, day, hour, minute, second);</span>
<span class="nc" id="L1023">		cal.set(Calendar.MILLISECOND, 0);</span>

<span class="nc" id="L1025">		return cal.getTime();</span>
	}

	/**
	 * Set milliseconds to zero for the given date.
	 *
	 * @param deadLine
	 * @return
	 */
	public static Date getDateWithMillisReset(Date deadLine) {
<span class="nc" id="L1035">		return new Date((deadLine.getTime() / 1000L) * 1000L);</span>
	}

	public static Date getDateWithSecondsReset(Date deadLine) {
<span class="nc" id="L1039">		return new Date((deadLine.getTime() / 60000L) * 60000L);</span>
	}

	/**
	 * Get the date for 'n' days from the current date
	 *
	 * @param n
	 * @return
	 */
	public static Date getDateForDaysFromNow(int n) {
<span class="nc" id="L1049">		Date deadLine = new Date(System.currentTimeMillis() + n * 24 * 60 * 60 * 1000L); // current</span>
																							// time
																							// +
																							// 7
																							// days
<span class="nc" id="L1054">		deadLine = RequestUtil.getDateWithMillisReset(deadLine);</span>
<span class="nc" id="L1055">		return deadLine;</span>
	}

	public static Date getEarlierDate(Date date1, Date date2) {
<span class="nc bnc" id="L1059" title="All 2 branches missed.">		return (date1.before(date2) ? date1 : date2);</span>
	}

	public static Date getLaterDate(Date date1, Date date2) {
<span class="nc bnc" id="L1063" title="All 2 branches missed.">		return (date1.after(date2) ? date1 : date2);</span>
	}

	/**
	 * Return the day of week for the start of the org day in which the given
	 * date falls. Day of week is returned as a value between
	 * {@link Calendar#SUNDAY Sunday} and {@link Calendar#SATURDAY Saturday}.
	 *
	 * @param org
	 * @param date
	 * @return
	 */
	public static int getDayOfWeekForOrgDayStart(Organization org, Date date) {
<span class="nc" id="L1076">		Date orgDayStartDate = TOCalcUtil.getDateForOrgDayStart(org, date);</span>

<span class="nc" id="L1078">		Calendar orgDayStartCal = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L1079">		orgDayStartCal.setTime(orgDayStartDate);</span>

<span class="nc" id="L1081">		return orgDayStartCal.get(Calendar.DAY_OF_WEEK);</span>
	}

	// public static String getDateFormtted(Date date, TimeZone tz) {
	// synchronized (m_dateformatFull){
	// m_dateformatFull.setTimeZone(tz);
	//
	// return m_dateformatFull.format(date);
	// }
	// }

	/**
	 * Is the given date between the specified time range (inclusive of time
	 * range's start and end)?
	 *
	 * @param givenDate
	 * @param start
	 * @param end
	 * @return
	 */
	public static boolean isDateBetween(Date givenDate, Date start, Date end) {
<span class="nc bnc" id="L1102" title="All 2 branches missed.">		start = (start == null) ? DATE_MIN : start;</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">		end = (end == null) ? DATE_MAX : end;</span>

		// givenDate &gt;= start and givenDate &lt;= end;
<span class="nc bnc" id="L1106" title="All 4 branches missed.">		return (!givenDate.before(start)) &amp;&amp; (!givenDate.after(end));</span>
	}

	/**
	 * returns the overlap length in milliseconds.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: A 'null' for start or 'end' is not a valid value. Map the
	 * 'null' to the proper value (either Date(0) or Date(Long.MAX_VALUE))
	 * before calling this method.
	 *
	 * &lt;p&gt;
	 * Note: There is no overlap if
	 * &lt;li&gt;time1End == time2Start
	 * &lt;li&gt;if time1Start == time2End
	 *
	 * @param time1Start
	 * @param time1End
	 * @param time2Start
	 * @param time2End
	 * @return true if ranges overlap; false otherwise
	 */
	public static long getOverlapLength(Date time1Start, Date time1End, Date time2Start, Date time2End) {
<span class="nc" id="L1129">		long time1StartMs = time1Start.getTime();</span>
<span class="nc" id="L1130">		long time1EndMs = time1End.getTime();</span>
<span class="nc" id="L1131">		long time2StartMs = time2Start.getTime();</span>
<span class="nc" id="L1132">		long time2EndMs = time2End.getTime();</span>

<span class="nc bnc" id="L1134" title="All 4 branches missed.">		assert (time1StartMs &lt;= time1EndMs);</span>
<span class="nc bnc" id="L1135" title="All 4 branches missed.">		assert (time2StartMs &lt;= time2EndMs);</span>

<span class="nc" id="L1137">		long overlap = 0L;</span>
		// 4 cases:
		// time1Start between time2Start and time2End
		// time1End between time2Start and time2End
		// time1 contains time2.
		// time2 cotains time1
		//
		// if ranges overlap
<span class="nc bnc" id="L1145" title="All 4 branches missed.">		if ((time1StartMs &lt; time2EndMs) &amp;&amp; (time1EndMs &gt; time2StartMs)) {</span>
<span class="nc" id="L1146">			overlap = Math.min(time1EndMs, time2EndMs) - Math.max(time1StartMs, time2StartMs);</span>
		}

		// // time1Start between time2Start and time2End
		// if (time1StartMs &gt;= time2StartMs &amp;&amp; time1StartMs &lt; time2EndMs) {
		// long minEndTimeMs = Math.min(time1EndMs, time2EndMs);
		// overlap = minEndTimeMs - time1StartMs;
		// // time1End between time2Start and time2End
		// } else if (time1EndMs &gt; time2StartMs &amp;&amp; time1EndMs &lt;= time2EndMs) {
		// long maxStartTimeMs = Math.max(time1StartMs, time2StartMs);
		// overlap = time1EndMs - maxStartTimeMs;
		// // time1 contains time2.
		// } else if (time1StartMs &lt;= time2StartMs &amp;&amp; time1EndMs &gt;= time2EndMs)
		// {
		// overlap = time2EndMs - time2StartMs;
		// } //Note: time2 cotains time1 is covered by either the 1st or 2nd
		// 'if' above.

<span class="nc bnc" id="L1164" title="All 4 branches missed.">		assert overlap &gt;= 0 : &quot;overlap &gt;= 0: &quot; + overlap;</span>

<span class="nc" id="L1166">		return overlap;</span>
	}

	/**
	 * Returns the overlap interval between the two specified time ranges.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: this method may return 'null' if no the time ranges do not
	 * overlap.
	 * &lt;p&gt;
	 * &lt;b&gt; Note &lt;/b&gt;: A 'null' for start or 'end' is not a valid value. Map the
	 * 'null' to the proper value (either Date(0) or Date(Long.MAX_VALUE))
	 * before calling this method.
	 *
	 * @param time1Start
	 * @param time1End
	 * @param time2Start
	 * @param time2End
	 * @return 'null' if no overlap. Otherwise the overlapping time range.
	 */
	public static TimeRange getOverlapTimeRange(Date time1Start, Date time1End, Date time2Start, Date time2End) {

<span class="nc bnc" id="L1188" title="All 4 branches missed.">		assert (!time1Start.after(time1End));</span>
<span class="nc bnc" id="L1189" title="All 4 branches missed.">		assert (!time2Start.after(time2End));</span>

<span class="nc" id="L1191">		boolean hasOverlap = TimePeriodUtil.overlap(time1Start, time1End, time2Start, time2End);</span>

<span class="nc bnc" id="L1193" title="All 2 branches missed.">		if (!hasOverlap) {</span>
<span class="nc" id="L1194">			return null;</span>
		}

<span class="nc bnc" id="L1197" title="All 2 branches missed.">		Date overlapStartTime = time1Start.after(time2Start) ? time1Start : time2Start;</span>
<span class="nc bnc" id="L1198" title="All 2 branches missed.">		Date overlapEndTime = time1End.before(time2End) ? time1End : time2End;</span>

<span class="nc" id="L1200">		return new TimeRange(overlapStartTime, overlapEndTime);</span>
	}

	public static TimeRange getOverlapTimeRange(TOHoursPerDay hrsPerDay, DailyHoursBuckets bkts) {
<span class="nc" id="L1204">		return getOverlapTimeRange(hrsPerDay.getStartTime(), hrsPerDay.getEndTime(),</span>
<span class="nc" id="L1205">				bkts.getDHBRangeStartAsOrgDayStart(), bkts.getDHBRangeEndAsOrgDayEnd());</span>
	}

	/**
	 * @param buffer1
	 * @param buffer2
	 * @param buffer3
	 * @return
	 */
	public static String concatStrBuffers(StringBuffer buffer1, StringBuffer buffer2, StringBuffer buffer3,
			String delimiter) {
<span class="nc" id="L1216">		StringBuffer concatStr = new StringBuffer(buffer1.length() + buffer2.length() + buffer3.length() + 64);</span>

<span class="nc" id="L1218">		return concatStr.append(buffer1).append(delimiter).append(buffer2).append(delimiter).append(buffer3).toString();</span>
	}

	protected static boolean isRmModuleException(BPException e) {
		// TODO: delete unnecessary exception types from RmModule.
<span class="nc bnc" id="L1223" title="All 6 branches missed.">		if (e instanceof RmException</span>
				|| /* e instanceof RmChangeStateException || */e instanceof RmHardValidationException
				|| /* e instanceof ValidationException || */e instanceof TimeOffCalculatorException) {
<span class="nc" id="L1226">			return true;</span>
		}

<span class="nc" id="L1229">		return false;</span>
	}

	public static BbmFinderException createBbmFinderExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1235" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BBM finder exception, just return.
<span class="nc bnc" id="L1237" title="All 2 branches missed.">			if (wrapped instanceof BbmFinderException) {</span>
				// BbmFinderException wrappedBbmExc = (BbmFinderException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1244">				return (BbmFinderException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1249">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1252">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
			// TODO: this will log BbmExceptions created in the RM module.
<span class="nc" id="L1257">			return createBbmFinderException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1258" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1261">			return createBbmFinderException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1262">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmFinderException createBbmFinderException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1268">		BbmFinderException exc = new BbmFinderException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1269" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1270">			cat.error(e, e);</span>
		}
<span class="nc" id="L1272">		return exc;</span>
	}

	public static BbmRemoveException createBbmRemoveExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1278" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BbmRemoveException, just return.
<span class="nc bnc" id="L1280" title="All 2 branches missed.">			if (wrapped instanceof BbmRemoveException) {</span>
				// BbmRemoveException wrappedBbmExc = (BbmRemoveException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1287">				return (BbmRemoveException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1292">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1295">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1299">			return createBbmRemoveException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1303">			return createBbmRemoveException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1304">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmRemoveException createBbmRemoveException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1310">		BbmRemoveException exc = new BbmRemoveException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1311" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1312">			cat.error(e, e);</span>
		}
<span class="nc" id="L1314">		return exc;</span>
	}

	public static BbmUpdateException createBbmUpdateExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1320" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a BbmUpdateException, just return.
<span class="nc bnc" id="L1322" title="All 2 branches missed.">			if (wrapped instanceof BbmUpdateException) {</span>
				// BbmUpdateException wrappedBbmExc = (BbmUpdateException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1329">				return (BbmUpdateException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1334">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1337">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1341">			return createBbmUpdateException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1342" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1345">			return createBbmUpdateException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1346">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmUpdateException createBbmUpdateException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1352">		BbmUpdateException exc = new BbmUpdateException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1354">			cat.error(e, e);</span>
		}
<span class="nc" id="L1356">		return exc;</span>
	}

	public static BbmCreateException createBbmCreateExceptionWrapper(Exception wrapped, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1362" title="All 2 branches missed.">		if (wrapped instanceof BPException) {</span>
			// if already a validaton exception, just return.
<span class="nc bnc" id="L1364" title="All 2 branches missed.">			if (wrapped instanceof BbmCreateException) {</span>
				// BbmCreateException wrappedBbmExc = (BbmCreateException)
				// wrapped;
				// //if this BBM exception was created in the RM, don't wrap.
				// if
				// (wrappedBbmExc.getBundleName().equals(RmEjbBundleKey.BUNDLE_NAME))
				// {
<span class="nc" id="L1371">				return (BbmCreateException) wrapped;</span>
				// }
			}

			// cast to BPException
<span class="nc" id="L1376">			BPException bpException = (BPException) wrapped;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1379">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1383">			return createBbmCreateException(wrapped, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1384" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1387">			return createBbmCreateException(wrapped, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1388">					new Object[] { wrapped.getMessage() }, cat);</span>
		}
	}

	private static BbmCreateException createBbmCreateException(Exception e, String bundleName, String msgKey,
			Object[] parms, Category cat) {
<span class="nc" id="L1394">		BbmCreateException exc = new BbmCreateException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1395" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1396">			cat.error(e, e);</span>
		}
<span class="nc" id="L1398">		return exc;</span>
	}

	/**
	 * Create and Log RmHardValidationException
	 *
	 * @param uiKey
	 *            - Rm Resource Bundle Key for UI
	 * @param logKey
	 *            - Rm Resource Bundle Key for Logging
	 * @param params
	 *            - Parameters that is part of the message
	 * @param cat
	 *            - Categroy to be used for logging if it is not null
	 * @return RmHardValidationException
	 */
	public static RmHardValidationException createAndLogRmHardValidationException(String uiKey, String logKey,
			Object[] params, Category cat) {
<span class="nc" id="L1416">		RmHardValidationException exc = new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, uiKey,</span>
				RmEjbLogBundleKey.BUNDLE_NAME, logKey, params);
<span class="nc bnc" id="L1418" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1419">			cat.debug(exc.getLocalizedMessage(), exc);</span>
		}
<span class="nc" id="L1421">		return exc;</span>
	}

	public static RmHardValidationException createRmHardValidationException(ValidationResult vr, Category cat) {
<span class="nc" id="L1425">		RmHardValidationException e = new RmHardValidationException(vr.getMessageBundle(), vr.getMessageResource(),</span>
<span class="nc" id="L1426">				vr.getMessageParms());</span>

		// since a hard validation error is a validation error and not a system
		// error, it is logged with
		// severity 'info' and not 'error' to avoid cluttering the log files.
<span class="nc bnc" id="L1431" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1432">			cat.debug(e, e);</span>
		}

<span class="nc" id="L1435">		return e;</span>
	}

	/**
	 * @param string
	 * @param objects
	 * @param m_cat2
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object[] parms,
			Category cat) {
<span class="nc" id="L1446">		RmHardValidationException exc = new RmHardValidationException(RmEjbBundleKey.BUNDLE_NAME, msgKey, parms);</span>
		// since a hard validation error is a validation error and not a system
		// error, it is logged with
		// severity 'info' and not 'error' to avoid cluttering the log files.
<span class="nc bnc" id="L1450" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1451">			cat.debug(exc, exc);</span>
		}
<span class="nc" id="L1453">		return exc;</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Category cat) {
<span class="nc" id="L1463">		return createRmHardValidationException(msgKey, new Object[] { obj1 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Category cat) {
<span class="nc" id="L1475">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param obj3
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Object obj3, Category cat) {
<span class="nc" id="L1488">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2, obj3 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param obj1
	 * @param obj2
	 * @param obj3
	 * @param obj4
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Object obj1, Object obj2,
			Object obj3, Object obj4, Category cat) {
<span class="nc" id="L1502">		return createRmHardValidationException(msgKey, new Object[] { obj1, obj2, obj3, obj4 }, cat);</span>
	}

	/**
	 * @param msgKey
	 * @param cat
	 * @return
	 */
	public static RmHardValidationException createRmHardValidationException(String msgKey, Category cat) {
<span class="nc" id="L1511">		return createRmHardValidationException(msgKey, null, cat);</span>
	}

	// TODO: verify createRmException is never passed a RmEjbValidationBundleKey
	public static RmException createRmException(String msgKey, Category cat) {
<span class="nc" id="L1516">		return createRmException(msgKey, null, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Category cat) {
<span class="nc" id="L1520">		return createRmException(msgKey, new Object[] { parm1 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Category cat) {
<span class="nc" id="L1524">		return createRmException(msgKey, new Object[] { parm1, parm2 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Object parm3, Category cat) {
<span class="nc" id="L1528">		return createRmException(msgKey, new Object[] { parm1, parm2, parm3 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object parm1, Object parm2, Object parm3, Object parm4,
			Category cat) {
<span class="nc" id="L1533">		return createRmException(msgKey, new Object[] { parm1, parm2, parm3, parm4 }, cat);</span>
	}

	public static RmException createRmException(String msgKey, Object[] parms, Category cat) {
<span class="nc" id="L1537">		RmException rmExc = new RmException(RmEjbLogBundleKey.BUNDLE_NAME, msgKey, parms);</span>
<span class="nc bnc" id="L1538" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1539">			cat.error(rmExc, rmExc);</span>
		}
<span class="nc" id="L1541">		return rmExc;</span>
	}

	private static RmException createRmException(Exception e, String bundleName, String msgKey, Object[] parms,
			Category cat) {
<span class="nc" id="L1546">		RmException rmExc = new RmException(e, bundleName, msgKey, parms);</span>
<span class="nc bnc" id="L1547" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1548">			cat.error(e, e);</span>
		}
<span class="nc" id="L1550">		return rmExc;</span>
	}

	// TODO: convert all throwXXXException()s to createXXXExceptions()
	// TODO: all throwXXXException() variants must use throwXXException(msgkey,
	// Object[] parms, cat).
	/**
	 * &lt;p&gt;
	 * Goal is to log the exception only once.
	 *
	 * &lt;p&gt;
	 * Passed exception is wrapped inside a newly created RMException.&lt;br&gt;
	 * If given exception is already an RmException, then it is not rewrapped.
	 * &lt;br&gt;
	 * If given exception is not an exception from the RM module, then it is
	 * logged (An exception from the RM module will always be logged when it was
	 * created). &lt;br&gt;
	 * TODO: enforce logging of RM module exceptions when created.
	 *
	 * @param e
	 * @param cat
	 * @return
	 */
	public static RmException createRmExceptionWrapper(Exception e, Category cat) {
		// BPExceptions are always localized (contains a resBundle, msgKey and
		// msgParms)
<span class="nc bnc" id="L1576" title="All 2 branches missed.">		if (e instanceof BPException) {</span>
			// if already a validaton exception, just return.
<span class="nc bnc" id="L1578" title="All 2 branches missed.">			if (e instanceof RmException) {</span>
<span class="nc" id="L1579">				return (RmException) e;</span>
			}

			// cast to BPException
<span class="nc" id="L1583">			BPException bpException = (BPException) e;</span>

			// obtain embedded message information from the exception.
<span class="nc" id="L1586">			ExceptionMessage excMsg = getMsgFromFirstBPException(bpException);</span>

			// t_hrow exception but log only if not an exception from the RM
			// module.
<span class="nc" id="L1590">			return createRmException(e, excMsg.getBundleName(), excMsg.getMsgKey(), excMsg.getMsgParms(),</span>
<span class="nc bnc" id="L1591" title="All 2 branches missed.">					isRmModuleException(bpException) ? null : cat);</span>
		} else {
			// log the non BP exception and throw
<span class="nc" id="L1594">			return createRmException(e, RmEjbBundleKey.BUNDLE_NAME, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
<span class="nc" id="L1595">					new Object[] { e.getMessage() }, cat);</span>
		}
	}

	/**
	 * @param string
	 * @return
	 */
	public static RuntimeException createRunTimeException(String msg, Category cat) {
<span class="nc" id="L1604">		RuntimeException exception = new RuntimeException(msg);</span>
<span class="nc bnc" id="L1605" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1606">			cat.error(exception);</span>
		}

<span class="nc" id="L1609">		return exception;</span>
	}

	/**
	 * @param msg
	 * @param e
	 * @return
	 */
	public static RuntimeException createRunTimeException(String msg, Exception e, Category cat) {
<span class="nc" id="L1618">		RuntimeException exception = new RuntimeException(msg, e);</span>
<span class="nc bnc" id="L1619" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1620">			cat.error(exception);</span>
		}

<span class="nc" id="L1623">		return exception;</span>
	}

	/**
	 * @param cat
	 * @return
	 */
	public static IllegalArgumentException createIllegalArgumentException(String msg, Category cat) {
<span class="nc bnc" id="L1631" title="All 2 branches missed.">		IllegalArgumentException e = (msg != null) ? new IllegalArgumentException(msg) : new IllegalArgumentException();</span>
<span class="nc bnc" id="L1632" title="All 2 branches missed.">		if (cat != null) {</span>
<span class="nc" id="L1633">			cat.error(e);</span>
		}

<span class="nc" id="L1636">		return e;</span>
	}

	/**
	 * Exceptions thrown in the RM module will be logged before being thrown.
	 * Exceptions thrown by other modules (BBM, AM etc) might not be logged when
	 * thrown. Java language exceptions are not logged when thrown.
	 *
	 * TODO: exception handling guidelines. Goals: Methods must throw a single
	 * exception to simplify exception handling for the caller(due to forcing
	 * checked exception handling by the compiler). Even though a single
	 * exception is thrown, it must be possible to identify the actual reason
	 * (error code) if necessary, for error handling by the caller. When
	 * exceptions are nested, due to the first requirement of only one
	 * exception, the internal information of BPException subtypes (bundle,
	 * msgKey, parms, severity code, message etc) must be extracted and wrapped
	 * in the newly thrown BPException subtype. Present exception types thrown
	 * in RM: BbmXXXX, ValidationException, RmHardValidationException,
	 * RmChangeStateException. Out of these, only RmHardValidationException is
	 * used by the caller (webtier) to identify a hard validation error. In
	 * fact, the webtier only uses the caught exceptions to display an error
	 * message and not recover from an error. Given that exceptions caught by
	 * callers are seldom used to recover from errors, it might be a good idea
	 * to to have a just a handfull of exceptions in the RM to prevent
	 * unnecessary wrapping and a short exception signature in the RM module
	 * methods. BP Exceptions, in the RM module, must be logged before they are
	 * thrown. BP Exceptions, from modules, other than RM, must be caught,
	 * logged, wrapped and then rethrown. Non BP Exceptions (Java exceptions)
	 * must also be caught, logged, wrapped and then rethrown.
	 *
	 * @param e
	 */
	public static ExceptionMessage getMsgFromFirstBPException(BPException e) {
		// Note: The innermost BPException either wraps a non BPException or
		// contains a
		// localized message (using bundle, msgkey and parms). It cannot contain
		// a
		// non localized message (ie. messages without bundlename).
		// (BPException implementation defaults to the common bundle for its
		// 'bundle' member variable).

		// get inner most BPException
<span class="nc" id="L1678">		BPException firstBPExcep = e.getFirstException();</span>

		// get wrapped non BPException
<span class="nc" id="L1681">		Exception nonBPException = firstBPExcep.getCoreException();</span>

		// TODO: must the locale be used?
		// if wrapped exception present.
<span class="nc bnc" id="L1685" title="All 2 branches missed.">		if (nonBPException != null) {</span>
<span class="nc" id="L1686">			return new ExceptionMessage(nonBPException.getClass().getName() + ':' + nonBPException.getMessage());</span>
		}

		// cannot contain non localized message (see above)
		/*
		 * if ( StringUtil.isEmpty(firstBPExcep.getBundleName()) ) { return new
		 * ExceptionMessage( firstBPExcep.getMessage() ); }
		 */

		// otherwise inner most BP Exception has a localized messgage.
<span class="nc" id="L1696">		return new ExceptionMessage(firstBPExcep.getBundleName(), firstBPExcep.getMsgID(),</span>
<span class="nc" id="L1697">				firstBPExcep.getParamObject());</span>
	}

	public static ExceptionMessage getMsgFromException(Exception e) {
		// if given exception is a BP Exception, extract exception information
<span class="nc bnc" id="L1702" title="All 2 branches missed.">		if (e instanceof BPException) {</span>
<span class="nc" id="L1703">			return getMsgFromFirstBPException((BPException) e);</span>
		}

		// if given exception is a non BP Exception, return embedded message.
<span class="nc" id="L1707">		return new ExceptionMessage(e.getClass().getName() + ':' + e.getMessage());</span>
	}

	/**
	 * Scans the parms array and localizes the parm if necessary (based on its
	 * datatype). Returns the given parms array with the localizable elements
	 * replaced with their localized strings.
	 *
	 * @param msgParms
	 * @return
	 */
	public static String getLocalizedMessage(String bundleName, String msgKey, Object[] msgParms, Localizer localizer,
			TimeZone tzView) {
<span class="nc" id="L1720">		TimeZone tzOrg = null;</span>
<span class="nc" id="L1721">		RequestFilingRule filingRule = null;</span>

		// localize the message parameters
<span class="nc bnc" id="L1724" title="All 4 branches missed.">		for (int i = 0; msgParms != null &amp;&amp; i &lt; msgParms.length; i++) {</span>
			// if type is Date
<span class="nc bnc" id="L1726" title="All 2 branches missed.">			if (msgParms[i] instanceof Date) {</span>
<span class="nc" id="L1727">				Date date = (Date) msgParms[i];</span>
<span class="nc" id="L1728">				msgParms[i] = localizer.formatDateTime(date, tzView);</span>
<span class="nc" id="L1729">			} // if type is ShiftsConflict.</span>
<span class="nc bnc" id="L1730" title="All 2 branches missed.">			else if (msgParms[i] instanceof ShiftsConflict) {</span>
<span class="nc" id="L1731">				ShiftsConflict conflict = (ShiftsConflict) msgParms[i];</span>
<span class="nc" id="L1732">				msgParms[i] = conflict.getDisplayString(localizer, tzView);</span>
<span class="nc bnc" id="L1733" title="All 2 branches missed.">			} else if (msgParms[i] instanceof UnlocalizedStringWrapper) {</span>
<span class="nc" id="L1734">				UnlocalizedStringWrapper unlocStringWrapper = (UnlocalizedStringWrapper) msgParms[i];</span>
<span class="nc" id="L1735">				msgParms[i] = unlocStringWrapper.getLocalizedString(localizer);</span>
<span class="nc bnc" id="L1736" title="All 2 branches missed.">			} else if (msgParms[i] instanceof ResourceBundleKeyWrapper) {</span>
<span class="nc" id="L1737">				ResourceBundleKeyWrapper resBundleWrapper = (ResourceBundleKeyWrapper) msgParms[i];</span>
				// Note: the parameter 'bundleName' for this method is not used
				// as the bundle name.
<span class="nc" id="L1740">				msgParms[i] = localizer.i18n(ResourceBundleKeyWrapper.getResBundleName(),</span>
<span class="nc" id="L1741">						resBundleWrapper.getResBundleMsgKey());</span>
<span class="nc bnc" id="L1742" title="All 2 branches missed.">			} else if (msgParms[i] instanceof PersonName) { // Class 'Employee'</span>
															// implements the
															// 'PersonName'
															// interface
<span class="nc" id="L1746">				msgParms[i] = localizer.formatName((PersonName) msgParms[i]);</span>
<span class="nc bnc" id="L1747" title="All 2 branches missed.">			} else if (msgParms[i] instanceof TimeZone) {</span>
<span class="nc" id="L1748">				tzOrg = (TimeZone) msgParms[i];</span>
<span class="nc bnc" id="L1749" title="All 2 branches missed.">			} else if (msgParms[i] instanceof RequestFilingRule) {</span>
<span class="nc" id="L1750">				filingRule = (RequestFilingRule) msgParms[i];</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">			} else if (msgParms[i] instanceof LocalDate) {</span>
<span class="nc" id="L1752">				LocalDate date = (LocalDate) msgParms[i];</span>
<span class="nc" id="L1753">				msgParms[i] = localizer.formatDate(date, RegionalFormatBundleKey.DATE_FORMAT);</span>
			}
		}
<span class="nc" id="L1756">		msgParms = addExtendedFilingRuleParams(bundleName, msgParms, localizer, tzView, tzOrg, filingRule);</span>
<span class="nc bnc" id="L1757" title="All 2 branches missed.">		return (msgParms != null) ? localizer.i18n(bundleName, msgKey, msgParms) : localizer.i18n(bundleName, msgKey);</span>
	}

	/**
	 * Add additional info about a filing rule to the msgParms array. The
	 * additional info is made up of the three parts that define the filing
	 * rule, so that the user will now which filing rule was violated. The three
	 * parts are: - Subtype string, which is the time off activity name - Date
	 * range data - File By data
	 */
	protected static Object[] addExtendedFilingRuleParams(String bundleName, Object[] msgParams, Localizer localizer,
			TimeZone tzView, TimeZone tzOrg, RequestFilingRule filingRule) {
<span class="nc bnc" id="L1769" title="All 2 branches missed.">		if (filingRule != null) {</span>
<span class="nc" id="L1770">			Object[] expandedMsgParams = new Object[msgParams.length + 1];</span>
			try {
				// make a copy of the params array, but exclude the last two
				// items because those are for the time zone and
				// the filing rule, which should be replaced by actual
				// description strings.
<span class="nc bnc" id="L1776" title="All 2 branches missed.">				TimeZone tz = tzOrg == null ? tzView : tzOrg;</span>
<span class="nc" id="L1777">				ResourceBundle rmEjbBundle = localizer.getBundle(bundleName);</span>
<span class="nc" id="L1778">				int i = 0;</span>
<span class="nc bnc" id="L1779" title="All 2 branches missed.">				for (i = 0; i &lt; msgParams.length - 2; i++) {</span>
<span class="nc" id="L1780">					expandedMsgParams[i] = msgParams[i];</span>
				}

<span class="nc" id="L1783">				String requestTypeDesc = RequestUtil.getTimeOffOrFlexTimeSubtypesString(false, filingRule, rmEjbBundle,</span>
						localizer, false);
<span class="nc" id="L1785">				String dateRangeData = RequestUtil.getDateRangeData(localizer, filingRule, rmEjbBundle, tz);</span>
<span class="nc" id="L1786">				String fileByData = RequestUtil.getFileByData(filingRule, rmEjbBundle, localizer, tz);</span>
<span class="nc" id="L1787">				expandedMsgParams[i++] = requestTypeDesc;</span>
<span class="nc" id="L1788">				expandedMsgParams[i++] = dateRangeData;</span>
<span class="nc" id="L1789">				expandedMsgParams[i++] = fileByData;</span>
<span class="nc" id="L1790">				return expandedMsgParams;</span>
<span class="nc" id="L1791">			} catch (Exception ex) {</span>
				// do nothing, not critical.
			}
		}
<span class="nc" id="L1795">		return msgParams;</span>
	}

	public static Localizer getLocalizerForAppDefLocale() {
<span class="nc" id="L1799">		return DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object[] msgParms, TimeZone tzView) {

<span class="nc" id="L1804">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1806">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, msgParms, appDefLocaleLocalizer, tzView);</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey) {

<span class="nc" id="L1811">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

		// passing 'null' for the TZ is ok as the TZ is only used for the
		// parameters to a message format.
<span class="nc" id="L1815">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, null, appDefLocaleLocalizer, null);</span>
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm, TimeZone tzView) {

<span class="nc" id="L1820">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1822">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm }, appDefLocaleLocalizer,</span>
				tzView);
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm1, Object msgParm2,
			TimeZone tzView) {

<span class="nc" id="L1829">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1831">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm1, msgParm2 },</span>
				appDefLocaleLocalizer, tzView);
	}

	public static String getLocalizedMsgInAppDefLocale(String msgKey, Object msgParm1, Object msgParm2, Object msgParm3,
			TimeZone tzView) {

<span class="nc" id="L1838">		Localizer appDefLocaleLocalizer = getLocalizerForAppDefLocale();</span>

<span class="nc" id="L1840">		return getLocalizedMessage(RmEjbBundleKey.BUNDLE_NAME, msgKey, new Object[] { msgParm1, msgParm2, msgParm3 },</span>
				appDefLocaleLocalizer, tzView);
	}

	public static String getLocalizedEmpNameByID(ID empID, Localizer localizer) throws Exception {
<span class="nc" id="L1845">		Employee emp = ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC);</span>
<span class="nc" id="L1846">		String empName = localizer.formatName(emp);</span>

<span class="nc" id="L1848">		return empName;</span>
	}

	/**
	 * Get the holidays for the given org during the time period.
	 *
	 * @return collection of Holiday objects
	 */
	public static Collection getHolidaysDuringPeriod(Organization org, TimeRange range) throws Exception {
		// HolidayManager hm = BbmManagerFactory.getHolidayManager();
<span class="nc" id="L1858">		ID orgID = org.getID();</span>
<span class="nc" id="L1859">		TimeZone tz = org.getTimeZone();</span>
<span class="nc" id="L1860">		LocalDate startLocDate = new LocalDate(range.getStartDate(), tz);</span>
<span class="nc" id="L1861">		LocalDate endLocDate = new LocalDate(range.getEndDate(), tz);</span>
		// if day boundary is &gt;0, add day boundary offset to end date to catch
		// all holidays
<span class="nc bnc" id="L1864" title="All 2 branches missed.">		if (org.getDayBoundaryOffset() &gt; 0) {</span>
<span class="nc" id="L1865">			endLocDate.add(Calendar.MINUTE, org.getDayBoundaryOffset());</span>
		}

		// return hm.getHolidays(orgId, ldStart, ldEnd);
<span class="nc" id="L1869">		Collection holidays = CacheUtilBBM.getHolidaysForOrg(orgID, startLocDate, endLocDate);</span>
<span class="nc" id="L1870">		return holidays;</span>
	}

	/**
	 * Get the OrganizationHOO objects for the given org during the time period.
	 *
	 * @return collection of OrganizationHOO objects
	 */
	public static Collection getHooAssignmentsDuringPeriod(Organization org, TimeRange range) throws Exception {
<span class="nc" id="L1879">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1880">		ID orgId = org.getID();</span>

<span class="nc" id="L1882">		Collection hooAssns = wrm.getOrganizationHOOAssignments(orgId, range.getStartDate(), range.getEndDate());</span>
<span class="nc bnc" id="L1883" title="All 2 branches missed.">		hooAssns = (hooAssns == null) ? Collections.emptyList() : hooAssns;</span>

<span class="nc" id="L1885">		return hooAssns;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static OrganizationHOOPeriod getHOOPeriod(ID orgID, Date start, Date end)
			throws BbmFinderException, RemoteException, BbmEJBCreateException {
<span class="nc" id="L1891">		List&lt;ID&gt; orgIDs = new ArrayList&lt;ID&gt;(1);</span>
<span class="nc" id="L1892">		orgIDs.add(orgID);</span>

<span class="nc" id="L1894">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L1895">		Map&lt;ID, OrganizationHOOPeriod&gt; orgIdToHoopMap = wrm.getHOOPeriod(orgIDs, start, end);</span>
<span class="nc" id="L1896">		return orgIdToHoopMap.get(orgID);</span>
	}

	/**
	 * @param string
	 * @return
	 */
	public static Campaign getCampaignByName(String campName) throws Exception {
<span class="nc" id="L1904">		CampaignManager cm = getCampaignManager();</span>

		// no getCampaignForName() method in campaingManager. Have to use
		// getCampaingns() instead.
<span class="nc" id="L1908">		Collection allCamps = cm.getCampaigns();</span>
<span class="nc bnc" id="L1909" title="All 2 branches missed.">		for (Iterator allCampsIter = allCamps.iterator(); allCampsIter.hasNext();) {</span>
<span class="nc" id="L1910">			Campaign camp = (Campaign) allCampsIter.next();</span>

<span class="nc bnc" id="L1912" title="All 2 branches missed.">			if (camp.getName().toLowerCase().equals(campName.toLowerCase())) {</span>
<span class="nc" id="L1913">				return camp;</span>
			}
<span class="nc" id="L1915">		}</span>

<span class="nc" id="L1917">		return null;</span>
	}

	public static Campaign getCampaignByID(ID campID, CampaignManager campMgr)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException, BbmEJBCreateException {
<span class="nc bnc" id="L1922" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>
<span class="nc" id="L1923">		return campMgr.getCampaignByID(campID);</span>
	}

	public static Collection getCampaignAssnsForWorkResDuringPeriod(ID empID, Date start, Date end) throws Exception {
		// try {
<span class="nc" id="L1928">		CampaignManager cm = getCampaignManager();</span>

		// todo: optimize with List, if possible
		// TODO: route thru validation cache.
<span class="nc" id="L1932">		Collection campWorkResAssns = cm.getWorkResourceCampaignAssignments(empID, start, end);</span>

<span class="nc" id="L1934">		return campWorkResAssns;</span>
		// } c_atch (Exception e) {
		// t_hrow createValidationExceptionWrapper(e, m_cat);
		// }
	}

	public static Collection getCampOrgAssignments(ID campaignID, Date aucStartTime, Date aucEndTime,
			CampaignManager campMgr) throws BbmEJBCreateException, BbmFinderException, RemoteException {

<span class="nc bnc" id="L1943" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>
<span class="nc" id="L1944">		return campMgr.getCampaignOrgAssignments(campaignID, aucStartTime, aucEndTime);</span>
	}

	/**
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @param campMgr
	 * @throws BbmEJBCreateException
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	private static Collection getSPIDsForEmpDuringTimeRange(ID empID, Date start, Date end, CampaignManager campMgr)
			throws Exception {

		// get SPs associated with employee.
<span class="nc" id="L1961">		Collection campWorkResAssns = RequestUtil.getCampaignAssnsForWorkResDuringPeriod(empID, start, end);</span>

<span class="nc" id="L1963">		Collection empSPIDDuringTimeRange = new ArrayList();</span>
<span class="nc bnc" id="L1964" title="All 2 branches missed.">		for (Iterator iter = campWorkResAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L1965">			CampaignWorkResource campWorkRes = (CampaignWorkResource) iter.next();</span>
<span class="nc" id="L1966">			empSPIDDuringTimeRange.add(campWorkRes.getSPID());</span>
<span class="nc" id="L1967">		}</span>

<span class="nc" id="L1969">		return empSPIDDuringTimeRange;</span>
	}

	/**
	 * @param shiftAssnSPID
	 */
	private static SchedulingPeriod getSPForSPID(ID SPID, CampaignManager campMgr)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc bnc" id="L1977" title="All 2 branches missed.">		campMgr = (campMgr == null) ? getCampaignManager() : campMgr;</span>

<span class="nc" id="L1979">		return campMgr.getSchedulingPeriodByID(SPID);</span>
	}

	public static Collection getSchedulingPeriod(Collection spIDs)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L1984">		CampaignManager campMgr = getCampaignManager();</span>

<span class="nc" id="L1986">		return campMgr.getSchedulingPeriodsByID(spIDs);</span>
	}

	public static Map getOrganizationsByNames(HashSet names, WorkResourceManager wrm) throws Exception {
<span class="nc bnc" id="L1990" title="All 2 branches missed.">		wrm = (wrm == null) ? BbmManagerFactory.getWorkResourceManager() : wrm;</span>

		// Can't use Collections.singleton() since method expects a HashSet
<span class="nc" id="L1993">		return wrm.getOrganizationIDsByNames(names);</span>
	}

	public static Organization getOrganizationByID(ID orgID, WorkResourceManager wrm) throws Exception {
<span class="nc" id="L1997">		return CacheUtilBBM.getOrganizationByID(orgID);</span>
	}

	public static Collection&lt;WorkResourceAssignment&gt; geOrgAssnsForWorkResDuringPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L2001">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>

<span class="nc" id="L2003">		return wrm.getWorkResourceAssignments(empID, start, end, false);</span>
	}

	/**
	 * Get the time off events for all the employees in the organization during
	 * the request time period.
	 *
	 * @param empIDsWithEvents
	 *            Optional. Can be null. If non-null, any empID with events are
	 *            added to this collection
	 */
	public static Collection getTimeoffEventsPubForOrg(Collection empIDs, TimeRange range, Collection empIDsWithEvents,
			ArrayList allotmentList) throws Exception {
<span class="nc" id="L2016">		Date start = range.getStartDate();</span>
<span class="nc" id="L2017">		Date end = range.getEndDate();</span>
<span class="nc" id="L2018">		Collection results = new ArrayList();</span>

<span class="nc" id="L2020">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc" id="L2021">		Collection listOfLists = sam.getPublishedEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF, empIDs, start,</span>
				end);

		// We don't need the separate lists, collect them as a single list.
<span class="nc" id="L2025">		Iterator empIDIter = empIDs.iterator();</span>
<span class="nc bnc" id="L2026" title="All 2 branches missed.">		for (Iterator it = listOfLists.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2027">			Collection list = (Collection) it.next();</span>
<span class="nc" id="L2028">			Collection newList = new ArrayList();</span>

			// if needed, filter out non allotment events
<span class="nc bnc" id="L2031" title="All 2 branches missed.">			if (list != null) {</span>
<span class="nc bnc" id="L2032" title="All 2 branches missed.">				if (!allotmentList.isEmpty()) {</span>
					// iterate through the list
<span class="nc bnc" id="L2034" title="All 2 branches missed.">					for (Iterator iter = list.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2035">						TimeOffEvent toEvt = (TimeOffEvent) iter.next();</span>
						// get the activity of the time off
<span class="nc bnc" id="L2037" title="All 2 branches missed.">						if (allotmentList.contains(toEvt.getActivityID())) {</span>
<span class="nc" id="L2038">							newList.add(toEvt);</span>
						}
<span class="nc" id="L2040">					}</span>
				} else {
<span class="nc" id="L2042">					newList.addAll(list);</span>
				}
			}

<span class="nc" id="L2046">			ID currEmpID = (ID) empIDIter.next();</span>

			// The list for each empId may be null.
<span class="nc bnc" id="L2049" title="All 4 branches missed.">			if (newList != null &amp;&amp; !newList.isEmpty()) {</span>
<span class="nc" id="L2050">				results.addAll(newList);</span>

				// add the empID if necessary.
<span class="nc bnc" id="L2053" title="All 2 branches missed.">				if (empIDsWithEvents != null) {</span>
<span class="nc" id="L2054">					empIDsWithEvents.add(currEmpID);</span>
				}
			}
<span class="nc" id="L2057">		}</span>

<span class="nc" id="L2059">		return results;</span>
	}

	/**
	 * Called during approval or tentative approval. For approvals of request
	 * type &quot;debit&quot;, the time off length is frozen after approval (ie. not
	 * recalculated if factors affecting length change after approval).
	 *
	 * @param toReq
	 * @param choice
	 * @param toRule
	 * @return
	 * @throws BbmFinderException
	 * @throws TimeOffCalculatorException
	 */
	public static TimeOffEvent createTimeOffEventVO(TORequest toReq, TOChoice choice, short toRule)
			throws BbmFinderException, RmException, TimeOffCalculatorException {
<span class="nc" id="L2076">		TimeOffEvent toEvt = new TimeOffEvent();</span>
<span class="nc" id="L2077">		setCalendarEventAssignFields(toEvt, toReq, choice);</span>

		// if UI option == &quot;debit&quot; chosen
<span class="nc bnc" id="L2080" title="All 2 branches missed.">		if (toRule == TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES) {</span>
			// Calculate the length of the time off event if approving.
			// if (
			// toReq.getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED))
			// {
			// for QA53522 -Tentative Approved Time Off to be counted towards X
			// minutes
			// tentative requests should also be created with non zero length.
<span class="nc" id="L2088">			TORequestUtil.updateTOEventMinutes(toEvt, toReq, choice);</span>
			// }

			// use the computed length for the length of the timeoff. Since any
			// changes to the schedule under
			// the timeoff event, after the event is created, will not alter
			// this length, it mut never be changed.
<span class="nc" id="L2095">			toEvt.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES);</span>
		}
		// if UI option == &quot;debit-if-necessary&quot; chosen
<span class="nc bnc" id="L2098" title="All 2 branches missed.">		else if (toRule == TimeOffEvent.TIME_OFF_RULE_USE_SHIFT) {</span>
			// set the length of the time off event to 0. The length is computed
			// on the fly anytime it is needed.
<span class="nc" id="L2101">			toEvt.setCountsMinutesTowardsRules(0);</span>
			// Use the current schedule (shifts) under the TOEvent to calculate
			// the length of the timeoff event.
<span class="nc" id="L2104">			toEvt.setTimeOffRule(TimeOffEvent.TIME_OFF_RULE_USE_SHIFT);</span>
		} else {
<span class="nc" id="L2106">			throw createRmException(RmEjbLogBundleKey.INVALID_VALUE, &quot;toRule&quot;, new Short(toRule), m_cat);</span>
		}

<span class="nc" id="L2109">		return toEvt;</span>
	}

	/**
	 * @param empID
	 * @param eventType
	 *            see {@link Event Event}
	 * @param published
	 * @param start
	 * @param end
	 * @param sam
	 * @return
	 * @throws Exception
	 */
	// TODO: refactor code to use this to retrive caleventassigns.
	public static Collection getEventsDuringPeriod(ID empID, int eventType, boolean published, Date start, Date end,
			ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L2126">		String methodName = &quot;getCalEventAssignsDuringPeriod&quot;;</span>
<span class="nc" id="L2127">		m_cat.debug(RmUtil.dumpEnterMethod(methodName,</span>
				new Object[] { empID, new Integer(eventType), new Boolean(published), start, end }));

<span class="nc bnc" id="L2130" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

<span class="nc" id="L2132">		Collection events = null;</span>
<span class="nc bnc" id="L2133" title="All 2 branches missed.">		if (!published) {</span>
<span class="nc" id="L2134">			events = sam.getEventsForWorkResourceByType(eventType, empID, start, end);</span>
		} else {
<span class="nc" id="L2136">			events = sam.getPublishedEventsForWorkResourceByType(eventType, empID, start, end);</span>
		}

<span class="nc" id="L2139">		m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>

<span class="nc" id="L2141">		return events;</span>
	}

	/**
	 * @param empID
	 * @param startDate
	 * @param endDate
	 * @param sam
	 * @return
	 */
	public static Collection getShiftAssignsDuringPeriod(ID empID, Date startDate, Date endDate, boolean pub,
			ScheduleAccessManager sam) throws Exception {

<span class="nc" id="L2154">		return getEventsDuringPeriod(empID, Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT,</span>
				pub, startDate, endDate, sam);
	}

	/**
	 * @param empID
	 * @param startDate
	 * @param endDate
	 * @param sam
	 * @return
	 */
	public static Collection getUnavailsDuringPeriod(ID empID, Date startDate, Date endDate, boolean pub,
			ScheduleAccessManager sam) throws Exception {

<span class="nc" id="L2168">		return getEventsDuringPeriod(empID, Event.EVENT_TYPE_UNAVAILABILITY, pub, startDate, endDate, sam);</span>
	}

	public static CalendarEventAssignment createCalendarEventAssignment(TORequest toReq, TOChoice apprChoice,
			boolean publish) throws BbmFinderException, RmException, TimeOffCalculatorException, BbmEJBCreateException,
			BbmScheduleConflictException, RemoteException, BbmCreateException, Exception {
		// create a new calendar event.
<span class="nc" id="L2175">		CalendarEventAssignment evt = null;</span>
<span class="nc" id="L2176">		String debitType = toReq.getTimeOffDebitType();</span>

<span class="nc" id="L2178">		ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

		// get overlap and trim existing time off events
<span class="nc" id="L2181">		TORequestUtil.trimOverlappingEvents(toReq, apprChoice, sam, publish);</span>

		// Create an unavailability event if debit type == DEBITTYPE_DONT_DEBIT
<span class="nc bnc" id="L2184" title="All 2 branches missed.">		if (debitType.equals(TORequest.DEBITTYPE_DONT_DEBIT)) {</span>
			// The constraint that &quot;Unavailability events must not overlap
			// shifts&quot;
			// has already been checked by the hard validation logic above.
<span class="nc" id="L2188">			evt = new UnavailabilityEvent();</span>
<span class="nc" id="L2189">			setCalendarEventAssignFields(evt, toReq, apprChoice);</span>
		}
		// Create a timeoff event if debit type == DEBITTYPE_DEBIT
<span class="nc bnc" id="L2192" title="All 2 branches missed.">		else if (debitType.equals(TORequest.DEBITTYPE_DEBIT)) {</span>
<span class="nc" id="L2193">			evt = createTimeOffEventVO(toReq, apprChoice, TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES);</span>
		}
		// create a timeoff event if debit type == DEBITTYPE_DEBIT_ONLY_IF
<span class="nc bnc" id="L2196" title="All 2 branches missed.">		else if (debitType.equals(TORequest.DEBITTYPE_DEBIT_ONLY_IF)) {</span>
<span class="nc" id="L2197">			evt = createTimeOffEventVO(toReq, apprChoice, TimeOffEvent.TIME_OFF_RULE_USE_SHIFT);</span>
		} else {
<span class="nc" id="L2199">			throw createRmException(RmEjbLogBundleKey.INVALID_VALUE, &quot;debitType&quot;, debitType, m_cat);</span>
		}
<span class="nc" id="L2201">		evt.setDescription(getAuditTrailStr(toReq));</span>
<span class="nc" id="L2202">		sam.createCalendarEventAssignment(evt);</span>
<span class="nc" id="L2203">		return evt;</span>
	}

	public static Collection getAuditTrail(TORequest request) throws BbmFinderException {
<span class="nc" id="L2207">		Jdmo dmo = null;</span>
		try {
<span class="nc" id="L2209">			dmo = new Jdmo(false);</span>
<span class="nc" id="L2210">			RequestAuditTrailDAO reqDAO = new RequestAuditTrailDAO(dmo);</span>
<span class="nc" id="L2211">			return reqDAO.getObjectsByParentID(request.getID());</span>
<span class="nc" id="L2212">		} catch (Exception e) {</span>
<span class="nc" id="L2213">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L2215" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L2216">				dmo.cleanUp();</span>
			}
		}
	}

	public static String getAuditTrailStr(TORequest request) throws Exception {
<span class="nc" id="L2222">		StringBuffer sb = new StringBuffer();</span>
<span class="nc" id="L2223">		Collection auditTrails = getAuditTrail(request);</span>
<span class="nc" id="L2224">		TimeZone tz = request.getCache().getOrg().getTimeZone();</span>
<span class="nc" id="L2225">		Localizer localizer = RequestUtil.getLocalizerForAppDefLocale();</span>
<span class="nc bnc" id="L2226" title="All 4 branches missed.">		if (auditTrails != null &amp;&amp; !auditTrails.isEmpty()) {</span>
<span class="nc" id="L2227">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.LAST_MODIFIED)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2228">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.STATUS)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2229">			sb.append(getLocalizedMsgInAppDefLocale(RmEjbBundleKey.COMMENTS)).append(&quot;\n&quot;);</span>
<span class="nc bnc" id="L2230" title="All 2 branches missed.">			for (Iterator it = auditTrails.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2231">				RequestAuditTrail rat = (RequestAuditTrail) it.next();</span>
<span class="nc" id="L2232">				sb.append(localizer.formatDateTime(rat.getModifiedAt(), tz)).append(&quot;\t&quot;);</span>
<span class="nc" id="L2233">				sb.append(getLocalizedMsgInAppDefLocale(NotificationUtil.getBundleKey(rat.getStatus()))).append(&quot;\t&quot;);</span>
<span class="nc" id="L2234">				sb.append(rat.getNote()).append(&quot;\n&quot;);</span>
<span class="nc" id="L2235">			}</span>
		}
<span class="nc bnc" id="L2237" title="All 4 branches missed.">		if (sb.toString() != null &amp;&amp; sb.length() &gt; 1000) {</span>
<span class="nc" id="L2238">			m_cat.info(&quot; The comments exceed allowed Chars so showing the last 1K only: &quot; + sb.toString());</span>
<span class="nc" id="L2239">			return sb.substring(sb.length() - 1000);</span>
		} else {
<span class="nc" id="L2241">			return sb.toString();</span>
		}
	}

	protected static void setCalendarEventAssignFields(CalendarEventAssignment calEvent, TORequest toReq,
			TOChoice toChoice) {
<span class="nc" id="L2247">		calEvent.setActivityID(toReq.getTimeOffType());</span>
<span class="nc" id="L2248">		calEvent.addWorkResourceID(toReq.getEmployeeID());</span>
<span class="nc" id="L2249">		calEvent.setDuration(</span>
<span class="nc" id="L2250">				Math.round(((toChoice.getEndDate().getTime() - toChoice.getStartDate().getTime()) / MINUTE_IN_MILLIS)));</span>
<span class="nc" id="L2251">		calEvent.setStartTime(toChoice.getStartDate());</span>
<span class="nc" id="L2252">	}</span>

	/**
	 * @param employeeID
	 * @param shiftAssn
	 * @param fixShiftAssnSPID
	 *            used to specify the behaviour if the shiftAssignment's SPID
	 *            does not match the employee's SPID during the shift assignment
	 *            timerange. If true and shiftAssn SPID does not match emp's
	 *            SPID, the SPID is set to 'null'. If false, an exception is
	 *            raised.
	 * @param sam
	 * @throws BbmCreateException
	 * @throws BbmScheduleConflictException
	 * @throws RemoteException
	 * @throws BbmEJBCreateException
	 */
	public static void createShiftAssignment(ID empID, ShiftAssignment shiftAssn, boolean fixShiftAssnSPID,
			ScheduleAccessManager sam) throws Exception {
<span class="nc bnc" id="L2271" title="All 2 branches missed.">		if (shiftAssn != null) {</span>
			// associate shiftAssignment with the given employee
<span class="nc" id="L2273">			shiftAssn.addWorkResourceID(empID);</span>

			// quirk of DAO framework: ValueObjectNode maintains four
			// collections of
			// children: read, created, updated and deleted. move the read
			// collection to the created collection.
			// todo: use the fieldInfo associated with ShiftAssignment to copy
			// all child
			// types. Ideal scenario: do a deep copy given a ValueObjectNode.
			// todo: remove hardcoded values below.
			// rewire the child objects for shift assignment (Shift Event
			// Assignments)
<span class="nc bnc" id="L2285" title="All 2 branches missed.">			for (Iterator itr = shiftAssn.getChildObjects(0).iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2286">				ShiftEventAssignment shiftEventAssn = (ShiftEventAssignment) itr.next();</span>
<span class="nc" id="L2287">				shiftEventAssn.addWorkResourceID(empID);</span>
<span class="nc" id="L2288">				shiftAssn.createChildObject(0, shiftEventAssn);</span>
<span class="nc" id="L2289">			}</span>

			// clear the 'read' collection after copying to 'created'
			// collection.
<span class="nc" id="L2293">			shiftAssn.clearChildObjectMap();</span>

			// Need to fix SP of created shift assignment.
			//
<span class="nc" id="L2297">			ID shiftAssnSPID = shiftAssn.getCampaignID();</span>
			// if (shiftAssn.SPID != null &amp;&amp; employeeID is not a member of
			// shiftAssn.SPID)
<span class="nc bnc" id="L2300" title="All 2 branches missed.">			if (shiftAssnSPID != null) {</span>
<span class="nc" id="L2301">				shiftAssn = fixShiftAssnSPIDIfNecess(empID, shiftAssn, fixShiftAssnSPID);</span>
			}

			// create shift assignment
<span class="nc bnc" id="L2305" title="All 2 branches missed.">			if (sam == null) {</span>
<span class="nc" id="L2306">				sam = WfmManagerFactory.getScheduleAccessManager();</span>
			}

			// lock the shift before saving
<span class="nc" id="L2310">			shiftAssn.setLocked(true);</span>
<span class="nc" id="L2311">			sam.createShiftAssignment(shiftAssn);</span>
		}
<span class="nc" id="L2313">	}</span>

	/**
	 * Fixes the SPID associated with the shiftAssn when the shiftAssn needs to
	 * be assigned to the specified empID (during a swap, a shift assignment is
	 * assigned from one employee to another. For this, in addition to switching
	 * the empID associated with the shiftAssignment to the second employee, the
	 * SPID field in the shiftAssn needs to be fixed as well).
	 *
	 * &lt;p&gt;
	 * Rules: During the shift's time range,
	 * &lt;li&gt;If empID is not assoicated with any SP, set ShiftAssn.SPID to 'null'.
	 * &lt;li&gt;if empID is associated with one SP, set shiftAssn.SPID = empSPID.
	 * &lt;li&gt;if empID is associaed with two or more SPs: if empSPIDs collection
	 * contains shiftAssn.SPID, then leave shiftAssn.SPID unchanged. Otherwise
	 * set shiftAssn.SPID to 'null'.
	 *
	 * @param empID
	 * @param shiftAssn
	 * @param fixShiftAssnSPID
	 * @return
	 * @throws Exception
	 */
	private static ShiftAssignment fixShiftAssnSPIDIfNecess(ID empID, ShiftAssignment shiftAssn,
			boolean fixShiftAssnSPID) throws Exception {

<span class="nc" id="L2339">		Date shiftStart = shiftAssn.getStartTime();</span>
<span class="nc" id="L2340">		Date shiftEnd = shiftAssn.getEndTime();</span>
		// Note: getCampignID() may return null.
<span class="nc" id="L2342">		ID shiftAssnSPID = shiftAssn.getCampaignID();</span>

		// empSPIDDuringShiftTimeRange can be 'null'
<span class="nc" id="L2345">		Collection empSPIDsDuringShift = getSPIDsForEmpDuringTimeRange(empID, shiftStart, shiftEnd, null);</span>

<span class="nc" id="L2347">		ID newSPID = null;</span>
<span class="nc bnc" id="L2348" title="All 2 branches missed.">		if (empSPIDsDuringShift.isEmpty()) {</span>
<span class="nc" id="L2349">			newSPID = null;</span>
<span class="nc bnc" id="L2350" title="All 2 branches missed.">		} else if (empSPIDsDuringShift.size() == 1) {</span>
<span class="nc" id="L2351">			newSPID = (ID) empSPIDsDuringShift.iterator().next();</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">		} else if (empSPIDsDuringShift.size() &gt; 1) {</span>
			// Note: shiftAssnSPID can be null.
<span class="nc bnc" id="L2354" title="All 2 branches missed.">			if (empSPIDsDuringShift.contains(shiftAssnSPID)) {</span>
<span class="nc" id="L2355">				newSPID = shiftAssnSPID;</span>
			} else {
<span class="nc" id="L2357">				newSPID = null;</span>
			}
		}

		// newSPID == null &amp;&amp; shiftAssnSPID == null ==&gt; both equal
		// newSPID == null &amp;&amp; shiftAssnSPID != null ==&gt; both not equal
		// newSPID != null &amp;&amp; shiftAssnSPID == null ==&gt; both not equal
		// newSPID != null &amp;&amp; shiftAssnSPID != null ==&gt; equal or not equal.
		// Note: both IDs can be null.
		//
		// if existing shiftAssn.SPID != the newSPID (to be assigned to the
		// shiftAssn).
<span class="nc bnc" id="L2369" title="All 8 branches missed.">		if ((newSPID == null &amp;&amp; shiftAssnSPID != null) || (newSPID != null &amp;&amp; !newSPID.equals(shiftAssnSPID))) {</span>
<span class="nc bnc" id="L2370" title="All 2 branches missed.">			if (!fixShiftAssnSPID) {</span>
<span class="nc" id="L2371">				CampaignManager campMgr = getCampaignManager();</span>

				// throw exception; (SPID must not be fixed for tentative
				// approvals since it can't be undone).
<span class="nc" id="L2375">				String campName = &quot;&quot;;</span>
<span class="nc bnc" id="L2376" title="All 2 branches missed.">				if (shiftAssnSPID != null) {</span>
<span class="nc" id="L2377">					campName = getCampaignByID(getSPForSPID(shiftAssnSPID, campMgr).getCampaignID(), campMgr).getName();</span>
				}

<span class="nc" id="L2380">				throw RequestUtil.createRmHardValidationException(</span>
						RmEjbBundleKey.REQ_CANNOT_CREATE_SHIFTASSIGNMENT_WITH_EMP_SPID_MISMATCH,
<span class="nc" id="L2382">						ValidationUtil.getEmployeeByID(empID, null, Employee.DETAIL_LEVEL_EMPLOYEE_BASIC), shiftStart,</span>
						shiftEnd, campName, m_cat);
			} else {
<span class="nc bnc" id="L2385" title="All 2 branches missed.">				if (newSPID != null) {</span>
<span class="nc" id="L2386">					shiftAssn.setCampaignID(newSPID);</span>
				} else {
<span class="nc" id="L2388">					shiftAssn.setFieldNull(ShiftAssignmentFields.CAMPAIGNID);</span>
				}
			}
		}

<span class="nc" id="L2393">		return shiftAssn;</span>
	}

	// TESTME undoSwap
	public static ShiftAssignment deleteShiftAssignment(ShiftSwapItem ssItem1, ScheduleAccessManager sam,
			ShiftSwapValidationCache ssCache) throws Exception {
		// try {
<span class="nc bnc" id="L2400" title="All 2 branches missed.">		if (sam == null) {</span>
<span class="nc" id="L2401">			sam = WfmManagerFactory.getScheduleAccessManager();</span>
		}

<span class="nc" id="L2404">		ShiftAssignment shiftAssignUnpub = ShiftSwapRequestUtil.getShiftAssignForSSItemAligned(ssItem1, false, sam,</span>
				ssCache);
<span class="nc bnc" id="L2406" title="All 2 branches missed.">		if (shiftAssignUnpub == null) {</span>
<span class="nc" id="L2407">			throw createAndLogRmHardValidationException(RmEjbBundleKey.SS_SHIFTNOTFOUND_FOR_SSITEM,</span>
<span class="nc" id="L2408">					RmEjbLogBundleKey.SS_SHIFTNOTFOUND_FOR_SSITEM, new Object[] { ssItem1.getStartDate(),</span>
<span class="nc" id="L2409">							ssItem1.getEndDate(), ssItem1.getEmployeeID(), ssItem1.getID() },</span>
					m_cat);
		}

		// delete shift assignment
<span class="nc" id="L2414">		sam.deleteShiftAssignments(Collections.singleton(shiftAssignUnpub.getID()));</span>

<span class="nc" id="L2416">		return shiftAssignUnpub;</span>
		// } c_atch (Exception e) {
		// t_hrow createValidationExceptionWrapper(e, m_cat);
		// }
	}

	public static String makeCacheKey(String keyPrefix, Object obj1) {
<span class="nc bnc" id="L2423" title="All 2 branches missed.">		if (obj1 == null) {</span>
<span class="nc" id="L2424">			throw new IllegalArgumentException();</span>
		}

<span class="nc" id="L2427">		return keyPrefix + '_' + obj1;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2) {
<span class="nc bnc" id="L2431" title="All 4 branches missed.">		if (obj1 == null || obj2 == null) {</span>
<span class="nc" id="L2432">			throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2);</span>
		}

<span class="nc" id="L2435">		return keyPrefix + '_' + obj1 + '_' + obj2;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2, Object obj3) {
<span class="nc bnc" id="L2439" title="All 6 branches missed.">		if (obj1 == null || obj2 == null || obj3 == null) {</span>
<span class="nc" id="L2440">			throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2 + ',' + obj3);</span>
		}

<span class="nc" id="L2443">		return keyPrefix + '_' + obj1 + '_' + obj2 + '_' + obj3;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object obj1, Object obj2, Object obj3, Object obj4) {
<span class="nc bnc" id="L2447" title="All 8 branches missed.">		if (obj1 == null || obj2 == null || obj3 == null || obj4 == null) {</span>
<span class="nc" id="L2448">			throw new IllegalArgumentException(</span>
					&quot;makeCacheKey: null argument: &quot; + obj1 + ',' + obj2 + ',' + obj3 + ',' + obj4);
		}

<span class="nc" id="L2452">		return keyPrefix + '_' + obj1 + '_' + obj2 + '_' + obj3 + '_' + obj4;</span>
	}

	public static String makeCacheKey(String keyPrefix, Object[] objs) {
<span class="nc" id="L2456">		StringBuffer strBuf = new StringBuffer(keyPrefix);</span>

<span class="nc bnc" id="L2458" title="All 2 branches missed.">		for (int i = 0; i &lt; objs.length; i++) {</span>
<span class="nc bnc" id="L2459" title="All 2 branches missed.">			if (objs[i] == null) {</span>
<span class="nc" id="L2460">				throw new IllegalArgumentException(&quot;makeCacheKey: null argument: &quot; + i);</span>
			}

<span class="nc" id="L2463">			strBuf.append('_').append(objs[i]);</span>
		}

<span class="nc" id="L2466">		return strBuf.toString();</span>
	}

	/**
	 * @param orgID
	 * @return
	 * @throws BbmFinderException
	 * @throws RemoteException
	 */
	public static OrganizationSetting getOrgSetting(ID orgID, OrganizationConfigManager orgCfgMgr) throws Exception {

		// Obtain the configuration settings for the employee's organization
<span class="nc" id="L2478">		return CacheUtilRM.getOrgSetting(orgID);</span>
	}

	public static void verifyAuditTrailOrdering(RequestAggregate reqAgg) throws Exception {
		// verify audit trail ordering
<span class="nc" id="L2483">		Date lastAuditTime = new Date(0);</span>
<span class="nc" id="L2484">		Collection auditTrails = reqAgg.getAuditTrail();</span>
<span class="nc bnc" id="L2485" title="All 2 branches missed.">		for (Iterator itr = auditTrails.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2486">			RequestAuditTrail trail = (RequestAuditTrail) itr.next();</span>

<span class="nc bnc" id="L2488" title="All 2 branches missed.">			if (lastAuditTime.after(trail.getModifiedAt())) {</span>
<span class="nc" id="L2489">				throw createRmException(RmEjbLogBundleKey.AUDIT_TRAIL_INVALIDORDER, reqAgg.getID(), m_cat);</span>
			}

<span class="nc" id="L2492">			lastAuditTime = trail.getModifiedAt();</span>
<span class="nc" id="L2493">		}</span>
<span class="nc" id="L2494">	}</span>

	public static synchronized RmManagerFactory getRmManagerFactory() {
<span class="nc bnc" id="L2497" title="All 2 branches missed.">		if (m_rmMgrFactory == null) {</span>
<span class="nc" id="L2498">			m_rmMgrFactory = RmManagerFactory.getInstance(true);</span>
		}

<span class="nc" id="L2501">		return m_rmMgrFactory;</span>
	}

	// TODO: add caching.
	public static TORequestManager getTORequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2506" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2507">			return getRmManagerFactory().getTimeOffRequestManager(userName, password);</span>
		}
<span class="nc" id="L2509">		return getRmManagerFactory().getTimeOffRequestManager(userName, password);</span>
	}

	public static FlexTimeRequestManager getFlexTimeRequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2513" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2514">			return getRmManagerFactory().getFlexTimeRequestManager(userName, password);</span>
		}
<span class="nc" id="L2516">		return getRmManagerFactory().getFlexTimeRequestManager(userName, password);</span>
	}

	public static TOWaitlistManager getTOWaitlistManager() throws Exception {
<span class="nc" id="L2520">		return getRmManagerFactory().getTOWaitlistManager();</span>
	}

	public static TOHoursPerDayManager getTOHoursPerDayManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2524" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2525">			return getRmManagerFactory().getTOHoursPerDayManager();</span>
		}
<span class="nc" id="L2527">		return getRmManagerFactory().getTOHoursPerDayManager(userName, password);</span>
	}

	public static TOWithdrawManager getTOWithdrawManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2531" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2532">			return getRmManagerFactory().getTOWithdrawManager();</span>
		}
<span class="nc" id="L2534">		return getRmManagerFactory().getTOWithdrawManager(userName, password);</span>
	}

	// TODO: add caching.
	public static ShiftSwapRequestManager getSSRequestMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2539" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2540">			return getRmManagerFactory().getShiftSwapRequestManager();</span>
		}
<span class="nc" id="L2542">		return getRmManagerFactory().getShiftSwapRequestManager(userName, password);</span>
	}

	public static ShiftBidRequestManager getShiftBidRequestManager(String userName, String password)
			throws BbmCreateException {
<span class="nc bnc" id="L2547" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2548">			return getRmManagerFactory().getShiftBidRequestManager();</span>
		}
<span class="nc" id="L2550">		return getRmManagerFactory().getShiftBidRequestManager(userName, password);</span>
	}

	// TODO: add caching.
	public static ShiftBidAuctionManager getShiftBidAuctionMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2555" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2556">			return getRmManagerFactory().getShiftBidAuctionManager();</span>
		}
<span class="nc" id="L2558">		return getRmManagerFactory().getShiftBidAuctionManager(userName, password);</span>
	}

	// TODO: add caching.
	public static OrganizationConfigManager getOrgConfigMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2563" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2564">			return getRmManagerFactory().getOrganizationConfigManager();</span>
		}
<span class="nc" id="L2566">		return getRmManagerFactory().getOrganizationConfigManager(userName, password);</span>
	}

	public static ScheduleAccessManager getScheduleAccessManager() throws Exception {
<span class="nc" id="L2570">		return WfmManagerFactory.getScheduleAccessManager();</span>
	}

	/**
	 *
	 */
	public static WorkResourceManager getWorkResourceManager() throws Exception {
<span class="nc" id="L2577">		return BbmManagerFactory.getWorkResourceManager();</span>
	}

	/**
	 * @return
	 */
	public static UserManager getUserManager() throws Exception {
		// TODO Auto-generated method stub
<span class="nc" id="L2585">		return CoreManagerFactory.getUserManager(false);</span>
	}

	public static ActivityManager getActivityManager() throws BbmEJBCreateException {
<span class="nc" id="L2589">		return WfmManagerFactory.getActivityManager();</span>
	}

	/**
	 * @param userName
	 * @param password
	 * @return
	 */
	public static CommonRequestManager getCommonRequestManager(String userName, String password) throws Exception {
<span class="nc bnc" id="L2598" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2599">			return getRmManagerFactory().getCommonRequestManager();</span>
		}
<span class="nc" id="L2601">		return getRmManagerFactory().getCommonRequestManager(userName, password);</span>
	}

	/**
	 *
	 */
	public static ShiftSwapPostingManager getShiftSwapPostingMgr(String userName, String password) throws Exception {
<span class="nc bnc" id="L2608" title="All 4 branches missed.">		if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L2609">			return getRmManagerFactory().getShiftSwapPostingManager();</span>
		}
<span class="nc" id="L2611">		return getRmManagerFactory().getShiftSwapPostingManager(userName, password);</span>
	}

	public static CampaignManager getCampaignManager() throws BbmEJBCreateException {
<span class="nc" id="L2615">		return WfmManagerFactory.getCampaignManager();</span>
	}

	public static Collection getMapValues(Map map) {
		// get entry set
<span class="nc" id="L2620">		Set entrySet = map.entrySet();</span>

		// if entry set empty, then return empty collection.
<span class="nc bnc" id="L2623" title="All 2 branches missed.">		if (entrySet.isEmpty()) {</span>
<span class="nc" id="L2624">			return Collections.emptyList();</span>
		}

		// Now, add the values of the each map entry to the collection.
<span class="nc" id="L2628">		ArrayList arrList = new ArrayList();</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">		for (Iterator itr = entrySet.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2630">			Map.Entry mapEntry = (Map.Entry) itr.next();</span>
<span class="nc" id="L2631">			arrList.add(mapEntry.getValue());</span>
<span class="nc" id="L2632">		}</span>

		// return collection.
<span class="nc" id="L2635">		return arrList;</span>
	}

	/**
	 * @param collection
	 */
	public static Set getSetFromCollection(Collection collection) {
<span class="nc bnc" id="L2642" title="All 4 branches missed.">		if (collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L2643">			return new HashSet(); // caller modifies the returned set; return</span>
									// Collections.EMPTY_SET
		}

		// if (collection.size() == 1) {
		// caller modifies the returned set; Collections.singleton() is
		// immutable.
		// return Collections.singleton(collection.iterator().next());
		// }

<span class="nc" id="L2653">		HashSet set = new HashSet(collection.size());</span>
<span class="nc" id="L2654">		set.addAll(collection);</span>

<span class="nc" id="L2656">		return set;</span>
	}

	/**
	 * @param collection
	 * @return
	 */
	public static &lt;T&gt; List&lt;T&gt; getListFromCollection(Collection&lt;T&gt; collection) {
<span class="nc bnc" id="L2664" title="All 4 branches missed.">		if (collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L2665">			return Collections.emptyList();</span>
		}

<span class="nc bnc" id="L2668" title="All 2 branches missed.">		if (collection.size() == 1) {</span>
<span class="nc" id="L2669">			return Collections.singletonList(collection.iterator().next());</span>
		}

<span class="nc" id="L2672">		return new ArrayList&lt;T&gt;(collection);</span>
	}

	/**
	 * Returns a list with the IDs extracted from the given collection of
	 * objects subclassed from {@link ValueObjectBase ValueObjectBase} objects
	 * (all value objects constructed for data read from the database)
	 *
	 * @param valObjBases
	 * @return
	 */
	public static List&lt;ID&gt; getListOfIDsFromVOBases(Collection valObjBases) {
<span class="nc bnc" id="L2684" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2685">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2688">		List&lt;ID&gt; idList = new ArrayList&lt;ID&gt;(valObjBases.size());</span>
<span class="nc bnc" id="L2689" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2690">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2691">			idList.add(valObjBase.getID());</span>
<span class="nc" id="L2692">		}</span>

<span class="nc" id="L2694">		return idList;</span>
	}

	public static List getListOfFieldValuesFromVOBases(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2698" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2699">			return Collections.emptyList();</span>
		}

<span class="nc" id="L2702">		List fieldValues = new ArrayList(valObjBases.size());</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2704">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2705">			fieldValues.add(valObjBase.getFieldValue(fieldIndex));</span>
<span class="nc" id="L2706">		}</span>

<span class="nc" id="L2708">		return fieldValues;</span>
	}

	public static Set getSetOfFieldValuesFromVOBases(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2712" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2713">			return Collections.emptySet();</span>
		}

<span class="nc" id="L2716">		Set fieldValues = new HashSet(valObjBases.size() * 2);</span>
<span class="nc bnc" id="L2717" title="All 2 branches missed.">		for (Iterator valObjBaseIter = valObjBases.iterator(); valObjBaseIter.hasNext();) {</span>
<span class="nc" id="L2718">			ValueObjectBase valObjBase = (ValueObjectBase) valObjBaseIter.next();</span>
<span class="nc" id="L2719">			fieldValues.add(valObjBase.getFieldValue(fieldIndex));</span>
<span class="nc" id="L2720">		}</span>

<span class="nc" id="L2722">		return fieldValues;</span>
	}

	/**
	 * orders the given voBasesList using the passed idList and return the
	 * ordered list of voBases.
	 *
	 * &lt;p&gt;
	 * &lt;li&gt;for an ID in 'idList' not found in 'voBasesList', no voBase is added
	 * to the returned list.
	 * &lt;li&gt;for an ID in 'idList' found in 'voBaseList', the voBase is added to
	 * the returned list.
	 * &lt;li&gt;for a voBase in 'voBaseList' not found in 'idList', the voBase is not
	 * added to the returned list.
	 *
	 * @param reqIDs
	 * @param sbReqsAsList
	 * @return
	 */
	public static List getListOfVOBasesOrderedByIDList(List idList, List voBasesList) {
<span class="nc" id="L2742">		Map idToVOBaseMap = getMapOfIDsForVOBases(voBasesList);</span>

		// reuse 'sbReqsAsList' if 'reqIDs' list and 'sbReqsAsList' are same
		// size. Otherwise
		// allocate a new List.
<span class="nc" id="L2747">		int voBasesListSize = voBasesList.size();</span>
<span class="nc" id="L2748">		int idListSize = idList.size();</span>
<span class="nc bnc" id="L2749" title="All 2 branches missed.">		voBasesList = (idListSize == voBasesListSize) ? voBasesList : new ArrayList(voBasesListSize);</span>

<span class="nc bnc" id="L2751" title="All 2 branches missed.">		for (int i = 0; i &lt; idListSize; i++) {</span>
<span class="nc" id="L2752">			Object voBaseForID = idToVOBaseMap.get(idList.get(i));</span>

<span class="nc bnc" id="L2754" title="All 2 branches missed.">			if (voBaseForID != null) {</span>
<span class="nc" id="L2755">				voBasesList.set(i, voBaseForID);</span>
			}
		}

<span class="nc" id="L2759">		return voBasesList;</span>
	}

	/**
	 * Reverses the given list in-place.
	 *
	 * @param sbReqsList
	 */
	public static void getListReversed(List sbReqsList) {
<span class="nc" id="L2768">		int sbReqsListSize = sbReqsList.size();</span>

		// if passed list is empty or size == 1.
<span class="nc bnc" id="L2771" title="All 4 branches missed.">		if (sbReqsList.isEmpty() || (sbReqsListSize == 1)) {</span>
<span class="nc" id="L2772">			return;</span>
		}

<span class="nc" id="L2775">		int rev = sbReqsListSize - 1; // index moving in reverse direction.</span>
		// reverses even and odd sized lists correctly.
<span class="nc bnc" id="L2777" title="All 2 branches missed.">		for (int fwd = 0; fwd &lt; rev; fwd++, rev--) { // fwd == index moving in</span>
														// forward direction.
			// swap elements pointed by 'fwd' and 'rev'.
<span class="nc" id="L2780">			Object tmp = sbReqsList.get(fwd);</span>
<span class="nc" id="L2781">			sbReqsList.set(fwd, sbReqsList.get(rev));</span>
<span class="nc" id="L2782">			sbReqsList.set(rev, tmp);</span>
		}
<span class="nc" id="L2784">	}</span>

	/**
	 * Searches for the value object with the specified ID in the given list of
	 * valueObjects.
	 *
	 * @param sbReq
	 * @param sbReqsSortedForBidSched
	 * @return -1, if not found. the index, if found.
	 */
	public static int findInVOBaseListByID(List voBasesList, ID givenVOBaseID) {
		// TODO: improve later. presently just a linear scan.
<span class="nc bnc" id="L2796" title="All 4 branches missed.">		for (int idx = 0; voBasesList != null &amp;&amp; idx &lt; voBasesList.size(); idx++) {</span>
<span class="nc" id="L2797">			ValueObjectBase voBase = (ValueObjectBase) voBasesList.get(idx);</span>

<span class="nc bnc" id="L2799" title="All 2 branches missed.">			if (voBase.getID().equals(givenVOBaseID)) {</span>
<span class="nc" id="L2800">				return idx;</span>
			}
		}

<span class="nc" id="L2804">		return -1;</span>
	}

	/**
	 * Searches for the value object with the specified field value, at the
	 * given field index, in the given list of valueObjects.
	 *
	 * @param sbReq
	 * @param sbReqsSortedForBidSched
	 * @return -1 if not found. if found, the index at which the value object
	 *         was found.
	 */
	public static int findInVOBaseListByFieldValue(List voBasesList, int fieldIndex, Object fieldValue) {
		// TODO: improve later. presently just a linear scan.
<span class="nc bnc" id="L2818" title="All 4 branches missed.">		for (int idx = 0; voBasesList != null &amp;&amp; idx &lt; voBasesList.size(); idx++) {</span>
<span class="nc" id="L2819">			ValueObjectBase voBase = (ValueObjectBase) voBasesList.get(idx);</span>

<span class="nc bnc" id="L2821" title="All 2 branches missed.">			if (voBase.getFieldValue(fieldIndex).equals(fieldValue)) {</span>
<span class="nc" id="L2822">				return idx;</span>
			}
		}

<span class="nc" id="L2826">		return -1;</span>
	}

	/**
	 * Builds and returns a map of valObjBase.ID to valueObjectBase
	 *
	 * @param valObjBases
	 * @return
	 */
	public static Map getMapOfIDsForVOBases(Collection valObjBases) {
<span class="nc" id="L2836">		return addToMapOfIDsForVOBases(null, valObjBases);</span>
	}

	/**
	 * Builds and returns a map of valObjBase.ID to valueObjectBase
	 *
	 * @param valObjBases
	 * @return
	 */
	public static Map addToMapOfIDsForVOBases(Map IDToVOMap, Collection valObjBases) {
<span class="nc bnc" id="L2846" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc bnc" id="L2847" title="All 2 branches missed.">			return (IDToVOMap == null) ? Collections.emptyMap() : IDToVOMap;</span>
		}

<span class="nc bnc" id="L2850" title="All 2 branches missed.">		IDToVOMap = (IDToVOMap == null) ? new HashMap(valObjBases.size() * 2) : IDToVOMap;</span>
<span class="nc bnc" id="L2851" title="All 2 branches missed.">		for (Iterator VOIter = valObjBases.iterator(); VOIter.hasNext();) {</span>
<span class="nc" id="L2852">			ValueObjectBase vo = (ValueObjectBase) VOIter.next();</span>
<span class="nc" id="L2853">			IDToVOMap.put(vo.getID(), vo);</span>
<span class="nc" id="L2854">		}</span>

<span class="nc" id="L2856">		return IDToVOMap;</span>
	}

	/**
	 * Builds and returns a map of valObjectBase.&lt;specified field&gt; to
	 * valueObjectBase.
	 *
	 * @param valObjBases
	 * @param fieldIndex
	 * @return
	 */
	public static Map getMapOfFieldToVOBase(Collection valObjBases, int fieldIndex) {
<span class="nc bnc" id="L2868" title="All 2 branches missed.">		if (valObjBases.isEmpty()) {</span>
<span class="nc" id="L2869">			return Collections.emptyMap();</span>
		}

<span class="nc" id="L2872">		Map fieldToVOMap = new HashMap(valObjBases.size() * 2);</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">		for (Iterator VOIter = valObjBases.iterator(); VOIter.hasNext();) {</span>
<span class="nc" id="L2874">			ValueObjectBase vo = (ValueObjectBase) VOIter.next();</span>
<span class="nc" id="L2875">			fieldToVOMap.put(vo.getFieldValue(fieldIndex), vo);</span>
<span class="nc" id="L2876">		}</span>

<span class="nc" id="L2878">		return fieldToVOMap;</span>
	}

	/**
	 * Invokes {@link ValueObjectNode#moveChildrenFromCreatedToPersisted()
	 * moveChildrenFromCreatedToPersisted()} for each element in the collection.
	 *
	 * @param voNodes
	 */
	public static void moveChildrenFromCreatedToPersisted(Collection voNodes) {
<span class="nc bnc" id="L2888" title="All 2 branches missed.">		for (Iterator iter = voNodes.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2889">			ValueObjectNode voNode = (ValueObjectNode) iter.next();</span>
<span class="nc" id="L2890">			voNode.moveChildrenFromCreatedToPersisted();</span>
<span class="nc" id="L2891">		}</span>
<span class="nc" id="L2892">	}</span>

	/**
	 * Checks if any of the given events is contained within the onBits of the
	 * given timeMap. if so, returns the first such event.
	 *
	 * @param unpubCalEventsTimeMap
	 * @param shiftAssns
	 * @return The contained event, if found. Null otherwise
	 */
	public static Event verifyOnBitsContainEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2903" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2904">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2905" title="All 2 branches missed.">			if (timeMap.onBitsContainRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2906">				return event;</span>
			}
<span class="nc" id="L2908">		}</span>

<span class="nc" id="L2910">		return null;</span>
	}

	/**
	 * Checks if any of the given events overlaps the offBits of the given
	 * timeMap. if so, returns the first such event.
	 *
	 * @param unpubCalEventsTimeMap
	 * @param shiftAssns
	 * @return The contained event, if found. Null otherwise
	 */
	public static Event verifyOffBitsOverlapEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2922" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2923">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2924" title="All 2 branches missed.">			if (!timeMap.onBitsContainRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2925">				return event;</span>
			}
<span class="nc" id="L2927">		}</span>

<span class="nc" id="L2929">		return null;</span>
	}

	/**
	 * Checks if any of the given events overlaps the onBits of the given
	 * timeMap. if so, returns the first such event.
	 *
	 * @param schedShiftAssnsTimeMap
	 * @param sbrShiftAssns
	 * @return The overlapping event, if found. Null otherwise
	 */
	public static Event verifyOnBitsOverlapEvents(TimeMap timeMap, Collection events) {
<span class="nc bnc" id="L2941" title="All 2 branches missed.">		for (Iterator eventIter = events.iterator(); eventIter.hasNext();) {</span>
<span class="nc" id="L2942">			Event event = (Event) eventIter.next();</span>
<span class="nc bnc" id="L2943" title="All 2 branches missed.">			if (timeMap.onBitsOverlapRange(event.getStartTime(), event.getEndTime())) {</span>
<span class="nc" id="L2944">				return event;</span>
			}
<span class="nc" id="L2946">		}</span>

<span class="nc" id="L2948">		return null;</span>
	}

	/**
	 * Get shift assignment as it would be created without accessing DB.
	 * @param shiftAssns
	 * @param toEmpID
	 * @param publishDateRange
	 * @param sam
	 * @param isMultiShiftBlocks
	 * @param allowOverlap
	 * @return Collection of shifts
	 * @throws Exception
	 */
	public static Collection getMovedShiftAssnsToEmp(Collection shiftAssns, ID toEmpID,
			TimeRange publishDateRange, ScheduleAccessManager sam,
			boolean isMultiShiftBlocks, boolean allowOverlap) throws Exception {

<span class="nc" id="L2966">		List srcShiftAssnIDs = RequestUtil.getListOfIDsFromVOBases(shiftAssns);</span>

		// modify shift assignments's employeeID from phantom / other emp to moved employee
<span class="nc" id="L2969">		RequestUtil.replaceEmployeeIDForShiftAssignments(shiftAssns, toEmpID);</span>

<span class="nc bnc" id="L2971" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>

		/**
		 * when a shift bidding is a multiple shift block bidding,
		 * the first shift block is going to update to include the next shift block
		 */
<span class="nc bnc" id="L2977" title="All 2 branches missed.">		if(isMultiShiftBlocks) {</span>
<span class="nc" id="L2978">			Collection&lt;BbmScheduleConflict&gt; listConflicts = sam.getConflictsForNewScheduleObjects(shiftAssns);</span>
<span class="nc bnc" id="L2979" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L2980">				Collection&lt;ShiftAssignment&gt; s = solveConflicts(listConflicts, publishDateRange, srcShiftAssnIDs, allowOverlap);</span>
				//Return stitched
<span class="nc" id="L2982">				return s;</span>
			}
		}
		//Not stitched. Return swapped shift.
<span class="nc" id="L2986">		return shiftAssns;</span>
	}

	public static boolean isOverlap(ShiftAssignment s1, ShiftAssignment s2){
<span class="nc bnc" id="L2990" title="All 4 branches missed.">		if (s1==null || s2==null){</span>
<span class="nc" id="L2991">			return false;</span>
		}
<span class="nc" id="L2993">		Timeline s1TimeLine = new Timeline(s1.getStartTime(),s1.getEndTime());</span>
<span class="nc bnc" id="L2994" title="All 2 branches missed.">		for (Iterator itr = s1.getChildObjects(0).iterator(); itr.hasNext(); ) {</span>
<span class="nc" id="L2995">			ShiftEventAssignment shiftEventAssn = (ShiftEventAssignment) itr.next();</span>
<span class="nc bnc" id="L2996" title="All 2 branches missed.">			if (shiftEventAssn.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)){</span>
<span class="nc" id="L2997">				s1TimeLine = s1TimeLine.subtract(new Timeline(shiftEventAssn.getStartTime(),shiftEventAssn.getEndTime()));</span>
			}
<span class="nc" id="L2999">		}</span>

<span class="nc" id="L3001">		Timeline s2TimeLine = new Timeline(s2.getStartTime(),s2.getEndTime());</span>
<span class="nc bnc" id="L3002" title="All 2 branches missed.">		for (Iterator itr = s2.getChildObjects(0).iterator(); itr.hasNext(); ) {</span>
<span class="nc" id="L3003">			ShiftEventAssignment shiftEventAssn = (ShiftEventAssignment) itr.next();</span>
<span class="nc bnc" id="L3004" title="All 2 branches missed.">			if (shiftEventAssn.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)){</span>
<span class="nc" id="L3005">				s2TimeLine = s2TimeLine.subtract(new Timeline(shiftEventAssn.getStartTime(),shiftEventAssn.getEndTime()));</span>
			}
<span class="nc" id="L3007">		}</span>
<span class="nc bnc" id="L3008" title="All 2 branches missed.">		return !s1TimeLine.intersect(s2TimeLine).isEmpty();</span>
	}

	/**
	 * Get overlap shift is shift will overlap an existing shift
	 * @param shiftAssns - shift being added to schedule
	 * @param toEmpID - emp id to replace. This is for swaps. If null will check original emp in shift
	 * @param sam
	 * @return - shift causing overlap
	 * @throws Exception
	 */
	public static ShiftAssignment getOverlap(Collection shiftAssns, ID toEmpID, TimeRange publishDateRange, ScheduleAccessManager sam) throws Exception {
<span class="nc" id="L3020">		ShiftAssignment ret = null;</span>
		// modify shift assignments's employeeID from phantom / other emp to moved employee
<span class="nc bnc" id="L3022" title="All 2 branches missed.">		if (toEmpID!=null){</span>
<span class="nc" id="L3023">			RequestUtil.replaceEmployeeIDForShiftAssignments(shiftAssns, toEmpID);</span>
		}
<span class="nc bnc" id="L3025" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>
<span class="nc" id="L3026">		Collection&lt;BbmScheduleConflict&gt; listConflicts = sam.getConflictsForNewScheduleObjects(shiftAssns);</span>

<span class="nc bnc" id="L3028" title="All 2 branches missed.">		for(BbmScheduleConflict c: listConflicts){</span>
<span class="nc bnc" id="L3029" title="All 2 branches missed.">			if (c.getConflictType()==BbmScheduleConflict.CONFLICT_OVERLAP_SHIFT){</span>
<span class="nc" id="L3030">				ShiftAssignment first = (ShiftAssignment) c.getFirstObject();</span>
<span class="nc" id="L3031">				ShiftAssignment second = (ShiftAssignment) c.getSecondObject();</span>

<span class="nc" id="L3033">				TimeMap firstTimeMap = buildTimeMap(Collections.singleton(first), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc" id="L3034">				TimeMap secondTimeMap = buildTimeMap(Collections.singleton(second), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc bnc" id="L3035" title="All 2 branches missed.">				if(firstTimeMap.intersects(secondTimeMap)){</span>
<span class="nc" id="L3036">					ret = (ShiftAssignment)c.getSecondObject();</span>
				}
				break;
			}
<span class="nc" id="L3040">		}</span>
<span class="nc" id="L3041">		return ret;</span>
	}


	/**
	 * @param shiftAssns
	 * @param toEmpID
	 * @param publish
	 * @param publishDateRange
	 *            if 'null' then each shift assignment is published
	 *            individually. If 'non-null' the specified interval is
	 *            published.
	 * @param deleteUnderlyingUnavails
	 * @param sam
	 * @return
	 * @throws Exception
	 */
	public static List&lt;ShiftAssignment&gt; moveShiftAssnsToEmp(Collection&lt;ShiftAssignment&gt; shiftAssns, ID toEmpID, boolean publish,
			TimeRange publishDateRange, boolean deleteUnderlyingUnavails, ScheduleAccessManager sam,
			boolean isMultiShiftBlocks, boolean allowOverlap) throws Exception {

<span class="nc bnc" id="L3062" title="All 2 branches missed.">		for (ShiftAssignment sa : shiftAssns) {</span>
<span class="nc" id="L3063">			sa.setID(null);</span>
<span class="nc" id="L3064">		}</span>
<span class="nc" id="L3065">		Collection&lt;ID&gt; srcShiftAssnIDs = Collections.emptyList();</span>

		// modify shift assignments's employeeID from phantom to actual employee
<span class="nc" id="L3068">		RequestUtil.replaceEmployeeIDForShiftAssignments(shiftAssns, toEmpID);</span>

<span class="nc bnc" id="L3070" title="All 2 branches missed.">		sam = (sam == null) ? WfmManagerFactory.getScheduleAccessManager() : sam;</span>



		// delete underlying unavailabilities before creating the shift
		// assignments if parameter
		// deleteUnderlyingUnavails == true.
<span class="nc bnc" id="L3077" title="All 2 branches missed.">		if (deleteUnderlyingUnavails) {</span>
<span class="nc bnc" id="L3078" title="All 2 branches missed.">			for (Object shiftAssnsObj : shiftAssns) {</span>
<span class="nc" id="L3079">				ShiftAssignment shiftAssn = (ShiftAssignment) shiftAssnsObj;</span>

				// delete underlying unavailabilies
<span class="nc" id="L3082">				ShiftSwapRequestUtil.deleteUnderlyingUnavailabilities(toEmpID, shiftAssn.getStartTime(),</span>
<span class="nc" id="L3083">						shiftAssn.getEndTime(), sam);</span>
<span class="nc" id="L3084">			}</span>
		}

<span class="nc" id="L3087">		Collection&lt;ID&gt; shiftAssnIDsToPublish = new ArrayList&lt;ID&gt;();</span>
		/**
		 * when a shift bidding is a multiple shift block bidding,
		 * the first shift block is going to update to include the next shift block
		 */
<span class="nc bnc" id="L3092" title="All 2 branches missed.">		if(isMultiShiftBlocks) {</span>
<span class="nc" id="L3093">			Collection&lt;BbmScheduleConflict&gt; listConflicts = sam.getConflictsForNewScheduleObjects(shiftAssns);</span>
<span class="nc bnc" id="L3094" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L3095">				Collection&lt;ShiftAssignment&gt; s = solveConflicts(listConflicts, publishDateRange, srcShiftAssnIDs, allowOverlap);</span>
<span class="nc bnc" id="L3096" title="All 2 branches missed.">				for (ShiftAssignment shiftAssn : s) {</span>
<span class="nc" id="L3097">					shiftAssn.setDeleteChildrenBeforeCreate(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc" id="L3098">					sam.updateShiftAssignment(shiftAssn);</span>
<span class="nc" id="L3099">					shiftAssnIDsToPublish.add(shiftAssn.getID());</span>
<span class="nc" id="L3100">					m_cat.debug(&quot;Shift block merged into shift assignment ID: &quot; + shiftAssn.getID());</span>
<span class="nc" id="L3101">				}</span>
			}
		}

<span class="nc bnc" id="L3105" title="All 2 branches missed.">		if(shiftAssnIDsToPublish.isEmpty()) {</span>
			// create the shift assignments for the actual employee and publish if
			// necessary
<span class="nc" id="L3108">			Collection&lt;ID&gt; createdShiftAssnIDs = sam.createShiftAssignments(shiftAssns);</span>
<span class="nc bnc" id="L3109" title="All 2 branches missed.">			if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L3110">				m_cat.debug(&quot;created shift assignments: IDs &quot; + RmUtil.dumpCollection(createdShiftAssnIDs));</span>
			}
<span class="nc" id="L3112">			shiftAssnIDsToPublish.addAll(createdShiftAssnIDs);</span>
		}

<span class="nc" id="L3115">		int nMaxRetries = 3;</span>
<span class="nc" id="L3116">		int nRetry = 0;</span>
<span class="nc bnc" id="L3117" title="All 2 branches missed.">		boolean publishByDateRange = publishDateRange != null;</span>
<span class="nc" id="L3118">		List&lt;ShiftAssignment&gt; createdShiftAssns = new ArrayList&lt;ShiftAssignment&gt;(shiftAssns.size());</span>
<span class="nc bnc" id="L3119" title="All 2 branches missed.">		for (ID createdShiftAssnID: shiftAssnIDsToPublish) {</span>

<span class="nc" id="L3121">			ShiftAssignment createdShiftAssn = sam.getShiftAssignmentByID(createdShiftAssnID);</span>
<span class="nc" id="L3122">			createdShiftAssns.add(createdShiftAssn);</span>

			// publish if necessary, shift by shift.
			// QC46055 some approved shiftbidrequests do not get published
<span class="nc bnc" id="L3126" title="All 4 branches missed.">			if (publish &amp;&amp; !publishByDateRange) {</span>
<span class="nc bnc" id="L3127" title="All 2 branches missed.">				for (; nRetry &lt; nMaxRetries; nRetry++) {</span>
					try {
<span class="nc" id="L3129">						Date startTime = createdShiftAssn.getStartTime();</span>
<span class="nc" id="L3130">						Date endTime = createdShiftAssn.getEndTime();</span>
<span class="nc" id="L3131">						m_cat.debug(</span>
								&quot;publishing: empID, startTime, endTime: &quot; + toEmpID + ',' + startTime + ',' + endTime);
<span class="nc" id="L3133">						sam.publishSchedule(Collections.singleton(toEmpID), startTime, endTime);</span>
<span class="nc" id="L3134">						break;</span>
<span class="nc" id="L3135">					} catch (Exception e) {</span>
<span class="nc" id="L3136">						m_cat.debug(&quot;Publish shift bid schedule failed&quot;, e);</span>
<span class="nc bnc" id="L3137" title="All 2 branches missed.">						if (nRetry &lt; nMaxRetries) {</span>
<span class="nc" id="L3138">							continue;</span>
						}
<span class="nc" id="L3140">						m_cat.info(&quot;Publish shift bid schedule failed after retrying &quot; + nRetry + &quot; times&quot;);</span>
<span class="nc" id="L3141">						throw e;</span>
					}
				}
			}
<span class="nc" id="L3145">		}</span>

		// QC46055 some approved shiftbidrequests do not get published
<span class="nc bnc" id="L3148" title="All 4 branches missed.">		if (publish &amp;&amp; publishByDateRange) {</span>
<span class="nc bnc" id="L3149" title="All 2 branches missed.">			for (; nRetry &lt; nMaxRetries; nRetry++) {</span>
				try {
<span class="nc" id="L3151">					Date startTime = publishDateRange.getStartDate();</span>
<span class="nc" id="L3152">					Date endTime = publishDateRange.getEndDate();</span>
<span class="nc" id="L3153">					m_cat.debug(&quot;publishing: empID, startTime, endTime: &quot; + toEmpID + ',' + startTime + ',' + endTime);</span>
<span class="nc" id="L3154">					sam.publishSchedule(Collections.singleton(toEmpID), startTime, endTime);</span>
<span class="nc" id="L3155">					break;</span>
<span class="nc" id="L3156">				} catch (Exception e) {</span>
<span class="nc" id="L3157">					m_cat.debug(&quot;Publish shift bid schedule failed&quot;, e);</span>
<span class="nc bnc" id="L3158" title="All 2 branches missed.">					if (nRetry &lt; nMaxRetries) {</span>
<span class="nc" id="L3159">						continue;</span>
					}
<span class="nc" id="L3161">					m_cat.info(&quot;Publish shift bid schedule failed after retrying &quot; + nRetry + &quot; times&quot;);</span>
<span class="nc" id="L3162">					throw e;</span>
				}
			}
		}

<span class="nc" id="L3167">		return createdShiftAssns;</span>
	}

	/**
	 * Solve conflict by stitching with gap activities
	 * @param conflicts - Collection of BbmScheduleConflict
	 * @param publishDateRange - Date range of SP conflicts exist in
	 * @param phantomIDs - Phantom IDs of shifts
	 * @return stitched shifts or empty list in case stitching not valid
	 * @throws Exception
	 */
	public static Collection&lt;ShiftAssignment&gt; solveConflicts(Collection&lt;BbmScheduleConflict&gt; conflicts,
			TimeRange publishDateRange, Collection&lt;ID&gt; phantomIDs, boolean allowOverlap) throws Exception{
<span class="nc" id="L3180">		Collection&lt;ShiftAssignment&gt; shifts = new ArrayList&lt;ShiftAssignment&gt;();</span>
<span class="nc" id="L3181">		BbmScheduleConflict conflict=null;</span>

<span class="nc bnc" id="L3183" title="All 2 branches missed.">		for (BbmScheduleConflict c : conflicts) {</span>
<span class="nc bnc" id="L3184" title="All 2 branches missed.">			if (c.getConflictType()!=BbmScheduleConflict.CONFLICT_OVERLAP_SHIFT &amp;&amp;</span>
<span class="nc bnc" id="L3185" title="All 2 branches missed.">					c.getConflictType()!=BbmScheduleConflict.CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY){</span>
				//Unknown conflict type.
<span class="nc" id="L3187">				conflict=null;</span>
<span class="nc" id="L3188">				break;</span>
			}
<span class="nc" id="L3190">			conflict=c;</span>
<span class="nc" id="L3191">		}</span>

<span class="nc bnc" id="L3193" title="All 2 branches missed.">		if (conflict!=null){</span>
			//Check if conflict is on gaps
<span class="nc" id="L3195">			ShiftAssignment first = (ShiftAssignment) conflict.getFirstObject();</span>
<span class="nc" id="L3196">			ShiftAssignment second = (ShiftAssignment) conflict.getSecondObject();</span>

			//What does this do? Why swap first and second if the first is a phantom shift?
			//Does this thing need the phantom shift to be the second shift? 
<span class="nc" id="L3200">			Set&lt;ID&gt; phantomIdSet = new HashSet&lt;ID&gt;(phantomIDs);</span>
<span class="nc bnc" id="L3201" title="All 2 branches missed.">			if (phantomIdSet.contains(first.getID())){</span>
<span class="nc" id="L3202">				ShiftAssignment swap = first;</span>
<span class="nc" id="L3203">				first = second;</span>
<span class="nc" id="L3204">				second = swap;</span>
			}

<span class="nc" id="L3207">			TimeMap firstTimeMap = buildTimeMap(Collections.singleton(first), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc" id="L3208">			TimeMap secondTimeMap = buildTimeMap(Collections.singleton(second), publishDateRange, TimeMap.ONE_MINUTE, false);</span>
<span class="nc bnc" id="L3209" title="All 4 branches missed.">			if(allowOverlap || !firstTimeMap.intersects(secondTimeMap)){</span>
				//No overlap excluding gaps. Start stitching.
<span class="nc" id="L3211">				shifts.add(stitchAssignments(firstTimeMap, secondTimeMap, first, second));</span>
			}
		}

<span class="nc" id="L3215">		return shifts;</span>
	}

	/**
	 * stitchAssignments - Take first and second shifts and stitch them together to return a single event in the shifts
	 * TimeMap is a Bit array. For example an array could look like this:
	 *   000000011111111111100000111111000000
	 *   To find the start and end of the shift, we search the first &quot;On&quot; and the last &quot;On&quot;
	 *   Then we create gaps for the &quot;Off&quot;'s which are in between.
	 * @param firstTimeMap - first TimeMap
	 * @param secondTimeMap - second TimeMap
	 * @param first - first shift
	 * @param shifts - second shift
	 * @return Stitched shift
	 */
	public static ShiftAssignment stitchAssignments(TimeMap firstTimeMap, TimeMap secondTimeMap,
			ShiftAssignment first, ShiftAssignment second)
		throws Exception{

		//First time map is now a merge of the two Shift Assignments
<span class="nc" id="L3235">		firstTimeMap.or(secondTimeMap);</span>
<span class="nc" id="L3236">		Date beforeOTDate=null;</span>
<span class="nc" id="L3237">		Date afterOTDate=null;</span>

		//Add non gap shift event assignments from second to the first
<span class="nc bnc" id="L3240" title="All 2 branches missed.">		for(ShiftEventAssignment g:second.getChildren()){</span>
<span class="nc bnc" id="L3241" title="All 2 branches missed.">			if(g.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)!=0){</span>
<span class="nc" id="L3242">				first.addShiftEventAssignment(g);</span>
			}
<span class="nc" id="L3244">		}</span>

		//Set start and end based on TimeMap
<span class="nc" id="L3247">		Date cur = firstTimeMap.findFirstOn();</span>
<span class="nc" id="L3248">		first.setStartTime(cur);</span>
<span class="nc" id="L3249">		cur=firstTimeMap.findLastOn();</span>
		//Add 1 minute to include the last &quot;On&quot; bit in the time map.
<span class="nc" id="L3251">		long duration = ((cur.getTime() + TimeMap.ONE_MINUTE) - first.getStartTime().getTime()) / 60000; // minutes</span>
<span class="nc" id="L3252">		first.setDuration((int)duration);</span>

		//Delete gaps from first
<span class="nc bnc" id="L3255" title="All 2 branches missed.">		for(ShiftEventAssignment g:first.getChildren()){</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">			if(g.getActivityID().compareTo(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)==0){</span>
<span class="nc" id="L3257">				first.removeShiftEventAssignment(g.getID());</span>

				//Remove gaps from overtime. They may be added back when stitching
<span class="nc bnc" id="L3260" title="All 2 branches missed.">				if(g.getOverTimeGapType()==1){</span>
<span class="nc" id="L3261">					first.setExtensionBefore(first.getExtensionBefore()-g.getDuration());</span>
<span class="nc" id="L3262">					beforeOTDate = new Date(first.getStartTime().getTime() + first.getExtensionBefore()*TimeMap.ONE_MINUTE);</span>
				}
<span class="nc bnc" id="L3264" title="All 2 branches missed.">				if(g.getOverTimeGapType()==2){</span>
<span class="nc" id="L3265">					first.setExtensionAfter(first.getExtensionAfter()-g.getDuration());</span>
<span class="nc" id="L3266">					afterOTDate = new Date(first.getEndTime().getTime() - first.getExtensionAfter()*TimeMap.ONE_MINUTE);</span>
				}
			}
<span class="nc" id="L3269">		}</span>

		//Fill gaps in between shifts
<span class="nc" id="L3272">		Date endDate = first.getEndTime();</span>
<span class="nc" id="L3273">		cur=first.getStartTime();</span>
<span class="nc" id="L3274">		ShiftEventAssignment gapSEA = null;</span>
<span class="nc bnc" id="L3275" title="All 2 branches missed.">		while(cur.before(endDate)){</span>
			//cur is the first gap date
<span class="nc" id="L3277">			cur = firstTimeMap.findNextOff(cur);</span>
<span class="nc bnc" id="L3278" title="All 4 branches missed.">			if (cur.equals(endDate) || cur.after(endDate)){</span>
<span class="nc" id="L3279">				break;</span>
			}
			//endGap is the end time of the gap
<span class="nc" id="L3282">			Date endGap = firstTimeMap.findNextOn(cur);</span>
<span class="nc" id="L3283">			duration = (endGap.getTime() - cur.getTime()) / 60000; // minutes</span>
			//Create the gap and add it to the shift
<span class="nc" id="L3285">			gapSEA = createSEAFromParams(cur, Activity.ACTIVITY_SHIFT_OVERTIME_GAP,</span>
<span class="nc" id="L3286">					(int) duration, first.getWorkResourceID());</span>
<span class="nc bnc" id="L3287" title="All 4 branches missed.">			if(beforeOTDate!=null &amp;&amp; cur.equals(beforeOTDate)){</span>
				//Handle first gap. Add extention if needed
<span class="nc" id="L3289">				gapSEA.setOverTimeGapType((short)1);</span>
<span class="nc" id="L3290">				first.setExtensionBefore(first.getExtensionBefore()+(int)duration);</span>
<span class="nc" id="L3291">				beforeOTDate=null;</span>
			}
<span class="nc" id="L3293">			first.addShiftEventAssignment(gapSEA);</span>
<span class="nc" id="L3294">			cur = endGap;</span>
<span class="nc" id="L3295">		}</span>
		//Handle last gap
<span class="nc bnc" id="L3297" title="All 6 branches missed.">		if(gapSEA!=null &amp;&amp; afterOTDate!=null &amp;&amp; gapSEA.getEndTime().equals(afterOTDate)){</span>
<span class="nc" id="L3298">			gapSEA.setOverTimeGapType((short)2);</span>
<span class="nc" id="L3299">			first.setExtensionAfter(first.getExtensionAfter()+gapSEA.getDuration());</span>
		}

<span class="nc bnc" id="L3302" title="All 2 branches missed.">		if (first.getID() == null) {</span>
<span class="nc" id="L3303">			first.setID(second.getID());</span>
		}

<span class="nc" id="L3306">		return first;</span>
	}

	/**
	 * Create a Shift Event Assignment activity
	 * @param start - Start time
	 * @param activityID
	 * @param duration
	 * @param workResourceID
	 * @return
	 */
	public static ShiftEventAssignment createSEAFromParams(Date start, ID activityID, int duration,
			ID workResourceID) {
<span class="nc" id="L3319">		ShiftEventAssignment sea = new ShiftEventAssignment();</span>
<span class="nc" id="L3320">		sea.setActivityID(activityID);</span>
<span class="nc" id="L3321">		sea.setStartTime(start);</span>
<span class="nc" id="L3322">		sea.setDuration(duration);</span>
<span class="nc" id="L3323">		sea.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L3324">		return sea;</span>
	}

	public static void replaceEmployeeIDForShiftAssignments(Collection&lt;ShiftAssignment&gt; shiftAssignments, ID empID) {
<span class="nc bnc" id="L3328" title="All 2 branches missed.">		for (ShiftAssignment shift : shiftAssignments) {</span>
<span class="nc" id="L3329">			shift.addWorkResourceID(empID);</span>

			// get shift event assignments for this shift assignment
<span class="nc" id="L3332">			Collection&lt;ShiftEventAssignment&gt; shiftEventAssns = shift.getChildren();</span>
			// remove the shift event assignment children for this shift
			// assignment.
<span class="nc" id="L3335">			shift.clearChildObjectMap(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc bnc" id="L3336" title="All 2 branches missed.">			for (ShiftEventAssignment shiftEvent : shiftEventAssns) {</span>
<span class="nc" id="L3337">				shiftEvent.addWorkResourceID(empID);</span>
				// add shift event to shift as a child to be created.
<span class="nc" id="L3339">				shift.addShiftEventAssignment(shiftEvent);</span>
<span class="nc" id="L3340">			}</span>
<span class="nc" id="L3341">		}</span>
<span class="nc" id="L3342">	}</span>




	
	private static void fillGapsFromTimeMap(ShiftAssignment shift, TimeMap sourceTimeMap) {

<span class="nc" id="L3350">		Date endDate = shift.getEndTime();</span>
<span class="nc" id="L3351">		Date cur = shift.getStartTime();</span>
<span class="nc bnc" id="L3352" title="All 2 branches missed.">		while (cur.before(endDate)) {</span>
			// cur is the first gap date
<span class="nc" id="L3354">			cur = sourceTimeMap.findNextOff(cur);</span>
<span class="nc bnc" id="L3355" title="All 4 branches missed.">			if (cur.equals(endDate) || cur.after(endDate)) {</span>
<span class="nc" id="L3356">				break;</span>
			}
			// endGap is the end time of the gap
<span class="nc" id="L3359">			Date endGap = sourceTimeMap.findNextOn(cur);</span>
<span class="nc" id="L3360">			long duration = (endGap.getTime() - cur.getTime()) / 60000; // minutes</span>
			// Create the gap and add it to the shift
<span class="nc" id="L3362">			ShiftEventAssignment gapSEA = createSEAFromParams(cur, Activity.ACTIVITY_SHIFT_OVERTIME_GAP, (int) duration,</span>
<span class="nc" id="L3363">					shift.getWorkResourceID());</span>
<span class="nc" id="L3364">			shift.addShiftEventAssignment(gapSEA);</span>
<span class="nc" id="L3365">			cur = endGap;</span>
<span class="nc" id="L3366">		}</span>
<span class="nc" id="L3367">	}</span>

	private static ShiftAssignment createCustomShiftAssignment(TimeRange newShiftTimeRange,
			ShiftAssignment sourceShift) {
<span class="nc" id="L3371">		ShiftAssignment shift = new ShiftAssignment();</span>
<span class="nc" id="L3372">		shift.setStartTime(newShiftTimeRange.getStartDate());</span>
<span class="nc" id="L3373">		shift.setDuration((int) newShiftTimeRange.getDurationMin());</span>
<span class="nc" id="L3374">		shift.setLocked(false);</span>
		//Set SPID
<span class="nc" id="L3376">		shift.setActivityID(sourceShift.getActivityID());</span>
<span class="nc" id="L3377">		shift.setShiftID(sourceShift.getShiftID());</span>
<span class="nc" id="L3378">		shift.addWorkResourceID(sourceShift.getWorkResourceID());</span>
<span class="nc" id="L3379">		shift.setCampaignID(sourceShift.getCampaignID());</span>
<span class="nc" id="L3380">		shift.setOverlayPrecedence(sourceShift.getOverlayPrecedence());</span>
<span class="nc" id="L3381">		shift.setWorkPatternID(sourceShift.getWorkPatternID());</span>
<span class="nc" id="L3382">		shift.setDescription(sourceShift.getDescription());</span>

		// move non phantom shift events to the new shift
<span class="nc bnc" id="L3385" title="All 2 branches missed.">		for (ShiftEventAssignment event : sourceShift.getChildren()) {</span>
<span class="nc bnc" id="L3386" title="All 2 branches missed.">			if (!event.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc" id="L3387">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L3388" title="All 4 branches missed.">				if (eventRange.equals(newShiftTimeRange) || eventRange.getOverlapDuration(newShiftTimeRange) &gt; 0) {</span>
<span class="nc" id="L3389">					event.setParentID(null);</span>
<span class="nc" id="L3390">					shift.addShiftEventAssignment(event);</span>
				}
			}
<span class="nc" id="L3393">		}</span>

<span class="nc" id="L3395">		return shift;</span>
	}

	/**
	 * Computes the total length of the given shift assignments taking into
	 * account paid/unpaid shift event assignments associated with the shift
	 * assignments. The returned length is in minutes.
	 *
	 * @param shiftAssns
	 * @return
	 */
	public static int computePaidShiftLength(ShiftAssignment shiftAssn) {
<span class="nc" id="L3407">		int totalMinutes = 0;</span>
<span class="nc bnc" id="L3408" title="All 2 branches missed.">		if (shiftAssn.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
			// compute the duration for the shift assignment
<span class="nc" id="L3410">			totalMinutes += shiftAssn.getDuration();</span>
<span class="nc" id="L3411">			Collection&lt;ShiftEventAssignment&gt; shiftEventAssns = shiftAssn.getChildren();</span>
<span class="nc bnc" id="L3412" title="All 2 branches missed.">			for (Event shiftEventAssn : shiftEventAssns) {</span>
<span class="nc bnc" id="L3413" title="All 2 branches missed.">				if (!shiftEventAssn.getPaid()) {</span>
<span class="nc" id="L3414">					totalMinutes -= shiftEventAssn.getDuration();</span>
				}
<span class="nc" id="L3416">			}</span>
		}

<span class="nc" id="L3419">		return totalMinutes;</span>
	}

	/**
	 * Computes the total length of the given shift assignments taking into
	 * account paid/unpaid shift event assignments associated with the shift
	 * assignments. The returned length is in minutes.
	 *
	 * @param shiftAssns
	 * @return
	 */
	public static int computeScheduleLength(Collection&lt;ShiftAssignment&gt; shiftAssns) {
<span class="nc" id="L3431">		int totalMinutes = 0;</span>
<span class="nc bnc" id="L3432" title="All 2 branches missed.">		for (ShiftAssignment shiftAssn : shiftAssns) {</span>
<span class="nc" id="L3433">			totalMinutes += computePaidShiftLength(shiftAssn);</span>
<span class="nc" id="L3434">		}</span>

<span class="nc" id="L3436">		return totalMinutes;</span>
	}

	/**
	 * Note: This method may return a 'null' value.
	 *
	 * Return the proper {@link WorkResourceMinMaxHour WorkResourceMinMaxHour}
	 * element from the given collection for the specified time range. The
	 * chosen minMax assignment is the one with an effectivity which overlaps
	 * the given time range.
	 *
	 * @param minMaxAssns
	 * @param startTime
	 * @param endTime
	 * @return
	 */
	public static WorkResourceMinMaxHour getMinMaxHourAssnOverlappingTimeRange(Collection minMaxAssns, Date startTime,
			Date endTime) {

		// If a campaign(SP) override for min/max hours exists for this
		// employee, then
		// this override must be used. It seems
		// the returned elements in the collection are sorted by the start-time
		// of the
		// min/max hour assignment's effectivity period. Here is an example of a
		// returned collection:
		// starttime, endtime == null, SPStartTime.
		// starttime, endtime == SPStartTime, SPEndTime
		// starttime, endTime == SPEndTime, null.
<span class="nc" id="L3465">		long maxOverlap = 0;</span>
<span class="nc" id="L3466">		WorkResourceMinMaxHour wrMinMaxHourWithMaxOverlap = null;</span>
<span class="nc bnc" id="L3467" title="All 2 branches missed.">		for (Iterator iter = minMaxAssns.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3468">			WorkResourceMinMaxHour wrMinMaxHour = (WorkResourceMinMaxHour) iter.next();</span>

			// if strt time == null, adjust.
<span class="nc bnc" id="L3471" title="All 2 branches missed.">			if (wrMinMaxHour.getStartTime() == null) {</span>
<span class="nc" id="L3472">				wrMinMaxHour.setStartTime(new Date(0));</span>
			}

			// if end time == null, adjust
<span class="nc bnc" id="L3476" title="All 2 branches missed.">			if (wrMinMaxHour.getEndTime() == null) {</span>
<span class="nc" id="L3477">				wrMinMaxHour.setEndTime(new Date(Long.MAX_VALUE));</span>
			}

<span class="nc" id="L3480">			long overlapMs = RequestUtil.getOverlapLength(wrMinMaxHour.getStartTime(), wrMinMaxHour.getEndTime(),</span>
					startTime, endTime);

<span class="nc bnc" id="L3483" title="All 2 branches missed.">			if (overlapMs &gt; maxOverlap) {</span>
<span class="nc" id="L3484">				maxOverlap = overlapMs;</span>
<span class="nc" id="L3485">				wrMinMaxHourWithMaxOverlap = wrMinMaxHour;</span>
			}
<span class="nc" id="L3487">		}</span>

<span class="nc" id="L3489">		return wrMinMaxHourWithMaxOverlap;</span>
	}

	/**
	 * @param msg
	 * @return
	 * @throws Exception
	 */
	public static Element createXMLDoc(DocumentBuilder docBuilder, String rootElementName) throws Exception {
<span class="nc" id="L3498">		Document doc = docBuilder.newDocument();</span>

<span class="nc" id="L3500">		Element rootElement = doc.createElement(rootElementName);</span>
<span class="nc" id="L3501">		doc.appendChild(rootElement);</span>

		// Text textNode = doc.createTextNode(msg);
		// rootElement.appendChild(textNode);

<span class="nc" id="L3506">		return rootElement;</span>
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text) {

<span class="nc" id="L3520">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, (String[]) null, null);</span>
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrName1
	 * @param attrValue1
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String attrName1, String attrValue1) {

<span class="nc" id="L3537">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, new String[] { attrName1 },</span>
				new String[] { attrValue1 });
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrName1
	 * @param attrValue1
	 * @param attrName2
	 * @param attrValue2
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String attrName1, String attrValue1, String attrName2, String attrValue2) {

<span class="nc" id="L3557">		return createElemAndAppendAsChild(parentElem, doc, elemName, text, new String[] { attrName1, attrName2 },</span>
				new String[] { attrValue1, attrValue2 });
	}

	/**
	 * Either doc or parentElem must be non-null
	 *
	 * @param parentElem
	 * @param doc
	 * @param elemName
	 * @param text
	 * @param attrNames
	 * @param attrValues
	 * @return
	 */
	public static Element createElemAndAppendAsChild(Element parentElem, Document doc, String elemName, String text,
			String[] attrNames, String[] attrValues) {

		// get the owning document
<span class="nc bnc" id="L3576" title="All 2 branches missed.">		Document ownerDoc = (parentElem != null) ? parentElem.getOwnerDocument() : doc;</span>
		// create the child element
<span class="nc" id="L3578">		Element elem = ownerDoc.createElement(elemName);</span>

		// attach the child element to parent
<span class="nc bnc" id="L3581" title="All 2 branches missed.">		if (parentElem != null) {</span>
<span class="nc" id="L3582">			parentElem.appendChild(elem);</span>
		}

		// create the attributes
<span class="nc bnc" id="L3586" title="All 4 branches missed.">		for (int i = 0; attrNames != null &amp;&amp; i &lt; attrValues.length; i++) {</span>
<span class="nc" id="L3587">			createAndAppendAttr(elem, attrNames[i], attrValues[i]);</span>
		}

		// attach text node as child
<span class="nc bnc" id="L3591" title="All 2 branches missed.">		if (text != null) {</span>
<span class="nc" id="L3592">			Text textNode = ownerDoc.createTextNode(text);</span>
<span class="nc" id="L3593">			elem.appendChild(textNode);</span>
		}

<span class="nc" id="L3596">		return elem;</span>
	}

	public static void createAndAppendAttr(Element elem, String attrName, String attrValue) {
<span class="nc" id="L3600">		elem.setAttribute(attrName, attrValue);</span>
<span class="nc" id="L3601">	}</span>

	/**
	 * Either the element or the document must be specified and not both.
	 * Converts the XML DOM tree to a serialized string.
	 *
	 * @param element
	 * @param doc
	 * @return
	 * @throws Exception
	 */
	public static String getXMLStringForElemOrDoc(Element element, Document doc) throws Exception {
		// serialize the DOM tree to a string
<span class="nc" id="L3614">		StringWriter writer = new StringWriter();</span>

<span class="nc" id="L3616">		OutputFormat format = new OutputFormat();</span>
<span class="nc" id="L3617">		format.setPreserveSpace(true);</span>

<span class="nc" id="L3619">		XMLSerializer serializer = new XMLSerializer(writer, format);</span>
<span class="nc bnc" id="L3620" title="All 2 branches missed.">		if (element != null) {</span>
<span class="nc" id="L3621">			serializer.serialize(element);</span>
		} else {
<span class="nc" id="L3623">			serializer.serialize(doc);</span>
		}

<span class="nc" id="L3626">		writer.flush();</span>

<span class="nc" id="L3628">		String msgXML = writer.toString();</span>
<span class="nc" id="L3629">		writer.close();</span>

<span class="nc" id="L3631">		return msgXML;</span>
	}

	public static Activity getActivityByID(ID activityID)
			throws BbmEJBCreateException, BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L3636">		ActivityManager actMgr = getActivityManager();</span>

<span class="nc" id="L3638">		return actMgr.findActivityById(activityID);</span>
	}

	public static String getActivityNameByID(ID actID)
			throws BbmObjectNotFoundException, BbmEJBCreateException, BbmFinderException, RemoteException {
<span class="nc" id="L3643">		Activity act = getActivityByID(actID);</span>

<span class="nc" id="L3645">		return act.getName();</span>
	}

	/**
	 * @param collec1
	 * @param collec2
	 * @return a three element collections array.
	 *         &lt;li&gt;First collection in array contains elements in first set but
	 *         not in the second.
	 *         &lt;li&gt;Second collection in array contains the common elements.
	 *         &lt;li&gt;Third collection in array contains elements in second but not
	 *         in first.
	 */
	public static Collection[] diffObjectLists(Collection collec1, Collection collec2) {

<span class="nc bnc" id="L3660" title="All 4 branches missed.">		if (collec1 == null || collec2 == null) {</span>
<span class="nc" id="L3661">			return new Collection[] {};</span>
		}

<span class="nc" id="L3664">		Collection commonElems = new ArrayList(collec1.size());</span>

<span class="nc" id="L3666">		Set set1 = new HashSet(collec1);</span>
<span class="nc" id="L3667">		Set set2 = new HashSet(collec2);</span>

		// iterate thru obj1Set elements
<span class="nc bnc" id="L3670" title="All 2 branches missed.">		for (Iterator set1Iter = set1.iterator(); set1Iter.hasNext();) {</span>
<span class="nc" id="L3671">			Object set1Elem = set1Iter.next();</span>

			// attempt to remove obj1Elem from obj2Set
<span class="nc" id="L3674">			boolean removed = set2.remove(set1Elem);</span>
			// if element found in obj2Set
<span class="nc bnc" id="L3676" title="All 2 branches missed.">			if (removed) {</span>
				// add to commonSet
<span class="nc" id="L3678">				commonElems.add(set1Elem);</span>

				// remove from obj1Set
<span class="nc" id="L3681">				set1Iter.remove();</span>
			}
<span class="nc" id="L3683">		}</span>

		// At this point obj1Set contains elements not in obj2Set and vice
		// versa.
<span class="nc" id="L3687">		return new Collection[] { set1, commonElems, set2 };</span>
	}

	/**
	 * Order the given list of VOBases according to the given collection of
	 * voBaseIDs.
	 * &lt;p&gt;
	 * &lt;b&gt;Note:&lt;/b&gt; This method modifies the passed voBaseList argument.
	 *
	 * @param shiftBidderIDs
	 * @param list
	 * @return
	 */
	public static &lt;T extends ValueObjectBase&gt; List&lt;T&gt; orderVOsByGivenIDs(Collection&lt;ID&gt; voBaseIDs, List&lt;T&gt; voBaseList) {
		// convert the voBaseList to a map.
<span class="nc" id="L3702">		Map&lt;ID, T&gt; idToVOBaseMap = getMapOfIDsForVOBases(voBaseList);</span>

<span class="nc" id="L3704">		int i = 0;</span>
<span class="nc bnc" id="L3705" title="All 2 branches missed.">		for (Iterator iter = voBaseIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3706">			Object voBaseID = iter.next();</span>

<span class="nc" id="L3708">			T voBase = idToVOBaseMap.get(voBaseID);</span>
<span class="nc bnc" id="L3709" title="All 2 branches missed.">			if (voBase != null) {</span>
<span class="nc" id="L3710">				voBaseList.set(i++, voBase);</span>
			}
<span class="nc" id="L3712">		}</span>

<span class="nc" id="L3714">		return voBaseList;</span>
	}

	public static void resetRMDebugEnabled() {
<span class="nc" id="L3718">		isWaitListRankOnRqPageDisabled = null;</span>
<span class="nc" id="L3719">		rmDebugEnabled = null;</span>
<span class="nc" id="L3720">	}</span>

	public static void setIsRmDebugEnabled(boolean enabled) {
<span class="nc" id="L3723">		rmDebugEnabled = enabled;</span>
<span class="nc" id="L3724">	}</span>

	public static boolean isRMDebugEnabled() {
		try {
<span class="nc bnc" id="L3728" title="All 2 branches missed.">			if (rmDebugEnabled == null) {</span>
<span class="nc" id="L3729">				rmDebugEnabled = &quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.RM_DEBUG_ENABLED));</span>
			}
<span class="nc" id="L3731">		} catch (Exception e) {</span>
<span class="nc" id="L3732">			m_cat.error(e);</span>
<span class="nc" id="L3733">		}</span>
<span class="nc bnc" id="L3734" title="All 2 branches missed.">		return rmDebugEnabled != null ? rmDebugEnabled.booleanValue() : false;</span>
	}

<span class="nc" id="L3737">	private static Boolean isWaitListRankOnRqPageDisabled = null;</span>

	public static boolean isWaitListRankOnRqPageDisabled() {
		try {
<span class="nc bnc" id="L3741" title="All 2 branches missed.">			if (isWaitListRankOnRqPageDisabled == null) {</span>
<span class="nc" id="L3742">				isWaitListRankOnRqPageDisabled = new Boolean(&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager()</span>
<span class="nc" id="L3743">						.getValue(ConfigKey.RM_WAITLIST_RANK_ON_RQ_PAGE_DISABLED)));</span>
			}
<span class="nc" id="L3745">		} catch (Exception e) {</span>
<span class="nc" id="L3746">			m_cat.error(e);</span>
<span class="nc" id="L3747">		}</span>
<span class="nc bnc" id="L3748" title="All 2 branches missed.">		return isWaitListRankOnRqPageDisabled != null ? isWaitListRankOnRqPageDisabled.booleanValue() : false; </span>
	}

	public static boolean isTOAllocationCalendarAuditEnabled() {
<span class="nc" id="L3752">		boolean returnVal = false;</span>
		try {
<span class="nc" id="L3754">			returnVal = (&quot;true&quot;.equals(</span>
<span class="nc" id="L3755">					BbmManagerFactory.getDBConfigManager().getValue(ConfigKey.TO_ALLOCATION_CALENDAR_AUDIT_ENABLED)));</span>
<span class="nc" id="L3756">		} catch (Exception e) {</span>
<span class="nc" id="L3757">			m_cat.error(e);</span>
<span class="nc" id="L3758">		}</span>
<span class="nc" id="L3759">		return returnVal;</span>
	}

<span class="nc" id="L3762">	private static Boolean isNetStaffingUpdateForTOMDisabled = null;</span>

	public static boolean isNetStaffingUpdateForTOMDisabled() {
		try {
<span class="nc bnc" id="L3766" title="All 2 branches missed.">			if (isNetStaffingUpdateForTOMDisabled == null) {</span>
<span class="nc" id="L3767">				isNetStaffingUpdateForTOMDisabled = new Boolean(&quot;true&quot;.equals(BbmManagerFactory.getDBConfigManager()</span>
<span class="nc" id="L3768">						.getValue(ConfigKey.NETSTAFFING_UPDATE_FOR_TOM_DISABLED)));</span>
			}
<span class="nc" id="L3770">		} catch (Exception e) {</span>
<span class="nc" id="L3771">			m_cat.error(e);</span>
<span class="nc" id="L3772">		}</span>
<span class="nc bnc" id="L3773" title="All 2 branches missed.">		return isNetStaffingUpdateForTOMDisabled != null ? isNetStaffingUpdateForTOMDisabled.booleanValue() : false;</span>
	}

	/**
	 * Make Shift Dates as Strings
	 *
	 * @param dayRange
	 *            - Date Range for Day
	 * @param sDate
	 *            - Start of Shift
	 * @param eDate
	 *            - End of Shift
	 * @param localizer
	 *            - Localizer
	 * @param tz
	 *            - TimeZone
	 */
	public static String makeShiftDatesString(CalendarRange dayRange, Date sDate, Date eDate, Localizer localizer,
			TimeZone tz) {
<span class="nc" id="L3792">		StringBuffer sb = new StringBuffer(100);</span>

		// --- start label ----
<span class="nc bnc" id="L3795" title="All 4 branches missed.">		if (dayRange != null &amp;&amp; dayRange.includes(sDate)) { // make time string</span>
<span class="nc" id="L3796">			sb.append(localizer.formatDate(sDate, tz, RegionalFormatBundleKey.TIME_FORMAT));</span>
		} else { // make date+time string
<span class="nc" id="L3798">			sb.append(localizer.formatDateTime(sDate, tz));</span>
		}

		// --- middle dash ---
<span class="nc" id="L3802">		sb.append(&quot; - &quot;);</span>

		// --- end label ---
<span class="nc bnc" id="L3805" title="All 4 branches missed.">		if (dayRange != null &amp;&amp; dayRange.includes(eDate)) { // make time string</span>
<span class="nc" id="L3806">			sb.append(localizer.formatDate(eDate, tz, RegionalFormatBundleKey.TIME_FORMAT));</span>
		} else { // make date+time string
<span class="nc" id="L3808">			sb.append(localizer.formatDateTime(eDate, tz));</span>
		}

<span class="nc" id="L3811">		return sb.toString();</span>
	}

	/**
	 * Get the display start time of a ShiftAssignment.
	 * &lt;P&gt;
	 *
	 * @return Date - event start time
	 */
	public static Date getDisplayStartTime(ShiftAssignment sa) {
<span class="nc" id="L3821">		Date startTime = sa.getFieldValueDate(ShiftAssignmentFields.STARTTIME);</span>

		// Hack to treat initial NO_ACTIVITY events as not part of the shift
<span class="nc" id="L3824">		Collection shiftEventAssignments = sa.getChildren();</span>
<span class="nc bnc" id="L3825" title="All 4 branches missed.">		if (shiftEventAssignments != null &amp;&amp; !shiftEventAssignments.isEmpty()) {</span>
<span class="nc" id="L3826">			Iterator it = shiftEventAssignments.iterator();</span>
<span class="nc bnc" id="L3827" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L3828">				ShiftEventAssignment sea = (ShiftEventAssignment) it.next();</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">				if (sea.getActivityID().toInt() == Activity.NO_ACTIVITY</span>
<span class="nc bnc" id="L3830" title="All 2 branches missed.">						&amp;&amp; sea.getStartTime().equals(sa.getStartTime())) {</span>
<span class="nc" id="L3831">					startTime = sea.getEndTime();</span>
<span class="nc" id="L3832">					break;</span>
				}
<span class="nc" id="L3834">			}</span>
		}
<span class="nc" id="L3836">		return startTime;</span>
	}

	public static Collection findShifts(CalendarRange dayRange, Collection shifts) {
<span class="nc" id="L3840">		Collection results = new ArrayList(2);</span>
<span class="nc bnc" id="L3841" title="All 4 branches missed.">		if (shifts == null || shifts.isEmpty()) {</span>
<span class="nc" id="L3842">			return results;</span>
		}

<span class="nc bnc" id="L3845" title="All 2 branches missed.">		for (Iterator it = shifts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L3846">			ShiftAssignment sa = (ShiftAssignment) it.next();</span>
<span class="nc bnc" id="L3847" title="All 2 branches missed.">			if (dayRange.includes(getDisplayStartTime(sa))) {</span>
<span class="nc" id="L3848">				results.add(sa);</span>
			}
<span class="nc" id="L3850">		}</span>
<span class="nc" id="L3851">		return results;</span>
	}

	public static Collection getEmpIdsInOrg(ID orgID, Date startDate, Date endDate, boolean inclChildOrgs)
			throws Exception {
<span class="nc" id="L3856">		Set orgIDSet = new HashSet();</span>
<span class="nc" id="L3857">		orgIDSet.add(orgID);</span>
<span class="nc" id="L3858">		Set empIdsSet = new HashSet();</span>
<span class="nc bnc" id="L3859" title="All 2 branches missed.">		if (inclChildOrgs) {</span>
<span class="nc" id="L3860">			orgIDSet.addAll(BbmManagerFactory.getWorkResourceManager()</span>
<span class="nc" id="L3861">					.getOrganizationsChildrenByIDs(Collections.singleton(orgID)));</span>
		}
<span class="nc bnc" id="L3863" title="All 2 branches missed.">		for (Iterator iterator = orgIDSet.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L3864">			ID orgIDVal = (ID) iterator.next();</span>
<span class="nc" id="L3865">			empIdsSet.addAll(</span>
<span class="nc" id="L3866">					ValueObjectUtil.getFieldObjectCol(WorkResourceAssignmentFieldInfo.WRASSIGNMENT_WORKRESOURCEID,</span>
<span class="nc" id="L3867">							CacheUtilBBM.getWorkResourceAssnForOrgID(orgIDVal, startDate, endDate)));</span>
<span class="nc" id="L3868">		}</span>
<span class="nc" id="L3869">		return empIdsSet;</span>
	}

	public static ValidationResult setValidationResult(ID empID, String empName, Validatable validatable,
			Collection results, String className) throws Exception {
<span class="nc" id="L3874">		ValidationResult result = null;</span>
<span class="nc bnc" id="L3875" title="All 4 branches missed.">		if (results != null &amp;&amp; !results.isEmpty()) {</span>
<span class="nc bnc" id="L3876" title="All 2 branches missed.">			for (Iterator itr = results.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L3877">				ShiftsConflict conflict = (ShiftsConflict) itr.next();</span>
<span class="nc" id="L3878">				conflict.setWorkResourceName(empName);</span>
				// todo: we lose validation errors if results has 2 or more
<span class="nc" id="L3880">				result = ValidationUtil.setSoftValidationResult(validatable, RmEjbBundleKey.NONLOCALIZED_MESSAGE,</span>
						conflict, className);
<span class="nc" id="L3882">			}</span>
		}
<span class="nc" id="L3884">		return result;</span>
	}

	/**
	 * Get a filing rule's interval count and unit, based on request type (since
	 * Flex Time requests allow minutes)
	 *
	 * @param iIntervalCount
	 *            - interval count for the filing rule
	 * @param isFlex
	 *            - is this a Flex Time filing rule?
	 * @return a pair of Strings, where the key is the interval count, and the
	 *         value is the units string (days/hours/minutes).
	 */
	public static StringsPair getIntervalCountAndUnit(int iIntervalCount, boolean isFlexTime) {
		// Note: It seems like originally, we only stored days in the
		// REQUESTFILINGRULE.INTERVALDAYS field. Then
		// we started storing hours instead. But for Flex Time (FT), we need to
		// store minutes instead of hours.
		String intervalUnit;
<span class="nc bnc" id="L3904" title="All 2 branches missed.">		if (isFlexTime) {</span>
			// iInterval for Flex Time request filing rules stores the number of
			// minutes, regardless of the unit
<span class="nc bnc" id="L3907" title="All 2 branches missed.">			if (iIntervalCount % (24 * 60) == 0) {</span>
				// convert into days
<span class="nc" id="L3909">				iIntervalCount = iIntervalCount / (24 * 60);</span>
<span class="nc" id="L3910">				intervalUnit = DAYS;</span>
<span class="nc bnc" id="L3911" title="All 2 branches missed.">			} else if (iIntervalCount % 60 == 0) {</span>
				// convert into hours
<span class="nc" id="L3913">				iIntervalCount = iIntervalCount / 60;</span>
<span class="nc" id="L3914">				intervalUnit = HOURS;</span>
			} else {
				// no need to convert because it's already in minutes
<span class="nc" id="L3917">				intervalUnit = MINUTES;</span>
			}
		} else {
			// iInterval for all other request types stores the number of hours,
			// regardless of the unit
<span class="nc bnc" id="L3922" title="All 2 branches missed.">			if (iIntervalCount % 24 == 0) {</span>
				// convert into days
<span class="nc" id="L3924">				iIntervalCount = iIntervalCount / 24;</span>
<span class="nc" id="L3925">				intervalUnit = DAYS;</span>
			} else {
<span class="nc" id="L3927">				intervalUnit = HOURS;</span>
			}
		}
<span class="nc" id="L3930">		String intervalCount = Integer.toString(iIntervalCount);</span>
<span class="nc" id="L3931">		StringsPair intervalCountAndUnit = new StringsPair(intervalCount, intervalUnit);</span>
<span class="nc" id="L3932">		return intervalCountAndUnit;</span>
	}

	public static ActivityManager getActivityManager(boolean isInWhatIfMode) throws BbmException {
<span class="nc" id="L3936">		return WfmManagerFactory.getActivityManager(isInWhatIfMode);</span>
	}

	/**
	 * Get the subtypes string for a Time Off or Flex Time filing rule, which is
	 * displayed in the &quot;Request Type&quot; column of the filing rules list.
	 */
	public static String getTimeOffOrFlexTimeSubtypesString(boolean isInWhatIfMode, RequestFilingRule rule,
			ResourceBundle rmBundle, Localizer localizer, boolean isTimeOff)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException, BbmException {
		String subTypes;
		// Append TimeOff name
<span class="nc" id="L3948">		Activity activity = activity = getActivityManager(isInWhatIfMode).findActivityById(rule.getActivityId());</span>
<span class="nc bnc" id="L3949" title="All 2 branches missed.">		String timeoffName = activity == null ? &quot;&quot; : activity.getName();</span>

<span class="nc bnc" id="L3951" title="All 2 branches missed.">		if (isTimeOff) {</span>
<span class="nc" id="L3952">			subTypes = timeoffName;</span>
		} else {
<span class="nc bnc" id="L3954" title="All 2 branches missed.">			String beforeAfterKey = rule.getRequestSubType() == RequestFilingRule.REQUEST_SUB_TYPE_TIMEOFF_BEFORE_MAKEUP</span>
					? RmEjbBundleKey.ORG_RM_FILING_RULE_TIMEOFF_BEFORE_MAKEUP
					: RmEjbBundleKey.ORG_RM_FILING_RULE_TIMEOFF_AFTER_MAKEUP;
<span class="nc" id="L3957">			String beforeOrAfter = localizer.i18n(rmBundle, beforeAfterKey);</span>
<span class="nc" id="L3958">			subTypes = timeoffName + &quot;, &quot; + beforeOrAfter;</span>
		}
<span class="nc" id="L3960">		return subTypes;</span>
	}

	/**
	 * Get the subtypes string for a Shift Request filing rule, which is
	 * displayed in the &quot;Request Type&quot; column of the filing rules list.
	 */
	public static String getCustomShiftSubtypesString(RequestFilingRule rule, ResourceBundle rmBundle,
			Localizer localizer) {
<span class="nc" id="L3969">		String subTypes = &quot;&quot;;</span>
<span class="nc" id="L3970">		boolean foundOne = false;</span>
<span class="nc" id="L3971">		String comma = localizer.i18n(rmBundle, RmEjbBundleKey.COMMA_DELIMITER);</span>

<span class="nc bnc" id="L3973" title="All 2 branches missed.">		if (rule.getRequestSubTypeRegNewShift()) {</span>
<span class="nc" id="L3974">			subTypes = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_REG_NEW_SHIFT);</span>
<span class="nc" id="L3975">			foundOne = true;</span>
		}
<span class="nc bnc" id="L3977" title="All 2 branches missed.">		if (rule.getRequestSubTypeRegShiftChange()) {</span>
<span class="nc bnc" id="L3978" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L3979">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_REG_SHIFT_CHANGE);</span>
<span class="nc" id="L3980">			foundOne = true;</span>
		}
<span class="nc bnc" id="L3982" title="All 2 branches missed.">		if (rule.getRequestSubTypeOTNewShift()) {</span>
<span class="nc bnc" id="L3983" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L3984">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_OT_NEW_SHIFT);</span>
<span class="nc" id="L3985">			foundOne = true;</span>
		}
<span class="nc bnc" id="L3987" title="All 2 branches missed.">		if (rule.getRequestSubTypeOTShiftChange()) {</span>
<span class="nc bnc" id="L3988" title="All 2 branches missed.">			subTypes += (foundOne ? comma + &quot; &quot; : &quot;&quot;)</span>
<span class="nc" id="L3989">					+ localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_OT_SHIFT_CHANGE);</span>
		}
<span class="nc" id="L3991">		return subTypes;</span>
	}

	public static String getAllDaysLabel(ResourceBundle rmBundle, Localizer localizer) {
<span class="nc" id="L3995">		return localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_ALL_REQUESTS_LABEL);</span>
	}

	public static Collection getDayTypeList(ResourceBundle rmBundle, Localizer localizer) {
<span class="nc" id="L3999">		Collection dayTypeList = new ArrayList(7);</span>
<span class="nc" id="L4000">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4002">		dayTypeList.add(new StringsPair(&quot;weekend&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.WEEKEND)));</span>
<span class="nc" id="L4003">		dayTypeList.add(new StringsPair(&quot;sunday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.SUNDAY)));</span>
<span class="nc" id="L4004">		dayTypeList.add(new StringsPair(&quot;monday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.MONDAY)));</span>
<span class="nc" id="L4005">		dayTypeList.add(new StringsPair(&quot;tuesday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.TUESDAY)));</span>
<span class="nc" id="L4006">		dayTypeList.add(new StringsPair(&quot;wednesday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.WEDNESDAY)));</span>
<span class="nc" id="L4007">		dayTypeList.add(new StringsPair(&quot;thursday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.THURSDAY)));</span>
<span class="nc" id="L4008">		dayTypeList.add(new StringsPair(&quot;friday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.FRIDAY)));</span>
<span class="nc" id="L4009">		dayTypeList.add(new StringsPair(&quot;saturday&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.SATURDAY)));</span>

<span class="nc" id="L4011">		dayTypeList.add(new StringsPair(&quot;workingholiday&quot;,</span>
<span class="nc" id="L4012">				localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_SETTINGS_TO_WORKING_LABEL)));</span>

<span class="nc" id="L4014">		return dayTypeList;</span>
	}

	/**
	 * Get the date range data part of the description for a filing rule.
	 */
	public static String getDateRangeData(Localizer localizer, RequestFilingRule rule, ResourceBundle rmBundle,
			TimeZone tz) {
<span class="nc" id="L4022">		String dayRange = rule.getDayRange();</span>
<span class="nc" id="L4023">		String dataToAdd = null;</span>
<span class="nc bnc" id="L4024" title="All 4 branches missed.">		if (dayRange == null || dayRange.equals(DAYRANGE_ALL_DAYS)) {</span>
<span class="nc" id="L4025">			dataToAdd = getAllDaysLabel(rmBundle, localizer);</span>
<span class="nc bnc" id="L4026" title="All 2 branches missed.">		} else if (dayRange.equals(DAYRANGE_DAY_TYPE)) {</span>
<span class="nc" id="L4027">			String dayType = rule.getDayType();</span>
<span class="nc" id="L4028">			Collection dTypeList = getDayTypeList(rmBundle, localizer);</span>
<span class="nc" id="L4029">			Object args[] = new Object[] { getSelectLabel(dayType, dTypeList) };</span>
<span class="nc" id="L4030">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_FOR_DAYS_LABEL, args);</span>
<span class="nc bnc" id="L4031" title="All 2 branches missed.">		} else if (dayRange.equals(DAYRANGE_DATES)) {</span>
<span class="nc" id="L4032">			String strFromDate = localizer.formatDateTime(rule.getStartDate(), tz);</span>
<span class="nc" id="L4033">			String strToDate = localizer.formatDateTime(rule.getEndDate(), tz);</span>
<span class="nc" id="L4034">			Object args[] = new Object[] { strFromDate, strToDate };</span>
<span class="nc" id="L4035">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_FROM_TO_DATE, args);</span>
		}
<span class="nc" id="L4037">		return dataToAdd;</span>
	}

	/**
	 * Get the date &quot;file by&quot; part of the description for a filing rule.
	 */
	public static String getFileByData(RequestFilingRule rule, ResourceBundle rmBundle, Localizer localizer,
			TimeZone tz) {
<span class="nc" id="L4045">		String dataToAdd = null;</span>
<span class="nc" id="L4046">		String timeType = rule.getTimeType();</span>
<span class="nc bnc" id="L4047" title="All 4 branches missed.">		if (timeType == null || timeType.equals(TIMETYPE_BYDATE)) {</span>
<span class="nc" id="L4048">			String dateCompar = rule.getDateComparision();</span>
<span class="nc bnc" id="L4049" title="All 2 branches missed.">			if (StringUtil.isEmpty(dateCompar)) {</span>
<span class="nc" id="L4050">				dateCompar = DATECOMPARISION_ON_DATE;</span>
			}
<span class="nc" id="L4052">			Collection dateCList = getDateComparisonList(localizer);</span>
<span class="nc" id="L4053">			String selectLabel = getSelectLabel(dateCompar, dateCList);</span>
<span class="nc" id="L4054">			String strByDate = localizer.formatDateTime(rule.getFileByDate(), tz);</span>
<span class="nc" id="L4055">			Object args[] = new Object[] { selectLabel, strByDate };</span>
<span class="nc" id="L4056">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_SB_ON_BEFORE_AFTER, args);</span>

<span class="nc bnc" id="L4058" title="All 2 branches missed.">		} else if (timeType.equals(TIMETYPE_INTERVAL)) {</span>
<span class="nc" id="L4059">			String intervalType = rule.getIntervalType();</span>
<span class="nc bnc" id="L4060" title="All 2 branches missed.">			if (StringUtil.isEmpty(intervalType)) {</span>
<span class="nc" id="L4061">				intervalType = INTERVALTYPE_LESSTHAN;</span>
			}

<span class="nc" id="L4064">			Collection iTypeList = getIntervalTypeList(localizer);</span>
<span class="nc" id="L4065">			String selectLabel = getSelectLabel(intervalType, iTypeList);</span>

			// Note: most request types store number of hours in the
			// IntervalDays field, but Flex Time stores minutes.
<span class="nc" id="L4069">			boolean isFlexTime = Request.REQUESTTYPE_FLEXTIME.equals(rule.getRequestType());</span>
<span class="nc" id="L4070">			StringsPair intervalCountAndUnit = RequestUtil.getIntervalCountAndUnit(rule.getIntervalDays(), isFlexTime);</span>
<span class="nc" id="L4071">			String intervalCount = intervalCountAndUnit.getKey();</span>
<span class="nc" id="L4072">			String sUnit = intervalCountAndUnit.getValue();</span>
<span class="nc" id="L4073">			String intervalUnits = localizer.i18n(rmBundle, getKeyForUnit(sUnit));</span>

<span class="nc bnc" id="L4075" title="All 2 branches missed.">			String timeLine = rule.getTimeLine() == RequestFilingRule.TIMELINE_IN_THE_PAST</span>
<span class="nc" id="L4076">					? localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_IN_PAST)</span>
<span class="nc" id="L4077">					: localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_IN_ADVANCE);</span>

<span class="nc" id="L4079">			Object args[] = new Object[] { selectLabel, intervalCount, intervalUnits, timeLine };</span>
<span class="nc" id="L4080">			dataToAdd = localizer.i18n(rmBundle, RmEjbBundleKey.ORG_RM_FILING_RULE_LIST_ADVANCE_LABEL, args);</span>
		}
<span class="nc" id="L4082">		return dataToAdd;</span>
	}

	/**
	 * Get the appropriate resource bundle key for the given interval unit.
	 *
	 * @param sUnit
	 *            - &quot;days&quot;, &quot;hours&quot;, &quot;minutes&quot;
	 * @return - the associated RmWebBundleKey
	 */
	public static String getKeyForUnit(String sUnit) {
<span class="nc" id="L4093">		String sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_DAYS;</span>
<span class="nc bnc" id="L4094" title="All 2 branches missed.">		if (sUnit.equals(RequestUtil.HOURS)) {</span>
<span class="nc" id="L4095">			sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_HOURS;</span>
<span class="nc bnc" id="L4096" title="All 2 branches missed.">		} else if (sUnit.equals(RequestUtil.MINUTES)) {</span>
<span class="nc" id="L4097">			sKey = RmEjbBundleKey.ORG_RM_FILING_RULE_MINUTES;</span>
		}
<span class="nc" id="L4099">		return sKey;</span>
	}

	/**
	 * Get a list of key/value StringsPair's for the &quot;On, &quot;Before&quot; and &quot;After&quot;
	 * options.
	 */
	public static Collection getDateComparisonList(Localizer localizer) {
<span class="nc" id="L4107">		Collection dateComparisonList = new ArrayList(3);</span>
<span class="nc" id="L4108">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4110">		dateComparisonList</span>
<span class="nc" id="L4111">				.add(new StringsPair(&quot;on-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.ON_THE_FOLLOWING_DATE)));</span>
<span class="nc" id="L4112">		dateComparisonList.add(new StringsPair(&quot;before-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.BEFORE)));</span>
<span class="nc" id="L4113">		dateComparisonList.add(new StringsPair(&quot;after-date&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.AFTER)));</span>

<span class="nc" id="L4115">		return dateComparisonList;</span>
	}

	/**
	 * Return string pair collection for interval type list drop down.
	 *
	 * @param localizer
	 * @return collection of StringPair objects.
	 */
	public static Collection getIntervalTypeList(Localizer localizer) {
<span class="nc" id="L4125">		Collection intervalTypeList = new ArrayList(3);</span>
<span class="nc" id="L4126">		ResourceBundle coreBundle = localizer.getBundle(UIFWebBundleKey.BUNDLE_NAME);</span>

<span class="nc" id="L4128">		intervalTypeList.add(new StringsPair(&quot;less-than&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.LESS_THAN)));</span>
<span class="nc" id="L4129">		intervalTypeList.add(new StringsPair(&quot;equal-to&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.EQUAL_TO)));</span>
<span class="nc" id="L4130">		intervalTypeList.add(new StringsPair(&quot;more-than&quot;, localizer.i18n(coreBundle, UIFWebBundleKey.MORE_THAN)));</span>

<span class="nc" id="L4132">		return intervalTypeList;</span>
	}

	public static String getSelectLabel(String key, Collection stringPairs) {
<span class="nc bnc" id="L4136" title="All 2 branches missed.">		if (stringPairs == null) {</span>
<span class="nc" id="L4137">			return &quot;&quot;;</span>
		}

<span class="nc" id="L4140">		String defaultValue = null;</span>
<span class="nc bnc" id="L4141" title="All 2 branches missed.">		for (Object obj : stringPairs) {</span>
<span class="nc" id="L4142">			StringsPair sp = (StringsPair) obj;</span>
<span class="nc bnc" id="L4143" title="All 2 branches missed.">			if (sp.getKey().equals(key)) {</span>
<span class="nc" id="L4144">				return sp.getValue();</span>
			}
<span class="nc bnc" id="L4146" title="All 2 branches missed.">			if (defaultValue == null) {</span>
<span class="nc" id="L4147">				defaultValue = sp.getValue();</span>
			}
<span class="nc" id="L4149">		}</span>

<span class="nc bnc" id="L4151" title="All 2 branches missed.">		return defaultValue == null ? &quot;&quot; : defaultValue;</span>
	}

	public static boolean checkGap(ShiftAssignment event, BitSet bits, long startingTime, long resolution, int limit) {
<span class="nc" id="L4155">		boolean ret = false;</span>
<span class="nc" id="L4156">		List&lt;ShiftEventAssignment&gt; assignments = new ArrayList&lt;ShiftEventAssignment&gt;(event.getChildren());</span>

<span class="nc bnc" id="L4158" title="All 2 branches missed.">		for (ShiftEventAssignment sea : assignments) {</span>
<span class="nc bnc" id="L4159" title="All 2 branches missed.">			if (sea.getActivityID().equals(Activity.ACTIVITY_SHIFT_OVERTIME_GAP)) {</span>
<span class="nc bnc" id="L4160" title="All 2 branches missed.">				if (!ret){</span>
					//This adds the bits of the full duration of the Shift Assignment
<span class="nc" id="L4162">					addToBits(bits, event.getStartTime().getTime(), event.getEndTime().getTime(), startingTime, resolution, limit, false);</span>
				}
				//Clear the bits of the gap
<span class="nc" id="L4165">				removeFromBits(bits, sea.getStartTime().getTime(), sea.getEndTime().getTime(), startingTime, resolution, limit, false);</span>
<span class="nc" id="L4166">				ret = true;</span>
			}

<span class="nc" id="L4169">		}</span>
<span class="nc" id="L4170">		return ret;</span>
	}

	// Convert event to interval index range and set in map
	private static  void addToBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean setEndBit) {
<span class="nc" id="L4175">		setBits(bits, eventStart, eventEnd, startingTime, resolution, limit, true, setEndBit);</span>
<span class="nc" id="L4176">	}</span>

	// Clear event to interval index range and set in map
	private static  void removeFromBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean setEndBit) {
<span class="nc" id="L4180">		setBits(bits, eventStart, eventEnd, startingTime, resolution, limit, false, setEndBit);</span>
<span class="nc" id="L4181">	}</span>

	private static  void  setBits(BitSet bits, long eventStart, long eventEnd, long startingTime, long resolution, int limit, boolean isAdd, boolean setEndBit) {
<span class="nc bnc" id="L4184" title="All 2 branches missed.">		if (!setEndBit){</span>
<span class="nc" id="L4185">			eventEnd--; //Reduce 1 mili sec so will not include last interval</span>
		}
<span class="nc" id="L4187">		int ixStrt = (int) ((eventStart - startingTime) / resolution);</span>
<span class="nc bnc" id="L4188" title="All 2 branches missed.">		ixStrt = (ixStrt &lt; 0) ? 0 : ixStrt;</span>

<span class="nc" id="L4190">		int ixEnd = (int) ((eventEnd - startingTime) / resolution);</span>
<span class="nc bnc" id="L4191" title="All 2 branches missed.">		ixEnd = (ixEnd &lt; 0) ? -1 : ixEnd;</span>

<span class="nc" id="L4193">		int upperBound = Math.min(ixEnd, limit);</span>
<span class="nc bnc" id="L4194" title="All 2 branches missed.">		for (int i = ixStrt; i &lt;= upperBound; i++) {</span>
<span class="nc bnc" id="L4195" title="All 2 branches missed.">			if(isAdd){</span>
<span class="nc" id="L4196">				bits.set(i);</span>
			} else {
<span class="nc" id="L4198">				bits.clear(i);</span>
			}
		}
<span class="nc" id="L4201">	}</span>

	/**
	 * Build a time map object from events.
	 * 	Default for setEndBit is true
	 * @param events - Events to create the timemap
	 * @param range - time boundary of time map
	 * @param resolution - resolution in millis
	 * @return Time Map object
	 */
	public static  TimeMap buildTimeMap(Collection events, TimeRange range, long resolution){
<span class="nc" id="L4212">		return buildTimeMap(events, range, resolution, true);</span>
	}

	/**
	 * Build a time map object from events
	 * @param events - Events to create the timemap
	 * @param range - time boundary of time map
	 * @param resolution - resolution in millis
	 * @param setEndBit - If to set last bit in timemap in case endtime of event includes only first milli second of bit.
	 *                    For example event 10:00-11:00 will also mark bit of 11:00-11:01 in case this boolean is true
	 * @return Time Map object
	 */
	public static  TimeMap buildTimeMap(Collection events, TimeRange range, long resolution, boolean setEndBit) {
		// todo: more strict validation of passed arguments.
<span class="nc" id="L4226">		long startingTime = range.getStartDate().getTime();</span>
<span class="nc" id="L4227">		int limit = (int) ((range.getEndDate().getTime() - startingTime) / resolution);</span>
<span class="nc" id="L4228">		BitSet bits = new BitSet(limit);</span>

		// Did we find events?
<span class="nc bnc" id="L4231" title="All 2 branches missed.">		if (events != null) {</span>
			// Loop through the events. Check each one. If its overlap type
			// is OVERLAP_TYPE_MUST_OVERLAP_SHIFT, then add it to the map
<span class="nc bnc" id="L4234" title="All 2 branches missed.">			for (Object obj: events) {</span>
<span class="nc" id="L4235">				PlannedEvent plannedEvent = (PlannedEvent) obj;</span>

<span class="nc" id="L4237">				long eventStart = 0, eventEnd = 0;</span>
<span class="nc" id="L4238">				int eventType = plannedEvent.getEventType();</span>
<span class="nc bnc" id="L4239" title="All 6 branches missed.">				if (eventType == Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT || eventType == Event.EVENT_TYPE_TIME_OFF</span>
						|| eventType == Event.EVENT_TYPE_UNAVAILABILITY) {
<span class="nc" id="L4241">					CalendarEventAssignment event = (CalendarEventAssignment) obj;</span>
<span class="nc" id="L4242">					eventStart = event.getStartTime().getTime();</span>
<span class="nc" id="L4243">					eventEnd = event.getEndTime().getTime();</span>
<span class="nc bnc" id="L4244" title="All 2 branches missed.">				} else if (eventType == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L4245">					ShiftAssignment event = (ShiftAssignment) obj;</span>
<span class="nc bnc" id="L4246" title="All 2 branches missed.">					if (checkGap(event, bits, startingTime, resolution, limit)) {</span>
<span class="nc" id="L4247">						continue;</span>
					}
<span class="nc" id="L4249">                    eventStart = event.getStartTime().getTime();</span>
<span class="nc" id="L4250">					eventEnd = event.getEndTime().getTime();</span>
<span class="nc" id="L4251">				} else {</span>
<span class="nc" id="L4252">					throw new IllegalArgumentException();</span>
				}
				// Convert event to interval index range and set in map
<span class="nc" id="L4255">                addToBits(bits, eventStart, eventEnd, startingTime, resolution, limit, setEndBit);</span>
<span class="nc" id="L4256">			} // end for (Iterator it=events.iterator()...</span>
		} // end if (events != null)

		// At this point, the BitSet is built and we can build the TimeMap
<span class="nc" id="L4260">		return new TimeMap(bits, resolution, range.getStartDate(), range.getEndDate());</span>
	}

	/**
	 * Gets a collection of IDs for the employee names. If employeeNames is null, null is returned.
	 */
	public static Collection&lt;ID&gt; getIDs(Collection&lt;EmployeeName&gt; employeeNames) {
<span class="nc bnc" id="L4267" title="All 2 branches missed.">		if (employeeNames == null) {</span>
<span class="nc" id="L4268">			return null;</span>
		}
<span class="nc" id="L4270">		List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;(employeeNames.size());</span>
<span class="nc bnc" id="L4271" title="All 2 branches missed.">		for (EmployeeName name : employeeNames) {</span>
<span class="nc" id="L4272">			ids.add(name.getID());</span>
<span class="nc" id="L4273">		}</span>
<span class="nc" id="L4274">		return ids;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>