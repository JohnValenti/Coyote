<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClientForecastTraceCube.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">ClientForecastTraceCube.java</span></div><h1>ClientForecastTraceCube.java</h1><pre class="source lang-java linenums">/*
 * (c) 2011 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.model;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;

/**
 * This trace cube type exists to supply forecast data to the Forecasting client.
 * In the Forecasting client, unlike all other applications, AHT is weighted on CRATE
 * for outbound queues, and RPCAHT is weighted on RPCRATE.  Further, CRATE and RPCRATE
 * use simple averages instead of weighted averages for aggregation.
 * &lt;p&gt;
 * This trace cube type is intended only for the use of the Forecasting client application;
 * therefore it does not participate in the prototype pattern that is widely used in the DAOs, etc.
 */
public class ClientForecastTraceCube extends TraceCube {
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;
	// All trace types supported by this trace cube class.
<span class="nc" id="L28">	public static final short[] TYPES = {Trace.CV, Trace.VH, Trace.CV_VH, Trace.FORECASTING_CRATE, Trace.FORECASTING_AHT, Trace.FORECASTING_RPCRATE, Trace.FORECASTING_RPCAHT};</span>
	// Trace types that are derived from other trace types rather than loaded directly
	// from the database.  This trace cube type does not use the calcComputedTraceValues method
	// to set these values as they are known at creation time and setting them again later
	// would overwrite user-entered data.
<span class="nc" id="L33">	public static final short[] COMPUTED_TYPES = {Trace.CV, Trace.VH, Trace.CV_VH, Trace.FORECASTING_CRATE, Trace.FORECASTING_AHT, Trace.FORECASTING_RPCRATE, Trace.FORECASTING_RPCAHT};</span>
	// Trace types that are handed to a client that requests a forecast trace cube
	// from this trace cube.  They will be copied from the corresponding client types.
<span class="nc" id="L36">	private static final short[] OUTPUT_TYPES = { Trace.CRATE, Trace.AHT, Trace.RPCRATE, Trace.RPCAHT };</span>
	// Map from server trace types to their corresponding client trace types.
<span class="nc" id="L38">	private static final Map&lt;Short, Short&gt; SERVER_TO_CLIENT_TRACE_TYPE_MAP = new HashMap&lt;Short, Short&gt;();</span>
	static {
<span class="nc" id="L40">		SERVER_TO_CLIENT_TRACE_TYPE_MAP.put(Trace.CRATE, Trace.FORECASTING_CRATE);</span>
<span class="nc" id="L41">		SERVER_TO_CLIENT_TRACE_TYPE_MAP.put(Trace.AHT, Trace.FORECASTING_AHT);</span>
<span class="nc" id="L42">		SERVER_TO_CLIENT_TRACE_TYPE_MAP.put(Trace.RPCRATE, Trace.FORECASTING_RPCRATE);</span>
<span class="nc" id="L43">		SERVER_TO_CLIENT_TRACE_TYPE_MAP.put(Trace.RPCAHT, Trace.FORECASTING_RPCAHT);</span>
<span class="nc" id="L44">	}</span>

	/**
	 * Creates a new instance of ClientForecastTraceCube and populates it with the specified
	 * forecast data.
	 * 
	 * @param forecastData
	 * @param serviceGoalData
	 */
	public ClientForecastTraceCube(ForecastTraceCube forecastData) {
<span class="nc" id="L54">		super(forecastData.getQueueID(), forecastData.getRawStartDate(), forecastData.getRawEndDate(), TYPES);</span>

		// This trace cube class uses CV_VH to house volume information for use in aggregating
		// the forecast traces, and copies CRATE, AHT, RPCRATE, and RPCAHT respectively into
		// FORECASTING_CRATE, FORECASTING_AHT, FORECASTING_RPCRATE, and FORECASTING_RPCAHT.
		// This is because the &quot;FORECASTING_&quot; trace types use an aggregation strategy peculiar
		// to the Forecasting client: they treat CRATE and RPCRATE as simple averages, and 
		// weight AHT and RPCAHT, respectively, with CRATE and RPCRATE.
		// This trace cube type does not use the calcComputedTraceValues method
		// to set these values as they are known at creation time and setting them again later
		// would overwrite user-entered data.
<span class="nc" id="L65">		double[] volume = forecastData.getTraceValueD(Trace.CV);</span>
<span class="nc bnc" id="L66" title="All 2 branches missed.">		if (volume != null) {</span>
<span class="nc" id="L67">			double[] clientVolume = new double[volume.length];</span>
<span class="nc" id="L68">			System.arraycopy(volume, 0, clientVolume, 0, volume.length);</span>
<span class="nc" id="L69">			setTraceValue(Trace.CV, clientVolume);</span>
<span class="nc" id="L70">			setTraceValue(Trace.CV_VH, clientVolume);</span>
<span class="nc bnc" id="L71" title="All 2 branches missed.">			if (forecastData.isDirty(Trace.CV) == false) {</span>
<span class="nc" id="L72">				setTypeDirty(Trace.CV, false);</span>
<span class="nc" id="L73">				setTypeDirty(Trace.CV_VH, false);</span>
			}
		}
<span class="nc" id="L76">		double[] connectRate = forecastData.getTraceValueD(Trace.CRATE);</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">		if (connectRate != null) {</span>
<span class="nc" id="L78">			double[] forecastConnectRate = new double[connectRate.length];</span>
<span class="nc" id="L79">			System.arraycopy(connectRate, 0, forecastConnectRate, 0, connectRate.length);</span>
<span class="nc" id="L80">			setTraceValue(FORECASTING_CRATE, forecastConnectRate);</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">			if (forecastData.isDirty(Trace.CRATE) == false) {</span>
<span class="nc" id="L82">				setTypeDirty(FORECASTING_CRATE, false);</span>
			}
		}
<span class="nc" id="L85">		double[] aht = forecastData.getTraceValueD(Trace.AHT);</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">		if (aht != null) {</span>
<span class="nc" id="L87">			double[] forecastAht = new double[aht.length];</span>
<span class="nc" id="L88">			System.arraycopy(aht, 0, forecastAht, 0, aht.length);</span>
<span class="nc" id="L89">			setTraceValue(FORECASTING_AHT, forecastAht);</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">			if (forecastData.isDirty(Trace.AHT) == false) {</span>
<span class="nc" id="L91">				setTypeDirty(FORECASTING_AHT, false);</span>
			}
		}
<span class="nc" id="L94">		double[] rpcRate = forecastData.getTraceValueD(Trace.RPCRATE);</span>
<span class="nc bnc" id="L95" title="All 2 branches missed.">		if (rpcRate != null) {</span>
<span class="nc" id="L96">			double[] forecastRpcRate = new double[rpcRate.length];</span>
<span class="nc" id="L97">			System.arraycopy(rpcRate, 0, forecastRpcRate, 0, rpcRate.length);</span>
<span class="nc" id="L98">			setTraceValue(FORECASTING_RPCRATE, forecastRpcRate);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">			if (forecastData.isDirty(Trace.RPCRATE) == false) {</span>
<span class="nc" id="L100">				setTypeDirty(FORECASTING_RPCRATE, false);</span>
			}
		}
<span class="nc" id="L103">		double[] rpcAht = forecastData.getTraceValueD(Trace.RPCAHT);</span>
<span class="nc bnc" id="L104" title="All 2 branches missed.">		if (rpcAht != null) {</span>
<span class="nc" id="L105">			double[] forecastRpcAht = new double[rpcAht.length];</span>
<span class="nc" id="L106">			System.arraycopy(rpcAht, 0, forecastRpcAht, 0, rpcAht.length);</span>
<span class="nc" id="L107">			setTraceValue(FORECASTING_RPCAHT, forecastRpcAht);</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">			if (forecastData.isDirty(Trace.RPCAHT) == false) {</span>
<span class="nc" id="L109">				setTypeDirty(FORECASTING_RPCAHT, false);</span>
			}
		}
<span class="nc" id="L112">	}</span>

	/**
	 * This trace cube type really isn't designed to participate in the prototype
	 * pattern that the server trace cube types use.  This constructor is only
	 * supplied because I don't know the full implications of simply throwing
	 * an UnsupportedOperationException in newInstance().
	 */
	private ClientForecastTraceCube(ID queueID, Date startDate, Date endDate, short[] types)
			throws BbmTimeSeriesException {
<span class="nc" id="L122">		super(queueID, startDate, endDate, types);</span>
<span class="nc" id="L123">	}</span>

	/**
	 * This trace cube type really isn't designed to participate in the prototype
	 * pattern that the server trace cube types use.  This constructor is only
	 * supplied because I don't know the full implications of simply throwing
	 * an UnsupportedOperationException in newInstance().
	 */
	@Override
	public TraceCube newInstance(ID queueID, Date startDate, Date endDate, short[] types)
			throws BbmTimeSeriesException {
<span class="nc" id="L134">		return new ClientForecastTraceCube(queueID, startDate, endDate, types);</span>
	}

	public short[] getComputedTraceTypes() {
<span class="nc" id="L138">		return COMPUTED_TYPES;</span>
	}

	/**
	 * Returns a ForecastTraceCube created based on the supplied meta-cube.  The returned
	 * trace cube will contain all forecast data that are both present in this cube and
	 * supported by the supplied meta-cube.
	 * 
	 * @param metaTc
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	public TraceCube getForecast(ForecastTraceCube metaTc)
			throws BbmTimeSeriesException {
<span class="nc" id="L152">		TraceCube forecast = metaTc.newInstance(metaTc.getQueueID(), metaTc.getRawStartDate(), metaTc.getRawEndDate(), metaTc.getSupportedTraceType());</span>

		// Copy the types that the destination supports and we have data for into the
		// destination cube.
<span class="nc bnc" id="L156" title="All 2 branches missed.">		for (short traceType : OUTPUT_TYPES) {</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (metaTc.supportType(traceType)) {</span>
<span class="nc" id="L158">				Short clientTraceType = SERVER_TO_CLIENT_TRACE_TYPE_MAP.get(traceType);</span>
<span class="nc bnc" id="L159" title="All 2 branches missed.">				if (clientTraceType != null) {</span>
<span class="nc" id="L160">					double[] clientValues = getTraceValueD(clientTraceType);</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">					if (clientValues != null) {</span>
<span class="nc" id="L162">						double[] returnValues = new double[clientValues.length];</span>
<span class="nc" id="L163">						System.arraycopy(clientValues, 0, returnValues, 0, clientValues.length);</span>
<span class="nc" id="L164">						forecast.setTraceValue(traceType, returnValues);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">						if (isDirty(clientTraceType) == false) {</span>
<span class="nc" id="L166">							forecast.setTypeDirty(traceType, false);		//Clear dirty flag on cloned trace cube if the associated data in this cube is not dirty</span>
						}
					}
				}
			}
		}

<span class="nc" id="L173">		return forecast;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>