<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ValidationUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.common.validation</a> &gt; <span class="el_source">ValidationUtil.java</span></div><h1>ValidationUtil.java</h1><pre class="source lang-java linenums">/*
 * ValidationUtil.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.common.validation;

import java.io.Serializable;
import java.lang.reflect.InvocationTargetException;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtil;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.shifts.model.ShiftsUtil;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;
import com.verint.ejb.wfm.WfmManagerFactory;


/**
 * utilities for getting data from the ejb tier for use when validating requests
 */
public class ValidationUtil {
<span class="fc" id="L66">    private static final Category m_cat = Log.initCategory(ValidationUtil.class.getName());</span>

    /** Don't construct these...static only methods */
<span class="nc" id="L69">    private ValidationUtil() {</span>
<span class="nc" id="L70">    }</span>

    /**
     * Get the employee object
     * @param employeeID id of employee
     * @param dateNow point in time to get object data
     * @return an Employee, given it's ID.
     * @throws Exception
     */
    public static Employee getEmployeeByID(ID empID, Date dateNow, long empDetailLevel)
            throws Exception {

        // if caching is enabled, force load the following detail levels which is a list of all possible
        // detail levels used in RM.
<span class="fc bfc" id="L84" title="All 2 branches covered.">        if (CacheUtil.isThreadLocalCacheEnabled()) {</span>
<span class="fc" id="L85">            long rmDetailLevel = Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFYEARLY |</span>
                    Employee.DETAIL_LEVEL_EMPLOYEE_TIMEOFFDEFAULT | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEBASEDPROPERTY;

            // verify that the passed detailLevel is a subset
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">            if ( (rmDetailLevel &amp; empDetailLevel) != empDetailLevel ) {</span>
<span class="nc" id="L90">                throw RequestUtil.createIllegalArgumentException(</span>
                        &quot;specified employee detail level is not a subset: &quot; + rmDetailLevel + ',' + empDetailLevel, m_cat);
            }

<span class="fc" id="L94">            empDetailLevel = rmDetailLevel;</span>
        }

<span class="fc" id="L97">        Employee emp = CacheUtilBBM.getEmployeeByID(empID, dateNow, empDetailLevel);</span>

<span class="fc" id="L99">        return emp;</span>
    }

    public static Collection getEmployeesByIDs(Collection empIDsWithTOEvts, Date dateNow, long empDetLevel)
            throws Exception {

<span class="nc" id="L105">        WorkResourceManager wrm = RequestUtil.getWorkResourceManager();</span>
<span class="nc" id="L106">        Collection empsWithTOEvts = wrm.getEmployeesByIDs(empIDsWithTOEvts, dateNow, empDetLevel);</span>
<span class="nc" id="L107">        return empsWithTOEvts;</span>
    }


    /**
     * Get the organization object
     * @param orgID of organization
     * @return an Organization, given it's ID.
     * @throws Exception
     */
    public static Organization getOrganizationByID(ID orgID) throws Exception {

<span class="fc" id="L119">        return RequestUtil.getOrganizationByID(orgID, null);</span>

    }

    /**
     * Get the org id for an employee during a given period.
     * @param empID the employee id
     * @param start the beginning of the period
     * @param end   the ending of the period
     * @return the orgID of the organization for the employee during the given period
     * @throws Exception
     */
    public static ID getOrgIDForEmployeeDuringPeriod(ID empID, Date start, Date end) throws Exception {


<span class="fc" id="L134">        Collection wrAssns = getWorkResAssnWithTZForWRID(empID, start, end);</span>

<span class="fc" id="L136">        WorkResourceAssignment overlappingWRAssn = null;</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">        if (!wrAssns.isEmpty()) {</span>
<span class="fc" id="L138">            overlappingWRAssn = (WorkResourceAssignment) wrAssns.iterator().next();</span>
        }

        // In London, a workresouce can only have one (workResource, organization) association.  In
        // the future, this might change and an employee can have one or more
        // (workResource, organization) associations.  When it does, additional code will be needed to
        // determine which one of the associations to use.

<span class="pc bpc" id="L146" title="1 of 2 branches missed.">        return (overlappingWRAssn == null)?null:overlappingWRAssn.getOrganizationID();</span>
    }

    /**
     * Note: This method may return a null.
     * &lt;p&gt; Obtains the work resource assignment for the specified employee which overlaps the specified time range.
     *
     * @param empID
     * @param start
     * @param end
     * @return
     * @throws InstantiationException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     * @throws NoSuchMethodException
     * @throws BbmFinderException
     * @throws BbmEJBCreateException
     * @throws RemoteException
     */
    public static Collection getWorkResAssnWithTZForWRID(ID empID, Date start, Date end) throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException, BbmFinderException, BbmEJBCreateException, RemoteException {
        // accomodate 'null' for start
<span class="fc" id="L167">        Date minDate = new Date(0);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">        start = (start == null)?minDate:start;</span>
        // accomodate 'null' for end
<span class="fc" id="L170">        Date maxDate = new Date(Long.MAX_VALUE);</span>
<span class="pc bpc" id="L171" title="1 of 2 branches missed.">        end = (end == null)?maxDate:end;</span>

        // get work resource assignments for given employee.
<span class="fc" id="L174">        Collection wrAssns = CacheUtilBBM.getWorkResourceAssnWithTZForWRID(empID);</span>

<span class="fc" id="L176">        Collection overlappingWRAssns = new ArrayList();</span>
        // for each work resource assignment
<span class="fc bfc" id="L178" title="All 2 branches covered.">        for (Iterator iter = wrAssns.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L179">            WorkResourceAssignment wrAssn = (WorkResourceAssignment) iter.next();</span>

            // adjust if startTime == null
<span class="fc" id="L182">            Date wrAssnStart = wrAssn.getStartTime();</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            wrAssnStart = (wrAssnStart == null)?minDate:wrAssnStart;</span>

            // adjust if endTime == null
<span class="fc" id="L186">            Date wrAssnEnd = wrAssn.getEndTime();</span>
<span class="pc bpc" id="L187" title="1 of 2 branches missed.">            wrAssnEnd = (wrAssnEnd == null)?maxDate:wrAssnEnd;</span>

<span class="fc" id="L189">            boolean overlap = TimePeriodUtil.overlap(start, end, wrAssnStart, wrAssnEnd);</span>
            // if ranges overlap
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">            if (overlap) {</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">                overlappingWRAssns = (overlappingWRAssns == null)?new ArrayList(8):overlappingWRAssns;</span>
<span class="fc" id="L193">                overlappingWRAssns.add(wrAssn);</span>
            }
<span class="fc" id="L195">        }</span>

<span class="pc bpc" id="L197" title="1 of 2 branches missed.">        if (overlappingWRAssns.size() == 0){</span>
            //still need a workresourceassignment: pick the first one
<span class="nc" id="L199">            WorkResourceAssignment wrAssn = (WorkResourceAssignment) wrAssns.iterator().next();</span>
<span class="nc" id="L200">            overlappingWRAssns.add(wrAssn);</span>
        }

<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        return (overlappingWRAssns == null)?Collections.EMPTY_LIST:overlappingWRAssns;</span>
    }

    public static Map getOrgIDsForEmployeesOnGivenDate(List empIDs, Date onDate) throws Exception {
<span class="nc" id="L207">        WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L208">        HashMap empIDToOrgIDMap = wrm.getEmployeesReportingOrgs(empIDs, onDate);</span>

<span class="nc" id="L210">        return empIDToOrgIDMap;</span>
    }

    public static Organization getOrganizationForEmployeeDuringPeriod(ID empID, Date start, Date end)
            throws Exception    {
//      try {
<span class="nc" id="L216">        return getOrganizationByID(getOrgIDForEmployeeDuringPeriod(empID, start, end));</span>
//      } c_atch (Exception e) {
//          //log.error(e);
//          t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
//      }
    }

    /**
     * Get the Collection&lt;SkillAssignment&gt; for an employee during a period.
     * @param empID - an Employee ID
     * @param start - the start time for the period
     * @param end - the end time for the period
     * @return the Collection of SkillAssignment's.
     * @throws Exception
     */
    public static Collection getSkillsForEmployeeDuringPeriod(ID empID, Date start, Date end)
            throws Exception {
<span class="nc" id="L233">        Collection cSkills = null;</span>

<span class="nc" id="L235">        SkillManager sm = WfmManagerFactory.getSkillManager();</span>
<span class="nc" id="L236">        cSkills = sm.getSkillAssignments(empID, start, end);</span>

<span class="nc" id="L238">        return cSkills;</span>
    }

    public static Collection&lt;ID&gt; getSkillsForSchedulingPeriod(Collection&lt;ID&gt; spIDs)
    	throws Exception {
<span class="nc" id="L243">		CampaignManager cm = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L244">		Collection&lt;SPQueue&gt; spQs = cm.getSPQueuesBySPIDsFixed(spIDs);</span>
<span class="nc" id="L245">		Collection&lt;ID&gt; skillIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">		for (SPQueue spQ: spQs) {</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">			if (spQ.getSkills() != null)</span>
<span class="nc" id="L248">				skillIDs.addAll(spQ.getSkills());</span>
<span class="nc" id="L249">		}</span>
<span class="nc" id="L250">		return skillIDs;</span>
	}

    /**
     * Get the name of a Skill given its ID.
     * @param id the ID for the Skill.
     * @return the name of the Skill.
     * @throws Exception
     */
    public static String getSkillName(ID id) throws Exception {
<span class="nc" id="L260">        String strSkill = &quot;deletedSkill&quot;;</span>

<span class="nc" id="L262">        SkillManager sm = WfmManagerFactory.getSkillManager();</span>
        // Note: using skillMgr.getSkillsByIDs() instead of skillMgr.getSkillByID() method
        // as it t_hrows a BbmObjectNotFoundException for a deleted skill and marks the
        // transaction as rolled back (which prevents any further access to the DB)
        // even if the skill is assigned to an employee by a 'SkillAssignment'.  Essentially the
        // 'SkillAssignment' indicates that an employee has this skill, but the actual skill
        // value object cannot be fetched as it was deleted.  Deletion of skill does
        // not delete the skill object itself (which would also delete the 'SkillAssignment')
        // in the 'skill' table but simply sets the 'deleteOnDate' column to a non-null value.
        // For further details see SQL query in SkillDAO.getSkillsByIDs() method.
<span class="nc" id="L272">        Collection skills = sm.getSkillsByIDs(Collections.singleton(id));</span>

<span class="nc bnc" id="L274" title="All 2 branches missed.">        if (!skills.isEmpty()) {</span>
<span class="nc" id="L275">            Skill skill = (Skill)skills.iterator().next();</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">            if (skill != null) {</span>
<span class="nc" id="L277">                strSkill = (skill).getName();</span>
            }
        }

<span class="nc" id="L281">        return strSkill;</span>
    }

    /**
     * Retrieve events from published schedule for a WorkResource given an
     * Event Type.
     *
     * @param eventType a type from the Event class
     * @param idWorkResource a WorkResource ID
     * @param dtStart the start Date for the period from which to retrieve events
     * @param dtEnd the end Date for the period from which to retrieve events
     * @return a Collection of Events for the input WorkResource in the input
     * time period
     * @throws Exception
     */
    public static Collection getPublishedEventsForWorkResourceByType(int eventType, ID idWorkResource,
                                                                     Date dtStart, Date dtEnd) throws Exception
    {
<span class="fc" id="L299">        String methodName = &quot;getPublishedEventsForWorkResourceByType&quot;;</span>
<span class="fc" id="L300">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Integer(eventType),</span>
                idWorkResource, dtStart, dtEnd));

<span class="fc" id="L303">        Collection events = null;</span>

<span class="fc" id="L305">        ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="fc" id="L307">        events = sam.getPublishedEventsForWorkResourceByType(eventType, idWorkResource, dtStart,</span>
                dtEnd);

<span class="fc" id="L310">        m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>
<span class="fc" id="L311">        return events;</span>
    }

    /**
     * Retrieve events from unpublished schedule for a WorkResource given an
     * Event Type.
     *
     * @param eventType a type from the Event class
     * @param idWorkResource a WorkResource ID
     * @param dtStart the start Date for the period from which to retrieve events
     * @param dtEnd the end Date for the period from which to retrieve events
     * @return a Collection of Events for the input WorkResource in the input
     * time period
     * @throws Exception
     */
    public static Collection getEventsForWorkResourceByType(int eventType, ID idWorkResource,
                                                            Date dtStart, Date dtEnd) throws Exception
    {
<span class="nc" id="L329">        String methodName = &quot;getEventsForWorkResourceByType&quot;;</span>
<span class="nc" id="L330">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, new Integer(eventType),</span>
                idWorkResource, dtStart, dtEnd));

<span class="nc" id="L333">        Collection events = null;</span>

<span class="nc" id="L335">        ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>

<span class="nc" id="L337">        events = sam.getEventsForWorkResourceByType(eventType, idWorkResource, dtStart,</span>
                dtEnd);

<span class="nc bnc" id="L340" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) m_cat.debug(RmUtil.dumpExitMethod(methodName, events));</span>
<span class="nc" id="L341">        return events;</span>
    }

    /**
     * Get an instance of a validator by name.
     * @param validatorName the name of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator Validator}
     * interface.
     * @param valMap a cache for Validator instances
     * @return an instance of the class whose name is validatorName
     */
    public static Validator getValidator(String validatorName, Map valMap) throws Exception {
<span class="fc" id="L353">        Validator result = (Validator) valMap.get(validatorName);</span>

<span class="fc bfc" id="L355" title="All 2 branches covered.">        if (result == null) {</span>
//            try {
<span class="fc" id="L357">            result = (Validator) Class.forName(validatorName).newInstance();</span>
<span class="fc" id="L358">            valMap.put(validatorName, result);</span>
//            } c_atch (Exception e) {
//                m_cat.error(&quot;Exception when loading validator class: &quot; + validatorName, e);
//                t_hrow RequestUtil.createValidationExceptionWrapper(e, m_cat);
//            }
        }

<span class="fc" id="L365">        return result;</span>
    }

    /**
     * Perform a single validation
     * @param validatorClassName The name of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validator Validator}
     * interface.
     * @param request An instance of a class that implements the
     * {@link com.bluepumpkin.ejb.rm.requests.common.validation.Validatable Validatable}
     * interface.
     * @param validatorsMap a cache for Validator instances
     * @throws Exception
     */
	public static ValidationResult doValidation(String validatorClassName, Validatable request,
                                                Map validatorsMap) throws Exception {
<span class="fc" id="L381">        Validator val = getValidator(validatorClassName, validatorsMap);</span>

        // Check to make sure we actually constructed the validator.  If there
        // was a problem, then the error has already been logged.  Guard the
        // use of the validator against null pointer exception.
<span class="pc bpc" id="L386" title="1 of 2 branches missed.">        if (val != null) {</span>
<span class="fc" id="L387">			return val.validate(request);</span>
        }

<span class="nc" id="L390">		return null;</span>
    }

    /**
     * Get the holidays for an Organization for a time period.
     *
     * @param org The {@link com.bluepumpkin.ejb.bbm.workresource.model.Organization
     * Organization} to retrieve holidays from.
     * @param tz The TimeZone of the TimeRange dates.
     * @param range A start and end date, packaged as a
     * {@link com.bluepumpkin.common.datatypes.TimeRange TimeRange}
     * &lt;p&gt;
     * @return a Collection of
     * {@link com.bluepumpkin.ejb.bbm.holiday.model.Holiday Holiday}s.
     * &lt;p&gt;
     * @throws Exception
     */
    public static Collection&lt;Holiday&gt; getHolidays(Organization org, TimeZone tz, TimeRange range)
        throws Exception
    {
<span class="fc" id="L410">        String methodName = &quot;getHolidays&quot;;</span>
<span class="fc" id="L411">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, org, tz, range));</span>

        // get the holidays for the organization during the period
<span class="fc" id="L414">        Collection&lt;Holiday&gt; holidays = </span>
<span class="fc" id="L415">            CacheUtilBBM.getHolidaysForOrg(org.getID(), range.getStartLocalDate(tz), range.getEndLocalDate(tz));</span>
<span class="fc" id="L416">        m_cat.debug(RmUtil.dumpEnterMethod(methodName, holidays));</span>
<span class="fc" id="L417">        return holidays;</span>
    }

    /**
     * Transfer the exception information in the given ExceptionMessage to a new ValidationResult
     *
     * @param validatable
     * @param e
     * @param validatorName
     * @return
     */
    private static ValidationResult setValidationResult(boolean softValidation, Validatable validatable,
                                                        Exception e, String validatorName)
    {
        // we log this with priority 'error' since only unexpected exceptions are thrown by the validation
        // rules. If the validation rule fails, only a validation result is added and an exception is not thrown.
        //m_cat.info(&quot;Translating Exception to Validation result: &quot; + e.getLocalizedMessage());

<span class="nc" id="L435">        RequestUtil.ExceptionMessage excMsg = RequestUtil.getMsgFromException(e);</span>

        // if bundle not specified
<span class="nc bnc" id="L438" title="All 2 branches missed.">        if (!excMsg.getUseBundle()) {</span>
<span class="nc bnc" id="L439" title="All 2 branches missed.">            return softValidation?</span>
<span class="nc" id="L440">                    setSoftValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L441">                            RmEjbBundleKey.REQ_UNEXPECTED_ERROR, new Serializable[] {excMsg.getUnLocalizedMessage()}, validatorName):</span>
<span class="nc" id="L442">                    setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME,</span>
<span class="nc" id="L443">                            RmEjbBundleKey.REQ_UNEXPECTED_ERROR, new Serializable[] {excMsg.getUnLocalizedMessage()}, validatorName);</span>
        }

        // bundle has been specified.  Now translate Object[], from ExceptionMessage.getMsgParms(),
        // to Serializable[] for passing to ValidationResult() constructor.
<span class="nc" id="L448">        Serializable[] serArr = convertToSerializable(excMsg.getMsgParms());</span>

<span class="nc bnc" id="L450" title="All 2 branches missed.">        return ( (softValidation)?</span>
<span class="nc" id="L451">                setSoftValidationResult(validatable, excMsg.getBundleName(),</span>
<span class="nc" id="L452">                        excMsg.getMsgKey(), serArr, validatorName):</span>
<span class="nc" id="L453">                setHardValidationResult(validatable, excMsg.getBundleName(),</span>
<span class="nc" id="L454">                        excMsg.getMsgKey(), serArr, validatorName));</span>
    }

    protected static Serializable[] convertToSerializable(Object[] objArr)
    {
        //Note: from sdk doc: if any actual component of the source array from cannot be converted to the component type of
        // the destination array by assignment conversion, an ArrayStoreException is thrown
<span class="nc" id="L461">        Serializable[] serArr = null;</span>
<span class="nc bnc" id="L462" title="All 2 branches missed.">        if (objArr != null) {</span>
<span class="nc" id="L463">            serArr = new Serializable[objArr.length];</span>
<span class="nc" id="L464">            System.arraycopy(objArr, 0, serArr, 0, objArr.length);</span>
        }

<span class="nc" id="L467">        return serArr;</span>
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           Exception e, String validatorName)
    {
<span class="nc" id="L473">        return setValidationResult(false, validatable, e, validatorName);</span>
    }

    /*public static ValidationResult setHardValidationResult(Validatable validatable,
        String msg, String className)
    {
        ValidationResult result = new ValidationResult(className, false);

        result.setMessage(msg);

        validatable.addValidationResult(result);

        return result;
    }*/

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, String className)
    {
<span class="nc" id="L491">        return setHardValidationResult(validatable, msgKey, null, className);</span>
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, String className)
    {
<span class="nc" id="L497">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, String className)
    {
<span class="nc" id="L504">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3, String className)
    {
<span class="nc" id="L511">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3,
                                                           Serializable obj4, String className)
    {
<span class="nc" id="L519">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3, obj4}, className);
    }

    public static ValidationResult setHardValidationResult(Validatable validatable,
                                                           String msgKey, Serializable obj1, Serializable obj2, Serializable obj3,
                                                           Serializable obj4, Serializable obj5, String className)
    {
<span class="nc" id="L527">        return setHardValidationResult(validatable, msgKey,</span>
                new Serializable[] {obj1, obj2, obj3, obj4, obj5}, className);
    }

    //TODO: modify all validation rules to use these methods.
    public static ValidationResult setHardValidationResult(Validatable validatable, String msgKey,
                                                           Serializable[] parms, String className)
    {
<span class="nc" id="L535">        return setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, msgKey,</span>
                parms, className);
    }

    /**
     * Set HardValidationResult to Validatable Object and Log message
     * @param validatable - Validatable Object to set Validation Result to
     * @param uiKey - RM Resource Bundle Key for UI
     * @param logKey - RM Resource Bundle Key for Logging
     * @param params - Parameters associated with the Message
     * @param className - The Class NAme
     * @return ValidationResult
     */
    public static ValidationResult setAndLogHardValidationResult(
            Validatable validatable, String uiKey, String logKey,
            Serializable[] params, String className) {
<span class="nc" id="L551">        m_cat.l7dError(logKey, params);</span>
<span class="nc" id="L552">        return setHardValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, uiKey,</span>
                params, className);
    }


    private static ValidationResult setHardValidationResult(Validatable validatable,
                                                            String msgBundleName, String msgKey, Serializable[] parms, String className) {
<span class="nc" id="L559">        ValidationResult result = getValidationResult(msgBundleName, msgKey, parms, className, false);</span>
<span class="nc" id="L560">        validatable.addValidationResult(result);</span>
<span class="nc" id="L561">        return result;</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           Exception e, String validatorName) {
<span class="nc" id="L566">        return setValidationResult(true, validatable, e, validatorName);</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, String className) {
<span class="nc" id="L571">        return setSoftValidationResult(validatable, msgKey, null, className);</span>
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, String className)
    {
<span class="fc" id="L577">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, String className)
    {
<span class="fc" id="L584">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3, String className)
    {
<span class="fc" id="L591">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3,
                                                           Serializable ser4, String className)
    {
<span class="fc" id="L599">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3, ser4}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgKey, Serializable ser1, Serializable ser2, Serializable ser3,
                                                           Serializable ser4, Serializable ser5, String className)
    {
<span class="fc" id="L607">        return setSoftValidationResult(validatable, msgKey,</span>
                new Serializable[] {ser1, ser2, ser3, ser4, ser5}, className);
    }

    public static ValidationResult setSoftValidationResult(Validatable validatable, String msgKey,
                                                           Serializable[] parms, String className) {
<span class="fc" id="L613">        return setSoftValidationResult(validatable, RmEjbBundleKey.BUNDLE_NAME, msgKey, parms, className);</span>
    }
    public static ValidationResult setSoftValidationResult(Validatable validatable,
                                                           String msgBundleName, String msgKey, Serializable[] parms, String className) {
<span class="fc" id="L617">        ValidationResult result = getValidationResult(msgBundleName, msgKey, parms, className, true);</span>
<span class="fc" id="L618">        validatable.addValidationResult(result);</span>
<span class="fc" id="L619">        return result;</span>
    }


    /*public static ValidationResult getFirstValidationResult(Validatable validatable)
     {
         if ( validatable.getValidationResults() != null &amp;&amp; !validatable.getValidationResults().isEmpty() )
             return (ValidationResult) validatable.getValidationResults().iterator().next();

         return null;
     }*/

    public static String dumpEnterValidateMethod(Class validClass, Validatable val) {
<span class="nc" id="L632">        return &quot;ENTER: &quot; + validClass.getName() + &quot;.validate(&quot; + val + &quot;)&quot;;</span>
    }

    public static String dumpExitValidateMethod(Class validClass) {
<span class="nc" id="L636">        return &quot;EXIT: &quot; + validClass.getName() + &quot;.validate()&quot;;</span>
    }
    /**
     * Construct a ValidationResult.
     * @param bundle the base name of the resource bundle that contains the
     * translatable text for this message.
     * @param msgKey the resource name of the translatable text in the bundle.
     * @param parms an array of Serializable objects used to fill in parameters
     * in the message.
     * that produced this result.  Typically, this will be the fully qualified
     * classname of the validator.
     * @param isSoft true if this is a soft validation, false otherwise
     */
    public static ValidationResult getValidationResult(String bundle, String msgKey, Serializable[] parms, String className, boolean isSoft) {
<span class="fc" id="L650">        ValidationResult result = new ValidationResult(className, isSoft);</span>
<span class="fc" id="L651">        result.setMessage(bundle, msgKey, parms);</span>
<span class="fc" id="L652">        return result;</span>
    }


    public static Collection getSchedulingPeriods(Collection spIDs) throws Exception {
<span class="nc" id="L657">        return RequestUtil.getSchedulingPeriod(spIDs);</span>
    }

    /**
     * Get all of an employee's work patterns (a map of ShiftPatternID-&gt;ShiftPattern) for a particular date range.
     * We consider Rotations and non-Rotation work pattern assignments.
     */
    public static HashMap getEmpWorkPatterns(EmpWorkRuleManager empWorkRuleManager, WorkRuleManager workRuleManager, ID empID,
                                             Date fromDate, Date toDate) throws RemoteException, BbmFinderException
    {
<span class="nc" id="L667">        HashMap shiftPatterns = new HashMap();</span>
<span class="nc" id="L668">        HashSet colWorkPatternIDs = new HashSet();</span>
<span class="nc" id="L669">        boolean hasRotationShiftPattern = false;</span>
<span class="nc" id="L670">        HashMap mapEmpRotationAssignments = empWorkRuleManager.getRotationAssignments(Collections.singletonList(empID)); //key = employee ID, value = collection of rotation assignments</span>
<span class="nc bnc" id="L671" title="All 4 branches missed.">        if (mapEmpRotationAssignments != null &amp;&amp; !mapEmpRotationAssignments.isEmpty())</span>
        {
<span class="nc" id="L673">            Collection rotations = (Collection)mapEmpRotationAssignments.get(empID);</span>
<span class="nc bnc" id="L674" title="All 4 branches missed.">            if (rotations != null &amp;&amp; !rotations.isEmpty())</span>
            {
<span class="nc bnc" id="L676" title="All 2 branches missed.">                for (Iterator rotIt=rotations.iterator(); rotIt.hasNext();)</span>
                {
<span class="nc" id="L678">                    WorkResourceRotation wrr = (WorkResourceRotation)rotIt.next();</span>
<span class="nc" id="L679">                    ShiftPattern pPattern = ShiftsUtil.getRotationShiftPatternForTheWeek(wrr, fromDate);</span>
<span class="nc" id="L680">                    shiftPatterns.put(pPattern.getID(), pPattern);</span>
<span class="nc" id="L681">                    hasRotationShiftPattern = true;</span>
<span class="nc" id="L682">                }</span>
            }
        }

<span class="nc bnc" id="L686" title="All 2 branches missed.">        if (!hasRotationShiftPattern)</span>
        {
            //Get all of the employee's workPatternIDs on the asOfDate (SHIFTPATTERNWORKRESOURCE)
<span class="nc" id="L689">            Collection colAssignments = empWorkRuleManager.getWorkPatternAssignmentsForEmployee(empID, fromDate, toDate);</span>
<span class="nc" id="L690">            WorkResourceWorkPattern ww= null;</span>
<span class="nc bnc" id="L691" title="All 4 branches missed.">            if (colAssignments != null &amp;&amp; !colAssignments.isEmpty())</span>
            {
<span class="nc bnc" id="L693" title="All 2 branches missed.">                for (Iterator ix = colAssignments.iterator(); ix.hasNext(); )</span>
                {
<span class="nc" id="L695">                    ww= (WorkResourceWorkPattern)ix.next();</span>
<span class="nc" id="L696">                    colWorkPatternIDs.add(ww.getWorkPatternSID());</span>
                }
            }

<span class="nc bnc" id="L700" title="All 2 branches missed.">            if (!colWorkPatternIDs.isEmpty())</span>
            {
<span class="nc" id="L702">                shiftPatterns = ValueObjectUtil.getIDObjectMap(workRuleManager.getShiftPatternsByIDs(colWorkPatternIDs));</span>
            }
        }

<span class="nc" id="L706">        return shiftPatterns;</span>
    }

	/**
	 * Get the request start and end dates, given the timeRange segments in the request.
	 * @param trCol - The timeRange segments for the reuqest. They must be in chronological order.
	 * @return A TimeRange of the request start and end dates.
	 */
	public static TimeRange getRequestDateRange(List&lt;TimeRange&gt; trCol)
	{
<span class="nc" id="L716">		Date requestStartDate = null;</span>
<span class="nc" id="L717">		Date requestEndDate = null;</span>
<span class="nc" id="L718">		boolean isFirst =  true;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">		for (TimeRange tr : trCol)</span>
		{
<span class="nc bnc" id="L721" title="All 2 branches missed.">			if (isFirst)</span>
			{
<span class="nc" id="L723">				requestStartDate = tr.getStartDate();</span>
<span class="nc" id="L724">				isFirst = false;</span>
			}

<span class="nc" id="L727">			requestEndDate = tr.getEndDate();</span>
<span class="nc" id="L728">		}</span>
<span class="nc" id="L729">		return new TimeRange(requestStartDate, requestEndDate);</span>
	}

	/**
	 * Determines if the given date falls within one of the given TimeRange's.
	 */
	public static boolean isValidInterval(Date curIntervalStart, List&lt;TimeRange&gt; trCol)
	{
<span class="nc bnc" id="L737" title="All 2 branches missed.">		for (TimeRange tr : trCol)</span>
		{
<span class="nc bnc" id="L739" title="All 4 branches missed.">			if (!curIntervalStart.before(tr.getStartDate()) &amp;&amp; curIntervalStart.before(tr.getEndDate()))</span>
			{
<span class="nc" id="L741">				return true;</span>
			}
<span class="nc" id="L743">		}</span>
<span class="nc" id="L744">		return false;</span>
	}

	/**
	 * Get a HashMap of SPQueue mapped to the FTE Differential value for the specified date range.
	 * If the value is below the threshold, we return 0.
	 * @param fromDate
	 * @param toDate
	 * @param cubeCacheKey - the unique identifier for this NetStaffingCube. It will be used for caching aggregations in the ValidationCache.
	 * @return
	 */
	public static HashMap&lt;SPQueue, Double&gt; getFTEDPastThreshold(NetStaffingCube nsCube, Date fromDate, Date toDate, String cubeCacheKey, ValidationCache cache)
	{
<span class="nc" id="L757">		HashMap&lt;SPQueue, Double&gt; netStaffMap = new HashMap();</span>

<span class="nc" id="L759">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L760">		cal.setTime(fromDate);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		while (toDate.after(cal.getTime()))</span>
		{
<span class="nc bnc" id="L763" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; iterator = nsCube.getPredictTraceCubeMap().keySet().iterator(); iterator.hasNext();)</span>
			{
<span class="nc" id="L765">				ID spQID = iterator.next();</span>
<span class="nc" id="L766">				PredictTraceCube pCube = nsCube.getPredictTraceCubeMap().get(spQID);</span>
<span class="nc bnc" id="L767" title="All 2 branches missed.">				if (!pCube.fallsIn(cal.getTime())) {</span>
<span class="nc" id="L768">					continue;</span>
				}
<span class="nc" id="L770">				RequireTraceCube rCube = nsCube.getRequireTraceCubeMap().get(spQID);</span>
<span class="nc" id="L771">				SPQueue spQueue = nsCube.getSPQueueMap().get(spQID);</span>
<span class="nc" id="L772">				Campaign camp = nsCube.getCampaignMap().get(spQID);</span>
<span class="nc" id="L773">				TimeRange range = nsCube.snapDate(camp, pCube, spQueue, cal.getTime());</span>
				
<span class="nc bnc" id="L775" title="All 2 branches missed.">				if (range.getStartDate().equals(range.getEndDate())) {</span>
<span class="nc" id="L776">					continue;</span>
				}

<span class="nc" id="L779">				int pStartAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L780">				int pEndAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L781">				int rStartAbsOffset = rCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L782">				int rEndAbsOffset = rCube.getTimeOffset(range.getEndDate());</span>

<span class="nc" id="L784">				double cForFTE = cache.aggregatePeriodD(pCube, cubeCacheKey+&quot;_FOR&quot;, Trace.AFTE, pStartAbsOffset, pEndAbsOffset);</span>
<span class="nc" id="L785">				double cReqFTE = cache.aggregatePeriodD(rCube, cubeCacheKey+&quot;_REQ&quot;, Trace.FTE, rStartAbsOffset, rEndAbsOffset);</span>

<span class="nc" id="L787">				double fted = nsCube.getFTEDPastThreshold(cForFTE, cReqFTE, spQueue);</span>

<span class="nc" id="L789">				netStaffMap.put(spQueue, fted);</span>
<span class="nc" id="L790">			}</span>

<span class="nc" id="L792">			Date stDate = cal.getTime();</span>
<span class="nc" id="L793">			cal.add(Calendar.MINUTE, Trace.INTERVAL); //add 15 minutes every time regardless of LTI</span>
<span class="nc" id="L794">			Date enDate = cal.getTime();</span>
<span class="nc" id="L795">			TimeRange range = new TimeRange(stDate, enDate);</span>
<span class="nc" id="L796">		}</span>
<span class="nc" id="L797">		return netStaffMap;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>