<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeIntervalManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timerecord.ejb</a> &gt; <span class="el_source">TimeIntervalManagerEJB.java</span></div><h1>TimeIntervalManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timerecord.ejb;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.jdmo.JdmoDuplicateKeyException;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.Priority;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.ActivityFilter;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.paypolicy.ejb.PayPeriodTypeManager;
import com.bluepumpkin.ejb.bbm.paypolicy.ejb.PayPolicyManager;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPeriod;
import com.bluepumpkin.ejb.bbm.paypolicy.model.PayPolicy;
import com.bluepumpkin.ejb.bbm.payroll.util.RulesTimeSpan;
import com.bluepumpkin.ejb.bbm.payroll.util.StateChange;
import com.bluepumpkin.ejb.bbm.payroll.util.TimeSpanNarrower;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ImportedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.util.SimpleTimeOff;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeInterval;
import com.bluepumpkin.ejb.bbm.timerecord.model.TimeRecord;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourcePayPolicy;
import com.bluepumpkin.ejb.bbm.workrules.model.WorkRuleUtil;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;

/**
 * Title: Blue Pumpkin Software Basic Business Model
 * Description: TimeIntervalManager EJB implementation
 * Copyright: Copyright (c) 2001
 * Company: Blue Pumpkin Software, Inc
 * &lt;p&gt;
 * @author Sheng Song
 * @version 1.0
 */
<span class="nc" id="L58">public class TimeIntervalManagerEJB</span>
		extends SessionEJBBase {
	private static final long serialVersionUID = 1L;
<span class="nc" id="L61">	private static final Category m_cat = Log.initCategory(TimeIntervalManagerEJB.class.getName());</span>
	private PayPeriodTypeManager m_PayPeriodTypeManager;
	private WorkResourceManager m_WorkResourceManager;
	private PayPolicyManager m_PayPolicyManager;
	private ActivityManager m_ActivityManager;
<span class="nc" id="L66">	private static final TimeZone m_gmtTZ = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
	private int m_Overlap;
	// internal caches for individual value objects
	public HashMap m_PayPolicy;
	public HashSet m_OrganizationSet;
	// internal caches for association value objects
	public HashMap m_EmpPayPolicy;
	public HashMap m_EmpOrganization;

	{
<span class="nc" id="L76">		super.init(TimeIntervalManagerEJB.class.getName());</span>
<span class="nc" id="L77">	}</span>

	// override the base class to provide the appropriate logging category
	@Override
	protected Category getCategory() {
<span class="nc" id="L82">		return m_cat;</span>
	}

	@Override
	public void ejbCreate() {
		try {
<span class="nc" id="L88">			m_PayPeriodTypeManager = BbmManagerFactory.getPayPeriodTypeManager();</span>
<span class="nc" id="L89">			m_WorkResourceManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L90">			m_PayPolicyManager = BbmManagerFactory.getPayPolicyManager();</span>
<span class="nc" id="L91">			m_ActivityManager = WfmManagerFactory.getActivityManager();</span>
<span class="nc" id="L92">			DBConfigManager dbcm = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L93">			m_Overlap = dbcm.getPeriodOverlap();</span>
<span class="nc" id="L94">			m_PayPolicy = new HashMap();</span>
<span class="nc" id="L95">			m_OrganizationSet = new HashSet();</span>
<span class="nc" id="L96">			m_EmpPayPolicy = new HashMap();</span>
<span class="nc" id="L97">			m_EmpOrganization = new HashMap();</span>
<span class="nc" id="L98">		} catch (Exception e) {</span>
<span class="nc" id="L99">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="nc" id="L100">		}</span>

<span class="nc" id="L102">	}</span>

	public Collection createTimeIntervalForHoliday(Collection empCol, ID activity, boolean isPaid, ID payPeriodID, boolean autoApprove, boolean overrideHistory, String memo)
			throws BbmCreateException {
<span class="nc" id="L106">		return createTimeIntervalForHoliday(empCol, activity, isPaid, payPeriodID, autoApprove, overrideHistory, memo, m_sessionContext.getCallerPrincipal().getName());</span>
	}

	/**
	 * For auto-create TimeInterval for a Collection of Employees, will query the holiday definition from DB, and use the given activity.
	 * &lt;p&gt;
	 * @param empCol a collection of employee IDs
	 * @param activity a mapped activity ID
	 * @param isPaid the TimeInterval is payable
	 * @param payPeriodID a pay period id
	 * @param autoApprove auto approve the timeinterval
	 * @param overrideHistory override historical record with same activity
	 * @param memo a description of the time record
	 * @param approverName Approver Employee Name, if not provided, will defaults to EJB caller name
	 * &lt;p&gt;
	 * @return
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeIntervalForHoliday(Collection empCol, ID activity, boolean isPaid, ID payPeriodID, boolean autoApprove, boolean overrideHistory,
			String memo, String approverName)
			throws BbmCreateException {
<span class="nc" id="L128">		methodStart(&quot;createTimeIntervalForHoliday&quot;, empCol, activity, payPeriodID, JdmoParam.getObject(overrideHistory));</span>
		try {
<span class="nc bnc" id="L130" title="All 4 branches missed.">			if (empCol == null || empCol.isEmpty()) {</span>
<span class="nc" id="L131">				return Collections.EMPTY_LIST;</span>
			}
			// Clear up all the four HashMaps
<span class="nc" id="L134">			clearUp();</span>
<span class="nc" id="L135">			ArrayList array = new ArrayList(empCol.size());</span>
			// Load the PayPeriod first
<span class="nc" id="L137">			PayPeriod payPeriod = m_PayPeriodTypeManager.getPayPeriod(payPeriodID);</span>
			// Caching the payperiod start/end date
<span class="nc" id="L139">			LocalDate ppStart = payPeriod.getStartDate();</span>
<span class="nc" id="L140">			LocalDate ppEnd = payPeriod.getEndDate();</span>
			// Load necessary orgnizations, paypolicies in batch
<span class="nc" id="L142">			prepare(empCol, payPeriod.getPayPeriodTypeID(), ppStart, ppEnd);</span>
			// If the employees don't have organizations, return empty list
<span class="nc bnc" id="L144" title="All 2 branches missed.">			if (m_OrganizationSet.isEmpty()) {</span>
<span class="nc" id="L145">				return Collections.EMPTY_LIST;</span>
			}
			// Load all the holidays in this period for each organization
//			HolidayManager hm = BbmManagerFactory.getHolidayManager();
<span class="nc" id="L149">			HashMap orgHolidayMap = new HashMap(m_OrganizationSet.size());</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">			for (Iterator it = m_OrganizationSet.iterator(); it.hasNext();) {</span>
<span class="nc" id="L151">				ID orgID = (ID)it.next();</span>
<span class="nc" id="L152">				Collection holiday = null;// hm.getHolidays(orgID, ppStart, ppEnd);</span>
<span class="nc bnc" id="L153" title="All 4 branches missed.">				if (holiday == null || holiday.isEmpty()) {</span>
<span class="nc" id="L154">					continue;</span>
				}
<span class="nc" id="L156">				orgHolidayMap.put(orgID, holiday);</span>
<span class="nc" id="L157">			}</span>
			// If there is no holiday definition, return immediately
<span class="nc bnc" id="L159" title="All 2 branches missed.">			if (orgHolidayMap.isEmpty()) {</span>
<span class="nc" id="L160">				return Collections.EMPTY_LIST;</span>
			}
			// Set current date for all Time Intervals
<span class="nc" id="L163">			Date curTime = new Date();</span>
			// if approver name is needed and not passed in, use EJB caller name
<span class="nc bnc" id="L165" title="All 4 branches missed.">			if (autoApprove &amp;&amp; approverName == null) {</span>
<span class="nc" id="L166">				approverName = m_sessionContext.getCallerPrincipal().getName();</span>
			}
			// Iterate each employee
<span class="nc bnc" id="L169" title="All 2 branches missed.">			for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L170">				ID wrkID = (ID)it.next();</span>
<span class="nc" id="L171">				ArrayList idArray = new ArrayList(1);</span>
<span class="nc" id="L172">				Collection wraCol = (Collection)m_EmpOrganization.get(wrkID);</span>
<span class="nc" id="L173">				Collection wrpCol = (Collection)m_EmpPayPolicy.get(wrkID);</span>
				// If the employee has no paypolicy/orgnization, skip
<span class="nc bnc" id="L175" title="All 8 branches missed.">				if (wraCol == null || wraCol.isEmpty() || wrpCol == null || wrpCol.isEmpty()) {</span>
<span class="nc" id="L176">					continue;</span>
				}
<span class="nc bnc" id="L178" title="All 2 branches missed.">				for (Iterator wraIT = wraCol.iterator(); wraIT.hasNext();) {</span>
<span class="nc" id="L179">					WorkResourceAssignment wra = (WorkResourceAssignment)wraIT.next();</span>
<span class="nc" id="L180">					ID orgID = wra.getOrganizationID();</span>
<span class="nc" id="L181">					TimeZone orgTZ = TimeZone.getTimeZone(wra.getTimeZone());</span>
<span class="nc" id="L182">					Collection holCol = (Collection)orgHolidayMap.get(orgID);</span>
					// If there is no holiday for this org, skip
<span class="nc bnc" id="L184" title="All 4 branches missed.">					if (holCol == null || holCol.isEmpty()) {</span>
<span class="nc" id="L185">						continue;</span>
					}
<span class="nc bnc" id="L187" title="All 2 branches missed.">					for (Iterator holIT = holCol.iterator(); holIT.hasNext();) {</span>
<span class="nc" id="L188">						Holiday hol = (Holiday)holIT.next();</span>
						// Remark Code for spliting holiday into day-by-day series, Holiday start time may be in the middle of a day
//						Date holOrigStart = hol.getStartDate().getTime(orgTZ);
//						Date holOrigEnd = hol.getEndDate().getTime(orgTZ);
<span class="nc" id="L192">						Date holStart = hol.getStartDate().getTime(orgTZ);</span>
<span class="nc" id="L193">						Date holEnd = hol.getEndDate().getTime(orgTZ);</span>
						// First of all will split the holiday into day-by-day
//						Calendar startDay = Calendar.getInstance(orgTZ);
//						startDay.setTime(holOrigStart);
//						boolean finishFlag = false;
//						while (!finishFlag) {
						// Cache the start
//							Date holStart = startDay.getTime();
						// Add one day
//							startDay.add(Calendar.DATE, 1);
						// Get the next day
//							Date holEnd = startDay.getTime();
						// Adjust next day, and check if need stop
//							if (!holEnd.before(holOrigEnd)) {
//								holEnd = holOrigEnd;
//								finishFlag = true;
//							}
						// Rule1: we only calculate a full holiday if the user transit org during the holiday he/she won't get it, this prevents double credit
						// Use the Falls-in Rule to determine if the holiday belongs to the period or not
<span class="nc bnc" id="L212" title="All 2 branches missed.">						if (WorkRuleUtil.isInPeriod(holStart, holEnd, wra.getStartTime(), wra.getEndTime(), m_Overlap)) {</span>
							// Rule2: for that period, picks the paypolicy if there are paypolicy transition, pick the first if the paypolicy of the first is not using the
							// payperiodtype, then skip
<span class="nc" id="L215">							PayPolicy pp = getPayPolicy(wrpCol, holStart, holEnd);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">							if (pp == null) {</span>
<span class="nc" id="L217">								continue;</span>
							}
							try {
								// If need clean up historical TimeRecords
<span class="nc bnc" id="L221" title="All 2 branches missed.">								if (overrideHistory) {</span>
<span class="nc" id="L222">									TimeRecordDAO.removeTimeInterval(wrkID, TimeInterval.HOLIDAY, null, TimeZoneUtil.toTimestamp(holStart), TimeZoneUtil.toTimestamp(holEnd),</span>
											m_Overlap);
								} else {
									// If there is TimeInterval in the period with same Activity skip
<span class="nc bnc" id="L226" title="All 2 branches missed.">									if (TimeRecordDAO.checkExistingTimeInterval(wrkID, activity, TimeZoneUtil.toTimestamp(holStart), TimeZoneUtil.toTimestamp(holEnd))) {</span>
<span class="nc" id="L227">										continue;</span>
									}
								}
								// One TimeInterval per Holiday-Day
<span class="nc" id="L231">								TimeRecord record = new TimeRecord(wrkID);</span>
<span class="nc" id="L232">								TimeInterval interval = new TimeInterval(activity, holStart, holEnd, pp.getDailyDefaultPaidMinutes(), TimeInterval.HOLIDAY, isPaid, null);</span>
<span class="nc" id="L233">								record.addChild(interval);</span>
<span class="nc" id="L234">								record.setApprove(autoApprove);</span>
<span class="nc" id="L235">								record.setDescription(memo);</span>
<span class="nc" id="L236">								record.setLastModifiedTime(curTime);</span>
<span class="nc" id="L237">								record.setApproverName(approverName);</span>
<span class="nc" id="L238">								ID id = TimeRecordDAO.createTimeInterval(record);</span>
<span class="nc" id="L239">								idArray.add(id);</span>
<span class="nc" id="L240">							} catch (JdmoDuplicateKeyException e) {</span>
								// If there is JdmoDuplicateKeyException, which means the create failed due to constraints issue, the program should continue execution
<span class="nc" id="L242">								handleException(e, false);</span>
<span class="nc" id="L243">							}</span>
						}
<span class="nc" id="L245">					}</span>
<span class="nc" id="L246">				}</span>
				// Add the array of IDs to the overall array
<span class="nc" id="L248">				array.add(idArray);</span>
<span class="nc" id="L249">			}</span>
<span class="nc" id="L250">			return array;</span>
<span class="nc" id="L251">		} catch (Exception e) {</span>
<span class="nc" id="L252">			handleException(e);</span>
<span class="nc" id="L253">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L255">			methodFinish();</span>
		}
	}

	/**
	 *
	 * @param empCol
	 * @param activityCol
	 * @param isPaidCol
	 * @param payPeriodID
	 * @param autoApprove
	 * @param overrideHistory
	 * @param memo
	 * &lt;p&gt;
	 * @return
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeIntervalForSchedule(Collection empCol, Collection activityCol, Collection isPaidCol, ID payPeriodID, boolean autoApprove,
			boolean overrideHistory, String memo)
			throws BbmCreateException {
<span class="nc" id="L276">		return createTimeIntervalForSchedule(empCol, activityCol, isPaidCol, payPeriodID, autoApprove, overrideHistory, memo, m_sessionContext.getCallerPrincipal().getName());</span>
	}

	/**
	 * For auto-create TimeInterval for a Collection of Employees, will query the Schedule for ImportedEvents, and convert those having the given activity
	 * IDs to TimeIntervals.
	 * &lt;p&gt;
	 * @param empCol a collection of employee IDs
	 * @param activityCol activity in the schedule that will be converted
	 * @param isPaidCol a collection of the isPaid attributes of each activity
	 * @param payPeriodID a pay period ID
	 * @param autoApprove auto-approve the time interval
	 * @param overrideHistory override historical record with same activity
	 * @param memo a description for the time record
	 * @param approverName an approver name
	 * &lt;p&gt;
	 * @return a collection of collections of new time intervals IDs
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeIntervalForSchedule(Collection empCol, Collection activityCol, Collection isPaidCol, ID payPeriodID, boolean autoApprove,
			boolean overrideHistory, String memo, String approverName)
			throws BbmCreateException {
<span class="nc" id="L299">		methodStart(&quot;createTimeIntervalForSchedule&quot;, empCol, activityCol, payPeriodID, JdmoParam.getObject(overrideHistory));</span>
		try {
<span class="nc bnc" id="L301" title="All 12 branches missed.">			if (empCol == null || empCol.isEmpty() || activityCol == null || activityCol.isEmpty() || isPaidCol == null || isPaidCol.isEmpty()</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">					|| activityCol.size() != isPaidCol.size()) {</span>
<span class="nc" id="L303">				return Collections.EMPTY_LIST;</span>
			}
			// Set current date for all Time Intervals
<span class="nc" id="L306">			Date curTime = new Date();</span>
			// if approver name is needed and not passed in, use EJB caller name
<span class="nc bnc" id="L308" title="All 4 branches missed.">			if (autoApprove &amp;&amp; approverName == null) {</span>
<span class="nc" id="L309">				approverName = m_sessionContext.getCallerPrincipal().getName();</span>
			}
			// Clear up all the four HashMaps
<span class="nc" id="L312">			clearUp();</span>
<span class="nc" id="L313">			int empSize = empCol.size();</span>
<span class="nc" id="L314">			ArrayList array = new ArrayList(empSize);</span>
			// Load the PayPeriod first
<span class="nc" id="L316">			PayPeriod payPeriod = m_PayPeriodTypeManager.getPayPeriod(payPeriodID);</span>
			// Caching the payperiod start/end date
<span class="nc" id="L318">			LocalDate ppStart = payPeriod.getStartDate();</span>
<span class="nc" id="L319">			LocalDate ppEnd = payPeriod.getEndDate();</span>
<span class="nc" id="L320">			ID payPeriodTypeID = payPeriod.getPayPeriodTypeID();</span>
			// Load necessary orgnizations, paypolicies in batch
<span class="nc" id="L322">			prepare(empCol, payPeriodTypeID, ppStart, ppEnd);</span>
			// Convert Activity Collection/IsPaid Collection to HashMap
<span class="nc" id="L324">			HashMap activityMap = new HashMap(activityCol.size());</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			for (Iterator it1 = activityCol.iterator(), it2 = isPaidCol.iterator(); it1.hasNext();) {</span>
<span class="nc" id="L326">				activityMap.put(it1.next(), it2.next());</span>
			}
			// Expand the LocalDate window to load schedules in batch
<span class="nc" id="L329">			ppStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L330">			ppEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L331">			Date dtStart = ppStart.getTime(m_gmtTZ);</span>
<span class="nc" id="L332">			Date dtEnd = ppEnd.getTime(m_gmtTZ);</span>
<span class="nc" id="L333">			ppStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L334">			ppEnd.add(Calendar.DATE, -1);</span>
<span class="nc" id="L335">			ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">			for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L337">				ID wrkID = (ID)it.next();</span>
<span class="nc" id="L338">				Collection wraCol = (Collection)m_EmpOrganization.get(wrkID);</span>
<span class="nc" id="L339">				Collection wppCol = (Collection)m_EmpPayPolicy.get(wrkID);</span>
<span class="nc bnc" id="L340" title="All 8 branches missed.">				if (wraCol == null || wraCol.isEmpty() || wppCol == null || wppCol.isEmpty()) {</span>
<span class="nc" id="L341">					continue;</span>
				}
<span class="nc" id="L343">				Collection timespan = TimeSpanNarrower.payrollNarrower(wraCol, wppCol, m_PayPolicy, null, null, payPeriodTypeID);</span>
				// If one employee fails to retrieve schedule,  continue for others
<span class="nc" id="L345">				Collection scheduleCol = null;</span>
				try {
<span class="nc" id="L347">					Collection rawScheduleCol = sam.getPublishedEventsForWorkResource(wrkID, dtStart, dtEnd);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">					if (rawScheduleCol != null) {</span>
<span class="nc" id="L349">						scheduleCol = SimpleTimeOff.getSimpleTimeOffEvents(rawScheduleCol);</span>
					}
<span class="nc" id="L351">				} catch (Exception e) {</span>
<span class="nc" id="L352">					m_cat.error(&quot;createTimeIntervalForSchedule&quot;, e);</span>
<span class="nc" id="L353">					continue;</span>
<span class="nc" id="L354">				}</span>

<span class="nc bnc" id="L356" title="All 4 branches missed.">				if (scheduleCol == null || scheduleCol.isEmpty()) {</span>
<span class="nc" id="L357">					continue;</span>
				}
				// Additional step to filter based on activities
<span class="nc bnc" id="L360" title="All 2 branches missed.">				for (Iterator itSch = scheduleCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L361">					Event iEvent = (Event)itSch.next();</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">					if (!activityCol.contains(iEvent.getActivityID())) {</span>
<span class="nc" id="L363">						it.remove();</span>
					}
<span class="nc" id="L365">				}</span>

<span class="nc" id="L367">				ArrayList empTimeCol = new ArrayList(scheduleCol.size());</span>
<span class="nc bnc" id="L368" title="All 2 branches missed.">				for (Iterator itSpan = timespan.iterator(); itSpan.hasNext();) {</span>
<span class="nc" id="L369">					RulesTimeSpan span = (RulesTimeSpan)itSpan.next();</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">					if (overrideHistory) {</span>
<span class="nc" id="L371">						TimeRecordDAO.removeTimeInterval(wrkID, TimeInterval.SCHEDULE, activityCol, TimeZoneUtil.toTimestamp(span.getStartDate()),</span>
<span class="nc" id="L372">								TimeZoneUtil.toTimestamp(span.getEndDate()), m_Overlap);</span>
					}

<span class="nc bnc" id="L375" title="All 2 branches missed.">					for (Iterator itSch = scheduleCol.iterator(); itSch.hasNext();) {</span>
<span class="nc" id="L376">						Event iEvent = (Event)itSch.next();</span>
						// Now only in ImportedEvent/TimeOffEvent, there is definition for count towards minutes
<span class="nc bnc" id="L378" title="All 4 branches missed.">						if (!(iEvent instanceof ImportedEvent || iEvent instanceof TimeOffEvent)) {</span>
<span class="nc" id="L379">							continue;</span>
						}

<span class="nc bnc" id="L382" title="All 2 branches missed.">						if (WorkRuleUtil.isInPeriod(iEvent.getStartTime(), iEvent.getEndTime(), span.getStartDate(), span.getEndDate(), m_Overlap)) {</span>
<span class="nc" id="L383">							ID actID = iEvent.getActivityID();</span>
<span class="nc" id="L384">							Boolean isPaid = (Boolean)activityMap.get(actID);</span>
							// If there is TimeInterval in the period with same Activity skip
<span class="nc bnc" id="L386" title="All 4 branches missed.">							if (!overrideHistory &amp;&amp; TimeRecordDAO.checkExistingTimeInterval(wrkID, actID, TimeZoneUtil.toTimestamp(iEvent.getStartTime()),</span>
<span class="nc" id="L387">									TimeZoneUtil.toTimestamp(iEvent.getEndTime()))) {</span>
<span class="nc" id="L388">								continue;</span>
							}
<span class="nc" id="L390">							TimeRecord record = new TimeRecord(wrkID);</span>
<span class="nc" id="L391">							TimeInterval interval = null;</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">							if (iEvent instanceof ImportedEvent) {</span>
<span class="nc bnc" id="L393" title="All 2 branches missed.">								interval = new TimeInterval(actID, iEvent.getStartTime(), iEvent.getEndTime(), (((ImportedEvent)iEvent)).getMinsTowardsMinMax(),</span>
<span class="nc" id="L394">										TimeInterval.SCHEDULE, isPaid == null ? false : isPaid, null);</span>
							} else {
<span class="nc bnc" id="L396" title="All 2 branches missed.">								interval = new TimeInterval(actID, iEvent.getStartTime(), iEvent.getEndTime(), (((TimeOffEvent)iEvent)).getCountsMinutesTowardsRules(),</span>
<span class="nc" id="L397">										TimeInterval.SCHEDULE, isPaid == null ? false : isPaid, null);</span>
							}
<span class="nc" id="L399">							record.addChild(interval);</span>
<span class="nc" id="L400">							record.setApprove(autoApprove);</span>
<span class="nc" id="L401">							record.setDescription(memo);</span>
<span class="nc" id="L402">							record.setLastModifiedTime(curTime);</span>
<span class="nc" id="L403">							record.setApproverName(approverName);</span>
<span class="nc" id="L404">							ID trID = TimeRecordDAO.createTimeInterval(record);</span>
<span class="nc" id="L405">							empTimeCol.add(trID);</span>
						}
<span class="nc" id="L407">					}</span>
<span class="nc" id="L408">				}</span>
				// Add the created IDs into the ArrayList
<span class="nc" id="L410">				array.add(empTimeCol);</span>
<span class="nc" id="L411">			}</span>
<span class="nc" id="L412">			return array;</span>
<span class="nc" id="L413">		} catch (Exception e) {</span>
<span class="nc" id="L414">			handleException(e);</span>
<span class="nc" id="L415">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L417">			methodFinish();</span>
		}
	}

	/**
	 *
	 * @param empCol
	 * @param payPeriodID
	 * @param autoApprove
	 * @param overrideHistory
	 * @param memo
	 * &lt;p&gt;
	 * @return a collection of collections of new time intervals IDs
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeIntervalForSchedule(Collection empCol, ID payPeriodID, boolean autoApprove, boolean overrideHistory, String memo)
			throws BbmCreateException {
<span class="nc" id="L435">		return createTimeIntervalForSchedule(empCol, payPeriodID, autoApprove, overrideHistory, memo, m_sessionContext.getCallerPrincipal().getName());</span>
	}

	/**
	 * For auto-create TimeInterval for a collection of employees, will query the Schedule for ImportedEvents, and convert those having the given
	 * activity IDs to TimeIntervals.
	 * &lt;p&gt;
	 * @param empCol a collection of employee IDs
	 * @param payPeriodID a pay period ID
	 * @param autoApprove auto-approve the time interval
	 * @param overrideHistory override historical record with same activity
	 * @param memo a description for the time record
	 * @param approverName an approver name
	 * &lt;p&gt;
	 * @return a collection of collections of new time intervals IDs
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeIntervalForSchedule(Collection empCol, ID payPeriodID, boolean autoApprove, boolean overrideHistory, String memo, String approverName)
			throws BbmCreateException {
<span class="nc" id="L455">		methodStart(&quot;createTimeIntervalForSchedule&quot;, empCol, payPeriodID, JdmoParam.getObject(overrideHistory));</span>
		try {
<span class="nc bnc" id="L457" title="All 4 branches missed.">			if (empCol == null || empCol.isEmpty()) {</span>
<span class="nc" id="L458">				return Collections.EMPTY_LIST;</span>
			}
			// Only convert timeoff activities
<span class="nc" id="L461">			ActivityFilter activityFilter = new ActivityFilter();</span>
<span class="nc" id="L462">			activityFilter.setTimeoff(true);</span>
<span class="nc" id="L463">			Collection activityCol = m_ActivityManager.findActivitiesIds(activityFilter);</span>
<span class="nc bnc" id="L464" title="All 4 branches missed.">			if (activityCol == null || activityCol.isEmpty()) {</span>
<span class="nc" id="L465">				return Collections.EMPTY_LIST;</span>
			}
			// Set current date for all Time Intervals
<span class="nc" id="L468">			Date curTime = new Date();</span>
			// if approver name is needed and not passed in, use EJB caller name
<span class="nc bnc" id="L470" title="All 4 branches missed.">			if (autoApprove &amp;&amp; approverName == null) {</span>
<span class="nc" id="L471">				approverName = m_sessionContext.getCallerPrincipal().getName();</span>
			}
			// Clear up all the four HashMaps
<span class="nc" id="L474">			clearUp();</span>
<span class="nc" id="L475">			int empSize = empCol.size();</span>
<span class="nc" id="L476">			ArrayList array = new ArrayList(empSize);</span>
			// Load the PayPeriod first
<span class="nc" id="L478">			PayPeriod payPeriod = m_PayPeriodTypeManager.getPayPeriod(payPeriodID);</span>
			// Caching the payperiod start/end date
<span class="nc" id="L480">			LocalDate ppStart = payPeriod.getStartDate();</span>
<span class="nc" id="L481">			LocalDate ppEnd = payPeriod.getEndDate();</span>
<span class="nc" id="L482">			ID payPeriodTypeID = payPeriod.getPayPeriodTypeID();</span>
			// Load necessary orgnizations, paypolicies in batch
<span class="nc" id="L484">			prepare(empCol, payPeriodTypeID, ppStart, ppEnd);</span>
			// Expand the LocalDate window to load schedules in batch
<span class="nc" id="L486">			ppStart.add(Calendar.DATE, -1);</span>
<span class="nc" id="L487">			ppEnd.add(Calendar.DATE, 1);</span>
<span class="nc" id="L488">			Date dtStart = ppStart.getTime(m_gmtTZ);</span>
<span class="nc" id="L489">			Date dtEnd = ppEnd.getTime(m_gmtTZ);</span>
<span class="nc" id="L490">			ppStart.add(Calendar.DATE, 1);</span>
<span class="nc" id="L491">			ppEnd.add(Calendar.DATE, -1);</span>
<span class="nc" id="L492">			ScheduleAccessManager sam = WfmManagerFactory.getScheduleAccessManager();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">			for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L494">				ID wrkID = (ID)it.next();</span>
<span class="nc" id="L495">				Collection wraCol = (Collection)m_EmpOrganization.get(wrkID);</span>
<span class="nc" id="L496">				Collection wppCol = (Collection)m_EmpPayPolicy.get(wrkID);</span>
<span class="nc bnc" id="L497" title="All 8 branches missed.">				if (wraCol == null || wraCol.isEmpty() || wppCol == null || wppCol.isEmpty()) {</span>
<span class="nc" id="L498">					continue;</span>
				}
<span class="nc" id="L500">				Collection timespan = TimeSpanNarrower.payrollNarrower(wraCol, wppCol, m_PayPolicy, null, null, payPeriodTypeID);</span>
				// If one employee fails to retrieve schedule, continue for others
<span class="nc" id="L502">				Collection scheduleCol = null;</span>
				try {
<span class="nc" id="L504">					Collection rawScheduleCol = sam.getPublishedEventsForWorkResource(wrkID, dtStart, dtEnd);</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">					if (rawScheduleCol != null) {</span>
<span class="nc" id="L506">						scheduleCol = SimpleTimeOff.getSimpleTimeOffEvents(rawScheduleCol);</span>
					}
<span class="nc" id="L508">				} catch (Exception e) {</span>
<span class="nc" id="L509">					m_cat.error(&quot;createTimeIntervalForSchedule&quot;, e);</span>
<span class="nc" id="L510">					continue;</span>
<span class="nc" id="L511">				}</span>

<span class="nc bnc" id="L513" title="All 4 branches missed.">				if (scheduleCol == null || scheduleCol.isEmpty()) {</span>
<span class="nc" id="L514">					continue;</span>
				}
				// Additional step to filter based on activities
<span class="nc bnc" id="L517" title="All 2 branches missed.">				for (Iterator itSch = scheduleCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L518">					Event iEvent = (Event)itSch.next();</span>
<span class="nc bnc" id="L519" title="All 2 branches missed.">					if (!activityCol.contains(iEvent.getActivityID())) {</span>
<span class="nc" id="L520">						it.remove();</span>
					}
<span class="nc" id="L522">				}</span>

<span class="nc" id="L524">				ArrayList empTimeCol = new ArrayList(scheduleCol.size());</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">				for (Iterator itSpan = timespan.iterator(); itSpan.hasNext();) {</span>
<span class="nc" id="L526">					RulesTimeSpan span = (RulesTimeSpan)itSpan.next();</span>
<span class="nc bnc" id="L527" title="All 2 branches missed.">					if (overrideHistory) {</span>
<span class="nc" id="L528">						TimeRecordDAO.removeTimeInterval(wrkID, TimeInterval.SCHEDULE, activityCol, TimeZoneUtil.toTimestamp(span.getStartDate()),</span>
<span class="nc" id="L529">								TimeZoneUtil.toTimestamp(span.getEndDate()), m_Overlap);</span>
					}
<span class="nc bnc" id="L531" title="All 2 branches missed.">					for (Iterator itSch = scheduleCol.iterator(); itSch.hasNext();) {</span>
<span class="nc" id="L532">						Event iEvent = (Event)itSch.next();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">						if (WorkRuleUtil.isInPeriod(iEvent.getStartTime(), iEvent.getEndTime(), span.getStartDate(), span.getEndDate(), m_Overlap)) {</span>
<span class="nc" id="L534">							ID actID = iEvent.getActivityID();</span>
							// If there is TimeInterval in the period with same Activity skip
<span class="nc bnc" id="L536" title="All 4 branches missed.">							if (!overrideHistory &amp;&amp; TimeRecordDAO.checkExistingTimeInterval(wrkID, actID, TimeZoneUtil.toTimestamp(iEvent.getStartTime()),</span>
<span class="nc" id="L537">									TimeZoneUtil.toTimestamp(iEvent.getEndTime()))) {</span>
<span class="nc" id="L538">								continue;</span>
							}
							// Always create TimeInterval is Paid
<span class="nc" id="L541">							TimeRecord record = new TimeRecord(wrkID);</span>
<span class="nc" id="L542">							TimeInterval interval = null;</span>
<span class="nc bnc" id="L543" title="All 2 branches missed.">							if (iEvent instanceof ImportedEvent) {</span>
<span class="nc" id="L544">								interval = new TimeInterval(actID, iEvent.getStartTime(), iEvent.getEndTime(), (((ImportedEvent)iEvent)).getMinsTowardsMinMax(),</span>
										TimeInterval.SCHEDULE, true, null);
							} else {
<span class="nc" id="L547">								interval = new TimeInterval(actID, iEvent.getStartTime(), iEvent.getEndTime(), (((TimeOffEvent)iEvent)).getCountsMinutesTowardsRules(),</span>
										TimeInterval.SCHEDULE, true, null);
							}
<span class="nc" id="L550">							record.addChild(interval);</span>
<span class="nc" id="L551">							record.setApprove(autoApprove);</span>
<span class="nc" id="L552">							record.setDescription(memo);</span>
<span class="nc" id="L553">							record.setLastModifiedTime(curTime);</span>
<span class="nc" id="L554">							record.setApproverName(approverName);</span>
<span class="nc" id="L555">							ID trID = TimeRecordDAO.createTimeInterval(record);</span>
<span class="nc" id="L556">							empTimeCol.add(trID);</span>
						}
<span class="nc" id="L558">					}</span>
<span class="nc" id="L559">				}</span>
				// Add the created IDs into the ArrayList
<span class="nc" id="L561">				array.add(empTimeCol);</span>
<span class="nc" id="L562">			}</span>
<span class="nc" id="L563">			return array;</span>
<span class="nc" id="L564">		} catch (Exception e) {</span>
<span class="nc" id="L565">			handleException(e);</span>
<span class="nc" id="L566">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L568">			methodFinish();</span>
		}
	}

	/**
	 *
	 * @param empCol
	 * @param activity
	 * @param isPaid
	 * @param start
	 * @param end
	 * @param countTowards
	 * @param autoApprove
	 * @param overrideHistory
	 * @param memo
	 * &lt;p&gt;
	 * @return
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeInterval(Collection empCol, ID activity, boolean isPaid, LocalDate start, LocalDate end, int countTowards, boolean autoApprove,
			boolean overrideHistory, String memo)
			throws BbmCreateException {
<span class="nc" id="L591">		return createTimeInterval(empCol, activity, isPaid, start, end, countTowards, autoApprove, overrideHistory, memo, m_sessionContext.getCallerPrincipal().getName());</span>
	}

	/**
	 * For auto-create time interval collection of employees, given a time window defined by LocalDate, will check the organization for that time window,
	 * using the first org's timezone to convert the localdate to realdate, create the timeinterval.
	 * &lt;p&gt;
	 * @param empCol a collection of employee IDs
	 * @param activity the activity ID of the time interval
	 * @param isPaid the isPaid attributes of the activity
	 * @param start the start date
	 * @param end the end date
	 * @param countTowards the duration of the time interval
	 * @param autoApprove auto-approve the time interval
	 * @param overrideHistory override historical record with same activity
	 * @param memo a description for the time record
	 * @param approverName an approver name
	 * &lt;p&gt;
	 * @return a collection of employee time record IDs
	 * &lt;p&gt;
	 * @throws BbmCreateException
	 */
	public Collection createTimeInterval(Collection empCol, ID activity, boolean isPaid, LocalDate start, LocalDate end, int countTowards, boolean autoApprove,
			boolean overrideHistory, String memo, String approverName)
			throws BbmCreateException {
<span class="nc" id="L616">		methodStart(&quot;createTimeInterval&quot;, empCol, activity, start.toLogString(), end.toLogString());</span>
		try {
<span class="nc bnc" id="L618" title="All 4 branches missed.">			if (empCol == null || empCol.isEmpty()) {</span>
<span class="nc" id="L619">				return Collections.EMPTY_LIST;</span>
			}
			// Set current date for all Time Intervals
<span class="nc" id="L622">			Date curTime = new Date();</span>
			// if approver name is needed and not passed in, use EJB caller name
<span class="nc bnc" id="L624" title="All 4 branches missed.">			if (autoApprove &amp;&amp; approverName == null) {</span>
<span class="nc" id="L625">				approverName = m_sessionContext.getCallerPrincipal().getName();</span>
			}
<span class="nc" id="L627">			ArrayList array = new ArrayList(empCol.size());</span>
<span class="nc bnc" id="L628" title="All 2 branches missed.">			for (Iterator it = empCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L629">				ID wrkID = (ID)it.next();</span>
				try {
<span class="nc" id="L631">					Collection col = m_WorkResourceManager.getValidWorkResourceAssignments(wrkID, start, end);</span>
<span class="nc bnc" id="L632" title="All 4 branches missed.">					if (col == null || col.isEmpty()) {</span>
<span class="nc" id="L633">						continue;</span>
					}
<span class="nc" id="L635">					WorkResourceAssignment wra = (WorkResourceAssignment)col.iterator().next();</span>
<span class="nc" id="L636">					TimeZone orgTZ = TimeZone.getTimeZone(wra.getTimeZone());</span>
<span class="nc" id="L637">					Collection actCol = new ArrayList(1);</span>
<span class="nc" id="L638">					actCol.add(activity);</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">					if (overrideHistory) {</span>
<span class="nc" id="L640">						TimeRecordDAO.removeTimeInterval(wrkID, 0, actCol, TimeZoneUtil.toTimestamp(start.getTime(orgTZ)), TimeZoneUtil.toTimestamp(end.getTime(orgTZ)),</span>
								m_Overlap);
					} else {
						// If there is TimeInterval in the period with same Activity skip
<span class="nc bnc" id="L644" title="All 2 branches missed.">						if (TimeRecordDAO.checkExistingTimeInterval(wrkID, activity, TimeZoneUtil.toTimestamp(start.getTime(orgTZ)),</span>
<span class="nc" id="L645">								TimeZoneUtil.toTimestamp(end.getTime(orgTZ)))) {</span>
<span class="nc" id="L646">							continue;</span>
						}
					}
<span class="nc" id="L649">					TimeRecord record = new TimeRecord(wrkID);</span>
<span class="nc" id="L650">					TimeInterval interval = new TimeInterval(activity, start.getTime(orgTZ), end.getTime(orgTZ), countTowards, TimeInterval.MANUAL, isPaid, null);</span>
<span class="nc" id="L651">					record.addChild(interval);</span>
<span class="nc" id="L652">					record.setApprove(autoApprove);</span>
<span class="nc" id="L653">					record.setDescription(memo);</span>
<span class="nc" id="L654">					record.setLastModifiedTime(curTime);</span>
<span class="nc" id="L655">					record.setApproverName(approverName);</span>
<span class="nc" id="L656">					ID id = TimeRecordDAO.createTimeInterval(record);</span>
<span class="nc bnc" id="L657" title="All 2 branches missed.">					if (id != null) {</span>
<span class="nc" id="L658">						array.add(id);</span>
					}
<span class="nc" id="L660">				} catch (JdmoDuplicateKeyException e) {</span>
					// If fail to create TimeInterval for one employee, due to duplicate key constraint, it should continue
<span class="nc" id="L662">					handleException(Priority.INFO, e, false);</span>
<span class="nc" id="L663">				} catch (Exception e) {</span>
					// If fail to create TimeInterval for one employee, due to whatever reason, it should continue
<span class="nc" id="L665">					handleException(e);</span>
<span class="nc" id="L666">					throw new BbmCreateException(e);</span>
<span class="nc" id="L667">				}</span>
<span class="nc" id="L668">			}</span>
<span class="nc" id="L669">			return array;</span>
		} finally {
<span class="nc" id="L671">			methodFinish();</span>
		}
	}

	/**
	 *
	 * @param workResourceID
	 * @param payPeriodID
	 * @param vote
	 * @throws BbmUpdateException
	 */
	public void approveTimeInterval(Collection workResourceID, ID payPeriodID, boolean vote)
			throws BbmUpdateException {
<span class="nc" id="L684">		approveTimeInterval(workResourceID, payPeriodID, vote, m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L685">	}</span>

	/**
	 * Approves a pay period.
	 * &lt;p&gt;
	 * @param workResourceID a collection of employee work resource IDs
	 * @param payPeriodID the pay period ID
	 * @param vote a boolean value determining whether to approve the pay period or not
	 * @param approverName an employee approver name, this will defaults to the EJB caller name if not provided
	 * &lt;p&gt;
	 * @throws BbmUpdateException
	 */
	public void approveTimeInterval(Collection workResourceID, ID payPeriodID, boolean vote, String approverName)
			throws BbmUpdateException {
<span class="nc" id="L699">		methodStart(&quot;approveTimeInterval&quot;, workResourceID, payPeriodID, JdmoParam.getObject(vote), approverName);</span>
		try {
<span class="nc" id="L701">			PayPeriodTypeManager pptm = BbmManagerFactory.getPayPeriodTypeManager();</span>
<span class="nc" id="L702">			PayPeriod pp = pptm.getPayPeriod(payPeriodID);</span>
<span class="nc bnc" id="L703" title="All 2 branches missed.">			if (pp != null) {</span>
				// Set current date for all Time Intervals
<span class="nc" id="L705">				Date curTime = new Date();</span>
				// if approver name is needed and not passed in, use EJB caller name
<span class="nc bnc" id="L707" title="All 4 branches missed.">				if (vote &amp;&amp; approverName == null) {</span>
<span class="nc" id="L708">					approverName = m_sessionContext.getCallerPrincipal().getName();</span>
				}
<span class="nc" id="L710">				WorkResourceManager wram = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L711">				PayPolicyManager ppm = BbmManagerFactory.getPayPolicyManager();</span>
<span class="nc" id="L712">				int size = workResourceID.size();</span>
<span class="nc" id="L713">				HashMap wrMap = new HashMap(size);</span>
<span class="nc" id="L714">				HashMap wrppMap = new HashMap(size);</span>
<span class="nc" id="L715">				HashMap ppMap = new HashMap(1);</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L717">					ID wrID = (ID)it.next();</span>
<span class="nc" id="L718">					Collection wraCol = wram.getValidWorkResourceAssignments(wrID, pp.getStartDate(), pp.getEndDate());</span>
<span class="nc" id="L719">					wrMap.put(wrID, wraCol);</span>
<span class="nc" id="L720">					Collection wrppCol = wram.getValidWorkResourcePayPolicies(wrID, pp.getStartDate(), pp.getEndDate());</span>
<span class="nc" id="L721">					wrppMap.put(wrID, wrppCol);</span>
<span class="nc" id="L722">					Iterator itPP = wrppCol.iterator();</span>
					// Cache the PayPolicies for all employees in m_PayPolicy
<span class="nc bnc" id="L724" title="All 2 branches missed.">					while (itPP.hasNext()) {</span>
<span class="nc" id="L725">						WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy)itPP.next();</span>
<span class="nc" id="L726">						ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc bnc" id="L727" title="All 2 branches missed.">						if (!ppMap.containsKey(policyID)) {</span>
<span class="nc" id="L728">							PayPolicy policy = ppm.getPayPolicyByID(policyID);</span>
							// if the paypolicy is not using the payPeriodType,
							// ignore it
<span class="nc bnc" id="L731" title="All 2 branches missed.">							if (policy.getPayPeriodType().equals(pp.getPayPeriodTypeID())) {</span>
<span class="nc" id="L732">								ppMap.put(policyID, policy);</span>
							}
						}
<span class="nc" id="L735">					}</span>
<span class="nc" id="L736">				}</span>
<span class="nc" id="L737">				LocalDate start = pp.getStartDate();</span>
<span class="nc" id="L738">				LocalDate end = pp.getEndDate();</span>
<span class="nc" id="L739">				start.add(Calendar.DATE, -1);</span>
<span class="nc" id="L740">				end.add(Calendar.DATE, 1);</span>
<span class="nc" id="L741">				TimeZone gmtTZ = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
<span class="nc" id="L742">				HashMap trMap = TimeRecordDAO.findTimeIntervals(workResourceID, TimeZoneUtil.toTimestamp(start.getTime(gmtTZ)), TimeZoneUtil.toTimestamp(end.getTime(gmtTZ)));</span>
<span class="nc" id="L743">				start.add(Calendar.DATE, 1);</span>
<span class="nc" id="L744">				end.add(Calendar.DATE, -1);</span>
<span class="nc" id="L745">				DBConfigManager dbcm = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L746">				int overlap = dbcm.getPeriodOverlap();</span>
<span class="nc bnc" id="L747" title="All 2 branches missed.">				for (Iterator it = workResourceID.iterator(); it.hasNext();) {</span>
<span class="nc" id="L748">					ID wrID = (ID)it.next();</span>
					// Retrieve the TimeRecord, if there is no such record, skip
<span class="nc" id="L750">					Collection trCol = (Collection)trMap.get(wrID);</span>
<span class="nc bnc" id="L751" title="All 4 branches missed.">					if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L752">						continue;</span>
					}
					// If there is timerecord, get the splitted time window
<span class="nc" id="L755">					Collection wraCol = (Collection)wrMap.get(wrID);</span>
<span class="nc" id="L756">					Collection wrppCol = (Collection)wrppMap.get(wrID);</span>
<span class="nc" id="L757">					Collection tsCol = TimeSpanNarrower.payrollNarrower(wraCol, wrppCol, ppMap, null, null, pp.getPayPeriodTypeID());</span>
<span class="nc bnc" id="L758" title="All 2 branches missed.">					for (Iterator tsIT = tsCol.iterator(); tsIT.hasNext();) {</span>
<span class="nc" id="L759">						RulesTimeSpan wra = (RulesTimeSpan)tsIT.next();</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">						for (Iterator itTR = trCol.iterator(); itTR.hasNext();) {</span>
<span class="nc" id="L761">							TimeRecord tr = (TimeRecord)itTR.next();</span>
							// check TimeRecord is in peirod or not
<span class="nc bnc" id="L763" title="All 2 branches missed.">							if (StateChange.isInPeriod(tr, wra.getStartDate(), wra.getEndDate(), overlap)) {</span>
<span class="nc bnc" id="L764" title="All 4 branches missed.">								if (!tr.isOpenShift() &amp;&amp; !tr.isLocked()) {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">									if (tr.getApprove() != vote) {</span>
<span class="nc" id="L766">										tr.setApprove(vote);</span>
<span class="nc" id="L767">										tr.setLastModifiedTime(curTime);</span>
<span class="nc" id="L768">										tr.setApproverName(approverName);</span>
<span class="nc" id="L769">										TimeRecordDAO.updateTimeRecord(tr, false, true);</span>
									}
								}
							}
<span class="nc" id="L773">						}</span>
<span class="nc" id="L774">					}</span>
<span class="nc" id="L775">				}</span>
			}
<span class="nc" id="L777">		} catch (Exception e) {</span>
<span class="nc" id="L778">			handleException(e);</span>
<span class="nc" id="L779">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L781">			methodFinish();</span>
<span class="nc" id="L782">		}</span>
<span class="nc" id="L783">	}</span>

	/**
	 * Internal routine for caching.
	 * &lt;p&gt;
	 * @param Collection, Employee
	 * @param ID, PayPeriodType ID
	 * @param LocalDate, start
	 * @param LocalDate, end
	 */
	private void prepare(Collection empCol, ID payPeriodTypeID, LocalDate startDate, LocalDate endDate) {
<span class="nc bnc" id="L794" title="All 2 branches missed.">		for (Iterator empIT = empCol.iterator(); empIT.hasNext();) {</span>
<span class="nc" id="L795">			ID empID = (ID)empIT.next();</span>
			try {
				// Get all the organization assignment for employee during the period
				// This is the exact window, adjustment is done inside the ejb method
<span class="nc" id="L799">				Collection wrkRscAssign = m_WorkResourceManager.getValidWorkResourceAssignments(empID, startDate, endDate);</span>
				// Cache the organizations
<span class="nc bnc" id="L801" title="All 2 branches missed.">				for (Iterator it = wrkRscAssign.iterator(); it.hasNext();) {</span>
<span class="nc" id="L802">					WorkResourceAssignment wra = (WorkResourceAssignment)it.next();</span>
<span class="nc" id="L803">					ID orgID = wra.getOrganizationID();</span>
<span class="nc" id="L804">					m_OrganizationSet.add(orgID);</span>
					/* if (!m_Organization.containsKey(orgID)) {
					 * Organization org = m_WorkResourceManager.
					 * getOrganizationByID(orgID);
					 * m_Organization.put(orgID, org);
					 * }
<span class="nc" id="L810">					 */				}</span>
				// Cache employee-org assocation
<span class="nc bnc" id="L812" title="All 2 branches missed.">				if (!m_EmpOrganization.containsKey(empID)) {</span>
<span class="nc" id="L813">					m_EmpOrganization.put(empID, wrkRscAssign);</span>
				}
				//Get PayPolicy, a bigger window
<span class="nc" id="L816">				Collection wrppCol = m_WorkResourceManager.getValidWorkResourcePayPolicies(empID, startDate, endDate);</span>
				// Cache the PayPolicies for all employees in m_PayPolicy
<span class="nc bnc" id="L818" title="All 2 branches missed.">				for (Iterator it = wrppCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L819">					WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy)it.next();</span>
<span class="nc" id="L820">					ID policyID = wrpp.getPayPolicyID();</span>
<span class="nc bnc" id="L821" title="All 2 branches missed.">					if (!m_PayPolicy.containsKey(policyID)) {</span>
<span class="nc" id="L822">						PayPolicy policy = m_PayPolicyManager.getPayPolicyByID(policyID);</span>
						// if the paypolicy is not using the payPeriodType, ignore it
<span class="nc bnc" id="L824" title="All 2 branches missed.">						if (policy.getPayPeriodType().equals(payPeriodTypeID)) {</span>
<span class="nc" id="L825">							m_PayPolicy.put(policyID, policy);</span>
						}
					}
<span class="nc" id="L828">				}</span>
				// cache the result of employee/paypolicy time-based association
<span class="nc bnc" id="L830" title="All 2 branches missed.">				if (!m_EmpPayPolicy.containsKey(empID)) {</span>
<span class="nc" id="L831">					m_EmpPayPolicy.put(empID, wrppCol);</span>
				}
<span class="nc" id="L833">			} catch (Exception e) {</span>
<span class="nc" id="L834">				handleException(&quot;prepare&quot;, e, false);</span>
<span class="nc" id="L835">				continue;</span>
<span class="nc" id="L836">			}</span>
<span class="nc" id="L837">		}</span>
<span class="nc" id="L838">	}</span>

	/**
	 * Internal routine for clean up.
	 */
	private void clearUp() {
<span class="nc" id="L844">		m_PayPolicy.clear();</span>
<span class="nc" id="L845">		m_OrganizationSet.clear();</span>
<span class="nc" id="L846">		m_EmpPayPolicy.clear();</span>
<span class="nc" id="L847">		m_EmpOrganization.clear();</span>
<span class="nc" id="L848">	}</span>

	/**
	 * Internal routine to get the first pay policy.
	 * &lt;p&gt;
	 * @param Collection, WorkResourcePayPolicy
	 * @param Date, start
	 * @param Date, end
	 */
	private PayPolicy getPayPolicy(Collection wrpCol, Date start, Date end) {
<span class="nc bnc" id="L858" title="All 2 branches missed.">		for (Iterator it = wrpCol.iterator(); it.hasNext();) {</span>
<span class="nc" id="L859">			WorkResourcePayPolicy wrpp = (WorkResourcePayPolicy)it.next();</span>
			// If the paypolicy cover the whole day, return it or if the paypolicy starts/ends in the middle of the day
			// Assume the wrpCol is sorted by start time, so any PayPolicy cross the start/end window, should be returned
<span class="nc bnc" id="L862" title="All 4 branches missed.">			if ((wrpp.getEndTime() != null &amp;&amp; wrpp.getEndTime().before(start))</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">					|| wrpp.getStartTime().after(end)) {</span>
<span class="nc" id="L864">				continue;</span>
			}
			// since we are not going to pick the paypolicy not using the payperiod type, if it is null, try to find next
<span class="nc" id="L867">			PayPolicy pp = (PayPolicy)m_PayPolicy.get(wrpp.getPayPolicyID());</span>
<span class="nc bnc" id="L868" title="All 2 branches missed.">			if (pp != null) {</span>
<span class="nc" id="L869">				return pp;</span>
			}
<span class="nc" id="L871">		}</span>
		// At last, return null
<span class="nc" id="L873">		return null;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>