<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FlexRequestMustOccurASAPValidationRule.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.flextime.validation</a> &gt; <span class="el_source">FlexRequestMustOccurASAPValidationRule.java</span></div><h1>FlexRequestMustOccurASAPValidationRule.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.flextime.validation;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.EventUtils;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validatable;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.common.validation.Validator;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.FlexRequestMakeup;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.ejb.rm.setup.validation.ejb.ValidationRuleManager;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.RmUtil;

<span class="nc" id="L37">public class FlexRequestMustOccurASAPValidationRule implements Validator {</span>

	public static final String MUST_OCCUR_ASAP_MAX_DAYS = &quot;MUST_OCCUR_ASAP_MAX_DAYS&quot;;

<span class="nc" id="L41">	public static final ID RULE_ID = new ID(-194062);</span>

<span class="nc" id="L43">	private static final String CLASS_NAME = FlexRequestMustOccurASAPValidationRule.class.getName();</span>
<span class="nc" id="L44">	private static final Category LOG = Log.initCategory(CLASS_NAME);</span>

	@Override
	public ValidationResult validate(Validatable validatable) throws Exception {
		ValidationResult result;
<span class="nc" id="L49">		LOG.debug(RmUtil.dumpEnterMethod(&quot;validate&quot;, validatable));</span>

<span class="nc" id="L51">		TORequest tor = (TORequest) validatable;</span>

<span class="nc bnc" id="L53" title="All 2 branches missed.">		if (getLatestMakeupStartDate(tor).before(getTimeOffStartDate(tor))) {</span>
			// all makeup blocks happen before time off duration
<span class="nc" id="L55">			result = null;</span>

		} else {
			// some makeup blocks happen after time off

			// check all makeup blocks happen in N-day duration from time off end time
<span class="nc" id="L61">			result = validateAllMakeupHappenBeforeLatestAllowedDate(RULE_ID, tor);</span>

			// if we can find a big enough OT block which agent didn't use, then rule is violated
<span class="nc bnc" id="L64" title="All 2 branches missed.">			if (result == null) {</span>
<span class="nc" id="L65">				result = validateAllMakeupHappenNotLaterThanFirstAvailableBlock(RULE_ID, tor);</span>
			}

		}

<span class="nc" id="L70">		LOG.debug(RmUtil.dumpExitMethod(&quot;validate&quot;, result));</span>
<span class="nc" id="L71">		return result;</span>
	}

	private ValidationResult validateAllMakeupHappenBeforeLatestAllowedDate(ID ruleId, TORequest tor) throws Exception {
		ValidationResult result;

<span class="nc" id="L77">		Map&lt;String, Integer&gt; ruleParams = getValidationRuleManager().getValidationRuleParams(getOrgID(tor), ruleId);</span>
<span class="nc" id="L78">		int maxAllowedDayNum = ruleParams.get(MUST_OCCUR_ASAP_MAX_DAYS);</span>

<span class="nc" id="L80">		Date latestAllowedDate = DateTimeUtil.getDateForDaysAfter(getTimeOffEndDate(tor), maxAllowedDayNum, getTimeZone(tor));</span>

<span class="nc" id="L82">		Date latestMakeupStartDate = getLatestMakeupStartDate(tor);</span>

<span class="nc bnc" id="L84" title="All 2 branches missed.">		if (DateUtil.isBeforeOrEqual(latestMakeupStartDate, latestAllowedDate)) {</span>
<span class="nc" id="L85">			result = null;</span>
		} else {
<span class="nc" id="L87">			result = ValidationUtil.setSoftValidationResult(tor, RmEjbBundleKey.FLEX_REQ_ASAP_MAKEUP_NOT_IN_DURATION, latestAllowedDate, maxAllowedDayNum, CLASS_NAME);</span>
		}
<span class="nc" id="L89">		return result;</span>
	}


	private ValidationResult validateAllMakeupHappenNotLaterThanFirstAvailableBlock(ID ruleId, TORequest tor) throws Exception {

		// If we can find some slot which can fit the all makeup time minutes
		// between time off end date and the latest (makeup+gap)'s start date
		// then the rule is violated. Also consider below exceptions:
		// Exceptions:
		//       1. Time Off end time = shift end time, IGNORE this (AFTER) OT when checking availability (both for this flex time off and existing calendar time off)
		//       2. (Makeup + gap)'s start time = shift end time, ignore this AFTER OT (because if this OT fits, request is still valid)
		//       3. (Makeup + gap)'s end time = shift start time, ignore this BEFORE OT (because if it fits, request is still valid)
		//
		// For AFTER OTs, check the first available duration from shift end time to first event start time (or HOO end time if no event)
		// For BEFOTE OTs, check the first available duration from shift start time backward to last event end time (or HOO start time if no event)

		// The block (if any) will be between end date of time off -&gt; start date of latest (makeup+gap)
<span class="nc" id="L107">		TimeRange latestMakeupAndGapExtension = getLatestMakeupAndGapExtension(tor);</span>
<span class="nc" id="L108">		TimeRange limitDuration = new TimeRange(getTimeOffEndDate(tor), latestMakeupAndGapExtension.getStartDate());</span>

		// find calendar events and shift events between  start date of time off -&gt; start date of latest (makeup+gap)
		// if time off ends at shift end, make sure we also IGNORE this AFTER OT at shift end - so using Time Off End Date to avoid &quot;seeing&quot; the shift -
		// when finding shift events. And we also exclude the OT block which contains last makeup block - so using last makeup start date
<span class="nc" id="L113">		Collection&lt;ShiftAssignment&gt; shiftEvents = getPublishedShiftAssignments(tor, new TimeRange(getTimeOffEndDate(tor), latestMakeupAndGapExtension.getStartDate()));</span>
<span class="nc" id="L114">		TimeRange eventsDuration = new TimeRange(getTimeOffStartDate(tor), latestMakeupAndGapExtension.getStartDate());</span>
<span class="nc" id="L115">		Collection&lt;CalendarEventAssignment&gt; calendarEvents = getPublishedCalendarEvents(tor, eventsDuration);</span>
<span class="nc" id="L116">		Collection&lt;OrganizationHOO&gt; organizationHOOs = getHOOs(tor, eventsDuration);</span>
<span class="nc" id="L117">		int totalMakeupMinutes = getTotalMakeupMinutes(tor);</span>
<span class="nc" id="L118">		TimeZone tz = getTimeZone(tor);</span>
<span class="nc" id="L119">		TimeRange availableBlock = null;</span>
<span class="nc" id="L120">		OrganizationSetting orgSettings = getFTValidationCache(tor).getOrgSettingForOrgID(getOrgID(tor));</span>

<span class="nc bnc" id="L122" title="All 2 branches missed.">		for (ShiftAssignment shiftEvent : shiftEvents) {</span>
<span class="nc" id="L123">			TimeRange mainShiftTimeRange = shiftEvent.getMainShiftTimeRange();</span>

<span class="nc bnc" id="L125" title="All 2 branches missed.">			if (isExtBeforeShiftAvailable(tor, latestMakeupAndGapExtension, orgSettings, mainShiftTimeRange)) {</span>
<span class="nc" id="L126">				availableBlock = findAvailableBlockInBeforeExtension(limitDuration, shiftEvent, shiftEvents, calendarEvents, organizationHOOs, totalMakeupMinutes, tz);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">				if (availableBlock != null) {</span>
<span class="nc" id="L128">					break;</span>
				}
			}

<span class="nc bnc" id="L132" title="All 2 branches missed.">			if (isExtAfterShiftAvailable(tor, latestMakeupAndGapExtension, orgSettings, mainShiftTimeRange)) {</span>
<span class="nc" id="L133">				availableBlock = findAvailableBlockInAfterExtension(limitDuration, shiftEvent, shiftEvents, calendarEvents, organizationHOOs, totalMakeupMinutes, tz);</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">				if (availableBlock != null) {</span>
<span class="nc" id="L135">					break;</span>
				}
			}
<span class="nc" id="L138">		}</span>

		ValidationResult result;
<span class="nc bnc" id="L141" title="All 2 branches missed.">		if (availableBlock != null) {</span>
<span class="nc" id="L142">			result = ValidationUtil.setSoftValidationResult(tor, RmEjbBundleKey.FLEX_REQ_ASAP_AVAILABLE_BLOCK_IN_DURATION, availableBlock.getStartDate(), availableBlock.getEndDate(), CLASS_NAME);</span>
		} else {
<span class="nc" id="L144">			result = null;</span>
		}

<span class="nc" id="L147">		return result;</span>
	}

	/**
	 * Check if BEFORE OT extension is available (skip the extension if it is right before the flex time off or it 
	 * contains the latest makeup, or if the Request Management settings for the organization disable extensions before shift)
	 */
	private boolean isExtBeforeShiftAvailable(TORequest tor, TimeRange latestMakeupAndGapExtension,
			OrganizationSetting orgSettings, TimeRange mainShiftTimeRange) {
<span class="nc bnc" id="L156" title="All 2 branches missed.">		return orgSettings.getAllowMakeupBeforeShift() &amp;&amp; </span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">				!getTimeOffStartDate(tor).equals(mainShiftTimeRange.getStartDate()) &amp;&amp; </span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">				!latestMakeupAndGapExtension.getEndDate().equals(mainShiftTimeRange.getStartDate());</span>
	}

	/**
	 * Check if AFTER OT extension is available (skip extension if it is right after the flex time off or it 
	 * contains the latest makeup, or if the Request Management settings for the organization disable extensions after shift)
	 */
	private boolean isExtAfterShiftAvailable(TORequest tor, TimeRange latestMakeupAndGapExtension,
			OrganizationSetting orgSettings, TimeRange mainShiftTimeRange) {
<span class="nc bnc" id="L167" title="All 2 branches missed.">		return orgSettings.getAllowMakeupAfterShift() &amp;&amp; </span>
<span class="nc bnc" id="L168" title="All 2 branches missed.">				!getTimeOffEndDate(tor).equals(mainShiftTimeRange.getEndDate()) &amp;&amp; </span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				!latestMakeupAndGapExtension.getStartDate().equals(mainShiftTimeRange.getEndDate());</span>
	}

	private TimeRange findAvailableBlockInBeforeExtension(TimeRange limitDuration, ShiftAssignment shiftAssignment,
			Collection&lt;ShiftAssignment&gt; shiftEvents, Collection&lt;CalendarEventAssignment&gt; calendarEvents, Collection&lt;OrganizationHOO&gt; organizationHOOs, int totalMakeupMinutes, TimeZone tz) throws Exception {

		// Make sure BEFORE OT Extension is available
<span class="nc bnc" id="L176" title="All 6 branches missed.">		if (!EventUtils.isOTShift(shiftAssignment) &amp;&amp; shiftAssignment.getOTExtensionBeforeID() == null &amp;&amp; shiftAssignment.getOTExtensionBeforeActivityID() == null) {</span>
<span class="nc" id="L177">			TimeRange shift = new TimeRange(shiftAssignment.getStartTime(), shiftAssignment.getEndTime());</span>
<span class="nc" id="L178">			TimeRange hoo = findHOO(tz, shiftAssignment.getStartTime(), organizationHOOs);</span>
			// make sure this shift inside HOO
<span class="nc bnc" id="L180" title="All 4 branches missed.">			if (hoo != null &amp;&amp; shift.isInside(hoo)) {</span>

				// find available blocks in the limit duration and not including event time
<span class="nc" id="L183">				Collection&lt;TimeRange&gt; availableBlocks = findAvailableBlocks(hoo.getStartDate(), shiftAssignment.getStartTime(), shiftEvents, calendarEvents, limitDuration);</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">				if (!availableBlocks.isEmpty()) {</span>
					// the block must end at shift start time and big enough and has no adjacent time off or unavailability after it
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L187">					TimeRange nearestAvailableBlock = Collections.max(availableBlocks);</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">					if (nearestAvailableBlock.getEndDate().equals(shiftAssignment.getStartTime()) &amp;&amp; nearestAvailableBlock.getDurationMin() &gt;= totalMakeupMinutes</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">							&amp;&amp; !hasAdjacentTimeOffEvents(nearestAvailableBlock, calendarEvents, TimeRange.ADJACENT_AFTER)) {</span>
<span class="nc" id="L190">						return nearestAvailableBlock;</span>
					}
				}
			}
		}
<span class="nc" id="L195">		return null;</span>
	}


	private TimeRange findAvailableBlockInAfterExtension(TimeRange limitDuration, ShiftAssignment shiftAssignment,
			Collection&lt;ShiftAssignment&gt; shiftEvents, Collection&lt;CalendarEventAssignment&gt; calendarEvents, Collection&lt;OrganizationHOO&gt; organizationHOOs, int totalMakeupMinutes, TimeZone tz) throws Exception {

		// Make sure AFTER OT Extension is available
<span class="nc bnc" id="L203" title="All 6 branches missed.">		if (!EventUtils.isOTShift(shiftAssignment) &amp;&amp; shiftAssignment.getOTExtensionAfterID() == null &amp;&amp; shiftAssignment.getOTExtensionAfterActivityID() == null) {</span>
<span class="nc" id="L204">			TimeRange shift = new TimeRange(shiftAssignment.getStartTime(), shiftAssignment.getEndTime());</span>
<span class="nc" id="L205">			TimeRange hoo = findHOO(tz, shiftAssignment.getStartTime(), organizationHOOs);</span>
			// make sure this shift inside HOO
<span class="nc bnc" id="L207" title="All 4 branches missed.">			if (hoo != null &amp;&amp; shift.isInside(hoo)) {</span>

				// find available blocks in the limit duration and not including event time
<span class="nc" id="L210">				Collection&lt;TimeRange&gt; availableBlocks = findAvailableBlocks(shiftAssignment.getEndTime(), hoo.getEndDate(), shiftEvents, calendarEvents, limitDuration);</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">				if (!availableBlocks.isEmpty()) {</span>
					// the block must start at shift end time and big enough and has no adjacent time off or unavailability before it
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L214">					TimeRange nearestAvailableBlock = Collections.min(availableBlocks);</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">					if (nearestAvailableBlock.getStartDate().equals(shiftAssignment.getEndTime()) &amp;&amp; nearestAvailableBlock.getDurationMin() &gt;= totalMakeupMinutes</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">							&amp;&amp; !hasAdjacentTimeOffEvents(nearestAvailableBlock, calendarEvents, TimeRange.ADJACENT_BEFORE)) {</span>
<span class="nc" id="L217">						return nearestAvailableBlock;</span>
					}
				}
			}
		}
<span class="nc" id="L222">		return null;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private TimeRange getLatestMakeupAndGapExtension(TORequest tor) throws Exception {
		// Find makeup durations
<span class="nc" id="L228">		List&lt;TimeRange&gt; makeupDurations = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc" id="L229">		Calendar cal = Calendar.getInstance(getTimeZone(tor));</span>
<span class="nc bnc" id="L230" title="All 2 branches missed.">		for (FlexRequestMakeup flexMakeup : tor.getFlexRequestMakeupList()) {</span>
<span class="nc bnc" id="L231" title="All 2 branches missed.">			if (flexMakeup.getExtBeforeActivityID() != null) {</span>
<span class="nc" id="L232">				cal.setTime(flexMakeup.getShiftStartTime());</span>
<span class="nc" id="L233">				cal.add(Calendar.MINUTE, - (flexMakeup.getExtBeforeGap() + flexMakeup.getExtBeforeDuration()));</span>
<span class="nc" id="L234">				makeupDurations.add(new TimeRange(cal.getTime(), flexMakeup.getShiftStartTime()));</span>
			}
<span class="nc bnc" id="L236" title="All 2 branches missed.">			if (flexMakeup.getExtAfterActivityID() != null) {</span>
<span class="nc" id="L237">				cal.setTime(flexMakeup.getShiftEndTime());</span>
<span class="nc" id="L238">				cal.add(Calendar.MINUTE, flexMakeup.getExtAfterGap() + flexMakeup.getExtAfterDuration());</span>
<span class="nc" id="L239">				makeupDurations.add(new TimeRange(flexMakeup.getShiftEndTime(), cal.getTime()));</span>
			}
<span class="nc" id="L241">		}</span>
<span class="nc" id="L242">		return Collections.max(makeupDurations);</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Collection&lt;TimeRange&gt; findAvailableBlocks(Date start, Date end, Collection&lt;ShiftAssignment&gt; shiftEvents, Collection&lt;CalendarEventAssignment&gt; calendarEvents, TimeRange limitDuration) {
<span class="nc" id="L247">		Collection&lt;TimeRange&gt; availableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">		if (start.before(end)) {</span>
<span class="nc" id="L249">			TimeRange overlappingRange = new TimeRange(start, end).getOverlapInterval(limitDuration);</span>
<span class="nc bnc" id="L250" title="All 4 branches missed.">			if (overlappingRange != null &amp;&amp; !overlappingRange.isInstant()) {</span>
<span class="nc" id="L251">				availableBlocks.add(overlappingRange);</span>
				// remove event time
<span class="nc bnc" id="L253" title="All 2 branches missed.">				for (CalendarEventAssignment event : calendarEvents) {</span>
<span class="nc" id="L254">					Collection&lt;TimeRange&gt; newAvailableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">					for (TimeRange availableBlock : availableBlocks) {</span>
<span class="nc" id="L256">						newAvailableBlocks.addAll(availableBlock.splitOrTrim(new TimeRange(event.getStartTime(), event.getEndTime())));</span>
<span class="nc" id="L257">					}</span>
<span class="nc" id="L258">					availableBlocks = newAvailableBlocks;</span>
<span class="nc" id="L259">				}</span>
				// remove shift assignment time (in case a shift crossing HOO boundaries and is close to the next shift)
<span class="nc bnc" id="L261" title="All 2 branches missed.">				for (ShiftAssignment shiftEvent : shiftEvents) {</span>
<span class="nc" id="L262">					Collection&lt;TimeRange&gt; newAvailableBlocks = new ArrayList&lt;TimeRange&gt;();</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">					for (TimeRange availableBlock : availableBlocks) {</span>
<span class="nc" id="L264">						newAvailableBlocks.addAll(availableBlock.splitOrTrim(new TimeRange(shiftEvent.getStartTime(), shiftEvent.getEndTime())));</span>
<span class="nc" id="L265">					}</span>
<span class="nc" id="L266">					availableBlocks = newAvailableBlocks;</span>
<span class="nc" id="L267">				}</span>
			}
		}

<span class="nc" id="L271">		return availableBlocks;</span>
	}

	private TimeRange findHOO(TimeZone tz, Date date, Collection&lt;OrganizationHOO&gt; organizationHOOs) {
<span class="nc" id="L275">		TimeRange result = null;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">		for (OrganizationHOO hoo : organizationHOOs) {</span>
<span class="nc bnc" id="L277" title="All 4 branches missed.">			if (hoo.isActive() &amp;&amp; RequestUtil.isDateBetween(date, hoo.getStartTime(), hoo.getEndTime())) {</span>
<span class="nc" id="L278">				Date open = hoo.getDayOpen(date, tz);</span>
<span class="nc" id="L279">				Date close = hoo.getDayClose(date, tz);</span>
<span class="nc bnc" id="L280" title="All 4 branches missed.">				if (open != null &amp;&amp; close != null) {</span>
<span class="nc" id="L281">					result = new TimeRange(open, close);</span>
				}
			}
<span class="nc" id="L284">		}</span>
<span class="nc" id="L285">		return result;</span>
	}
	// adjacentBeforeOrAfter = TimeRange.ADJACENT_BEFORE or TimeRange.ADJACENT_AFTER
	private boolean hasAdjacentTimeOffEvents(TimeRange block, Collection&lt;CalendarEventAssignment&gt; calendarEvents, int adjacentBeforeOrAfter) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">		for (CalendarEventAssignment event : calendarEvents) {</span>
<span class="nc bnc" id="L290" title="All 4 branches missed.">			if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF || event.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc" id="L291">				TimeRange eventBlock = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L292">				int eventLocation = eventBlock.getAdjacency(block);</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">				if (eventLocation == adjacentBeforeOrAfter) {</span>
<span class="nc" id="L294">					return true;</span>
				}
			}
<span class="nc" id="L297">		}</span>
<span class="nc" id="L298">		return false;</span>
	}

	private Date getTimeOffEndDate(TORequest tor) {
<span class="nc" id="L302">		return tor.getFirstTOChoice().getEndDate();</span>
	}

	private Date getTimeOffStartDate(TORequest tor) {
<span class="nc" id="L306">		return tor.getFirstTOChoice().getStartDate();</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	private Date getLatestMakeupStartDate(TORequest tor) throws Exception {
<span class="nc" id="L311">		return Collections.max(getFTValidationCache(tor).getMakeupDurations()).getStartDate();</span>
	}

	private int getTotalMakeupMinutes(TORequest tor) {
<span class="nc" id="L315">		return getFTValidationCache(tor).getTotalMakeupMinutes();</span>
	}

	private ID getOrgID(TORequest tor) throws Exception {
<span class="nc" id="L319">		return getFTValidationCache(tor).getOrg().getID();</span>
	}

	private TimeZone getTimeZone(TORequest tor) throws Exception {
<span class="nc" id="L323">		return getFTValidationCache(tor).getOrg().getTimeZone();</span>
	}

	private Collection&lt;OrganizationHOO&gt; getHOOs(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L327">		return getFTValidationCache(tor).getHOOAssignmentsDuringPeriod(eventsDuration);</span>
	}

	private Collection&lt;ShiftAssignment&gt; getPublishedShiftAssignments(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L331">		return getFTValidationCache(tor).getPublishedShiftAssignments(eventsDuration);</span>
	}

	private Collection&lt;CalendarEventAssignment&gt; getPublishedCalendarEvents(TORequest tor, TimeRange eventsDuration) throws Exception {
<span class="nc" id="L335">		return getFTValidationCache(tor).getPublishedCalendarEvents(eventsDuration);</span>
	}

	protected FTValidationCache getFTValidationCache(TORequest toRequest) {
<span class="nc" id="L339">		return (FTValidationCache) toRequest.getCache();</span>
	}

	protected ValidationRuleManager getValidationRuleManager() throws BbmCreateException {
<span class="nc" id="L343">		return RmManagerFactory.getInstance().getValidationRuleManager();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>