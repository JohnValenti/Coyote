<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ValidationRuleManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.validation.ejb</a> &gt; <span class="el_source">ValidationRuleManagerEJB.java</span></div><h1>ValidationRuleManagerEJB.java</h1><pre class="source lang-java linenums">/*
 * ValidationRuleManagerEJB.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.setup.validation.ejb;

import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.setup.validation.model.ValidationRule;
import com.bluepumpkin.ejb.rm.setup.validation.model.ValidationSetting;
import com.bluepumpkin.ejb.rm.util.LicenseUtil;
import com.bluepumpkin.ejb.rm.util.TONotifyMessageClient;
import com.bluepumpkin.ejb.rm.util.ThreadLocalCache;

/**
 * EJB for ValidationRule
 */
<span class="fc" id="L35">public class ValidationRuleManagerEJB extends SessionEJBBase { //OUTSIDE_CONTAINER</span>
//public class ValidationRuleManagerEJB extends SessionEjbBaseForTest implements ValidationRuleManager { //OUTSIDE_CONTAINER

<span class="fc" id="L38">	private static Category m_cat = Log.initCategory(ValidationRuleManagerEJB.class.getName());</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L43">		return m_cat;</span>
	}

	{
<span class="fc" id="L47">		super.init( ValidationRuleManagerEJB.class.getName() );</span>
<span class="fc" id="L48">	}</span>

    /**
     * Return ValidationSetting object, which includes the bundlekey-&gt;ValidationRule
     * map, as well as ancestor org information .
     * @param requestType - One of: 'time-off', 'shift-swap', 'shift-bid', 'time-off-withdraw', 'all'
     * @param orgID   ID  Identifes the organizationId
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the rules are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
     *
     * @return  The ValidationSetting object.
     */
    public ValidationSetting getSettings(String requestType, ID organizationId, boolean shallow, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs)
        throws BbmFinderException, BbmCreateException
    {
<span class="fc" id="L64">        return getSettings(getInitValidationMap(requestType), organizationId, shallow, listSelectedTimeOffTypeActivityIDs);</span>
    }


    /**
     * Find the ValidationRules for the OrganizationId, request type passed
     * as argument and returns a collection of ValidationRule Object if found.
     * We search org and it's ancestors if necessary to find the rules.
     *
     * @param requestType - One of: 'time-off', 'shift-swap', 'shift-bid', 'time-off-withdraw', 'all'
     * @param organizationId - Organization ID.
     *
     * @return Map A map of validation bundlekey to isenabled flag
     * @throws BbmFinderException if there is an error.
     */
	public Map findValidationRules(String requestType, ID organizationId, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs)
	    throws BbmFinderException
    {
<span class="nc" id="L82">		return findValidationRules(getInitValidationMap(requestType), organizationId, false, listSelectedTimeOffTypeActivityIDs);</span>

	}

    /**
     * Find the ValidationRules for the OrganizationId, request type passed
     * as argument and returns a collection of ValidationRule Object if found.
     *
     * @param requestType - On of: 'time-off', 'shift-swap', 'shift-bid', 'time-off-withdraw', 'all'
     * @param organizationId - Organization ID.
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the rules are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
     *
     * @return Map A map of validation bundlekey to isenabled flag
     * @throws BbmFinderException if there is an error.
     */
    public Map findValidationRules(String requestType, ID organizationId, boolean shallow, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs)
        throws BbmFinderException
    {
<span class="fc" id="L102">        return findValidationRules(getInitValidationMap(requestType), organizationId, shallow, listSelectedTimeOffTypeActivityIDs);</span>

    }


    /** OK
     * Find the Validators enabled for the OrganizationId, request type passed
     * as argument and returns a collection of Validator class names. If shallow
     * is false, then the validation rules from the parent organizations of the
     * supplied org are also checked if the rules do not exist for the specified org.
     *
     * @param pRequestType - Type of request TimeOff or ShiftSwap.  Note that
     *     All is not a valid choice here since this method is expected to be
     *     called for a particular request type, not the UI setting up validation
     *     rules for an organization.
     * @param pOrganizationId - Organisation ID object.
     * @param shallow - If true, only the specified org's enabled rules of the
     *     specified type are returned. If false, and if the requested rules do
     *     not exist for the specified org, then we get the rules from the ancestor
     *     orgs until we find all the rules of the requested type. Once we find a
     *     rule (whether it's enabled or disabled), we stop searching for it.
     *
     * @return Collection A collection of Strings that are the Validator class
     *     names in effect for the given organization and type.  Returns an empty
     *     collection if there are none.
     */
    public Collection&lt;String&gt; findValidators(String pRequestType, ID pOrganizationId, ID activityID)
        throws BbmFinderException
    {
<span class="fc" id="L131">        final String l_MethodName = &quot;findValidators&quot;;</span>
<span class="fc" id="L132">        methodStart(l_MethodName, pRequestType, pOrganizationId);</span>
<span class="fc" id="L133">        OrgValidationDAO dao = new OrgValidationDAO();</span>
<span class="fc" id="L134">        Collection&lt;String&gt; result = Collections.emptyList();</span>
        try
        {
<span class="fc" id="L137">            result = dao.findValidators(pRequestType, pOrganizationId, activityID);</span>
        }
<span class="nc" id="L139">        catch (Exception e)</span>
        {
<span class="nc" id="L141">            handleException(e);</span>
<span class="nc" id="L142">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        }
        finally
        {
<span class="pc" id="L146">            methodFinish();</span>
<span class="pc" id="L147">            dao.cleanUp();</span>
<span class="fc" id="L148">        }</span>
<span class="fc" id="L149">        return result;</span>
    }

   


	/**
	 * Find the ValidationRules for the OrganizationId, request type passed
	 * as argument and returns a collection of ValidationRule Object if found.
	 *
	 * @param validationMap - map (BUNDLEKEY-&gt;ISENABLED) containing the specific validation rules to get.
     *                        It will be converted to a map of BUNDLEKEY-&gt;ValidationRule, containing the
     *                        rule's parameters, if any.
  	 * @param organizationId - Organization ID.
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the rules are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
     *
	 * @return Map A map of validation bundlekey to isenabled flag
	 * @throws BbmFinderException if there is an error.
	 */
	public Map findValidationRules(Map validationMap, ID organizationId, boolean shallow,  List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs)
	    throws BbmFinderException
    {
<span class="fc" id="L173">		final String l_MethodName = &quot;findValidationRules&quot;;</span>
<span class="fc" id="L174">		methodStart(l_MethodName, validationMap, organizationId);</span>
<span class="fc" id="L175">		OrgValidationDAO dao = new  OrgValidationDAO();</span>

        try
        {
<span class="pc bpc" id="L179" title="1 of 2 branches missed.">        	if (!LicenseUtil.isAdvancedRMLicenseForValidationByType()){</span>
<span class="fc" id="L180">    			listSelectedTimeOffTypeActivityIDs = Collections.emptyList();</span>
    		}
        	
<span class="fc" id="L183">			dao.populatePropertyMap(organizationId, validationMap, shallow, listSelectedTimeOffTypeActivityIDs);</span>
<span class="fc" id="L184">			return validationMap;</span>
		}
<span class="nc" id="L186">        catch (Exception e)</span>
        {
<span class="nc" id="L188">            handleException(e);</span>
<span class="nc" id="L189">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        }
        finally
        {
<span class="pc" id="L193">			methodFinish();</span>
<span class="pc" id="L194">			dao.cleanUp();</span>
		}
	}
	public Map findValidationRules(String validationMap, ID organizationId, boolean shallow)
		    throws BbmFinderException{
<span class="nc" id="L199">		return findValidationRules( validationMap,  organizationId,  shallow,  null);</span>
	}

    /**
     * Return ValidationSetting object, which includes the bundlekey-&gt;ValidationRule
     * map, as well as ancestor org information .
     * @param validationMap - map (BUNDLEKEY-&gt;ISENABLED) containing the specific validation rules to get.
     *                        It will be converted to a map of BUNDLEKEY-&gt;ValidationRule, containing the
     *                        rule's parameters, if any.
     * @param orgID   ID  Identifes the organizationId
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the rules are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
     *
     * @return  The ValidationSetting object.
     */
    public ValidationSetting getSettings(Map validationMap, ID organizationId, boolean shallow, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs )
        throws BbmFinderException
    {
<span class="fc" id="L218">        final String l_MethodName = &quot;getSettings&quot;;</span>
<span class="fc" id="L219">        methodStart(l_MethodName, validationMap, organizationId);</span>

<span class="fc" id="L221">        HashMap pAncestorMap = new HashMap();</span>
<span class="fc" id="L222">        boolean hasChildren = false;</span>

<span class="fc" id="L224">        OrgValidationDAO dao = new  OrgValidationDAO();</span>
        try
        {
			//Get all the required properties form the property key file
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">			if (!LicenseUtil.isAdvancedRMLicenseForValidationByType()) {</span>
<span class="fc" id="L229">				listSelectedTimeOffTypeActivityIDs = Collections.emptyList();</span>
			}
			
<span class="fc" id="L232">			dao.populatePropertyMap(organizationId, validationMap, pAncestorMap, shallow, listSelectedTimeOffTypeActivityIDs);</span>

            //determine if the org has any children. Although not truely an org setting, it is
            //needed by the RM Settings page. It will not be added to the property map.
<span class="fc" id="L236">            hasChildren = getHasChildren(organizationId);</span>

        }
<span class="nc" id="L239">        catch (Exception e)</span>
        {
<span class="nc" id="L241">            handleException(e);</span>
<span class="nc" id="L242">            throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
        }
        finally
        {
<span class="pc" id="L246">            methodFinish();</span>
<span class="pc" id="L247">            dao.cleanUp();</span>
<span class="fc" id="L248">        }</span>

<span class="fc" id="L250">        ValidationSetting vs = new ValidationSetting(validationMap, pAncestorMap, organizationId.toString());</span>
<span class="fc" id="L251">        vs.setHasChildren(hasChildren);</span>
<span class="fc" id="L252">        return vs;</span>

    }

	/**
	 * Find the ValidationRule params for the OrganizationId, and validation rule type.
	 * @param orgID
	 * @param validationRuleID
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the params are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
	 *
	 * @return HashMap A map of validation rule params
	 * @throws BbmFinderException if there is an error.
	 */
	public Map&lt;String, Integer&gt; getValidationRuleParams(ID orgID, ID validationRuleID) throws BbmFinderException {

<span class="nc" id="L269">		return getValidationRuleParams(orgID, validationRuleID, null);</span>
	
	}
	
	/**
	 * Find the ValidationRule params for the OrganizationId, and validation rule type.
	 * @param orgID
	 * @param validationRuleID
	 * @param activityID - valid only for time-off types currently
     * @param shallow - If true, we will search only the specified org. If false, and
     *           the params are not found at the specified org, then we search the ancestor
     *           orgs until we find them.
	 *
	 * @return HashMap A map of validation rule params
	 * @throws BbmFinderException if there is an error.
	 */
	public Map&lt;String, Integer&gt; getValidationRuleParams(ID orgID, ID validationRuleID, ID activityID) throws BbmFinderException {
		
<span class="fc" id="L287">		ID validateByActivityId = null;</span>
		// Protect against searching for validators by activity if license not enabled
<span class="pc bpc" id="L289" title="1 of 2 branches missed.">		if( LicenseUtil.isAdvancedRMLicenseForValidationByType()){</span>
<span class="nc" id="L290">			validateByActivityId = activityID;</span>
		}
		
		
<span class="fc bfc" id="L294" title="All 2 branches covered.">		if (!ThreadLocalCache.isEnabled()) {</span>
<span class="fc" id="L295">			return getValidationRuleParamsDB(orgID, validationRuleID,  validateByActivityId);</span>
		}

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">		String key = String.format(&quot;[%s][%s][%s]&quot;, orgID, validationRuleID,validateByActivityId==null? &quot;null&quot;:validateByActivityId);</span>

<span class="fc" id="L300">		Map&lt;String, Map&lt;String, Integer&gt;&gt; cache = ThreadLocalCache.getMap(&quot;ValidationRuleManagerEJB.getValidationRuleParams&quot;);</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">		if (cache.containsKey(key)) {</span>
<span class="fc" id="L302">			return cache.get(key);</span>
		}

<span class="fc" id="L305">		Map&lt;String, Integer&gt; result = getValidationRuleParamsDB(orgID, validationRuleID, validateByActivityId);</span>
<span class="fc" id="L306">		cache.put(key, result);</span>
<span class="fc" id="L307">		return result;</span>
	}
	
	


	private Map&lt;String, Integer&gt; getValidationRuleParamsDB(ID orgID, ID validationRuleID,  ID activityID) throws BbmFinderException {
<span class="fc" id="L314">		final String l_MethodName = &quot;getValidationRuleParams&quot;;</span>
<span class="fc" id="L315">		methodStart(l_MethodName, orgID, validationRuleID);</span>
<span class="fc" id="L316">		OrgValidationDAO dao = new OrgValidationDAO();</span>
		try {
<span class="fc" id="L318">			return dao.getValidationRuleParams(orgID, validationRuleID, activityID);</span>
		}

<span class="nc" id="L321">		catch (Exception e) {</span>
<span class="nc" id="L322">			handleException(e);</span>
<span class="nc" id="L323">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="pc" id="L325">			methodFinish();</span>
<span class="pc" id="L326">			dao.cleanUp();</span>
		}
	}

   

    /**
     * Update the validation rules for an Organization. Argument HashMap
     * contains VALIDATION-BUNDLE KEY as the key and checked/unchecked status as
     * value.  Note that VALIDATION-BUNDLE KEY is not the same as the validator
     * classname.  The bundle key is a key in the webtier bundle (refer to
     * VALIDATIONRULE table in the db for the bundlename).
     *
     * @see ValidationRule ValidationRule for a list of VALIDATION-RULE keys
     *
     * @param validationMap - contains VALIDATION-BUNDLEKEY as the key and
     *                          Boolean checked/unchecked status as value.
     * @param orgnizationId - the organization to update.
     * @param shallow - If true, we will update only the specified org. If false,
     *           then we update the child orgs too, if any. In other words, ALL of the
     *           child orgs' rules of ALL types will be removed, and they will inherit
     *           their settings from this org.
     * @param List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs - a list of activity types for TimeOff Request Validation
     * @throws BbmUpdateException if there is an error.
     */
	public void updateValidationRules(Map validationMap, ID organizationId, boolean shallow, List&lt;ID&gt; listSelectedTimeOffTypeActivityIDs)
	    throws BbmCreateException, BbmUpdateException
    {

<span class="fc" id="L355">		final String l_MethodName = &quot;updateValidationRules&quot;;</span>
<span class="fc" id="L356">		methodStart(l_MethodName, validationMap, organizationId);</span>
<span class="fc" id="L357">		OrgValidationDAO dao = new  OrgValidationDAO();</span>
		try
        {
<span class="fc" id="L360">			dao.savePropertyList(organizationId, validationMap, shallow, listSelectedTimeOffTypeActivityIDs);</span>
<span class="fc" id="L361">            triggerWaitlistScan(organizationId);</span>
		}
<span class="nc" id="L363">        catch (Exception e)</span>
        {
<span class="nc" id="L365">            handleException(e);</span>
<span class="nc" id="L366">            throw RequestUtil.createBbmUpdateExceptionWrapper(e, m_cat);</span>
        }
        finally
        {
<span class="pc" id="L370">			methodFinish();</span>
<span class="pc" id="L371">			dao.cleanUp();</span>
<span class="fc" id="L372">		}</span>
<span class="fc" id="L373">	}</span>

   

    /**
	 * Return a map of validation class Name to validation resource key name.
	 */
	public Map getValidationRuleMap() throws BbmFinderException
	{
<span class="fc" id="L382">		final String l_MethodName = &quot;getValidationRuleMap&quot;;</span>
<span class="fc" id="L383">		methodStart(l_MethodName);</span>
<span class="fc" id="L384">		ValidationRuleDAO dao = new ValidationRuleDAO();</span>
<span class="fc" id="L385">		HashMap results = new HashMap(31);</span>
		try {
<span class="fc" id="L387">			Collection rules = dao.getObjects(null);</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">			if (rules != null) {</span>
<span class="fc" id="L389">				Iterator itr = rules.iterator();</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">				while (itr.hasNext()) {</span>
<span class="fc" id="L391">					ValidationRule vr = (ValidationRule)itr.next();</span>
<span class="fc" id="L392">					results.put(vr.getValidator(), vr.getKey());</span>
<span class="fc" id="L393">				}</span>
			}
<span class="nc" id="L395">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L396">			handleException(&quot;getValidationRuleMap&quot;, e, false);</span>
<span class="nc" id="L397">			throw e;</span>
		} finally {
<span class="pc" id="L399">			methodFinish();</span>
<span class="pc" id="L400">			dao.cleanUp();</span>
<span class="fc" id="L401">		}</span>
<span class="fc" id="L402">		return results;</span>
	}

	/**
	 * Return a collection of validation objects
	 */
	public Collection getValidationRules() throws BbmFinderException {
<span class="fc" id="L409">		final String l_MethodName = &quot;getValidationRules&quot;;</span>
<span class="fc" id="L410">		methodStart(l_MethodName);</span>
<span class="fc" id="L411">		ValidationRuleDAO dao = new ValidationRuleDAO();</span>
		try {
<span class="fc" id="L413">			return dao.getObjects(null);</span>
<span class="nc" id="L414">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L415">			handleException(&quot;getValidationRules&quot;, e, false);</span>
<span class="nc" id="L416">			throw e;</span>
		} finally {
<span class="pc" id="L418">			methodFinish();</span>
<span class="pc" id="L419">			dao.cleanUp();</span>
		}
	}

	/**
	 * Get a map of the different validation bundle keys given a request type.
     * All the values will be set to false. Your job will be to populate the map
     * with real values from the database.
	 *
	 * @param requestType - the request type to get the map for.
	 * @return Map - of the validation information
	 */
	private Map&lt;Object, Object&gt; getInitValidationMap(String requestType)
    {
		//Due to timeoff types being validated by activity, we now have 
		//3 states: 0=not validate, 1=validate, 2=partially validatable
<span class="fc" id="L435">		final Integer iFalse = 0;</span>
<span class="pc bpc" id="L436" title="1 of 2 branches missed.">		if (requestType == null) {</span>
<span class="nc" id="L437">			requestType = Request.REQUESTTYPE_ALL;</span>
		}
<span class="fc" id="L439">		boolean all = requestType.equals(Request.REQUESTTYPE_ALL);</span>
<span class="pc bpc" id="L440" title="1 of 2 branches missed.">		boolean shiftSwap = all ||</span>
<span class="pc bnc" id="L441" title="All 2 branches missed.">			requestType.equals(Request.REQUESTTYPE_SHIFTSWAP);</span>
<span class="pc bpc" id="L442" title="1 of 2 branches missed.">		boolean shiftSwapWithdraw = all ||</span>
<span class="pc bnc" id="L443" title="All 2 branches missed.">				requestType.equals(Request.REQUESTTYPE_SHIFTSWAP_WITHDRAW);</span>
<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		boolean timeOff = all ||</span>
<span class="pc bnc" id="L445" title="All 2 branches missed.">			requestType.equals(Request.REQUESTTYPE_TIMEOFF);</span>
<span class="pc bpc" id="L446" title="1 of 2 branches missed.">		boolean flexTime = all ||</span>
<span class="pc bnc" id="L447" title="All 2 branches missed.">				requestType.equals(Request.REQUESTTYPE_FLEXTIME);</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">		boolean shiftBid = all ||</span>
<span class="pc bnc" id="L449" title="All 2 branches missed.">			requestType.equals(Request.REQUESTTYPE_SHIFTBID);</span>
<span class="pc bpc" id="L450" title="1 of 2 branches missed.">		boolean timeOffWithdraw = all ||</span>
<span class="pc bnc" id="L451" title="All 2 branches missed.">			requestType.equals(Request.REQUESTTYPE_TIMEOFF_WITHDRAW);</span>
<span class="pc bpc" id="L452" title="1 of 2 branches missed.">		boolean customShift = all ||</span>
<span class="pc bnc" id="L453" title="All 2 branches missed.">		requestType.equals(Request.REQUESTTYPE_CUSTSHIFT);</span>

<span class="fc" id="L455">		HashMap map = new HashMap(31);</span>
<span class="pc bpc" id="L456" title="1 of 2 branches missed.">		if (shiftSwap) {</span>
			// for Shift swap
<span class="fc" id="L458">			map.put(ValidationRule.VALIDATION_SS_SAME_CALL_CENTER, iFalse);</span>
<span class="fc" id="L459">			map.put(ValidationRule.VALIDATION_SS_SAME_CAMPAIGN, iFalse);</span>
<span class="fc" id="L460">			map.put(ValidationRule.VALIDATION_SS_SAME_SKILLS, iFalse);</span>
<span class="fc" id="L461">			map.put(ValidationRule.VALIDATION_SS_AT_LEAST_SAME_SKILLS, iFalse);</span>
<span class="fc" id="L462">			map.put(ValidationRule.VALIDATION_SS_SAME_PROFICIENCY, iFalse);</span>
<span class="fc" id="L463">			map.put(ValidationRule.VALIDATION_SS_COMPLY_HRS, iFalse);</span>
<span class="fc" id="L464">			map.put(ValidationRule.VALIDATION_SS_NO_EVENT_OVERLAP, iFalse);</span>
<span class="fc" id="L465">			map.put(ValidationRule.VALIDATION_SS_EVENT_MUST_OVERLAP, iFalse);</span>
<span class="fc" id="L466">			map.put(ValidationRule.VALIDATION_SS_PAID_HRS, iFalse);</span>
<span class="fc" id="L467">			map.put(ValidationRule.VALIDATION_SS_SHIFT_START, iFalse);</span>
<span class="fc" id="L468">			map.put(ValidationRule.VALIDATION_SS_COMPLY_RULES, iFalse);</span>
<span class="fc" id="L469">			map.put(ValidationRule.VALIDATION_PSS_MIN_SHIFT_SWAP_DURATION, iFalse);</span>
<span class="fc" id="L470">			map.put(ValidationRule.VALIDATION_PSS_MIN_REMAINING_SHIFT_DURATION, iFalse);</span>
<span class="fc" id="L471">			map.put(ValidationRule.VALIDATION_PSS_MAX_SWAP_DURATION_PER_DAY, iFalse);</span>
<span class="fc" id="L472">			map.put(ValidationRule.VALIDATION_PSS_NON_SWAPPABLE_ACTIVITIES, iFalse);</span>
<span class="fc" id="L473">			map.put(ValidationRule.VALIDATION_PSS_SHIFT_GAP_CONDITIONS, iFalse);</span>
<span class="fc" id="L474">			map.put(ValidationRule.VALIDATION_PSS_MAX_ALLOWABLE_OVERLAP, iFalse);</span>
<span class="fc" id="L475">			map.put(ValidationRule.VALIDATION_SS_MAX_CONSECUTIVE_WORKING_DAYS, iFalse);</span>
<span class="fc" id="L476">			map.put(ValidationRule.VALIDATION_SS_MIN_TIME_BETWEEN_SHIFT_ASSIGNMENTS, iFalse);</span>
<span class="fc" id="L477">			map.put(ValidationRule.VALIDATION_SS_MAX_ONE_WAY_SWAP_PER_PERSON_PERIOD, iFalse);</span>
<span class="fc" id="L478">			map.put(ValidationRule.VALIDATION_SS_MAX_APPROVED_SWAP_PER_SHIFT, iFalse);</span>
<span class="fc" id="L479">			map.put(ValidationRule.VALIDATION_PSS_MAX_APPROVED_PARTIAL_SWAPS_PER_SHIFT, iFalse);</span>
<span class="fc" id="L480">			map.put(ValidationRule.VALIDATION_SS_MAX_HOURS_ALTERNATE_MAX_HOURS_PER_DAY, iFalse);</span>
		}

<span class="pc bpc" id="L483" title="1 of 2 branches missed.">		if (shiftSwapWithdraw) {</span>
<span class="fc" id="L484">			map.put(ValidationRule.VALIDATION_APPROVED_SS_WITHDRAW_COMPLY_FILINGRULE   , iFalse);</span>
		}

<span class="pc bpc" id="L487" title="1 of 2 branches missed.">		if (timeOffWithdraw) {</span>
<span class="fc" id="L488">			map.put(ValidationRule.VALIDATION_APPROVED_TO_WITHDRAW_COMPLY_FILINGRULE   , iFalse);</span>
		}

<span class="pc bpc" id="L491" title="1 of 2 branches missed.">		if (timeOff) {</span>
<span class="fc" id="L492">			map.put(ValidationRule.VALIDATION_AVAILABLE_TO_HRS   , iFalse);</span>
<span class="fc" id="L493">			map.put(ValidationRule.VALIDATION_ENOUGH_TO_HRS      , iFalse);</span>
<span class="fc" id="L494">			map.put(ValidationRule.VALIDATION_COMPLY_FILINGRULE  , iFalse);</span>
<span class="fc" id="L495">			map.put(ValidationRule.VALIDATION_AVOID_BLACKOUT     , iFalse);</span>
<span class="fc" id="L496">			map.put(ValidationRule.VALIDATION_AVOID_CAL_EVENTS   , iFalse);</span>
<span class="fc" id="L497">			map.put(ValidationRule.VALIDATION_TO_NOT_SWAPPED     , iFalse);</span>
<span class="fc" id="L498">			map.put(ValidationRule.VALIDATION_REQ_MIN_DURATION   , iFalse);</span>
<span class="fc" id="L499">			map.put(ValidationRule.VALIDATION_REQ_MAX_DURATION   , iFalse);</span>
<span class="fc" id="L500">			map.put(ValidationRule.VALIDATION_REQUEST_IN_PAST    , iFalse);</span>
<span class="fc" id="L501">			map.put(ValidationRule.VALIDATION_VTO_REDUCE_NET_STAFFING_SURPLUS    , iFalse);</span>
<span class="fc" id="L502">			map.put(ValidationRule.VALIDATION_VTO_COMPLY_MAX_VTO_HRS    , iFalse);</span>
<span class="fc" id="L503">			map.put(ValidationRule.VALIDATION_TOB_COMPLY_MAX_EMPLOYEE_APPROVAL    , iFalse);</span>
<span class="fc" id="L504">			map.put(ValidationRule.VALIDATION_TOB_SUBMITTED_DATE, iFalse);</span>
<span class="fc" id="L505">			map.put(ValidationRule.VALIDATION_TOB_DONOT_APPROVE_OVERLAP_REQUEST, iFalse);</span>
		}

<span class="pc bpc" id="L508" title="1 of 2 branches missed.">		if(flexTime) {</span>
<span class="fc" id="L509">			map.put(ValidationRule.VALIDATION_FT_MAX_DURATION   					, iFalse);</span>
<span class="fc" id="L510">			map.put(ValidationRule.VALIDATION_FT_MIN_DURATION   					, iFalse);</span>
<span class="fc" id="L511">			map.put(ValidationRule.VALIDATION_FT_MAX_NUMBER_MAKEUP_PER_REQUEST   	, iFalse);</span>
<span class="fc" id="L512">			map.put(ValidationRule.VALIDATION_FT_MAX_NUMBER_FLEX_REQ_PER_PERIOD  	, iFalse);</span>
<span class="fc" id="L513">			map.put(ValidationRule.VALIDATION_FT_MUST_OCCUR_ASAP   					, iFalse);</span>
<span class="fc" id="L514">			map.put(ValidationRule.VALIDATION_FT_AVOID_SCHEDULED_CALENDAR_EVENTS   	, iFalse);</span>
<span class="fc" id="L515">			map.put(ValidationRule.VALIDATION_FT_COMPLYING_FILING_RULES   			, iFalse);</span>
<span class="fc" id="L516">			map.put(ValidationRule.VALIDATION_FT_MAKEUP_COMPLYING_HOO   			, iFalse);</span>
<span class="fc" id="L517">			map.put(ValidationRule.VALIDATION_FT_MIN_GAP_BETWEEN_CONSECUTIVE_SHIFTS , iFalse);</span>
<span class="fc" id="L518">			map.put(ValidationRule.VALIDATION_FT_MAX_SHIFT_DURATION, 				  iFalse);</span>
			
		}

<span class="pc bpc" id="L522" title="1 of 2 branches missed.">		if (shiftBid) {</span>
<span class="fc" id="L523">			map.put(ValidationRule.VALIDATION_SB_COMPLY_RULES    , iFalse);</span>
<span class="fc" id="L524">			map.put(ValidationRule.VALIDATION_SB_COMPLY_HRS      , iFalse);</span>
<span class="fc" id="L525">			map.put(ValidationRule.VALIDATION_SB_COMPLY_SKILLS   , iFalse);</span>
<span class="fc" id="L526">			map.put(ValidationRule.VALIDATION_SB_COMPLY_AT_LEAST_SKILLS, iFalse);</span>
<span class="fc" id="L527">			map.put(ValidationRule.VALIDATION_SB_COMPLY_HOO      , iFalse);</span>
		}
<span class="pc bpc" id="L529" title="1 of 2 branches missed.">		if (customShift) {</span>
<span class="fc" id="L530">			map.put(ValidationRule.VALIDATION_CS_FULFILLS_NET_STAFFING_SHORTAGE    , iFalse);</span>
<span class="fc" id="L531">			map.put(ValidationRule.VALIDATION_CS_MAX_SHIFT_DURATION_PER_DAY    , iFalse);</span>
<span class="fc" id="L532">			map.put(ValidationRule.VALIDATION_CS_MIN_SHIFT_DURATION_PER_DAY    , iFalse);</span>
<span class="fc" id="L533">			map.put(ValidationRule.VALIDATION_CS_MAX_CONSECUTIVE_WORKING_DAYS    , iFalse);</span>
<span class="fc" id="L534">			map.put(ValidationRule.VALIDATION_CS_MIN_TIME_BETWEEN_SHIFT_ASSIGNMENTS    , iFalse);</span>
<span class="fc" id="L535">			map.put(ValidationRule.VALIDATION_CS_COMPLY_RULES    , iFalse);</span>
<span class="fc" id="L536">			map.put(ValidationRule.VALIDATION_CS_COMPLY_HRS    , iFalse);</span>
<span class="fc" id="L537">			map.put(ValidationRule.VALIDATION_CS_COMPLY_HOO    , iFalse);</span>
<span class="fc" id="L538">			map.put(ValidationRule.VALIDATION_CS_TIMEOFF_OVERLAP    , iFalse);</span>
<span class="fc" id="L539">			map.put(ValidationRule.VALIDATION_CS_UNAVAILABILITY_OVERLAP    , iFalse);</span>
<span class="fc" id="L540">			map.put(ValidationRule.VALIDATION_CS_PUBLISHED_PERIOD    , iFalse);</span>
		}

<span class="fc" id="L543">		return map;</span>
	}
    public void triggerWaitlistScan(ID orgID) throws BbmUpdateException {
<span class="fc" id="L546">        TONotifyMessageClient toNotifyMessageClient = new TONotifyMessageClient();</span>
<span class="fc" id="L547">        toNotifyMessageClient.scanTOWaitlist(orgID, true, TONotifyMessage.TO_NOTIFY_VALIDATION_RULE_CHANGE);</span>
<span class="fc" id="L548">    }</span>

	/**
	 * Given an orgID, return whether it has any children.
	 *
	 * @param orgID The ID of the organization whose to investigate.
	 * @return True if the org has any children orgs, false otherwise.
	 */
	private boolean getHasChildren(ID orgID) throws BbmFinderException {
		try {
<span class="fc" id="L558">			return BbmManagerFactory.getWorkResourceManager().organizationHasChildren(orgID);</span>
<span class="nc" id="L559">		} catch (Exception e) {</span>
<span class="nc" id="L560">			handleException(e);</span>
<span class="nc" id="L561">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		}
	}

	public Map&lt;Integer, List&lt;String&gt;&gt; getEnabledTimeOffRuleKeys(ID organizationId) throws BbmFinderException {
<span class="nc" id="L566">		OrgValidationDAO dao = null;</span>
		try {
<span class="nc" id="L568">			dao = new OrgValidationDAO();</span>
<span class="nc" id="L569">			return dao.getEnabledTimeOffRuleKeys(organizationId);</span>
<span class="nc" id="L570">		} catch (Exception e) {</span>
<span class="nc" id="L571">			handleException(e);</span>
<span class="nc" id="L572">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc bnc" id="L574" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L575">				dao.cleanUp();</span>
			}
		}

	}

	/**
	 * Gets a collection of the effective ValidationRules and parameter values for the org.
	 * If there are multiple rules for different activity (validation by time off type), a rule is returned for each rule and activity.
	 */
	public Collection&lt;ValidationRule&gt; getEffectiveOrgValidationRules(ID orgID) throws BbmFinderException {
<span class="nc" id="L586">		final String l_MethodName = &quot;getEffectiveOrgValidationRules&quot;;</span>
<span class="nc" id="L587">		methodStart(l_MethodName, orgID);</span>

<span class="nc" id="L589">		OrgValidationDAO dao = new OrgValidationDAO();</span>

		try {
<span class="nc" id="L592">			boolean isValidationByTimeOffType = LicenseUtil.isAdvancedRMLicenseForValidationByType();</span>
<span class="nc" id="L593">			return dao.getEffectiveOrgValidationRules(orgID, isValidationByTimeOffType);</span>
<span class="nc" id="L594">		} catch (Exception e) {</span>
<span class="nc" id="L595">			handleException(e);</span>
<span class="nc" id="L596">			throw RequestUtil.createBbmFinderExceptionWrapper(e, m_cat);</span>
		} finally {
<span class="nc" id="L598">			methodFinish();</span>
<span class="nc" id="L599">			dao.cleanUp();</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>