<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TextAppletIO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.core.applet</a> &gt; <span class="el_source">TextAppletIO.java</span></div><h1>TextAppletIO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.core.applet;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.StringTokenizer;

import com.bluepumpkin.common.datatypes.ID;

/**
 * Title:        TextAppletIO
 * Description:  An implementation of communication between the applet and the server.  This implementation
 *   uses clear text for the communication mechanism.
 *
 * Copyright:    Copyright (c) 2004
 * Company:      Blue Pumpkin Software, Inc
 * @author       Alvin Cham
 * @version      1.0
 *
 * Created on Apr 15, 2003, 4:05:33 PM
 */
public class TextAppletIO implements AppletIO {

	/**
	 *  Retrieves the singleton instance of this object.
	 */
	static public TextAppletIO getInstance() {
<span class="nc" id="L37">		return m_instance;</span>
	}

	// ***********************************************
	// a set of packaging routines.
	//
	// text -&gt; different java objects.
	// ***********************************************

	static public Collection convertToCollection(String str) {
<span class="nc" id="L47">		StringTokenizer st = new StringTokenizer(str, &quot;,&quot;);</span>
<span class="nc" id="L48">		Collection c = new ArrayList(st.countTokens());</span>

<span class="nc bnc" id="L50" title="All 2 branches missed.">		while (st.hasMoreTokens()) {</span>
<span class="nc" id="L51">			String token = st.nextToken();</span>
<span class="nc" id="L52">			c.add(token);</span>
<span class="nc" id="L53">		}</span>
<span class="nc" id="L54">		return c;</span>
	}
	
	static public Collection convertToIDCollection(String str) {
<span class="nc" id="L58">		StringTokenizer st = new StringTokenizer(str, &quot;,&quot;);</span>
<span class="nc" id="L59">		Collection c = new ArrayList(st.countTokens());</span>

<span class="nc bnc" id="L61" title="All 2 branches missed.">		while (st.hasMoreTokens()) {</span>
<span class="nc" id="L62">			String token = st.nextToken();</span>
<span class="nc" id="L63">			c.add(new ID(token));</span>
<span class="nc" id="L64">		}</span>
<span class="nc" id="L65">		return c;</span>
	}

	static public HashMap convertToHashMap(String map) {
<span class="nc" id="L69">		StringTokenizer st = new StringTokenizer(map, &quot;,&quot;);</span>
<span class="nc" id="L70">		HashMap ret = new HashMap();</span>

<span class="nc bnc" id="L72" title="All 2 branches missed.">		while (st.hasMoreTokens()) {</span>
<span class="nc" id="L73">			String token = st.nextToken();</span>

<span class="nc" id="L75">			StringTokenizer element = new StringTokenizer(token, &quot;:&quot;);</span>
<span class="nc" id="L76">			String key = element.nextToken();</span>
<span class="nc" id="L77">			String property = element.nextToken();</span>
<span class="nc" id="L78">			ret.put(key, property);</span>
<span class="nc" id="L79">		}</span>
<span class="nc" id="L80">		return ret;</span>
	}

	static public Integer convertToInteger(String numString) {
<span class="nc" id="L84">		return new Integer(numString);</span>
	}

	static public Boolean convertToBoolean(String booleanValue) {
<span class="nc bnc" id="L88" title="All 2 branches missed.">		if (&quot;true&quot;.equalsIgnoreCase(booleanValue))</span>
<span class="nc" id="L89">			return Boolean.TRUE;</span>
<span class="nc" id="L90">		return Boolean.FALSE;</span>
	}

	static public Date convertToDate(String timeInMillis) {
<span class="nc bnc" id="L94" title="All 2 branches missed.">		if (timeInMillis.equals(&quot;null&quot;))</span>
<span class="nc" id="L95">			return null;</span>
<span class="nc" id="L96">		return new Date((new Long(timeInMillis)).longValue());</span>
	}

	// ***********************************************
	// a set of un-packaging routines.
	//
	// different java objects -&gt; text
	// ***********************************************
	static public String unPackage(Date date) {
<span class="nc bnc" id="L105" title="All 2 branches missed.">		if (date == null)</span>
<span class="nc" id="L106">			return &quot;null&quot;;</span>
<span class="nc" id="L107">		return String.valueOf(date.getTime());</span>
	}

	static public String unPackage(Boolean b) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (b.booleanValue()) </span>
<span class="nc" id="L112">			return &quot;true&quot;;</span>
		else
<span class="nc" id="L114">			return &quot;false&quot;;</span>
	}

	static public String unPackage(Integer i) {
<span class="nc" id="L118">		return String.valueOf(i);</span>
	}

	/**
	 *  Expects a collection of strings...  The individual strings
	 *  must be pre-packaged by the application for each appropriate object type.
	 *
	 *  @return a comma delimited string.
	 *     &lt;str1&gt;,&lt;str2&gt;,...,&lt;str-n&gt;
	 */
	static public String unPackage(Collection c) {
<span class="nc" id="L129">		boolean first = true;</span>
<span class="nc" id="L130">		StringBuffer sb = new StringBuffer(128);</span>

<span class="nc bnc" id="L132" title="All 2 branches missed.">		for (Iterator iter=c.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L133">			String s = (String)iter.next();</span>
<span class="nc bnc" id="L134" title="All 2 branches missed.">			if (first) {</span>
<span class="nc" id="L135">				first = false;</span>
			} else {
<span class="nc" id="L137">				sb.append(&quot;,&quot;);</span>
			}
<span class="nc" id="L139">			sb.append(s);</span>
<span class="nc" id="L140">		}</span>
<span class="nc" id="L141">		return sb.toString();</span>
	}
	
	/**
	 *  Expects a collection of strings...  The individual strings
	 *  must be pre-packaged by the application for each appropriate object type.
	 *
	 *  @return a comma delimited string.
	 *     &lt;str1&gt;,&lt;str2&gt;,...,&lt;str-n&gt;
	 */
	static public String unPackageIDs(Collection c) {
<span class="nc" id="L152">		boolean first = true;</span>
<span class="nc" id="L153">		StringBuffer sb = new StringBuffer(128);</span>

<span class="nc bnc" id="L155" title="All 2 branches missed.">		for (Iterator iter=c.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L156">			String s = ((ID)iter.next()).toString();</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (first) {</span>
<span class="nc" id="L158">				first = false;</span>
			} else {
<span class="nc" id="L160">				sb.append(&quot;,&quot;);</span>
			}
<span class="nc" id="L162">			sb.append(s);</span>
<span class="nc" id="L163">		}</span>
<span class="nc" id="L164">		return sb.toString();</span>
	}

	/**
	 *  Expects a map of string keys and values.  The individual strings
	 *  must be pre-packaged by the application for each appropriate object type.
	 *
	 *  @return a comma delimited key-value pairs.
	 *     &lt;key1&gt;:&lt;value1&gt;,&lt;key2&gt;:&lt;value2&gt;,...,&lt;key-n&gt;:&lt;value-n&gt;
	 */
	static public String unPackage(Map map) {
<span class="nc" id="L175">		boolean first = true;</span>
<span class="nc" id="L176">		StringBuffer sb = new StringBuffer(128);</span>

<span class="nc bnc" id="L178" title="All 2 branches missed.">		for (Iterator iter=map.keySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L179">			String key = (String)iter.next();</span>
<span class="nc" id="L180">			String value = (String)map.get(key);</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">			if (first) {</span>
<span class="nc" id="L182">				first = false;</span>
			} else {
<span class="nc" id="L184">				sb.append(&quot;,&quot;);</span>
			}
<span class="nc" id="L186">			sb.append(key).append(&quot;:&quot;).append(value);</span>
<span class="nc" id="L187">		}</span>
<span class="nc" id="L188">		return sb.toString();</span>




	}

<span class="nc" id="L195">	private static TextAppletIO m_instance = new TextAppletIO();</span>

<span class="nc" id="L197">	private TextAppletIO() {}</span>

	// -------------------------------------------------------
	// public instance methods
	// -------------------------------------------------------

	/**
	 * Write specified Map to the OutputStream in a clear text format.  
	 *
	 * @param out - OutputStream to be written to
	 * @param data - The data to be writen.  For this implementation, the key
	 *   and the value for this Map object must both be of type String.  It is
	 *   up to the application, however, on how to package these strings.
	 *
	 * @throws IOException
	 */
	public void write(OutputStream out, Map data) throws IOException {
<span class="nc" id="L214">		writeObject(out, data);</span>
<span class="nc" id="L215">	}</span>

	/**
	 * Read String from specified InputStream.
	 *
	 * @param in - InputStream where Map resides
	 * @return A Map object that contains parameters and values of type String
	 * @throws IOException
	 * @throws ClassNotFoundException
	 */
	public Map read(InputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L226">		return readObject(in);</span>
	}

	// -------------------------------------------------------
	// private methods
	// -------------------------------------------------------

	/**
	 * Write specified Map to specified OutputStream
	 *
	 * @param out - OutputStream to write Object to
	 * @param map - The Map to write to OutputStream
	 * @throws IOException
	 */
	private void writeObject(OutputStream out, Map map) throws IOException {
<span class="nc" id="L241">		PrintWriter writer = null;</span>

		// go through map.
<span class="nc" id="L244">		StringBuffer sb = new StringBuffer(512);</span>
<span class="nc" id="L245">		int mapSize = map.size();</span>
<span class="nc" id="L246">		int cnt = 0;</span>
<span class="nc bnc" id="L247" title="All 2 branches missed.">		for (Iterator iter = map.keySet().iterator(); iter.hasNext();) {</span>
<span class="nc" id="L248">			String prop = (String)iter.next();</span>
<span class="nc" id="L249">			String key = (String)map.get(prop);</span>

<span class="nc" id="L251">			sb.append(prop).append(&quot;=&quot;).append(key);</span>
<span class="nc" id="L252">			cnt++;</span>

			// if this is not last, append an '&amp;' to the end to let the server know more is coming
<span class="nc bnc" id="L255" title="All 2 branches missed.">			if (cnt != mapSize) {</span>
<span class="nc" id="L256">				sb.append(&quot;&amp;&quot;);</span>
			}
<span class="nc" id="L258">		}</span>

		try {
<span class="nc" id="L261">			writer = new PrintWriter(out);</span>
<span class="nc" id="L262">			writer.print(sb.toString());</span>
<span class="nc" id="L263">			writer.flush();</span>
		}	finally {
<span class="nc bnc" id="L265" title="All 4 branches missed.">			if (writer != null) {</span>
				try {
<span class="nc" id="L267">					writer.close();</span>
<span class="nc" id="L268">				} catch( Exception e) {</span>
					// we don't care about the exception
<span class="nc" id="L270">				}</span>
			}
		}
<span class="nc" id="L273">	}</span>

	/**
	 * Read String from specified InputStream
	 *
	 * @param in - The InputStream to read String from
	 * @return A Map object containing parameters and keys in type String
	 */
	private Map readObject(InputStream in) throws IOException, ClassNotFoundException {
<span class="nc" id="L282">		BufferedReader reader = null;</span>
<span class="nc" id="L283">		StringBuffer contents = null;</span>

		try {
<span class="nc" id="L286">			reader = new BufferedReader(new InputStreamReader(in),4096);</span>
<span class="nc" id="L287">			contents = new StringBuffer(4096);</span>
<span class="nc" id="L288">			char[] buffer = new char[4096];</span>
<span class="nc" id="L289">			int nb = 0;</span>
			while (true) {
<span class="nc" id="L291">				nb = reader.read(buffer, 0, 4096);</span>
<span class="nc bnc" id="L292" title="All 2 branches missed.">				if (nb == -1) </span>
<span class="nc" id="L293">					break;</span>
<span class="nc" id="L294">				contents.append(buffer, 0, nb);</span>
			}
		}	finally {
<span class="nc bnc" id="L297" title="All 4 branches missed.">			if ( reader != null ) {</span>
				try {
<span class="nc" id="L299">					reader.close();</span>
<span class="nc" id="L300">				} catch ( Exception ie) {</span>
					// we don't care for this exception
<span class="nc" id="L302">				}</span>
			}
		}

<span class="nc" id="L306">		Map data = new HashMap(8);</span>

<span class="nc bnc" id="L308" title="All 2 branches missed.">		if (contents != null) {</span>
<span class="nc" id="L309">			StringTokenizer st = new StringTokenizer(contents.toString(),&quot;&amp;&quot;);</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">			while (st.hasMoreTokens()) {</span>
<span class="nc" id="L311">				String token = st.nextToken();</span>
<span class="nc" id="L312">				int idx = token.indexOf(&quot;=&quot;);</span>
<span class="nc" id="L313">				String param = token.substring(0, idx);</span>
<span class="nc" id="L314">				String value = token.substring(idx+1);</span>
<span class="nc" id="L315">				data.put(param, value);</span>
<span class="nc" id="L316">			}</span>
		}
<span class="nc" id="L318">		return data;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>