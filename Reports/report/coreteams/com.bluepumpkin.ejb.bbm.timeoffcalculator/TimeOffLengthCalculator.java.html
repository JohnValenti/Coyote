<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeOffLengthCalculator.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeoffcalculator</a> &gt; <span class="el_source">TimeOffLengthCalculator.java</span></div><h1>TimeOffLengthCalculator.java</h1><pre class="source lang-java linenums">/*
 * TimeOffLengthCalculator.java
 * Copyright (c) 2002, Blue Pumpkin Software, Inc
 * All rights reserved
 */

package com.bluepumpkin.ejb.bbm.timeoffcalculator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.CollectionUtil;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.holiday.model.Holiday;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTimeOffDefault;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOO;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.gcr.ejb.GCRManager;
import com.witness.ejb.core.gcr.model.GCREntry;

/**
 * This class computes the length of a time off request. This calculation
 * depends on whether the time off interval falls before or after the last shift
 * assignment for the employee
 *
 * &lt;pre&gt;
 * &lt;code&gt;
 * Legend:
 * OW -- OrgWeekBoundary.
 * OD -- OrgDayBoundary.
 * CD -- CutoffDay (org day with last shift for employee).
 * 
 *                                &lt;--- **TOEvent** ----&gt;
 *                      |-----------------------------------------------|                                   -
 *    #   |   |   |   |   |   |   #   |   |   |   |   x   |   #   |   |   |   |   |   |   #   |   |   |
 *    #   |   |   |   |   |   |   #   |   |   |   |   x   |   #   |   |   |   |   |   |   #   |   |   |
 *    #   |   |   |   |   |   |   #   |   |   |   |   x   |   #   |   |   |   |   |   |   #   |   |   |
 *    #                           #                   x       #                           #
 * -------------------------------- **Calendar ** ----x--------------------------------------------------------
 * ---------------------------------------------------x--------------------------------------------------------
 *    #                           #                   x       #                           #
 *    #   |   |   |   |   |   |   #   |   |   |   |   x   |   #   |   |   |   |   |   |   #   |   |   |
 *    #   |   |   |   |   |   |   #   |   |   |   |   x   |   #   |   |   |   |   |   |   #   |   |   |
 *   OW   OD  OD  OD  OD  OD  OD  OW  OD  OD  OD OD   CD  OD  OW  OD  OD  OD  OD  OD  OD  OW  OD  OD  OD
 * 
 * &lt;/code&gt;
 * &lt;/pre&gt;
 *
 * &lt;p&gt;
 * The calculator is set up to compute lengths of time off requests for a single
 * employee during a given time period. Batch processing of requests from
 * multiple employees should create one TimeOffLengthCalculator per employee of
 * interest.
 * &lt;li&gt;The computation is done one org day at a time.
 * &lt;li&gt;The duration of the TOEvt is divided into two: scheduled period (before
 * and including the day of last shift) and an unscheduled period.
 * &lt;li&gt;For orgDays where TOEvent overlaps the scheduled period, the TOLength is
 * the hours of overlap with shifts minus any unpaid shift events within the
 * shift.
 * &lt;li&gt;For orgDays where the TOEvent overlaps unscheduled periods, the TOlength
 * is the overlap with workable hours (HOO minus unavails minus holidays for the
 * orgDay), up to the daily maximum, subject to the weekly maximum.
 * &lt;li&gt;For periods where the TOEvt overlaps the unscheduled period, the
 * computation is done orgWeek by orgWeek. The reason being that the
 * 'otherTOEvents' that occur prior to 'thisTOEvent' during the orgWeek, also
 * need to be considered to calculate the TOLengh of 'thisTOEvent'.
 *
 * &lt;p&gt;
 * &lt;b&gt;Rules:&lt;/b&gt;
 * &lt;li&gt;If any seed event exceeds the calculator's range, event must be trimmed.
 * If not, TimeMap.setRange() will throw an exception. Instead of trimming the
 * event itself, the implemntation trims just the dates passed to the timemap.
 * &lt;li&gt;When computing TOLength for a timeRange which overlaps the unscheduled
 * period, the the entire unscheduled period within the org week must be
 * considered. To understand the reason for this, consider this scenario: For a
 * week after the cut-off day, assume there are 2 timeoff events. To compute the
 * length of the 2nd event, the first must be considered as well since the TO
 * hours, subject to the daily and weekly default, may be consumed by the first
 * event itself. This will leave the 2nd with no more hours.
 * &lt;li&gt;For the cut-off org week, the unscheduled period within the org week is
 * the period after the cut-off day. For org weeks after the cut-off orgWeek,
 * the unscheduled period within the orgWeek is the entire orgWeek.
 * &lt;li&gt;If an interval exists between the start of the unscheduled period of the
 * orgWeek and the first day of the TOEvent in the unscheduled portion of the
 * orgWeek, then load all other TOEvents in the interval to compute the length
 * of the given TOEvent.
 * &lt;li&gt;If any unscheduled period exists in the TOCalculators's range during the
 * first or last orgWeek, then the first or last orgWeek must be expanded to
 * include the entire unscheduled period within these orgWeek See
 * {@link com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffLengthCalculatorHelper#getCalculator(ID, Organization, TimeRange, Collection, Collection, Collection, Collection, ShiftAssignment, Map)
 * getCalculator()} for more information.
 *
 *
 * &lt;p&gt;
 * To implenent the above rules:
 * 
 * &lt;pre&gt;
 *  1. if (TOEvtRangeStart.after(lastShiftAssn)
 *        move rangeStart to the closest earlier orgWeekStart (for rule above).
 *        load unavailabilites, holidays and hoos between origal rangeStart and adjusted rangeStart.
 *     end if
 *  2. if (TOEvtRangeEnd.after(lastShiftAssignment),
 *        move endRange to the next closest orgWeekEnd. (for rule above).
 *        load unavailabilites and holidays between origal rangeEnd and adjustedRangeEnd.
 *     end if
 *  3. Trim the following seed events to fit within the timeRange: shiftAssignments, unavailabilities
 *  4. Set shiftAssignments, unavails and holidays in their respective timeMaps.
 *     TimeMap.setRange() should not throw an exception for the condition
 *     'event exceeds map's range' since the events were already trimmed.
 *
 * &lt;/pre&gt;
 *
 */




//
// TODO: TO length computed for a period after the last shift needs to consider
// the entire org week.
// TODO: TO length computation for a period when employee switches hours.
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">public class  TimeOffLengthCalculator{</span>
<span class="fc" id="L145">	private static final Category LOG = Log.initCategory(TimeOffLengthCalculator.class.getName());</span>

	private static final int EMP_NOT_TERMINATED = 1;
	private static final int EMP_TERMINATED_BEFORE_TO_PERIOD_START = 2;
	private static final int EMP_TERMINATED_BEFORE_TO_PERIOD_END = 3;
	private static final int EMP_TERMINATED_AFTER_TO_PERIOD_END = 4;

	
	/**
	 * States for the published period: unknown, unpublished, or published.
	 */
	public static final int PERIOD_PUBLISHED_UNKNOWN = 0;
	public static final int PERIOD_UNPUBLISHED = 1;
	public static final int PERIOD_PUBLISHED = 2;

	
	
	
	/**
	 * Employee id that this calculator is used for
	 */
<span class="fc" id="L166">	ID empId = null;</span>

	/**
	 * Map of activity id to EmployeeTimeOff objects. Each one contains the
	 * information about how many hours this employee is allotted for each type
	 * of time off activity.
	 */
<span class="fc" id="L173">	Map allotmentMap = null;</span>

	/**
	 * Organization object for the employee during the time period.
	 */
<span class="fc" id="L178">	Organization organization = null;</span>

	/**
	 * Time range that this time off calculator. In order to compute the length
	 * of a time off request, the request must be in this range.
	 */
<span class="fc" id="L184">	TimeRange timeRange = null;</span>
	
	/**
	 * Collection of publishing periods for which the employee has a schedule
	 * published.
	 */

<span class="fc" id="L191">	Collection&lt;PublishingPeriod&gt; publishedPeriods = null;</span>


	/**
	 * Collection of Shift Assignments for the employee during the time range
	 * for this calculator.
	 */
<span class="fc" id="L198">	List&lt;ShiftAssignment&gt; shiftAssignments = null;</span>
	
<span class="fc" id="L200">	List&lt;ShiftAssignment&gt; referenceShiftAssignments = null;</span>

	/**
	 * Collection of unavailabiltiy calendar events, published and unpublished
	 */
<span class="fc" id="L205">	Collection unavailabilityEvents = null;</span>

	/**
	 * Collection of time off events for the employee during the time range for
	 * this calculator.
	 */
<span class="fc" id="L211">	Collection m_TimeOffs = null;</span>

	/**
	 * Collection of organization hours of operation (HOO) assignments. Note:
	 * HOO operation dayStart and dayClose offsets are from midnight. They are
	 * independent of the organization day boundary offset.
	 */
<span class="fc" id="L218">	Collection orgHoursOfOperationAssignments = null;</span>

	/**
	 * Collection of holidays applicable to the employee's organization
	 */
<span class="fc" id="L223">	Collection holidays = null;</span>

	/**
	 * The last shift assigned to the employee that this calculator is
	 * associated with (empId)
	 */
<span class="fc" id="L229">	protected ShiftAssignment lastShiftAssignment = null;</span>

	/**
	 * The duration during which the time off length must be computed is
	 * partitioned into 3 periods: org weeks before the week with last shift
	 * assignment, the org week with the last shift assignment and the org weeks
	 * after the week with the last shift assignment. These fields are used to
	 * determine in which period a given time is located.
	 */
<span class="fc" id="L238">	Date cutOffOrgDayStartTime = null;</span>

	public Date getLastPublishedShiftDayEnd() {
<span class="fc" id="L241">		return cutOffOrgDayEndTime;</span>
	}

<span class="fc" id="L244">	Date cutOffOrgDayEndTime = null;</span>
	/**
	 * orgDayStart for the day after the cutoff day. Note: This date may be
	 * beyond the cutOffOrgWeekEnd if the cutOff day happens to be the last day
	 * in the cutOffOrgWeek.
	 */
<span class="fc" id="L250">	Date cutOffOrgDayNextStartTime = null;</span>
<span class="fc" id="L251">	Date cutOffOrgWeekStartTime = null;</span>
<span class="fc" id="L252">	Date cutOffOrgWeekEndTime = null;</span>

	/**
	 * The TimeMap starts on the organization day that contains
	 * timeRange.startTime and ends on the organization day that contains
	 * timeRange.endTime
	 *
	 * The TimeMap that represents the shifts during the time range (timeRange)
	 * for this calculator. The map has bits set to 'on' during the shift
	 * interval when agents work and has bits set to 'off' during intervals when
	 * they don't (shift event assignments such as lunch breaks, breaks etc).
	 *
	 * Used to represent paid shift hours for each org day
	 *
	 * see also {@link #initShiftAssignmentMap() setShiftAssignmentsInMap()}
	 */
<span class="fc" id="L268">	protected TimeMap shiftAssignmentMap = null;</span>

<span class="fc" id="L270">	protected TimeMap referenceShiftAssignmentMap = null;</span>
	
	/**
	 * The TimeMap starts on the organization day that contains
	 * timeRange.startTime and ends on the organization day that contains
	 * timeRange.endTime
	 *
	 * The TimeMap has bits turned 'on' during HOO for each day. It also has
	 * bits turned off for 'unavailability' events.
	 *
	 * Used to represent the possible work hours for each org day and is used
	 * for timeoff calculations on days past the 'cutoff' day (see lastShiftAssignment)
	 *
	 * see also {@link #setWorkableTimeMap() setWorkableTimeMap}
	 */
<span class="fc" id="L285">	protected TimeMap workableTimeMap = null;</span>

	/**
	 * The TimeMap starts on the organization day that contains
	 * timeRange.startTime and ends on the organization day that contains
	 * timeRange.endTime
	 *
	 * The TimeMap has bits turned 'on' for durations when paid holidays and HOO
	 * overlap.
	 *
	 * Used to represent paid holiday intervals during timeRange.
	 *
	 * see also {@link #setHolidaysInMap() setHolidaysInMap}
	 */
<span class="fc" id="L299">	protected TimeMap holidayAssignmentMap = null;</span>

	/**
	 * The start of the org day that contains the timeRange.startTime. The above
	 * TimeMaps have a start time set to this value.
	 */
<span class="fc" id="L305">	Date organizationDayStartForRange = null;</span>

	/**
	 * The end time of the org day that contains timeRange.endTime. The above time
	 * maps have an end time set to this.
	 */
<span class="fc" id="L311">	Date organizationDayEndForRange = null;</span>

	static final long MINUTES_IN_MILLISECS = 60 * 1000L;

	// lazily initialized.
<span class="fc" id="L316">	private ScheduleAccessManager scheduleAccessManager = null;</span>

	/**
	 * TO Event startTime passed to {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method for computing its TO Length
	 *
	 * &lt;p&gt;
	 * Scope: execution of {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method
	 */
<span class="fc" id="L326">	private Date thisTimeOffEventStart = null;</span>

	/**
	 * TO Event endTime passed to {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method for computing its TO Length
	 *
	 * &lt;p&gt;
	 * Scope: execution of {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method
	 */
<span class="fc" id="L336">	private Date thisTimeOffEventEnd = null;</span>

	public Date getEmpTerminationDate() {
<span class="nc" id="L339">		return empTerminationDate;</span>
	}

	public void setEmpTerminationDate(Date aEmpTerminationDate) {
<span class="fc" id="L343">		this.empTerminationDate = aEmpTerminationDate;</span>
<span class="fc" id="L344">	}</span>

	/**
	 * activity ID of 'thisTOEvt' (for which TO length is being computed)
	 *
	 * &lt;p&gt;
	 * Scope: execution of {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method
	 */
	private ID thisTimeOffEventActivityID;

	/**
	 * daily default mins for a day (for activity ID thisTimeOffEventActivityID above).
	 *
	 * &lt;p&gt;
	 * Scope: execution of {@link #calculateLength(Date, Date, ID)
	 * calculateLength} method
	 */
	private int dayDefaultMins;

	// calendar object initialized to org TZ. primary purpose is to avoid
	// unnecessary
	// creation of a calendar object when member methods need one.
<span class="fc" id="L367">	Calendar calendarOrgTimeZone1 = null;</span>
<span class="fc" id="L368">	Calendar calendarOrgTimeZone2 = null;</span>

	/**
	 * @see {@link DailyHoursBuckets#TOCHOICE_PERIOD_SCHED DailyHoursBuckets}
	 *      for valid states: 1=in scheduled period 2=overlaps scheduled and
	 *      unscheduled periods. 3=in unscheduled period
	 */
<span class="fc" id="L375">	private int periodFlag = DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_INIT;</span>

	
	/**
	 * isInUnpublishededGap
	 *
	 * &lt;p&gt;
	 * During length calculation, if the range is before the last scheduled day, we should
	 * not assume it is a published schedule. We check to see if range is explicitly published.
	 * If so, then it is a published schedule. If not, then it is an unpublished schedule.
	 * 	 
	 * */

<span class="fc" id="L388">	private boolean isInUnpublishededGap = false;</span>

	

<span class="fc" id="L392">	private Date empTerminationDate = null;</span>

	// Bridge needed to call into wfm-rm-backend for reference schedules
<span class="fc" id="L395">	private TimeOffHoursManagerBridge timeOffHoursManagerBridge = null;</span>

	// A flag to note that we substituted reference schedules for the passed-in schedules
	private boolean usingReferenceSchedules;
	
	
	/*
	 *  small structure to record daily hours and &quot;hours source&quot;, which is how the hours were calculated
	 */
	public static class HoursAndSource{
		int hours;
		int hoursSource;
		
<span class="fc" id="L408">		public HoursAndSource(){</span>
<span class="fc" id="L409">			 hours = 0;</span>
<span class="fc" id="L410">			 hoursSource = DailyHoursBuckets.HOURS_SOURCE_UNINITIALIZED;</span>
<span class="fc" id="L411">		}</span>
		
	}
	/*
	 *  Collection of HoursAndSource to record daily hours and &quot;hours From&quot;, which is how the hours were calculated
	 */
<span class="pc bpc" id="L417" title="1 of 2 branches missed.">	public static class ListHoursAndSource{</span>
<span class="fc" id="L418">		private List&lt;HoursAndSource&gt; list = new ArrayList&lt;HoursAndSource&gt;();</span>
		
<span class="fc" id="L420">		public ListHoursAndSource(int size){</span>
<span class="fc" id="L421">			list = new ArrayList&lt;HoursAndSource&gt;(size);</span>
<span class="fc bfc" id="L422" title="All 2 branches covered.">			for(int i = 0; i &lt; size; i++){</span>
<span class="fc" id="L423">				HoursAndSource item = new HoursAndSource();</span>
<span class="fc" id="L424">				list.add(item);</span>
			}
<span class="fc" id="L426">			clear();</span>
<span class="fc" id="L427">		}</span>
		
		
		public void setAt(int index, int hours, int source){
<span class="fc" id="L431">			HoursAndSource item = getAt(index);</span>
<span class="fc" id="L432">			item.hours = hours;</span>
<span class="fc" id="L433">			item.hoursSource = source;</span>
<span class="fc" id="L434">			setAt(index, item);</span>
<span class="pc bpc" id="L435" title="3 of 4 branches missed.">			assert getAt(index).hours == hours;</span>
<span class="pc bpc" id="L436" title="3 of 4 branches missed.">			assert getAt(index).hoursSource == source;</span>
			
<span class="fc" id="L438">		}</span>

		public void setAt(int i, HoursAndSource at) {
<span class="fc" id="L441">			list.set(i, at);</span>
<span class="fc" id="L442">		}</span>
		
		public HoursAndSource getAt(int index){
<span class="fc" id="L445">			return list.get(index);</span>
		}
		

		public void updateHoursAt(int i, int hours) {
<span class="nc" id="L450">			HoursAndSource item = getAt(i);</span>
<span class="nc" id="L451">			item.hours = hours;</span>
<span class="nc" id="L452">			setAt(i,item);</span>
<span class="nc" id="L453">		}</span>
		
		public int getSize(){
<span class="fc" id="L456">			return list.size();</span>
		}
		
		public void clear(){
			
<span class="fc bfc" id="L461" title="All 2 branches covered.">			for (Iterator&lt;HoursAndSource&gt; it = list.iterator(); it.hasNext();) {</span>
<span class="fc" id="L462">				HoursAndSource item = it.next();</span>
<span class="fc" id="L463">				item.hours = 0;</span>
<span class="fc" id="L464">				item.hoursSource = DailyHoursBuckets.HOURS_SOURCE_UNINITIALIZED;</span>
<span class="fc" id="L465">			}</span>
<span class="fc" id="L466">		}</span>
			
		public void logDebug(String string){
<span class="fc" id="L469">			LOG.debug(&quot;ListHoursAndSource: &quot; + string + &quot;\n&quot;);</span>
<span class="fc bfc" id="L470" title="All 2 branches covered.">			for (Iterator&lt;HoursAndSource&gt; it = list.iterator(); it.hasNext();) {</span>
<span class="fc" id="L471">				HoursAndSource item = it.next();</span>
<span class="fc" id="L472">				LOG.debug(&quot;hours= &quot; + item.hours + &quot; status= &quot; + item.hoursSource + &quot;\n&quot;);</span>
<span class="fc" id="L473">			}</span>
<span class="fc" id="L474">		}</span>


		public int getTotalMinutes() {
<span class="fc" id="L478">			int minutesTotal = 0;</span>
<span class="fc bfc" id="L479" title="All 2 branches covered.">			for (int i = 0; i &lt; getSize(); i++) {</span>
<span class="fc" id="L480">				HoursAndSource item = getAt(i);</span>
<span class="fc" id="L481">				minutesTotal += item.hours;</span>
				
			}
<span class="fc" id="L484">			return minutesTotal;</span>
			
		}
		
		public int getTotalMinutesDefaulted() {
<span class="nc" id="L489">			int minutesTotal = 0;</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">			for (int i = 0; i &lt; getSize(); i++) {</span>
<span class="nc" id="L491">				HoursAndSource item = getAt(i);</span>
<span class="nc bnc" id="L492" title="All 2 branches missed.">				if(item.hoursSource == DailyHoursBuckets.HOURS_SOURCE_DEFAULT)</span>
<span class="nc" id="L493">					minutesTotal += item.hours;</span>
				
			}
<span class="nc" id="L496">			return minutesTotal;</span>
			
		}
		public int getTotalMinutesFromShifts() {
<span class="nc" id="L500">			int minutesTotal = 0;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">			for (int i = 0; i &lt; getSize(); i++) {</span>
<span class="nc" id="L502">				HoursAndSource item = getAt(i);</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">				if(item.hoursSource == DailyHoursBuckets.HOURS_SOURCE_SCHEDULE)</span>
<span class="nc" id="L504">					minutesTotal += item.hours;</span>
			}
<span class="nc" id="L506">			return minutesTotal;</span>
		}
	}
	
	
	

	/**
	 * Create a new instance of a TimeOffLengthCalculator. This is the package
	 * level constructor with limited visibility. Use
	 * TimeOffLengthCalculatorHelper to create a new instance. Note that all the
	 * inputs are required and must be non-null, although some of the
	 * Collections may be empty.
	 */
	protected TimeOffLengthCalculator(ID aEmpId, Organization aOrg, TimeRange aRange, Collection&lt;ShiftAssignment&gt; aShiftAssignments,
			Collection aUnavailabilities, Collection aTimeOffs, Collection aOrgHOOAssignments, Collection aHolidays, 
<span class="fc" id="L522">			ShiftAssignment aLastShift, Map aAllotmentMap, Date aEmpTerminationDate) {</span>
		

<span class="fc" id="L525">		LOG.debug(TOCalcUtil.dumpEnterMethod(&quot;TimeOffLengthCalculator&quot;, new Object[] { aEmpId, aAllotmentMap, aOrgHOOAssignments, </span>
				aLastShift, aRange, shiftAssignments, aUnavailabilities, aTimeOffs, aHolidays }));

<span class="pc bpc" id="L528" title="1 of 2 branches missed.">		if (aEmpId == null) {</span>
<span class="nc" id="L529">			throw new IllegalArgumentException(&quot;aEmpId == null&quot;);</span>
		}
		
<span class="pc bpc" id="L532" title="1 of 2 branches missed.">		if (aOrg == null) {</span>
<span class="nc" id="L533">			throw new IllegalArgumentException(&quot;org == null&quot;);</span>
		}
		
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">		if (aLastShift == null) {</span>
<span class="nc" id="L537">			LOG.debug(&quot;lastShift == null.  Using a default last shift instead: &quot; + aLastShift);</span>
<span class="nc" id="L538">			aLastShift = TOCalcUtil.getDefaultLastShift();</span>
		}
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">		if (aRange == null) {</span>
<span class="nc" id="L541">			throw new IllegalArgumentException(&quot;aRange == null&quot;);</span>
		}

<span class="fc" id="L544">		setEmpId(aEmpId);</span>
<span class="fc" id="L545">		setAllotmentMap(aAllotmentMap); </span>
<span class="fc" id="L546">		setOrg(aOrg);</span>
<span class="fc" id="L547">		setOrgHOOAssignments(aOrgHOOAssignments);</span>
<span class="fc" id="L548">		setShiftAssignments(aShiftAssignments);</span>
<span class="fc" id="L549">		setUnavailabilities(aUnavailabilities);</span>
<span class="fc" id="L550">		setHolidays(aHolidays);</span>
<span class="fc" id="L551">		setEmpTerminationDate(aEmpTerminationDate);</span>

		// must be after setOrg() for org to be initialized.
<span class="fc" id="L554">		calendarOrgTimeZone1 = Calendar.getInstance(organization.getTimeZone());</span>
<span class="fc" id="L555">		calendarOrgTimeZone2 = Calendar.getInstance(organization.getTimeZone());</span>

		// expanding the range is not necessary since the start and end time of
		// the events
		// are trimmed before setting the time maps.
<span class="fc" id="L560">		setRange(aRange);</span>

<span class="fc" id="L562">		organizationDayStartForRange = getOrgDayStartTime(timeRange.getStartDate());</span>
<span class="fc" id="L563">		organizationDayEndForRange = getOrgDayEndTime(timeRange.getEndDate());</span>

<span class="fc" id="L565">		setLastShift(aLastShift);</span>
<span class="fc" id="L566">		setTimeOffs(aTimeOffs);</span>
<span class="fc" id="L567">		initShiftAssignmentMaps();</span>
<span class="fc" id="L568">		setWorkableTimeMap();</span>
<span class="fc" id="L569">		setHolidaysInMap();</span>
		
		

<span class="fc" id="L573">		LOG.debug(&quot;TimeOffLengthCalculator created: &quot; + this);</span>
<span class="fc" id="L574">	}</span>

	/**
	 * Sets the last shift and recomputes other attributes which depend on the
	 * last shift.
	 *
	 * @param lastShift
	 * @return returns the last shift assignment being replaced.
	 */
	ShiftAssignment setLastShift(ShiftAssignment lastShift) {
<span class="fc" id="L584">		ShiftAssignment savedLastShift = lastShiftAssignment;</span>
<span class="fc" id="L585">		lastShiftAssignment = lastShift;</span>

<span class="fc" id="L587">		Date lastShiftStart = lastShiftAssignment.getStartTime();</span>
<span class="fc" id="L588">		cutOffOrgDayStartTime = getOrgDayStartTime(lastShiftStart);</span>
<span class="fc" id="L589">		cutOffOrgDayEndTime = getOrgDayEndTime(lastShiftStart);</span>
<span class="fc" id="L590">		cutOffOrgDayNextStartTime = getNextOrgDayStartTime(lastShiftStart);</span>

<span class="fc" id="L592">		cutOffOrgWeekStartTime = getOrgWeekStartTime(lastShiftStart);</span>
<span class="fc" id="L593">		cutOffOrgWeekEndTime = getOrgWeekEndTime(lastShiftStart);</span>

<span class="fc" id="L595">		return savedLastShift;</span>
	}
	
	Date getLastShiftStartTime(){
<span class="nc bnc" id="L599" title="All 2 branches missed.">		return lastShiftAssignment==null? null : lastShiftAssignment.getStartTime();</span>
	}
	

	/**
	 * Sets the last shift and recomputes other attributes which depend on the
	 * last shift.
	 *
	 * @param timeOffs
	 *
	 */
	private void setTimeOffs(Collection timeOffs) {
<span class="pc bpc" id="L611" title="1 of 2 branches missed.">		if (timeOffs == null) {</span>
<span class="nc" id="L612">			return;</span>
		}

<span class="fc" id="L615">		m_TimeOffs = new java.util.ArrayList();</span>
<span class="fc bfc" id="L616" title="All 2 branches covered.">		for (Iterator it = timeOffs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L617">			Event event = (Event) it.next();</span>
<span class="pc bpc" id="L618" title="1 of 2 branches missed.">			if (event.getStartTime().compareTo(cutOffOrgWeekStartTime) &gt;= 0) {</span>
<span class="fc" id="L619">				m_TimeOffs.add(event);</span>
			}
<span class="fc" id="L621">		}</span>
<span class="fc" id="L622">	}</span>

	public float calculateTotalLength(Date toStartTime, Date toEndTime, ID activityID) throws TimeOffCalculatorException {
		try {
<span class="nc" id="L626">			ListHoursAndSource intervalDayBuckets = calculateLength(toStartTime, toEndTime, activityID, true);</span>
			// find the total # of time off hours
<span class="nc" id="L628">			int toMinTotal = intervalDayBuckets.getTotalMinutes();</span>
<span class="nc" id="L629">			return toMinTotal / 60.0f;</span>
<span class="nc" id="L630">		} catch (Exception e) {</span>
<span class="nc" id="L631">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L632">			throw new TimeOffCalculatorException(e, BbmEjbBundleKey.UNLOCALIZED_MESSAGE, e.getMessage(), null);</span>
		}
	}

	public DailyHoursBuckets calculateDailyLengthsForPartialPeriod(Date toStartTime, Date toEndTime, ID activityID, Date toCutOffStartDate,
			Date toCutOffEndDate) throws TimeOffCalculatorException {
<span class="nc" id="L638">		String printStr = null;</span>
		try {
<span class="nc" id="L640">			ListHoursAndSource returnBuckets = null;</span>
<span class="nc bnc" id="L641" title="All 2 branches missed.">			if (toCutOffStartDate != null</span>
<span class="nc bnc" id="L642" title="All 4 branches missed.">					&amp;&amp; (toCutOffStartDate.before(getLastPublishedShiftDayEnd()) || !toCutOffStartDate.after(toStartTime))) {</span>
<span class="nc bnc" id="L643" title="All 4 branches missed.">				returnBuckets = calculateLength(toCutOffStartDate.after(toStartTime) ? toCutOffStartDate : toStartTime,</span>
<span class="nc bnc" id="L644" title="All 2 branches missed.">						toCutOffEndDate != null &amp;&amp; toCutOffEndDate.before(toEndTime) ? toCutOffEndDate : toEndTime, activityID, true);</span>
			} else {
				// DO Calculation for full period in unpublished period or
				// enddate is shorter . then adjust to the required Window
<span class="nc" id="L648">				ListHoursAndSource intervalDayBuckets = calculateLength(toStartTime, toEndTime, activityID, true);</span>
<span class="nc bnc" id="L649" title="All 4 branches missed.">				int endLength = toCutOffEndDate != null &amp;&amp; toCutOffEndDate.before(toEndTime) ? getNumOfDaysForRange(toStartTime,</span>
<span class="nc" id="L650">						toCutOffEndDate) : intervalDayBuckets.getSize();</span>
<span class="nc bnc" id="L651" title="All 4 branches missed.">				int start = toCutOffStartDate != null &amp;&amp; toCutOffStartDate.after(toStartTime) ? intervalDayBuckets.getSize()</span>
<span class="nc" id="L652">						- getNumOfDaysForRange(toCutOffStartDate, toEndTime) + 1 : 0;</span>
				
<span class="nc" id="L654">				returnBuckets = new ListHoursAndSource(endLength - start);</span>
<span class="nc" id="L655">				int x = 0;</span>
<span class="nc bnc" id="L656" title="All 4 branches missed.">				for (int i = start; i &lt; endLength &amp;&amp; i &lt; intervalDayBuckets.getSize(); i++) {</span>
<span class="nc bnc" id="L657" title="All 4 branches missed.">					if (i &gt;= intervalDayBuckets.getSize() || x &gt;= returnBuckets.getSize()) {</span>
<span class="nc" id="L658">						printStr = (&quot; (endLength - start)=&quot; + (endLength - start) + &quot;\t: 	partial interval=&quot;</span>
<span class="nc" id="L659">								+ calculateLength(toCutOffStartDate, toCutOffEndDate, activityID, true).getSize() + &quot;\t: 	intervalDayBuckets=&quot;</span>
<span class="nc" id="L660">								+ intervalDayBuckets.getSize() + &quot;\t:	toStartTime	 =&quot; + toStartTime + &quot;\t:	toEndTime =&quot; + toEndTime</span>
								+ &quot;\t:	toCutOffStartDate	 =&quot; + toCutOffStartDate + &quot;\t:	toCutOffEndDate	 =&quot; + toCutOffEndDate
								+ &quot;\t:	endLength	 =&quot; + endLength + &quot;\t:	start		 =&quot; + start);
					}
<span class="nc" id="L664">					returnBuckets.setAt(x++, intervalDayBuckets.getAt(i));</span>
					//returnBuckets[x++] = intervalDayBuckets[i];
				}
			}
			
<span class="nc" id="L669">			return getDailyHoursBuckets(new TimeRange(toCutOffStartDate, toCutOffEndDate), organization.getTimeZone(),</span>
<span class="nc" id="L670">					organization.getDayBoundaryOffset(), returnBuckets);</span>
<span class="nc" id="L671">		} catch (Exception e) {</span>
<span class="nc" id="L672">			LOG.info(&quot;PARTIAL  LENGTH EXCEPTION =&quot; + printStr);</span>
<span class="nc" id="L673">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L674">			throw new TimeOffCalculatorException(e, BbmEjbBundleKey.UNLOCALIZED_MESSAGE, e.getMessage(), null);</span>
		}
	}

	private float calculatePartialLengthForTO(Date toStartTime, Date toEndTime, ID activityID, Date toCutOffStartDate, Date toCutOffEndDate)
			throws TimeOffCalculatorException {
		try {
<span class="nc" id="L681">			DailyHoursBuckets intervalDayBuckets = calculateDailyLengthsForPartialPeriod(toStartTime, toEndTime, activityID,</span>
					toCutOffStartDate, toCutOffEndDate);
			// find the total # of time off hours
<span class="nc" id="L684">			return intervalDayBuckets.getTotalHours(); </span>
<span class="nc" id="L685">		} catch (Exception e) {</span>
<span class="nc" id="L686">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L687">			throw new TimeOffCalculatorException(e, BbmEjbBundleKey.UNLOCALIZED_MESSAGE, e.getMessage(), null);</span>
		}
	}

	private int getTotalMinutes(int[] intervalDayBuckets) {
<span class="nc" id="L692">		int toMinTotal = 0;</span>
<span class="nc bnc" id="L693" title="All 2 branches missed.">		for (int i = 0; i &lt; intervalDayBuckets.length; i++) {</span>
<span class="nc" id="L694">			toMinTotal += intervalDayBuckets[i];</span>
		}
<span class="nc" id="L696">		return toMinTotal;</span>
	}

	/**
	 * Use the calculator to find the length of the given time off choice.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note: &lt;/b&gt; The computed daily allocation for a given day of a
	 * multiday TO *may* be different if a partial TimeRange of the TO is used
	 * instead of the full timerange. For this reason, when computing daily
	 * lengths for a TO, always use the entire TimeRange of the TO and not a
	 * partial TimeRange to be safe. if the TO overlaps the schedule portion,
	 * the a partial TO or full TO should yield the same results for the daily
	 * allocations. Not so sure for TO which overlaps the unscheduled portion in
	 * which case the daily allocations for partial TO might be inconsistent
	 * with full TO.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note: &lt;/b&gt; There might be a bug in the case where the otherTOEvt
	 * overlaps thisTOEvt. Consider the case where the otherTOEvt ends after
	 * midday and thisTOEvt starts before midday. How will this scenario be
	 * handled. It seems that the daily allocations computed for thisTOEvent
	 * might not be correct.
	 *
	 * @param choice
	 *            the time off choice to use in the calculation
	 * @param the
	 *            activity id
	 * @return the number of hours, for each org day in the time off choice
	 * @exception java.lang.IllegalArgumentException
	 *                when the given choice is not contained in the range served
	 *                by this calculator.
	 */
	public DailyHoursBuckets calculateDailyLengths(Date start, Date end, ID activityID) throws TimeOffCalculatorException {
		try {
<span class="fc" id="L731">			setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_INIT);</span>
<span class="fc" id="L732">			ListHoursAndSource intervalDayBuckets = calculateLength(start, end, activityID, true);</span>

			// translate daily hours to a DailyHoursBuckets object.
<span class="fc" id="L735">			return getDailyHoursBuckets(new TimeRange(start, end), organization.getTimeZone(), organization.getDayBoundaryOffset(),</span>
					intervalDayBuckets);
<span class="nc" id="L737">		} catch (Exception e) {</span>
<span class="nc" id="L738">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L739">			throw new TimeOffCalculatorException(e, BbmEjbBundleKey.UNLOCALIZED_MESSAGE, e.getMessage(), null);</span>
		}
	}

	/**
	 * Attempts to compute the daily lengths for the specified TORange so that
	 * the total length adds up to the given totalLength.
	 *
	 * &lt;p&gt;
	 * &lt;b&gt; Note: &lt;/b&gt; computed daily allocation for a given day of a multiday TO
	 * will be different if partial portion of the TO is used instead of the
	 * entire TO. For this reason, when computing daily lengths for a TO, always
	 * use the entire TimeRange of the TO and not a partial TimeRange.
	 *
	 * &lt;p&gt;
	 * Use case for this is the computation of daily allocations for TOEvents
	 * with timeOffRule == USE_MINUTES or TOReq with timeOffType == DEBIT. The
	 * computed daily allocations are used in TOCalendar and a few validation
	 * rules.
	 *
	 * &lt;p&gt;
	 * The algorithm is:
	 * &lt;li&gt;First attempt to compute the daily length using usual length
	 * calculation logic. If daily lengths add upto specified totalLength, then
	 * return.
	 * &lt;li&gt;If above fails, attempt to compute length for the specified TORange
	 * using default hours (by adjusting last shift). If daily lengths add upto
	 * specified totalLength, then computation is finished (most likely this
	 * condition will not be true).
	 * &lt;li&gt;if above fails, then attempt to add or remove daily minutes from the
	 * daily lengths to adjust the daily length total to equal the specified
	 * totalLength. When adding or removing, the logic ensures that daily
	 * lengths do not exceed 1440 minutes or become -ve and daily lengths for
	 * days with no HOOs are not affected.
	 *
	 * @param start
	 * @param end
	 * @param activityID
	 * @param givenTotalLenInMins
	 *            the computed daily lengths must total to this length.
	 * @return
	 * @throws TimeOffCalculatorException
	 */
	public DailyHoursBuckets calculateDailyLengthsForGivenTotalLength(Date thisTOStart, Date thisTOEnd, ID activityID,
			int givenTotalLenInMins) throws TimeOffCalculatorException {

<span class="fc" id="L785">		String method = &quot;calculateDailyLengthsForGivenTotalLength&quot;;</span>
<span class="fc" id="L786">		LOG.debug(method + '(' + thisTOStart + ',' + thisTOEnd + ',' + activityID + ',' + givenTotalLenInMins + ')');</span>

		try {
			// first attempt to compute normally
<span class="fc" id="L790">			ListHoursAndSource intervalDayBuckets = calculateLength(thisTOStart, thisTOEnd, activityID, true);</span>

<span class="fc" id="L792">			int computedTotalMins = intervalDayBuckets.getTotalMinutes();</span>
			// if computed total length does match the requested length.
<span class="fc" id="L794">			int terminationStatus = getEmployeeTerminationStatus(thisTOStart, thisTOEnd);</span>
<span class="pc bpc" id="L795" title="5 of 6 branches missed.">			if (computedTotalMins == givenTotalLenInMins || terminationStatus == EMP_TERMINATED_BEFORE_TO_PERIOD_START</span>
					|| terminationStatus == EMP_TERMINATED_BEFORE_TO_PERIOD_END) {
<span class="fc" id="L797">				LOG.debug(&quot;computed length matches requested length without replacing last shift: &quot; + computedTotalMins + ','</span>
						+ givenTotalLenInMins);

				// translate daily hours to a DailyHoursBuckets object.
<span class="fc" id="L801">				intervalDayBuckets.logDebug(&quot;intervalDayBuckets&quot;);</span>
				
<span class="fc" id="L803">				return getDailyHoursBuckets(new TimeRange(thisTOStart, thisTOEnd), organization.getTimeZone(), organization.getDayBoundaryOffset(),</span>
						intervalDayBuckets);
			}

<span class="nc" id="L807">			LOG.debug(&quot;computed length does not match requested length: &quot; + computedTotalMins + ',' + givenTotalLenInMins);</span>
<span class="nc" id="L808">			LOG.debug(&quot;Re-computing length using unscheduled region entirely (by replacing last shift) and not using 'otherTOEvts'&quot;);</span>

			// switch last shift.
<span class="nc" id="L811">			ShiftAssignment savedLastShift = setLastShift(TOCalcUtil.getDefaultLastShift());</span>

			// compute without including 'otherTOEvts'
<span class="nc" id="L814">			intervalDayBuckets = calculateLength(thisTOStart, thisTOEnd, activityID, false);</span>

<span class="nc" id="L816">			computedTotalMins = intervalDayBuckets.getTotalMinutes();</span>
			// check if the computedLength matches requested (most likely not)
<span class="nc bnc" id="L818" title="All 2 branches missed.">			if (computedTotalMins == givenTotalLenInMins) {</span>
<span class="nc" id="L819">				LOG.debug(&quot;Re-computed length matches requested length after replacing last shift: &quot; + computedTotalMins + ','</span>
						+ givenTotalLenInMins);
				// revert to the saved last shift assignment
<span class="nc" id="L822">				setLastShift(savedLastShift);</span>
				
<span class="nc" id="L824">				intervalDayBuckets.logDebug(&quot;intervalDayBuckets&quot;);</span>
				// translate daily hours to a DailyHoursBuckets object.
<span class="nc" id="L826">				return getDailyHoursBuckets(new TimeRange(thisTOStart, thisTOEnd), organization.getTimeZone(), organization.getDayBoundaryOffset(),</span>
						intervalDayBuckets);
			}

<span class="nc" id="L830">			LOG.debug(&quot;Re-computed length does not match requested length after replacing last shift: &quot; + computedTotalMins + ','</span>
					+ givenTotalLenInMins);

<span class="nc" id="L833">			Date orgDayStartForThisTOStart = getOrgDayStartTime(thisTOStart);</span>

			// attempt to add/substract minutes, starting with the last day, to
			// match the requested minutes
<span class="nc" id="L837">			int totalMinsToBeAdjusted = givenTotalLenInMins - computedTotalMins;</span>
<span class="nc" id="L838">			LOG.debug(&quot;totalMinsToBeAdjusted = &quot; + totalMinsToBeAdjusted);</span>
<span class="nc bnc" id="L839" title="All 4 branches missed.">			for (int i = intervalDayBuckets.getSize() - 1; i &gt;= 0 &amp;&amp; totalMinsToBeAdjusted != 0; i--) {</span>
<span class="nc" id="L840">				int dayMins = intervalDayBuckets.getAt(i).hours;</span>

<span class="nc" id="L842">				Date orgDayStartForCurrIdx = DateTimeUtil.getDateForDaysAfter(orgDayStartForThisTOStart, i, organization.getTimeZone());</span>

				// don't add minutes to a day if call center is closed
				// this is not true anymore, as per Jason always disregard the
				// hoo when calculating
				// accounted hrs in unpublished world when use minutes towards
				// rules is used.
				if (true || getDayOpen(orgDayStartForCurrIdx) != null) {
<span class="nc bnc" id="L850" title="All 2 branches missed.">					if (totalMinsToBeAdjusted &gt; 0) { </span>
						// need to add minutes
						// add minutes but ensure that dailyMins &lt;= 1440 minutes
<span class="nc" id="L853">						int minsToBeAdded = Math.min((1440 - dayMins), totalMinsToBeAdjusted);</span>
<span class="nc" id="L854">						LOG.debug(&quot;adding mins to day i = &quot; + i + ',' + minsToBeAdded);</span>
<span class="nc" id="L855">						dayMins += minsToBeAdded;</span>
<span class="nc" id="L856">						totalMinsToBeAdjusted -= minsToBeAdded;</span>
<span class="nc" id="L857">					} else { </span>
						// need to remove minutes
						// substract minutes but ensure that dailMins &gt;= 0
<span class="nc" id="L860">						int minsToBeRemoved = Math.min(dayMins, -totalMinsToBeAdjusted);</span>

<span class="nc" id="L862">						LOG.debug(&quot;removing mins from day i = &quot; + i + ',' + minsToBeRemoved);</span>

<span class="nc" id="L864">						dayMins -= minsToBeRemoved;</span>
<span class="nc" id="L865">						totalMinsToBeAdjusted += minsToBeRemoved;</span>
					}

					//intervalDayBuckets[i] = dayMins;
<span class="nc" id="L869">					intervalDayBuckets.updateHoursAt(i, dayMins);</span>
				}
			}

			// if all the excess minutes cannot be adjusted, then the
			// totalLength is incorrect to begin with.
<span class="nc bnc" id="L875" title="All 4 branches missed.">			assert totalMinsToBeAdjusted == 0 : &quot;totalMinsToBeAdjusted == 0: &quot; + totalMinsToBeAdjusted;</span>

			// revert to the saved last shift assignment
<span class="nc" id="L878">			setLastShift(savedLastShift);</span>

<span class="nc" id="L880">			intervalDayBuckets.logDebug(&quot;intervalDayBuckets&quot;);</span>
			//LOG.debug(&quot;intervalDayBuckets: &quot; + TOCalcUtil.dumpArray(intervalDayBuckets));
			// translate daily hours to a DailyHoursBuckets object.
<span class="nc" id="L883">			return getDailyHoursBuckets(new TimeRange(thisTOStart, thisTOEnd), organization.getTimeZone(), organization.getDayBoundaryOffset(),</span>
					intervalDayBuckets);
<span class="nc" id="L885">		} catch (Exception e) {</span>
<span class="nc" id="L886">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L887">			throw new TimeOffCalculatorException(e, BbmEjbBundleKey.UNLOCALIZED_MESSAGE, e.getMessage(), null);</span>
		}
	}

	/**
	 * See {@link OrganizationHOO#getDayOpen(Date, TimeZone) getDayOpen} for
	 * doc.
	 *
	 * @param date
	 * @return
	 */
	private Date getDayOpen(Date date) {

		// this logic can only handle a single HOO. verify.
<span class="nc bnc" id="L901" title="All 4 branches missed.">		assert orgHoursOfOperationAssignments.size() == 1 : &quot;orgHoursOfOperationAssignments.size() == 1: &quot; + orgHoursOfOperationAssignments;</span>
<span class="nc bnc" id="L902" title="All 4 branches missed.">		if (orgHoursOfOperationAssignments == null || orgHoursOfOperationAssignments.isEmpty()) {</span>
<span class="nc" id="L903">			return null;</span>
		}
		// get first HOO
<span class="nc" id="L906">		OrganizationHOO orgHOO = (OrganizationHOO) orgHoursOfOperationAssignments.iterator().next();</span>
		// get dayOpen
<span class="nc" id="L908">		return orgHOO.getDayOpen(date, organization.getTimeZone());</span>
	}

	
	protected OrgWeekDataDuringUnSchedPeriod createOrgWeekDataDuringUnSchedPeriod(EmployeeTimeOffDefault activityAlloc, Date dateInOrgWeek){
<span class="nc" id="L913">		return new OrgWeekDataDuringUnSchedPeriod(activityAlloc, dateInOrgWeek);</span>
	}
	
	/**
	 * contains data about the current org week being processed when computing
	 * time-off lengths during org weeks with unScheduled period days (with days
	 * after cut-off). Relevant details include
	 * &lt;ul&gt;
	 * &lt;li&gt;org week type (before, during or after cutoff)
	 * &lt;li&gt;org week start time
	 * &lt;li&gt;org week end time
	 * &lt;li&gt;daily buckets for thisTOEvent during this orgWeek.
	 * &lt;li&gt;daily buckets for otherTOEvents during this orgWeek.
	 * &lt;li&gt;actual and prorated week default minutes
	 * &lt;li&gt;and a few more
	 * &lt;/ul&gt;
	 *
	 *
	 * Title: Blue Pumpkin Software Request Management Module Copyright:
	 * Copyright (c) 2001-2004 Company: Blue Pumpkin Software, inc
	 * 
	 * @author Raja Rajendran
	 */
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">	class OrgWeekDataDuringUnSchedPeriod {</span>
		static final int ORGWEEKTYPE_UNKNOWN = 0;
		static final int ORGWEEKTYPE_BEFORECUTOFF = 1;
		static final int ORGWEEKTYPE_DURINGCUTOFF = 2;
		static final int ORGWEEKTYPE_AFTERCUTOFF = 3;
<span class="fc" id="L941">		private String[] ORGWEEKTYPE_STRARR = new String[] { &quot;ORGWEEKTYPE_UNKNOWN&quot;, &quot;ORGWEEKTYPE_BEFORECUTOFF&quot;, &quot;ORGWEEKTYPE_DURINGCUTOFF&quot;,</span>
				&quot;ORGWEEKTYPE_AFTERCUTOFF&quot; };

		// one of the above constants; indicates the type
		// of org week being processed.
		int currentOrgWeekType; 

		// current org week's start time.
		Date currentOrgWeekStartTime; 
		// current org week's end time.
		Date currentOrgWeekEndTime; 

		// daily buckets for unScheduled period days for 'thisTOEvent' in this
		// orgWeek
		// (daily buckets for days during 'thisTOEvent's interval which overlaps
		// this org week).
<span class="fc" id="L957">		int[] unscheduledDailyBuckets = new int[7];</span>
		// Source is where the &quot;unscheduled&quot; hours derive. This MAY BE a scheduled event
		// due to midnight crossing from published to unpublished period. We will mark it
		// here as such
<span class="fc" id="L961">		int[] unscheduledDailyBucketsSource = new int[7];</span>
		
		
		// Marker for at least one date that occurs before the last scheduled shift, but is unpublished
<span class="fc" id="L965">		boolean isDayInWeekInUnpublishedGap = false;</span>

		// start time for first 'UnSchedPeriod OrgDay' in this org week.
		private Date dateWeekOtherTOEventsStartTime;
		// start time for 'thisTOEvent' within this org week which is the
		// end-time for other TOEvents in this orgWeek.

		// Note: 'thisTOEvent' can span org weeks, ie it may start during one
		// org week and
		// extend into the following org week or more. In this case,
		// 'thisTOEventStartTime' will
		// equal 'dateWeekOtherTOEventsStartTime' above if 'thisTOEvent'
		// happens to start at the 'orgWeekStartTime' during the first org week
		// or
		// if it overlaps the second or more orgWeeks.
		private Date dateWeekOtherTOEventsEndTime;

		/**
		 *
		 * For this org week, TO daily buckets for 'otherTOEvts' during the
		 * interval between the first 'unSchedPeriod orgDay' and
		 * 'thisTOEventStart' (within this org week).
		 *
		 * These daily buckets are limited to the 'daily default' during
		 * computation.
		 *
		 * daily buckets represent minutes for TOEvents only between the above
		 * dates and not for events in the entire org week.
		 *
		 * Note: These daily buckets are related to the above
		 * 'unscheduledDailyBuckets' as follows: Given that TOEvents
		 * cannot overlap, this means the non-zero elements in these buckets
		 * must not overlap each other except at the edges (ie the rightmost
		 * non-zero element of weekUnSchedPerDayBktsForOtherTOEvts may
		 * overlap with leftmost non-zero element of
		 * m_weekUnSchedPerDayBktsForThisTOEvent). Presently this constraint is
		 * not enforced.
		 *
		 */
<span class="fc" id="L1004">		int[] weekUnSchedPerDayBktsForOtherTOEvts = new int[7];</span>

		/**
		 * current index for day in unscheduled period of org week.
		 *
		 * When an orgWeek is first entered, this is initialized to the index of
		 * the first day of 'thisTOEvent' which falls in the unscheduled period
		 * of this org week. Later as days in the orgWeek are processed for
		 * TOLength, the index is incremented.
		 */
		
		// Range: 0 to 6; used as index into the above array.
<span class="fc" id="L1016">		int curIdxForDayInUnSchedPerForOW = 0; </span>

		// weekly default for this TO activity ID.
		final int weekDefaultMinutes; 
		
		// pro-rated weekly default minutes during the cutOff org week.
		int weekDefaultMinutesProRated; 
										
		// weekly total for holiday minutes for this org week during unScheduled period days.
		
<span class="fc" id="L1026">		private int weekHolidayMinsForUnSchedPerDays = 0; </span>
		
		

<span class="fc" id="L1030">		protected OrgWeekDataDuringUnSchedPeriod(EmployeeTimeOffDefault activityAlloc, Date dateInOrgWeek) {</span>
			
			// initialize bucket elements to zero.
<span class="fc" id="L1033">			Arrays.fill(unscheduledDailyBuckets, 0);</span>
<span class="fc" id="L1034">			Arrays.fill(unscheduledDailyBucketsSource, 0);</span>
<span class="fc" id="L1035">			Arrays.fill(weekUnSchedPerDayBktsForOtherTOEvts, 0);</span>
<span class="fc" id="L1036">			isDayInWeekInUnpublishedGap = false;</span>
			
			

<span class="fc" id="L1040">			currentOrgWeekType = ORGWEEKTYPE_UNKNOWN;</span>

<span class="fc" id="L1042">			weekDefaultMinutes = (int) (activityAlloc.getHoursPerWeek() * 60);</span>

<span class="fc" id="L1044">			currentOrgWeekStartTime = getOrgWeekStartTime(dateInOrgWeek);</span>
<span class="fc" id="L1045">			currentOrgWeekEndTime = getOrgWeekEndTime(dateInOrgWeek);</span>
<span class="fc" id="L1046">		}</span>

		/**
		 * @param curDayStartTime
		 */
		void resetAndInitOrgWeekData(Date curDayStartTime, boolean enableOtherTOEvtsProcessing) throws Exception {
<span class="fc" id="L1052">			currentOrgWeekStartTime = getOrgWeekStartTime(curDayStartTime);</span>
<span class="fc" id="L1053">			currentOrgWeekEndTime = getOrgWeekEndTime(curDayStartTime);</span>

<span class="fc" id="L1055">			curIdxForDayInUnSchedPerForOW = 0;</span>

<span class="fc" id="L1057">			Arrays.fill(unscheduledDailyBuckets, 0);</span>
<span class="fc" id="L1058">			Arrays.fill(unscheduledDailyBucketsSource, 0);</span>
			
<span class="fc" id="L1060">			isDayInWeekInUnpublishedGap = false;</span>
			

<span class="fc" id="L1063">			dateWeekOtherTOEventsStartTime = dateWeekOtherTOEventsEndTime = null;</span>
<span class="fc" id="L1064">			Arrays.fill(weekUnSchedPerDayBktsForOtherTOEvts, 0);</span>

<span class="fc" id="L1066">			weekHolidayMinsForUnSchedPerDays = 0;</span>

			// if this orgWeek is before cutoff org week
<span class="pc bpc" id="L1069" title="1 of 2 branches missed.">			if (currentOrgWeekStartTime.before(cutOffOrgWeekStartTime)) {</span>
<span class="nc" id="L1070">				currentOrgWeekType = ORGWEEKTYPE_BEFORECUTOFF;</span>
<span class="fc bfc" id="L1071" title="All 2 branches covered.">			} else if (currentOrgWeekStartTime.equals(cutOffOrgWeekStartTime)) {</span>
				// if this orgWeek is the cutoff org week
<span class="fc" id="L1073">				currentOrgWeekType = ORGWEEKTYPE_DURINGCUTOFF;</span>

<span class="fc" id="L1075">				initOrgWeekDataForCutOffOrgWeek(curDayStartTime, getDayDefaultMins(), enableOtherTOEvtsProcessing);</span>
			} else { // if this orgWeek is after the cutoff org week
<span class="pc bpc" id="L1077" title="3 of 4 branches missed.">				assert currentOrgWeekStartTime.after(cutOffOrgWeekStartTime) : &quot;currentOrgWeekStartTime.after(cutOffOrgWeekStartTime): &quot;</span>
<span class="nc" id="L1078">						+ currentOrgWeekStartTime.getTime() + &quot;,&quot; + cutOffOrgWeekStartTime.getTime();</span>

<span class="fc" id="L1080">				currentOrgWeekType = ORGWEEKTYPE_AFTERCUTOFF;</span>

<span class="fc" id="L1082">				initOrgWeekDataForAfterCutOffOrgWeek(curDayStartTime, getDayDefaultMins(), enableOtherTOEvtsProcessing);</span>
			}
<span class="fc" id="L1084">		}</span>

		/**
		 * intialize weekData, when the org week is entered, for org weeks after
		 * the 'cutOff' org week (cutOff org week is the org week which contains
		 * the day with the last shift)
		 *
		 * @param weekData
		 * @param curDayStartTime
		 * @throws Exception
		 */
		private void initOrgWeekDataForAfterCutOffOrgWeek(Date thisTOEvtStartInOrgWeek, int dailyDefaultMins,
				boolean enableOtherTOEvtsProcessing) throws Exception {

<span class="pc bpc" id="L1098" title="3 of 4 branches missed.">			assert currentOrgWeekType == ORGWEEKTYPE_AFTERCUTOFF : &quot;currentOrgWeekType == ORGWEEKTYPE_AFTERCUTOFF: &quot; + currentOrgWeekType;</span>

			// get holiday minutes during org week
<span class="fc" id="L1101">			weekHolidayMinsForUnSchedPerDays = holidayAssignmentMap.countBitsOn(currentOrgWeekStartTime, currentOrgWeekStartTime);</span>

			// get daily buckets for 'other TO Events' between first unScheduled
			// period org day and start of
			// 'thisTOEvent' during 'unScheduled period' portion of this org
			// week.
<span class="pc bpc" id="L1107" title="1 of 2 branches missed.">			if (enableOtherTOEvtsProcessing) {</span>
<span class="fc" id="L1108">				fillDailyBktsForUnSchedPerMinsForOtherTOEvents(currentOrgWeekStartTime, thisTOEvtStartInOrgWeek, dailyDefaultMins);</span>
			}

<span class="fc" id="L1111">			curIdxForDayInUnSchedPerForOW = getNumOfDaysForRange(currentOrgWeekStartTime, thisTOEvtStartInOrgWeek) - 1;</span>

<span class="fc" id="L1113">			LOG.debug(&quot;Exiting initAtOrgWeekEnterAfterCutOff()&quot; + this);</span>
<span class="fc" id="L1114">		}</span>

		/**
		 * intialize weekData, when the orgWeek is entered, for the 'cutOff' org
		 * week (cutOff org week is the org week which contains the day with the
		 * last shift).
		 *
		 * @param weekData
		 * @param curDayStartTime
		 * @throws Exception
		 */
		private void initOrgWeekDataForCutOffOrgWeek(Date thisTOEvtStartInOrgWeek, int dailyDefaultMins, boolean enableOtherTOEvtsProcessing)
				throws Exception {

<span class="pc bpc" id="L1128" title="3 of 4 branches missed.">			assert (currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF) : &quot;(currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF): &quot; + currentOrgWeekType;</span>

			// if cutOffOrgDay == last day of orgWeek, nextDayAfterCutOffOrgDay
			// will be &gt; lastDay of OrgWeek.
<span class="fc" id="L1132">			boolean orgDayAfterCutOffInsideOW = cutOffOrgDayNextStartTime.before(currentOrgWeekEndTime);</span>

			// get pro-rated weekly default (for # of days after cut-off).
<span class="pc bpc" id="L1135" title="1 of 2 branches missed.">			if (orgDayAfterCutOffInsideOW) {</span>
<span class="fc" id="L1136">				int numOfDaysForRange = getNumOfDaysForRange(cutOffOrgDayNextStartTime, cutOffOrgWeekEndTime);</span>
				// get # of holiday minutes between day after cut-off and org
				// week end.
				// if cutOffOrgDay == last day of orgWeek,
				// nextDayAfterCutOffOrgDay will be &gt; lastDay of OrgWeek.
<span class="pc bpc" id="L1141" title="1 of 2 branches missed.">				weekHolidayMinsForUnSchedPerDays = (orgDayAfterCutOffInsideOW) ? holidayAssignmentMap.countBitsOn(</span>
						cutOffOrgDayNextStartTime, cutOffOrgWeekEndTime) : 0;

				// get first day of 'thisTOEvent' after cut-off.
<span class="pc bpc" id="L1145" title="1 of 2 branches missed.">				Date thisTOEvtStartInUnSchedPerOfOrgWeek = (thisTOEvtStartInOrgWeek.before(cutOffOrgDayNextStartTime)) ? cutOffOrgDayNextStartTime</span>
						: thisTOEvtStartInOrgWeek;

				// fill daily buckets for 'other TO Events' between
				// 'dayAfterCutoff' and first
				// day of 'thisTOEvt' after cut-off.
<span class="pc bpc" id="L1151" title="1 of 2 branches missed.">				if (enableOtherTOEvtsProcessing) {</span>
<span class="fc" id="L1152">					fillDailyBktsForUnSchedPerMinsForOtherTOEvents(cutOffOrgDayNextStartTime, thisTOEvtStartInUnSchedPerOfOrgWeek,</span>
							dailyDefaultMins);
				}

<span class="fc" id="L1156">				curIdxForDayInUnSchedPerForOW = getNumOfDaysForRange(currentOrgWeekStartTime, thisTOEvtStartInUnSchedPerOfOrgWeek) - 1;</span>
<span class="fc" id="L1157">			} else {</span>
				// Note: if there is no unscheduled period during the cutOff org
				// week (condition for entering
				// this block), then this variable should never be used during
				// the processing of the
				// cutOffOrgWeek. So setting the index outside the range of the
				// array to trigger an exception
				// to check if it is used.
<span class="nc" id="L1165">				curIdxForDayInUnSchedPerForOW = unscheduledDailyBuckets.length;</span>
			}

<span class="fc" id="L1168">			LOG.debug(&quot;Exiting initAtOrgWeekEnterForCutOffOrgWeek()&quot; + this);</span>
<span class="fc" id="L1169">		}</span>

		/**
		 * Fill 'otherTOEvents' daily buckets for the unScheduled period of this
		 * orgWeek between the specified date range.
		 *
		 * &lt;pre&gt;
		 * Obtain all TO Events between given date range for the activity ID of this calc.
		 * for each such TO event
		 *    If TO Event == 'thisTOEvent', then skip this event.
		 *    Compute unScheduled period minutes for each day (using workableTimeMap) but limit
		 *       computed range to (limitStart, limitEnd) and limit daily hours to 'dailyDefault'.
		 *    store unScheduled period minutes in weekData.m_weekDailyBktsForOtherTOEvts.
		 * endFor
		 * &lt;/pre&gt;
		 *
		 * @param rangeStart
		 * @param rangeEnd
		 * @return
		 */
		protected void fillDailyBktsForUnSchedPerMinsForOtherTOEvents(Date otherTOEvtsStart, Date otherTOEvtsEnd, int dailyDefaultMins)
				throws Exception {

<span class="fc" id="L1192">			dateWeekOtherTOEventsStartTime = otherTOEvtsStart;</span>
<span class="fc" id="L1193">			dateWeekOtherTOEventsEndTime = otherTOEvtsEnd;</span>
<span class="fc" id="L1194">			Collection otherTOEvents = null;</span>

			// Fetch and cache TOEvents during the given range.
<span class="pc bpc" id="L1197" title="1 of 2 branches missed.">			if (m_TimeOffs != null) {</span>
<span class="fc" id="L1198">				otherTOEvents = m_TimeOffs;</span>
			} else {
<span class="nc" id="L1200">				ScheduleAccessManager sam = getScheduleAccessManager();</span>
<span class="nc" id="L1201">				otherTOEvents = sam.getPublishedEventsForWorkResourceByType(Event.EVENT_TYPE_TIME_OFF, empId,</span>
						dateWeekOtherTOEventsStartTime, dateWeekOtherTOEventsEndTime);
			}

<span class="fc bfc" id="L1205" title="All 2 branches covered.">			for (Iterator iter = otherTOEvents.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L1206">				TimeOffEvent otherTOEvt = (TimeOffEvent) iter.next();</span>
				// if the time off event does not fall under required range,
				// skip it
<span class="pc bpc" id="L1209" title="1 of 2 branches missed.">				if (otherTOEvt.getStartTime().after(dateWeekOtherTOEventsEndTime)</span>
<span class="fc bfc" id="L1210" title="All 2 branches covered.">						|| otherTOEvt.getEndTime().before(dateWeekOtherTOEventsStartTime)</span>
<span class="pc bpc" id="L1211" title="1 of 2 branches missed.">						|| !otherTOEvt.getActivityID().equals(thisTimeOffEventActivityID)) {</span>
						// or if the activity ID does not match skip.
<span class="nc" id="L1213">					continue;</span>
				}

				// if the TO event is 'TOEventBeingComputed', then skip.
				// The calculator does not have the TO activity ID to use.
<span class="fc" id="L1218">				ID otherTOEvtEmpID = otherTOEvt.getWorkResourceIDs().iterator().next();</span>
<span class="pc bpc" id="L1219" title="2 of 4 branches missed.">				if (otherTOEvt.getActivityID().equals(thisTimeOffEventActivityID) &amp;&amp; otherTOEvt.getStartTime().equals(thisTimeOffEventStart)</span>
<span class="pc bpc" id="L1220" title="3 of 4 branches missed.">						&amp;&amp; otherTOEvt.getEndTime().equals(thisTimeOffEventEnd) &amp;&amp; otherTOEvtEmpID.equals(empId)) {</span>
<span class="nc" id="L1221">					continue;</span>
				}

				// compute daily hours assigned to this TO event, for each day
				// of the week between rangeStart and rangeEnd.
<span class="fc" id="L1226">				fillDailyBktsForUnSchedPerMinsForTOEvt(otherTOEvt, weekUnSchedPerDayBktsForOtherTOEvts, dailyDefaultMins);</span>
<span class="fc" id="L1227">			}</span>

<span class="fc" id="L1229">		}</span>

		/**
		 * Add TO minutes from the given TOEvt, during the unScheduled period of
		 * this orgWeek, to the 'otherTOEvents' daily buckets
		 *
		 * @param otherTOEvt
		 */
		private void fillDailyBktsForUnSchedPerMinsForTOEvt(TimeOffEvent otherTOEvt, int[] dailyBktsArr, int dailyDefaultMins) {

<span class="fc" id="L1239">			Date otherTOEvtsStartTime = dateWeekOtherTOEventsStartTime;</span>
<span class="fc" id="L1240">			Date otherTOEvtsEndTime = dateWeekOtherTOEventsEndTime;</span>

			/*
			 * ------------------------------------------------------------------
			 * -------------------------------------- ^ ^ ^ ^ ^ ^ | | | | | | |
			 * | | | | | otherTOEvtsStartTime adjTOEvtStart curDayStart
			 * curDayEnd adjTOEvtEnd otherTOEvtsEndTime
			 */
			// trim TOEvent start to limitStart if necessary.
			//
			// adjusted timeoff events start.
<span class="fc" id="L1251">			Date adjTOEvtStart = otherTOEvt.getStartTime();</span>
<span class="fc bfc" id="L1252" title="All 2 branches covered.">			adjTOEvtStart = (adjTOEvtStart.before(otherTOEvtsStartTime)) ? otherTOEvtsStartTime : adjTOEvtStart;</span>

			// trim toEvent end to limitEnd if necessary.
			// adjusted timeoff event end.
<span class="fc" id="L1256">			Date adjTOEvtEnd = otherTOEvt.getEndTime();</span>
<span class="fc bfc" id="L1257" title="All 2 branches covered.">			adjTOEvtEnd = (adjTOEvtEnd.after(otherTOEvtsEndTime)) ? otherTOEvtsEndTime : adjTOEvtEnd;</span>

			// QA 81059 - adjTOEvtEnd
<span class="fc" id="L1260">			Date toEvtOrgDayEndTime = getOrgDayEndTime(adjTOEvtEnd);</span>
<span class="pc bpc" id="L1261" title="1 of 2 branches missed.">			if (adjTOEvtEnd.after(adjTOEvtStart)) {</span>
<span class="nc" id="L1262">				toEvtOrgDayEndTime = getOrgDayEndTime(TOCalcUtil.adjustDateUsingResolution(adjTOEvtEnd, shiftAssignmentMap.getResolution()));</span>
			}
<span class="fc" id="L1264">			Date curDayStart = adjTOEvtStart;</span>
<span class="fc" id="L1265">			Date curDayEnd = adjustCurDayEndToEarlierOfTheseTwo(adjTOEvtStart, adjTOEvtEnd, shiftAssignmentMap, organization);</span>

			// obtain index for curDayStart
<span class="fc" id="L1268">			int orgWeekDayIdxForTOEvt = getNumOfDaysForRange(currentOrgWeekStartTime, curDayStart) - 1;</span>
<span class="pc bpc" id="L1269" title="3 of 4 branches missed.">			assert orgWeekDayIdxForTOEvt &gt;= 0 : &quot;orgWeekDayIdx &gt;= 0: orgWeekDayIdx = &quot; + orgWeekDayIdxForTOEvt;</span>
<span class="pc bpc" id="L1270" title="3 of 4 branches missed.">			assert orgWeekDayIdxForTOEvt &lt; 7 : &quot;orgWeekDayIdx &lt; 7: orgWeekDayIdx = &quot; + orgWeekDayIdxForTOEvt;</span>

			// compute daily hours for each org day.
<span class="pc bpc" id="L1273" title="3 of 4 branches missed.">			while (curDayStart.before(adjTOEvtEnd) &amp;&amp; curDayStart.before(toEvtOrgDayEndTime)) {</span>
<span class="nc" id="L1274">				int workableMins = 0;</span>
<span class="nc" id="L1275">				int holidayMins = 0;</span>

				try {
					// compute unScheduled period minutes for current org day.
<span class="nc" id="L1279">					workableMins = workableTimeMap.countBitsOn(curDayStart, curDayEnd);</span>
					// compute holiday mins for current org day.
<span class="nc" id="L1281">					holidayMins = holidayAssignmentMap.countBitsOn(curDayStart, curDayEnd);</span>
<span class="nc" id="L1282">				} catch (IllegalArgumentException e) {</span>
<span class="nc" id="L1283">					LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L1284">				}</span>

				// deduct holidayMins from unScheduled period mins
<span class="nc" id="L1287">				workableMins = Math.max(workableMins - holidayMins, 0);</span>

				// add unScheduled period minutes to day bucket
<span class="nc" id="L1290">				dailyBktsArr[orgWeekDayIdxForTOEvt] += workableMins;</span>
<span class="nc" id="L1291">				dailyBktsArr[orgWeekDayIdxForTOEvt] = Math.min(dailyBktsArr[orgWeekDayIdxForTOEvt], dailyDefaultMins);</span>

				// move to next org day start.
<span class="nc" id="L1294">				curDayStart = getNextOrgDayStartTime(curDayStart);</span>
				// move to next org day end.
<span class="nc" id="L1296">				curDayEnd = adjustCurDayEndToEarlierOfTheseTwo(curDayStart, adjTOEvtEnd, shiftAssignmentMap, organization);</span>

<span class="nc" id="L1298">				orgWeekDayIdxForTOEvt++;</span>
<span class="nc bnc" id="L1299" title="All 6 branches missed.">				assert orgWeekDayIdxForTOEvt &gt;= 0 &amp;&amp; orgWeekDayIdxForTOEvt &lt; 7 : &quot;orgWeekDayIdx &gt;= 0 &amp;&amp; orgWeekDayIdx &lt; 7: dayIdx = &quot;</span>
						+ orgWeekDayIdxForTOEvt;
<span class="nc" id="L1301">			}</span>
<span class="fc" id="L1302">		}</span>

		/**
		* The End Date is adjusted before invoking the TimeMap.countBitsOn() to count the WorkableMins and holidayMins.
		* @param startDate
		* @param endDate
		* @return adjusted curDayEnd time 
		*/
		private Date adjustCurDayEndToEarlierOfTheseTwo(Date startDate, Date endDate, TimeMap map, Organization aOrg) {

<span class="fc" id="L1312">			Date curDayEnd = TOCalcUtil.getDateForOrgDayEnd(aOrg, startDate);</span>
			// trim curDayEnd if necessary.
			/*Fix for QC#150550/QC 150711/ ESR#4471200 - 1 millisecond being subtracted from the End Time 
			 * as the end time of the Time Off event is not inclusive.
			 */

<span class="pc bpc" id="L1318" title="1 of 2 branches missed.">			curDayEnd = (endDate.before(curDayEnd)) ? TOCalcUtil.adjustDateUsingResolution(endDate, map.getResolution()) : curDayEnd;</span>
<span class="fc" id="L1319">			return curDayEnd;</span>
		}

		/**
		 * process the already computed unScheduled period minutes for this
		 * orgWeek (represented by this weekData) for 'thisTOEvent' and allocate
		 * these computed minutes to the corresponding day bucket in the passed
		 * 'listEventDayBuckets' (day buckets which represent the entire range
		 * of 'thisTOEvt'
		 *
		 * &lt;p&gt;
		 * The following factors are considered when allocating unScheduled
		 * period minutes for this org week
		 * &lt;li&gt;otherTOEvents for the same employee and activityID that precede
		 * 'thisTOEvt' during this org week.
		 * &lt;li&gt;daily default and weekly default restrictions.
		 * &lt;li&gt;holidays for the week.
		 *
		 * @param listEventDayBuckets
		 *            Buckets to represent each day and status information in the TO event's length
		 *            being computed. Elements of the bucket represent a day (24
		 *            hour period) in the time range associated with the
		 *            buckets.
		 *
		 * @param toBktsOrgDayStart
		 *            startTime for the time range for the above buckets. within
		 *            the calc, this start time will be an orgDayStart as well.
		 *
		 * @param weekData
		 *            endTime for the time range for the above buckets. within
		 *            the calc, this end time will be an org day end.
		 */
		void processUnscheduledPeriodHours(ListHoursAndSource listEventDayBuckets, Date toEvtBktsOrgDayStart, Date toEvtBktsOrgDayEnd,
				int dayMinsDefault, boolean enableOtherTOEvtsProcessing) {
			// limiting the computed daily minutes by considering otherTOEvents,
			// dayDefaults and weekDefaults
			// only applies to 'unSchedPeriod' org weeks (org weeks with days
			// after the cut-off day).
<span class="pc bpc" id="L1357" title="3 of 4 branches missed.">			if (!isOrgWeekWithUnSchedPeriod() &amp;&amp; !isInUnpublishedGap()) {</span>
<span class="nc" id="L1358">				return;</span>
			}

			// if 'thisTOEvt' does not overlap any unScheduled period days (for
			// example if 'thisTOEvent' overlaps
			// the scheduled days but not the unScheduled period days in the
			// cut-off orgWeek.
<span class="fc" id="L1365">			boolean unpublishedGap = false;</span>
<span class="fc bfc" id="L1366" title="All 2 branches covered.">			if (toEvtBktsOrgDayEnd.before(cutOffOrgDayNextStartTime)) {</span>
<span class="pc bpc" id="L1367" title="1 of 2 branches missed.">				if (isInUnpublishedGap()) {</span>
<span class="nc" id="L1368">					unpublishedGap = true;</span>
				} else {
<span class="fc" id="L1370">					return;</span>
				}
			}

<span class="pc bpc" id="L1374" title="1 of 2 branches missed.">			if (currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF) {</span>
				// if cutOffOrgDay == last day of orgWeek,
				// nextDayAfterCutOffOrgDay will be &gt; lastDay of OrgWeek.
<span class="nc" id="L1377">				boolean orgDayAfterCutOffInsideOW = cutOffOrgDayNextStartTime.before(currentOrgWeekEndTime);</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">				if (!orgDayAfterCutOffInsideOW) {</span>
<span class="nc" id="L1379">					LOG.debug(&quot;day after cutOffOrgDay outside cutOffOrgWeek. No unsched &quot;</span>
							+ &quot;period exists in cut-off org week.  No processing done for cut-off org week&quot;);
<span class="nc" id="L1381">					return;</span>
				}
			}

			// ********************************
			// At this point we know for sure that the TOEvent overlaps some
			// unscheduled period of
			// this org week.
			// ********************************

			// adjWeeklyDefault = (during 'cutOffOrgWeek')?prorated week
			// default is weeklyDefault;
			// Bug fix for ONYX QA 76207; Sameet July 2007
			// Calc of accounted hours when the last published date falls in
			// between the requested TO period.
			// if Acct hrs in Pub Area is less than weekly default Then the
			// total acct hrs should never exceed weekly defaults.
			// (WeeklyDef - Acc hrs in Pub Area) shld be evenly distributed in
			// unpub area taking care not to exceed daily/Weekly defaults.
			// if Acct Hours in Pub Area are more than weekly default then acct
			// hours in unpub area shld be zero.
<span class="fc" id="L1402">			weekDefaultMinutesProRated = weekDefaultMinutes;</span>
			
<span class="fc bfc" id="L1404" title="All 2 branches covered.">			for (int i = 0; i &lt; listEventDayBuckets.getSize(); i++) {</span>
<span class="fc" id="L1405">				HoursAndSource item = listEventDayBuckets.getAt(i);</span>
<span class="fc" id="L1406">				weekDefaultMinutesProRated -= item.hours;</span>
			}
			
			
<span class="fc" id="L1410">			long adjWeekDefMins = weekDefaultMinutes;</span>
<span class="pc bpc" id="L1411" title="1 of 2 branches missed.">			if(currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF) {</span>
<span class="nc" id="L1412">				adjWeekDefMins = weekDefaultMinutesProRated;</span>
			}
<span class="fc" id="L1414">			adjWeekDefMins -= weekHolidayMinsForUnSchedPerDays;</span>
<span class="pc bpc" id="L1415" title="1 of 2 branches missed.">			if (adjWeekDefMins &lt;= 0) {</span>
<span class="nc" id="L1416">				return;</span>
			}

			// compute total hours for 'otherTOEvents' between
			// 'firstUnSchedPerDayInOrgWeek' and 'thisTOEventStart'
			// during the unScheduled period day period of this org week.
			//
			// Note: otherTOEvent daily buckets are already limited to the
			// 'dailyDefault'.
			//
			// Note: Only the buckets in the range (otherTOEventsStart,
			// otherTOEventsEnd) must be processed.
			// Since all buckets after this range will be zero, the entire array
			// is simply processed.
<span class="pc bpc" id="L1430" title="1 of 2 branches missed.">			if (enableOtherTOEvtsProcessing) {</span>
<span class="fc" id="L1431">				int unSchedPerMinsForotherTOEvtsTotal = 0;</span>
<span class="fc bfc" id="L1432" title="All 2 branches covered.">				for (int i = 0; i &lt; weekUnSchedPerDayBktsForOtherTOEvts.length; i++) {</span>
<span class="fc" id="L1433">					unSchedPerMinsForotherTOEvtsTotal += weekUnSchedPerDayBktsForOtherTOEvts[i];</span>
				}

				// adjWeeklyDef = adjWeeklyDef - totalMinsForOtherTOEvents.
<span class="fc" id="L1437">				adjWeekDefMins -= unSchedPerMinsForotherTOEvtsTotal;</span>
<span class="pc bpc" id="L1438" title="1 of 2 branches missed.">				if (adjWeekDefMins &lt;= 0) {</span>
<span class="nc" id="L1439">					return;</span>
				}
			}

			// orgWeekDayBktsIdxForFirstUnSchedPerDayInOWForThisTOEvt: orgWeekDay
			// buckets Index for first unScheduled period
			// day in 'this org week' for 'ThisTOEvt'
<span class="fc" id="L1446">			int orgWeekDayBktsIdxForFirstUnSchedPerDayInOWForThisTOEvt = 0;</span>
			// toIntDayBktsIdxForFirstNSDayForThisTOEvt: TOIntervalDayBuckets
			// index for first unScheduled period
			// day for 'thisTOEvt'.
<span class="fc" id="L1450">			int toEvtDayBktsIdxForFirstUSPerDayForThisTOEvt = 0;</span>

			// first unScheduled period day in orgWeek for 'ThisTOEvt'
<span class="fc" id="L1453">			Date firstUnSchedPerDayInOWForThisTOEvt = null;</span>

			// Note: toBktsOrgDayStart may be &gt; currentOrgWeekStartTime; this can
			// happen if TOEvt falls after the cutOff.
			// In this case, during the first orgWeek, toBktsOrgDayStart points
			// inside the orgWeek while
			// currentOrgWeekStartTime points to the start of the week.
			//
			// TODO: can use the following equivalent construct which is
			// simpler. modify and test.
			
<span class="pc bpc" id="L1464" title="1 of 2 branches missed.">			if (toEvtBktsOrgDayStart.before(currentOrgWeekStartTime)) {</span>
				// first unScheduled period day in orgWeek for 'ThisTOEvt'
<span class="nc bnc" id="L1466" title="All 2 branches missed.">				firstUnSchedPerDayInOWForThisTOEvt = (currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF) ? cutOffOrgDayNextStartTime</span>
						: currentOrgWeekStartTime;
			} else {
<span class="pc bpc" id="L1469" title="1 of 2 branches missed.">				if (currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF) {</span>
<span class="nc bnc" id="L1470" title="All 2 branches missed.">					firstUnSchedPerDayInOWForThisTOEvt = (toEvtBktsOrgDayStart.after(cutOffOrgDayNextStartTime)) ? toEvtBktsOrgDayStart</span>
							: cutOffOrgDayNextStartTime;
				} else { 
<span class="pc bpc" id="L1473" title="1 of 2 branches missed.">					if(unpublishedGap){</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">						firstUnSchedPerDayInOWForThisTOEvt = (toEvtBktsOrgDayStart.after(currentOrgWeekStartTime)) ? toEvtBktsOrgDayStart</span>
								: currentOrgWeekStartTime;
					} else {
						// ORGWEEKTYPE_AFTERCUTOFF
<span class="pc bpc" id="L1478" title="1 of 2 branches missed.">						firstUnSchedPerDayInOWForThisTOEvt = (toEvtBktsOrgDayStart.after(currentOrgWeekStartTime)) ? toEvtBktsOrgDayStart</span>
								: currentOrgWeekStartTime;
					}
				}
			}

			
<span class="fc" id="L1485">			orgWeekDayBktsIdxForFirstUnSchedPerDayInOWForThisTOEvt = getNumOfDaysForRange(currentOrgWeekStartTime,</span>
					firstUnSchedPerDayInOWForThisTOEvt) - 1;

<span class="fc" id="L1488">			toEvtDayBktsIdxForFirstUSPerDayForThisTOEvt = getNumOfDaysForRange(toEvtBktsOrgDayStart, firstUnSchedPerDayInOWForThisTOEvt) - 1;</span>

			// number of buckets in the toIntervalDayBkts passed.
<span class="fc" id="L1491">			int numOfTOIntDayBkts = listEventDayBuckets.getSize();</span>

			// Move computed minutes from orgWeek daily buckets for 'thisTOEvt'
			// to TOIntervalDayBuckets (for
			// the entire TOEvt duration).
			//
			// for each daily unScheduled period minutes bucket (for this
			// orgWeek) for 'thisTOEvt' during this orgWeek
			// and adjWeeklyDefault &gt; 0.
<span class="fc" id="L1500">			int offset = 0;</span>
<span class="fc" id="L1501">			boolean done = false;</span>
			
			do {
				

<span class="fc" id="L1506">				int orgWeekDayBktsIdx = orgWeekDayBktsIdxForFirstUnSchedPerDayInOWForThisTOEvt + offset;</span>
<span class="fc" id="L1507">				int dayMins = 0;</span>
<span class="fc" id="L1508">				int daySource = DailyHoursBuckets.HOURS_SOURCE_DEFAULT;</span>
				
<span class="pc bpc" id="L1510" title="1 of 2 branches missed.">				if (unscheduledDailyBuckets.length &gt; orgWeekDayBktsIdx) {</span>
<span class="fc" id="L1511">					dayMins = Math.min(unscheduledDailyBuckets[orgWeekDayBktsIdx], dayMinsDefault);</span>
<span class="fc" id="L1512">					daySource = unscheduledDailyBucketsSource[orgWeekDayBktsIdx];</span>
				}
<span class="fc" id="L1514">				dayMins = (int) Math.min(dayMins, adjWeekDefMins);</span>

<span class="fc" id="L1516">				int toIntDayBktsIdx = toEvtDayBktsIdxForFirstUSPerDayForThisTOEvt + offset;</span>
				
				// make sure it's not from a schedule (possible if crossing midnight into unpublished)
				//HoursAndSource item = listEventDayBuckets.getAt(toIntDayBktsIdx);
<span class="fc" id="L1520">				listEventDayBuckets.setAt(toIntDayBktsIdx, dayMins, daySource);</span>
<span class="fc" id="L1521">				adjWeekDefMins -= dayMins;</span>
				
				// exhausted the minimums. clear out the rest of the buckets.
<span class="pc bpc" id="L1524" title="1 of 2 branches missed.">				if(adjWeekDefMins &lt;= 0){</span>
					do{
<span class="nc" id="L1526">						offset++;</span>
<span class="nc" id="L1527">						orgWeekDayBktsIdx = orgWeekDayBktsIdxForFirstUnSchedPerDayInOWForThisTOEvt + offset;</span>
<span class="nc" id="L1528">						toIntDayBktsIdx = toEvtDayBktsIdxForFirstUSPerDayForThisTOEvt + offset;</span>
<span class="nc bnc" id="L1529" title="All 4 branches missed.">						if(toIntDayBktsIdx &lt; numOfTOIntDayBkts &amp;&amp; orgWeekDayBktsIdx &lt; unscheduledDailyBuckets.length){</span>
<span class="nc" id="L1530">							listEventDayBuckets.setAt(toIntDayBktsIdx, 0, 0);</span>
						}else{
<span class="nc" id="L1532">							done = true;</span>
						}
<span class="nc bnc" id="L1534" title="All 2 branches missed.">					}while(!done);</span>
				} else {
<span class="pc bpc" id="L1536" title="4 of 6 branches missed.">					done = adjWeekDefMins &lt;= 0 || (toIntDayBktsIdx + 1) &gt;= numOfTOIntDayBkts</span>
							|| (orgWeekDayBktsIdx + 1) &gt;= unscheduledDailyBuckets.length;
<span class="fc" id="L1538">					offset++;</span>
				}

<span class="pc bpc" id="L1541" title="1 of 2 branches missed.">			} while (!done);</span>
<span class="fc" id="L1542">		}</span>

		/**
		 * Does the given orgWeek (specified in the weekData) have a time period
		 * with unScheduled period orgDays (orgDays after the cutOffOrgDay)?
		 *
		 * @param weekData
		 * @return
		 */
		boolean isOrgWeekWithUnSchedPeriod() {
<span class="pc bpc" id="L1552" title="1 of 4 branches missed.">			return currentOrgWeekType == ORGWEEKTYPE_DURINGCUTOFF || currentOrgWeekType == ORGWEEKTYPE_AFTERCUTOFF;</span>
		}
		
		
		

		/*
		 * (non-Javadoc)
		 * 
		 * @see java.lang.Object#toString()
		 */
		@Override
		public String toString() {
<span class="fc" id="L1565">			StringBuffer buf = new StringBuffer(256);</span>
<span class="fc" id="L1566">			buf.append(&quot;currentOrgWeekType = &quot; + ORGWEEKTYPE_STRARR[currentOrgWeekType] + '\n');</span>
<span class="fc" id="L1567">			buf.append(&quot;currentOrgWeekStartTime = &quot; + currentOrgWeekStartTime + '\n');</span>
<span class="fc" id="L1568">			buf.append(&quot;currentOrgWeekEndTime = &quot; + currentOrgWeekEndTime + '\n');</span>
<span class="fc" id="L1569">			buf.append(&quot;unscheduledDailyBuckets = &quot; + dumpArray(unscheduledDailyBuckets) + '\n');</span>
<span class="fc" id="L1570">			buf.append(&quot;dateWeekOtherTOEventsStartTime = &quot; + dateWeekOtherTOEventsStartTime + '\n');</span>
<span class="fc" id="L1571">			buf.append(&quot;dateWeekOtherTOEventsEndTime = &quot; + dateWeekOtherTOEventsEndTime + '\n');</span>
<span class="fc" id="L1572">			buf.append(&quot;weekUnSchedPerDayBktsForOtherTOEvts = &quot; + dumpArray(weekUnSchedPerDayBktsForOtherTOEvts) + '\n');</span>
<span class="fc" id="L1573">			buf.append(&quot;curIdxForDayInUnSchedPerForOW = &quot; + curIdxForDayInUnSchedPerForOW + '\n');</span>
<span class="fc" id="L1574">			buf.append(&quot;weekDefaultMinutes = &quot; + weekDefaultMinutes + '\n');</span>
<span class="fc" id="L1575">			buf.append(&quot;weekDefaultMinutesProRated = &quot; + weekDefaultMinutesProRated + '\n');</span>
<span class="fc" id="L1576">			buf.append(&quot;weekHolidayMinsForUnSchedPerDays = &quot; + weekHolidayMinsForUnSchedPerDays + '\n');</span>

<span class="fc" id="L1578">			return buf.toString();</span>
		}

		public boolean isInUnpublishedGap() {
<span class="fc" id="L1582">			return isDayInWeekInUnpublishedGap;</span>
			
		}
	}

	
	public int getEmployeeTerminationStatus(Date toStartTime, Date toEndTime) {
<span class="pc bpc" id="L1589" title="1 of 2 branches missed.">		if (empTerminationDate == null) {</span>
<span class="fc" id="L1590">			return EMP_NOT_TERMINATED;</span>
		}
<span class="nc bnc" id="L1592" title="All 2 branches missed.">		if (empTerminationDate.before(toStartTime)) {</span>
<span class="nc" id="L1593">			return EMP_TERMINATED_BEFORE_TO_PERIOD_START;</span>
		}
<span class="nc bnc" id="L1595" title="All 2 branches missed.">		if (empTerminationDate.before(toEndTime)) {</span>
<span class="nc" id="L1596">			return EMP_TERMINATED_BEFORE_TO_PERIOD_END;</span>
		} else {
<span class="nc" id="L1598">			return EMP_TERMINATED_AFTER_TO_PERIOD_END;</span>
		}
	}

	/**
	 * Calculates the length for a TO event between 'toStartTime' and
	 * 'toEndTime' for the given activityID.
	 *
	 * @param toStartTime
	 * @param toEndTime
	 * @param activityID
	 * @param enableOtherTOEvtsProcessing
	 *            use otherTOEvts (events which overlap the unscheduled region
	 *            before the toEvt for which the length is being computed) when
	 *            computing the length of the request in the unscheduled region.
	 * @return an array of integers. Each element represents the # of hours for
	 *         each day in the given range.
	 * @throws TimeOffCalculatorException
	 */
	private ListHoursAndSource calculateLength(Date toStartTime, Date toEndTime, ID activityID, 
			boolean enableOtherTOEvtsProcessing) throws Exception {
		
<span class="fc" id="L1620">		String method = &quot;calculateLength&quot;;</span>
<span class="fc" id="L1621">		LOG.debug(method + '(' + toStartTime + ',' + toEndTime + ',' + activityID + ')');</span>
<span class="fc" id="L1622">		int terminationStatus = getEmployeeTerminationStatus(toStartTime, toEndTime);</span>
<span class="pc bpc" id="L1623" title="1 of 2 branches missed.">		if (terminationStatus == EMP_TERMINATED_BEFORE_TO_PERIOD_START) {</span>
<span class="nc" id="L1624">			int size = getNumOfDaysForRange(getOrgDayStartTime(toStartTime), getOrgDayEndTime(toEndTime));</span>
<span class="nc" id="L1625">			ListHoursAndSource list = new ListHoursAndSource(size);</span>
<span class="nc" id="L1626">			return list;</span>
		}
<span class="pc bpc" id="L1628" title="1 of 2 branches missed.">		if (terminationStatus == EMP_TERMINATED_BEFORE_TO_PERIOD_END) {</span>
<span class="nc" id="L1629">			toEndTime = new Date(empTerminationDate.getTime());</span>
		}

<span class="fc" id="L1632">		thisTimeOffEventStart = toStartTime;</span>

		// Ensure that the TO start time falls between the calculator's range.
		// Note that the TO endTime
		// could fall outside the calculator's end time. One example of this is
		// when the reporting system seeds the
		// calculator with schedule data fetched from BBM using a time range.
		// The fetched schedule data might have
		// events whose end time falls outside the specified range but whose
		// start times will always be
		// between the given time range.
<span class="pc bpc" id="L1643" title="1 of 2 branches missed.">		if (thisTimeOffEventStart.before(timeRange.getStartDate())) {</span>

			// This confirms that the time difference is defintely not due to
			// DST.
<span class="nc bnc" id="L1647" title="All 2 branches missed.">			if (TOCalcUtil.isTimeDifferenceDueToDSTTransition(organization.getTimeZone(), thisTimeOffEventStart, timeRange.getStartDate())) {</span>
<span class="nc" id="L1648">				timeRange.setStartDate(new Date(thisTimeOffEventStart.getTime()));</span>
			} else {
<span class="nc" id="L1650">				throw new IllegalArgumentException(&quot;thisTimeOffEventStart, toEndTime, timeRange.getStartDate(), timeRange.getEndDate(): &quot;</span>
<span class="nc" id="L1651">						+ thisTimeOffEventStart + ',' + toEndTime + ',' + timeRange.getStartDate() + ',' + timeRange.getEndDate());</span>
			}
		}

<span class="fc" id="L1655">		thisTimeOffEventEnd = toEndTime;</span>
		// adjust the time back by 1 millisecond only if the end time &gt; start
		// time.
<span class="pc bpc" id="L1658" title="1 of 2 branches missed.">		if (thisTimeOffEventEnd.after(thisTimeOffEventStart)) {</span>
<span class="fc" id="L1659">			thisTimeOffEventEnd = TOCalcUtil.adjustDateUsingResolution(thisTimeOffEventEnd, shiftAssignmentMap.getResolution());</span>
		}

<span class="fc" id="L1662">		thisTimeOffEventActivityID = activityID;</span>

<span class="fc" id="L1664">		final Date toEvtOrgDayStartTime = getOrgDayStartTime(thisTimeOffEventStart);</span>
<span class="fc" id="L1665">		final Date toEvtOrgDayEndTime = getOrgDayEndTime(thisTimeOffEventEnd);</span>

<span class="fc" id="L1667">		Date curOrgDayStartTime = toEvtOrgDayStartTime;</span>
<span class="fc" id="L1668">		Date curOrgDayEndTime = getOrgDayEndTime(thisTimeOffEventStart);</span>

		// start time for thisTOEvent in current org day.
<span class="fc" id="L1671">		Date curDayStartTime = thisTimeOffEventStart;</span>
<span class="fc" id="L1672">		LOG.debug(&quot;curDayStartTime = &quot; + curDayStartTime);</span>
<span class="fc bfc" id="L1673" title="All 2 branches covered.">		Date curDayEndTime = thisTimeOffEventEnd.before(curOrgDayEndTime) ? thisTimeOffEventEnd : curOrgDayEndTime;</span>
<span class="fc" id="L1674">		LOG.debug(&quot;curDayEndTime = &quot; + curDayEndTime);</span>

<span class="fc" id="L1676">		int size = getNumOfDaysForRange(toEvtOrgDayStartTime, toEvtOrgDayEndTime);</span>
<span class="fc" id="L1677">		ListHoursAndSource listIntervalDayBuckets = new ListHoursAndSource(size);</span>
<span class="fc" id="L1678">		LOG.debug(&quot;ListHoursAndSource size = &quot; + listIntervalDayBuckets.getSize());</span>

<span class="fc" id="L1680">		int toIntervalDayIdx = 0;</span>

<span class="fc" id="L1682">		EmployeeTimeOffDefault activityAlloc = getAllocForActivity(activityID);</span>
<span class="fc" id="L1683">		setDayDefaultMins((int) (activityAlloc.getHoursPerDay() * 60));</span>

<span class="fc" id="L1685">		OrgWeekDataDuringUnSchedPeriod orgWeekData = new OrgWeekDataDuringUnSchedPeriod(activityAlloc, thisTimeOffEventStart);</span>
<span class="fc" id="L1686">		orgWeekData.resetAndInitOrgWeekData(curDayStartTime, enableOtherTOEvtsProcessing);</span>
<span class="fc" id="L1687">		LOG.debug(&quot;weekData.currentOrgWeekStartTime = &quot; + orgWeekData.currentOrgWeekStartTime);</span>
<span class="fc" id="L1688">		LOG.debug(&quot;weekData.currentOrgWeekEndTime = &quot; + orgWeekData.currentOrgWeekEndTime);</span>
<span class="fc" id="L1689">		Date prevCurDayStartTime = curDayStartTime;</span>
<span class="fc" id="L1690">		int counter = 0;</span>
		// while current day is before the last day
		
		// Are we going to use reference schedules?
<span class="fc" id="L1694">		this.usingReferenceSchedules = checkIfUsingReferenceSchedules(thisTimeOffEventStart, thisTimeOffEventEnd);</span>
		
<span class="pc bpc" id="L1696" title="1 of 4 branches missed.">		while (curDayStartTime.before(thisTimeOffEventEnd) &amp;&amp; curDayStartTime.before(toEvtOrgDayEndTime)) {</span>
<span class="pc bpc" id="L1697" title="1 of 2 branches missed.">			if (prevCurDayStartTime.equals(curDayStartTime)) {</span>
<span class="fc" id="L1698">				counter++;</span>
			} else {
<span class="nc" id="L1700">				prevCurDayStartTime = curDayStartTime;</span>
<span class="nc" id="L1701">				counter = 0;</span>
			}
<span class="pc bpc" id="L1703" title="1 of 2 branches missed.">			if (counter &gt; 2) {</span>
<span class="nc" id="L1704">				break;</span>
			}
			
<span class="fc" id="L1707">			int currentDayLength = calculateLengthCurrentDay(curDayStartTime, curDayEndTime, orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);</span>
			
<span class="fc" id="L1709">			LOG.debug(&quot;curDayStartTime: &quot; + curDayStartTime + &quot; currentDayLength: &quot; + currentDayLength);</span>

<span class="fc" id="L1711">			curDayStartTime = getNextOrgDayStartTime(curDayStartTime);</span>
<span class="fc" id="L1712">			curOrgDayStartTime = curDayStartTime;</span>
<span class="fc" id="L1713">			curOrgDayEndTime = getOrgDayEndTime(curOrgDayStartTime);</span>
<span class="pc bpc" id="L1714" title="1 of 2 branches missed.">			curDayEndTime = curOrgDayEndTime.after(thisTimeOffEventEnd) ? thisTimeOffEventEnd : curOrgDayEndTime;</span>

<span class="fc" id="L1716">			toIntervalDayIdx++;</span>
			
			// if rolling over to next org week, reset and initialize orgWeek
			// data
<span class="pc bpc" id="L1720" title="1 of 2 branches missed.">			if (curDayStartTime.after(orgWeekData.currentOrgWeekEndTime)) {</span>
				// process unScheduled period minutes accumulated so far.
				// Unscheduled is during cutoff or after
<span class="nc bnc" id="L1723" title="All 4 branches missed.">				if (orgWeekData.isOrgWeekWithUnSchedPeriod() || orgWeekData.isInUnpublishedGap() ) {</span>
<span class="nc" id="L1724">					orgWeekData.processUnscheduledPeriodHours(listIntervalDayBuckets, toEvtOrgDayStartTime, toEvtOrgDayEndTime,</span>
<span class="nc" id="L1725">							getDayDefaultMins(), enableOtherTOEvtsProcessing);</span>
				}

				// reset org week statistics and initialize with orgWeekStart
				// and orgWeekEnd for next week.
<span class="nc" id="L1730">				orgWeekData.resetAndInitOrgWeekData(curDayStartTime, enableOtherTOEvtsProcessing);</span>
			}
<span class="fc" id="L1732">		} // end while.</span>

		// if the last processed orgWeek has an unscheduled period and the
		// orgweek
		// overlaps the TOEvent , process the orgWeek data (as it was not
		// processed within the loop).
		// Note: the check for orgWeek overlap with the TOEvent is done to
		// handle the case where the
		// TOEvent ends on the last day of the org week. In this case, during
		// the last iteration of the loop, the code within  if rolling to new org week  block is
		// executed which advances
		// the orgWeekData to the next orgWeek. If this org week is processed
		// below, an 'IllegalARgumentException'
		// is thrown. See silk issue #27959.
<span class="pc bpc" id="L1746" title="3 of 4 branches missed.">		if ( orgWeekData.isOrgWeekWithUnSchedPeriod() || orgWeekData.isInUnpublishedGap()) {</span>
			//if (!calculatedLastDayRollOver &amp;&amp; orgWeekData.isOrgWeekWithUnSchedPeriod() || orgWeekData.isInUnpublishedGap()) {
<span class="pc bpc" id="L1748" title="1 of 2 branches missed.">			if (!orgWeekData.currentOrgWeekStartTime.after(toEvtOrgDayEndTime)) {</span>
<span class="fc" id="L1749">				orgWeekData.processUnscheduledPeriodHours(listIntervalDayBuckets, toEvtOrgDayStartTime, toEvtOrgDayEndTime,</span>
<span class="fc" id="L1750">						getDayDefaultMins(), enableOtherTOEvtsProcessing);</span>
			}
		}

<span class="fc" id="L1754">		listIntervalDayBuckets.logDebug(&quot;listIntervalDayBuckets&quot;);</span>
		
		// Sometimes the calc returns 0.02 hours instead of returning zero.
<span class="fc" id="L1757">		return listIntervalDayBuckets;</span>
	}

	boolean checkIfUsingReferenceSchedules(Date start, Date end) {
		
		// If there aren't any initialized, then definitely not.
		// Just because we loaded them does not mean we will need them.
		// This is due to the bulk load mechanism for updates. We have to 
		// check for reference schedules on a per request basis.
<span class="pc bpc" id="L1766" title="2 of 4 branches missed.">		if( this.referenceShiftAssignments == null || this.referenceShiftAssignments.isEmpty() ){</span>
<span class="fc" id="L1767">			return false;</span>
		}
		
		// if any part of the period is published, no reference schedules
<span class="nc bnc" id="L1771" title="All 2 branches missed.">		if (isPeriodPublishedAtAll(start, end)){</span>
<span class="nc" id="L1772">			return false;</span>
		}
		
<span class="nc" id="L1775">		return true;</span>
	}

	/**
	 * calculateLengthCurrentDay
	 * Will calculate the length for the current day 
	 * @return int length of current day. Only intended for use as debug information
	 */
	 int calculateLengthCurrentDay(Date curDayStartTime, Date curDayEndTime, OrgWeekDataDuringUnSchedPeriod orgWeekData,
			ListHoursAndSource listIntervalDayBuckets, int toIntervalDayIdx) {
		
<span class="fc" id="L1786"> 		int currentDayLength = 0;</span>
<span class="pc bpc" id="L1787" title="1 of 2 branches missed.">		if( this.usingReferenceSchedules ){</span>
			// if we are using reference schedules, assume they are like published schedules that need holidays removed.
<span class="nc" id="L1789">			currentDayLength = calculateLengthCurrentDayForReferenceSchedules(curDayStartTime, curDayEndTime, orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);</span>
<span class="pc bpc" id="L1790" title="1 of 2 branches missed.">		} else if (curDayStartTime.before(cutOffOrgWeekStartTime)) {</span>
			// if current day start time is before the cutOff week start time, see if there are any hours scheduled.
<span class="nc" id="L1792">			currentDayLength = calculateLengthCurrentDayBeforeCutOff(curDayStartTime, curDayEndTime, orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);</span>
			
<span class="fc bfc" id="L1794" title="All 2 branches covered.">		} else if (TOCalcUtil.dateBetween(curDayStartTime, cutOffOrgWeekStartTime, cutOffOrgWeekEndTime)) {</span>
			// if current day start time is &gt;= cutoff week start time and
			// current day end time &lt;= cutoff week end time
<span class="fc" id="L1797">			setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_OVERLAP);</span>
<span class="fc" id="L1798">			currentDayLength = processOneDayInOrgWeekDuringCutOff(curDayStartTime, curDayEndTime, getDayDefaultMins(),</span>
					orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);
		} else {
			// current day start time is &gt; the cutoff week end time.
			// If we've marked flag as Scheduled or Overlap, mark as overlap
<span class="pc bpc" id="L1803" title="1 of 2 branches missed.">			if (getPeriodFlag() == DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_SCHED</span>
<span class="pc bpc" id="L1804" title="1 of 2 branches missed.">					|| getPeriodFlag() == DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_OVERLAP) {</span>
<span class="nc" id="L1805">				setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_OVERLAP);</span>
			} else {
				// otherwise, mark as unscheduled
<span class="fc" id="L1808">				setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_UNSCHED);</span>
			}
			// If we have schedules, then we are probably crossing midnight over from 
			// published to unpublished. We handle it in processOneDayInOrgWeekDuringCutOff
<span class="fc" id="L1812">			int minutesInShift = getShiftAssignmentMap().countBitsOn(curDayStartTime, curDayEndTime);</span>
<span class="pc bpc" id="L1813" title="1 of 2 branches missed.">			if( minutesInShift &gt; 0){</span>
<span class="nc" id="L1814">				setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_OVERLAP);</span>
<span class="nc" id="L1815">				currentDayLength = processOneDayInOrgWeekDuringCutOff(curDayStartTime, curDayEndTime, getDayDefaultMins(),</span>
						orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);
			}else{
<span class="fc" id="L1818">				currentDayLength = processOneDayInOrgWeekAfterCutOff(curDayStartTime, curDayEndTime, getDayDefaultMins(),orgWeekData);</span>
			}
					
		} 
		
<span class="fc" id="L1823">		return currentDayLength;</span>
	}

	/**
	 * calculateLengthCurrentDayBeforeCutOff
	 * Will calculate the length for the current day if it is before the last shift cutoff.
	 * Takes into account the possibility that the shift has not been published
	 * * @return int length of current day. Only intended for use as debug information
	 */
	private int calculateLengthCurrentDayBeforeCutOff(Date curDayStartTime, Date curDayEndTime, OrgWeekDataDuringUnSchedPeriod orgWeekData,
			ListHoursAndSource listIntervalDayBuckets, int toIntervalDayIdx) {
<span class="nc" id="L1834">		int currentDayLength = 0;</span>
		
		// Initialize
<span class="nc" id="L1837">		setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_SCHED);</span>
<span class="nc" id="L1838">		currentDayLength = this.getShiftAssignmentMap().countBitsOn(curDayStartTime, curDayEndTime);</span>
		//toIntervalDayBuckets[toIntervalDayIdx] = currentDayLength;
<span class="nc" id="L1840">		listIntervalDayBuckets.setAt(toIntervalDayIdx, currentDayLength, DailyHoursBuckets.HOURS_SOURCE_SCHEDULE);</span>

		//Nothing scheduled for the day. But is it a published day?
<span class="nc bnc" id="L1843" title="All 2 branches missed.">		if (currentDayLength &lt; 1) {</span>
			// If not published, then mark it as such
			// Reference schedules are assumed to be published
<span class="nc bnc" id="L1846" title="All 4 branches missed.">			if (!usingReferenceSchedules &amp;&amp; PERIOD_UNPUBLISHED == getPublishedPeriodStatus(curDayStartTime, curDayEndTime)) {</span>
<span class="nc" id="L1847">				this.setIsInUnpublishededGap(true);</span>
<span class="nc" id="L1848">				setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_UNSCHED);</span>
				
				// Will update toIntervalDayBuckets with daily value
<span class="nc" id="L1851">				currentDayLength = processOneDayInOrgWeekInUnpublishedGap(curDayStartTime, curDayEndTime, getDayDefaultMins(),orgWeekData, listIntervalDayBuckets, toIntervalDayIdx);</span>
			} 
		}
		
<span class="nc" id="L1855">		LOG.debug(&quot;Before cut off week: dayMins = &quot; + currentDayLength);</span>
<span class="nc" id="L1856">		LOG.debug(&quot;Before cut off week: in Gap?  &quot; + this.getIsInUnpublishededGap());</span>
<span class="nc" id="L1857">		return currentDayLength;</span>
	}
	
	/**
	 * calculateLengthCurrentDayForReferenceSchedules
	 * 
	 * Will calculate the length for the current day for reference schedules.
	 * These schedules are treated as published schedules before the cutoff date.
	 * We have to deduct holidays because the reference schedule should be outside of our actual request range. 
	 * They are mapped into our request range on a weekday by weeday (all mondays are the same, etc).
	 * For published shifts, we do not deduct holidays. In this case, we must since reference schedules
	 * do not know anything about holidays.
	 * 
	 * See calculateLengthCurrentDayBeforeCutOff. this should be very similar.
	 * 
	 * * @return int length of current day. Only intended for use as debug information
	 */
	
	private int calculateLengthCurrentDayForReferenceSchedules(
			Date curDayStartTime, Date curDayEndTime,
			OrgWeekDataDuringUnSchedPeriod orgWeekData,
			ListHoursAndSource listIntervalDayBuckets, int toIntervalDayIdx) {

<span class="nc bnc" id="L1880" title="All 2 branches missed.">		if( referenceShiftAssignmentMap == null){</span>
<span class="nc" id="L1881">			return 0;</span>
		}

		// Initialize as scheduled
<span class="nc" id="L1885">		setPeriodFlag(DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_SCHED);</span>
<span class="nc" id="L1886">		int currentDayLength = this.referenceShiftAssignmentMap.countBitsOn(</span>
				curDayStartTime, curDayEndTime);

<span class="nc bnc" id="L1889" title="All 2 branches missed.">		if (currentDayLength &gt; 0) {</span>
			// calculate holiday minutes during the interval
<span class="nc" id="L1891">			int holidayMins = holidayAssignmentMap.countBitsOn(curDayStartTime,</span>
					curDayEndTime);

			// if holiday exists during this interval, then trim shift minutes
			// for the interval
<span class="nc" id="L1896">			currentDayLength = Math.max((currentDayLength - holidayMins), 0);</span>
		}

<span class="nc" id="L1899">		listIntervalDayBuckets.setAt(toIntervalDayIdx, currentDayLength,</span>
				DailyHoursBuckets.HOURS_SOURCE_SCHEDULE);

<span class="nc" id="L1902">		LOG.debug(&quot;calculateLengthCurrentDayForReferenceSchedules: dayMins = &quot;</span>
				+ currentDayLength);

<span class="nc" id="L1905">		return currentDayLength;</span>
	}
	
	
	/**
	 * @param activityID
	 * @return
	 */
	private EmployeeTimeOffDefault getAllocForActivity(ID activityID) {
<span class="fc" id="L1914">		EmployeeTimeOffDefault activityAlloc = (EmployeeTimeOffDefault) allotmentMap.get(activityID);</span>
<span class="fc" id="L1915">		LOG.debug(&quot;activityAlloc = &quot; + activityAlloc);</span>
<span class="fc bfc" id="L1916" title="All 2 branches covered.">		if (activityAlloc == null) {</span>
<span class="fc" id="L1917">			activityAlloc = getDefaultActivityAlloc(empId, activityID);</span>
<span class="fc" id="L1918">			allotmentMap.put(activityID, activityAlloc);</span>
		}
<span class="fc" id="L1920">		return activityAlloc;</span>
	}

	
	/**
	 * Unpublished gap is scheduled dates before the cutoff but yet unpublished
	 * We treat these dates as if they are after the cutoff 
	 * @param curDayStartTime
	 * @param curDayEndTime
	 * @param dayDefaultMins
	 * @param weekData
	 * @return number of computed minutes for the org day.
	 */
	private int processOneDayInOrgWeekInUnpublishedGap(Date curDayStartTime, Date curDayEndTime, final int dayDefaultMins,
			OrgWeekDataDuringUnSchedPeriod weekData, ListHoursAndSource listIntervalDayBuckets, int toIntervalDayIdx) {

		// factors: partial/full week (toEnd does/doesn't fall within this week)
		// holidays this week
		// non shift hours lesser or greater than adjusted week default.
<span class="nc" id="L1939">		final String prefix = &quot;Unpublished Gap before cut off week: &quot;;</span>

<span class="nc" id="L1941">		int workableMins = processOrgDayInUnpublishedGap(curDayStartTime, curDayEndTime, dayDefaultMins, weekData, prefix);</span>

		// Update dayMins to the array
<span class="nc" id="L1944">		listIntervalDayBuckets.setAt(toIntervalDayIdx, workableMins, DailyHoursBuckets.HOURS_SOURCE_DEFAULT);</span>
		//toIntervalDayBuckets[toIntervalDayIdx] = workableMins;
		
<span class="nc" id="L1947">		return workableMins;</span>
	}
	
	/**
	 *
	 * @param curDayStartTime
	 * @param curDayEndTime
	 * @param dayDefaultMins
	 * @param weekData
	 * @return number of computed minutes for the org day.
	 */
	private int processOneDayInOrgWeekAfterCutOff(Date curDayStartTime, Date curDayEndTime, final int dayDefaultMins,
			OrgWeekDataDuringUnSchedPeriod weekData) {

		// factors: partial/full week (toEnd does/doesn't fall within this week)
		// holidays this week
		// non shift hours lesser or greater than adjusted week default.
<span class="fc" id="L1964">		final String prefix = &quot;After  cut off week: &quot;;</span>

<span class="fc" id="L1966">		int workableMins = processOrgDayAfterCutOffOrgDay(curDayStartTime, curDayEndTime, dayDefaultMins, weekData, prefix);</span>

<span class="fc" id="L1968">		return workableMins;</span>
	}
	
	private int processOrgDayInUnpublishedGap(Date curDayStartTime, Date curDayEndTime, final int dayDefaultMins,
			OrgWeekDataDuringUnSchedPeriod weekData, final String prefix)
	{
		
		
<span class="nc" id="L1976">		weekData.isDayInWeekInUnpublishedGap = true;</span>
		
		// For now, simply handle dates in unpublished gap as if it were after the cutoff date
<span class="nc" id="L1979">		return processOrgDayAfterCutOffOrgDay( curDayStartTime,  curDayEndTime, dayDefaultMins,weekData, prefix);</span>
				
	}
	/**
	 * @param isInUnpublishedGap marks this day as occurring before cutoff but is unpublished. Currently, only a flag.
	 * @return number of computed minutes for the org day.
	 */
	
	private int processOrgDayAfterCutOffOrgDay(Date curDayStartTime, Date curDayEndTime, final int dayDefaultMins,
			OrgWeekDataDuringUnSchedPeriod weekData, final String prefix) {
	
<span class="fc" id="L1990">		int workableMins = 0;</span>
<span class="pc bpc" id="L1991" title="1 of 2 branches missed.">		if (weekData.curIdxForDayInUnSchedPerForOW &gt;= 7) {</span>
			// Problematic condition. Index overflow.
			// Avoid using the index for the
			// weekData.unscheduledDailyBuckets[] array.
			// Issue a warning, return 0
<span class="nc" id="L1996">			LOG.warn(&quot; processOrgDayAfterCutOffOrgDay:\n&quot; + &quot; Array index &gt;= 7 condition encountered. \n&quot;</span>
					+ &quot; This may happen when switching to/from daylight saving time. \n&quot;
					+ &quot; Warning: The calculated time off may be off by one hour. \n&quot; + &quot; Datailed Week Data for problematic condition: \n&quot;
<span class="nc" id="L1999">					+ weekData.toString() + &quot;\n&quot; + &quot; prefix= &quot; + prefix + &quot;\n&quot; + &quot; dayDefaultMins= &quot; + dayDefaultMins + &quot;\n&quot;</span>
					+ &quot; curDayStartTime= &quot; + curDayStartTime + &quot;, curDayEndTime= &quot; + curDayEndTime + &quot;\n&quot; + &quot;, EMPID=&quot; + empId
					+ &quot;  , range=&quot; + timeRange
					);
		} else {
			//This may be crossing midnight from published to unpublished if there is anything scheduled.
<span class="fc" id="L2005">			int minutesInShift = getShiftAssignmentMap().countBitsOn(curDayStartTime, curDayEndTime);</span>
<span class="pc bpc" id="L2006" title="1 of 2 branches missed.">			if (minutesInShift &gt; 0) {</span>
				// store in the week day's bucket
<span class="nc" id="L2008">				workableMins = minutesInShift;</span>
<span class="nc" id="L2009">				weekData.unscheduledDailyBuckets[weekData.curIdxForDayInUnSchedPerForOW] = workableMins;</span>
<span class="nc" id="L2010">				weekData.unscheduledDailyBucketsSource[weekData.curIdxForDayInUnSchedPerForOW]= DailyHoursBuckets.HOURS_SOURCE_SCHEDULE;</span>
				
			} else {
				// Normal situation: calculate holiday minutes during the interval
<span class="fc" id="L2014">				int holidayMins = holidayAssignmentMap.countBitsOn(curDayStartTime, curDayEndTime);</span>

				// calculate non shift minutes (possible work hours) between curent
				// day start time and current day end time
<span class="fc" id="L2018">				workableMins = workableTimeMap.countBitsOn(curDayStartTime, curDayEndTime);</span>
<span class="fc" id="L2019">				LOG.debug(prefix + &quot;gross dayMins = &quot; + workableMins + &quot; holidayMins = &quot; + holidayMins + &quot; dayDefaultMins = &quot;</span>
						+ dayDefaultMins);
				// if holiday exists during this interval, then trim non shift
				// minutes for the interval
<span class="fc" id="L2023">				workableMins = Math.max((workableMins - holidayMins), 0);</span>

				// limit to day default
<span class="fc" id="L2026">				workableMins = Math.min(workableMins, dayDefaultMins);</span>
<span class="fc" id="L2027">				LOG.debug(prefix + &quot;adjusted dayMins = &quot; + workableMins);</span>

<span class="fc" id="L2029">				int idx = weekData.curIdxForDayInUnSchedPerForOW;</span>
				// store in the week day's bucket
<span class="pc bpc" id="L2031" title="1 of 2 branches missed.">				if(weekData.isInUnpublishedGap()){</span>
					//jt
					//If we are in the unpublished gap, the weekdata is 
					//not set up properly since it's before the
					//last shift. Get the index here.
<span class="nc" id="L2036">					idx = getNumOfDaysForRange(weekData.currentOrgWeekStartTime, curDayStartTime) - 1;</span>
<span class="nc bnc" id="L2037" title="All 4 branches missed.">					assert (idx &lt; 7)  : &quot;getNumOfDaysForRange &lt; 7: &quot; + idx;</span>

				}
				
				
<span class="fc" id="L2042">				weekData.unscheduledDailyBuckets[idx] = workableMins;</span>
<span class="fc" id="L2043">				weekData.unscheduledDailyBucketsSource[idx]= DailyHoursBuckets.HOURS_SOURCE_DEFAULT;</span>
				
				
			}
			// Increment the pointer to the 'unScheduled period' day within the week.
			// Protected from overflow by the &quot;if&quot; statement
<span class="fc" id="L2049">			weekData.curIdxForDayInUnSchedPerForOW++; </span>
			
		}
<span class="fc" id="L2052">		return workableMins;</span>
		
	}

	/**
	 *
	 * @param curDayStartTime
	 * @param curDayEndTime
	 * @param dayDefaultMins
	 * @param weekData
	 * @param intervalDayBuckets
	 * @param intervalDayIdx
	 * @return number of minutes for current org day.
	 */
	private int processOneDayInOrgWeekDuringCutOff(Date curDayStartTime, Date curDayEndTime, final int dayDefaultMins,
			OrgWeekDataDuringUnSchedPeriod weekData, ListHoursAndSource listIntervalDayBuckets, int toIntervalDayIdx) {
		// factors:
		// shift hours &gt; or &lt; weekly default
		// shift hours + non shift hours &gt; or &lt; adjusted weekly default
<span class="fc" id="L2071">		final String prefix = &quot;During cut off week: &quot;;</span>

<span class="fc" id="L2073">		int dayMins = 0;</span>

<span class="fc" id="L2075">		boolean pastCutOffDay = true;</span>
		
		// if current day start time &lt;= cutOffDayStartTime
<span class="pc bpc" id="L2078" title="1 of 2 branches missed.">		if (curDayStartTime.getTime() &lt; cutOffOrgDayEndTime.getTime()) {</span>
<span class="fc" id="L2079">			pastCutOffDay = false;</span>
		}
<span class="fc" id="L2081">		LOG.debug(prefix + &quot;pastCutOffDay = &quot; + pastCutOffDay);</span>

		
		// If we are past the cut off day, and the last shift crossed midnight into this day,
		// the shift minutes won't be checked and we'll miss them.
		// So let's use the shift minutes whether we are before the cutoff or after (only if there are any)
		// if not past the cutoff day. Get from shifts. 
<span class="fc" id="L2088">		dayMins = getShiftAssignmentMap().countBitsOn(curDayStartTime, curDayEndTime);</span>
<span class="pc bpc" id="L2089" title="1 of 2 branches missed.">		if (!pastCutOffDay) {</span>
<span class="fc" id="L2090">			listIntervalDayBuckets.setAt(toIntervalDayIdx, dayMins, DailyHoursBuckets.HOURS_SOURCE_SCHEDULE);</span>
<span class="fc" id="L2091">			LOG.debug(prefix + &quot;dayMins = &quot; + dayMins);</span>
		} else {
<span class="nc bnc" id="L2093" title="All 2 branches missed.">			if (dayMins &gt; 0) {</span>
<span class="nc" id="L2094">				listIntervalDayBuckets.setAt(toIntervalDayIdx, dayMins, DailyHoursBuckets.HOURS_SOURCE_SCHEDULE);</span>
			}
			// If past cut off day, we default hours. But what if these days are published?
<span class="nc" id="L2097">			dayMins = processOrgDayAfterCutOffOrgDay(curDayStartTime, curDayEndTime, dayDefaultMins, weekData, prefix);</span>
		}

<span class="fc" id="L2100">		return dayMins;</span>
	}

	/**
	 * Note: Range of returned dayOfWeek is between 1 and 7 (not 0 and 6).
	 *
	 * @param curDayStart
	 * @return
	 */
	private short getDayOfWeekInOrgTZ(Date date) {
		// instantiate if necessary.
<span class="fc" id="L2111">		calendarOrgTimeZone1.setTime(date);</span>

<span class="fc" id="L2113">		return (short) calendarOrgTimeZone1.get(Calendar.DAY_OF_WEEK);</span>
	}

	/**
	 * Get the allotment map from the calculator. This map maps an activity id
	 * to an EmployeeTimeOff object. It is used to find the allotted hours of
	 * each activity type for this employee.
	 */
	public Map getAllotmentMap() {
<span class="nc" id="L2122">		return allotmentMap;</span>
	}

	/**
	 * Setter for property allotmentMap. Package visibility only.
	 * 
	 * @param allotmentMap
	 *            map of activityIds to EmployeeTimeOff objects.
	 */
	void setAllotmentMap(Map aAllotmentMap) {
		// Allotment map can be empty
<span class="fc" id="L2133">		this.allotmentMap = aAllotmentMap;</span>
<span class="pc bpc" id="L2134" title="1 of 2 branches missed.">		if (this.allotmentMap == null) {</span>
<span class="nc" id="L2135">			this.allotmentMap = new HashMap();</span>
		} 
<span class="fc" id="L2137">	}</span>

	/**
	 * Get the employee ID for this time off length calculator.
	 */
	public ID getEmpId() {
<span class="fc" id="L2143">		return empId;</span>
	}

	/**
	 * Setter for property employee id. Package visibility only.
	 * 
	 * @param empId
	 *            employee id to use with this calculator.
	 */
	private void setEmpId(ID aEmpId) {
		// the employee id cannot be null
		
<span class="fc" id="L2155">		this.empId = aEmpId;</span>
<span class="pc bpc" id="L2156" title="1 of 2 branches missed.">		if (this.empId == null) {</span>
<span class="nc" id="L2157">			throw new IllegalArgumentException();</span>
		}
<span class="fc" id="L2159">	}</span>

	/**
	 * Getter for property org.
	 * 
	 * @return organization for this employee during the period for purposes of
	 *         calculating time off length
	 */
	public Organization getOrg() {
<span class="nc" id="L2168">		return organization;</span>
	}

	/**
	 * Setter for organization. Package visibility only.
	 * 
	 * @param org
	 *            organization for this employee for the purposes of calculating
	 *            time off length.
	 */
	protected void setOrg(Organization aOrg) {
		// organization cannot be null
<span class="pc bpc" id="L2180" title="1 of 2 branches missed.">		if (aOrg == null) {</span>
<span class="nc" id="L2181">			throw new IllegalArgumentException();</span>
		}
<span class="fc" id="L2183">		organization = aOrg;</span>
<span class="fc" id="L2184">	}</span>

	/**
	 * Get Collection of hours of operation (HOO) assignments for this
	 * organization.
	 */
	public Collection getOrgHOOAssignments() {
<span class="nc" id="L2191">		return orgHoursOfOperationAssignments;</span>
	}

	/**
	 * Setter for orgHOOAssignments. Package visibility only.
	 * 
	 * @param orgHOOAssignments
	 *            Collection of OrganizationHOO objects for this employee's
	 *            organization
	 *
	 */
	private void setOrgHOOAssignments(Collection orgHOOAssignments) {
<span class="fc" id="L2203">		this.orgHoursOfOperationAssignments = orgHOOAssignments;</span>
<span class="pc bpc" id="L2204" title="1 of 2 branches missed.">		if (orgHoursOfOperationAssignments == null) {</span>
<span class="nc" id="L2205">			orgHoursOfOperationAssignments = Collections.emptyList();</span>
		}
<span class="fc" id="L2207">	}</span>

	/**
	 * Get the time range that this calculator operates on. Any time off request
	 * that is checked must be within this range.
	 * 
	 * @return time range for this calculator
	 *
	 */
	public TimeRange getRange() {
<span class="fc" id="L2217">		return timeRange;</span>
	}

	/**
	 * Setter for time range. Package visibility only.
	 * 
	 * @param range
	 *            value of time range that specifies period for which this time
	 *            off length calculator will compute lengths of time off
	 *            requests.
	 */
	private void setRange(TimeRange range) {
		// range cannot be null
<span class="pc bpc" id="L2230" title="1 of 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L2231">			throw new IllegalArgumentException();</span>
		}

<span class="fc" id="L2234">		this.timeRange = range;</span>
<span class="fc" id="L2235">	}</span>

	/**
	 * Getter for Collection of shift assignemnts for this employee during the
	 * period.
	 * 
	 * @return Collection of Event objects.
	 *
	 */
	public Collection&lt;ShiftAssignment&gt; getShiftAssignments() {
<span class="nc" id="L2245">		return shiftAssignments;</span>
	}

	/**
	 * Setter for property shiftAssignments. Package visibility only.
	 * 
	 * @param shiftAssignments
	 *            Collection of Event objects representing the shift assignments
	 *            for this employee during the period
	 */
	private void setShiftAssignments(Collection&lt;ShiftAssignment&gt; aShiftAssignments) {
<span class="fc" id="L2256">		this.shiftAssignments = (List&lt;ShiftAssignment&gt;) aShiftAssignments;</span>
<span class="pc bpc" id="L2257" title="1 of 2 branches missed.">		if (this.shiftAssignments == null) {</span>
<span class="nc" id="L2258">			this.shiftAssignments = Collections.emptyList();</span>
		}
<span class="fc" id="L2260">	}</span>

	/**
	 * Getter for unavailabilities. Collection of unavailability calendar events
	 * for this employee during the period.
	 * 
	 * @return Collection of unavailabiltiy calendar events
	 */
	public Collection getUnavailabilities() {
<span class="nc" id="L2269">		return unavailabilityEvents;</span>
	}

	/**
	 * Setter for unavailabilities. Package visibility only.
	 * 
	 * @param unavailabilities
	 *            Set the Collection of unavailability calendar events for this
	 *            employee during the period.
	 */
	private void setUnavailabilities(Collection unavailabilities) {
<span class="fc" id="L2280">		this.unavailabilityEvents = unavailabilities;</span>
<span class="pc bpc" id="L2281" title="1 of 2 branches missed.">		if (this.unavailabilityEvents == null) {</span>
<span class="nc" id="L2282">			this.unavailabilityEvents = Collections.emptyList();</span>
		}
<span class="fc" id="L2284">	}</span>

	/**
	 * Getter for property list of holidays.
	 * 
	 * @return Collection of holidays stored in this calculator
	 */
	public Collection getHolidays() {
<span class="nc" id="L2292">		return holidays;</span>
	}

	/**
	 * Set the holiday collection
	 * 
	 * @param holidays
	 *            a collection of paid holidays taken into consideration when
	 *            calculating the length of a time off request.
	 */
	private void setHolidays(Collection aHolidays) {
<span class="fc" id="L2303">		this.holidays = aHolidays;</span>
<span class="pc bpc" id="L2304" title="1 of 2 branches missed.">		if (this.holidays == null) {</span>
<span class="nc" id="L2305">			this.holidays = Collections.emptyList();</span>
		}
<span class="fc" id="L2307">	}</span>

	/**
	 * Returns the 'midnight' date for the given 'date' in the TOCalc's
	 * organization timezone.
	 *
	 * @param date
	 * @return
	 */
	protected Date getDayStart(Date date) {
<span class="fc" id="L2317">		Calendar cal = Calendar.getInstance(organization.getTimeZone());</span>

<span class="fc" id="L2319">		cal.setTime(date);</span>
<span class="fc" id="L2320">		TOCalcUtil.setCalMinsOffsetFromMidnight(cal, 0);</span>

<span class="fc" id="L2322">		return cal.getTime();</span>
	}

	/**
	 * Compute the next day for the given date, retaining the hour, minute and
	 * seconds. For instance, if the passed date is 11:53AM 1/1/2001, this
	 * returns 11:53AM, 1/2/2001.
	 */
	protected Date getNextDay(Date date) {
<span class="fc" id="L2331">		return TOCalcUtil.getDateForwardOneDay(date, organization.getTimeZone());</span>
	}

	protected Date getOrgWeekStartTime(Date date) {
<span class="fc" id="L2335">		return TOCalcUtil.getDateForOrgWeekStart(organization, date);</span>
	}

	protected Date getOrgWeekEndTime(Date date) {
<span class="fc" id="L2339">		return TOCalcUtil.getDateForOrgWeekEnd(organization, date);</span>
	}

	protected Date getOrgDayStartTime(Date date) {
<span class="fc" id="L2343">		return TOCalcUtil.getDateForOrgDayStart(organization, date);</span>
	}

	protected Date getNextOrgDayStartTime(Date date) {
		// todo: make this a member variable
<span class="fc" id="L2348">		Calendar cal = Calendar.getInstance(organization.getTimeZone());</span>
<span class="fc" id="L2349">		cal.setTime(getOrgDayStartTime(date));</span>
<span class="fc" id="L2350">		TOCalcUtil.addDaysToCalendar(cal, 1);</span>

<span class="fc" id="L2352">		return cal.getTime();</span>
	}

	protected Date getOrgDayEndTime(Date date) {
<span class="fc" id="L2356">		return TOCalcUtil.getDateForOrgDayEnd(organization, date);</span>
	}

	/**
	 * returns number of 24 hour periods in the given range.
	 *
	 * &lt;p&gt;
	 * For example:
	 * &lt;li&gt;range (1/1/2004 10:00AM, 1/1/2004 11:00AM) returns 1.
	 * &lt;li&gt;range (1/1/2004 10:00AM, 1/2/2004 9:00AM) returns 2.
	 *
	 * &lt;p&gt;
	 * Caution: This method is normally used to compute an index into the
	 * dailyBuckets array. Each element in the day bucket has an associated date
	 * (in TOCalc, the orgDayStart). The 'start' parameter ***must*** be a 24
	 * hour multiple of the date associated with the first element in the bucket
	 * and ***not*** some random date which falls between the '24 hour mulitple'
	 * dates of consecutive elements.
	 *
	 * &lt;p&gt;
	 * 
	 * &lt;pre&gt;
	 * Consider the following example:
	 * 
	 * dailyBucket range: start = 1/1/2004 10:00AM; end = 1/5/2004 10:00AM;  # of elements = 5
	 * numOfDays for range 1/1/2004 10:00AM and 1/2/2004 10:00AM: 2 (correct)
	 * numOfDays for range 1/1/2004 10:01AM and 1/2/2004 10:00AM: 1 (must actaully be 2. incorrect since 'start' not aligned).
	 * &lt;/pre&gt;
	 *
	 * @param start
	 * @param end
	 * @return
	 */
	// TODO: make this a method of a new DailyHoursBucket class which represents
	// a bucket of integer minutes.
	public int getNumOfDaysForRange(Date aStart, Date aEnd) {
		// QA 95083 - Receiving zero length errors Oct 31 for DST 2009
		// make sure the date has time is start time of Organization to prevent
		// DST issue
<span class="fc" id="L2395">		Date start = getOrgDayStartTime(aStart);</span>
<span class="fc" id="L2396">		Date end = getOrgDayStartTime(aEnd);</span>
		// End #95083
<span class="pc bpc" id="L2398" title="1 of 2 branches missed.">		if (start.after(end)) {</span>
<span class="nc bnc" id="L2399" title="All 2 branches missed.">			if (TOCalcUtil.isTimeDifferenceDueToDSTTransition(organization.getTimeZone(), start, end)) {</span>
<span class="nc" id="L2400">				start = new Date(end.getTime());</span>
			} else {
<span class="nc" id="L2402">				throw new IllegalArgumentException(&quot;start after end: &quot; + start + &quot; after &quot; + end);</span>
			}
		}

		// Calculate the day difference between given start and end time
<span class="fc" id="L2407">		Calendar startCal = calendarOrgTimeZone1;</span>
<span class="fc" id="L2408">		startCal.setTime(start);</span>

		// get year for the orgDayStart that contains dt.
<span class="fc" id="L2411">		Calendar endCal = calendarOrgTimeZone2;</span>
<span class="fc" id="L2412">		endCal.setTime(end);</span>

<span class="fc" id="L2414">		int endYear = endCal.get(Calendar.YEAR);</span>
		// if startCal points to a prior calendar year

		// compute numOfDays, starting at 'start', during years prior to
		// 'endYear'.
<span class="fc" id="L2419">		int diffInDays = 0;</span>
<span class="pc bpc" id="L2420" title="1 of 2 branches missed.">		while (startCal.get(Calendar.YEAR) &lt; endYear) {</span>
<span class="nc" id="L2421">			int dayInYear = startCal.get(Calendar.DAY_OF_YEAR);</span>
<span class="nc" id="L2422">			int lastDayOfYear = startCal.getActualMaximum(Calendar.DAY_OF_YEAR);</span>

			// number of days to get the rest of year.
<span class="nc" id="L2425">			diffInDays += lastDayOfYear - dayInYear + 1;</span>

			// set startCal to point the beginning of the next year
<span class="nc" id="L2428">			startCal.roll(Calendar.YEAR, true);</span>
<span class="nc" id="L2429">			startCal.set(Calendar.MONTH, Calendar.JANUARY);</span>
<span class="nc" id="L2430">			startCal.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L2431">		}</span>

		// Now the calendars point to the same year
<span class="fc" id="L2434">		diffInDays += (endCal.get(Calendar.DAY_OF_YEAR) - startCal.get(Calendar.DAY_OF_YEAR));</span>

		// This logic is needed for the scenarios similar to one shown below.
		// Without it, the
		// returned value will not be accurate:
		// For StartDate: 7/12/2004 22:00 CST; EndDate: 7/19/2004 00:00 CST, the
		// returned value must be 7 and not 8.
		// For StartDate: 7/12/2004 00:00 CST; EndDate: 7/19/2004 00:00 CST, the
		// returned value must be 8
<span class="fc" id="L2443">		long offSetFromDayStartInMsForStartDate = getOffsetFromDayStartInMs(startCal);</span>
<span class="fc" id="L2444">		long offSetFromDayStartInMsForEndDate = getOffsetFromDayStartInMs(endCal);</span>

<span class="pc bpc" id="L2446" title="1 of 2 branches missed.">		if (offSetFromDayStartInMsForStartDate &gt; offSetFromDayStartInMsForEndDate) {</span>
<span class="nc" id="L2447">			return diffInDays;</span>
		}

<span class="fc" id="L2450">		return diffInDays + 1;</span>
	}

	private int getOffsetFromDayStartInMs(Calendar cal) {
<span class="fc" id="L2454">		return cal.get(Calendar.HOUR_OF_DAY) * (60 * 60 * 1000) + cal.get(Calendar.MINUTE) * 60 * 1000 + cal.get(Calendar.SECOND) * 1000</span>
<span class="fc" id="L2455">				+ cal.get(Calendar.MILLISECOND);</span>
	}

	protected DailyHoursBuckets getDailyHoursBuckets(TimeRange range, TimeZone tz, int dayBoundaryOffset, ListHoursAndSource dailyhoursAndSourceBuckets) {
<span class="fc" id="L2459">		DailyHoursBuckets dayBuckets = new DailyHoursBuckets(dayBoundaryOffset, tz, range);</span>
<span class="fc" id="L2460">		Date curDay = range.getStartDate();</span>
<span class="fc" id="L2461">		final float MINUTES_IN_HOUR = 60.0f;</span>
		
<span class="pc bpc" id="L2463" title="1 of 2 branches missed.">		for (int i = 0; i &lt; dailyhoursAndSourceBuckets.getSize(); i++) {</span>
<span class="fc" id="L2464">			HoursAndSource item = dailyhoursAndSourceBuckets.getAt(i);</span>
			
<span class="fc" id="L2466">			dayBuckets.addToBucket(curDay, item.hours / MINUTES_IN_HOUR, item.hoursSource);</span>
<span class="fc" id="L2467">			curDay = getNextDay(curDay);</span>
			// QC 46084; [10SP4 - TO] When I create a TO Event or TO Request
			// accross day boundary.
			// The Hours Account for Pending or Approved TO is only counted for
			// the firstday.
			// Need to always check against the Day end for TO event end date
			// instead of the TO Event end time because
			// the last day is lost if the end time is in middle of the day.
			// Sameet, sept 2009
<span class="pc bpc" id="L2476" title="1 of 2 branches missed.">			if (curDay.after(dayBuckets.getDHBRangeEndAsOrgDayEnd())) {</span>
<span class="fc" id="L2477">				break;</span>
			}
			
		}
		// set the flag to denote which of 3 cases interval falls in:
<span class="fc" id="L2482">		dayBuckets.setPeriodFlag(getPeriodFlag());</span>
<span class="fc" id="L2483">		return dayBuckets;</span>
	}

	/**
	 *
	 * Calls to TimeMap.setRange() are passed trimmed dates if necessary to
	 * ensure that the passed range is within the map's time range.
	 *
	 */
	protected void setOrgHOOAssignmentsInMap() {
		// for each hoo in collection
		// for hoo.start to hoo.end
		// setBits in map
		// end for
		// end for
<span class="fc bfc" id="L2498" title="All 2 branches covered.">		for (Iterator it = orgHoursOfOperationAssignments.iterator(); it.hasNext();) {</span>
<span class="fc" id="L2499">			OrganizationHOO hoo = (OrganizationHOO) it.next();</span>

<span class="fc" id="L2501">			Date hooStart = hoo.getStartTime();</span>
<span class="pc bpc" id="L2502" title="1 of 2 branches missed.">			if (hooStart == null) {</span>
<span class="fc" id="L2503">				hooStart = new Date(0);</span>
			}

			// trim hooStart to orgDayStartForRange if necessary.
<span class="pc bpc" id="L2507" title="1 of 2 branches missed.">			hooStart = hooStart.before(organizationDayStartForRange) ? organizationDayStartForRange : hoo.getStartTime();</span>

			// trim hooEnd to orgDayEndForRange if necessary.
<span class="fc" id="L2510">			Date hooEnd = hoo.getEndTime();</span>
<span class="pc bpc" id="L2511" title="1 of 2 branches missed.">			hooEnd = (hooEnd == null) ? organizationDayEndForRange : hooEnd;</span>
<span class="pc bpc" id="L2512" title="1 of 2 branches missed.">			hooEnd = hooEnd.after(organizationDayEndForRange) ? organizationDayEndForRange : hooEnd;</span>

			// for **each day** that the HOO's range represents.
<span class="fc" id="L2515">			Date midnightForCurDay = getDayStart(hooStart);</span>
<span class="fc bfc" id="L2516" title="All 2 branches covered.">			for (; midnightForCurDay.before(hooEnd); midnightForCurDay = getNextDay(midnightForCurDay)) {</span>
				// get the day of week for this day.
<span class="fc" id="L2518">				short dayOfWeek = getDayOfWeekInOrgTZ(midnightForCurDay);</span>

<span class="fc" id="L2520">				int dayOpenOffset = hoo.getDayOpen(dayOfWeek);</span>

				// if hours of operation are specified for this day of the week.
<span class="pc bpc" id="L2523" title="1 of 2 branches missed.">				if (dayOpenOffset &gt;= 0) {</span>
					// get day close offest
<span class="fc" id="L2525">					int dayCloseOffset = hoo.getDayClose(dayOfWeek);</span>

					// Set the range of bits between day open and day close.
					// Even after limiting hooStart and hooEnd to TOCalc's
					// range,
					// this scenario can still happen:
<span class="fc" id="L2531">					long hooStartForCurDay = midnightForCurDay.getTime() + dayOpenOffset * MINUTES_IN_MILLISECS;</span>
					// Scenario: TOCalc range start org day = 10:00AM; day HOO
					// start = 8:00AM. To guard
					// against this, limit dayHooStart to TOCalc's range start
<span class="fc bfc" id="L2535" title="All 2 branches covered.">					hooStartForCurDay = (hooStartForCurDay &gt; organizationDayStartForRange.getTime()) ? hooStartForCurDay : organizationDayStartForRange</span>
<span class="fc" id="L2536">							.getTime();</span>
					// limit dayHooStart to TOCalc's range end.
<span class="pc bpc" id="L2538" title="1 of 2 branches missed.">					hooStartForCurDay = (hooStartForCurDay &lt; organizationDayEndForRange.getTime()) ? hooStartForCurDay : organizationDayEndForRange</span>
<span class="pc" id="L2539">							.getTime();</span>

					// limit dayHooEnd to TOCalc's range end.
<span class="fc" id="L2542">					long hooEndForCurDay = midnightForCurDay.getTime() + dayCloseOffset * MINUTES_IN_MILLISECS;</span>
<span class="fc bfc" id="L2543" title="All 2 branches covered.">					hooEndForCurDay = (hooEndForCurDay &lt; organizationDayEndForRange.getTime()) ? hooEndForCurDay : organizationDayEndForRange.getTime();</span>
					// limit dayHooEnd to TOCalc's range start.
<span class="pc bpc" id="L2545" title="1 of 2 branches missed.">					hooEndForCurDay = (hooEndForCurDay &gt;= organizationDayStartForRange.getTime()) ? hooEndForCurDay : organizationDayStartForRange</span>
<span class="pc" id="L2546">							.getTime();</span>

<span class="fc" id="L2548">					workableTimeMap.setRange(hooStartForCurDay, hooEndForCurDay);</span>
				}
			}
<span class="fc" id="L2551">		}</span>
<span class="fc" id="L2552">	}</span>

	/**
	 *
	 * Calls to TimeMap.setRange() are passed trimmed dates if necessary to
	 * ensure that the passed range is within the map's time range.
	 *
	 */
	protected void clearUnavailabilitiesInMap() {
		// Now clear any periods of unavailability during the range
<span class="pc bpc" id="L2562" title="1 of 2 branches missed.">		for (Iterator itr = unavailabilityEvents.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L2563">			Event evt = (Event) itr.next();</span>

			// skip irrelevant ones
<span class="nc bnc" id="L2566" title="All 4 branches missed.">			if (evt.getStartTime().after(organizationDayEndForRange) || evt.getEndTime().before(organizationDayStartForRange)) {</span>
<span class="nc" id="L2567">				continue;</span>
			}

<span class="nc" id="L2570">			workableTimeMap.clearRange(Math.max(evt.getStartTime().getTime(), organizationDayStartForRange.getTime()),</span>
<span class="nc" id="L2571">					Math.min(evt.getEndTime().getTime(), organizationDayEndForRange.getTime()));</span>
<span class="nc" id="L2572">		}</span>
<span class="fc" id="L2573">	}</span>

	/**
	 * Sets the bits of the time map 'on' during hours of operation. Clears the
	 * bits during unavailabilities.
	 *
	 * Calls to TimeMap.setRange() are passed trimmed dates if necessary to
	 * ensure that the passed range is within the map's time range.
	 *
	 * see also {@link #workableTimeMap workableTimeMap}
	 */
	protected void setWorkableTimeMap() {
		// create time map
		// todo: org != null before this call is made
<span class="fc" id="L2587">		workableTimeMap = new TimeMap(TimeMap.ONE_MINUTE, organizationDayStartForRange, organizationDayEndForRange);</span>

		// clear the map first
<span class="fc" id="L2590">		workableTimeMap.clear();</span>

		// TODO: an exception thrown if the HOO.dayOffset is after org day
		// boundary offset. (Pavel reported when
		// testing reports. could run reports for west full timeAgent0 but not
		// for east fulltime agent0 or something
		// like that.
<span class="fc" id="L2597">		setOrgHOOAssignmentsInMap();</span>

<span class="fc" id="L2599">		clearUnavailabilitiesInMap();</span>

<span class="fc" id="L2601">	}</span>
	
	/**
	 * Initializes and sets shifts into both maps, published and referenced schedules
	 * unpaid shift event assignments.
	 *
	 */
	void initShiftAssignmentMaps(){
<span class="fc" id="L2609">		setShiftAssignmentsInMap();</span>
<span class="fc" id="L2610">		setReferenceShiftAssignmentInMap();</span>
<span class="fc" id="L2611">	}</span>

	/**
	 * Sets time map bits on during shift assignments. Clears the bits for
	 * unpaid shift event assignments.
	 *
	 * Calls to TimeMap.setRange() are passed trimmed dates if necessary to
	 * ensure that the passed range is within the map's time range.
	 *
	 * see also {@link #shiftAssignmentMap shiftAssignmentMap}
	 * @throws Exception 
	 */
	
	void setShiftAssignmentsInMap() {
		
		// Resolution used for the timeMap.
<span class="fc" id="L2627">		final long timeMapRes = TimeMap.ONE_MINUTE;</span>
<span class="fc" id="L2628">		shiftAssignmentMap = new TimeMap(timeMapRes,</span>
				organizationDayStartForRange, organizationDayEndForRange);

<span class="fc bfc" id="L2631" title="All 2 branches covered."> 		for( ShiftAssignment shiftAssignment : shiftAssignments){</span>
			// skip irrelevant ones
<span class="fc" id="L2633">			Date shiftAssnStart = shiftAssignment.getStartTime();</span>
<span class="fc" id="L2634">			Date shiftAssnEnd = shiftAssignment.getEndTime();</span>
			// QC52572 allocation off by .02 if previous day's shift ends on organization
			// day boundary
<span class="pc bpc" id="L2637" title="2 of 4 branches missed.">			if (shiftAssnStart.after(organizationDayEndForRange) || !shiftAssnEnd.after(organizationDayStartForRange)) {</span>
<span class="nc" id="L2638">				continue;</span>
			}

			// set the bits spanned by the shift assignment.
			// QC52572 allocation off by .02 if previous day's shift ends on organization
			// day boundary
<span class="fc" id="L2644">			shiftAssignmentMap.setRange(Math.max(shiftAssnStart.getTime(), organizationDayStartForRange.getTime()),</span>
<span class="fc" id="L2645">					Math.min(shiftAssnEnd.getTime(), organizationDayEndForRange.getTime()));</span>

			// Now clear any unpaid sub-events (like break during the shift,
			// lunch etc)
<span class="fc bfc" id="L2649" title="All 2 branches covered.">			for( Event shiftEvtAssn : shiftAssignment.getChildren()){</span>
				// skip irrelevant ones
<span class="fc" id="L2651">				Date shiftEvtAssnStart = shiftEvtAssn.getStartTime();</span>
<span class="fc" id="L2652">				Date shiftEvtAssnEnd = shiftEvtAssn.getEndTime();</span>
<span class="pc bpc" id="L2653" title="2 of 4 branches missed.">				if (shiftEvtAssnStart.after(organizationDayEndForRange) || shiftEvtAssnEnd.before(organizationDayStartForRange)) {</span>
<span class="nc" id="L2654">					continue;</span>
				}
				// only want paid sub events
<span class="pc bpc" id="L2657" title="1 of 2 branches missed.">				if (!shiftEvtAssn.getPaid()) {</span>
					// clear the bits which represent this range.
<span class="fc" id="L2659">					shiftAssignmentMap.clearRange(Math.max(shiftEvtAssnStart.getTime(), organizationDayStartForRange.getTime()),</span>
<span class="fc" id="L2660">							Math.min(shiftEvtAssnEnd.getTime(), organizationDayEndForRange.getTime()));</span>
				}
<span class="fc" id="L2662">			}</span>
<span class="fc" id="L2663">		}</span>
		
		
<span class="fc" id="L2666">	}</span>

	/*
	 *  Due to updates, which can set bulk shifts then process multiple requests
	 *  with a single calculator, we must set a separate map for reference shifts
	 *  and use them if the request needs them.
	 */
	void setReferenceShiftAssignmentInMap() {
		
<span class="fc" id="L2675">		this.usingReferenceSchedules = false;</span>
		
		// If the entire period is published, we do not need to load reference
		// schedules.
		// So get out early.
<span class="fc" id="L2680">		int publishedStatus = getPublishedPeriodStatus(</span>
				organizationDayStartForRange, organizationDayEndForRange);
<span class="pc bpc" id="L2682" title="1 of 2 branches missed.">		if (publishedStatus == PERIOD_PUBLISHED) {</span>
			
<span class="nc" id="L2684">			return;</span>
		}
		
<span class="fc" id="L2687">		referenceShiftAssignmentMap = new TimeMap(TimeMap.ONE_MINUTE,</span>
				organizationDayStartForRange, organizationDayEndForRange);

		try {

<span class="fc" id="L2692">			referenceShiftAssignments = getReferenceSchedules(</span>
					organizationDayStartForRange, organizationDayEndForRange);
			
<span class="pc bpc" id="L2695" title="2 of 4 branches missed.">			if (referenceShiftAssignments == null || referenceShiftAssignments.isEmpty()) {</span>
<span class="fc" id="L2696">				return;</span>
			}
			
			// Must update the last shift if it's earlier than the reference
			// shifts, otherwise we'll never see them
<span class="nc" id="L2701">			ShiftAssignment lastShift = referenceShiftAssignments</span>
<span class="nc" id="L2702">					.get(referenceShiftAssignments.size() - 1);</span>
<span class="nc bnc" id="L2703" title="All 2 branches missed.">			if (lastShift != null</span>
<span class="nc bnc" id="L2704" title="All 2 branches missed.">					&amp;&amp; lastShift.getStartTime().after(</span>
<span class="nc" id="L2705">							this.getLastShiftStartTime())) {</span>
<span class="nc" id="L2706">				setLastShift(lastShift);</span>
			}
			

<span class="nc" id="L2710">		} catch (Exception e) {</span>
<span class="nc" id="L2711">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L2712">		}</span>

<span class="nc bnc" id="L2714" title="All 2 branches missed.">		for( ShiftAssignment shiftAssignment : referenceShiftAssignments){</span>

			// skip irrelevant ones
<span class="nc" id="L2717">			Date shiftAssnStart = shiftAssignment.getStartTime();</span>
<span class="nc" id="L2718">			Date shiftAssnEnd = shiftAssignment.getEndTime();</span>
			
<span class="nc bnc" id="L2720" title="All 4 branches missed.">			if (shiftAssnStart.after(organizationDayEndForRange) || !shiftAssnEnd.after(organizationDayStartForRange)) {</span>
<span class="nc" id="L2721">				continue;</span>
			}

			// set the bits spanned by the shift assignment.
			
<span class="nc" id="L2726">			referenceShiftAssignmentMap.setRange(Math.max(shiftAssnStart.getTime(), organizationDayStartForRange.getTime()),</span>
<span class="nc" id="L2727">					Math.min(shiftAssnEnd.getTime(), organizationDayEndForRange.getTime()));</span>

			// Now clear any unpaid sub-events (like break during the shift,
			// lunch etc)
<span class="nc bnc" id="L2731" title="All 2 branches missed.">			for( Event shiftEvtAssn : shiftAssignment.getChildren()){</span>
				// skip irrelevant ones
<span class="nc" id="L2733">				Date shiftEvtAssnStart = shiftEvtAssn.getStartTime();</span>
<span class="nc" id="L2734">				Date shiftEvtAssnEnd = shiftEvtAssn.getEndTime();</span>
<span class="nc bnc" id="L2735" title="All 4 branches missed.">				if (shiftEvtAssnStart.after(organizationDayEndForRange) || shiftEvtAssnEnd.before(organizationDayStartForRange)) {</span>
<span class="nc" id="L2736">					continue;</span>
				}
				// Clear the unpaid ones
<span class="nc bnc" id="L2739" title="All 2 branches missed.">				if (!shiftEvtAssn.getPaid()) {</span>
					// clear the bits which represent this range.
<span class="nc" id="L2741">					referenceShiftAssignmentMap.clearRange(Math.max(shiftEvtAssnStart.getTime(), organizationDayStartForRange.getTime()),</span>
<span class="nc" id="L2742">							Math.min(shiftEvtAssnEnd.getTime(), organizationDayEndForRange.getTime()));</span>
				}
<span class="nc" id="L2744">			}</span>
<span class="nc" id="L2745">		}</span>

<span class="nc" id="L2747">	}</span>
	
	

	private List&lt;ShiftAssignment&gt; getReferenceSchedules(Date start, Date end) throws Exception {
		// Get the reference schedule from wfm-rm-backend
		// We need the bridge to do this
<span class="fc" id="L2754">		TimeOffHoursManagerBridge bridge = getTimeOffHoursManagerBridge();</span>
<span class="fc" id="L2755">		return bridge.getReferenceSchedules(this.organization, this.empId,</span>
				start, end);
	}

	/**
	 * Sets the bits of the time map 'on' during 'paid' holidays (unpaid
	 * holidays are skipped). Trims the set bits using the 'workable time map'.
	 *
	 * Calls to TimeMap.setRange() are passed trimmed dates if necessary to
	 * ensure that the passed range is within the map's time range.
	 *
	 * see also {@link #holidayAssignmentMap holidayAssignmentMap}
	 *
	 */
	protected void setHolidaysInMap() {
<span class="fc" id="L2770">		holidayAssignmentMap = new TimeMap(TimeMap.ONE_MINUTE, organizationDayStartForRange, organizationDayEndForRange);</span>

		// Now set paid holidays during the range
<span class="pc bpc" id="L2773" title="1 of 2 branches missed.">		for (Iterator hols = holidays.iterator(); hols.hasNext();) {</span>
<span class="nc" id="L2774">			Holiday hd = (Holiday) hols.next();</span>

			// only consider Paid Holidays
<span class="nc bnc" id="L2777" title="All 2 branches missed.">			if (hd.isPaidHoliday()) {</span>
				// Make date objects in the organization's time zone
<span class="nc" id="L2779">				TimeZone orgTZ = organization.getTimeZone();</span>
<span class="nc" id="L2780">				Date hdStart = hd.getStartDate().getTime(orgTZ);</span>
<span class="nc" id="L2781">				Date hdEnd = hd.getEndDate().getTime(orgTZ);</span>

				// QA 74100 - in TO Calendar, scheduled time off hours are
				// incorrect for many different days
				// Check to see if end date has format hh:59:00 then add 1
				// minute on it
				// to prevent TimeMap.adjustTimeUsingResolution subtract by 1
				// milisecond this cause end time is hh:58:00
<span class="nc" id="L2789">				Calendar calHdEnd = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L2790">				calHdEnd.setTime(hdEnd);</span>
<span class="nc bnc" id="L2791" title="All 6 branches missed.">				if (calHdEnd.get(Calendar.MINUTE) == 59 &amp;&amp; calHdEnd.get(Calendar.SECOND) == 0 &amp;&amp; calHdEnd.get(Calendar.MILLISECOND) == 0) {</span>
<span class="nc" id="L2792">					calHdEnd.add(Calendar.MINUTE, 1);</span>
<span class="nc" id="L2793">					hdEnd = calHdEnd.getTime();</span>
				}
				// skip holidays that are out of the range of interest
<span class="nc bnc" id="L2796" title="All 4 branches missed.">				if (hdStart.after(organizationDayEndForRange) || hdEnd.before(organizationDayStartForRange)) {</span>
<span class="nc" id="L2797">					continue;</span>
				}

				// set the bits during the holiday
<span class="nc" id="L2801">				holidayAssignmentMap.setRange(Math.max(hdStart.getTime(), organizationDayStartForRange.getTime()),</span>
<span class="nc" id="L2802">						Math.min(hdEnd.getTime(), organizationDayEndForRange.getTime()));</span>
			}

<span class="nc" id="L2805">		}</span>

		// Trim holiday map bits using the HOO map.
<span class="fc" id="L2808">		holidayAssignmentMap.and(workableTimeMap);</span>
<span class="fc" id="L2809">	}</span>

	@Override
	public String toString() {
<span class="fc" id="L2813">		StringBuffer strbuf = new StringBuffer();</span>

<span class="fc" id="L2815">		strbuf.append(&quot;*** empId *** = &quot;).append(empId).append('\n');</span>
<span class="fc" id="L2816">		strbuf.append(&quot;*** org *** = &quot;).append(organization).append('\n');</span>
<span class="fc" id="L2817">		strbuf.append(&quot;*** allotmentMap *** = &quot;).append(TOCalcUtil.dumpMap(allotmentMap));</span>
<span class="fc" id="L2818">		strbuf.append(&quot;*** lastShiftAssignment *** = &quot; + lastShiftAssignment).append('\n');</span>
<span class="fc" id="L2819">		strbuf.append(&quot;*** cutOffOrgDayStartTime *** = &quot;).append(cutOffOrgDayStartTime).append('\n');</span>
<span class="fc" id="L2820">		strbuf.append(&quot;*** cutOffOrgDayEndTime *** = &quot;).append(cutOffOrgDayEndTime).append('\n');</span>
<span class="fc" id="L2821">		strbuf.append(&quot;*** cutOffOrgWeekStartTime *** = &quot;).append(cutOffOrgWeekStartTime).append('\n');</span>
<span class="fc" id="L2822">		strbuf.append(&quot;*** cutOffOrgWeekEndTime *** = &quot;).append(cutOffOrgWeekEndTime).append('\n');</span>
<span class="fc" id="L2823">		strbuf.append(&quot;*** timeRange *** = &quot; + timeRange.getStartDate() + &quot; to &quot; + timeRange.getEndDate()).append('\n');</span>
<span class="fc" id="L2824">		strbuf.append(&quot;*** organizationDayStartForRange *** = &quot;).append(organizationDayStartForRange).append('\n');</span>
<span class="fc" id="L2825">		strbuf.append(&quot;*** organizationDayEndForRange *** = &quot;).append(organizationDayEndForRange).append('\n');</span>
<span class="fc" id="L2826">		strbuf.append(&quot;*** unavailabilityEvents *** = &quot; + CollectionUtil.dumpCollection(unavailabilityEvents));</span>
<span class="fc" id="L2827">		strbuf.append(&quot;*** orgHoursOfOperationAssignments *** = &quot; + CollectionUtil.dumpCollection(orgHoursOfOperationAssignments));</span>
<span class="fc" id="L2828">		strbuf.append(&quot;*** workableTimeMap *** = &quot; + workableTimeMap);</span>
<span class="fc" id="L2829">		strbuf.append(&quot;*** holidays *** = &quot;).append(CollectionUtil.dumpCollection(holidays));</span>
<span class="fc" id="L2830">		strbuf.append(&quot;*** holidayAssignmentMap *** = &quot;).append(holidayAssignmentMap);</span>
<span class="fc" id="L2831">		strbuf.append(&quot;*** shiftAssignments *** = &quot;).append(CollectionUtil.dumpCollection(shiftAssignments));</span>
<span class="fc" id="L2832">		strbuf.append(&quot;*** shiftAssignmentMap *** = &quot;).append(shiftAssignmentMap);</span>
<span class="fc" id="L2833">		return strbuf.toString();</span>
	}

	private EmployeeTimeOffDefault getDefaultActivityAlloc(ID empID, ID activityID) {
<span class="fc" id="L2837">		EmployeeTimeOffDefault empTODef = new EmployeeTimeOffDefault();</span>

<span class="fc" id="L2839">		empTODef.setActivityID(activityID);</span>
<span class="fc" id="L2840">		empTODef.setEmployeeID(empID);</span>
<span class="fc" id="L2841">		empTODef.setHoursPerDay(0.0);</span>
<span class="fc" id="L2842">		empTODef.setHoursPerWeek(0.0);</span>

<span class="fc" id="L2844">		LOG.debug(&quot;Using default TO allocations (0.0/0.0) for employee ID &quot; + empID + &quot; with activity ID &quot; + activityID);</span>

<span class="fc" id="L2846">		return empTODef;</span>
	}

	/**
	 * @param sam
	 * @return
	 * @throws BbmEJBCreateException
	 */
	private ScheduleAccessManager getScheduleAccessManager() throws BbmEJBCreateException {
<span class="pc bpc" id="L2855" title="1 of 2 branches missed.">		if(scheduleAccessManager == null){</span>
<span class="fc" id="L2856">			scheduleAccessManager = WfmManagerFactory.getScheduleAccessManager();</span>
		}
<span class="fc" id="L2858">		return scheduleAccessManager;</span>
	}

	public static String dumpArray(int[] arr) {
<span class="pc bpc" id="L2862" title="1 of 2 branches missed.">		if (arr == null) {</span>
<span class="nc" id="L2863">			return &quot;null&quot;;</span>
		}

<span class="fc" id="L2866">		StringBuffer buf = new StringBuffer();</span>
<span class="fc" id="L2867">		buf.append(&quot;arr.length = &quot; + arr.length + ';');</span>
<span class="fc bfc" id="L2868" title="All 2 branches covered.">		for (int i = 0; i &lt; arr.length; i++) {</span>
<span class="fc" id="L2869">			buf.append(arr[i] + &quot;,&quot;);</span>
		}

<span class="fc" id="L2872">		return buf.toString();</span>
	}

	/**
	 * @return the isInUnpublishededGap
	 */
	public boolean getIsInUnpublishededGap() {
<span class="nc" id="L2879">		return isInUnpublishededGap;</span>
	}

	/**
	 * @param setIsInUnpublishededGap the isInUnpublishededGap to set
	 */
	public void setIsInUnpublishededGap(boolean aIsInUnpublishededGap) {
<span class="nc" id="L2886">		this.isInUnpublishededGap = aIsInUnpublishededGap;</span>
<span class="nc" id="L2887">	}</span>

	/*
	 * getPublishedPeriodStatus
	 * For the requested date range, is the period published?
	 */
	protected int getPublishedPeriodStatus (Date startDateTime, Date endDateTime) {

		//Will load the range of periods, if not already loaded
<span class="fc" id="L2896">		Collection&lt;PublishingPeriod&gt; published = getPublishedPeriods();</span>

<span class="pc bpc" id="L2898" title="1 of 2 branches missed.">		if (published == null) {</span>
<span class="nc" id="L2899">			return PERIOD_PUBLISHED_UNKNOWN;</span>
		}

<span class="fc bfc" id="L2902" title="All 2 branches covered.">		if (published.isEmpty()){</span>
<span class="fc" id="L2903">			return PERIOD_UNPUBLISHED;</span>
		}

<span class="fc" id="L2906">		TimeRange range = new TimeRange(startDateTime, endDateTime);</span>

<span class="fc bfc" id="L2908" title="All 2 branches covered.">		for (Iterator&lt;PublishingPeriod&gt; iter = published.iterator(); iter.hasNext();) {</span>
<span class="fc" id="L2909">			PublishingPeriod publishingPeriod = iter.next();</span>
<span class="fc" id="L2910">			TimeRange publishedRange = new TimeRange(publishingPeriod.getStartTime(), publishingPeriod.getEndTime());</span>
<span class="pc bpc" id="L2911" title="1 of 4 branches missed.">			if (!publishingPeriod.isPartialPublish() &amp;&amp; range.isInside(publishedRange)) {</span>
<span class="nc" id="L2912">				return PERIOD_PUBLISHED;</span>
			}
<span class="fc" id="L2914">		}</span>

<span class="fc" id="L2916">		return PERIOD_UNPUBLISHED;</span>
	}
	/*
	 * isPeriodPublishedAtAll
	 * For the requested date range, is any day published?
	 * Disregards partially published periods
	 */
	protected boolean isPeriodPublishedAtAll(Date startDateTime, Date endDateTime) {

		//Will load the range of periods, if not already loaded
<span class="nc" id="L2926">		Collection&lt;PublishingPeriod&gt; published = getPublishedPeriods();</span>

<span class="nc bnc" id="L2928" title="All 2 branches missed.">		if (published == null) {</span>
<span class="nc" id="L2929">			return false;</span>
		}

<span class="nc bnc" id="L2932" title="All 2 branches missed.">		if (published.isEmpty()){</span>
<span class="nc" id="L2933">			return false;</span>
		}

<span class="nc" id="L2936">		TimeRange range = new TimeRange(startDateTime, endDateTime);</span>

<span class="nc bnc" id="L2938" title="All 2 branches missed.">		for (Iterator&lt;PublishingPeriod&gt; iter = published.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L2939">			PublishingPeriod publishingPeriod = iter.next();</span>
<span class="nc" id="L2940">			TimeRange publishedRange = new TimeRange(publishingPeriod.getStartTime(), publishingPeriod.getEndTime());</span>
<span class="nc bnc" id="L2941" title="All 6 branches missed.">			if(!publishingPeriod.isPartialPublish() &amp;&amp; !publishedRange.isBefore(range) &amp;&amp; !publishedRange.isAfter(range) ) {</span>
<span class="nc" id="L2942">				return true;</span>
			}
			
<span class="nc" id="L2945">		}</span>

<span class="nc" id="L2947">		return false;</span>
	}


	/*
	 * loadPublishedPeriods
	 * Will query ScheduleAccessManager for the published periods for the range, if not already loaded
	 */
	protected Collection&lt;PublishingPeriod&gt; getPublishedPeriods() {

<span class="pc bpc" id="L2957" title="1 of 2 branches missed.">		if (this.publishedPeriods != null){</span>
<span class="nc" id="L2958">			return this.publishedPeriods;</span>
		}

		try {
<span class="fc" id="L2962">			ScheduleAccessManager sam = getScheduleAccessManager();</span>
<span class="fc" id="L2963">			TimeRange range = getRange();</span>
<span class="fc" id="L2964">			List&lt;Collection&lt;PublishingPeriod&gt;&gt; listOfPublishedPeriods = sam.getPublishedPeriods(Collections.singleton(this.getEmpId()),</span>
<span class="fc" id="L2965">					range.getStartDate(), range.getEndDate());</span>

<span class="fc" id="L2967">			this.publishedPeriods = (Collection&lt;PublishingPeriod&gt;) listOfPublishedPeriods.get(0);</span>
<span class="fc bfc" id="L2968" title="All 2 branches covered.">			if (this.publishedPeriods == null) {</span>
<span class="fc" id="L2969">				this.publishedPeriods = Collections.emptyList();</span>
			}
<span class="nc" id="L2971">		} catch (Exception e) {</span>
<span class="nc" id="L2972">			LOG.error(e.getMessage(), e);</span>
<span class="fc" id="L2973">		}</span>

<span class="fc" id="L2975">		return this.publishedPeriods;</span>
	}

	/**
	 * @return the dayDefaultMins
	 */
	private int getDayDefaultMins() {
<span class="fc" id="L2982">		return dayDefaultMins;</span>
	}

	/**
	 * @param dayDefaultMins the dayDefaultMins to set
	 * 
	 */
	public void setDayDefaultMins(int dayDefaultMins) {
<span class="fc" id="L2990">		this.dayDefaultMins = dayDefaultMins;</span>
<span class="fc" id="L2991">	}</span>
	
	public TimeMap getShiftAssignmentMap(){
<span class="fc" id="L2994">		return this.shiftAssignmentMap;</span>
	}

	/**
	 * @return the periodFlag
	 */
	public int getPeriodFlag() {
<span class="fc" id="L3001">		return periodFlag;</span>
	}

	/**
	 * @param periodFlag the periodFlag to set
	 */
	private void setPeriodFlag(int aPeriodFlag) {
<span class="fc" id="L3008">		this.periodFlag = aPeriodFlag;</span>
<span class="fc" id="L3009">	}</span>

	public ListHoursAndSource getNewListHoursAndSource(int size) {
<span class="nc" id="L3012">		return new ListHoursAndSource(size);</span>
	}
	  

	private TimeOffHoursManagerBridge getTimeOffHoursManagerBridge() throws Exception
	{
<span class="pc bpc" id="L3018" title="1 of 2 branches missed.">		if (timeOffHoursManagerBridge == null)</span>
		{
<span class="fc" id="L3020">		    String gcrType = &quot;TIMEOFFHOURSMANAGER_BRIDGE&quot;;</span>
<span class="fc" id="L3021">		    GCRManager gcrManager  = CoreManagerFactory.getGCRManagerRemote(false);</span>
<span class="fc" id="L3022">		    Collection entries = gcrManager.getGCREntryOfType(gcrType);</span>
<span class="fc" id="L3023">		    Class clazz = Class.forName(((GCREntry) (entries.iterator().next())).getHook());</span>
<span class="fc" id="L3024">		    timeOffHoursManagerBridge = (TimeOffHoursManagerBridge) clazz.newInstance();</span>
		}
<span class="fc" id="L3026">	    return timeOffHoursManagerBridge;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>