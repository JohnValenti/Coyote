<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleMessageSchedulerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.ejb.facade.scheduling</a> &gt; <span class="el_source">ScheduleMessageSchedulerEJB.java</span></div><h1>ScheduleMessageSchedulerEJB.java</h1><pre class="source lang-java linenums">package com.verint.ejb.facade.scheduling;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingRequest;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingState;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingWarning;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.bluepumpkin.ejb.facade.FacadeManagerFactory;
import com.bluepumpkin.ejb.facade.corbafacade.ejb.FacadeCorbaFacadeManager;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage;
import com.verint.ejb.bbm.schedule.model.ScheduleMessage.SchedulingAction;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParameters;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersDAO;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageParametersFieldInfo;
import com.verint.ejb.bbm.schedule.model.ScheduleMessageRequestMapping;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequest;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestDAO;
import com.verint.ejb.bbm.schedule.model.WSAutoScheduleRequestFieldInfo;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.ejb.core.base.CoreFinderException;
import com.witness.ejb.core.security.UserManager;
import com.witness.ejb.core.security.model.User;

<span class="fc" id="L52">public class ScheduleMessageSchedulerEJB extends SessionEJBBase {</span>
<span class="fc" id="L53">	private static final Object _CREATE_LOCK = new Object();</span>

	private static final int REQUEST_CONTINUE = SchedulingRequest.CONTINUE_SCHEDULE;
	public static final int DEFAULT_NO_OF_CPU = 5;

	// progress percentage for a completed job
	private static final int COMPLETED_PERCENTAGE_PROGRESS = ScheduleMessageSchedulerHelper.COMPLETED_PERCENTAGE_PROGRESS;
	private static final int DAYS_IN_WEEK = 7;
	private static final int DAYS_IN_THREE_WEEKS = 3 * DAYS_IN_WEEK;

	private static final int MAX_OLD_SCHEDULE_STATUS_MILLIS = 1000 * 60 * 5;
	private static final int DEFAULT_SCHEDULING_ERROR_RETRY_COUNT = 3;
	// if can not schedule after 2 retries, we give up.
	private static final int DEFAULT_SCHEDULING_RETRY_COUNT = 2;
	// 30 seconds
	private static final long DEFAULT_SCHEDULING_RETRY_INTERVAL = 30000;
	// 15 minutes
	private static final int DEFAULT_GIVE_UP_TIME = 900000;

	private static final String COULD_NOT_SCHEDULE_DUE_TO_FSSERVER_ERROR =
			&quot;This could not be scheduled because of the integration server error!&quot;;

<span class="fc" id="L75">	private static Category m_cat = Log.initCategory(ScheduleMessageSchedulerEJB.class.getName());</span>

<span class="fc" id="L77">	private boolean isWhatIf = false;</span>

	private FacadeCorbaFacadeManager facadeCorbaFacadeManager;

	private CampaignManager campaignManager;

	private DBConfigManager dbConfigManager;

	private UserManager userManager;

	private ScheduleMessageSchedulerHelper schedulerHelper;

	{
<span class="fc" id="L90">		super.init(ScheduleMessageSchedulerEJB.class.getName());</span>
<span class="fc" id="L91">	}</span>

	/**
	 * Perform one-time initialization of this EJB instance
	 */
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L99">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L100">			Boolean wif = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">			if (wif != null) {</span>
<span class="fc" id="L102">				isWhatIf = wif.booleanValue();</span>
			}
<span class="fc" id="L104">			facadeCorbaFacadeManager = FacadeManagerFactory.getFacadeCorbaFacadeManager();</span>
<span class="fc" id="L105">			campaignManager = WfmManagerFactory.getCampaignManager(isWhatIf);</span>
<span class="fc" id="L106">			dbConfigManager = BbmManagerFactory.getDBConfigManager(isWhatIf);</span>
<span class="fc" id="L107">			userManager = CoreManagerFactory.getUserManager(isWhatIf);</span>
<span class="fc" id="L108">			schedulerHelper = new ScheduleMessageSchedulerHelper();</span>

<span class="nc" id="L110">		} catch (Exception e) {</span>
<span class="nc" id="L111">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L112">		}</span>
<span class="fc" id="L113">	}</span>

	protected Category getCategory() {
<span class="fc" id="L116">		return m_cat;</span>
	}

	public ID createMessage(ScheduleRequestsMessage message) throws BbmCreateException {
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">		if (message == null) {</span>
<span class="nc" id="L121">			throw new IllegalArgumentException(&quot;The message to be persisted in empty&quot;);</span>
		}

<span class="fc" id="L124">		ID created = null;</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">		if (schedulerHelper.validateSecondaryParamsAndUpdateInvalidRequests(message)) {</span>
			// insert the scheduling parameters
<span class="fc" id="L127">			created = createDBMessage(message);</span>
			// insert secondary scheduling parameters
<span class="fc" id="L129">			schedulerHelper.createSecondaryParameters(message, created);</span>
			// insert the mappings between message to requests
<span class="fc" id="L131">			schedulerHelper.createRequestMappings(message, created);</span>
		}
<span class="fc" id="L133">		return created;</span>
	}

	/**
	 * Attempts to schedule the Scheduling messages in the ScheduleMessage
	 * table. The messages will be scheduled in the order they have been last
	 * updated. This will ensure that all messages are being processed as
	 * opposed to just processing messages in the order in which they arrive.
	 */
	public void scheduleReadyRequests() {
<span class="fc" id="L143">		methodStart(&quot;scheduleReadyRequests&quot;);</span>
		// get the capacity that we can schedule now
		// get all the messages and try to consume one by one
		// get the request IDs for a message
		try {
<span class="fc" id="L148">			int availableServers = checkServersAndUpdateStatusForNonAvailability();</span>
<span class="fc" id="L149">			Collection&lt;ScheduleMessage&gt; allMessages = schedulerHelper.getAllMessages();</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">			if (availableServers &lt;= 0) {</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">				if (!allMessages.isEmpty()) {</span>
<span class="fc" id="L152">					m_cat.error(&quot;Scheduling not done due to the non-availability of FS server to schedule.&quot;);</span>
				}
<span class="fc" id="L154">				return;</span>
			}
<span class="fc" id="L156">			scheduleMessages(allMessages, availableServers);</span>
<span class="nc" id="L157">		} catch (BbmFinderException e1) {</span>
<span class="nc" id="L158">			m_cat.error(&quot;Could not get Request messages&quot;, e1);</span>
<span class="nc" id="L159">		} catch (RemoteException re) {</span>
<span class="nc" id="L160">			m_cat.error(&quot;Error scheduling the requests. They will be re-tried latter&quot;, re);</span>
<span class="nc" id="L161">		} catch (MultiUserException e) {</span>
<span class="nc" id="L162">			m_cat.error(&quot;Error updating the request/message&quot;, e);</span>
<span class="nc" id="L163">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L164">			m_cat.error(&quot;Error updating the request&quot;, e);</span>
<span class="nc" id="L165">		} catch (Exception any) {</span>
<span class="nc" id="L166">			m_cat.error(&quot;Error scheduling the requests. They will be re-tried latter&quot;, any);</span>
		} finally {
<span class="pc" id="L168">			methodFinish();</span>
<span class="pc" id="L169">		}</span>
<span class="fc" id="L170">	}</span>

	/**
	 * Copies the scheduling state for the in-progress requests and clears the
	 * completed requests from state table, ScheduleMEssageRequestMapping tables
	 * and ScheduleMessage tables.
	 */
	public void updateStatusAndClearCompletedRequests() {
<span class="fc" id="L178">		methodStart(&quot;updateStatusAndClearCompletedRequests&quot;);</span>
		// clear schedule state from spShedStatus tables and update the
		// WSAutoScheduleRequest tables
		// get all the requests with status 'P'
		try {
<span class="fc" id="L183">			List&lt;WSAutoScheduleRequest&gt; requests = schedulerHelper.getRequestsByStatus(null,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS);

<span class="pc bpc" id="L186" title="1 of 2 branches missed.">			if (!requests.isEmpty()) {</span>
<span class="nc" id="L187">				List&lt;WSAutoScheduleRequest&gt; requestsToBeUpdated = updateStatus(requests);</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">				if (!requestsToBeUpdated.isEmpty()) {</span>
<span class="nc" id="L189">					schedulerHelper.updateRequests(requestsToBeUpdated);</span>
				}
			}
			// clear message, mappings and parameters tables if there are
			// no more requests to process
<span class="fc" id="L194">			schedulerHelper.clearCompletedMessages();</span>

<span class="nc" id="L196">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L197">			m_cat.error(&quot;Exception while getting/clearing scheduling status from Campaign Manager &quot;, e);</span>
<span class="nc" id="L198">		} catch (RemoteException e) {</span>
<span class="nc" id="L199">			m_cat.error(&quot;Exception while clearing the schedule state&quot;, e);</span>
<span class="nc" id="L200">		} catch (JdmoException e) {</span>
<span class="nc" id="L201">			m_cat.error(&quot;Exception while updating scheduling status &quot;, e);</span>
<span class="nc" id="L202">		} catch (MultiUserException e) {</span>
<span class="nc" id="L203">			m_cat.error(&quot;Error while updating the scheduling status to the requests&quot;, e);</span>
<span class="nc" id="L204">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L205">			m_cat.error(&quot;Error while updating the scheduling status to the requests&quot;, e);</span>
<span class="nc" id="L206">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L207">			m_cat.error(&quot;Could not clear completed messages&quot;, e);</span>
		} finally {
<span class="pc" id="L209">			methodFinish();</span>
<span class="pc" id="L210">		}</span>
<span class="fc" id="L211">	}</span>

	/**
	 * Sets the older requests created when the message was not persisted to DB
	 * as these cannot be processed any longer
	 */
	public void clearOrphanRequests() {
<span class="fc" id="L218">		methodStart(&quot;clearOrphanRequests&quot;);</span>
		// what if these messages get hit before the message is created?
		// Do a timecheck ...clean only those that are more than a week old
<span class="fc" id="L221">		WSAutoScheduleRequestDAO dao = new WSAutoScheduleRequestDAO();</span>
<span class="fc" id="L222">		Calendar cal = Calendar.getInstance();</span>
<span class="fc" id="L223">		cal.add(Calendar.DAY_OF_MONTH, -DAYS_IN_WEEK);</span>
		try {
			// get the requests that are not connected
<span class="fc" id="L226">			String[] statuses = { WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS };
<span class="fc" id="L228">			List&lt;ID&gt; requestIDs = dao.getRequestIDsNotLinkedToMessageByStatus(statuses, cal.getTime());</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">			if (!requestIDs.isEmpty()) {</span>
<span class="nc" id="L230">				m_cat.warn(&quot;Cleared &quot; + requestIDs.size() + &quot; requests not connected to schedule message.&quot;);</span>
<span class="nc" id="L231">				dao.updateScheduleStatus(requestIDs, null, WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,</span>
						&quot;Could not process requests as the schedule message could not be located.&quot;);
			}
<span class="nc" id="L234">		} catch (Exception any) {</span>
<span class="nc" id="L235">			m_cat.error(&quot;Error purging new and in-process requests not connected to schedule message.&quot;, any);</span>
		} finally {
<span class="pc" id="L237">			dao.cleanUp();</span>
<span class="pc" id="L238">			methodFinish();</span>
<span class="pc" id="L239">		}</span>
<span class="fc" id="L240">	}</span>


	/**
	 * Schedules messages if there is a free server to schedule.
	 */
	private void scheduleMessages(Collection&lt;ScheduleMessage&gt; allMessages, int availableServers)
			throws BbmFinderException, MultiUserException, BbmUpdateException, RemoteException {
<span class="pc bpc" id="L248" title="1 of 2 branches missed.">		for (ScheduleMessage message : allMessages) {</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">			if (doesFreeServerExist(availableServers)) {</span>
<span class="nc" id="L250">				scheduleMessage(message, availableServers);</span>
			} else {
				// cannot schedule any more as there is no free server
				break;
			}
<span class="nc" id="L255">		}</span>
<span class="fc" id="L256">	}</span>

	/**
	 * Schedules the requests of a message (as many as possible) based on the
	 * availability of the server to schedule.
	 */
	private boolean scheduleMessage(ScheduleMessage message, int availableServers)
			throws MultiUserException, BbmUpdateException, RemoteException {

<span class="nc" id="L265">		boolean messageScheduled = false;</span>
<span class="nc" id="L266">		Collection&lt;ScheduleMessageRequestMapping&gt; mappings = schedulerHelper.getMappings(message.getID());</span>
<span class="nc bnc" id="L267" title="All 4 branches missed.">		if (mappings == null || mappings.isEmpty()) {</span>
<span class="nc" id="L268">			return false;</span>
		}
		List&lt;WSAutoScheduleRequest&gt; requests;
		try {
<span class="nc" id="L272">			requests = schedulerHelper.getRequestsByStatus(schedulerHelper.getRequestIDs(mappings),</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);
<span class="nc" id="L274">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L275">			m_cat.error(&quot;Could not get requests for message &quot; + message.getID(), e);</span>
<span class="nc" id="L276">			return false;</span>
<span class="nc" id="L277">		}</span>
<span class="nc" id="L278">		messageScheduled = scheduleRequests(requests, message, availableServers);</span>

<span class="nc bnc" id="L280" title="All 2 branches missed.">		if (messageScheduled) {</span>
			// update the message
			// this will help in all messages being treated fairly in a
			// round robin rather than do messages sequentially
<span class="nc" id="L284">			schedulerHelper.updateMessage(message);</span>
		}
<span class="nc" id="L286">		return messageScheduled;</span>
	}

	/**
	 * Schedules the requests (as many as possible) based on the availability of
	 * the server to schedule. Returns true if atleast one request is scheduled.
	 *
	 * @throws BbmUpdateException
	 * @throws MultiUserException
	 */
	private boolean scheduleRequests(List&lt;WSAutoScheduleRequest&gt; requests, ScheduleMessage message,
			int availableServers) throws RemoteException, MultiUserException, BbmUpdateException {
<span class="nc" id="L298">		boolean requestScheduled = false;</span>
<span class="nc bnc" id="L299" title="All 2 branches missed.">		for (WSAutoScheduleRequest request : requests) {</span>
			// check for retry count
<span class="nc bnc" id="L301" title="All 2 branches missed.">			if (checkForErrorsOrMaxRetriesAndUpdate(request)</span>
<span class="nc bnc" id="L302" title="All 4 branches missed.">					|| (!message.isOverrideSchedules() &amp;&amp; schedulerHelper.checkIfAlreadyScheduledAndUpdate(request))) {</span>
<span class="nc" id="L303">				continue;</span>
			}
<span class="nc bnc" id="L305" title="All 2 branches missed.">			if (!doesFreeServerExist(availableServers)) {</span>
				// when there is no free server, we just return
				// there is no point to go through the whole list.
<span class="nc" id="L308">				return requestScheduled;</span>
			}
<span class="nc bnc" id="L310" title="All 2 branches missed.">			if (canScheduleNow(request.getSPID(), request.getMode(), message.isScheduleInOrder())</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">					&amp;&amp; scheduleRequest(request, message)) {</span>
<span class="nc" id="L312">				requestScheduled = true;</span>
			}
<span class="nc" id="L314">		}</span>
<span class="nc" id="L315">		return requestScheduled;</span>
	}

	/**
	 * Checks if the request has exceeded the max-retries/ max number of errors
	 * and it has exceeded, updated the request as error
	 *
	 * @param request
	 * @return true if the request has exceeded max-retries for scheduling of
	 *         (in case the sp is not picked up by FS) max-retries after
	 *         integration server errors.
	 */
	private boolean checkForErrorsOrMaxRetriesAndUpdate(WSAutoScheduleRequest request) {
<span class="nc" id="L328">		boolean hasErrorOrMaxRetries = false;</span>
<span class="nc" id="L329">		String message = request.getFormattedFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE);</span>
<span class="nc" id="L330">		String newErrorMessage = null;</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">		if (request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT) &gt; getSchedulingRetryCount()) {</span>
<span class="nc" id="L332">			hasErrorOrMaxRetries = true;</span>
<span class="nc" id="L333">			newErrorMessage = &quot;This could not be scheduled after &quot;</span>
<span class="nc" id="L334">					+ request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT)</span>
					+ &quot; retries. This will not be scheduled.&quot;;
<span class="nc" id="L336">		} else if (request</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">				.getFieldValueInt(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT) &gt; getSchedulingErrorRetryCount()) {</span>
<span class="nc" id="L338">			hasErrorOrMaxRetries = true;</span>
<span class="nc" id="L339">			newErrorMessage = COULD_NOT_SCHEDULE_DUE_TO_FSSERVER_ERROR;</span>
		}

<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (hasErrorOrMaxRetries) {</span>
			try {
<span class="nc bnc" id="L344" title="All 2 branches missed.">				schedulerHelper.updateScheduleStatusForRequest(request.getID(), WSAutoScheduleRequest.SCHEDULE_STATUS_NEW,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,
						(message != null) ? message + &quot; &quot; + newErrorMessage : newErrorMessage);
<span class="nc" id="L347">			} catch (Exception e) {</span>
<span class="nc" id="L348">				m_cat.error(&quot;Error updating the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L349">						+ &quot; for the scheduling period &quot; + request.getSPID(), e);</span>
<span class="nc" id="L350">			}</span>
		}
<span class="nc" id="L352">		return hasErrorOrMaxRetries;</span>
	}

	/**
	 * Returns true if the scheduling is successfully initiated for the request
	 *
	 * @throws BbmUpdateException
	 * @throws MultiUserException
	 */
	private boolean scheduleRequest(WSAutoScheduleRequest request, ScheduleMessage message)
			throws RemoteException, MultiUserException, BbmUpdateException {
<span class="nc" id="L363">		boolean requestScheduled = false;</span>
<span class="nc" id="L364">		int spID = request.getSPID();</span>
		// if able to trigger the auto scheduling for this,
		// update the status to 'P'

		// QC-124839 get the user from the request
<span class="nc" id="L369">		String user = request.getFormattedFieldValue(WSAutoScheduleRequestFieldInfo.MODIFIEDBY);</span>
<span class="nc bnc" id="L370" title="All 2 branches missed.">		if (user == null) {</span>
			// user the super user
<span class="nc" id="L372">			user = getSuperUser();</span>
		}
<span class="nc" id="L374">		setSecondarySchedulingParameters(message.getID(), ID.fromInt(spID));</span>

<span class="nc" id="L376">		int status = facadeCorbaFacadeManager.recalcScheduling(user, getUserPassword(user, message.getUserSeal()),</span>
<span class="nc" id="L377">				message.isWhatIfMode(), message.getSchedulingAction().getActionID(), ID.fromInt(request.getSPID()),</span>
<span class="nc" id="L378">				message.isEnableLQF(), message.isRecalcSubCampaigns(), schedulerHelper.extractParamters(message));</span>
		// if status is an invalid code (like absence of
		// adapter, we need to re-attempt to schedule
<span class="nc bnc" id="L381" title="All 2 branches missed.">		if (status == 1) {</span>
			// typical success scenario
<span class="nc" id="L383">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS);
<span class="nc" id="L385">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT, 0);</span>
			// Debug log message to indicate that the given
			// sp
			// were processed
<span class="nc" id="L389">			m_cat.debug(&quot;Scheduling Triggered for the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L390">					+ &quot; for the scheduling period &quot; + request.getSPID());</span>
<span class="nc" id="L391">			requestScheduled = true;</span>
		} else {
			// remove the set scheduling parameters?
			// need to add to the unscheduled
<span class="nc" id="L395">			m_cat.warn(&quot;An attempt to schedule the Scheduling Request of ID &quot; + request.getID()</span>
<span class="nc" id="L396">					+ &quot; for the scheduling period &quot; + request.getSPID()</span>
					+ &quot; failed. This will be reattempted at a later time. The error code from the Corba Facade Manager is &quot;
					+ status + &quot;.&quot;);
<span class="nc" id="L399">			int oldCount = request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT);</span>
<span class="nc" id="L400">			oldCount++;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">			if (oldCount &gt;= getSchedulingErrorRetryCount()) {</span>
<span class="nc" id="L402">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
			}

<span class="nc bnc" id="L406" title="All 2 branches missed.">			if (status == 3) {</span>
<span class="nc" id="L407">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;There was an error connecting to the Integration Server.  Please verify that the integration server is running.&quot;);
			}
<span class="nc bnc" id="L410" title="All 2 branches missed.">			if (status == 4) {</span>
<span class="nc" id="L411">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;There was an error with the configuration of the Integration Server.&quot;);
			}
<span class="nc" id="L414">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.ERRORRETRYCOUNT, oldCount);</span>
		}
<span class="nc" id="L416">		schedulerHelper.updateRequest(request);</span>
<span class="nc" id="L417">		return requestScheduled;</span>
	}

	/**
	 * Updates the status of the requests that need updation and returns the
	 * requests to be updated.
	 *
	 * @throws RemoteException
	 * @throws BbmFinderException
	 * @throws JdmoException
	 */
	private List&lt;WSAutoScheduleRequest&gt; updateStatus(List&lt;WSAutoScheduleRequest&gt; requests)
			throws BbmFinderException, RemoteException, JdmoException {
<span class="nc" id="L430">		List&lt;WSAutoScheduleRequest&gt; requestsToBeUpdated = new ArrayList&lt;WSAutoScheduleRequest&gt;();</span>
		// get the scheduling action for requests
		// this is needed for continue requests
<span class="nc" id="L433">		Map&lt;ID, SchedulingAction&gt; schedulingActionByRequestID = schedulerHelper.getSchedulingActionForRequests(requests);</span>

<span class="nc bnc" id="L435" title="All 2 branches missed.">		for (int i = 0; i &lt; requests.size(); i++) {</span>
<span class="nc" id="L436">			WSAutoScheduleRequest request = requests.get(i);</span>

<span class="nc" id="L438">			int spIDInt = request.getSPID();</span>
<span class="nc" id="L439">			ID spID = ID.fromInt(spIDInt);</span>
<span class="nc" id="L440">			SchedulingAction schedulingAction = schedulingActionByRequestID.get(request.getID());</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">			if (schedulingAction == null) {</span>
				// we can not further process this
				// this is done to handle any left over records from earlier
				// implementation
				// they are to be marked as error
<span class="nc" id="L446">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
<span class="nc" id="L448">				request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
						&quot;This request could not be processed as there is no scheduling information&quot;);
<span class="nc" id="L450">				requestsToBeUpdated.add(request);</span>
<span class="nc" id="L451">				continue;</span>
			}
<span class="nc" id="L453">			SchedulingState state = campaignManager.getSchedulingState(spID, schedulingAction.getActionCode());</span>

<span class="nc bnc" id="L455" title="All 2 branches missed.">			if (state != null) {</span>
<span class="nc" id="L456">				updateStatus(request, state, spID, schedulingAction);</span>
<span class="nc" id="L457">				requestsToBeUpdated.add(request);</span>
			} else {
<span class="nc bnc" id="L459" title="All 2 branches missed.">				if (updateRequestNotPickedUpByFS(request, spID, schedulingAction)) {</span>
<span class="nc" id="L460">					requestsToBeUpdated.add(request);</span>
				}
			}
		}
<span class="nc" id="L464">		return requestsToBeUpdated;</span>
	}

	/**
	 * Updates the request with the state from the SchedulingState. &lt;b&gt;Note:&lt;/b&gt;
	 * All parameters are required to be non-null. No null checks are performed.
	 */
	private void updateStatus(WSAutoScheduleRequest request, SchedulingState state, ID spID,
			SchedulingAction schedulingAction) {
<span class="nc" id="L473">		boolean isStale = isScheduleStatusOld(state);</span>
<span class="nc" id="L474">		int progress = state.getOverallStatus();</span>
		// copy and update the ws request table and delete the state
		// messages from spschedstatus tables
<span class="nc" id="L477">		boolean hasError = schedulerHelper.copySchedulingStateToRequestAndGetErrorStatus(request, state);</span>
<span class="nc" id="L478">		clearWarningMessages(state);</span>

<span class="nc bnc" id="L480" title="All 2 branches missed.">		if (state.hasWarning()</span>
<span class="nc bnc" id="L481" title="All 4 branches missed.">				&amp;&amp; (WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS.equals(request.getSchedulingStatus()))</span>
				&amp;&amp; !isStale) {
			// make a continue request
<span class="nc" id="L484">			makeContinueRequest(spID, schedulingAction);</span>
		}

<span class="nc bnc" id="L487" title="All 4 branches missed.">		if (isStale &amp;&amp; progress &lt; COMPLETED_PERCENTAGE_PROGRESS) {</span>
			// update WSAutoScheduleRequest status and error message
<span class="nc" id="L489">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR);
<span class="nc" id="L491">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
<span class="nc" id="L492">					request.getStatusMessage() + &quot;|&quot; + &quot;Stopped By System due to Non-Progess&quot;);</span>
		}

<span class="nc bnc" id="L495" title="All 6 branches missed.">		if (progress == COMPLETED_PERCENTAGE_PROGRESS || hasError || isStale) {</span>
			// if there is a warning, we already put a continue
			// request
			// clear the state
<span class="nc" id="L499">			clearSchedulingSession(spID, schedulingAction);</span>
		}
<span class="nc" id="L501">	}</span>

	/**
	 * Updates the request if necessary. Updates when 1. Last updated time of
	 * the request is null (first attempt to clear) 2. The request has exceeded
	 * the max wait time to be pisked up by FS.
	 */
	private boolean updateRequestNotPickedUpByFS(WSAutoScheduleRequest request, ID spID,
			SchedulingAction schedulingAction) {
		// if it did not get picked up in 15 minutes
<span class="nc" id="L511">		Date lastUpdated = request.getFieldValueDate(WSAutoScheduleRequestFieldInfo.LASTUPDATED);</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">		if (lastUpdated == null) {</span>
<span class="nc" id="L513">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.LASTUPDATED, Calendar.getInstance().getTime());</span>
<span class="nc" id="L514">			return true;</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">		} else if (isOld(lastUpdated, getGiveUpForClearing())) {</span>
			// probably never picked up by FS for some reason. we
			// will re try
<span class="nc" id="L518">			clearSchedulingSession(spID, schedulingAction);</span>
			// we should attempt to retrigger
			// set to new status and send a message again
<span class="nc" id="L521">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.SCHEDULESTATUS,</span>
					WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);
<span class="nc" id="L523">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.STATUSMESSAGE,</span>
					&quot;Re trying the  scheduling due to a prior failure&quot;);
<span class="nc" id="L525">			int retryCount = request.getFieldValueInt(WSAutoScheduleRequestFieldInfo.RETRYCOUNT);</span>
<span class="nc" id="L526">			retryCount++;</span>
<span class="nc" id="L527">			request.setFieldValue(WSAutoScheduleRequestFieldInfo.RETRYCOUNT, retryCount);</span>
<span class="nc" id="L528">			return true;</span>
		}
<span class="nc" id="L530">		return false;</span>
	}

	/**
	 * makes a continue request for the sp.
	 */
	private void makeContinueRequest(ID spID, SchedulingAction schedulingAction) {
		// make a continue request
		try {
<span class="nc" id="L539">			SchedulingRequest schedRequest = new SchedulingRequest();</span>
<span class="nc" id="L540">			schedRequest.setSPSID(spID);</span>
<span class="nc" id="L541">			schedRequest.setRequest(REQUEST_CONTINUE);</span>
<span class="nc" id="L542">			schedRequest.setMode(schedulingAction.getActionCode());</span>
<span class="nc" id="L543">			campaignManager.makeSchedulingRequest(schedRequest);</span>
<span class="nc" id="L544">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L545">			m_cat.error(&quot;Exception while continuing the scheduling for Scheduling Period &quot; + spID, e);</span>
<span class="nc" id="L546">		} catch (RemoteException e) {</span>
<span class="nc" id="L547">			m_cat.error(&quot;Remote exception while continuing the scheduling for Scheduling Period &quot; + spID, e);</span>
<span class="nc" id="L548">		}</span>
<span class="nc" id="L549">	}</span>

	/**
	 * Clears the warning messages of the state
	 */
	private void clearWarningMessages(SchedulingState state) {
<span class="nc" id="L555">		Collection&lt;SchedulingWarning&gt; warnings = state.getWarnings();</span>
<span class="nc" id="L556">		List&lt;ID&gt; ids = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">		for (SchedulingWarning warning : warnings) {</span>
<span class="nc" id="L558">			ids.add(warning.getID());</span>
<span class="nc" id="L559">		}</span>

<span class="nc bnc" id="L561" title="All 2 branches missed.">		if (!warnings.isEmpty()) {</span>
			try {
<span class="nc" id="L563">				campaignManager.clearSchedulingStateWarnings(ids);</span>
<span class="nc" id="L564">			} catch (Exception e) {</span>
				// no big deal! the get Scheduling state in the DAO itself
				// clears them sometimes
<span class="nc" id="L567">				m_cat.warn(&quot;Could not find the warnings to clear!&quot;, e);</span>
<span class="nc" id="L568">			}</span>
		}
<span class="nc" id="L570">	}</span>

	/**
	 * Checks to see if there are any currently pending scheduling requests for
	 * the given SP and adjacent SPs. This method will get all SPs that lie in a
	 * range of 3 weeks prior to the given SP's start date and 3 weeks after the
	 * end of the given SP's end date. Using these SPs, this method will: 1)
	 * Check the SchedulingState (SPSCHEDSTATE table) to see if there is a
	 * non-stale record for any of the SPs. If there is, the method will return
	 * false. Schedules of adjacent SPs will have an impact on scheduling of
	 * current SP 2) Check the status of the schedule request coming from the
	 * web service (WSAUTOSCHEDULEREQUEST table) to see if there is a request in
	 * progress (status code of &quot;P&quot;, indicating that the SP is already being
	 * scheduled). If so, this method will return false.
	 */
	private boolean canScheduleNow(int spID, String mode, boolean scheduleInOrder) {
<span class="nc bnc" id="L586" title="All 4 branches missed.">		if (scheduleInOrder &amp;&amp; schedulerHelper.isEarlierSchedulingPeriodRequestIncomplete(spID)) {</span>
<span class="nc" id="L587">			return false;</span>
		}
		try {
<span class="nc bnc" id="L590" title="All 2 branches missed.">			return !areAdjacentSPsBeingScheduled(ID.fromInt(spID), mode);</span>
<span class="nc" id="L591">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L592">			m_cat.error(&quot;Exception while getting the scheduling period/scheduling state &quot;, e);</span>
<span class="nc" id="L593">			return false;</span>
<span class="nc" id="L594">		} catch (RemoteException e) {</span>
<span class="nc" id="L595">			m_cat.error(&quot;Exception while getting the scheduling periods &quot;, e);</span>
<span class="nc" id="L596">			return false;</span>
		}
	}

	/**
	 * Checks if any SPs within 3 week window of current sp are being scheduled.
	 * Returns true even if one of them is being scheduled
	 */
	private boolean areAdjacentSPsBeingScheduled(ID spID, String mode) throws BbmFinderException, RemoteException {
<span class="nc" id="L605">		Collection&lt;SchedulingPeriod&gt; sps = getAdjacentSPs(campaignManager.getSchedulingPeriodByID(spID));</span>
<span class="nc bnc" id="L606" title="All 2 branches missed.">		for (SchedulingPeriod sp : sps) {</span>
<span class="nc" id="L607">			ID currentSPID = sp.getID();</span>
<span class="nc bnc" id="L608" title="All 4 branches missed.">			if (isSPBeingScheduled(currentSPID, mode) || schedulerHelper.doOpenRequestsExist(currentSPID)) {</span>
<span class="nc" id="L609">				return true;</span>
			}
<span class="nc" id="L611">		}</span>
<span class="nc" id="L612">		return false;</span>
	}

	/**
	 * checks if the given SP is being scheduled by Fns
	 */
	private boolean isSPBeingScheduled(ID spID, String mode) {
		try {
<span class="nc" id="L620">			Date lastUpdatedDate = campaignManager.getSchedulingStateLastUpdatedTime(spID, mode);</span>
<span class="nc bnc" id="L621" title="All 4 branches missed.">			if (lastUpdatedDate != null &amp;&amp; !isOld(lastUpdatedDate)) {</span>
<span class="nc" id="L622">				return true;</span>
			}
<span class="nc" id="L624">		} catch (Exception any) {</span>
<span class="nc" id="L625">			m_cat.warn(&quot;Error gettting the last updated time for SP&quot; + spID + &quot;. The error is &quot; + any.getMessage(),</span>
					any);
<span class="nc" id="L627">		}</span>
<span class="nc" id="L628">		return false;</span>
	}

	/**
	 * Returns all the SPs within 3 week window of this SP for the same
	 * campaign.
	 *
	 * @param sp
	 * @throws RemoteException
	 * @throws BbmFinderException
	 */
	private Collection&lt;SchedulingPeriod&gt; getAdjacentSPs(SchedulingPeriod sp)
			throws BbmFinderException, RemoteException {
<span class="nc" id="L641">		Date startDate = sp.getStartTime();</span>
<span class="nc" id="L642">		Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L643">		cal.clear();</span>
<span class="nc" id="L644">		cal.setTime(startDate);</span>
		// 3 weeks
<span class="nc" id="L646">		cal.add(Calendar.DATE, -DAYS_IN_THREE_WEEKS);</span>
<span class="nc" id="L647">		startDate = cal.getTime();</span>
<span class="nc" id="L648">		Date endDate = sp.getEndTime();</span>
<span class="nc" id="L649">		cal.clear();</span>
<span class="nc" id="L650">		cal.setTime(endDate);</span>
<span class="nc" id="L651">		cal.add(Calendar.DATE, DAYS_IN_THREE_WEEKS);</span>
<span class="nc" id="L652">		endDate = cal.getTime();</span>

<span class="nc" id="L654">		return campaignManager.getSchedulingPeriods(sp.getCampaignID(), startDate, endDate);</span>
	}

	/**
	 * Clears the scheduling session data used by FS thick client.
	 */
	private void clearSchedulingSession(ID spID, SchedulingAction action) {
		// clear any requests
		try {
<span class="nc" id="L663">			SchedulingRequest request = new SchedulingRequest();</span>
<span class="nc" id="L664">			request.setSPSID(spID);</span>
<span class="nc" id="L665">			request.setMode(action.getActionCode());</span>
<span class="nc" id="L666">			campaignManager.clearSchedulingRequest(request);</span>

<span class="nc" id="L668">		} catch (BbmRemoveException e) {</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L670">			m_cat.warn(&quot;Could not clear the scheduling request for sp &quot; + spID, e);</span>
<span class="nc" id="L671">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L674">			m_cat.warn(&quot;Could not clear the scheduling request for sp &quot; + spID, e);</span>
<span class="nc" id="L675">		}</span>
		try {
<span class="nc" id="L677">			campaignManager.clearSPScheduleSession(spID);</span>
<span class="nc" id="L678">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L679">			m_cat.debug(&quot;Could not find SP &quot; + spID + &quot;to clear.&quot;, e);</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L681">		} catch (BbmRemoveException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L684">			m_cat.warn(&quot;Could not clear the scheduling session for sp &quot; + spID, e);</span>
<span class="nc" id="L685">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L688">			m_cat.warn(&quot;Could not clear the scheduling session for sp &quot; + spID, e);</span>
<span class="nc" id="L689">		}</span>
		try {
<span class="nc" id="L691">			campaignManager.clearSchedulingState(spID, action.getActionCode());</span>
<span class="nc" id="L692">		} catch (BbmRemoveException bre) {</span>
			// We don't care if there wasn't anything to clear.
<span class="nc" id="L694">			m_cat.debug(&quot;Could not clear scheduling state for sp &quot; + spID, bre);</span>
<span class="nc" id="L695">		} catch (RemoteException e) {</span>
			// We don't care if there wasn't anything to clear or could not
			// clear
<span class="nc" id="L698">			m_cat.warn(&quot;Could not clear the scheduling state&quot; + spID, e);</span>
<span class="nc" id="L699">		}</span>
<span class="nc" id="L700">	}</span>

	/**
	 * Checks if there is a free server available for scheduling. This method
	 * deducts any in-process SPs from available servers and returns true if
	 * this calculated number is &gt;0
	 */
	private boolean doesFreeServerExist(int availableServers) {
		// get the number of scheduling states (from schedstate table
<span class="nc" id="L709">		List&lt;Integer&gt; inProcessSPs = new ArrayList&lt;Integer&gt;();</span>
		try {
<span class="nc" id="L711">			Map&lt;ID, Date&gt; spIdVsDate = campaignManager.getAllSchedulingStateLastUpdatedTimes();</span>
<span class="nc bnc" id="L712" title="All 2 branches missed.">			for (ID spID : spIdVsDate.keySet()) {</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">				if (!isOld(spIdVsDate.get(spID))) {</span>
<span class="nc" id="L714">					inProcessSPs.add(spID.toInt());</span>
				}
<span class="nc" id="L716">			}</span>
<span class="nc" id="L717">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L718">			m_cat.error(&quot;Could not get the last updated time of scheduling states&quot;, e);</span>
<span class="nc" id="L719">		} catch (Exception e) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L721">			m_cat.warn(&quot;Error getting the last updated time of scheduling states&quot;, e);</span>
<span class="nc" id="L722">		}</span>
		// match their sp ids with wsautoscheduleRequest
		// add any missing sp ids
<span class="nc" id="L725">		WSAutoScheduleRequestDAO requestDAO = new WSAutoScheduleRequestDAO();</span>
<span class="nc" id="L726">		List&lt;WSAutoScheduleRequest&gt; requests = new ArrayList&lt;WSAutoScheduleRequest&gt;();</span>
		try {
<span class="nc" id="L728">			requests.addAll(requestDAO.getRequestsByStatus(WSAutoScheduleRequest.SCHEDULE_STATUS_IN_PROGRESS));</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">			for (WSAutoScheduleRequest request : requests) {</span>
<span class="nc" id="L730">				inProcessSPs.remove(new Integer(request.getSPID()));</span>
<span class="nc" id="L731">			}</span>

<span class="nc" id="L733">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L734">			m_cat.error(&quot;Could not get the scheduling requests&quot;, e);</span>
<span class="nc" id="L735">		} catch (Exception any) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L737">			m_cat.warn(&quot;Could not get the scheduling requests&quot;, any);</span>
		} finally {
<span class="nc" id="L739">			requestDAO.cleanUp();</span>
<span class="nc" id="L740">		}</span>

		// deduct from the number of available servers and see if that is &gt;0 and
		// return true, otherwise false
<span class="nc bnc" id="L744" title="All 2 branches missed.">		return availableServers - (inProcessSPs.size() + requests.size()) &gt; 0;</span>
	}

	private int checkServersAndUpdateStatusForNonAvailability() {
<span class="fc" id="L748">		int availableServers = getNumberOfAvailableServers();</span>
<span class="fc bfc" id="L749" title="All 2 branches covered.">		if (availableServers &lt;= 0) {</span>
			// issue with integration server or no silent Fns configured!
			// increment all new requests with one error count
			try {
<span class="fc" id="L753">				schedulerHelper.incrementErrorRetryCount(WSAutoScheduleRequest.SCHEDULE_STATUS_NEW);</span>
				// update requests with error status if the retry count is
				// beyond the max error retry count
<span class="fc" id="L756">				schedulerHelper.updateErrorStatus(getSchedulingErrorRetryCount(),</span>
						WSAutoScheduleRequest.SCHEDULE_STATUS_NEW, WSAutoScheduleRequest.SCHEDULE_STATUS_ERROR,
						COULD_NOT_SCHEDULE_DUE_TO_FSSERVER_ERROR);
<span class="nc" id="L759">			} catch (Exception any) {</span>
<span class="nc" id="L760">				m_cat.error(&quot;Could not increment error status as the silent Fns server is unavailable&quot;, any);</span>
<span class="fc" id="L761">			}</span>
		}
<span class="fc" id="L763">		return availableServers;</span>
	}

	/**
	 * Returns the number of available servers for scheduling. This includes the
	 * servers that are already in use
	 */
	private int getNumberOfAvailableServers() {
		// number of server nodes
<span class="fc" id="L772">		int noOfServers = 1;</span>
		try {
<span class="fc" id="L774">			noOfServers = facadeCorbaFacadeManager.getCountOfServers(FacadeCorbaFacadeManager.SILENT_FNS_ADAPTER);</span>
<span class="nc" id="L775">		} catch (RemoteException e) {</span>
<span class="nc" id="L776">			m_cat.warn(&quot;Could not get the number of servers&quot;, e);</span>
<span class="nc" id="L777">			return -1;</span>
<span class="nc" id="L778">		} catch (Exception any) {</span>
			// should not throw runtime exceptions too!
<span class="nc" id="L780">			m_cat.warn(&quot;Could not get the number of servers&quot;, any);</span>
<span class="nc" id="L781">			return -1;</span>
<span class="fc" id="L782">		}</span>

<span class="fc" id="L784">		return getCPUsPerFSServer() * noOfServers;</span>
	}

	/**
	 * Returns the number of CPUs that are present per FS server. If the config
	 * parameter is not present, returns {@link#DEFAULT_NO_OF_CPU}
	 */
	private int getCPUsPerFSServer() {
		try {
<span class="fc" id="L793">			int noOfCPUs = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_CPU);</span>
<span class="pc bpc" id="L794" title="1 of 2 branches missed.">			if (noOfCPUs &gt; 0) {</span>
<span class="nc" id="L795">				return noOfCPUs;</span>
			}
<span class="nc" id="L797">		} catch (Exception e) {</span>
<span class="nc" id="L798">			m_cat.warn(&quot;Could not get the number of CPUs per FS server&quot;, e);</span>
<span class="fc" id="L799">		}</span>
<span class="fc" id="L800">		return DEFAULT_NO_OF_CPU;</span>
	}

	/**
	 * Returns the superuser
	 */
	private String getSuperUser() {
		try {
<span class="nc" id="L808">			User superuser = userManager.getUserByID(User.SUPER_USERID);</span>
<span class="nc" id="L809">			return superuser.getUserName();</span>
<span class="nc" id="L810">		} catch (CoreFinderException e) {</span>
<span class="nc" id="L811">			m_cat.warn(&quot;Could not find the super user&quot;, e);</span>
<span class="nc" id="L812">		} catch (RemoteException e) {</span>
<span class="nc" id="L813">			m_cat.error(&quot;Error getting the super user&quot;, e);</span>
<span class="nc" id="L814">		}</span>

<span class="nc" id="L816">		return null;</span>
	}

	/**
	 * Returns the password token for the user. If the seal is not null, uses
	 * the seal for generating the password token
	 */
	private String getUserPassword(String username, String seal) {
		try {
<span class="nc bnc" id="L825" title="All 2 branches missed.">			if (!StringUtil.isEmpty(seal)) {</span>
<span class="nc" id="L826">				return userManager.generateToken(username, seal);</span>
			}
			// hurry: this token is only valid for 1 minute!
<span class="nc" id="L829">			return userManager.generateSSOTokenWIthNoSeal(username);</span>
<span class="nc" id="L830">		} catch (RemoteException e) {</span>
<span class="nc" id="L831">			m_cat.error(&quot;Error getting the super user credentials&quot;, e);</span>
		}
<span class="nc" id="L833">		return null;</span>
	}

	/**
	 * Returns the time in milli seconds after which again scheduling attempt
	 * should be made
	 */
	private long getSchedulingRetryInterval() {
		try {
<span class="nc" id="L842">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_RETRY_INTERVAL);</span>
<span class="nc bnc" id="L843" title="All 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L844">				return retryInterval;</span>
			}
<span class="nc" id="L846">		} catch (Exception e) {</span>
<span class="nc" id="L847">			m_cat.debug(&quot;Could not get scheduling retry interval. The default interval &quot;</span>
					+ DEFAULT_SCHEDULING_RETRY_COUNT + &quot; will be used.&quot;, e);
<span class="nc" id="L849">		}</span>
<span class="nc" id="L850">		return DEFAULT_SCHEDULING_RETRY_INTERVAL;</span>
	}

	/**
	 * Returns the number of times scheduling should be retried before giving up
	 * when there is an error
	 */
	private int getSchedulingErrorRetryCount() {
		try {
<span class="fc" id="L859">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_ERROR_RETRY_COUNT);</span>
<span class="pc bpc" id="L860" title="1 of 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L861">				return retryInterval;</span>
			}
<span class="nc" id="L863">		} catch (Exception e) {</span>
<span class="nc" id="L864">			m_cat.warn(&quot;Could not get the scheduling error retry count&quot;, e);</span>
<span class="fc" id="L865">		}</span>
<span class="fc" id="L866">		return DEFAULT_SCHEDULING_ERROR_RETRY_COUNT;</span>
	}

	/**
	 * Returns the number of times scheduling should be retried before giving up
	 */
	private int getSchedulingRetryCount() {
		try {
<span class="nc" id="L874">			int retryInterval = dbConfigManager.getIntValue(ConfigKey.FACADE_SCHEDULING_RETRY_COUNT);</span>
<span class="nc bnc" id="L875" title="All 2 branches missed.">			if (retryInterval &gt; 0) {</span>
<span class="nc" id="L876">				return retryInterval;</span>
			}
<span class="nc" id="L878">		} catch (Exception e) {</span>
<span class="nc" id="L879">			m_cat.warn(&quot;Could not get the scheduling retry count&quot;, e);</span>
<span class="nc" id="L880">		}</span>
<span class="nc" id="L881">		return DEFAULT_SCHEDULING_RETRY_COUNT;</span>
	}

	/**
	 * Creates the {@link ScheduleMessage} using the parameters in
	 * {@link ScheduleRequestsMessage}
	 **/
	private ID createDBMessage(ScheduleRequestsMessage message) throws BbmCreateException {
<span class="fc" id="L889">		ScheduleMessageDAO messageDAO = new ScheduleMessageDAO();</span>
		try {
<span class="fc" id="L891">			synchronized (_CREATE_LOCK) {</span>
<span class="fc" id="L892">				return messageDAO.createObject(schedulerHelper.getDBMessageFromJMSMessage(message));</span>
<span class="nc" id="L893">			}</span>
		} finally {
<span class="pc" id="L895">			messageDAO.cleanUp();</span>
		}
	}

	/**
	 * sets the scheduling parameters for the SP to be used by FS thick client
	 * during scheduling.
	 */
	private void setSecondarySchedulingParameters(ID messageID, ID spID) {
<span class="nc" id="L904">		Map&lt;String, Object&gt; secondaryParams = null;</span>
<span class="nc" id="L905">		ScheduleMessageParametersDAO dao = new ScheduleMessageParametersDAO();</span>
		try {
<span class="nc" id="L907">			Collection&lt;ScheduleMessageParameters&gt; allParameters = dao.getObjectsByParentID(messageID);</span>
<span class="nc bnc" id="L908" title="All 4 branches missed.">			if (allParameters != null &amp;&amp; !allParameters.isEmpty()) {</span>
<span class="nc" id="L909">				ScheduleMessageParameters parameters = allParameters.iterator().next();</span>
<span class="nc" id="L910">				secondaryParams = new HashMap&lt;String, Object&gt;();</span>
				//omit id and message id...they are not part of the parameters
<span class="nc" id="L912">				for (int i = ScheduleMessageParametersFieldInfo.DAYS_TO_SCHEDULE; i &lt; dao.getDaoFieldInfo()</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">						.getFieldCount(); i++) {</span>
<span class="nc bnc" id="L914" title="All 2 branches missed.">					if (parameters.getFieldValue(i) != null) {</span>
<span class="nc" id="L915">						secondaryParams.put(dao.getDaoFieldInfo().getFieldName(i), parameters.getFieldValue(i));</span>
					}
				}
			}
<span class="nc" id="L919">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L920">			m_cat.error(&quot;Could not get the scheduling parameters&quot;, e);</span>
		} finally {
<span class="nc" id="L922">			dao.cleanUp();</span>
<span class="nc" id="L923">		}</span>
<span class="nc bnc" id="L924" title="All 4 branches missed.">		if (secondaryParams != null &amp;&amp; secondaryParams.size() &gt; 0) {</span>
			try {
<span class="nc" id="L926">				campaignManager.setSchedulingParameters(spID, secondaryParams, &quot;&quot;);</span>
<span class="nc" id="L927">			} catch (BbmCreateException e) {</span>
<span class="nc" id="L928">				m_cat.error(&quot;Could not set the scheduling parameters&quot;, e);</span>
<span class="nc" id="L929">			} catch (RemoteException e) {</span>
<span class="nc" id="L930">				m_cat.error(&quot;Could not set the scheduling parameters&quot;, e);</span>
<span class="nc" id="L931">			}</span>
		}
<span class="nc" id="L933">	}</span>

	/**
	 * Compares the time with the current system time. If that time difference
	 * is greater than MAX_OLD_SCHEDULE_STATUS_MILLIS milliseconds
	 */
	private boolean isOld(Date date) {
<span class="nc" id="L940">		return isOld(date, MAX_OLD_SCHEDULE_STATUS_MILLIS);</span>
	}

	/**
	 * Compares the time of the SchedulingState with the current system time. If
	 * that time difference is greater than MAX_OLD_SCHEDULE_STATUS_MILLIS
	 * milliseconds, this method will return true. If the
	 * state.getTimeLastUpdated is null, this will return a false.
	 */
	private boolean isScheduleStatusOld(SchedulingState state) {
<span class="nc" id="L950">		return isScheduleStatusOld(state, MAX_OLD_SCHEDULE_STATUS_MILLIS);</span>
	}

	/**
	 * Compares the time of the SchedulingState with the current system time. If
	 * that time difference of current state - last updated is greater than time
	 * in milliseconds, this method will return true.If
	 * thestate.getTimeLastUpdated is null, this will return a false.
	 */
	private boolean isScheduleStatusOld(SchedulingState state, int time) {
<span class="nc bnc" id="L960" title="All 2 branches missed.">		if (state == null) {</span>
<span class="nc" id="L961">			throw new IllegalArgumentException(&quot;The state cannot be null&quot;);</span>
		}
<span class="nc bnc" id="L963" title="All 2 branches missed.">		if (state.getTimeLastUpdated() == null) {</span>
<span class="nc" id="L964">			return false;</span>
		}
<span class="nc" id="L966">		return isOld(state.getTimeLastUpdated(), time);</span>
	}

	/**
	 * Compares the time with the current system time. If that time difference
	 * is greater than 'time' milliseconds
	 */
	private boolean isOld(Date date, long time) {
<span class="nc bnc" id="L974" title="All 2 branches missed.">		if (date == null) {</span>
<span class="nc" id="L975">			throw new IllegalArgumentException(&quot;The date cannot be null&quot;);</span>
		}

		// Determine the current time and compare that to the status's time
		// to see if there is a significant time difference.
<span class="nc bnc" id="L980" title="All 2 branches missed.">		return Math.abs((new Date()).getTime() - date.getTime()) &gt; Math.max(time, getSchedulingRetryInterval());</span>
	}

	/**
	 * Returns the time that needs to elapse for FS to pick up scheduling
	 * request before this request is deemed as not takenup.
	 *
	 * @return
	 */
	private long getGiveUpForClearing() {
<span class="nc" id="L990">		return Math.max(DEFAULT_GIVE_UP_TIME, getSchedulingRetryInterval() * 20);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>