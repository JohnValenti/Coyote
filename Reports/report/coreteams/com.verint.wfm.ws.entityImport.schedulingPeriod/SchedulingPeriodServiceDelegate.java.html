<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>SchedulingPeriodServiceDelegate.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.verint.wfm.ws.entityImport.schedulingPeriod</a> &gt; <span class="el_source">SchedulingPeriodServiceDelegate.java</span></div><h1>SchedulingPeriodServiceDelegate.java</h1><pre class="source lang-java linenums">/**
 * @author Eliot Clingman, Copyright (c) 2011, 2017 by Verint Systems, Inc. All Rights Reserved. Campaign
 *         Manager Web Service This supports methods to synchronize campaigns between WFO and an
 *         external application
 */

package com.verint.wfm.ws.entityImport.schedulingPeriod;

import java.rmi.RemoteException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import javax.annotation.PostConstruct;

import com.bluepumpkin.common.datatypes.CalendarRange;
import com.bluepumpkin.common.datatypes.TimeRange;
import org.apache.commons.collections.CollectionUtils;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignHOO;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueueIDMap;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueueFieldInfo;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.dao.MapUtil;
import com.bluepumpkin.ejb.bbm.dao.MapUtil.SystemType;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.core.Log;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.verint.common.util.EncodeUtil;
import com.verint.ejb.bbm.servicegoals.ejb.ServiceGoalsManager;
import com.verint.ejb.bbm.servicegoals.model.ASATimeSeriesDataItem;
import com.verint.ejb.bbm.servicegoals.model.ServiceGoalsTimeSeriesDataItem;
import com.verint.ejb.bbm.servicegoals.model.ServiceLevelPercentTimeSeriesDataItem;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.verint.wfm.ws.ServiceApplicationException;
import com.verint.wfm.ws.entityImport.campaign.CampaignServiceDelegate;
import com.verint.wfm.ws.entityImport.model.HoursOfOperationDTO;
import com.verint.wfm.ws.entityImport.schedulingPeriod.model.SchedulingPeriodDTO;
import com.verint.wfm.ws.entityImport.schedulingPeriod.model.SchedulingPeriodDTO.SchedulingPeriodExternalNaturalKey;
import com.verint.wfm.ws.entityImport.schedulingPeriod.model.SchedulingPeriodQueueDTO;
import com.verint.wfm.ws.entityImport.schedulingPeriod.model.ServiceGoalDTO;
import com.verint.wfm.ws.entityImport.schedulingPeriod.model.ServiceGoalSeriesDTO;
import com.verint.wfm.ws.util.CalendarUtil;
import com.verint.wfm.ws.util.ExternalIDUtil;
import com.verint.wfm.ws.util.SchedulingPeriodExternalNaturalKeyMapJAXBType;
import com.verint.wfm.ws.util.SyncUtil;
import com.verint.wfm.ws.util.TimePeriodUtil;

<span class="fc" id="L76">public class SchedulingPeriodServiceDelegate {</span>
	public static final int DAYS_IN_WEEK = 7;
	private static final long serialVersionUID = 1L;
<span class="fc" id="L79">	private static Category CAT = Log.initCategory(SchedulingPeriodServiceDelegate.class.getName());</span>

	public static final String DATE_FORMAT = &quot;MM/dd/yyyy&quot;;
	private static final int HOUR_PER_DAY =  24;

<span class="fc" id="L84">	private CampaignManager campaignManager = null;</span>
<span class="fc" id="L85">	private WorkloadManager workloadManager = null;</span>
<span class="fc" id="L86">	private ServiceGoalsManager serviceGoalsManager = null;</span>
<span class="fc" id="L87">	private WorkResourceManager workResourceManager = null;</span>

	//Batch size for updating scheduling period queues
	private static final int SPQUEUE_BATCH_SIZE = 5000;
	//Batch size for updating service goals
	private static final int SG_BATCH_SIZE = 100000;

	/**
	 * Make sure all campaigns from the source system are represented in WFO. New entities are
	 * determined by comparing the externalSourceId with what's already persisted to WFO. Old
	 * entities are updated instead of recreated ?? Entities missing from the external source are
	 * not deleted on WFO, ?nor are they archived
	 * 
	 * The QueueDTO class here is a simplified version of WFOs Campaign class
	 * 
	 * @throws ServiceApplicationException
	 *             when there is a application fault
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;SchedulingPeriodNotPersistedInfo&gt; createOrUpdate(
			Collection&lt;SchedulingPeriodDTO&gt; schedulingPeriodDTOs, String systemTypeName)
					throws ServiceApplicationException {

<span class="nc" id="L110">		SystemType systemType = SystemType.valueOf(systemTypeName);</span>
<span class="nc" id="L111">		CAT.info(&quot;createOrUpdate(): systemType.name(): &quot; + systemType.name());</span>
<span class="nc" id="L112">		List&lt;SchedulingPeriodNotPersistedInfo&gt; schedulingPeriodNotPersistedInfos = new ArrayList&lt;SchedulingPeriodNotPersistedInfo&gt;();</span>
<span class="nc bnc" id="L113" title="All 4 branches missed.">		if (schedulingPeriodDTOs == null || schedulingPeriodDTOs.isEmpty()) {</span>
<span class="nc" id="L114">			CAT.debug(&quot;No Scheduling Periods to create or update&quot;);</span>
		}

		// Convert From DTO's to entities so that the EJB layer can handle them
<span class="nc" id="L118">		Collection&lt;SchedulingPeriodWithStuffWrapper&gt; newSchedulingPeriodWrappers = new ArrayList&lt;SchedulingPeriodWithStuffWrapper&gt;();</span>
<span class="nc" id="L119">		Collection&lt;SchedulingPeriodWithStuffWrapper&gt; oldSchedulingPeriodWrappers = new ArrayList&lt;SchedulingPeriodWithStuffWrapper&gt;();</span>

		try {
<span class="nc" id="L122">			convertToEntity(schedulingPeriodDTOs, systemType, newSchedulingPeriodWrappers,</span>
					oldSchedulingPeriodWrappers, schedulingPeriodNotPersistedInfos);
<span class="nc" id="L124">			CAT.info(&quot;Succeeded to convert DTOs!&quot;);</span>
<span class="nc" id="L125">		} catch (RuntimeException e) {</span>
<span class="nc" id="L126">			CAT.error(&quot;Unrecoverable system bug while converting DTO to entity Campaign&quot;, e);</span>
<span class="nc" id="L127">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L128">		}</span>

<span class="nc" id="L130">		CAT.info(&quot;createOrUpdate(): new and old Campaigns.size() resp.: &quot;</span>
<span class="nc" id="L131">				+ newSchedulingPeriodWrappers.size() + &quot;, &quot; + oldSchedulingPeriodWrappers.size());</span>

<span class="nc bnc" id="L133" title="All 2 branches missed.">		if (campaignManager == null) {</span>
<span class="nc" id="L134">			CAT.error(&quot;In createOrUpdate method: bean manager does not exist&quot;);</span>
		}

<span class="nc" id="L137">		List&lt;SPQueue&gt; spqToInsert = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L138">		List&lt;SPQueue&gt; spqToUpdate = new ArrayList&lt;&gt;();</span>

		// TODO all start and end dates are midnight, or else throw exception
		// Create persist the new scheduling periods
<span class="nc bnc" id="L142" title="All 2 branches missed.">		for (SchedulingPeriodWithStuffWrapper newSchedulingPeriodWrapper : newSchedulingPeriodWrappers) {</span>
			try {
<span class="nc" id="L144">				SchedulingPeriod newSchedulingPeriod = newSchedulingPeriodWrapper.getSchedulingPeriod();</span>
<span class="nc" id="L145">				ID newSchedulingPeriodSID = campaignManager.createSchedulingPeriod(newSchedulingPeriod);</span>
<span class="nc" id="L146">				newSchedulingPeriod.setID(newSchedulingPeriodSID);</span>

				// ... and so are all campaignHOOs
<span class="nc bnc" id="L149" title="All 2 branches missed.">				for (CampaignHOO newCampaignHOO : newSchedulingPeriodWrapper.getNewCampaignHOOs()) {</span>
<span class="nc" id="L150">					newCampaignHOO.setSPID(newSchedulingPeriod.getID());</span>
<span class="nc" id="L151">					campaignManager.createCampaignHOOAssignment(newCampaignHOO);</span>
<span class="nc" id="L152">				}</span>

				// ... and so are all schedulingPeriodQueues
<span class="nc bnc" id="L155" title="All 2 branches missed.">				for (SPQueueWithServiceGoalsWrapper newSPQueueWrapper : newSchedulingPeriodWrapper.getNewSPQueueWrappers()) {</span>
<span class="nc" id="L156">					SPQueue newSPQueue = newSPQueueWrapper.getSPQueue();</span>
<span class="nc" id="L157">					newSPQueue.setSpID(newSchedulingPeriod.getID());</span>
<span class="nc" id="L158">					spqToInsert.add(newSPQueue);</span>
<span class="nc" id="L159">				}</span>

				// Note: any problem with validity or database state should have been detected by
				// now. So any exceptions thrown here are unrecoverable system bugs. They are
				// captured separately in case invoked method's contract changes
<span class="nc" id="L164">			} catch (BbmCreateException e) {</span>
<span class="nc" id="L165">				String message = &quot;Failed to create the scheduling period or CampaignHOOAssignment&quot;;</span>
<span class="nc" id="L166">				CAT.error(message, e);</span>
<span class="nc" id="L167">				throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L168">			} catch (RemoteException e) {</span>
<span class="nc" id="L169">				String message = &quot;There was a communication fault creating the SchedulingPeriod or CampaignHOOAssignment&quot;;</span>
<span class="nc" id="L170">				CAT.error(message, e);</span>
<span class="nc" id="L171">				throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L172">			} catch (RuntimeException e) {</span>
<span class="nc" id="L173">				String message = &quot;Failed to create the scheduling period due to Runtime Exception&quot;;</span>
<span class="nc" id="L174">				CAT.error(message, e);</span>
<span class="nc" id="L175">				throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L176">			}</span>
<span class="nc" id="L177">		}</span>

		// persist updates for the old scheduling periods
		try {
<span class="nc" id="L181">			campaignManager.updateSchedulingPeriods(</span>
<span class="nc" id="L182">					SchedulingPeriodWithStuffWrapper.convertToSchedulingPeriods(oldSchedulingPeriodWrappers));</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">			for (SchedulingPeriodWithStuffWrapper oldSchedulingPeriodWrapper : oldSchedulingPeriodWrappers) {</span>
				// Persist CampaignHOOs
<span class="nc bnc" id="L185" title="All 2 branches missed.">				for (CampaignHOO newCampaignHOO : oldSchedulingPeriodWrapper.getNewCampaignHOOs()) {</span>
<span class="nc" id="L186">					campaignManager.createCampaignHOOAssignment(newCampaignHOO);</span>
<span class="nc" id="L187">				}</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">				for (CampaignHOO oldCampaignHOO : oldSchedulingPeriodWrapper.getOldCampaignHOOs()) {</span>
<span class="nc" id="L189">					campaignManager.updateCampaignHOOAssignment(oldCampaignHOO);</span>
<span class="nc" id="L190">				}</span>

				// Persist schedulingPeriodQueues
<span class="nc bnc" id="L193" title="All 2 branches missed.">				for (SPQueueWithServiceGoalsWrapper newSPQueueWrapper : oldSchedulingPeriodWrapper.getNewSPQueueWrappers()) {</span>
<span class="nc" id="L194">					spqToInsert.add(newSPQueueWrapper.getSPQueue());</span>
<span class="nc" id="L195">				}</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">				for (SPQueueWithServiceGoalsWrapper oldSPQueueWrapper : oldSchedulingPeriodWrapper.getOldSPQueueWrappers()) {</span>
<span class="nc" id="L197">					spqToUpdate.add(oldSPQueueWrapper.getSPQueue());</span>
<span class="nc" id="L198">				}</span>
<span class="nc" id="L199">			}</span>
<span class="nc" id="L200">			CAT.info(&quot;suceeded to update SP and CampaignHOOAssignment!&quot;);</span>
<span class="nc" id="L201">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L202">			String message = &quot;Failed to create the SP or CampaignHOOAssignment!&quot;;</span>
<span class="nc" id="L203">			CAT.error(message, e);</span>
<span class="nc" id="L204">			throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L205">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L206">			String message = &quot;Failed to update the SP or CampaignHOOAssignment!&quot;;</span>
<span class="nc" id="L207">			CAT.error(message, e);</span>
<span class="nc" id="L208">			throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L209">		} catch (RemoteException e) {</span>
<span class="nc" id="L210">			String message = &quot;There was a communication fault updating SchedulingPeriods or CampaignHOOAssignment&quot;;</span>
<span class="nc" id="L211">			CAT.error(message, e);</span>
<span class="nc" id="L212">			throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L213">		} catch (RuntimeException e) {</span>
<span class="nc" id="L214">			String message = &quot;Failed to update the scheduling period or CampaignHOOAssignment due to Runtime Exception&quot;;</span>
<span class="nc" id="L215">			CAT.error(message, e);</span>
<span class="nc" id="L216">			throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L217">		} catch (MultiUserException e) {</span>
<span class="nc" id="L218">			String message = &quot;Another process is trying to update this scheduling period or CampaignHOOAssignment&quot;;</span>
<span class="nc" id="L219">			CAT.error(message, e);</span>
<span class="nc" id="L220">			throw new ServiceApplicationException(message, e);</span>
<span class="nc" id="L221">		}</span>

<span class="nc" id="L223">		createSPQueues(spqToInsert);</span>
<span class="nc" id="L224">		updateSPQueues(spqToUpdate);</span>
<span class="nc" id="L225">		CAT.info(&quot;Succeeded creating/ updating SPQueues!&quot;);</span>
<span class="nc" id="L226">		createOrUpdateServiceGoals(</span>
<span class="nc" id="L227">				(Collection&lt;SchedulingPeriodWithStuffWrapper&gt;) CollectionUtils.union(</span>
						newSchedulingPeriodWrappers,
						oldSchedulingPeriodWrappers));
<span class="nc" id="L230">		return schedulingPeriodNotPersistedInfos;</span>
	}

	/**
	 * Creates the SPQueues and sets the created Ids on to the SPQueues
	 */
	protected void createSPQueues(List&lt;SPQueue&gt; spQueues) throws ServiceApplicationException {
		try {
<span class="nc" id="L238">			int startIndex = 0;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">			while (startIndex &lt; spQueues.size()) {</span>
<span class="nc" id="L240">				int endIndex = Math.min(startIndex + SPQUEUE_BATCH_SIZE, spQueues.size());</span>
<span class="nc" id="L241">				List&lt;SPQueue&gt; currentBatch = new ArrayList&lt;SPQueue&gt;(spQueues.subList(startIndex, endIndex));</span>
<span class="nc" id="L242">				SPQueueIDMap idMap = campaignManager.createSPQueuesWithLimitedFields(currentBatch);</span>
<span class="nc bnc" id="L243" title="All 2 branches missed.">				for (SPQueue spQueue : currentBatch) {</span>
<span class="nc" id="L244">					ID spqueueId = idMap.getSPQueueID(spQueue.getQueueID(), spQueue.getSpID());</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">					if (spqueueId == null) {</span>
<span class="nc" id="L246">						String message = &quot;Scheduling Period queue not created due to overlapping time for sp queue with Scheduling Period Id &quot;</span>
<span class="nc" id="L247">										+ spQueue.getSpID() + &quot; and Queue Id &quot; + spQueue.getQueueID();</span>
<span class="nc" id="L248">						CAT.error(message);</span>
<span class="nc" id="L249">						throw new ServiceApplicationException(message);</span>
					}

<span class="nc" id="L252">					spQueue.setID(spqueueId);</span>
<span class="nc" id="L253">				}</span>
<span class="nc" id="L254">				startIndex = endIndex;</span>
<span class="nc" id="L255">			}</span>
<span class="nc" id="L256">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L257">			CAT.error(&quot;Failed to create the SP Queues!&quot;, e);</span>
<span class="nc" id="L258">			throw new ServiceApplicationException(&quot;Failed to create the SP Queues!&quot;, e);</span>
<span class="nc" id="L259">		} catch (RemoteException e) {</span>
<span class="nc" id="L260">			CAT.error(&quot;There was a communication fault invoking campaignManager.createSPQueuesWithLimitedFields()&quot;, e);</span>
<span class="nc" id="L261">			throw new ServiceApplicationException(</span>
					&quot;There was a communication fault invoking campaignManager.createSPQueuesWithLimitedFields)&quot;, e);
<span class="nc" id="L263">		} catch (RuntimeException e) {</span>
<span class="nc" id="L264">			CAT.error(&quot;Failed to create the SP Queues due to Runtime Exception&quot;, e);</span>
<span class="nc" id="L265">			throw new ServiceApplicationException(&quot;Failed to create the sp queues due to Runtime Exception&quot;, e);</span>
<span class="nc" id="L266">		}</span>
<span class="nc" id="L267">	}</span>

	/**
	 * Updates the SPQueues
	 */
	protected void updateSPQueues(List&lt;SPQueue&gt; spQueues) throws ServiceApplicationException {
		try {
<span class="nc" id="L274">			int startIndex = 0;</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			while (startIndex &lt; spQueues.size()) {</span>
<span class="nc" id="L276">				int endIndex = Math.min(startIndex + SPQUEUE_BATCH_SIZE, spQueues.size());</span>
<span class="nc" id="L277">				List&lt;SPQueue&gt; currentBatch = new ArrayList&lt;SPQueue&gt;(spQueues.subList(startIndex, endIndex));</span>
<span class="nc" id="L278">				campaignManager.updateSPQueuesWithLimitedFields(spQueues);</span>
<span class="nc" id="L279">				startIndex = endIndex;</span>
<span class="nc" id="L280">			}</span>
<span class="nc" id="L281">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L282">			CAT.error(&quot;Failed to update the SP Queues!&quot;, e);</span>
<span class="nc" id="L283">			throw new ServiceApplicationException(&quot;Failed to update the SP Queues!&quot;, e);</span>
<span class="nc" id="L284">		} catch (RemoteException e) {</span>
<span class="nc" id="L285">			CAT.error(&quot;There was a communication fault invoking campaignManager.updateSPQueuesWithLimitedFields()&quot;, e);</span>
<span class="nc" id="L286">			throw new ServiceApplicationException(</span>
					&quot;There was a communication fault invoking campaignManager.updateSPQueuesWithLimitedFields)&quot;, e);
<span class="nc" id="L288">		} catch (RuntimeException e) {</span>
<span class="nc" id="L289">			CAT.error(&quot;Failed to update the SP Queues due to Runtime Exception&quot;, e);</span>
<span class="nc" id="L290">			throw new ServiceApplicationException(&quot;Failed to update the SP Queues due to Runtime Exception&quot;, e);</span>
<span class="nc" id="L291">		}</span>
<span class="nc" id="L292">	}</span>

	public SchedulingPeriodExternalNaturalKeyMapJAXBType areSaved(
			Collection&lt;SchedulingPeriodExternalNaturalKey&gt; schedulingPeriodExternalNaturalKeys,
			String systemTypeName) throws ServiceApplicationException {
		SystemType systemType;
		try {
<span class="nc" id="L299">			systemType = SystemType.valueOf(systemTypeName);</span>
<span class="nc" id="L300">		} catch (RuntimeException e) {</span>
<span class="nc" id="L301">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L302">		}</span>
<span class="nc bnc" id="L303" title="All 4 branches missed.">		if (schedulingPeriodExternalNaturalKeys == null || schedulingPeriodExternalNaturalKeys.isEmpty()) {</span>
<span class="nc" id="L304">			CAT.debug(&quot;No Scheduling periods to check&quot;);</span>
<span class="nc" id="L305">			return new SchedulingPeriodExternalNaturalKeyMapJAXBType();</span>
		}
<span class="nc" id="L307">		Map&lt;SchedulingPeriodExternalNaturalKey, Boolean&gt; preResult = buildSchedulingPeriodExternalKeyTruthMap(</span>
				schedulingPeriodExternalNaturalKeys, systemType);

		// Map needs to be wrapped by a custom JAXB type
<span class="nc" id="L311">		return new SchedulingPeriodExternalNaturalKeyMapJAXBType(preResult);</span>
	}

	public String doTheseExist(
			Collection&lt;SchedulingPeriodExternalNaturalKey&gt; schedulingPeriodExternalNaturalKeys,
			String systemTypeName)
					throws ServiceApplicationException {
		SystemType systemType;
		try {
<span class="nc" id="L320">			systemType = SystemType.valueOf(systemTypeName);</span>
<span class="nc" id="L321">		} catch (RuntimeException e) {</span>
<span class="nc" id="L322">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L323">		}</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">		if (schedulingPeriodExternalNaturalKeys == null</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">				|| schedulingPeriodExternalNaturalKeys.isEmpty()) {</span>
<span class="nc" id="L326">			CAT.debug(&quot;No Scheduling periods to check&quot;);</span>
<span class="nc" id="L327">			return &quot;&quot;;</span>
		}

		// First pass: build maps to local campaign ids
<span class="nc" id="L331">		Collection&lt;ID&gt; campaignExternalSourceIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L332" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>
<span class="nc" id="L333">			campaignExternalSourceIds.add(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L335">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>
<span class="nc" id="L336">		}</span>

		Map&lt;ID, ID&gt; campaignExternalWfoIDMap;
		try {
<span class="nc" id="L340">			campaignExternalWfoIDMap = MapUtil.getExternalIDMap(systemType,</span>
					MapUtil.ObjectType.Campaign, campaignExternalSourceIds,
					true);
<span class="nc" id="L343">		} catch (JdmoException e) {</span>
<span class="nc" id="L344">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L345">		}</span>
		// Second pass: Load from database all campaigns of the scheduling periods: we need their time zones
<span class="nc" id="L347">		Map&lt;ID, Campaign&gt; wfoIDCampaignMap = getIDCampaignMap(campaignManager, campaignExternalWfoIDMap.values());</span>
<span class="nc" id="L348">		StringBuilder preResult = new StringBuilder();</span>
<span class="nc bnc" id="L349" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>
<span class="nc" id="L350">			boolean isExistenceProven = false;</span>
<span class="nc" id="L351">			ID wfoCampaignID = campaignExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L353">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>
<span class="nc bnc" id="L354" title="All 2 branches missed.">			if (wfoCampaignID != null) {</span>
				try {
<span class="nc" id="L356">					Campaign campaign = wfoIDCampaignMap.get(wfoCampaignID);</span>
<span class="nc" id="L357">					Calendar startDateWithZone = schedulingPeriodExternalNaturalKey.startCalendarWithZone(campaign.getTimeZone());</span>
<span class="nc" id="L358">					LocalDate startLocalDate = new LocalDate(startDateWithZone.getTime(), campaign.getTimeZone());</span>

					// Notes: (1)There is a design flaw in the ejb, whereby the query is based on
					// the GMT time (2) scheduling period has two relevant properties startTime
					// which is GMT translated and also startTimeLocal
					// TODO could we create method to do all of this at once?
<span class="nc" id="L364">					Date startDateGMT = com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil.convertToGMTFromLocalDateTimeInTimeZone(</span>
							startLocalDate,
<span class="nc" id="L366">							campaign.getTimeZone());</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L368">					Collection&lt;SchedulingPeriod&gt; candidateSchedulingPeriods = campaignManager.getSchedulingPeriods(</span>
							wfoCampaignID,
							startDateGMT,
							1,
							SchedulingPeriod.FutureOnly);
<span class="nc bnc" id="L373" title="All 2 branches missed.">					if (!candidateSchedulingPeriods.isEmpty()</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">							&amp;&amp; candidateSchedulingPeriods.iterator().next().getStartTime().equals(startDateGMT)) {</span>
<span class="nc" id="L375">						isExistenceProven = true;</span>
					}
<span class="nc" id="L377">				} catch (BbmFinderException e) {</span>
<span class="nc" id="L378">					throw new ServiceApplicationException(e);</span>
<span class="nc" id="L379">				} catch (RemoteException e) {</span>
<span class="nc" id="L380">					throw new ServiceApplicationException(e);</span>
<span class="nc" id="L381">				}</span>
			}
<span class="nc bnc" id="L383" title="All 2 branches missed.">			if(isExistenceProven) {</span>
<span class="nc" id="L384">				preResult.append(1);</span>
			}else{
<span class="nc" id="L386">				preResult.append(0);</span>
			}
<span class="nc" id="L388">		}</span>
<span class="nc" id="L389">		return preResult.toString();</span>
	}

	// ----------------------------------------------------------------------
	// helpers

	@PostConstruct
	public void postConstruct() {
		// Note: These are only available as remote beans which slows things down
		try {
<span class="fc" id="L399">			campaignManager = WfmManagerFactory.getCampaignManager();</span>
<span class="fc" id="L400">			serviceGoalsManager = WfmManagerFactory.getServiceGoalsManager(false);</span>
<span class="fc" id="L401">			workloadManager = WfmManagerFactory.getWorkloadManager();</span>
<span class="fc" id="L402">			workResourceManager = BbmManagerFactory.getWorkResourceManager();</span>
<span class="fc" id="L403">			CAT.info(&quot;Succeeded to obtain reference to all managers :)&quot;);</span>
<span class="nc" id="L404">		} catch (BbmEJBCreateException e) {</span>
<span class="nc" id="L405">			CAT.error(&quot;Failed to obtain reference to a manager :(&quot;, e);</span>
<span class="fc" id="L406">		}</span>
<span class="fc" id="L407">	}</span>

	public Map&lt;SchedulingPeriodExternalNaturalKey, ID&gt; convertToID(
			SystemType systemType,
			Collection&lt;SchedulingPeriodExternalNaturalKey&gt; schedulingPeriodExternalNaturalKeys,
			Map&lt;ID, Campaign&gt; outWfoIdCampaignMap)
					throws ServiceApplicationException {
<span class="nc" id="L414">		return convertToID(systemType, schedulingPeriodExternalNaturalKeys, outWfoIdCampaignMap, false);</span>
	}

	public Map&lt;SchedulingPeriodExternalNaturalKey, ID&gt; convertToID(
			SystemType systemType,
			Collection&lt;SchedulingPeriodExternalNaturalKey&gt; schedulingPeriodExternalNaturalKeys,
			Map&lt;ID, Campaign&gt; outWfoIdCampaignMap,
			boolean useDEID)
					throws ServiceApplicationException {
		// Clear the external id cache in case its stale
<span class="nc" id="L424">		MapUtil.flushMap(systemType);</span>
		// Refresh the org name cache too in case its stale
<span class="nc" id="L426">		SyncUtil.getOrganizationIDsByNamesCaseInsensitive(Collections.emptyList(), workResourceManager, true);</span>

		// first pass.. collect the external campaign ids, and determine the earliest sp start date
<span class="nc" id="L429">		Date minDate = null;</span>
<span class="nc" id="L430">		Date maxDate = null;</span>
<span class="nc" id="L431">		Collection&lt;ID&gt; campaignExternalSourceIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>
<span class="nc" id="L433">			campaignExternalSourceIds.add(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L435">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>

<span class="nc" id="L437">			Date periodStartDate = schedulingPeriodExternalNaturalKey.getStartDate();</span>
			// TODO: one year is an extreme out guess... what is a realistic way to decide this?
<span class="nc" id="L439">			Date periodGuessEndDate = DateTimeUtil.getDateForDaysAfter(periodStartDate, +365);</span>
<span class="nc bnc" id="L440" title="All 2 branches missed.">			minDate = (minDate == null) ? periodStartDate : Collections.min(Arrays.asList(minDate, periodStartDate));</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">			maxDate = (maxDate == null) ? periodGuessEndDate : Collections.max(Arrays.asList(maxDate, periodGuessEndDate));</span>
<span class="nc" id="L442">		}</span>
		// Better safe than sorry one day tolerance, because of time zones
<span class="nc" id="L444">		minDate = DateTimeUtil.getDateForDaysAfter(minDate, -1);</span>
<span class="nc" id="L445">		maxDate = DateTimeUtil.getDateForDaysAfter(maxDate, +1);</span>

		// If there are no IDs in the collection, you're done!
<span class="nc" id="L448">		Map&lt;SchedulingPeriodExternalNaturalKey, ID&gt; result = new HashMap&lt;SchedulingPeriodExternalNaturalKey, ID&gt;();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">		if (campaignExternalSourceIds.isEmpty()) {</span>
<span class="nc" id="L450">			return result;</span>
		}

		Map&lt;ID, ID&gt; campaignExternalWfoIDMap;
		try {
<span class="nc" id="L455">			campaignExternalWfoIDMap = MapUtil.getExternalIDMap(</span>
					systemType,
					MapUtil.ObjectType.Campaign,
					campaignExternalSourceIds,
					true);
<span class="nc" id="L460">			outWfoIdCampaignMap.clear();</span>
<span class="nc" id="L461">			outWfoIdCampaignMap.putAll(getIDCampaignMap(campaignManager, campaignExternalWfoIDMap.values()));</span>
<span class="nc" id="L462">		} catch (JdmoException e) {</span>
<span class="nc" id="L463">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L464">		}</span>

<span class="nc" id="L466">		Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; naturalKeyOldSchedulingPeriodMap = buildNaturalKeySchedulingPeriodMap(</span>
<span class="nc" id="L467">				outWfoIdCampaignMap.keySet(), minDate, maxDate);</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>

			// Create a natural local key
<span class="nc" id="L471">			ID campaignID = campaignExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L473">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>
<span class="nc" id="L474">			Campaign campaign = outWfoIdCampaignMap.get(campaignID);</span>
<span class="nc" id="L475">			LocalDate startTimeLocal = new LocalDate(</span>
<span class="nc" id="L476">					schedulingPeriodExternalNaturalKey.startCalendarWithZone(campaign.getTimeZone()).getTime(),</span>
<span class="nc" id="L477">					campaign.getTimeZone());</span>
<span class="nc" id="L478">			LocalDate endTimeLocal = new LocalDate(CalendarUtil.convertMidnightDateToCalendarWithZone(</span>
<span class="nc" id="L479">					DateTimeUtil.getDateForDaysAfter(schedulingPeriodExternalNaturalKey.getStartDate(), 7),</span>
<span class="nc" id="L480">					campaign.getTimeZone()));</span>
<span class="nc" id="L481">			SchedPeriodNaturalKey schedPeriodNaturalKey = new SchedPeriodNaturalKey(campaignID, startTimeLocal, endTimeLocal);</span>

			// Get the scheduling period using the natural key
<span class="nc" id="L484">			SchedulingPeriod schedPeriod = naturalKeyOldSchedulingPeriodMap.get(schedPeriodNaturalKey);</span>
<span class="nc" id="L485">			ID schedPeriodID = null;</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">			if (schedPeriod != null) {</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">				if (useDEID) {</span>
<span class="nc" id="L488">					schedPeriodID = schedPeriod.getDEID();</span>
				} else {
<span class="nc" id="L490">					schedPeriodID = schedPeriod.getID();</span>
				}
			}
<span class="nc" id="L493">			result.put(schedulingPeriodExternalNaturalKey, schedPeriodID);</span>
<span class="nc" id="L494">		}</span>
<span class="nc" id="L495">		return result;</span>
	}

	@SuppressWarnings(&quot;deprecation&quot;)
	protected void convertToEntity(
			Collection&lt;SchedulingPeriodDTO&gt; noEditSchedulingPeriodDTOs,
			SystemType systemType,
			Collection&lt;SchedulingPeriodWithStuffWrapper&gt; newSchedulingPeriodWrappers,
			Collection&lt;SchedulingPeriodWithStuffWrapper&gt; oldSchedulingPeriodWrappers,
			List&lt;SchedulingPeriodNotPersistedInfo&gt; schedulingPeriodNotPersistedInfos)
					throws ServiceApplicationException {

		// First pass of scheduling period DTOs: collect all the wfo campaign ids based on external
		// campaign ids and we also need the wfo queue ids. We need a collection copy so that we can
		// safely remove invalid DTOs we can't persist
<span class="nc" id="L510">		Collection&lt;SchedulingPeriodDTO&gt; schedulingPeriodDTOs = new ArrayList&lt;SchedulingPeriodDTO&gt;(noEditSchedulingPeriodDTOs);</span>
<span class="nc" id="L511">		Collection&lt;ID&gt; campaignExternalSourceIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L512">		Collection&lt;ID&gt; queueExternalSourceIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L513">		List&lt;Date&gt; range = validateSchedulingPeriodDTOs(systemType, schedulingPeriodDTOs, schedulingPeriodNotPersistedInfos,</span>
				campaignExternalSourceIds, queueExternalSourceIds);
		// Load the scheduling periods for those campaigns
		// Better safe than sorry one day tolerance, because of time zones
<span class="nc" id="L517">		Date minDate = DateTimeUtil.getDateForDaysAfter(range.get(0), -1);</span>
<span class="nc" id="L518">		Date maxDate = DateTimeUtil.getDateForDaysAfter(range.get(1), +1);</span>

		// If there were no DTOs with sufficient data, you're done
<span class="nc bnc" id="L521" title="All 2 branches missed.">		if (schedulingPeriodDTOs.isEmpty()) {</span>
<span class="nc" id="L522">			return;</span>
		}

		Map&lt;ID, ID&gt; campaignExternalWfoIDMap;
		Map&lt;ID, ID&gt; queueExternalWfoIDMap;
		try {
<span class="nc" id="L528">			campaignExternalWfoIDMap = MapUtil.getExternalIDMap(systemType, MapUtil.ObjectType.Campaign,</span>
					campaignExternalSourceIds, true);
<span class="nc" id="L530">			queueExternalWfoIDMap = MapUtil.getExternalIDMap(systemType, MapUtil.ObjectType.Queue,</span>
					queueExternalSourceIds, true);
<span class="nc" id="L532">		} catch (JdmoException e) {</span>
<span class="nc" id="L533">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L534">		}</span>

		// Load from database all campaigns of the scheduling periods: we need their time zones
<span class="nc" id="L537">		Map&lt;ID, Campaign&gt; wfoIDCampaignMap = getIDCampaignMap(campaignManager, campaignExternalWfoIDMap.values());</span>

		// Also load from database all the Scheduling periods and Hours that already exist, so we can sort new and old.
<span class="nc" id="L540">		Map&lt;ID, Collection&lt;CalendarRange&gt;&gt; campaignIDToSPIntervals = new HashMap&lt;ID, Collection&lt;CalendarRange&gt;&gt;();</span>
<span class="nc" id="L541">		Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; naturalKeyOldSchedulingPeriodMap = buildNaturalKeySchedulingPeriodMapWithCampaignIdMap(</span>
<span class="nc" id="L542">				wfoIDCampaignMap.keySet(), minDate, maxDate, campaignIDToSPIntervals);</span>
		// We may want to validate the scheduling period dtos do not overlap existing scheduling periods while building the map
		// instead of using campaignIDToSPIntervals.

		// TODO naturalKeyOldSchedulingPeriodHooMap does not need to be built yet, move to ConvertHOO, and
		// remove from ConvertSchedulingPeriodDTOParameters class.
		// The same is true for the OldSPQueueMap and IDQueueMap.
<span class="nc" id="L549">		Map&lt;SchedPeriodHOONaturalKey, CampaignHOO&gt; naturalKeyOldSchedulingPeriodHooMap = buildNaturalKeySchedulingPeriodHooMap(</span>
<span class="nc" id="L550">				wfoIDCampaignMap.keySet(), minDate, maxDate);</span>
<span class="nc" id="L551">		Map&lt;SPQueueNaturalKey, SPQueue&gt; naturalKeyOldSPQueueMap = buildNaturalKeySchedulingPeriodQueueMap(</span>
<span class="nc" id="L552">				naturalKeyOldSchedulingPeriodMap.values());</span>

		// We need to load all relevant queues from database, for reading their media ids
<span class="nc" id="L555">		Map&lt;ID, Queue&gt; wfoIDQueueMap = buildIDQueueMap(queueExternalWfoIDMap.values());</span>

		// Second and main pass of scheduling period DTOs: copy scheduling period and hours of
		// operation data over to entity objects
<span class="nc" id="L559">		Collection&lt;SchedulingPeriodWithStuffWrapper&gt; allSchedulingPeriodWrappers = new ArrayList&lt;SchedulingPeriodWithStuffWrapper&gt;();</span>

<span class="nc bnc" id="L561" title="All 2 branches missed.">		for (Iterator&lt;SchedulingPeriodDTO&gt; iterator = schedulingPeriodDTOs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L562">			SchedulingPeriodDTO schedulingPeriodDTO = iterator.next();</span>

			// Scheduling Period Validation
			// We will create exception info; only add to collection if there is an exception
<span class="nc" id="L566">			SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo = new SchedulingPeriodNotPersistedInfo(</span>
<span class="nc" id="L567">					schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey());</span>

<span class="nc bnc" id="L569" title="All 2 branches missed.">			if (CollectionUtils.isEmpty(schedulingPeriodDTO.getOrganizationNames())) {</span>
<span class="nc" id="L570">				schedulingPeriodNotPersistedInfo.addOrganizationNamesMissingMessage();</span>
			}

			// Organization ids have to be converted from external to local
<span class="nc" id="L574">			Map&lt;String, ID&gt; organizationIDsByNameMap = SyncUtil.getOrganizationIDsByNamesCaseInsensitive(</span>
<span class="nc" id="L575">					schedulingPeriodDTO.getOrganizationNames(), workResourceManager, false);</span>
			// lets see if there are any names for which an org doesn't exist
<span class="nc bnc" id="L577" title="All 2 branches missed.">			for (Map.Entry&lt;String, ID&gt; nameWithID : organizationIDsByNameMap.entrySet()) {</span>
<span class="nc bnc" id="L578" title="All 2 branches missed.">				if (nameWithID.getValue() == null) {</span>
<span class="nc" id="L579">					schedulingPeriodNotPersistedInfo.addNoSuchOrganizatonNameMessage(nameWithID.getKey());</span>
				}
<span class="nc" id="L581">			}</span>
<span class="nc" id="L582">			ID wfoCampaignSID = campaignExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L584">					schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getCampaignExternalSourceId()));</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">			if (wfoCampaignSID == null) {</span>
<span class="nc" id="L586">				schedulingPeriodNotPersistedInfo.addNoSuchCampaignExternalIdMessage();</span>
<span class="nc" id="L587">				continue;</span>
<span class="nc bnc" id="L588" title="All 2 branches missed.">			} else if (wfoIDCampaignMap.get(wfoCampaignSID) == null) {</span>
<span class="nc" id="L589">				schedulingPeriodNotPersistedInfo.addSchedulingPeriodServerExceptionMessage(</span>
						&quot;An unknown application bug has resulted in scheduling period's campaign not loading.&quot;);
<span class="nc" id="L591">				continue;</span>
			}

<span class="nc" id="L594">			ConvertSchedulingPeriodDTOParameters parameters = new ConvertSchedulingPeriodDTOParameters(</span>
					systemType,
					wfoCampaignSID,
					iterator,
					schedulingPeriodDTO,
					schedulingPeriodNotPersistedInfo,
					new ConvertSchedulingPeriodDTOCollectionParameters(schedulingPeriodNotPersistedInfos,
							newSchedulingPeriodWrappers,
							oldSchedulingPeriodWrappers,
							allSchedulingPeriodWrappers),
					new ConvertSchedulingPeriodDTOMapParameters(
							organizationIDsByNameMap,
							wfoIDCampaignMap,
							queueExternalWfoIDMap,
							wfoIDQueueMap,
							naturalKeyOldSchedulingPeriodMap,
							naturalKeyOldSchedulingPeriodHooMap,
							naturalKeyOldSPQueueMap)
			);

<span class="nc" id="L614">			Campaign campaign = parameters.getCampaign();</span>
<span class="nc" id="L615">			Calendar schedulingPeriodStart = schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().startCalendarWithZone(</span>
<span class="nc" id="L616">					campaign.getTimeZone());</span>
<span class="nc" id="L617">			validateStartOfWeekWithCampaign(schedulingPeriodStart, campaign, parameters.getSchedulingPeriodNotPersistedInfo());</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">			if (wrapSchedulingPeriodDTO(parameters, campaignIDToSPIntervals)) {</span>
<span class="nc" id="L620">				validateAndConvertSchedulingPeriodDTO(parameters);</span>
			}
<span class="nc" id="L622">		}</span>
		// end of SchedulingPeriodDTO main loop
<span class="nc" id="L624">	}</span>

	private boolean wrapSchedulingPeriodDTO(ConvertSchedulingPeriodDTOParameters parameters,
			Map&lt;ID, Collection&lt;CalendarRange&gt;&gt; campaignIDToSPIntervals)
					throws ServiceApplicationException {
<span class="nc" id="L629">		SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper = new SchedulingPeriodWithStuffWrapper();</span>
<span class="nc" id="L630">		parameters.getAllSchedulingPeriodWrappers().add(schedulingPeriodWrapper);</span>
<span class="nc" id="L631">		SchedulingPeriod schedulingPeriod = new SchedulingPeriod();</span>
<span class="nc" id="L632">		schedulingPeriodWrapper.setSchedulingPeriod(schedulingPeriod);</span>

<span class="nc" id="L634">		schedulingPeriod.setCampaignID(parameters.getWfoCampaignSID());</span>
<span class="nc" id="L635">		schedulingPeriod.setManualFteRequirementsMode(true);</span>
		// Note: name and end date will be set below based on the size of collection hoursOfOperationDTOs
<span class="nc" id="L637">		schedulingPeriod.setDescription(&quot;synched at time &quot; + Calendar.getInstance().getTime());</span>
<span class="nc" id="L638">		schedulingPeriod.setStartTimeLocal(new LocalDate(</span>
<span class="nc" id="L639">				parameters.getSchedulingPeriodDTO().getSchedulingPeriodExternalNaturalKey().startCalendarWithZone(</span>
<span class="nc" id="L640">						parameters.getCampaign().getTimeZone()).getTime(),</span>
<span class="nc" id="L641">				parameters.getCampaign().getTimeZone()));</span>
<span class="nc" id="L642">		schedulingPeriod.setSkillBased(parameters.getSchedulingPeriodDTO().isSkillBased());</span>
<span class="nc" id="L643">		schedulingPeriod.setOrgs(parameters.getOrganizationIDsByNameMap().values());</span>
<span class="nc" id="L644">		schedulingPeriod.setUsingAllEmployees(parameters.getSchedulingPeriodDTO().isUsingAllEmployees());</span>


		// Assign id to schedulingPeriod (when it already exists)
		// And we then know whether it will be new/create or old/update
		//We are assuming a week long SP here but later we set the end time based on the HOO.
<span class="nc" id="L650">		schedulingPeriod.setEndTimeLocal(new LocalDate(CalendarUtil.convertMidnightDateToCalendarWithZone(</span>
<span class="nc" id="L651">				DateTimeUtil.getDateForDaysAfter(</span>
<span class="nc" id="L652">						parameters.getSchedulingPeriodDTO().getSchedulingPeriodExternalNaturalKey().getStartDate(), 7),</span>
<span class="nc" id="L653">				parameters.getCampaign().getTimeZone())));</span>
<span class="nc" id="L654">		SchedPeriodNaturalKey schedPeriodNaturalKey = new SchedPeriodNaturalKey(</span>
<span class="nc" id="L655">				parameters.getWfoCampaignSID(),</span>
<span class="nc" id="L656">				schedulingPeriod.getStartTimeLocal(),</span>
<span class="nc" id="L657">				schedulingPeriod.getEndTimeLocal());</span>
<span class="nc" id="L658">		Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; keyToExistingSPMap = parameters.getNaturalKeyOldSchedulingPeriodMap();</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">		ID wfoSchedPeriodID = keyToExistingSPMap.get(schedPeriodNaturalKey) != null</span>
<span class="nc" id="L660">				? keyToExistingSPMap.get(schedPeriodNaturalKey).getID() : null;</span>
<span class="nc" id="L661">		CAT.debug(&quot;wfoSchedPeriodID: &quot; + wfoSchedPeriodID);</span>
<span class="nc" id="L662">		parameters.setSchedulingPeriodWithStuffWrapper(schedulingPeriodWrapper);</span>
<span class="nc bnc" id="L663" title="All 2 branches missed.">		if (wfoSchedPeriodID != null) {</span>
<span class="nc" id="L664">			schedulingPeriod.setID(wfoSchedPeriodID);</span>
<span class="nc" id="L665">			parameters.getOldSchedulingPeriodWrappers().add(schedulingPeriodWrapper);</span>
<span class="nc" id="L666">			return true;</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">		} else if ( ! isSchedulingPeriodDTOOverlapExisting(parameters, campaignIDToSPIntervals) ) {</span>
<span class="nc" id="L668">			parameters.getNewSchedulingPeriodWrappers().add(schedulingPeriodWrapper);</span>
<span class="nc" id="L669">			return true;</span>
		}
<span class="nc" id="L671">		return false;</span>
	}

	private boolean isSchedulingPeriodDTOOverlapExisting(
			ConvertSchedulingPeriodDTOParameters parameters,
			Map&lt;ID, Collection&lt;CalendarRange&gt;&gt; campaignIDToSPIntervals) {
<span class="nc" id="L677">		SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper = parameters.getSchedulingPeriodWithStuffWrapper();</span>
<span class="nc" id="L678">		SchedulingPeriod schedulingPeriod = schedulingPeriodWrapper.getSchedulingPeriod();</span>
<span class="nc" id="L679">		TimeZone timeZone = parameters.getCampaign().getTimeZone();</span>
<span class="nc" id="L680">		TimeRange spRange = new TimeRange(</span>
<span class="nc" id="L681">				schedulingPeriod.getStartTimeLocal().getTime(timeZone),</span>
<span class="nc" id="L682">				schedulingPeriod.getEndTimeLocal().getTime(timeZone));</span>
<span class="nc" id="L683">		Collection&lt;CalendarRange&gt; existingSPRangeCollection = campaignIDToSPIntervals.get(parameters.getCampaign().getID());</span>
<span class="nc bnc" id="L684" title="All 2 branches missed.">		if (existingSPRangeCollection != null) {</span>
<span class="nc bnc" id="L685" title="All 2 branches missed.">			for (CalendarRange existingSPRange : existingSPRangeCollection ) {</span>
<span class="nc" id="L686">				TimeRange overlapInterval = existingSPRange.getOverlapInterval(spRange);</span>
<span class="nc bnc" id="L687" title="All 4 branches missed.">				if ( overlapInterval != null &amp;&amp; overlapInterval.getDurationMin() &gt; 0) {</span>
<span class="nc" id="L688">					SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo = parameters.getSchedulingPeriodNotPersistedInfo();</span>
<span class="nc" id="L689">					schedulingPeriodNotPersistedInfo.logAndAddError(</span>
							CAT,
<span class="nc" id="L691">							schedulingPeriodNotPersistedInfo.getTimePeriodOverlap(schedulingPeriod.getCampaignID()));</span>
<span class="nc" id="L692">					parameters.getSchedulingPeriodNotPersistedInfos().add(schedulingPeriodNotPersistedInfo);</span>
<span class="nc" id="L693">					return true;</span>
				}
<span class="nc" id="L695">			}</span>
		}
<span class="nc" id="L697">		return false;</span>
	}

	private void validateAndConvertSchedulingPeriodDTO(ConvertSchedulingPeriodDTOParameters parameters)
			throws ServiceApplicationException {
<span class="nc" id="L702">		SchedulingPeriodDTO schedulingPeriodDTO = parameters.getSchedulingPeriodDTO();</span>
		//Scheduling Period validation should be consolidated.

<span class="nc" id="L705">		validateSPQueueDTOsAndConvertServiceGoalType(</span>
<span class="nc" id="L706">				parameters.getSystemType(),</span>
<span class="nc" id="L707">				parameters.getQueueExternalWfoIDMap(),</span>
				schedulingPeriodDTO,
<span class="nc" id="L709">				parameters.getSchedulingPeriodNotPersistedInfo());</span>

<span class="nc bnc" id="L711" title="All 2 branches missed.">		if (!parameters.getSchedulingPeriodNotPersistedInfo().getMessages().isEmpty()) {</span>
<span class="nc" id="L712">			CAT.error(&quot;User error: Scheduling Period entity will not be persisted&quot;);</span>
<span class="nc" id="L713">			parameters.getSchedulingPeriodNotPersistedInfos().add(parameters.getSchedulingPeriodNotPersistedInfo());</span>
<span class="nc" id="L714">			parameters.getSchedulingPeriodDTOIterator().remove();</span>
		} else {
<span class="nc" id="L716">			convertSchedulingPeriodDTO(parameters);</span>
		}
<span class="nc" id="L718">	}</span>

	private void validateStartOfWeekWithCampaign(
			Calendar schedulingPeriodStart, Campaign campaign, SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo) {
<span class="nc bnc" id="L722" title="All 2 branches missed.">		if (schedulingPeriodStart.get(Calendar.DAY_OF_WEEK) != CampaignServiceDelegate.campaignWeekStartMinutesToDayOfWeek(</span>
<span class="nc" id="L723">				campaign.getWeekStart())) {</span>
<span class="nc" id="L724">			schedulingPeriodNotPersistedInfo.addStartDateInKeyNotOnCampaignWeekStartMessage(</span>
					schedulingPeriodStart,
<span class="nc" id="L726">					CampaignServiceDelegate.campaignWeekStartMinutesToDayOfWeek(campaign.getWeekStart()));</span>
		}
<span class="nc" id="L728">	}</span>

	private void validateSPQueueDTOsAndConvertServiceGoalType(SystemType systemType,
			Map&lt;ID, ID&gt; queueExternalWfoIDMap,
			SchedulingPeriodDTO schedulingPeriodDTO,
			SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo)
					throws ServiceApplicationException {
<span class="nc bnc" id="L735" title="All 2 branches missed.">		if (schedulingPeriodDTO.getSchedulingPeriodQueueDTOs() != null) {</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">			for (SchedulingPeriodQueueDTO schedulingPeriodQueueDTO : schedulingPeriodDTO.getSchedulingPeriodQueueDTOs()) {</span>

				// Validate queueSchedulingPeriodMapDTO as much as possible before using it
<span class="nc" id="L739">				schedulingPeriodQueueDTO.validate(schedulingPeriodNotPersistedInfo);</span>

				// Does the queue exist?
<span class="nc" id="L742">				ID wfoQueueSID = queueExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
						systemType,
<span class="nc" id="L744">						schedulingPeriodQueueDTO.getQueueExternalSourceId()));</span>
<span class="nc bnc" id="L745" title="All 2 branches missed.">				if (wfoQueueSID == null) {</span>
<span class="nc" id="L746">					schedulingPeriodNotPersistedInfo.addNoSuchQueueExternalIdMessage(</span>
<span class="nc" id="L747">							schedulingPeriodQueueDTO.getQueueExternalSourceId());</span>
				}

<span class="nc bnc" id="L750" title="All 2 branches missed.">				if (schedulingPeriodQueueDTO.getSkillExternalSourceId() != null) {</span>
					try {
<span class="nc" id="L752">						ID wfoSkillSID = MapUtil.getExternalToWfoID(</span>
								systemType,
								MapUtil.ObjectType.Skill,
<span class="nc" id="L755">								ExternalIDUtil.buildExternalID(systemType, schedulingPeriodQueueDTO.getSkillExternalSourceId()));</span>
<span class="nc bnc" id="L756" title="All 2 branches missed.">						if (wfoSkillSID == null) {</span>
<span class="nc" id="L757">							schedulingPeriodNotPersistedInfo.addNoSuchSkillExternalIdMessage(</span>
<span class="nc" id="L758">									schedulingPeriodQueueDTO.getSkillExternalSourceId());</span>
						}
<span class="nc" id="L760">					} catch (NumberFormatException e) {</span>
<span class="nc" id="L761">						throw new ServiceApplicationException(e);</span>
<span class="nc" id="L762">					} catch (JdmoException e) {</span>
<span class="nc" id="L763">						throw new ServiceApplicationException(e);</span>
<span class="nc" id="L764">					}</span>
				}

				// Verify that service goal type exists. or else info gets some state added
<span class="nc" id="L768">				convertToServiceLevelGoalType(schedulingPeriodQueueDTO.getServiceGoalType(), schedulingPeriodNotPersistedInfo);</span>
<span class="nc" id="L769">			}</span>
		}
<span class="nc" id="L771">	}</span>

	private void convertSchedulingPeriodDTO(ConvertSchedulingPeriodDTOParameters parameters)
			throws ServiceApplicationException {
<span class="nc" id="L775">		SchedulingPeriodDTO schedulingPeriodDTO = parameters.getSchedulingPeriodDTO();</span>
<span class="nc" id="L776">		SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper = parameters.getSchedulingPeriodWithStuffWrapper();</span>
<span class="nc" id="L777">		SchedulingPeriod schedulingPeriod = schedulingPeriodWrapper.getSchedulingPeriod();</span>
<span class="nc" id="L778">		Campaign campaign = parameters.getCampaign();</span>

		// Get hours of operation for each week
<span class="nc" id="L781">		Calendar weekStartWithZone = schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().startCalendarWithZone(</span>
<span class="nc" id="L782">				campaign.getTimeZone());</span>
<span class="nc" id="L783">		Calendar weekEndWithZone = (Calendar) weekStartWithZone.clone();</span>
<span class="nc" id="L784">		weekEndWithZone.add(Calendar.DATE, SchedulingPeriodServiceDelegate.DAYS_IN_WEEK);</span>
<span class="nc" id="L785">		convertHOO(</span>
<span class="nc" id="L786">				parameters.getNaturalKeyOldSchedulingPeriodHooMap(),</span>
				schedulingPeriodDTO,
<span class="nc" id="L788">				parameters.getWfoCampaignSID(),</span>
				campaign,
				schedulingPeriodWrapper,
				weekStartWithZone,
				weekEndWithZone);

		// We use the last end date of the HOO as the end date of the scheduling period :)
<span class="nc" id="L795">		DateFormat localZoneFormat = new SimpleDateFormat(DATE_FORMAT);</span>
<span class="nc" id="L796">		localZoneFormat.setTimeZone(parameters.getCampaign().getTimeZone());</span>
<span class="nc" id="L797">		schedulingPeriod.setName(localZoneFormat.format(weekStartWithZone.getTime()) + &quot;To&quot;</span>
<span class="nc" id="L798">				+ localZoneFormat.format(weekEndWithZone.getTime()));</span>
		//TODO if the end time is changed, another validation check should be made to ensure the does not overlap existing SPs.
		//Current assumption is SPs are only a week long.
<span class="nc" id="L801">		schedulingPeriod.setEndTimeLocal(new LocalDate(weekEndWithZone.getTime(),</span>
<span class="nc" id="L802">				parameters.getCampaign().getTimeZone()));</span>

<span class="nc bnc" id="L804" title="All 2 branches missed.">		if (schedulingPeriodDTO.getSchedulingPeriodQueueDTOs() != null) {</span>
<span class="nc" id="L805">			convertSPQueues(parameters);</span>
		}
<span class="nc" id="L807">	}</span>

	private void convertHOO(
			Map&lt;SchedPeriodHOONaturalKey, CampaignHOO&gt; naturalKeyOldSchedulingPeriodHooMap,
			SchedulingPeriodDTO schedulingPeriodDTO,
			ID wfoCampaignSID,
			Campaign campaign,
			SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper,
			Calendar weekStartWithZone,
			Calendar weekEndWithZone)
					throws ServiceApplicationException {
<span class="nc" id="L818">		SchedulingPeriod schedulingPeriod = schedulingPeriodWrapper.getSchedulingPeriod();</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">		if (schedulingPeriodDTO.getHoursOfOperationDTOs() != null) {</span>
<span class="nc" id="L820">			boolean isFirstIteration = true;</span>
<span class="nc" id="L821">			List&lt;CampaignHOO&gt; campaignHOOs = new ArrayList&lt;CampaignHOO&gt;();</span>
<span class="nc bnc" id="L822" title="All 2 branches missed.">			for (HoursOfOperationDTO schedulingWeekDTO : schedulingPeriodDTO.getHoursOfOperationDTOs()) {</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">				if (!isFirstIteration) {</span>
<span class="nc" id="L824">					weekStartWithZone.add(Calendar.DATE, SchedulingPeriodServiceDelegate.DAYS_IN_WEEK);</span>
<span class="nc" id="L825">					weekEndWithZone.add(Calendar.DATE, SchedulingPeriodServiceDelegate.DAYS_IN_WEEK);</span>
				}

				// Set hours of operation for the days in scheduling period (Day Open and CLose)
				// based on the week start day of the SP and not from Sunday to Saturday
<span class="nc" id="L830">				CampaignHOO campaignHOO = new CampaignHOO();</span>
<span class="nc" id="L831">				campaignHOO.setCampaignID(wfoCampaignSID);</span>
<span class="nc" id="L832">				int weekStartDay = CampaignServiceDelegate.campaignWeekStartMinutesToDayOfWeek(campaign.getWeekStart());</span>
<span class="nc" id="L833">				int j = 1;</span>
<span class="nc bnc" id="L834" title="All 2 branches missed.">				for (short i = 1; i &lt;= SchedulingPeriodServiceDelegate.DAYS_IN_WEEK; i++) {</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">					if(weekStartDay != Calendar.SUNDAY) {</span>
<span class="nc" id="L836">						j = weekStartDay + i - 1;</span>
<span class="nc bnc" id="L837" title="All 2 branches missed.">						if(j &gt; SchedulingPeriodServiceDelegate.DAYS_IN_WEEK) {</span>
<span class="nc" id="L838">							j = j - SchedulingPeriodServiceDelegate.DAYS_IN_WEEK;</span>
						}
					} else {
<span class="nc" id="L841">						j = i;</span>
					}
<span class="nc" id="L843">					campaignHOO.setDayOpen((short) j, (short) (schedulingWeekDTO.getDayOpen()[i]));</span>
<span class="nc" id="L844">					campaignHOO.setDayClose((short) j, (short) (schedulingWeekDTO.getDayClose()[i]));</span>
				}
<span class="nc" id="L846">				campaignHOO.setStartTimeLocal(new LocalDate(weekStartWithZone.getTime(), campaign.getTimeZone()));</span>
<span class="nc" id="L847">				campaignHOO.setEndTimeLocal(new LocalDate(weekEndWithZone.getTime(), campaign.getTimeZone()));</span>
<span class="nc" id="L848">				campaignHOOs.add(campaignHOO);</span>

				// Hours of operation validation TODO complete
				// If scheduling period is old, campaignHOO might be old too.. then try
				// to assign id to CampaignHOO (when it already exists) And we then know
				// whether it will be new/create or old/update
<span class="nc" id="L854">				ID wfoSchedPeriodHOOID = null;</span>
<span class="nc bnc" id="L855" title="All 2 branches missed.">				if (schedulingPeriod.getID() != null) {</span>
<span class="nc" id="L856">					SchedPeriodHOONaturalKey HOOKey = new SchedPeriodHOONaturalKey(</span>
							wfoCampaignSID,
<span class="nc" id="L858">							schedulingPeriod.getID(),</span>
<span class="nc" id="L859">							campaignHOO.getStartTimeLocal());</span>
<span class="nc" id="L860">					CampaignHOO preUpdateSchedulePeriodHOO = naturalKeyOldSchedulingPeriodHooMap.get(HOOKey);</span>
<span class="nc" id="L861">					CAT.debug(&quot;preUpdateSchedulePeriodHOO: &quot; + preUpdateSchedulePeriodHOO);</span>
<span class="nc bnc" id="L862" title="All 2 branches missed.">					wfoSchedPeriodHOOID = (preUpdateSchedulePeriodHOO == null) ? null</span>
<span class="nc" id="L863">							: preUpdateSchedulePeriodHOO.getID();</span>
<span class="nc" id="L864">					CAT.debug(&quot;wfoSchedPeriodHOOID: &quot; + wfoSchedPeriodHOOID);</span>
				}
<span class="nc bnc" id="L866" title="All 2 branches missed.">				if (wfoSchedPeriodHOOID != null) {</span>
<span class="nc" id="L867">					campaignHOO.setID(wfoSchedPeriodHOOID);</span>
<span class="nc" id="L868">					schedulingPeriodWrapper.getOldCampaignHOOs().add(campaignHOO);</span>
				} else {
<span class="nc" id="L870">					schedulingPeriodWrapper.getNewCampaignHOOs().add(campaignHOO);</span>
				}
<span class="nc" id="L872">				isFirstIteration = false;</span>
<span class="nc" id="L873">			}</span>
			// end of CampaignHOO loop
		}
		// end if CampaignHOOs not null
<span class="nc" id="L877">	}</span>

	private void convertSPQueues(ConvertSchedulingPeriodDTOParameters parameters)
			throws ServiceApplicationException {
<span class="nc" id="L881">		SystemType systemType = parameters.getSystemType();</span>
<span class="nc" id="L882">		Map&lt;ID, ID&gt; queueExternalWfoIDMap = parameters.getQueueExternalWfoIDMap();</span>
<span class="nc" id="L883">		Map&lt;SPQueueNaturalKey, SPQueue&gt; naturalKeyOldSPQueueMap = parameters.getNaturalKeyOldSPQueueMap();</span>
<span class="nc" id="L884">		Map&lt;ID, Queue&gt; wfoIDQueueMap = parameters.getWfoIDQueueMap();</span>
<span class="nc" id="L885">		SchedulingPeriodDTO schedulingPeriodDTO = parameters.getSchedulingPeriodDTO();</span>
<span class="nc" id="L886">		SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo = parameters.getSchedulingPeriodNotPersistedInfo();</span>
<span class="nc" id="L887">		Campaign campaign = parameters.getCampaign();</span>
<span class="nc" id="L888">		SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper = parameters.getSchedulingPeriodWithStuffWrapper();</span>
<span class="nc" id="L889">		SchedulingPeriod schedulingPeriod = schedulingPeriodWrapper.getSchedulingPeriod();</span>
<span class="nc" id="L890">		ID wfoSchedPeriodID = schedulingPeriod.getID();</span>
		// Get the linked Queue information for each week, converting to entity SPQueue
<span class="nc" id="L892">		List&lt;SPQueueWithServiceGoalsWrapper&gt; spQueueWrappers = new ArrayList&lt;SPQueueWithServiceGoalsWrapper&gt;();</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">		for (SchedulingPeriodQueueDTO schedulingPeriodQueueDTO : schedulingPeriodDTO.getSchedulingPeriodQueueDTOs()) {</span>

			// Create the spQueue and associated wrapper
<span class="nc" id="L896">			SPQueue spQueue = new SPQueue();</span>
<span class="nc" id="L897">			SPQueueWithServiceGoalsWrapper spQueueWrapper = new SPQueueWithServiceGoalsWrapper();</span>
<span class="nc" id="L898">			spQueueWrapper.setSPQueue(spQueue);</span>
<span class="nc" id="L899">			spQueueWrappers.add(spQueueWrapper);</span>
<span class="nc" id="L900">			setSPQueueIDsAndAddToWrappedCollections(systemType,</span>
					queueExternalWfoIDMap,
					naturalKeyOldSPQueueMap,
					schedulingPeriodWrapper,
					wfoSchedPeriodID,
					schedulingPeriodQueueDTO,
					spQueueWrapper);

			// Note: Create will use the media from queue, but update will not
<span class="nc" id="L909">			spQueue.setMediaID(wfoIDQueueMap.get(spQueue.getQueueID()).getMediaID());</span>
<span class="nc" id="L910">			setSPQueueSkills(systemType, spQueue, schedulingPeriodQueueDTO);</span>

			// Note: false means SERVICE_LEVEL_ANSWER_TIME...its a bit counter-intuitive.
<span class="nc" id="L913">			spQueue.setServiceLevelGoalType(convertToServiceLevelGoalType(</span>
<span class="nc" id="L914">					schedulingPeriodQueueDTO.getServiceGoalType(),</span>
					schedulingPeriodNotPersistedInfo));

			// Handle service goal constant properties, based on goal type
			// Reminder: for this release we only handle constant service goals!
<span class="nc bnc" id="L919" title="All 2 branches missed.">			if (schedulingPeriodQueueDTO.getServiceGoalType().trim().equals(SchedulingPeriodQueueDTO.SERVICE_LEVEL_ANSWER_TIME)) {</span>
<span class="nc" id="L920">				spQueue.setSlAnswerWaitingTime(</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">						schedulingPeriodQueueDTO.getServiceLevelAnswerTime() == null ? 0</span>
<span class="nc" id="L922">								: schedulingPeriodQueueDTO.getServiceLevelAnswerTime().intValue());</span>
			}
			//do nothing if the DTO's ServiceGoalType is AVERAGE_ANSWER_TIME. Everything is a time series, there are no scalars.

<span class="nc" id="L926">			spQueue.setPatience(schedulingPeriodQueueDTO.getAbandonmentTime());</span>

<span class="nc" id="L928">			ServiceGoalDTO serviceGoalDTO = schedulingPeriodQueueDTO.getServiceGoalDTO();</span>
<span class="nc" id="L929">			ServiceGoalSeriesDTO serviceGoalSeriesDTO = schedulingPeriodQueueDTO.getServiceGoalSeriesDTO();</span>

<span class="nc" id="L931">			List&lt;HoursOfOperationDTO&gt; hoursOfOperationDTOs =</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">					CollectionUtils.isEmpty(schedulingPeriodQueueDTO.getOverrideHoursOfOperationDTOs())</span>
<span class="nc" id="L933">							? schedulingPeriodDTO.getHoursOfOperationDTOs()</span>
<span class="nc" id="L934">							: schedulingPeriodQueueDTO.getOverrideHoursOfOperationDTOs();</span>

			// Warning: For these hourly calculations, we really need dates stated
			// in local time zone, not GMT time zone. Later in preparation for
			// persisting the dates, we will convert them to GMT dates :( somewhat confusing
<span class="nc" id="L939">			LinkedHashMap&lt;Calendar, Boolean&gt; onOffHoursMap = TimePeriodUtil.buildOnOffHoursMap(</span>
<span class="nc" id="L940">					schedulingPeriod.getStartTimeLocal().getCalendar(campaign.getTimeZone()),</span>
<span class="nc" id="L941">					schedulingPeriod.getEndTimeLocal().getCalendar(campaign.getTimeZone()),</span>
					hoursOfOperationDTOs);

			//Store the dates for the time series records in a hash set.  We do this because we want
			//to ensure that we aren't creating two data points with the same spqueue + datetime combination
			//(which can happen in a fall DST transition with the code below).
<span class="nc" id="L947">			HashSet&lt;Date&gt; gmtDateHash = new HashSet&lt;Date&gt;();</span>
<span class="nc bnc" id="L948" title="All 2 branches missed.">			if (!spQueueWrapper.getSPQueue().getServiceLevelGoalType()) {</span>
<span class="nc" id="L949">				boolean hasSLError = false;</span>
				// Remember: false means service level... I'm dizzy :(
<span class="nc" id="L951">				List&lt;ServiceLevelPercentTimeSeriesDataItem&gt; serviceGoalsTimeSeries =</span>
						new ArrayList&lt;ServiceLevelPercentTimeSeriesDataItem&gt;();
<span class="nc" id="L953">				int serviceLevelPercentConstant = Integer.MIN_VALUE;</span>
<span class="nc" id="L954">				int[] slPercent = null;</span>
<span class="nc bnc" id="L955" title="All 2 branches missed.">				if(serviceGoalDTO!=null){</span>
<span class="nc" id="L956">					 serviceLevelPercentConstant = serviceGoalDTO.getServiceLevelPercent();</span>
				} else {
<span class="nc" id="L958">					String serviceLevelPercentEncoded = serviceGoalSeriesDTO.getServiceLevelPercentSeriesEncoded();</span>
					// check if there are adequate number
<span class="nc" id="L960">					int daysInPeriod = DateTimeUtil.daysBetween(</span>
<span class="nc" id="L961">							schedulingPeriod.getStartTimeLocal().getCalendar(campaign.getTimeZone()),</span>
<span class="nc" id="L962">							schedulingPeriod.getEndTimeLocal().getCalendar(campaign.getTimeZone()));</span>
<span class="nc" id="L963">					slPercent = EncodeUtil.base64ToInt(serviceLevelPercentEncoded);</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">					if (slPercent.length != daysInPeriod * HOUR_PER_DAY) {</span>
<span class="nc" id="L965">						CAT.debug(&quot;ServiceLevelPercentTimeSeriesDataItem not created for sp queue: &quot;</span>
<span class="nc" id="L966">								+ spQueueWrapper.getSPQueue().getID()</span>
								+ &quot;. In Scheduling period &quot;
<span class="nc" id="L968">								+ schedulingPeriod.getID()</span>
								+ &quot;has a service level time series of length &quot;
<span class="nc" id="L970">								+ serviceLevelPercentEncoded.length()</span>
								+ &quot; which is not the same as &quot;+HOUR_PER_DAY+&quot; times the number of days &quot;
								+ daysInPeriod
<span class="nc" id="L973">								+ &quot; in the scheduling period for the queue &quot;+spQueueWrapper.getSPQueue().getID());</span>
<span class="nc" id="L974">						hasSLError = true;</span>
					}
				}

<span class="nc bnc" id="L978" title="All 2 branches missed.">				if (!hasSLError) {</span>
<span class="nc" id="L979">					int counter = 0;</span>
<span class="nc bnc" id="L980" title="All 2 branches missed.">					for (Map.Entry&lt;Calendar, Boolean&gt; dateOnOff : onOffHoursMap.entrySet()) {</span>
						// The database needs each date in GMT format
<span class="nc" id="L982">						LocalDate temp = new LocalDate(</span>
<span class="nc" id="L983">								dateOnOff.getKey().getTime(),</span>
<span class="nc" id="L984">								campaign.getTimeZone());</span>
<span class="nc" id="L985">						Date gmtDate = com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil</span>
<span class="nc" id="L986">								.convertToGMTFromLocalDateTimeInTimeZone(</span>
										temp,
<span class="nc" id="L988">										campaign.getTimeZone());</span>
						// Don't create a data item if we've already created one for the current datetime
<span class="nc bnc" id="L990" title="All 2 branches missed.">						if (gmtDateHash.contains(gmtDate)) {</span>
<span class="nc" id="L991">							CAT.debug(&quot;ServiceLevelPercentTimeSeriesDataItem not created for date: &quot;</span>
									+ gmtDate
									+ &quot;. &quot;
									+ &quot;Data item was already created for that date for SPQueue ID: &quot;
<span class="nc" id="L995">									+ spQueueWrapper.getSPQueue().getID()</span>
									+ &quot;.  This was likely due to a DST transition.&quot;);
						} else {
<span class="nc" id="L998">							gmtDateHash.add(gmtDate);</span>
<span class="nc" id="L999">							int curSLPercent = 0;</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">							if (serviceGoalDTO != null) {</span>
<span class="nc" id="L1001">								curSLPercent = serviceLevelPercentConstant;</span>
							} else {
<span class="nc" id="L1003">								curSLPercent = slPercent[counter];</span>
<span class="nc" id="L1004">								counter++;</span>
							}

<span class="nc" id="L1007">							ServiceLevelPercentTimeSeriesDataItem slItem = new ServiceLevelPercentTimeSeriesDataItem(</span>
									gmtDate,
<span class="nc bnc" id="L1009" title="All 2 branches missed.">									dateOnOff.getValue() ? ((double) curSLPercent) : 0.d);</span>
<span class="nc" id="L1010">							serviceGoalsTimeSeries.add(slItem);</span>
						}
<span class="nc" id="L1012">					}</span>
				}
<span class="nc" id="L1014">				spQueueWrapper.setAllServiceGoals(serviceGoalsTimeSeries);</span>
<span class="nc" id="L1015">				CAT.debug(&quot;serviceGoalTSsize: &quot; + serviceGoalsTimeSeries.size());</span>
<span class="nc" id="L1016">			} else {</span>
<span class="nc" id="L1017">				List&lt;ASATimeSeriesDataItem&gt; serviceGoalsTimeSeries = new ArrayList&lt;ASATimeSeriesDataItem&gt;();</span>
<span class="nc" id="L1018">				boolean hasASAError = false;</span>
<span class="nc" id="L1019">				int averageSpeedToAnswerConstant = Integer.MIN_VALUE;</span>
<span class="nc" id="L1020">				int[] asaPercent = null;</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">				if(serviceGoalDTO!=null){</span>
<span class="nc" id="L1022">					averageSpeedToAnswerConstant = serviceGoalDTO.getAverageAnswerTime();</span>
				} else {
<span class="nc" id="L1024">					String asaPercentEncoded = serviceGoalSeriesDTO.getAverageAnswerTimeSeriesEncoded();</span>
					// check if there are adequate number
<span class="nc" id="L1026">					int daysInPeriod = DateTimeUtil.daysBetween(</span>
<span class="nc" id="L1027">							schedulingPeriod.getStartTimeLocal().getCalendar(campaign.getTimeZone()),</span>
<span class="nc" id="L1028">							schedulingPeriod.getEndTimeLocal().getCalendar(campaign.getTimeZone()));</span>
<span class="nc" id="L1029">					asaPercent = EncodeUtil.base64ToInt(asaPercentEncoded);</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">					if (asaPercent.length != daysInPeriod * HOUR_PER_DAY) {</span>
<span class="nc" id="L1031">						CAT.debug(&quot;ASATimeSeriesDataItem not created for sp queue: &quot;</span>
<span class="nc" id="L1032">								+ spQueueWrapper.getSPQueue().getID()</span>
								+ &quot;. In Scheduling period &quot;
<span class="nc" id="L1034">								+ schedulingPeriod.getID()</span>
								+ &quot;has a service level time series of length &quot;
<span class="nc" id="L1036">								+ asaPercentEncoded.length()</span>
								+ &quot; which is not the same as &quot;+HOUR_PER_DAY+&quot; times the number of days &quot;
								+ daysInPeriod
<span class="nc" id="L1039">								+ &quot; in the scheduling period for the queue &quot; + spQueueWrapper.getSPQueue().getID());</span>
<span class="nc" id="L1040">						hasASAError = true;</span>
					}
				}
<span class="nc bnc" id="L1043" title="All 2 branches missed.">				if (!hasASAError) {</span>
<span class="nc" id="L1044">					int counter = 0;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">					for (Map.Entry&lt;Calendar, Boolean&gt; dateOnOff : onOffHoursMap.entrySet()) {</span>
						// The database needs each date in GMT format
<span class="nc" id="L1047">						LocalDate temp = new LocalDate(dateOnOff.getKey().getTime(), campaign.getTimeZone());</span>
<span class="nc" id="L1048">						Date gmtDate = com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil</span>
<span class="nc" id="L1049">								.convertToGMTFromLocalDateTimeInTimeZone(</span>
										temp,
<span class="nc" id="L1051">										campaign.getTimeZone());</span>
						// Don't create a data item if we've already created one for the current datetime
<span class="nc bnc" id="L1053" title="All 2 branches missed.">						if (gmtDateHash.contains(gmtDate)) {</span>
<span class="nc" id="L1054">							CAT.debug(&quot;ASATimeSeriesDataItem not created for date: &quot;</span>
									+ gmtDate
									+ &quot;. &quot;
									+ &quot;Data item was already created for that date for SPQueue ID: &quot;
<span class="nc" id="L1058">									+ spQueueWrapper.getSPQueue().getID()</span>
									+ &quot;.  This was likely due to a DST transition.&quot;);
						} else {
<span class="nc" id="L1061">							gmtDateHash.add(gmtDate);</span>
<span class="nc" id="L1062">							int curASAPercent = 0;</span>
<span class="nc bnc" id="L1063" title="All 2 branches missed.">							if (serviceGoalDTO != null) {</span>
<span class="nc" id="L1064">								curASAPercent = averageSpeedToAnswerConstant;</span>
							} else {
<span class="nc" id="L1066">								curASAPercent = asaPercent[counter];</span>
<span class="nc" id="L1067">								counter++;</span>
							}
<span class="nc" id="L1069">							ASATimeSeriesDataItem asaItem = new ASATimeSeriesDataItem(</span>
<span class="nc" id="L1070">									dateOnOff.getKey().getTime(),</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">									dateOnOff.getValue() ? ((double) curASAPercent) : 0.d);</span>
<span class="nc" id="L1072">							serviceGoalsTimeSeries.add(asaItem);</span>
						}
<span class="nc" id="L1074">					}</span>
<span class="nc" id="L1075">					spQueueWrapper.setAllServiceGoals(serviceGoalsTimeSeries);</span>
				}
			}
			// end of look soon
<span class="nc" id="L1079">		}</span>
		// end of SchedulingPeriodQueueDTO sub loop
<span class="nc" id="L1081">	}</span>

	private void setSPQueueIDsAndAddToWrappedCollections(SystemType systemType,
			Map&lt;ID, ID&gt; queueExternalWfoIDMap,
			Map&lt;SPQueueNaturalKey, SPQueue&gt; naturalKeyOldSPQueueMap,
			SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper,
			ID wfoSchedPeriodID,
			SchedulingPeriodQueueDTO schedulingPeriodQueueDTO,
			SPQueueWithServiceGoalsWrapper spQueueWrapper)
					throws ServiceApplicationException {
<span class="nc" id="L1091">		SPQueue spQueue = spQueueWrapper.getSPQueue();</span>

		// Warning: The scheduling period id can be null if the Scheduling Period is new
<span class="nc" id="L1094">		spQueue.setSpID(wfoSchedPeriodID);</span>

		// Verified above it is not null
<span class="nc" id="L1097">		ID wfoQueueSID = queueExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
<span class="nc" id="L1098">				systemType, schedulingPeriodQueueDTO.getQueueExternalSourceId()));</span>
<span class="nc" id="L1099">		spQueue.setQueueID(wfoQueueSID);</span>

		// Assign id to spQueue (when it already exists) And we then know
		// whether it will be new/create or old/update :) This can only be the
		// case when queue exists and scheduling period already exists
<span class="nc" id="L1104">		ID wfoSPQueueID = null;</span>
<span class="nc" id="L1105">		ID wfoSPQueueDEID = null;</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">		if (spQueue.getSpID() != null) {</span>
<span class="nc" id="L1107">			SPQueueNaturalKey spQueueNaturalKey = new SPQueueNaturalKey(spQueue.getSpID(), spQueue.getQueueID());</span>
<span class="nc" id="L1108">			SPQueue preUpdateSPQueue = naturalKeyOldSPQueueMap.get(spQueueNaturalKey);</span>
<span class="nc" id="L1109">			CAT.debug(&quot;preUpdateSPQueue: &quot; + preUpdateSPQueue);</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">			wfoSPQueueID = (preUpdateSPQueue == null) ? null : preUpdateSPQueue.getID();</span>
<span class="nc bnc" id="L1111" title="All 2 branches missed.">			wfoSPQueueDEID = (preUpdateSPQueue == null) ? null : preUpdateSPQueue.getDEID();</span>
<span class="nc" id="L1112">			CAT.debug(&quot;wfoSchedPeriodID: &quot; + wfoSPQueueID);</span>
		}
<span class="nc bnc" id="L1114" title="All 2 branches missed.">		if (wfoSPQueueID != null) {</span>
<span class="nc" id="L1115">			spQueue.setID(wfoSPQueueID);</span>
			// very necessary, but stupid (the deprecated DEID is needed to save
			// the service goals unfortunately :(
<span class="nc" id="L1118">			spQueue.setFieldValue(SPQueueFieldInfo.SPQUEUE_ID, wfoSPQueueDEID);</span>
<span class="nc" id="L1119">			schedulingPeriodWrapper.getOldSPQueueWrappers().add(spQueueWrapper);</span>
		} else {
<span class="nc" id="L1121">			schedulingPeriodWrapper.getNewSPQueueWrappers().add(spQueueWrapper);</span>
		}
<span class="nc" id="L1123">	}</span>

	private void setSPQueueSkills(SystemType systemType,
			SPQueue spQueue,
			SchedulingPeriodQueueDTO schedulingPeriodQueueDTO) throws ServiceApplicationException {
		// Look up linked local wfo skill id in the same way (not required)
<span class="nc bnc" id="L1129" title="All 2 branches missed.">		if (schedulingPeriodQueueDTO.getSkillExternalSourceId() != null) {</span>
			try {
<span class="nc" id="L1131">				ID wfoSkillDEID = MapUtil.getExternalToWfoID(</span>
						systemType,
						MapUtil.ObjectType.Skill,
<span class="nc" id="L1134">						ExternalIDUtil.buildExternalID(</span>
								systemType,
<span class="nc" id="L1136">								schedulingPeriodQueueDTO.getSkillExternalSourceId()));</span>
				// We verified above that this is not null
<span class="nc" id="L1138">				spQueue.setSkills(Arrays.asList(wfoSkillDEID));</span>
<span class="nc" id="L1139">			} catch (JdmoException e) {</span>
<span class="nc" id="L1140">				throw new ServiceApplicationException(e);</span>
<span class="nc" id="L1141">			}</span>
		}
<span class="nc" id="L1143">	}</span>

	private void createOrUpdateServiceGoals(Collection&lt;SchedulingPeriodWithStuffWrapper&gt; schedulingPeriodWrappers)
			throws ServiceApplicationException {
		// Finally, save the service goals, irrespective of whether they are new or old
<span class="nc" id="L1148">		int goalsCount = 0;</span>
<span class="nc" id="L1149">		Map&lt;SPQueue, List&lt;ServiceGoalsTimeSeriesDataItem&gt;&gt; serviceGoalsBySPQueue = new HashMap&lt;&gt;();</span>
		try {
<span class="nc bnc" id="L1151" title="All 2 branches missed.">			for (SchedulingPeriodWithStuffWrapper schedulingPeriodWrapper : schedulingPeriodWrappers) {</span>
				for (SPQueueWithServiceGoalsWrapper spQueueWithServiceGoalsWrapper :
<span class="nc bnc" id="L1153" title="All 2 branches missed.">						(Collection&lt;SPQueueWithServiceGoalsWrapper&gt;) CollectionUtils.union(</span>
<span class="nc" id="L1154">								schedulingPeriodWrapper.getNewSPQueueWrappers(),</span>
<span class="nc" id="L1155">								schedulingPeriodWrapper.getOldSPQueueWrappers())) {</span>
<span class="nc" id="L1156">					serviceGoalsBySPQueue.put(</span>
<span class="nc" id="L1157">							spQueueWithServiceGoalsWrapper.getSPQueue(),</span>
<span class="nc" id="L1158">							spQueueWithServiceGoalsWrapper.getAllServiceGoals());</span>
<span class="nc" id="L1159">					goalsCount += spQueueWithServiceGoalsWrapper.getAllServiceGoals().size();</span>
<span class="nc" id="L1160">				}</span>

<span class="nc bnc" id="L1162" title="All 2 branches missed.">				if (goalsCount &gt;= SG_BATCH_SIZE) {</span>
<span class="nc" id="L1163">					serviceGoalsManager.bulkCreateOrUpdateSLOrASAServiceGoalTimeSeries(serviceGoalsBySPQueue);</span>
<span class="nc" id="L1164">					serviceGoalsBySPQueue.clear();</span>
<span class="nc" id="L1165">					goalsCount = 0;</span>
				}
<span class="nc" id="L1167">			}</span>

<span class="nc bnc" id="L1169" title="All 2 branches missed.">			if (goalsCount &gt; 0) {</span>
<span class="nc" id="L1170">				serviceGoalsManager.bulkCreateOrUpdateSLOrASAServiceGoalTimeSeries(serviceGoalsBySPQueue);</span>
			}
<span class="nc" id="L1172">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L1173">			CAT.error(&quot;Failed to save the service goals!&quot;, e);</span>
<span class="nc" id="L1174">			throw new ServiceApplicationException(&quot;The service goals have not been saved.!&quot;, e);</span>
<span class="nc" id="L1175">		} catch (RemoteException e) {</span>
<span class="nc" id="L1176">			CAT.error(&quot;RemoteException while saving service goals saving !&quot;, e);</span>
<span class="nc" id="L1177">			throw new ServiceApplicationException(&quot;RemoteException whil saving the service goals!&quot;, e);</span>
<span class="nc" id="L1178">		} catch(Exception any) {</span>
<span class="nc" id="L1179">			CAT.error(&quot;Incorrect service goal types!&quot;, any);</span>
<span class="nc" id="L1180">			throw new ServiceApplicationException(&quot;Failed to save service goals!&quot;, any);</span>
<span class="nc" id="L1181">		}</span>
<span class="nc" id="L1182">	}</span>

	public static Map&lt;ID, Campaign&gt; getIDCampaignMap(CampaignManager campaignManager, Collection&lt;ID&gt; campaignIds)
			throws ServiceApplicationException {
		try {
			// Unfortunately we need to worry about white space padding making ID not match :(
<span class="nc" id="L1188">			Collection&lt;Campaign&gt; campaigns = campaignManager.getCampaignsByIDs(campaignIds);</span>
<span class="nc" id="L1189">			Map&lt;ID, Campaign&gt; idCampaignMap = new HashMap&lt;ID, Campaign&gt;();</span>
<span class="nc bnc" id="L1190" title="All 2 branches missed.">			for (Campaign campaign : campaigns) {</span>
<span class="nc" id="L1191">				idCampaignMap.put(campaign.getID(), campaign);</span>
<span class="nc" id="L1192">			}</span>
<span class="nc" id="L1193">			return idCampaignMap;</span>
<span class="nc" id="L1194">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1195">			CAT.error(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1196">			throw new ServiceApplicationException(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1197">		} catch (RemoteException e) {</span>
<span class="nc" id="L1198">			CAT.error(&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1199">			throw new ServiceApplicationException(</span>
					&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);
<span class="nc" id="L1201">		} catch (Throwable e) {</span>
<span class="nc" id="L1202">			CAT.error(e);</span>
<span class="nc" id="L1203">			throw new ServiceApplicationException(e);</span>
		}
	}

	/**
	 * Validates each of the DTOs to make sure that the externalIds for the
	 * campaign and the start date of the period is present. Validates all the
	 * SchedulingPeriodQueue DTOs to make sure that the queue external is set.
	 * This returns the min start date and the max end date of all the
	 * scheduling periods in this list.
	 */
	private List&lt;Date&gt; validateSchedulingPeriodDTOs(
			SystemType systemType,
			Collection&lt;SchedulingPeriodDTO&gt; schedulingPeriodDTOs,
			Collection&lt;SchedulingPeriodNotPersistedInfo&gt; schedulingPeriodNotPersistedInfos,
			Collection&lt;ID&gt; campaignExternalSourceIds,
			Collection&lt;ID&gt; queueExternalSourceIds) {
<span class="nc" id="L1220">		Date minDate = null;</span>
<span class="nc" id="L1221">		Date maxDate = null;</span>
<span class="nc" id="L1222">		List&lt;Date&gt; startEnd = new ArrayList&lt;Date&gt;();</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">		for (Iterator&lt;SchedulingPeriodDTO&gt; iterator = schedulingPeriodDTOs.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1224">			SchedulingPeriodDTO schedulingPeriodDTO = iterator.next();</span>

			// Key validation (basic only)
<span class="nc" id="L1227">			SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo = new SchedulingPeriodNotPersistedInfo();</span>
<span class="nc" id="L1228">			validateSchedulingPeriodDTO(schedulingPeriodDTO, schedulingPeriodNotPersistedInfo);</span>

			// if invalid, add to infos and remove from being processes further
<span class="nc bnc" id="L1231" title="All 2 branches missed.">			if (!schedulingPeriodNotPersistedInfo.getMessages().isEmpty()) {</span>
<span class="nc" id="L1232">				schedulingPeriodNotPersistedInfos.add(schedulingPeriodNotPersistedInfo);</span>
<span class="nc" id="L1233">				iterator.remove();</span>
			} else {
<span class="nc" id="L1235">				ID campaignExternalSourceId = ExternalIDUtil.buildExternalID(</span>
						systemType,
<span class="nc" id="L1237">						schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getCampaignExternalSourceId());</span>
<span class="nc bnc" id="L1238" title="All 2 branches missed.">				if (!campaignExternalSourceIds.contains(campaignExternalSourceId)) {</span>
<span class="nc" id="L1239">					campaignExternalSourceIds.add(campaignExternalSourceId);</span>
				}

<span class="nc" id="L1242">				Date periodStartDate = schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getStartDate();</span>
<span class="nc" id="L1243">				Date periodEndDate = DateTimeUtil.getDateForDaysAfter(</span>
<span class="nc" id="L1244">						schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getStartDate(),</span>
<span class="nc" id="L1245">						DAYS_IN_WEEK * schedulingPeriodDTO.getHoursOfOperationDTOs().size());</span>
<span class="nc bnc" id="L1246" title="All 2 branches missed.">				minDate = (minDate == null) ? periodStartDate : Collections.min(Arrays.asList(minDate, periodStartDate));</span>
<span class="nc bnc" id="L1247" title="All 2 branches missed.">				maxDate = (maxDate == null) ? periodEndDate : Collections.max(Arrays.asList(maxDate, periodEndDate));</span>

<span class="nc bnc" id="L1249" title="All 2 branches missed.">				if (schedulingPeriodDTO.getSchedulingPeriodQueueDTOs() != null) {</span>
<span class="nc bnc" id="L1250" title="All 2 branches missed.">					for (SchedulingPeriodQueueDTO schedulingPeriodQueueDTO : schedulingPeriodDTO.getSchedulingPeriodQueueDTOs()) {</span>
<span class="nc bnc" id="L1251" title="All 2 branches missed.">						if (schedulingPeriodQueueDTO.getQueueExternalSourceId() == null) {</span>
<span class="nc" id="L1252">							schedulingPeriodNotPersistedInfo.addQueueExternalSourceIdMissingMessage();</span>
<span class="nc" id="L1253">							schedulingPeriodNotPersistedInfos.add(schedulingPeriodNotPersistedInfo);</span>
<span class="nc" id="L1254">							iterator.remove();</span>
							// We need to break from inner loop to avoid illegally invoking remove() twice
<span class="nc" id="L1256">							break;</span>
						} else {
<span class="nc" id="L1258">							queueExternalSourceIds.add(ExternalIDUtil.buildExternalID(</span>
									systemType,
<span class="nc" id="L1260">									schedulingPeriodQueueDTO.getQueueExternalSourceId()));</span>
						}
<span class="nc" id="L1262">					}</span>
				}
			}
<span class="nc" id="L1265">		}</span>
<span class="nc" id="L1266">		startEnd.add(minDate);</span>
<span class="nc" id="L1267">		startEnd.add(maxDate);</span>
<span class="nc" id="L1268">		return startEnd;</span>
	}

	/**
	 * Validates that the DTO has the campaign and the start date information.
	 */
	private void validateSchedulingPeriodDTO(
			SchedulingPeriodDTO schedulingPeriodDTO, SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo){
<span class="nc bnc" id="L1276" title="All 2 branches missed.">		if (schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey() == null) {</span>
<span class="nc" id="L1277">			schedulingPeriodNotPersistedInfo.addExternalNaturalKeyMissingMessage(schedulingPeriodDTO</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">					.getOrganizationNames().iterator().hasNext() ? schedulingPeriodDTO</span>
<span class="nc" id="L1279">					.getOrganizationNames().iterator().next() : null);</span>

		} else {
<span class="nc bnc" id="L1282" title="All 2 branches missed.">			if (schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getCampaignExternalSourceId() == null) {</span>
<span class="nc" id="L1283">				schedulingPeriodNotPersistedInfo.addCampaignExternalSourceIdInKeyMissingMessage();</span>
			}

<span class="nc bnc" id="L1286" title="All 2 branches missed.">			if (schedulingPeriodDTO.getSchedulingPeriodExternalNaturalKey().getStartDate() == null) {</span>
<span class="nc" id="L1287">				schedulingPeriodNotPersistedInfo.addStartDateInKeyMissingMessage();</span>
			}
		}
<span class="nc" id="L1290">	}</span>

	private Map&lt;ID, Queue&gt; buildIDQueueMap(Collection&lt;ID&gt; queueIDs) throws ServiceApplicationException {
		try {
<span class="nc" id="L1294">			Collection&lt;Queue&gt; Queue = workloadManager.getQueuesByIDs(queueIDs);</span>
<span class="nc" id="L1295">			Map&lt;ID, Queue&gt; idQueueMap = new HashMap&lt;ID, Queue&gt;();</span>
<span class="nc bnc" id="L1296" title="All 2 branches missed.">			for (Queue queue : Queue) {</span>
<span class="nc" id="L1297">				idQueueMap.put(queue.getID(), queue);</span>
<span class="nc" id="L1298">			}</span>
<span class="nc" id="L1299">			return idQueueMap;</span>
<span class="nc" id="L1300">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1301">			CAT.error(&quot;Failure invoking fault invoking workloadManager.get~()&quot;, e);</span>
<span class="nc" id="L1302">			throw new ServiceApplicationException(&quot;Failure invoking fault invoking workloadManager.get~()&quot;, e);</span>
<span class="nc" id="L1303">		} catch (RemoteException e) {</span>
<span class="nc" id="L1304">			CAT.error(&quot;There was a communication fault invoking workloadManager.get~()&quot;, e);</span>
<span class="nc" id="L1305">			throw new ServiceApplicationException(&quot;There was a communication fault invoking workloadManager.get~()&quot;, e);</span>
<span class="nc" id="L1306">		} catch (Throwable e) {</span>
<span class="nc" id="L1307">			CAT.error(e);</span>
<span class="nc" id="L1308">			throw new ServiceApplicationException(e);</span>
		}
	}

	public Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; buildNaturalKeySchedulingPeriodMap(
			Collection&lt;ID&gt; campaignIDs, Date minDate, Date maxDate) throws ServiceApplicationException {
<span class="nc" id="L1314">		Map&lt;ID, Collection&lt;CalendarRange&gt;&gt; campaignIDToSPIntervals = new HashMap&lt;ID, Collection&lt;CalendarRange&gt;&gt;();</span>
<span class="nc" id="L1315">		return buildNaturalKeySchedulingPeriodMapWithCampaignIdMap(</span>
				campaignIDs, minDate, maxDate, campaignIDToSPIntervals);
	}

	public Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; buildNaturalKeySchedulingPeriodMapWithCampaignIdMap(
			Collection&lt;ID&gt; campaignIDs, Date minDate, Date maxDate, Map&lt;ID, Collection&lt;CalendarRange&gt;&gt; campaignIDToSPIntervals)
					throws ServiceApplicationException {
		try {
			// Load the scheduling periods for those campaigns
<span class="nc" id="L1324">			Collection&lt;SchedulingPeriod&gt; oldSchedulingPeriods = campaignManager.getSchedulingPeriodsByCampaignIDs(</span>
					campaignIDs, minDate, maxDate);

			// Convert from collection to map
<span class="nc" id="L1328">			Map&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt; naturalKeyOldSchedulingPeriodMap =</span>
					new HashMap&lt;SchedPeriodNaturalKey, SchedulingPeriod&gt;();
<span class="nc bnc" id="L1330" title="All 2 branches missed.">			for (SchedulingPeriod oldSchedulingPeriod : oldSchedulingPeriods) {</span>
<span class="nc bnc" id="L1331" title="All 2 branches missed.">				if (oldSchedulingPeriod.getStartTimeLocal() == null) {</span>
<span class="nc" id="L1332">					throw new ServiceApplicationException(&quot;Scheduling Periods start time local not set&quot;);</span>
				}

<span class="nc" id="L1335">				Collection spIntervals = campaignIDToSPIntervals.get(oldSchedulingPeriod.getCampaignID());</span>
<span class="nc bnc" id="L1336" title="All 2 branches missed.">				if (spIntervals == null) {</span>
<span class="nc" id="L1337">					spIntervals = new ArrayList&lt;CalendarRange&gt;();</span>
<span class="nc" id="L1338">					campaignIDToSPIntervals.put(oldSchedulingPeriod.getCampaignID(), spIntervals);</span>
				}
<span class="nc" id="L1340">				spIntervals.add(new CalendarRange(oldSchedulingPeriod.getStartTime(), oldSchedulingPeriod.getEndTime()));</span>
<span class="nc" id="L1341">				naturalKeyOldSchedulingPeriodMap.put(</span>
						new SchedPeriodNaturalKey(
<span class="nc" id="L1343">								oldSchedulingPeriod.getCampaignID(),</span>
<span class="nc" id="L1344">								oldSchedulingPeriod.getStartTimeLocal(),</span>
<span class="nc" id="L1345">								oldSchedulingPeriod.getEndTimeLocal()),</span>
						oldSchedulingPeriod);
<span class="nc" id="L1347">			}</span>
<span class="nc" id="L1348">			return naturalKeyOldSchedulingPeriodMap;</span>
<span class="nc" id="L1349">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1350">			CAT.error(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1351">			throw new ServiceApplicationException(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1352">		} catch (RemoteException e) {</span>
<span class="nc" id="L1353">			CAT.error(&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1354">			throw new ServiceApplicationException(&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1355">		} catch (Throwable e) {</span>
<span class="nc" id="L1356">			CAT.error(e);</span>
<span class="nc" id="L1357">			throw new ServiceApplicationException(e);</span>
		}
	}

	private Map&lt;SchedPeriodHOONaturalKey, CampaignHOO&gt; buildNaturalKeySchedulingPeriodHooMap(
			Collection&lt;ID&gt; campaignIDs, Date minDate, Date maxDate) throws ServiceApplicationException {
		try {
<span class="nc" id="L1364">			Collection&lt;CampaignHOO&gt; oldSchedulingPeriodHours = campaignManager.getCampaignHOOsByCampaignIDs(</span>
					campaignIDs, minDate, maxDate);

			// Convert from collection to map
<span class="nc" id="L1368">			Map&lt;SchedPeriodHOONaturalKey, CampaignHOO&gt; naturalKeyOldSchedulingPeriodHooMap = new HashMap&lt;SchedPeriodHOONaturalKey, CampaignHOO&gt;();</span>
<span class="nc bnc" id="L1369" title="All 2 branches missed.">			for (CampaignHOO oldSchedulingPeriodHour : oldSchedulingPeriodHours) {</span>
<span class="nc" id="L1370">				naturalKeyOldSchedulingPeriodHooMap.put(</span>
						new SchedPeriodHOONaturalKey(
<span class="nc" id="L1372">								oldSchedulingPeriodHour.getCampaignID(),</span>
<span class="nc" id="L1373">								oldSchedulingPeriodHour.getSPID(),</span>
<span class="nc" id="L1374">								oldSchedulingPeriodHour.getStartTimeLocal()),</span>
						oldSchedulingPeriodHour);
<span class="nc" id="L1376">			}</span>
<span class="nc" id="L1377">			return naturalKeyOldSchedulingPeriodHooMap;</span>
<span class="nc" id="L1378">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1379">			CAT.error(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1380">			throw new ServiceApplicationException(&quot;Failure invoking fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1381">		} catch (RemoteException e) {</span>
<span class="nc" id="L1382">			CAT.error(&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1383">			throw new ServiceApplicationException(&quot;There was a communication fault invoking campaignManager.get~()&quot;, e);</span>
<span class="nc" id="L1384">		} catch (Throwable e) {</span>
<span class="nc" id="L1385">			CAT.error(e);</span>
<span class="nc" id="L1386">			throw new ServiceApplicationException(e);</span>
		}
	}

	private Map&lt;SPQueueNaturalKey, SPQueue&gt; buildNaturalKeySchedulingPeriodQueueMap(
			Collection&lt;SchedulingPeriod&gt; schedulingPeriods) throws ServiceApplicationException {
		try {
<span class="nc" id="L1393">			Collection&lt;ID&gt; schedulingPeriodIDs = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1394" title="All 2 branches missed.">			for (SchedulingPeriod schedulingPeriod : schedulingPeriods) {</span>
<span class="nc" id="L1395">				schedulingPeriodIDs.add(schedulingPeriod.getID());</span>
<span class="nc" id="L1396">			}</span>

<span class="nc" id="L1398">			Collection&lt;SPQueue&gt; oldSPQueues = campaignManager.getSPQueuesBySPIDsFixed(schedulingPeriodIDs);</span>
<span class="nc" id="L1399">			Map&lt;SPQueueNaturalKey, SPQueue&gt; naturalKeyOldSPQueueMap = new HashMap&lt;SPQueueNaturalKey, SPQueue&gt;();</span>
<span class="nc bnc" id="L1400" title="All 2 branches missed.">			for (SPQueue oldSpQueue : oldSPQueues) {</span>
<span class="nc" id="L1401">				naturalKeyOldSPQueueMap.put(</span>
<span class="nc" id="L1402">						new SPQueueNaturalKey(oldSpQueue.getSpID(), oldSpQueue.getQueueID()),</span>
						oldSpQueue);
<span class="nc" id="L1404">			}</span>
<span class="nc" id="L1405">			return naturalKeyOldSPQueueMap;</span>
<span class="nc" id="L1406">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1407">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L1408">		} catch (RemoteException e) {</span>
<span class="nc" id="L1409">			throw new ServiceApplicationException(e);</span>
		}
	}

	private Map&lt;SchedulingPeriodExternalNaturalKey, Boolean&gt; buildSchedulingPeriodExternalKeyTruthMap(
			Collection&lt;SchedulingPeriodExternalNaturalKey&gt; schedulingPeriodExternalNaturalKeys,
			SystemType systemType)
					throws ServiceApplicationException {
		// First pass: build maps to local campaign ids
<span class="nc" id="L1418">		Collection&lt;ID&gt; campaignExternalSourceIds = new ArrayList&lt;ID&gt;();</span>
<span class="nc bnc" id="L1419" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>
<span class="nc" id="L1420">			campaignExternalSourceIds.add(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L1422">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>
<span class="nc" id="L1423">		}</span>
		Map&lt;ID, ID&gt; campaignExternalWfoIDMap;

		try {
<span class="nc" id="L1427">			campaignExternalWfoIDMap = MapUtil.getExternalIDMap(</span>
					systemType, MapUtil.ObjectType.Campaign, campaignExternalSourceIds, true);
<span class="nc" id="L1429">		} catch (JdmoException e) {</span>
<span class="nc" id="L1430">			throw new ServiceApplicationException(e);</span>
<span class="nc" id="L1431">		}</span>
		// Second pass: Load from database all campaigns of the scheduling periods: we need their time zones
<span class="nc" id="L1433">		Map&lt;ID, Campaign&gt; wfoIDCampaignMap = getIDCampaignMap(campaignManager, campaignExternalWfoIDMap.values());</span>
<span class="nc" id="L1434">		Map&lt;SchedulingPeriodExternalNaturalKey, Boolean&gt; result = new HashMap&lt;SchedulingPeriodExternalNaturalKey, Boolean&gt;();</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">		for (SchedulingPeriodExternalNaturalKey schedulingPeriodExternalNaturalKey : schedulingPeriodExternalNaturalKeys) {</span>
<span class="nc" id="L1436">			boolean isExistenceProven = false;</span>
<span class="nc" id="L1437">			ID wfoCampaignID = campaignExternalWfoIDMap.get(ExternalIDUtil.buildExternalID(</span>
					systemType,
<span class="nc" id="L1439">					schedulingPeriodExternalNaturalKey.getCampaignExternalSourceId()));</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">			if (wfoCampaignID != null) {</span>
				try {
<span class="nc" id="L1442">					Campaign campaign = wfoIDCampaignMap.get(wfoCampaignID);</span>
<span class="nc" id="L1443">					Calendar startDateWithZone = schedulingPeriodExternalNaturalKey.startCalendarWithZone(campaign.getTimeZone());</span>
<span class="nc" id="L1444">					LocalDate startLocalDate = new LocalDate(startDateWithZone.getTime(), campaign.getTimeZone());</span>

					// Notes: (1)There is a design flaw in the ejb, whereby the query is based on
					// the GMT time (2) scheduling period has two relevant properties startTime
					// which is GMT translated and also startTimeLocal
					// TODO could we create method to do all of this at once?
<span class="nc" id="L1450">					Date startDateGMT = com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil</span>
<span class="nc" id="L1451">							.convertToGMTFromLocalDateTimeInTimeZone(startLocalDate, campaign.getTimeZone());</span>
					@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L1453">					Collection&lt;SchedulingPeriod&gt; candidateSchedulingPeriods = campaignManager.getSchedulingPeriods(</span>
							wfoCampaignID, startDateGMT, 1, SchedulingPeriod.FutureOnly);
<span class="nc bnc" id="L1455" title="All 2 branches missed.">					if (!candidateSchedulingPeriods.isEmpty()</span>
<span class="nc bnc" id="L1456" title="All 2 branches missed.">							&amp;&amp; candidateSchedulingPeriods.iterator().next().getStartTime().equals(startDateGMT)) {</span>
<span class="nc" id="L1457">						isExistenceProven = true;</span>
					}
<span class="nc" id="L1459">				} catch (BbmFinderException e) {</span>
<span class="nc" id="L1460">					throw new ServiceApplicationException(e);</span>
<span class="nc" id="L1461">				} catch (RemoteException e) {</span>
<span class="nc" id="L1462">					throw new ServiceApplicationException(e);</span>
<span class="nc" id="L1463">				}</span>
			}
<span class="nc" id="L1465">			result.put(schedulingPeriodExternalNaturalKey, isExistenceProven);</span>
<span class="nc" id="L1466">		}</span>
<span class="nc" id="L1467">		return result;</span>
	}

	//Nothing is actually converted here, this validation seems to be done twice.
	private boolean convertToServiceLevelGoalType(
			String serviceGoalType,
			SchedulingPeriodNotPersistedInfo schedulingPeriodNotPersistedInfo) {

<span class="nc bnc" id="L1475" title="All 2 branches missed.">		if (!SchedulingPeriodQueueDTO.SERVICE_GOAL_TYPES.contains(serviceGoalType)) {</span>
<span class="nc" id="L1476">			schedulingPeriodNotPersistedInfo.addNoSuchServiceGoalType(serviceGoalType);</span>
		}
<span class="nc bnc" id="L1478" title="All 2 branches missed.">		if (serviceGoalType.equals(SchedulingPeriodQueueDTO.SERVICE_LEVEL_ANSWER_TIME)) {</span>
<span class="nc" id="L1479">			return false;</span>
		} else {
<span class="nc" id="L1481">			return true;</span>
		}
	}

	/**
	 * We need to keep each scheduling period directly associated with its hours of operation for
	 * proper processing. Its only meant to be used here, and that's why its not a top level class.
	 * 
	 * WARNING: We use this in lieu of a Map, because SchedulingPeriod as key doesn't work properly
	 * when its id is not yet assigned
	 * 
	 * @author EClingman
	 */
<span class="nc" id="L1494">	protected static class SchedulingPeriodWithStuffWrapper {</span>
		private SchedulingPeriod m_schedulingPeriod;

<span class="nc" id="L1497">		private final List&lt;CampaignHOO&gt; m_newCampaignHOOs = new ArrayList&lt;CampaignHOO&gt;();</span>
<span class="nc" id="L1498">		private final List&lt;CampaignHOO&gt; m_oldCampaignHOOs = new ArrayList&lt;CampaignHOO&gt;();</span>
<span class="nc" id="L1499">		private final List&lt;SPQueueWithServiceGoalsWrapper&gt; m_newSPQueueWrappers = new ArrayList&lt;SPQueueWithServiceGoalsWrapper&gt;();</span>
<span class="nc" id="L1500">		private final List&lt;SPQueueWithServiceGoalsWrapper&gt; m_oldSPQueueWrappers = new ArrayList&lt;SPQueueWithServiceGoalsWrapper&gt;();</span>

		public SchedulingPeriod getSchedulingPeriod() {
<span class="nc" id="L1503">			return m_schedulingPeriod;</span>
		}

		public void setSchedulingPeriod(SchedulingPeriod schedulingPeriod) {
<span class="nc" id="L1507">			m_schedulingPeriod = schedulingPeriod;</span>
<span class="nc" id="L1508">		}</span>

		public List&lt;CampaignHOO&gt; getNewCampaignHOOs() {
<span class="nc" id="L1511">			return m_newCampaignHOOs;</span>
		}

		public List&lt;CampaignHOO&gt; getOldCampaignHOOs() {
<span class="nc" id="L1515">			return m_oldCampaignHOOs;</span>
		}

		public List&lt;SPQueueWithServiceGoalsWrapper&gt; getNewSPQueueWrappers() {
<span class="nc" id="L1519">			return m_newSPQueueWrappers;</span>
		}

		public List&lt;SPQueueWithServiceGoalsWrapper&gt; getOldSPQueueWrappers() {
<span class="nc" id="L1523">			return m_oldSPQueueWrappers;</span>
		}

		public static Collection&lt;SchedulingPeriod&gt; convertToSchedulingPeriods(
				Collection&lt;SchedulingPeriodWithStuffWrapper&gt; wrappers) {
<span class="nc" id="L1528">			Collection&lt;SchedulingPeriod&gt; result = new ArrayList&lt;SchedulingPeriod&gt;();</span>
<span class="nc bnc" id="L1529" title="All 2 branches missed.">			for (SchedulingPeriodWithStuffWrapper wrapper : wrappers) {</span>
<span class="nc" id="L1530">				result.add(wrapper.getSchedulingPeriod());</span>
<span class="nc" id="L1531">			}</span>
<span class="nc" id="L1532">			return result;</span>
		}
	}

	/**
	 * We need to keep each SPQueue directly associated with its service goals for proper
	 * processing. Its only meant to be used here, and that's why its not a top level class.
	 * 
	 * WARNING: We use this in lieu of a Map, because SPQueue as key doesn't work properly when its
	 * id is not yet assigned
	 * 
	 * @author EClingman
	 */
<span class="nc" id="L1545">	protected static class SPQueueWithServiceGoalsWrapper {</span>
		private SPQueue m_SPQueue;
		// The CRUD layer doesn't care whether a service goal is a create or
		// update, so we stick them all together!
		private List&lt;? extends ServiceGoalsTimeSeriesDataItem&gt; m_allServiceGoals;
		
		public SPQueue getSPQueue() {
<span class="nc" id="L1552">			return m_SPQueue;</span>
		}

		public void setSPQueue(SPQueue sPQueue) {
<span class="nc" id="L1556">			m_SPQueue = sPQueue;</span>
<span class="nc" id="L1557">		}</span>

		@SuppressWarnings(&quot;unchecked&quot;)
		public &lt;T extends ServiceGoalsTimeSeriesDataItem&gt; List&lt;T&gt; getAllServiceGoals() {
<span class="nc" id="L1561">			return (List&lt;T&gt;) m_allServiceGoals;</span>
		}

		public &lt;T extends ServiceGoalsTimeSeriesDataItem&gt; void setAllServiceGoals(List&lt;T&gt; allServiceGoals) {
<span class="nc" id="L1565">			m_allServiceGoals = allServiceGoals;</span>
<span class="nc" id="L1566">		}</span>

		public static Collection&lt;SPQueue&gt; convertToSPQueues(Collection&lt;SPQueueWithServiceGoalsWrapper&gt; wrappers) {
<span class="nc" id="L1569">			Collection&lt;SPQueue&gt; result = new ArrayList&lt;SPQueue&gt;();</span>
<span class="nc bnc" id="L1570" title="All 2 branches missed.">			for (SPQueueWithServiceGoalsWrapper wrapper : wrappers) {</span>
<span class="nc" id="L1571">				result.add(wrapper.getSPQueue());</span>
<span class="nc" id="L1572">			}</span>
<span class="nc" id="L1573">			return result;</span>
		}
	}

	/**
	 * we need to compare scheduling periods in the database to those being synched from the
	 * external application. We decide if the latter is new entity or update entity based on
	 * campaign id and start date.
	 */
	public static class SchedPeriodNaturalKey {
		private final ID m_campaignID;
		private final LocalDate m_startDateLocal;
		final private LocalDate m_endDateLocal;

		public SchedPeriodNaturalKey(ID campaignID, LocalDate startDateLocal, LocalDate endDateLocal)
<span class="nc" id="L1588">				throws ServiceApplicationException {</span>
<span class="nc bnc" id="L1589" title="All 6 branches missed.">			if (campaignID == null || startDateLocal == null || endDateLocal == null) {</span>
<span class="nc" id="L1590">				throw new ServiceApplicationException(&quot;Nulls not allowed in constructor&quot;);</span>
			}
<span class="nc" id="L1592">			m_campaignID = campaignID;</span>
<span class="nc" id="L1593">			m_startDateLocal = startDateLocal;</span>
<span class="nc" id="L1594">			m_endDateLocal = endDateLocal;</span>
<span class="nc" id="L1595">		}</span>

		@Override
		public int hashCode() {
			// CAT.error(&quot;hash inputs: &quot; + m_campaignID + &quot;, &quot; + m_startDateLocal);
<span class="nc" id="L1600">			return m_campaignID.toString().trim().hashCode()</span>
<span class="nc" id="L1601">					+ m_startDateLocal.hashCode() + m_endDateLocal.hashCode();</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc" id="L1606">			SchedPeriodNaturalKey k = (SchedPeriodNaturalKey) obj;</span>
<span class="nc" id="L1607">			return m_campaignID.toString().trim()</span>
<span class="nc bnc" id="L1608" title="All 2 branches missed.">					.equals(k.m_campaignID.toString().trim())</span>
<span class="nc bnc" id="L1609" title="All 2 branches missed.">					&amp;&amp; m_startDateLocal.equals(k.m_startDateLocal)</span>
<span class="nc bnc" id="L1610" title="All 2 branches missed.">					&amp;&amp; m_endDateLocal.equals(k.m_endDateLocal);</span>
		}
	}

	/**
	 * we need to compare scheduling periods in the database to those being synched from the
	 * external application. We decide if the latter is new entity or update entity based on
	 * campaign id and start date.
	 */
	public class SchedPeriodHOONaturalKey {
		private final ID m_campaignID;
		private final ID m_schedulingPeriodID;
		private final LocalDate m_schedPeriodHOOStartDateLocal;

		public SchedPeriodHOONaturalKey(ID campaignID, ID schedulingPeriodID, LocalDate schedPeriodHOOStartDateLocal)
<span class="nc" id="L1625">				throws ServiceApplicationException {</span>
<span class="nc" id="L1626">			m_campaignID = campaignID;</span>
<span class="nc" id="L1627">			m_schedulingPeriodID = schedulingPeriodID;</span>
<span class="nc" id="L1628">			m_schedPeriodHOOStartDateLocal = schedPeriodHOOStartDateLocal;</span>
<span class="nc bnc" id="L1629" title="All 6 branches missed.">			if (campaignID == null || m_schedulingPeriodID == null || schedPeriodHOOStartDateLocal == null) {</span>
<span class="nc" id="L1630">				throw new ServiceApplicationException(&quot;Nulls not allowed in constructor&quot;);</span>
			}
<span class="nc" id="L1632">		}</span>

		@Override
		public int hashCode() {
			// CAT.error(&quot;hash inputs: &quot; + m_campaignID + &quot;, &quot; +
			// m_schedulingPeriodID + &quot;, &quot;
			// + m_schedPeriodHOOStartDateLocal);
<span class="nc" id="L1639">			return m_campaignID.toString().trim().hashCode()</span>
<span class="nc" id="L1640">					+ m_schedulingPeriodID.toString().trim().hashCode()</span>
<span class="nc" id="L1641">					+ m_schedPeriodHOOStartDateLocal.hashCode();</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc" id="L1646">			SchedPeriodHOONaturalKey k = (SchedPeriodHOONaturalKey) obj;</span>
			// CAT.error(&quot;equals this? &quot; + m_campaignID.toString().trim() + &quot;, &quot;
			// + m_schedulingPeriodID.toString().trim()
			// + &quot;, &quot; + m_schedPeriodHOOStartDateLocal + &quot;that? &quot; +
			// k.m_campaignID.toString().trim() + &quot;, &quot;
			// + k.m_schedulingPeriodID.toString().trim() + &quot;, &quot; +
			// k.m_schedPeriodHOOStartDateLocal);
			// CAT.error(&quot;equals? &quot; +
			// m_campaignID.toString().trim().equals(k.m_campaignID.toString().trim())
			// + &quot;&amp;&amp;&quot; + m_schedulingPeriodID.toString().trim().equals(k.m_schedulingPeriodID.toString().trim())
			// + &quot;&amp;&amp;&quot; + m_schedPeriodHOOStartDateLocal.equals(k.m_schedPeriodHOOStartDateLocal));
<span class="nc bnc" id="L1657" title="All 2 branches missed.">			return m_campaignID.toString().trim().equals(k.m_campaignID.toString().trim())</span>
<span class="nc" id="L1658">					&amp;&amp; m_schedulingPeriodID.toString().trim()</span>
<span class="nc bnc" id="L1659" title="All 2 branches missed.">							.equals(k.m_schedulingPeriodID.toString().trim())</span>
<span class="nc bnc" id="L1660" title="All 2 branches missed.">					&amp;&amp; m_schedPeriodHOOStartDateLocal.equals(k.m_schedPeriodHOOStartDateLocal);</span>
		}
	}

	/**
	 * we need to compare SPQueues in the database to those being synched from the external
	 * application. We decide if the latter is new entity or update entity based on campaign id and queue id.
	 */
<span class="fc" id="L1668">	public static class SPQueueNaturalKey {</span>
		private final ID m_schedulingPeriodID;
		private final ID m_queueID;

<span class="nc" id="L1672">		public SPQueueNaturalKey(ID schedulingPeriodID, ID queueID) throws ServiceApplicationException {</span>
<span class="nc bnc" id="L1673" title="All 4 branches missed.">			if (schedulingPeriodID == null || queueID == null) {</span>
<span class="nc" id="L1674">				throw new ServiceApplicationException(&quot;Nulls not allowed in constructor&quot;);</span>
			}
<span class="nc" id="L1676">			m_schedulingPeriodID = schedulingPeriodID;</span>
<span class="nc" id="L1677">			m_queueID = queueID;</span>
<span class="nc" id="L1678">		}</span>

		@Override
		public int hashCode() {
			// CAT.error(&quot;hash inputs: &quot; + m_schedulingPeriodID + &quot;, &quot; + m_queueID);
<span class="nc" id="L1683">			return m_schedulingPeriodID.toString().trim().hashCode() + m_queueID.toString().trim().hashCode();</span>
		}

		@Override
		public boolean equals(Object obj) {
<span class="nc" id="L1688">			SPQueueNaturalKey k = (SPQueueNaturalKey) obj;</span>
			// CAT.error(&quot;equals this? &quot; +
			// m_schedulingPeriodID.toString().trim() + &quot;, &quot; +
			// m_queueID.toString().trim()
			// + &quot;that? &quot; + k.m_schedulingPeriodID.toString().trim() + &quot;, &quot; +
			// k.m_queueID.toString().trim());
			// CAT.error(&quot;equals? &quot;
			// + m_schedulingPeriodID.toString().trim().equals(k.m_schedulingPeriodID.toString().trim())
			// + &quot;&amp;&amp;&quot; + m_queueID.toString().trim().equals(k.m_queueID.toString().trim()));
<span class="nc bnc" id="L1697" title="All 2 branches missed.">			return m_schedulingPeriodID.toString().trim().equals(k.m_schedulingPeriodID.toString().trim())</span>
<span class="nc bnc" id="L1698" title="All 2 branches missed.">					&amp;&amp; m_queueID.toString().trim().equals(k.m_queueID.toString().trim());</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>