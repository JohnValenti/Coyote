<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>PlannedEventTimeLineDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.rtaamanager.ejb</a> &gt; <span class="el_source">PlannedEventTimeLineDAO.java</span></div><h1>PlannedEventTimeLineDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.rtaamanager.ejb;

import java.sql.Timestamp;
import java.sql.Types;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.HashSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoPKGenerator;
import com.bluepumpkin.common.jdmo.JdmoPKGeneratorFactory;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.OrganizationDay;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.PlannedEventTimeLine;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.PlannedEventTimeLineFieldInfo;
import com.bluepumpkin.ejb.bbm.rtaamanager.model.UniqueEventID;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;

public class PlannedEventTimeLineDAO extends DAOBase {
	
	// meta data info.
<span class="fc" id="L35">	private static FieldInfo m_fieldInfo = new PlannedEventTimeLineFieldInfo();</span>
<span class="fc" id="L36">	private static JdmoPKGenerator primaryKeyGenerator = JdmoPKGeneratorFactory.create(m_fieldInfo.getTableName(), false);</span>
	
	public PlannedEventTimeLineDAO (Jdmo dmo) {
<span class="fc" id="L39">		super(dmo);</span>
<span class="fc" id="L40">	}</span>

	protected FieldInfo getFieldInfo() {
<span class="fc" id="L43">		return m_fieldInfo;</span>
	}

	protected ValueObjectBase createValueObject() {
<span class="nc" id="L47">		return new PlannedEventTimeLine();</span>
	}	
	
	/**
	 * 
	 * @param colEmployeeIDs
	 * @param hmPlannedEventTimelines
	 * @param hmActivities
	 * @param hmParentEvents
	 * @param orgDaysPerWKRS
	 * @param spDaysPerWKRS
	 * @param tsStart
	 * @param tsEnd
	 * @param bUnpublished
	 * @return planned event time line grouped by workresource id
	 * @throws Exception
	 */
	public HashMap updatePlannedEventsTimeline(
		Collection colEmployeeIDs,
		HashMap hmPlannedEventTimelines,
		HashMap hmActivities,
		HashMap hmParentEvents,
		HashMap orgDaysPerWKRS,
		HashMap spDaysPerWKRS,
		Timestamp tsStart,
		Timestamp tsEnd,
		boolean bUnpublished,
		boolean bAdhocDumpEnabled)
		throws Exception {
		try {
			//group shift by workresourceid
<span class="fc" id="L78">			HashMap hmShiftAssignments = groupShiftByWorkResource(hmParentEvents, bUnpublished);</span>
<span class="fc" id="L79">			String inClause = m_dmo.createInClause(colEmployeeIDs);</span>
			//get left overlaps
<span class="fc" id="L81">			String startDBString = &quot;'&quot; + JdmoUtil.formatDBString(tsStart) + &quot;'&quot;;</span>
<span class="fc" id="L82">			String endDBString = &quot;'&quot; + JdmoUtil.formatDBString(tsEnd) + &quot;'&quot;;</span>
<span class="fc" id="L83">			StringBuffer strSQL = new StringBuffer();</span>
<span class="fc" id="L84">			strSQL.append(&quot; WORKRESOURCEID in &quot;).append(inClause);</span>
<span class="fc" id="L85">			strSQL.append(&quot; and STARTTIME &lt; &quot;).append(startDBString);</span>
<span class="fc" id="L86">			strSQL.append(&quot; and ENDTIME &gt; &quot;).append(startDBString);</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">			strSQL.append(&quot; and ISUNPUBLISHED = &quot;).append((bUnpublished ? '1' : '0'));				</span>
<span class="fc" id="L88">			HashMap leftOverlaps = ValueObjectUtil.groupByField(PlannedEventTimeLineFieldInfo.PETIMELINE_WORKRESOURCEID, getObjects(strSQL.toString()));</span>
			
			//get right overlaps
<span class="fc" id="L91">			strSQL = new StringBuffer();</span>
<span class="fc" id="L92">			strSQL.append(&quot; WORKRESOURCEID in &quot;).append(inClause);</span>
<span class="fc" id="L93">			strSQL.append(&quot; and STARTTIME &lt; &quot;).append(endDBString);</span>
<span class="fc" id="L94">			strSQL.append(&quot; and ENDTIME &gt; &quot;).append(endDBString);</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">			strSQL.append(&quot; and ISUNPUBLISHED = &quot;).append((bUnpublished ? '1' : '0'));</span>
<span class="fc" id="L96">			HashMap rightOverlaps = ValueObjectUtil.groupByField(PlannedEventTimeLineFieldInfo.PETIMELINE_WORKRESOURCEID, getObjects(strSQL.toString()));</span>
			
<span class="fc" id="L98">			PlannedEventTimeLine leftOverlap = null;</span>
<span class="fc" id="L99">			PlannedEventTimeLine rightOverlap = null;</span>
<span class="fc" id="L100">			PlannedEventTimeLine firstNewEvent = null;</span>
<span class="fc" id="L101">			PlannedEventTimeLine lastNewEvent = null;</span>
			
<span class="fc" id="L103">			ArrayList insert = new ArrayList();</span>
			//ArrayList update = new ArrayList();
<span class="fc" id="L105">			HashSet delete = new HashSet();</span>
<span class="fc" id="L106">			ArrayList colFieldValues = new ArrayList();</span>
					
<span class="fc" id="L108">			SimpleEvent event = null;</span>
<span class="fc" id="L109">			ID idWorkResource = null;</span>
<span class="fc" id="L110">			ID idParentEvent = null;</span>
<span class="fc" id="L111">			ID idShiftAssignment = null;</span>
<span class="fc" id="L112">			ID idOrgDay = null;</span>
<span class="fc" id="L113">			ID idSPDay = null;</span>
<span class="fc" id="L114">			Event eventParent = null;</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">			for (Iterator itEmployeeID = colEmployeeIDs.iterator(); itEmployeeID.hasNext();)</span>
			{
<span class="fc" id="L117">				ID idEmployee = (ID) itEmployeeID.next();</span>
<span class="fc" id="L118">				Collection colPlannedEvents = (Collection) hmPlannedEventTimelines.get(idEmployee);</span>
<span class="fc" id="L119">				ArrayList newPlannedEvents = new ArrayList();</span>
<span class="pc bpc" id="L120" title="2 of 4 branches missed.">				if (colPlannedEvents == null || colPlannedEvents.isEmpty())</span>
<span class="nc" id="L121">					continue;</span>

<span class="fc" id="L123">				Collection orgDays = null;</span>
<span class="fc" id="L124">				Collection spDays = null;</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">				if (bAdhocDumpEnabled) {</span>
<span class="fc" id="L126">					orgDays = (Collection)orgDaysPerWKRS.get(idEmployee);</span>
<span class="pc bpc" id="L127" title="3 of 4 branches missed.">					if (orgDays != null &amp;&amp; !orgDays.isEmpty())</span>
<span class="nc" id="L128">						Collections.sort((ArrayList)orgDays);</span>
<span class="fc" id="L129">					spDays = (Collection)spDaysPerWKRS.get(idEmployee);</span>
<span class="pc bpc" id="L130" title="3 of 4 branches missed.">					if (spDays != null &amp;&amp; !spDays.isEmpty())</span>
<span class="nc" id="L131">						Collections.sort((ArrayList)spDays);</span>
				}
				
<span class="fc bfc" id="L134" title="All 2 branches covered.">				for (Iterator itEvent = colPlannedEvents.iterator(); itEvent.hasNext();) {</span>
<span class="fc" id="L135">					event = (SimpleEvent) itEvent.next();</span>
<span class="fc" id="L136">					idWorkResource = idEmployee;</span>
<span class="fc" id="L137">					idParentEvent = event.getParentID();</span>
<span class="fc" id="L138">					idShiftAssignment = null;</span>
<span class="fc" id="L139">					eventParent = null;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">					if (idParentEvent != null) {</span>
<span class="fc" id="L141">						eventParent = (Event) hmParentEvents.get(new UniqueEventID(idParentEvent, RTAAUtil.getParentEventType(event), bUnpublished));</span>
<span class="fc" id="L142">						idShiftAssignment = idParentEvent;</span>
					}
<span class="fc" id="L144">					Date dateShiftStart = null;</span>
<span class="fc" id="L145">					Date dateShiftEnd = null;</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">					if (eventParent != null) {</span>
<span class="fc" id="L147">						dateShiftStart = eventParent.getStartTime();</span>
<span class="fc" id="L148">						dateShiftEnd = eventParent.getEndTime();</span>
					} 

<span class="fc" id="L151">					boolean bIsPaid = event.getPaid();</span>
<span class="fc" id="L152">					boolean bIsWork = event.getIsWork();</span>
<span class="fc" id="L153">					boolean bIsOvertime = event.getIsOvertime();</span>
<span class="fc" id="L154">					boolean bIsBreak = false;</span>
<span class="fc" id="L155">					boolean bIsCalendar = false;</span>
<span class="fc" id="L156">					boolean bIsUnavailability = false;</span>
<span class="fc" id="L157">					boolean bIsAbsence = false;</span>

<span class="pc bpc" id="L159" title="1 of 5 branches missed.">					switch (event.getEventType()) {</span>
						case Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT : {
<span class="fc bfc" id="L161" title="All 2 branches covered.">								if (!bIsWork)</span>
<span class="fc" id="L162">									bIsBreak = true;</span>
								break;
							}
						case Event.EVENT_TYPE_UNAVAILABILITY : {
<span class="fc" id="L166">								bIsUnavailability = true;</span>
<span class="fc" id="L167">								break;</span>
							}
						case Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT : {
<span class="nc" id="L170">								bIsCalendar = true;</span>
<span class="nc" id="L171">								break;</span>
							}
						case Event.EVENT_TYPE_TIME_OFF : {
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">								if (bIsWork)</span>
<span class="fc" id="L175">									bIsAbsence = true;</span>
<span class="fc" id="L176">								bIsWork = false;</span>
								break;
							}
					}
<span class="fc" id="L180">					ID idActivity = event.getActivityID();</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">					if (idActivity.compareTo(Activity.ACTIVITY_DELETED) == 0) {</span>
<span class="fc" id="L182">						idActivity = Activity.ACTIVITY_NONE;</span>
<span class="fc" id="L183">						bIsPaid = false;</span>
<span class="fc" id="L184">						bIsWork = false;</span>
<span class="fc" id="L185">						bIsCalendar = false;</span>
<span class="fc" id="L186">						bIsUnavailability = false;</span>
<span class="fc" id="L187">						bIsAbsence = false;</span>
<span class="fc" id="L188">						dateShiftStart = null;</span>
					}
					
					//find the id of the shift assignment that the planned event are overlapped. it was done in adhoc dump stored procedure before
<span class="fc" id="L192">					ID spDayID = RTAAUtil.ID_0;</span>
<span class="fc" id="L193">					ID orgDayID = RTAAUtil.ID_0;</span>
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">					if (bAdhocDumpEnabled) {</span>
<span class="fc" id="L195">						Date eventOrgDayStart = event.getStartTime();</span>
<span class="fc" id="L196">						ID shiftSPID = null;</span>
<span class="fc" id="L197">						ShiftAssignment shift = null;</span>
						
<span class="fc bfc" id="L199" title="All 2 branches covered.">						if (eventParent != null) {</span>
<span class="fc" id="L200">							shift = (ShiftAssignment)eventParent;</span>
						} else {
<span class="fc" id="L202">							shift = findOverlapShiftAssignment((Collection)hmShiftAssignments.get(idWorkResource), event);</span>
						}
<span class="fc bfc" id="L204" title="All 2 branches covered.">						if (shift != null) {</span>
<span class="fc" id="L205">							eventOrgDayStart = shift.getStartTime(); //if event is within a shift, event org day is the shift org day</span>
<span class="fc" id="L206">							idShiftAssignment = shift.getID();</span>
<span class="fc" id="L207">							shiftSPID = shift.getCampaignID();</span>
						} else {
<span class="fc" id="L209">							idShiftAssignment = RTAAUtil.ID_0;</span>
						}
						
						
<span class="pc bpc" id="L213" title="1 of 4 branches missed.">						if (shift != null &amp;&amp; shiftSPID != null) {</span>
<span class="fc" id="L214">							spDayID = findOverlapSPDayID(spDays, shift);</span>
						}
<span class="fc" id="L216">						orgDayID = findOverlapOrgDayID(orgDays, eventOrgDayStart);</span>
					}
					
<span class="fc" id="L219">					newPlannedEvents.add(new PlannedEventTimeLine(</span>
<span class="fc" id="L220">							getNextKey(),</span>
							idWorkResource,
							idActivity,
<span class="fc" id="L223">							event.getStartTime(),</span>
<span class="fc" id="L224">							event.getEndTime(),</span>
							dateShiftStart,
							bIsPaid,
							bIsWork,
							bIsBreak,
							bIsCalendar,
							bIsUnavailability,
							bIsAbsence,
							bUnpublished,
							bIsOvertime,
<span class="fc" id="L234">							event.getEventType(),</span>
							idShiftAssignment,
							orgDayID,
							spDayID));
				
<span class="fc" id="L239">				}</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">				if (newPlannedEvents.isEmpty())</span>
<span class="nc" id="L241">					continue;</span>
				
<span class="fc" id="L243">				insert.addAll(newPlannedEvents);</span>
				
				//now for one employee we have leftoverlaps, rightoverlaps and new events.
<span class="fc" id="L246">				leftOverlap = (PlannedEventTimeLine)RTAAUtil.getOverlap(leftOverlaps, idEmployee);</span>
<span class="fc" id="L247">				rightOverlap = (PlannedEventTimeLine)RTAAUtil.getOverlap(rightOverlaps, idEmployee);</span>

<span class="fc" id="L249">				Collections.sort(newPlannedEvents);</span>
<span class="fc" id="L250">				firstNewEvent = (PlannedEventTimeLine)newPlannedEvents.get(0);</span>
<span class="fc" id="L251">				lastNewEvent = (PlannedEventTimeLine)newPlannedEvents.get(newPlannedEvents.size()-1);</span>
				
<span class="fc" id="L253">				PlannedEventTimeLine cloned = null;</span>
				
<span class="pc bpc" id="L255" title="7 of 10 branches missed.">				if (firstNewEvent != null &amp;&amp; lastNewEvent != null &amp;&amp; firstNewEvent.equals(lastNewEvent) &amp;&amp; </span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">					leftOverlap != null &amp;&amp; rightOverlap != null &amp;&amp; firstNewEvent.isBasicallyEqual(leftOverlap) ) {						</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">					if (!leftOverlap.equals(rightOverlap)) {</span>
						//update the left overlap event's endtime by delete and recreating
<span class="nc" id="L259">						delete.add(leftOverlap.getID());</span>
						//we should use org day id and sp day id of leftoverlap event since it is ealier
<span class="nc" id="L261">						cloned = (PlannedEventTimeLine)leftOverlap.clone();</span>
<span class="nc" id="L262">						cloned.setID(getNextKey());</span>
<span class="nc" id="L263">						cloned.setEndTime(firstNewEvent.getEndTime());</span>
<span class="nc" id="L264">						insert.add(cloned);</span>
						
						//update the right over lap event's start time by delete and recreate
<span class="nc" id="L267">						delete.add(rightOverlap.getID());</span>
<span class="nc" id="L268">						cloned = (PlannedEventTimeLine)rightOverlap.clone();</span>
<span class="nc" id="L269">						cloned.setID(getNextKey());</span>
<span class="nc" id="L270">						cloned.setStartTime(lastNewEvent.getEndTime());</span>
<span class="nc" id="L271">						insert.add(cloned);</span>
					} 
					//the newly dumpped event have no change
<span class="nc" id="L274">					insert.remove(firstNewEvent);</span>
<span class="nc" id="L275">					continue;</span>
				}
				
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">				if (leftOverlap != null) {</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">					if (leftOverlap.isBasicallyEqual(firstNewEvent)) {</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">						if (!firstNewEvent.getEndTime().equals(leftOverlap.getEndTime())) {</span>
							//update the left overlap event's endtime by delete and recreating
<span class="nc" id="L282">							delete.add(leftOverlap.getID());</span>
							//we should use org day id and sp day id of leftoverlap event since it is ealier
<span class="nc" id="L284">							cloned = (PlannedEventTimeLine)leftOverlap.clone();</span>
<span class="nc" id="L285">							cloned.setID(getNextKey());</span>
<span class="nc" id="L286">							cloned.setEndTime(firstNewEvent.getEndTime());</span>
<span class="nc" id="L287">							insert.add(cloned);</span>
						}
<span class="nc" id="L289">						insert.remove(firstNewEvent);</span>
					} else {
						//update the existing event's endtime by delete and recreating
<span class="nc" id="L292">						delete.add(leftOverlap.getID());</span>
<span class="nc" id="L293">						cloned = (PlannedEventTimeLine)leftOverlap.clone();</span>
<span class="nc" id="L294">						cloned.setID(getNextKey());</span>
<span class="nc" id="L295">						cloned.setEndTime(firstNewEvent.getStartTime());</span>
<span class="nc" id="L296">						insert.add(cloned);</span>
					}
				}
				
<span class="pc bpc" id="L300" title="1 of 2 branches missed.">				if (rightOverlap != null) {</span>
<span class="nc bnc" id="L301" title="All 2 branches missed.">					if (rightOverlap.isBasicallyEqual(lastNewEvent)) {</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">						if (!lastNewEvent.getStartTime().equals(rightOverlap.getStartTime())) {</span>
							//update the right overlap event's start time by delete and recreating
<span class="nc" id="L304">							delete.add(rightOverlap.getID());</span>
							//we should use org day id and sp day id of new created event since it is earlier
<span class="nc" id="L306">							lastNewEvent.setEndTime(rightOverlap.getEndTime());</span>
						} else {
<span class="nc" id="L308">							insert.remove(lastNewEvent);</span>
						}
					} else {
						//update the right over lap event's start time by delete and recreate
<span class="nc" id="L312">						delete.add(rightOverlap.getID());</span>
<span class="nc" id="L313">						cloned = (PlannedEventTimeLine)rightOverlap.clone();</span>
<span class="nc" id="L314">						cloned.setID(getNextKey());</span>
<span class="nc" id="L315">						cloned.setStartTime(lastNewEvent.getEndTime());</span>
<span class="nc" id="L316">						insert.add(cloned);</span>
					}
				}
<span class="fc" id="L319">			}</span>
			
			//clear out events that fall within window
<span class="fc" id="L322">			StringBuffer strQuery = new StringBuffer(200);</span>
<span class="fc bfc" id="L323" title="All 2 branches covered.">			if (!bUnpublished) {</span>
<span class="fc" id="L324">				strQuery.append(&quot;delete from &quot;).append(m_fieldInfo.getTableName());</span>
				/*
				if (m_dmo.isMsSqlDB())
					strQuery.append(&quot; with (rowlock) &quot;);*/
				
<span class="fc" id="L329">				strQuery.append(&quot; where WORKRESOURCEID in &quot;);</span>
<span class="fc" id="L330">				strQuery.append(inClause);</span>
<span class="fc" id="L331">				strQuery.append(&quot; and STARTTIME &gt;= &quot;);</span>
<span class="fc" id="L332">				strQuery.append(startDBString);</span>
<span class="fc" id="L333">				strQuery.append(&quot; and ENDTIME &lt;= &quot;);</span>
<span class="fc" id="L334">				strQuery.append(endDBString);</span>
				//strQuery.append(&quot; and ISUNPUBLISHED = &quot;);
				//strQuery.append((bUnpublished ? 1 : 0));
<span class="fc" id="L337">				m_dmo.execute(strQuery.toString());</span>
			}
			
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">			if (!delete.isEmpty()) {</span>
<span class="nc" id="L341">				Collections.sort(new ArrayList(delete));</span>
<span class="nc" id="L342">				strQuery = new StringBuffer(200);</span>
<span class="nc" id="L343">				strQuery.append(&quot; delete from &quot;).append(m_fieldInfo.getTableName());</span>
<span class="nc" id="L344">				strQuery.append(&quot; where id in &quot;).append(m_dmo.createInClause(delete));</span>
<span class="nc" id="L345">                m_dmo.execute(strQuery.toString());</span>
			}
			
			//update
			/*
			if (!update.isEmpty()) {
				JdmoPCommand pc = m_dmo.createPCommand(&quot;update &quot;+m_fieldInfo.getTableName()+&quot; with (rowlock) set starttime = ?, endtime = ? where id = ?&quot;);
				HashMap param = new HashMap();
				int ix = 0;
				PlannedEventTimeLine plEvent = null;
				for (Iterator iter = update.iterator(); iter.hasNext();) {
					plEvent = (PlannedEventTimeLine)iter.next();
					param.clear();
					param.put(new Integer(1), event.getStartTime());
					param.put(new Integer(2), event.getEndTime());
					param.put(new Integer(3), event.getID());
					m_dmo.addBatchPCommand(pc, param);
				}
				m_dmo.executeBatchPCommand(pc);
			}*/
			
			//insert
<span class="fc" id="L367">			String arrFieldNames[] =</span>
				new String[] {
					&quot;ID&quot;,
					&quot;STARTTIME&quot;,
					&quot;ENDTIME&quot;,
					&quot;SHIFTSTARTTIME&quot;,
					&quot;ACTIVITYID&quot;,
					&quot;WORKRESOURCEID&quot;,				
					&quot;ISPAID&quot;,
					&quot;ISWORK&quot;,
					&quot;ISCALENDAR&quot;,
					&quot;ISUNAVAILABILITY&quot;,
					&quot;ISABSENCE&quot;,
					&quot;ISBREAK&quot;,					
					&quot;ISUNPUBLISHED&quot;,
					&quot;ISOVERTIME&quot;,
					&quot;EVENTTYPE&quot;,
					&quot;ORGANIZATIONDAYID&quot;,
					&quot;SPDAYID&quot;,
					&quot;SHIFTASSIGNMENTID&quot;};
<span class="fc" id="L387">			int arrFieldTypes[] = { Types.INTEGER, </span>
									Types.TIMESTAMP, 
									Types.TIMESTAMP, 
									Types.TIMESTAMP,
									Types.INTEGER,
									Types.INTEGER, 
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.BOOLEAN,
									Types.INTEGER,
									Types.INTEGER,
									Types.INTEGER,
									Types.INTEGER
									};
<span class="fc" id="L406">			Object[] fields = null;</span>
<span class="fc" id="L407">			PlannedEventTimeLine plEvent = null;</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">			for (Iterator i = insert.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L409">				plEvent = (PlannedEventTimeLine)i.next();</span>
<span class="fc" id="L410">				fields = plEvent.getFieldValues();</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">				for (int ix = 0; ix &lt; fields.length; ix ++) {</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">					if (plEvent.isFieldNull(ix))</span>
<span class="fc" id="L413">						fields[ix] = null;</span>
				}
<span class="fc" id="L415">				colFieldValues.add(plEvent.getFieldValues());</span>
			}
<span class="fc" id="L417">			System.out.println(&quot;updatePlannedEventsTimeLine for Employees &quot;+ colEmployeeIDs.toString() +  &quot;between &quot; + tsStart + &quot;-&quot; + tsEnd +&quot;: insert-&quot; + insert.size() + &quot;, delete-&quot; + delete.size()) ;//+ &quot;, update-&quot; + update.size());</span>
<span class="fc" id="L418">			m_dmo.insertBatchAndExecute(m_fieldInfo.getTableName(), arrFieldNames, arrFieldTypes, colFieldValues);</span>
<span class="fc" id="L419">			return ValueObjectUtil.groupByField(PlannedEventTimeLineFieldInfo.PETIMELINE_WORKRESOURCEID, insert);</span>
		} finally {
<span class="pc" id="L421">			m_dmo.cleanUp();;</span>
		}
	}
	
	private HashMap groupShiftByWorkResource(HashMap hmParentEvents, boolean isUnpublished) {
<span class="fc" id="L426">		HashMap map = new HashMap();</span>
		
<span class="fc" id="L428">		ArrayList list = null;</span>
<span class="fc" id="L429">		Map.Entry entry = null;</span>
<span class="fc" id="L430">		UniqueEventID id = null;</span>
<span class="fc" id="L431">		ShiftAssignment shift = null;</span>
<span class="fc" id="L432">		ID workresourceID = null;</span>
<span class="fc bfc" id="L433" title="All 2 branches covered.">		for (Iterator i = hmParentEvents.entrySet().iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L434">			entry = (Map.Entry)i.next();</span>
<span class="fc" id="L435">			id = (UniqueEventID)entry.getKey();</span>
<span class="fc bfc" id="L436" title="All 4 branches covered.">			if ((id.isUnPublished() == isUnpublished) &amp;&amp; (id.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT)) {</span>
<span class="fc" id="L437">				shift = (ShiftAssignment)entry.getValue();</span>
<span class="fc" id="L438">				workresourceID = (ID)(shift.getWorkResourceIDs()).iterator().next(); //shift must has one workresource</span>
<span class="fc" id="L439">				list = (ArrayList)map.get(workresourceID);</span>
<span class="fc bfc" id="L440" title="All 2 branches covered.">				if (list == null) {</span>
<span class="fc" id="L441">					list = new ArrayList();</span>
<span class="fc" id="L442">					map.put(workresourceID, list);</span>
				}
<span class="fc" id="L444">				list.add(shift);				</span>
			}
		}
<span class="fc" id="L447">		return map;		</span>
	}
	
	//find the sp day that the shift linked to
	/*
	  	select 	PLANNEDEVENTTIMELINE.ID PLANNEDEVENTTIMELINE_ID,
		max(ORGANIZATIONDAY.ID) SPDAY_ID
		from		ORGANIZATIONDAY
		join		SP
		on			SP.SID = ORGANIZATIONDAY.SPID
		join		SPWORKRESOURCE
		on  		SPWORKRESOURCE.SPID = SP.ID
		join		SHIFTASSIGNMENT as ShiftAssignment
		on			SPWORKRESOURCE.WORKRESOURCEID = ShiftAssignment.WORKRESOURCEID
		and ShiftAssignment.STARTTIME between @fromdate and @todate
		and ShiftAssignment.SPID = SP.SID
		and ShiftAssignment.STARTTIME &gt;= ORGANIZATIONDAY.STARTTIME
		and (ShiftAssignment.STARTTIME &lt; ORGANIZATIONDAY.ENDTIME or ORGANIZATIONDAY.ENDTIME is null)
		join 		PLANNEDEVENTTIMELINE
		on			SPWORKRESOURCE.WORKRESOURCEID = PLANNEDEVENTTIMELINE.WORKRESOURCEID
		and PLANNEDEVENTTIMELINE.STARTTIME &lt; ShiftAssignment.ENDTIME
		and PLANNEDEVENTTIMELINE.ENDTIME &gt; ShiftAssignment.STARTTIME
		and PLANNEDEVENTTIMELINE.ISUNPUBLISHED = 1
		and PLANNEDEVENTTIMELINE.STARTTIME between @fromdate and @todate
		join 		#EmployeeIDs
		on	 		#EmployeeIDs.ID = PLANNEDEVENTTIMELINE.WORKRESOURCEID
		where 	PLANNEDEVENTTIMELINE.SPDAYID is null
		and ORGANIZATIONDAY.STARTTIME between @fromdate and @todate
		and PLANNEDEVENTTIMELINE.STARTTIME between @fromdate and @todate
		group by PLANNEDEVENTTIMELINE.ID
		
		note: one employee could belong to multiple sps at the same time, so using shift assignment sp id to to get sp day is more accurate.
	 */
	private ID findOverlapSPDayID(Collection spDayIDs, ShiftAssignment shift) {
<span class="fc" id="L481">		OrganizationDay spDay = null;</span>
<span class="pc bpc" id="L482" title="1 of 2 branches missed.">		if (spDayIDs == null)</span>
<span class="fc" id="L483">			return RTAAUtil.ID_0;</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">		for (Iterator i = spDayIDs.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L485">			spDay = (OrganizationDay)i.next();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">			if (spDay.getSPID().equals(shift.getCampaignID()) &amp;&amp;</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">				!shift.getStartTime().before(spDay.getStartTime())&amp;&amp;</span>
<span class="nc bnc" id="L488" title="All 4 branches missed.">				( spDay.getEndTime() == null ||shift.getStartTime().before(spDay.getEndTime())))</span>
<span class="nc" id="L489">				return spDay.getID();</span>
		}
<span class="nc" id="L491">		return RTAAUtil.ID_0;</span>
	}
	
	private ID findOverlapOrgDayID(Collection orgDays,Date timespot) {
<span class="fc" id="L495">		OrganizationDay orgDay = null;</span>
<span class="pc bpc" id="L496" title="1 of 2 branches missed.">		if (orgDays == null)</span>
<span class="fc" id="L497">			return RTAAUtil.ID_0;</span>
<span class="nc bnc" id="L498" title="All 2 branches missed.">		for (Iterator i = orgDays.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L499">			orgDay = (OrganizationDay)i.next();</span>
<span class="nc bnc" id="L500" title="All 4 branches missed.">			if ((orgDay.getEndTime() == null || timespot.before(orgDay.getEndTime())&amp;&amp;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">				( !timespot.before(orgDay.getStartTime()))))</span>
<span class="nc" id="L502">				return orgDay.getID();</span>
		}
<span class="nc" id="L504">		return RTAAUtil.ID_0;</span>
	}
	
	private ShiftAssignment findOverlapShiftAssignment(Collection colShiftAssignment, SimpleEvent event) {
<span class="fc" id="L508">		ShiftAssignment shiftAssignment = null;</span>
<span class="pc bpc" id="L509" title="2 of 4 branches missed.">		if (colShiftAssignment != null &amp;&amp; !colShiftAssignment.isEmpty()) {</span>
<span class="fc" id="L510">			Collections.sort((ArrayList)colShiftAssignment);</span>
<span class="fc" id="L511">			Collections.reverse((ArrayList)colShiftAssignment);</span>
<span class="fc" id="L512">			ShiftAssignment shift = null;</span>
<span class="fc bfc" id="L513" title="All 2 branches covered.">			for (Iterator i = colShiftAssignment.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L514">				shift = (ShiftAssignment)i.next();</span>
<span class="fc bfc" id="L515" title="All 2 branches covered.">				if (event.getStartTime().before(shift.getEndTime()) &amp;&amp;</span>
<span class="fc bfc" id="L516" title="All 2 branches covered.">					event.getEndTime().after(shift.getStartTime()))</span>
<span class="fc" id="L517">					return shift;</span>
			}
		}
<span class="fc" id="L520">		return shiftAssignment;</span>
	}
	
	private ID getNextKey() throws Exception {
<span class="fc" id="L524">		return primaryKeyGenerator.generate(m_dmo.getConnection(), m_fieldInfo.getTableName());</span>
	}
}


</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>