<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ActualTraceCube.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">ActualTraceCube.java</span></div><h1>ActualTraceCube.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.model;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.workload.model.Media;

import java.util.Date;
import java.util.TimeZone;

public class ActualTraceCube extends TraceCube {

	private static final long serialVersionUID = 1L;
	// As of August 2010, every defined trace type except DEADLINE_TIME
	// can be derived from actual values.
<span class="fc" id="L16">	public static final short[] TYPES = { Trace.CV, Trace.AHT, Trace.PCA,</span>
			Trace.ASA, Trace.ABANDONMENT, Trace.BACKLOG, Trace.STAFFING,
			Trace.OCCUPANCY, Trace.FTE, Trace.DIALS, Trace.CONNECTS,
			Trace.CRATE, Trace.RPC, Trace.RPCRATE, Trace.RPCAHT, Trace.VH,
			Trace.VAR, Trace.CV_VH, Trace.ASA_WEIGHT };

	// array of all trace types that are computed for ActualTraceCube
<span class="fc" id="L23">	private static final short[] COMPUTED_TYPES = { CRATE, RPCRATE, VAR, CV_VH, ASA_WEIGHT};</span>

<span class="fc" id="L25">	public ActualTraceCube() {</span>
<span class="fc" id="L26">	}</span>

	public ActualTraceCube(short[] types) {
<span class="fc" id="L29">		super(types);</span>
<span class="fc" id="L30">	}</span>

	/**
	 * TraceCube is a container for types of Trace, given period
	 *
	 * @param queueID
	 * @param startDate,
	 * @param endDate,
	 * @param types, the Trace Types to be included
	 */
	public ActualTraceCube(ID queueID, Date startDate, Date endDate,
			short[] types) throws BbmTimeSeriesException {
<span class="nc" id="L42">		this(queueID, startDate, endDate, types, TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L43">	}</span>

	/**
	 * TraceCube is a container for types of Trace, given period
	 *
	 * @param queueID 
	 * @param startDate
	 * @param endDate   
	 * @param types, the Trace Types to be included
	 * @param timeZone
	 */
	public ActualTraceCube(ID queueID, Date startDate, Date endDate,
			short[] types, TimeZone timeZone) throws BbmTimeSeriesException {
<span class="nc" id="L56">		super(queueID, startDate, endDate, types);</span>
<span class="nc" id="L57">		checkTraceTypeSupport(types);</span>
<span class="nc" id="L58">	}</span>

	// Base TraceCube supports all types of Trace
	protected short[] getSupportedTraceType() {
<span class="fc" id="L62">		return TYPES;</span>
	}

	public short[] getComputedTraceTypes() {
<span class="nc" id="L66">		return COMPUTED_TYPES;</span>
	}

	// Override parent function used in toString()
	protected String getCubeName() {
<span class="nc" id="L71">		return &quot;QUEUEHISTORYTIMESERIES&quot;;</span>
	}

	// make a clone from given parameters
	public TraceCube newInstance(ID queueID, Date startDate, Date endDate,
			short[] types) throws BbmTimeSeriesException {
<span class="nc" id="L77">		return new ActualTraceCube(queueID, startDate, endDate, types);</span>
	}

	/**
	 * Calculates all the computed values for the given array of Trace types.
	 * this method needs to implemented in all child object that use computed
	 * trace types the computation is done for each time interval Separately
	 * (identified by the offset) This method is used to calculate the computed
	 * values of the trace cube and should be called for each time interval
	 * after all the reqd values are acquired for a that time interval.
	 *
	 * @param mediaID
	 * @return result
	 */
	public void calcComputedTraceValues(ID mediaID) {
<span class="nc" id="L92">		short[] traceTypes = getTraceTypes();</span>
<span class="nc bnc" id="L93" title="All 2 branches missed.">		for (short type : traceTypes) {</span>
<span class="nc bnc" id="L94" title="All 2 branches missed.">			if (isTraceTypeComputed(type)) {</span>
<span class="nc bnc" id="L95" title="All 4 branches missed.">				if (type == Trace.CRATE || type == Trace.RPCRATE) {</span>
<span class="nc" id="L96">					calcComputedTraceValuesForOutbound(type);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">				} else if (type == Trace.CV_VH) {</span>
<span class="nc" id="L98">					calcComputedTraceValuesFoCVAndVH(type);</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">				} else if (type == Trace.VAR) {</span>
<span class="nc bnc" id="L100" title="All 4 branches missed.">					if (Media.isMediaImmediate(mediaID) &amp;&amp; Trace.isComputeActualImmediateSLOnVHAndAbandons()) {</span>
<span class="nc" id="L101">						calcComputedTraceValuesForVARWithVHAndABN(mediaID, type);</span>
					} else {
<span class="nc" id="L103">						calcComputedTraceValuesForVARWithCVOrVH(mediaID, type);</span>
					}
<span class="nc bnc" id="L105" title="All 2 branches missed.">				} else if (type == Trace.ASA_WEIGHT) {</span>
<span class="nc" id="L106">					calcComputedTraceValuesForASAWEIGHT(type, mediaID);</span>
				}
			}
		}
<span class="nc" id="L110">	}</span>

	/**
	 * Calculate ASA_WEIGHT, which is used as the weight in the weighted average formula for
	 * Immediate Actual cubes only. All other cubes use a weight of (CV-ABANDONS) for ASA. See
	 * TraceOperator.getDependentTypeForWeightedAvgForPeriod().
	 * @param type - the trace type (should be Trace.ASA)
	 * @param mediaID - the weighted average dependent type depends on media type
	 */
	private void calcComputedTraceValuesForASAWEIGHT(short type, ID mediaID) {
		double[] weightingArray;
<span class="nc" id="L121">		double[] vhArray = getTraceValueD(Trace.VH);</span>
<span class="nc" id="L122">		double[] cvArray = getTraceValueD(Trace.CV);</span>
<span class="nc" id="L123">		double[] abandonmentArray = getTraceValueD(Trace.ABANDONMENT);</span>

<span class="nc bnc" id="L125" title="All 4 branches missed.">		if (Media.isMediaImmediate(mediaID) &amp;&amp; doesArrayHaveValidValues(vhArray)) {</span>
<span class="nc" id="L126">			weightingArray = copyOf(vhArray);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">		} else if (!doesArrayHaveValidValues(abandonmentArray)) {</span>
<span class="nc" id="L128">			weightingArray = copyOf(cvArray);</span>
		} else {
<span class="nc" id="L130">			weightingArray = zipDifferenceBetween(cvArray, abandonmentArray);</span>
		}
<span class="nc" id="L132">		setTraceValue(type, weightingArray);</span>
<span class="nc" id="L133">	}</span>

	private double[] copyOf(double[] input) {
<span class="nc" id="L136">		double[] result = new double[input.length];</span>
<span class="nc" id="L137">		System.arraycopy(input, 0, result, 0, input.length);</span>
<span class="nc" id="L138">		return result;</span>
	}

	private double[] zipDifferenceBetween(double[] cvArray, double [] abandonmentArray) {
		double[] differences;
<span class="nc" id="L143">		int shorterLength = Math.min(cvArray.length, abandonmentArray.length);</span>
<span class="nc" id="L144">		differences = new double[shorterLength];</span>
<span class="nc" id="L145">		initIntArray(differences);</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">		for (int i = 0; i &lt; shorterLength; i++) {</span>
<span class="nc bnc" id="L147" title="All 4 branches missed.">			if (cvArray[i] &gt;= 0 &amp;&amp; abandonmentArray[i] &gt;= 0) {</span>
<span class="nc" id="L148">				differences[i] = cvArray[i] - abandonmentArray[i];</span>
			}
		}
<span class="nc" id="L151">		return differences;</span>
	}

	protected void calcComputedTraceValuesForVARWithVHAndABN(ID mediaID, short type) {
<span class="nc" id="L155">		double[] abandonmentArray = getTraceValueD(Trace.ABANDONMENT);</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">		if (!doesArrayHaveValidValues(abandonmentArray)) {</span>
<span class="nc" id="L157">			calcComputedTraceValuesForVARWithCVOrVH(mediaID, type);</span>
<span class="nc" id="L158">			return;</span>
		}

		double[] valueArray;
<span class="nc" id="L162">		double[] vhArray = getTraceValueD(Trace.VH);</span>
<span class="nc bnc" id="L163" title="All 2 branches missed.">		if (!doesArrayHaveValidValues(vhArray)) {</span>
<span class="nc" id="L164">			double[] cvArray = getTraceValueD(Trace.CV);</span>
<span class="nc" id="L165">			valueArray = copyOf(cvArray);</span>
<span class="nc" id="L166">		} else {</span>
<span class="nc" id="L167">			valueArray = zipSumsOf(vhArray, abandonmentArray);</span>
		}
<span class="nc" id="L169">		setTraceValue(type, valueArray);</span>
<span class="nc" id="L170">	}</span>

	private double[] zipSumsOf(double[] vhArray, double[] abandonmentArray) {
		double[] sums;
<span class="nc" id="L174">		int shorterLength = Math.min(vhArray.length, abandonmentArray.length);</span>
<span class="nc" id="L175">		sums = new double[shorterLength];</span>
<span class="nc" id="L176">		initIntArray(sums);</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">		for (int i = 0; i &lt; shorterLength; i++) {</span>
<span class="nc bnc" id="L178" title="All 4 branches missed.">			if (vhArray[i] &gt;= 0 &amp;&amp; abandonmentArray[i] &gt;= 0) {</span>
<span class="nc" id="L179">				sums[i] = vhArray[i] + abandonmentArray[i];</span>
			}
		}
<span class="nc" id="L182">		return sums;</span>
	}

	protected void calcComputedTraceValuesForVARWithCVOrVH(ID mediaID, short type) {
<span class="nc" id="L186">		double[] cArray = null;</span>
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (isVolumeHandledEnabled()</span>
<span class="nc bnc" id="L188" title="All 4 branches missed.">				&amp;&amp; (isAlwaysUseVHInsteadOfCV()</span>
<span class="nc bnc" id="L189" title="All 2 branches missed.">				|| (mediaID != null &amp;&amp; !Media.isMediaImmediate(mediaID)))) {</span>
<span class="nc" id="L190">			cArray = getTraceValueD(Trace.VH);</span>
		}
<span class="nc bnc" id="L192" title="All 2 branches missed.">		if (!doesArrayHaveValidValues(cArray)) {</span>
<span class="nc" id="L193">			cArray = getTraceValueD(Trace.CV);</span>
		}
<span class="nc" id="L195">		double[] value = copyOf(cArray);</span>
<span class="nc" id="L196">		setTraceValue(type, value);</span>
<span class="nc" id="L197">	}</span>

	protected void calcComputedTraceValuesFoCVAndVH(short type) {
<span class="nc" id="L200">		double[] cArray = null;</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">		if (isVolumeHandledEnabled()) {</span>
<span class="nc" id="L202">			cArray = getTraceValueD(Trace.VH);</span>
		}
<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (!doesArrayHaveValidValues(cArray)) {</span>
<span class="nc" id="L205">			cArray = getTraceValueD(Trace.CV);</span>
		}
<span class="nc" id="L207">		double[] value = copyOf(cArray);</span>
<span class="nc" id="L208">		setTraceValue(type, value);</span>
<span class="nc" id="L209">	}</span>

	protected void calcComputedTraceValuesForOutbound(short type) {
<span class="nc" id="L212">		double[] cArray = null;</span>
<span class="nc" id="L213">		double[] dialsArray = getTraceValueD(Trace.DIALS);</span>
<span class="nc bnc" id="L214" title="All 2 branches missed.">		if (type == Trace.CRATE) {</span>
<span class="nc" id="L215">			cArray = getTraceValueD(Trace.CONNECTS);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">		} else if (type == Trace.RPCRATE) {</span>
<span class="nc" id="L217">			cArray = getTraceValueD(Trace.RPC);</span>
		}
<span class="nc bnc" id="L219" title="All 4 branches missed.">		if (dialsArray == null || cArray == null) {</span>
<span class="nc" id="L220">			return;</span>
		}
<span class="nc bnc" id="L222" title="All 2 branches missed.">		int arrayLength = dialsArray.length &gt; cArray.length ? cArray.length : dialsArray.length;</span>
<span class="nc" id="L223">		double[] value = new double[arrayLength];</span>
<span class="nc" id="L224">		initIntArray(value);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		for (int i = 0; i &lt; cArray.length; i++) {</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">			if (i &lt; dialsArray.length) {</span>
<span class="nc bnc" id="L227" title="All 4 branches missed.">				if (cArray[i] &gt;= 0 &amp;&amp; dialsArray[i] &gt; 0) {</span>
<span class="nc" id="L228">					value[i] = (cArray[i] * 100) / dialsArray[i];</span>
<span class="nc bnc" id="L229" title="All 4 branches missed.">				} else if (cArray[i] == 0 &amp;&amp; dialsArray[i] == 0) {</span>
<span class="nc" id="L230">					value[i] = 0;</span>
				}
			} else {
				break;
			}
		}
<span class="nc" id="L236">		setTraceValue(type, value);</span>
<span class="nc" id="L237">	}</span>

	public void calcComputedTraceValues(short[] traceTypes,
			float[] traceValues, ID mediaID) {
<span class="nc" id="L241">		float dials = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
				Trace.DIALS, traceTypes, traceValues);
<span class="nc bnc" id="L243" title="All 2 branches missed.">		for (int traceTypeColumn = 0; traceTypeColumn &lt; traceTypes.length; traceTypeColumn++) {</span>
<span class="nc" id="L244">			short type = traceTypes[traceTypeColumn];</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">			if (isTraceTypeComputed(type)) {</span>
<span class="nc bnc" id="L246" title="All 4 branches missed.">				if (type == Trace.CRATE || type == Trace.RPCRATE) {</span>
<span class="nc" id="L247">					calcComputedTraceValuesForOutbound(traceTypes, traceValues, dials, traceTypeColumn, type);</span>
<span class="nc bnc" id="L248" title="All 2 branches missed.">				} else if (type == Trace.CV_VH) {</span>
<span class="nc" id="L249">					calcComputedTraceValuesFoCVAndVH(traceTypes, traceValues, traceTypeColumn);</span>
<span class="nc bnc" id="L250" title="All 2 branches missed.">				} else if (type == Trace.VAR) {</span>
<span class="nc bnc" id="L251" title="All 4 branches missed.">					if (Media.isMediaImmediate(mediaID) &amp;&amp; Trace.isComputeActualImmediateSLOnVHAndAbandons()) {</span>
<span class="nc" id="L252">						calcComputedTraceValuesForVARWithVHAndABN(traceTypes, traceValues, traceTypeColumn);</span>
					} else {
<span class="nc" id="L254">						calcComputedTraceValuesForVARWithCVOrVH(traceTypes, traceValues, mediaID, traceTypeColumn);</span>
					}
<span class="nc bnc" id="L256" title="All 2 branches missed.">				} else if (type == Trace.ASA_WEIGHT) {</span>
<span class="nc" id="L257">					calcComputedTraceValuesForASAWEIGHT(traceTypes, traceValues, traceTypeColumn);</span>
				}
			}
		}
<span class="nc" id="L261">	}</span>

	private void calcComputedTraceValuesForASAWEIGHT(short[] traceTypes, float[] traceValues, int traceTypeColumn) {
		float resultVal;
<span class="nc" id="L265">		float vhVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.VH, traceTypes, traceValues);</span>
<span class="nc" id="L266">		float cvVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.CV, traceTypes, traceValues);</span>
<span class="nc" id="L267">		float abnVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.ABANDONMENT, traceTypes, traceValues);</span>

<span class="nc bnc" id="L269" title="All 2 branches missed.">		if (isTraceValueValid(vhVal)) {</span>
<span class="nc" id="L270">			resultVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.VH, traceTypes, traceValues);</span>
<span class="nc bnc" id="L271" title="All 4 branches missed.">		} else if (isTraceValueValid(cvVal) &amp;&amp; isTraceValueValid(abnVal)) {</span>
<span class="nc" id="L272">			resultVal = cvVal - abnVal;</span>
		} else {
<span class="nc" id="L274">			resultVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.CV, traceTypes, traceValues);</span>
		}
<span class="nc" id="L276">		traceValues[traceTypeColumn] = resultVal;</span>
<span class="nc" id="L277">	}</span>

	protected void calcComputedTraceValuesForVARWithVHAndABN(short[] traceTypes, float[] traceValues, int traceTypeColumn) {
		float varVal;
<span class="nc" id="L281">		float abnVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.ABANDONMENT, traceTypes, traceValues);</span>
<span class="nc" id="L282">		float vhVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.VH, traceTypes, traceValues);</span>

<span class="nc bnc" id="L284" title="All 4 branches missed.">		if (isTraceValueValid(abnVal) &amp;&amp; isTraceValueValid(vhVal)) {</span>
<span class="nc" id="L285">			varVal = abnVal + vhVal;</span>
		} else {
<span class="nc" id="L287">			varVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(Trace.CV, traceTypes, traceValues);</span>
		}
<span class="nc" id="L289">		traceValues[traceTypeColumn] = varVal;</span>
<span class="nc" id="L290">	}</span>

	protected void calcComputedTraceValuesForVARWithCVOrVH(short[] traceTypes, float[] traceValues, ID mediaID, int traceTypeColumn) {
<span class="nc" id="L293">		float cVal = Trace.TRACENA;</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">		if (isVolumeHandledEnabled()</span>
<span class="nc bnc" id="L295" title="All 6 branches missed.">				&amp;&amp; (isAlwaysUseVHInsteadOfCV() || (mediaID != null &amp;&amp; !Media.isMediaImmediate(mediaID)))) {</span>
<span class="nc" id="L296">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.VH, traceTypes, traceValues);
		}
<span class="nc bnc" id="L299" title="All 2 branches missed.">		if (!isTraceValueValid(cVal)) {</span>
<span class="nc" id="L300">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.CV, traceTypes, traceValues);
		}
<span class="nc" id="L303">		traceValues[traceTypeColumn] = cVal;</span>
<span class="nc" id="L304">	}</span>

	protected void calcComputedTraceValuesFoCVAndVH(short[] traceTypes, float[] traceValues, int traceTypeColumn) {
<span class="nc" id="L307">		float cVal = Trace.TRACENA;</span>
<span class="nc bnc" id="L308" title="All 2 branches missed.">		if (isVolumeHandledEnabled()) {</span>
<span class="nc" id="L309">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.VH, traceTypes, traceValues);
		}
<span class="nc bnc" id="L312" title="All 2 branches missed.">		if (!isTraceValueValid(cVal)) {</span>
<span class="nc" id="L313">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.CV, traceTypes, traceValues);
		}
<span class="nc" id="L316">		traceValues[traceTypeColumn] = cVal;</span>
<span class="nc" id="L317">	}</span>

	protected void calcComputedTraceValuesForOutbound(short[] traceTypes, float[] traceValues, float dials, int traceTypeColumn,
			short type) {
<span class="nc" id="L321">		float cVal = Trace.TRACENA;</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">		if (type == Trace.CRATE) {</span>
<span class="nc" id="L323">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.CONNECTS, traceTypes, traceValues);
<span class="nc bnc" id="L325" title="All 2 branches missed.">		} else if (type == Trace.RPCRATE) {</span>
<span class="nc" id="L326">			cVal = getTraceValueForTraceTypeFromGivenArrayOfTraceValues(</span>
					Trace.RPC, traceTypes, traceValues);
		}
<span class="nc bnc" id="L329" title="All 4 branches missed.">		if (dials &gt; 0 &amp;&amp; cVal &gt;= 0) {</span>
<span class="nc" id="L330">			traceValues[traceTypeColumn] = (cVal * 100) / dials;</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">		} else if (dials == 0 &amp;&amp; cVal == 0) {</span>
<span class="nc" id="L332">			traceValues[traceTypeColumn] = 0;</span>
		}
<span class="nc" id="L334">	}</span>

	public void calcComputedTraceValuesForTraceChunk(TraceChunk traceChunk, ID mediaID) {
<span class="nc" id="L337">		calcComputedTraceValuesForTraceChunkForOutbound(traceChunk);</span>

<span class="nc" id="L339">		float vhVal = traceChunk.getTraceValue(Trace.VH);</span>
<span class="nc bnc" id="L340" title="All 4 branches missed.">		boolean setVH = isVolumeHandledEnabled() &amp;&amp; isTraceValueValid(vhVal);</span>
<span class="nc" id="L341">		calcComputedTraceValuesForTraceChunkForCVOrVH(traceChunk, setVH);</span>

<span class="nc" id="L343">		calcComputedTraceValuesForTraceChunkForVARWithCVOrVH(traceChunk, mediaID, setVH);</span>

<span class="nc bnc" id="L345" title="All 6 branches missed.">		if (Media.isMediaImmediate(mediaID) &amp;&amp; Trace.isComputeActualImmediateSLOnVHAndAbandons() &amp;&amp; setVH) {</span>
<span class="nc" id="L346">			calcComputedTraceValuesForTraceChunkForVARWithVHAndABN(traceChunk, mediaID, vhVal);</span>
		} else {
<span class="nc" id="L348">			calcComputedTraceValuesForTraceChunkForVARWithCVOrVH(traceChunk, mediaID, setVH);</span>
		}

<span class="nc" id="L351">		calcComputedTraceValuesForTraceChunkForASAWEIGHT(traceChunk, mediaID, vhVal);</span>
<span class="nc" id="L352">	}</span>

	private void calcComputedTraceValuesForTraceChunkForASAWEIGHT(TraceChunk traceChunk, ID mediaID, float vhVal) {
<span class="nc" id="L355">		float cvVal = traceChunk.getTraceValue(Trace.CV);</span>
<span class="nc" id="L356">		float abnVal = traceChunk.getTraceValue(Trace.ABANDONMENT);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">		if (isTraceValueValid(vhVal)) {</span>
<span class="nc" id="L358">			traceChunk.setTraceValue(Trace.ASA_WEIGHT, vhVal);</span>
<span class="nc bnc" id="L359" title="All 4 branches missed.">		} else if (isTraceValueValid(cvVal) &amp;&amp; isTraceValueValid(abnVal)) {</span>
<span class="nc" id="L360">			float resultVal = cvVal - abnVal;</span>
<span class="nc" id="L361">			traceChunk.setTraceValue(Trace.ASA_WEIGHT, resultVal);</span>
<span class="nc" id="L362">		} else {</span>
<span class="nc" id="L363">			traceChunk.setTraceValue(Trace.ASA_WEIGHT, cvVal);</span>
		}
<span class="nc" id="L365">	}</span>

	protected void calcComputedTraceValuesForTraceChunkForVARWithVHAndABN(TraceChunk traceChunk,  ID mediaID, float vhVal) {
<span class="nc" id="L368">		float abnVal = traceChunk.getTraceValue(Trace.ABANDONMENT);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">		if (isTraceValueValid(abnVal)) {</span>
<span class="nc" id="L370">			float varVal = abnVal + vhVal;</span>
<span class="nc" id="L371">			traceChunk.setTraceValue(Trace.VAR, varVal);</span>
<span class="nc" id="L372">		} else {</span>
<span class="nc" id="L373">			calcComputedTraceValuesForTraceChunkForVARWithCVOrVH(traceChunk, mediaID, true);</span>
		}
<span class="nc" id="L375">	}</span>

	protected void calcComputedTraceValuesForTraceChunkForVARWithCVOrVH(TraceChunk traceChunk, ID mediaID, boolean setVH) {
<span class="nc bnc" id="L378" title="All 2 branches missed.">		boolean setVolumeHandled = setVH</span>
<span class="nc bnc" id="L379" title="All 6 branches missed.">				&amp;&amp; (isAlwaysUseVHInsteadOfCV() || (mediaID != null &amp;&amp; !Media.isMediaImmediate(mediaID)));</span>
<span class="nc bnc" id="L380" title="All 2 branches missed.">		traceChunk.setTraceValue(Trace.VAR, traceChunk.getTraceValue(setVolumeHandled ? Trace.VH : Trace.CV));</span>
<span class="nc" id="L381">	}</span>

	protected void calcComputedTraceValuesForTraceChunkForCVOrVH(TraceChunk traceChunk, boolean setVH) {
<span class="nc bnc" id="L384" title="All 2 branches missed.">		traceChunk.setTraceValue(Trace.CV_VH, traceChunk.getTraceValue(setVH ? Trace.VH : Trace.CV));</span>
<span class="nc" id="L385">	}</span>

	protected void calcComputedTraceValuesForTraceChunkForOutbound(TraceChunk traceChunk) {
<span class="nc" id="L388">		float dials = traceChunk.getTraceValue(Trace.DIALS);</span>
<span class="nc" id="L389">		float connects = traceChunk.getTraceValue(Trace.CONNECTS);</span>
<span class="nc bnc" id="L390" title="All 4 branches missed.">		if (dials &gt; 0 &amp;&amp; connects &gt;= 0) {</span>
<span class="nc" id="L391">			traceChunk.setTraceValue(Trace.CRATE, (connects * 100) / dials);</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">		} else if (dials == 0 &amp;&amp; connects == 0) {</span>
<span class="nc" id="L393">			traceChunk.setTraceValue(Trace.CRATE, 0);</span>
		}
<span class="nc" id="L395">		float rpc = traceChunk.getTraceValue(Trace.RPC);</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">		if (dials &gt; 0 &amp;&amp; rpc &gt;= 0) {</span>
<span class="nc" id="L397">			traceChunk.setTraceValue(Trace.RPCRATE, (rpc * 100) / dials);</span>
<span class="nc bnc" id="L398" title="All 4 branches missed.">		} else if (dials == 0 &amp;&amp; rpc == 0) {</span>
<span class="nc" id="L399">			traceChunk.setTraceValue(Trace.RPCRATE, 0);</span>
		}
<span class="nc" id="L401">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>