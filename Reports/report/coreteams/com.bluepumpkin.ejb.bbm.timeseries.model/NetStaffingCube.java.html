<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>NetStaffingCube.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">NetStaffingCube.java</span></div><h1>NetStaffingCube.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.model;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;

/**
 * Title: Verint Software Basic Business Model Description: NetStaffingCube
 * object, mainly used by UI to load NET-STAFFING &amp; OVER/UNDER Staffing of Trace
 * Data for a given period for a set a queues for a givwn employee. the Queues
 * are filtered based on employee skills. the Queues can have a LTI of 15 mins,
 * hourly, daily or weekly interval. Copyright: Copyright (c) 2011 Company:
 * Verint, inc
 *
 * @author Sameet Joshi
 * @version 2.0
 */
public class NetStaffingCube implements Serializable, INetStaffingCube {

	/**
	 *
	 */
	private static final long serialVersionUID = 1L;
	// All the HashMaps are store with reference to SPQID; that is the least
	// commmon denominator between the collections.
<span class="nc" id="L44">	private HashMap&lt;ID, PredictTraceCube&gt; m_PTCMap = new HashMap&lt;ID, PredictTraceCube&gt;();</span>
<span class="nc" id="L45">	private HashMap&lt;ID, RequireTraceCube&gt; m_RTCMap = new HashMap&lt;ID, RequireTraceCube&gt;();</span>

<span class="nc" id="L47">	private HashMap&lt;ID, SPQueue&gt; m_SPQueueMap = new HashMap&lt;ID, SPQueue&gt;();</span>
<span class="nc" id="L48">	private HashMap&lt;ID, Campaign&gt; m_CampaignMap = new HashMap&lt;ID, Campaign&gt;();</span>

<span class="nc" id="L50">	private TimeRange tr = null;</span>

<span class="nc" id="L52">	public NetStaffingCube() {</span>

<span class="nc" id="L54">	}</span>

	public HashMap&lt;ID, PredictTraceCube&gt; getPredictTraceCubeMap() {
<span class="nc" id="L57">		return m_PTCMap;</span>
	}

	public HashMap&lt;ID, RequireTraceCube&gt; getRequireTraceCubeMap() {
<span class="nc" id="L61">		return m_RTCMap;</span>
	}

	public HashMap&lt;ID, SPQueue&gt; getSPQueueMap() {
<span class="nc" id="L65">		return m_SPQueueMap;</span>
	}

	public HashMap&lt;ID, Campaign&gt; getCampaignMap() {
<span class="nc" id="L69">		return m_CampaignMap;</span>
	}

	/* Adds NetStaffing Data for relevant Campaign -Queue combination */
	public void addNetStaffing(Campaign camp, PredictTraceCube pCube, RequireTraceCube rCube, SPQueue spQueue) {
<span class="nc" id="L74">		m_PTCMap.put(spQueue.getID(), pCube);</span>
<span class="nc" id="L75">		m_RTCMap.put(spQueue.getID(), rCube);</span>
<span class="nc" id="L76">		m_SPQueueMap.put(spQueue.getID(), spQueue);</span>
<span class="nc" id="L77">		m_CampaignMap.put(spQueue.getID(), camp);</span>
<span class="nc" id="L78">	}</span>

	/**
	 * Returns Over / Under Numbers for a given datetime instant.
	 *
	 * @param eventActivity - The activity that the agent is currently scheduled to work
	 *                      on at this time, or null if none.
	 * @param mediaIDs      - The media IDs linked to the scheduled activity.
	 * @param qIDs          - the queue IDs linked to the activity (for queue-hopping
	 *                      activities only).
	 */
	public int getOverUnder(Date date, Activity eventActivity, Collection&lt;ID&gt; mediaIDs, Collection&lt;ID&gt; qIDs) {
<span class="nc" id="L90">		boolean foundOver = false;</span>
<span class="nc" id="L91">		boolean foundNotOverUnder = false;</span>
<span class="nc" id="L92">		int retOverUnder = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>

<span class="nc" id="L94">		Collection&lt;ID&gt; spQueueIDsForActivity = getSPQueueIDsForActivity(eventActivity, mediaIDs, qIDs);</span>

<span class="nc bnc" id="L96" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L97">			ID spQID = iterator.next();</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">			if (spQueueIDsForActivity.contains(spQID)) {</span>
<span class="nc" id="L99">				PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">				if (!pCube.fallsIn(date)) {</span>
<span class="nc" id="L101">					continue;</span>
				}
<span class="nc" id="L103">				RequireTraceCube rCube = m_RTCMap.get(spQID);</span>
<span class="nc" id="L104">				Campaign camp = m_CampaignMap.get(spQID);</span>
<span class="nc" id="L105">				SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L106">				TimeRange range = snapDate(camp, pCube, spQueue, date);</span>
<span class="nc" id="L107">				int startAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L108">				int endAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L109">				double cForFTE = TraceOperator.aggregatePeriodD(pCube, Trace.AFTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L110">				double cReqFTE = TraceOperator.aggregatePeriodD(rCube, Trace.FTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L111">				int over_under = getOverUnder(cForFTE, cReqFTE, spQueue);</span>
<span class="nc bnc" id="L112" title="All 4 branches missed.">				switch (over_under) {</span>
					case Trace.NETSTAFF_NOT_OVER_OR_UNDER:
<span class="nc" id="L114">						foundNotOverUnder = true;</span>
<span class="nc" id="L115">						continue;</span>
					case Trace.NETSTAFF_UNDER:
<span class="nc" id="L117">						return Trace.NETSTAFF_UNDER; // as soon as under is found</span>
					// just stop here
					case Trace.NETSTAFF_OVER:
<span class="nc" id="L120">						foundOver = true;</span>
<span class="nc" id="L121">						continue;</span>
				}
			}
<span class="nc" id="L124">		}</span>

<span class="nc bnc" id="L126" title="All 2 branches missed.">		if (foundNotOverUnder) {</span>
<span class="nc" id="L127">			return Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
		} else {
<span class="nc bnc" id="L129" title="All 2 branches missed.">			if (foundOver) {</span>
<span class="nc" id="L130">				return Trace.NETSTAFF_OVER;</span>
			}
		}
<span class="nc" id="L133">		return retOverUnder;</span>
	}

	/**
	 * Returns the SPQueues in this cube that are linked to the specified
	 * activity (either through queue hopping, or through media).
	 *
	 * @param activity - The activity.
	 * @param mediaIDs - The media IDs linked to the scheduled activity.
	 * @param qIDs     - the queue IDs linked to the activity (for queue-hopping
	 *                 activities only).
	 * @return A subset of the SPQueues in this cube.
	 */
	private Collection&lt;ID&gt; getSPQueueIDsForActivity(Activity activity, Collection&lt;ID&gt; mediaIDs, Collection&lt;ID&gt; qIDs) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (activity == null) {</span>
			// The agent is not scheduled, so we need to consider all queues.
<span class="nc" id="L149">			return m_PTCMap.keySet();</span>
		}

<span class="nc" id="L152">		HashSet&lt;ID&gt; spQueueIDs = new HashSet(m_SPQueueMap.size());</span>

<span class="nc" id="L154">		boolean hasIndividualQueue = false;</span>
<span class="nc bnc" id="L155" title="All 2 branches missed.">		for (ID spQID : m_PTCMap.keySet()) {</span>
<span class="nc" id="L156">			SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc bnc" id="L157" title="All 2 branches missed.">			if (spQueue.getQueueID() != null) {</span>
<span class="nc" id="L158">				hasIndividualQueue = true;</span>
			}
<span class="nc" id="L160">		}</span>
<span class="nc bnc" id="L161" title="All 2 branches missed.">		if (!hasIndividualQueue) {</span>
			// non-skilled SP's will only contain the Combined-Phone SPQueues
			// (there can be &gt;1 for consecutive SP's).
			// Any activity will be for those Combined-Phone SPQueues.
<span class="nc" id="L165">			return m_PTCMap.keySet();</span>
		}

<span class="nc bnc" id="L168" title="All 2 branches missed.">		if (activity.isQueueHopping()) {</span>
			// find the queues linked to this activity
<span class="nc bnc" id="L170" title="All 4 branches missed.">			if (qIDs != null &amp;&amp; !qIDs.isEmpty()) {</span>
<span class="nc bnc" id="L171" title="All 2 branches missed.">				for (ID queueID : qIDs) {</span>
					// find the spq (if any) for this queue
					// TBD GQ: Will we need to consider the combined queues of
					// this queue's media as well? Probably not.
<span class="nc" id="L175">					Collection&lt;SPQueue&gt; curQueueHopSPQColl = getSPQueuesByQueueID(m_SPQueueMap, queueID);</span>
<span class="nc bnc" id="L176" title="All 2 branches missed.">					if (!curQueueHopSPQColl.isEmpty()) {</span>
<span class="nc" id="L177">						spQueueIDs.addAll(ValueObjectUtil.getIDFromObjects(curQueueHopSPQColl));</span>
					}
<span class="nc" id="L179">				}</span>
			}
		} else {
			// find the medias linked to this activity, then find all spQueues
			// linked to those medias. We can probably eliminate the combined
			// spQueues.
<span class="nc" id="L185">			spQueueIDs = getSPQueuesForMedias(mediaIDs);</span>
		}

<span class="nc" id="L188">		return spQueueIDs;</span>
	}

	/**
	 * Returns the collection of SPQueues linked to the given QueueID in this NetStaffingCube.
	 */
	static Collection&lt;SPQueue&gt; getSPQueuesByQueueID(Map&lt;ID, SPQueue&gt; spQueueMap, ID queueID) {
<span class="nc" id="L195">		Collection&lt;SPQueue&gt; retVal = new ArrayList&lt;SPQueue&gt;();</span>
<span class="nc bnc" id="L196" title="All 2 branches missed.">		for (ID spQueueID : spQueueMap.keySet()) {</span>
<span class="nc" id="L197">			SPQueue spQueue = spQueueMap.get(spQueueID);</span>
<span class="nc bnc" id="L198" title="All 4 branches missed.">			if (spQueue.getQueueID() != null &amp;&amp; spQueue.getQueueID().equals(queueID)) {</span>
<span class="nc" id="L199">				retVal.add(spQueue);</span>
			}
<span class="nc" id="L201">		}</span>
<span class="nc" id="L202">		return retVal;</span>
	}

	/**
	 * Get all non-combined SPQ's of the given media types.
	 */
	private HashSet&lt;ID&gt; getSPQueuesForMedias(Collection&lt;ID&gt; mediaIDs) {
<span class="nc" id="L209">		HashSet&lt;ID&gt; spQueueIDs = new HashSet(m_SPQueueMap.size());</span>
<span class="nc bnc" id="L210" title="All 4 branches missed.">		if (mediaIDs != null &amp;&amp; !mediaIDs.isEmpty()) {</span>
<span class="nc bnc" id="L211" title="All 2 branches missed.">			for (ID spQueueID : m_SPQueueMap.keySet()) {</span>
<span class="nc" id="L212">				SPQueue spQueue = m_SPQueueMap.get(spQueueID);</span>
				// make sure it's not a combined queue
<span class="nc bnc" id="L214" title="All 2 branches missed.">				if (spQueue.getQueueID() != null) {</span>
<span class="nc" id="L215">					ID mediaID = spQueue.getMediaID();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">					if (mediaIDs.contains(mediaID)) {</span>
<span class="nc" id="L217">						spQueueIDs.add(spQueue.getID());</span>
					}
				}
<span class="nc" id="L220">			}</span>
		}
<span class="nc" id="L222">		return spQueueIDs;</span>
	}

	/*
	 * Returns NetStaff Numbers for a given date range, for each queue.
	 */
	@Override
	public HashMap&lt;SPQueue, Double&gt; getNetStaffingForDateRange(Date start, Date end) {
<span class="nc" id="L230">		HashMap&lt;SPQueue, Double&gt; m_SPQueueRetMap = new HashMap&lt;SPQueue, Double&gt;();</span>

<span class="nc bnc" id="L232" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L233">			ID spQID = iterator.next();</span>
<span class="nc" id="L234">			PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L235" title="All 4 branches missed.">			if (start.after(pCube.getRawEndDate()) || end.before(pCube.getRawStartDate())) {</span>
<span class="nc" id="L236">				continue;</span>
			}
<span class="nc bnc" id="L238" title="All 2 branches missed.">			Date stDate = start.before(pCube.getRawStartDate()) ? pCube.getRawStartDate() : start;</span>
<span class="nc bnc" id="L239" title="All 2 branches missed.">			Date enDate = end.after(pCube.getRawEndDate()) ? pCube.getRawEndDate() : end;</span>
<span class="nc" id="L240">			SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L241">			Campaign camp = m_CampaignMap.get(spQID);</span>

<span class="nc" id="L243">			TimeRange rangeSt = snapDate(camp, pCube, spQueue, stDate);</span>
<span class="nc" id="L244">			TimeRange rangeEnd = snapDate(camp, pCube, spQueue, enDate);</span>
<span class="nc" id="L245">			int startAbsOffset = pCube.getTimeOffset(rangeSt.getStartDate());</span>
<span class="nc" id="L246">			int endAbsOffset = pCube.getTimeOffset(rangeEnd.getEndDate());</span>
<span class="nc" id="L247">			double origVal = TraceOperator.aggregatePeriod(pCube, Trace.NETSTAFFING, startAbsOffset, endAbsOffset);</span>

<span class="nc" id="L249">			m_SPQueueRetMap.put(spQueue, origVal);</span>
<span class="nc" id="L250">		}</span>
<span class="nc" id="L251">		return m_SPQueueRetMap;</span>
	}

	public int getOverUnder(double cForFTE, double cReqFTE, SPQueue spQueue) {
<span class="nc" id="L255">		int retVal = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc bnc" id="L256" title="All 4 branches missed.">		if (Trace.isValidValue(cForFTE) &amp;&amp; Trace.isValidValue(cReqFTE)) {</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			double fteRatio = cForFTE == 0 ? Double.MAX_VALUE : ((double) cReqFTE * 100d / (double) cForFTE);</span>

<span class="nc bnc" id="L259" title="All 2 branches missed.">			if (cReqFTE &gt; cForFTE) { // UNDER</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdUnderPercentage()) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">					if ((cReqFTE - cForFTE) &gt; spQueue.getFTEThresholdUnder()) {</span>
<span class="nc" id="L262">						retVal = Trace.NETSTAFF_UNDER;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L266" title="All 2 branches missed.">					if ((fteRatio - 100.0d) &gt; spQueue.getFTEThresholdUnder()) {</span>
<span class="nc" id="L267">						retVal = Trace.NETSTAFF_UNDER;</span>
					}
				}
<span class="nc bnc" id="L270" title="All 2 branches missed.">			} else if (cReqFTE &lt; cForFTE) { // OVER</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdOverPercentage()) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">					if ((cForFTE - cReqFTE) &gt; spQueue.getFTEThresholdOver()) {</span>
<span class="nc" id="L273">						retVal = Trace.NETSTAFF_OVER;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L277" title="All 2 branches missed.">					if ((100.0d - fteRatio) &gt; spQueue.getFTEThresholdOver()) {</span>
<span class="nc" id="L278">						retVal = Trace.NETSTAFF_OVER;</span>
					}
				}
			} else {
<span class="nc" id="L282">				retVal = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
			}
		}
<span class="nc" id="L285">		return retVal;</span>
	}

	/**
	 * If the FTE Differential value falls under the spQueue's net staffing
	 * threshold, returns 0. Otherwise, returns the FTE Differential value.
	 * Note: FTE Differential = (Forecasted FTE - Required FTE) The purpose of
	 * threshold is to allow queue to have a &quot;buffer zone&quot; in case the forecast
	 * is not accurate. For example, if they're not completely sure that their
	 * forecast is accurate, they might set the threshold to 5, meaning that
	 * they don't want to let agents take a time off unless they're absolutely
	 * sure that they will have overstaffing. So, a threshold of 5 would mean
	 * that they have a confidence in their forecast values of +/- 5 staffed
	 * agents. Conversely, they don't want to let the agents request a shift
	 * unless they are certain that they are understaffed, lest they become
	 * overstaffed in the event of the forecast having been a bit too high.
	 */
	public double getFTEDPastThreshold(double cForFTE, double cReqFTE, SPQueue spQueue) {
<span class="nc" id="L303">		double retVal = 0;</span>

<span class="nc bnc" id="L305" title="All 4 branches missed.">		if (Trace.isValidValue(cForFTE) &amp;&amp; Trace.isValidValue(cReqFTE)) {</span>
<span class="nc" id="L306">			retVal = cForFTE - cReqFTE;</span>
<span class="nc bnc" id="L307" title="All 2 branches missed.">			double fteRatio = (cForFTE == 0) ? Double.MAX_VALUE : ((double) cReqFTE * 100d / (double) cForFTE);</span>

<span class="nc bnc" id="L309" title="All 2 branches missed.">			if (retVal &lt; 0.0d) { // UNDER</span>
<span class="nc bnc" id="L310" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdUnderPercentage()) {</span>
<span class="nc bnc" id="L311" title="All 2 branches missed.">					if (Math.abs(retVal) &lt;= (double) (spQueue.getFTEThresholdUnder())) {</span>
<span class="nc" id="L312">						retVal = 0.0d;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L316" title="All 2 branches missed.">					if ((fteRatio - 100.0d) &lt;= (double) (spQueue.getFTEThresholdUnder())) {</span>
<span class="nc" id="L317">						retVal = 0.0d; // Trace.NETSTAFF_UNDER;</span>
					}
				}
<span class="nc bnc" id="L320" title="All 2 branches missed.">			} else if (retVal &gt; 0.0d) { // OVER</span>
<span class="nc bnc" id="L321" title="All 2 branches missed.">				if (!spQueue.isFTEThresholdOverPercentage()) {</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">					if (retVal &lt;= (double) (spQueue.getFTEThresholdOver())) {</span>
<span class="nc" id="L323">						retVal = 0.0d;</span>
					}
				} else {
					// check for percentage
<span class="nc bnc" id="L327" title="All 2 branches missed.">					if ((100.0d - fteRatio) &lt;= (double) (spQueue.getFTEThresholdOver())) {</span>
<span class="nc" id="L328">						retVal = 0.0d; // Trace.NETSTAFF_OVER;</span>
					}
				}
			} else {
			}
		}
<span class="nc" id="L334">		return retVal;</span>
	}

	// cst cen
	// ----------|------|----
	// st--end
	// st---------------------en
	// st---en
	// st-----------en
	// st---------en
	// st-en
	/*
	 * Snaps Date to start of period based on the LTI. //LTI= 15 Mins******
	 * //Just return the date as is ( snap date is internal to TRACECUBE
	 * implementation.
	 *
	 * //LTI= Hourly****** //snaps the date on the hour by actual time based on
	 * GMT TZ, if the campaign does not start at the hour and the passd date is
	 * within camp start time and the first turn of hour then it returns the
	 * campaign start time.
	 *
	 * //LTI= Daily ****** //snaps the date on the start of the day i.e. 12:00
	 * AM by actual time based on GMT TZ, if the campaign does not start at
	 * 12:00 AM and starts at a day boundary &amp; the passd date falls within
	 * campaign start time and the end of the first day then it returns the
	 * campaign start time.
	 *
	 * //LTI= weekly****** // Weekly Ranges are created based on the actual
	 * campaign start times. // Find if the date falls in weekly range and
	 * returns start date of the weekly range.
	 */
	public TimeRange snapDate(Campaign camp, TraceCube pCube, SPQueue spQueue, Date date) {
<span class="nc" id="L366">		return snapDate(camp, pCube.getRawStartDate(), pCube.getRawEndDate(), spQueue.getLeastTimeInterval(), date);</span>
	}

	public static TimeRange getDateRangeForNetstaffing(Campaign camp, Collection&lt;SPQueue&gt; spQueues,
			CampaignWorkResource ass, Date start, Date end) throws Exception {
<span class="nc" id="L371">		int lti = getMaxLeastTimeInterval(spQueues);</span>
		// we need the max LTI in following precedence weekly &gt; daily -&gt; hourly
		// -&gt; 15mins
<span class="nc" id="L374">		TimeRange tr = new TimeRange(ass.getStartTime(), ass.getEndTime());</span>
<span class="nc bnc" id="L375" title="All 2 branches missed.">		if (start.after(ass.getStartTime())) {</span>
<span class="nc" id="L376">			TimeRange trStart = snapDate(camp, ass.getStartTime(), ass.getEndTime(), lti, start);</span>
<span class="nc" id="L377">			tr.setStartDate(trStart.getStartDate());</span>
		}
<span class="nc bnc" id="L379" title="All 2 branches missed.">		if (end.before(ass.getEndTime())) {</span>
<span class="nc" id="L380">			TimeRange trEnd = snapDate(camp, ass.getStartTime(), ass.getEndTime(), lti, end);</span>
<span class="nc" id="L381">			tr.setEndDate(trEnd.getEndDate());</span>
		}
<span class="nc" id="L383">		return tr;</span>
	}

	public static TimeRange snapDate(Campaign camp, Date spStartDate, Date spEndDate, int leastTimeItvl, Date date) {
<span class="nc" id="L387">		Calendar cal = Calendar.getInstance(camp.getTimeZone());</span>
<span class="nc" id="L388">		cal.setTime(date);</span>
		//DST issue due to Java quirk. We must use cal.add instead of cal.set. (See bug JDK-6615045).
<span class="nc" id="L390">		cal.add(Calendar.SECOND, -cal.get(Calendar.SECOND));</span>
<span class="nc" id="L391">		cal.add(Calendar.MILLISECOND, -cal.get(Calendar.MILLISECOND));</span>

<span class="nc bnc" id="L393" title="All 5 branches missed.">		switch (leastTimeItvl) {</span>
			case SPQueue.LEAST_TIME_INTERVAL_15MINS: {
<span class="nc" id="L395">				snapCalTo15Minutes(cal);</span>
<span class="nc" id="L396">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_HOURLY: {
<span class="nc" id="L399">				cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="nc" id="L400">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_DAILY: {
<span class="nc" id="L403">				cal.add(Calendar.HOUR_OF_DAY, -cal.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L404">				cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">				if (camp.getDayBoundaryOffset() &gt; 0) {</span>
					//possible DST bug: may need to call TOCalcUtil.setCalMinsOffsetFromMidnight() below, instead of cal.add.
<span class="nc" id="L407">					cal.add(Calendar.MINUTE, camp.getDayBoundaryOffset());</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">					if (!cal.getTime().before(date)) {</span>
<span class="nc" id="L409">						cal.add(Calendar.DAY_OF_MONTH, -1);</span>
						// go back one day because of stupid day boundary logic
					}
				}
				break;
			}
			case SPQueue.LEAST_TIME_INTERVAL_WEEKLY: {
<span class="nc" id="L416">				TimeRange[] weekRanges = TraceOperator.getWeeklyRanges(camp.getTimeZone(), spStartDate, spEndDate);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">				if (weekRanges != null) {</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">					for (int weekOffset = 0; weekOffset &lt; weekRanges.length; weekOffset++) {</span>
<span class="nc" id="L419">						TimeRange curWeek = weekRanges[weekOffset];</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">						if (curWeek.includes(date)) {</span>
<span class="nc" id="L421">							cal.setTime(curWeek.getStartDate());</span>
<span class="nc" id="L422">							break;</span>
						}
					}
				}
				break;
			}
		}
		// snap to startdate if campaign does not start on the hour or on start
		// of the day and derived date is before SP start.
<span class="nc bnc" id="L431" title="All 2 branches missed.">		if (cal.getTime().before(spStartDate)) {</span>
<span class="nc" id="L432">			cal.setTime(spStartDate);</span>
		}
<span class="nc" id="L434">		Date st = cal.getTime();</span>

<span class="nc bnc" id="L436" title="All 5 branches missed.">		switch (leastTimeItvl) {</span>
			case SPQueue.LEAST_TIME_INTERVAL_15MINS: {
<span class="nc" id="L438">				cal.add(Calendar.MINUTE, Trace.INTERVAL);</span>
<span class="nc" id="L439">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_HOURLY: {
<span class="nc" id="L442">				cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L443">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_DAILY: {
<span class="nc" id="L446">				cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L447">				break;</span>
			}
			case SPQueue.LEAST_TIME_INTERVAL_WEEKLY: {
<span class="nc" id="L450">				cal.add(Calendar.DATE, 7);</span>
				break;
			}
		}
		// snap to startdate if campaign does not start on the hour or on start
		// of the day and derived date is before SP start.
<span class="nc bnc" id="L456" title="All 2 branches missed.">		if (cal.getTime().after(spEndDate)) {</span>
<span class="nc" id="L457">			cal.setTime(spEndDate);</span>
		}
<span class="nc bnc" id="L459" title="All 2 branches missed.">		if (cal.getTime().after(st)) {</span>
<span class="nc" id="L460">			return new TimeRange(st, new Date(cal.getTime().getTime() - 1));</span>
		} else {
<span class="nc" id="L462">			return new TimeRange(st, st);</span>
		}

	}

	/**
	 * Snap the minutes part of a Calendar date to the 15-minute interval it falls under.
	 * Seconds and milliseconds will not be altered. For example:
	 * 11/11/2015 8:44:00 PM will be snapped to 11/11/2015 8:30:00 PM.
	 * 11/11/2015 8:45:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 * 11/11/2015 8:46:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 * 11/11/2015 8:59:00 PM will be snapped to 11/11/2015 8:45:00 PM.
	 */
	public static void snapCalTo15Minutes(Calendar cal) {
<span class="nc" id="L476">		int minute = cal.get(Calendar.MINUTE) / Trace.INTERVAL;</span>
		//DST issue due to Java quirk. We must use cal.add instead of cal.set. (See bug JDK-6615045).
<span class="nc" id="L478">		cal.add(Calendar.MINUTE, -cal.get(Calendar.MINUTE));</span>
<span class="nc" id="L479">		cal.add(Calendar.MINUTE, Trace.INTERVAL * minute);</span>
<span class="nc" id="L480">	}</span>

	@Override
	public HashMap getOverUnder(Date fromDate, Date toDate) {
<span class="nc" id="L484">		HashMap&lt;Integer, HashMap&gt; overUnderMap = new HashMap&lt;Integer, HashMap&gt;();</span>
<span class="nc" id="L485">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L486">		cal.setTime(fromDate);</span>
<span class="nc bnc" id="L487" title="All 2 branches missed.">		while (toDate.after(cal.getTime())) {</span>
<span class="nc" id="L488">			int totalOverUnder = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc" id="L489">			boolean foundNotOverUnder = false;</span>
<span class="nc" id="L490">			boolean foundOver = false;</span>
<span class="nc" id="L491">			TreeSet spQUnderSet = new TreeSet();</span>
<span class="nc" id="L492">			TreeSet spQNotOverOrUnderSet = new TreeSet();</span>

<span class="nc bnc" id="L494" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; iterator = m_PTCMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L495">				ID spQID = iterator.next();</span>
<span class="nc" id="L496">				PredictTraceCube pCube = m_PTCMap.get(spQID);</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">				if (!pCube.fallsIn(cal.getTime())) {</span>
<span class="nc" id="L498">					continue;</span>
				}
<span class="nc" id="L500">				RequireTraceCube rCube = m_RTCMap.get(spQID);</span>
<span class="nc" id="L501">				SPQueue spQueue = m_SPQueueMap.get(spQID);</span>
<span class="nc" id="L502">				Campaign camp = m_CampaignMap.get(spQID);</span>
<span class="nc" id="L503">				TimeRange range = snapDate(camp, pCube, spQueue, cal.getTime());</span>
<span class="nc" id="L504">				int startAbsOffset = pCube.getTimeOffset(range.getStartDate());</span>
<span class="nc" id="L505">				int endAbsOffset = pCube.getTimeOffset(range.getEndDate());</span>
<span class="nc" id="L506">				double cForFTE = TraceOperator.aggregatePeriod(pCube, Trace.AFTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L507">				double cReqFTE = TraceOperator.aggregatePeriod(rCube, Trace.FTE, startAbsOffset, endAbsOffset);</span>
<span class="nc" id="L508">				int over_under = getOverUnder(cForFTE, cReqFTE, spQueue);</span>

<span class="nc bnc" id="L510" title="All 2 branches missed.">				if (over_under == Trace.NETSTAFF_UNDER) {</span>
<span class="nc" id="L511">					spQUnderSet.add(spQID);</span>
				}
<span class="nc bnc" id="L513" title="All 2 branches missed.">				if (over_under == Trace.NETSTAFF_NOT_OVER_OR_UNDER) {</span>
<span class="nc" id="L514">					spQNotOverOrUnderSet.add(spQID);</span>
<span class="nc bnc" id="L515" title="All 2 branches missed.">				} else if (over_under == Trace.NETSTAFF_OVER) {</span>
<span class="nc" id="L516">					foundOver = true;</span>
				}
<span class="nc" id="L518">			}</span>

<span class="nc" id="L520">			Date stDate = cal.getTime();</span>
<span class="nc" id="L521">			cal.add(Calendar.MINUTE, Trace.INTERVAL); // add 15 minutes every</span>
														// time regardless of
														// LTI
			// cal.add(Calendar.MILLISECOND, -1);
<span class="nc" id="L525">			Date enDate = cal.getTime();</span>
			// cal.add(Calendar.MILLISECOND, 1);
<span class="nc" id="L527">			TimeRange range = new TimeRange(stDate, enDate);</span>
			// Over / under , time range, spQueue
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (!spQUnderSet.isEmpty()) {</span>
<span class="nc" id="L530">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_UNDER, spQUnderSet);</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			} else if (!spQNotOverOrUnderSet.isEmpty()) {</span>
<span class="nc" id="L532">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_NOT_OVER_OR_UNDER, spQNotOverOrUnderSet);</span>
			} else {
<span class="nc" id="L534">				setSPQAndTimeRange(overUnderMap, range, Trace.NETSTAFF_OVER, m_PTCMap.keySet());</span>
			}
<span class="nc" id="L536">		}</span>
		/*
		 * Return a HASHMAP of OVER /UNDER / NEUTRAL &lt;-&gt; HASHMAP of Time
		 * Ranges&lt;-&gt; SPQueues
		 */
<span class="nc" id="L541">		return overUnderMap;</span>
	}

	private void setSPQAndTimeRange(Map overUnderMap, TimeRange range, int over_under, Set spQSet) {
<span class="nc bnc" id="L545" title="All 2 branches missed.">		if (!overUnderMap.containsKey(over_under)) {</span>
<span class="nc" id="L546">			overUnderMap.put(over_under, new HashMap());</span>
		}
<span class="nc" id="L548">		HashMap timeRangeSPQMap = (HashMap) overUnderMap.get(over_under);</span>
<span class="nc" id="L549">		timeRangeSPQMap.put(range, spQSet);</span>
<span class="nc" id="L550">	}</span>

	public HashMap getOverUnder(Collection&lt;TimeRange&gt; trCol) {
<span class="nc" id="L553">		HashMap&lt;Integer, HashMap&gt; overUnderSPQMap = new HashMap();</span>
<span class="nc bnc" id="L554" title="All 4 branches missed.">		if (trCol == null || trCol.isEmpty()) {</span>
<span class="nc" id="L555">			return overUnderSPQMap;</span>
		}
<span class="nc bnc" id="L557" title="All 2 branches missed.">		for (Iterator iterator = trCol.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L558">			TimeRange range = (TimeRange) iterator.next();</span>
<span class="nc" id="L559">			mergeMap(overUnderSPQMap, getOverUnder(range.getStartDate(), range.getEndDate()));</span>
<span class="nc" id="L560">		}</span>
<span class="nc" id="L561">		return overUnderSPQMap;</span>
	}

	private void mergeMap(HashMap destMap, HashMap srcMap) {
<span class="nc bnc" id="L565" title="All 4 branches missed.">		if (srcMap == null || srcMap.isEmpty()) {</span>
<span class="nc" id="L566">			return;</span>
		}
<span class="nc bnc" id="L568" title="All 2 branches missed.">		for (Iterator iterator = srcMap.keySet().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L569">			Object key = iterator.next();</span>
<span class="nc" id="L570">			HashMap over_underMap = (HashMap) srcMap.get(key);</span>
<span class="nc bnc" id="L571" title="All 6 branches missed.">			if (over_underMap == null || (over_underMap != null &amp;&amp; over_underMap.isEmpty())) {</span>
<span class="nc" id="L572">				continue; // Src Map does not have this value no point in trying</span>
							// to merge. skip this
			}
<span class="nc bnc" id="L575" title="All 2 branches missed.">			if (!destMap.containsKey(key)) {</span>
<span class="nc" id="L576">				destMap.put(key, new HashMap());</span>
			}
<span class="nc" id="L578">			HashMap over_underMapDest = (HashMap) destMap.get(key);</span>
<span class="nc" id="L579">			over_underMapDest.putAll(over_underMap);</span>
<span class="nc" id="L580">		}</span>
<span class="nc" id="L581">	}</span>

	public int getMaxLeastTimeInterval() {
<span class="nc" id="L584">		return getMaxLeastTimeInterval(m_SPQueueMap.values());</span>
	}

	private static int getMaxLeastTimeInterval(Collection&lt;SPQueue&gt; spQueues) {
<span class="nc" id="L588">		int lti = SPQueue.LEAST_TIME_INTERVAL_15MINS;</span>
		// we need the max LTI in following precedence weekly &gt; daily -&gt; hourly
		// -&gt; 15mins
<span class="nc bnc" id="L591" title="All 2 branches missed.">		for (SPQueue spQueue : spQueues) {</span>
<span class="nc bnc" id="L592" title="All 2 branches missed.">			if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_WEEKLY) {</span>
<span class="nc" id="L593">				lti = SPQueue.LEAST_TIME_INTERVAL_WEEKLY;</span>
<span class="nc" id="L594">				break;</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">			} else if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_DAILY) {</span>
<span class="nc" id="L596">				lti = SPQueue.LEAST_TIME_INTERVAL_DAILY;</span>
<span class="nc bnc" id="L597" title="All 2 branches missed.">			} else if (spQueue.getLeastTimeInterval() == SPQueue.LEAST_TIME_INTERVAL_HOURLY) {</span>
<span class="nc bnc" id="L598" title="All 2 branches missed.">				if (lti != SPQueue.LEAST_TIME_INTERVAL_DAILY) {</span>
<span class="nc" id="L599">					lti = SPQueue.LEAST_TIME_INTERVAL_HOURLY;</span>
				}
			}
<span class="nc" id="L602">		}</span>
<span class="nc" id="L603">		return lti;</span>
	}

	public TimeRange getTimeRange() {
<span class="nc bnc" id="L607" title="All 2 branches missed.">		if (tr == null) {</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">			for (Iterator&lt;PredictTraceCube&gt; iterator = m_PTCMap.values().iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L609">				PredictTraceCube pCube = iterator.next();</span>
<span class="nc bnc" id="L610" title="All 2 branches missed.">				if (tr == null) {</span>
<span class="nc" id="L611">					tr = new TimeRange(pCube.getRawStartDate(), pCube.getRawEndDate());</span>
				} else {
<span class="nc bnc" id="L613" title="All 2 branches missed.">					if (tr.getStartDate().after(pCube.getRawStartDate())) {</span>
<span class="nc" id="L614">						tr.setStartDate(pCube.getRawStartDate());</span>
					}
<span class="nc bnc" id="L616" title="All 2 branches missed.">					if (tr.getEndDate().before(pCube.getRawEndDate())) {</span>
<span class="nc" id="L617">						tr.setEndDate(pCube.getRawEndDate());</span>
					}
				}
<span class="nc" id="L620">			}</span>
		}
<span class="nc" id="L622">		return tr;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>