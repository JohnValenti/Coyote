<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ClientServiceGoalTraceCube.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">ClientServiceGoalTraceCube.java</span></div><h1>ClientServiceGoalTraceCube.java</h1><pre class="source lang-java linenums">/*
 * (c) 2010-2011 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.model;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.workload.model.MediaType;

/**
 * This trace cube type exists to supply service goals data to the Service Goals client.
 * In the Service Goals client, unlike all other applications, ASA, PCA, and deadline time
 * are aggregated using a simple average rather than a weighted average if all the weights are
 * zero or unavailable.
 * &lt;p&gt;
 * This trace cube type is intended only for the use of a client application; therefore it does
 * not participate in the prototype pattern that is widely used in the DAOs, etc.
 */
@SuppressWarnings(&quot;serial&quot;)
public class ClientServiceGoalTraceCube extends TraceCube
{
	// All trace types supported by this trace cube class.
<span class="fc" id="L27">	public static final short[] TYPES = {Trace.CV, Trace.VAR, Trace.SERVICE_GOALS_PCA_IMMEDIATE, Trace.SERVICE_GOALS_PCA_DEFERRED, Trace.SERVICE_GOALS_ASA, Trace.SERVICE_GOALS_DEADLINE_TIME, Trace.MAX_DIALS };</span>
	// Trace types that are derived from other trace types rather than loaded directly
	// from the database.  This trace cube type does not use the calcComputedTraceValues method
	// to set these values as they are known at creation time and setting them again later
	// would overwrite user-entered data.
<span class="fc" id="L32">	public static final short[] COMPUTED_TYPES = {Trace.CV, Trace.VAR, Trace.SERVICE_GOALS_PCA_IMMEDIATE, Trace.SERVICE_GOALS_PCA_DEFERRED, Trace.SERVICE_GOALS_ASA, Trace.SERVICE_GOALS_DEADLINE_TIME };</span>
	// Trace types that are handed to a client that requests a service goals trace cube
	// from this trace cube.  They will be copied from the corresponding client types.
<span class="fc" id="L35">	private static final short[] OUTPUT_TYPES = { Trace.ABANDONMENT, Trace.PCA, Trace.ASA, Trace.DEADLINE_TIME, Trace.MAX_DIALS };</span>
	// Map from server trace types to their corresponding client trace types, based on media type.
<span class="fc" id="L37">	private static final Map&lt;Short, Short&gt; IMMEDIATE_TRACE_TYPE_MAP = new HashMap&lt;Short, Short&gt;();</span>
<span class="fc" id="L38">	private static final Map&lt;Short, Short&gt; DEFERRED_TRACE_TYPE_MAP = new HashMap&lt;Short, Short&gt;();</span>
<span class="fc" id="L39">	private static final Map&lt;Short, Short&gt; OUTBOUND_TRACE_TYPE_MAP = new HashMap&lt;Short, Short&gt;();</span>
	static {
<span class="fc" id="L41">		IMMEDIATE_TRACE_TYPE_MAP.put(Trace.ABANDONMENT, Trace.ABANDONMENT);</span>
<span class="fc" id="L42">		IMMEDIATE_TRACE_TYPE_MAP.put(Trace.PCA, Trace.SERVICE_GOALS_PCA_IMMEDIATE);</span>
<span class="fc" id="L43">		IMMEDIATE_TRACE_TYPE_MAP.put(Trace.ASA, Trace.SERVICE_GOALS_ASA);</span>
<span class="fc" id="L44">		IMMEDIATE_TRACE_TYPE_MAP.put(Trace.DEADLINE_TIME, Trace.SERVICE_GOALS_DEADLINE_TIME);</span>

<span class="fc" id="L46">		DEFERRED_TRACE_TYPE_MAP.put(Trace.ABANDONMENT, Trace.ABANDONMENT);</span>
<span class="fc" id="L47">		DEFERRED_TRACE_TYPE_MAP.put(Trace.PCA, Trace.SERVICE_GOALS_PCA_DEFERRED);</span>
<span class="fc" id="L48">		DEFERRED_TRACE_TYPE_MAP.put(Trace.ASA, Trace.SERVICE_GOALS_ASA);</span>
<span class="fc" id="L49">		DEFERRED_TRACE_TYPE_MAP.put(Trace.DEADLINE_TIME, Trace.SERVICE_GOALS_DEADLINE_TIME);</span>

<span class="fc" id="L51">		OUTBOUND_TRACE_TYPE_MAP.put(Trace.MAX_DIALS, Trace.MAX_DIALS);</span>
<span class="fc" id="L52">	}</span>

	// Map from server trace types to their corresponding client trace types.
	private final Map&lt;Short, Short&gt; m_serverToClientTraceTypeMap;
	
	/**
	 * Creates a new instance of ClientServiceGoalTraceCube and populates it with the specified
	 * forecast and service goal data.
	 *
	 * @param forecastData
	 * @param serviceGoalData
	 */
	public ClientServiceGoalTraceCube(ForecastTraceCube forecastData, ServiceGoalTraceCube serviceGoalData, MediaType mediaType) {
<span class="fc" id="L65">		super(forecastData.getQueueID(), forecastData.getRawStartDate(), forecastData.getRawEndDate(), TYPES);</span>
		// That &quot;^&quot; operator is boolean XOR.  If one or the other ID is null but not both
		// then they are mismatched.
		// Unfortunately these checks are not always satisfied; for instance if there is service goal
		// data for a single queue but no matching forecast data, one ID comes in null and the other
		// is non-null.
		// For now we have to trust the client code to provide consistent forecast and service
		// goals data.
		//if ( ((forecastData.getQueueID() == null) ^ (serviceGoalData.getQueueID() == null)) ||
		//	 ( forecastData.getQueueID() != null &amp;&amp; ! forecastData.getQueueID().equals(serviceGoalData.getQueueID()) ) ||
		//	 ! forecastData.getRawStartDate().equals(serviceGoalData.getRawStartDate()) ||
		//	 ! forecastData.getRawEndDate().equals(serviceGoalData.getRawEndDate()) ) {
		//	throw new IllegalArgumentException(&quot;ClientServiceGoalTraceCube: Forecast data and service goals data must have the same queue ID, raw start date, and raw end date.\nForecast: {&quot; + forecastData.getQueueID() + &quot;, &quot; + forecastData.getRawStartDate().toGMTString() + &quot;, &quot; + forecastData.getRawEndDate().toGMTString() + &quot;}, Service Goal: {&quot; + serviceGoalData.getQueueID() + &quot;, &quot; + serviceGoalData.getRawStartDate().toGMTString() + &quot;, &quot; + serviceGoalData.getRawEndDate().toGMTString() + &quot;}&quot;);
		//}

		// This trace cube class uses VAR to house volume information for use in aggregating
		// the service goal traces, and copies PCA, ASA, and DEADLINE_TIME respectively into
		// CLIENT_PCA, CLIENT_ASA, and CLIENT_DEADLINE_TIME.  This is because the &quot;CLIENT_&quot;
		// trace types use an aggregation strategy peculiar to the Service Goals client:
		// they treat the weighted average as a simple average when the weights are all zero
		// or unavailable.
		// This trace cube type does not use the calcComputedTraceValues method
		// to set these values as they are known at creation time and setting them again later
		// would overwrite user-entered data.

<span class="fc" id="L90">		double[] volume = forecastData.getTraceValueD(Trace.CV);</span>
<span class="pc bpc" id="L91" title="1 of 2 branches missed.">		if (volume != null) {</span>
<span class="fc" id="L92">			double[] clientVolume = new double[volume.length];</span>
<span class="fc" id="L93">			System.arraycopy(volume, 0, clientVolume, 0, volume.length);</span>
<span class="fc" id="L94">			setTraceValue(Trace.CV, clientVolume);</span>
<span class="fc" id="L95">			setTraceValue(Trace.VAR, clientVolume);</span>
		}
<span class="fc" id="L97">		double[] asa = serviceGoalData.getTraceValueD(Trace.ASA);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">		if (asa != null) {</span>
<span class="fc" id="L99">			double[] clientAsa = new double[asa.length];</span>
<span class="fc" id="L100">			System.arraycopy(asa, 0, clientAsa, 0, asa.length);</span>
<span class="fc" id="L101">			setTraceValue(SERVICE_GOALS_ASA, clientAsa);</span>
		}
<span class="fc" id="L103">		double[] pca = serviceGoalData.getTraceValueD(Trace.PCA);</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">		if (pca != null) {</span>
<span class="fc" id="L105">			double[] clientPca = new double[pca.length];</span>
<span class="fc" id="L106">			System.arraycopy(pca, 0, clientPca, 0, pca.length);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">			if (mediaType == MediaType.IMMEDIATE) {</span>
<span class="fc" id="L108">				setTraceValue(SERVICE_GOALS_PCA_IMMEDIATE, clientPca);</span>
<span class="nc bnc" id="L109" title="All 2 branches missed.">			} else if (mediaType == MediaType.DEFERRED) {</span>
<span class="nc" id="L110">				setTraceValue(SERVICE_GOALS_PCA_DEFERRED, clientPca);</span>
			}
		}

<span class="fc" id="L114">		double[] deadlineTime = serviceGoalData.getTraceValueD(Trace.DEADLINE_TIME);</span>
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">		if (deadlineTime != null) {</span>
<span class="nc" id="L116">			double[] clientDeadlineTime = new double[deadlineTime.length];</span>
<span class="nc" id="L117">			System.arraycopy(deadlineTime, 0, clientDeadlineTime, 0, deadlineTime.length);</span>
<span class="nc" id="L118">			setTraceValue(SERVICE_GOALS_DEADLINE_TIME, clientDeadlineTime);</span>
		}

<span class="fc" id="L121">		double[] dials = serviceGoalData.getTraceValueD(Trace.MAX_DIALS);</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">		if (dials != null) {</span>
<span class="fc" id="L123">			double[] clientDials = new double[dials.length];</span>
<span class="fc" id="L124">			System.arraycopy(dials, 0, clientDials, 0, dials.length);</span>
<span class="fc" id="L125">			setTraceValue(MAX_DIALS, clientDials);</span>
		}
		
<span class="pc bpc" id="L128" title="1 of 2 branches missed.">		if (mediaType == MediaType.DEFERRED) {</span>
<span class="nc" id="L129">			m_serverToClientTraceTypeMap = DEFERRED_TRACE_TYPE_MAP;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">		} else if (mediaType == MediaType.OUTBOUND) {</span>
<span class="fc" id="L131">			m_serverToClientTraceTypeMap = OUTBOUND_TRACE_TYPE_MAP;</span>
		} else {
			// For now we use immediate trace type map for all non-deferred media types.
			// This probably doesn't work that well for outbound, project etc.
<span class="fc" id="L135">			m_serverToClientTraceTypeMap = IMMEDIATE_TRACE_TYPE_MAP;</span>
		}


<span class="fc" id="L139">	}</span>

	/**
	 * This trace cube type really isn't designed to participate in the prototype
	 * pattern that the server trace cube types use.  This constructor is only
	 * supplied because I don't know the full implications of simply throwing
	 * an UnsupportedOperationException in newInstance().
	 */
	private ClientServiceGoalTraceCube(ID queueID, Date startDate, Date endDate, short[] types, MediaType mediaType)
			throws BbmTimeSeriesException {
<span class="nc" id="L149">		super(queueID, startDate, endDate, types);</span>
<span class="nc bnc" id="L150" title="All 2 branches missed.">		if (mediaType == MediaType.DEFERRED) {</span>
<span class="nc" id="L151">			m_serverToClientTraceTypeMap = DEFERRED_TRACE_TYPE_MAP;</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">		} else if (mediaType == MediaType.OUTBOUND) {</span>
<span class="nc" id="L153">			m_serverToClientTraceTypeMap = OUTBOUND_TRACE_TYPE_MAP;</span>
		} else {
<span class="nc" id="L155">			m_serverToClientTraceTypeMap = IMMEDIATE_TRACE_TYPE_MAP;</span>
		}
<span class="nc" id="L157">	}</span>

	/**
	 * This trace cube type really isn't designed to participate in the prototype
	 * pattern that the server trace cube types use.  This constructor is only
	 * supplied because I don't know the full implications of simply throwing
	 * an UnsupportedOperationException in newInstance() and I don't have time
	 * to investigate before 11.0 hotfix 2 goes out.
	 * &lt;p&gt;
	 * The returned trace cube will always be an IMMEDIATE media service goals
	 * trace cube, regardless of the media type your original trace cube was
	 * using.  TraceCube's use of the prototype pattern isn't flexible enough
	 * to support passing in the original media type.
	 */

	@Override
	public TraceCube newInstance(ID queueID, Date startDate, Date endDate, short[] types)
			throws BbmTimeSeriesException {
<span class="nc" id="L175">		return new ClientServiceGoalTraceCube(queueID, startDate, endDate, types, MediaType.IMMEDIATE);</span>
	}

	public short[] getComputedTraceTypes() {
<span class="nc" id="L179">		return COMPUTED_TYPES;</span>
	}

	/**
	 * Returns a ServiceGoalTraceCube created based on the supplied meta-cube.  The returned
	 * trace cube will contain all service goals data that are both present in this cube and
	 * supported by the supplied meta-cube.
	 * &lt;p&gt;
	 * This method copies data from client trace types into the corresponding server trace
	 * types.
	 *
	 * @param metaTc
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	public TraceCube getServiceGoals(ServiceGoalTraceCube metaTc)
			throws BbmTimeSeriesException {
<span class="fc" id="L196">		TraceCube serviceGoals = metaTc.newInstance(metaTc.getQueueID(), metaTc.getRawStartDate(), metaTc.getRawEndDate(), metaTc.getSupportedTraceType());</span>

		// Copy the types that the destination supports and we have data for into the
		// destination cube.
<span class="fc bfc" id="L200" title="All 2 branches covered.">		for (short traceType : OUTPUT_TYPES) {</span>
<span class="pc bpc" id="L201" title="1 of 2 branches missed.">			if (metaTc.supportType(traceType)) {</span>
<span class="fc" id="L202">				Short clientTraceType = m_serverToClientTraceTypeMap.get(traceType);</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">				if (clientTraceType != null) {</span>
<span class="fc" id="L204">					double[] clientValues = getTraceValueD(clientTraceType);</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">					if (clientValues != null) {</span>
<span class="fc" id="L206">						double[] returnValues = new double[clientValues.length];</span>
<span class="fc" id="L207">						System.arraycopy(clientValues, 0, returnValues, 0, clientValues.length);</span>
<span class="fc" id="L208">						serviceGoals.setTraceValue(traceType, returnValues);</span>
					}
				}
			}
		}

<span class="fc" id="L214">		return serviceGoals;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>