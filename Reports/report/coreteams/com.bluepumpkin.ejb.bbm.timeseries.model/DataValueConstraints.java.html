<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>DataValueConstraints.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.model</a> &gt; <span class="el_source">DataValueConstraints.java</span></div><h1>DataValueConstraints.java</h1><pre class="source lang-java linenums">/*
 * (c) 2009-2010 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.model;

/**
 * An instance of this immutable class constrains a numeric value in various ways.
 * &lt;p&gt;
 * Values may be integer or floating point, and can have upper and/or
 * lower bounds.
 * &lt;p&gt;
 * As bounds and scaling operations are currently implemented, negative values are
 * not supported in data series.  If both positive and negative values are to be
 * supported, the treatment of SCALE_ORIGIN bounds will have to be more sophisticated.
 * Currently all bounds are treated as one-sided, and data value constraints have only
 * two bounds.  If both positive and negative values are supported then SCALE_ORIGIN
 * bounds will effectively become two-sided, and it will be necessary to specify bounds
 * both above and below a SCALE_ORIGIN bound.
 * 
 * @see Bound
 */
public final class DataValueConstraints
{
	private final DataType m_dataType;
	private final Bound m_lowerBound;
	private final Bound m_upperBound;

	/**
	 * Creates an instance of &lt;code&gt;DataValueConstraints&lt;/code&gt; having the specified
	 * data type, lower bound, and upper bound.  If both &lt;code&gt;lowerBound&lt;/code&gt;
	 * and &lt;code&gt;upperBound&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;, then the lower bound is set to
	 * an instance of &lt;code&gt;Bound&lt;/code&gt; of type &lt;code&gt;SCALE_ORIGIN&lt;/code&gt; located at zero.
	 * 
	 * @param dataType
	 * @param lowerBound the lower bound for individual trace values of this data type, or
	 * &lt;code&gt;null&lt;/code&gt; if this type has no defined lower bound.
	 * @param upperBound the upper bound for individual trace values of this data type, or
	 * &lt;code&gt;null&lt;/code&gt; if this type has no defined upper bound.
	 * 
	 * @see BoundType
	 */
<span class="fc" id="L42">	public DataValueConstraints(DataType dataType, Bound lowerBound, Bound upperBound) {</span>
<span class="fc" id="L43">		m_dataType = dataType;</span>
<span class="pc bpc" id="L44" title="3 of 4 branches missed.">		if (lowerBound == null &amp;&amp; upperBound == null) {</span>
<span class="nc" id="L45">			m_lowerBound = Bound.SCALE_FROM_ZERO;</span>
<span class="nc" id="L46">			m_upperBound = null;</span>
		} else {
<span class="fc" id="L48">			m_lowerBound = lowerBound;</span>
<span class="fc" id="L49">			m_upperBound = upperBound;</span>
		}
<span class="fc" id="L51">	}</span>

	/**
	 * Returns an instance of &lt;code&gt;DataValueConstraints&lt;/code&gt; whose lower bound is
	 * a scaling origin at zero and whose upper bound is a truncation point 
	 * at &lt;code&gt;maxValue&lt;/code&gt; if &lt;code&gt;maxValue&lt;/code&gt; is non-null.
	 * 
	 * @param dataType the data type of the constraints
	 * @param maxValue if null, there is no upper bound on the constraints; otherwise the upper
	 * bound is set to &lt;code&gt;maxValue&lt;/code&gt;.
	 * @return
	 */
	public static DataValueConstraints createNonNegativeConstraints(DataType dataType, Double maxValue) {
<span class="pc bpc" id="L64" title="1 of 2 branches missed.">		return new DataValueConstraints(dataType, Bound.SCALE_FROM_ZERO, maxValue == null ? null : new Bound(BoundType.TRUNCATION_POINT, maxValue));</span>
	}

	/**
	 * Returns an instance of &lt;code&gt;DataValueConstraints&lt;/code&gt; whose lower bound is
	 * a scaling origin at zero and whose upper bound is a scaling origin at 100.
	 * 
	 * @param dataType the data type of the constraints
	 * @return
	 */
	public static DataValueConstraints createPercentageConstraints(DataType dataType) {
<span class="fc" id="L75">		return new DataValueConstraints(dataType, Bound.SCALE_FROM_ZERO, new Bound(BoundType.SCALE_ORIGIN, 100));</span>
	}

	/**
	 * Returns the data type of these constraints.
	 * 
	 * @return
	 */
	public DataType getDataType()
	{
<span class="nc" id="L85">		return m_dataType;</span>
	}

	/**
	 * Returns the lower bound of these constraints, or &lt;code&gt;null&lt;/code&gt; if
	 * these constraints have no defined lower bound.
	 * 
	 * @return
	 */
	public Bound getLowerBound() {
<span class="nc" id="L95">		return m_lowerBound;</span>
	}

	/**
	 * Returns the upper bound of these constraints, or &lt;code&gt;null&lt;/code&gt; if
	 * these constraints have no defined upper bound.
	 * 
	 * @return
	 */
	public Bound getUpperBound() {
<span class="nc" id="L105">		return m_upperBound;</span>
	}

	/**
	 * A convenience method that returns the lower bound's value, or &lt;code&gt;null&lt;/code&gt; if
	 * these constraints have no defined lower bound.
	 * 
	 * @return
	 */
	public Double getMinValue()
	{
<span class="nc bnc" id="L116" title="All 2 branches missed.">		return (m_lowerBound == null) ? null : (Double)m_lowerBound.m_value;</span>
	}

	/**
	 * A convenience method that returns the upper bound's value, or &lt;code&gt;null&lt;/code&gt; if
	 * these constraints have no defined upper bound.
	 * 
	 * @return
	 */
	public Double getMaxValue()
	{
<span class="nc bnc" id="L127" title="All 2 branches missed.">		return (m_upperBound == null) ? null : (Double)m_upperBound.m_value;</span>
	}

	/**
	 * Checks for equality.
	 */
	@Override
	public boolean equals(Object o)
	{
<span class="nc bnc" id="L136" title="All 2 branches missed.">		if (this == o)</span>
		{
<span class="nc" id="L138">			return true;</span>
		}
<span class="nc bnc" id="L140" title="All 2 branches missed.">		if ( ! (o instanceof DataValueConstraints) )</span>
		{
<span class="nc" id="L142">			return false;</span>
		}
<span class="nc" id="L144">		DataValueConstraints other = (DataValueConstraints)o;</span>
<span class="nc bnc" id="L145" title="All 6 branches missed.">		return m_dataType == other.m_dataType &amp;&amp;</span>
<span class="nc bnc" id="L146" title="All 6 branches missed.">		   	   ( (m_lowerBound == null) ? (other.m_lowerBound == null) : (m_lowerBound.equals(other.m_lowerBound)) ) &amp;&amp;</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		   	   ( (m_upperBound == null) ? (other.m_upperBound == null) : (m_upperBound.equals(other.m_upperBound)) );</span>
	}

	/**
	 * Return an appropriate hash code.
	 * 
	 * Based on code from _Effective Java_ by Joshua Bloch, 1st Ed., item 8.
	 */
	@Override
	public int hashCode()
	{
<span class="nc" id="L158">		int result = 17;</span>
<span class="nc" id="L159">		result = 37 * result + m_dataType.hashCode();</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">		if (m_lowerBound != null)</span>
		{
<span class="nc" id="L162">			result = 37 * result + m_lowerBound.hashCode();</span>
		}
<span class="nc bnc" id="L164" title="All 2 branches missed.">		if (m_upperBound != null)</span>
		{
<span class="nc" id="L166">			result = 37 * result + m_upperBound.hashCode();</span>
		}
<span class="nc" id="L168">		return result;</span>
	}

	@Override
	public String toString()
	{
<span class="nc" id="L174">		return &quot;DataValueConstraints[&quot; + m_dataType + &quot;, &quot; + m_lowerBound + &quot;, &quot; + m_upperBound + &quot;]&quot;;</span>
	}

	/**
	 * An instance of this immutable class encapsulates a bound on a particular kind of data value.
	 * A bound has both a type and a value or position.  In general all data stored in a 
	 * finite data type such as &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;double&lt;/code&gt; has both an upper 
	 * and a lower bound, though in practice much software ignores this fact.
	 * &lt;p&gt;
	 * If a set of data value constraints does not set a particular bound, no care will be
	 * taken to limit the growth of data in that direction when scaling or aggregating data.
	 * If data is aggregated by summation this can lead to values overflowing the underlying
	 * data type, potentially leading to display or calculation errors.
	 *
	 * @see BoundType
	 */
	public static final class Bound {

<span class="fc" id="L192">		public static final Bound SCALE_FROM_ZERO = new Bound(BoundType.SCALE_ORIGIN, 0.);</span>

		private final BoundType m_type;
		private final double m_value;

		/**
		 * Creates a new instance of &lt;code&gt;Bound&lt;/code&gt; having the specified bound type
		 * and value.
		 * 
		 * @param type
		 * @param value
		 */
<span class="fc" id="L204">		public Bound(BoundType type, double value) {</span>
<span class="fc" id="L205">			m_type = type;</span>
<span class="fc" id="L206">			m_value = value;</span>
<span class="fc" id="L207">		}</span>

		/**
		 * Returns the type of the bound.
		 * 
		 * @return
		 */
		public BoundType getType() {
<span class="nc" id="L215">			return m_type;</span>
		}

		/**
		 * Returns the numeric value of the bound.
		 * 
		 * @return
		 */
		public double getValue() {
<span class="nc" id="L224">			return m_value;</span>
		}

		/**
		 * Checks for equality.
		 */
		@Override
		public boolean equals(Object o) {
<span class="nc bnc" id="L232" title="All 2 branches missed.">			if (this == o)</span>
			{
<span class="nc" id="L234">				return true;</span>
			}
<span class="nc bnc" id="L236" title="All 2 branches missed.">			if ( ! (o instanceof Bound) )</span>
			{
<span class="nc" id="L238">				return false;</span>
			}
<span class="nc" id="L240">			Bound other = (Bound)o;</span>
<span class="nc bnc" id="L241" title="All 4 branches missed.">			return this.m_type == other.m_type &amp;&amp;</span>
				   this.m_value == other.m_value;
		}

		/**
		 * Return an appropriate hash code.
		 * 
		 * Based on code from _Effective Java_ by Joshua Bloch, 1st Ed., item 8.
		 */
		@Override
		public int hashCode()
		{
<span class="nc" id="L253">			int result = 17;</span>
<span class="nc" id="L254">			result = 37 * result + m_type.hashCode();</span>
<span class="nc" id="L255">			long valueLong = Double.doubleToLongBits(m_value);</span>
<span class="nc" id="L256">			result = 37 * result + (int)(valueLong ^ (valueLong &gt;&gt;&gt; 32));</span>
<span class="nc" id="L257">			return result;</span>
		}

		public String toString() {
<span class="nc" id="L261">			return m_type + &quot; at &quot; + m_value;</span>
		}
	}

	/**
	 * This enum captures the possible types of numeric bound that may be set on a type
	 * of data.
	 * &lt;p&gt;
	 * Bounds are used
	 * &lt;ul&gt;
	 * &lt;li&gt; to validate individual data values during data entry&lt;/li&gt;
	 * &lt;li&gt; when aggregating data values, and&lt;/li&gt;
	 * &lt;li&gt; when a series of values are being scaled so that their
	 * aggregate becomes a target value.&lt;/li&gt;
	 * &lt;/ul&gt;
	 * &lt;p&gt;
	 * If individual values in a series are required to fall within a range of values,
	 * those bounds must be taken into account when scaling or aggregating the data.
	 */
<span class="pc" id="L280">	public static enum BoundType {</span>
		/**
		 * When a series of data values is scaled towards a SCALE_ORIGIN
		 * boundary, all the values are scaled linearly with respect to that bound.
		 * The proportions between the individual values in the series will be preserved
		 * &lt;em&gt;relative to that bound&lt;/em&gt;.  If a SCALE_ORIGIN bound is an upper bound
		 * greater than zero, the shape of the series being scaled will appear to become 
		 * flatter as the series is scaled towards the bound.
		 * &lt;p&gt;
		 * Every data series must have at least one SCALE_ORIGIN bound in order to support
		 * scaling at all.  If no bounds are specified for a series, it is assumed that
		 * the lower bound is a SCALE_ORIGIN bound at zero. 
		 */
<span class="fc" id="L293">		SCALE_ORIGIN,</span>
		/**
		 * If one bound of a series is a TRUNCATION_POINT, the other must be a SCALE_ORIGIN.
		 * When a series of values is scaled towards a TRUNCATION_POINT boundary, all the
		 * values are scaled linearly with respect to the opposite bound, which must be a
		 * SCALE_ORIGIN bound.
		 */
<span class="fc" id="L300">		TRUNCATION_POINT</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>