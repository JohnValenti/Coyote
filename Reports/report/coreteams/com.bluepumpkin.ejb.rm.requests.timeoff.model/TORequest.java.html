<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TORequest.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.model</a> &gt; <span class="el_source">TORequest.java</span></div><h1>TORequest.java</h1><pre class="source lang-java linenums">/*
 * TORequest.java
 *
 * Copyright (c) 2002, Blue Pumpkin Software, Inc.
 * All rights reserved.
 */
package com.bluepumpkin.ejb.rm.requests.timeoff.model;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.DailyHoursBuckets;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.rm.base.RmException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestDetailLevel;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationCache;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.flextime.validation.FTValidationCacheFactory;
import com.bluepumpkin.ejb.rm.requests.timeoff.validation.TOValidationCache;
import com.bluepumpkin.ejb.rm.requests.timeoff.waitlist.model.TOWaitlist;
import com.bluepumpkin.ejb.rm.requests.timeoff.withdraw.model.TOWithdraw;
import com.bluepumpkin.ejb.rm.setup.filingrules.model.RequestFilingRule;
import com.bluepumpkin.ejb.rm.setup.timeoffbid.model.TimeOffBid;
import com.bluepumpkin.ejb.rm.util.TORequestUtil;


/**
 * Class represents TimeOff Requests.
 */
public class TORequest extends RequestAggregate {

	private static final long serialVersionUID = 1414257089538501312L;

	//Type of time off debit - This seems to be the &quot;Time Off Hours&quot; setting for the request
	//Time Off Hours: &quot;Use my time off hours to schedule my absence&quot; 
	//see TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES (2). 
	//Seems to set the CountsMinsTowardsRules for the time off event to the length of the request
	public static final String DEBITTYPE_DEBIT = &quot;debit&quot;;

	//Time Off Hours: &quot;Schedule around my time off request if possible&quot;
	//see TimeOffEvent.TIME_OFF_RULE_USE_SHIFT (1)
	//Seems to set CountsMinsTowardsRules for the time off event to zero. 
	public static final String DEBITTYPE_DEBIT_ONLY_IF = &quot;debit-only-if&quot;;

	//Time Off Hours: &quot;Mark as unavailable and schedule around this time&quot;
	public static final String DEBITTYPE_DONT_DEBIT = &quot;dont-debit&quot;;

	// Flex types
	public static final int FLEXTYPE_NONE = 0;
	public static final int FLEXTYPE_FLEXWITHMAKEUP = 1;
		
	/**
	 * Time Off Request Statuses that are part of Pending hour calculation
	 */
<span class="fc" id="L77">	public static final String[] PENDING_HOUR_STATUSES = new String[]{ // NOSONAR</span>
		RequestAuditTrail.STATUS_PENDING,
		RequestAuditTrail.STATUS_TENTATIVE,
		RequestAuditTrail.STATUS_ESCALATED,
		RequestAuditTrail.STATUS_WAITLIST
	};


	public static final long DL_TIMEOFF_CHOICES = RequestDetailLevel.DL_TIMEOFF_CHOICES;
	public static final long DL_TIMEOFF_CHOICES_LENGTH = RequestDetailLevel.DL_TIMEOFF_CHOICES_LENGTH;
	public static final long DL_TIMEOFF_WAITLIST = RequestDetailLevel.DL_TIMEOFF_WAITLIST;
	public static final long DL_TIMEOFF_WITHDRAW = RequestDetailLevel.DL_TIMEOFF_WITHDRAW;
	public static final long DL_TIMEOFF_FLEXMAKEUP = RequestDetailLevel.DL_TIMEOFF_FLEXMAKEUP;

<span class="fc" id="L91">	public static final Set VALID_DEBITTYPES = new HashSet(3);</span>

	static {
<span class="fc" id="L94">		VALID_DEBITTYPES.add(DEBITTYPE_DEBIT);</span>
<span class="fc" id="L95">		VALID_DEBITTYPES.add(DEBITTYPE_DONT_DEBIT);</span>
<span class="fc" id="L96">		VALID_DEBITTYPES.add(DEBITTYPE_DEBIT_ONLY_IF);</span>
	}

<span class="fc" id="L99">	public static final Set&lt;Integer&gt; VALID_FLEXTYPES = new HashSet&lt;Integer&gt;(2);</span>

	static {
<span class="fc" id="L102">		VALID_FLEXTYPES.add(FLEXTYPE_NONE);</span>
<span class="fc" id="L103">		VALID_FLEXTYPES.add(FLEXTYPE_FLEXWITHMAKEUP);</span>
	}

<span class="fc" id="L106">	private static FieldInfo fieldInfo = new TORequestFieldInfo();</span>

	// Caches the TOChoices associated with this request for retrieval by getRequestChoiceList()
	// method.  Necessary for returning only the approved choice for an approved request.  The
	// cache must be invalidated if the TOChoice collection is modified in any way.
	private transient List&lt;TOChoice&gt; timeoffChoiceCache;
	private transient TOWaitlist timeoffWaitlistCache;
	private transient TOWithdraw timeoffWithdrawCache;
	private transient List&lt;FlexRequestMakeup&gt; flexRequestMakeupCache;
	private transient List&lt;TOChoiceGroup&gt; choiceGroups;

<span class="nc" id="L117">	private List&lt;TOChoice&gt; calculatedTimeoffChoicesForAdvancedVto = null;</span>

<span class="nc" id="L119">	Boolean cachedWaitlistEnabled = null;</span>

	//this is a priority Order relative to the currently acquired list as per the Request Filter criteria
<span class="nc" id="L122">	private int timeoffWaitlistPriorityOrder = -1;</span>
<span class="nc" id="L123">	private transient TOValidationCache validationCache = null;</span>
<span class="nc" id="L124">	private boolean eligibleForWaitlist = false;</span>



<span class="nc" id="L128">	private Employee cachedEmployee = null;</span>
<span class="nc" id="L129">	private TOChoice waitlistEligibleTOChoice = null;</span>
<span class="nc" id="L130">	private TOChoice waitlistTOChoice = null;</span>
	private transient TOChoiceGroup toChoiceGroupForValidation;
<span class="nc" id="L132">	private transient List&lt;TOChoice&gt; toChoiceForValidation = new ArrayList&lt;TOChoice&gt;();</span>
	Set&lt;ID&gt; approvedChoiceIDs;
	List&lt;TOChoice&gt; approvedChoices;
<span class="nc" id="L135">	List&lt;TOChoice&gt; willBeApprovedChoices = new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L136">	private Pair&lt;TimeOffBid, Pair&lt;Integer, Integer&gt;&gt; timeOffBidInfo = null;</span>
<span class="nc" id="L137">	private boolean isRunForGroupTOBApproval=false; </span>

	public TORequest(long detailLevel) {
<span class="nc" id="L140">		super(Request.REQUESTTYPE_TIMEOFF, detailLevel);</span>
<span class="nc" id="L141">	}</span>


	/** If choices have been specified for validation then return those choices, otherwise return all choices. */
	public List&lt;TOChoice&gt; getTOChoicesAdjustedForValidation() {
<span class="nc bnc" id="L146" title="All 4 branches missed.">		return getTOChoicesForValidation() == null || getTOChoicesForValidation().isEmpty() ? getRequestChoiceList() : getTOChoicesForValidation();</span>
	}

	/** The choices that have been manually set for validation. */
	public List&lt;TOChoice&gt; getTOChoicesForValidation() {
<span class="nc" id="L151">			return toChoiceForValidation;</span>
	}

	/** Set choices for validation	 */
	public void setTOChoiceForValidation(Collection&lt;TOChoice&gt; aToChoiceForValidation) {
<span class="nc" id="L156">		this.toChoiceForValidation = new ArrayList&lt;TOChoice&gt;(aToChoiceForValidation);</span>
<span class="nc" id="L157">	}</span>

	public void clearTOChoiceForValidation() {
<span class="nc" id="L160">		toChoiceForValidation.clear();</span>
<span class="nc" id="L161">	}</span>

	public void setTOChoiceForValidation(TOChoice aToChoiceForValidation) {
<span class="nc" id="L164">		clearTOChoiceForValidation();</span>
<span class="nc" id="L165">		toChoiceForValidation.add(aToChoiceForValidation);</span>
<span class="nc" id="L166">	}</span>

	public TOChoiceGroup getTOChoiceGroupForValidation() {
<span class="nc" id="L169">		return toChoiceGroupForValidation;</span>
	}

	public void setTOChoiceGroupForValidation(TOChoiceGroup forValidation) {
<span class="nc" id="L173">		this.toChoiceGroupForValidation = forValidation;</span>
<span class="nc" id="L174">	}</span>




	/**
	 * Note: {@link #DL_TIMEOFF_CHOICES_LENGTH DL_TIMEOFF_CHOICES_LENGTH} is automatically
	 * added by the validation rule {@link com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeOffChoiceApprOrTentAppNotZeroLengthHV validation.TimeOffChoiceApprOrTentAppNotZeroLengthHV}
	 *
	 * @return
	 */
	public static long getDetailLevelForValidation() {
		//Note: DL_TIMEOFF_CHOICE_LENGTH is automatically added by TimeOffChoiceApprOrTentApprNotZeroLengthHV.java
		// removing the DL_TIMEOFF_FLEXMAKEUP which might be needed for validation but this is causing the problem for pulling My requests list
<span class="nc" id="L188">		return DL_BASIC | DL_TIMEOFF_CHOICES | DL_TIMEOFF_WAITLIST | DL_TIMEOFF_WITHDRAW;</span>
	}

	
	
	/**
	 * Get the validation cache in the proper type...conveniece method to
	 * avoid having to cast everywhere it is used.
	 */
	public TOValidationCache getCache() {
<span class="nc" id="L198">		return (TOValidationCache) getValidationCache();</span>
	}
	

	public TOValidationCache getTOValidationCache() {
<span class="nc" id="L203">		return getCache();</span>
	}


	public void clearValidationCache() {
<span class="nc" id="L208">		validationCache = null;</span>
<span class="nc" id="L209">	}</span>

	public void setCache(TOValidationCache cache) {
<span class="nc" id="L212">		validationCache = cache;</span>
<span class="nc" id="L213">	}</span>

	@Override
	public FieldInfo getFieldInfo() {
<span class="nc" id="L217">		return fieldInfo;</span>
	}

	/**
	 * Returns a list of TOChoices associated with this request, sorted by their rank.
	 * To obtain only the approved TOChoice, use getApprovedChoice().
	 * &lt;p/&gt;
	 * Note:
	 *
	 * @return
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;TOChoice&gt; getRequestChoiceList() {
		// if TOChoice cache is uninitialized, initialize.
<span class="nc bnc" id="L231" title="All 2 branches missed.">		if (timeoffChoiceCache == null) {</span>
<span class="nc" id="L232">			timeoffChoiceCache = new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L233">			timeoffChoiceCache.addAll(getChildObjects(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE));</span>

			// sort TimeOff choices by user rank and cache it.  Caching necessary since ValueObjectNode
			// cannot maintain a sorted list of TOChoices(uses a Map internally to hold the TOChoices).
<span class="nc bnc" id="L237" title="All 2 branches missed.">			if (timeoffChoiceCache.size() &gt; 1) {</span>
<span class="nc" id="L238">				Collections.sort(timeoffChoiceCache, TOChoice.USER_RANK_COMPARATOR);</span>
			}
		}

<span class="nc" id="L242">		return timeoffChoiceCache;</span>
	}
	


	public List&lt;TOChoice&gt; getCalculatedTimeoffChoicesForAdvancedVto() {
<span class="nc bnc" id="L248" title="All 2 branches missed.">		return calculatedTimeoffChoicesForAdvancedVto == null ? Collections.emptyList() : calculatedTimeoffChoicesForAdvancedVto;</span>
	}

	public void setToApprovedAllCalculatedTimeOffChoicesForAdvanceVto() {

<span class="nc bnc" id="L253" title="All 2 branches missed.">		if (calculatedTimeoffChoicesForAdvancedVto == null) {</span>
<span class="nc" id="L254">			return;</span>
		}

<span class="nc bnc" id="L257" title="All 2 branches missed.">		for (TOChoice choice : calculatedTimeoffChoicesForAdvancedVto) {</span>
<span class="nc" id="L258">			choice.setIsApproved(true);</span>
<span class="nc" id="L259">		}</span>

<span class="nc" id="L261">		approvedChoices = null;</span>
<span class="nc" id="L262">		approvedChoiceIDs = null;</span>
<span class="nc" id="L263">	}</span>

	public void resetCalculatedTimeoffChoicesForAdvancedVto() {
<span class="nc" id="L266">		calculatedTimeoffChoicesForAdvancedVto = null;</span>
<span class="nc" id="L267">	}</span>

	public boolean isTimeoffChoicesForAdvancedVtoInitialized() {
<span class="nc bnc" id="L270" title="All 2 branches missed.">		return calculatedTimeoffChoicesForAdvancedVto != null;</span>
	}

	public void setCalculatedTimeoffChoicesForAdvancedVto(List&lt;TOChoice&gt; choices) {
<span class="nc" id="L274">		calculatedTimeoffChoicesForAdvancedVto = choices;</span>
<span class="nc" id="L275">	}</span>

	// For testing primarily
	protected void addChoice(TOChoice choice){
<span class="nc bnc" id="L279" title="All 2 branches missed.">		if (timeoffChoiceCache == null) {</span>
<span class="nc" id="L280">			timeoffChoiceCache = new ArrayList&lt;TOChoice&gt;();</span>
		}
<span class="nc" id="L282">		timeoffChoiceCache.add(choice);</span>
<span class="nc" id="L283">	}</span>

	public Collection&lt;TOChoiceGroup&gt; getChoiceGroups() {

<span class="nc bnc" id="L287" title="All 2 branches missed.">		if (choiceGroups != null) {</span>
<span class="nc" id="L288">			return choiceGroups;</span>
		}

<span class="nc" id="L291">		choiceGroups = new ArrayList&lt;TOChoiceGroup&gt;();</span>
<span class="nc" id="L292">		Map&lt;Integer, List&lt;TOChoice&gt;&gt; map = new HashMap&lt;Integer, List&lt;TOChoice&gt;&gt;();</span>

<span class="nc bnc" id="L294" title="All 2 branches missed.">		for (TOChoice choice : getRequestChoiceList()) {</span>
<span class="nc" id="L295">			int groupID = choice.getGroupID();</span>
<span class="nc" id="L296">			List&lt;TOChoice&gt; list = map.get(groupID);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">			if (list == null) {</span>
<span class="nc" id="L298">				list = new ArrayList&lt;TOChoice&gt;();</span>
<span class="nc" id="L299">				map.put(groupID, list);</span>
			}
<span class="nc" id="L301">			list.add(choice);</span>
<span class="nc" id="L302">		}</span>

<span class="nc bnc" id="L304" title="All 2 branches missed.">		for (List&lt;TOChoice&gt; choiceList : map.values()) {</span>
<span class="nc" id="L305">			Collections.sort(choiceList, TOChoiceStartComparator.INSTANCE);</span>
<span class="nc" id="L306">			choiceGroups.add(new TOChoiceGroup(choiceList));</span>
<span class="nc" id="L307">		}</span>

<span class="nc" id="L309">		Collections.sort(choiceGroups, TOChoiceGroupRankComparator.INSTANCE);</span>
<span class="nc" id="L310">		return choiceGroups;</span>
	}

	/**
	 * Returns a list of FlexRequestMakeups associated with this request, sorted by their STARTTIME.
	 */
	@SuppressWarnings(&quot;unchecked&quot;)
	public List&lt;FlexRequestMakeup&gt; getFlexRequestMakeupList() {
		// if FlexRequestMakeup cache is uninitialized, initialize.
<span class="nc bnc" id="L319" title="All 2 branches missed.">		if (flexRequestMakeupCache == null) {</span>
<span class="nc" id="L320">			flexRequestMakeupCache = new ArrayList&lt;FlexRequestMakeup&gt;();</span>
<span class="nc" id="L321">			flexRequestMakeupCache.addAll(getChildObjects(TORequestFieldInfo.TO_FLEXMAKEUP_CHILD_TYPE));</span>

			// sort FlexRequestMakeups by STARTTIME and cache it.  Caching necessary since ValueObjectNode
			// cannot maintain a sorted list of FlexRequestMakeups (uses a Map internally to hold the FlexRequestMakeups).
<span class="nc bnc" id="L325" title="All 2 branches missed.">			if (flexRequestMakeupCache.size() &gt; 1) {</span>
<span class="nc" id="L326">				Collections.sort(flexRequestMakeupCache);</span>
			}
		}

<span class="nc" id="L330">		return flexRequestMakeupCache;</span>
	}

	/**
	 * Returns waitlist info associated with this request.
	 * &lt;p/&gt;
	 * Note:
	 *
	 * @return
	 */
	public TOWaitlist getWaitlistInfo() {
		// if m_TOWaitlist Cache is uninitialized, initialize.
<span class="nc bnc" id="L342" title="All 2 branches missed.">		if (timeoffWaitlistCache == null) {</span>
<span class="nc" id="L343">			Collection towaitlistCol = getChildObjects(TORequestFieldInfo.TO_WAITLIST_CHILD_TYPE);</span>
<span class="nc bnc" id="L344" title="All 4 branches missed.">			if (towaitlistCol != null &amp;&amp; !towaitlistCol.isEmpty()) {</span>
<span class="nc" id="L345">				timeoffWaitlistCache = (TOWaitlist) towaitlistCol.iterator().next();</span>
			}
		}
<span class="nc" id="L348">		return timeoffWaitlistCache;</span>
	}

	/**
	 * get the first TOChoice with rank one for this request
	 *
	 * @return
	 */
	public TOChoice getFirstTOChoice() {
<span class="nc" id="L357">		TOChoice firstTOChoice = null;</span>
<span class="nc" id="L358">		Iterator iterator = getRequestChoiceList().iterator();</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">		while (iterator.hasNext()) {</span>
<span class="nc" id="L360">			TOChoice toChoice = (TOChoice) iterator.next();</span>
<span class="nc bnc" id="L361" title="All 2 branches missed.">			if (toChoice.getRank() == 1) {</span>
<span class="nc" id="L362">				firstTOChoice = toChoice;</span>
<span class="nc" id="L363">				break;</span>
			}
<span class="nc" id="L365">		}</span>
<span class="nc" id="L366">		return firstTOChoice;</span>
	}

	/**
	 * Debit type for time off requests.
	 * &lt;p/&gt;
	 * A Time off event is represented by a CalendarEventAssignment. The
	 * following time off debit types are supported:
	 * &lt;li&gt;&lt;b&gt; debit &lt;/b&gt;
	 * CalendarEventAssignment field values: EVENT_TYPE = TIME_OFF;
	 * TIMEOFFRULE == USE_COUNTMINSTOWARDSRULE; COUNTSMINSTOWARDRULE = timeOffLength. &lt;br&gt;
	 * TimeOff length calculated during approval and persisted.  Not recalculated
	 * after approval even if underlying events change.
	 * &lt;li&gt;&lt;b&gt; debit-if-necessary &lt;/b&gt;
	 * CalendarEventAssignment field values: EVENT_TYPE = TIME_OFF; TIMEOFFRULE == USE_SHIFT; COUNTSMINSTOWARDRULE = N/A &lt;br&gt;
	 * TimeOff length is never persisted.  Calculated every time it is needed.
	 * &lt;li&gt;&lt;b&gt; 'don't debit &lt;/b&gt;
	 * CalendarEventAssignment field values: EVENT_TYPE == UNAVAILABILITY; TIMEOFFRULE == N/A; COUNTSMINSTOWARDSRULE = N/A. &lt;br&gt;
	 * Created unavailability event cannot have any events under it (shift assignments
	 * or calendar or time off events). &lt;br&gt;
	 *
	 * @return
	 */
	public String getTimeOffDebitType() {
<span class="nc" id="L390">		return getFormattedFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_S_DEBITTYPE);</span>
	}

	/**
	 * Activity ID for this time off event. Following activity attributes are
	 * used in TORequest workflow:
	 * &lt;li&gt; Requestable - activity does not qualify for TORequest workflow unless it is requestable.
	 * &lt;li&gt; TimeOff - activity qualifies for &quot;debit&quot; and &quot;debit-if&quot; TORequest types. In other words, this
	 * activity can be used to create CalendarEventAssignments with EVENT_TYPE == TIME_OFF. See
	 * {@link com.bluepumpkin.ejb.bbm.activity.model.Event Event} for further information.
	 * &lt;li&gt; hasAllocations - available only if &quot;timeOff&quot; attribute is enabled. Denotes that
	 * activity can have allocations (daily default, weekly default and yearly allocations).
	 * &lt;li&gt; Unavailability - activity qualifies for &quot;don't debit&quot; TORequest type.
	 *
	 * @return
	 */
	public ID getTimeOffType() {
<span class="nc" id="L407">		return getFieldValueID(TORequestFieldInfo.TIMEOFFREQUEST_I_ACTIVITYID);</span>
	}

	/**
	 * @return The Flex type for this time off request.
	 */
	public int getFlexType() {
<span class="nc" id="L414">		return getFieldValueInt(TORequestFieldInfo.TIMEOFFREQUEST_N_FLEXTYPE);</span>
	}
	
	public boolean isVTOFullDay(){
<span class="nc" id="L418">		return getFieldValueBoolean(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOFULLDAY);</span>
	}
	public void setVTOFullDay(boolean value){
<span class="nc" id="L421">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOFULLDAY,value);</span>
<span class="nc" id="L422">	}</span>
	public boolean isVTOPartialDay(){
<span class="nc" id="L424">		return getFieldValueBoolean(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOPARTIALDAY);</span>
	}
	public void setVTOPartialDay(boolean value){
<span class="nc" id="L427">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOPARTIALDAY,value);</span>
<span class="nc" id="L428">	}</span>
	public boolean isVTOLateStart(){
<span class="nc" id="L430">		return getFieldValueBoolean(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOLATESTART);</span>
	}
	public void setVTOLateStart(boolean value){
<span class="nc" id="L433">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOLATESTART,value);</span>
<span class="nc" id="L434">	}</span>
	public boolean isVTOEarlyOff(){
<span class="nc" id="L436">		return getFieldValueBoolean(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOEARLYOFF);</span>
	}
	public void setVTOEarlyOff(boolean value){
<span class="nc" id="L439">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOEARLYOFF,value);</span>
<span class="nc" id="L440">	}</span>
	public boolean isVTOAnytimeOff(){
<span class="nc" id="L442">		return getFieldValueBoolean(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOANYTIMEOFF);</span>
	}
	public void setVTOAnytimeOff(boolean value){
<span class="nc" id="L445">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_B_ISVTOANYTIMEOFF,value);</span>
<span class="nc" id="L446">	}</span>
	public Date getAdvancedVTODate() {
<span class="nc" id="L448">		return getFieldValueDate(TORequestFieldInfo.TIMEOFFREQUEST_D_ADVANCEDVTODATE);</span>
	}
	public Date getPartialDayStartTime() {
<span class="nc" id="L451">		return getFieldValueDate(TORequestFieldInfo.TIMEOFFREQUEST_D_PARTIALDAYSTARTTIME);</span>
	}
	public Date getPartialDayEndTime() {
<span class="nc" id="L454">		return getFieldValueDate(TORequestFieldInfo.TIMEOFFREQUEST_D_PARTIALDAYENDTIME);</span>
	}
	


	public boolean isPendingAdvancedVto() {
<span class="nc bnc" id="L460" title="All 4 branches missed.">		return isAdvancedVTORequest() &amp;&amp; isPending();</span>
	}



	public List&lt;TOChoice&gt; getTOChoices(Collection&lt;ID&gt; choiceIDs) throws RmException {
<span class="nc" id="L466">		List&lt;TOChoice&gt; choice = findChoices(getRequestChoiceList(), choiceIDs);</span>
<span class="nc bnc" id="L467" title="All 2 branches missed.">		if (choice.isEmpty()) {</span>
<span class="nc" id="L468">			throw RequestUtil.createRmException(RmEjbLogBundleKey.TOCHOICE_NOT_FOUND,</span>
<span class="nc" id="L469">					choiceIDs, getID(), null);</span>
		}
<span class="nc" id="L471">		return choice;</span>
	}

	public TOChoice getTOChoice(ID choiceID) throws RmException {
<span class="nc bnc" id="L475" title="All 2 branches missed.">		if (choiceID == null) {</span>
<span class="nc" id="L476">			return null;</span>
		}

<span class="nc" id="L479">		List&lt;TOChoice&gt; choice = findChoices(getTOChoicesAdjustedForCalculatedVto(), Collections.singleton(choiceID));</span>
<span class="nc bnc" id="L480" title="All 2 branches missed.">		if (choice.isEmpty()) {</span>
<span class="nc" id="L481">			throw RequestUtil.createRmException(RmEjbLogBundleKey.TOCHOICE_NOT_FOUND,</span>
<span class="nc" id="L482">					choiceID, getID(), null);</span>
		}
<span class="nc" id="L484">		return choice.get(0);</span>
	}

	/** If we have calculated time off choices then return that,  otherwise get the regular choice list */
	public List&lt;TOChoice&gt; getTOChoicesAdjustedForCalculatedVto() {
<span class="nc bnc" id="L489" title="All 2 branches missed.">		if (hasCalculatedAdvancedVto()) {</span>
<span class="nc" id="L490">			return getCalculatedTimeoffChoicesForAdvancedVto();</span>
		}
<span class="nc" id="L492">		return getRequestChoiceList();</span>
	}

	/** If we have calculated time off choices then search the calculated time off choices otherwise look at the regular choice list  */
	public List&lt;TOChoice&gt; getTOChoicesAdjustedForCalculatedVto(Collection&lt;ID&gt; choiceIDs) throws RmException {

<span class="nc bnc" id="L498" title="All 4 branches missed.">		if (choiceIDs == null || choiceIDs.isEmpty()) {</span>
<span class="nc" id="L499">			return Collections.emptyList();</span>
		}

<span class="nc bnc" id="L502" title="All 2 branches missed.">		if (hasCalculatedAdvancedVto()) {</span>
<span class="nc" id="L503">			return getCalculatedAdvancedVtoChoices(choiceIDs);</span>
		}

<span class="nc" id="L506">		return getTOChoices(choiceIDs);</span>
	}

	private boolean hasCalculatedAdvancedVto() {
<span class="nc bnc" id="L510" title="All 4 branches missed.">		return isPendingAdvancedVto() &amp;&amp; calculatedTimeoffChoicesForAdvancedVto != null;</span>
	}

	public List&lt;TOChoice&gt; getApprovedAdvancedVtoChoices() {
<span class="nc" id="L514">		return getCalculatedAdvancedVtoChoices(getApprovedChoiceIDs());</span>
	}

	List&lt;TOChoice&gt; getCalculatedAdvancedVtoChoices(Collection&lt;ID&gt; choiceIDs) {
<span class="nc" id="L518">		return findChoices(calculatedTimeoffChoicesForAdvancedVto, choiceIDs);</span>
	}

	List&lt;TOChoice&gt; findChoices(Collection&lt;TOChoice&gt; choices, Collection&lt;ID&gt; choiceIDs) {
<span class="nc bnc" id="L522" title="All 8 branches missed.">		if (choices == null || choiceIDs == null || choices.isEmpty() || choiceIDs.isEmpty()) {</span>
<span class="nc" id="L523">			return Collections.emptyList();</span>
		}

<span class="nc" id="L526">		Set&lt;ID&gt; choiceIDSet = new HashSet&lt;ID&gt;(choiceIDs);</span>
<span class="nc" id="L527">		List&lt;TOChoice&gt; result = new ArrayList&lt;TOChoice&gt;();</span>

<span class="nc bnc" id="L529" title="All 2 branches missed.">		for (TOChoice choice : choices) {</span>
<span class="nc bnc" id="L530" title="All 2 branches missed.">			if (choiceIDSet.contains(choice.getID())) {</span>
<span class="nc" id="L531">				result.add(choice);</span>
			}
<span class="nc" id="L533">		}</span>
<span class="nc" id="L534">		return result;</span>
	}

	/**
	 * Find the FlexRequestMakeup with ID == makeupID.
	 */
	public FlexRequestMakeup getFlexRequestMakeup(ID makeupID) throws RmException {
<span class="nc" id="L541">		Collection&lt;FlexRequestMakeup&gt; makeupList = getFlexRequestMakeupList();</span>

		// Find the makeup
<span class="nc" id="L544">		FlexRequestMakeup theReturn = null;</span>
<span class="nc bnc" id="L545" title="All 2 branches missed.">		for (FlexRequestMakeup makeup : makeupList) {</span>
<span class="nc bnc" id="L546" title="All 2 branches missed.">			if (makeup.getID().equals(makeupID)) {</span>
<span class="nc" id="L547">				theReturn = makeup;</span>
<span class="nc" id="L548">				break;</span>
			}
<span class="nc" id="L550">		}</span>

<span class="nc bnc" id="L552" title="All 2 branches missed.">		if (theReturn == null) {</span>
<span class="nc" id="L553">			throw RequestUtil.createRmException(RmEjbLogBundleKey.TOCHOICE_NOT_FOUND,</span>
<span class="nc" id="L554">					makeupID, getID(), null);</span>
		}

<span class="nc" id="L557">		return theReturn;</span>
	}

	/**
	 * Returns the employee iD and timeoff range for the first timeoff choice. Used for
	 * autoprocessing.
	 * &lt;p/&gt;
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#getEmpIDTimeRangePairs()
	 */
	@Override
	public Collection&lt;Pair&lt;ID, TimeRange&gt;&gt; getEmpIDTimeRangePairs() {
<span class="nc" id="L570">		TOChoice firstChoice = getFirstTOChoice();</span>
<span class="nc" id="L571">		return Collections.singletonList(new Pair&lt;ID, TimeRange&gt;(getEmployeeID(),</span>
<span class="nc" id="L572">		        new TimeRange(firstChoice.getStartDate(), firstChoice.getEndDate())));</span>
	}

	/**
	 * Returns the employee iD and timeoff range for all timeoff choices. Used for autoprocessing loops only
	 * The return type is Pair&lt;List&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt;
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#getEmpIDTimeRangePairs()
	 */
	public Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt; getAllEmpIDTimeRangePairs() {
<span class="nc" id="L582">		List&lt;TOChoice&gt; toChoiceList = getRequestChoiceList();</span>
<span class="nc" id="L583">		List&lt;Pair&lt;ID, TimeRange&gt;&gt; empIdTimeRange = new ArrayList&lt;Pair&lt;ID, TimeRange&gt;&gt;();</span>
<span class="nc bnc" id="L584" title="All 2 branches missed.">		for (TOChoice toChoice : toChoiceList) {</span>
<span class="nc" id="L585">			empIdTimeRange.add(new Pair&lt;ID, TimeRange&gt;(getEmployeeID(), new TimeRange(toChoice.getStartDate(), toChoice.getEndDate())));</span>
<span class="nc" id="L586">		}</span>
<span class="nc" id="L587">		return new Pair&lt;Collection&lt;Pair&lt;ID, TimeRange&gt;&gt;, List&lt;TOChoice&gt;&gt;(empIdTimeRange, toChoiceList);</span>
	}

	public Pair getFirstEmpIDTimeRangePair() {
<span class="nc" id="L591">		Collection requestChoiceList = new ArrayList();</span>
<span class="nc" id="L592">		List toChoiceList = new ArrayList();</span>
<span class="nc" id="L593">		TOChoice toChoice = getFirstTOChoice();</span>
<span class="nc" id="L594">		requestChoiceList.add(toChoice);</span>
<span class="nc" id="L595">		toChoiceList.add(new Pair(getEmployeeID(), new TimeRange(toChoice.getStartDate(), toChoice.getEndDate())));</span>
<span class="nc" id="L596">		return new Pair(toChoiceList, requestChoiceList);</span>
	}

	/**
	 * Implements a method from the Validatable interface.
	 *
	 * @return the ValidationCache associated with this object.
	 */
	@Override
	public ValidationCache getValidationCache() {
<span class="nc bnc" id="L606" title="All 2 branches missed.">		if (validationCache == null) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">			validationCache = this.isFlexTimeRequest() ? FTValidationCacheFactory.newFTValidationCache(this) : new TOValidationCache(this);</span>
		}
<span class="nc" id="L609">		return validationCache;</span>
	}



	/**
	 * Implements a method from the Validatable interface.
	 *
	 * @return a Collection of TimeRanges: one for each TOChoice.
	 */
	@Override
	public Collection getValidationTimeRanges() {
<span class="nc" id="L621">		ArrayList result = new ArrayList();</span>

<span class="nc" id="L623">		Collection&lt;TOChoice&gt; choiceList = getRequestChoiceList();</span>
		TimeRange range;

<span class="nc bnc" id="L626" title="All 2 branches missed.">		if (choiceList != null) {</span>
<span class="nc bnc" id="L627" title="All 2 branches missed.">			for (Iterator&lt;TOChoice&gt; it = choiceList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L628">				TOChoice choice = it.next();</span>
<span class="nc" id="L629">				range = new TimeRange(choice.getStartDate(), choice.getEndDate());</span>
<span class="nc" id="L630">				result.add(range);</span>
<span class="nc" id="L631">			}</span>
		}

<span class="nc" id="L634">		return result;</span>
	}



	/**
	 * Replaces existing list of TOChoices with the given list.
	 *
	 * @param toChoices
	 */
	public void setRequestChoiceList(Collection toChoices) {
		// clear existing choices (in this valueObject and set flag for removal from database).
<span class="nc" id="L646">		deleteAllChildren(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE);</span>

		// Now add the passed choices for creation.
<span class="nc bnc" id="L649" title="All 2 branches missed.">		for (Iterator itr = toChoices.iterator(); itr.hasNext();) {</span>
<span class="nc" id="L650">			createChildObject(TORequestFieldInfo.TO_CHOICE_CHILD_TYPE, (TOChoice) itr.next());</span>
		}

		// invalidate cache as the TOChoice collection has changed.
<span class="nc" id="L654">		invalidateTimeoffChoiceCache();</span>

<span class="nc" id="L656">		addDetailLevel(DL_TIMEOFF_CHOICES);</span>
<span class="nc" id="L657">	}</span>

	private void invalidateTimeoffChoiceCache() {
<span class="nc" id="L660">		timeoffChoiceCache = null;</span>
<span class="nc" id="L661">		approvedChoices = null;</span>
<span class="nc" id="L662">		approvedChoiceIDs = null;</span>
<span class="nc" id="L663">	}</span>

	/**
	 * Replaces existing list of FlexRequestMakeups with the given list.
	 *
	 * @param flexMakeups
	 */
	public void setFlexRequestMakeupList(Collection&lt;FlexRequestMakeup&gt; flexMakeups) {
		// clear existing makeups (in this valueObject and set flag for removal from database).
<span class="nc" id="L672">		deleteAllChildren(TORequestFieldInfo.TO_FLEXMAKEUP_CHILD_TYPE);</span>

		// Now add the passed makeups for creation.
<span class="nc bnc" id="L675" title="All 2 branches missed.">		for (FlexRequestMakeup makeup : flexMakeups) {</span>
<span class="nc" id="L676">			createChildObject(TORequestFieldInfo.TO_FLEXMAKEUP_CHILD_TYPE, makeup);</span>
<span class="nc" id="L677">		}</span>

		// invalidate cache as the FlexRequestMakeup collection has changed.
<span class="nc bnc" id="L680" title="All 2 branches missed.">		if (flexRequestMakeupCache != null) {</span>
<span class="nc" id="L681">			flexRequestMakeupCache.clear();</span>
		}
<span class="nc" id="L683">		flexRequestMakeupCache = null;</span>

<span class="nc" id="L685">		addDetailLevel(DL_TIMEOFF_FLEXMAKEUP);</span>
<span class="nc" id="L686">	}</span>

	/**
	 * Replaces existing Waitlist with the given list.
	 *
	 * @param Waitlist
	 */
	public void setWaitlistInfo(TOWaitlist waitlist) {
		// clear existing choices (in this valueObject and set flag for removal from database).
<span class="nc" id="L695">		deleteAllChildren(TORequestFieldInfo.TO_WAITLIST_CHILD_TYPE);</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">		if (waitlist != null) {</span>
<span class="nc" id="L697">			createChildObject(TORequestFieldInfo.TO_WAITLIST_CHILD_TYPE, waitlist);</span>
		}
		// invalidate cache as the m_TOWaitlist  has changed.
<span class="nc" id="L700">		timeoffWaitlistCache = null;</span>
<span class="nc" id="L701">		addDetailLevel(DL_TIMEOFF_WAITLIST);</span>
<span class="nc" id="L702">	}</span>

	/**
	 * see {@link #getTimeOffDebitType() getTimeOffDebitType}
	 *
	 * @param pTimeOffDebitType
	 */
	public void setTimeOffDebitType(String pTimeOffDebitType) {
<span class="nc" id="L710">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_S_DEBITTYPE, pTimeOffDebitType);</span>
<span class="nc" id="L711">	}</span>

	/**
	 * see {@link #getTimeOffType() getTimeOffType}
	 *
	 * @param pTimeOffType
	 */
	public void setTimeOffType(ID pTimeOffType) {
<span class="nc" id="L719">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_I_ACTIVITYID, pTimeOffType);</span>
<span class="nc" id="L720">	}</span>

	public void setAdvancedVTODate(Date anyTimeDate) {
<span class="nc" id="L723">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_D_ADVANCEDVTODATE, anyTimeDate);</span>
<span class="nc" id="L724">	}</span>
	public void setPartialStartTime(Date startTime) {
<span class="nc" id="L726">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_D_PARTIALDAYSTARTTIME, startTime);</span>
<span class="nc" id="L727">	}</span>
	public void setPartialEndTime(Date endTime) {
<span class="nc" id="L729">		setFieldValue(TORequestFieldInfo.TIMEOFFREQUEST_D_PARTIALDAYENDTIME, endTime);</span>
<span class="nc" id="L730">	} 	</span>
	/**
	 * Calculate the length of the time off choices
	 */
	public void resetLengths() {
<span class="nc" id="L735">		Collection&lt;TOChoice&gt; choiceList = getRequestChoiceList();</span>

<span class="nc bnc" id="L737" title="All 2 branches missed.">		if (choiceList == null) {</span>
<span class="nc" id="L738">			return;</span>
		}

<span class="nc bnc" id="L741" title="All 2 branches missed.">		for (Iterator&lt;TOChoice&gt; it = choiceList.iterator(); it.hasNext();) {</span>
<span class="nc" id="L742">			it.next().setLength(0.0f);</span>
		}
<span class="nc" id="L744">	}</span>

	//Equivalent to Use Unvailability
	public boolean isUnavailability() {
<span class="nc" id="L748">		return getTimeOffDebitType().equals(TORequest.DEBITTYPE_DONT_DEBIT);</span>
	}

	/**
	 * @return
	 */
	//Equivalent to use underlying shift
	public boolean isUseUnderlyingShift() {
<span class="nc" id="L756">		return getTimeOffDebitType().equals(TORequest.DEBITTYPE_DEBIT_ONLY_IF);</span>
	}

	//Equivalent to Use My TO Hours
	public boolean isUseFixedHours() {
<span class="nc" id="L761">		return getTimeOffDebitType().equals(TORequest.DEBITTYPE_DEBIT);</span>
	}

	

	/**
	 * Validation results for TORequests are stored in the request and its choices.
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#hardValidationFailed()
	 *      &lt;p/&gt;
	 *      &lt;p/&gt;
	 *      &lt;b&gt;Hard validation fails if:&lt;/b&gt;
	 *      &lt;li&gt; hard validation error(s) exist for the request
	 *      &lt;li&gt; hard validation error(s) exist for all TOChoices
	 *      &lt;li&gt; Otherwise hard validation successful.
	 */
	@Override
	public ValidationResult hardValidationFailed() {
		// if hard validation errors found for the request
<span class="nc" id="L780">		ValidationResult result = super.hardValidationFailed();</span>
<span class="nc bnc" id="L781" title="All 2 branches missed.">		if (result != null) {</span>
<span class="nc" id="L782">			return result;</span>
		}

		// Verify if all TOChoices have hard validation errors.  If so, hard validation failed.
<span class="nc bnc" id="L786" title="All 2 branches missed.">		for (Iterator&lt;TOChoice&gt; itr = getRequestChoiceList().iterator(); itr.hasNext();) {</span>
<span class="nc" id="L787">			Collection&lt;ValidationResult&gt; choiceValResults = itr.next().getValidationResults(true);</span>

			// if this TO choice passes, reset flag to success.
<span class="nc" id="L790">			result = hardValidationErrorExists(choiceValResults);</span>
<span class="nc bnc" id="L791" title="All 2 branches missed.">			if (result == null) {</span>
<span class="nc" id="L792">				return result;</span>
			}
<span class="nc" id="L794">		}</span>
<span class="nc" id="L795">		return result;</span>
	}

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.validation.Validatable#clearValidationResults(boolean)
	 */
	@Override
	public void clearValidationResults(boolean entireBranch) {
		// clear the results associated with this request
<span class="nc" id="L804">		super.clearValidationResults(entireBranch);</span>

		//now clear the results associated with the children.
<span class="nc bnc" id="L807" title="All 2 branches missed.">		if (entireBranch) {</span>
<span class="nc" id="L808">			List&lt;TOChoice&gt; toChoices = getRequestChoiceList();</span>
<span class="nc bnc" id="L809" title="All 2 branches missed.">			for (int i = 0; i &lt; toChoices.size(); i++) {</span>
<span class="nc" id="L810">				toChoices.get(i).clearValidationResults(true);</span>
			}
		}
<span class="nc" id="L813">	}</span>

	/* (non-Javadoc)
	 * @see com.bluepumpkin.ejb.rm.requests.common.validation.Validatable#getValidationResults()
	 */
	@Override
	public Collection&lt;ValidationResult&gt; getValidationResults(boolean entireBranch) {
<span class="nc" id="L820">		Collection&lt;ValidationResult&gt; results = super.getValidationResults(true);</span>

<span class="nc bnc" id="L822" title="All 2 branches missed.">		if (!entireBranch) {</span>
<span class="nc" id="L823">			return results;</span>
		}

		//obtain results from children.
<span class="nc" id="L827">		List&lt;TOChoice&gt; toChoices = getRequestChoiceList();</span>

<span class="nc bnc" id="L829" title="All 2 branches missed.">		for (TOChoice choice : toChoices) {</span>
<span class="nc" id="L830">			results.addAll(choice.getValidationResults(entireBranch));</span>
<span class="nc" id="L831">		}</span>

<span class="nc bnc" id="L833" title="All 2 branches missed.">		if (getWithdrawInfo() != null) {</span>
<span class="nc" id="L834">			results.addAll(getWithdrawInfo().getValidationResults(entireBranch));</span>
		}
<span class="nc" id="L836">		return results;</span>

	}

	//This is a hack, needed to deal with the validation interfaces which wants to return a ValidationResult, 
	//but which should really be returning  a collection of ValidationResult
	public ValidationResult getFirstValidationResult() {
<span class="nc" id="L843">		Collection&lt;ValidationResult&gt; results = super.getValidationResults(true);</span>
<span class="nc bnc" id="L844" title="All 2 branches missed.">		if (!results.isEmpty()) {</span>
<span class="nc" id="L845">			return results.iterator().next();</span>
		}
<span class="nc" id="L847">		return null;</span>
	}

	/**
	 * Return the subtype of this request. For a Time Off request, the subtype is the time off type,
	 * which is the activityID.
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#getRequestSubType()
	 */
	@Override
	public ID getRequestSubType() {
<span class="nc" id="L857">		return getTimeOffType();</span>
	}

	/**
	 * Return the subtype of this Flex Time request, which will be one of the following values:
	 * 0 : The time off comes before the makeup. (REQUEST_SUB_TYPE_TIMEOFF_BEFORE_MAKEUP)
	 * 1 : The time off comes after the makeup. (REQUEST_SUB_TYPE_MAKEUP_BEFORE_TIMEOFF)
	 * The default return value is 0 .
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#getRequestSubType()
	 */
	public int getFlexTimeRequestSubType() {
<span class="nc" id="L868">		int result = RequestFilingRule.REQUEST_SUB_TYPE_TIMEOFF_BEFORE_MAKEUP;</span>
<span class="nc" id="L869">		List&lt;FlexRequestMakeup&gt; sortedMakeups = getFlexRequestMakeupList();</span>
<span class="nc bnc" id="L870" title="All 2 branches missed.">		if (sortedMakeups != null) {</span>
<span class="nc bnc" id="L871" title="All 2 branches missed.">			for (FlexRequestMakeup makeup : sortedMakeups) {</span>
<span class="nc" id="L872">				TOChoice timeoff = getFirstTOChoice();</span>
<span class="nc bnc" id="L873" title="All 2 branches missed.">				if (timeoff != null) {</span>
<span class="nc" id="L874">					Date makeupStart = makeup.getStartTime();</span>
<span class="nc" id="L875">					Date timeoffStart = timeoff.getStartDate();</span>
<span class="nc bnc" id="L876" title="All 2 branches missed.">					result = timeoffStart.before(makeupStart) ?</span>
							RequestFilingRule.REQUEST_SUB_TYPE_TIMEOFF_BEFORE_MAKEUP :
							RequestFilingRule.REQUEST_SUB_TYPE_MAKEUP_BEFORE_TIMEOFF;
<span class="nc" id="L879">				}</span>
				break;
			}
		}
<span class="nc" id="L883">		return result;</span>
	}

	/**
	 * Returns the number of hours  for the first timeoff choice. Used for sorting waitlists
	 * &lt;p/&gt;
	 * (non-Javadoc)
	 *
	 * @see com.bluepumpkin.ejb.rm.requests.common.model.RequestAggregate#getEmpIDTimeRangePairs()
	 */
	public TOChoice getWaitlistTOChoice() {
<span class="nc bnc" id="L894" title="All 6 branches missed.">		if (waitlistTOChoice == null &amp;&amp; (getWaitlistInfo() != null &amp;&amp; RequestAuditTrail.STATUS_WAITLIST.equals(getRequestStatus()))) {</span>
<span class="nc" id="L895">			Iterator&lt;TOChoice&gt; iterator = getRequestChoiceList().iterator();</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">			while (iterator.hasNext()) {</span>
<span class="nc" id="L897">				TOChoice toChoice = iterator.next();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">				if (toChoice.isWaitlist()) {</span>
<span class="nc" id="L899">					waitlistTOChoice = toChoice;</span>
<span class="nc" id="L900">					break;</span>
				}
<span class="nc" id="L902">			}</span>
		}
<span class="nc" id="L904">		return waitlistTOChoice;</span>
	}

	public void setWaitlistTOChoice(TOChoice aWaitlistTOChoice) {
<span class="nc" id="L908">		this.waitlistTOChoice = aWaitlistTOChoice;</span>
<span class="nc" id="L909">	}</span>

	public long getWaitlistTOChoiceActualDurationInMilliSecs() {
<span class="nc" id="L912">		TOChoice firstChoice = getWaitlistTOChoice();</span>
<span class="nc" id="L913">		return firstChoice.getEndDate().getTime() - firstChoice.getStartDate().getTime();</span>
	}

	public float getWaitlistTOChoiceUsedAllocationHours() {
<span class="nc" id="L917">		TOChoice firstChoice = getWaitlistTOChoice();</span>
<span class="nc" id="L918">		return firstChoice.getLength();</span>
	}

	public Date getWaitlistTOChoiceStartDate() {
<span class="nc" id="L922">		TOChoice firstChoice = getWaitlistTOChoice();</span>
<span class="nc" id="L923">		return firstChoice.getStartDate();</span>
	}

	public int getNumberOfDaysOnWaitlist() {
<span class="nc" id="L927">		int numberOfDays = -1;</span>
<span class="nc" id="L928">		long timeinMsecs = getTimeOnWaitlist();</span>
<span class="nc bnc" id="L929" title="All 2 branches missed.">		if (timeinMsecs &gt; 0) {</span>
<span class="nc" id="L930">			numberOfDays = (int) (timeinMsecs / TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
		}
<span class="nc" id="L932">		return numberOfDays;</span>
	}

	public long getTimeOnWaitlist() {
<span class="nc" id="L936">		long timeInMilliSecs = -1;</span>
<span class="nc" id="L937">		TOWaitlist waitlist = getWaitlistInfo();</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">		if (waitlist != null) {</span>
<span class="nc" id="L939">			Date creationDate = waitlist.getTOWaitlistCreationDate();</span>
<span class="nc" id="L940">			timeInMilliSecs = new Date().getTime() - creationDate.getTime();</span>
		}
<span class="nc" id="L942">		return timeInMilliSecs;</span>
	}


	public Date getWaitlistCreationDateTime() {
<span class="nc" id="L947">		Date creationDate = null;</span>
<span class="nc" id="L948">		TOWaitlist waitlist = getWaitlistInfo();</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">		if (waitlist != null) {</span>
<span class="nc" id="L950">			creationDate = waitlist.getTOWaitlistCreationDate();</span>
		}
<span class="nc" id="L952">		return creationDate;</span>
	}

	public int getTOWaitlistPriorityOrder() {
<span class="nc" id="L956">		return timeoffWaitlistPriorityOrder;</span>
	}

	public void setTOWaitlistPriorityOrder(int priorityOrder) {
<span class="nc" id="L960">		timeoffWaitlistPriorityOrder = priorityOrder;</span>
<span class="nc" id="L961">	}</span>

	public Date getEmployeeStartDate() {
<span class="nc" id="L964">		return getEmployee().getStartTime();</span>
	}

	public int getEmployeeRank() {
<span class="nc" id="L968">		return getEmployee().getRank();</span>

	}

	public Employee getEmployee() {
		try {
<span class="nc bnc" id="L974" title="All 2 branches missed.">			if (cachedEmployee == null) {</span>
<span class="nc" id="L975">				cachedEmployee = CacheUtilBBM.getEmployeeByID(getEmployeeID(), null,</span>
				        Employee.DETAIL_LEVEL_EMPLOYEE_BASIC | Employee.DETAIL_LEVEL_EMPLOYEE_TIMEBASEDPROPERTY);
			}

<span class="nc" id="L979">		} catch (Exception e) {</span>
<span class="nc" id="L980">			this.logException(e);</span>
<span class="nc" id="L981">		}</span>
<span class="nc" id="L982">		return cachedEmployee;</span>
	}
	
	public boolean isWaitlistRequested() {
<span class="nc bnc" id="L986" title="All 2 branches missed.">		return getWaitlistInfo() != null;</span>
	}

	public boolean isEligibleForWaitlist() {
<span class="nc" id="L990">		return eligibleForWaitlist;</span>
	}

	public void setEligibleForWaitlist(boolean flag) {
<span class="nc" id="L994">		eligibleForWaitlist = flag;</span>
<span class="nc" id="L995">	}</span>

	/**
	 * Returns withdraw info associated with this request.
	 * &lt;p/&gt;
	 * Note:
	 *
	 * @return
	 */
	public TOWithdraw getWithdrawInfo() {
		// if m_TOWithdraw Cache is uninitialized, initialize.
<span class="nc bnc" id="L1006" title="All 2 branches missed.">		if (timeoffWithdrawCache == null) {</span>
<span class="nc" id="L1007">			Collection towithdrawCol = getChildObjects(TORequestFieldInfo.TO_WITHDRAW_CHILD_TYPE);</span>
<span class="nc bnc" id="L1008" title="All 4 branches missed.">			if (towithdrawCol != null &amp;&amp; !towithdrawCol.isEmpty()) {</span>
<span class="nc" id="L1009">				timeoffWithdrawCache = (TOWithdraw) towithdrawCol.iterator().next();</span>
			}
		}
<span class="nc" id="L1012">		return timeoffWithdrawCache;</span>
	}

	/**
	 * Replaces existing Withdraw with the given list.
	 *
	 * @param Withdraw
	 */
	public void setWithdrawInfo(TOWithdraw withdraw) {
		// clear existing choices (in this valueObject and set flag for removal from database).
<span class="nc" id="L1022">		deleteAllChildren(TORequestFieldInfo.TO_WITHDRAW_CHILD_TYPE);</span>
<span class="nc bnc" id="L1023" title="All 2 branches missed.">		if (withdraw != null) {</span>
<span class="nc" id="L1024">			createChildObject(TORequestFieldInfo.TO_WITHDRAW_CHILD_TYPE, withdraw);</span>
		}
		// invalidate cache as the m_TOWithdraw  has changed.
<span class="nc" id="L1027">		timeoffWithdrawCache = null;</span>
<span class="nc" id="L1028">		addDetailLevel(DL_TIMEOFF_WITHDRAW);</span>
<span class="nc" id="L1029">	}</span>

	public TOChoice getTOChoiceEligibleForWaitlist() {
<span class="nc" id="L1032">		return waitlistEligibleTOChoice;</span>
	}

	public void setTOChoiceEligibleForWaitlist(TOChoice aWaitlistEligibleTOChoice) {
<span class="nc" id="L1036">		this.waitlistEligibleTOChoice = aWaitlistEligibleTOChoice;</span>
<span class="nc" id="L1037">	}</span>

	public void setFirstTOChoice(ID toChoiceID) {
<span class="nc" id="L1040">		Collection&lt;TOChoice&gt; col = getRequestChoiceList();</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">		for (Iterator&lt;TOChoice&gt; iterator = col.iterator(); iterator.hasNext();) {</span>
<span class="nc" id="L1042">			TOChoice choice = iterator.next();</span>
<span class="nc bnc" id="L1043" title="All 2 branches missed.">			choice.setRank(choice.getID().equals(toChoiceID) ? 1 : 0);</span>
<span class="nc" id="L1044">		}</span>
<span class="nc" id="L1045">	}</span>

	public boolean isEligibleForAcceptAndRejectWithdrawAction() {
<span class="nc bnc" id="L1048" title="All 4 branches missed.">		return isEligibleForRejectWithdrawAction() &amp;&amp; isEligibleForAcceptWithdrawAction();</span>
	}

	public boolean isEligibleForRejectWithdrawAction() {
<span class="nc bnc" id="L1052" title="All 2 branches missed.">		return getWithdrawInfo() != null &amp;&amp;</span>
<span class="nc bnc" id="L1053" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_WITHDRAW_REQUEST.equals(getWithdrawInfo().getRequestStatus()) &amp;&amp;</span>
<span class="nc bnc" id="L1054" title="All 2 branches missed.">		        getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED);</span>
	}

	public boolean isEligibleForAcceptWithdrawAction() {
<span class="nc bnc" id="L1058" title="All 2 branches missed.">		return getWithdrawInfo() != null &amp;&amp;</span>
<span class="nc bnc" id="L1059" title="All 2 branches missed.">		        (RequestAuditTrail.STATUS_WITHDRAW_REQUEST.equals(getWithdrawInfo().getRequestStatus()) ||</span>
<span class="nc bnc" id="L1060" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_WITHDRAW_REJECT.equals(getWithdrawInfo().getRequestStatus())) &amp;&amp;</span>
<span class="nc bnc" id="L1061" title="All 2 branches missed.">		        getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED);</span>
	}

	public boolean isEligibleForCancelWithdrawAction() {
<span class="nc bnc" id="L1065" title="All 2 branches missed.">		return getWithdrawInfo() != null &amp;&amp;</span>
<span class="nc bnc" id="L1066" title="All 2 branches missed.">		        (RequestAuditTrail.STATUS_WITHDRAW_REQUEST.equals(getWithdrawInfo().getRequestStatus()) ||</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_WITHDRAW_REJECT.equals(getWithdrawInfo().getRequestStatus())) &amp;&amp;</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">		        getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED);</span>
	}

	public boolean isEligibleForWithdraw() {
<span class="nc bnc" id="L1072" title="All 2 branches missed.">		return (RequestAuditTrail.STATUS_WAITLIST.equals(getRequestStatus()) ||</span>
<span class="nc bnc" id="L1073" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_PENDING.equals(getRequestStatus()) ||</span>
<span class="nc bnc" id="L1074" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_TENTATIVE.equals(getRequestStatus()) ||</span>
<span class="nc bnc" id="L1075" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_ESCALATED.equals(getRequestStatus()) ||</span>
<span class="nc bnc" id="L1076" title="All 2 branches missed.">		        RequestAuditTrail.STATUS_NEGOTIATION.equals(getRequestStatus())) ||</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">		        (getRequestStatus().equals(RequestAuditTrail.STATUS_APPROVED) &amp;&amp;</span>
<span class="nc bnc" id="L1078" title="All 4 branches missed.">		        (getWithdrawInfo() == null || getWithdrawInfo().getRequestStatus().equals(RequestAuditTrail.STATUS_WITHDRAW_CANCEL)));</span>
	}

	@Override
	protected Collection getSoftValidationStates() {
<span class="nc bnc" id="L1083" title="All 2 branches missed.">		if(isFlexTimeRequest()) {</span>
<span class="nc" id="L1084">			return RequestAuditTrail.FLEX_SOFT_VALIDATION_STATES;</span>
		}
		
<span class="nc" id="L1087">		return RequestAuditTrail.TO_SOFT_VALIDATION_STATES;</span>
	}

	@Override
	public boolean isHardValidationNeeded(int methodType) {
		try {
<span class="nc" id="L1093">			String reqStatus = getRequestStatus();</span>
<span class="nc bnc" id="L1094" title="All 2 branches missed.">			if (getHardValidationStatesToBeSkipped().contains(reqStatus)) {</span>
<span class="nc bnc" id="L1095" title="All 4 branches missed.">				if (!(reqStatus.equals(RequestAuditTrail.STATUS_DENIED) &amp;&amp; isWaitlistEnabled())) {</span>
<span class="nc" id="L1096">					return false;</span>
				}
			}
<span class="nc bnc" id="L1099" title="All 2 branches missed.">			if (methodType != RequestUtil.METHODTYPE_CREATOR &amp;&amp;</span>
<span class="nc bnc" id="L1100" title="All 4 branches missed.">			        getExpirationDate() != null &amp;&amp; hasExpired()) {</span>
<span class="nc" id="L1101">				return false;</span>
			}
<span class="nc" id="L1103">		} catch (Exception e) {</span>
<span class="nc" id="L1104">			this.logException(e);</span>
<span class="nc" id="L1105">		}</span>
<span class="nc" id="L1106">		return true;</span>
	}

	

	public boolean isWaitlistEnabled() {
		try {
<span class="nc bnc" id="L1113" title="All 2 branches missed.">			if (cachedWaitlistEnabled == null) {</span>
<span class="nc" id="L1114">				cachedWaitlistEnabled = new Boolean(TORequestUtil.isTOWaitlistEnabled(this));</span>
			}
<span class="nc" id="L1116">		} catch (Exception e) {</span>
<span class="nc" id="L1117">			this.logException(e);</span>
<span class="nc" id="L1118">		}</span>
<span class="nc bnc" id="L1119" title="All 4 branches missed.">		return cachedWaitlistEnabled != null &amp;&amp; cachedWaitlistEnabled.booleanValue();</span>
	}

	public int getTimeOffRule() {
<span class="nc bnc" id="L1123" title="All 2 branches missed.">		if (getTimeOffDebitType().equals(TORequest.DEBITTYPE_DEBIT)) {</span>
<span class="nc" id="L1124">			return TimeOffEvent.TIME_OFF_RULE_USE_MINSTOWARDSRULES;</span>
<span class="nc bnc" id="L1125" title="All 2 branches missed.">		} else if (getTimeOffDebitType().equals(TORequest.DEBITTYPE_DEBIT_ONLY_IF)) {</span>
<span class="nc" id="L1126">			return TimeOffEvent.TIME_OFF_RULE_USE_SHIFT;</span>
		} else {
<span class="nc" id="L1128">			return -1;</span>
		}
	}

	public int getPeriodFlag(TOChoice choice) {
		try {
<span class="nc" id="L1134">			ShiftAssignment lastShift = getCache().getLastPublishedShiftAssignment();</span>
<span class="nc bnc" id="L1135" title="All 2 branches missed.">			if (choice.getEndDate().before(lastShift.getEndTime())) {</span>
<span class="nc bnc" id="L1136" title="All 2 branches missed.">				if (choice.getIsInUnpublishedGap())//JT</span>
<span class="nc" id="L1137">					return DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_UNSCHED;</span>
				else {
<span class="nc" id="L1139">					return DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_SCHED;</span>
				}
<span class="nc bnc" id="L1141" title="All 2 branches missed.">			} else if (choice.getStartDate().after(lastShift.getEndTime())) {</span>
<span class="nc" id="L1142">				return DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_UNSCHED;</span>
			} else {
<span class="nc" id="L1144">				return DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_OVERLAP;</span>
			}
<span class="nc" id="L1146">		} catch (Exception e) {</span>
<span class="nc" id="L1147">			this.logException(e);</span>

		}
<span class="nc" id="L1150">		return DailyHoursBuckets.DAILYHOURSBUCKETS_PERIOD_INIT;</span>
	}

	public String getOrgName()throws Exception{ // NOSONAR
<span class="nc" id="L1154">		return getCache().getOrgNameForMsg();</span>
	}



	public List&lt;TOChoice&gt; getApprovedChoices() {

<span class="nc bnc" id="L1161" title="All 2 branches missed.">		if (approvedChoices != null) {</span>
<span class="nc" id="L1162">			return approvedChoices;</span>
		}

<span class="nc" id="L1165">		buildApprovedChoiceLists();</span>
<span class="nc" id="L1166">		return approvedChoices;</span>
	}

	public TOChoice getFirstApprovedChoice() {
<span class="nc" id="L1170">		List&lt;TOChoice&gt; choices = getApprovedChoices();</span>
<span class="nc bnc" id="L1171" title="All 4 branches missed.">		if (choices == null || choices.isEmpty()) {</span>
<span class="nc" id="L1172">			return null;</span>
		}
<span class="nc" id="L1174">		return choices.get(0);</span>
	}

	public Set&lt;ID&gt; getApprovedChoiceIDs() {
<span class="nc bnc" id="L1178" title="All 2 branches missed.">		if (approvedChoiceIDs != null) {</span>
<span class="nc" id="L1179">			return approvedChoiceIDs;</span>
		}

<span class="nc" id="L1182">		buildApprovedChoiceLists();</span>
<span class="nc" id="L1183">		return approvedChoiceIDs;</span>
	}

	private void buildApprovedChoiceLists() {
<span class="nc" id="L1187">		Collection&lt;TOChoice&gt; choiceList = getTOChoicesAdjustedForCalculatedVto();</span>
<span class="nc bnc" id="L1188" title="All 2 branches missed.">		if (choiceList.isEmpty()) {</span>
<span class="nc" id="L1189">			approvedChoices = Collections.emptyList();</span>
<span class="nc" id="L1190">			approvedChoiceIDs = Collections.emptySet();</span>
<span class="nc" id="L1191">			return;</span>
		}

<span class="nc" id="L1194">		approvedChoices = new ArrayList&lt;TOChoice&gt;(choiceList.size());</span>
<span class="nc" id="L1195">		approvedChoiceIDs = new HashSet&lt;ID&gt;(choiceList.size());</span>

<span class="nc bnc" id="L1197" title="All 2 branches missed.">		for (TOChoice choice : choiceList) {</span>
<span class="nc bnc" id="L1198" title="All 4 branches missed.">			if (choice != null &amp;&amp; choice.isApproved()) {</span>
<span class="nc" id="L1199">				approvedChoices.add(choice);</span>
<span class="nc" id="L1200">				approvedChoiceIDs.add(choice.getID());</span>
			}
<span class="nc" id="L1202">		}</span>
<span class="nc" id="L1203">	}</span>

	public void emptyApprovedChoices() {
<span class="nc bnc" id="L1206" title="All 2 branches missed.">		for (TOChoice choice : getApprovedChoices()) {</span>
<span class="nc" id="L1207">			choice.setIsApproved(false);</span>
<span class="nc" id="L1208">		}</span>
<span class="nc" id="L1209">		approvedChoices = Collections.emptyList();</span>
<span class="nc" id="L1210">		approvedChoiceIDs = Collections.emptySet();</span>
<span class="nc" id="L1211">	}</span>
	

	public TimeRange getApprovedChoiceDateRange() {

<span class="nc" id="L1216">		List&lt;TOChoice&gt; choices = getApprovedChoices();</span>
<span class="nc bnc" id="L1217" title="All 2 branches missed.">		if (choices.isEmpty()) {</span>
<span class="nc" id="L1218">			throw new IllegalStateException(&quot;There are no approved choices&quot;);</span>
		}

<span class="nc" id="L1221">		long min = Long.MAX_VALUE;</span>
<span class="nc" id="L1222">		long max = Long.MIN_VALUE;</span>
<span class="nc bnc" id="L1223" title="All 2 branches missed.">		for (TOChoice choice : choices) {</span>
<span class="nc" id="L1224">			min = Math.min(min, choice.getStartDate().getTime());</span>
<span class="nc" id="L1225">			max = Math.max(max, choice.getEndDate().getTime());</span>
<span class="nc" id="L1226">		}</span>
<span class="nc" id="L1227">		return new TimeRange(new Date(min), new Date(max));</span>
	}
	/**If a time off request submitted during an open time off bidding and the employee is added to that bid
	 * it become a time off bid request-it has timeOffBidInfo which is not null*/
	public Pair&lt;TimeOffBid, Pair&lt;Integer, Integer&gt;&gt; getTimeOffBidInfo() {
<span class="nc" id="L1232">		return timeOffBidInfo;</span>
	}

	public void setTimeOffBidInfo(Pair&lt;TimeOffBid, Pair&lt;Integer, Integer&gt;&gt; timeOffBidInfo) {
<span class="nc" id="L1236">		this.timeOffBidInfo = timeOffBidInfo;</span>
<span class="nc" id="L1237">	}</span>
	/** The choices thatpass all validators and will be approved-(when evaluating all valid muli choices ) */
	public List&lt;TOChoice&gt; getTOChoicesWillBeApproved() {
<span class="nc" id="L1240">			return willBeApprovedChoices;</span>
	}

	/** Set choices pass all validators and will be approved-(when evaluating all valid muli choices )*/
	public void addTOChoiceWillBeApproved(TOChoice aToChoice) {
<span class="nc" id="L1245">		willBeApprovedChoices.add(aToChoice);</span>
<span class="nc" id="L1246">	}</span>
	public void removeTOChoiceWillBeApproved(TOChoice aToChoice) {
<span class="nc" id="L1248">		willBeApprovedChoices.remove(aToChoice);</span>
<span class="nc" id="L1249">	}</span>
	
	public void setTOChoiceWillBeApproved(Collection&lt;TOChoice&gt; aToChoices) {
<span class="nc" id="L1252">		willBeApprovedChoices=new ArrayList&lt;TOChoice&gt;(aToChoices);</span>
<span class="nc" id="L1253">	}</span>
	public void clearTOChoiceWillBeApproved() {
<span class="nc" id="L1255">		toChoiceForValidation.clear();</span>
<span class="nc" id="L1256">	}</span>

	public TimeRange getChoiceRange() {

<span class="nc" id="L1260">		Date start = new Date(Long.MAX_VALUE);</span>
<span class="nc" id="L1261">		Date end = new Date(0L);</span>

<span class="nc bnc" id="L1263" title="All 2 branches missed.">		if (isAdvancedVTORequest()) {</span>
<span class="nc" id="L1264">			start = getAdvancedVTODate();</span>
			//end time is the worst case to cover a shift that starts at the end of the VTO date
<span class="nc" id="L1266">			end = new Date(start.getTime() + TimeUnit.DAYS.toMillis(2));</span>
<span class="nc" id="L1267">			return new TimeRange(start, end);</span>
		}

<span class="nc bnc" id="L1270" title="All 2 branches missed.">		for (TOChoice c : getRequestChoiceList()) {</span>

<span class="nc bnc" id="L1272" title="All 2 branches missed.">			if (c.getStartDate().before(start)) {</span>
<span class="nc" id="L1273">				start = c.getStartDate();</span>
			}

<span class="nc bnc" id="L1276" title="All 2 branches missed.">			if (c.getEndDate().after(end)) {</span>
<span class="nc" id="L1277">				end = c.getEndDate();</span>
			}
<span class="nc" id="L1279">		}</span>

<span class="nc bnc" id="L1281" title="All 4 branches missed.">		if ((start.getTime() == Long.MAX_VALUE) || (end.getTime() == 0)) {</span>
<span class="nc" id="L1282">			throw new IllegalStateException(&quot;No valid choices found&quot;);</span>
		}

<span class="nc" id="L1285">		return new TimeRange(start, end);</span>

	}

	//This is used for run TOB Group approval
	public boolean isRunForGroupTOBApproval() {
<span class="nc" id="L1291">		return isRunForGroupTOBApproval;</span>
	}


	public void setRunForGroupTOBApproval(boolean isRunForGroupApproval) {
<span class="nc" id="L1296">		this.isRunForGroupTOBApproval = isRunForGroupApproval;</span>
<span class="nc" id="L1297">	}</span>




}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>