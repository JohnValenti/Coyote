<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeSeriesDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.ejb</a> &gt; <span class="el_source">TimeSeriesDAO.java</span></div><h1>TimeSeriesDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.ejb;

import java.sql.Timestamp;
import java.sql.Types;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;
import java.util.TreeSet;
import java.util.concurrent.TimeUnit;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignDAO;
import com.bluepumpkin.ejb.bbm.campaign.ejb.SchedulingPeriodDAO;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.SPQueue;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.timeseries.model.ActualTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ForecastTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.PredictTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.RequireTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.ServiceGoalTraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceChunk;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.timeseries.util.DSTConversionUtil;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperatorAdapter;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.model.CombinedQueueStaffing;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.bbm.workload.model.QueueFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceInner;

/**
 * Title:        TimeSeriesDAO.java
 * Description:  DAO of TimeSeries
 * Copyright:    Copyright (c) 2002 - 2016
 * Company:      Verint Systems, Inc.
 *
 * TimeSeriesDAO is not to be accessed by other objects directly. It has full
 * knowledge of how to persist Traces for BPDE schema. Use default package level
 * restriction.
 */
<span class="nc" id="L72">class TimeSeriesDAO {</span>
<span class="nc" id="L73">	private static final Integer NAVALUE = NumberFactory.newInteger(-2);</span>
	private static final String ACTUALTRACETABLENAME = &quot;QUEUEHISTORYTIMESERIES&quot;;
	private static final String FORECASTTRACETABLENAME = &quot;FORECASTTIMESERIES&quot;;
	private static final String PREDICTTRACETABLENAME = &quot;PREDICTEDTIMESERIES&quot;;
	private static final String REQUIRETRACETABLENAME = &quot;REQUIREDTIMESERIES&quot;;
	private static final String SERVICEGOALTRACETABLENAME = &quot;SPQUEUEGOALSERIES&quot;;
	private static final String PREDICTNOPHANTOMTRACETABLENAME = &quot;PREDICTEDNOPHANTOMTIMESERIES&quot;;

	private static final String REPORTTABLENAME = &quot;#TRACEREPORT&quot;;
	private static final String REPORTTABLENAMEDELETE = &quot;TRACEREPORT&quot;;
<span class="nc" id="L83">	private static final String[] FIELDNAMES = new String[] {&quot;QUEUEID&quot;, &quot;CAMPAIGNID&quot;, &quot;MEDIAID&quot;, &quot;STARTTIME&quot;, &quot;ACV&quot;,</span>
			&quot;AAHT&quot;, &quot;APCA&quot;, &quot;AASA&quot;, &quot;AABANDONMENT&quot;, &quot;ABACKLOG&quot;, &quot;ASTAFFING&quot;, &quot;AOCCUPANCY&quot;, &quot;AFTE&quot;, &quot;ADIALS&quot;, &quot;ACONNECTS&quot;,
			&quot;ACRATE&quot;, &quot;ARPC&quot;, &quot;ARPCRATE&quot;, &quot;ARPCAHT&quot;, &quot;AVH&quot;, &quot;AVAR&quot;, &quot;FCV&quot;, &quot;FAHT&quot;, &quot;FCRATE&quot;, &quot;FRPCAHT&quot;, &quot;FRPCRATE&quot;, &quot;FPCA&quot;,
			&quot;FASA&quot;, &quot;FABANDONMENT&quot;, &quot;FBACKLOG&quot;, &quot;FSTAFFING&quot;, &quot;FOCCUPANCY&quot;, &quot;FFTE&quot;, &quot;FDIALS&quot;, &quot;FCONNECTS&quot;, &quot;FRPC&quot;, &quot;RFTE&quot;,
			&quot;RPCA&quot;, &quot;RASA&quot;, &quot;RABANDONMENT&quot;};
<span class="nc" id="L88">	private static final int[] FIELDTYPES = new int[]{Types.INTEGER, Types.INTEGER, Types.INTEGER,</span>
			Types.TIMESTAMP, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER, Types.INTEGER,
			Types.INTEGER, Types.INTEGER};
	private static final String TIMESERIESAUDITTABLENAME = &quot;TRACETRACK&quot;;
<span class="nc" id="L96">	private static final Category LOG = Log.initCategory(TimeSeriesDAO.class.getName());</span>
<span class="nc" id="L97">	private static boolean m_ignoreFutureData = false;</span>

	public static void setIgnoreFutureData(boolean ignore) {
<span class="nc" id="L100">		m_ignoreFutureData = ignore;</span>
<span class="nc" id="L101">	}</span>

	/**
	 * Create/Update actual trace
	 *
	 * @param traceType
	 * @param queIDCol
	 * @param value
	 * @param start
	 * @throws JdmoException
	 */
	public static void createActualTimeSeries(short traceType, Collection&lt;? extends ID&gt; queIDCol, int value, Date posTime)
			throws JdmoException {
<span class="nc" id="L114">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L116">			Set extQueSet = existingRows(queIDCol, posTime, jdmo);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">			for (ID qID : queIDCol) {</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">				if (extQueSet.contains(qID)) {</span>
<span class="nc" id="L119">					updateActualCube(qID, traceType, value, posTime, jdmo);</span>
				} else {
<span class="nc" id="L121">					createActualCube(qID, traceType, value, posTime, jdmo);</span>
				}
<span class="nc" id="L123">			}</span>
<span class="nc" id="L124">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L126">			jdmo.cleanUp();</span>
<span class="nc" id="L127">		}</span>
<span class="nc" id="L128">	}</span>

	/**
	 * To create a chunk of TimeSeries in Actual Trace table If the offSet is 1,
	 * which implies it is a new Trace, try create first Else try update if
	 * update failed, then retry with create, exit. if create failed with
	 * duplicatekey, then retry update, exit.
	 *
	 * @param TraceChunk
	 */
	public static void createTimeSeriesInChunk(TraceChunk chunk) throws JdmoException {
<span class="nc" id="L139">		Jdmo jdmo = new Jdmo();</span>
		try {
			try {
<span class="nc" id="L142">				createChunkForActual(chunk, jdmo);</span>
<span class="nc" id="L143">				jdmo.executeBatch();</span>
<span class="nc" id="L144">			} catch (JdmoException ex) {</span>
<span class="nc" id="L145">				updateTimeSeriesInChunk(chunk, ex);</span>
<span class="nc" id="L146">			}</span>

		} finally {
<span class="nc" id="L149">			jdmo.cleanUp();</span>
<span class="nc" id="L150">		}</span>
<span class="nc" id="L151">	}</span>

	private static void updateTimeSeriesInChunk(TraceChunk chunk, JdmoException ex) throws JdmoException {
<span class="nc" id="L154">		Jdmo updateDmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L156" title="All 2 branches missed.">			if (existingRow(chunk.getQueueID(), chunk.getStartDate(), updateDmo)) {</span>
<span class="nc" id="L157">				updateChunkForActual(chunk, updateDmo);</span>
<span class="nc" id="L158">				updateDmo.executeBatch();</span>
			} else {
<span class="nc" id="L160">				throw ex;</span>
			}
		} finally {
<span class="nc" id="L163">			updateDmo.cleanUp();</span>
<span class="nc" id="L164">		}</span>
<span class="nc" id="L165">	}</span>

	/**
	 * To create a chunk of TimeSeries in Actual Trace table If the offSet is 1,
	 * which implies it is a new Trace, try create first Else try update if
	 * update failed, then retry with create, exit. if create failed with
	 * duplicatekey, then retry update, exit.
	 *
	 * @param TraceChunk
	 */
	public static void createTimeSeriesInCube(TraceCube cube) throws JdmoException {
<span class="nc" id="L176">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L178">			Set extSet = existingActualRows(cube.getQueueID(), cube.getRawStartDate(), cube.getRawEndDate(), jdmo);</span>
<span class="nc" id="L179">			Date posTime = TraceUtil.snapDate(cube.getRawStartDate());</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">			while (!posTime.after(cube.getRawEndDate())) {</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">				if (extSet.contains(posTime)) {</span>
<span class="nc" id="L182">					updateCube(cube, posTime, jdmo);</span>
				} else {
<span class="nc" id="L184">					createCube(cube, posTime, jdmo);</span>
				}
<span class="nc" id="L186">				posTime.setTime(posTime.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
<span class="nc" id="L188">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L190">			jdmo.cleanUp();</span>
<span class="nc" id="L191">		}</span>
<span class="nc" id="L192">	}</span>

	/**
	 * @param qID
	 * @param traceType
	 * @param value
	 * @param posTime
	 * @param jdmo
	 * @throws JdmoException
	 */
	private static void createActualCube(ID qID, short traceType, int value, Date posTime, Jdmo jdmo) throws JdmoException {
		// Select Query for Queueid
<span class="nc" id="L204">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">		if (!cube.isTraceTypeComputed(traceType)) {</span>
<span class="nc" id="L206">			StringBuilder vStmt = new StringBuilder(200);</span>
<span class="nc" id="L207">			vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L208">			vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(posTime)).append(&quot;',&quot;);</span>
<span class="nc" id="L209">			vStmt.append(value).append(&quot;,&quot;);</span>
<span class="nc" id="L210">			vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L211">			vStmt.append(&quot;' from QUEUE where SID=&quot;).append(qID);</span>
			// Insert Query
<span class="nc" id="L213">			StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L214">			iStmt.append(&quot;insert into &quot;).append(ACTUALTRACETABLENAME);</span>
<span class="nc" id="L215">			iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L216">			iStmt.append(getDETraceColumn(traceType)).append(&quot;, &quot;);</span>
<span class="nc" id="L217">			iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L218">			iStmt.append(vStmt);</span>
<span class="nc" id="L219">			jdmo.addBatch(iStmt.toString());</span>
		}
<span class="nc" id="L221">	}</span>

	/**
	 * @param qID
	 * @param traceType
	 * @param value
	 * @param posTime
	 * @param jdmo
	 * @throws JdmoException
	 */
	private static void updateActualCube(ID qID, short traceType, int value, Date posTime, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L232">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (!cube.isTraceTypeComputed(traceType)) {</span>
<span class="nc" id="L234">			StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L235">			iStmt.append(&quot;update &quot;).append(ACTUALTRACETABLENAME).append(&quot; set &quot;);</span>
<span class="nc" id="L236">			iStmt.append(getDETraceColumn(traceType)).append(&quot;=&quot;);</span>
<span class="nc" id="L237">			iStmt.append(value).append(&quot;, &quot;);</span>
<span class="nc" id="L238">			iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L239">			iStmt.append(&quot;' where TIME='&quot;).append(JdmoUtil.formatDBString(posTime));</span>
<span class="nc" id="L240">			iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(qID).append(&quot;)&quot;);</span>
<span class="nc" id="L241">			jdmo.addBatch(iStmt.toString());</span>
		}
<span class="nc" id="L243">	}</span>

	/**
	 * Gets volume/AHT from queuehistorytimeseries table that has valid data  within the data range
	 * i.e (volume/AHT &gt; 0 and wolume/AHT not null)
	 *
	 * @param queueID
	 * @param startDate
	 * @param endDate
	 * @return TraceCube
	 * @throws JdmoException, BbmTimeSeriesException
	 */
	public static ActualTraceCube getActualTraceCube(ID queueID, Date startDate, Date endDate)
			throws JdmoException, BbmTimeSeriesException {
<span class="nc" id="L257">		short[] types = {Trace.CV, Trace.AHT};</span>
<span class="nc" id="L258">		ActualTraceCube actualTC = new ActualTraceCube(queueID, startDate, endDate, types);</span>
<span class="nc" id="L259">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L261">			String sqlString = getSqlQueryToGetActualTimeSeriesData(queueID, startDate, endDate);</span>
<span class="nc" id="L262">			JdmoQuery jQuery = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L263">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L264">			ArrayList&lt;Double&gt; cv = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L265">			ArrayList&lt;Double&gt; aht = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L267">				cv.add(rs.getDouble(&quot;CALLVOLUME&quot;));</span>
<span class="nc" id="L268">				aht.add(rs.getDouble(&quot;AHT&quot;));</span>
			}
<span class="nc" id="L270">			rs.close();</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">			if (!cv.isEmpty()) {</span>
<span class="nc" id="L272">				double[] cvArray = new double[cv.size()];</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">				for (int i = 0; i &lt; cv.size(); i++) {</span>
<span class="nc" id="L274">					cvArray[i] = cv.get(i);</span>
				}
<span class="nc" id="L276">				actualTC.setTraceValue(Trace.CV, cvArray);</span>
			}
<span class="nc bnc" id="L278" title="All 2 branches missed.">			if (!aht.isEmpty()) {</span>
<span class="nc" id="L279">				double[] ahtArray = new double[aht.size()];</span>
<span class="nc bnc" id="L280" title="All 2 branches missed.">				for (int i = 0; i &lt; aht.size(); i++) {</span>
<span class="nc" id="L281">					ahtArray[i] = aht.get(i);</span>
				}
<span class="nc" id="L283">				actualTC.setTraceValue(Trace.AHT, ahtArray);</span>
			}
<span class="nc" id="L285">			return actualTC;</span>
		} finally {
<span class="nc" id="L287">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param cube
	 * @param posTime
	 * @param jdmo
	 */
	private static void createCube(TraceCube cube, Date posTime, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L297">		StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L298">		iStmt.append(&quot;insert into &quot;).append(ACTUALTRACETABLENAME);</span>
<span class="nc" id="L299">		iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L300">		StringBuilder vStmt = new StringBuilder(200);</span>
<span class="nc" id="L301">		vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L302">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(posTime)).append(&quot;',&quot;);</span>
<span class="nc" id="L303">		short[] types = cube.getTraceTypes();</span>
<span class="nc bnc" id="L304" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L305" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L306">				iStmt.append(getDETraceColumn(types[i])).append(&quot;, &quot;);</span>
<span class="nc" id="L307">				vStmt.append(cube.getTraceValue(types[i], posTime)).append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L310">		iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L311">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L312">		vStmt.append(&quot;' from QUEUE where SID=&quot;).append(cube.getQueueID());</span>
<span class="nc" id="L313">		iStmt.append(vStmt);</span>
<span class="nc" id="L314">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L315">	}</span>

	/**
	 * @param cube
	 * @param posTime
	 * @param jdmo
	 */
	private static void updateCube(TraceCube cube, Date posTime, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L323">		StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L324">		iStmt.append(&quot;update &quot;).append(ACTUALTRACETABLENAME).append(&quot; set &quot;);</span>
<span class="nc" id="L325">		short[] types = cube.getTraceTypes();</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L328">				iStmt.append(getDETraceColumn(types[i])).append(&quot;=&quot;);</span>
<span class="nc" id="L329">				iStmt.append(cube.getTraceValue(types[i], posTime)).append(&quot;, &quot;);</span>
			}
		}
<span class="nc" id="L332">		iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L333">		iStmt.append(&quot;' where TIME='&quot;).append(JdmoUtil.formatDBString(posTime));</span>
<span class="nc" id="L334">		iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(cube.getQueueID()).append(&quot;)&quot;);</span>
<span class="nc" id="L335">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L336">	}</span>

	private static void createTempReportDumpTable(Jdmo jdmo) throws JdmoException {
		//create temp table to hold TRACEREPORT data
<span class="nc" id="L340">		StringBuilder strSQL = new StringBuilder();</span>
<span class="nc" id="L341">		String strNativeTempName = REPORTTABLENAME;</span>

		try {
			// drop temp table just in case
<span class="nc" id="L345">			jdmo.dropTempTable(REPORTTABLENAMEDELETE);</span>
<span class="nc" id="L346">		} catch (JdmoException e) {</span>
<span class="nc" id="L347">			LOG.error(&quot;Exception in dropTempTable() when dropping temp table:&quot; + strNativeTempName + &quot;Message:&quot; + e.getMessage());</span>
<span class="nc" id="L348">		}</span>

<span class="nc" id="L350">		strSQL.append(strNativeTempName);</span>
<span class="nc" id="L351">		strSQL.append(&quot; (QUEUEID int,STARTTIME datetime,CAMPAIGNID int,MEDIAID int,ACV int,AAHT int,APCA int,AASA int, &quot;)</span>
<span class="nc" id="L352">			.append(&quot;AABANDONMENT int,ABACKLOG int, ASTAFFING int, AOCCUPANCY int,FCV int,FAHT int,FPCA int,FASA int, &quot;)</span>
<span class="nc" id="L353">			.append(&quot;FABANDONMENT int, FBACKLOG int, FSTAFFING int, FOCCUPANCY int, RFTE int, RPCA int, RASA int, &quot;)</span>
<span class="nc" id="L354">			.append(&quot;RABANDONMENT int, AFTE int,FFTE int,ADIALS int,ACONNECTS int,ACRATE int,ARPC int, ARPCRATE int,ARPCAHT int, &quot;)</span>
<span class="nc" id="L355">			.append(&quot;FDIALS int,FCONNECTS int,FCRATE int,FRPC int,FRPCRATE int,FRPCAHT int,AVH int,AVAR int,ISUPDATE INT)&quot;);</span>

		try {
<span class="nc" id="L358">			jdmo.createTempTable(strSQL.toString());</span>
<span class="nc" id="L359">		} catch (JdmoException e) {</span>
<span class="nc" id="L360">			LOG.error(&quot;Exception in createTempReportDumpTable() when dropping temp table:&quot; + strNativeTempName + &quot;Message:&quot; + </span>
<span class="nc" id="L361">					e.getMessage());</span>
<span class="nc" id="L362">		}</span>
<span class="nc" id="L363">	}</span>

	/**
	 * Update Report table based on meta TraceCube information for a queue TraceChunk Array is 5 elements array, 0 is actual,
	 * 1 is forecast, 2 is predict, 3 is require, 4 is servicegoal.
	 */
	public static void dumpTimeSeriesFromLastUpdate(ID queueID, ID campaignID, ID mediaID, Map&lt;Date, TraceChunk[]&gt; chunkMap,
			Map&lt;Date, CombinedQueueStaffing&gt; cmbStfMap, Date start, Date end, Set&lt;Date&gt; removeTimeSet) throws JdmoException {
<span class="nc" id="L371">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L373">			TimeSeriesDAO.createTempReportDumpTable(jdmo);</span>
<span class="nc" id="L374">			Map&lt;Date, ID&gt; existingPoints = new HashMap&lt;&gt;();</span>
<span class="nc" id="L375">			ArrayList&lt;Object[]&gt; paramValCol = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">			LOG.info(&quot;dumpTimeSeriesFromLastUpdate Number of Records&quot; + (chunkMap != null ? chunkMap.size() : 0) + &quot; QueueID :&quot;  + queueID +</span>
					&quot; CampaignID :&quot; + campaignID + &quot; Start:&quot; + start + &quot; End:&quot; + end + &quot; MediaID&quot; + mediaID);
<span class="nc bnc" id="L378" title="All 2 branches missed.">			if (chunkMap != null) {</span>
<span class="nc bnc" id="L379" title="All 2 branches missed.">				for (Date startDate : chunkMap.keySet()) {</span>
<span class="nc" id="L380">					TraceChunk[] chunkArray = chunkMap.get(startDate);</span>
<span class="nc" id="L381">					CombinedQueueStaffing cmbStf = cmbStfMap.remove(startDate);</span>
<span class="nc" id="L382">					paramValCol.add(createDump(chunkArray, cmbStf, queueID, campaignID, mediaID, startDate));</span>
<span class="nc" id="L383">				}</span>
			}
			// update remaining Combined Staffing
<span class="nc bnc" id="L386" title="All 2 branches missed.">			for (Date startDate : cmbStfMap.keySet()) {</span>
<span class="nc" id="L387">				CombinedQueueStaffing cmbStf = cmbStfMap.get(startDate);</span>
<span class="nc" id="L388">				paramValCol.add(createDump(null, cmbStf, queueID, campaignID, mediaID, startDate));</span>
<span class="nc" id="L389">			}</span>
			// now remove time
<span class="nc" id="L391">			Set&lt;ID&gt; removeIDSet = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L392" title="All 4 branches missed.">			if (removeTimeSet != null &amp;&amp; !removeTimeSet.isEmpty()) {</span>
<span class="nc" id="L393">				LOG.info(&quot;Inside removeTimeSet is not Empty&quot; + removeTimeSet.size());</span>
<span class="nc" id="L394">				existingPoints = existingRows(queueID, campaignID, mediaID, start, end, jdmo);</span>
<span class="nc bnc" id="L395" title="All 2 branches missed.">				for (Iterator&lt;Date&gt; it = removeTimeSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L396">					ID id = existingPoints.get(it.next());</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">					if (id != null) {</span>
<span class="nc" id="L398">						removeIDSet.add(id);</span>
					}
<span class="nc" id="L400">				}</span>
			}
<span class="nc bnc" id="L402" title="All 2 branches missed.">			if (!removeIDSet.isEmpty()) {</span>
<span class="nc" id="L403">				StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L404">				sb.append(&quot;delete from &quot;).append(REPORTTABLENAMEDELETE).append(&quot; where ID in&quot;).append(jdmo.createInClause(removeIDSet));</span>
<span class="nc" id="L405">				jdmo.addBatch(sb.toString());</span>
			}
<span class="nc" id="L407">			jdmo.executeBatch();</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">			if (!paramValCol.isEmpty()) {</span>
<span class="nc" id="L409">				jdmo.insertBatchAndExecute(REPORTTABLENAME, FIELDNAMES, FIELDTYPES, paramValCol);</span>
			}
<span class="nc" id="L411">			TimeSeriesDAO.moveDataFromTempTableToMainTable(jdmo);</span>
		} finally {
<span class="nc" id="L413">			jdmo.cleanUp();</span>
<span class="nc" id="L414">		}</span>
<span class="nc" id="L415">	}</span>

	private static void moveDataFromTempTableToMainTable(Jdmo jdmo) throws JdmoException{
		try{
<span class="nc" id="L419">			String pStmt = &quot;BP_TIMESERIES_DUMP&quot;;</span>
<span class="nc" id="L420">			JdmoQuery jQuery = jdmo.createQuery(pStmt, Jdmo.STORPROC_QUERY_NORS);</span>
<span class="nc" id="L421">			int debugLevel = 0;</span>
<span class="nc" id="L422">			jQuery.setParInt(1, debugLevel);</span>
<span class="nc" id="L423">			jQuery.setParString(2,REPORTTABLENAME);</span>
<span class="nc" id="L424">			jdmo.execute(jQuery);</span>
<span class="nc" id="L425">		} catch (JdmoException e) {</span>
<span class="nc" id="L426">			LOG.error(&quot;Exception in moveDataFromTempTableToMainTable method:&quot; + e.getMessage());</span>
<span class="nc" id="L427">			throw e;</span>
<span class="nc" id="L428">		}</span>
<span class="nc" id="L429">	}</span>

	/**
	 *  @deprecated No longer relevant data is refreshed into the main table using inserts into #TRACEREPORT(temp table). 
	 */
	@Deprecated
	private static void updateCmbStaffingDump(CombinedQueueStaffing cmbStf, ID queueID, ID campaignID, ID mediaID, Date startDate,
			Jdmo jdmo) throws JdmoException {
<span class="nc" id="L437">		StringBuilder pStmt = new StringBuilder(&quot;update &quot;).append(REPORTTABLENAME).append(&quot; set &quot;);</span>
		// if combined queue and no actual, need fix the Actual Occupancy
<span class="nc" id="L439">		pStmt.append(&quot;ASTAFFING=&quot;).append(TraceUtil.roundDouble(cmbStf.getStaffing()));</span>
<span class="nc" id="L440">		pStmt.append(&quot; where QUEUEID=&quot;).append(JdmoUtil.asSqlLiteral(queueID))</span>
<span class="nc" id="L441">				.append(&quot; and CAMPAIGNID=&quot;).append(JdmoUtil.asSqlLiteral(campaignID))</span>
<span class="nc" id="L442">				.append(&quot; and MEDIAID=&quot;).append(JdmoUtil.asSqlLiteral(mediaID))</span>
<span class="nc" id="L443">				.append(&quot; and STARTTIME=&quot;).append(JdmoUtil.asSqlLiteral(startDate));</span>
<span class="nc" id="L444">		jdmo.addBatch(pStmt.toString());</span>
<span class="nc" id="L445">	}</span>

	// internal function to return each row's parameter values according to the column name sequence
	private static Object[] createDump(TraceChunk[] chunkArray, CombinedQueueStaffing cmbStf, ID queueID, ID campaignID,
			ID mediaID, Date startDate) {
		// Trace 22 types + 4ids + 1 time
<span class="nc" id="L451">		Object[] paramArray = new Object[FIELDNAMES.length];</span>
		// Initialize them to 0 value, coz JDMO doesn't support null object yet
<span class="nc" id="L453">		Arrays.fill(paramArray, NumberFactory.newInteger(0));</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">		paramArray[0] = queueID == null ? new ID(-1) : queueID;</span>
<span class="nc bnc" id="L455" title="All 2 branches missed.">		paramArray[1] = campaignID == null ? new ID(-1) : campaignID;</span>
<span class="nc bnc" id="L456" title="All 2 branches missed.">		paramArray[2] = mediaID == null ? new ID(-10) : mediaID;</span>
<span class="nc" id="L457">		paramArray[3] = TimeZoneUtil.toTimestamp(startDate);</span>
		// Done because the Report dump was not updated for the combined queues and normal queues
		// FIX: Commenting this whole part as it applies only to the Combined queues and is taken care in the If block below
<span class="nc" id="L460">		addToArray(chunkArray, paramArray, 4);</span>
<span class="nc bnc" id="L461" title="All 2 branches missed.">		if (campaignID != null) {</span>
			// for any combined queue, Actual Staffing is available in cmbStf and Actual Occupancy is never available for combined queues
<span class="nc bnc" id="L463" title="All 2 branches missed.">			paramArray[4 + Trace.STAFFING] = cmbStf != null ?</span>
<span class="nc" id="L464">					NumberFactory.newInteger(TraceUtil.roundDouble(cmbStf.getStaffing())) : NAVALUE;</span>
<span class="nc" id="L465">			paramArray[4 + Trace.OCCUPANCY] = NAVALUE;</span>
		}
		/* end of Fix Sameet 9/23/2005 */
<span class="nc" id="L468">		return paramArray;</span>
	}

	private static short[] getMetaTypes(int i) {
<span class="nc bnc" id="L472" title="All 6 branches missed.">		switch (i) {</span>
			case 0:
				// TODO not support FTE
<span class="nc" id="L475">				return TraceUtil.META_REPORT_ACTUAL.getTraceTypes();</span>
			case 1:
<span class="nc" id="L477">				return TraceUtil.META_FORECAST.getTraceTypes();</span>
			case 2:
<span class="nc" id="L479">				return TraceUtil.META_REPORT_PREDICT.getTraceTypes();</span>
			case 3:
<span class="nc" id="L481">				return TraceUtil.META_REQUIRE.getTraceTypes();</span>
			case 4:
<span class="nc" id="L483">				return TraceUtil.META_REPORT_SERVICEGOAL.getTraceTypes();</span>
			default:
<span class="nc" id="L485">				return null;</span>
		}
	}

	/**
	 * This method appears to set the values of the paramArray object array based on the values of
	 * the chunkArray.  Each index of paramArray represents a column value of a row on the TRACEREPORT table.
	 * @param chunkArray - An array of TraceChunks representing the time series data to be stored in the TRACEREPORT table.
	 * @param paramArray - Contains an index for every item in FieldNames, representing one parameter
	 *                   for every column of the TraceReport table.  Note: this array is modified by this method.
	 * @param pointer - Index into the paramArray indicating where to set the value in paramArray.
	 */
	private static void addToArray(TraceChunk[] chunkArray, Object[] paramArray, int pointer) {

<span class="nc" id="L499">		JdmoParam nullParam = new JdmoParam(null, Types.INTEGER);</span>

<span class="nc bnc" id="L501" title="All 4 branches missed.">		for (int i = 0; chunkArray != null &amp;&amp; i &lt; chunkArray.length; i++) {</span>
<span class="nc" id="L502">			TraceChunk chunk = chunkArray[i];</span>
<span class="nc" id="L503">			short[] types = getMetaTypes(i);</span>

<span class="nc bnc" id="L505" title="All 2 branches missed.">			for (int j = 0; j &lt; types.length; j++) {</span>
				int traceVal;
<span class="nc bnc" id="L507" title="All 2 branches missed.">				if (chunk != null) {</span>
<span class="nc" id="L508">					traceVal = TraceUtil.roundDouble(chunk.getTraceValue(types[j]));</span>
<span class="nc" id="L509">					paramArray[j + pointer] = NumberFactory.newInteger(traceVal);</span>
				} else {
<span class="nc" id="L511">					paramArray[j + pointer] = nullParam;</span>
				}
			}
<span class="nc" id="L514">			pointer += types.length;</span>
		}
<span class="nc" id="L516">	}</span>

	/**
	 * Return the earliest date for all queues in ActualTrace table
	 */
	public static Date getEarliestDate() throws JdmoException {
<span class="nc" id="L522">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L524">			StringBuilder pStmt = new StringBuilder(100);</span>
<span class="nc" id="L525">			pStmt.append(&quot;select min(TIME) from &quot;).append(ACTUALTRACETABLENAME);</span>
<span class="nc" id="L526">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L527">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L528">			Date earliestDate = null;</span>
<span class="nc bnc" id="L529" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L530">				earliestDate = TimeZoneUtil.toDate(rs.getTimestamp(1));</span>
			}
<span class="nc" id="L532">			rs.close();</span>
<span class="nc bnc" id="L533" title="All 2 branches missed.">			if (earliestDate == null) {</span>
<span class="nc" id="L534">				pStmt = new StringBuilder(100);</span>
<span class="nc" id="L535">				pStmt.append(&quot;select min(DATETIME) from &quot;).append(FORECASTTRACETABLENAME);</span>
<span class="nc bnc" id="L536" title="All 2 branches missed.">				if (m_ignoreFutureData) {</span>
<span class="nc" id="L537">					pStmt.append(&quot; where TIME&lt;=?&quot;);</span>
				}
<span class="nc" id="L539">				jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">				if (m_ignoreFutureData) {</span>
<span class="nc" id="L541">					jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(new Date()));</span>
				}
<span class="nc" id="L543">				rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">				if (rs.next()) {</span>
<span class="nc" id="L545">					earliestDate = TimeZoneUtil.toDate(rs.getTimestamp(1));</span>
				}
			}
<span class="nc" id="L548">			return earliestDate;</span>
		} finally {
<span class="nc" id="L550">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Check if there is point already dumped
	 *
	 * @param queueID
	 * @param start
	 * @param end
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static Map&lt;Date, ID&gt; existingRows(ID queueID, ID campaignID, ID mediaID, Date start, Date end, Jdmo jdmo)
			throws JdmoException {
<span class="nc" id="L566">		Map&lt;Date, ID&gt; points = new HashMap&lt;&gt;();</span>
<span class="nc" id="L567">		StringBuilder pStmt = new StringBuilder(&quot;select ID, STARTTIME from &quot;);</span>
<span class="nc" id="L568">		pStmt.append(REPORTTABLENAMEDELETE).append(&quot; where&quot;);</span>
<span class="nc" id="L569">		int pos = 1;</span>
<span class="nc bnc" id="L570" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L571">			pStmt.append(&quot; STARTTIME&gt;=? and&quot;);</span>
<span class="nc" id="L572">			pos++;</span>
		}
<span class="nc bnc" id="L574" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L575">			pStmt.append(&quot; STARTTIME&lt;=? and&quot;);</span>
<span class="nc" id="L576">			pos++;</span>
		}
<span class="nc bnc" id="L578" title="All 2 branches missed.">		if (queueID != null) {</span>
<span class="nc" id="L579">			pStmt.append(&quot; QUEUEID=?&quot;);</span>
		} else {
<span class="nc" id="L581">			pStmt.append(&quot; CAMPAIGNID=?&quot;);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L583">				pStmt.append(&quot; and MEDIAID=?&quot;);</span>
<span class="nc" id="L584">				pos++;</span>
			} else {
<span class="nc" id="L586">				pStmt.append(&quot; and MEDIAID=-10&quot;);</span>
			}
		}
<span class="nc" id="L589">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">		if (queueID != null) {</span>
<span class="nc" id="L591">			jQuery.setParID(pos, queueID);</span>
		} else {
<span class="nc bnc" id="L593" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L594">				jQuery.setParID(pos--, mediaID);</span>
			}
<span class="nc" id="L596">			jQuery.setParID(pos, campaignID);</span>
		}
<span class="nc bnc" id="L598" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L599">			jQuery.setParTimestamp(pos - 2, TimeZoneUtil.toTimestamp(start));</span>
		}
<span class="nc bnc" id="L601" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L602">			jQuery.setParTimestamp(pos - 1, TimeZoneUtil.toTimestamp(end));</span>
		}
<span class="nc" id="L604">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L605" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L606">			points.put(TimeZoneUtil.toDate(rs.getTimestamp(2)), rs.getID(1));</span>
		}
<span class="nc" id="L608">		return points;</span>
	}

	/**
	 * Get combined result for multiple queues
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param includeAllServiceGoalTypes
	 * @return
	 * @throws Exception
	 */
	public static Collection getCombinedQueueTimeSeriesCubesFromLastUpdate(TraceCube metaTC, HashMap spQMap,
			HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
			Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
		// get all queues associated with changed SPIDs
<span class="nc" id="L630">		HashSet qIDSet = new HashSet();</span>
<span class="nc bnc" id="L631" title="All 2 branches missed.">		for (Iterator it = spQMap.keySet().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L632">			qIDSet.addAll((Collection) spQMap.get(it.next()));</span>
		}
<span class="nc" id="L634">		return getCombinedQueueTimeSeriesCubesFromLastUpdate(metaTC, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate,</span>
				includeAllServiceGoalTypes, spqueuesBySID);
	}

	/**
	 * Get combined result for multiple queues
	 *
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param includeAllServiceGoalTypes
	 * @return
	 * @throws Exception
	 */
	public static Collection getCombinedQueueTimeSeriesCubesFromLastUpdate(TraceCube metaTC, Set qIDSet, Map spQMap,
			Map spTimeRangeMap, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
			Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="nc" id="L656">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L658">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="nc" id="L659">			return convert(rs, metaTC, spQMap, spTimeRangeMap, jdmo, start, end, includeAllServiceGoalTypes, spqueuesBySID);</span>
<span class="nc" id="L660">		} catch (JdmoException e) {</span>
<span class="nc" id="L661">			throw e;</span>
		} finally {
<span class="nc" id="L663">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spQMap
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getMultiQueuesTrace(TraceCube metaTC, Set qIDSet, Map spQMap, Date start, Date end,
			Date lastUpdate, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L681">		StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L682">		pStmt.append(getCombinedQueueDESelectStmt(metaTC, qIDSet, spQMap.keySet(), jdmo, start, end, lastUpdate));</span>
<span class="nc" id="L683">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L684">		int lastUpdatePos = 1;</span>
<span class="nc" id="L685">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L686">		lastUpdatePos = setDateQueryParams(jQuery, metaTC, start, end1, lastUpdatePos);</span>
<span class="nc bnc" id="L687" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L688">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L689">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L690">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L691" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L692">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L693">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
		}
<span class="nc" id="L696">		long startTime = 0l;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">		if(metaTC instanceof ActualTraceCube){</span>
<span class="nc" id="L698">			startTime = System.currentTimeMillis();</span>
<span class="nc" id="L699">			lastUpdatePos = setDateQueryParams(jQuery, metaTC, start, end1, lastUpdatePos);</span>
		}
<span class="nc" id="L701">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">		if(metaTC instanceof  ActualTraceCube){</span>
<span class="nc" id="L703">			LOG.info(&quot;Time taken to execute query for Combined Queue:&quot; + pStmt.toString() + &quot;TimeTaken :&quot;</span>
<span class="nc" id="L704">					+ (System.currentTimeMillis() - startTime));</span>
		}
<span class="nc" id="L706">		return rs;</span>
	}

	private static int setDateQueryParams(JdmoQuery jQuery, TraceCube metaTC, Date start, Date end, int lastUpdatePos) {
<span class="nc bnc" id="L710" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L711">			jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(getTraceStart(metaTC, start)));</span>
<span class="nc" id="L712">			lastUpdatePos++;</span>
<span class="nc bnc" id="L713" title="All 2 branches missed.">			if (end != null) {</span>
<span class="nc" id="L714">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end)));</span>
<span class="nc" id="L715">				lastUpdatePos++;</span>
			}
		} else {
<span class="nc bnc" id="L718" title="All 2 branches missed.">			if (end != null) {</span>
<span class="nc" id="L719">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(getTraceEnd(metaTC, end)));</span>
<span class="nc" id="L720">				lastUpdatePos++;</span>
			}
		}
<span class="nc" id="L723">		return lastUpdatePos;</span>
	}

	/**
	 *
	 * @param metaTC
	 * @param qIDSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param start
	 * @param end
	 * @return
	 * @throws JdmoException
	 */
	private static String getCombinedQueueDESelectStmtForActualTC(TraceCube metaTC, Set qIDSet, Jdmo jdmo, Date lastUpdate,
			Date start, Date end) throws JdmoException {
<span class="nc" id="L739">		final String origName = &quot;QHTS_TIME&quot;;</span>
<span class="nc" id="L740">		StringBuilder query = new StringBuilder();</span>
<span class="nc" id="L741">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L742">		String strTemptableName = jdmo.getNativeTemptableName(origName);</span>
<span class="nc" id="L743">		query.append(&quot; IF (OBJECT_ID('tempdb..&quot;).append(strTemptableName).append(&quot;')) IS NOT NULL &quot;)</span>
<span class="nc" id="L744">				.append(&quot; DROP TABLE &quot;).append(strTemptableName).append(&quot;; &quot;)</span>
<span class="nc" id="L745">				.append(&quot; SELECT E.QUEUEID, E.TIME,MEDIASID = V_MEDIA.SID, QUEUESID = D.SID &quot;)</span>
<span class="nc" id="L746">				.append(&quot; INTO &quot;).append(strTemptableName)</span>
<span class="nc" id="L747">				.append(&quot; FROM &quot;).append(getTraceTable(metaTC)).append(&quot; E WITH (NOLOCK) &quot;)</span>
<span class="nc" id="L748">				.append(&quot; INNER JOIN QUEUE D WITH (NOLOCK) ON E.QUEUEID = D.ID &quot;)</span>
<span class="nc" id="L749">				.append(&quot; INNER JOIN V_MEDIA ON V_MEDIA.ID = D.MEDIAID &quot;)</span>
<span class="nc" id="L750">				.append(&quot; WHERE D.SID IN &quot;).append(jdmo.createInClause(qIDSet)).append(&quot; AND &quot;)</span>
<span class="nc" id="L751">				.append(createDateClauseWithGivenTimeColumName(&quot; E.TIME&quot;, start, end));</span>

<span class="nc bnc" id="L753" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L754">			query.append(&quot; and ((E.MODIFIED is null and E.CREATED&gt; ? ) or E.MODIFIED &gt; ?) &quot;);</span>

		}
<span class="nc" id="L757">		query.append(&quot; ; &quot;);</span>
<span class="nc" id="L758">		query.append(System.getProperty(&quot;line.separator&quot;));</span>
<span class="nc" id="L759">		query.append(System.getProperty(&quot;line.separator&quot;));</span>
<span class="nc" id="L760">		query.append(&quot;SELECT &quot;);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L762" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L763">				query.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
			}
		}
<span class="nc" id="L766">		query.append(&quot; A.TIME, &quot;)</span>
<span class="nc" id="L767">				.append(&quot; SID=Q.QUEUESID, &quot;)</span>
<span class="nc" id="L768">				.append(&quot; MEDIAID =Q.MEDIASID FROM &quot;)</span>
<span class="nc" id="L769">				.append(getTraceTable(metaTC))</span>
<span class="nc" id="L770">				.append(&quot; A WITH (NOLOCK) &quot;)</span>
<span class="nc" id="L771">				.append(&quot; INNER JOIN #QHTS_TIME Q ON Q.[TIME]=A.[TIME] &quot;)</span>
<span class="nc" id="L772">				.append(&quot; AND  Q.QUEUEID=A.QUEUEID &quot;)</span>
<span class="nc" id="L773">				.append(&quot; WHERE &quot;)</span>
<span class="nc" id="L774">				.append(createDateClauseWithGivenTimeColumName(&quot; A.TIME&quot;, start, end));</span>
<span class="nc" id="L775">		return query.toString();</span>
	}

	private static String createDateClauseWithGivenTimeColumName(String dateColumn, Date start, Date end) {
<span class="nc" id="L779">		StringBuilder query = new StringBuilder();</span>

<span class="nc bnc" id="L781" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L782">			query.append(dateColumn).append(&quot; &gt;= ? AND &quot;).append(dateColumn).append(&quot; &lt;= ?&quot;);</span>
<span class="nc bnc" id="L783" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L784">			query.append(dateColumn).append(&quot; &gt;= ?&quot;);</span>
<span class="nc bnc" id="L785" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L786">			query.append(dateColumn).append(&quot; &lt;= ?&quot;);</span>
		}
<span class="nc" id="L788">		return query.toString();</span>
	}

	public static Collection&lt;TraceChunk&gt; getCombinedQueueForecastTimeSeriesFromLastUpdate(TraceCube metaTC, HashSet qIDSet,
			HashMap spQMap, HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L793">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L794">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L797">			int arraySz = 0;</span>
<span class="nc bnc" id="L798" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L799">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L801" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L802">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// get all queues associated with changed SPIDs
<span class="nc" id="L805">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="nc" id="L806">			HashMap chunkDateMap = new HashMap(700);</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">			for (Iterator iterator = qIDSet.iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L808">				ID queID = (ID) iterator.next();</span>
<span class="nc" id="L809">				Collection prdCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_PREDICT, queID, start,</span>
						end, lastUpdate, false);
<span class="nc bnc" id="L811" title="All 4 branches missed.">				if (prdCol != null &amp;&amp; !prdCol.isEmpty()) {</span>
<span class="nc bnc" id="L812" title="All 2 branches missed.">					for (Iterator iterator1 = prdCol.iterator(); iterator1.hasNext(); ) {</span>
<span class="nc" id="L813">						TraceChunk chunk = (TraceChunk) iterator1.next();</span>
<span class="nc" id="L814">						HashMap queTraceChunkMap = (HashMap) chunkDateMap.get(chunk.getStartDate());</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">						if (queTraceChunkMap == null) {</span>
<span class="nc" id="L816">							queTraceChunkMap = new HashMap(qIDSet.size());</span>
<span class="nc" id="L817">							chunkDateMap.put(chunk.getStartDate(), queTraceChunkMap);</span>
						}
<span class="nc" id="L819">						queTraceChunkMap.put(queID, chunk);</span>
<span class="nc" id="L820">					}</span>
				}
<span class="nc" id="L822">			}</span>
<span class="nc" id="L823">			convert(rs, metaTC, spQMap, spTimeRangeMap, tcArray, start, end, jdmo, chunkDateMap);</span>
<span class="nc" id="L824">			return tcArray;</span>
<span class="nc" id="L825">		} catch (JdmoException e) {</span>
<span class="nc" id="L826">			throw e;</span>
<span class="nc" id="L827">		} catch (Exception e) {</span>
<span class="nc" id="L828">			return tcArray;</span>
		} finally {
<span class="nc" id="L830">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue
	 *
	 * @param TraceCube metaTC
	 * @param ID CampaignID
	 * @param ID mediaID
	 * @param HashMap (SPID, Queue ID Collection
	 * )
	 * @param HashMap (SPID, TimeRange)
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection&lt;TraceChunk&gt; getCombinedQueueTimeSeriesFromLastUpdate(TraceCube metaTC, HashSet qIDSet,
			HashMap spQMap, HashMap spTimeRangeMap, Date start, Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L850">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L851">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L854">			int arraySz = 0;</span>
<span class="nc bnc" id="L855" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L856">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L858" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L859">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// get all queues associated with changed SPIDs
<span class="nc" id="L862">			JdmoRowset rs = getMultiQueuesTrace(metaTC, qIDSet, spQMap, start, end, lastUpdate, jdmo);</span>
<span class="nc" id="L863">			convert(rs, metaTC, spQMap, spTimeRangeMap, tcArray, start, end, jdmo, null);</span>
<span class="nc" id="L864">			return tcArray;</span>
<span class="nc" id="L865">		} catch (JdmoException e) {</span>
<span class="nc" id="L866">			throw e;</span>
<span class="nc" id="L867">		} catch (Exception e) {</span>
<span class="nc" id="L868">			return tcArray;</span>
		} finally {
<span class="nc" id="L870">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueDESelectStmt(TraceCube metaTC, Set qIDSet, Set spSet, Jdmo jdmo, Date start, Date end,
			Date lastUpdate) throws JdmoException {
<span class="nc" id="L876">		StringBuilder pStmt = new StringBuilder(15 * metaTC.getTraceTypes().length);</span>
<span class="nc" id="L877">		short[] types = metaTC.getTraceTypes();</span>

<span class="nc bnc" id="L879" title="All 2 branches missed.">		if(!(metaTC instanceof  ActualTraceCube)) {</span>
<span class="nc" id="L880">			pStmt.append(&quot; SELECT &quot;);</span>
		}

<span class="nc bnc" id="L883" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L884">			pStmt.append(getCombinedQueueDESelectStmtForActualTC(metaTC, qIDSet, jdmo, lastUpdate, start, end));</span>
<span class="nc bnc" id="L885" title="All 2 branches missed.">		} else if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L886">			getCombinedQueueDESelectStmtForForecastTC(metaTC, spSet, jdmo, lastUpdate, pStmt, types);</span>
<span class="nc bnc" id="L887" title="All 2 branches missed.">		} else if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L888">			getCombinedQueueDESelectStmtForSGTC(metaTC, spSet, jdmo, lastUpdate, pStmt);</span>
<span class="nc bnc" id="L889" title="All 2 branches missed.">		} else if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L890">			getCombinedQueueDESelectStmtForRequireTC(metaTC, spSet, jdmo, lastUpdate, pStmt, types);</span>
		} else {
<span class="nc" id="L892">			return null;</span>
		}
<span class="nc" id="L894">		String TIME = getDETimeColumn(metaTC, false, false);</span>
<span class="nc bnc" id="L895" title="All 2 branches missed.">		if (!(metaTC instanceof ActualTraceCube)) {</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">			String tableNameAppendStr = (lastUpdate != null ? &quot;E.&quot; : &quot;A.&quot;) + TIME;</span>
<span class="nc bnc" id="L897" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L898">				pStmt.append(&quot; AND &quot;).append(tableNameAppendStr).append(&quot;&gt;= ? and &quot;).append(tableNameAppendStr).append(&quot;&lt;= ?&quot;);</span>
<span class="nc bnc" id="L899" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L900">				pStmt.append(&quot; AND &quot;).append(tableNameAppendStr).append(&quot;&gt;= ?&quot;);</span>
<span class="nc bnc" id="L901" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L902">				pStmt.append(&quot; AND &quot;).append(tableNameAppendStr).append(&quot;&lt;= ?&quot;);</span>
			}
<span class="nc bnc" id="L904" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L905">				pStmt.append(&quot; and ((E.MODIFIED is null and E.CREATED&gt; ? ) or E.MODIFIED &gt; ? &quot;);</span>
<span class="nc bnc" id="L906" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L907">					pStmt.append(&quot;or (G.MODIFIED is null and G.CREATED&gt; ? ) or G.MODIFIED &gt; ?&quot;);</span>
				}
<span class="nc" id="L909">				pStmt.append(&quot;) ) &quot;);</span>
			}
		}
<span class="nc" id="L912">		pStmt.append(&quot; order by A.&quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="nc bnc" id="L913" title="All 2 branches missed.">		if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L914">			LOG.debug(&quot;QUERY=&quot; + pStmt);</span>
		}
<span class="nc" id="L916">		return pStmt.toString();</span>
	}

	private static String appendForecastInstanceID(TraceCube metaTC) {
<span class="nc" id="L920">		StringBuilder sbr = new StringBuilder();</span>
<span class="nc bnc" id="L921" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L922">			sbr.append(&quot; AND FORECASTINSTANCEID &quot;);</span>
<span class="nc" id="L923">			ForecastTraceCube fCube = (ForecastTraceCube) metaTC;</span>
<span class="nc bnc" id="L924" title="All 2 branches missed.">			if (!StringUtil.isEmptyOrWhiteSpace(fCube.getForecastInstanceID())) {</span>
<span class="nc" id="L925">				sbr.append(&quot;= '&quot;).append(fCube.getForecastInstanceID().trim()).append(&quot;' &quot;);</span>
			} else {
<span class="nc" id="L927">				sbr.append(&quot; IS NULL &quot;);</span>
			}
		}
<span class="nc" id="L930">		return sbr.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForRequireTC(TraceCube metaTC, Set spSet, Jdmo jdmo, Date lastUpdate,
			StringBuilder pStmt, short[] types) throws JdmoException {
		// FTE is from real queue
<span class="nc bnc" id="L945" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L946" title="All 2 branches missed.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L948">					pStmt.append(getDETraceColumn(types[t])).append(i).append(',');</span>
				}
			}
		}
<span class="nc" id="L952">		pStmt.append(&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE ,  V_MEDIA.SID MEDIAID, B.SID SPQUEUESID from &quot;)</span>
<span class="nc" id="L953">				.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN, V_MEDIA &quot;)</span>
<span class="nc" id="L954">				.append(&quot; where C.CAMPAIGNID=CAMPAIGN.ID and V_MEDIA.ID=D.MEDIAID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID &quot;)</span>
<span class="nc" id="L955">				.append(&quot; and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID &quot;)</span>
<span class="nc" id="L956">				.append(&quot; and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="nc bnc" id="L957" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L958">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC))</span>
<span class="nc" id="L959">					.append(&quot; E, SPQUEUE F, SP G where E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;).append(jdmo.createInClause(spSet));</span>
		}
<span class="nc" id="L961">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForSGTC(TraceCube metaTC, Set spSet, Jdmo jdmo, Date lastUpdate, StringBuilder pStmt)
			throws JdmoException {
<span class="nc" id="L973">		pStmt.append(&quot;SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, D.SID, C.SID, B.SERVICELEVELGOALTYPE, V_MEDIA.SID MEDIAID, &quot;)</span>
<span class="nc" id="L974">				.append(&quot;B.SID SPQUEUESID from &quot;).append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B, SP C, QUEUE D, V_MEDIA &quot;)</span>
<span class="nc" id="L975">				.append(&quot; where A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and V_MEDIA.ID=D.MEDIAID  and C.SID in &quot;)</span>
<span class="nc" id="L976">				.append(jdmo.createInClause(spSet));</span>
<span class="nc bnc" id="L977" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L978">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC))</span>
<span class="nc" id="L979">					.append(&quot; E, SPQUEUE F, SP G where E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;).append(jdmo.createInClause(spSet));</span>
		}
<span class="nc" id="L981">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param lastUpdate
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForForecastTC(TraceCube metaTC, Set spSet, Jdmo jdmo, Date lastUpdate,
			StringBuilder pStmt, short[] types) throws JdmoException {
<span class="nc bnc" id="L994" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L995" title="All 2 branches missed.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L996" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L997">					pStmt.append(getDETraceColumn(types[t])).append(i).append(',');</span>
				}
			}
		}
<span class="nc" id="L1001">		pStmt.append(&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE,  V_MEDIA.SID MEDIAID, B.SID SPQUEUESID from &quot;)</span>
<span class="nc" id="L1002">				.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN , V_MEDIA &quot;)</span>
<span class="nc" id="L1003">				.append(&quot; where C.CAMPAIGNID=CAMPAIGN.ID and V_MEDIA.ID=D.MEDIAID &quot;)</span>
<span class="nc" id="L1004">				.append(&quot; and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME &quot;)</span>
<span class="nc" id="L1005">				.append(&quot; AND A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L1006">		pStmt.append(appendForecastInstanceID(metaTC));</span>
<span class="nc bnc" id="L1007" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1008">			pStmt.append(&quot; and A.DATETIME in (select E.DATETIME from &quot;).append(getTraceTable(metaTC))</span>
<span class="nc" id="L1009">					.append(&quot; E, SPQUEUE F, SP G where E.FORECASTINSTANCEID is null and E.SPQUEUEID=F.ID and F.SPID=G.ID and G.SID in &quot;)</span>
<span class="nc" id="L1010">					.append(jdmo.createInClause(spSet));</span>
		}
<span class="nc" id="L1012">	}</span>

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue directly load.
	 *
	 * @param TraceCube metaTC
	 * @param ID CampaignID
	 * @param ID mediaID
	 * @param Set SPID set
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return TraceCube
	 */
	public static TraceCube getCombinedQueueTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID campaignID, ID mediaID,
			Set&lt;? extends ID&gt; spIDSet, Date start, Date end, Date lastUpdate, boolean includeAllServiceGoalTypes,
			Map&lt;ID, SPQueue&gt; spqueuesBySID, boolean isNoPhantom) throws Exception {
<span class="nc" id="L1029">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1031">			JdmoRowset rs = getCombinedQueueTimeSeries(metaTC, campaignID, mediaID, spIDSet, start, end, lastUpdate, jdmo, isNoPhantom);</span>
<span class="nc" id="L1032">			return convert(rs, metaTC, start, end, mediaID, includeAllServiceGoalTypes, jdmo.isWhatIf(), spqueuesBySID, isNoPhantom);</span>
<span class="nc" id="L1033">		} catch (Exception e) {</span>
<span class="nc" id="L1034">			throw e;</span>
		} finally {
<span class="nc" id="L1036">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param campaignID
	 * @param mediaID
	 * @param spIDSet
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getCombinedQueueTimeSeries(TraceCube metaTC, ID campaignID, ID mediaID, Set&lt;? extends ID&gt; spIDSet, Date start,
			Date end, Date lastUpdate, Jdmo jdmo, boolean isNoPhantom)
			throws JdmoException {
<span class="nc" id="L1055">		StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1056">		pStmt.append(getCombinedQueueDESelectStmt(metaTC, mediaID, spIDSet, jdmo, isNoPhantom));</span>
<span class="nc" id="L1057">		String TIME = getDETimeColumn(metaTC, true, isNoPhantom);</span>
<span class="nc bnc" id="L1058" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1059">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1060" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1061">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1062" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1063">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
		}
<span class="nc bnc" id="L1065" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1066">			pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc bnc" id="L1067" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1068">				pStmt.append(&quot;or (C.MODIFIED is null and C.CREATED&gt;?) or C.MODIFIED&gt;?&quot;);</span>
			}
<span class="nc" id="L1070">			pStmt.append(&quot;)&quot;);</span>
		}
<span class="nc" id="L1072">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="nc" id="L1073">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1074">		int lastUpdatePos = 1;</span>
<span class="nc" id="L1075">		jQuery.setParID(lastUpdatePos++, campaignID);</span>
<span class="nc" id="L1076">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">		if (mediaID != null) {</span>
<span class="nc" id="L1078">			jQuery.setParID(lastUpdatePos++, mediaID);</span>
		}
<span class="nc" id="L1080">		lastUpdatePos = setDateQueryParams(jQuery, metaTC, start, end1, lastUpdatePos);</span>
<span class="nc bnc" id="L1081" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1082">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1083">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1084">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L1085" title="All 2 branches missed.">			if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1086">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1087">				jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
		}
<span class="nc" id="L1090">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1091">		return rs;</span>
	}

	/**
	 * Retrieve getCombinedQueueTimeSeriesFromLastUpdate for a combined Queue directly load, this method is used by the TRACEREPORT
	 * DUMP only.
	 *
	 * @param TraceCube metaTC
	 * @param ID CampaignID
	 * @param ID mediaID
	 * @param Set SPID set
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection&lt;TraceChunk&gt; getCombinedQueueTimeSeriesFromLastUpdate(TraceCube metaTC, ID campaignID,
			ID mediaID, Set&lt;? extends ID&gt; spIDSet, Date start, Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L1109">		ArrayList&lt;TraceChunk&gt; tcArray = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1110">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L1113">			int arraySz = 0;</span>
<span class="nc bnc" id="L1114" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1115">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1117" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1118">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
<span class="nc" id="L1120">			JdmoRowset rs = getCombinedQueueTimeSeries(metaTC, campaignID, mediaID, spIDSet, start, end, lastUpdate, jdmo, false);</span>
<span class="nc" id="L1121">			convert(rs, metaTC, tcArray, start, end, mediaID);</span>
<span class="nc" id="L1122">			return tcArray;</span>
<span class="nc" id="L1123">		} catch (JdmoException e) {</span>
<span class="nc" id="L1124">			throw e;</span>
<span class="nc" id="L1125">		} catch (Exception e) {</span>
<span class="nc" id="L1126">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L1127">			return tcArray;</span>
		} finally {
<span class="nc" id="L1129">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueDESelectStmt(TraceCube metaTC, ID mediaID, Set&lt;? extends ID&gt; spSet,
			Jdmo jdmo, boolean isNoPhantom)
			throws JdmoException {
<span class="nc" id="L1136">		StringBuilder pStmt = new StringBuilder(15 * metaTC.getTraceTypes().length);</span>
<span class="nc" id="L1137">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1138">		pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1140">			getCombinedQueueDESelectStmtForPredictTC(metaTC, spSet, jdmo, isNoPhantom, pStmt, types);</span>
		}
<span class="nc bnc" id="L1142" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1143">			getCombinedQueueDESelectStmtForSGTC(metaTC, spSet, jdmo, pStmt);</span>
		}
<span class="nc bnc" id="L1145" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1146">			getCombinedQueueDESelectStmtForRequireTC(metaTC, spSet, jdmo, pStmt, types);</span>
		}
<span class="nc" id="L1148">		pStmt.append(&quot; and QUEUEID is null and CAMPAIGNID=(select ID from CAMPAIGN where SID=?)&quot;);</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">		if (mediaID != null) {</span>
<span class="nc" id="L1150">			pStmt.append(&quot; and MEDIAID=(select ID from MEDIA where SID=?)&quot;);</span>
		} else {
<span class="nc" id="L1152">			pStmt.append(&quot; and MEDIAID is null&quot;);</span>
		}
<span class="nc" id="L1154">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForRequireTC(TraceCube metaTC, Set&lt;? extends ID&gt; spSet, Jdmo jdmo,
			StringBuilder pStmt, short[] types)
			throws JdmoException {
<span class="nc bnc" id="L1168" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L1170" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L1171">					pStmt.append(&quot;FTE&quot;).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
<span class="nc" id="L1175">		pStmt.append(&quot; A.DATETIME, TIMEZONEMAP.JAVATZIDENT, c.FROMDATE, c.TODATE , B.SID SPQUEUESID from &quot;)</span>
<span class="nc" id="L1176">				.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B, SP C,TIMEZONE,TIMEZONEMAP,CAMPAIGN &quot;)</span>
<span class="nc" id="L1177">				.append(&quot; where C.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and &quot;)</span>
<span class="nc" id="L1178">				.append(&quot; TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;)</span>
<span class="nc" id="L1179">				.append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L1180">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param pStmt
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForSGTC(TraceCube metaTC, Set&lt;? extends ID&gt; spSet, Jdmo jdmo, StringBuilder pStmt)
			throws JdmoException {
<span class="nc" id="L1191">		pStmt.append(&quot; SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, B.SERVICELEVELGOALTYPE from &quot;).append(getTraceTable(metaTC))</span>
<span class="nc" id="L1192">				.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L1193">	}</span>

	/**
	 * @param metaTC
	 * @param spSet
	 * @param jdmo
	 * @param isNoPhantom
	 * @param pStmt
	 * @param types
	 * @throws JdmoException
	 */
	private static void getCombinedQueueDESelectStmtForPredictTC(TraceCube metaTC, Set&lt;? extends ID&gt; spSet, Jdmo jdmo, boolean isNoPhantom,
			StringBuilder pStmt, short[] types)
			throws JdmoException {
<span class="nc bnc" id="L1207" title="All 2 branches missed.">		for (int i = 1; i &lt;= 96; i++) {</span>
<span class="nc bnc" id="L1208" title="All 2 branches missed.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L1209" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
					// bad hack; done for Netstaffing feature. implemeneted as per Jason's directive for performance reasons.
<span class="nc bnc" id="L1211" title="All 3 branches missed.">					switch (types[t]) {</span>
						case Trace.ASTAFFING:
<span class="nc" id="L1213">							pStmt.append(&quot;ISNULL(ASTAFF&quot;).append(i).append(&quot;,STAFFING&quot;).append(i).append(&quot;) ASTAFF&quot;).append(i).append(&quot;,&quot;);</span>
							// ISNULL(ASTAFF,STAFFING) ASTAFF1
<span class="nc" id="L1215">							break;</span>
						case Trace.AFTE:
<span class="nc" id="L1217">							pStmt.append(&quot;ISNULL(AFTE&quot;).append(i).append(&quot;,FTE&quot;).append(i).append(&quot;) AFTE&quot;).append(i).append(&quot;,&quot;);</span>
<span class="nc" id="L1218">							break;</span>
						default:
<span class="nc" id="L1220">							pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
							break;
					}
				}
			}
		}
<span class="nc" id="L1226">		pStmt.append(getDETimeColumn(metaTC, true, isNoPhantom))</span>
<span class="nc" id="L1227">				.append(&quot;, TIMEZONEMAP.JAVATZIDENT, c.FROMDATE, c.TODATE , B.SID SPQUEUESID from &quot;)</span>
<span class="nc" id="L1228">				.append(getTraceTable(metaTC, isNoPhantom))</span>
<span class="nc" id="L1229">				.append(&quot; A, SPQUEUE B, SP C, TIMEZONE, TIMEZONEMAP, CAMPAIGN &quot;)</span>
<span class="nc" id="L1230">				.append(&quot; where C.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID &quot;)</span>
<span class="nc" id="L1231">				.append(&quot; and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;)</span>
<span class="nc" id="L1232">				.append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L1233">	}</span>

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types with timestamp on it.
	 *
	 * @param ID Queue ID
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getActualTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end, Date lastUpdate)
			throws JdmoException {
<span class="nc" id="L1246">		ArrayList tcArray = new ArrayList();</span>
<span class="nc" id="L1247">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L1250">			int arraySz = 0;</span>
<span class="nc bnc" id="L1251" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1252">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1254" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1255">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1258">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1259">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1260">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
			// Prepare the Statement
<span class="nc" id="L1262">			StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1263">			short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1264">			pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1265" title="All 2 branches missed.">			for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1266" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1267">					pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
				}
			}
<span class="nc" id="L1270">			pStmt.append(&quot; TIME, MODIFIED, CREATED from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1271">			pStmt.append(&quot; A where QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L1272">			String TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="nc bnc" id="L1273" title="All 4 branches missed.">			if (start != null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1274">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1275" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end1 == null) {</span>
<span class="nc" id="L1276">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1277" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1278">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="nc bnc" id="L1280" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1281">				pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc" id="L1282">				pStmt.append(&quot;)&quot;);</span>
			}
<span class="nc" id="L1284">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1286">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1287">			jQuery.setParID(1, queueID);</span>
<span class="nc" id="L1288">			int lastUpdatePos = 2;</span>
<span class="nc bnc" id="L1289" title="All 2 branches missed.">			if (traceStart != null) {</span>
<span class="nc" id="L1290">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1291" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1292">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			} else {
<span class="nc bnc" id="L1295" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1296">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			}
<span class="nc bnc" id="L1299" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1300">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1301">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1302">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
<span class="nc" id="L1304">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc bnc" id="L1306" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1307">				TraceChunk tc = new TraceChunk(queueID, TimeZoneUtil.toDate(rs.getTimestamp(types.length + 1)));</span>
<span class="nc bnc" id="L1308" title="All 2 branches missed.">				for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L1309">					tc.setTraceValue(types[i], i + 1);</span>
				}
<span class="nc" id="L1311">				Date modifedAt = TimeZoneUtil.toDate(rs.getTimestamp(types.length + 2));</span>
<span class="nc bnc" id="L1312" title="All 2 branches missed.">				if (modifedAt == null) {</span>
<span class="nc" id="L1313">					modifedAt = TimeZoneUtil.toDate(rs.getTimestamp(types.length + 3));</span>
				}
<span class="nc" id="L1315">				tc.setLastModifiedDate(modifedAt);</span>
<span class="nc" id="L1316">				tcArray.add(tc);</span>
<span class="nc" id="L1317">			}</span>
<span class="nc" id="L1318">			return tcArray;</span>
<span class="nc" id="L1319">		} catch (JdmoException e) {</span>
<span class="nc" id="L1320">			throw e;</span>
<span class="nc" id="L1321">		} catch (Exception e) {</span>
<span class="nc" id="L1322">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L1323">			return tcArray;</span>
		} finally {
<span class="nc" id="L1325">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types with timestamp on it
	 *
	 * @param ID Queue ID
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getActualTimeSeriesCubeFromLastUpdate(TraceCube metaTC, Collection queueIDCol, Date start,
			Date end, Date lastUpdate) throws JdmoException {
<span class="nc" id="L1340">		ArrayList tcArray = new ArrayList();</span>
<span class="nc" id="L1341">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1343">			String inClause = jdmo.createInClause(queueIDCol);</span>
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L1345">			int arraySz = 0;</span>
<span class="nc bnc" id="L1346" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1347">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1349" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1350">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1353">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1354">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1355">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
			// Prepare the Statement
<span class="nc" id="L1357">			StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1358">			short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1359">			pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1360" title="All 2 branches missed.">			for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1361" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1362">					pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
				}
			}
<span class="nc" id="L1365">			pStmt.append(&quot; TIME, B.SID from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1366">			pStmt.append(&quot; A, QUEUE B where A.QUEUEID=B.ID and B.SID in &quot;).append(inClause);</span>
<span class="nc" id="L1367">			String TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="nc bnc" id="L1368" title="All 4 branches missed.">			if (start != null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1369">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1370" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end1 == null) {</span>
<span class="nc" id="L1371">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1372" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end1 != null) {</span>
<span class="nc" id="L1373">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}

<span class="nc bnc" id="L1376" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
				// first the earliest startime has changes, then load everything till end
<span class="nc" id="L1378">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=&quot;);</span>
<span class="nc" id="L1379">				pStmt.append(&quot;(select min(&quot;).append(TIME).append(&quot;) from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1380">				pStmt.append(&quot; X where X.&quot;).append(TIME).append(&quot;&gt;=? and X.&quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc" id="L1381">				pStmt.append(&quot; and ((X.MODIFIED is null and X.CREATED&gt;?) or X.MODIFIED&gt;?) and X.QUEUEID in (select ID from QUEUE Y where Y.SID in &quot;);</span>
<span class="nc" id="L1382">				pStmt.append(inClause).append(&quot;))&quot;);</span>
			}
<span class="nc" id="L1384">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1386">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1387">			int lastUpdatePos = 1;</span>
<span class="nc" id="L1388">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc" id="L1389">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc bnc" id="L1390" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1391">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1392">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc" id="L1393">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1394">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1395">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
			}
<span class="nc" id="L1397">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1398">			return convertActual(rs, metaTC, queueIDCol, start, end1, jdmo.isWhatIf());</span>
<span class="nc" id="L1399">		} catch (JdmoException e) {</span>
<span class="nc" id="L1400">			throw e;</span>
<span class="nc" id="L1401">		} catch (Exception e) {</span>
<span class="nc" id="L1402">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L1403">			return tcArray;</span>
		} finally {
<span class="nc" id="L1405">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types
	 *
	 * @param ID Queue ID
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
			Date lastUpdate, boolean includeAllServiceGoalTypes) throws JdmoException {
<span class="nc" id="L1420">		Jdmo jdmo = null;</span>
		try {
<span class="nc" id="L1422">			jdmo = new Jdmo();</span>
<span class="nc" id="L1423">			return getTimeSeriesFromLastUpdate(metaTC, queueID, start, end, lastUpdate, jdmo, includeAllServiceGoalTypes);</span>
		} finally {
<span class="nc bnc" id="L1425" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L1426">				jdmo.cleanUp();</span>
			}
		}
	}

	public static Collection getTimeSeriesFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
			Date lastUpdate, Jdmo jdmo, boolean includeAllServiceGoalTypes) throws JdmoException {
<span class="nc" id="L1433">		ArrayList tcArray = new ArrayList();</span>
		// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L1435">		int arraySz = 0;</span>
<span class="nc bnc" id="L1436" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1437">			arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
		}
<span class="nc bnc" id="L1439" title="All 2 branches missed.">		if (arraySz != 0) {</span>
<span class="nc" id="L1440">			tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
		}
<span class="nc" id="L1442">		Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1443">		Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1444">		Date traceEnd = getTraceEnd(metaTC, end1);</span>
<span class="nc" id="L1445">		JdmoRowset rs = getSingleQueueTrace(metaTC, queueID, start, end1, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="nc" id="L1446">		convertTraceChunks(rs, metaTC, queueID, tcArray, start, end1, includeAllServiceGoalTypes, jdmo.isWhatIf());</span>
<span class="nc" id="L1447">		return tcArray;</span>
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types
	 *
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param spqueuesBySID isNoPhantom is set to false as the default behavior.
	 * @return TraceCube
	 */
	public static TraceCube getTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
			Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID, Map&lt;ID, Queue&gt; idQueueMap) throws Exception {
<span class="nc" id="L1463">		return getTimeSeriesCubeFromLastUpdate(metaTC, queueID, start, end, lastUpdate, spqueuesBySID, false, idQueueMap);</span>
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types.
	 *
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param spqueuesBySID
	 * @param isNoPhantom   will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 *                      ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws Exception
	 */
	public static TraceCube getTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
			Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID, boolean isNoPhantom, Map&lt;ID, Queue&gt; idQueueMap) throws Exception {
<span class="nc" id="L1482">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Prepare for select window
<span class="nc" id="L1485">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1486">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1487">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
<span class="nc" id="L1488">			JdmoRowset rs = getSingleQueueTrace(metaTC, queueID, start, end1, lastUpdate, jdmo, traceStart, traceEnd, isNoPhantom);</span>
<span class="nc" id="L1489">			return convert(rs, metaTC, queueID, start, end1, false, jdmo.isWhatIf(), spqueuesBySID, isNoPhantom, idQueueMap);</span>
<span class="nc" id="L1490">		} catch (JdmoException e) {</span>
<span class="nc" id="L1491">			throw e;</span>
		} finally {
<span class="nc" id="L1493">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Retrieve TimeSeries for a Queue, specifying a given period for all Trace Types.
	 *
	 * @param ID Queue ID
	 * @param Date start
	 * @param Date end
	 * @param Date lastUpdate
	 * @return TraceCube
	 */
	public static TraceCube getActualTimeSeriesCubeFromLastUpdate(TraceCube metaTC, ID queueID, Date start, Date end,
			Date lastUpdate, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="nc" id="L1508">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L1510">			Date traceStart = getTraceStart(metaTC, start);</span>
<span class="nc" id="L1511">			Date end1 = adjustActualEndDateForDemo(end, metaTC);</span>
<span class="nc" id="L1512">			Date traceEnd = getTraceEnd(metaTC, end1);</span>
<span class="nc" id="L1513">			StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1514">			pStmt.append(getDESelectStmt(metaTC, jdmo));</span>
<span class="nc" id="L1515">			String TIME = getDETimeColumn(metaTC, true, false);</span>
			// first the earliest startime has changes, then load everything till end
<span class="nc" id="L1517">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=&quot;);</span>
<span class="nc bnc" id="L1518" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1519">				pStmt.append(&quot;(select min(&quot;).append(TIME).append(&quot;) from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1520">				pStmt.append(&quot; X where X.&quot;).append(TIME).append(&quot;&gt;=? and X.&quot;).append(TIME).append(&quot;&lt;=? and &quot;);</span>
<span class="nc" id="L1521">				pStmt.append(&quot; and ((X.MODIFIED is null and X.CREATED&gt;?) or X.MODIFIED&gt;?) and X.QUEUEID=(select ID from QUEUE where SID=?))&quot;);</span>
			} else {
<span class="nc" id="L1523">				pStmt.append(&quot;?&quot;);</span>
			}
<span class="nc" id="L1525">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc" id="L1526">			pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
			// SQL Execution
<span class="nc" id="L1528">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1529">			jQuery.setParString(1, DAOUtil.mapIDToDEID(queueID, new QueueFieldInfo()).toString());</span>
<span class="nc" id="L1530">			int lastUpdatePos = 2;</span>
<span class="nc" id="L1531">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1532" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1533">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1534">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1535">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1536">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1537">				jQuery.setParID(lastUpdatePos, queueID);</span>
			}
<span class="nc" id="L1539">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
<span class="nc" id="L1540">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1541">			return convert(rs, metaTC, queueID, start, end1, false, jdmo.isWhatIf(), spqueuesBySID, false, null);</span>
<span class="nc" id="L1542">		} catch (JdmoException e) {</span>
<span class="nc" id="L1543">			throw e;</span>
		} finally {
<span class="nc" id="L1545">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd   isNoPhantom will default to false.
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSingleQueueTrace(TraceCube metaTC, ID queueID, Date start, Date end, Date lastUpdate,
			Jdmo jdmo, Date traceStart, Date traceEnd) throws JdmoException {
<span class="nc" id="L1563">		return getSingleQueueTrace(metaTC, queueID, start, end, lastUpdate, jdmo, traceStart, traceEnd, false);</span>
	}

	/**
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 *                    ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSingleQueueTrace(TraceCube metaTC, ID queueID, Date start, Date end, Date lastUpdate,
			Jdmo jdmo, Date traceStart, Date traceEnd, boolean isNoPhantom) throws JdmoException {
<span class="nc" id="L1582">		StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1583">		pStmt.append(getDESelectStmt(metaTC, jdmo, isNoPhantom));</span>
<span class="nc" id="L1584">		appendDateClause(metaTC, pStmt, start, end, lastUpdate, isNoPhantom);</span>
		// SQL Execution
<span class="nc" id="L1586">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
		try {
<span class="nc" id="L1588">			jQuery.setParString(1, DAOUtil.mapIDToDEID(queueID, new QueueFieldInfo()).toString());</span>
<span class="nc" id="L1589">			int lastUpdatePos = 2;</span>
<span class="nc bnc" id="L1590" title="All 2 branches missed.">			if (traceStart != null) {</span>
<span class="nc" id="L1591">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1592" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1593">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			} else {
<span class="nc bnc" id="L1596" title="All 2 branches missed.">				if (traceEnd != null) {</span>
<span class="nc" id="L1597">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
				}
			}
<span class="nc bnc" id="L1600" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1601">				Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1602">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1603">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc bnc" id="L1604" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1605">					jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1606">					jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
				}
			}
<span class="nc" id="L1609">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1610">			return rs;</span>
<span class="nc" id="L1611">		} catch(BbmFinderException e) {</span>
<span class="nc" id="L1612">			throw new JdmoException(&quot;Exception in method getSingleQueueTrace while getting ID from SID for queue &quot;+e.getMessage());</span>
		}
	}

	private static void appendDateClause(TraceCube metaTC, StringBuilder pStmt, Date start, Date end, Date lastUpdate, boolean isNoPhantom) {
<span class="nc" id="L1617">		boolean instanceOfForecast = metaTC instanceof ForecastTraceCube;</span>
<span class="nc" id="L1618">		boolean instanceOfPredict = metaTC instanceof PredictTraceCube;</span>
<span class="nc" id="L1619">		String TIME = null;</span>
<span class="nc bnc" id="L1620" title="All 4 branches missed.">		if (instanceOfForecast || instanceOfPredict) {</span>
<span class="nc" id="L1621">			TIME = &quot;F.&quot; + getDETimeColumn(metaTC, false, isNoPhantom);</span>
<span class="nc" id="L1622">			pStmt.append(&quot; AND A.ID in (SELECT F.ID FROM &quot;).append(getTraceTable(metaTC, isNoPhantom)).append(&quot; F, SPQUEUE D WHERE &quot;);</span>
<span class="nc" id="L1623">			pStmt.append(&quot; D.ID = F.SPQUEUEID AND D.QUEUEID= ?&quot;);</span>
<span class="nc bnc" id="L1624" title="All 2 branches missed.">			if (instanceOfForecast) {</span>
<span class="nc" id="L1625">				pStmt.append(appendForecastInstanceID(metaTC));</span>
			}

<span class="nc bnc" id="L1628" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1629">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1630" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1631">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1632" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1633">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="nc bnc" id="L1635" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1636">				pStmt.append(&quot; and ((F.MODIFIED is null and F.CREATED&gt;?) or F.MODIFIED&gt;? ) &quot;);</span>
			}
<span class="nc" id="L1638">			pStmt.append(&quot;)&quot;);</span>
			// this is reqd for the order
<span class="nc" id="L1640">			TIME = getDETimeColumn(metaTC, true, isNoPhantom);</span>
			// by clause below
		} else {
<span class="nc" id="L1643">			TIME = getDETimeColumn(metaTC, true, false);</span>
<span class="nc bnc" id="L1644" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1645">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1646" title="All 4 branches missed.">			} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1647">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1648" title="All 4 branches missed.">			} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1649">				pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
			}
<span class="nc bnc" id="L1651" title="All 2 branches missed.">			if (lastUpdate != null) {</span>
<span class="nc" id="L1652">				pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc bnc" id="L1653" title="All 2 branches missed.">				if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1654">					pStmt.append(&quot;or (B.MODIFIED is null and B.CREATED&gt;?) or B.MODIFIED&gt;?&quot;);</span>
				}
<span class="nc" id="L1656">				pStmt.append(&quot;)&quot;);</span>
			}
		}
<span class="nc" id="L1659">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="nc" id="L1660">	}</span>

	/**
	 * Retrieve SGTimeSeries for a Queue, specifying a given period for all Trace Types
	 *
	 * @param Set  , SPID
	 * @param Date , start
	 * @param Date , end
	 * @param Date , lastUpdate
	 * @return TraceCube
	 */
	public static TraceCube getSGTimeSeriesCubeFromLastUpdate(ID queueID, Set SPIDSet, String mediaDeID, Date start,
			Date end, Date lastUpdate, boolean includeAllServiceGoalTypes, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="nc" id="L1673">		Jdmo jdmo = new Jdmo();</span>
		try {
			// Prepare for select window
<span class="nc" id="L1676">			Date traceStart = getTraceStart(TraceUtil.META_SERVICEGOAL, start);</span>
<span class="nc" id="L1677">			Date traceEnd = getTraceEnd(TraceUtil.META_SERVICEGOAL, end);</span>
<span class="nc" id="L1678">			JdmoRowset rs = getSGTimeSeries(SPIDSet, mediaDeID, start, end, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="nc" id="L1679">			return convert(rs, TraceUtil.META_SERVICEGOAL, queueID, start, end, includeAllServiceGoalTypes, jdmo.isWhatIf(),</span>
					spqueuesBySID, false, null);
<span class="nc" id="L1681">		} catch (JdmoException e) {</span>
<span class="nc" id="L1682">			throw e;</span>
		} finally {
<span class="nc" id="L1684">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * @param SPIDSet
	 * @param mediaDeID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param jdmo
	 * @param traceStart
	 * @param traceEnd
	 * @return
	 * @throws JdmoException
	 */
	private static JdmoRowset getSGTimeSeries(Set SPIDSet, String mediaDeID, Date start, Date end, Date lastUpdate,
			Jdmo jdmo, Date traceStart, Date traceEnd) throws JdmoException {
		// Prepare the Statement
<span class="nc" id="L1703">		StringBuilder pStmt = new StringBuilder(6800);</span>
<span class="nc" id="L1704">		pStmt.append(getDESelectStmt(SPIDSet, mediaDeID, jdmo));</span>
<span class="nc" id="L1705">		String TIME = getDETimeColumn(TraceUtil.META_SERVICEGOAL, true, false);</span>
<span class="nc bnc" id="L1706" title="All 4 branches missed.">		if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1707">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=? and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
<span class="nc bnc" id="L1708" title="All 4 branches missed.">		} else if (start != null &amp;&amp; end == null) {</span>
<span class="nc" id="L1709">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&gt;=?&quot;);</span>
<span class="nc bnc" id="L1710" title="All 4 branches missed.">		} else if (start == null &amp;&amp; end != null) {</span>
<span class="nc" id="L1711">			pStmt.append(&quot; and &quot;).append(TIME).append(&quot;&lt;=?&quot;);</span>
		}
<span class="nc bnc" id="L1713" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1714">			pStmt.append(&quot; and ((A.MODIFIED is null and A.CREATED&gt;?) or A.MODIFIED&gt;? &quot;);</span>
<span class="nc" id="L1715">			pStmt.append(&quot;or (B.MODIFIED is null and B.CREATED&gt;?) or B.MODIFIED&gt;?&quot;);</span>
<span class="nc" id="L1716">			pStmt.append(&quot;)&quot;);</span>
		}
<span class="nc" id="L1718">		pStmt.append(&quot; order by &quot;).append(TIME).append(&quot; asc&quot;);</span>
<span class="nc" id="L1719">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L1720">		int lastUpdatePos = 1;</span>
<span class="nc bnc" id="L1721" title="All 2 branches missed.">		if (traceStart != null) {</span>
<span class="nc" id="L1722">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceStart));</span>
<span class="nc bnc" id="L1723" title="All 2 branches missed.">			if (traceEnd != null) {</span>
<span class="nc" id="L1724">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
			}
		} else {
<span class="nc bnc" id="L1727" title="All 2 branches missed.">			if (traceEnd != null) {</span>
<span class="nc" id="L1728">				jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(traceEnd));</span>
			}
		}
<span class="nc bnc" id="L1731" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L1732">			Date adjLastUpdate = new Date(lastUpdate.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L1733">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1734">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1735">			jQuery.setParTimestamp(lastUpdatePos++, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
<span class="nc" id="L1736">			jQuery.setParTimestamp(lastUpdatePos, TimeZoneUtil.toTimestamp(adjLastUpdate));</span>
		}
<span class="nc" id="L1738">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L1739">		return rs;</span>
	}

	/**
	 * Retrieve SGTimeSeries for a Queue, specifying a given period for all Trace Types
	 *
	 * @param Set  , SPID
	 * @param Date , start
	 * @param Date , end
	 * @param Date , lastUpdate
	 * @return Collection, TraceChunk, null if all points are Unkonwn(-1)
	 */
	public static Collection getSGTimeSeriesFromLastUpdate(ID queueID, Set SPIDSet, String mediaDeID, Date start, Date end,
			Date lastUpdate, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L1753">		ArrayList tcArray = new ArrayList();</span>
		try {
			// Anticipate the collection size won't exceed the real days in between start/end
<span class="nc" id="L1756">			int arraySz = 0;</span>
<span class="nc bnc" id="L1757" title="All 4 branches missed.">			if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L1758">				arraySz = TimeZoneUtil.numberOfDays(start, end) + 1;</span>
			}
<span class="nc bnc" id="L1760" title="All 2 branches missed.">			if (arraySz != 0) {</span>
<span class="nc" id="L1761">				tcArray.ensureCapacity(arraySz * Trace.DAYPOINTS);</span>
			}
			// Prepare for select window
<span class="nc" id="L1764">			Date traceStart = getTraceStart(TraceUtil.META_SERVICEGOAL, start);</span>
<span class="nc" id="L1765">			Date traceEnd = getTraceEnd(TraceUtil.META_SERVICEGOAL, end);</span>
<span class="nc" id="L1766">			JdmoRowset rs = getSGTimeSeries(SPIDSet, mediaDeID, start, end, lastUpdate, jdmo, traceStart, traceEnd);</span>
<span class="nc" id="L1767">			convertTraceChunks(rs, TraceUtil.META_SERVICEGOAL, queueID, tcArray, start, end, false, jdmo.isWhatIf());</span>
<span class="nc" id="L1768">			return tcArray;</span>
<span class="nc" id="L1769">		} catch (JdmoException e) {</span>
<span class="nc" id="L1770">			throw e;</span>
<span class="nc" id="L1771">		} catch (Exception e) {</span>
<span class="nc" id="L1772">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L1773">			return tcArray;</span>
		}
	}

	public static Date getTraceStart(TraceCube metaTC, Date start) {
<span class="nc bnc" id="L1778" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc bnc" id="L1779" title="All 6 branches missed.">			if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1780">				return new Date(start.getTime() - TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
			}
		}
<span class="nc" id="L1783">		return start;</span>
	}

	public static Date getTraceEnd(TraceCube metaTC, Date end) {
<span class="nc bnc" id="L1787" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc bnc" id="L1788" title="All 4 branches missed.">			if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1789">				return new Date(end.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
			}
		}
<span class="nc" id="L1792">		return end;</span>
	}

	// non skill based SG load is from Combined Media queue
	private static String getDESelectStmt(Set SPIDSet, String mediaDeID, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L1797">		StringBuilder pStmt = new StringBuilder(15 * TraceUtil.META_SERVICEGOAL.getTraceTypes().length);</span>
		// TODO: add TIMEZONEMAP.JAVATZIDENT in query for DST fix
<span class="nc" id="L1799">		pStmt.append(&quot;select SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, B.SERVICELEVELGOALTYPE from &quot;);</span>
<span class="nc" id="L1800">		pStmt.append(getTraceTable(TraceUtil.META_SERVICEGOAL)).append(&quot; A, SPQUEUE B&quot;);</span>
<span class="nc" id="L1801">		pStmt.append(&quot; where A.SPQUEUEID=B.ID and &quot;);</span>
		// if no skill based, need get the trace from combined media queue instead
<span class="nc" id="L1803">		pStmt.append(&quot;B.ID in (select SPQUEUE.ID from SPQUEUE, SP where SPQUEUE.SPID=SP.ID and SP.SID in &quot;);</span>
<span class="nc" id="L1804">		pStmt.append(jdmo.createInClause(SPIDSet)).append(&quot; and MEDIAID='&quot;);</span>
<span class="nc" id="L1805">		pStmt.append(mediaDeID).append(&quot;' and QUEUEID is null)&quot;);</span>
<span class="nc" id="L1806">		return pStmt.toString();</span>
	}

	/**
	 * direct load for single queue
	 *
	 * @param metaTC
	 * @param jdmo Sets isNoPhantom to false as the default.
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmt(TraceCube metaTC, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L1818">		return getDESelectStmt(metaTC, jdmo, false);</span>
	}

	/**
	 * direct load for single queue
	 *
	 * @param metaTC
	 * @param jdmo
	 * @param isNoPhantom will tell TrackingManager whether to load the &quot;No Phantom&quot; Predicted FTE, Service Level,
	 *                    ASA, and Dials for the same queue(s) being requested.
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmt(TraceCube metaTC, Jdmo jdmo, boolean isNoPhantom) throws JdmoException {
<span class="nc" id="L1832">		StringBuilder pStmt = new StringBuilder(15 * metaTC.getTraceTypes().length);</span>
<span class="nc" id="L1833">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1834">		pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L1835" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1836">			return getDESelectStmtForActualTC(metaTC, jdmo, pStmt, types);</span>
		}
<span class="nc bnc" id="L1838" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L1839">			return getDESelectStmtForForecastTC(metaTC, pStmt, types);</span>
		}
<span class="nc bnc" id="L1841" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1842">			return getDESelectStmtForRequireTC(metaTC, pStmt, types);</span>
		}
<span class="nc bnc" id="L1844" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1845">			return getDESelectStmtForPredictTC(metaTC, isNoPhantom, pStmt,</span>
					types);
		}
<span class="nc bnc" id="L1848" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1849">			return getDESelectStmtForSGTC(metaTC, pStmt);</span>
		}
<span class="nc" id="L1851">		return null;</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @return
	 */
	private static String getDESelectStmtForSGTC(TraceCube metaTC, StringBuilder pStmt) {
		// TODO: add TIMEZONEMAP.JAVATZIDENT in query for DST fix
<span class="nc" id="L1861">		pStmt.append(&quot;SLPERCENT, ASA, B.MAXABANDONSPERCENT, A.DATETIME, B.SERVICELEVELGOALTYPE, MAXDIALS from &quot;);</span>
<span class="nc" id="L1862">		pStmt.append(getTraceTable(metaTC)).append(&quot; A, SPQUEUE B&quot;);</span>
<span class="nc" id="L1863">		pStmt.append(&quot; where A.SPQUEUEID=B.ID and &quot;);</span>
<span class="nc" id="L1864">		pStmt.append(&quot;B.QUEUEID=? &quot;);</span>
<span class="nc" id="L1865">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param isNoPhantom
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForPredictTC(TraceCube metaTC, boolean isNoPhantom, StringBuilder pStmt, short[] types) {

<span class="nc bnc" id="L1877" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L1878" title="All 2 branches missed.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L1879" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
					// bad hack; done for Netstaffing feature. implemeneted
					// as per Jason's directive for performance reasons.
<span class="nc bnc" id="L1882" title="All 3 branches missed.">					switch (types[t]) {</span>
						case Trace.ASTAFFING:
<span class="nc" id="L1884">							pStmt.append(&quot;ISNULL(ASTAFF&quot;).append(i).append(&quot;,STAFFING&quot;).append(i).append(&quot;) ASTAFF&quot;).append(i).append(&quot;,&quot;);</span>
							// ISNULL(ASTAFF,STAFFING) ASTAFF1
<span class="nc" id="L1886">							break;</span>
						case Trace.AFTE:
<span class="nc" id="L1888">							pStmt.append(&quot;ISNULL(AFTE&quot;).append(i).append(&quot;,FTE&quot;).append(i).append(&quot;) AFTE&quot;).append(i).append(&quot;,&quot;);</span>
<span class="nc" id="L1889">							break;</span>
						default:
<span class="nc" id="L1891">							pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
							break;
					}
				}
			}
		}
<span class="nc" id="L1897">		pStmt.append(getDETimeColumn(metaTC, true, isNoPhantom));</span>
<span class="nc" id="L1898">		pStmt.append(&quot;, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;);</span>
<span class="nc" id="L1899">		pStmt.append(getTraceTable(metaTC, isNoPhantom)).append(&quot; A, SPQUEUE B, TIMEZONE, TIMEZONEMAP, CAMPAIGN, SP &quot;);</span>
<span class="nc" id="L1900">		pStmt.append(&quot; where SP.CAMPAIGNID=CAMPAIGN.ID and CAMPAIGN.TIMEZONEID=TIMEZONE.ID&quot;);</span>
<span class="nc" id="L1901">		pStmt.append(&quot; and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME and SP.ID=B.SPID and A.SPQUEUEID=B.ID &quot;);</span>
<span class="nc" id="L1902">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForRequireTC(TraceCube metaTC, StringBuilder pStmt, short[] types) {
<span class="nc bnc" id="L1912" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L1913" title="All 2 branches missed.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L1915">					pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
<span class="nc" id="L1919">		pStmt.append(&quot; A.DATETIME, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;).append(</span>
<span class="nc" id="L1920">				getTraceTable(metaTC));</span>
<span class="nc" id="L1921">		pStmt.append(&quot; A, SPQUEUE B, TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID &quot;);</span>
<span class="nc" id="L1922">		pStmt.append(&quot;AND  CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME &quot;);</span>
<span class="nc" id="L1923">		pStmt.append(&quot;AND SP.ID=B.SPID and B.ID = A.SPQUEUEID and B.QUEUEID=? &quot;);</span>
<span class="nc" id="L1924">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param pStmt
	 * @param types
	 * @return
	 */
	private static String getDESelectStmtForForecastTC(TraceCube metaTC, StringBuilder pStmt, short[] types) {
<span class="nc bnc" id="L1934" title="All 2 branches missed.">		for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L1935" title="All 2 branches missed.">			for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L1936" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L1937">					pStmt.append(getDETraceColumn(types[t])).append(i).append(&quot;,&quot;);</span>
				}
			}
		}
<span class="nc" id="L1941">		pStmt.append(&quot; A.DATETIME, TIMEZONEMAP.JAVATZIDENT, SP.FROMDATE, SP.TODATE , B.SID SPQUEUESID from &quot;).append(</span>
<span class="nc" id="L1942">				getTraceTable(metaTC));</span>
<span class="nc" id="L1943">		pStmt.append(&quot; A, SPQUEUE B, TIMEZONE,TIMEZONEMAP,CAMPAIGN,SP where SP.CAMPAIGNID=CAMPAIGN.ID &quot;);</span>
<span class="nc" id="L1944">		pStmt.append(&quot; and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME&quot;);</span>
<span class="nc" id="L1945">		pStmt.append(&quot; and SP.ID=B.SPID and B.ID = A.SPQUEUEID &quot;);</span>
<span class="nc" id="L1946">		pStmt.append(appendForecastInstanceID(metaTC));</span>
<span class="nc" id="L1947">		return pStmt.toString();</span>
	}

	/**
	 * @param metaTC
	 * @param jdmo
	 * @param pStmt
	 * @param types
	 * @return
	 * @throws JdmoException
	 */
	private static String getDESelectStmtForActualTC(TraceCube metaTC, Jdmo jdmo, StringBuilder pStmt, short[] types) throws JdmoException {
<span class="nc bnc" id="L1959" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1960" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1961">				pStmt.append(getDESelectTraceColumn(jdmo, types[i], metaTC)).append(',');</span>
			}
		}
<span class="nc" id="L1964">		pStmt.append(&quot; TIME from &quot;).append(getTraceTable(metaTC));</span>
<span class="nc" id="L1965">		pStmt.append(&quot; A where QUEUEID=?&quot;);</span>
<span class="nc" id="L1966">		return pStmt.toString();</span>
	}

	// TODO:change the calcComputedTraceValuesForTraceChunk to other place
	// So far this is always called either from reports, or metaTC is an instance of
	// ServiceGoalsTraceCube. 2011-09-08
	private static void convertTraceChunks(JdmoRowset rs, TraceCube metaTC, ID queueID, ArrayList tcArray, Date start, Date end,
			boolean includeAllServiceGoalTypes, boolean isWhatIf) throws JdmoException {
<span class="nc" id="L1974">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L1975">		ID mediaID = TraceOperatorAdapter.getMediaIDForQueue(queueID, isWhatIf);</span>
<span class="nc bnc" id="L1976" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc bnc" id="L1977" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L1978">				TraceChunk tc = new TraceChunk(queueID, TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;)));</span>
<span class="nc" id="L1979">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L1980" title="All 2 branches missed.">				for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L1981" title="All 2 branches missed.">					if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L1982">						tc.setTraceValue(types[i], rs.getFloat(resultSetCounter++));</span>
					}
				}
				// TODO: add computed Method for Tracechunk
<span class="nc" id="L1986">				metaTC.calcComputedTraceValuesForTraceChunk(tc, mediaID);</span>
<span class="nc" id="L1987">				tcArray.add(tc);</span>
<span class="nc" id="L1988">			}</span>
		}
<span class="nc bnc" id="L1990" title="All 6 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
			// calculate the total trace types excluding the computed ones
<span class="nc" id="L1992">			int typeLen = 0;</span>
<span class="nc bnc" id="L1993" title="All 2 branches missed.">			for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L1994" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L1995">					typeLen++;</span>
				}
			}
<span class="nc" id="L1998">			Date prvEndOfDay = null;</span>
<span class="nc bnc" id="L1999" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2000">				DstObject dstObj = new DstObject();</span>
<span class="nc" id="L2001">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L2002">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L2003">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L2004">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
				// used in report dump for individual queues and from pulse UI for history get &amp; update
<span class="nc" id="L2006">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L2007" title="All 2 branches missed.">				if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L2008">					continue;</span>
				}
<span class="nc bnc" id="L2010" title="All 2 branches missed.">				if (dstObj.needNewTraceCube) {</span>
					// Need to initialize the arraylist and clear all the values it is holding
<span class="nc" id="L2012">					tcArray.clear();</span>
				}
<span class="nc" id="L2014">				Date lineStart = dstObj.lineStart;</span>
				// 92 points day, need shrink
<span class="nc" id="L2016">				boolean tfrIn = dstObj.tfrIn;</span>
				// 100 points day, need expand
<span class="nc" id="L2018">				boolean tfrOut = dstObj.tfrOut;</span>
				// track points
<span class="nc" id="L2020">				int dstPoints = dstObj.dstPoints;</span>
				// temp variable to track transition
<span class="nc" id="L2022">				boolean prvDSTFlag = dstObj.prvDSTFlag;</span>

<span class="nc bnc" id="L2024" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L2025" title="All 2 branches missed.">					if (fallsIn(lineStart, start, end)) {</span>
<span class="nc bnc" id="L2026" title="All 6 branches missed.">						if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
							// if transition will happen on this line
<span class="nc bnc" id="L2028" title="All 2 branches missed.">							if (tz.inDaylightTime(lineStart) != prvDSTFlag) {</span>
								// from this point, there is dst transition
<span class="nc" id="L2030">								int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L2031" title="All 2 branches missed.">								if (tfrIn) {</span>
									// skip points
<span class="nc" id="L2033">									i += dstIntv - 1;</span>
<span class="nc bnc" id="L2034" title="All 2 branches missed.">									prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L2035">									continue;</span>
								}
								// add points
<span class="nc bnc" id="L2038" title="All 2 branches missed.">								for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L2039">									TraceChunk tc = new TraceChunk(queueID, lineStart);</span>
<span class="nc bnc" id="L2040" title="All 2 branches missed.">									for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2041">										tc.setTraceValue(types[t], Trace.TRACENA);</span>
									}
<span class="nc" id="L2043">									tcArray.add(tc);</span>
<span class="nc" id="L2044">									lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L2045" title="All 2 branches missed.">									if (lineStart.after(end)) {</span>
<span class="nc" id="L2046">										break;</span>
									}
								}
							}
						}
<span class="nc" id="L2051">						TraceChunk tc = new TraceChunk(queueID, lineStart);</span>
						// this is done to omit the computed types
<span class="nc" id="L2053">						int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2054" title="All 2 branches missed.">						for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L2055" title="All 2 branches missed.">							if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L2056">								tc.setTraceValue(types[idx], rs.getFloat(typeLen * i + resultSetCounter++));</span>
							}
						}
<span class="nc" id="L2059">						metaTC.calcComputedTraceValuesForTraceChunk(tc, mediaID);</span>
<span class="nc" id="L2060">						tcArray.add(tc);</span>
<span class="nc bnc" id="L2061" title="All 2 branches missed.">					} else if (lineStart.after(end)) {</span>
<span class="nc" id="L2062">						break;</span>
					}
<span class="nc bnc" id="L2064" title="All 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L2065">						prvDSTFlag = tz.inDaylightTime(lineStart);</span>
					}
<span class="nc" id="L2067">					lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
				// always save last line's end date
<span class="nc" id="L2070">				prvEndOfDay = lineStart;</span>
<span class="nc" id="L2071">			}</span>
		}
<span class="nc bnc" id="L2073" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc bnc" id="L2074" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L2075">				Date hour = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L2076">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="nc" id="L2077">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>
<span class="nc" id="L2078">				boolean isMaxDialsEnabled = isTypeMaxDialsEnabled(mediaID);</span>
<span class="nc" id="L2079">				TraceChunk tc = new TraceChunk(queueID, hour);</span>
<span class="nc bnc" id="L2080" title="All 2 branches missed.">				if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2081">					tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2082" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2083">						tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					} else {
<span class="nc" id="L2085">						tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
					}
<span class="nc bnc" id="L2087" title="All 2 branches missed.">				} else if (!typeASAEnabled) {</span>
<span class="nc" id="L2088">					tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2089" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2090">						tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					}
				} else {
<span class="nc" id="L2093">					tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}

<span class="nc bnc" id="L2096" title="All 2 branches missed.">				if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2097">					tc.setTraceValue(Trace.MAX_DIALS, rs.getFloat(&quot;MAXDIALS&quot;));</span>
				}

<span class="nc" id="L2100">				tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L2101">				tcArray.add(tc);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L2103" title="All 2 branches missed.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L2104">					TraceChunk tc1 = new TraceChunk(queueID, new Date(hour.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc bnc" id="L2105" title="All 2 branches missed.">					if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2106">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2107" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2108">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						} else {
<span class="nc" id="L2110">							tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
						}
<span class="nc bnc" id="L2112" title="All 2 branches missed.">					} else if (!typeASAEnabled) {</span>
<span class="nc" id="L2113">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2114" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2115">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L2118">						tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L2120">					tc1.setTraceValue(Trace.ABANDONMENT, tc.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc bnc" id="L2121" title="All 2 branches missed.">					if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2122">						tc1.setTraceValue(Trace.MAX_DIALS, tc.getTraceValue(Trace.MAX_DIALS));</span>
					}
<span class="nc" id="L2124">					tcArray.add(tc1);</span>
				}
<span class="nc" id="L2126">			}</span>
		}
<span class="nc" id="L2128">	}</span>

	private static Collection convertActual(JdmoRowset rs, TraceCube metaTC, Collection queueIDCol, Date start, Date end,
			boolean isWhatif) throws Exception {
<span class="nc" id="L2132">		HashMap cubeMap = new HashMap(queueIDCol.size());</span>
<span class="nc" id="L2133">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L2134">		Map queueMediaMap = TraceOperatorAdapter.getMediaForQueues(queueIDCol, isWhatif);</span>
<span class="nc bnc" id="L2135" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2136">			Date insertPoint = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
<span class="nc" id="L2137">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L2138">			TraceCube cube = (TraceCube) cubeMap.get(queueID);</span>
<span class="nc bnc" id="L2139" title="All 2 branches missed.">			if (cube == null) {</span>
<span class="nc" id="L2140">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L2142">			double[] value = new double[types.length];</span>
<span class="nc" id="L2143">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2144" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2145" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2146">					value[i] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L2149">			cube.setTraceValue(types, value, insertPoint);</span>
<span class="nc" id="L2150">			cubeMap.put(queueID, cube);</span>
<span class="nc" id="L2151">		}</span>
<span class="nc bnc" id="L2152" title="All 2 branches missed.">		for (Iterator iterator = cubeMap.values().iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L2153">			TraceCube cube = (TraceCube) iterator.next();</span>
<span class="nc" id="L2154">			cube.calcComputedTraceValues((ID) queueMediaMap.get(cube.getQueueID()));</span>
<span class="nc" id="L2155">		}</span>

<span class="nc" id="L2157">		return cubeMap.values();</span>
	}

	/**
	 * Convert a rowset into a TraceCube of type metaTC.
	 * this method is used in pulse to see the different trace types
	 *
	 * @param rs
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param isWhatif
	 * @param spqueuesBySID
	 * @param isNoPhantom
	 * @return
	 * @throws Exception
	 */
	private static TraceCube convert(JdmoRowset rs, TraceCube metaTC, ID queueID, Date start, Date end,
			boolean includeAllServiceGoalTypes, boolean isWhatif, Map&lt;ID, SPQueue&gt; spqueuesBySID,
			boolean isNoPhantom, Map&lt;ID, Queue&gt; idQueueMap) throws Exception {

<span class="nc" id="L2180">		TraceCube cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
<span class="nc" id="L2181">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L2182">		ID mediaID = null;</span>
<span class="nc bnc" id="L2183" title="All 4 branches missed.">		if (idQueueMap != null &amp;&amp; idQueueMap.get(cube.getQueueID()) != null) {</span>
<span class="nc" id="L2184">			mediaID = idQueueMap.get(cube.getQueueID()).getMediaID();</span>
		} else {
			//inside ejb call to get queue object
<span class="nc" id="L2187">			mediaID = TraceOperatorAdapter.getMediaIDForQueue(cube.getQueueID(), isWhatif);</span>
		}
<span class="nc bnc" id="L2189" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L2190">			convertActualTC(rs, metaTC, cube, types);</span>
		}
<span class="nc bnc" id="L2192" title="All 6 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L2193">			cube = convertForecastPredictRequiredTC(rs, metaTC, queueID, start, end, spqueuesBySID, cube, types, isNoPhantom);</span>
		}
<span class="nc bnc" id="L2195" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L2196">			convertSGTC(rs, queueID, end, includeAllServiceGoalTypes, cube, types, mediaID);</span>
		}
<span class="nc" id="L2198">		cube.calcComputedTraceValues(mediaID);</span>
<span class="nc bnc" id="L2199" title="All 2 branches missed.">		for (short type : cube.getTraceTypes()) {</span>
<span class="nc" id="L2200">			cube.setTypeDirty(type, false);</span>
		}
<span class="nc" id="L2202">		return cube;</span>
	}

	/**
	 * @param rs
	 * @param queueID
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param cube
	 * @param types
	 * @param mediaID
	 * @throws JdmoException
	 */
	private static void convertSGTC(JdmoRowset rs, ID queueID, Date end, boolean includeAllServiceGoalTypes, TraceCube cube, short[] types,
			ID mediaID) throws JdmoException {
		// TODO: this needs to be fixed for DST issues. Sameet, March 2006
		// SKILL Queue, Reqd SVC Level not blank for OCT
<span class="nc bnc" id="L2219" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2220">			Date hour = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L2221">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(&quot;SERVICELEVELGOALTYPE&quot;));</span>
<span class="nc" id="L2222">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(&quot;SERVICELEVELGOALTYPE&quot;));</span>
<span class="nc" id="L2223">			boolean isMaxDialsEnabled = isTypeMaxDialsEnabled(mediaID);</span>
			// hack for ops release. set PCAType to false to always show SL.
<span class="nc" id="L2225">			ArrayList tcList = new ArrayList(4);</span>
<span class="nc" id="L2226">			TraceChunk tc = new TraceChunk(queueID, hour);</span>
<span class="nc bnc" id="L2227" title="All 2 branches missed.">			if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2228">				tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2229" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2230">					tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L2232">					tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc bnc" id="L2234" title="All 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="nc" id="L2235">				tc.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L2236" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2237">					tc.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				}
			} else {
<span class="nc" id="L2240">				tc.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
			}
<span class="nc" id="L2242">			tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc bnc" id="L2243" title="All 2 branches missed.">			if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2244">				tc.setTraceValue(Trace.MAX_DIALS, rs.getFloat(&quot;MAXDIALS&quot;));</span>
			}
<span class="nc" id="L2246">			tcList.add(tc);</span>
			// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L2248" title="All 2 branches missed.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L2249">				Date exStart = new Date(hour.getTime() + i * Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc" id="L2250">				TraceChunk tc1 = new TraceChunk(queueID, exStart);</span>
<span class="nc bnc" id="L2251" title="All 2 branches missed.">				if (exStart.before(end)) {</span>
<span class="nc bnc" id="L2252" title="All 2 branches missed.">					if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L2253">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2254" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2255">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						} else {
<span class="nc" id="L2257">							tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
						}
<span class="nc bnc" id="L2259" title="All 2 branches missed.">					} else if (!typeASAEnabled) {</span>
<span class="nc" id="L2260">						tc1.setTraceValue(Trace.PCA, tc.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L2262">							tc1.setTraceValue(Trace.DEADLINE_TIME, tc.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L2265">						tc1.setTraceValue(Trace.ASA, tc.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L2267">					tc1.setTraceValue(Trace.ABANDONMENT, tc.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc bnc" id="L2268" title="All 2 branches missed.">					if (isMaxDialsEnabled) {</span>
<span class="nc" id="L2269">						tc1.setTraceValue(Trace.MAX_DIALS, tc.getTraceValue(Trace.MAX_DIALS));</span>
					}
<span class="nc" id="L2271">					tcList.add(tc1);</span>
				} else {
					break;
				}
			}
			// now add Chunk back to Cube
<span class="nc bnc" id="L2277" title="All 2 branches missed.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2278">				int[] value = new int[tcList.size()];</span>
<span class="nc" id="L2279">				int i = 0;</span>
<span class="nc bnc" id="L2280" title="All 2 branches missed.">				for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2281">					TraceChunk tc1 = (TraceChunk) it.next();</span>
<span class="nc" id="L2282">					value[i++] = TraceUtil.roundDouble(tc1.getTraceValue(types[t]));</span>
<span class="nc" id="L2283">				}</span>
<span class="nc" id="L2284">				((ServiceGoalTraceCube) cube).initTraceValue(types[t], value, hour);</span>
			}
<span class="nc" id="L2286">		}</span>
<span class="nc" id="L2287">	}</span>

	/**
	 * This method is package private for unit testing
	 *
	 * @param rs
	 * @param metaTC
	 * @param queueID
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param cube
	 * @param types
	 * @return
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	static TraceCube convertForecastPredictRequiredTC(JdmoRowset rs, TraceCube metaTC, ID queueID, Date start, Date end,
			Map&lt;ID, SPQueue&gt; spqueuesBySID, TraceCube cube, short[] types, boolean isNoPhantom)
			throws JdmoException, BbmTimeSeriesException {
<span class="nc" id="L2307">		Date prvEndOfDay = null;</span>
		// calculate the total trace types excluding the computed ones
<span class="nc" id="L2309">		int typeLen = 0;</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L2311" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L2312">				typeLen++;</span>
			}
		}
<span class="nc bnc" id="L2315" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2316">			DstObject dstObj = new DstObject();</span>
<span class="nc" id="L2317">			dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(getDETimeColumn(metaTC, false, isNoPhantom)));</span>
<span class="nc" id="L2318">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L2319">			dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L2320">			dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L2321">			dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);// tested</span>
<span class="nc bnc" id="L2322" title="All 2 branches missed.">			if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L2323">				continue;</span>
			}
<span class="nc bnc" id="L2325" title="All 2 branches missed.">			if (dstObj.needNewTraceCube) {</span>
<span class="nc" id="L2326">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L2328">			cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="nc" id="L2329">			ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="nc" id="L2330">			cube.setSPQueueSID(spQueueSID);</span>
<span class="nc" id="L2331">			SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="nc bnc" id="L2332" title="All 2 branches missed.">			if (spq != null) {</span>
<span class="nc" id="L2333">				cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="nc" id="L2334">				cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="nc" id="L2335">				cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
			}
<span class="nc" id="L2337">			Date currentIntervalStart = dstObj.lineStart;</span>
<span class="nc" id="L2338">			Date cubeInsertPoint = new Date(dstObj.lineStart.getTime());</span>
			// 92 points day, need shrink
<span class="nc" id="L2340">			boolean tfrIn = dstObj.tfrIn;</span>
			// 100 points day, need expand
<span class="nc" id="L2342">			boolean tfrOut = dstObj.tfrOut;</span>
			// track points
<span class="nc" id="L2344">			int dstPoints = dstObj.dstPoints;</span>
			// temp variable to track transition
<span class="nc" id="L2346">			boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc" id="L2347">			Date endOfDay = dstObj.endOfDay;</span>
<span class="nc" id="L2348">			boolean init = false;</span>
<span class="nc" id="L2349">			double[][] values = new double[types.length][];</span>
<span class="nc" id="L2350">			int arrIdx = 0;</span>
<span class="nc" id="L2351">			int arrSz = 0;</span>
<span class="nc bnc" id="L2352" title="All 2 branches missed.">			for (int rsIdx = 0; rsIdx &lt; Trace.DAYPOINTS; rsIdx++) {</span>
<span class="nc bnc" id="L2353" title="All 4 branches missed.">				if (fallsIn(currentIntervalStart, start, end) || fallsIn(currentIntervalStart, start, endOfDay)) {</span>
<span class="nc bnc" id="L2354" title="All 2 branches missed.">					if (!init) {</span>
<span class="nc" id="L2355">						cubeInsertPoint = currentIntervalStart;</span>
<span class="nc" id="L2356">						arrSz = Trace.DAYPOINTS;</span>
<span class="nc bnc" id="L2357" title="All 2 branches missed.">						if (tfrOut) {</span>
<span class="nc" id="L2358">							arrSz = arrSz + dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2360" title="All 2 branches missed.">						if (tfrIn) {</span>
<span class="nc" id="L2361">							arrSz = arrSz - dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2363" title="All 2 branches missed.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2364">							values[t] = new double[arrSz];</span>
						}
<span class="nc" id="L2366">						init = true;</span>
					}

<span class="nc bnc" id="L2369" title="All 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="nc bnc" id="L2371" title="All 2 branches missed.">						if (tz.inDaylightTime(currentIntervalStart) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="nc" id="L2373">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L2374" title="All 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="nc" id="L2376">								rsIdx += dstIntv - 1;</span>
<span class="nc bnc" id="L2377" title="All 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>

<span class="nc bnc" id="L2379" title="All 2 branches missed.">								if (dstObj.isLineStartInPartialTransition) {</span>
									//Adjust currentIntervalStart accordingly so we don't exit the loop prematurely
<span class="nc" id="L2381">									currentIntervalStart = new Date(currentIntervalStart.getTime()</span>
										- ((Trace.HOURPOINTS - dstIntv) * Trace.INTERVAL_IN_MILLIS));
								}
								continue;
							}
							// add points
<span class="nc bnc" id="L2387" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L2388" title="All 2 branches missed.">								for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2389">									values[t][arrIdx] = Trace.TRACENA;</span>
								}
<span class="nc" id="L2391">								arrIdx++;</span>
<span class="nc" id="L2392">								currentIntervalStart = new Date(currentIntervalStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L2393" title="All 2 branches missed.">								if (currentIntervalStart.after(end)) {</span>
<span class="nc" id="L2394">									break;</span>
								}
							}
						}
					}
<span class="nc bnc" id="L2399" title="All 2 branches missed.">					if (!init) {</span>
<span class="nc" id="L2400">						cubeInsertPoint = currentIntervalStart;</span>
<span class="nc" id="L2401">						arrSz = Trace.DAYPOINTS - rsIdx;</span>
<span class="nc bnc" id="L2402" title="All 2 branches missed.">						if (tfrOut) {</span>
<span class="nc" id="L2403">							arrSz = arrSz + dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2405" title="All 2 branches missed.">						if (tfrIn) {</span>
<span class="nc" id="L2406">							arrSz = arrSz - dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
						}
<span class="nc bnc" id="L2408" title="All 2 branches missed.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2409">							values[t] = new double[arrSz];</span>
						}
<span class="nc" id="L2411">						init = true;</span>
					}
					// this is done to omit the computed types
<span class="nc" id="L2414">					int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2415" title="All 2 branches missed.">					for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L2416" title="All 2 branches missed.">						if (!metaTC.isTraceTypeComputed(types[t])) {</span>
<span class="nc" id="L2417">							values[t][arrIdx] = rs.getFloat(typeLen * rsIdx + resultSetCounter++);</span>
						}
					}
<span class="nc" id="L2420">					arrIdx++;</span>
				}
<span class="nc bnc" id="L2422" title="All 4 branches missed.">				if (currentIntervalStart.after(end) &amp;&amp; currentIntervalStart.after(endOfDay)) {</span>
<span class="nc" id="L2423">					break;</span>
				}
<span class="nc bnc" id="L2425" title="All 4 branches missed.">				if (tfrIn || tfrOut) {</span>
<span class="nc" id="L2426">					prvDSTFlag = tz.inDaylightTime(currentIntervalStart);</span>
				}
<span class="nc" id="L2428">				currentIntervalStart = new Date(currentIntervalStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
<span class="nc bnc" id="L2430" title="All 2 branches missed.">			if (endOfDay.getTime() &gt; end.getTime()){</span>
<span class="nc" id="L2431">				shrinkValues(types, values, arrIdx);</span>
			}
<span class="nc bnc" id="L2433" title="All 2 branches missed.">			for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L2434">				cube.setTraceValue(types[t], values[t], getInsertionDate(prvEndOfDay, cubeInsertPoint, dstObj));</span>
			}
<span class="nc" id="L2436">			prvEndOfDay = currentIntervalStart;</span>
<span class="nc" id="L2437">		}</span>
<span class="nc" id="L2438">		return cube;</span>
	}

	private static Date getInsertionDate(Date prvEndOfDay, Date cubeInsertPoint, DstObject dstObj) {
<span class="nc" id="L2442">		Date resultDate = cubeInsertPoint;</span>
<span class="nc bnc" id="L2443" title="All 6 branches missed.">		if (prvEndOfDay != null &amp;&amp; prvEndOfDay.before(cubeInsertPoint) &amp;&amp; dstObj.isLineStartInPartialTransition) {</span>
<span class="nc" id="L2444">			resultDate = prvEndOfDay;</span>
		}
<span class="nc" id="L2446">		return resultDate;</span>
	}

	private static void shrinkValues(short[] types, double[][] values, int idx) {
<span class="nc bnc" id="L2450" title="All 2 branches missed.">		for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L2451" title="All 2 branches missed.">			int noDataPeriods = (int) Arrays.stream(values[t]).filter(value -&gt; value == Trace.TRACENA).count();</span>
<span class="nc" id="L2452">			int periods = idx - noDataPeriods;</span>
<span class="nc" id="L2453">			double[] value = new double[periods];</span>
<span class="nc" id="L2454">			System.arraycopy(values[t], noDataPeriods, value, 0, periods);</span>
<span class="nc" id="L2455">			values[t] = value;</span>
		}
<span class="nc" id="L2457">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param cube
	 * @param types
	 * @throws JdmoException
	 */
	private static void convertActualTC(JdmoRowset rs, TraceCube metaTC, TraceCube cube, short[] types) throws JdmoException {
<span class="nc bnc" id="L2467" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2468">			Date insertPoint = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
<span class="nc" id="L2469">			double[] value = new double[types.length];</span>
<span class="nc" id="L2470">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L2471" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2472" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2473">					value[i] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L2476">			cube.setTraceValue(types, value, insertPoint);</span>
<span class="nc" id="L2477">		}</span>
<span class="nc" id="L2478">	}</span>

	private static boolean queueFallsIn(ID queueID, Date time, Map spQMap, Map spTimeRangeMap) {
<span class="nc bnc" id="L2481" title="All 2 branches missed.">		for (Iterator it = spTimeRangeMap.keySet().iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L2482">			ID spID = (ID) it.next();</span>
<span class="nc" id="L2483">			Date[] range = (Date[]) spTimeRangeMap.get(spID);</span>
<span class="nc bnc" id="L2484" title="All 2 branches missed.">			if (fallsIn(time, range[0], range[1])) {</span>
<span class="nc" id="L2485">				Collection queueIDCol = (Collection) spQMap.get(spID);</span>
<span class="nc bnc" id="L2486" title="All 2 branches missed.">				if (queueIDCol.contains(queueID)) {</span>
<span class="nc" id="L2487">					return true;</span>
				}
			}
<span class="nc" id="L2490">		}</span>
<span class="nc" id="L2491">		return false;</span>
	}

	protected static boolean fallsIn(Date point, Date start, Date end) {
<span class="nc bnc" id="L2495" title="All 2 branches missed.">		if (start == null) {</span>
<span class="nc bnc" id="L2496" title="All 2 branches missed.">			if (end != null) {</span>
<span class="nc bnc" id="L2497" title="All 2 branches missed.">				return !point.after(end);</span>
			}
		} else {
<span class="nc bnc" id="L2500" title="All 2 branches missed.">			if (!point.before(start)) {</span>
<span class="nc bnc" id="L2501" title="All 2 branches missed.">				if (end != null) {</span>
<span class="nc bnc" id="L2502" title="All 2 branches missed.">					return !point.after(end);</span>
				}
			} else {
<span class="nc" id="L2505">				return false;</span>
			}
		}
<span class="nc" id="L2508">		return true;</span>
	}

	private static boolean existingRow(ID queueID, Date start, Jdmo jdmo) throws JdmoException {
<span class="nc bnc" id="L2512" title="All 4 branches missed.">		if (m_ignoreFutureData &amp;&amp; start.after(new Date())) {</span>
<span class="nc" id="L2513">			return false;</span>
		}
<span class="nc" id="L2515">		StringBuilder pStmt = new StringBuilder(&quot;select QUEUEID from &quot;);</span>
<span class="nc" id="L2516">		pStmt.append(ACTUALTRACETABLENAME).append(&quot; where TIME=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L2517">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2518">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2519">		jQuery.setParID(2, queueID);</span>
<span class="nc" id="L2520">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2521">		boolean exists = false;</span>
<span class="nc bnc" id="L2522" title="All 2 branches missed.">		if (rs.next()) {</span>
<span class="nc" id="L2523">			exists = true;</span>
		}
<span class="nc" id="L2525">		rs.close();</span>
<span class="nc" id="L2526">		return exists;</span>
	}

	/**
	 * Note that Timestamp extends Date but cannot be compared to an instance of
	 * Date. Code that needs to compare the returned Timestamps to Dates should
	 * first convert them to Date objects.
	 *
	 * @param queueID
	 * @param start
	 * @param end
	 * @param jdmo
	 * @return
	 * @throws JdmoException
	 * @see java.sql.Timestamp
	 */
	static Set&lt;Timestamp&gt; existingRow(ID queueID, Date start, Date end, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2543">		StringBuilder pStmt = new StringBuilder(&quot;select TIME from &quot;);</span>
<span class="nc" id="L2544">		pStmt.append(ACTUALTRACETABLENAME).append(&quot; where TIME&gt;=? and TIME&lt;=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L2545">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2546">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2547">		jQuery.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L2548">		jQuery.setParID(3, queueID);</span>
<span class="nc" id="L2549">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2550">		Set&lt;Timestamp&gt; timeSet = new HashSet();</span>
<span class="nc bnc" id="L2551" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2552">			timeSet.add(rs.getTimestamp(1));</span>
		}
<span class="nc" id="L2554">		rs.close();</span>
<span class="nc" id="L2555">		return timeSet;</span>
	}

	private static Set&lt;ID&gt; existingRows(Collection queueIDCol, Date start, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2559">		HashSet&lt;ID&gt; queIDSet = new HashSet(queueIDCol.size());</span>
<span class="nc bnc" id="L2560" title="All 4 branches missed.">		if (m_ignoreFutureData &amp;&amp; start.after(new Date())) {</span>
<span class="nc" id="L2561">			return queIDSet;</span>
		}
<span class="nc" id="L2563">		StringBuilder pStmt = new StringBuilder(&quot;select B.SID from &quot;);</span>
<span class="nc" id="L2564">		pStmt.append(ACTUALTRACETABLENAME).append(&quot; A, QUEUE B where A.TIME=? and A.QUEUEID=B.ID and B.SID in &quot;);</span>
<span class="nc" id="L2565">		pStmt.append(jdmo.createInClause(queueIDCol));</span>
<span class="nc" id="L2566">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2567">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L2568">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="nc bnc" id="L2570" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2571">			queIDSet.add(rs.getID(1));</span>
		}
<span class="nc" id="L2573">		return queIDSet;</span>
	}

	private static Set&lt;Date&gt; existingActualRows(ID queueID, Date start, Date end, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2577">		StringBuilder pStmt = new StringBuilder(&quot;select TIME from &quot;);</span>
<span class="nc" id="L2578">		pStmt.append(ACTUALTRACETABLENAME).append(&quot; where TIME&gt;=? and TIME&lt;=? and QUEUEID=(select ID from QUEUE where SID=?)&quot;);</span>
<span class="nc" id="L2579">		JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L2580">		jQuery.setParTimestamp(1, TimeZoneUtil.toTimestamp(TraceUtil.snapDate(start)));</span>
<span class="nc" id="L2581">		jQuery.setParTimestamp(2, TimeZoneUtil.toTimestamp(TraceUtil.snapDate(end)));</span>
<span class="nc" id="L2582">		jQuery.setParID(3, queueID);</span>
<span class="nc" id="L2583">		JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L2584">		Set&lt;Date&gt; timeSet = new HashSet();</span>
<span class="nc bnc" id="L2585" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L2586">			timeSet.add(TimeZoneUtil.toDate(rs.getTimestamp(1)));</span>
		}
<span class="nc" id="L2588">		return timeSet;</span>
	}

	/**
	 * For a particular StartDate, need update the existing Trace
	 *
	 * @param TraceChunk
	 * @param Jdmo
	 */
	static void updateChunkForActual(TraceChunk chunk, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2598">		StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L2599">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc" id="L2600">		iStmt.append(&quot;update &quot;).append(getTraceTable(cube)).append(&quot; set &quot;);</span>
<span class="nc" id="L2601">		short[] types = chunk.getTraceTypes();</span>
		// add parameters for Start
<span class="nc bnc" id="L2603" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2604" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2605">				iStmt.append(getDETraceColumn(types[i])).append(&quot;=&quot;).append(chunk.getTraceValue(types[i])).append(&quot;, &quot;);</span>
			}
		}
<span class="nc" id="L2608">		iStmt.append(&quot;MODIFIED='&quot;).append(JdmoUtil.formatDBString(new Date())).append(&quot;' where TIME='&quot;);</span>
<span class="nc" id="L2609">		iStmt.append(JdmoUtil.formatDBString(chunk.getStartDate()));</span>
<span class="nc" id="L2610">		iStmt.append(&quot;' and QUEUEID=(select ID from QUEUE where SID=&quot;).append(chunk.getQueueID()).append(&quot;)&quot;);</span>
<span class="nc" id="L2611">		jdmo.addBatch(iStmt.toString());</span>
<span class="nc" id="L2612">	}</span>

	/**
	 * For a particular StartDate, need create the new Trace
	 *
	 * @param TraceChunk
	 * @param Jdmo
	 */
	static void createChunkForActual(TraceChunk chunk, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L2621">		StringBuilder iStmt = new StringBuilder(500);</span>
<span class="nc" id="L2622">		ActualTraceCube cube = new ActualTraceCube();</span>
<span class="nc" id="L2623">		iStmt.append(&quot;insert into &quot;).append(getTraceTable(cube));</span>
<span class="nc" id="L2624">		iStmt.append(&quot; (QUEUEID, TIME, &quot;);</span>
<span class="nc" id="L2625">		StringBuilder vStmt = new StringBuilder(200);</span>
<span class="nc" id="L2626">		vStmt.append(&quot; select ID,&quot;);</span>
<span class="nc" id="L2627">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(chunk.getStartDate())).append(&quot;',&quot;);</span>
<span class="nc" id="L2628">		short[] types = chunk.getTraceTypes();</span>
<span class="nc bnc" id="L2629" title="All 2 branches missed.">		for (short i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L2630" title="All 2 branches missed.">			if (!cube.isTraceTypeComputed(types[i])) {</span>
<span class="nc" id="L2631">				iStmt.append(getDETraceColumn(types[i])).append(&quot;, &quot;);</span>
<span class="nc" id="L2632">				vStmt.append(chunk.getTraceValue(types[i])).append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L2635">		iStmt.append(&quot;MODIFIED)&quot;);</span>
<span class="nc" id="L2636">		vStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(new Date()));</span>
<span class="nc" id="L2637">		vStmt.append(&quot;' from QUEUE where SID=&quot;).append(chunk.getQueueID());</span>
<span class="nc" id="L2638">		iStmt.append(vStmt);</span>
<span class="nc" id="L2639">		jdmo.addBatch(iStmt.toString());</span>

<span class="nc" id="L2641">	}</span>

	/**
	 * Internal routine to return TraceColumn names
	 */
	public static StringBuilder getDETraceColumn(short type) {
<span class="nc" id="L2647">		StringBuilder column = new StringBuilder(14);</span>
<span class="nc bnc" id="L2648" title="All 20 branches missed.">		switch (type) {</span>
			case Trace.CV:
<span class="nc" id="L2650">				column.append(&quot;CALLVOLUME&quot;);</span>
<span class="nc" id="L2651">				break;</span>
			case Trace.AHT:
<span class="nc" id="L2653">				column.append(&quot;AHT&quot;);</span>
<span class="nc" id="L2654">				break;</span>
			case Trace.PCA:
<span class="nc" id="L2656">				column.append(&quot;SERVICELEVEL&quot;);</span>
<span class="nc" id="L2657">				break;</span>
			case Trace.ASA:
<span class="nc" id="L2659">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2660">				break;</span>
			case Trace.ABANDONMENT:
<span class="nc" id="L2662">				column.append(&quot;ABANDONS&quot;);</span>
<span class="nc" id="L2663">				break;</span>
			case Trace.BACKLOG:
<span class="nc" id="L2665">				column.append(&quot;BACKLOG&quot;);</span>
<span class="nc" id="L2666">				break;</span>
			case Trace.STAFFING:
<span class="nc" id="L2668">				column.append(&quot;STAFFING&quot;);</span>
<span class="nc" id="L2669">				break;</span>
			case Trace.OCCUPANCY:
<span class="nc" id="L2671">				column.append(&quot;OCCUPANCY&quot;);</span>
<span class="nc" id="L2672">				break;</span>
			case Trace.FTE:
<span class="nc" id="L2674">				column.append(&quot;FTE&quot;);</span>
<span class="nc" id="L2675">				break;</span>
			case Trace.DIALS:
<span class="nc" id="L2677">				column.append(&quot;DIALS&quot;);</span>
<span class="nc" id="L2678">				break;</span>
			case Trace.CONNECTS:
<span class="nc" id="L2680">				column.append(&quot;CONNECTS&quot;);</span>
<span class="nc" id="L2681">				break;</span>
			case Trace.CRATE:
<span class="nc" id="L2683">				column.append(&quot;CRATE&quot;);</span>
<span class="nc" id="L2684">				break;</span>
			case Trace.RPC:
<span class="nc" id="L2686">				column.append(&quot;RPC&quot;);</span>
<span class="nc" id="L2687">				break;</span>
			case Trace.RPCRATE:
<span class="nc" id="L2689">				column.append(&quot;RPCRATE&quot;);</span>
<span class="nc" id="L2690">				break;</span>
			case Trace.RPCAHT:
<span class="nc" id="L2692">				column.append(&quot;RPCAHT&quot;);</span>
<span class="nc" id="L2693">				break;</span>
			case Trace.VH:
<span class="nc" id="L2695">				column.append(&quot;VH&quot;);</span>
<span class="nc" id="L2696">				break;</span>
			case Trace.DEADLINE_TIME:
<span class="nc" id="L2698">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2699">				break;</span>
			case Trace.ASTAFFING:
<span class="nc" id="L2701">				column.append(&quot;ASTAFF&quot;);</span>
<span class="nc" id="L2702">				break;</span>
			case Trace.AFTE:
<span class="nc" id="L2704">				column.append(&quot;AFTE&quot;);</span>
<span class="nc" id="L2705">				break;</span>
			default:
<span class="nc" id="L2707">				return null;</span>
		}
<span class="nc" id="L2709">		return column;</span>
	}

	private static StringBuilder getDESelectTraceColumn(Jdmo jdmo, short type, TraceCube metaTC) throws JdmoException {
<span class="nc" id="L2713">		StringBuilder column = new StringBuilder(25);</span>
<span class="nc" id="L2714">		column.append(jdmo.getNullFunctionName()).append(&quot;(&quot;);</span>
<span class="nc" id="L2715">		StringBuilder sbTraceCol = getDETraceColumn(type);</span>
<span class="nc bnc" id="L2716" title="All 2 branches missed.">		if (sbTraceCol == null) {</span>
<span class="nc" id="L2717">			return null;</span>
		}
<span class="nc" id="L2719">		column.append(sbTraceCol);</span>
<span class="nc" id="L2720">		column.append(&quot;,&quot;).append(Trace.TRACENA).append(&quot;)&quot;);</span>
<span class="nc" id="L2721">		return column;</span>
	}

	/**
	 * Internal routine to return TraceColumn names that are used for the
	 * reportdump table and utility. this has nothing to do directly with PULSE
	 * tables
	 */
	private static StringBuilder getTraceColumn(short type) {
<span class="nc" id="L2730">		StringBuilder column = new StringBuilder(14);</span>
<span class="nc bnc" id="L2731" title="All 22 branches missed.">		switch (type) {</span>
			case Trace.CV:
<span class="nc" id="L2733">				column.append(&quot;CV&quot;);</span>
<span class="nc" id="L2734">				break;</span>
			case Trace.AHT:
<span class="nc" id="L2736">				column.append(&quot;AHT&quot;);</span>
<span class="nc" id="L2737">				break;</span>
			case Trace.PCA:
<span class="nc" id="L2739">				column.append(&quot;PCA&quot;);</span>
<span class="nc" id="L2740">				break;</span>
			case Trace.ASA:
<span class="nc" id="L2742">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2743">				break;</span>
			case Trace.ABANDONMENT:
<span class="nc" id="L2745">				column.append(&quot;ABANDONMENT&quot;);</span>
<span class="nc" id="L2746">				break;</span>
			case Trace.BACKLOG:
<span class="nc" id="L2748">				column.append(&quot;BACKLOG&quot;);</span>
<span class="nc" id="L2749">				break;</span>
			case Trace.STAFFING:
<span class="nc" id="L2751">				column.append(&quot;STAFFING&quot;);</span>
<span class="nc" id="L2752">				break;</span>
			case Trace.OCCUPANCY:
<span class="nc" id="L2754">				column.append(&quot;OCCUPANCY&quot;);</span>
<span class="nc" id="L2755">				break;</span>
			case Trace.FTE:
<span class="nc" id="L2757">				column.append(&quot;FTE&quot;);</span>
<span class="nc" id="L2758">				break;</span>
			case Trace.DIALS:
<span class="nc" id="L2760">				column.append(&quot;DIALS&quot;);</span>
<span class="nc" id="L2761">				break;</span>
			case Trace.CONNECTS:
<span class="nc" id="L2763">				column.append(&quot;CONNECTS&quot;);</span>
<span class="nc" id="L2764">				break;</span>
			case Trace.CRATE:
<span class="nc" id="L2766">				column.append(&quot;CRATE&quot;);</span>
<span class="nc" id="L2767">				break;</span>
			case Trace.RPC:
<span class="nc" id="L2769">				column.append(&quot;RPC&quot;);</span>
<span class="nc" id="L2770">				break;</span>
			case Trace.RPCRATE:
<span class="nc" id="L2772">				column.append(&quot;RPCRATE&quot;);</span>
<span class="nc" id="L2773">				break;</span>
			case Trace.RPCAHT:
<span class="nc" id="L2775">				column.append(&quot;RPCAHT&quot;);</span>
<span class="nc" id="L2776">				break;</span>
			case Trace.VH:
<span class="nc" id="L2778">				column.append(&quot;VH&quot;);</span>
<span class="nc" id="L2779">				break;</span>
			case Trace.VAR:
<span class="nc" id="L2781">				column.append(&quot;VAR&quot;);</span>
<span class="nc" id="L2782">				break;</span>
			case Trace.CV_VH:
<span class="nc" id="L2784">				column.append(&quot;CV_VH&quot;);</span>
<span class="nc" id="L2785">				break;</span>
			case Trace.DEADLINE_TIME:
<span class="nc" id="L2787">				column.append(&quot;ASA&quot;);</span>
<span class="nc" id="L2788">				break;</span>
			case Trace.ASTAFFING:
<span class="nc" id="L2790">				column.append(&quot;ASTAFF&quot;);</span>
<span class="nc" id="L2791">				break;</span>
			case Trace.AFTE:
<span class="nc" id="L2793">				column.append(&quot;AFTE&quot;);</span>
<span class="nc" id="L2794">				break;</span>
			default:
<span class="nc" id="L2796">				return null;</span>
		}
<span class="nc" id="L2798">		return column;</span>
	}

	private static String getDETimeColumn(TraceCube tc, boolean needPrefix, boolean isNoPhantom) {
<span class="nc bnc" id="L2802" title="All 2 branches missed.">		if (isNoPhantom) {</span>
<span class="nc bnc" id="L2803" title="All 2 branches missed.">			if (needPrefix) {</span>
<span class="nc" id="L2804">				return &quot;A.TIMESERIESDATE&quot;;</span>
			}
<span class="nc" id="L2806">			return &quot;TIMESERIESDATE&quot;;</span>
<span class="nc bnc" id="L2807" title="All 8 branches missed.">		} else if (tc instanceof ForecastTraceCube || tc instanceof PredictTraceCube || tc instanceof RequireTraceCube</span>
				|| tc instanceof ServiceGoalTraceCube) {
<span class="nc bnc" id="L2809" title="All 2 branches missed.">			if (needPrefix) {</span>
<span class="nc" id="L2810">				return &quot;A.DATETIME&quot;;</span>
			}
<span class="nc" id="L2812">			return &quot;DATETIME&quot;;</span>
		}
<span class="nc" id="L2814">		return &quot;TIME&quot;;</span>
	}

	private static String getTraceTable(TraceCube tc) {
<span class="nc" id="L2818">		return getTraceTable(tc, false);</span>
	}

	static String getTraceTable(TraceCube tc, boolean isNoPhantom) {
<span class="nc bnc" id="L2822" title="All 4 branches missed.">		if (isNoPhantom &amp;&amp; tc instanceof PredictTraceCube) {</span>
<span class="nc" id="L2823">			return PREDICTNOPHANTOMTRACETABLENAME;</span>
		}
<span class="nc bnc" id="L2825" title="All 2 branches missed.">		if (tc instanceof ForecastTraceCube) {</span>
<span class="nc" id="L2826">			return FORECASTTRACETABLENAME;</span>
		}
<span class="nc bnc" id="L2828" title="All 2 branches missed.">		if (tc instanceof PredictTraceCube) {</span>
<span class="nc" id="L2829">			return PREDICTTRACETABLENAME;</span>
		}
<span class="nc bnc" id="L2831" title="All 2 branches missed.">		if (tc instanceof RequireTraceCube) {</span>
<span class="nc" id="L2832">			return REQUIRETRACETABLENAME;</span>
		}
<span class="nc bnc" id="L2834" title="All 2 branches missed.">		if (tc instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L2835">			return SERVICEGOALTRACETABLENAME;</span>
		}
<span class="nc bnc" id="L2837" title="All 2 branches missed.">		if (tc instanceof ActualTraceCube) {</span>
<span class="nc" id="L2838">			return ACTUALTRACETABLENAME;</span>
		}
<span class="nc" id="L2840">		return null;</span>
	}

	// combine new line to existing trace chunk
	private static TraceChunk combineRpt(short[] types, Date time, List&lt;float[]&gt; lines) {
<span class="nc" id="L2845">		TraceChunk chunk = new TraceChunk(null, time);</span>
		try {
<span class="nc bnc" id="L2847" title="All 2 branches missed.">			for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L2848">				short type = types[i];</span>
<span class="nc" id="L2849">				chunk.setTraceValue(type, 0);</span>
<span class="nc bnc" id="L2850" title="All 8 branches missed.">				switch (type) {</span>
					// CV/Backlog is Sum(type)
					case Trace.CV:
					case Trace.BACKLOG:
					case Trace.ABANDONMENT:
					case Trace.FTE:
					case Trace.AFTE:
					case Trace.DIALS:
					case Trace.RPC:
					case Trace.CONNECTS:
					case Trace.VAR:
					case Trace.CV_VH:
<span class="nc" id="L2862">						float value = 0;</span>
<span class="nc bnc" id="L2863" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc bnc" id="L2864" title="All 2 branches missed.">							if (newLine[type] &gt; 0) {</span>
<span class="nc" id="L2865">								value += newLine[type];</span>
							}
<span class="nc" id="L2867">						}</span>
<span class="nc" id="L2868">						chunk.setTraceValue(type, value);</span>
<span class="nc" id="L2869">						break;</span>
					case Trace.VH:
<span class="nc" id="L2871">						float valueVH = 0;</span>
<span class="nc bnc" id="L2872" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">							if (newLine[type] &gt;= 0) {</span>
<span class="nc" id="L2874">								valueVH += newLine[type];</span>
							} else {
								// abondon the combine since one queue is empty and we need all valid
<span class="nc" id="L2877">								valueVH = Trace.TRACENA;</span>
<span class="nc" id="L2878">								break;</span>
							}
<span class="nc" id="L2880">						}</span>
<span class="nc" id="L2881">						chunk.setTraceValue(type, valueVH);</span>
<span class="nc" id="L2882">						break;</span>
						// AHT/PCA is Sum(CV*type)/Sum(CV)
					case Trace.AHT:
					case Trace.PCA:
					case Trace.DEADLINE_TIME: {
<span class="nc" id="L2887">						float aggVAR = 0;</span>
<span class="nc" id="L2888">						float aggVal = 0;</span>
<span class="nc" id="L2889">						short type_VAR_CVVH = 0;</span>
<span class="nc bnc" id="L2890" title="All 4 branches missed.">						if (type == Trace.PCA || type == Trace.DEADLINE_TIME) {</span>
<span class="nc" id="L2891">							type_VAR_CVVH = Trace.VAR;</span>
<span class="nc bnc" id="L2892" title="All 2 branches missed.">						} else if (type == Trace.AHT) {</span>
<span class="nc bnc" id="L2893" title="All 2 branches missed.">							type_VAR_CVVH = Trace.isVolumeHandledEnabled() ? Trace.VH : Trace.CV;</span>
						}
<span class="nc bnc" id="L2895" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L2896">							float val = newLine[type];</span>
<span class="nc" id="L2897">							float var = newLine[type_VAR_CVVH];</span>
							// for outbound we need Connects instead of CV
<span class="nc bnc" id="L2899" title="All 2 branches missed.">							if (type == Trace.AHT) {</span>
								// if values is less than zero then try CV
<span class="nc bnc" id="L2901" title="All 2 branches missed.">								if (var &lt; 0) {</span>
<span class="nc" id="L2902">									var = newLine[Trace.CV];</span>
								}
								// if value is still zero try Connects
<span class="nc bnc" id="L2905" title="All 2 branches missed.">								if (var &lt; 0) {</span>
<span class="nc" id="L2906">									var = newLine[Trace.CONNECTS];</span>
								}
							}
<span class="nc bnc" id="L2909" title="All 4 branches missed.">							if (var == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L2910">								continue;</span>
							}
							// PCA in percentage if it exceeds 100, that's invalid point
<span class="nc bnc" id="L2913" title="All 2 branches missed.">							if (type == Trace.PCA) {</span>
<span class="nc bnc" id="L2914" title="All 4 branches missed.">								if (val &gt; 100 || val &lt; 0) {</span>
<span class="nc" id="L2915">									continue;</span>
								}
							}
<span class="nc" id="L2918">							aggVal += var * val;</span>
<span class="nc" id="L2919">							aggVAR += var;</span>
<span class="nc" id="L2920">						}</span>
<span class="nc bnc" id="L2921" title="All 2 branches missed.">						if (aggVAR &gt; 0) {</span>
							// Fix for issue where both values are 0 so the combined q shld be 0 required for virtual / dist queues
<span class="nc" id="L2923">							chunk.setTraceValue(type, (aggVal / aggVAR));</span>
						}
						break;
					}
					case Trace.RPCAHT: {
<span class="nc" id="L2928">						float aggCV = 0;</span>
<span class="nc" id="L2929">						float aggAHT_PCA = 0;</span>
<span class="nc bnc" id="L2930" title="All 2 branches missed.">						short type_CV_Connects_RPC = (type != Trace.RPCAHT ? Trace.CV : Trace.RPC);</span>
<span class="nc bnc" id="L2931" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L2932">							float val = newLine[type];</span>
<span class="nc" id="L2933">							float cv = newLine[type_CV_Connects_RPC];</span>
<span class="nc bnc" id="L2934" title="All 4 branches missed.">							if (cv == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L2935">								continue;</span>
							}
<span class="nc" id="L2937">							aggAHT_PCA += cv * val;</span>
<span class="nc" id="L2938">							aggCV += cv;</span>
<span class="nc" id="L2939">						}</span>
<span class="nc bnc" id="L2940" title="All 2 branches missed.">						if (aggCV &gt; 0) {</span>
<span class="nc" id="L2941">							chunk.setTraceValue(type, aggAHT_PCA / aggCV);</span>
						}
						break;
					}
					// ASA is Sum((CV-ABN)*ASA)/Sum(CV-ABN)
					case Trace.ASA:
<span class="nc" id="L2947">						float aggABN = 0;</span>
<span class="nc" id="L2948">						float aggASA = 0;</span>
<span class="nc bnc" id="L2949" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L2950">							float cv = newLine[Trace.CV];</span>
<span class="nc" id="L2951">							float abn = newLine[Trace.ABANDONMENT];</span>
<span class="nc" id="L2952">							float val = newLine[type];</span>
<span class="nc bnc" id="L2953" title="All 6 branches missed.">							if (val == Trace.TRACENA || cv == Trace.TRACENA || abn == Trace.TRACENA) {</span>
<span class="nc" id="L2954">								continue;</span>
							}
<span class="nc bnc" id="L2956" title="All 2 branches missed.">							if (cv - abn &lt; 0) {</span>
<span class="nc" id="L2957">								continue;</span>
							}
<span class="nc" id="L2959">							aggASA += (cv - abn) * val;</span>
<span class="nc" id="L2960">							aggABN += (cv - abn);</span>
<span class="nc" id="L2961">						}</span>
<span class="nc bnc" id="L2962" title="All 2 branches missed.">						if (aggABN &gt; 0) {</span>
<span class="nc" id="L2963">							chunk.setTraceValue(type, aggASA / aggABN);</span>
						}
						break;
					case Trace.STAFFING:
					case Trace.ASTAFFING:
					case Trace.OCCUPANCY:
					case Trace.NETSTAFFING:
<span class="nc" id="L2970">						chunk.setTraceValue(type, -2);</span>
<span class="nc" id="L2971">						break;</span>
					case Trace.CRATE:
					case Trace.RPCRATE: {
<span class="nc" id="L2974">						float aggDials = 0;</span>
<span class="nc" id="L2975">						float aggVal = 0;</span>
<span class="nc bnc" id="L2976" title="All 2 branches missed.">						for (float[] newLine : lines) {</span>
<span class="nc" id="L2977">							float val = newLine[type];</span>
<span class="nc" id="L2978">							float dials = newLine[Trace.DIALS];</span>
<span class="nc bnc" id="L2979" title="All 4 branches missed.">							if (dials == Trace.TRACENA || val == Trace.TRACENA) {</span>
<span class="nc" id="L2980">								continue;</span>
							}
							// CRate or RPCRate cannot be greater than 100
<span class="nc bnc" id="L2983" title="All 2 branches missed.">							if (val &gt; 100) {</span>
<span class="nc" id="L2984">								continue;</span>
							}
<span class="nc" id="L2986">							aggVal += dials * val;</span>
<span class="nc" id="L2987">							aggDials += dials;</span>
<span class="nc" id="L2988">						}</span>
<span class="nc bnc" id="L2989" title="All 2 branches missed.">						if (aggDials &gt; 0) {</span>
<span class="nc" id="L2990">							chunk.setTraceValue(type, (aggVal / aggDials));</span>
						}
						break;
					}
					default:
				}
			}
<span class="nc" id="L2997">		} catch (Exception e) {</span>
<span class="nc" id="L2998">			LOG.error(&quot;Exception in combineRpt&quot;, e);</span>
<span class="nc" id="L2999">		}</span>
<span class="nc" id="L3000">		return chunk;</span>
	}

	// combine new line to existing trace chunk
	private static void combineRptDayLine(short types[], Date time, ArrayList dayLines, Date prvEndOfDay, TimeZone tz,
			Date start, Date end, ArrayList tcArray, DstObject dstObj) throws JdmoException {
<span class="nc" id="L3006">		ArrayList chunkList = new ArrayList(Trace.DAYPOINTS);</span>
		// used in Reportdump logic
<span class="nc" id="L3008">		dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L3009" title="All 2 branches missed.">		if (dstObj.skipLoop) {</span>
<span class="nc" id="L3010">			return;</span>
		}
<span class="nc bnc" id="L3012" title="All 2 branches missed.">		if (dstObj.needNewTraceCube) {</span>
			// Flush the contents of the tcarray since this is the real start line.
<span class="nc" id="L3014">			tcArray.clear();</span>
		}
<span class="nc" id="L3016">		Date lineStart = dstObj.lineStart;</span>
		// 92 points day, need shrink sameet
<span class="nc" id="L3018">		boolean tfrIn = dstObj.tfrIn;</span>
		// 100 points day, need expand
<span class="nc" id="L3020">		boolean tfrOut = dstObj.tfrOut;</span>
		// track points
<span class="nc" id="L3022">		int dstPoints = dstObj.dstPoints;</span>
		// temp variable to track transition
<span class="nc" id="L3024">		boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc bnc" id="L3025" title="All 2 branches missed.">		for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L3026" title="All 6 branches missed.">			if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
				// if transition will happen on this line
<span class="nc bnc" id="L3028" title="All 2 branches missed.">				if (tz.inDaylightTime(lineStart) != prvDSTFlag) {</span>
					// from this point, there is dst transition
<span class="nc" id="L3030">					int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3031" title="All 2 branches missed.">					if (tfrIn) {</span>
						// skip points
<span class="nc" id="L3033">						i += dstIntv - 1;</span>
<span class="nc bnc" id="L3034" title="All 2 branches missed.">						prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3035">						continue;</span>
					}
					// add points
<span class="nc bnc" id="L3038" title="All 2 branches missed.">					for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L3039">						TraceChunk chunk = new TraceChunk(null, lineStart);</span>
<span class="nc bnc" id="L3040" title="All 2 branches missed.">						for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3041">							chunk.setTraceValue(types[t], Trace.TRACENA);</span>
						}
<span class="nc" id="L3043">						chunkList.add(chunk);</span>
<span class="nc" id="L3044">						lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
					}
				}
			}
<span class="nc" id="L3048">			ArrayList lines = new ArrayList();</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">			for (Iterator it = dayLines.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3050">				float[][] dayLine = (float[][]) it.next();</span>
<span class="nc" id="L3051">				lines.add(dayLine[i]);</span>
<span class="nc" id="L3052">			}</span>
<span class="nc" id="L3053">			chunkList.add(combineRpt(types, lineStart, lines));</span>
			// QA 92053 - report not showing combined REQ FTE for Sunday Oct 26.
			// prvDSTFlag should be re-calculate if not DST code transition above will be executed all the loop
<span class="nc bnc" id="L3056" title="All 4 branches missed.">			if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3057">				prvDSTFlag = tz.inDaylightTime(lineStart);</span>
			}
<span class="nc" id="L3059">			lineStart = new Date(lineStart.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
		}
<span class="nc" id="L3061">		tcArray.addAll(chunkList);</span>
<span class="nc" id="L3062">	}</span>

	/**
	 * Seems to be called from a lot of places in the client code.
	 * This method does not have any effect on PredictTraceCubes. 2011-09-08
	 * TODO: DST issue for this method is not tested, Sameet, March 2006 for CV
	 * in service goal tracecube.
	 *
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param jdmo
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param spqueuesBySID
	 * @return
	 * @throws Exception
	 */
	private static Collection convert(JdmoRowset rs, TraceCube metaTC, Map spQMap, Map spTimeRangeMap, Jdmo jdmo,
			Date start, Date end, boolean includeAllServiceGoalTypes, Map&lt;ID, SPQueue&gt; spqueuesBySID) throws Exception {
<span class="nc" id="L3084">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L3085">		HashMap queueTraceMap = new HashMap();</span>
<span class="nc" id="L3086">		HashMap queueEndOfDayMap = new HashMap();</span>
<span class="nc bnc" id="L3087" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L3088">			convertActualTC(rs, metaTC, spQMap, spTimeRangeMap, start, end, types, queueTraceMap);</span>
		}
<span class="nc bnc" id="L3090" title="All 4 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L3091">			convertForecastRequiredTC(rs, metaTC, spQMap, spTimeRangeMap, start, end, spqueuesBySID, types, queueTraceMap,</span>
					queueEndOfDayMap);
		}
<span class="nc bnc" id="L3094" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L3095">			convertSGTC(rs, spQMap, spTimeRangeMap, jdmo, start, end, includeAllServiceGoalTypes, types, queueTraceMap);</span>
		}
		// calculate the computed trace values
<span class="nc" id="L3098">		HashMap queueMediaMap = TraceOperatorAdapter.getMediaForQueues(queueTraceMap.values().toArray(), jdmo.isWhatIf());</span>
<span class="nc bnc" id="L3099" title="All 2 branches missed.">		for (Iterator iterator = queueTraceMap.values().iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L3100">			TraceCube cube = (TraceCube) iterator.next();</span>
<span class="nc" id="L3101">			cube.calcComputedTraceValues((ID) queueMediaMap.get(cube.getQueueID()));</span>
<span class="nc" id="L3102">		}</span>
<span class="nc" id="L3103">		ArrayList traceList = new ArrayList(queueTraceMap.size());</span>
<span class="nc" id="L3104">		traceList.addAll(queueTraceMap.values());</span>
<span class="nc" id="L3105">		return traceList;</span>
	}

	/**
	 * @param rs
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param jdmo
	 * @param start
	 * @param end
	 * @param includeAllServiceGoalTypes
	 * @param types
	 * @param queueTraceMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertSGTC(JdmoRowset rs, Map spQMap, Map spTimeRangeMap, Jdmo jdmo, Date start, Date end,
			boolean includeAllServiceGoalTypes, short[] types, HashMap queueTraceMap)
			throws JdmoException, BbmTimeSeriesException {
		// special handling here, as it need load Forecast CV for each queue 
		// Track affected SP for Forecast load
<span class="nc" id="L3126">		HashSet spSet = new HashSet();</span>
<span class="nc" id="L3127">		HashSet queueSet = new HashSet();</span>
<span class="nc" id="L3128">		HashMap sgTimeLines = new HashMap();</span>
<span class="nc bnc" id="L3129" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3130">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L3131">			ID queueID = rs.getID(5);</span>
<span class="nc" id="L3132">			ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3133" title="All 2 branches missed.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3134">				continue;</span>
			}
			// Add 1 line per Time for all queues
<span class="nc" id="L3137">			ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="nc bnc" id="L3138" title="All 2 branches missed.">			if (tcList == null) {</span>
<span class="nc" id="L3139">				tcList = new ArrayList();</span>
			}
<span class="nc" id="L3141">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(7));</span>
<span class="nc" id="L3142">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(7));</span>
			// hack for ops release. set PCAType to false to always show SL.
			// typeASAEnabled = false;
<span class="nc" id="L3145">			TraceChunk sgTC = new TraceChunk(queueID, curTime);</span>
<span class="nc bnc" id="L3146" title="All 2 branches missed.">			if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L3147">				sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L3148" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3149">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L3151">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc bnc" id="L3153" title="All 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="nc" id="L3154">				sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L3155" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3156">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				}
			} else {
<span class="nc" id="L3159">				sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
			}
<span class="nc" id="L3161">			sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L3162">			tcList.add(sgTC);</span>
<span class="nc" id="L3163">			sgTimeLines.put(curTime, tcList);</span>
			// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L3165" title="All 2 branches missed.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L3166">				TraceChunk tc1 = new TraceChunk(queueID, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc" id="L3167">				ArrayList tc1List = (ArrayList) sgTimeLines.get(tc1.getStartDate());</span>
<span class="nc bnc" id="L3168" title="All 2 branches missed.">				if (tc1List == null) {</span>
<span class="nc" id="L3169">					tc1List = new ArrayList();</span>
				}
<span class="nc bnc" id="L3171" title="All 2 branches missed.">				if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L3172">					tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3173" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3174">						tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
					} else {
<span class="nc" id="L3176">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="nc bnc" id="L3178" title="All 2 branches missed.">				} else if (!typeASAEnabled) {</span>
<span class="nc" id="L3179">					tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3180" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3181">						tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
					}
				} else {
<span class="nc" id="L3184">					tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
				}
<span class="nc" id="L3186">				tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc" id="L3187">				tc1List.add(tc1);</span>
<span class="nc" id="L3188">				sgTimeLines.put(tc1.getStartDate(), tc1List);</span>
			}
			// track all affected sps
<span class="nc" id="L3191">			spSet.add(rs.getID(6));</span>
			// track all affected queues
<span class="nc" id="L3193">			queueSet.add(queueID);</span>
<span class="nc" id="L3194">		}</span>
<span class="nc" id="L3195">		rs.close();</span>
<span class="nc bnc" id="L3196" title="All 2 branches missed.">		if (!sgTimeLines.isEmpty()) {</span>
<span class="nc" id="L3197">			Set affectedTimeSet = sgTimeLines.keySet();</span>
			// Prepare to load Forecast CV for all queues in affected SPs
<span class="nc" id="L3199">			StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L3200">			pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L3201" title="All 2 branches missed.">			for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3202">				pStmt.append(&quot;CALLVOLUME&quot;).append(i).append(&quot;,&quot;);</span>
			}
<span class="nc" id="L3204">			pStmt.append(&quot; A.DATETIME, D.SID, TIMEZONEMAP.JAVATZIDENT, C.FROMDATE, C.TODATE , B.SID SPQUEUESID  from &quot;)</span>
<span class="nc" id="L3205">					.append(FORECASTTRACETABLENAME);</span>
<span class="nc" id="L3206">			pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D, TIMEZONE,TIMEZONEMAP,CAMPAIGN where C.CAMPAIGNID=CAMPAIGN.ID &quot;)</span>
<span class="nc" id="L3207">					.append(&quot;and CAMPAIGN.TIMEZONEID=TIMEZONE.ID and TIMEZONEMAP.WINTZSTDNAME=TIMEZONE.STANDARDNAME &quot;)</span>
<span class="nc" id="L3208">					.append(&quot;and A.FORECASTINSTANCEID is null and A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;)</span>
<span class="nc" id="L3209">					.append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L3210">			pStmt.append(&quot; and A.FORECASTINSTANCEID is null and D.SID in &quot;).append(jdmo.createInClause(queueSet));</span>
<span class="nc" id="L3211">			pStmt.append(&quot; order by A.DATETIME asc&quot;);</span>
<span class="nc" id="L3212">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc" id="L3213">			HashMap hashMapPrevEndOfDayForQ = new HashMap();</span>
<span class="nc bnc" id="L3214" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3215">				ID queID = rs.getID(Trace.DAYPOINTS + 2);</span>
<span class="nc" id="L3216">				Date prvEndOfDay = (Date) hashMapPrevEndOfDayForQ.get(queID);</span>
<span class="nc" id="L3217">				DstObject dstObj = new DstObject();</span>
<span class="nc" id="L3218">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L3219">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L3220">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3221">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
				// TESTED reqd svc level for Skill campagain at comb level
<span class="nc" id="L3223">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L3224" title="All 2 branches missed.">				if (dstObj.skipLoop) {</span>
<span class="nc" id="L3225">					continue;</span>
				}
<span class="nc bnc" id="L3227" title="All 2 branches missed.">				if (dstObj.needNewTraceCube) {</span>
					// Flush the contents of the tcarray since this is the real start line.
					// tcArray.clear()
				}
<span class="nc" id="L3231">				Date insertPoint = dstObj.lineStart;</span>
				// 92 points day, need shrink sameet
<span class="nc" id="L3233">				boolean tfrIn = dstObj.tfrIn;</span>
				// 100 points day, need expand
<span class="nc" id="L3235">				boolean tfrOut = dstObj.tfrOut;</span>
				// track points
<span class="nc" id="L3237">				int dstPoints = dstObj.dstPoints;</span>
				// temp variable to track transition
<span class="nc" id="L3239">				boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc bnc" id="L3240" title="All 2 branches missed.">				for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
					// This is wrong as it increments the time on DST transition day in APR
					// Date insertPoint = new Date(lineStart.getTime() + (i-1)*Trace.INTERVAL_IN_MILLIS)
<span class="nc bnc" id="L3243" title="All 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="nc bnc" id="L3245" title="All 2 branches missed.">						if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="nc" id="L3247">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3248" title="All 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="nc" id="L3250">								i += dstIntv - 1;</span>
<span class="nc bnc" id="L3251" title="All 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3252">								continue;</span>
							}
							// add points
<span class="nc bnc" id="L3255" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L3256" title="All 2 branches missed.">								for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3257">									ArrayList tcList = (ArrayList) sgTimeLines.get(insertPoint);</span>
<span class="nc bnc" id="L3258" title="All 2 branches missed.">									if (tcList != null) {</span>
<span class="nc bnc" id="L3259" title="All 2 branches missed.">										for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3260">											TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc bnc" id="L3261" title="All 2 branches missed.">											if (tc.getQueueID().equals(queID)) {</span>
<span class="nc" id="L3262">												tc.setTraceValue(Trace.CV, Trace.TRACENA);</span>
											}
<span class="nc" id="L3264">										}</span>
									}
								}
<span class="nc" id="L3267">								insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
							}
						}
					}
<span class="nc bnc" id="L3271" title="All 2 branches missed.">					if (insertPoint.after(end)) {</span>
<span class="nc" id="L3272">						break;</span>
					}
					// regular processing
<span class="nc bnc" id="L3275" title="All 2 branches missed.">					if (affectedTimeSet.contains(insertPoint)) {</span>
<span class="nc" id="L3276">						ArrayList tcList = (ArrayList) sgTimeLines.get(insertPoint);</span>
<span class="nc bnc" id="L3277" title="All 2 branches missed.">						if (tcList != null) {</span>
<span class="nc bnc" id="L3278" title="All 2 branches missed.">							for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3279">								TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc bnc" id="L3280" title="All 2 branches missed.">								if (tc.getQueueID().equals(queID)) {</span>
<span class="nc" id="L3281">									tc.setTraceValue(Trace.CV, rs.getFloat(i));</span>
								}
<span class="nc" id="L3283">							}</span>
						}
					}
<span class="nc bnc" id="L3286" title="All 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3287">						prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
					}
<span class="nc" id="L3289">					insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
<span class="nc" id="L3291">				prvEndOfDay = insertPoint;</span>
<span class="nc" id="L3292">				hashMapPrevEndOfDayForQ.put(queID, prvEndOfDay);</span>
<span class="nc" id="L3293">			}</span>
			// now add to cube
<span class="nc bnc" id="L3295" title="All 2 branches missed.">			for (Iterator it = affectedTimeSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3296">				Date chunkTime = (Date) it.next();</span>
<span class="nc bnc" id="L3297" title="All 2 branches missed.">				if (fallsIn(chunkTime, start, end)) {</span>
<span class="nc" id="L3298">					ArrayList lines = (ArrayList) sgTimeLines.get(chunkTime);</span>
<span class="nc bnc" id="L3299" title="All 2 branches missed.">					for (Iterator lineIt = lines.iterator(); lineIt.hasNext(); ) {</span>
<span class="nc" id="L3300">						TraceChunk chunk = (TraceChunk) lineIt.next();</span>
<span class="nc" id="L3301">						ID qID = chunk.getQueueID();</span>
<span class="nc" id="L3302">						TraceCube cube = (TraceCube) queueTraceMap.get(qID);</span>
<span class="nc bnc" id="L3303" title="All 2 branches missed.">						if (cube == null) {</span>
<span class="nc" id="L3304">							cube = TraceUtil.META_AGGR_REQUIRE.newInstance(qID, start, end, types);</span>
						}
<span class="nc" id="L3306">						cube.setTraceValue(types, chunk.getTraceValues(types), chunkTime);</span>
<span class="nc" id="L3307">						cube.setTraceValue(Trace.CV, chunk.getTraceValue(Trace.CV), chunkTime, true);</span>
						// calcComputedValues Method needs media ID only for Actual timeSeries
<span class="nc" id="L3309">						cube.calcComputedTraceValues((ID) null);</span>
<span class="nc" id="L3310">						queueTraceMap.put(qID, cube);</span>
<span class="nc" id="L3311">					}</span>
				}
<span class="nc" id="L3313">			}</span>
		}
<span class="nc" id="L3315">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param types
	 * @param queueTraceMap
	 * @param queueEndOfDayMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertForecastRequiredTC(JdmoRowset rs, TraceCube metaTC, Map spQMap, Map spTimeRangeMap, Date start,
			Date end, Map&lt;ID, SPQueue&gt; spqueuesBySID, short[] types, HashMap queueTraceMap, HashMap queueEndOfDayMap)
			throws JdmoException, BbmTimeSeriesException {
<span class="nc bnc" id="L3334" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3335">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L3336">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc bnc" id="L3337" title="All 2 branches missed.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3338">				continue;</span>
			}
<span class="nc" id="L3340">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L3341">			double[][] dayLine = new double[Trace.DAYPOINTS][];</span>
<span class="nc" id="L3342">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3343" title="All 2 branches missed.">			for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
				// forecast is CV/AHT
<span class="nc" id="L3345">				double[] newLine = new double[types.length];</span>
<span class="nc bnc" id="L3346" title="All 2 branches missed.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3347" title="All 2 branches missed.">					if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3348">						newLine[j] = rs.getFloat(resultSetCounter++);</span>
					}
				}
<span class="nc" id="L3351">				dayLine[i] = newLine;</span>
			}
<span class="nc" id="L3353">			convertLinesMap(metaTC, start, end, types, queueID, dayLine, queueTraceMap, curTime, queueEndOfDayMap, tz, spqueuesBySID, rs);</span>
<span class="nc" id="L3354">		}</span>
<span class="nc" id="L3355">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param spQMap
	 * @param spTimeRangeMap
	 * @param start
	 * @param end
	 * @param types
	 * @param queueTraceMap
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static void convertActualTC(JdmoRowset rs, TraceCube metaTC, Map spQMap, Map spTimeRangeMap, Date start, Date end,
			short[] types, HashMap queueTraceMap)
			throws JdmoException, BbmTimeSeriesException {
<span class="nc bnc" id="L3372" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3373">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
			// check if the queue ID is in the association window or not
<span class="nc" id="L3375">			ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3376">			ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3377" title="All 2 branches missed.">			if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3378">				continue;</span>
			}
<span class="nc" id="L3380">			double[] newLine = new double[types.length];</span>
<span class="nc" id="L3381">			int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3382" title="All 2 branches missed.">			for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3383" title="All 2 branches missed.">				if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3384">					newLine[j] = rs.getFloat(resultSetCounter++);</span>
				}
			}
<span class="nc" id="L3387">			TraceCube cube = (TraceCube) queueTraceMap.get(queueID);</span>
<span class="nc bnc" id="L3388" title="All 2 branches missed.">			if (cube == null) {</span>
<span class="nc" id="L3389">				cube = metaTC.newInstance(queueID, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L3391">			cube.setTraceValue(types, newLine, curTime);</span>
<span class="nc" id="L3392">			cube.calcComputedTraceValues(mediaID);</span>
<span class="nc" id="L3393">			queueTraceMap.put(queueID, cube);</span>
<span class="nc" id="L3394">		}</span>
<span class="nc" id="L3395">	}</span>

	// Used to calculate trace types for a combined Queue. Indvl queues are passed to this method, one day at a time for the whole SP
	private static void convertLinesMap(TraceCube metaTC, Date start, Date end, short[] types, ID qID, double[][] values,
			HashMap queueTraceMap, Date lineStart, HashMap queueEndOfDayMap, TimeZone tz, Map&lt;ID, SPQueue&gt; spqueuesBySID,
			JdmoRowset rs) throws BbmTimeSeriesException, JdmoException {

<span class="nc" id="L3402">		TraceCube cube = (TraceCube) queueTraceMap.get(qID);</span>
<span class="nc" id="L3403">		Date insertPoint = new Date(lineStart.getTime());</span>
<span class="nc" id="L3404">		Date prvEndOfDay = (Date) queueEndOfDayMap.get(qID);</span>
<span class="nc" id="L3405">		DstObject dstObj = new DstObject();</span>
<span class="nc" id="L3406">		dstObj.lineStart = lineStart;</span>
<span class="nc" id="L3407">		dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3408">		dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L3409">		dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L3410" title="All 2 branches missed.">		if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L3411">			return;</span>
		}
<span class="nc bnc" id="L3413" title="All 4 branches missed.">		if (dstObj.needNewTraceCube || cube == null) {</span>
<span class="nc" id="L3414">			cube = metaTC.newInstance(qID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc" id="L3416">		cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="nc" id="L3417">		ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="nc" id="L3418">		cube.setSPQueueSID(spQueueSID);</span>
<span class="nc" id="L3419">		SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="nc bnc" id="L3420" title="All 2 branches missed.">		if (spq != null) {</span>
<span class="nc" id="L3421">			cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="nc" id="L3422">			cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="nc" id="L3423">			cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
		}
<span class="nc" id="L3425">		lineStart = dstObj.lineStart;</span>
<span class="nc" id="L3426">		insertPoint = new Date(dstObj.lineStart.getTime());</span>
		// 92 points day, need shrink
<span class="nc" id="L3428">		boolean tfrIn = dstObj.tfrIn;</span>
		// 100 points day, need expand
<span class="nc" id="L3430">		boolean tfrOut = dstObj.tfrOut;</span>
		// track points
<span class="nc" id="L3432">		int dstPoints = dstObj.dstPoints;</span>
		// temp variable to track transition
<span class="nc" id="L3434">		boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc bnc" id="L3435" title="All 2 branches missed.">		for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L3436" title="All 2 branches missed.">			if (fallsIn(insertPoint, start, end)) {</span>
<span class="nc bnc" id="L3437" title="All 6 branches missed.">				if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
					// if transition will happen on this line
<span class="nc bnc" id="L3439" title="All 2 branches missed.">					if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
						// from this point, there is dst transition
<span class="nc" id="L3441">						int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3442" title="All 2 branches missed.">						if (tfrIn) {</span>
							// skip points
<span class="nc" id="L3444">							i += dstIntv - 1;</span>
<span class="nc bnc" id="L3445" title="All 2 branches missed.">							prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3446">							continue;</span>
						}
						// add points
<span class="nc bnc" id="L3449" title="All 2 branches missed.">						for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L3450" title="All 2 branches missed.">							for (int t = 0; t &lt; types.length; t++) {</span>
<span class="nc" id="L3451">								cube.setTraceValue(types[t], Trace.TRACENA, insertPoint, true);</span>
							}
<span class="nc" id="L3453">							insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3454" title="All 2 branches missed.">							if (insertPoint.after(end)) {</span>
<span class="nc" id="L3455">								break;</span>
							}
						}
					}
				}
<span class="nc bnc" id="L3460" title="All 2 branches missed.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc" id="L3461">					cube.setTraceValue(types[j], values[i][j], insertPoint, true);</span>
				}
			}
<span class="nc bnc" id="L3464" title="All 4 branches missed.">			if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3465">				prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
			}
<span class="nc" id="L3467">			insertPoint.setTime(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3468" title="All 2 branches missed.">			if (insertPoint.after(end)) {</span>
<span class="nc" id="L3469">				break;</span>
			}
		}
<span class="nc" id="L3472">		queueEndOfDayMap.put(qID, insertPoint);</span>
		// passing null for media id since it is reqd only for actuals not forecast
<span class="nc" id="L3474">		cube.calcComputedTraceValues((ID) null);</span>
<span class="nc" id="L3475">		queueTraceMap.put(qID, cube);</span>
<span class="nc" id="L3476">	}</span>

	// This method does not have any effect on PredictTraceCubes. 2011-09-08
	private static void convert(JdmoRowset rs, TraceCube metaTC, HashMap spQMap, HashMap spTimeRangeMap,
			ArrayList&lt;TraceChunk&gt; tcArray, Date start, Date end, Jdmo jdmo, HashMap traceChunkMap) throws JdmoException {
<span class="nc" id="L3481">		Date prvTime = null;</span>
<span class="nc" id="L3482">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc" id="L3483">		ArrayList lines = new ArrayList();</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc bnc" id="L3485" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3486">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TIME&quot;));</span>
				// check if the queue ID is in the association window or not
<span class="nc" id="L3488">				ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3489">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3490" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3491">					continue;</span>
				}
<span class="nc" id="L3493">				float[] newLine = new float[types.length];</span>
<span class="nc" id="L3494">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3495" title="All 2 branches missed.">				for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3496" title="All 2 branches missed.">					if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3497">						newLine[j] = rs.getFloat(resultSetCounter++);</span>
					}
				}
<span class="nc" id="L3500">				metaTC.calcComputedTraceValues(types, newLine, mediaID);</span>
<span class="nc bnc" id="L3501" title="All 4 branches missed.">				if (prvTime == null || !prvTime.equals(curTime)) {</span>
					// if prvTime is not null, means we can aggregate previous time point
<span class="nc bnc" id="L3503" title="All 2 branches missed.">					if (prvTime != null) {</span>
						// aggregate
<span class="nc" id="L3505">						tcArray.add(combineRpt(types, prvTime, lines));</span>
<span class="nc" id="L3506">						lines.clear();</span>
					}
<span class="nc" id="L3508">					prvTime = curTime;</span>
				}
<span class="nc" id="L3510">				lines.add(newLine);</span>
<span class="nc" id="L3511">			}</span>
<span class="nc bnc" id="L3512" title="All 4 branches missed.">			if (!lines.isEmpty() &amp;&amp; prvTime != null) {</span>
<span class="nc" id="L3513">				tcArray.add(combineRpt(types, prvTime, lines));</span>
			}
		}
<span class="nc bnc" id="L3516" title="All 4 branches missed.">		if (metaTC instanceof ForecastTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L3517">			Date prvEndOfDay = null;</span>
<span class="nc" id="L3518">			TimeZone prvTZ = null;</span>
<span class="nc" id="L3519">			DstObject dstObj = null;</span>
<span class="nc bnc" id="L3520" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3521">				dstObj = new DstObject();</span>
<span class="nc" id="L3522">				dstObj.lineStart = prvTime;</span>
<span class="nc" id="L3523">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L3524">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3525">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L3526">				ID queueID = rs.getID(&quot;SID&quot;);</span>
<span class="nc" id="L3527">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3528" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3529">					continue;</span>
				}
<span class="nc" id="L3531">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc bnc" id="L3532" title="All 4 branches missed.">				if (prvTime == null || !prvTime.equals(curTime)) {</span>
					// if prvTime is not null, means we can aggregate previous time point
<span class="nc bnc" id="L3534" title="All 2 branches missed.">					if (prvTime != null) {</span>
						// aggregate
<span class="nc" id="L3536">						combineRptDayLine(types, prvTime, lines, prvEndOfDay, prvTZ, start, end, tcArray, dstObj);</span>
<span class="nc" id="L3537">						prvEndOfDay = new Date(prvTime.getTime() + Trace.INTERVAL_IN_MILLIS * Trace.DAYPOINTS);</span>
<span class="nc" id="L3538">						lines.clear();</span>
					}
				}
<span class="nc" id="L3541">				prvTime = curTime;</span>
<span class="nc" id="L3542">				prvTZ = tz;</span>
<span class="nc" id="L3543">				float[][] dayLine = new float[Trace.DAYPOINTS][];</span>
<span class="nc" id="L3544">				int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3545" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
					// forecast is CV/AHT
<span class="nc" id="L3547">					float[] newLine = new float[Trace.MAX_TYPE];</span>
<span class="nc bnc" id="L3548" title="All 2 branches missed.">					for (int j = 0; j &lt; newLine.length; j++) {</span>
<span class="nc" id="L3549">						newLine[j] = Trace.TRACENA;</span>
					}
<span class="nc bnc" id="L3551" title="All 2 branches missed.">					for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">						if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3553">							newLine[types[j]] = rs.getFloat(resultSetCounter++);</span>
						}
					}
<span class="nc" id="L3556">					metaTC.calcComputedTraceValues(types, newLine, mediaID);</span>
<span class="nc" id="L3557">					Date timeNow = new Date(prvTime.getTime() + (Trace.INTERVAL_IN_MILLIS * i));</span>
<span class="nc bnc" id="L3558" title="All 2 branches missed.">					HashMap queChunkMap = traceChunkMap != null ? (HashMap) traceChunkMap.get(timeNow) : null;</span>
<span class="nc bnc" id="L3559" title="All 2 branches missed.">					TraceChunk predictChunk = queChunkMap != null ? (TraceChunk) queChunkMap.get(queueID) : null;</span>

<span class="nc bnc" id="L3561" title="All 2 branches missed.">					if (predictChunk != null) {</span>
<span class="nc" id="L3562">						newLine[Trace.DIALS] = predictChunk.getTraceValue(Trace.DIALS);</span>
						// Predicted Connects &amp; RPC are computed values dependent on CRATE &amp; RPCSRATE from Forecast Timeseries.
						// These cannot be always computed before this call
						// If its not available then compute based on DIALS and RPCRATE
						// make a call to calculate the computed values
<span class="nc" id="L3567">						new PredictTraceCube().calcComputedTraceValues(Trace.TYPES, newLine, null);</span>
					}
<span class="nc" id="L3569">					dayLine[i] = newLine;</span>
				}
<span class="nc" id="L3571">				lines.add(dayLine);</span>
<span class="nc" id="L3572">			}</span>
<span class="nc bnc" id="L3573" title="All 4 branches missed.">			if (prvTime != null &amp;&amp; !lines.isEmpty()) {</span>
<span class="nc" id="L3574">				combineRptDayLine(types, prvTime, lines, prvEndOfDay, prvTZ, start, end, tcArray, dstObj);</span>
			}
		}
<span class="nc bnc" id="L3577" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
			// special handling here, as it need load Forecast CV for each queue
			// Track affected SP for Forecast load
<span class="nc" id="L3580">			HashSet spSet = new HashSet();</span>
<span class="nc" id="L3581">			HashSet queueSet = new HashSet();</span>
<span class="nc" id="L3582">			HashMap sgTimeLines = new HashMap();</span>
<span class="nc bnc" id="L3583" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3584">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L3585">				ID queueID = rs.getID(5);</span>
<span class="nc" id="L3586">				ID mediaID = rs.getID(&quot;MEDIAID&quot;);</span>
<span class="nc bnc" id="L3587" title="All 2 branches missed.">				if (!queueFallsIn(queueID, curTime, spQMap, spTimeRangeMap)) {</span>
<span class="nc" id="L3588">					continue;</span>
				}
				// Add 1 line per Time for all queues
<span class="nc" id="L3591">				ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="nc bnc" id="L3592" title="All 2 branches missed.">				if (tcList == null) {</span>
<span class="nc" id="L3593">					tcList = new ArrayList();</span>
				}
<span class="nc" id="L3595">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(7));</span>
<span class="nc" id="L3596">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(7));</span>
				// hack for ops release. set PCAType to false to always show SL.
				// typeASAEnabled = false;
<span class="nc" id="L3599">				TraceChunk sgTC = new TraceChunk(queueID, curTime);</span>
<span class="nc bnc" id="L3600" title="All 2 branches missed.">				if (!typeASAEnabled) {</span>
<span class="nc" id="L3601">					sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
<span class="nc bnc" id="L3602" title="All 2 branches missed.">					if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3603">						sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
					}
				} else {
<span class="nc" id="L3606">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc" id="L3608">				sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L3609">				tcList.add(sgTC);</span>
<span class="nc" id="L3610">				sgTimeLines.put(curTime, tcList);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L3612" title="All 2 branches missed.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L3613">					TraceChunk tc1 = new TraceChunk(queueID, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc" id="L3614">					ArrayList tc1List = (ArrayList) sgTimeLines.get(tc1.getStartDate());</span>
<span class="nc bnc" id="L3615" title="All 2 branches missed.">					if (tc1List == null) {</span>
<span class="nc" id="L3616">						tc1List = new ArrayList();</span>
					}
<span class="nc bnc" id="L3618" title="All 2 branches missed.">					if (!typeASAEnabled) {</span>
<span class="nc" id="L3619">						tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3620" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3621">							tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L3624">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L3626">					tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc" id="L3627">					tc1List.add(tc1);</span>
<span class="nc" id="L3628">					sgTimeLines.put(tc1.getStartDate(), tc1List);</span>
				}
				// track all affected sps
<span class="nc" id="L3631">				spSet.add(rs.getID(6));</span>
				// track all affected queues
<span class="nc" id="L3633">				queueSet.add(queueID);</span>
<span class="nc" id="L3634">			}</span>
<span class="nc" id="L3635">			rs.close();</span>
<span class="nc bnc" id="L3636" title="All 2 branches missed.">			if (!sgTimeLines.isEmpty()) {</span>
<span class="nc" id="L3637">				Set affectedTimeSet = sgTimeLines.keySet();</span>
				// Prepare to load Forecast CV for all queues in affected SPs
<span class="nc" id="L3639">				StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L3640">				pStmt.append(&quot;select &quot;);</span>
<span class="nc bnc" id="L3641" title="All 2 branches missed.">				for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3642">					pStmt.append(&quot;CALLVOLUME&quot;).append(i).append(&quot;,&quot;);</span>
				}
<span class="nc" id="L3644">				pStmt.append(&quot; A.DATETIME, D.SID from &quot;).append(FORECASTTRACETABLENAME);</span>
<span class="nc" id="L3645">				pStmt.append(&quot; A, SPQUEUE B, SP C, QUEUE D where A.FORECASTINSTANCEID is null AND &quot;);</span>
<span class="nc" id="L3646">				pStmt.append(&quot; A.SPQUEUEID=B.ID and B.QUEUEID=D.ID and B.SPID=C.ID and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L3647">				pStmt.append(&quot; and D.SID in &quot;).append(jdmo.createInClause(queueSet));</span>
<span class="nc" id="L3648">				rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L3649" title="All 2 branches missed.">				while (rs.next()) {</span>
<span class="nc" id="L3650">					Date dayTime = TimeZoneUtil.toDate(rs.getTimestamp(Trace.DAYPOINTS + 1));</span>
<span class="nc bnc" id="L3651" title="All 2 branches missed.">					for (int i = 1; i &lt;= Trace.DAYPOINTS; i++) {</span>
<span class="nc" id="L3652">						Date curTime = new Date(dayTime.getTime() + (i - 1) * Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3653" title="All 2 branches missed.">						if (affectedTimeSet.contains(curTime)) {</span>
<span class="nc" id="L3654">							ArrayList tcList = (ArrayList) sgTimeLines.get(curTime);</span>
<span class="nc bnc" id="L3655" title="All 2 branches missed.">							if (tcList != null) {</span>
<span class="nc bnc" id="L3656" title="All 2 branches missed.">								for (Iterator it = tcList.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3657">									TraceChunk tc = (TraceChunk) it.next();</span>
<span class="nc bnc" id="L3658" title="All 2 branches missed.">									if (tc.getQueueID().equals(rs.getID(Trace.DAYPOINTS + 2))) {</span>
<span class="nc" id="L3659">										float cv = rs.getFloat(i);</span>
<span class="nc" id="L3660">										tc.setTraceValue(Trace.CV, cv);</span>
										// VAR &amp; CV_VH =CV for Forecast or REquired Timeseries
<span class="nc" id="L3662">										tc.setTraceValue(Trace.VAR, cv);</span>
<span class="nc" id="L3663">										tc.setTraceValue(Trace.CV_VH, cv);</span>
									}
<span class="nc" id="L3665">								}</span>
							}
						}
					}
<span class="nc" id="L3669">				}</span>
				// now add to tcArray
<span class="nc bnc" id="L3671" title="All 2 branches missed.">				for (Iterator it = affectedTimeSet.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L3672">					Date chunkTime = (Date) it.next();</span>
<span class="nc" id="L3673">					lines = (ArrayList) sgTimeLines.get(chunkTime);</span>
<span class="nc" id="L3674">					ArrayList dataLines = new ArrayList(lines.size());</span>
<span class="nc bnc" id="L3675" title="All 2 branches missed.">					for (Iterator lineIt = lines.iterator(); lineIt.hasNext(); ) {</span>
<span class="nc" id="L3676">						dataLines.add(((TraceChunk) lineIt.next()).getTraceValues());</span>
					}
<span class="nc" id="L3678">					tcArray.add(combineRpt(types, chunkTime, dataLines));</span>
<span class="nc" id="L3679">				}</span>
			}
		}
<span class="nc" id="L3682">	}</span>

	/* this method is used for Combined Predicted Time series Calculation */
	private static TraceCube convert(JdmoRowset rs, TraceCube metaTC, Date start, Date end, ID mediaID,
			boolean includeAllServiceGoalTypes, boolean isWhatIf, Map&lt;ID, SPQueue&gt; spqueuesBySID,
			boolean isNoPhantom) throws Exception {
<span class="nc" id="L3688">		TraceCube cube = metaTC.newInstance(null, start, end, metaTC.getTraceTypes());</span>
<span class="nc bnc" id="L3689" title="All 4 branches missed.">		if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L3690">			cube = convertForPredictRequiredTC(rs, metaTC, start, end, spqueuesBySID, cube, isNoPhantom);</span>
		}
<span class="nc bnc" id="L3692" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L3693">			convertForSGTC(rs, start, end, mediaID, includeAllServiceGoalTypes, cube);</span>
		}
<span class="nc" id="L3695">		cube.calcComputedTraceValues(TraceOperatorAdapter.getMediaIDForQueue(cube.getQueueID(), isWhatIf));</span>
<span class="nc" id="L3696">		return cube;</span>
	}

	/**
	 * @param rs
	 * @param start
	 * @param end
	 * @param mediaID
	 * @param includeAllServiceGoalTypes
	 * @param cube
	 * @throws JdmoException
	 */
	private static void convertForSGTC(JdmoRowset rs, Date start, Date end, ID mediaID, boolean includeAllServiceGoalTypes, TraceCube cube)
			throws JdmoException {
<span class="nc bnc" id="L3710" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3711">			Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L3712">			boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="nc" id="L3713">			boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>

<span class="nc" id="L3715">			List&lt;Integer&gt; valueList = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L3716">			List&lt;Short&gt; typeList = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L3717" title="All 2 branches missed.">			if (includeAllServiceGoalTypes) {</span>
<span class="nc" id="L3718">				typeList.add(Trace.PCA);</span>
<span class="nc" id="L3719">				valueList.add(TraceUtil.roundDouble(rs.getFloat(1)));</span>
<span class="nc bnc" id="L3720" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3721">					typeList.add(Trace.DEADLINE_TIME);</span>
				} else {
<span class="nc" id="L3723">					typeList.add(Trace.ASA);</span>
				}
<span class="nc" id="L3725">				valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
<span class="nc bnc" id="L3726" title="All 2 branches missed.">			} else if (!typeASAEnabled) {</span>
<span class="nc bnc" id="L3727" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3728">					typeList.add(Trace.DEADLINE_TIME);</span>
<span class="nc" id="L3729">					valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
				}
<span class="nc" id="L3731">				typeList.add(Trace.PCA);</span>
<span class="nc" id="L3732">				valueList.add(TraceUtil.roundDouble(rs.getFloat(1)));</span>
			} else {
<span class="nc" id="L3734">				typeList.add(Trace.ASA);</span>
<span class="nc" id="L3735">				valueList.add(TraceUtil.roundDouble(rs.getFloat(2)));</span>
			}
<span class="nc" id="L3737">			typeList.add(Trace.ABANDONMENT);</span>
<span class="nc" id="L3738">			valueList.add(TraceUtil.roundDouble(rs.getFloat(3)));</span>

			// typeList and valueList must be of the same length.
<span class="nc" id="L3741">			double[] values = new double[valueList.size()];</span>
<span class="nc" id="L3742">			short[] types = new short[valueList.size()];</span>
<span class="nc bnc" id="L3743" title="All 2 branches missed.">			for (int i = 0; i &lt; valueList.size(); ++i) {</span>
<span class="nc" id="L3744">				values[i] = valueList.get(i);</span>
<span class="nc" id="L3745">				types[i] = typeList.get(i);</span>
			}

<span class="nc bnc" id="L3748" title="All 2 branches missed.">			if (fallsIn(curTime, start, end)) {</span>
<span class="nc" id="L3749">				cube.setTraceValue(types, values, curTime);</span>
			}
			// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L3752" title="All 2 branches missed.">			for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L3753">				Date insPoint = new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3754" title="All 2 branches missed.">				if (fallsIn(insPoint, start, end)) {</span>
<span class="nc" id="L3755">					cube.setTraceValue(types, values, insPoint);</span>
				}
			}
<span class="nc" id="L3758">		}</span>
<span class="nc" id="L3759">	}</span>

	/**
	 * @param rs
	 * @param metaTC
	 * @param start
	 * @param end
	 * @param spqueuesBySID
	 * @param cube
	 * @return
	 * @throws JdmoException
	 * @throws BbmTimeSeriesException
	 */
	private static TraceCube convertForPredictRequiredTC(JdmoRowset rs, TraceCube metaTC, Date start, Date end,
			Map&lt;ID, SPQueue&gt; spqueuesBySID, TraceCube cube, boolean isNoPhantom)
			throws JdmoException, BbmTimeSeriesException {
<span class="nc" id="L3775">		int typeLen = 0;</span>
<span class="nc" id="L3776">		Date prvEndOfDay = null;</span>
<span class="nc" id="L3777">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L3778" title="All 2 branches missed.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L3779" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L3780">				typeLen++;</span>
			}
		}
<span class="nc bnc" id="L3783" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L3784">			DstObject dstObj = new DstObject();</span>
<span class="nc" id="L3785">			dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(getDETimeColumn(metaTC, false, isNoPhantom)));</span>
<span class="nc" id="L3786">			TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L3787">			dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3788">			dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
<span class="nc" id="L3789">			dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L3790" title="All 2 branches missed.">			if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L3791">				continue;</span>
			}
<span class="nc bnc" id="L3793" title="All 2 branches missed.">			if (dstObj.needNewTraceCube) {</span>
<span class="nc" id="L3794">				cube = metaTC.newInstance(null, start, end, metaTC.getTraceTypes());</span>
			}
<span class="nc" id="L3796">			cube.setCampaignTimeZoneID(tz.getID());</span>
<span class="nc" id="L3797">			ID spQueueSID = rs.getID(&quot;SPQUEUESID&quot;);</span>
<span class="nc" id="L3798">			cube.setSPQueueSID(spQueueSID);</span>
<span class="nc" id="L3799">			SPQueue spq = spqueuesBySID.get(spQueueSID);</span>
<span class="nc bnc" id="L3800" title="All 2 branches missed.">			if (spq != null) {</span>
<span class="nc" id="L3801">				cube.setStartingBacklog(TraceUtil.roundDouble(spq.getStartingBacklog()));</span>
<span class="nc" id="L3802">				cube.setInterimBacklog(TraceUtil.roundDouble(spq.getInterimBacklog()));</span>
<span class="nc" id="L3803">				cube.setInterimBacklogDate(spq.getInterimBacklogDate());</span>
			}
<span class="nc" id="L3805">			Date insertPoint = dstObj.lineStart;</span>
			// 92 points day, need shrink sameet
<span class="nc" id="L3807">			boolean tfrIn = dstObj.tfrIn;</span>
			// 100 points day, need expand
<span class="nc" id="L3809">			boolean tfrOut = dstObj.tfrOut;</span>
			// track points
<span class="nc" id="L3811">			int dstPoints = dstObj.dstPoints;</span>
			// temp variable to track transition
<span class="nc" id="L3813">			boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc bnc" id="L3814" title="All 2 branches missed.">			for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L3815" title="All 2 branches missed.">				if (fallsIn(insertPoint, start, end)) {</span>
<span class="nc bnc" id="L3816" title="All 6 branches missed.">					if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
						// if transition will happen on this line
<span class="nc bnc" id="L3818" title="All 2 branches missed.">						if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
							// from this point, there is dst transition
<span class="nc" id="L3820">							int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3821" title="All 2 branches missed.">							if (tfrIn) {</span>
								// skip points
<span class="nc" id="L3823">								i += dstIntv - 1;</span>
<span class="nc bnc" id="L3824" title="All 2 branches missed.">								prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3825">								continue;</span>
							}
							// add points
<span class="nc bnc" id="L3828" title="All 2 branches missed.">							for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc bnc" id="L3829" title="All 2 branches missed.">								for (int t = 0; t &lt; typeLen; t++) {</span>
<span class="nc" id="L3830">									cube.setTraceValue(metaTC.getTraceTypes()[t], Trace.TRACENA, insertPoint, true);</span>
								}
<span class="nc" id="L3832">								insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
<span class="nc bnc" id="L3833" title="All 2 branches missed.">								if (insertPoint.after(end)) {</span>
<span class="nc" id="L3834">									break;</span>
								}
							}
						}
					}
<span class="nc" id="L3839">					double[] values = new double[types.length];</span>
					// this is done to omit the comupted types
<span class="nc" id="L3841">					int resultSetCounter = 1;</span>
<span class="nc bnc" id="L3842" title="All 2 branches missed.">					for (int j = 0; j &lt; types.length; j++) {</span>
<span class="nc bnc" id="L3843" title="All 2 branches missed.">						if (!metaTC.isTraceTypeComputed(types[j])) {</span>
<span class="nc" id="L3844">							values[j] = rs.getFloat(typeLen * i + resultSetCounter++);</span>
						}
					}
<span class="nc" id="L3847">					cube.setTraceValue(metaTC.getTraceTypes(), values, insertPoint);</span>
				}
<span class="nc bnc" id="L3849" title="All 4 branches missed.">				if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3850">					prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
				}
<span class="nc" id="L3852">				insertPoint.setTime(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
			}
<span class="nc" id="L3854">			prvEndOfDay = insertPoint;</span>
<span class="nc" id="L3855">		}</span>
<span class="nc" id="L3856">		return cube;</span>
	}

	private static void convert(JdmoRowset rs, TraceCube metaTC, List&lt;TraceChunk&gt; tcArray, Date start, Date end, ID mediaID)
			throws JdmoException {
<span class="nc" id="L3861">		int typeLen = 0;</span>
<span class="nc" id="L3862">		short[] types = metaTC.getTraceTypes();</span>
<span class="nc bnc" id="L3863" title="All 2 branches missed.">		for (short idx = 0; idx &lt; types.length; idx++) {</span>
<span class="nc bnc" id="L3864" title="All 2 branches missed.">			if (!metaTC.isTraceTypeComputed(types[idx])) {</span>
<span class="nc" id="L3865">				typeLen++;</span>
			}
		}
<span class="nc bnc" id="L3868" title="All 4 branches missed.">		if (metaTC instanceof PredictTraceCube || metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L3869">			boolean RTC = metaTC instanceof RequireTraceCube;</span>
<span class="nc" id="L3870">			Date prvEndOfDay = null;</span>
			// predict is always precombined just load
<span class="nc bnc" id="L3872" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3873">				DstObject dstObj = new DstObject();</span>
<span class="nc" id="L3874">				dstObj.lineStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;DATETIME&quot;));</span>
<span class="nc" id="L3875">				TimeZone tz = TimeZone.getTimeZone(rs.getString(&quot;JAVATZIDENT&quot;));</span>
<span class="nc" id="L3876">				dstObj.spStartDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;FROMDATE&quot;));</span>
<span class="nc" id="L3877">				dstObj.spEndDate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TODATE&quot;));</span>
				// used in report dump logic
<span class="nc" id="L3879">				dstObj = getDSTFix(dstObj, tz, prvEndOfDay, start, end);</span>
<span class="nc bnc" id="L3880" title="All 2 branches missed.">				if (dstObj.shouldSkip(start, end)) {</span>
<span class="nc" id="L3881">					continue;</span>
				}
<span class="nc bnc" id="L3883" title="All 2 branches missed.">				if (dstObj.needNewTraceCube) {</span>
					// Flush the contents of the tcarray since this is the real start line.
<span class="nc" id="L3885">					tcArray.clear();</span>
				}
<span class="nc" id="L3887">				Date insertPoint = dstObj.lineStart;</span>
				// 92 points day, need shrink sameet
<span class="nc" id="L3889">				boolean tfrIn = dstObj.tfrIn;</span>
				// 100 points day, need expand
<span class="nc" id="L3891">				boolean tfrOut = dstObj.tfrOut;</span>
				// track points
<span class="nc" id="L3893">				int dstPoints = dstObj.dstPoints;</span>
				// temp variable to track transition
<span class="nc" id="L3895">				boolean prvDSTFlag = dstObj.prvDSTFlag;</span>
<span class="nc bnc" id="L3896" title="All 2 branches missed.">				for (int i = 0; i &lt; Trace.DAYPOINTS; i++) {</span>
<span class="nc bnc" id="L3897" title="All 2 branches missed.">					if (fallsIn(insertPoint, start, end)) {</span>
<span class="nc bnc" id="L3898" title="All 6 branches missed.">						if (dstPoints != 0 &amp;&amp; (tfrIn || tfrOut)) {</span>
							// if transition will happen on this line
<span class="nc bnc" id="L3900" title="All 2 branches missed.">							if (tz.inDaylightTime(insertPoint) != prvDSTFlag) {</span>
								// from this point, there is dst transition
<span class="nc" id="L3902">								int dstIntv = dstPoints / (int) Trace.INTERVAL_IN_MILLIS;</span>
<span class="nc bnc" id="L3903" title="All 2 branches missed.">								if (tfrIn) {</span>
									// skip points
<span class="nc" id="L3905">									i += dstIntv - 1;</span>
<span class="nc bnc" id="L3906" title="All 2 branches missed.">									prvDSTFlag = !prvDSTFlag;</span>
<span class="nc" id="L3907">									continue;</span>
								}
								// add points
<span class="nc bnc" id="L3910" title="All 2 branches missed.">								for (int j = 0; j &lt; dstIntv; j++) {</span>
<span class="nc" id="L3911">									TraceChunk tc = new TraceChunk(null, insertPoint);</span>
<span class="nc bnc" id="L3912" title="All 2 branches missed.">									if (RTC) {</span>
<span class="nc" id="L3913">										tc.setTraceValue(Trace.FTE, Trace.TRACENA);</span>
									} else {
<span class="nc" id="L3915">										tc.setTraceValue(Trace.PCA, Trace.TRACENA);</span>
<span class="nc" id="L3916">										tc.setTraceValue(Trace.ASA, Trace.TRACENA);</span>
<span class="nc" id="L3917">										tc.setTraceValue(Trace.ABANDONMENT, Trace.TRACENA);</span>
<span class="nc" id="L3918">										tc.setTraceValue(Trace.BACKLOG, Trace.TRACENA);</span>
<span class="nc" id="L3919">										tc.setTraceValue(Trace.STAFFING, Trace.TRACENA);</span>
<span class="nc" id="L3920">										tc.setTraceValue(Trace.OCCUPANCY, Trace.TRACENA);</span>
<span class="nc" id="L3921">										tc.setTraceValue(Trace.FTE, Trace.TRACENA);</span>
<span class="nc" id="L3922">										tc.setTraceValue(Trace.DIALS, Trace.TRACENA);</span>
<span class="nc" id="L3923">										tc.setTraceValue(Trace.CONNECTS, Trace.TRACENA);</span>
<span class="nc" id="L3924">										tc.setTraceValue(Trace.ASTAFFING, Trace.TRACENA);</span>
<span class="nc" id="L3925">										tc.setTraceValue(Trace.AFTE, Trace.TRACENA);</span>
<span class="nc" id="L3926">										tc.setTraceValue(Trace.NETSTAFFING, Trace.TRACENA);</span>
									}
<span class="nc" id="L3928">									tcArray.add(tc);</span>
<span class="nc" id="L3929">									insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
								}
							}
						}
<span class="nc" id="L3933">						TraceChunk tc = new TraceChunk(null, insertPoint);</span>
<span class="nc bnc" id="L3934" title="All 2 branches missed.">						if (RTC) {</span>
<span class="nc" id="L3935">							tc.setTraceValue(Trace.FTE, rs.getFloat(typeLen * i + 1));</span>
						} else {
<span class="nc" id="L3937">							tc.setTraceValue(Trace.PCA, rs.getFloat(typeLen * i + 1));</span>
<span class="nc" id="L3938">							tc.setTraceValue(Trace.ASA, rs.getFloat(typeLen * i + 2));</span>
<span class="nc" id="L3939">							tc.setTraceValue(Trace.ABANDONMENT, rs.getFloat(typeLen * i + 3));</span>
<span class="nc" id="L3940">							tc.setTraceValue(Trace.BACKLOG, rs.getFloat(typeLen * i + 4));</span>
<span class="nc" id="L3941">							tc.setTraceValue(Trace.STAFFING, rs.getFloat(typeLen * i + 5));</span>
<span class="nc" id="L3942">							tc.setTraceValue(Trace.OCCUPANCY, rs.getFloat(typeLen * i + 6));</span>
<span class="nc" id="L3943">							tc.setTraceValue(Trace.FTE, rs.getFloat(typeLen * i + 7));</span>
<span class="nc" id="L3944">							tc.setTraceValue(Trace.DIALS, rs.getFloat(typeLen * i + 8));</span>
						}
<span class="nc" id="L3946">						tcArray.add(tc);</span>
<span class="nc bnc" id="L3947" title="All 2 branches missed.">					} else if (insertPoint.after(end)) {</span>
<span class="nc" id="L3948">						break;</span>
					}
<span class="nc bnc" id="L3950" title="All 4 branches missed.">					if (tfrIn || tfrOut) {</span>
<span class="nc" id="L3951">						prvDSTFlag = tz.inDaylightTime(insertPoint);</span>
					}
<span class="nc" id="L3953">					insertPoint = new Date(insertPoint.getTime() + Trace.INTERVAL_IN_MILLIS);</span>
				}
<span class="nc" id="L3955">				prvEndOfDay = insertPoint;</span>
<span class="nc" id="L3956">			}</span>
		}
<span class="nc bnc" id="L3958" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc bnc" id="L3959" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L3960">				Date curTime = TimeZoneUtil.toDate(rs.getTimestamp(4));</span>
<span class="nc" id="L3961">				boolean typeASAEnabled = isTypeASAEnabled(mediaID, rs.getBoolean(5));</span>
<span class="nc" id="L3962">				boolean typeDeadlineTimeEnabled = isTypeDeadlineTimeEnabled(mediaID, rs.getBoolean(5));</span>
				// hack for ops release. set PCAType to false to always show SL
<span class="nc" id="L3964">				TraceChunk sgTC = new TraceChunk(null, curTime);</span>
<span class="nc bnc" id="L3965" title="All 2 branches missed.">				if (!typeASAEnabled) {</span>
<span class="nc" id="L3966">					sgTC.setTraceValue(Trace.PCA, rs.getFloat(1));</span>
				}
<span class="nc bnc" id="L3968" title="All 2 branches missed.">				if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3969">					sgTC.setTraceValue(Trace.DEADLINE_TIME, rs.getFloat(2));</span>
				} else {
<span class="nc" id="L3971">					sgTC.setTraceValue(Trace.ASA, rs.getFloat(2));</span>
				}
<span class="nc" id="L3973">				sgTC.setTraceValue(Trace.ABANDONMENT, rs.getFloat(3));</span>
<span class="nc" id="L3974">				tcArray.add(sgTC);</span>
				// Add 3 identical TCs, as DE service goal is per hour, report is per 15 mins
<span class="nc bnc" id="L3976" title="All 2 branches missed.">				for (int i = 1; i &lt; 4; i++) {</span>
<span class="nc" id="L3977">					TraceChunk tc1 = new TraceChunk(null, new Date(curTime.getTime() + i * Trace.INTERVAL_IN_MILLIS));</span>
<span class="nc bnc" id="L3978" title="All 2 branches missed.">					if (!typeASAEnabled) {</span>
<span class="nc" id="L3979">						tc1.setTraceValue(Trace.PCA, sgTC.getTraceValue(Trace.PCA));</span>
<span class="nc bnc" id="L3980" title="All 2 branches missed.">						if (typeDeadlineTimeEnabled) {</span>
<span class="nc" id="L3981">							tc1.setTraceValue(Trace.DEADLINE_TIME, sgTC.getTraceValue(Trace.DEADLINE_TIME));</span>
						}
					} else {
<span class="nc" id="L3984">						tc1.setTraceValue(Trace.ASA, sgTC.getTraceValue(Trace.ASA));</span>
					}
<span class="nc" id="L3986">					tc1.setTraceValue(Trace.ABANDONMENT, sgTC.getTraceValue(Trace.ABANDONMENT));</span>
<span class="nc" id="L3987">					tcArray.add(tc1);</span>
				}
<span class="nc" id="L3989">			}</span>
		}
<span class="nc" id="L3991">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param queueID
	 * @param areatype
	 * @param start
	 * @param end
	 */
	public static void createAudit(ID campaignID, ID mediaID, ID queueID, short areatype, Date start, Date end)
			throws JdmoException {
<span class="nc" id="L4003">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4005">			HashMap map = new HashMap();</span>
<span class="nc bnc" id="L4006" title="All 2 branches missed.">			if (campaignID != null) {</span>
<span class="nc" id="L4007">				map.put(&quot;CAMPAIGNID&quot;, campaignID);</span>
			}
<span class="nc bnc" id="L4009" title="All 2 branches missed.">			if (mediaID != null) {</span>
<span class="nc" id="L4010">				map.put(&quot;MEDIAID&quot;, mediaID);</span>
			}
<span class="nc bnc" id="L4012" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4013">				map.put(&quot;QUEUEID&quot;, queueID);</span>
			}
<span class="nc" id="L4015">			map.put(&quot;AREATYPE&quot;, NumberFactory.newShort(areatype));</span>
<span class="nc" id="L4016">			map.put(&quot;STARTTIME&quot;, start);</span>
<span class="nc" id="L4017">			map.put(&quot;ENDTIME&quot;, end);</span>
<span class="nc" id="L4018">			map.put(&quot;LASTMODIFIEDAT&quot;, new Date());</span>
<span class="nc" id="L4019">			jdmo.addBatchInsert(TIMESERIESAUDITTABLENAME, map);</span>
<span class="nc" id="L4020">			jdmo.executeBatch();</span>
		} finally {
<span class="nc" id="L4022">			jdmo.cleanUp();</span>
<span class="nc" id="L4023">		}</span>
<span class="nc" id="L4024">	}</span>

	/**
	 * @param campaignID
	 * @param mediaID
	 * @param queueID
	 * @param areatype
	 * @param start
	 * @param end
	 * @param lastCheck
	 */
	public static boolean hasAudit(ID campaignID, ID mediaID, ID queueID, Date start, Date end, Date lastCheck)
			throws JdmoException {
<span class="nc" id="L4037">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4039">			StringBuilder findAudit = new StringBuilder(128);</span>
<span class="nc" id="L4040">			findAudit.append(&quot;select AREATYPE from &quot;).append(TIMESERIESAUDITTABLENAME).append(&quot; where &quot;);</span>
<span class="nc bnc" id="L4041" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4042">				findAudit.append(&quot;QUEUEID=&quot;).append(queueID).append(&quot; and &quot;);</span>
<span class="nc bnc" id="L4043" title="All 2 branches missed.">			} else if (mediaID != null) {</span>
<span class="nc" id="L4044">				findAudit.append(&quot;MEDIAID=&quot;).append(mediaID).append(&quot; and &quot;);</span>
			} else {
<span class="nc" id="L4046">				findAudit.append(&quot;CAMPAIGNID=&quot;).append(campaignID).append(&quot; and &quot;);</span>
			}
<span class="nc" id="L4048">			findAudit.append(&quot;STARTTIME&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;' and ENDTIME&gt;='&quot;)</span>
<span class="nc" id="L4049">					.append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
<span class="nc bnc" id="L4050" title="All 2 branches missed.">			if (lastCheck != null) {</span>
<span class="nc" id="L4051">				findAudit.append(&quot; and LASTMODIFIEDAT&gt;='&quot;).append(JdmoUtil.formatDBString(lastCheck)).append(&quot;'&quot;);</span>
			}
<span class="nc" id="L4053">			JdmoRowset rs = jdmo.createRowset(findAudit.toString());</span>
<span class="nc" id="L4054">			return rs.next();</span>
		} finally {
<span class="nc" id="L4056">			jdmo.cleanUp();</span>
		}
	}

	public static boolean[] getAudit(ID campaignID, ID mediaID, ID queueID, Date start, Date end) throws JdmoException {
<span class="nc" id="L4061">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4063">			StringBuilder sb = new StringBuilder(&quot;select distinct AREATYPE from TRACETRACK where &quot;);</span>
<span class="nc bnc" id="L4064" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L4065">				sb.append(&quot;QUEUEID=&quot;).append(queueID);</span>
			} else {
<span class="nc bnc" id="L4067" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L4068">					sb.append(&quot;MEDIAID=&quot;).append(mediaID).append(&quot; and &quot;);</span>
				}
<span class="nc" id="L4070">				sb.append(&quot;CAMPAIGNID=&quot;).append(campaignID);</span>
			}
<span class="nc" id="L4072">			sb.append(&quot; and STARTTIME&lt;=&quot;).append(JdmoUtil.formatDBString(end)).append(&quot; and ENDTIME&gt;=&quot;)</span>
<span class="nc" id="L4073">					.append(JdmoUtil.formatDBString(start));</span>
<span class="nc" id="L4074">			JdmoRowset rs = jdmo.createRowset(sb.toString());</span>
<span class="nc" id="L4075">			boolean[] changedArea = new boolean[TraceUtil.MAXAREA];</span>
<span class="nc" id="L4076">			boolean changed = false;</span>
<span class="nc bnc" id="L4077" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4078">				short type = rs.getShort(1);</span>
<span class="nc bnc" id="L4079" title="All 2 branches missed.">				if (type &lt; TraceUtil.MAXAREA) {</span>
<span class="nc" id="L4080">					changed = true;</span>
<span class="nc" id="L4081">					changedArea[rs.getShort(1)] = true;</span>
				}
<span class="nc" id="L4083">			}</span>
<span class="nc bnc" id="L4084" title="All 2 branches missed.">			if (!changed) {</span>
<span class="nc" id="L4085">				return null;</span>
			}
<span class="nc" id="L4087">			return changedArea;</span>
		} finally {
<span class="nc" id="L4089">			jdmo.cleanUp();</span>
		}
	}

	public static Collection getCombinedQueueStaffing(ID campaignID, ID mediaID, Set spSet, Date start, Date end)
			throws JdmoException {
<span class="nc" id="L4095">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4097">			JdmoRowset rs = jdmo.createRowset(getCombinedQueueStaffingStmt(campaignID, mediaID, spSet, start, end, null, jdmo));</span>
<span class="nc" id="L4098">			ArrayList stfChunkCol = new ArrayList();</span>
<span class="nc bnc" id="L4099" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4100">				CombinedQueueStaffing stf = new CombinedQueueStaffing();</span>
<span class="nc" id="L4101">				stf.setTimeInterval(rs.getTimestamp(1));</span>
<span class="nc" id="L4102">				stf.setStaffing(rs.getFloat(2));</span>
<span class="nc" id="L4103">				stfChunkCol.add(stf);</span>
<span class="nc" id="L4104">			}</span>
<span class="nc" id="L4105">			return stfChunkCol;</span>
		} finally {
<span class="nc" id="L4107">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueStaffingStmt(ID campaignID, ID mediaID, Set spSet, Date start, Date end,
			Date lastUpdate, Jdmo jdmo) throws JdmoException {
<span class="nc" id="L4113">		StringBuilder pStmt = new StringBuilder(150);</span>
<span class="nc" id="L4114">		pStmt.append(&quot;select A.TIMEINTERVAL, A.STAFFING from SPCOMBINEDQUEUESTAFFING&quot;);</span>
<span class="nc" id="L4115">		pStmt.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID and C.SID in &quot;).append(jdmo.createInClause(spSet));</span>
<span class="nc" id="L4116">		pStmt.append(&quot; and QUEUEID is null and CAMPAIGNID=(select ID from CAMPAIGN where SID=&quot;).append(campaignID).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L4117" title="All 2 branches missed.">		if (mediaID != null) {</span>
<span class="nc" id="L4118">			pStmt.append(&quot; and MEDIAID=(select ID from MEDIA where SID=&quot;).append(mediaID).append(&quot;)&quot;);</span>
		} else {
<span class="nc" id="L4120">			pStmt.append(&quot; and MEDIAID is null&quot;);</span>
		}
<span class="nc bnc" id="L4122" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L4123">			pStmt.append(&quot; and A.TIMEINTERVAL&gt;='&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4125" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L4126">			pStmt.append(&quot; and A.TIMEINTERVAL&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4128" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L4129">			pStmt.append(&quot; and A.LASTMODIFIEDAT&gt;'&quot;).append(JdmoUtil.formatDBString(lastUpdate)).append(&quot;'&quot;);</span>
		}
<span class="nc" id="L4131">		return pStmt.toString();</span>
	}

	public static HashMap getCombinedQueueStaffing(ID campaignID, ID mediaID, Date start, Date end, Date lastUpdate)
			throws JdmoException {
<span class="nc" id="L4136">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4138">			JdmoRowset rs = jdmo.createRowset(getCombinedQueueStaffingStmt(campaignID, mediaID, start, end, lastUpdate, jdmo));</span>
<span class="nc" id="L4139">			HashMap stfMap = new HashMap();</span>
<span class="nc bnc" id="L4140" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4141">				CombinedQueueStaffing stf = new CombinedQueueStaffing();</span>
<span class="nc" id="L4142">				stf.setTimeInterval(rs.getTimestamp(1));</span>
<span class="nc" id="L4143">				stf.setStaffing(rs.getFloat(2));</span>
<span class="nc" id="L4144">				stfMap.put(stf.getTimeInterval(), stf);</span>
<span class="nc" id="L4145">			}</span>
<span class="nc" id="L4146">			return stfMap;</span>
		} finally {
<span class="nc" id="L4148">			jdmo.cleanUp();</span>
		}
	}

	private static String getCombinedQueueStaffingStmt(ID campaignID, ID mediaID, Date start, Date end, Date lastUpdate, Jdmo jdmo)
			throws JdmoException {
<span class="nc" id="L4154">		StringBuilder pStmt = new StringBuilder(150);</span>
<span class="nc" id="L4155">		pStmt.append(&quot;select A.TIMEINTERVAL, A.STAFFING from SPCOMBINEDQUEUESTAFFING&quot;);</span>
<span class="nc" id="L4156">		pStmt.append(&quot; A, SPQUEUE B, SP C where A.SPQUEUEID=B.ID and B.SPID=C.ID &quot;);</span>
<span class="nc" id="L4157">		pStmt.append(&quot; and B.QUEUEID is null and C.CAMPAIGNID=(select ID from CAMPAIGN where SID=&quot;).append(campaignID).append(&quot;)&quot;);</span>
		// Sameet Bug #81134 10/04/2005
		// Media Id should not be null and -10 (-10 represents no Media) for COMB-COMB QUEUES
<span class="nc bnc" id="L4160" title="All 4 branches missed.">		if (mediaID != null &amp;&amp; mediaID.toInt() != -10) {</span>
<span class="nc" id="L4161">			pStmt.append(&quot; and B.MEDIAID=(select ID from MEDIA where SID=&quot;).append(mediaID).append(&quot;)&quot;);</span>
		} else {
<span class="nc" id="L4163">			pStmt.append(&quot; and B.MEDIAID is null&quot;);</span>
		}
<span class="nc bnc" id="L4165" title="All 2 branches missed.">		if (start != null) {</span>
<span class="nc" id="L4166">			pStmt.append(&quot; and A.TIMEINTERVAL&gt;='&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4168" title="All 2 branches missed.">		if (end != null) {</span>
<span class="nc" id="L4169">			pStmt.append(&quot; and A.TIMEINTERVAL&lt;='&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
		}
<span class="nc bnc" id="L4171" title="All 2 branches missed.">		if (lastUpdate != null) {</span>
<span class="nc" id="L4172">			pStmt.append(&quot; and (A.LASTMODIFIEDAT is null or A.LASTMODIFIEDAT&gt;'&quot;).append(JdmoUtil.formatDBString(lastUpdate)).append(&quot;')&quot;);</span>
		}
<span class="nc" id="L4174">		return pStmt.toString();</span>
	}

	public static DstObject getDSTFix(DstObject dstObject, TimeZone tz, Date prvEndOfDay, Date start, Date end) {
		// This is debug for Dev purposes only
		if (false &amp;&amp; LOG.isDebugEnabled()) {
			StringBuilder sbuff = new StringBuilder();
			try {
				throw new Exception(&quot;TimeSeriesDAO getDSTFix() TRACE&quot;);
			} catch (Exception e) {
				StackTraceElement elem[] = e.getStackTrace();
				for (int i = 0; i &lt; (elem.length &gt; 3 ? 3 : elem.length); i++) {
					if (i == 1) {
						sbuff.append(&quot;Caller for getDSTFix[&quot;).append(elem[i].getLineNumber()).append(&quot;]&quot;).append(elem[i].getMethodName());
						LOG.debug(sbuff);
						break;
					}
				}
			}
		}
		try {
			// track points
<span class="nc" id="L4196">			dstObject.dstPoints = tz.getDSTSavings();</span>
			// temp variable to track transition
<span class="nc" id="L4198">			dstObject.prvDSTFlag = false;</span>
			// this is the computed end of the day start +24 hrs
<span class="nc" id="L4200">			dstObject.endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG - 1);</span>
<span class="nc" id="L4201">			boolean isDSTTransitionSPWeekOut = false;</span>
<span class="nc" id="L4202">			boolean isDSTTransitionSPWeekIn = false;</span>
<span class="nc bnc" id="L4203" title="All 2 branches missed.">			if (tz.useDaylightTime()) {</span>
<span class="nc bnc" id="L4204" title="All 4 branches missed.">				if (dstObject.spStartDate == null || dstObject.spEndDate == null) {</span>
<span class="nc" id="L4205">					LOG.info(&quot;.spStartDate ==null || spEndDate==null&quot;);</span>
<span class="nc" id="L4206">					throw new Exception(&quot;TimeSeriesDAO getDSTFix() spStartDate ==null || spEndDate==null&quot;);</span>
				}
<span class="nc bnc" id="L4208" title="All 4 branches missed.">				isDSTTransitionSPWeekOut = (tz.inDaylightTime(dstObject.spStartDate) &amp;&amp; !tz.inDaylightTime(dstObject.spEndDate));</span>
<span class="nc bnc" id="L4209" title="All 4 branches missed.">				isDSTTransitionSPWeekIn = (!tz.inDaylightTime(dstObject.spStartDate) &amp;&amp; tz.inDaylightTime(dstObject.spEndDate));</span>
<span class="nc" id="L4210">				dstObject.prvDSTFlag = tz.inDaylightTime(dstObject.lineStart);</span>
<span class="nc bnc" id="L4211" title="All 4 branches missed.">				dstObject.tfrOut = dstObject.prvDSTFlag &amp;&amp; !tz.inDaylightTime(dstObject.endOfDay);</span>
<span class="nc bnc" id="L4212" title="All 4 branches missed.">				dstObject.tfrIn = !dstObject.prvDSTFlag &amp;&amp; tz.inDaylightTime(dstObject.endOfDay);</span>

<span class="nc" id="L4214">				Date beforeStOfDay = new Date(dstObject.lineStart.getTime() - 1);</span>
<span class="nc bnc" id="L4215" title="All 4 branches missed.">				dstObject.tfrInBeforeStartOfday = dstObject.prvDSTFlag &amp;&amp; !tz.inDaylightTime(beforeStOfDay);</span>
<span class="nc bnc" id="L4216" title="All 4 branches missed.">				dstObject.tfrOutBeforeStartOfday = !dstObject.prvDSTFlag &amp;&amp; tz.inDaylightTime(beforeStOfDay);</span>

<span class="nc bnc" id="L4218" title="All 4 branches missed.">				if (dstObject.tfrInBeforeStartOfday || dstObject.tfrOutBeforeStartOfday) {</span>
<span class="nc" id="L4219">					dstObject.prvDSTFlag = tz.inDaylightTime(beforeStOfDay);</span>
				}

				// need to calculate real end of day after DSt transition in Apr, shrink by 4 points, its only 23 hr day
<span class="nc bnc" id="L4223" title="All 2 branches missed.">				if (dstObject.tfrIn) {</span>
<span class="nc" id="L4224">					dstObject.endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG</span>
							- dstObject.dstPoints - 1);
					// Skip this day completely if the start and end of the day do not fall in the start and end of SP
<span class="nc bnc" id="L4227" title="All 4 branches missed.">					if (!fallsIn(dstObject.lineStart, start, end) &amp;&amp; !fallsIn(dstObject.endOfDay, start, end)) {</span>
<span class="nc bnc" id="L4228" title="All 2 branches missed.">						if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L4229">							LOG.debug(&quot;DST transition SP; Skipping this day; endOfDay=&quot; + dstObject.endOfDay + &quot;:SP start&quot; + start);</span>
						}
<span class="nc" id="L4231">						dstObject.skipLoop = true;</span>
<span class="nc" id="L4232">						return dstObject;</span>
					}
				}
			}
<span class="nc bnc" id="L4236" title="All 4 branches missed.">			if (dstObject.lineStart.before(start) &amp;&amp; !fallsIn(start, dstObject.lineStart, dstObject.endOfDay)) {</span>
<span class="nc bnc" id="L4237" title="All 2 branches missed.">				if (LOG.isDebugEnabled()) {</span>
<span class="nc" id="L4238">					LOG.debug(&quot;Around DST transition SP; skipping this day totally dstObject.lineStart=&quot;</span>
							+ dstObject.lineStart + &quot; SP start=&quot; + start);
				}
<span class="nc" id="L4241">				dstObject.skipLoop = true;</span>
<span class="nc" id="L4242">				return dstObject;</span>

<span class="nc bnc" id="L4244" title="All 2 branches missed.">			} else if (dstObject.lineStart.equals(start)) {</span>
				// Ignore all the data Collected before this time since it was collected for wrong day
<span class="nc" id="L4246">				dstObject.needNewTraceCube = true;</span>
<span class="nc" id="L4247">				prvEndOfDay = null;</span>
			}

<span class="nc" id="L4250">			fixLineStartDueToThickClientWeirdness(dstObject, tz, isDSTTransitionSPWeekOut, isDSTTransitionSPWeekIn);</span>

<span class="nc" id="L4252">		} catch (Exception e) {</span>
<span class="nc" id="L4253">			LOG.error(e.getMessage(), e);</span>
<span class="nc" id="L4254">		}</span>
<span class="nc" id="L4255">		return fixDstObjectForPartialTransitions(dstObject, tz);</span>
	}

	private static DstObject fixDstObjectForPartialTransitions(DstObject dstObject, TimeZone tz) {

<span class="nc" id="L4260">		Calendar lineStartCal = Calendar.getInstance(tz);</span>
<span class="nc" id="L4261">		lineStartCal.setTime(dstObject.lineStart);</span>
<span class="nc" id="L4262">		int minutes = lineStartCal.get(Calendar.MINUTE);</span>
<span class="nc bnc" id="L4263" title="All 2 branches missed.">		if (minutes &gt; 0) {</span>

<span class="nc" id="L4265">			Date endOfDay = new Date(dstObject.lineStart.getTime() + TimeZoneUtil.DAY_IN_MILLISECONDS_LONG);</span>
<span class="nc bnc" id="L4266" title="All 2 branches missed.">			if (DSTConversionUtil.hourContainsPartialDaylightTransition(endOfDay, tz)) {</span>
				//final hour of the day
<span class="nc" id="L4268">				dstObject.dstPoints = minutes * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc bnc" id="L4269" title="All 2 branches missed.">			} else if (DSTConversionUtil.hourContainsPartialDaylightTransition(dstObject.lineStart, tz)) {</span>
				//first hour of the day
<span class="nc" id="L4271">				dstObject.dstPoints = (60 - minutes) * TimeZoneUtil.MINUTE_IN_MILLISECONDS;</span>
<span class="nc" id="L4272">				dstObject.prvDSTFlag = false;</span>
<span class="nc" id="L4273">				dstObject.tfrOut = false;</span>
<span class="nc" id="L4274">				dstObject.tfrIn = true;</span>
<span class="nc" id="L4275">				dstObject.isLineStartInPartialTransition = true;</span>
			}
		}
<span class="nc" id="L4278">		return dstObject;</span>
	}

			// If we are in a transition week, the C++ F&amp;S client will not put the correct start
			// times in the days following a DST transition for the remainder of that week.
			// Instead, it will continue to put start times as if there was no DST transition.
			// The data that is in that row represents data from the day boundary, but the start time
			// will not reflect that.
			//
			// We need to check for that scenario.
			//
			// First, check that a transition happens in the SP and has already occurred.
		private static void fixLineStartDueToThickClientWeirdness(DstObject dstObject, TimeZone tz,
					boolean isDSTTransitionSPWeekOut, boolean isDSTTransitionSPWeekIn) {
<span class="nc bnc" id="L4292" title="All 2 branches missed.">			if (isDSTTransitioning(dstObject, tz, isDSTTransitionSPWeekOut, isDSTTransitionSPWeekIn)) {</span>
<span class="nc" id="L4293">				Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L4294">				cal.setTime(dstObject.spEndDate);</span>
<span class="nc" id="L4295">				int spEndHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L4296">				int spEndMinute = cal.get(Calendar.MINUTE);</span>

<span class="nc" id="L4298">				cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L4299">				cal.setTime(dstObject.lineStart);</span>
<span class="nc" id="L4300">				int lineStartHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L4301">				int lineStartMinute = cal.get(Calendar.MINUTE);</span>

				// If the wall clock hour or seconds do not match, it probably
				// is because F&amp;S didn't apply the DST amount. Shift the times
				// by the DST amount
<span class="nc bnc" id="L4306" title="All 4 branches missed.">				if ((spEndHour != lineStartHour) || (spEndMinute != lineStartMinute)) {</span>
<span class="nc bnc" id="L4307" title="All 2 branches missed.">					if (isDSTTransitionSPWeekOut) {</span>
<span class="nc" id="L4308">						cal.add(Calendar.MILLISECOND, tz.getDSTSavings());</span>
<span class="nc bnc" id="L4309" title="All 2 branches missed.">					} else if (isDSTTransitionSPWeekIn) {</span>
<span class="nc" id="L4310">						cal.add(Calendar.MILLISECOND, -tz.getDSTSavings());</span>
					}
					// Check that we actually solved the issue.
<span class="nc bnc" id="L4313" title="All 4 branches missed.">					if ((spEndHour == cal.get(Calendar.HOUR_OF_DAY)) &amp;&amp; (spEndMinute == cal.get(Calendar.MINUTE))) {</span>
<span class="nc" id="L4314">						dstObject.lineStart = new Date(cal.getTime().getTime());</span>
					} else {
<span class="nc" id="L4316">						logWeirdness(dstObject);</span>
					}
				}
			}
<span class="nc" id="L4320">		}</span>

	private static boolean isDSTTransitioning(DstObject dstObject, TimeZone tz, boolean isDSTTransitionSPWeekOut, boolean 
			isDSTTransitionSPWeekIn) {
<span class="nc bnc" id="L4324" title="All 6 branches missed.">		boolean dstTransitioningOut = isDSTTransitionSPWeekOut &amp;&amp; (!tz.inDaylightTime(dstObject.lineStart) &amp;&amp; !dstObject</span>
			.tfrOutBeforeStartOfday);
<span class="nc bnc" id="L4326" title="All 6 branches missed.">		boolean dstTransitioningIn = isDSTTransitionSPWeekIn &amp;&amp; (tz.inDaylightTime(dstObject.lineStart) &amp;&amp; !dstObject</span>
			.tfrInBeforeStartOfday);
<span class="nc bnc" id="L4328" title="All 4 branches missed.">		return dstTransitioningOut || dstTransitioningIn;</span>
	}

	private static void logWeirdness(DstObject dstObject) {
						// The issue was something other than the F&amp;S client
						// neglecting to use the DST offset for the start
						// timestamp, so log it.
<span class="nc" id="L4335">						SimpleDateFormat timestampFormat = new SimpleDateFormat(&quot;yyyy-MM-dd'T'HH:mm:ssZ&quot;);</span>
<span class="nc" id="L4336">						timestampFormat.setTimeZone(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L4337">						SimpleDateFormat timeFormat = new SimpleDateFormat(&quot;HH:mm:ssZ&quot;);</span>
<span class="nc" id="L4338">						timeFormat.setTimeZone(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L4339">						LOG.l7dWarn(</span>
								BbmEjbLogBundleKey.UNEXPECTED_TIME_SERIES_DATETIME, 
<span class="nc" id="L4341">								new Object[]{timestampFormat.format(dstObject.lineStart), timeFormat.format(dstObject.spEndDate)});</span>
<span class="nc" id="L4342">					}</span>

	private static boolean isTypeASAEnabled(ID mediaID, boolean typeASAEnabled) {
		// removed earlier hack done by amit for ops release. set PCAType to false to always show SL.
		// Change:
		// typeASAEnabled should always be false for Defered and null media as per Jason,
		// Should always consider PCA if media type does not exist or is defered.
		// Sameet, Apr-2008
<span class="nc bnc" id="L4350" title="All 4 branches missed.">		if (mediaID == null || !Media.isMediaImmediate(mediaID)) {</span>
<span class="nc" id="L4351">			typeASAEnabled = false;</span>
		}
<span class="nc" id="L4353">		return typeASAEnabled;</span>
	}

	/**
	 * Returns whether deadline time should be populated for the specified media ID and goal type.
	 *
	 * @param mediaID
	 * @return
	 */
	private static boolean isTypeDeadlineTimeEnabled(ID mediaID, boolean nonPCAGoalType) {
<span class="nc bnc" id="L4363" title="All 6 branches missed.">		return nonPCAGoalType &amp;&amp; mediaID != null &amp;&amp; Media.isMediaDeferred(mediaID);</span>
	}

	/**
	 * Returns whether dials data should be populated for the specified media ID.
	 *
	 * @param mediaID
	 * @return
	 */
	private static boolean isTypeMaxDialsEnabled(ID mediaID) {
<span class="nc bnc" id="L4373" title="All 4 branches missed.">		return mediaID != null &amp;&amp; Media.isMediaOutbound(mediaID);</span>
	}

	/**
	 *
	 */

	public static void updatePredictTraceCube(PredictTraceCube cube, short[] types, Map&lt;? extends ID, SPQueue&gt; spQMap)
			throws Exception {
<span class="nc" id="L4382">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L4384">			SPQueue spQ = spQMap.get(cube.getSPQueueSID());</span>
<span class="nc" id="L4385">			ID spID = spQ.getSpID();</span>
<span class="nc" id="L4386">			SchedulingPeriodDAO spDAO = new SchedulingPeriodDAO(jdmo);</span>
<span class="nc" id="L4387">			SchedulingPeriod sp = spDAO.getSchedulingPeriodByID(spID);</span>
<span class="nc" id="L4388">			Date spStartDate = sp.getStartTime();</span>
<span class="nc" id="L4389">			ID campaignID = sp.getCampaignID();</span>
<span class="nc" id="L4390">			CampaignDAO campDAO = new CampaignDAO(jdmo);</span>
<span class="nc" id="L4391">			Campaign camp = campDAO.getCampaignByID(campaignID, false);</span>
<span class="nc" id="L4392">			Calendar cal = Calendar.getInstance(camp.getTimeZone());</span>
<span class="nc" id="L4393">			cal.setTime(spStartDate);</span>

			// we need to initially set i to the offset of the start of the cube relative to the SP day that it falls in.
<span class="nc" id="L4396">			int i = getIntervalOffset(spStartDate, cube.getRawStartDate(), camp.getTimeZone());</span>
<span class="nc" id="L4397">			int dayOffset = i / Trace.DAYPOINTS;</span>
<span class="nc" id="L4398">			i %= Trace.DAYPOINTS;</span>

<span class="nc bnc" id="L4400" title="All 2 branches missed.">			for (int dayCounter = 0; dayCounter &lt; dayOffset; dayCounter++) {</span>
<span class="nc" id="L4401">				cal.add(Calendar.DAY_OF_MONTH, 1);</span>
			}

<span class="nc" id="L4404">			int j = 0;</span>
<span class="nc bnc" id="L4405" title="All 2 branches missed.">			while (cal.getTime().before(cube.getRawEndDate())) {</span>
<span class="nc" id="L4406">				StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L4407">				pStmt.append(&quot; UPDATE &quot;).append(PREDICTTRACETABLENAME).append(&quot; SET &quot;);</span>
<span class="nc" id="L4408">				boolean isFirstValue = true;</span>
				// in data array, data is stored from index 0. but the column name in db is starting from index 1.
<span class="nc" id="L4410">				boolean reachedEndOfarray = false;</span>

<span class="nc bnc" id="L4412" title="All 2 branches missed.">				for (; i &lt; Trace.DAYPOINTS; i++, j++) {</span>
<span class="nc bnc" id="L4413" title="All 2 branches missed.">					for (short t = 0; t &lt; types.length; t++) {</span>
<span class="nc bnc" id="L4414" title="All 4 branches missed.">						if (!cube.isTraceTypeComputed(types[t]) &amp;&amp; cube.isDirty(types[t])) {</span>
<span class="nc" id="L4415">							double[] traceValArray = cube.getTraceValueD(types[t]);</span>
<span class="nc bnc" id="L4416" title="All 4 branches missed.">							if (traceValArray == null || traceValArray.length &lt;= j) {</span>
<span class="nc" id="L4417">								LOG.debug(&quot;stopping update for this trace type; reached the end of array; it has no values tracetype=&quot;</span>
<span class="nc" id="L4418">										+ getTraceColumn(types[t]) + &quot; index=&quot; + j);</span>
<span class="nc" id="L4419">								reachedEndOfarray = true;</span>
								// reached the end of array of array has no values
<span class="nc" id="L4421">								break;</span>
							}
<span class="nc bnc" id="L4423" title="All 2 branches missed.">							if (isFirstValue) {</span>
<span class="nc" id="L4424">								isFirstValue = false;</span>
							} else {
<span class="nc" id="L4426">								pStmt.append(&quot;, &quot;);</span>
							}
<span class="nc" id="L4428">							pStmt.append(getDETraceColumn(types[t])).append(i + 1).append(&quot;=&quot;)</span>
<span class="nc" id="L4429">									.append((float) cube.getTraceValueD(types[t], j));</span>
						}
					}
<span class="nc bnc" id="L4432" title="All 2 branches missed.">					if (reachedEndOfarray) {</span>
<span class="nc" id="L4433">						LOG.debug(&quot;stopping update all trace types; reached the end of array; it has no values index=&quot; + j);</span>
<span class="nc" id="L4434">						break;</span>
					}
				}
				// if isFirstValue==false then it means there is something to update
<span class="nc bnc" id="L4438" title="All 2 branches missed.">				if (isFirstValue == false) {</span>
<span class="nc" id="L4439">					pStmt.append(&quot; where SPQUEUEID ='&quot;).append(spQ.getDEID()).append(&quot;' AND DATETIME='&quot;)</span>
<span class="nc" id="L4440">							.append(JdmoUtil.formatDBString(cal.getTime())).append(&quot;'&quot;);</span>
<span class="nc" id="L4441">					jdmo.execute(pStmt.toString());</span>
				} else {
<span class="nc" id="L4443">					LOG.error(&quot;ERROR NOTHING TO UPDATE ; where SPQUEUEID ='&quot; + spQ.getDEID() + &quot;' AND DATETIME='&quot;</span>
<span class="nc" id="L4444">							+ JdmoUtil.formatDBString(cal.getTime()) + &quot;'\t CUBE=&quot; + cube);</span>
				}
<span class="nc" id="L4446">				cal.add(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L4447">				i = 0; // start of the next day in the SP</span>
<span class="nc" id="L4448">			}</span>
		} finally {
<span class="nc" id="L4450">			jdmo.cleanUp();</span>
<span class="nc" id="L4451">		}</span>
<span class="nc" id="L4452">	}</span>

	/**
	 * Get the number of 15-minute intervals between two dates.
	 */
	private static int getIntervalOffset(Date startDate, Date endDate, TimeZone tz) {
<span class="nc" id="L4458">		int i = 0;</span>
<span class="nc" id="L4459">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L4460">		cal.setTime(startDate);</span>

<span class="nc bnc" id="L4462" title="All 2 branches missed.">		while (cal.getTime().before(endDate)) {</span>
<span class="nc" id="L4463">			cal.add(Calendar.MINUTE, 15);</span>
<span class="nc" id="L4464">			i++;</span>
		}
<span class="nc" id="L4466">		return i;</span>
	}

	/**
	 * Get the SPIDS to recalc based on Changes to Forecasted data ( checks Time of change of Forecasted data with Predicted Data to decide
	 * which SPs need recalc. Only checks for SPs that falls in the date range from today to (Today + lookfwdDays) Also returns SPIDS that
	 * have any scheduling activity for the same range=&gt;has defect 144472 Defect 144472:The old query only gets data on SPWORKRESOURCE so it
	 * only works if the SP has isUsingallemployees =0, then employees are physically added to SPWORKRESOURCE The fixed query also handles
	 * for isUsingallemployees =1, the employees will get from spcallcenter and workresourceorganization
	 *
	 * @param lookfwdDays
	 * @return
	 * @throws com.bluepumpkin.ejb.bbm.base.BbmFinderException
	 *
	 * @throws java.rmi.RemoteException
	 */
	public static Set getSPIDsToReCalc(int lookfwdDays, Date lastRunTime) throws Exception {
<span class="nc" id="L4483">		Jdmo jdmo = null;</span>
<span class="nc" id="L4484">		HashSet retSet = new HashSet();</span>
<span class="nc" id="L4485">		JdmoRowset rs = null;</span>
		try {
<span class="nc" id="L4487">			jdmo = new Jdmo();</span>
<span class="nc" id="L4488">			StringBuffer pStmt = new StringBuffer();</span>
<span class="nc" id="L4489">			pStmt.append(&quot; SELECT DISTINCT SP.SID &quot;);</span>
<span class="nc" id="L4490">			pStmt.append(&quot; FROM FORECASTTIMESERIES F with (nolock), PREDICTEDTIMESERIES P with (nolock), &quot;);</span>
<span class="nc" id="L4491">			pStmt.append(&quot; SPQUEUE Q with (nolock), SP with (nolock) &quot;);</span>
<span class="nc" id="L4492">			pStmt.append(&quot; WHERE F.SPQUEUEID in (SELECT DISTINCT ID FROM SPQUEUE WHERE SPQUEUE.SPID = Q.SPID) &quot;);</span>
<span class="nc" id="L4493">			pStmt.append(&quot; AND P.SPQUEUEID in (SELECT DISTINCT ID FROM SPQUEUE WHERE SPQUEUE.SPID = Q.SPID) &quot;);</span>
<span class="nc" id="L4494">			pStmt.append(&quot; AND Q.SPID = SP.ID AND Q.ID = F.SPQUEUEID AND F.DATETIME= P.DATETIME &quot;);</span>
<span class="nc" id="L4495">			pStmt.append(&quot; AND ( F.CREATED &gt; P.CREATED ) &quot;);</span>
<span class="nc" id="L4496">			pStmt.append(&quot; AND F.DATETIME&lt; (GETUTCDATE() + &quot;).append(lookfwdDays).append(&quot;) &quot;);</span>
<span class="nc" id="L4497">			pStmt.append(&quot; AND F.DATETIME &gt;='&quot;).append(JdmoUtil.formatDBString(lastRunTime)).append(&quot;'&quot;);</span>
<span class="nc" id="L4498">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L4499" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4500">				retSet.add(rs.getID(1));</span>
			}
<span class="nc bnc" id="L4502" title="All 2 branches missed.">			if (rs != null) {</span>
<span class="nc" id="L4503">				rs.close();</span>
			}

<span class="nc" id="L4506">			pStmt = new StringBuffer();</span>
<span class="nc" id="L4507">			pStmt.append(&quot; SELECT DISTINCT SP.SID FROM AUDITTRAILENTRY A with (nolock), SP with (nolock) &quot;);</span>
<span class="nc" id="L4508">			pStmt.append(&quot; WHERE IMPACTSTART&lt;TODATE AND IMPACTEND&gt;FROMDATE &quot;);</span>
<span class="nc" id="L4509">			pStmt.append(&quot; AND MODULEID = &quot;).append(AuditTrailEntry.MODULE_SCHEDULING);</span>

			//make sure the modified schedule is between the lookback and lookforward
<span class="nc" id="L4512">			pStmt.append(&quot; AND IMPACTSTART &lt;= (GETUTCDATE()+ &quot;).append(lookfwdDays).append(&quot;) &quot;);</span>
<span class="nc" id="L4513">			pStmt.append(&quot; AND IMPACTSTART &gt; '&quot;).append(JdmoUtil.formatDBString(lastRunTime)).append(&quot;' &quot;);</span>

			//An SP's statistics are out-of-date if the schedule was changed after the last recalc
<span class="nc" id="L4516">			pStmt.append(&quot; AND ATWHEN &gt; (SELECT ISNULL(MAX(E.ATWHEN), '&quot;).append(JdmoUtil.formatDBString(lastRunTime)).append(&quot;') &quot;);</span>
<span class="nc" id="L4517">			pStmt.append(&quot; FROM AUDITTRAILENTRY E, AUDITTRAILPROPERTY P WHERE E.ID = P.AUDITTRAILENTRYID AND E.ACTIONID = &quot;);</span>
<span class="nc" id="L4518">			pStmt.append(AuditTrailEntry.ACTION_SCHEDULER_COMPLETE);</span>
<span class="nc" id="L4519">			pStmt.append(&quot; and E.PRIMARYOBJECTID = SP.SID &quot;);</span>
<span class="nc" id="L4520">			pStmt.append(&quot; and E.MODULEID = &quot;).append(AuditTrailEntry.MODULE_SCHEDULING).append(&quot; and P.NAME='Scheduling Mode' &quot;);</span>
<span class="nc" id="L4521">			pStmt.append(&quot; and P.VALUE in ('SILENTRECALC', 'SILENTRECALCWEB', 'RECALC', 'RECALCWEB', 'SCHEDULE', 'SCHEDULENOUI', &quot;);</span>
<span class="nc" id="L4522">			pStmt.append(&quot; 'SCHEDULEWEB', 'SCHEDULENOUIWEB')) &quot;);</span>
<span class="nc" id="L4523">			pStmt.append(&quot; AND ((SP.ISUSINGALLEMPLOYEES = 0 and SP.ID in (select w.SPID from SPWORKRESOURCE w with (nolock) &quot;);</span>
<span class="nc" id="L4524">			pStmt.append(&quot; where WORKRESOURCEID = PRIMARYOBJECTID and SP.ISUSINGALLEMPLOYEES = 0)) &quot;);</span>
<span class="nc" id="L4525">			pStmt.append(&quot; OR (SP.ISUSINGALLEMPLOYEES = 1 and SP.ID in (select sp_o.SPID from workresourceorganization wrs &quot;);</span>
<span class="nc" id="L4526">			pStmt.append(&quot; inner join spcallcenter sp_o on wrs.ORGANIZATIONid = sp_o.organizationid &quot;);</span>
<span class="nc" id="L4527">			pStmt.append(&quot; inner join WORKRESOURCE r on r.ID = wrs.WORKRESOURCEID where sp_o.SPID = sp.id &quot;);</span>
<span class="nc" id="L4528">			pStmt.append(&quot; and SP.ISUSINGALLEMPLOYEES = 1 and WORKRESOURCEID = PRIMARYOBJECTID))) &quot;);</span>

<span class="nc" id="L4530">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc bnc" id="L4531" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4532">				retSet.add(rs.getID(1));</span>
			}
		} finally {
<span class="nc bnc" id="L4535" title="All 4 branches missed.">			if (rs != null) {</span>
<span class="nc" id="L4536">				rs.close();</span>
			}
<span class="nc bnc" id="L4538" title="All 4 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L4539">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L4542">		return retSet;</span>
	}

	/**
	 * Checks if Forecasted staffing &amp; FTE exists for the given time range for the said employee QC 138372: The old query only gets data on
	 * SPWORKRESOURCE so it only works if the SP has isUsingallemployees =0, then employees are physically added to SPWORKRESOURCE The
	 * fixed query also handles for isUsingallemployees =1, the employees will get from spcallcenter and workresourceorganization.
	 *
	 * @param empID
	 * @param start
	 * @param end
	 * @return
	 */
	public static boolean doesStaffingExistForPeriod(ID empID, Date start, Date end) throws Exception {
<span class="nc" id="L4556">		Jdmo jdmo = null;</span>
<span class="nc" id="L4557">		JdmoRowset rs = null;</span>
		try {
<span class="nc" id="L4559">			jdmo = new Jdmo();</span>
<span class="nc" id="L4560">			StringBuilder pStmt = new StringBuilder();</span>
<span class="nc" id="L4561">			pStmt.append(&quot;	SELECT DISTINCT SP.ID ,SP.FROMDATE,SP.TODATE,SP.ISUSINGALLEMPLOYEES &quot;);</span>
<span class="nc" id="L4562">			pStmt.append(&quot;	FROM PREDICTEDTIMESERIES P &quot;);</span>
<span class="nc" id="L4563">			pStmt.append(&quot;		INNER JOIN SPQUEUE Q ON Q.ID =P.SPQUEUEID &quot;);</span>
<span class="nc" id="L4564">			pStmt.append(&quot;		INNER JOIN SP SP ON SP.ID = Q.SPID &quot;);</span>
<span class="nc" id="L4565">			pStmt.append(&quot;	CROSS APPLY( &quot;);</span>
<span class="nc" id="L4566">			pStmt.append(&quot;		SELECT SP.ID &quot;);</span>
<span class="nc" id="L4567">			pStmt.append(&quot;		FROM SPWORKRESOURCE W &quot;);</span>
<span class="nc" id="L4568">			pStmt.append(&quot;			INNER JOIN WORKRESOURCE WR ON WR.ID = W.WORKRESOURCEID &quot;);</span>
<span class="nc" id="L4569">			pStmt.append(&quot;		WHERE W.SPID=SP.ID AND WR.WORKRESTYPE ='&quot;).append(WorkResourceInner.TYPE_EMPLOYEE).append(&quot;' &quot;);</span>
<span class="nc" id="L4570">			pStmt.append(&quot;			AND W.WORKRESOURCEID=&quot;).append(empID);</span>
<span class="nc" id="L4571">			pStmt.append(&quot;			AND SP.ISUSINGALLEMPLOYEES = 0&quot;);</span>
<span class="nc" id="L4572">			pStmt.append(&quot;		UNION ALL&quot;);</span>
<span class="nc" id="L4573">			pStmt.append(&quot;		SELECT SPC.SPID &quot;);</span>
<span class="nc" id="L4574">			pStmt.append(&quot;		FROM SPCALLCENTER SPC&quot;);</span>
<span class="nc" id="L4575">			pStmt.append(&quot;			INNER JOIN WORKRESOURCEORGANIZATION WRO ON WRO.ORGANIZATIONID=SPC.ORGANIZATIONID&quot;);</span>
<span class="nc" id="L4576">			pStmt.append(&quot;			INNER JOIN WORKRESOURCE W  ON W.ID = WRO.WORKRESOURCEID&quot;);</span>
<span class="nc" id="L4577">			pStmt.append(&quot;		WHERE &quot;);</span>
<span class="nc" id="L4578">			pStmt.append(&quot;			SPC.SPID=SP.ID &quot;);</span>
<span class="nc" id="L4579">			pStmt.append(&quot;			AND W.WORKRESTYPE ='&quot;).append(WorkResourceInner.TYPE_EMPLOYEE).append(&quot;'&quot;);</span>
<span class="nc" id="L4580">			pStmt.append(&quot;			AND WRO.WORKRESOURCEID=&quot;).append(empID);</span>
<span class="nc" id="L4581">			pStmt.append(&quot;			AND SP.ISUSINGALLEMPLOYEES = 1&quot;);</span>
<span class="nc" id="L4582">			pStmt.append(&quot;			AND WRO.STARTTIME&lt;SP.TODATE AND (WRO.ENDTIME&gt;SP.FROMDATE OR WRO.ENDTIME IS NULL)&quot;);</span>
<span class="nc" id="L4583">			pStmt.append(&quot;			AND WRO.STARTTIME&lt;'&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
<span class="nc" id="L4584">			pStmt.append(&quot;			AND  (WRO.ENDTIME&gt;'&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;' OR WRO.ENDTIME IS NULL)&quot;);</span>
<span class="nc" id="L4585">			pStmt.append(&quot;	) B &quot;);</span>
<span class="nc" id="L4586">			pStmt.append(&quot;	WHERE SP.FROMDATE&lt;'&quot;).append(JdmoUtil.formatDBString(end)).append(&quot;'&quot;);</span>
<span class="nc" id="L4587">			pStmt.append(&quot;		AND SP.TODATE&gt;'&quot;).append(JdmoUtil.formatDBString(start)).append(&quot;'&quot;);</span>
			

<span class="nc" id="L4590">			rs = jdmo.createRowset(pStmt.toString());</span>
<span class="nc" id="L4591">			TreeSet retSet = new TreeSet();</span>
<span class="nc bnc" id="L4592" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4593">				TimeRange tr = new TimeRange(rs.getTimestamp(2), rs.getTimestamp(3));</span>
<span class="nc bnc" id="L4594" title="All 4 branches missed.">				if (tr.includes(start) &amp;&amp; tr.includes(end)) {</span>
					// no point in going ahead this looks good. the period is contained in a single SP
<span class="nc" id="L4596">					return true;</span>
				}
<span class="nc" id="L4598">				retSet.add(tr);</span>
<span class="nc" id="L4599">			}</span>
<span class="nc bnc" id="L4600" title="All 2 branches missed.">			if (retSet.size() &gt; 1) {</span>
<span class="nc" id="L4601">				TimeRange rangePrev = null;</span>
<span class="nc" id="L4602">				boolean startDateIsIncluded = false;</span>
<span class="nc" id="L4603">				boolean endDateIsIncluded = false;</span>
<span class="nc bnc" id="L4604" title="All 2 branches missed.">				for (Iterator iterator = retSet.iterator(); iterator.hasNext(); ) {</span>
<span class="nc" id="L4605">					TimeRange range = (TimeRange) iterator.next();</span>
<span class="nc bnc" id="L4606" title="All 4 branches missed.">					if (rangePrev != null &amp;&amp; range.getAdjacency(rangePrev) == TimeRange.ADJACENT_NONE) {</span>
						// there are gaps , return false. no point continuing
<span class="nc" id="L4608">						return false;</span>
					}
<span class="nc bnc" id="L4610" title="All 2 branches missed.">					if (range.includes(start)) {</span>
<span class="nc" id="L4611">						startDateIsIncluded = true;</span>
					}
<span class="nc bnc" id="L4613" title="All 2 branches missed.">					if (range.includes(end)) {</span>
<span class="nc" id="L4614">						endDateIsIncluded = true;</span>
					}
<span class="nc" id="L4616">					rangePrev = range;</span>
<span class="nc" id="L4617">				}</span>
				// All ranges are covered. we are good. because if any gap is found then we returned false in the loop already
<span class="nc bnc" id="L4619" title="All 4 branches missed.">				return (startDateIsIncluded &amp;&amp; endDateIsIncluded);</span>
			}
		} finally {
<span class="nc bnc" id="L4622" title="All 10 branches missed.">			if (rs != null) {</span>
<span class="nc" id="L4623">				rs.close();</span>
			}
<span class="nc bnc" id="L4625" title="All 10 branches missed.">			if (jdmo != null) {</span>
<span class="nc" id="L4626">				jdmo.cleanUp();</span>
			}
		}
<span class="nc" id="L4629">		return false;</span>
	}

	/**
	 * For marketing demo, database will be populated with future data, but queries should only return data prior to current time.
	 */
	public static Date adjustActualEndDateForDemo(Date end, TraceCube metaTC) {
<span class="nc" id="L4636">		Date newEnd = end;</span>
<span class="nc bnc" id="L4637" title="All 6 branches missed.">		if (end != null &amp;&amp; m_ignoreFutureData &amp;&amp; metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L4638">			Date now = new Date();</span>
<span class="nc bnc" id="L4639" title="All 2 branches missed.">			newEnd = end.after(now) ? now : end;</span>
		}
<span class="nc" id="L4641">		return newEnd;</span>
	}

	/**
	 * Gets the list of months that has valid volume/aht data in the queuehistorytimeseries table.
	 *
	 * @return List of month/year (Format: yyyymm)
	 * @throws JdmoException
	 */
	public static List&lt;String&gt; getMonthYearListInActualTimeSeries(ID queueID, int nOffset) throws JdmoException {
<span class="nc" id="L4651">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L4652">		final ArrayList&lt;String&gt; monthYearList = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc" id="L4654">			String sqlString = getSqlQueryToGetMonthYearListInActualTimeSeries(queueID, nOffset);</span>
<span class="nc" id="L4655">			final JdmoQuery jq = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L4656">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L4657" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4658">				monthYearList.add(rs.getString(&quot;MONTHYEAR&quot;));</span>
			}
<span class="nc" id="L4660">			return monthYearList;</span>
<span class="nc" id="L4661">		} catch (final JdmoException e) {</span>
<span class="nc" id="L4662">			throw e;</span>
		} finally {
<span class="nc" id="L4664">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Gets the list of date that has valid volume/aht data in the queuehistorytimeseries table.
	 *
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public static List&lt;String&gt; getDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws JdmoException {
<span class="nc" id="L4675">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L4676">		final ArrayList&lt;String&gt; daymonthYearList = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc" id="L4678">			String sqlString = getSqlQueryToGetDayMonthYearListInActualTimeSeries(queueID, startDate, endDate);</span>
<span class="nc" id="L4679">			final JdmoQuery jq = jdmo.createQuery(sqlString, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L4680">			final JdmoRowset rs = jdmo.createRowset(jq, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L4681" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4682">				daymonthYearList.add(rs.getString(&quot;DAYMONTHYEAR&quot;));</span>
			}
<span class="nc" id="L4684">			return daymonthYearList;</span>
<span class="nc" id="L4685">		} catch (final JdmoException e) {</span>
<span class="nc" id="L4686">			throw e;</span>
		} finally {
<span class="nc" id="L4688">			jdmo.cleanUp();</span>
		}
	}

	/**
	 * Gets the list of week start date that has valid volume/aht data in the queuehistorytimeseries table.
	 * The list does not include partial weeks in the year.
	 *
	 * @return String list of date (ddmmyyyy)
	 * @throws BbmFinderException
	 */
	public static List&lt;String&gt; getWeekListInActualTimeSeries(ID queueID, Date startDate, Date endDate) throws JdmoException {
<span class="nc" id="L4700">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L4701">		final ArrayList&lt;String&gt; weekList = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc" id="L4703">			final JdmoQuery query = jdmo.createQuery(&quot;GETWEEKSWITHDATAINACTUALTIMESERIES&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="nc" id="L4704">			query.setParTimestamp(1, new Timestamp(startDate.getTime()));</span>
<span class="nc" id="L4705">			query.setParTimestamp(2, new Timestamp(endDate.getTime()));</span>
<span class="nc" id="L4706">			query.setParString(3, queueID.toString());</span>

<span class="nc" id="L4708">			final JdmoRowset rs = jdmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L4709" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4710">				weekList.add(rs.getString(&quot;WeekStart&quot;));</span>
			}
<span class="nc" id="L4712">			return weekList;</span>
<span class="nc" id="L4713">		} catch (JdmoException e) {</span>
<span class="nc" id="L4714">			throw e;</span>
		} finally {
<span class="nc" id="L4716">			jdmo.cleanUp();</span>
		}
	}

	private static String getSqlQueryToGetActualTimeSeriesData(ID qID, Date startDate, Date endDate) {
<span class="nc" id="L4721">		StringBuffer pStmt = new StringBuffer(&quot;SELECT TIME, &quot;);</span>
<span class="nc" id="L4722">		pStmt.append(&quot;(CASE WHEN CALLVOLUME&lt;0 THEN -1 ELSE CALLVOLUME END) AS CALLVOLUME, &quot;);</span>
<span class="nc" id="L4723">		pStmt.append(&quot;(CASE WHEN AHT&lt;0 THEN -1 ELSE AHT END) AS AHT \n&quot;);</span>
<span class="nc" id="L4724">		pStmt.append(&quot;FROM QUEUEHISTORYTIMESERIES \n&quot;);</span>
<span class="nc" id="L4725">		pStmt.append(&quot;WHERE (QUEUEID=&quot;);</span>
<span class="nc" id="L4726">		JdmoUtil.asSqlLiteral(qID.toString(), pStmt);</span>
<span class="nc" id="L4727">		pStmt.append(&quot;AND TIME BETWEEN&quot;);</span>
<span class="nc" id="L4728">		pStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(startDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L4729">		pStmt.append(&quot;AND&quot;);</span>
<span class="nc" id="L4730">		pStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(endDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L4731">		pStmt.append(&quot;)&quot;);</span>
<span class="nc" id="L4732">		return pStmt.toString();</span>
	}

	private static String getSqlQueryToGetMonthYearListInActualTimeSeries(ID queueID, int nOffset) {
<span class="nc" id="L4736">		StringBuffer pStmt = new StringBuffer(&quot;SELECT DISTINCT STR(DATEPART(YEAR, DATEADD(minute,&quot;);</span>
<span class="nc" id="L4737">		pStmt.append(nOffset);</span>
<span class="nc" id="L4738">		pStmt.append(&quot;, [TIME]))*100 + DATEPART(MONTH, DATEADD(minute,&quot;);</span>
<span class="nc" id="L4739">		pStmt.append(nOffset);</span>
<span class="nc" id="L4740">		pStmt.append(&quot;, [TIME]))) AS MONTHYEAR FROM QUEUEHISTORYTIMESERIES WHERE QUEUEID=&quot;);</span>
<span class="nc" id="L4741">		JdmoUtil.asSqlLiteral(queueID.toString(), pStmt);</span>
<span class="nc" id="L4742">		pStmt.append(&quot;AND NOT(CALLVOLUME IS NULL)ORDER BY MONTHYEAR&quot;);</span>
<span class="nc" id="L4743">		return pStmt.toString();</span>
	}

	private static String getSqlQueryToGetDayMonthYearListInActualTimeSeries(ID queueID, Date startDate, Date endDate) {
<span class="nc" id="L4747">		StringBuffer pStmt = new StringBuffer();</span>
<span class="nc bnc" id="L4748" title="All 2 branches missed.">		if (startDate == null) {</span>
<span class="nc" id="L4749">			pStmt.append(&quot;SELECT DISTINCT STR(DATEPART(YEAR,TIME)*10000 + DATEPART(MONTH,TIME)*100 + DATEPART(DAY,TIME)) &quot;)</span>
<span class="nc" id="L4750">					.append(&quot;AS DAYMONTHYEAR&quot;);</span>
<span class="nc" id="L4751">			pStmt.append(&quot; FROM QUEUEHISTORYTIMESERIES  WHERE QUEUEID =&quot;);</span>
<span class="nc" id="L4752">			JdmoUtil.asSqlLiteral(queueID.toString(), pStmt);</span>
<span class="nc" id="L4753">			pStmt.append(&quot;AND NOT(CALLVOLUME IS NULL) ORDER BY DAYMONTHYEAR&quot;);</span>
		} else {
<span class="nc" id="L4755">			pStmt.append(&quot;SELECT DISTINCT STR(DATEPART(YEAR,TIME)*10000 + DATEPART(MONTH,TIME)*100 + DATEPART(DAY,TIME)) AS DAYMONTHYEAR&quot;);</span>
<span class="nc" id="L4756">			pStmt.append(&quot; FROM QUEUEHISTORYTIMESERIES  WHERE QUEUEID =&quot;);</span>
<span class="nc" id="L4757">			JdmoUtil.asSqlLiteral(queueID.toString(), pStmt);</span>
<span class="nc" id="L4758">			pStmt.append(&quot;AND NOT(CALLVOLUME IS NULL)&quot;);</span>
<span class="nc" id="L4759">			pStmt.append(&quot;AND CALLVOLUME &gt;= 0&quot;);</span>
<span class="nc" id="L4760">			pStmt.append(&quot;AND TIME &gt;=&quot;);</span>
<span class="nc" id="L4761">			pStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(startDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L4762">			pStmt.append(&quot;AND TIME &lt; &quot;);</span>
<span class="nc" id="L4763">			pStmt.append(&quot;'&quot;).append(JdmoUtil.formatDBString(endDate)).append(&quot;'&quot;);</span>
<span class="nc" id="L4764">			pStmt.append(&quot;ORDER BY DAYMONTHYEAR&quot;);</span>
		}
<span class="nc" id="L4766">		return pStmt.toString();</span>
	}

	public static List&lt;Date&gt; getDaysWithHistoryForQueues(Collection&lt;ID&gt; queueIds, Date startDate, Date endDate)
			throws JdmoException {
<span class="nc bnc" id="L4771" title="All 4 branches missed.">		if (queueIds == null || queueIds.isEmpty()) {</span>
<span class="nc" id="L4772">			return Collections.emptyList();</span>
		}
<span class="nc" id="L4774">		final Jdmo jdmo = new Jdmo();</span>
<span class="nc" id="L4775">		final List&lt;Date&gt; dateList = new ArrayList&lt;&gt;();</span>
		try {
<span class="nc" id="L4777">			final JdmoQuery query = jdmo.createQuery(&quot;GET_DAYS_WITH_HISTORY&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="nc" id="L4778">			query.setParString(1, StringUtil.createDelimitedString(queueIds.toArray(new ID[]{})));</span>
<span class="nc" id="L4779">			query.setParTimestamp(2, new Timestamp(startDate.getTime()));</span>
<span class="nc" id="L4780">			query.setParTimestamp(3, new Timestamp(endDate.getTime()));</span>

<span class="nc" id="L4782">			final JdmoRowset rs = jdmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L4783" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4784">				dateList.add(rs.getTimestamp(&quot;DaysWithHistory&quot;));</span>
			}
<span class="nc" id="L4786">			return dateList;</span>
<span class="nc" id="L4787">		} catch (final JdmoException e) {</span>
<span class="nc" id="L4788">			throw e;</span>
		} finally {
<span class="nc" id="L4790">			jdmo.cleanUp();</span>
		}
	}

<span class="nc" id="L4794">	public static class DstObject {</span>
		/* start of Out Variables */
<span class="nc" id="L4796">		boolean tfrInBeforeStartOfday = false;</span>
<span class="nc" id="L4797">		boolean tfrOutBeforeStartOfday = false;</span>
		// 92 points/day, need to shrink Apr
<span class="nc" id="L4799">		boolean tfrIn = false;</span>
		// 100 points/day , need to expand Oct
<span class="nc" id="L4801">		boolean tfrOut = false;</span>
		// track points
<span class="nc" id="L4803">		int dstPoints = 0;</span>
		// temp variable to track transition
<span class="nc" id="L4805">		boolean prvDSTFlag = false;</span>
		// this is the computed end of the day start +24 hrs
<span class="nc" id="L4807">		Date endOfDay = null;</span>
		// this is required so that we skip one loop when loop through the request Object
<span class="nc" id="L4809">		boolean skipLoop = false;</span>
		// Indicates if new traceCube needs to initialized
<span class="nc" id="L4811">		boolean needNewTraceCube = false;</span>
		/* start of IN / OUT Variables */
<span class="nc" id="L4813">		Date lineStart = null;</span>
<span class="nc" id="L4814">		Date spStartDate = null;</span>
<span class="nc" id="L4815">		Date spEndDate = null;</span>

<span class="nc" id="L4817">		boolean isLineStartInPartialTransition = false;</span>

		private long getDayDurationInMilliseconds() {
<span class="nc" id="L4820">			long duration = TimeUnit.DAYS.toMillis(1);</span>
<span class="nc bnc" id="L4821" title="All 2 branches missed.">			if (tfrOut) {</span>
<span class="nc" id="L4822">				duration += dstPoints;</span>
			}
<span class="nc bnc" id="L4824" title="All 2 branches missed.">			if (tfrIn) {</span>
<span class="nc" id="L4825">				duration -= dstPoints;</span>
			}
<span class="nc" id="L4827">			return duration;</span>
		}

		/**
		 * @param dayStart   - start of day
		 * @param rangeStart - Inclusive start of the range to check
		 * @param rangeEnd   - Exclusive end of the range to check
		 * @return true if the range defined by [rangStart,rangeEnd) falls into the day defined by lineStart
		 */
		private boolean rangeIsInDay(Date rangeStart, Date rangeEnd) {
<span class="nc bnc" id="L4837" title="All 2 branches missed.">			rangeStart = rangeStart == null ? new Date(0L) : rangeStart;</span>
<span class="nc bnc" id="L4838" title="All 2 branches missed.">			rangeEnd = rangeEnd == null ? new Date(Long.MAX_VALUE) : rangeEnd;</span>
<span class="nc" id="L4839">			TimeRange dayRange = new TimeRange(lineStart, getDayDurationInMilliseconds());</span>
<span class="nc" id="L4840">			TimeRange loadRange = new TimeRange(rangeStart, rangeEnd);</span>
<span class="nc" id="L4841">			int relation = loadRange.getRelativeLocationTo(dayRange);</span>
<span class="nc bnc" id="L4842" title="All 4 branches missed.">			return relation != TimeRange.TIME_BEFORE &amp;&amp; relation != TimeRange.TIME_AFTER;</span>
		}

		boolean shouldSkip(Date rangeStart, Date rangeEnd) {
<span class="nc bnc" id="L4846" title="All 4 branches missed.">			return skipLoop || !rangeIsInDay(rangeStart, rangeEnd);</span>
		}

	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>