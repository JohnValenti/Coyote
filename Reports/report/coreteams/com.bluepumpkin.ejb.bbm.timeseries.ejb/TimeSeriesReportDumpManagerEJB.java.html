<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeSeriesReportDumpManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.ejb</a> &gt; <span class="el_source">TimeSeriesReportDumpManagerEJB.java</span></div><h1>TimeSeriesReportDumpManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.timeseries.ejb;

import com.bluepumpkin.common.config.ConfigManager;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.*;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.pulse.ejb.TrackingManager;
import com.bluepumpkin.ejb.bbm.pulse.model.TraceChart;
import com.bluepumpkin.ejb.bbm.pulse.model.TrackingView;
import com.bluepumpkin.ejb.bbm.timeseries.model.*;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceUtil;
import com.bluepumpkin.ejb.bbm.workload.ejb.WorkloadManager;
import com.bluepumpkin.ejb.bbm.workload.model.CombinedQueueStaffing;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workload.model.Queue;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;

import javax.naming.Context;
import javax.naming.InitialContext;
import javax.transaction.UserTransaction;
import java.util.*;

/**
 * Title:        TimeSeriesReportDumpManagerEJB
 * Description:  TimeSeriesReportDumpManager EJB implementation
 * Copyright:    Copyright (c) 2002 - 2016
 * Company:      Verint Systems, inc
 */

<span class="nc" id="L43">public class TimeSeriesReportDumpManagerEJB extends SessionEJBBase {</span>
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

<span class="nc" id="L49">	private static Category m_cat = Log.initCategory(TimeSeriesReportDumpManagerEJB.class.getName());</span>

	private CampaignManager m_CampaignManager;
	private TimeSeriesManager m_TimeSeriesManager;
	private WorkloadManager m_WorkloadManager;
	private TrackingManager m_TrackingManager;

<span class="nc" id="L56">	private static TraceChunk NAChunk = new TraceChunk(null, null);</span>

	static {
<span class="nc" id="L59">		NAChunk.setTraceValue(Trace.STAFFING, -2);</span>
	}

<span class="nc" id="L62">	private static int LOOKBACKMONTH = 2;</span>
<span class="nc" id="L63">	private static int LOOKFORWARDMONTH = 2;</span>
<span class="nc" id="L64">	private static int USERTRANSACTION_TIMEOUT = 600;</span>
<span class="nc" id="L65">	private static final ID ComQueID = new ID(-1);</span>

	// override the base class to provide the appropriate logging category
	protected Category getCategory() {
<span class="nc" id="L69">		return m_cat;</span>
	}

	{
<span class="nc" id="L73">		super.init(TimeSeriesReportDumpManagerEJB.class.getName());</span>
	}

<span class="nc" id="L76">	private static TrackingView tv = new TrackingView();</span>

	static {
<span class="nc" id="L79">		TraceChart tc1 = new TraceChart(Trace.CV, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L80">		TraceChart tc2 = new TraceChart(Trace.AHT, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>

<span class="nc" id="L82">		TraceChart tc3 = new TraceChart(Trace.ASA, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE, TraceChart.REQUIRE_LINE}, true);</span>
<span class="nc" id="L83">		TraceChart tc4 = new TraceChart(Trace.PCA, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE, TraceChart.REQUIRE_LINE}, true);</span>
<span class="nc" id="L84">		TraceChart tc5 = new TraceChart(Trace.ABANDONMENT, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE, TraceChart.REQUIRE_LINE}, true);</span>
<span class="nc" id="L85">		TraceChart tc6 = new TraceChart(Trace.FTE, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE, TraceChart.REQUIRE_LINE}, true);</span>
<span class="nc" id="L86">		TraceChart tc7 = new TraceChart(Trace.STAFFING, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE, TraceChart.REQUIRE_LINE}, true);</span>
<span class="nc" id="L87">		TraceChart tc8 = new TraceChart(Trace.OCCUPANCY, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L88">		TraceChart tc9 = new TraceChart(Trace.BACKLOG, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L89">		TraceChart tc10 = new TraceChart(Trace.DIALS, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L90">		TraceChart tc11 = new TraceChart(Trace.CONNECTS, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L91">		TraceChart tc12 = new TraceChart(Trace.CRATE, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L92">		TraceChart tc13 = new TraceChart(Trace.RPC, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L93">		TraceChart tc14 = new TraceChart(Trace.RPCRATE, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L94">		TraceChart tc15 = new TraceChart(Trace.RPCAHT, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE, TraceChart.FORECAST_LINE}, true);</span>
<span class="nc" id="L95">		TraceChart tc16 = new TraceChart(Trace.VH, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE}, true);</span>
<span class="nc" id="L96">		TraceChart tc17 = new TraceChart(Trace.VAR, TraceChart.ABSOLUTE_CHART, new short[]{TraceChart.ACTUAL_LINE}, true);</span>


<span class="nc" id="L99">		ArrayList&lt;TraceChart&gt; defList = new ArrayList&lt;TraceChart&gt;();</span>
<span class="nc" id="L100">		defList.add(tc1);</span>
<span class="nc" id="L101">		defList.add(tc2);</span>
<span class="nc" id="L102">		defList.add(tc3);</span>
<span class="nc" id="L103">		defList.add(tc4);</span>
<span class="nc" id="L104">		defList.add(tc5);</span>
<span class="nc" id="L105">		defList.add(tc6);</span>
<span class="nc" id="L106">		defList.add(tc7);</span>
<span class="nc" id="L107">		defList.add(tc8);</span>
<span class="nc" id="L108">		defList.add(tc9);</span>
<span class="nc" id="L109">		defList.add(tc10);</span>
<span class="nc" id="L110">		defList.add(tc11);</span>
<span class="nc" id="L111">		defList.add(tc12);</span>
<span class="nc" id="L112">		defList.add(tc13);</span>
<span class="nc" id="L113">		defList.add(tc14);</span>
<span class="nc" id="L114">		defList.add(tc15);</span>
<span class="nc" id="L115">		defList.add(tc16);</span>
<span class="nc" id="L116">		defList.add(tc17);</span>
<span class="nc" id="L117">		tv.setChartDefinition(defList);</span>
<span class="nc" id="L118">	}</span>

<span class="nc" id="L120">	private boolean WhatIfMode = false;</span>

	public void ejbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="nc" id="L125">			Context initialContext = new InitialContext();</span>
<span class="nc" id="L126">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">			if (WIF != null) {</span>
<span class="nc" id="L128">				WhatIfMode = WIF.booleanValue();</span>
			}
<span class="nc" id="L130">			m_CampaignManager = WfmManagerFactory.getCampaignManager(WhatIfMode);</span>
<span class="nc" id="L131">			m_TimeSeriesManager = WfmManagerFactory.getTimeSeriesManager(WhatIfMode);</span>
<span class="nc" id="L132">			m_WorkloadManager = WfmManagerFactory.getWorkloadManager(WhatIfMode);</span>
<span class="nc" id="L133">			m_TrackingManager = WfmManagerFactory.getPulseTrackingManager(WhatIfMode);</span>
<span class="nc" id="L134">			String lookBack = BbmManagerFactory.getDBConfigManager(WhatIfMode).getValue(&quot;PERFREPORTLOOKBACK&quot;);</span>
<span class="nc bnc" id="L135" title="All 2 branches missed.">			if (lookBack != null) {</span>
				try {
<span class="nc" id="L137">					LOOKBACKMONTH = Integer.parseInt(lookBack);</span>
<span class="nc" id="L138">				} catch (Exception e) {</span>
<span class="nc" id="L139">					m_cat.info(&quot;Invalid value set for LookBackMonth, &quot; + lookBack);</span>
<span class="nc" id="L140">				}</span>
			}
<span class="nc" id="L142">		} catch (Exception e) {</span>
<span class="nc" id="L143">			handleException(&quot;ejbCreate&quot;, e);</span>
<span class="nc" id="L144">		}</span>
<span class="nc" id="L145">	}</span>

	public void updateDumpLog(Jdmo jdmo, ID queueID, ID campaignID, ID mediaID, Date dumpStart, Date dumpEnd, Date lastDump) throws Exception {
<span class="nc" id="L148">		UserTransaction ut = null;</span>
		try {
<span class="nc" id="L150">			ut = m_sessionContext.getUserTransaction();</span>
<span class="nc" id="L151">			ut.setTransactionTimeout(USERTRANSACTION_TIMEOUT);</span>
<span class="nc" id="L152">			ut.begin();</span>
<span class="nc" id="L153">			StringBuffer pStmt = new StringBuffer(&quot;select TRACEDUMPTIME from TRACEDUMPLOG where &quot;);</span>
<span class="nc bnc" id="L154" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L155">				pStmt.append(&quot;QUEUEID=?&quot;);</span>
			} else {
<span class="nc" id="L157">				pStmt.append(&quot;CAMPAIGNID=?&quot;);</span>
<span class="nc bnc" id="L158" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L159">					pStmt.append(&quot; and MEDIAID=?&quot;);</span>
				} else {
<span class="nc" id="L161">					pStmt.append(&quot; and MEDIAID=-10&quot;);</span>
				}
			}
<span class="nc" id="L164">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L165" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L166">				jQuery.setParID(1, queueID);</span>
			} else {
<span class="nc" id="L168">				jQuery.setParID(1, campaignID);</span>
<span class="nc bnc" id="L169" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L170">					jQuery.setParID(2, mediaID);</span>
				}
			}
<span class="nc" id="L173">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L174" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L175">				StringBuffer pStmt2 = new StringBuffer(&quot;update TRACEDUMPLOG set TRACEDUMPTIME=?, STARTTIME=?, ENDTIME=? where &quot;);</span>
<span class="nc" id="L176">				int params = 3;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">				if (queueID != null) {</span>
<span class="nc" id="L178">					pStmt2.append(&quot;QUEUEID=?&quot;);</span>
<span class="nc" id="L179">					params++;</span>
				} else {
<span class="nc" id="L181">					pStmt2.append(&quot;CAMPAIGNID=?&quot;);</span>
<span class="nc" id="L182">					params++;</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">					if (mediaID != null) {</span>
<span class="nc" id="L184">						pStmt2.append(&quot; and MEDIAID=?&quot;);</span>
<span class="nc" id="L185">						params++;</span>
					} else {
<span class="nc" id="L187">						pStmt2.append(&quot; and MEDIAID=-10&quot;);</span>
					}
				}
<span class="nc" id="L190">				Object[] param = new Object[params];</span>
<span class="nc" id="L191">				param[0] = TimeZoneUtil.toTimestamp(lastDump);</span>
<span class="nc" id="L192">				param[1] = TimeZoneUtil.toTimestamp(dumpStart);</span>
<span class="nc" id="L193">				param[2] = TimeZoneUtil.toTimestamp(dumpEnd);</span>
<span class="nc bnc" id="L194" title="All 2 branches missed.">				if (queueID != null) {</span>
<span class="nc" id="L195">					param[3] = queueID;</span>
				} else {
<span class="nc" id="L197">					param[3] = campaignID;</span>
<span class="nc bnc" id="L198" title="All 2 branches missed.">					if (mediaID != null) {</span>
<span class="nc" id="L199">						param[4] = mediaID;</span>
					}
				}
<span class="nc" id="L202">				jdmo.executePCommand(pStmt2.toString(), param);</span>
<span class="nc" id="L203">			} else {</span>
// there is no entry for that queue yet, create the entry
<span class="nc" id="L205">				HashMap map = new HashMap(3);</span>
<span class="nc" id="L206">				map.put(&quot;TRACEDUMPTIME&quot;, TimeZoneUtil.toTimestamp(lastDump));</span>
<span class="nc" id="L207">				map.put(&quot;STARTTIME&quot;, TimeZoneUtil.toTimestamp(dumpStart));</span>
<span class="nc" id="L208">				map.put(&quot;ENDTIME&quot;, TimeZoneUtil.toTimestamp(dumpEnd));</span>
<span class="nc" id="L209">				map.put(&quot;QUEUEID&quot;, new ID(-1));</span>
<span class="nc" id="L210">				map.put(&quot;CAMPAIGNID&quot;, new ID(-1));</span>
<span class="nc" id="L211">				map.put(&quot;MEDIAID&quot;, new ID(-10));</span>
<span class="nc bnc" id="L212" title="All 2 branches missed.">				if (queueID != null) {</span>
<span class="nc" id="L213">					map.put(&quot;QUEUEID&quot;, queueID);</span>
				} else {
<span class="nc" id="L215">					map.put(&quot;CAMPAIGNID&quot;, campaignID);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">					if (mediaID != null) {</span>
<span class="nc" id="L217">						map.put(&quot;MEDIAID&quot;, mediaID);</span>
					}
				}
<span class="nc" id="L220">				jdmo.addBatchInsert(&quot;TRACEDUMPLOG&quot;, map);</span>
<span class="nc" id="L221">				jdmo.executeBatch();</span>
			}

// finally dump the trace chunks
<span class="nc" id="L225">			ut.commit();</span>
<span class="nc" id="L226">		} catch (Exception e) {</span>
<span class="nc bnc" id="L227" title="All 2 branches missed.">			if (ut != null) {</span>
<span class="nc" id="L228">				ut.rollback();</span>
			}
<span class="nc" id="L230">			throw e;</span>
<span class="nc" id="L231">		}</span>

<span class="nc" id="L233">	}</span>

	/**
	 * update Report table based on meta TraceCube information for a queue
	 * If queue ID is given, it is a real queue, else
	 * If campaign and media ID given, it is a media combined queue, else
	 * it is a combined/combined queue
	 *
	 * @param campaignID
	 * @param mediaID
	 * @param queueID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param alwaysUpdateDumpLog, for scheduled report dump, we always refresh dump log
	 * @param fixHOO,              decide HOO should be honored or not, it depends on media ID
	 * @throws JdmoException
	 */
	public void dumpTimeSeriesFromLastDump(ID campaignID, ID mediaID, ID queueID, Date start, Date end, boolean alwaysUpdateDumpLog, boolean fixHOO) throws BbmUpdateException {
<span class="nc bnc" id="L252" title="All 4 branches missed.">		if (queueID == null || queueID.equals(new ID(-1))) {</span>
<span class="nc bnc" id="L253" title="All 2 branches missed.">			methodStart(&quot;dumpTimeSeriesFromLastUpdate&quot;, campaignID, mediaID, start, end, alwaysUpdateDumpLog ? Boolean.TRUE : Boolean.FALSE);</span>
		} else {
<span class="nc bnc" id="L255" title="All 2 branches missed.">			methodStart(&quot;dumpTimeSeriesFromLastUpdate&quot;, queueID, start, end, alwaysUpdateDumpLog ? Boolean.TRUE : Boolean.FALSE);</span>
		}
		//QA 79960 - Report Dump Failed after upgrade to 7.7.2
<span class="nc" id="L258">		USERTRANSACTION_TIMEOUT = getReportDumpUserTransactionTimeOut();</span>
<span class="nc" id="L259">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="nc" id="L261">			StringBuffer pStmt = new StringBuffer(&quot;select TRACEDUMPTIME, STARTTIME, ENDTIME from TRACEDUMPLOG where &quot;);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L263">				pStmt.append(&quot;QUEUEID=?&quot;);</span>
			} else {
<span class="nc" id="L265">				pStmt.append(&quot;CAMPAIGNID=?&quot;);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L267">					pStmt.append(&quot; and MEDIAID=?&quot;);</span>
				} else {
<span class="nc" id="L269">					pStmt.append(&quot; and MEDIAID=-10&quot;);</span>
				}
			}
<span class="nc" id="L272">			JdmoQuery jQuery = jdmo.createQuery(pStmt.toString(), Jdmo.PARAM_QUERY);</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">			if (queueID != null) {</span>
<span class="nc" id="L274">				jQuery.setParID(1, queueID);</span>
			} else {
<span class="nc" id="L276">				jQuery.setParID(1, campaignID);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">				if (mediaID != null) {</span>
<span class="nc" id="L278">					jQuery.setParID(2, mediaID);</span>
				}
			}
<span class="nc" id="L281">			JdmoRowset rs = jdmo.createRowset(jQuery, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc" id="L282">			Date lastUpdate = null;</span>
			// Use time before dump is really finished, so any update to existing data during dump will be picked up in next dump
<span class="nc" id="L284">			Date lastDumpStart = null;</span>
<span class="nc" id="L285">			Date lastDumpEnd = null;</span>
<span class="nc bnc" id="L286" title="All 2 branches missed.">			if (rs.next()) {</span>
<span class="nc" id="L287">				lastUpdate = TimeZoneUtil.toDate(rs.getTimestamp(&quot;TRACEDUMPTIME&quot;));</span>
<span class="nc" id="L288">				lastDumpStart = TimeZoneUtil.toDate(rs.getTimestamp(&quot;STARTTIME&quot;));</span>
<span class="nc" id="L289">				lastDumpEnd = TimeZoneUtil.toDate(rs.getTimestamp(&quot;ENDTIME&quot;));</span>
			}
<span class="nc" id="L291">			rs.close();</span>
<span class="nc" id="L292">			Date curDate = new Date();</span>
			// We always dump for two previous months plus one future crossing the date
<span class="nc bnc" id="L294" title="All 2 branches missed.">			if (lastUpdate == null) {</span>
				// save dump log, if it is not for whole dump
				//Changes start for QA100626 starts
<span class="nc" id="L297">				int iLookForwardMonth = ConfigManager.NOVALUE;</span>
				try {
<span class="nc" id="L299">					iLookForwardMonth = BbmManagerFactory.getDBConfigManager().getIntValue(ConfigKey.CRYSTAL_REPORTS_TIMSERIES_LOOKFORWARD_MONTH);</span>
<span class="nc" id="L300">				} catch (Exception e) {</span>
<span class="nc" id="L301">					m_cat.debug(&quot;Exception while getting value for CRYSTAL_REPORTS_TIMSERIES_LOOKFORWARD_MONTH:&quot; + e);</span>
<span class="nc" id="L302">				}</span>
<span class="nc bnc" id="L303" title="All 2 branches missed.">				if (iLookForwardMonth != ConfigManager.NOVALUE) {</span>
<span class="nc" id="L304">					LOOKFORWARDMONTH = iLookForwardMonth;</span>
				}
<span class="nc" id="L306">				Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L307">				cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L308">				cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L309">				cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L310">				cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L311">				cal.set(Calendar.DAY_OF_MONTH, 1);</span>
<span class="nc" id="L312">				cal.add(Calendar.MONTH, LOOKFORWARDMONTH);//QA100626</span>
<span class="nc" id="L313">				cal.add(Calendar.DAY_OF_MONTH, 2);</span>
<span class="nc" id="L314">				Date curDumpEnd = cal.getTime();</span>
<span class="nc" id="L315">				cal.add(Calendar.MONTH, -(LOOKFORWARDMONTH + LOOKBACKMONTH));//QA100626</span>
<span class="nc" id="L316">				cal.add(Calendar.DAY_OF_MONTH, -4);</span>
<span class="nc" id="L317">				Date curDumpStart = cal.getTime();</span>
				//Changes end for QA100626 starts
				// as never dumped, use input start/end
				// try to expand that window with the dump window, if they overlap
<span class="nc" id="L321">				boolean saveLog = true;</span>
<span class="nc bnc" id="L322" title="All 4 branches missed.">				if (start != null &amp;&amp; end != null) {</span>
<span class="nc" id="L323">					boolean startsFallsIn = false;</span>
<span class="nc" id="L324">					boolean endsFallsIn = false;</span>
<span class="nc bnc" id="L325" title="All 6 branches missed.">					if (start != null &amp;&amp; !curDumpStart.after(start) &amp;&amp; !curDumpEnd.before(start)) {</span>
<span class="nc" id="L326">						startsFallsIn = true;</span>
					}
<span class="nc bnc" id="L328" title="All 6 branches missed.">					if (end != null &amp;&amp; !curDumpStart.after(end) &amp;&amp; !curDumpEnd.before(end)) {</span>
<span class="nc" id="L329">						endsFallsIn = true;</span>
					}
<span class="nc bnc" id="L331" title="All 4 branches missed.">					if (startsFallsIn &amp;&amp; endsFallsIn) {</span>
						// if the window can be merged, we will dump a bigger window, and save log
<span class="nc" id="L333">						dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, curDumpStart, curDumpEnd, null, fixHOO);</span>
//						dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, end, null, fixHOO);
					} else {
<span class="nc bnc" id="L336" title="All 4 branches missed.">						if (!startsFallsIn &amp;&amp; !endsFallsIn) {</span>
<span class="nc" id="L337">							dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, end, null, fixHOO);</span>
<span class="nc bnc" id="L338" title="All 4 branches missed.">							if (end.before(curDumpStart) || start.after(curDumpEnd)) {</span>
<span class="nc" id="L339">								saveLog = false;</span>
							}
						} else {
							// QA 93001
<span class="nc bnc" id="L343" title="All 2 branches missed.">							curDumpStart = start.before(curDumpStart) ? start : curDumpStart;</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">							curDumpEnd = end.after(curDumpEnd) ? end : curDumpEnd;</span>

<span class="nc" id="L346">							dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, curDumpStart, curDumpEnd, null, fixHOO);</span>
							// end of QA 93001
						}
					}
<span class="nc" id="L350">				} else {</span>
<span class="nc" id="L351">					dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, end, null, fixHOO);</span>
<span class="nc bnc" id="L352" title="All 6 branches missed.">					if (start != null &amp;&amp; start.after(curDumpStart) ||</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">							end != null &amp;&amp; end.before(curDumpEnd)) {</span>
<span class="nc" id="L354">						saveLog = false;</span>
					}
				}
<span class="nc bnc" id="L357" title="All 2 branches missed.">				if (saveLog) {</span>
<span class="nc" id="L358">					updateDumpLog(jdmo, queueID, campaignID, mediaID, curDumpStart, curDumpEnd, curDate);</span>
				}
<span class="nc" id="L360">			} else {</span>
<span class="nc bnc" id="L361" title="All 10 branches missed.">				if (lastDumpStart != null &amp;&amp; start != null &amp;&amp; start.equals(lastDumpStart) &amp;&amp;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">						lastDumpEnd != null &amp;&amp; end != null &amp;&amp; end.equals(lastDumpEnd)) {</span>

<span class="nc" id="L364">					m_cat.debug(&quot;Dump window is matching dump log window, simple redump and refresh log&quot;);</span>
					// perfect match, simple redump
<span class="nc" id="L366">					dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, end, lastUpdate, fixHOO);</span>
<span class="nc" id="L367">					updateDumpLog(jdmo, queueID, campaignID, mediaID, start, end, curDate);</span>
				} else {
<span class="nc" id="L369">					boolean startsFallsIn = false;</span>
<span class="nc" id="L370">					boolean endsFallsIn = false;</span>
<span class="nc bnc" id="L371" title="All 6 branches missed.">					if (start != null &amp;&amp; !lastDumpStart.after(start) &amp;&amp; !lastDumpEnd.before(start)) {</span>
<span class="nc" id="L372">						startsFallsIn = true;</span>
					}
<span class="nc bnc" id="L374" title="All 6 branches missed.">					if (end != null &amp;&amp; !lastDumpStart.after(end) &amp;&amp; !lastDumpEnd.before(end)) {</span>
<span class="nc" id="L375">						endsFallsIn = true;</span>
					}
<span class="nc bnc" id="L377" title="All 4 branches missed.">					if (startsFallsIn &amp;&amp; endsFallsIn) {</span>
						// falls in dump window, still dump for a bigger window

<span class="nc" id="L380">						m_cat.debug(&quot;Dump window is inside dump log window, expand to dump window and refresh log&quot;);</span>
<span class="nc" id="L381">						dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, lastUpdate, fixHOO);</span>
<span class="nc" id="L382">						updateDumpLog(jdmo, queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, curDate);</span>
					} else {
<span class="nc bnc" id="L384" title="All 4 branches missed.">						if (!startsFallsIn &amp;&amp; !endsFallsIn) {</span>
							// it is totally out of current dumped window, or covers current dump window
<span class="nc bnc" id="L386" title="All 6 branches missed.">							if (end != null &amp;&amp; end.before(lastDumpStart) ||</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">									start != null &amp;&amp; start.after(lastDumpEnd)) {</span>

<span class="nc" id="L389">								m_cat.debug(&quot;Dump window is totally outside of dump log window, dump from scratch&quot;);</span>
<span class="nc" id="L390">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, end, null, fixHOO);</span>
							} else {

<span class="nc" id="L393">								m_cat.debug(&quot;Dump window is covering outside of dump log window, dump from in three batches&quot;);</span>
								// can split into three dumps
<span class="nc" id="L395">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, new Date(lastDumpStart.getTime() - TimeZoneUtil.MINUTE_IN_MILLISECONDS), null, fixHOO);</span>
<span class="nc" id="L396">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, lastUpdate, fixHOO);</span>
<span class="nc" id="L397">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, new Date(lastDumpEnd.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS), end, null, fixHOO);</span>
							}
<span class="nc bnc" id="L399" title="All 2 branches missed.">							if (alwaysUpdateDumpLog) {</span>
<span class="nc" id="L400">								updateDumpLog(jdmo, queueID, campaignID, mediaID, start, end, curDate);</span>
							}
						} else {
<span class="nc bnc" id="L403" title="All 2 branches missed.">							if (startsFallsIn) {</span>

<span class="nc" id="L405">								m_cat.debug(&quot;Dump window is overlapping with dump log window, ends after it, dump from in two batches&quot;);</span>
								// then ends after cur window, split into two dumps
<span class="nc" id="L407">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, lastUpdate, fixHOO);</span>
<span class="nc" id="L408">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, new Date(lastDumpEnd.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS), end, null, fixHOO);</span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">								if (alwaysUpdateDumpLog) {</span>
<span class="nc" id="L410">									updateDumpLog(jdmo, queueID, campaignID, mediaID, start, end, curDate);</span>
								} else {
<span class="nc" id="L412">									updateDumpLog(jdmo, queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, curDate);</span>
								}
							} else {

<span class="nc" id="L416">								m_cat.debug(&quot;Dump window is overlapping with dump log window, starts before it, dump from in two batches&quot;);</span>
<span class="nc" id="L417">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, lastUpdate, fixHOO);</span>
<span class="nc" id="L418">								dumpTimeSeriesFromLastDump(queueID, campaignID, mediaID, start, new Date(lastDumpStart.getTime() - TimeZoneUtil.MINUTE_IN_MILLISECONDS), null, fixHOO);</span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">								if (alwaysUpdateDumpLog) {</span>
<span class="nc" id="L420">									updateDumpLog(jdmo, queueID, campaignID, mediaID, start, end, curDate);</span>
								} else {
<span class="nc" id="L422">									updateDumpLog(jdmo, queueID, campaignID, mediaID, lastDumpStart, lastDumpEnd, curDate);</span>
								}
							}
						}
					}
				}
			}
<span class="nc" id="L429">		} catch (Exception e) {</span>
<span class="nc" id="L430">			handleException(e);</span>
<span class="nc" id="L431">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L433">			jdmo.cleanUp();</span>
<span class="nc" id="L434">			methodFinish();</span>
<span class="nc" id="L435">		}</span>
<span class="nc" id="L436">	}</span>

	/**
	 * update Report table based on meta TraceCube information for MultiSite campaign without smart dump feature
	 * Only for MultiSite campaign (which will use TrackingManager) without any dump logging
	 *
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param fixHOO,    decide HOO should be honored or not, it depends on media ID
	 * @throws BbmUpdateException
	 */
	public void dumpMultiSiteTimeSeriesFromLastDump(ID campaignID, ID mediaID, Date start, Date end, boolean fixHOO) throws BbmUpdateException {
<span class="nc" id="L450">		methodStart(&quot;dumpMultiSiteTimeSeriesFromLastDump&quot;, campaignID, mediaID, start, end);</span>
<span class="nc" id="L451">		int nMaxRetry = getReportDumpRetryCount();</span>
<span class="nc" id="L452">		boolean returnVal = false;</span>
<span class="nc" id="L453">		int retryCount = 0;</span>
		while (true) {
			// we use -10 to represent null media ID
<span class="nc bnc" id="L456" title="All 4 branches missed.">			ID realMediaID = (mediaID != null &amp;&amp; mediaID.equals(new ID(-10))) ? null : mediaID;</span>
<span class="nc" id="L457">			Collection[] chunkCol = new Collection[5];</span>
<span class="nc" id="L458">			Collection&lt;TimePeriod&gt; mergedClosedPeriod = null;</span>
			try {
<span class="nc" id="L460">				Map&lt;ID, TraceCube[]&gt; map = m_TrackingManager.getCombineTraceCubesByTrackingView(tv, campaignID, mediaID, start, end, false);//QA99997 passing false flag, to ignore missing values</span>
				// TrackingManager returns Required at Pos 4, need swap
<span class="nc" id="L462">				TraceCube[] cubes = map.get(ComQueID);</span>
<span class="nc" id="L463">				TraceCube tempCube = cubes[3];</span>
<span class="nc" id="L464">				cubes[3] = cubes[4];</span>
<span class="nc" id="L465">				cubes[4] = tempCube;</span>
				// now convert to chunk Col
<span class="nc bnc" id="L467" title="All 4 branches missed.">				for (int i = 0; i &lt; cubes.length &amp;&amp; i &lt; chunkCol.length; i++) {</span>
<span class="nc bnc" id="L468" title="All 2 branches missed.">					if (cubes[i] != null) {</span>
<span class="nc" id="L469">						int maxLen = cubes[i].getMaximumLength(cubes[i].getTraceTypes());</span>
<span class="nc" id="L470">						chunkCol[i] = new ArrayList(maxLen);</span>
<span class="nc" id="L471">						Date chunkStart = TraceUtil.snapDate(cubes[i].getRawStartDate());</span>
<span class="nc bnc" id="L472" title="All 2 branches missed.">						for (int j = 0; j &lt; maxLen; j++) {</span>
<span class="nc" id="L473">							TraceChunk tc = new TraceChunk(ComQueID, chunkStart);</span>
<span class="nc" id="L474">							tc.setTraceValues(cubes[i].getTraceTypes(), cubes[i].getTraceValueD(cubes[i].getTraceTypes(), chunkStart));</span>
<span class="nc" id="L475">							chunkStart = new Date(chunkStart.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG * Trace.INTERVAL);</span>
<span class="nc" id="L476">							chunkCol[i].add(tc);</span>
						}
					}
				}
		/*
			 {
				m_cat.debug(&quot;Campaign queue Campaign ID &quot;+campaignID+&quot; Media ID &quot;+mediaID);
				m_cat.debug(chunkCol[0]);
				m_cat.debug(chunkCol[1]);
				m_cat.debug(chunkCol[2]);
				m_cat.debug(chunkCol[3]);
				m_cat.debug(chunkCol[4]);
			}*/
<span class="nc bnc" id="L489" title="All 2 branches missed.">				if (fixHOO) {</span>
					// find HOO, then normalize the result
					// for each campaign, fetch the HOO, convert to HOOPeriod, then normalize the result
<span class="nc" id="L492">					Campaign cpg = m_CampaignManager.getCampaignByID(campaignID);</span>
<span class="nc" id="L493">					Collection&lt;CampaignHOO&gt; cpgHOOCol = m_CampaignManager.getCampaignHOOAssignments(campaignID, start, end);</span>
<span class="nc" id="L494">					CampaignHOOPeriod cpgPeriod = new CampaignHOOPeriod(start, end, cpg.getTimeZone(), cpgHOOCol);</span>
<span class="nc" id="L495">					mergedClosedPeriod = cpgPeriod.getClosePeriods(start, end);</span>
				}
				// Now convert trace chunk to HashMap, and normalize them based on Campaign HOO definition
<span class="nc" id="L498">				Map&lt;Date, TraceChunk[]&gt; chunkMap = new HashMap&lt;Date, TraceChunk[]&gt;();</span>
<span class="nc" id="L499">				Date chunkStart = start;</span>
<span class="nc" id="L500">				Date chunkEnd = end;</span>
<span class="nc bnc" id="L501" title="All 2 branches missed.">				for (int i = 0; i &lt; chunkCol.length; i++) {</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">					if (chunkCol[i] != null) {</span>
<span class="nc bnc" id="L503" title="All 2 branches missed.">						for (Iterator chunkIT = chunkCol[i].iterator(); chunkIT.hasNext(); ) {</span>
<span class="nc" id="L504">							TraceChunk chunk = (TraceChunk) chunkIT.next();</span>
<span class="nc" id="L505">							Date startDate = chunk.getStartDate();</span>
<span class="nc" id="L506">							TraceChunk[] chunkArray = chunkMap.get(startDate);</span>
<span class="nc bnc" id="L507" title="All 2 branches missed.">							if (chunkArray == null) {</span>
<span class="nc" id="L508">								chunkArray = new TraceChunk[5];</span>
							}
<span class="nc" id="L510">							chunkArray[i] = chunk;</span>
<span class="nc" id="L511">							chunkMap.put(startDate, chunkArray);</span>
<span class="nc bnc" id="L512" title="All 6 branches missed.">							if (chunkStart == null || (chunkStart != null &amp;&amp; startDate.before(chunkStart))) {</span>
<span class="nc" id="L513">								chunkStart = startDate;</span>
							}
<span class="nc bnc" id="L515" title="All 6 branches missed.">							if (chunkEnd == null || (chunkEnd != null &amp;&amp; startDate.after(chunkEnd))) {</span>
<span class="nc" id="L516">								chunkEnd = startDate;</span>
							}
<span class="nc" id="L518">						}</span>
					}
				}
<span class="nc" id="L521">				Set&lt;Date&gt; removeTimeSet = new HashSet&lt;Date&gt;();</span>
<span class="nc" id="L522">				Map&lt;Date, CombinedQueueStaffing&gt; cmbStfMap = TimeSeriesDAO.getCombinedQueueStaffing(campaignID, mediaID, chunkStart, chunkEnd, null);</span>
<span class="nc bnc" id="L523" title="All 6 branches missed.">				if (fixHOO &amp;&amp; mergedClosedPeriod != null &amp;&amp; !mergedClosedPeriod.isEmpty()) {</span>
					// now normalize any chunk in the closedPeriod window
<span class="nc bnc" id="L525" title="All 2 branches missed.">					for (TimePeriod period : mergedClosedPeriod) {</span>
<span class="nc" id="L526">						Date pStart = TraceUtil.snapDate(period.getStartTime());</span>
<span class="nc" id="L527">						Date pEnd = TraceUtil.snapDate(period.getEndTime());</span>
						do {
							// replace chunks start in non working period with -1 chunk
							//			chunkMap.put(pStart, TraceUtil.NULL_TraceChunkArray);
<span class="nc" id="L531">							chunkMap.remove(pStart);</span>
<span class="nc" id="L532">							cmbStfMap.remove(pStart);</span>
<span class="nc" id="L533">							removeTimeSet.add(pStart);</span>
<span class="nc bnc" id="L534" title="All 6 branches missed.">							if (chunkStart == null || (chunkStart != null &amp;&amp; pStart.before(chunkStart))) {</span>
<span class="nc" id="L535">								chunkStart = pStart;</span>
							}
<span class="nc bnc" id="L537" title="All 6 branches missed.">							if (chunkEnd == null || (chunkEnd != null &amp;&amp; pStart.after(chunkEnd))) {</span>
<span class="nc" id="L538">								chunkEnd = pStart;</span>
							}
<span class="nc" id="L540">							pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L541" title="All 2 branches missed.">						} while (pStart.before(pEnd));</span>
<span class="nc" id="L542">					}</span>
				}
				// we decide to use UserTransaction, and only control the final dump to avoid JTA timeout
<span class="nc" id="L545">				UserTransaction ut = m_sessionContext.getUserTransaction();</span>
				try {
<span class="nc" id="L547">					ut.setTransactionTimeout(USERTRANSACTION_TIMEOUT);</span>
<span class="nc" id="L548">					ut.begin();</span>
					// finally dump the trace chunks
<span class="nc" id="L550">					TimeSeriesDAO.dumpTimeSeriesFromLastUpdate(null, campaignID, realMediaID, chunkMap, cmbStfMap, chunkStart, chunkEnd, removeTimeSet);</span>
<span class="nc" id="L551">					ut.commit();</span>
<span class="nc" id="L552">				} catch (Exception e) {</span>
<span class="nc" id="L553">					ut.rollback();</span>
<span class="nc" id="L554">					throw e;</span>
<span class="nc" id="L555">				}</span>
<span class="nc" id="L556">				returnVal = true;</span>
<span class="nc" id="L557">			} catch (Exception e) {</span>
<span class="nc" id="L558">				handleException(e);</span>
<span class="nc" id="L559">				retryCount++;</span>
<span class="nc bnc" id="L560" title="All 2 branches missed.">				if (retryCount &gt;= nMaxRetry) {</span>
<span class="nc" id="L561">					throw new BbmUpdateException(e);</span>
				}
<span class="nc" id="L563">				m_cat.info(&quot;FAILED ON &quot; + retryCount + &quot; ATTEMPT, Dumping AGAIN campaignID: &quot; + campaignID + &quot;,mediaID =&quot; + mediaID + &quot;,start =&quot; + start + &quot;, end=&quot; + end + &quot;, fixHOO=&quot; + fixHOO);</span>
			} finally {
<span class="nc bnc" id="L565" title="All 6 branches missed.">				if (returnVal) {</span>
<span class="nc bnc" id="L566" title="All 6 branches missed.">					if (retryCount &gt; 1) {</span>
<span class="nc bnc" id="L567" title="All 6 branches missed.">						m_cat.info((returnVal ? &quot;SUCCEDED&quot; : &quot;FAILED&quot;) + &quot; AFTER &quot; + retryCount + &quot; ATTEMPTS &quot; + &quot;: Dumping campaignID: &quot; + campaignID + &quot;,mediaID =&quot; + mediaID + &quot;,start =&quot; + start + &quot;, end=&quot; + end + &quot;, fixHOO=&quot; + fixHOO);</span>
					}
<span class="nc" id="L569">					methodFinish();</span>
				}
			}
<span class="nc" id="L572">		}</span>
	}

	//QA 79960 - Report Dump Failed after upgrade to 7.7.2
	public int getReportDumpUserTransactionTimeOut() {
<span class="nc" id="L577">		int nUserTransactionTimeOut = USERTRANSACTION_TIMEOUT;</span>
		try {
<span class="nc" id="L579">			nUserTransactionTimeOut = BbmManagerFactory.getDBConfigManager(WhatIfMode).getIntValue(ConfigKey.REPORTDUMP_USER_TRANSACTION_TIMEOUT);</span>
<span class="nc bnc" id="L580" title="All 2 branches missed.">			if (nUserTransactionTimeOut &lt; 120) {</span>
<span class="nc" id="L581">				nUserTransactionTimeOut = 120;</span>
			}
<span class="nc bnc" id="L583" title="All 2 branches missed.">			if (nUserTransactionTimeOut &gt; 1200) {</span>
<span class="nc" id="L584">				nUserTransactionTimeOut = 1200;</span>
			}
<span class="nc" id="L586">		} catch (Exception e) {</span>
<span class="nc" id="L587">		}</span>
<span class="nc" id="L588">		return nUserTransactionTimeOut;</span>
	}

	public int getReportDumpRetryCount() {
<span class="nc" id="L592">		int nReportDumpMaxRetry = 10;</span>
		try {
<span class="nc" id="L594">			nReportDumpMaxRetry = BbmManagerFactory.getDBConfigManager(WhatIfMode).getIntValue(ConfigKey.CRYSTAL_REPORTS_DUMP_MAX_RETRY);</span>
<span class="nc bnc" id="L595" title="All 2 branches missed.">			if (nReportDumpMaxRetry &lt; 0) {</span>
<span class="nc" id="L596">				nReportDumpMaxRetry = 10;</span>
			}
<span class="nc" id="L598">		} catch (Exception e) {</span>
<span class="nc" id="L599">		}</span>
<span class="nc" id="L600">		return nReportDumpMaxRetry;</span>
	}

	/**
	 * update Report table based on meta TraceCube information for a queue
	 * If queue ID is given, it is a real queue, else
	 * If campaign and media ID given, it is a media combined queue, else
	 * it is a combined/combined queue
	 *
	 * @param queueID
	 * @param campaignID
	 * @param mediaID
	 * @param start
	 * @param end
	 * @param lastUpdate
	 * @param fixHOO,    decide HOO should be honored or not, it depends on media ID
	 * @throws JdmoException
	 */
	private void dumpTimeSeriesFromLastDump(ID queueID, ID campaignID, ID mediaID, Date start, Date end, Date lastUpdate, boolean fixHOO) throws BbmUpdateException {
<span class="nc" id="L619">		int nMaxRetry = getReportDumpRetryCount();</span>
<span class="nc" id="L620">		boolean returnVal = false;</span>
<span class="nc" id="L621">		int retryCount = 0;</span>
		while (true) {
			try {
				// we use -10 to represent null media ID
<span class="nc bnc" id="L625" title="All 4 branches missed.">				ID realMediaID = (mediaID != null &amp;&amp; mediaID.equals(new ID(-10))) ? null : mediaID;</span>
<span class="nc" id="L626">				Collection[] chunkCol = new Collection[5];</span>
				//need this collection to hold the data for combined queue in single queue NON-SKILL campaign scenario
<span class="nc" id="L628">				Collection[] chunkColForCombinedQue = new Collection[5];</span>
<span class="nc" id="L629">				Collection&lt;TimePeriod&gt; mergedClosedPeriod = null;</span>
<span class="nc" id="L630">				m_cat.debug(&quot;Inside dumpTimeSeriesFromLastDump, where lastUpdate is &quot; + lastUpdate + &quot; and fixHOO is &quot; + fixHOO);</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">				if (queueID != null &amp;&amp; !queueID.equals(new ID(-1))) {</span>
<span class="nc" id="L632">					Queue queue = m_WorkloadManager.getQueueByID(queueID);</span>
					//TODO: realQue appears never to be used.
<span class="nc" id="L634">					Set&lt;ID&gt; realQue = new HashSet&lt;ID&gt;();</span>
					// find queue campaign assignment, for HOO processing
<span class="nc" id="L636">					Collection&lt;CampaignQueue&gt; queCpgAssCol = null;</span>
<span class="nc bnc" id="L637" title="All 4 branches missed.">					if (fixHOO || queue.doesQueueHaveSubQs()) {</span>
<span class="nc" id="L638">						queCpgAssCol = m_CampaignManager.getQueueCampaignAssignments(queueID, start, end);</span>
<span class="nc" id="L639">						m_cat.debug(&quot;Campaign Queue assignments are &quot; + queCpgAssCol);</span>
					}
<span class="nc bnc" id="L641" title="All 2 branches missed.">					if (queue.doesQueueHaveSubQs()) {</span>
<span class="nc" id="L642">						realQue.addAll(m_WorkloadManager.getSubQueues(Collections.singletonList(queueID)));</span>
<span class="nc bnc" id="L643" title="All 2 branches missed.">						if (queCpgAssCol.isEmpty()) {</span>
<span class="nc" id="L644">							m_cat.debug(&quot;Cannot find the campaign for the non real Queue &quot; + queueID);</span>
<span class="nc" id="L645">							return;</span>
						}
<span class="nc" id="L647">						ID cpgID = queCpgAssCol.iterator().next().getCampaignID();</span>

<span class="nc" id="L649">						m_cat.debug(&quot;Find the campaign for the virtual Queue is &quot; + cpgID);</span>
						//Bug #90300;Sameet March 2006; [7.6]Staff.Num.Ass.ByInterv.report,distrib. queue isn't show Actual data
						//Fix for the Combined staffing issue. Cannot pass Last updated date since there is a substitution
						// happening inside this method
<span class="nc" id="L653">						TraceCube[] cubes = null;</span>
<span class="nc" id="L654">						UserTransaction ut = m_sessionContext.getUserTransaction();</span>
						try {
<span class="nc" id="L656">							ut.setTransactionTimeout(USERTRANSACTION_TIMEOUT);</span>
<span class="nc" id="L657">							ut.begin();</span>
<span class="nc" id="L658">							cubes = m_TimeSeriesManager.getRefreshedRawNonRealQueueTimeSeries(tv, cpgID, queueID, queue.getQueueType(), realQue, start, end, null);</span>
<span class="nc" id="L659">							ut.commit();</span>
<span class="nc" id="L660">						} catch (Exception e) {</span>
<span class="nc" id="L661">							ut.rollback();</span>
<span class="nc" id="L662">							throw e;</span>
<span class="nc" id="L663">						}</span>
						// TrackingManager returns Required at Pos 4, need swap
<span class="nc" id="L665">						TraceCube tempCube = cubes[3];</span>
<span class="nc" id="L666">						cubes[3] = cubes[4];</span>
<span class="nc" id="L667">						cubes[4] = tempCube;</span>
						// now convert to chunk Col
<span class="nc bnc" id="L669" title="All 4 branches missed.">						for (int i = 0; i &lt; cubes.length &amp;&amp; i &lt; chunkCol.length; i++) {</span>
<span class="nc bnc" id="L670" title="All 2 branches missed.">							if (cubes[i] != null) {</span>
<span class="nc" id="L671">								int maxLen = cubes[i].getMaximumLength(cubes[i].getTraceTypes());</span>
<span class="nc" id="L672">								chunkCol[i] = new ArrayList(maxLen);</span>
<span class="nc" id="L673">								Date chunkStart = TraceUtil.snapDate(cubes[i].getRawStartDate());</span>
<span class="nc bnc" id="L674" title="All 2 branches missed.">								for (int j = 0; j &lt; maxLen; j++) {</span>
<span class="nc" id="L675">									TraceChunk tc = new TraceChunk(queueID, chunkStart);</span>
<span class="nc" id="L676">									tc.setTraceValues(cubes[i].getTraceTypes(), cubes[i].getTraceValueD(cubes[i].getTraceTypes(), chunkStart));</span>
<span class="nc" id="L677">									chunkStart = new Date(chunkStart.getTime() + TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG * Trace.INTERVAL);</span>
<span class="nc" id="L678">									chunkCol[i].add(tc);</span>
								}
							}
						}

<span class="nc" id="L683">					} else {</span>
<span class="nc" id="L684">						ID realID = queueID;</span>
						// Get skill based info and media ID
<span class="nc" id="L686">						Jdmo jdmo = null;</span>
						// Special handling for non-skillBased
<span class="nc" id="L688">						HashSet&lt;ID&gt; nonSkillBasedSPSet = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L689">						ArrayList&lt;Date[]&gt; nonSkillRangeSet = new ArrayList&lt;Date[]&gt;();</span>
<span class="nc" id="L690">						String mediaDeID = null;</span>
						try {
<span class="nc" id="L692">							jdmo = new Jdmo();</span>
<span class="nc" id="L693">							String checkSkilledBased = &quot;select ISSKILLBASED, A.MEDIAID, C.SID, C.FROMDATE, C.TODATE from QUEUE A, SPQUEUE B, SP C where A.ID=B.QUEUEID and B.SPID=C.ID and A.SID=? and C.FROMDATE&lt;=? and C.TODATE&gt;=? order by C.FROMDATE asc&quot;;</span>
<span class="nc" id="L694">							JdmoQuery jQuery1 = jdmo.createQuery(checkSkilledBased, Jdmo.PARAM_QUERY);</span>
<span class="nc" id="L695">							jQuery1.setParID(1, realID);</span>
<span class="nc" id="L696">							jQuery1.setParTimestamp(2, TimeZoneUtil.toTimestamp(end));</span>
<span class="nc" id="L697">							jQuery1.setParTimestamp(3, TimeZoneUtil.toTimestamp(start));</span>
<span class="nc" id="L698">							JdmoRowset rs1 = jdmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">							while (rs1.next()) {</span>
<span class="nc" id="L700">								boolean skillBased = rs1.getBoolean(1);</span>
<span class="nc" id="L701">								mediaDeID = rs1.getString(2);</span>
<span class="nc bnc" id="L702" title="All 2 branches missed.">								if (!skillBased) {</span>
<span class="nc" id="L703">									nonSkillBasedSPSet.add(rs1.getID(3));</span>
<span class="nc" id="L704">									Date[] range = new Date[2];</span>
<span class="nc" id="L705">									range[0] = rs1.getTimestamp(4);</span>
<span class="nc" id="L706">									range[1] = rs1.getTimestamp(5);</span>
<span class="nc" id="L707">									nonSkillRangeSet.add(range);</span>
								}
<span class="nc" id="L709">							}</span>
<span class="nc" id="L710">							rs1.close();</span>
<span class="nc" id="L711">							jQuery1.close();</span>
<span class="nc" id="L712">							chunkCol[0] = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_ACTUAL, realID, start, end, lastUpdate, jdmo, false);</span>
<span class="nc" id="L713">							chunkCol[1] = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_FORECAST, realID, start, end, lastUpdate, jdmo, false);</span>
<span class="nc" id="L714">							chunkCol[2] = new ArrayList();</span>
<span class="nc" id="L715">							Collection prdCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_PREDICT, realID, start, end, lastUpdate, jdmo, false);</span>
<span class="nc bnc" id="L716" title="All 4 branches missed.">							if (prdCol != null &amp;&amp; !prdCol.isEmpty()) {</span>
<span class="nc" id="L717">								chunkCol[2].addAll(prdCol);</span>
							}
							// Add back RFTE
<span class="nc" id="L720">							chunkCol[3] = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_REQUIRE, realID, start, end, lastUpdate, jdmo, false);</span>
<span class="nc" id="L721">							chunkCol[4] = new ArrayList();</span>
<span class="nc" id="L722">							Collection sgCol = TimeSeriesDAO.getTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, realID, start, end, lastUpdate, jdmo, false);</span>
<span class="nc bnc" id="L723" title="All 4 branches missed.">							if (sgCol != null &amp;&amp; !sgCol.isEmpty()) {</span>
<span class="nc" id="L724">								chunkCol[4].addAll(sgCol);</span>
							}

							// fix predicted trace in nonskill mode
							// add NAChunk to staffing
<span class="nc bnc" id="L729" title="All 2 branches missed.">							if (!nonSkillRangeSet.isEmpty()) {</span>
								//  non skill SG is direct load
<span class="nc" id="L731">								Collection nonSkillSGCol = TimeSeriesDAO.getSGTimeSeriesFromLastUpdate(realID, nonSkillBasedSPSet, mediaDeID, start, end, lastUpdate, jdmo);</span>
<span class="nc bnc" id="L732" title="All 4 branches missed.">								if (nonSkillSGCol != null &amp;&amp; !nonSkillSGCol.isEmpty()) {</span>
<span class="nc" id="L733">									chunkCol[4].addAll(nonSkillSGCol);</span>
								}
<span class="nc" id="L735">								TraceChunk tc = null;</span>
<span class="nc" id="L736">								Iterator cubeIT = chunkCol[2].iterator();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">								if (cubeIT.hasNext()) {</span>
<span class="nc" id="L738">									tc = (TraceChunk) cubeIT.next();</span>
								}
								// if no predicted trace, still need put -2 to staffing
<span class="nc" id="L741">								ArrayList&lt;TraceChunk&gt; NAStaffList = new ArrayList&lt;TraceChunk&gt;();</span>
<span class="nc bnc" id="L742" title="All 2 branches missed.">								for (Date[] tr : nonSkillRangeSet) {</span>
<span class="nc" id="L743">									Date st = new Date(tr[0].getTime());</span>
<span class="nc bnc" id="L744" title="All 2 branches missed.">									while (st.before(tr[1])) {</span>
<span class="nc bnc" id="L745" title="All 4 branches missed.">										if (tc != null &amp;&amp; TimeSeriesDAO.fallsIn(tc.getStartDate(), tr[0], tr[1])) {</span>
<span class="nc bnc" id="L746" title="All 2 branches missed.">											if (st.equals(tc.getStartDate())) {</span>
<span class="nc" id="L747">												tc.setTraceValue(Trace.STAFFING, -2);</span>
<span class="nc bnc" id="L748" title="All 2 branches missed.">												if (cubeIT.hasNext()) {</span>
<span class="nc" id="L749">													tc = (TraceChunk) cubeIT.next();</span>
<span class="nc" id="L750">													st.setTime(st.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
<span class="nc" id="L751">													continue;</span>
												}
											} else {
<span class="nc" id="L754">												TraceChunk stfChunk = new TraceChunk(null, new Date(st.getTime()));</span>
<span class="nc" id="L755">												stfChunk.setTraceValue(Trace.STAFFING, -2);</span>
<span class="nc" id="L756">												NAStaffList.add(stfChunk);</span>
											}
<span class="nc" id="L758">											st.setTime(st.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
										} else {
<span class="nc bnc" id="L760" title="All 4 branches missed.">											if (tc == null || tc.getStartDate().after(tr[1])) {</span>
<span class="nc" id="L761">												TraceChunk stfChunk = new TraceChunk(null, new Date(st.getTime()));</span>
<span class="nc" id="L762">												stfChunk.setTraceValue(Trace.STAFFING, -2);</span>
<span class="nc" id="L763">												NAStaffList.add(stfChunk);</span>
<span class="nc" id="L764">											} else {</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">												if (cubeIT.hasNext()) {</span>
<span class="nc" id="L766">													tc = (TraceChunk) cubeIT.next();</span>
												}
											}
										}
<span class="nc" id="L770">										st.setTime(st.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG);</span>
									}
<span class="nc" id="L772">								}</span>
<span class="nc" id="L773">								chunkCol[2].addAll(NAStaffList);</span>
							}
							/*Sameet: 9/29/2005 Call to Adjust Required and Predicted Timeseries for Campaigns having Single NON-Skill Queue for IMMEDIATE Media Only*/
<span class="nc" id="L776">							adjustTimeSeriesForSingleQueueCampaigns(queueID, mediaID, queCpgAssCol, start, end, lastUpdate, chunkColForCombinedQue);</span>
						} finally {
<span class="nc bnc" id="L778" title="All 4 branches missed.">							if (jdmo != null) {</span>
<span class="nc" id="L779">								jdmo.cleanUp();</span>
							}
						}
					}
<span class="nc bnc" id="L783" title="All 2 branches missed.">					if (fixHOO) {</span>
						// for each campaign, fetch the HOO, convert to HOOPeriod, then normalize the result
<span class="nc" id="L785">						HashMap&lt;ID, Campaign&gt; cpgMap = new HashMap&lt;ID, Campaign&gt;();</span>
<span class="nc" id="L786">						ArrayList&lt;TimePeriod&gt; closedPeriodList = new ArrayList&lt;TimePeriod&gt;();</span>
<span class="nc bnc" id="L787" title="All 2 branches missed.">						for (CampaignQueue cq : queCpgAssCol) {</span>
<span class="nc" id="L788">							ID cpgID = cq.getCampaignID();</span>
<span class="nc bnc" id="L789" title="All 2 branches missed.">							if (cpgMap.get(cpgID) == null) {</span>
<span class="nc" id="L790">								cpgMap.put(cpgID, m_CampaignManager.getCampaignByID(cpgID));</span>
							}
<span class="nc" id="L792">							Collection&lt;CampaignHOO&gt; cpgHOOCol = m_CampaignManager.getCampaignHOOAssignments(cpgID, cq.getStartTime(), cq.getEndTime());</span>
<span class="nc" id="L793">							Campaign cpg = (Campaign) cpgMap.get(cpgID);</span>
<span class="nc" id="L794">							CampaignHOOPeriod cpgPeriod = new CampaignHOOPeriod(cq.getStartTime(), cq.getEndTime(), cpg.getTimeZone(), cpgHOOCol);</span>
<span class="nc" id="L795">							Collection&lt;TimePeriod&gt; closedPeriod = cpgPeriod.getClosePeriods(cq.getStartTime(), cq.getEndTime());</span>
<span class="nc" id="L796">							closedPeriodList.addAll(closedPeriod);</span>
<span class="nc" id="L797">							m_cat.debug(&quot;For campaign &quot; + cpgID + &quot; the closed periods are &quot; + closedPeriod);</span>
<span class="nc" id="L798">						}</span>
						// merge all closed period
<span class="nc" id="L800">						mergedClosedPeriod = TimePeriodUtil.merge(closedPeriodList);</span>
					}
<span class="nc" id="L802">				} else {</span>
					//Start For Campaign and Combined Media Trace type (COMB &amp; COMB-COMB Queues)
<span class="nc" id="L804">					boolean hasOutBoundQue = false;</span>
<span class="nc" id="L805">					Collection&lt;CampaignQueue&gt; queueAssignment = m_CampaignManager.getCampaignQueueAssignments(campaignID, realMediaID, start, end);</span>
<span class="nc bnc" id="L806" title="All 2 branches missed.">					if (queueAssignment.isEmpty()) {</span>
<span class="nc" id="L807">						return;</span>
					}
<span class="nc" id="L809">					m_cat.debug(&quot;CampaignQueue Assignments are&quot;);</span>
<span class="nc" id="L810">					m_cat.debug(queueAssignment);</span>
<span class="nc" id="L811">					HashMap&lt;ID, Collection&lt;ID&gt;&gt; spQMap = new HashMap&lt;ID, Collection&lt;ID&gt;&gt;();</span>
<span class="nc" id="L812">					HashMap&lt;ID, Date[]&gt; spTimeRangeMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="nc" id="L813">					Date spStart = null;</span>
<span class="nc" id="L814">					Date spEnd = null;</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">					for (CampaignQueue cq : queueAssignment) {</span>
<span class="nc" id="L816">						ID qID = cq.getQueueID();</span>
<span class="nc" id="L817">						ID spID = cq.getSPID();</span>
<span class="nc" id="L818">						Collection&lt;ID&gt; qCol = spQMap.get(spID);</span>
<span class="nc bnc" id="L819" title="All 2 branches missed.">						if (qCol == null) {</span>
<span class="nc" id="L820">							qCol = new ArrayList&lt;ID&gt;();</span>
						}
<span class="nc bnc" id="L822" title="All 2 branches missed.">						if (!hasOutBoundQue) {</span>
<span class="nc" id="L823">							Queue queue = m_WorkloadManager.getQueueByID(qID);</span>
<span class="nc bnc" id="L824" title="All 4 branches missed.">							hasOutBoundQue = queue != null &amp;&amp; Media.MEDIA_ID_PHONE_OUTBOUND.equals(queue.getMediaID());</span>
						}
<span class="nc" id="L826">						qCol.add(qID);</span>
<span class="nc" id="L827">						spQMap.put(spID, qCol);</span>
<span class="nc" id="L828">						Date[] timeRange = (Date[]) spTimeRangeMap.get(spID);</span>
<span class="nc bnc" id="L829" title="All 2 branches missed.">						if (timeRange == null) {</span>
<span class="nc bnc" id="L830" title="All 4 branches missed.">							if (spStart == null || spStart.after(cq.getStartTime())) {</span>
<span class="nc" id="L831">								spStart = cq.getStartTime();</span>
							}
<span class="nc bnc" id="L833" title="All 4 branches missed.">							if (spEnd == null || spEnd.before(cq.getEndTime())) {</span>
<span class="nc" id="L834">								spEnd = cq.getEndTime();</span>
							}
<span class="nc" id="L836">							timeRange = new Date[2];</span>
<span class="nc" id="L837">							timeRange[0] = cq.getStartTime();</span>
<span class="nc" id="L838">							timeRange[1] = cq.getEndTime();</span>
<span class="nc" id="L839">							spTimeRangeMap.put(spID, timeRange);</span>
						}
<span class="nc" id="L841">					}</span>
					// Now go fetch SP skill based information
<span class="nc" id="L843">					HashMap&lt;ID, Boolean&gt; spSkillMap = new HashMap&lt;ID, Boolean&gt;();</span>
<span class="nc" id="L844">					Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriods(campaignID, spStart, spEnd);</span>
<span class="nc bnc" id="L845" title="All 2 branches missed.">					for (SchedulingPeriod sp : spCol) {</span>
<span class="nc bnc" id="L846" title="All 2 branches missed.">						spSkillMap.put(sp.getID(), sp.getSkillBased() ? Boolean.TRUE : Boolean.FALSE);</span>
<span class="nc" id="L847">					}</span>
					//				long s2 = System.currentTimeMillis();
					// Actual/Forecast always need additional aggregation
<span class="nc" id="L850">					HashSet&lt;ID&gt; qIDSet = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">					for (ID spID : spQMap.keySet()) {</span>
						//qIDSet.addAll((Collection) spQMap.get(it.next()));
						//QA 92889 - Missing data in the daily global performance report
<span class="nc" id="L854">						Collection&lt;ID&gt; qIDs = spQMap.get(spID);</span>
<span class="nc" id="L855">						Collection&lt;Queue&gt; qs = m_WorkloadManager.getQueuesByIDs(qIDs);</span>
<span class="nc bnc" id="L856" title="All 2 branches missed.">						for (Queue q : qs) {</span>
<span class="nc" id="L857">							ID qID = q.getID();</span>
<span class="nc bnc" id="L858" title="All 2 branches missed.">							if (q.getQueueType() == Queue.QUEUE_TYPE_VIRTUAL) {</span>
<span class="nc" id="L859">								Collection&lt;ID&gt; subQIDs = m_WorkloadManager.getSubQueues(Collections.singletonList(qID));</span>
<span class="nc" id="L860">								qIDs.addAll(subQIDs);</span>
							}
<span class="nc" id="L862">						}</span>
<span class="nc" id="L863">						spQMap.put(spID, qIDs);</span>
<span class="nc" id="L864">						qIDSet.addAll(qIDs);</span>
						//End #92889
<span class="nc" id="L866">					}</span>
<span class="nc" id="L867">					chunkCol[0] = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_ACTUAL, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate);</span>

					// predicted is direct load always
<span class="nc bnc" id="L870" title="All 2 branches missed.">					if (hasOutBoundQue) {</span>
<span class="nc" id="L871">						chunkCol[1] = TimeSeriesDAO.getCombinedQueueForecastTimeSeriesFromLastUpdate(TraceUtil.META_FORECAST, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate);</span>
					} else {
<span class="nc" id="L873">						chunkCol[1] = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_FORECAST, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate);</span>
					}
<span class="nc" id="L875">					chunkCol[2] = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_PREDICT, campaignID, realMediaID, spQMap.keySet(), start, end, lastUpdate);</span>
					// Require/ServiceGoal has timeseries for non-skill based combined queue, skill based sp need aggregation
					// split SPs by Skill based info
<span class="nc" id="L878">					HashMap&lt;ID, Collection&lt;ID&gt;&gt; n_spQMap = new HashMap&lt;ID, Collection&lt;ID&gt;&gt;();</span>
<span class="nc" id="L879">					HashMap&lt;ID, Date[]&gt; n_spTimeRangeMap = new HashMap&lt;ID, Date[]&gt;();</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">					for (ID spID : spSkillMap.keySet()) {</span>
<span class="nc" id="L881">						Boolean skillBased = spSkillMap.get(spID);</span>
<span class="nc bnc" id="L882" title="All 4 branches missed.">						if (skillBased == null || !skillBased.booleanValue()) {</span>
<span class="nc" id="L883">							n_spQMap.put(spID, spQMap.get(spID));</span>
<span class="nc" id="L884">							spQMap.remove(spID);</span>
<span class="nc" id="L885">							n_spTimeRangeMap.put(spID, spTimeRangeMap.get(spID));</span>
<span class="nc" id="L886">							spTimeRangeMap.remove(spID);</span>
						}
<span class="nc" id="L888">					}</span>
					// the timerange may cover skill/non-skill based so need add them all
<span class="nc" id="L890">					chunkCol[4] = new ArrayList();</span>
<span class="nc" id="L891">					chunkCol[3] = new ArrayList();</span>
					// Add non-skill based for service goal
<span class="nc bnc" id="L893" title="All 2 branches missed.">					if (!n_spQMap.isEmpty()) {</span>

<span class="nc" id="L895">						m_cat.debug(&quot;Non skill based service goal dump for sp &quot; + n_spQMap.keySet());</span>
<span class="nc" id="L896">						Collection sgCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, campaignID, realMediaID, n_spQMap.keySet(), start, end, lastUpdate);</span>
<span class="nc" id="L897">						chunkCol[4].addAll(sgCol);</span>
						// direct load for required traces for non-skill based sps
<span class="nc" id="L899">						Collection stfCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REQUIRE, campaignID, realMediaID, n_spQMap.keySet(), start, end, lastUpdate);</span>
<span class="nc bnc" id="L900" title="All 2 branches missed.">						if (stfCol != null) {</span>
<span class="nc" id="L901">							chunkCol[3].addAll(stfCol);</span>
						}
					}
					//				long s6 = System.currentTimeMillis();
					// Add skill based combined result
<span class="nc bnc" id="L906" title="All 2 branches missed.">					if (!spQMap.isEmpty()) {</span>

<span class="nc" id="L908">						m_cat.debug(&quot;Skill based required/service goal dump for sp &quot; + spQMap);</span>
						//collection of tracechunks
<span class="nc" id="L910">						Collection stfCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REQUIRE, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate);</span>
<span class="nc bnc" id="L911" title="All 2 branches missed.">						if (stfCol != null) {</span>
<span class="nc" id="L912">							chunkCol[3].addAll(stfCol);</span>
						}
						// combine for service goal
<span class="nc" id="L915">						Collection sgCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_SERVICEGOAL, qIDSet, spQMap, spTimeRangeMap, start, end, lastUpdate);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">						if (sgCol != null) {</span>
<span class="nc" id="L917">							chunkCol[4].addAll(sgCol);</span>
						}
					}
<span class="nc bnc" id="L920" title="All 2 branches missed.">					if (fixHOO) {</span>
						// find HOO, then normalize the result
						// for each campaign, fetch the HOO, convert to HOOPeriod, then normalize the result
<span class="nc" id="L923">						Campaign cpg = m_CampaignManager.getCampaignByID(campaignID);</span>
<span class="nc" id="L924">						Collection&lt;CampaignHOO&gt; cpgHOOCol = m_CampaignManager.getCampaignHOOAssignments(campaignID, start, end);</span>
<span class="nc" id="L925">						CampaignHOOPeriod cpgPeriod = new CampaignHOOPeriod(start, end, cpg.getTimeZone(), cpgHOOCol);</span>
<span class="nc" id="L926">						mergedClosedPeriod = cpgPeriod.getClosePeriods(start, end);</span>
					}
				}
<span class="nc" id="L929">				m_cat.debug(&quot;Merged HOO closed periods are &quot; + mergedClosedPeriod);</span>
				// Now convert trace chunk to HashMap, and normalize them based on Campaign HOO definition
<span class="nc" id="L931">				Map&lt;Date, TraceChunk[]&gt; chunkMap = new HashMap&lt;Date, TraceChunk[]&gt;();</span>
<span class="nc" id="L932">				Map&lt;Date, CombinedQueueStaffing&gt; cmbStfMap = new HashMap&lt;Date, CombinedQueueStaffing&gt;();</span>
<span class="nc bnc" id="L933" title="All 4 branches missed.">				if (!(queueID != null &amp;&amp; !queueID.equals(new ID(-1)))) {</span>
<span class="nc" id="L934">					cmbStfMap = TimeSeriesDAO.getCombinedQueueStaffing(campaignID, mediaID, start, end, lastUpdate);</span>
				}
<span class="nc" id="L936">				Date chunkStart = start;</span>
<span class="nc" id="L937">				Date chunkEnd = end;</span>
<span class="nc bnc" id="L938" title="All 2 branches missed.">				for (int i = 0; i &lt; chunkCol.length; i++) {</span>
<span class="nc bnc" id="L939" title="All 2 branches missed.">					if (chunkCol[i] != null) {</span>
<span class="nc bnc" id="L940" title="All 2 branches missed.">						for (Iterator chunkIT = chunkCol[i].iterator(); chunkIT.hasNext(); ) {</span>
<span class="nc" id="L941">							TraceChunk chunk = (TraceChunk) chunkIT.next();</span>
<span class="nc" id="L942">							Date startDate = chunk.getStartDate();</span>
<span class="nc bnc" id="L943" title="All 8 branches missed.">							if ((end != null &amp;&amp; startDate.after(end)) || (start != null &amp;&amp; startDate.before(start))) {</span>
<span class="nc" id="L944">								continue;</span>
							}
<span class="nc" id="L946">							TraceChunk[] chunkArray = chunkMap.get(startDate);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">							if (chunkArray == null) {</span>
<span class="nc" id="L948">								chunkArray = new TraceChunk[5];</span>
							}
							/*if (queueID != null &amp;&amp; !queueID.equals(new ID(-1))) {
								chunkArray[3] = NAChunk;
							}*/
<span class="nc" id="L953">							chunkArray[i] = chunk;</span>
							//Calculate Computed Values For Forecast Trace Cube
<span class="nc bnc" id="L955" title="All 4 branches missed.">							if (i == 1 &amp;&amp; chunkArray[1] != null) {</span>
<span class="nc" id="L956">								(new ForecastTraceCube()).calcComputedTraceValuesForTraceChunk(chunkArray[1], mediaID);</span>
							}
<span class="nc bnc" id="L958" title="All 6 branches missed.">							if (i == 2 &amp;&amp; chunkArray[1] != null &amp;&amp; chunkArray[2] != null) {</span>
<span class="nc" id="L959">								PredictTraceCube.calcComputedTraceValuesForTraceChunk(chunkArray[2], chunkArray[1]);</span>
							}
<span class="nc" id="L961">							chunkMap.put(startDate, chunkArray);</span>
<span class="nc bnc" id="L962" title="All 6 branches missed.">							if (chunkStart == null || (chunkStart != null &amp;&amp; startDate.before(chunkStart))) {</span>
<span class="nc" id="L963">								chunkStart = startDate;</span>
							}
<span class="nc bnc" id="L965" title="All 6 branches missed.">							if (chunkEnd == null || (chunkEnd != null &amp;&amp; startDate.after(chunkEnd))) {</span>
<span class="nc" id="L966">								chunkEnd = startDate;</span>
							}
<span class="nc" id="L968">						}</span>
					}
				}
				//Sameet 9/29/2005 New block added to populate the Required &amp; Predicted timeseries for a single NON SKill Queue in a Campaign
<span class="nc bnc" id="L972" title="All 4 branches missed.">				for (int i = 0; chunkColForCombinedQue != null &amp;&amp; i &lt; chunkColForCombinedQue.length; i++) {</span>
<span class="nc bnc" id="L973" title="All 2 branches missed.">					if (chunkColForCombinedQue[i] != null) {</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">						for (Iterator chunkIT = chunkColForCombinedQue[i].iterator(); chunkIT.hasNext(); ) {</span>
<span class="nc" id="L975">							TraceChunk chunk = (TraceChunk) chunkIT.next();</span>
<span class="nc" id="L976">							Date startDate = chunk.getStartDate();</span>
<span class="nc bnc" id="L977" title="All 8 branches missed.">							if ((end != null &amp;&amp; startDate.after(end)) || (start != null &amp;&amp; startDate.before(start))) {</span>
<span class="nc" id="L978">								continue;</span>
							}
<span class="nc" id="L980">							TraceChunk[] chunkArray = chunkMap.get(startDate);</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">							if (chunkArray == null) {</span>
<span class="nc" id="L982">								chunkArray = new TraceChunk[5];</span>
							}
<span class="nc" id="L984">							chunkArray[i] = chunk;</span>
<span class="nc" id="L985">							chunkMap.put(startDate, chunkArray);</span>
<span class="nc bnc" id="L986" title="All 6 branches missed.">							if (chunkStart == null || (chunkStart != null &amp;&amp; startDate.before(chunkStart))) {</span>
<span class="nc" id="L987">								chunkStart = startDate;</span>
							}
<span class="nc bnc" id="L989" title="All 6 branches missed.">							if (chunkEnd == null || (chunkEnd != null &amp;&amp; startDate.after(chunkEnd))) {</span>
<span class="nc" id="L990">								chunkEnd = startDate;</span>
							}
<span class="nc" id="L992">						}</span>
					}
				}
				//End of change
<span class="nc" id="L996">				Set&lt;Date&gt; removeTimeSet = new HashSet&lt;Date&gt;();</span>
<span class="nc bnc" id="L997" title="All 6 branches missed.">				if (fixHOO &amp;&amp; mergedClosedPeriod != null &amp;&amp; !mergedClosedPeriod.isEmpty()) {</span>
					// now normalize any chunk in the closedPeriod window
<span class="nc bnc" id="L999" title="All 2 branches missed.">					for (TimePeriod period : mergedClosedPeriod) {</span>
<span class="nc" id="L1000">						Date pStart = TraceUtil.snapDate(period.getStartTime());</span>
<span class="nc" id="L1001">						Date pEnd = TraceUtil.snapDate(period.getEndTime());</span>
						do {
							// replace chunks start in non working period with -1 chunk
//						chunkMap.put(pStart, TraceUtil.NULL_TraceChunkArray);
							//QA46352 - staffing number by interval report not showing data for 12AM interval
							//if the start time and end time is the same, then it should not delete the period for chunk
<span class="nc bnc" id="L1007" title="All 2 branches missed.">							if (pStart.compareTo(pEnd) == 0) {</span>
<span class="nc" id="L1008">								m_cat.debug(&quot; While fixing the merged Closed period when start time and end time of closed period is same &quot; + chunkMap.get(pStart));</span>
							} else {
<span class="nc" id="L1010">								chunkMap.remove(pStart);</span>
<span class="nc" id="L1011">								cmbStfMap.remove(pStart);</span>
<span class="nc" id="L1012">								removeTimeSet.add(pStart);</span>
							}
<span class="nc bnc" id="L1014" title="All 6 branches missed.">							if (chunkStart == null || (chunkStart != null &amp;&amp; pStart.before(chunkStart))) {</span>
<span class="nc" id="L1015">								chunkStart = pStart;</span>
							}
<span class="nc bnc" id="L1017" title="All 6 branches missed.">							if (chunkEnd == null || (chunkEnd != null &amp;&amp; pStart.after(chunkEnd))) {</span>
<span class="nc" id="L1018">								chunkEnd = pStart;</span>
							}
<span class="nc" id="L1020">							pStart = new Date(pStart.getTime() + Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS);</span>
<span class="nc bnc" id="L1021" title="All 2 branches missed.">						} while (pStart.before(pEnd));</span>
<span class="nc" id="L1022">					}</span>
				}
				// we decide to use UserTransaction, and only control the final dump to avoid JTA timeout
<span class="nc" id="L1025">				UserTransaction ut = m_sessionContext.getUserTransaction();</span>
				try {
<span class="nc" id="L1027">					ut.setTransactionTimeout(USERTRANSACTION_TIMEOUT);</span>
<span class="nc" id="L1028">					ut.begin();</span>
					// finally dump the trace chunks
<span class="nc bnc" id="L1030" title="All 4 branches missed.">					if (queueID != null &amp;&amp; !queueID.equals(new ID(-1))) {</span>
<span class="nc" id="L1031">						TimeSeriesDAO.dumpTimeSeriesFromLastUpdate(queueID, null, null, chunkMap, cmbStfMap, chunkStart, chunkEnd, removeTimeSet);</span>
					} else {
<span class="nc" id="L1033">						TimeSeriesDAO.dumpTimeSeriesFromLastUpdate(null, campaignID, realMediaID, chunkMap, cmbStfMap, chunkStart, chunkEnd, removeTimeSet);</span>
					}
<span class="nc" id="L1035">					ut.commit();</span>
<span class="nc" id="L1036">				} catch (Exception e) {</span>
<span class="nc" id="L1037">					ut.rollback();</span>
<span class="nc" id="L1038">					throw e;</span>
<span class="nc" id="L1039">				}</span>
<span class="nc" id="L1040">				returnVal = true;</span>
				break;
<span class="nc" id="L1042">			} catch (Exception e) {</span>
<span class="nc" id="L1043">				handleException(e);</span>
<span class="nc" id="L1044">				retryCount++;</span>
<span class="nc bnc" id="L1045" title="All 2 branches missed.">				if (retryCount &gt;= nMaxRetry) {</span>
<span class="nc" id="L1046">					throw new BbmUpdateException(e);</span>
				}
<span class="nc" id="L1048">				m_cat.info(&quot;FAILED ON &quot; + retryCount + &quot; ATTEMPT, Dumping AGAIN campaignID: &quot; + campaignID + &quot;,mediaID =&quot; + mediaID + &quot;,queueID =&quot; + queueID + &quot;,start =&quot; + start + &quot;, end=&quot; + end + &quot;,lastUpdate =&quot; + lastUpdate + &quot;, fixHOO=&quot; + fixHOO);</span>
			} finally {
<span class="nc bnc" id="L1050" title="All 10 branches missed.">				if (retryCount &gt; 1) {</span>
<span class="nc bnc" id="L1051" title="All 10 branches missed.">					m_cat.info((returnVal ? &quot;SUCCEDED&quot; : &quot;FAILED&quot;) + &quot; AFTER &quot; + retryCount + &quot; ATTEMPTS &quot; + &quot;: Dumping campaignID: &quot; + campaignID + &quot;,mediaID =&quot; + mediaID + &quot;,queueID =&quot; + queueID + &quot;,start =&quot; + start + &quot;, end=&quot; + end + &quot;,lastUpdate =&quot; + lastUpdate + &quot;, fixHOO=&quot; + fixHOO);</span>
				}
<span class="nc" id="L1053">				methodFinish();</span>
<span class="nc" id="L1054">			}</span>
		}
<span class="nc" id="L1056">	}</span>

	/**
	 * Adjust the timeseries for QUEUE that has Single-Queue-Camapigns to include the Predicated and required time series
	 *
	 * @param queueID
	 * @param queCpgAssCol Collections of campaigns that used this queue for the specified period
	 * @param mediaID
	 * @param start        start of the period
	 * @param end
	 * @param lastUpdate
	 * @throws BbmUpdateException
	 */
	private void adjustTimeSeriesForSingleQueueCampaigns(ID queueID, ID mediaID, Collection&lt;CampaignQueue&gt; queCpgAssCol, Date start, Date end, Date lastUpdate, Collection[] chunkColForCombinedQue) throws BbmUpdateException {

<span class="nc" id="L1071">		m_cat.debug(&quot;Inside adjustTimeSeriesForSingleQueueCampaigns, where Queue &quot; + queueID + &quot;For Time Period:&quot; + start + &quot;:END =&quot; + end + &quot; LAST UPDATE:&quot; + lastUpdate);</span>
		try {
			//Find the campaigns for the specified time period for given Queue
			//Collection queCpgAssCol = m_CampaignManager.getQueueCampaignAssignments(queueID, start, end);
			//For the campaigns find the SPs with only one non skill queue attached
<span class="nc bnc" id="L1076" title="All 4 branches missed.">			if (queCpgAssCol == null || queCpgAssCol.isEmpty()) {</span>

<span class="nc bnc" id="L1078" title="All 2 branches missed.">				m_cat.debug(&quot;Cannot find any campaign for the real Queue &quot; + queueID + &quot;For Time Period:&quot; + start + &quot;:END =&quot; + end + &quot; LAST UPDATE:&quot; + lastUpdate + &quot; : Campaign is &quot; + (queCpgAssCol == null ? &quot;NULL&quot; : &quot;EMPTY&quot;));</span>
<span class="nc" id="L1079">				return;</span>
			}
<span class="nc" id="L1081">			Map&lt;ID, Map&lt;ID, List&lt;CampaignQueue&gt;&gt;&gt; campaignSPMap = new HashMap&lt;ID, Map&lt;ID, List&lt;CampaignQueue&gt;&gt;&gt;(); //Hashmap having  camapignID &lt;-&gt; Hashmap of SP that have queues</span>
<span class="nc bnc" id="L1082" title="All 2 branches missed.">			for (CampaignQueue cq : queCpgAssCol) {</span>
<span class="nc" id="L1083">				ID campaignID = cq.getCampaignID();</span>
				// get all SPs for the campaign and create a hashmap SP&lt;&gt; QUEUES for all sps
<span class="nc" id="L1085">				Collection&lt;CampaignQueue&gt; cpgQueCol = m_CampaignManager.getCampaignQueueAssignmentsAndCombinedQueues(campaignID, start, end);</span>
<span class="nc" id="L1086">				Map&lt;ID, List&lt;CampaignQueue&gt;&gt; spCpgQueMap = new HashMap&lt;ID, List&lt;CampaignQueue&gt;&gt;(); //hashmap that holds SP ID&lt;--&gt; Arraylist of QUEUES for all sps</span>
<span class="nc bnc" id="L1087" title="All 2 branches missed.">				for (CampaignQueue cpgQue : cpgQueCol) {</span>
<span class="nc" id="L1088">					ID spID = cpgQue.getSPID();</span>
<span class="nc" id="L1089">					List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">					if (cpqQueList == null) {</span>
<span class="nc" id="L1091">						cpqQueList = new ArrayList&lt;CampaignQueue&gt;();</span>
					}
<span class="nc" id="L1093">					cpqQueList.add(cpgQue);</span>
<span class="nc" id="L1094">					spCpgQueMap.put(spID, cpqQueList);</span>
<span class="nc" id="L1095">				}</span>
<span class="nc bnc" id="L1096" title="All 2 branches missed.">				if (!spCpgQueMap.isEmpty()) {</span>
<span class="nc" id="L1097">					campaignSPMap.put(campaignID, spCpgQueMap);</span>
				}
<span class="nc" id="L1099">			}</span>
			// find SP that only has one Queue linked
			//Sameet: if the ArrayList of queues for SP has two queues then it is defintely having only one real queue
<span class="nc" id="L1102">			Map&lt;ID, Map&lt;ID, CampaignQueue&gt;&gt; campaignSPMapForSingleNonSkillQs = new HashMap&lt;ID, Map&lt;ID, CampaignQueue&gt;&gt;();  //Hashmap having  camapignID &lt;-&gt; Hashmap of SP that have only single NON-SKILL queue</span>
<span class="nc bnc" id="L1103" title="All 2 branches missed.">			for (ID campaignID : campaignSPMap.keySet()) {</span>
<span class="nc" id="L1104">				Map&lt;ID, List&lt;CampaignQueue&gt;&gt; spCpgQueMap = campaignSPMap.get(campaignID);//hashmap that already holds SP ID&lt;--&gt; Arraylist of All QUEUES in that SP</span>
<span class="nc" id="L1105">				HashMap&lt;ID, CampaignQueue&gt; spQueIDMap = new HashMap&lt;ID, CampaignQueue&gt;();   //Hashmap that will contain  SP ID&lt;--&gt; queue for SP that have only one QUEUE</span>
<span class="nc bnc" id="L1106" title="All 2 branches missed.">				for (ID spID : spCpgQueMap.keySet()) {</span>
<span class="nc" id="L1107">					List&lt;CampaignQueue&gt; cpqQueList = spCpgQueMap.get(spID);</span>
<span class="nc bnc" id="L1108" title="All 2 branches missed.">					if (cpqQueList.size() == 2) {</span>
						// if cpgQue list size is 2, check if the media is Phone or not
<span class="nc" id="L1110">						CampaignQueue cpgQue1 = (CampaignQueue) cpqQueList.get(0);       //INDV QUEUE ; always normal queue</span>
<span class="nc" id="L1111">						CampaignQueue cpgQue2 = (CampaignQueue) cpqQueList.get(1);       //combined queue</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">						CampaignQueue medQue = cpgQue1.getMediaID() == null ? cpgQue2 : cpgQue1; //getMediaID is always always null for cpgQue1;( real queues)</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">						CampaignQueue relQue = cpgQue1.getQueueID() == null ? cpgQue2 : cpgQue1; //getQueueID will never be null for cpgQue1</span>
						// THIS applies to  PHONE QUEUES only; rest should be ignored
						// TODO eclingman Not clear what this logic does, so we still need
						// to verify that we don't need face to face test as well as phone test
<span class="nc bnc" id="L1117" title="All 2 branches missed.">						if (medQue.getMediaID().equals(Media.MEDIA_ID_PHONE)) {</span>
							// Put only those SPs that have the queue that we are working on
<span class="nc bnc" id="L1119" title="All 4 branches missed.">							if (queueID != null &amp;&amp; queueID.equals(relQue.getQueueID())) {</span>
<span class="nc" id="L1120">								spQueIDMap.put(relQue.getSPID(), relQue);</span>
							}
						}
					}
<span class="nc" id="L1124">				}</span>
				//If the SP is skill based then remove it from the Hashmap
<span class="nc" id="L1126">				Collection&lt;SchedulingPeriod&gt; spCol = m_CampaignManager.getSchedulingPeriodsByID(spQueIDMap.keySet());</span>
<span class="nc bnc" id="L1127" title="All 2 branches missed.">				for (SchedulingPeriod sp : spCol) {</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">					if (sp.getSkillBased()) {</span>
<span class="nc" id="L1129">						spQueIDMap.remove(sp.getID());</span>
					}
<span class="nc" id="L1131">				}</span>
				// now if SP is not empty then put it in the campaign HASHMAP.
<span class="nc bnc" id="L1133" title="All 4 branches missed.">				if (spQueIDMap != null &amp;&amp; !spQueIDMap.isEmpty()) {</span>
<span class="nc" id="L1134">					campaignSPMapForSingleNonSkillQs.put(campaignID, spQueIDMap);</span>
				}
<span class="nc" id="L1136">			}</span>
			/*
			chunkCol : Array of 5 holding collection of tracechunks FOR A REAL QUEUE
			combQueCube : TRACECUBE OF SOME TYPE FOR THE ENTIRE RANGE    */
			// TODO eclingman: do we want to consider face-to-face as similar to phone here?
<span class="nc bnc" id="L1141" title="All 4 branches missed.">			if (campaignSPMapForSingleNonSkillQs != null &amp;&amp; !campaignSPMapForSingleNonSkillQs.isEmpty()) {</span>
<span class="nc bnc" id="L1142" title="All 2 branches missed.">				for (ID campaignID : campaignSPMapForSingleNonSkillQs.keySet()) {</span>
<span class="nc" id="L1143">					Map&lt;ID, List&lt;CampaignQueue&gt;&gt; spQueIDMap = campaignSPMap.get(campaignID);//hashmap that already holds SP ID&lt;--&gt; Arraylist of single NONSKILL PHONE QUEUEs</span>
<span class="nc bnc" id="L1144" title="All 2 branches missed.">					if (!spQueIDMap.isEmpty()) {</span>
<span class="nc" id="L1145">						Collection stfCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REPORT_PREDICT, campaignID, Media.MEDIA_ID_PHONE, spQueIDMap.keySet(), start, end, null);</span>
<span class="nc bnc" id="L1146" title="All 2 branches missed.">						if (stfCol != null) {</span>
<span class="nc bnc" id="L1147" title="All 2 branches missed.">							if (chunkColForCombinedQue[2] == null) {</span>
<span class="nc" id="L1148">								chunkColForCombinedQue[2] = new ArrayList();</span>
							}
<span class="nc" id="L1150">							chunkColForCombinedQue[2].addAll(stfCol);</span>
						}
<span class="nc" id="L1152">						stfCol = TimeSeriesDAO.getCombinedQueueTimeSeriesFromLastUpdate(TraceUtil.META_REQUIRE, campaignID, Media.MEDIA_ID_PHONE, spQueIDMap.keySet(), start, end, null);</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">						if (stfCol != null) {</span>
<span class="nc bnc" id="L1154" title="All 2 branches missed.">							if (chunkColForCombinedQue[3] == null) {</span>
<span class="nc" id="L1155">								chunkColForCombinedQue[3] = new ArrayList();</span>
							}
<span class="nc" id="L1157">							chunkColForCombinedQue[3].addAll(stfCol);</span>
						}
					}
<span class="nc" id="L1160">				}</span>
			}
<span class="nc" id="L1162">		} catch (Exception e) {</span>
<span class="nc" id="L1163">			handleException(e);</span>
<span class="nc" id="L1164">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1166">			methodFinish();</span>
<span class="nc" id="L1167">		}</span>
<span class="nc" id="L1168">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>