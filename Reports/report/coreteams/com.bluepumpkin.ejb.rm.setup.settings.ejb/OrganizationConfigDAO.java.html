<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OrganizationConfigDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.settings.ejb</a> &gt; <span class="el_source">OrganizationConfigDAO.java</span></div><h1>OrganizationConfigDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.setup.settings.ejb;
/**
 * Title:        OrganizationConfigDAO
 * Description:  DAO class for OrganizationConfig
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Shailendra Sharma
 * @version      1.0
 */

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmSettingKey;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationConfig;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationConfigFieldInfo;
import com.bluepumpkin.ejb.rm.util.RmUtil;

public class OrganizationConfigDAO extends DAOBase {

<span class="fc" id="L44">    private static FieldInfo m_fieldInfo = new OrganizationConfigFieldInfo();</span>

	@Override
	protected FieldInfo getFieldInfo() {
<span class="fc" id="L48">		return m_fieldInfo;</span>
	}

<span class="fc" id="L51">    private static Category m_cat = Log.initCategory(OrganizationConfigDAO.class.getName());</span>

    private static final String TABLE_NAME = &quot;ORGANIZATIONCONFIG&quot;;

<span class="fc" id="L55">    private static final HashMap PROP_NAME_TO_POLICY_TYPE = new HashMap(7);</span>
	{
<span class="pc" id="L57">		PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_TO_POLICY, Request.REQUESTTYPE_TIMEOFF);</span>
<span class="pc" id="L58">		PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_FT_POLICY, Request.REQUESTTYPE_FLEXTIME);</span>
<span class="pc" id="L59">		PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_SS_POLICY, Request.REQUESTTYPE_SHIFTSWAP);</span>
<span class="pc" id="L60">		PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_SB_POLICY, Request.REQUESTTYPE_SHIFTBID);</span>
<span class="pc" id="L61">		PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_CS_POLICY, Request.REQUESTTYPE_CUSTSHIFT);</span>
	}

    /**
     * Returns the Category for the class
     * @return Category - Category object for the class
     */
    protected Category getCategory() {
<span class="nc" id="L69">    	return m_cat;</span>
    }

    /**
     * Default constructor for the creating object instance of the class.
    */
    public OrganizationConfigDAO() {
<span class="fc" id="L76">    	super();</span>
<span class="fc" id="L77">    }</span>

    /**
     * Constructor for the creating object instance of the class.
     * @param Jdmo  - Jdmo instance used for executing sql statements.
    */
    public OrganizationConfigDAO(Jdmo dmo) {
<span class="nc" id="L84">    	super(dmo);</span>
<span class="nc" id="L85">    }</span>

    /**
     * Creates OrganizationConfig object and return as value object.
     * @return ValueObjectBase - OrganizationConfig object instance
     * as value object.
    */
    @Override
	protected ValueObjectBase createValueObject() {
<span class="nc" id="L94">    	return (new OrganizationConfig());</span>
    }

    /**
     * Get PROPERTY-KEY and PROPERTY-VALUE pairs as HashMap for the the PROPERTY-KEY
     * specified in the pPropertyMap for the OrganizationId
     * passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - if true then only the properties defined at the org
     *                  is returned. If false then properties that are not defined
     *                  at the org but defined at parent orgs are added in.
     *                  The inherited values used based on the closeness to
     *                  given org. If A is parent of B is parent of C then
     *                  C will return properties defined a B if they are not
     *                  defined as C and will ignore those same properties
     *                  if they are also defined at A.
     *
     * @throws BbmFinderException if there is an error while executing database
     *                            query
     */
    public Map getPropertyList(ID orgId, Map pPropertyMap, boolean shallow) throws Exception {
<span class="fc" id="L118">        return getPropertyList(orgId, pPropertyMap, new HashMap(), new HashMap&lt;String, ID&gt;(), shallow);</span>
    }

    public Map getPropertyList(ID orgId, Map pPropertyMap, Map pAncestorMap, boolean shallow) throws Exception {
<span class="nc" id="L122">    	return getPropertyList(orgId, pPropertyMap, pAncestorMap, new HashMap&lt;String, ID&gt;(), shallow);</span>
	}

    /**
     * Get PROPERTY-KEY and PROPERTY-VALUE pairs as HashMap for the the PROPERTY-KEY
     * specified in the pPropertyMap for the OrganizationId
     * passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEYs mapped to PROPERTY-VALUEs
     * @param pAncestorIDsMap - A Map that contains PROPERTY-KEYs mapped to ancestor org names
     * @param pAncestorMap - A Map that contains PROPERTY-KEYs mapped to ancestor org IDs
     * @param shallow - if true then only the properties defined at the org
     *                  is returned. If false then properties that are not defined
     *                  at the org but defined at parent orgs are added in.
     *                  The inherited values used based on the closeness to
     *                  given org. If A is parent of B is parent of C then
     *                  C will return properties defined a B if they are not
     *                  defined as C and will ignore those same properties
     *                  if they are also defined at A.
     *
     * @return We return the pPropertyMap with the mapped values. We also modify pPropertyMap
     *         and pAncestorMap, so you can get the return values from there.
     * @throws BbmFinderException if there is an error while executing database
     *                            query
     */
    public Map getPropertyList(ID orgId, Map pPropertyMap, Map pAncestorMap, Map&lt;String, ID&gt; pAncestorIDsMap,
                               boolean shallow) throws Exception {
<span class="fc" id="L150">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>

        try {
<span class="fc" id="L153">            HashSet wantedPropList = new HashSet(pPropertyMap.keySet());</span>
<span class="fc" id="L154">            HashSet wantedPolicyList = new HashSet();</span>

            // We store the policies in another table because they are large
            // but we use keys as if these values are stored in the organization
            // config table. Now, we have to treat those keys specially to
            // get the data from the correct location.
            String key;
<span class="fc bfc" id="L161" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_TO_POLICY)) {</span>
<span class="fc" id="L162">                wantedPolicyList.add(key);</span>
            }

<span class="fc bfc" id="L165" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_SS_POLICY)) {</span>
<span class="fc" id="L166">                wantedPolicyList.add(key);</span>
            }

<span class="fc bfc" id="L169" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_SB_POLICY)) {</span>
<span class="fc" id="L170">                wantedPolicyList.add(key);</span>
            }

<span class="fc bfc" id="L173" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_CS_POLICY)) {</span>
<span class="fc" id="L174">                wantedPolicyList.add(key);</span>
            }

<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_FT_POLICY)) {</span>
<span class="fc" id="L178">                wantedPolicyList.add(key);</span>
            }

<span class="fc" id="L181">            StringBuffer strQuery = new StringBuffer(512);</span>
<span class="fc" id="L182">            strQuery.append(&quot; SELECT PROPERTYNAME, PROPERTYVALUE &quot;);</span>
<span class="fc" id="L183">            strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="fc" id="L184">            strQuery.append(&quot; WHERE ORGANIZATIONID = ?&quot;);</span>
<span class="fc" id="L185">            strQuery.append(&quot; AND PROPERTYNAME IN &quot;);</span>
<span class="fc" id="L186">            int resetLength = strQuery.length();</span>

            Collection lParentOrgIDList;

            // if we only want the settings that are defined at the given
            // organization.
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (shallow) {</span>
<span class="fc" id="L193">                ArrayList al = new ArrayList(1);</span>
<span class="fc" id="L194">                al.add(orgId);</span>
<span class="fc" id="L195">                lParentOrgIDList = al;</span>
<span class="fc" id="L196">            }</span>
            // we want settings that are inherited from parent organization
            // if they are missing from the ones defined at the organization
            else {
                //lParentOrgIDList = orderOrgs(CacheUtilBBM.getParentOrgIDs(orgId, getDMO())); //not ordered!
<span class="fc" id="L201">                lParentOrgIDList = getParentOrganizationsCollection(orgId, m_dmo);</span>
<span class="fc" id="L202">                ArrayList al = new ArrayList(lParentOrgIDList.size()+1);</span>
<span class="fc" id="L203">                al.add(orgId); //add our org to the front of the list</span>
<span class="fc" id="L204">                al.addAll(lParentOrgIDList);</span>
            }
<span class="fc" id="L206">            Iterator lParentOrgIdIterator = lParentOrgIDList.iterator();</span>

<span class="fc" id="L208">            for (int i = 0;</span>
<span class="pc bpc" id="L209" title="3 of 4 branches missed.">                 (!wantedPropList.isEmpty() || !wantedPolicyList.isEmpty()) &amp;&amp;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                 lParentOrgIdIterator.hasNext();</span>
<span class="fc" id="L211">                 i++) {</span>

<span class="fc" id="L213">                ID tmpId = (ID)lParentOrgIdIterator.next();</span>

                // make sure the orgId is the first one we process
<span class="fc bfc" id="L216" title="All 4 branches covered.">                if (i == 0 &amp;&amp; !tmpId.equals(orgId)) {</span>
                    // if it isn't then pretend ...
<span class="fc" id="L218">                    lParentOrgIdIterator = lParentOrgIDList.iterator();</span>
<span class="fc" id="L219">                    tmpId = orgId;</span>
                }

                // we get the properties we want from the current org in the
                // hierarchy. If we can't find all we need then we go to the
                // parent org until we've gotten everything.
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                if (!wantedPropList.isEmpty()) {</span>
<span class="fc" id="L226">                    strQuery.setLength(resetLength);</span>
<span class="fc" id="L227">                    strQuery.append(RmUtil.createInClause(wantedPropList));</span>

<span class="fc" id="L229">                    JdmoQuery jQuery1 = m_dmo.createQuery(strQuery.toString(), Jdmo.PARAM_QUERY);</span>

<span class="fc" id="L231">                    jQuery1.setParID(1, tmpId);</span>
<span class="fc" id="L232">                    JdmoRowset rs = m_dmo.createRowset(jQuery1, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

<span class="fc bfc" id="L234" title="All 2 branches covered.">                    while(rs.next()) {</span>
<span class="fc" id="L235">                        String prop = rs.getString(&quot;PROPERTYNAME&quot;);</span>
<span class="fc" id="L236">                        String valu = rs.getString(&quot;PROPERTYVALUE&quot;);</span>

<span class="fc" id="L238">                        pPropertyMap.put(prop, valu);</span>

<span class="pc bpc" id="L240" title="1 of 2 branches missed.">                        if (!tmpId.equals(orgId)) {</span>
<span class="nc" id="L241">                            pAncestorMap.put(prop, getOrgName(tmpId));</span>
<span class="nc" id="L242">                            pAncestorIDsMap.put(prop, tmpId);</span>
                        }

                        // now that we have what we want, we can remove
                        // this property from the list.
<span class="fc" id="L247">                        wantedPropList.remove(prop);</span>
<span class="fc" id="L248">                    }</span>
                }

                // we do the same thing for policy text
<span class="fc bfc" id="L252" title="All 2 branches covered.">                if (!wantedPolicyList.isEmpty()) {</span>
<span class="fc" id="L253">                    Iterator policyKeys = wantedPolicyList.iterator();</span>

<span class="fc bfc" id="L255" title="All 2 branches covered.">                    if (lRequestPolicyTextDAO == null) {</span>
<span class="fc" id="L256">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>
                    }

<span class="fc bfc" id="L259" title="All 2 branches covered.">                    while (policyKeys.hasNext()) {</span>
<span class="fc" id="L260">                        String propName = (String)policyKeys.next();</span>
<span class="fc" id="L261">                        String policyType = getPolicyType(propName);</span>
<span class="fc" id="L262">                        String policy = lRequestPolicyTextDAO.getRequestPolicy(tmpId, policyType);</span>

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">                        if (policy != null) {</span>
<span class="nc" id="L265">                            pPropertyMap.put(propName, policy);</span>
<span class="nc bnc" id="L266" title="All 2 branches missed.">                            if (!tmpId.equals(orgId)) {</span>
<span class="nc" id="L267">                                pAncestorMap.put(propName, getOrgName(tmpId));</span>
<span class="nc" id="L268">                                pAncestorIDsMap.put(propName, tmpId);</span>
                            }
<span class="nc" id="L270">                            wantedPolicyList.remove(propName);</span>
<span class="nc" id="L271">                            policyKeys = wantedPolicyList.iterator();</span>
                        }
<span class="fc" id="L273">                    }</span>
                }

                // if we're shallow then we won't check the ancestors for
                // their properties.
<span class="fc bfc" id="L278" title="All 2 branches covered.">                if (shallow) {</span>
<span class="fc" id="L279">                    break;</span>
                }
            }

            //If there are any properties or policies left in the lists, that means that we never found them.
            //We cannot leave the ancestors empty for them however, because that would imply that the values were overridden
            //rather than &quot;inherited&quot;. In this case, no org had a value for them, so technically, they are the default values,
            //but for the sake of the user, we'll say that these values are inheritted from the top level organization.
<span class="fc bfc" id="L287" title="All 4 branches covered.">            if (!shallow &amp;&amp; !orgId.equals(Organization.YOUR_COMPANY_ID_OBJ)) {</span>
<span class="fc" id="L288">            	String yourCompanyName = getOrgName(Organization.YOUR_COMPANY_ID_OBJ);</span>

<span class="pc bpc" id="L290" title="1 of 2 branches missed.">            	if (!wantedPropList.isEmpty()) {</span>
<span class="fc bfc" id="L291" title="All 2 branches covered.">            		for (Iterator it=wantedPropList.iterator(); it.hasNext();) {</span>
<span class="fc" id="L292">            			String propName = (String)it.next();</span>
<span class="fc" id="L293">            			pAncestorMap.put(propName, yourCompanyName);</span>
<span class="fc" id="L294">            			pAncestorIDsMap.put(propName, Organization.YOUR_COMPANY_ID_OBJ);</span>
<span class="fc" id="L295">            		}</span>
            	}

<span class="pc bpc" id="L298" title="1 of 2 branches missed.">            	if (!wantedPolicyList.isEmpty()) {</span>
<span class="fc bfc" id="L299" title="All 2 branches covered.">            		for (Iterator it=wantedPolicyList.iterator(); it.hasNext();) {</span>
<span class="fc" id="L300">            			String propName = (String)it.next();</span>
<span class="fc" id="L301">            			pAncestorMap.put(propName, yourCompanyName);</span>
<span class="fc" id="L302">            			pAncestorIDsMap.put(propName, Organization.YOUR_COMPANY_ID_OBJ);</span>
<span class="fc" id="L303">            		}</span>
            	}
            }
        } finally {
<span class="pc bpc" id="L307" title="2 of 4 branches missed.">            if (lRequestPolicyTextDAO != null) {</span>
<span class="pc" id="L308">            	lRequestPolicyTextDAO.cleanUp();</span>
            }
        }

<span class="fc" id="L312">        return pPropertyMap;</span>
    }

    /**
     * Set PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as arguments. The methods will split
     * the propertyMap into a set of properties to update and a set to
     * insert. If shallow is false, then the value of the properties are
     * copied to all children (this will overwrite the values of the children).
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - true if you want to update only this org, false to update children too.
     *
     * @throws BbmCreateException if there is an error while executing database
     *                            query
     * @throws BbmUpdateException if there is an error while executing database
     *                            query
     */
    public void setPropertyList(ID orgId, Map pPropertyMap, boolean shallow) throws Exception {

<span class="pc bpc" id="L334" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L335">            m_cat.debug(&quot;setPropertyList: &quot;+pPropertyMap);</span>
        }

<span class="fc" id="L338">        Iterator propItr = pPropertyMap.keySet().iterator();</span>

        // get the current settings to compare against the new
<span class="fc" id="L341">        Map pPropertyMapCopy = new HashMap(pPropertyMap);</span>

        // We use a test value to determine which properties
        // are not defined at the given organization. Since
        // we are using a shallow query of the properties of
        // an organization it is possible that there will be
        // properties that are not defined at the level yet.
        //FIXME: why are we using an empty byte array as a test value?
<span class="fc" id="L349">        Object test= new byte[0];</span>
<span class="fc bfc" id="L350" title="All 2 branches covered.">        while ( propItr.hasNext() ) {</span>
<span class="fc" id="L351">            String propName = (String) propItr.next();</span>
<span class="fc" id="L352">            pPropertyMapCopy.put(propName, test);</span>
<span class="fc" id="L353">        }</span>
<span class="fc" id="L354">        getPropertyList(orgId, pPropertyMapCopy, true);</span>

        // figure out which settings to update and which to create
        // If shallow is true, and there is no change in the value then we skip it.
<span class="fc" id="L358">        HashMap pPropertyMapCreate = new HashMap(31);</span>
<span class="fc" id="L359">        HashMap pPropertyMapUpdate = new HashMap(31);</span>
<span class="fc" id="L360">        propItr = pPropertyMap.keySet().iterator();</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        while (propItr.hasNext()) {</span>
<span class="fc" id="L362">            String propName = (String) propItr.next();</span>
<span class="fc" id="L363">            Object oldValue = pPropertyMapCopy.get(propName);</span>
<span class="fc" id="L364">            Object newValue = pPropertyMap.get(propName);</span>
            /*
            if ((shallow==true) &amp;&amp; ((oldValue == newValue) || (oldValue.equals(newValue)))) {
                // for shallow save, ignore properties which have not changed
                continue;
            }
            */
<span class="pc bpc" id="L371" title="2 of 4 branches missed.">            if (oldValue == null || newValue == null) {</span>
<span class="nc" id="L372">                pPropertyMapUpdate.put(propName, newValue);</span>
<span class="nc" id="L373">                continue;</span>
            }
            //Only create a new record if the old record had no value and the new record does have a value.
            //New values can sometimes be an empty string (&quot;&quot;) and not an empty byte array.  It is not clear
            //why the empty byte array is used as a test value.
<span class="pc bpc" id="L378" title="2 of 4 branches missed.">            if (oldValue == test &amp;&amp; !newValue.equals(oldValue)) {</span>

            	// In this case the key is not in the DB, so don't try
            	// to add it as it's empty.  Previously it would try to
            	// update the value which caused an error.
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">            	if (!newValue.equals(&quot;&quot;)) {</span>
<span class="fc" id="L384">            		pPropertyMapCreate.put(propName, newValue);</span>
            	}
            } else {
<span class="nc" id="L387">                pPropertyMapUpdate.put(propName, newValue);</span>
            }
<span class="fc" id="L389">        }</span>

<span class="pc bpc" id="L391" title="1 of 2 branches missed.">        if (!pPropertyMapCreate.isEmpty()) {</span>
<span class="fc" id="L392">            createPropertyList(orgId, pPropertyMapCreate);</span>
        }

<span class="pc bpc" id="L395" title="1 of 2 branches missed.">        if (!pPropertyMapUpdate.isEmpty()) {</span>
<span class="nc" id="L396">            updatePropertyList(orgId, pPropertyMapUpdate, shallow);</span>
        }
<span class="fc" id="L398">    }</span>

    /**
     * Create PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as argument.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     */
    private void createPropertyList(ID orgId, Map pPropertyMap) throws Exception {
<span class="pc bpc" id="L409" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L410">            m_cat.debug(&quot;createPropertyList: &quot;+pPropertyMap);</span>
        }
<span class="fc" id="L412">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>
<span class="fc" id="L413">        HashMap lColumnValHashMap = null;</span>
<span class="fc" id="L414">        boolean executeBatch = false;</span>

        try {
<span class="fc" id="L417">            Iterator propItr = pPropertyMap.keySet().iterator();</span>

<span class="fc bfc" id="L419" title="All 2 branches covered.">            while (propItr.hasNext()) {</span>
<span class="fc" id="L420">                String propName = (String) propItr.next();</span>
<span class="fc" id="L421">                String propValue = (String) pPropertyMap.get(propName);</span>

<span class="fc" id="L423">                String policyType = getPolicyType(propName);</span>

<span class="pc bpc" id="L425" title="1 of 2 branches missed.">                if (policyType != null ) {</span>
<span class="nc bnc" id="L426" title="All 2 branches missed.">                    if (lRequestPolicyTextDAO == null) {</span>
<span class="nc" id="L427">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>
                    }

<span class="nc" id="L430">                    lRequestPolicyTextDAO.createRequestPolicy(orgId, policyType, propValue);</span>
<span class="nc" id="L431">                    continue;</span>
                }

<span class="fc bfc" id="L434" title="All 2 branches covered.">                if (lColumnValHashMap == null) {</span>
<span class="fc" id="L435">                    lColumnValHashMap = new HashMap(7);</span>
                }
<span class="fc" id="L437">                lColumnValHashMap.put(&quot;ORGANIZATIONID&quot;,orgId);</span>
<span class="fc" id="L438">                lColumnValHashMap.put(&quot;PROPERTYNAME&quot;,propName);</span>
<span class="fc" id="L439">                lColumnValHashMap.put(&quot;PROPERTYVALUE&quot;,propValue);</span>

<span class="fc" id="L441">                m_dmo.addBatchInsert(TABLE_NAME, lColumnValHashMap);</span>
<span class="fc" id="L442">                executeBatch = true;</span>
<span class="fc" id="L443">            }</span>

<span class="pc bpc" id="L445" title="1 of 2 branches missed.">            if (executeBatch) {</span>
<span class="fc" id="L446">                m_dmo.executeBatch();</span>
            }
        } finally {
<span class="pc bpc" id="L449" title="3 of 4 branches missed.">            if (lRequestPolicyTextDAO != null) {</span>
<span class="nc" id="L450">            	lRequestPolicyTextDAO.cleanUp();</span>
            }
        }
<span class="fc" id="L453">    }</span>

    /**
     * Update PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - true if you want to update only this org, false to update children too.
     */
    private void updatePropertyList(ID orgId, Map pPropertyMap, boolean shallow) throws Exception {
<span class="nc" id="L465">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>
<span class="nc bnc" id="L466" title="All 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="nc" id="L467">            m_cat.debug(&quot;updatePropertyList: &quot;+pPropertyMap);</span>
        }

        try {
            Collection lChildOrgIDList;
<span class="nc bnc" id="L472" title="All 2 branches missed.">            if (shallow) {</span>
<span class="nc" id="L473">                lChildOrgIDList = new ArrayList(1);</span>
            } else {
<span class="nc" id="L475">                lChildOrgIDList = DAOUtil.getChildOrganizations(orgId, m_dmo); //uses proc BP_GETCHILDORG.</span>
            }
<span class="nc" id="L477">            lChildOrgIDList.add(orgId);</span>

<span class="nc" id="L479">            StringBuilder strQuery = new StringBuilder(512);</span>
<span class="nc" id="L480">            strQuery.append(&quot; UPDATE &quot;);</span>
<span class="nc" id="L481">            strQuery.append(&quot; ORGANIZATIONCONFIG SET PROPERTYVALUE = ? &quot;);</span>
<span class="nc" id="L482">            strQuery.append(&quot; WHERE PROPERTYNAME = ? &quot;);</span>
<span class="nc" id="L483">            strQuery.append(&quot; AND ORGANIZATIONID IN &quot;);</span>
<span class="nc" id="L484">            strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>

<span class="nc" id="L486">            String query = strQuery.toString();</span>
<span class="nc" id="L487">            Object params[] = new Object[2];</span>

<span class="nc" id="L489">            Iterator propItr = pPropertyMap.keySet().iterator();</span>
<span class="nc bnc" id="L490" title="All 2 branches missed.">            while (propItr.hasNext()) {</span>
<span class="nc" id="L491">                String propName = (String) propItr.next();</span>
<span class="nc" id="L492">                String propValue = (String) pPropertyMap.get(propName);</span>

<span class="nc" id="L494">                String policyType = getPolicyType(propName);</span>

<span class="nc bnc" id="L496" title="All 2 branches missed.">                if (policyType != null) {</span>
<span class="nc bnc" id="L497" title="All 2 branches missed.">                    if (lRequestPolicyTextDAO == null) {</span>
<span class="nc" id="L498">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>
                    }
<span class="nc" id="L500">                    lRequestPolicyTextDAO.updateRequestPolicy(lChildOrgIDList, policyType, propValue);</span>
<span class="nc" id="L501">                    continue;</span>
                }

<span class="nc" id="L504">                params[1] = propName;</span>
<span class="nc bnc" id="L505" title="All 2 branches missed.">                if (propValue == null) {</span>
                    // jdmo requires that null parameters are passed
                    // this way.
<span class="nc" id="L508">                    params[0] = new JdmoParam(null, java.sql.Types.VARCHAR);</span>
                } else {
<span class="nc" id="L510">                    params[0] = propValue;</span>
                }

<span class="nc" id="L513">                int results = m_dmo.executePCommand(query, params);</span>
<span class="nc bnc" id="L514" title="All 2 branches missed.">                if (results == 0) {</span>
<span class="nc" id="L515">                    m_cat.error(&quot;SQL Execute returned &quot;+results+</span>
                                &quot;: property=&quot;+propName+
                                &quot;: value=&quot;+propValue);
<span class="nc bnc" id="L518" title="All 2 branches missed.">                } else if (results &lt; 0) {</span>
                    // wasn't expecting this
<span class="nc" id="L520">                    throw new BbmUpdateException(&quot;SQL Execute returned &quot;+results+</span>
                                                 &quot;: property=&quot;+propName+
                                                 &quot;: value=&quot;+propValue);
                }
<span class="nc" id="L524">            }</span>
        } finally {
<span class="nc bnc" id="L526" title="All 4 branches missed.">            if (lRequestPolicyTextDAO != null) {</span>
<span class="nc" id="L527">            	lRequestPolicyTextDAO.cleanUp();</span>
            }
        }
<span class="nc" id="L530">    }</span>

    /**
     * Delete all properties for all the child orgs of orgID. Does not affect orgID itself.
     *
     * @param orgId - The Organisation ID whose children's properties you want to delete.
     * @throws BbmRemoveException if there is an error while executing database query
     */
	public void deleteAllPropertiesFromChildren(ID orgId) throws Exception {

<span class="pc bpc" id="L540" title="1 of 2 branches missed.">		if (orgId == null) {</span>
<span class="nc" id="L541">			return;</span>
		}

<span class="fc" id="L544">		RequestPolicyTextDAO reqPolicyDAO = null;</span>
		try {
			Collection lChildOrgIDList;
<span class="fc" id="L547">			lChildOrgIDList = DAOUtil.getChildOrganizations(orgId, m_dmo);</span>

			// delete the properties
<span class="fc" id="L550">			StringBuilder strQuery = new StringBuilder(512);</span>
<span class="fc" id="L551">			strQuery.append(&quot; DELETE &quot;);</span>
<span class="fc" id="L552">			strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="fc" id="L553">			strQuery.append(&quot; WHERE ORGANIZATIONID IN &quot;);</span>
<span class="fc" id="L554">			strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>
<span class="fc" id="L555">			m_dmo.executeCommand(strQuery.toString());</span>

			// delete the policies
<span class="fc" id="L558">			reqPolicyDAO = new RequestPolicyTextDAO();</span>
<span class="fc" id="L559">			reqPolicyDAO.deleteRequestPolicy(lChildOrgIDList, null);</span>
		} finally {
<span class="pc bpc" id="L561" title="3 of 4 branches missed.">			if (reqPolicyDAO != null) {</span>
<span class="pc" id="L562">				reqPolicyDAO.cleanUp();</span>
			}
		}
<span class="fc" id="L565">	}</span>

    /**
     * Convert property name to policy type.
     *
     * @param  propName - name of organization property
     * @return String null if propName is not a policy property, otherwise
     *         returns REQUESTTYPE_TIMEOFF or REQUESTTYPE_SHIFTSWAP or REQUESTTYPE_SHIFTBID.
     */
    private static String getPolicyType(String propName) {
<span class="fc" id="L575">        return (String)PROP_NAME_TO_POLICY_TYPE.get(propName);</span>
    }

    /**
     * Given an orgID, return its parent org ID. If it has no parent, returns null.
     * @param orgID The ID of the organization whose parent ID we want to get.
     * @return its parent org ID. If it has no parent, returns null.
     *
    public ID getParentOrgID(ID orgID) throws Exception
    {
        ID parentID = null;
        //List lParentOrgIDList = orderOrgs(CacheUtilBBM.getParentOrgIDs(orgID, getDMO())); //not ordered!
        Collection lParentOrgIDList = getParentOrganizationsCollection(orgID, m_dmo);

        Iterator lParentOrgIdIterator = lParentOrgIDList.iterator();
        while (lParentOrgIdIterator.hasNext())
        {
            parentID = (ID)lParentOrgIdIterator.next();
            break;
        }
        return parentID;
    }
    */

    /**
     * Get the name of an organization.
     * @param orgID The organization ID.
     * @return the name of an organization.
     * @throws Exception
     */
    private String getOrgName(ID orgID) throws Exception {
<span class="fc" id="L606">	    return CacheUtilBBM.getOrganizationByID(orgID).getName();</span>
	    /*
        if (orgID == null)
            return null;

        String name = null;
        StringBuffer strQuery = new StringBuffer(512);
        strQuery.append(&quot; SELECT NAME &quot;);
        strQuery.append(&quot; FROM ORGANIZATION &quot;);
        strQuery.append(&quot; WHERE ID = ?&quot;);

        JdmoQuery jQuery1 = m_dmo.createQuery(strQuery.toString(),
                                              Jdmo.PARAM_QUERY);

        jQuery1.setParID(1, orgID);
        JdmoRowset rs = m_dmo.createRowset(jQuery1,
                                           Jdmo.FORWARD_ONLY,
                                           Jdmo.READ_ONLY);

        while(rs.next())
            name = rs.getString(&quot;NAME&quot;);

        return name;*/
    }


    /**
     *  get all parent orgs of a given org, returned as a list with child organizations first.
     *  @return a list of parent organization ids.  The first id in the list is the
     *  immediate parent of idOrg, followed by that organization's parent up to
     *  the company root, which is the last id in the list.  If the company root is
     *  passed as input, then an empty List is returned.
     */
    private Collection getParentOrganizationsCollection(ID idOrg, Jdmo dmo) throws BbmFinderException {
        // call stored procedure to get parent orgs
        try {
<span class="fc" id="L642">            JdmoQuery  query = dmo.createQuery(&quot;BP_GETPARENTORG&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="fc" id="L643">            query.setParID(1, idOrg);</span>
<span class="fc" id="L644">            JdmoRowset rs = dmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

            // fetch parent orgs to format the query
<span class="fc" id="L647">            ArrayList arList = new ArrayList();</span>
<span class="fc bfc" id="L648" title="All 2 branches covered.">            while(rs.next()) {</span>
<span class="fc" id="L649">                arList.add(rs.getID(&quot;ID&quot;));</span>
            }
<span class="fc" id="L651">            rs.close();</span>
<span class="fc" id="L652">            return arList;</span>
<span class="nc" id="L653">        } catch(Exception e) {</span>
<span class="nc" id="L654">            throw new BbmFinderException(e);</span>
        }
    }

    /**
     * Delete all PROPERTY-KEYs specified in the pPropertySet for the organization IDs
     * and all the child organizations.
     *
     * @param orgIds - organization IDs
     * @param pPropertySet - A Set that contains PROPERTY-KEY
     * @throws BbmRemoveException if there is an error while executing database query
     */
    public void deletePropertyList(Collection&lt;ID&gt; orgIds, Set&lt;String&gt; pPropertySet) throws Exception {

<span class="nc bnc" id="L668" title="All 4 branches missed.">        if ((pPropertySet == null) || (pPropertySet.isEmpty()) ) {</span>
<span class="nc" id="L669">            return;</span>
        }

<span class="nc" id="L672">        RequestPolicyTextDAO reqPolicyDAO = null;</span>
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L675">            Collection&lt;ID&gt; lChildOrgIDList = DAOUtil.getChildOrganizationsCollection(orgIds, m_dmo);</span>
<span class="nc" id="L676">            lChildOrgIDList.addAll(orgIds);</span>


<span class="nc" id="L679">            ArrayList&lt;String&gt; policyTypeList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L680">            ArrayList&lt;String&gt; propNameList = new ArrayList&lt;String&gt;();</span>

            // split the property list into the normal properties that
            // are defined in the organization config table and those
            // special ones that are for organization policy.
<span class="nc" id="L685">            Iterator&lt;String&gt; propItr = pPropertySet.iterator();</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">            while (propItr.hasNext()) {</span>
<span class="nc" id="L687">                String  propName = (String) propItr.next();</span>
<span class="nc" id="L688">                String policyType = getPolicyType(propName);</span>

<span class="nc bnc" id="L690" title="All 2 branches missed.">                if (policyType != null ) {</span>
<span class="nc" id="L691">                    policyTypeList.add(policyType);</span>
                } else {
<span class="nc" id="L693">                    propNameList.add(propName);</span>
                }
<span class="nc" id="L695">            }</span>

            // delete the properties
<span class="nc bnc" id="L698" title="All 2 branches missed.">            if (!propNameList.isEmpty()) {</span>
<span class="nc" id="L699">                StringBuilder strQuery = new StringBuilder(512);</span>
<span class="nc" id="L700">                strQuery.append(&quot; DELETE &quot;);</span>
<span class="nc" id="L701">                strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="nc" id="L702">                strQuery.append(&quot; WHERE ORGANIZATIONID IN &quot;);</span>
<span class="nc" id="L703">                strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>

<span class="nc" id="L705">                strQuery.append(&quot; AND PROPERTYNAME IN &quot;);</span>
<span class="nc" id="L706">                strQuery.append( RmUtil.createInClause(propNameList) );</span>

<span class="nc" id="L708">                m_dmo.executeCommand(strQuery.toString());</span>
            }

            // delete the policies
<span class="nc bnc" id="L712" title="All 2 branches missed.">			if (!policyTypeList.isEmpty()) {</span>
<span class="nc" id="L713">                reqPolicyDAO = new RequestPolicyTextDAO();</span>
<span class="nc" id="L714">                reqPolicyDAO.deleteRequestPolicy(lChildOrgIDList, policyTypeList);</span>
            }
        } finally {
<span class="nc bnc" id="L717" title="All 4 branches missed.">            if (reqPolicyDAO != null) {</span>
<span class="nc" id="L718">            	reqPolicyDAO.cleanUp();</span>
            }
        }
<span class="nc" id="L721">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>