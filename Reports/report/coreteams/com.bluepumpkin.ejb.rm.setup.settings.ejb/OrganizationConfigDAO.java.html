<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>OrganizationConfigDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.setup.settings.ejb</a> &gt; <span class="el_source">OrganizationConfigDAO.java</span></div><h1>OrganizationConfigDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.setup.settings.ejb;
/**
 * Title:        OrganizationConfigDAO
 * Description:  DAO class for OrganizationConfig
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, Inc.
 * @author       Shailendra Sharma
 * @version      1.0
 */

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoParam;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.cache.CacheUtilBBM;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.l10n.RmSettingKey;
import com.bluepumpkin.ejb.rm.requests.common.model.Request;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationConfig;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationConfigFieldInfo;
import com.bluepumpkin.ejb.rm.util.RmUtil;

public class OrganizationConfigDAO extends DAOBase {

<span class="fc" id="L44">    private static FieldInfo m_fieldInfo = new OrganizationConfigFieldInfo();</span>

<span class="fc" id="L46">    protected FieldInfo getFieldInfo() { return m_fieldInfo; }</span>

<span class="fc" id="L48">    private static Category m_cat = Log.initCategory(OrganizationConfigDAO.class.getName());</span>

    private static final String TABLE_NAME = &quot;ORGANIZATIONCONFIG&quot;;

<span class="fc" id="L52">    private static final HashMap PROP_NAME_TO_POLICY_TYPE = new HashMap(7);</span>
    {
<span class="pc" id="L54">        PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_TO_POLICY,</span>
                                     Request.REQUESTTYPE_TIMEOFF);
<span class="pc" id="L56">        PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_SS_POLICY,</span>
                                     Request.REQUESTTYPE_SHIFTSWAP);
<span class="pc" id="L58">        PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_SB_POLICY,</span>
                                     Request.REQUESTTYPE_SHIFTBID);
<span class="pc" id="L60">        PROP_NAME_TO_POLICY_TYPE.put(RmSettingKey.ORG_RM_SETTINGS_FT_POLICY,</span>
                Request.REQUESTTYPE_FLEXTIME);
    }

    /**
     * Returns the Category for the class
     * @return Category - Category object for the class
     */
    protected Category getCategory() {
<span class="nc" id="L69">        return m_cat;</span>
    }

    /**
     * Default constructor for the creating object instance of the class.
    */
    public OrganizationConfigDAO() {
<span class="fc" id="L76">        super();</span>
<span class="fc" id="L77">    }</span>

    /**
     * Constructor for the creating object instance of the class.
     * @param Jdmo  - Jdmo instance used for executing sql statements.
    */
    public OrganizationConfigDAO(Jdmo dmo) {
<span class="nc" id="L84">        super(dmo);</span>
<span class="nc" id="L85">    }</span>

    /**
     * Creates OrganizationConfig object and return as value object.
     * @return ValueObjectBase - OrganizationConfig object instance
     * as value object.
    */
    protected ValueObjectBase createValueObject() {
<span class="nc" id="L93">        return (new OrganizationConfig());</span>
    }


    /**
     * Get PROPERTY-KEY and PROPERTY-VALUE pairs as HashMap for the the PROPERTY-KEY
     * specified in the pPropertyMap for the OrganizationId
     * passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - if true then only the properties defined at the org
     *                  is returned. If false then properties that are not defined
     *                  at the org but defined at parent orgs are added in.
     *                  The inherited values used based on the closeness to
     *                  given org. If A is parent of B is parent of C then
     *                  C will return properties defined a B if they are not
     *                  defined as C and will ignore those same properties
     *                  if they are also defined at A.
     *
     * @throws BbmFinderException if there is an error while executing database
     *                            query
     */
    public Map getPropertyList(ID orgId,
                               Map pPropertyMap,
                               boolean shallow)
        throws Exception {
<span class="fc" id="L121">        return getPropertyList(orgId, pPropertyMap, new HashMap(), new HashMap&lt;String, ID&gt;(), shallow);</span>
    }

    public Map getPropertyList(ID orgId, Map pPropertyMap, Map pAncestorMap, boolean shallow)	throws Exception {
<span class="nc" id="L125">    	return getPropertyList(orgId, pPropertyMap, pAncestorMap, new HashMap&lt;String, ID&gt;(), shallow);</span>
	}

    /**
     * Get PROPERTY-KEY and PROPERTY-VALUE pairs as HashMap for the the PROPERTY-KEY
     * specified in the pPropertyMap for the OrganizationId
     * passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEYs mapped to PROPERTY-VALUEs
     * @param pAncestorIDsMap - A Map that contains PROPERTY-KEYs mapped to ancestor org names
     * @param pAncestorMap - A Map that contains PROPERTY-KEYs mapped to ancestor org IDs
     * @param shallow - if true then only the properties defined at the org
     *                  is returned. If false then properties that are not defined
     *                  at the org but defined at parent orgs are added in.
     *                  The inherited values used based on the closeness to
     *                  given org. If A is parent of B is parent of C then
     *                  C will return properties defined a B if they are not
     *                  defined as C and will ignore those same properties
     *                  if they are also defined at A.
     *
     * @return We return the pPropertyMap with the mapped values. We also modify pPropertyMap
     *         and pAncestorMap, so you can get the return values from there.
     * @throws BbmFinderException if there is an error while executing database
     *                            query
     */
    public Map getPropertyList(ID orgId,
                               Map pPropertyMap,
                               Map pAncestorMap,
                               Map&lt;String, ID&gt; pAncestorIDsMap,
                               boolean shallow)
        throws Exception {
<span class="fc" id="L157">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>

        try {
<span class="fc" id="L160">            HashSet wantedPropList = new HashSet(pPropertyMap.keySet());</span>
<span class="fc" id="L161">            HashSet wantedPolicyList = new HashSet();</span>

            // We store the policies in another table because they are large
            // but we use keys as if these values are stored in the organization
            // config table. Now, we have to treat those keys specially to
            // get the data from the correct location.
            String key;
<span class="fc bfc" id="L168" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_TO_POLICY))</span>
<span class="fc" id="L169">                wantedPolicyList.add(key);</span>

<span class="fc bfc" id="L171" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_SS_POLICY))</span>
<span class="fc" id="L172">                wantedPolicyList.add(key);</span>

<span class="fc bfc" id="L174" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_SB_POLICY))</span>
<span class="fc" id="L175">                wantedPolicyList.add(key);</span>
                
<span class="fc bfc" id="L177" title="All 2 branches covered.">            if (wantedPropList.remove(key=RmSettingKey.ORG_RM_SETTINGS_FT_POLICY)) {</span>
<span class="fc" id="L178">                wantedPolicyList.add(key);</span>
            }

<span class="fc" id="L181">            StringBuffer strQuery = new StringBuffer(512);</span>
<span class="fc" id="L182">            strQuery.append(&quot; SELECT PROPERTYNAME, PROPERTYVALUE &quot;);</span>
<span class="fc" id="L183">            strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="fc" id="L184">            strQuery.append(&quot; WHERE ORGANIZATIONID = ?&quot;);</span>
<span class="fc" id="L185">            strQuery.append(&quot; AND PROPERTYNAME IN &quot;);</span>
<span class="fc" id="L186">            int resetLength = strQuery.length();</span>

            Collection lParentOrgIDList;

            // if we only want the settings that are defined at the given
            // organization.
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (shallow) {</span>
<span class="fc" id="L193">                ArrayList al = new ArrayList(1);</span>
<span class="fc" id="L194">                al.add(orgId);</span>
<span class="fc" id="L195">                lParentOrgIDList = al;</span>
<span class="fc" id="L196">            }</span>
            // we want settings that are inherited from parent organization
            // if they are missing from the ones defined at the organization
            else {
                //lParentOrgIDList = orderOrgs(CacheUtilBBM.getParentOrgIDs(orgId, getDMO())); //not ordered!
<span class="fc" id="L201">                lParentOrgIDList = getParentOrganizationsCollection(orgId, m_dmo);</span>
<span class="fc" id="L202">                ArrayList al = new ArrayList(lParentOrgIDList.size()+1);</span>
<span class="fc" id="L203">                al.add(orgId); //add our org to the front of the list</span>
<span class="fc" id="L204">                al.addAll(lParentOrgIDList);</span>
            }
<span class="fc" id="L206">            Iterator lParentOrgIdIterator = lParentOrgIDList.iterator();</span>

<span class="fc" id="L208">            for (int i = 0;</span>
<span class="pc bpc" id="L209" title="3 of 4 branches missed.">                 (wantedPropList.size() != 0 || wantedPolicyList.size() != 0) &amp;&amp;</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">                 lParentOrgIdIterator.hasNext();</span>
<span class="fc" id="L211">                 i++) {</span>

<span class="fc" id="L213">                ID tmpId = (ID)lParentOrgIdIterator.next();</span>

                // make sure the orgId is the first one we process
<span class="fc bfc" id="L216" title="All 4 branches covered.">                if (i == 0 &amp;&amp; !tmpId.equals(orgId)) {</span>
                    // if it isn't then pretend ...
<span class="fc" id="L218">                    lParentOrgIdIterator = lParentOrgIDList.iterator();</span>
<span class="fc" id="L219">                    tmpId = orgId;</span>
                }

                // we get the properties we want from the current org in the
                // hierarchy. If we can't find all we need then we go to the
                // parent org until we've gotten everything.
<span class="pc bpc" id="L225" title="1 of 2 branches missed.">                if (wantedPropList.size() &gt; 0) {</span>
<span class="fc" id="L226">                    strQuery.setLength(resetLength);</span>
<span class="fc" id="L227">                    strQuery.append(RmUtil.createInClause(wantedPropList));</span>

<span class="fc" id="L229">                    JdmoQuery jQuery1 = m_dmo.createQuery(strQuery.toString(),</span>
                                                          Jdmo.PARAM_QUERY);

<span class="fc" id="L232">                    jQuery1.setParID(1, tmpId);</span>
<span class="fc" id="L233">                    JdmoRowset rs = m_dmo.createRowset(jQuery1,</span>
                                                       Jdmo.FORWARD_ONLY,
                                                       Jdmo.READ_ONLY);

<span class="fc bfc" id="L237" title="All 2 branches covered.">                    while(rs.next()) {</span>
<span class="fc" id="L238">                        String prop = rs.getString(&quot;PROPERTYNAME&quot;);</span>
<span class="fc" id="L239">                        String valu = rs.getString(&quot;PROPERTYVALUE&quot;);</span>

<span class="fc" id="L241">                        pPropertyMap.put(prop, valu);</span>

<span class="fc bfc" id="L243" title="All 2 branches covered.">                        if (!tmpId.equals(orgId)) {</span>
<span class="fc" id="L244">                            pAncestorMap.put(prop, getOrgName(tmpId));</span>
<span class="fc" id="L245">                            pAncestorIDsMap.put(prop, tmpId);</span>
                        }

                        // now that we have what we want, we can remove
                        // this property from the list.
<span class="fc" id="L250">                        wantedPropList.remove(prop);</span>
<span class="fc" id="L251">                    }</span>
                }

                // we do the same thing for policy text
<span class="fc bfc" id="L255" title="All 2 branches covered.">                if (wantedPolicyList.size() &gt; 0) {</span>
<span class="fc" id="L256">                    Iterator policyKeys = wantedPolicyList.iterator();</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">                    if (lRequestPolicyTextDAO == null)</span>
<span class="fc" id="L259">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>

<span class="fc bfc" id="L261" title="All 2 branches covered.">                    while (policyKeys.hasNext()) {</span>
<span class="fc" id="L262">                        String propName = (String)policyKeys.next();</span>

<span class="fc" id="L264">                        String policyType = getPolicyType(propName);</span>

<span class="fc" id="L266">                        String policy =</span>
<span class="fc" id="L267">                            lRequestPolicyTextDAO.getRequestPolicy(tmpId,</span>
                                                                   policyType);

<span class="fc bfc" id="L270" title="All 2 branches covered.">                        if (policy != null) {</span>
<span class="fc" id="L271">                            pPropertyMap.put(propName, policy);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">                            if (!tmpId.equals(orgId)) {</span>
<span class="fc" id="L273">                                pAncestorMap.put(propName, getOrgName(tmpId));</span>
<span class="fc" id="L274">                                pAncestorIDsMap.put(propName, tmpId);</span>
                            }
<span class="fc" id="L276">                            wantedPolicyList.remove(propName);</span>
<span class="fc" id="L277">                            policyKeys = wantedPolicyList.iterator();</span>
                        }
<span class="fc" id="L279">                    }</span>
                }

                // if we're shallow then we won't check the ancestors for
                // their properties.
<span class="fc bfc" id="L284" title="All 2 branches covered.">                if (shallow) {</span>
<span class="fc" id="L285">                    break;</span>
                }
            }

            //If there are any properties or policies left in the lists, that means that we never found them.
            //We cannot leave the ancestors empty for them however, because that would imply that the values were overridden
            //rather than &quot;inherited&quot;. In this case, no org had a value for them, so technically, they are the default values,
            //but for the sake of the user, we'll say that these values are inheritted from the top level organization.
<span class="fc bfc" id="L293" title="All 4 branches covered.">            if (!shallow &amp;&amp; !orgId.equals(Organization.YOUR_COMPANY_ID_OBJ))</span>
            {
<span class="fc" id="L295">            	String yourCompanyName = getOrgName(Organization.YOUR_COMPANY_ID_OBJ);</span>

<span class="pc bpc" id="L297" title="1 of 2 branches missed.">            	if (wantedPropList.size() &gt; 0)</span>
            	{
<span class="fc bfc" id="L299" title="All 2 branches covered.">            		for (Iterator it=wantedPropList.iterator(); it.hasNext();)</span>
            		{
<span class="fc" id="L301">            			String propName = (String)it.next();</span>
<span class="fc" id="L302">            			pAncestorMap.put(propName, yourCompanyName);</span>
<span class="fc" id="L303">            			pAncestorIDsMap.put(propName, Organization.YOUR_COMPANY_ID_OBJ);</span>
<span class="fc" id="L304">            		}</span>
            	}

<span class="pc bpc" id="L307" title="1 of 2 branches missed.">            	if (wantedPolicyList.size() &gt; 0)</span>
            	{
<span class="fc bfc" id="L309" title="All 2 branches covered.">            		for (Iterator it=wantedPolicyList.iterator(); it.hasNext();)</span>
            		{
<span class="fc" id="L311">            			String propName = (String)it.next();</span>
<span class="fc" id="L312">            			pAncestorMap.put(propName, yourCompanyName);</span>
<span class="fc" id="L313">            			pAncestorIDsMap.put(propName, Organization.YOUR_COMPANY_ID_OBJ);</span>
<span class="fc" id="L314">            		}</span>
            	}
            }

        }  finally {
<span class="pc bpc" id="L319" title="2 of 4 branches missed.">            if (lRequestPolicyTextDAO != null) lRequestPolicyTextDAO.cleanUp();</span>
        }

<span class="fc" id="L322">        return pPropertyMap;</span>
    }

    /**
     * Set PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as arguments. The methods will split
     * the propertyMap into a set of properties to update and a set to
     * insert. If shallow is false, then the value of the properties are
     * copied to all children (this will overwrite the values of the children).
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - true if you want to update only this org, false to update children too.
     *
     * @throws BbmCreateException if there is an error while executing database
     *                            query
     * @throws BbmUpdateException if there is an error while executing database
     *                            query
     */
    public void setPropertyList(ID orgId, Map pPropertyMap, boolean shallow)
        throws Exception {

<span class="pc bpc" id="L345" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L346">            m_cat.debug(&quot;setPropertyList: &quot;+pPropertyMap);</span>
        }

<span class="fc" id="L349">        Iterator propItr = pPropertyMap.keySet().iterator();</span>

        // get the current settings to compare against the new
<span class="fc" id="L352">        Map pPropertyMapCopy = new HashMap(pPropertyMap);</span>

        // We use a test value to determine which properties
        // are not defined at the given organization. Since
        // we are using a shallow query of the properties of
        // an organization it is possible that there will be
        // properties that are not defined at the level yet.
        //FIXME: why are we using an empty byte array as a test value?
<span class="fc" id="L360">        Object test= new byte[0];</span>
<span class="fc bfc" id="L361" title="All 2 branches covered.">        while ( propItr.hasNext() ) {</span>
<span class="fc" id="L362">            String propName = (String) propItr.next();</span>
<span class="fc" id="L363">            pPropertyMapCopy.put(propName, test);</span>
<span class="fc" id="L364">        }</span>
<span class="fc" id="L365">        getPropertyList(orgId, pPropertyMapCopy, true);</span>

        // figure out which settings to update and which to create
        // If shallow is true, and there is no change in the value then we skip it.
<span class="fc" id="L369">        HashMap pPropertyMapCreate = new HashMap(31);</span>
<span class="fc" id="L370">        HashMap pPropertyMapUpdate = new HashMap(31);</span>
<span class="fc" id="L371">        propItr = pPropertyMap.keySet().iterator();</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">        while (propItr.hasNext()) {</span>
<span class="fc" id="L373">            String propName = (String) propItr.next();</span>
<span class="fc" id="L374">            Object oldValue = pPropertyMapCopy.get(propName);</span>
<span class="fc" id="L375">            Object newValue = pPropertyMap.get(propName);</span>
            /*
            if ((shallow==true) &amp;&amp; ((oldValue == newValue) || (oldValue.equals(newValue)))) {
                // for shallow save, ignore properties which have not changed
                continue;
            }
            */
<span class="pc bpc" id="L382" title="1 of 4 branches missed.">            if (oldValue == null || newValue == null) {</span>
<span class="fc" id="L383">                pPropertyMapUpdate.put(propName, newValue);</span>
<span class="fc" id="L384">                continue;</span>
            }
            //Only create a new record if the old record had no value and the new record does have a value.
            //New values can sometimes be an empty string (&quot;&quot;) and not an empty byte array.  It is not clear
            //why the empty byte array is used as a test value.
<span class="pc bpc" id="L389" title="2 of 6 branches missed.">            if (oldValue == test &amp;&amp; !newValue.equals(oldValue) &amp;&amp; !newValue.equals(&quot;&quot;)) {</span>
<span class="fc" id="L390">                pPropertyMapCreate.put(propName, newValue);</span>
            }
            else {
<span class="fc" id="L393">                pPropertyMapUpdate.put(propName, newValue);</span>
            }
<span class="fc" id="L395">        }</span>
<span class="pc bpc" id="L396" title="1 of 2 branches missed.">        if (pPropertyMapCreate.size() &gt; 0) {</span>
<span class="fc" id="L397">            createPropertyList(orgId, pPropertyMapCreate);</span>
        }
<span class="fc bfc" id="L399" title="All 2 branches covered.">        if (pPropertyMapUpdate.size() &gt; 0) {</span>
<span class="fc" id="L400">            updatePropertyList(orgId, pPropertyMapUpdate, shallow);</span>
        }
<span class="fc" id="L402">    }</span>

    /**
     * Create PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as argument.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     */
    private void createPropertyList(ID orgId, Map pPropertyMap)
        throws Exception
    {
<span class="pc bpc" id="L415" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L416">            m_cat.debug(&quot;createPropertyList: &quot;+pPropertyMap);</span>
        }
<span class="fc" id="L418">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>
<span class="fc" id="L419">        HashMap lColumnValHashMap = null;</span>
<span class="fc" id="L420">        boolean executeBatch = false;</span>

        try {
<span class="fc" id="L423">            Iterator propItr = pPropertyMap.keySet().iterator();</span>

<span class="fc bfc" id="L425" title="All 2 branches covered.">            while (propItr.hasNext()) {</span>
<span class="fc" id="L426">                String propName = (String) propItr.next();</span>
<span class="fc" id="L427">                String propValue = (String) pPropertyMap.get(propName);</span>

<span class="fc" id="L429">                String policyType = getPolicyType(propName);</span>

<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                if (policyType != null ) {</span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                    if (lRequestPolicyTextDAO == null)</span>
<span class="nc" id="L433">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>

<span class="nc" id="L435">                    lRequestPolicyTextDAO.createRequestPolicy(orgId,</span>
                                                              policyType,
                                                              propValue);
<span class="nc" id="L438">                    continue;</span>
                }

<span class="fc bfc" id="L441" title="All 2 branches covered.">                if (lColumnValHashMap == null) {</span>
<span class="fc" id="L442">                    lColumnValHashMap = new HashMap(7);</span>
                }
<span class="fc" id="L444">                lColumnValHashMap.put(&quot;ORGANIZATIONID&quot;,orgId);</span>
<span class="fc" id="L445">                lColumnValHashMap.put(&quot;PROPERTYNAME&quot;,propName);</span>
<span class="fc" id="L446">                lColumnValHashMap.put(&quot;PROPERTYVALUE&quot;,propValue);</span>

<span class="fc" id="L448">                m_dmo.addBatchInsert(TABLE_NAME, lColumnValHashMap);</span>
<span class="fc" id="L449">                executeBatch = true;</span>
<span class="fc" id="L450">            }</span>

<span class="pc bpc" id="L452" title="1 of 2 branches missed.">            if (executeBatch)</span>
<span class="fc" id="L453">                m_dmo.executeBatch();</span>
        }
        finally {
<span class="pc bpc" id="L456" title="3 of 4 branches missed.">            if (lRequestPolicyTextDAO != null) lRequestPolicyTextDAO.cleanUp();</span>
        }
<span class="fc" id="L458">    }</span>

    /**
     * Update PROPERTY-KEY and PROPERTY-VALUE specified in the pPropertyMap
     * for the OrganizationId passed as arguments.
     *
     * @param orgId - Organisation ID object.
     * @param pPropertyMap - A Map that contains PROPERTY-KEY
     *                       and PROPERTY-VALUE
     * @param shallow - true if you want to update only this org, false to update children too.
     */
    private void updatePropertyList(ID orgId, Map pPropertyMap, boolean shallow)
        throws Exception
    {
<span class="fc" id="L472">        RequestPolicyTextDAO lRequestPolicyTextDAO = null;</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">        if (m_cat.isDebugEnabled()) {</span>
<span class="fc" id="L474">            m_cat.debug(&quot;updatePropertyList: &quot;+pPropertyMap);</span>
        }

        try {
            Collection lChildOrgIDList;
<span class="pc bpc" id="L479" title="1 of 2 branches missed.">            if (shallow)</span>
<span class="fc" id="L480">                lChildOrgIDList = new ArrayList(1);</span>
            else
<span class="nc" id="L482">                lChildOrgIDList = DAOUtil.getChildOrganizations(orgId, m_dmo); //uses proc BP_GETCHILDORG.</span>
<span class="fc" id="L483">            lChildOrgIDList.add(orgId);</span>

<span class="fc" id="L485">            StringBuffer strQuery = new StringBuffer(512);</span>
<span class="fc" id="L486">            strQuery.append(&quot; UPDATE &quot;);</span>
<span class="fc" id="L487">            strQuery.append(&quot; ORGANIZATIONCONFIG SET PROPERTYVALUE = ? &quot;);</span>
<span class="fc" id="L488">            strQuery.append(&quot; WHERE PROPERTYNAME = ? &quot;);</span>
<span class="fc" id="L489">            strQuery.append(&quot; AND ORGANIZATIONID IN &quot;);</span>
<span class="fc" id="L490">            strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>

<span class="fc" id="L492">            String query = strQuery.toString();</span>
<span class="fc" id="L493">            Object params[] = new Object[2];</span>

<span class="fc" id="L495">            Iterator propItr = pPropertyMap.keySet().iterator();</span>
<span class="fc bfc" id="L496" title="All 2 branches covered.">            while (propItr.hasNext()) {</span>
<span class="fc" id="L497">                String propName = (String) propItr.next();</span>
<span class="fc" id="L498">                String propValue = (String) pPropertyMap.get(propName);</span>

<span class="fc" id="L500">                String policyType = getPolicyType(propName);</span>

<span class="fc bfc" id="L502" title="All 2 branches covered.">                if (policyType != null) {</span>
<span class="fc bfc" id="L503" title="All 2 branches covered.">                    if (lRequestPolicyTextDAO == null)</span>
<span class="fc" id="L504">                        lRequestPolicyTextDAO = new RequestPolicyTextDAO();</span>
<span class="fc" id="L505">                    lRequestPolicyTextDAO.updateRequestPolicy(lChildOrgIDList,</span>
                                                              policyType,
                                                              propValue);
<span class="fc" id="L508">                    continue;</span>
                }

<span class="fc" id="L511">                params[1] = propName;</span>
<span class="fc bfc" id="L512" title="All 2 branches covered.">                if (propValue == null) {</span>
                    // jdmo requires that null parameters are passed
                    // this way.
<span class="fc" id="L515">                    params[0] = new JdmoParam(null,</span>
                                              java.sql.Types.VARCHAR);
                }
                else {
<span class="fc" id="L519">                    params[0] = propValue;</span>
                }

<span class="fc" id="L522">                int results = m_dmo.executePCommand(query, params);</span>
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">                if (results == 0) {</span>
<span class="fc" id="L524">                    m_cat.error(&quot;SQL Execute returned &quot;+results+</span>
                                &quot;: property=&quot;+propName+
                                &quot;: value=&quot;+propValue);
                }
<span class="nc bnc" id="L528" title="All 2 branches missed.">                else if (results &lt; 0) {</span>
                    // wasn't expecting this
<span class="nc" id="L530">                    throw new BbmUpdateException(&quot;SQL Execute returned &quot;+results+</span>
                                                 &quot;: property=&quot;+propName+
                                                 &quot;: value=&quot;+propValue);
                }
<span class="fc" id="L534">            }</span>
        }
        finally {
<span class="pc bpc" id="L537" title="3 of 4 branches missed.">            if (lRequestPolicyTextDAO != null) lRequestPolicyTextDAO.cleanUp();</span>
        }
<span class="fc" id="L539">    }</span>

    /**
     * Delete all properties for all the child orgs of orgID. Does not affect orgID itself.
     *
     * @param orgId - The Organisation ID whose children's properties you want to delete.
     * @throws BbmRemoveException if there is an error while executing database query
     */
    public void deleteAllPropertiesFromChildren(ID orgId)
        throws Exception {

<span class="pc bpc" id="L550" title="1 of 2 branches missed.">        if (orgId == null)</span>
<span class="nc" id="L551">            return;</span>

<span class="fc" id="L553">        RequestPolicyTextDAO reqPolicyDAO = null;</span>
        try {
            Collection lChildOrgIDList;
<span class="fc" id="L556">            lChildOrgIDList = DAOUtil.getChildOrganizations(orgId, m_dmo);</span>

            // delete the properties
<span class="fc" id="L559">            StringBuffer strQuery = new StringBuffer(512);</span>
<span class="fc" id="L560">            strQuery.append(&quot; DELETE &quot;);</span>
<span class="fc" id="L561">            strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="fc" id="L562">            strQuery.append(&quot; WHERE ORGANIZATIONID IN &quot;);</span>
<span class="fc" id="L563">            strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>
<span class="fc" id="L564">            m_dmo.executeCommand(strQuery.toString());</span>

            // delete the policies
<span class="fc" id="L567">            reqPolicyDAO = new RequestPolicyTextDAO();</span>
<span class="fc" id="L568">            reqPolicyDAO.deleteRequestPolicy(lChildOrgIDList, null);</span>
        }
        finally {
<span class="pc bpc" id="L571" title="3 of 4 branches missed.">            if (reqPolicyDAO != null) reqPolicyDAO.cleanUp();</span>
        }
<span class="fc" id="L573">    }</span>

    /**
     * Convert property name to policy type.
     *
     * @param  propName - name of organization property
     * @return String null if propName is not a policy property, otherwise
     *         returns REQUESTTYPE_TIMEOFF or REQUESTTYPE_SHIFTSWAP or REQUESTTYPE_SHIFTBID.
     */
    private static String getPolicyType(String propName) {
<span class="fc" id="L583">        return (String)PROP_NAME_TO_POLICY_TYPE.get(propName);</span>
    }

    /**
     * Given an orgID, return its parent org ID. If it has no parent, returns null.
     * @param orgID The ID of the organization whose parent ID we want to get.
     * @return its parent org ID. If it has no parent, returns null.
     *
    public ID getParentOrgID(ID orgID) throws Exception
    {
        ID parentID = null;
        //List lParentOrgIDList = orderOrgs(CacheUtilBBM.getParentOrgIDs(orgID, getDMO())); //not ordered!
        Collection lParentOrgIDList = getParentOrganizationsCollection(orgID, m_dmo);

        Iterator lParentOrgIdIterator = lParentOrgIDList.iterator();
        while (lParentOrgIdIterator.hasNext())
        {
            parentID = (ID)lParentOrgIdIterator.next();
            break;
        }
        return parentID;
    }
    */

    /**
     * Get the name of an organization.
     * @param orgID The organization ID.
     * @return the name of an organization.
     * @throws Exception
     */
    private String getOrgName(ID orgID) throws Exception
    {
<span class="fc" id="L615">	    return CacheUtilBBM.getOrganizationByID(orgID).getName();</span>
	    /*
        if (orgID == null)
            return null;

        String name = null;
        StringBuffer strQuery = new StringBuffer(512);
        strQuery.append(&quot; SELECT NAME &quot;);
        strQuery.append(&quot; FROM ORGANIZATION &quot;);
        strQuery.append(&quot; WHERE ID = ?&quot;);

        JdmoQuery jQuery1 = m_dmo.createQuery(strQuery.toString(),
                                              Jdmo.PARAM_QUERY);

        jQuery1.setParID(1, orgID);
        JdmoRowset rs = m_dmo.createRowset(jQuery1,
                                           Jdmo.FORWARD_ONLY,
                                           Jdmo.READ_ONLY);

        while(rs.next())
            name = rs.getString(&quot;NAME&quot;);

        return name;*/
    }


    /**
     *  get all parent orgs of a given org, returned as a list with child organizations first.
     *  @return a list of parent organization ids.  The first id in the list is the
     *  immediate parent of idOrg, followed by that organization's parent up to
     *  the company root, which is the last id in the list.  If the company root is
     *  passed as input, then an empty List is returned.
     */
    private Collection getParentOrganizationsCollection(ID idOrg, Jdmo dmo) throws BbmFinderException
    {
        // call stored procedure to get parent orgs
        try
        {
<span class="fc" id="L653">            JdmoQuery  query = dmo.createQuery(&quot;BP_GETPARENTORG&quot;, Jdmo.STORPROC_QUERY);</span>
<span class="fc" id="L654">            query.setParID(1, idOrg);</span>
<span class="fc" id="L655">            JdmoRowset rs = dmo.createRowset(query, Jdmo.FORWARD_ONLY, Jdmo.READ_ONLY);</span>

            // fetch parent orgs to format the query
<span class="fc" id="L658">            ArrayList arList = new ArrayList();</span>
<span class="fc bfc" id="L659" title="All 2 branches covered.">            while(rs.next())</span>
<span class="fc" id="L660">                arList.add(rs.getID(&quot;ID&quot;));</span>
<span class="fc" id="L661">            rs.close();</span>
<span class="fc" id="L662">            return arList;</span>
        }
<span class="nc" id="L664">        catch(Exception e)</span>
        {
<span class="nc" id="L666">            throw new BbmFinderException(e);</span>
        }
    }

    /**
     * Delete all PROPERTY-KEYs specified in the pPropertySet for the organization IDs
     * and all the child organizations.
     *
     * @param orgIds - organization IDs
     * @param pPropertySet - A Set that contains PROPERTY-KEY
     * @throws BbmRemoveException if there is an error while executing database query
     */
    public void deletePropertyList(Collection&lt;ID&gt; orgIds, Set&lt;String&gt; pPropertySet)
        throws Exception {

<span class="nc bnc" id="L681" title="All 4 branches missed.">        if ((pPropertySet == null) || (pPropertySet.size() == 0 ) ) {</span>
<span class="nc" id="L682">            return;</span>
        }

<span class="nc" id="L685">        RequestPolicyTextDAO reqPolicyDAO = null;</span>
        try {
            @SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L688">            Collection&lt;ID&gt; lChildOrgIDList = DAOUtil.getChildOrganizationsCollection(orgIds, m_dmo);</span>
<span class="nc" id="L689">            lChildOrgIDList.addAll(orgIds);</span>


<span class="nc" id="L692">            ArrayList&lt;String&gt; policyTypeList = new ArrayList&lt;String&gt;();</span>
<span class="nc" id="L693">            ArrayList&lt;String&gt; propNameList = new ArrayList&lt;String&gt;();</span>

            // split the property list into the normal properties that
            // are defined in the organization config table and those
            // special ones that are for organization policy.
<span class="nc" id="L698">            Iterator&lt;String&gt; propItr = pPropertySet.iterator();</span>
<span class="nc bnc" id="L699" title="All 2 branches missed.">            while (propItr.hasNext()) {</span>
<span class="nc" id="L700">                String  propName = (String) propItr.next();</span>
<span class="nc" id="L701">                String policyType = getPolicyType(propName);</span>

<span class="nc bnc" id="L703" title="All 2 branches missed.">                if (policyType != null ) {</span>
<span class="nc" id="L704">                    policyTypeList.add(policyType);</span>
                } else {
<span class="nc" id="L706">                    propNameList.add(propName);</span>
                }
<span class="nc" id="L708">            }</span>

            // delete the properties
<span class="nc bnc" id="L711" title="All 2 branches missed.">            if (propNameList.size() &gt; 0) {</span>
<span class="nc" id="L712">                StringBuffer strQuery = new StringBuffer(512);</span>
<span class="nc" id="L713">                strQuery.append(&quot; DELETE &quot;);</span>
<span class="nc" id="L714">                strQuery.append(&quot; FROM ORGANIZATIONCONFIG &quot;);</span>
<span class="nc" id="L715">                strQuery.append(&quot; WHERE ORGANIZATIONID IN &quot;);</span>
<span class="nc" id="L716">                strQuery.append(m_dmo.createInClause(lChildOrgIDList));</span>

<span class="nc" id="L718">                strQuery.append(&quot; AND PROPERTYNAME IN &quot;);</span>
<span class="nc" id="L719">                strQuery.append( RmUtil.createInClause(propNameList) );</span>

<span class="nc" id="L721">                m_dmo.executeCommand(strQuery.toString());</span>
            }

            // delete the policies
<span class="nc bnc" id="L725" title="All 2 branches missed.">            if (policyTypeList.size() &gt; 0) {</span>
<span class="nc" id="L726">                reqPolicyDAO = new RequestPolicyTextDAO();</span>
<span class="nc" id="L727">                reqPolicyDAO.deleteRequestPolicy(lChildOrgIDList,</span>
                                        policyTypeList);
            }
        }
        finally {
<span class="nc bnc" id="L732" title="All 4 branches missed.">            if (reqPolicyDAO != null) reqPolicyDAO.cleanUp();</span>
        }
<span class="nc" id="L734">    }</span>


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>