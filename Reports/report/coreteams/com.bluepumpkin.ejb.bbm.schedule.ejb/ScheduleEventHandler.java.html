<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleEventHandler.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">ScheduleEventHandler.java</span></div><h1>ScheduleEventHandler.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.MissingResourceException;
import java.util.ResourceBundle;
import java.util.Set;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  This class reacts to various events happening the schedule
 * access manager EJB, such creation of an event, publishing of
 * the schedule, etc.
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 *
 * @author Greg Fichtenholtz
 * @version 1.0
 */

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.PatternLayout;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailPropertyConstant;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringFloatingEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ValueObjectAggEventTemplate;
import com.bluepumpkin.ejb.bbm.schedulelock.ejb.ScheduleLockManager;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TONotifyMessage;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TimeOffHoursManagerBridge;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;
import com.bluepumpkin.ejb.core.CoreEJBCreateException;
import com.bluepumpkin.ejb.core.CoreManagerFactory;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.witness.ejb.core.base.CoreFinderException;
import com.witness.ejb.core.gcr.ejb.GCRManager;
import com.witness.ejb.core.gcr.model.GCREntry;

/**
 * Note that all of the methods have package scope because they are only meant
 * to be called by Schedule Access Manager EJB implementation class
 */
class ScheduleEventHandler {
	private final Category m_cat;
	// for logging only, so we use default
	private final ResourceBundle m_bundle;
	// locale
	private final Localizer m_defLocalizer;
	private final ScheduleLockManager m_lockManager;
	private final EventAuditTrailManager m_auditManager;
	private final ScheduleAccessManager m_scheduleAccessManager;

	/**
	 * ctor
	 */
	ScheduleEventHandler(Category cat, ScheduleLockManager lockManager, EventAuditTrailManager auditManager,
			ScheduleAccessManager scheduleAccessManager) {
<span class="fc" id="L86">		this(cat, lockManager, auditManager, scheduleAccessManager, DefaultLocalizationManager</span>
<span class="fc" id="L87">			.getDefaultInstance().getLocalizer(), DefaultLocalizationManager.getDefaultInstance().getLocalizer()</span>
<span class="fc" id="L88">			.getBundle(BbmEjbLogBundleKey.BUNDLE_NAME));</span>
<span class="fc" id="L89">	}</span>

	ScheduleEventHandler(Category cat, ScheduleLockManager lockManager, EventAuditTrailManager auditManager,
<span class="fc" id="L92">			ScheduleAccessManager scheduleAccessManager, Localizer localizer, ResourceBundle bundle) {</span>
<span class="fc" id="L93">		m_cat = cat;</span>
<span class="fc" id="L94">		m_defLocalizer = localizer;</span>
<span class="fc" id="L95">		m_bundle = bundle;</span>
<span class="fc" id="L96">		m_lockManager = lockManager;</span>
<span class="fc" id="L97">		m_auditManager = auditManager;</span>
<span class="fc" id="L98">		m_scheduleAccessManager = scheduleAccessManager;</span>
<span class="fc" id="L99">	}</span>

	Map&lt;ID, EmployeeName&gt; getEmployeeNamesMap(Collection&lt;ID&gt; workResourceIDs) {
<span class="fc" id="L102">		CachePerEJBMethod cache = CachePerEJBMethod.getCache();</span>
<span class="fc" id="L103">		return cache.getEmployeeNames(workResourceIDs);</span>
	}

	private void createAuditTrailForUnpublishedEvent(Event event, short action) throws BbmFinderException,
		BbmCreateException, RemoteException {
<span class="nc" id="L108">		createAuditTrailForUnpublishedEvent(event.getWorkResourceIDs(), event, action);</span>
<span class="nc" id="L109">	}</span>

	private void createAuditTrailForUnpublishedEvent(Collection c, Event event, short action)
		throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L113">		ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L114">		list.add(event);</span>
<span class="nc" id="L115">		createAuditTrailEntry(c, list, action, AuditTrailEntry.MODULE_SCHEDULING, false);</span>
<span class="nc" id="L116">	}</span>

	private void createAuditTrailForUnpublishedEventTemplate(CalendarEventTemplate cet, short action) throws
		BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L120">		createAuditTrailForUnpublishedEventTemplate(cet.getWorkResourceIDs(), cet, action);</span>
<span class="nc" id="L121">	}</span>

	private void createAuditTrailForUnpublishedEventTemplate(Collection col, CalendarEventTemplate cet, short action)
		throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L125">		ArrayList list = new ArrayList(1);</span>
<span class="nc" id="L126">		list.add(cet);</span>
<span class="nc" id="L127">		createAuditTrailEntry(col, list, action, AuditTrailEntry.MODULE_SCHEDULING, true);</span>
<span class="nc" id="L128">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to check the
	 * pre-conditions before creating an event
	 */
	void preCreateEvent(Object lockID, Event event) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L136">		preCreateEvents(lockID, Arrays.asList(event));</span>
<span class="nc" id="L137">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event gets created
	 */
	void postCreateEvent(Event event) throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L144">		postCreateEvents(Arrays.asList(event));</span>
<span class="nc" id="L145">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to check the
	 * pre-conditions before creating an event
	 */
	void preCreateEvents(Object lockID, Collection events) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L153">		checkModifiable(lockID, events);</span>
<span class="nc" id="L154">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event gets created
	 */
	void postCreateEvents(Collection events) throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L161">		auditAndLogEventChange(events, null);</span>
<span class="nc" id="L162">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before an
	 * existing event gets updated
	 */
	void preUpdateEvent(Object lockID, Event oldEvent, Event newEvent) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L170">		preUpdateEvents(lockID, Arrays.asList(oldEvent), Arrays.asList(newEvent));</span>
<span class="nc" id="L171">	}</span>

	void preUpdateEvents(Object lockID, Collection oldEvents, Collection newEvents) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L175">		checkModifiable(lockID, oldEvents);</span>
<span class="nc" id="L176">		checkModifiable(lockID, newEvents);</span>
<span class="nc" id="L177">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing event gets updated
	 */
	void postUpdateEvent(Event oldEvent, Event newEvent) throws BbmFinderException, BbmCreateException,
		RemoteException {

		//QC119530:Update option for Audit viewer is not working
<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (newEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
			//for shift, it can't be partial update since it is single attendee
<span class="nc" id="L189">			createAuditTrailForUnpublishedEvent(newEvent, AuditTrailEntry.ACTION_UPDATE_OBJECT);</span>
		} else {
			/** log the fact that we've just updated an event */
<span class="nc" id="L192">			Collection[] c3 = WorkResourcesAndTimeRange.splitCollections(oldEvent.getWorkResourceIDs(),</span>
<span class="nc" id="L193">				newEvent.getWorkResourceIDs());</span>
			// Fix 98190 Changes made to the activity of Overtime not getting
			// published
			/*
			 * The change would not get through only if there is no other change
			 * apart from changing the activity for the Overtime period. i.e no
			 * change to shift length or overtime length or any other change.
			 */
<span class="nc" id="L201">			boolean bOvertimeActivityChange = true;</span>
<span class="nc bnc" id="L202" title="All 2 branches missed.">			if (c3[0] != null) {</span>
				// old employees removed from the event
<span class="nc" id="L204">				createAuditTrailForUnpublishedEvent(c3[0], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
			}
<span class="nc bnc" id="L206" title="All 2 branches missed.">			if (c3[2] != null) {</span>
				// new employees added to the event
<span class="nc" id="L208">				createAuditTrailForUnpublishedEvent(c3[2], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
			}
<span class="nc bnc" id="L210" title="All 2 branches missed.">			if (c3[1] != null) {</span>
				// employees remained in the event
<span class="nc" id="L212">				Date n1 = newEvent.getStartTime();</span>
<span class="nc" id="L213">				Date n9 = newEvent.getEndTime();</span>
<span class="nc" id="L214">				Date o1 = oldEvent.getStartTime();</span>
<span class="nc" id="L215">				Date o9 = oldEvent.getEndTime();</span>
<span class="nc bnc" id="L216" title="All 4 branches missed.">				boolean bSameTimes = n1.equals(o1) &amp;&amp; n9.equals(o9);</span>
<span class="nc bnc" id="L217" title="All 6 branches missed.">				boolean bTimesIntersect = bSameTimes || n1.before(o9) &amp;&amp; o1.before(n9);</span>
				// Fix 94726 - Changes to shift activities are not showing in web after re-publishing from campaign in FS
				// let check all children of Shifassignment if they have any change  in case nothing was change for the Shift
<span class="nc" id="L220">				boolean bSameChilds = true;</span>
<span class="nc bnc" id="L221" title="All 6 branches missed.">				if (bSameTimes &amp;&amp; oldEvent instanceof ShiftAssignment &amp;&amp; newEvent instanceof ShiftAssignment) {</span>

<span class="nc" id="L223">					if ((((ShiftAssignment) oldEvent).getOTExtensionBeforeActivityID() != ((ShiftAssignment) newEvent)</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">						.getOTExtensionBeforeActivityID())</span>
<span class="nc" id="L225">						|| (((ShiftAssignment) oldEvent).getOTExtensionAfterActivityID() != ((ShiftAssignment) newEvent)</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">						.getOTExtensionAfterActivityID())) {</span>
<span class="nc" id="L227">						bOvertimeActivityChange = false;</span>
					}
<span class="nc" id="L229">					Collection oldChildCol = ((ShiftAssignment) oldEvent).getChildren();</span>
<span class="nc" id="L230">					Collection newChildCol = ((ShiftAssignment) newEvent).getChildren();</span>

					// Reset all old Child Events Id to null to make sure that the objects are compare base on Start &amp; End time
<span class="nc bnc" id="L233" title="All 2 branches missed.">					for (Iterator it = oldChildCol.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L234">						((ShiftEventAssignment) it.next()).setID(null);</span>
					}

<span class="nc bnc" id="L237" title="All 4 branches missed.">					if (!(oldChildCol.containsAll(newChildCol) &amp;&amp; newChildCol.containsAll(oldChildCol))) {</span>
<span class="nc" id="L238">						bSameChilds = false;</span>
					}
				}
				// Change start for QA-96353 this checks if there is a change in meeting attending status for any of the work resource id.
<span class="nc" id="L242">				boolean bResourceAllattendingSync = true;</span>
				// for QC-90782,this boolean is to check whether old event's comments and new event's comments are in sync or not
<span class="nc" id="L244">				boolean bDescriptionSync = true;</span>
<span class="nc" id="L245">				boolean bOverlapTypesSync = true;</span>
<span class="nc" id="L246">				boolean eventIsCalendarEvent = oldEvent instanceof CalendarEvent;</span>
<span class="nc bnc" id="L247" title="All 8 branches missed.">				if (c3[1] != null</span>
<span class="nc" id="L248">					&amp;&amp; (eventIsCalendarEvent &amp;&amp; bSameTimes &amp;&amp; bSameChilds &amp;&amp; newEvent.getActivityID()</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">					.equals(oldEvent.getActivityID()))) {</span>
<span class="nc" id="L250">					Collection oldIds = c3[1];</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">					for (Iterator oldId = oldIds.iterator(); oldId.hasNext(); ) {</span>
<span class="nc" id="L252">						ID id = (ID) oldId.next();</span>
<span class="nc" id="L253">						if (((CalendarEvent) oldEvent).isWorkResourceAttending(id) != ((CalendarEvent) newEvent)</span>
<span class="nc bnc" id="L254" title="All 2 branches missed.">							.isWorkResourceAttending(id)) {</span>
<span class="nc" id="L255">							bResourceAllattendingSync = false;</span>
<span class="nc" id="L256">							break;</span>
						}
<span class="nc" id="L258">					}</span>
					// for QC-90782,set bDescriptionSync=false only if old event's comment is not equal to new event's comments .
<span class="nc bnc" id="L260" title="All 4 branches missed.">					if (!(oldEvent.getDescription() == null &amp;&amp; newEvent.getDescription() == null) </span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">						&amp;&amp; oldEvent.getDescription() == null</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">						|| newEvent.getDescription() == null</span>
<span class="nc bnc" id="L263" title="All 2 branches missed.">						|| !oldEvent.getDescription().equals(newEvent.getDescription())) {</span>
<span class="nc" id="L264">						bDescriptionSync = false;</span>
					}

<span class="nc" id="L267">					bOverlapTypesSync = getOverlapTypesSync(oldEvent, newEvent);</span>
				}
				// Fix 93421, For employees stay in the same calendar event (not be
				// removed or updated from the attendee list).
				// and calendar event start time, end time don't change
				// --&gt; These employees don't have any updates
				// --&gt; don't need to create AuditTrailEntry these employees
<span class="nc bnc" id="L274" title="All 2 branches missed.">				if (bTimesIntersect) {</span>
					// for QC-90782, added bDescriptionSync in the condition
<span class="nc bnc" id="L276" title="All 14 branches missed.">					if (!(bResourceAllattendingSync &amp;&amp; bSameTimes &amp;&amp; bSameChilds &amp;&amp; newEvent.getActivityID().equals(oldEvent.getActivityID())</span>
						&amp;&amp; bOvertimeActivityChange &amp;&amp; bDescriptionSync &amp;&amp; bOverlapTypesSync)) {
						// for QA-96353, added bResourceAllattendingSync in the condition
						// for QC-98190 added bOvertimeActivityChange in the condition
<span class="nc" id="L280">						createAuditTrailForUnpublishedEvent(c3[1], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc" id="L281">						createAuditTrailForUnpublishedEvent(c3[1], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
					}
				} else {
<span class="nc" id="L284">					createAuditTrailForUnpublishedEvent(c3[1], oldEvent, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc" id="L285">					createAuditTrailForUnpublishedEvent(c3[1], newEvent, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
				}
				// Change end for QA-96353
			}
		}
<span class="nc bnc" id="L290" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L291">			m_cat.l7dInfo(</span>
				BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT,
<span class="nc" id="L293">				new Object[]{getEventTypeString(newEvent.getEventType()), newEvent.getID(),</span>
<span class="nc" id="L294">					getEmployeeNames(newEvent.getWorkResourceIDs()), newEvent.getStartTime(),</span>
<span class="nc" id="L295">					NumberFactory.newInteger(newEvent.getDuration())});</span>
		}
<span class="nc" id="L297">	}</span>

	boolean getOverlapTypesSync(Event oldEvent, Event newEvent) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">		return ((CalendarEvent) newEvent).getOverlapType() == ((CalendarEvent) oldEvent).getOverlapType();</span>
	}

	void postUpdateEvents(Collection newEvents, HashMap oldIdEventMap) throws BbmFinderException, RemoteException,
		BbmCreateException {
<span class="nc" id="L305">		ArrayList auditRecords = new ArrayList();</span>
		Event event;
<span class="nc bnc" id="L307" title="All 2 branches missed.">		for (Iterator i = newEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L308">			event = (Event) i.next();</span>
<span class="nc" id="L309">			auditRecords.addAll(getAuditTrailForUnpublihsedEvent(event, (Event) oldIdEventMap.get(event.getID())));</span>
		}
<span class="nc" id="L311">		m_auditManager.createAuditEntry(auditRecords);</span>

<span class="nc bnc" id="L313" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just created a bunch of new shift
			 * assignments
			 */
<span class="nc" id="L318">			StringBuilder buf = new StringBuilder(200);</span>
<span class="nc bnc" id="L319" title="All 2 branches missed.">			for (Iterator it = newEvents.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L320">				event = (Event) it.next();</span>
<span class="nc" id="L321">				buf.append(m_defLocalizer.i18n(</span>
					m_bundle,
					BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT_TEMPLATE,
<span class="nc" id="L324">					getEventTypeString(event.getEventType()), event.getID(),</span>
<span class="nc" id="L325">					getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="nc" id="L326">					NumberFactory.newInteger(event.getDuration())));</span>
<span class="nc bnc" id="L327" title="All 2 branches missed.">				if (it.hasNext()) {</span>
<span class="nc" id="L328">					buf.append(PatternLayout.LINE_SEP);</span>
				}
			}
<span class="nc" id="L331">			m_cat.info(buf.toString());</span>
		}
<span class="nc" id="L333">	}</span>

	private Collection getAuditTrailForUnpublihsedEvent(Event newEvent, Event oldEvent) throws BbmFinderException,
		RemoteException {
<span class="nc" id="L337">		ArrayList list = new ArrayList();</span>
		// log the fact that we've just updated an event
<span class="nc" id="L339">		Collection[] c3 = WorkResourcesAndTimeRange.splitCollections(oldEvent.getWorkResourceIDs(),</span>
<span class="nc" id="L340">			newEvent.getWorkResourceIDs());</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">		if (c3[0] != null) {</span>
			// old employees removed from the event
<span class="nc" id="L343">			list.addAll(getAuditTrailForUnpublishedEvent(c3[0], oldEvent));</span>
		}
<span class="nc bnc" id="L345" title="All 2 branches missed.">		if (c3[2] != null) {</span>
			// new employees added to the event
<span class="nc" id="L347">			list.addAll(getAuditTrailForUnpublishedEvent(c3[2], newEvent));</span>
		}
<span class="nc bnc" id="L349" title="All 2 branches missed.">		if (c3[1] != null) {</span>
			// employees remained in the event
<span class="nc" id="L351">			Date n1 = newEvent.getStartTime();</span>
<span class="nc" id="L352">			Date n9 = newEvent.getEndTime();</span>
<span class="nc" id="L353">			Date o1 = oldEvent.getStartTime();</span>
<span class="nc" id="L354">			Date o9 = oldEvent.getEndTime();</span>
<span class="nc bnc" id="L355" title="All 4 branches missed.">			boolean bSameTimes = n1.equals(o1) &amp;&amp; n9.equals(o9);</span>
<span class="nc bnc" id="L356" title="All 6 branches missed.">			boolean bTimesIntersect = bSameTimes || n1.before(o9) &amp;&amp; o1.before(n9);</span>
<span class="nc bnc" id="L357" title="All 2 branches missed.">			if (bTimesIntersect) {</span>
				// actually, it is possible that nothing changed. e.g., we could remove one attendee...
<span class="nc" id="L359">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], newEvent));</span>
			} else {
<span class="nc" id="L361">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], oldEvent));</span>
<span class="nc" id="L362">				list.addAll(getAuditTrailForUnpublishedEvent(c3[1], newEvent));</span>
			}
		}
<span class="nc" id="L365">		return list;</span>
	}

	private Collection getAuditTrailForUnpublishedEvent(Collection c, Event event)
		throws BbmFinderException, RemoteException {
<span class="nc" id="L370">		List&lt;AuditTrailEntry&gt; listAuditTrails = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L371">		Map mapNames = collectEmployeeOrPhantomNameList(c);</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">		for (Iterator it = c.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L373">			ID workResourceID = (ID) it.next();</span>

<span class="nc" id="L375">			AuditTrailEntry entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING,</span>
<span class="nc" id="L376">				AuditTrailEntry.ACTION_UPDATE_OBJECT, workResourceID, (mapNames.get(workResourceID)).toString(),</span>
<span class="nc" id="L377">				event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L378">			entry.setTimeStamp(new Date());</span>
<span class="nc" id="L379">			entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(event.getEventType()), &quot;-1&quot;, false);</span>

<span class="nc" id="L381">			listAuditTrails.add(entry);</span>
<span class="nc" id="L382">		}</span>
<span class="nc" id="L383">		return listAuditTrails;</span>
	}

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a given type is about to be deleted
	 */
	void preDeleteEvents(Object lockID, Collection listEvents) throws BbmFinderException, MultiUserException,
		RemoteException {
<span class="fc" id="L392">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="pc bpc" id="L393" title="1 of 2 branches missed.">		if (range != null) {</span>
<span class="nc bnc" id="L394" title="All 4 branches missed.">			String lockObject = lockID != null &amp;&amp; lockID instanceof String ? (String) lockID : null;</span>
<span class="nc" id="L395">			m_lockManager.checkEmployeeScheduleCanBeModified(lockObject, range.getWorkResources(), range.getMinStart(),</span>
<span class="nc" id="L396">				range.getMaxEnd());</span>
		}
<span class="fc" id="L398">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a given type gets deleted
	 */
	void postDeleteEvents(Collection listEvents) throws BbmFinderException, BbmCreateException, RemoteException {
<span class="fc" id="L405">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="pc bpc" id="L406" title="1 of 2 branches missed.">		if (range == null) {</span>
<span class="fc" id="L407">			return;</span>
		}
		// log the fact that we've just deleted a bunch of events
<span class="nc" id="L410">		createAuditTrailEntry(range.getWorkResources(), listEvents, AuditTrailEntry.ACTION_DELETE_OBJECT,</span>
			AuditTrailEntry.MODULE_SCHEDULING, false);

<span class="nc bnc" id="L413" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/*
			 * find the employee names for all work resource ids whose events
			 * are being deleted
			 */
<span class="nc" id="L418">			StringBuilder buf = new StringBuilder(300);</span>
<span class="nc" id="L419">			buf.append(m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENTS));</span>

<span class="nc bnc" id="L421" title="All 2 branches missed.">			for (Iterator it = listEvents.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L422">				Event event = (Event) it.next();</span>
<span class="nc" id="L423">				buf.append(PatternLayout.LINE_SEP);</span>
<span class="nc" id="L424">				buf.append(m_defLocalizer.i18n(</span>
					m_bundle,
					BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENT,
<span class="nc" id="L427">					getEventTypeString(event.getEventType()), event.getID(),</span>
<span class="nc" id="L428">					getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="nc" id="L429">					NumberFactory.newInteger(event.getDuration())));</span>
<span class="nc" id="L430">			}</span>
<span class="nc" id="L431">			m_cat.info(buf.toString());</span>
		}
<span class="nc" id="L433">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a set
	 * of shift assignments gets created
	 */
	void preCreateShiftAssignments(Object lockID, Collection listEvents) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="fc" id="L441">		checkModifiable(lockID, listEvents);</span>
<span class="fc" id="L442">	}</span>

	private void checkModifiable(Object lockID, Collection events) throws BbmUpdateException, BbmFinderException,
		MultiUserException, RemoteException {
<span class="fc" id="L446">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(events);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">		if (range != null) {</span>
<span class="fc" id="L448">			Iterator it = events.iterator();</span>
			// so far, we don't support to create a list of shifts belonging to diff campaigns in one shoot
<span class="fc" id="L450">			ID campaignID = null; </span>
<span class="fc" id="L451">			ID id = null;</span>
<span class="fc bfc" id="L452" title="All 2 branches covered.">			while (it.hasNext()) {</span>
<span class="fc" id="L453">				Object event = it.next();</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">				if (event instanceof ShiftAssignment) {</span>
<span class="fc" id="L455">					id = ((ShiftAssignment) event).getCampaignID();</span>
				}
<span class="pc bpc" id="L457" title="1 of 4 branches missed.">				if (campaignID == null &amp;&amp; id != null) {</span>
<span class="fc" id="L458">					campaignID = id;</span>
<span class="pc bpc" id="L459" title="2 of 4 branches missed.">				} else if (id != null &amp;&amp; !id.equals(campaignID)) {</span>
<span class="nc" id="L460">					throw new BbmUpdateException(&quot;Don't support to create/update shifts in different campaigns.&quot;);</span>
				}
<span class="fc" id="L462">			}</span>
<span class="pc bpc" id="L463" title="1 of 2 branches missed.">			if (campaignID != null) {</span>
<span class="fc" id="L464">				m_lockManager.checkIfEmployeeExistingInSP(campaignID, range.getWorkResources());</span>
			}
<span class="pc bpc" id="L466" title="2 of 4 branches missed.">			String lockObject = lockID != null &amp;&amp; lockID instanceof String ? (String) lockID : null;</span>
<span class="fc" id="L467">			m_lockManager.checkEmployeeScheduleCanBeModified(lockObject, range.getWorkResources(), range.getMinStart(),</span>
<span class="fc" id="L468">				range.getMaxEnd());</span>
		}
<span class="fc" id="L470">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of shift assignments gets created
	 */
	void postCreateShiftAssignments(Collection listEvents) throws BbmFinderException, BbmCreateException,
		RemoteException {
		/**
		 * log the fact that we've just created a bunch of new shift assignments
		 * all the event should have te same type - shift assignment
		 */
<span class="fc" id="L482">		String strEventType = getEventTypeString(Event.EVENT_TYPE_SHIFT_ASSIGNMENT);</span>
<span class="fc" id="L483">		auditAndLogEventChange(listEvents, strEventType);</span>
<span class="fc" id="L484">	}</span>

	private void auditAndLogEventChange(Collection listEvents, String eventType) throws BbmFinderException,
		BbmCreateException, RemoteException {
<span class="fc" id="L488">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="pc bpc" id="L489" title="1 of 2 branches missed.">		if (range == null) {</span>
<span class="nc" id="L490">			return;</span>
		}
<span class="fc" id="L492">		createAuditTrailEntry(range.getWorkResources(), listEvents, AuditTrailEntry.ACTION_CREATE_OBJECT,</span>
			AuditTrailEntry.MODULE_SCHEDULING, false);

<span class="pc bpc" id="L495" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			// log the fact that we've just created a bunch of new shift assignments
<span class="fc" id="L497">			StringBuilder buf = new StringBuilder(200);</span>
<span class="fc" id="L498">			String typeString = eventType;</span>
<span class="fc bfc" id="L499" title="All 2 branches covered.">			for (Iterator it = listEvents.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L500">				Event event = (Event) it.next();</span>
<span class="pc bpc" id="L501" title="1 of 2 branches missed.">				if (eventType == null) {</span>
<span class="nc" id="L502">					typeString = getEventTypeString(event.getEventType());</span>
				}
<span class="fc" id="L504">				buf.append(m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_CREATED_EVENT, typeString, event.getID(), </span>
<span class="fc" id="L505">					getEmployeeNames(event.getWorkResourceIDs()), event.getStartTime(),</span>
<span class="fc" id="L506">					NumberFactory.newInteger(event.getDuration())));</span>
<span class="fc bfc" id="L507" title="All 2 branches covered.">				if (it.hasNext()) {</span>
<span class="fc" id="L508">					buf.append(PatternLayout.LINE_SEP);</span>
				}
<span class="fc" id="L510">			}</span>
<span class="fc" id="L511">			m_cat.info(buf.toString());</span>
		}
<span class="fc" id="L513">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before the
	 * schedule gets cleared for a set of employees and a given time window
	 */
	void preClearSchedule(String lockID, Collection workResourceIDs, Date startTime, Date endTime) throws
		BbmFinderException, MultiUserException, RemoteException {
<span class="nc" id="L521">		m_lockManager.checkEmployeeScheduleCanBeModified(lockID, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L522">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever the
	 * schedule gets cleared for a set of employees and a given time window
	 */
	void postClearSchedule(Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime, boolean unlockedOnly,
						   Collection listEvents) throws BbmFinderException, BbmCreateException, RemoteException {

<span class="fc" id="L531">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="fc" id="L532">		Collection&lt;AuditTrailEntry&gt; audits = new ArrayList&lt;&gt;(listEvents.size());</span>

		// the bug fix of silk 92949 introduces too many of audit records and
		// too much of details. sql server is out of memory if
		// deleting shifts of 4 weeks sp for 1600 employees.
		// here we can simplify the audit record, for each workresource, one
		// record per shift with the impact time range, no other details; same
		// as 771
		Event event;
		ID workResourceID;
		Date impactStart;
		Date impactEnd;
		AuditTrailEntry entry;
<span class="pc bpc" id="L545" title="1 of 2 branches missed.">		for (Iterator i = listEvents.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L546">			event = (Event) i.next();</span>
<span class="nc" id="L547">			workResourceID = event.getWorkResourceIDs().iterator().next();</span>
<span class="nc" id="L548">			impactStart = event.getStartTime();</span>
<span class="nc" id="L549">			impactEnd = event.getEndTime();</span>
<span class="nc" id="L550">			entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_DELETE_OBJECT,</span>
<span class="nc" id="L551">				workResourceID, (mapNames.get(workResourceID)).toString(), impactStart, impactEnd);</span>
<span class="nc" id="L552">			audits.add(entry);</span>
		}
<span class="fc" id="L554">		m_auditManager.createAuditEntry(audits);</span>

<span class="pc bpc" id="L556" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			// log the fact that we've just deleted a bunch of shift assignments
<span class="pc bpc" id="L558" title="1 of 2 branches missed.">			if (!unlockedOnly) {</span>
<span class="fc" id="L559">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CLEARED_SCHEDULE, new Object[]{</span>
<span class="fc" id="L560">					getEmployeeNames(workResourceIDs), startTime, endTime});</span>
			} else {
<span class="nc" id="L562">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CLEARED_SCHEDULE_UNLOCKED_ONLY, new Object[]{</span>
<span class="nc" id="L563">					getEmployeeNames(workResourceIDs), startTime, endTime});</span>
			}
		}
<span class="fc" id="L566">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a new
	 * event template gets created
	 */
	void preCreateEventTemplate(CalendarEventTemplate eventTemplate) throws BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L574">		preActionEventTemplate(eventTemplate);</span>
<span class="nc" id="L575">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a new
	 * event template gets created
	 */
	void postCreateEventTemplate(CalendarEventTemplate eventTemplate) throws BbmFinderException, BbmCreateException,
		RemoteException {
<span class="nc" id="L583">		createAuditTrailForUnpublishedEventTemplate(eventTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>

<span class="nc" id="L585">		Collection listAttendees = eventTemplate.getWorkResourceIDs();</span>
<span class="nc bnc" id="L586" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L587">			String strTemplateType = getEventTemplateTypeString(eventTemplate.getTemplateType());</span>
<span class="nc" id="L588">			Integer duration = NumberFactory.newInteger(eventTemplate.getDuration());</span>
<span class="nc" id="L589">			Object listNames = getEmployeeNames(listAttendees);</span>

			/** log the fact that we've just created a new event template */
<span class="nc" id="L592">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_CREATED_EVENT_TEMPLATE, new Object[]{strTemplateType,</span>
<span class="nc" id="L593">				eventTemplate.getID(), listNames, duration});</span>
		}
<span class="nc" id="L595">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets updated
	 */
	void preUpdateEventTemplate(CalendarEventTemplate oldTemplate) throws BbmFinderException, MultiUserException,
		RemoteException {
<span class="nc" id="L603">		preActionEventTemplate(oldTemplate);</span>
<span class="nc" id="L604">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets updated
	 */
	void postUpdateEventTemplate(CalendarEventTemplate oldTemplate, CalendarEventTemplate newTemplate) throws
		BbmFinderException, MultiUserException, RemoteException, BbmCreateException {
<span class="nc bnc" id="L612" title="All 2 branches missed.">		if (newTemplate instanceof ValueObjectAggEventTemplate) {</span>
<span class="nc" id="L613">			ValueObjectAggEventTemplate calTemplate = (ValueObjectAggEventTemplate) newTemplate;</span>
<span class="nc" id="L614">			m_lockManager.checkEmployeeScheduleCanBeModified(null, calTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L615">				calTemplate.getEarliestPossibleStartTime(), calTemplate.getLatestPossibleEndTime());</span>
		}
		/** log the fact that we've just updated an event */
<span class="nc" id="L618">		Collection[] c3 = WorkResourcesAndTimeRange.splitCollections(oldTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L619">			newTemplate.getWorkResourceIDs());</span>
<span class="nc bnc" id="L620" title="All 2 branches missed.">		if (c3[0] != null) {</span>
			// old employees removed from the event
<span class="nc" id="L622">			createAuditTrailForUnpublishedEventTemplate(c3[0], oldTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
		}
<span class="nc bnc" id="L624" title="All 2 branches missed.">		if (c3[2] != null) {</span>
			// new employees added to the event
<span class="nc" id="L626">			createAuditTrailForUnpublishedEventTemplate(c3[2], newTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
		}
<span class="nc bnc" id="L628" title="All 2 branches missed.">		if (c3[1] != null) {</span>
			// employees remained in the event
<span class="nc" id="L630">			Date n1 = ((ValueObjectAggEventTemplate) newTemplate).getEarliestPossibleStartTime();</span>
<span class="nc" id="L631">			Date n9 = ((ValueObjectAggEventTemplate) newTemplate).getLatestPossibleEndTime();</span>
<span class="nc" id="L632">			Date o1 = ((ValueObjectAggEventTemplate) oldTemplate).getEarliestPossibleStartTime();</span>
<span class="nc" id="L633">			Date o9 = ((ValueObjectAggEventTemplate) oldTemplate).getLatestPossibleEndTime();</span>
<span class="nc bnc" id="L634" title="All 4 branches missed.">			boolean bSameTimes = n1.equals(o1) &amp;&amp; n9.equals(o9);</span>

<span class="nc bnc" id="L636" title="All 2 branches missed.">			if (bSameTimes) {</span>
				// actually, it is possible that nothing changed. e.g., we could remove one attendee...
<span class="nc" id="L638">				createAuditTrailForUnpublishedEventTemplate(c3[1], newTemplate, AuditTrailEntry.ACTION_UPDATE_OBJECT);</span>
			} else {
<span class="nc" id="L640">				createAuditTrailForUnpublishedEventTemplate(c3[1], oldTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>
<span class="nc" id="L641">				createAuditTrailForUnpublishedEventTemplate(c3[1], newTemplate, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>
			}
		}

<span class="nc bnc" id="L645" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L646">			String strTemplateType = getEventTemplateTypeString(newTemplate.getTemplateType());</span>
<span class="nc" id="L647">			Integer duration = NumberFactory.newInteger(newTemplate.getDuration());</span>
<span class="nc" id="L648">			Object listNames = getEmployeeNames(newTemplate.getWorkResourceIDs());</span>

			// log the fact that we've just updated an existing event template
<span class="nc" id="L651">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UPDATED_EVENT_TEMPLATE, new Object[]{strTemplateType,</span>
<span class="nc" id="L652">				newTemplate.getID(), listNames, duration});</span>
		}
<span class="nc" id="L654">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets deleted
	 */
	void preDeleteEventTemplate(CalendarEventTemplate eventTemplate) throws BbmFinderException, MultiUserException,
		RemoteException {
<span class="nc" id="L662">		preActionEventTemplate(eventTemplate);</span>
<span class="nc" id="L663">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * existing calendar event template gets deleted
	 */
	void postDeleteEventTemplate(CalendarEventTemplate eventTemplate) throws BbmFinderException, BbmCreateException,
		RemoteException {
<span class="nc" id="L671">		Collection listAttendees = eventTemplate.getWorkResourceIDs();</span>
		/** log the fact that we've just deleted an existing event template */
<span class="nc" id="L673">		createAuditTrailForUnpublishedEventTemplate(eventTemplate, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>

<span class="nc bnc" id="L675" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
<span class="nc" id="L676">			String strTemplateType = getEventTemplateTypeString(eventTemplate.getTemplateType());</span>
<span class="nc" id="L677">			Integer duration = NumberFactory.newInteger(eventTemplate.getDuration());</span>
<span class="nc" id="L678">			Object listNames = getEmployeeNames(listAttendees);</span>

			/** log the fact that we've just updated an existing event template */
<span class="nc" id="L681">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_DELETED_EVENT_TEMPLATE, new Object[]{strTemplateType,</span>
<span class="nc" id="L682">				eventTemplate.getID(), listNames, duration});</span>
		}
<span class="nc" id="L684">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever an
	 * exception to the recurring event template rule gets created
	 */
	void postCreateRecurringException(CalendarEventAssignment eventException) throws BbmFinderException,
		MultiUserException, RemoteException, BbmCreateException {
		/*
		 * first check if there's another user that has locked the given
		 * schedule period, if so, reject the operation
		 */
<span class="nc" id="L696">		m_lockManager.checkEmployeeScheduleCanBeModified(null, eventException.getWorkResourceIDs(),</span>
<span class="nc" id="L697">			eventException.getStartTime(), eventException.getEndTime());</span>

<span class="nc" id="L699">		createAuditTrailForUnpublishedEvent(eventException, AuditTrailEntry.ACTION_CREATE_OBJECT);</span>

<span class="nc bnc" id="L701" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just created an exception */
<span class="nc" id="L703">			m_cat.l7dInfo(</span>
				BbmEjbLogBundleKey.SCHEDULE_CREATED_RECURRING_EXCEPTION,
<span class="nc" id="L705">				new Object[]{eventException.getEventTemplateID(),</span>
<span class="nc" id="L706">					getEmployeeNames(eventException.getWorkResourceIDs()), eventException.getStartTime()});</span>
		}
<span class="nc" id="L708">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react before a
	 * recurring event instance gets deleted (i.e. there is a &quot;hole&quot; in the
	 * recurring event template rule)
	 */
	void preDeleteRecurringEventInstance(Collection listEvents, Collection workResourceIDs) throws BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L717">		WorkResourcesAndTimeRange range = WorkResourcesAndTimeRange.get(listEvents);</span>
<span class="nc bnc" id="L718" title="All 2 branches missed.">		if (range != null) {</span>
<span class="nc" id="L719">			m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, range.getMinStart(),</span>
<span class="nc" id="L720">				range.getMaxEnd());</span>
		}
<span class="nc" id="L722">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * recurring event instance gets deleted (i.e. there is a &quot;hole&quot; in the
	 * recurring event template rule)
	 */
	void postDeleteRecurringEventInstance(ID templateID, Collection listEvents, Collection workResourceIDs)
		throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc bnc" id="L731" title="All 2 branches missed.">		if (!listEvents.isEmpty()) {</span>
			/*
			 * we just need a single event from this collection because we are
			 * only interested in the event start and end time, and all
			 * instances in the collection have the same start/end times
			 */
<span class="nc" id="L737">			Event event = (Event) listEvents.iterator().next();</span>

<span class="nc" id="L739">			createAuditTrailForUnpublishedEvent(event, AuditTrailEntry.ACTION_DELETE_OBJECT);</span>

<span class="nc bnc" id="L741" title="All 2 branches missed.">			if (m_cat.isInfoEnabled()) {</span>
				/**
				 * log the fact that we've just deleted a recurring event
				 * instance
				 */
<span class="nc" id="L746">				m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_DELETED_RECURRING_INSTANCE, new Object[]{templateID,</span>
<span class="nc" id="L747">					getEmployeeNames(workResourceIDs), event.getStartTime()});</span>
			}
		}
<span class="nc" id="L750">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is locked for the specified set of workresources in a
	 * given time window
	 */
	void preLockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L759">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L760">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is locked for the specified set of workresources in a
	 * given time window
	 */
	void postLockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws BbmFinderException,
		RemoteException, BbmCreateException {
		// no audit trail event saved for now (b/c no event here)
<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L772">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_LOCKED_EVENTS, new Object[]{getEmployeeNames(workResourceIDs),</span>
				startTime, endTime});
		}
		// generate audit records.
<span class="nc" id="L776">		generateAuditRecordForLockUnlockEvents(workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L777">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is unlocked for the specified set of workresources in a
	 * given time window
	 */
	void preUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc" id="L786">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L787">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a set
	 * of events of a is unlocked for the specified set of workresources in a
	 * given time window
	 */
	void postUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime) throws BbmFinderException,
		RemoteException, BbmCreateException { 
		// no audit trail events saved for now (b/c no  event  here)
<span class="nc bnc" id="L797" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L799">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UNLOCKED_EVENTS, new Object[]{</span>
<span class="nc" id="L800">				getEmployeeNames(workResourceIDs), startTime, endTime});</span>
		}

		// generate audit records.
<span class="nc" id="L804">		generateAuditRecordForLockUnlockEvents(workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L805">	}</span>

	private void generateAuditRecordForLockUnlockEvents(Collection workResourceIDs, Date startTime, Date endTime)
		throws BbmFinderException, RemoteException, BbmCreateException {
<span class="nc bnc" id="L809" title="All 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L810">			return;</span>
		}
<span class="nc" id="L812">		Collection entries = new ArrayList(workResourceIDs.size());</span>
		ID empID;
<span class="nc" id="L814">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="nc bnc" id="L815" title="All 2 branches missed.">		for (Iterator i = workResourceIDs.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L816">			empID = (ID) i.next();</span>
<span class="nc" id="L817">			entries.add(new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_UPDATE_OBJECT,</span>
<span class="nc" id="L818">				empID, (mapNames.get(empID)).toString(), startTime, endTime));</span>
		}
<span class="nc" id="L820">		m_auditManager.createAuditEntry(entries);</span>
<span class="nc" id="L821">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets published for the given set of work resources and the given
	 * time window
	 */
	void postPublishSchedule(Collection workResourceIDs, Date dtStartDate, Date dtEndDate,
			ScheduleChangeDetails changeDetails) { 
		// no audit trail events here
		// need to notify that there's a change in published schedule
<span class="pc bpc" id="L832" title="1 of 2 branches missed.">		if (changeDetails != null) {</span>
<span class="nc" id="L833">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		}

<span class="pc bpc" id="L836" title="1 of 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="fc" id="L838">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_PUBLISHED_SCHEDULE, new Object[]{</span>
<span class="fc" id="L839">				getEmployeeNames(workResourceIDs), dtStartDate, dtEndDate});</span>
		}
<span class="fc" id="L841">	}</span>

	void postPublishEvent(Collection events, ScheduleChangeDetails changeDetails) {
		/** need to notify that there's a change in published schedule */
<span class="nc bnc" id="L845" title="All 2 branches missed.">		if (changeDetails != null) {</span>
<span class="nc" id="L846">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		}
<span class="nc bnc" id="L848" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L850">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_PUBLISHED_EVENT, new Object[]{events});</span>
		}
<span class="nc" id="L852">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * published schedule gets updated for the given set of work resources and
	 * the given time window
	 */
	void postUpdatePublishedSchedule(Collection workResourceIDs, Date dtStartDate, Date dtEndDate,
			ScheduleChangeDetails changeDetails) {
		// no audit trail events here
		// need to notify that there's a change in published schedule
<span class="nc bnc" id="L863" title="All 2 branches missed.">		if (changeDetails != null) {</span>
<span class="nc" id="L864">			JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		}

<span class="nc bnc" id="L867" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just published a schedule */
<span class="nc" id="L869">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UPDATED_PUBLISHED_SCHEDULE, new Object[]{</span>
<span class="nc" id="L870">				getEmployeeNames(workResourceIDs), dtStartDate, dtEndDate});</span>
		}
<span class="nc" id="L872">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets un-published for the given set of work resources and the
	 * given time window
	 */
	void postUnPublishSchedule(Collection workResourceIDs, Date startTime, Date endTime)
		throws BbmSchedulePublishingException { 
		// no audit trail event here
		// need to notify to TO recalculator
<span class="nc" id="L883">		ScheduleChangeDetails changeDetails = new ScheduleChangeDetails(workResourceIDs, startTime, endTime,</span>
<span class="nc" id="L884">			Collections.emptyList(), Collections.emptyList());</span>
<span class="nc" id="L885">		changeDetails.setIsPublish(false);</span>
<span class="nc" id="L886">		JMSNotifyUtil.notifyOnUserAction(changeDetails);</span>
		// Adding TO Notification here
		try {
<span class="nc" id="L889">			triggerTONotification(changeDetails, false);</span>
<span class="nc" id="L890">		} catch (Exception e) {</span>
<span class="nc" id="L891">			throw new BbmSchedulePublishingException(e);</span>
<span class="nc" id="L892">		}</span>
<span class="nc bnc" id="L893" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/** log the fact that we've just un-published a schedule */
<span class="nc" id="L895">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_UNPUBLISHED_SCHEDULE, new Object[]{</span>
<span class="nc" id="L896">				getEmployeeNames(workResourceIDs), startTime, endTime});</span>
		}
<span class="nc" id="L898">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets reverted to published state for the given set of work
	 * resources and the given time window
	 */
	void preRevertToPublishedSchedule(Collection workResourceIDs, Date startTime, Date endTime) throws
		BbmFinderException, MultiUserException, RemoteException {
<span class="nc" id="L907">		m_lockManager.checkEmployeeScheduleCanBeModified(null, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L908">	}</span>

	/**
	 * This method gives the EJB manager the opportunity to react whenever a
	 * schedule gets reverted to published state for the given set of work
	 * resources and the given time window
	 */
	void postRevertToPublishedSchedule(Collection workResourceIDs, Date startTime, Date endTime) throws BbmFinderException,
		RemoteException, BbmCreateException {
		// add audit trail here
		ID workResourceID;
		AuditTrailEntry entry;
<span class="nc" id="L920">		Map mapNames = collectEmployeeOrPhantomNameList(workResourceIDs);</span>
<span class="nc" id="L921">		Date cur = new Date();</span>
<span class="nc" id="L922">		ArrayList auditTrailEntries = new ArrayList(workResourceIDs.size());</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">		for (Iterator j = workResourceIDs.iterator(); j.hasNext(); ) {</span>
<span class="nc" id="L924">			workResourceID = (ID) j.next();</span>
<span class="nc" id="L925">			entry = new AuditTrailEntry(AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_CREATE_OBJECT,</span>
<span class="nc" id="L926">				workResourceID, (mapNames.get(workResourceID)).toString(), startTime, endTime);</span>
<span class="nc" id="L927">			entry.setTimeStamp(cur);</span>
<span class="nc" id="L928">			auditTrailEntries.add(entry);</span>
		}

<span class="nc" id="L931">		m_auditManager.createAuditEntry(auditTrailEntries);</span>
<span class="nc bnc" id="L932" title="All 2 branches missed.">		if (m_cat.isInfoEnabled()) {</span>
			/**
			 * log the fact that we've just reverted the schedule to published
			 * state
			 */
<span class="nc" id="L937">			m_cat.l7dInfo(BbmEjbLogBundleKey.SCHEDULE_REVERTED_SCHEDULE, new Object[]{</span>
<span class="nc" id="L938">				getEmployeeNames(workResourceIDs), startTime, endTime});</span>
		}
<span class="nc" id="L940">	}</span>

	/**
	 * This is a method that returns an event type string given an integer event
	 * type
	 */
	protected String getEventTypeString(int eventType) {
<span class="fc" id="L947">		String bundleKey = BbmEjbLogBundleKey.SCHEDULE_EVENT_TYPE_PREFIX + eventType;</span>
		String strEventType;
		try {
<span class="fc" id="L950">			strEventType = m_defLocalizer.i18n(m_bundle, bundleKey);</span>
<span class="nc" id="L951">		} catch (MissingResourceException mre) {</span>
<span class="nc" id="L952">			bundleKey = BbmEjbLogBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE;</span>
<span class="nc" id="L953">			strEventType = m_defLocalizer.i18n(m_bundle, bundleKey,</span>
<span class="nc" id="L954">				NumberFactory.newInteger(eventType));</span>
<span class="fc" id="L955">		}</span>
<span class="fc" id="L956">		return strEventType;</span>
	}

	/**
	 * This is a method that returns an event template type string given an
	 * event template type
	 */
	private String getEventTemplateTypeString(int templateType) {
		String strTemplateType;
		try {
<span class="nc" id="L966">			strTemplateType = m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_EVENT_TEMPLATE_TYPE_PREFIX</span>
				+ templateType);
<span class="nc" id="L968">		} catch (MissingResourceException mre) {</span>
<span class="nc" id="L969">			strTemplateType = m_defLocalizer.i18n(m_bundle, BbmEjbLogBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE,</span>
<span class="nc" id="L970">				NumberFactory.newInteger(templateType));</span>
<span class="nc" id="L971">		}</span>
<span class="nc" id="L972">		return strTemplateType;</span>
	}

	/**
	 * Private method that returns a collection of displayable employee names
	 * for a given collection of work resource IDs
	 */
	private Object getEmployeeNames(Collection&lt;ID&gt; workResourceIDs) {
<span class="fc" id="L980">		Map&lt;ID, EmployeeName&gt; mapNames = getEmployeeNamesMap(workResourceIDs);</span>
		// I hope actual locale is not needed to represent employee names
		// - umm, except for &quot;Unknown&quot;... And name format...
		// But actually, it is for Logging only
<span class="fc" id="L984">		return EmployeeName.getEmployeeDisplayNames(mapNames.values(), DefaultLocalizationManager.getDefaultInstance()</span>
<span class="fc" id="L985">			.getLocalizer());</span>
	}

	public static void triggerTONotificationOnTOApproval(ScheduleChangeDetails changeDetails) throws BbmUpdateException {
		try {
<span class="nc" id="L990">			int msgType = TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_TO_ONLY;</span>
<span class="nc" id="L991">			TONotifyMessage msg = new TONotifyMessage(msgType);</span>
<span class="nc" id="L992">			msg.setEmployeeIDs(changeDetails.getWorkResourceIDs());</span>
<span class="nc" id="L993">			msg.setObject(changeDetails);</span>
<span class="nc" id="L994">			msg.sendMessage();</span>
<span class="nc" id="L995">		} catch (Exception e) {</span>
<span class="nc" id="L996">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L997">		}</span>

<span class="nc" id="L999">	}</span>

	public static void triggerTONotification(ScheduleChangeDetails changeDetails, boolean isBatchPublish)
		throws BbmUpdateException {
		try {
<span class="pc bpc" id="L1004" title="1 of 2 branches missed.">			int msgType = changeDetails.isPublish() ? TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH</span>
				: TONotifyMessage.TO_NOTIFY_SCHED_UNPUBLISH;
<span class="pc bpc" id="L1006" title="2 of 4 branches missed.">			if (changeDetails.isPublish() &amp;&amp; isBatchPublish) {</span>
<span class="fc" id="L1007">				msgType = TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_PART;</span>
			}
<span class="fc" id="L1009">			TONotifyMessage msg = new TONotifyMessage(msgType);</span>
<span class="fc" id="L1010">			msg.setEmployeeIDs(changeDetails.getWorkResourceIDs());</span>
<span class="fc" id="L1011">			msg.setObject(changeDetails);</span>
<span class="fc" id="L1012">			msg.sendMessage();</span>
<span class="nc" id="L1013">		} catch (Exception e) {</span>
<span class="nc" id="L1014">			throw new BbmUpdateException(e);</span>
<span class="fc" id="L1015">		}</span>

<span class="fc" id="L1017">	}</span>

	public void triggerTONotificationSynrchronized(ScheduleChangeDetails changeDetails) throws CoreEJBCreateException,
		CoreFinderException, ClassNotFoundException, InstantiationException, IllegalAccessException,
			RemoteException, BbmException {
<span class="nc" id="L1022">		String gcrType = &quot;TIMEOFFHOURSMANAGER_BRIDGE&quot;;</span>
<span class="nc" id="L1023">		GCRManager m_gcrManager = CoreManagerFactory.getGCRManagerRemote(false);</span>
<span class="nc" id="L1024">		Collection entries = m_gcrManager.getGCREntryOfType(gcrType);</span>
<span class="nc" id="L1025">		Class clazz = Class.forName(((GCREntry) (entries.iterator().next())).getHook());</span>
<span class="nc" id="L1026">		TimeOffHoursManagerBridge bridge = (TimeOffHoursManagerBridge) clazz.newInstance();</span>
<span class="nc" id="L1027">		bridge.onSynchronizeScheduleChange(changeDetails);</span>
<span class="nc" id="L1028">	}</span>

	public void triggerTONotification(Collection wrkResIds, Date startDate, Date endDate, boolean isPublish)
		throws BbmUpdateException {
		try {
<span class="pc bpc" id="L1033" title="1 of 2 branches missed.">			if (isPublish) { // We do not need unpublish notification for now</span>
<span class="fc" id="L1034">				TONotifyMessage msg = new TONotifyMessage(TONotifyMessage.TO_NOTIFY_SCHED_PUBLISH_BATCH_COMPLETE);</span>
<span class="fc" id="L1035">				msg.setEmployeeIDs(wrkResIds);</span>
<span class="fc" id="L1036">				msg.setStartDate(startDate);</span>
<span class="fc" id="L1037">				msg.setEndDate(endDate);</span>
<span class="fc" id="L1038">				msg.sendMessage();</span>
			}
<span class="nc" id="L1040">		} catch (Exception e) {</span>
<span class="nc" id="L1041">			throw new BbmUpdateException(e);</span>
<span class="fc" id="L1042">		}</span>
<span class="fc" id="L1043">	}</span>

	// ========= AUDIT TRAIL SUPPORT ===================

	public void createAuditTrailEntryForPublishing(Collection eventList, Collection publishedAttendeeList, short action)
		throws BbmFinderException, BbmCreateException, RemoteException {
<span class="fc" id="L1049">		createAuditTrailEntry(publishedAttendeeList, eventList, action, AuditTrailEntry.MODULE_PUBLISHING, false);</span>
<span class="fc" id="L1050">	}</span>

	public void createAuditTrailEntryForPublishing(Collection eventList, short action) throws BbmFinderException,
		BbmCreateException, RemoteException {
<span class="fc" id="L1054">		HashSet affectedAttendees = new HashSet();</span>
<span class="fc bfc" id="L1055" title="All 2 branches covered.">		for (Iterator i = eventList.iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L1056">			affectedAttendees.addAll(((Event) i.next()).getWorkResourceIDs());</span>
		}
<span class="fc" id="L1058">		createAuditTrailEntry(affectedAttendees, eventList, action, AuditTrailEntry.MODULE_PUBLISHING, false);</span>
<span class="fc" id="L1059">	}</span>

	public void createAuditTrailEntry(Collection events, short action, short module, boolean isTemplate)
		throws BbmFinderException, BbmCreateException, RemoteException {
<span class="nc" id="L1063">		HashSet affectedAttendees = new HashSet();</span>
<span class="nc bnc" id="L1064" title="All 2 branches missed.">		for (Iterator i = events.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1065">			affectedAttendees.addAll(((Event) i.next()).getWorkResourceIDs());</span>
		}
<span class="nc" id="L1067">		createAuditTrailEntry(affectedAttendees, events, action, module, isTemplate);</span>
<span class="nc" id="L1068">	}</span>

	public void createAuditTrailEntry(Collection affectedAttendees, Collection events, short action, short module,
									  boolean isTemplate) throws BbmFinderException, BbmCreateException, RemoteException {
<span class="fc" id="L1072">		Event event = null;</span>
		CalendarEventTemplate template;
		ID workResourceID;
<span class="fc" id="L1075">		ArrayList auditTrailEntries = new ArrayList();</span>
		AuditTrailEntry entry;
<span class="fc" id="L1077">		Map mapNames = collectEmployeeOrPhantomNameList(affectedAttendees);</span>
		Date start;
		Date end;
		int eventType;
		Collection attendees;
<span class="fc bfc" id="L1082" title="All 2 branches covered.">		for (Iterator i = events.iterator(); i.hasNext(); ) {</span>
<span class="pc bpc" id="L1083" title="1 of 2 branches missed.">			if (isTemplate) {</span>
				// so far, only recurry event template is audited on template
				// object.
				// for floating event template, we will audit on the real
				// created events.
<span class="nc" id="L1088">				template = (CalendarEventTemplate) i.next();</span>
<span class="nc" id="L1089">				start = ((ValueObjectAggEventTemplate) template).getEarliestPossibleStartTime();</span>
				// fix bug 95991, the latest possible end time is only make
				// sense for floating, but for recurring, it is not
				// floated, so the end is start plus duration.
<span class="nc" id="L1093">				end = new Date(start.getTime() + template.getDuration() * 60 * 1000);</span>
				/*
				 * fix 94339, fix bug QC27832 : for recurring, the impact time
				 * is the whole recurring period. not only the first instance
				 */
<span class="nc bnc" id="L1098" title="All 2 branches missed.">				if (template.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>
<span class="nc" id="L1099">					end = ((RecurringEventTemplate) template).getLatestPossibleEndTime();</span>
				}
<span class="nc bnc" id="L1101" title="All 2 branches missed.">				if (template.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L1102">					end = ((RecurringFloatingEventTemplate) template).getLatestPossibleEndTime();</span>
				}

<span class="nc" id="L1105">				eventType = template.getEventType();</span>
<span class="nc" id="L1106">				attendees = template.getWorkResourceIDs();</span>
			} else {
<span class="fc" id="L1108">				event = (Event) i.next();</span>
<span class="fc" id="L1109">				start = event.getStartTime();</span>
<span class="fc" id="L1110">				end = event.getEndTime();</span>
<span class="fc" id="L1111">				eventType = event.getEventType();</span>
<span class="fc" id="L1112">				attendees = event.getWorkResourceIDs();</span>
			}
<span class="fc bfc" id="L1114" title="All 2 branches covered.">			for (Iterator j = affectedAttendees.iterator(); j.hasNext(); ) {</span>
<span class="fc" id="L1115">				workResourceID = (ID) j.next();</span>
<span class="fc bfc" id="L1116" title="All 2 branches covered.">				if (attendees.contains(workResourceID)) {</span>
					// for partial update, such as update attendee list only.
<span class="fc" id="L1118">					entry = new AuditTrailEntry(module, action, workResourceID,</span>
<span class="fc" id="L1119">						(mapNames.get(workResourceID)).toString(), start, end);</span>
<span class="fc" id="L1120">					entry.setTimeStamp(new Date());</span>
<span class="fc" id="L1121">					entry.addProperty(AuditTrailPropertyConstant.EVENT_TYPE, String.valueOf(eventType), &quot;-1&quot;, false);</span>
<span class="pc bpc" id="L1122" title="2 of 4 branches missed.">					if (!isTemplate &amp;&amp; event.getParentID() != null) {</span>
						// event might have template id
<span class="fc" id="L1124">						entry.addProperty(AuditTrailPropertyConstant.EVENT_TEMPLATE,</span>
<span class="fc" id="L1125">							String.valueOf(event.getParentID()), &quot;-1&quot;, false);</span>
					}
<span class="fc" id="L1127">					auditTrailEntries.add(entry);</span>
				}
			}
		}
<span class="fc" id="L1131">		m_auditManager.createAuditEntry(auditTrailEntries);</span>
<span class="fc" id="L1132">	}</span>

	private Map collectEmployeeOrPhantomNameList(Collection workresourceIDs) throws BbmFinderException,
		RemoteException {
<span class="fc" id="L1136">		Map names = getEmployeeNamesMap(workresourceIDs);</span>
		EmployeeName empName;
		Object key;
<span class="fc bfc" id="L1139" title="All 2 branches covered.">		for (Iterator i = names.keySet().iterator(); i.hasNext(); ) {</span>
<span class="fc" id="L1140">			key = i.next();</span>
<span class="fc" id="L1141">			empName = (EmployeeName) names.get(key);</span>
			// replace EmployeeName object with formatted string
<span class="fc" id="L1143">			names.put(key, empName.getDisplayName(m_defLocalizer));</span>
		}
<span class="fc" id="L1145">		ArrayList phantomList = new ArrayList(workresourceIDs);</span>
<span class="fc" id="L1146">		phantomList.removeAll(names.keySet()); // all the remaining ids are</span>
		// phantom ids.
<span class="pc bpc" id="L1148" title="1 of 2 branches missed.">		if (!phantomList.isEmpty()) {</span>
<span class="nc" id="L1149">			names.putAll(m_scheduleAccessManager.getPhantomEmployeeNamesByIDs(phantomList));</span>
		}
		// workresourceIDs will be used as affectedAttendees later.
<span class="fc" id="L1152">		return names;</span>
	}

	/**
	 * This method gives the EJB manager the opportunity to react before a new
	 * event template gets created
	 */
	private void preActionEventTemplate(CalendarEventTemplate eventTemplate) throws BbmFinderException,
		MultiUserException, RemoteException {
<span class="nc bnc" id="L1161" title="All 2 branches missed.">		if (eventTemplate instanceof ValueObjectAggEventTemplate) {</span>
<span class="nc" id="L1162">			ValueObjectAggEventTemplate calTemplate = (ValueObjectAggEventTemplate) eventTemplate;</span>
<span class="nc" id="L1163">			m_lockManager.checkEmployeeScheduleCanBeModified(null, eventTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L1164">				calTemplate.getEarliestPossibleStartTime(), calTemplate.getLatestPossibleEndTime());</span>
		}
<span class="nc" id="L1166">	}</span>
}

/**
 * this is a helper class used to compute the earliest start time and the latest
 * end time and the complete set of workresources from a collection of events
 */
<span class="fc" id="L1173">class WorkResourcesAndTimeRange {</span>
<span class="fc" id="L1174">	private final Set&lt;ID&gt; m_setWorkresources = new HashSet&lt;ID&gt;();</span>
<span class="fc" id="L1175">	private Date m_dtMinStart = null;</span>
<span class="fc" id="L1176">	private Date m_dtMaxEnd = null;</span>

	static WorkResourcesAndTimeRange get(Collection listEvents) {
<span class="pc bpc" id="L1179" title="1 of 4 branches missed.">		if (listEvents == null || listEvents.isEmpty()) {</span>
<span class="fc" id="L1180">			return null;</span>
		}

<span class="fc" id="L1183">		WorkResourcesAndTimeRange obj = new WorkResourcesAndTimeRange();</span>

		/*
		 * go through all the events to find all the work resources and the min
		 * start time and the max end time
		 */
<span class="fc bfc" id="L1189" title="All 2 branches covered.">		for (Iterator it = listEvents.iterator(); it.hasNext(); ) {</span>
<span class="fc" id="L1190">			Event event = (Event) it.next();</span>
<span class="fc" id="L1191">			obj.m_setWorkresources.addAll(event.getWorkResourceIDs());</span>

<span class="fc" id="L1193">			Date dtEventStart = event.getStartTime();</span>
<span class="pc bpc" id="L1194" title="1 of 4 branches missed.">			if (obj.m_dtMinStart == null || obj.m_dtMinStart.after(dtEventStart)) {</span>
<span class="fc" id="L1195">				obj.m_dtMinStart = dtEventStart;</span>
			}

<span class="fc" id="L1198">			Date dtEventEnd = event.getEndTime();</span>
<span class="fc bfc" id="L1199" title="All 4 branches covered.">			if (obj.m_dtMaxEnd == null || obj.m_dtMaxEnd.before(dtEventEnd)) {</span>
<span class="fc" id="L1200">				obj.m_dtMaxEnd = dtEventEnd;</span>
			}
<span class="fc" id="L1202">		}</span>
<span class="fc" id="L1203">		return obj;</span>
	}

	Collection&lt;ID&gt; getWorkResources() {
<span class="fc" id="L1207">		return m_setWorkresources;</span>
	}

	Date getMinStart() {
<span class="fc" id="L1211">		return m_dtMinStart;</span>
	}

	Date getMaxEnd() {
<span class="fc" id="L1215">		return m_dtMaxEnd;</span>
	}

	/**
	 * splits elements of 2 sets into 3 sets: of ones which are members of the
	 * first collection only; of ones which are common for both; of ones which
	 * are members of the second collection only;
	 *
	 * @param c1
	 *            first collection
	 * @param c2
	 *            second collection
	 * @return array of 3 collections, as described above
	 */
	public static Collection[] splitCollections(Collection c1, Collection c2) {
<span class="nc" id="L1230">		ArrayList[] rc = new ArrayList[3];</span>
<span class="nc" id="L1231">		rc[0] = rc[1] = rc[2] = null;</span>
<span class="nc bnc" id="L1232" title="All 2 branches missed.">		for (Iterator it = c1.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1233">			Object item = it.next();</span>
<span class="nc bnc" id="L1234" title="All 2 branches missed.">			if (c2.contains(item)) {</span>
<span class="nc bnc" id="L1235" title="All 2 branches missed.">				if (rc[1] == null) {</span>
<span class="nc" id="L1236">					rc[1] = new ArrayList();</span>
				}
<span class="nc" id="L1238">				rc[1].add(item);</span>
			} else {
<span class="nc bnc" id="L1240" title="All 2 branches missed.">				if (rc[0] == null) {</span>
<span class="nc" id="L1241">					rc[0] = new ArrayList();</span>
				}
<span class="nc" id="L1243">				rc[0].add(item);</span>
			}
<span class="nc" id="L1245">		}</span>
		// now, fast check: may be, the collections are same?
<span class="nc bnc" id="L1247" title="All 4 branches missed.">		if (rc[1] == null || rc[1].size() != c2.size()) {</span>
<span class="nc bnc" id="L1248" title="All 2 branches missed.">			for (Iterator it = c2.iterator(); it.hasNext(); ) {</span>
<span class="nc" id="L1249">				Object item = it.next();</span>
<span class="nc bnc" id="L1250" title="All 4 branches missed.">				if (!c1.contains(item) &amp;&amp; rc[2] == null) {</span>
<span class="nc" id="L1251">					rc[2] = new ArrayList();</span>
<span class="nc" id="L1252">					rc[2].add(item);</span>
<span class="nc bnc" id="L1253" title="All 4 branches missed.">				} else if (!c1.contains(item) &amp;&amp; rc[2] != null) {</span>
<span class="nc" id="L1254">					rc[2].add(item);</span>
				}
<span class="nc" id="L1256">			}</span>
		}
<span class="nc" id="L1258">		return rc;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>