<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RecurringEventTemplateDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">RecurringEventTemplateDAO.java</span></div><h1>RecurringEventTemplateDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Recurring Event Template DAO class
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version      1.0
 */

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.model.*;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;

import java.util.*;

class RecurringEventTemplateDAO extends AggEventTemplateDAO&lt;RecurringEventTemplateBase&gt; implements ScheduleEventRetrieval&lt;CalendarEventAssignment&gt;,
		ScheduleConflictChecker&lt;RecurringEventTemplateBase&gt; {
	// meta data info.
<span class="fc" id="L29">	private static FieldInfo m_fieldInfo = new RecurringEventTemplateFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="fc" id="L32">		return m_fieldInfo;</span>
	}

	public RecurringEventTemplateDAO() {
<span class="nc" id="L36">		super();</span>
<span class="nc" id="L37">	}</span>

	public RecurringEventTemplateDAO(Jdmo dmo) {
<span class="fc" id="L40">		super(dmo);</span>
<span class="fc" id="L41">	}</span>

	/**
	 * This is an override of the base class function to create an appropriate
	 * type of the value object based on the event template type that is stored
	 * in CALENDAREVENTTEMPLATE record
	 */
	protected RecurringEventTemplateBase createValueObject(JdmoRowset rs) throws Exception {
<span class="nc bnc" id="L49" title="All 3 branches missed.">		switch (rs.getInt(&quot;TEMPLATETYPE&quot;)) {</span>
			case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING:
<span class="nc" id="L51">				return new RecurringEventTemplate();</span>

			case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING:
<span class="nc" id="L54">				return new RecurringFloatingEventTemplate();</span>

			default:
			/* this should never happen, could log an error here */
<span class="nc" id="L58">				return null;</span>
		}
	}

	/** This is an override of the base class function */
	protected RecurringEventTemplateBase createValueObject() {
		/** this flavor of createValueObject will never be called */
<span class="nc" id="L65">		return null;</span>
	}

	/** override from base class */
	protected DAOBase createChildDAO(int iType) {
<span class="nc" id="L70">		return new RecurringEventExceptionDAO(m_dmo);</span>
	}

	/** This is an override of the base class */
	public ID createObject(RecurringEventTemplateBase objValue, boolean bBatched) throws BbmCreateException {
		/**
		 * if this is a recurring floating event template, then set the event
		 * type for event instances to CALENDAR_EVENT_ASSIGNMENT. Gal says time
		 * off events and/or unavailabilities may not be floating.
		 */
<span class="nc" id="L80">		RecurringEventTemplateBase eventTemplate = objValue;</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">		if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L82">			eventTemplate.getAggregatedTemplate().setEventType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT);</span>
		}
<span class="nc" id="L84">		return super.createObject(eventTemplate, bBatched);</span>
	}

	/**
	 * Returns a collection of conflicts (schedule constraint violations) for a
	 * newly created recurring event template to make sure that the proposed
	 * change does not violate some constraint in the schedule. The returned
	 * collection contains objects of type BbmScheduleConflict. If there are no
	 * conflicts caused by the proposed change the returned collection will be
	 * empty.
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObject(RecurringEventTemplateBase obj) throws BbmFinderException {
<span class="nc" id="L96">		return getConflictsForScheduleObject(obj, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedScheduleObject(RecurringEventTemplateBase obj) throws BbmFinderException {
<span class="nc" id="L100">		return getConflictsForScheduleObject(obj, false);</span>
	}

	private Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(RecurringEventTemplateBase obj, boolean isNewObject)
			throws BbmFinderException {
<span class="nc" id="L105">		RecurringEventTemplateBase recTemplate = obj;</span>
<span class="nc bnc" id="L106" title="All 2 branches missed.">		if (isNewObject) {</span>
			try {
				// will be use later to check conflict.
<span class="nc" id="L109">				calcAndSetEventPrecedence(recTemplate);</span>
<span class="nc" id="L110">			} catch (Exception e) {</span>
<span class="nc" id="L111">				throw new BbmFinderException(e);</span>
<span class="nc" id="L112">			}</span>
		}

<span class="nc" id="L115">		ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO(m_dmo);</span>
<span class="nc" id="L116">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; listShifts = daoShift.getEventsForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L117">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>
<span class="nc" id="L118">		Collection&lt;ShiftAssignment&gt; shifts = ScheduleDAOUtil.getUniqueEvents(listShifts);</span>

<span class="nc" id="L120">		CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L121">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = daoEvent.getAttendingEventsForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L122">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>
<span class="nc" id="L123">		Collection&lt;CalendarEventAssignment&gt; events = ScheduleDAOUtil.getUniqueEvents(listEvents);</span>

<span class="nc" id="L125">		Collection&lt;RecurringEventTemplateBase&gt; templates = getTemplatesForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L126">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>

<span class="nc" id="L128">		Collection&lt;BbmScheduleConflict&gt; listConflicts = recTemplate.getConflictsForTemplate(isNewObject, shifts, events, templates);</span>

		/*
		 * the last step is to find the find all of the employee names for all
		 * of the conflicts returned from this method call
		 */
<span class="nc" id="L134">		ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>

<span class="nc" id="L136">		return listConflicts;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="fc" id="L145">		StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>
<span class="pc bpc" id="L146" title="1 of 2 branches missed.">		if (strSQL.length() &gt; 0) {</span>
<span class="fc" id="L147">			strSQL.append(&quot; AND &quot;);</span>
		}

		/*
		 * strSQL.append(m_dmo.bitwiseAND(&quot;EVENTTYPE&quot;,
		 * NumberFactory.newInteger(eventTypeBitMask)));
		 * strSQL.append(&quot; != 0)&quot;);
		 */
<span class="fc" id="L155">		strSQL.append(&quot;(&quot;);</span>
<span class="fc" id="L156">		strSQL.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask));</span>
<span class="fc" id="L157">		strSQL.append(&quot; )&quot;);</span>
<span class="fc" id="L158">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * event templates for a given set of work resources in a given time period.
	 * If these parameters are not provided (or are empty/null) then an empty query is returned.
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {

<span class="fc" id="L169">		StringBuffer strSQL = new StringBuffer(200);</span>

<span class="pc bpc" id="L171" title="1 of 2 branches missed.">		if (dtStart != null) {</span>
			// Jason: since the end date is inclusive I need to look back a day
<span class="fc" id="L173">			dtStart = new Date(dtStart.getTime() - ShiftAssignment.MILLIS_IN_ONE_DAY);</span>

<span class="pc bpc" id="L175" title="1 of 2 branches missed.">			if (dtEnd != null) {</span>
<span class="fc" id="L176">				strSQL.append(&quot;B.STARTDATE &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="fc" id="L177">				strSQL.append(&quot;' AND &quot;);</span>
			}
<span class="fc" id="L179">			strSQL.append(&quot;(B.ENDDATE IS NULL OR B.ENDDATE &gt; '&quot;);</span>
<span class="fc" id="L180">			strSQL.append(JdmoUtil.formatDBString(dtStart));</span>
<span class="fc" id="L181">			strSQL.append(&quot;')&quot;);</span>
		}

<span class="pc bpc" id="L184" title="2 of 4 branches missed.">		if (workResourceIDs != null &amp;&amp; !workResourceIDs.isEmpty()) {</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">			if (strSQL.length() &gt; 0) {</span>
<span class="fc" id="L186">				strSQL.append(&quot; AND &quot;);</span>
			}
<span class="fc" id="L188">			strSQL.append(&quot; EXISTS &quot;);</span>
<span class="fc" id="L189">			strSQL.append(&quot; (SELECT ID FROM CALENDAREVENTTEMPLATEATTENDEE  &quot;);</span>
<span class="fc" id="L190">			strSQL.append(&quot; WHERE WORKRESOURCEID IN &quot;);</span>
<span class="fc" id="L191">			strSQL.append(m_dmo.createInClause(workResourceIDs));</span>
<span class="fc" id="L192">			strSQL.append(&quot; AND CALENDAREVENTTEMPLATEID = B.ID)&quot;);</span>
		}
<span class="fc" id="L194">		return strSQL;</span>
	}

	/**
	 * Returns a collection of collections of events of specified type(s) for
	 * multiple work resources.
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L204">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L205">			return getEventsFromTemplateCollection(getObjects(strSQL.toString()), workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L206">		} catch (JdmoException e) {</span>
<span class="nc" id="L207">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of collections of events of specified type(s) for
	 * multiple work resources.
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L217">		return getEventsFromTemplateCollection(getTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd),</span>
				workResourceIDs, dtStart, dtEnd);
	}

	/**
	 * Returns a collection of recurring event templates for multiple work
	 * resources as follows: a template will be returned if its active time
	 * window overlaps with the requested time window and it contains in its
	 * attendee list at least a single work resource out the requested
	 * collection of work resources
	 */
	public Collection&lt;RecurringEventTemplateBase&gt; getTemplatesForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
		try {
<span class="fc" id="L231">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L232">			return getObjects(strSQL.toString());</span>
<span class="nc" id="L233">		} catch (JdmoException e) {</span>
<span class="nc" id="L234">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * This is an internal helper function that is used by
	 * getEventsForWorkResources() flavors for instantiation of recurring events
	 * from templates and filtering of recurring events for specific
	 * workresources
	 */
	private Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsFromTemplateCollection(Collection&lt;RecurringEventTemplateBase&gt; listTemplates,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) {
		/**
		 * now go through this collection and construct the map keyed by
		 * workresource ID with values being the corresponding collection of
		 * events
		 */
<span class="fc" id="L251">		Map&lt;ID, List&lt;CalendarEventAssignment&gt;&gt; mapEmpIDToEvents = new HashMap&lt;ID, List&lt;CalendarEventAssignment&gt;&gt;();</span>
<span class="pc bpc" id="L252" title="1 of 2 branches missed.">		for (Iterator&lt;RecurringEventTemplateBase&gt; it = listTemplates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L253">			RecurringEventTemplateBase template = it.next();</span>
<span class="nc" id="L254">			Collection&lt;CalendarEventAssignment&gt; listEvents = template.getRecurringEvents(dtStart, dtEnd, workResourceIDs);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it2 = listEvents.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L256">				CalendarEventAssignment event = it2.next();</span>
				/**
				 * the getRecurringEvents method may return a single event
				 * instance with many attendees, whereas the contract of
				 * getEventsForWorkResources method with its clients is that
				 * there is a an event instance for each of the work resources
				 * specified, so we shall massage the return collection a little
				 * bit to return copies of the same event object for each work
				 * resource that has the event
				 */
<span class="nc bnc" id="L266" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it3 = event.getWorkResourceIDs().iterator(); it3.hasNext();) {</span>
<span class="nc" id="L267">					ID workResourceID = it3.next();</span>
<span class="nc" id="L268">					List&lt;CalendarEventAssignment&gt; empEvents = mapEmpIDToEvents.get(workResourceID);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">					if (empEvents == null) {</span>
<span class="nc" id="L270">						empEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc" id="L271">						mapEmpIDToEvents.put(workResourceID, empEvents);</span>
					}
<span class="nc" id="L273">					empEvents.add(event);</span>
<span class="nc" id="L274">				}</span>
<span class="nc" id="L275">			}</span>
<span class="nc" id="L276">		}</span>

<span class="fc" id="L278">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = new ArrayList&lt;Collection&lt;CalendarEventAssignment&gt;&gt;(workResourceIDs.size());</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L280">			ID empID = it.next();</span>
<span class="fc" id="L281">			listEvents.add(mapEmpIDToEvents.get(empID));</span>
<span class="fc" id="L282">		}</span>
<span class="fc" id="L283">		return listEvents;</span>
	}

	/**
	 * Returns a collection of unpublished events that are to be published
	 */
	Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsToBePublishedInPublishedPeriodsOnly(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L291">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

		/* find the published periods */
<span class="nc" id="L294">		PublishingPeriodDAO daoPubPrd = new PublishingPeriodDAO(m_dmo);</span>
<span class="nc" id="L295">		Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; listPeriods = daoPubPrd.getPublishedPeriods(workResourceIDs, dtStart, dtEnd);</span>

		/* filter out those events that fall outside the published periods */
<span class="nc" id="L298">		Iterator&lt;Collection&lt;CalendarEventAssignment&gt;&gt; itEvents = listEvents.iterator();</span>
<span class="nc" id="L299">		Iterator&lt;ID&gt; itWorkResource = workResourceIDs.iterator();</span>
<span class="nc" id="L300">		Iterator&lt;Collection&lt;PublishingPeriod&gt;&gt; itPeriod = listPeriods.iterator();</span>
<span class="nc bnc" id="L301" title="All 6 branches missed.">		while (itEvents.hasNext() &amp;&amp; itWorkResource.hasNext() &amp;&amp; itPeriod.hasNext()) {</span>
<span class="nc" id="L302">			ID workResourceID = itWorkResource.next();</span>
<span class="nc" id="L303">			Collection&lt;CalendarEventAssignment&gt; listWrkEvents = itEvents.next();</span>
<span class="nc" id="L304">			Collection&lt;PublishingPeriod&gt; listWrkPeriods = itPeriod.next();</span>
<span class="nc bnc" id="L305" title="All 4 branches missed.">			if (listWrkEvents == null || listWrkEvents.isEmpty()) {</span>
<span class="nc" id="L306">				continue;</span>
			}

<span class="nc bnc" id="L309" title="All 4 branches missed.">			if (listWrkPeriods == null || listWrkPeriods.isEmpty()) {</span>
				/*
				 * no published periods for this employee, hence there should be
				 * no events returned
				 */
<span class="nc" id="L314">				listWrkEvents.clear();</span>
<span class="nc" id="L315">				continue;</span>
			}

<span class="nc bnc" id="L318" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it2 = listWrkEvents.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L319">				Event event = it2.next();</span>
				/* does this event fall within the published periods ? */
<span class="nc" id="L321">				Date eventStart = event.getStartTime();</span>
<span class="nc" id="L322">				Date eventEnd = event.getEndTime();</span>
<span class="nc" id="L323">				boolean bEventOk = false;</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">				for (Iterator&lt;PublishingPeriod&gt; it3 = listWrkPeriods.iterator(); it3.hasNext();) {</span>
<span class="nc" id="L325">					PublishingPeriod period = it3.next();</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">					if (eventStart.before(period.getEndTime()) &amp;&amp; eventEnd.after(period.getStartTime())) {</span>
<span class="nc" id="L327">						bEventOk = true;</span>
<span class="nc" id="L328">						break;</span>
					}
<span class="nc" id="L330">				}</span>
<span class="nc bnc" id="L331" title="All 2 branches missed.">				if (!bEventOk) {</span>
<span class="nc" id="L332">					it2.remove();</span>
				}
<span class="nc" id="L334">			}</span>
<span class="nc" id="L335">		}</span>
<span class="nc" id="L336">		return listEvents;</span>
	}

	/**
	 * Creates a single exception to the recurring event template rule
	 */
	public Object createRecurringEventException(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate, int duration, Date instanceStart, Date floatingStart, Date floatingEnd)
			throws BbmCreateException {
		try {
			/**
			 * first, record the fact that we have an exception on this date for
			 * each of the work resources
			 */
<span class="nc" id="L350">			deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>

			/**
			 * secondly, create the actual CalendarEventAssignment record for
			 * this exception
			 */
<span class="nc" id="L356">			Calendar cal = Calendar.getInstance(recTemplate.getTimeZone());</span>
<span class="nc" id="L357">			cal.setTime(exceptionDate);</span>
<span class="nc" id="L358">			cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L359">			cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L360">			cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L361">			CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">			if (recTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>
<span class="nc" id="L363">				cal.set(Calendar.MINUTE, ((RecurringEventTemplate) recTemplate).getDayStartOffset());</span>
				/* create and persist the new event assignment */
<span class="nc" id="L365">				CalendarEventAssignment event = recTemplate.getEventInstance(cal.getTime(), workResourceIDs);</span>

<span class="nc" id="L367">				ID eventID = daoEvent.createObject(event);</span>
<span class="nc" id="L368">				return (CalendarEventAssignment) daoEvent.getObjectByID(eventID);</span>
<span class="nc bnc" id="L369" title="All 2 branches missed.">			} else if (recTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
				// cal.set(Calendar.MINUTE,
				// ((RecurringEventTemplate)recTemplate).getDayStartOffset());
<span class="nc" id="L372">				RecurringFloatingEventTemplate recFloTemplate = (RecurringFloatingEventTemplate) recTemplate;</span>
				/* create and persist the new floating event template exception */
<span class="nc" id="L374">				FloatingEventTemplate template = new FloatingEventTemplate();</span>
<span class="nc" id="L375">				template.setOverlapType(recFloTemplate.getOverlapType());</span>
<span class="nc" id="L376">				template.setWindowStartDate(floatingStart);</span>
<span class="nc" id="L377">				template.setWindowEndDate(floatingEnd);</span>
<span class="nc" id="L378">				template.setActivityID(recFloTemplate.getActivityID());</span>
<span class="nc" id="L379">				template.setDescription(recFloTemplate.getDescription());</span>
<span class="nc" id="L380">				template.setDuration(recFloTemplate.getDuration());</span>
<span class="nc" id="L381">				template.setOverlayPrecedence(recFloTemplate.getOverlayPrecedence());</span>
<span class="nc bnc" id="L382" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY1STARTOFFSET) != null) {</span>
<span class="nc" id="L383">					template.setWindowDayStartOffset(1, recFloTemplate.getDayStartOffset(1));</span>
				}
<span class="nc bnc" id="L385" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY1ENDOFFSET) != null) {</span>
<span class="nc" id="L386">					template.setWindowDayEndOffset(1, recFloTemplate.getDayEndOffset(1));</span>
				}
<span class="nc bnc" id="L388" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY2STARTOFFSET) != null) {</span>
<span class="nc" id="L389">					template.setWindowDayStartOffset(2, recFloTemplate.getDayStartOffset(2));</span>
				}
<span class="nc bnc" id="L391" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY2ENDOFFSET) != null) {</span>
<span class="nc" id="L392">					template.setWindowDayEndOffset(2, recFloTemplate.getDayEndOffset(2));</span>
				}
<span class="nc bnc" id="L394" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY3STARTOFFSET) != null) {</span>
<span class="nc" id="L395">					template.setWindowDayStartOffset(3, recFloTemplate.getDayStartOffset(3));</span>
				}
<span class="nc bnc" id="L397" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY3ENDOFFSET) != null) {</span>
<span class="nc" id="L398">					template.setWindowDayEndOffset(3, recFloTemplate.getDayEndOffset(3));</span>
				}
<span class="nc bnc" id="L400" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY4STARTOFFSET) != null) {</span>
<span class="nc" id="L401">					template.setWindowDayStartOffset(4, recFloTemplate.getDayStartOffset(4));</span>
				}
<span class="nc bnc" id="L403" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY4ENDOFFSET) != null) {</span>
<span class="nc" id="L404">					template.setWindowDayEndOffset(4, recFloTemplate.getDayEndOffset(4));</span>
				}
<span class="nc bnc" id="L406" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY5STARTOFFSET) != null) {</span>
<span class="nc" id="L407">					template.setWindowDayStartOffset(5, recFloTemplate.getDayStartOffset(5));</span>
				}
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY5ENDOFFSET) != null) {</span>
<span class="nc" id="L410">					template.setWindowDayEndOffset(5, recFloTemplate.getDayEndOffset(5));</span>
				}
<span class="nc bnc" id="L412" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY6STARTOFFSET) != null) {</span>
<span class="nc" id="L413">					template.setWindowDayStartOffset(6, recFloTemplate.getDayStartOffset(6));</span>
				}
<span class="nc bnc" id="L415" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY6ENDOFFSET) != null) {</span>
<span class="nc" id="L416">					template.setWindowDayEndOffset(6, recFloTemplate.getDayEndOffset(6));</span>
				}
<span class="nc bnc" id="L418" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY7STARTOFFSET) != null) {</span>
<span class="nc" id="L419">					template.setWindowDayStartOffset(7, recFloTemplate.getDayStartOffset(7));</span>
				}
<span class="nc bnc" id="L421" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY7ENDOFFSET) != null) {</span>
<span class="nc" id="L422">					template.setWindowDayEndOffset(7, recFloTemplate.getDayEndOffset(7));</span>
				}

<span class="nc" id="L425">				template.setTimeZone(recFloTemplate.getTimeZone());</span>
<span class="nc" id="L426">				template.setParentID(recFloTemplate.getID());</span>
<span class="nc" id="L427">				template.setIsException(true);</span>
<span class="nc bnc" id="L428" title="All 2 branches missed.">				if (duration &gt; 0)</span>
<span class="nc" id="L429">					template.setDuration(duration);</span>

				// template.setParentID(recFloTemplate.getID()); //new to
				// floating event template
				// shoud set event type here???
<span class="nc bnc" id="L434" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L435">					ID workResourceID = it.next();</span>
<span class="nc" id="L436">					template.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L437">				}</span>

<span class="nc" id="L439">				template.setInstanceStart(instanceStart);</span>
<span class="nc" id="L440">				FloatingEventTemplateDAO daoFloating = new FloatingEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L441">				ID templateID = daoFloating.createObject(template);</span>
<span class="nc" id="L442">				template = (FloatingEventTemplate) daoFloating.getObjectByID(templateID);</span>
<span class="nc" id="L443">				CalendarEventAssignment cea = (CalendarEventAssignment) (daoEvent.getObjectsByParentID(templateID)</span>
<span class="nc" id="L444">						.iterator().next());</span>
<span class="nc" id="L445">				cea.setDuration(duration);</span>
<span class="nc" id="L446">				daoEvent.updateObject(cea);</span>
<span class="nc" id="L447">				return template;</span>
			}
<span class="nc" id="L449">			return null;</span>
<span class="nc" id="L450">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L451">			throw new BbmCreateException(e);</span>
<span class="nc" id="L452">		} catch (Exception e) {</span>
<span class="nc" id="L453">			throw new BbmCreateException(e);</span>
		}
	}

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventInstance(ID templateID, Collection&lt;ID&gt; workResourceIDs, Date exceptionDate)
			throws BbmCreateException {
		try {
<span class="nc" id="L464">			RecurringEventTemplateBase recTemplate = (RecurringEventTemplateBase) getObjectByID(templateID);</span>

<span class="nc" id="L466">			deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>
<span class="nc" id="L467">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L468">			throw e;</span>
<span class="nc" id="L469">		} catch (Exception e) {</span>
<span class="nc" id="L470">			throw new BbmCreateException(e);</span>
<span class="nc" id="L471">		}</span>
<span class="nc" id="L472">	}</span>

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventInstance(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate) throws BbmCreateException {
		try {
<span class="nc" id="L481">			RecurringEventExceptionDAO daoException = new RecurringEventExceptionDAO(m_dmo);</span>

			/*
			 * first check which exceptions already exist so that we don't
			 * create duplicate records
			 */
<span class="nc" id="L487">			HashSet&lt;ID&gt; setExisting = daoException.getExceptionsOnDate(recTemplate.getID(), exceptionDate);</span>

<span class="nc bnc" id="L489" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L490">				ID workResourceID = it.next();</span>
<span class="nc bnc" id="L491" title="All 2 branches missed.">				if (!setExisting.contains(workResourceID)) {</span>
					/**
					 * first, record the fact that we have an exception on this
					 * date for each of the work resources
					 */
<span class="nc" id="L496">					RecurringEventException exception = new RecurringEventException();</span>
<span class="nc" id="L497">					exception.setWorkResourceID(workResourceID);</span>
<span class="nc" id="L498">					exception.setExceptionDate(exceptionDate);</span>
<span class="nc" id="L499">					exception.setParentID(recTemplate.getID());</span>
					/* create the record in batched mode */
<span class="nc" id="L501">					daoException.createObject(exception, true);</span>
				}
<span class="nc" id="L503">			}</span>

			/*
			 * since we created several records in batched mode, we'll need to
			 * execute the batch now
			 */
<span class="nc" id="L509">			m_dmo.executeBatch();</span>
<span class="nc" id="L510">		} catch (Exception e) {</span>
<span class="nc" id="L511">			throw new BbmCreateException(e);</span>
<span class="nc" id="L512">		}</span>
<span class="nc" id="L513">	}</span>

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventException(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate) throws BbmCreateException {
		try {
<span class="nc" id="L522">			RecurringEventExceptionDAO daoException = new RecurringEventExceptionDAO(m_dmo);</span>

			/*
			 * first check which exceptions already exist so that we don't
			 * create duplicate records
			 */
<span class="nc" id="L528">			HashSet&lt;ID&gt; setExisting = daoException.getExceptionsOnDate(recTemplate.getID(), exceptionDate);</span>

<span class="nc" id="L530">			Collection&lt;ID&gt; templateWorkResouces = recTemplate.getWorkResourceIDs();</span>

<span class="nc bnc" id="L532" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L533">				ID workResourceID = it.next();</span>
<span class="nc bnc" id="L534" title="All 4 branches missed.">				if (setExisting.contains(workResourceID) &amp;&amp; !templateWorkResouces.contains(workResourceID)) {</span>
<span class="nc" id="L535">					daoException.deleteRecurringException(workResourceID, recTemplate.getID(), exceptionDate);</span>
				}
<span class="nc" id="L537">			}</span>

			/*
			 * since we created several records in batched mode, we'll need to
			 * execute the batch now
			 */
<span class="nc" id="L543">			m_dmo.executeBatch();</span>

<span class="nc" id="L545">		} catch (Exception e) {</span>
<span class="nc" id="L546">			throw new BbmCreateException(e);</span>
<span class="nc" id="L547">		}</span>
<span class="nc" id="L548">	}</span>

	/**
	 * This is a helper method used by the getConflictsForScheduleObject method.
	 * It will delete all recurring event instances from a template with a given
	 * ID that overlap with a given set of events
	 */
	public void deleteOverlappingInstances(RecurringEventTemplateBase recTemplate, Collection&lt;? extends Event&gt; listEvents)
			throws BbmCreateException {
<span class="nc bnc" id="L557" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; itEvent = listEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L558">			Event event = itEvent.next();</span>
<span class="nc" id="L559">			deleteRecurringEventInstance(recTemplate, event.getWorkResourceIDs(), event.getStartTime());</span>
<span class="nc" id="L560">		}</span>
<span class="nc" id="L561">	}</span>

	/*
	 * This method is specifically defined for post migration, it returns the
	 * recurring event templates ordered by endtime desc. Since whenever we find
	 * overlapped recurring event template, we prefer to remove the one ending
	 * earlier.
	 */
	public Collection&lt;RecurringEventTemplateBase&gt; getAllEventTemplatesForWorkResourcesForPostMigration(
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="nc" id="L572">			return getObjects(getWhereClauseForGetEventTemplatesQuery(workResourceIDs, dtStart, dtEnd)</span>
					+ &quot; ORDER BY B.ENDDATE DESC &quot;);
<span class="nc" id="L574">		} catch (JdmoException e) {</span>
<span class="nc" id="L575">			throw new BbmFinderException(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>