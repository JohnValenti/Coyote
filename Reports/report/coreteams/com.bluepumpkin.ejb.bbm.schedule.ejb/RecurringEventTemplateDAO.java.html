<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>RecurringEventTemplateDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">RecurringEventTemplateDAO.java</span></div><h1>RecurringEventTemplateDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Recurring Event Template DAO class
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version      1.0
 */
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.FloatingEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventException;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateBase;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateFields;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringFloatingEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;

class RecurringEventTemplateDAO extends AggEventTemplateDAO&lt;RecurringEventTemplateBase&gt; implements ScheduleEventRetrieval&lt;CalendarEventAssignment&gt;,
		ScheduleConflictChecker&lt;RecurringEventTemplateBase&gt; {
	// meta data info.
<span class="fc" id="L46">	private static FieldInfo m_fieldInfo = new RecurringEventTemplateFields();</span>

	protected FieldInfo getFieldInfo() {
<span class="fc" id="L49">		return m_fieldInfo;</span>
	}

	public RecurringEventTemplateDAO() {
<span class="nc" id="L53">		super();</span>
<span class="nc" id="L54">	}</span>

	public RecurringEventTemplateDAO(Jdmo dmo) {
<span class="fc" id="L57">		super(dmo);</span>
<span class="fc" id="L58">	}</span>

	/**
	 * This is an override of the base class function to create an appropriate
	 * type of the value object based on the event template type that is stored
	 * in CALENDAREVENTTEMPLATE record
	 */
	protected RecurringEventTemplateBase createValueObject(JdmoRowset rs) throws Exception {
<span class="nc bnc" id="L66" title="All 3 branches missed.">		switch (rs.getInt(&quot;TEMPLATETYPE&quot;)) {</span>
		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING:
<span class="nc" id="L68">			return new RecurringEventTemplate();</span>

		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING:
<span class="nc" id="L71">			return new RecurringFloatingEventTemplate();</span>

		default:
			/* this should never happen, could log an error here */
<span class="nc" id="L75">			return null;</span>
		}
	}

	/** This is an override of the base class function */
	protected RecurringEventTemplateBase createValueObject() {
		/** this flavor of createValueObject will never be called */
<span class="nc" id="L82">		return null;</span>
	}

	/** override from base class */
	protected DAOBase createChildDAO(int iType) {
<span class="nc" id="L87">		return new RecurringEventExceptionDAO(m_dmo);</span>
	}

	/** This is an override of the base class */
	public ID createObject(RecurringEventTemplateBase objValue, boolean bBatched) throws BbmCreateException {
		/**
		 * if this is a recurring floating event template, then set the event
		 * type for event instances to CALENDAR_EVENT_ASSIGNMENT. Gal says time
		 * off events and/or unavailabilities may not be floating.
		 */
<span class="nc" id="L97">		RecurringEventTemplateBase eventTemplate = objValue;</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">		if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L99">			eventTemplate.getAggregatedTemplate().setEventType(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT);</span>
		}
<span class="nc" id="L101">		return super.createObject(eventTemplate, bBatched);</span>
	}

	/**
	 * Returns a collection of conflicts (schedule constraint violations) for a
	 * newly created recurring event template to make sure that the proposed
	 * change does not violate some constraint in the schedule. The returned
	 * collection contains objects of type BbmScheduleConflict. If there are no
	 * conflicts caused by the proposed change the returned collection will be
	 * empty.
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObject(RecurringEventTemplateBase obj) throws BbmFinderException {
<span class="nc" id="L113">		return getConflictsForScheduleObject(obj, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedScheduleObject(RecurringEventTemplateBase obj) throws BbmFinderException {
<span class="nc" id="L117">		return getConflictsForScheduleObject(obj, false);</span>
	}

	private Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(RecurringEventTemplateBase obj, boolean isNewObject)
			throws BbmFinderException {
<span class="nc" id="L122">		RecurringEventTemplateBase recTemplate = obj;</span>
<span class="nc bnc" id="L123" title="All 2 branches missed.">		if (isNewObject) {</span>
			try {
				// will be use later to check conflict.
<span class="nc" id="L126">				calcAndSetEventPrecedence(recTemplate);</span>
<span class="nc" id="L127">			} catch (Exception e) {</span>
<span class="nc" id="L128">				throw new BbmFinderException(e);</span>
<span class="nc" id="L129">			}</span>
		}

<span class="nc" id="L132">		ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO(m_dmo);</span>
<span class="nc" id="L133">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; listShifts = daoShift.getEventsForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L134">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>
<span class="nc" id="L135">		Collection&lt;ShiftAssignment&gt; shifts = ScheduleDAOUtil.getUniqueEvents(listShifts);</span>

<span class="nc" id="L137">		CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc" id="L138">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = daoEvent.getAttendingEventsForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L139">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>
<span class="nc" id="L140">		Collection&lt;CalendarEventAssignment&gt; events = ScheduleDAOUtil.getUniqueEvents(listEvents);</span>

<span class="nc" id="L142">		Collection&lt;RecurringEventTemplateBase&gt; templates = getTemplatesForWorkResources(recTemplate.getWorkResourceIDs(),</span>
<span class="nc" id="L143">				recTemplate.getEarliestPossibleStartTime(), recTemplate.getLatestPossibleEndTime());</span>

<span class="nc" id="L145">		Collection&lt;BbmScheduleConflict&gt; listConflicts = recTemplate.getConflictsForTemplate(isNewObject, shifts, events, templates);</span>

		/*
		 * the last step is to find the find all of the employee names for all
		 * of the conflicts returned from this method call
		 */
<span class="nc" id="L151">		ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>

<span class="nc" id="L153">		return listConflicts;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="fc" id="L162">		StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L163">		strSQL.append(&quot; AND (&quot;);</span>
		/*
		 * strSQL.append(m_dmo.bitwiseAND(&quot;EVENTTYPE&quot;,
		 * NumberFactory.newInteger(eventTypeBitMask)));
		 * strSQL.append(&quot; != 0)&quot;);
		 */
<span class="fc" id="L169">		strSQL.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask));</span>
<span class="fc" id="L170">		strSQL.append(&quot; )&quot;);</span>
<span class="fc" id="L171">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * event templates for a given set of work resources in a given time period
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {

		// Jason: since the end date is inclusive I need to look back a day
<span class="fc" id="L182">		dtStart = new Date(dtStart.getTime() - ShiftAssignment.MILLIS_IN_ONE_DAY);</span>

<span class="fc" id="L184">		StringBuffer strSQL = new StringBuffer(200);</span>
<span class="pc bpc" id="L185" title="1 of 2 branches missed.">		if (dtEnd != null) {</span>
<span class="fc" id="L186">			strSQL.append(&quot;B.STARTDATE &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="fc" id="L187">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="fc" id="L189">		strSQL.append(&quot;(B.ENDDATE IS NULL OR B.ENDDATE &gt; '&quot;);</span>
<span class="fc" id="L190">		strSQL.append(JdmoUtil.formatDBString(dtStart));</span>
<span class="fc" id="L191">		strSQL.append(&quot;') AND EXISTS &quot;);</span>
<span class="fc" id="L192">		strSQL.append(&quot; (SELECT ID FROM CALENDAREVENTTEMPLATEATTENDEE &quot;);</span>
<span class="fc" id="L193">		strSQL.append(&quot;  WHERE WORKRESOURCEID IN &quot;);</span>
<span class="fc" id="L194">		strSQL.append(m_dmo.createInClause(workResourceIDs));</span>
<span class="fc" id="L195">		strSQL.append(&quot;  AND CALENDAREVENTTEMPLATEID = B.ID)&quot;);</span>
<span class="fc" id="L196">		return strSQL;</span>
	}

	/**
	 * Returns a collection of collections of events of specified type(s) for
	 * multiple work resources.
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L206">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L207">			return getEventsFromTemplateCollection(getObjects(strSQL.toString()), workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L208">		} catch (JdmoException e) {</span>
<span class="nc" id="L209">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of collections of events of specified type(s) for
	 * multiple work resources.
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L219">		return getEventsFromTemplateCollection(getTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd),</span>
				workResourceIDs, dtStart, dtEnd);
	}

	/**
	 * Returns a collection of recurring event templates for multiple work
	 * resources as follows: a template will be returned if its active time
	 * window overlaps with the requested time window and it contains in its
	 * attendee list at least a single work resource out the requested
	 * collection of work resources
	 */
	public Collection&lt;RecurringEventTemplateBase&gt; getTemplatesForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
		try {
<span class="fc" id="L233">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L234">			return getObjects(strSQL.toString());</span>
<span class="nc" id="L235">		} catch (JdmoException e) {</span>
<span class="nc" id="L236">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * This is an internal helper function that is used by
	 * getEventsForWorkResources() flavors for instantiation of recurring events
	 * from templates and filtering of recurring events for specific
	 * workresources
	 */
	private Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsFromTemplateCollection(Collection&lt;RecurringEventTemplateBase&gt; listTemplates,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) {
		/**
		 * now go through this collection and construct the map keyed by
		 * workresource ID with values being the corresponding collection of
		 * events
		 */
<span class="fc" id="L253">		Map&lt;ID, List&lt;CalendarEventAssignment&gt;&gt; mapEmpIDToEvents = new HashMap&lt;ID, List&lt;CalendarEventAssignment&gt;&gt;();</span>
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">		for (Iterator&lt;RecurringEventTemplateBase&gt; it = listTemplates.iterator(); it.hasNext();) {</span>
<span class="nc" id="L255">			RecurringEventTemplateBase template = it.next();</span>
<span class="nc" id="L256">			Collection&lt;CalendarEventAssignment&gt; listEvents = template.getRecurringEvents(dtStart, dtEnd, workResourceIDs);</span>
<span class="nc bnc" id="L257" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it2 = listEvents.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L258">				CalendarEventAssignment event = it2.next();</span>
				/**
				 * the getRecurringEvents method may return a single event
				 * instance with many attendees, whereas the contract of
				 * getEventsForWorkResources method with its clients is that
				 * there is a an event instance for each of the work resources
				 * specified, so we shall massage the return collection a little
				 * bit to return copies of the same event object for each work
				 * resource that has the event
				 */
<span class="nc bnc" id="L268" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it3 = event.getWorkResourceIDs().iterator(); it3.hasNext();) {</span>
<span class="nc" id="L269">					ID workResourceID = it3.next();</span>
<span class="nc" id="L270">					List&lt;CalendarEventAssignment&gt; empEvents = mapEmpIDToEvents.get(workResourceID);</span>
<span class="nc bnc" id="L271" title="All 2 branches missed.">					if (empEvents == null) {</span>
<span class="nc" id="L272">						empEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>
<span class="nc" id="L273">						mapEmpIDToEvents.put(workResourceID, empEvents);</span>
					}
<span class="nc" id="L275">					empEvents.add(event);</span>
<span class="nc" id="L276">				}</span>
<span class="nc" id="L277">			}</span>
<span class="nc" id="L278">		}</span>

<span class="fc" id="L280">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = new ArrayList&lt;Collection&lt;CalendarEventAssignment&gt;&gt;(workResourceIDs.size());</span>
<span class="fc bfc" id="L281" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L282">			ID empID = it.next();</span>
<span class="fc" id="L283">			listEvents.add(mapEmpIDToEvents.get(empID));</span>
<span class="fc" id="L284">		}</span>
<span class="fc" id="L285">		return listEvents;</span>
	}

	/**
	 * Returns a collection of unpublished events that are to be published
	 */
	Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsToBePublishedInPublishedPeriodsOnly(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L293">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

		/* find the published periods */
<span class="nc" id="L296">		PublishingPeriodDAO daoPubPrd = new PublishingPeriodDAO(m_dmo);</span>
<span class="nc" id="L297">		Collection&lt;Collection&lt;PublishingPeriod&gt;&gt; listPeriods = daoPubPrd.getPublishedPeriods(workResourceIDs, dtStart, dtEnd);</span>

		/* filter out those events that fall outside the published periods */
<span class="nc" id="L300">		Iterator&lt;Collection&lt;CalendarEventAssignment&gt;&gt; itEvents = listEvents.iterator();</span>
<span class="nc" id="L301">		Iterator&lt;ID&gt; itWorkResource = workResourceIDs.iterator();</span>
<span class="nc" id="L302">		Iterator&lt;Collection&lt;PublishingPeriod&gt;&gt; itPeriod = listPeriods.iterator();</span>
<span class="nc bnc" id="L303" title="All 6 branches missed.">		while (itEvents.hasNext() &amp;&amp; itWorkResource.hasNext() &amp;&amp; itPeriod.hasNext()) {</span>
<span class="nc" id="L304">			ID workResourceID = itWorkResource.next();</span>
<span class="nc" id="L305">			Collection&lt;CalendarEventAssignment&gt; listWrkEvents = itEvents.next();</span>
<span class="nc" id="L306">			Collection&lt;PublishingPeriod&gt; listWrkPeriods = itPeriod.next();</span>
<span class="nc bnc" id="L307" title="All 4 branches missed.">			if (listWrkEvents == null || listWrkEvents.isEmpty()) {</span>
<span class="nc" id="L308">				continue;</span>
			}

<span class="nc bnc" id="L311" title="All 4 branches missed.">			if (listWrkPeriods == null || listWrkPeriods.isEmpty()) {</span>
				/*
				 * no published periods for this employee, hence there should be
				 * no events returned
				 */
<span class="nc" id="L316">				listWrkEvents.clear();</span>
<span class="nc" id="L317">				continue;</span>
			}

<span class="nc bnc" id="L320" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAssignment&gt; it2 = listWrkEvents.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L321">				Event event = it2.next();</span>
				/* does this event fall within the published periods ? */
<span class="nc" id="L323">				Date eventStart = event.getStartTime();</span>
<span class="nc" id="L324">				Date eventEnd = event.getEndTime();</span>
<span class="nc" id="L325">				boolean bEventOk = false;</span>
<span class="nc bnc" id="L326" title="All 2 branches missed.">				for (Iterator&lt;PublishingPeriod&gt; it3 = listWrkPeriods.iterator(); it3.hasNext();) {</span>
<span class="nc" id="L327">					PublishingPeriod period = it3.next();</span>
<span class="nc bnc" id="L328" title="All 4 branches missed.">					if (eventStart.before(period.getEndTime()) &amp;&amp; eventEnd.after(period.getStartTime())) {</span>
<span class="nc" id="L329">						bEventOk = true;</span>
<span class="nc" id="L330">						break;</span>
					}
<span class="nc" id="L332">				}</span>
<span class="nc bnc" id="L333" title="All 2 branches missed.">				if (!bEventOk) {</span>
<span class="nc" id="L334">					it2.remove();</span>
				}
<span class="nc" id="L336">			}</span>
<span class="nc" id="L337">		}</span>
<span class="nc" id="L338">		return listEvents;</span>
	}

	/**
	 * Creates a single exception to the recurring event template rule
	 */
	public Object createRecurringEventException(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate, int duration, Date instanceStart, Date floatingStart, Date floatingEnd)
			throws BbmCreateException {
		try {
			/**
			 * first, record the fact that we have an exception on this date for
			 * each of the work resources
			 */
<span class="nc" id="L352">			deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>

			/**
			 * secondly, create the actual CalendarEventAssignment record for
			 * this exception
			 */
<span class="nc" id="L358">			Calendar cal = Calendar.getInstance(recTemplate.getTimeZone());</span>
<span class="nc" id="L359">			cal.setTime(exceptionDate);</span>
<span class="nc" id="L360">			cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L361">			cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L362">			cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L363">			CalendarEventAssignmentDAO daoEvent = new CalendarEventAssignmentDAO(m_dmo);</span>
<span class="nc bnc" id="L364" title="All 2 branches missed.">			if (recTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>
<span class="nc" id="L365">				cal.set(Calendar.MINUTE, ((RecurringEventTemplate) recTemplate).getDayStartOffset());</span>
				/* create and persist the new event assignment */
<span class="nc" id="L367">				CalendarEventAssignment event = recTemplate.getEventInstance(cal.getTime(), workResourceIDs);</span>

<span class="nc" id="L369">				ID eventID = daoEvent.createObject(event);</span>
<span class="nc" id="L370">				return (CalendarEventAssignment) daoEvent.getObjectByID(eventID);</span>
<span class="nc bnc" id="L371" title="All 2 branches missed.">			} else if (recTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
				// cal.set(Calendar.MINUTE,
				// ((RecurringEventTemplate)recTemplate).getDayStartOffset());
<span class="nc" id="L374">				RecurringFloatingEventTemplate recFloTemplate = (RecurringFloatingEventTemplate) recTemplate;</span>
				/* create and persist the new floating event template exception */
<span class="nc" id="L376">				FloatingEventTemplate template = new FloatingEventTemplate();</span>
<span class="nc" id="L377">				template.setOverlapType(recFloTemplate.getOverlapType());</span>
<span class="nc" id="L378">				template.setWindowStartDate(floatingStart);</span>
<span class="nc" id="L379">				template.setWindowEndDate(floatingEnd);</span>
<span class="nc" id="L380">				template.setActivityID(recFloTemplate.getActivityID());</span>
<span class="nc" id="L381">				template.setDescription(recFloTemplate.getDescription());</span>
<span class="nc" id="L382">				template.setDuration(recFloTemplate.getDuration());</span>
<span class="nc" id="L383">				template.setOverlayPrecedence(recFloTemplate.getOverlayPrecedence());</span>
<span class="nc bnc" id="L384" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY1STARTOFFSET) != null) {</span>
<span class="nc" id="L385">					template.setWindowDayStartOffset(1, recFloTemplate.getDayStartOffset(1));</span>
				}
<span class="nc bnc" id="L387" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY1ENDOFFSET) != null) {</span>
<span class="nc" id="L388">					template.setWindowDayEndOffset(1, recFloTemplate.getDayEndOffset(1));</span>
				}
<span class="nc bnc" id="L390" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY2STARTOFFSET) != null) {</span>
<span class="nc" id="L391">					template.setWindowDayStartOffset(2, recFloTemplate.getDayStartOffset(2));</span>
				}
<span class="nc bnc" id="L393" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY2ENDOFFSET) != null) {</span>
<span class="nc" id="L394">					template.setWindowDayEndOffset(2, recFloTemplate.getDayEndOffset(2));</span>
				}
<span class="nc bnc" id="L396" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY3STARTOFFSET) != null) {</span>
<span class="nc" id="L397">					template.setWindowDayStartOffset(3, recFloTemplate.getDayStartOffset(3));</span>
				}
<span class="nc bnc" id="L399" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY3ENDOFFSET) != null) {</span>
<span class="nc" id="L400">					template.setWindowDayEndOffset(3, recFloTemplate.getDayEndOffset(3));</span>
				}
<span class="nc bnc" id="L402" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY4STARTOFFSET) != null) {</span>
<span class="nc" id="L403">					template.setWindowDayStartOffset(4, recFloTemplate.getDayStartOffset(4));</span>
				}
<span class="nc bnc" id="L405" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY4ENDOFFSET) != null) {</span>
<span class="nc" id="L406">					template.setWindowDayEndOffset(4, recFloTemplate.getDayEndOffset(4));</span>
				}
<span class="nc bnc" id="L408" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY5STARTOFFSET) != null) {</span>
<span class="nc" id="L409">					template.setWindowDayStartOffset(5, recFloTemplate.getDayStartOffset(5));</span>
				}
<span class="nc bnc" id="L411" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY5ENDOFFSET) != null) {</span>
<span class="nc" id="L412">					template.setWindowDayEndOffset(5, recFloTemplate.getDayEndOffset(5));</span>
				}
<span class="nc bnc" id="L414" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY6STARTOFFSET) != null) {</span>
<span class="nc" id="L415">					template.setWindowDayStartOffset(6, recFloTemplate.getDayStartOffset(6));</span>
				}
<span class="nc bnc" id="L417" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY6ENDOFFSET) != null) {</span>
<span class="nc" id="L418">					template.setWindowDayEndOffset(6, recFloTemplate.getDayEndOffset(6));</span>
				}
<span class="nc bnc" id="L420" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY7STARTOFFSET) != null) {</span>
<span class="nc" id="L421">					template.setWindowDayStartOffset(7, recFloTemplate.getDayStartOffset(7));</span>
				}
<span class="nc bnc" id="L423" title="All 2 branches missed.">				if (recFloTemplate.getFieldValue(RecurringEventTemplateFields.FLOATDAY7ENDOFFSET) != null) {</span>
<span class="nc" id="L424">					template.setWindowDayEndOffset(7, recFloTemplate.getDayEndOffset(7));</span>
				}

<span class="nc" id="L427">				template.setTimeZone(recFloTemplate.getTimeZone());</span>
<span class="nc" id="L428">				template.setParentID(recFloTemplate.getID());</span>
<span class="nc" id="L429">				template.setIsException(true);</span>
<span class="nc bnc" id="L430" title="All 2 branches missed.">				if (duration &gt; 0)</span>
<span class="nc" id="L431">					template.setDuration(duration);</span>

				// template.setParentID(recFloTemplate.getID()); //new to
				// floating event template
				// shoud set event type here???
<span class="nc bnc" id="L436" title="All 2 branches missed.">				for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L437">					ID workResourceID = it.next();</span>
<span class="nc" id="L438">					template.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L439">				}</span>

<span class="nc" id="L441">				template.setInstanceStart(instanceStart);</span>
<span class="nc" id="L442">				FloatingEventTemplateDAO daoFloating = new FloatingEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L443">				ID templateID = daoFloating.createObject(template);</span>
<span class="nc" id="L444">				template = (FloatingEventTemplate) daoFloating.getObjectByID(templateID);</span>
<span class="nc" id="L445">				CalendarEventAssignment cea = (CalendarEventAssignment) (daoEvent.getObjectsByParentID(templateID)</span>
<span class="nc" id="L446">						.iterator().next());</span>
<span class="nc" id="L447">				cea.setDuration(duration);</span>
<span class="nc" id="L448">				daoEvent.updateObject(cea);</span>
<span class="nc" id="L449">				return template;</span>
			}
<span class="nc" id="L451">			return null;</span>
<span class="nc" id="L452">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L453">			throw new BbmCreateException(e);</span>
<span class="nc" id="L454">		} catch (Exception e) {</span>
<span class="nc" id="L455">			throw new BbmCreateException(e);</span>
		}
	}

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventInstance(ID templateID, Collection&lt;ID&gt; workResourceIDs, Date exceptionDate)
			throws BbmCreateException {
		try {
<span class="nc" id="L466">			RecurringEventTemplateBase recTemplate = (RecurringEventTemplateBase) getObjectByID(templateID);</span>

<span class="nc" id="L468">			deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>
<span class="nc" id="L469">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L470">			throw e;</span>
<span class="nc" id="L471">		} catch (Exception e) {</span>
<span class="nc" id="L472">			throw new BbmCreateException(e);</span>
<span class="nc" id="L473">		}</span>
<span class="nc" id="L474">	}</span>

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventInstance(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate) throws BbmCreateException {
		try {
<span class="nc" id="L483">			RecurringEventExceptionDAO daoException = new RecurringEventExceptionDAO(m_dmo);</span>

			/*
			 * first check which exceptions already exist so that we don't
			 * create duplicate records
			 */
<span class="nc" id="L489">			HashSet&lt;ID&gt; setExisting = daoException.getExceptionsOnDate(recTemplate.getID(), exceptionDate);</span>

<span class="nc bnc" id="L491" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L492">				ID workResourceID = it.next();</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">				if (!setExisting.contains(workResourceID)) {</span>
					/**
					 * first, record the fact that we have an exception on this
					 * date for each of the work resources
					 */
<span class="nc" id="L498">					RecurringEventException exception = new RecurringEventException();</span>
<span class="nc" id="L499">					exception.setWorkResourceID(workResourceID);</span>
<span class="nc" id="L500">					exception.setExceptionDate(exceptionDate);</span>
<span class="nc" id="L501">					exception.setParentID(recTemplate.getID());</span>
					/* create the record in batched mode */
<span class="nc" id="L503">					daoException.createObject(exception, true);</span>
				}
<span class="nc" id="L505">			}</span>

			/*
			 * since we created several records in batched mode, we'll need to
			 * execute the batch now
			 */
<span class="nc" id="L511">			m_dmo.executeBatch();</span>
<span class="nc" id="L512">		} catch (Exception e) {</span>
<span class="nc" id="L513">			throw new BbmCreateException(e);</span>
<span class="nc" id="L514">		}</span>
<span class="nc" id="L515">	}</span>

	/**
	 * Removes a single recurring event instance from a recurring event template
	 * rule
	 */
	public void deleteRecurringEventException(RecurringEventTemplateBase recTemplate, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate) throws BbmCreateException {
		try {
<span class="nc" id="L524">			RecurringEventExceptionDAO daoException = new RecurringEventExceptionDAO(m_dmo);</span>

			/*
			 * first check which exceptions already exist so that we don't
			 * create duplicate records
			 */
<span class="nc" id="L530">			HashSet&lt;ID&gt; setExisting = daoException.getExceptionsOnDate(recTemplate.getID(), exceptionDate);</span>

<span class="nc" id="L532">			Collection&lt;ID&gt; templateWorkResouces = recTemplate.getWorkResourceIDs();</span>

<span class="nc bnc" id="L534" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L535">				ID workResourceID = it.next();</span>
<span class="nc bnc" id="L536" title="All 4 branches missed.">				if (setExisting.contains(workResourceID) &amp;&amp; !templateWorkResouces.contains(workResourceID)) {</span>
<span class="nc" id="L537">					daoException.deleteRecurringException(workResourceID, recTemplate.getID(), exceptionDate);</span>
				}
<span class="nc" id="L539">			}</span>

			/*
			 * since we created several records in batched mode, we'll need to
			 * execute the batch now
			 */
<span class="nc" id="L545">			m_dmo.executeBatch();</span>

<span class="nc" id="L547">		} catch (Exception e) {</span>
<span class="nc" id="L548">			throw new BbmCreateException(e);</span>
<span class="nc" id="L549">		}</span>
<span class="nc" id="L550">	}</span>

	/**
	 * This is a helper method used by the getConflictsForScheduleObject method.
	 * It will delete all recurring event instances from a template with a given
	 * ID that overlap with a given set of events
	 */
	public void deleteOverlappingInstances(RecurringEventTemplateBase recTemplate, Collection&lt;? extends Event&gt; listEvents)
			throws BbmCreateException {
<span class="nc bnc" id="L559" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; itEvent = listEvents.iterator(); itEvent.hasNext();) {</span>
<span class="nc" id="L560">			Event event = itEvent.next();</span>
<span class="nc" id="L561">			deleteRecurringEventInstance(recTemplate, event.getWorkResourceIDs(), event.getStartTime());</span>
<span class="nc" id="L562">		}</span>
<span class="nc" id="L563">	}</span>

	/*
	 * This method is specifically defined for post migration, it returns the
	 * recurring event templates ordered by endtime desc. Since whenever we find
	 * overlapped recurring event template, we prefer to remove the one ending
	 * earlier.
	 */
	public Collection&lt;RecurringEventTemplateBase&gt; getAllEventTemplatesForWorkResourcesForPostMigration(
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="nc" id="L574">			return getObjects(getWhereClauseForGetEventTemplatesQuery(workResourceIDs, dtStart, dtEnd)</span>
					+ &quot; ORDER BY B.ENDDATE DESC &quot;);
<span class="nc" id="L576">		} catch (JdmoException e) {</span>
<span class="nc" id="L577">			throw new BbmFinderException(e);</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>