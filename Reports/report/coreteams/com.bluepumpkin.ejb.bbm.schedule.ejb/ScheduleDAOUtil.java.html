<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleDAOUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">ScheduleDAOUtil.java</span></div><h1>ScheduleDAOUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  Utility methods shared by schedule-related DAO classes
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 **/
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodImpl;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictException;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictResolutions;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAttendee;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateBase;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeName;

<span class="nc" id="L44">public class ScheduleDAOUtil {</span>
	/**
	 * Takes a collection of work resource IDs and a array of collections of
	 * associated events and massages it in a way to return a collection that
	 * combines all types of events
	 *
	 * @param allEvents - Collection of a Collection of a Collection of Events.
	 *                   Innermost 1st collection: collection of {@link#Event} objects, all of the same type
	 *                   2nd collection: group of first collection, grouped by workResource
	 *                   3rd collection: group of second collection, grouped by Event type
	 *
	 * @return A List of Collections, each individual collection contains all of the events (of all types)
	 * associated to a particular work resource.  It is essentially a merging of all of the innermost collections
	 * of the given input allEvents (which contain collections separated by event type AND work resource), collects
	 * all of the events of different types for a work resource, and returns a combined collection of events of all
	 * types, one collection for each work resource.
	 */
	static &lt;T&gt; List&lt;Collection&lt;T&gt;&gt; combineEventCollections(Collection&lt;ID&gt; workResourceIDs,
			Collection&lt;Collection&lt;Collection&lt;T&gt;&gt;&gt; allEvents) {

<span class="fc" id="L64">		Map&lt;ID, Collection&lt;T&gt;&gt; mapWrkIDToEvents = new HashMap&lt;ID, Collection&lt;T&gt;&gt;();</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">		for (Collection&lt;Collection&lt;T&gt;&gt; subCollection : allEvents) {</span>
<span class="fc" id="L66">			Iterator&lt;ID&gt; itID = workResourceIDs.iterator();</span>
<span class="fc" id="L67">			Iterator&lt;Collection&lt;T&gt;&gt; itEvent = subCollection.iterator();</span>
<span class="pc bpc" id="L68" title="1 of 4 branches missed.">			while (itID.hasNext() &amp;&amp; itEvent.hasNext()) {</span>
<span class="fc" id="L69">				ID workResourceID = itID.next();</span>
<span class="fc" id="L70">				Collection&lt;T&gt; colEventsAlreadyInMap = mapWrkIDToEvents.get(workResourceID);</span>
<span class="fc" id="L71">				Collection&lt;T&gt; colNewEvents = itEvent.next();</span>

				Collection&lt;T&gt; colCombinedEvents;

<span class="pc bpc" id="L75" title="1 of 4 branches missed.">				if (colNewEvents != null &amp;&amp; colEventsAlreadyInMap != null) {</span>
<span class="nc" id="L76">					colCombinedEvents = colEventsAlreadyInMap;</span>
<span class="nc" id="L77">					colCombinedEvents.addAll(colNewEvents);</span>
<span class="fc bfc" id="L78" title="All 2 branches covered.">				} else if (colNewEvents != null) {</span>
<span class="fc" id="L79">					colCombinedEvents = colNewEvents;</span>
				} else {
<span class="fc" id="L81">					colCombinedEvents = colEventsAlreadyInMap;</span>
				}
<span class="fc" id="L83">				mapWrkIDToEvents.put(workResourceID, colCombinedEvents);</span>
<span class="fc" id="L84">			}</span>
<span class="fc" id="L85">		}</span>

<span class="fc" id="L87">		List&lt;Collection&lt;T&gt;&gt; listEvents = new ArrayList&lt;Collection&lt;T&gt;&gt;(workResourceIDs.size());</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L89">			ID empID = it.next();</span>
<span class="fc" id="L90">			listEvents.add(mapWrkIDToEvents.get(empID));</span>
<span class="fc" id="L91">		}</span>
<span class="fc" id="L92">		return listEvents;</span>
	}

	/**
	 * Takes a collection of events returned as a result of an SQL query, and a
	 * collection of work resource IDs and returns a collection where there is
	 * either a collection of events that correspond to each work resource ID
	 * given, or null, if the work resource has no events.
	 *
	 * @returns A collection of collection of events.  The innermost collection contains the set of events
	 * belonging to a particular work resource.
	 */
	public static &lt;T extends Event&gt; Collection&lt;Collection&lt;T&gt;&gt; groupEventsByWorkResources(Collection&lt;T&gt; listEvents,
			Collection&lt;ID&gt; workResourceIDs) {
<span class="pc bpc" id="L106" title="1 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.size() &lt;= 1) {</span>
			// no need to group
<span class="fc" id="L108">			Collection&lt;Collection&lt;T&gt;&gt; returnList = new ArrayList&lt;Collection&lt;T&gt;&gt;();</span>
<span class="fc" id="L109">			returnList.add(listEvents);</span>
<span class="fc" id="L110">			return returnList;</span>
		}
		/**
		 * now go through this collection and construct the map keyed by
		 * workresource ID with values being the corresponding collection of
		 * event assignments
		 */
<span class="fc" id="L117">		Map&lt;ID, List&lt;T&gt;&gt; mapWrkResIDToEvents = new HashMap&lt;ID, List&lt;T&gt;&gt;();</span>
<span class="fc bfc" id="L118" title="All 2 branches covered.">		for (Iterator&lt;T&gt; itEvent = listEvents.iterator(); itEvent.hasNext();) {</span>
<span class="fc" id="L119">			T event = itEvent.next();</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">			for (Iterator&lt;ID&gt; itWrk = event.getWorkResourceIDs().iterator(); itWrk.hasNext();) {</span>
<span class="fc" id="L121">				ID workResourceID = itWrk.next();</span>
<span class="fc" id="L122">				List&lt;T&gt; wrkEvents = mapWrkResIDToEvents.get(workResourceID);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">				if (wrkEvents == null) {</span>
<span class="fc" id="L124">					wrkEvents = new ArrayList&lt;T&gt;();</span>
<span class="fc" id="L125">					mapWrkResIDToEvents.put(workResourceID, wrkEvents);</span>
				}
<span class="fc" id="L127">				wrkEvents.add(event);</span>
<span class="fc" id="L128">			}</span>
<span class="fc" id="L129">		}</span>

<span class="fc" id="L131">		List&lt;Collection&lt;T&gt;&gt; returnList = new ArrayList&lt;Collection&lt;T&gt;&gt;();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="fc" id="L133">			ID workResourceID = it.next();</span>
<span class="fc" id="L134">			returnList.add(mapWrkResIDToEvents.get(workResourceID));</span>
<span class="fc" id="L135">		}</span>
<span class="fc" id="L136">		return returnList;</span>
	}

	/**
	 * Takes a collection of collection of events and &quot;flattens&quot; it into a a
	 * list that contains clones of each event in the original collection This
	 * utility method is used in publishing and reverting back to publishing
	 * schedules
	 */
	static &lt;T extends PlannedEvent&gt; Collection&lt;T&gt; cloneEventsForPublishing(Collection&lt;Collection&lt;T&gt;&gt; listEvents) {
		/*
		 * we don't want to publish the same event more than once, even if it
		 * has multiple work resources attending
		 */
<span class="fc" id="L150">		Set&lt;T&gt; setClonedEvents = new HashSet&lt;T&gt;();</span>

<span class="fc bfc" id="L152" title="All 2 branches covered.">		for (Iterator&lt;Collection&lt;T&gt;&gt; i = listEvents.iterator(); i.hasNext();) {</span>
<span class="fc" id="L153">			Collection&lt;T&gt; wrkEvents = i.next();</span>
<span class="pc bpc" id="L154" title="1 of 4 branches missed.">			if (wrkEvents != null &amp;&amp; !wrkEvents.isEmpty()) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">				for (Iterator&lt;T&gt; j = wrkEvents.iterator(); j.hasNext();) {</span>
<span class="fc" id="L156">					PlannedEvent cloneable = j.next();</span>
<span class="fc" id="L157">					setClonedEvents.add((T)cloneable.cloneForPublishing());	//TODO: refactor PlannedEvent.cloneForPublishing to return T</span>
<span class="fc" id="L158">				}</span>
			}
<span class="fc" id="L160">		}</span>
<span class="fc" id="L161">		return setClonedEvents;</span>
	}

	/**
	 * This helper method is used by the schedule conflict-checking DAO classes
	 * to help format the conflict messages with employee's names
	 */
	static void findEmployeeNames(Collection&lt;BbmScheduleConflict&gt; listConflicts) {
<span class="pc bpc" id="L169" title="2 of 4 branches missed.">		if (listConflicts == null || listConflicts.isEmpty()) {</span>
<span class="fc" id="L170">			return;</span>
		}

		/*
		 * first, find the list of all possible work resource IDs that we'll
		 * need to get names for
		 */
<span class="nc" id="L177">		Set&lt;ID&gt; setIDs = new HashSet&lt;ID&gt;();</span>

<span class="nc bnc" id="L179" title="All 2 branches missed.">		for (Iterator&lt;BbmScheduleConflict&gt; it = listConflicts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L180">			BbmScheduleConflict conflict = it.next();</span>
<span class="nc" id="L181">			Collection&lt;ID&gt; workResourceIDs = conflict.getWorkResourceIDs();</span>
<span class="nc bnc" id="L182" title="All 2 branches missed.">			if (workResourceIDs != null) {</span>
<span class="nc" id="L183">				setIDs.addAll(workResourceIDs);</span>
			}
<span class="nc" id="L185">		}</span>

<span class="nc bnc" id="L187" title="All 2 branches missed.">		if (!setIDs.isEmpty()) {</span>
			/* now find the names of the employees with corresponding IDs */
<span class="nc" id="L189">			Map&lt;ID, EmployeeName&gt; mapNames = null;</span>
<span class="nc" id="L190">			CachePerEJBMethod cache = CachePerEJBMethod.getCache();</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">			if ( cache != null) {</span>
<span class="nc" id="L192">				mapNames = cache.getEmployeeNames(setIDs);</span>
			} else {
				try {
<span class="nc" id="L195">					Set&lt;ID&gt; workResourseIDs = new HashSet&lt;ID&gt;();</span>

<span class="nc bnc" id="L197" title="All 2 branches missed.">					for (Iterator&lt;ID&gt; it = setIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L198">						ID workResourceID = it.next();</span>
<span class="nc" id="L199">						workResourseIDs.add(workResourceID);</span>
<span class="nc" id="L200">					}</span>
					
<span class="nc" id="L202">					WorkResourceManager wrmanager = BbmManagerFactory.getWorkResourceManager(false);</span>
<span class="nc" id="L203">					mapNames = wrmanager.getWorkResourceNamesByIDs(workResourseIDs);</span>
<span class="nc" id="L204">				} catch (Exception e) {</span>
<span class="nc" id="L205">					mapNames = new HashMap&lt;ID, EmployeeName&gt;();</span>
<span class="nc" id="L206">				}</span>
			}

			/*
			 * finally, go through the conflicts collection and initialize the
			 * employee name for each conflict
			 */
<span class="nc bnc" id="L213" title="All 2 branches missed.">			for (Iterator&lt;BbmScheduleConflict&gt; it = listConflicts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L214">				BbmScheduleConflict conflict = it.next();</span>
<span class="nc" id="L215">				Collection&lt;ID&gt; workResourceIDs = conflict.getWorkResourceIDs();</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">				if (workResourceIDs != null) {</span>
<span class="nc" id="L217">					ArrayList&lt;EmployeeName&gt; listNames = new ArrayList&lt;EmployeeName&gt;(workResourceIDs.size());</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">					for (Iterator&lt;ID&gt; it2 = workResourceIDs.iterator(); it2.hasNext();) {</span>
<span class="nc" id="L219">						ID workResourceID = it2.next();</span>
<span class="nc" id="L220">						listNames.add(mapNames.get(workResourceID));</span>
<span class="nc" id="L221">					}</span>
<span class="nc" id="L222">					conflict.setEmployeeNames(listNames);</span>
				}
<span class="nc" id="L224">			}</span>
		}
<span class="nc" id="L226">	}</span>

	// ///////////////////// DK start /////////////////////
	/**
	 * Takes a collection of work resource IDs and two collections of associated
	 * templates and massages it in a way to return a collection that combines
	 * all types of templates. Returns ArrayList of ArrayLists ordered the same
	 * order as workResourceIDs is
	 */
	static List&lt;Collection&lt;? extends CalendarEventTemplate&gt;&gt; combineTemplateCollections(Collection&lt;ID&gt; workResourceIDs,
			Collection&lt;? extends CalendarEventTemplate&gt; t1, Collection&lt;? extends CalendarEventTemplate&gt; t2)
					throws BbmFinderException {
<span class="fc" id="L238">		Map&lt;ID, Collection&lt;CalendarEventTemplate&gt;&gt; map = new HashMap&lt;ID, Collection&lt;CalendarEventTemplate&gt;&gt;(); // wrkID -&gt; EventTemplate</span>
<span class="fc" id="L239">		List&lt;Collection&lt;? extends CalendarEventTemplate&gt;&gt; result =</span>
<span class="fc" id="L240">				new ArrayList&lt;Collection&lt;? extends CalendarEventTemplate&gt;&gt;(workResourceIDs.size());</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">		for (Iterator&lt;ID&gt; itWrk = workResourceIDs.iterator(); itWrk.hasNext();) {</span>
<span class="fc" id="L242">			ID workResourceID = itWrk.next();</span>
<span class="fc" id="L243">			List&lt;CalendarEventTemplate&gt; al = new ArrayList&lt;CalendarEventTemplate&gt;(); // may be, will stay empty</span>
<span class="fc" id="L244">			result.add(al);</span>
<span class="fc" id="L245">			map.put(workResourceID, al);</span>
<span class="fc" id="L246">		}</span>
<span class="fc" id="L247">		addTemplateCollectionToMap(map, t1);</span>
<span class="fc" id="L248">		addTemplateCollectionToMap(map, t2);</span>
<span class="fc" id="L249">		return result;</span>
	}

	private static void addTemplateCollectionToMap(Map&lt;ID, Collection&lt;CalendarEventTemplate&gt;&gt; map,
			Collection&lt;? extends CalendarEventTemplate&gt; tt) throws BbmFinderException {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">		for (Iterator&lt;? extends CalendarEventTemplate&gt; iTempl = tt.iterator(); iTempl.hasNext();) {// each template from the collection</span>
<span class="nc" id="L255">			CalendarEventTemplate ob = iTempl.next();</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">			if (!(ob instanceof CalendarEventTemplate)) {</span>
<span class="nc" id="L257">				throw new BbmFinderException(BbmEjbBundleKey.SCHEDULE_EVENT_TEMPLATE_INVALID, null);</span>
			}
			// iterate all attendees of the template
<span class="nc" id="L260">			CalendarEventTemplate te = ob;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			for (Iterator&lt;ID&gt; itWrk = te.getWorkResourceIDs().iterator(); itWrk.hasNext();) {</span>
<span class="nc" id="L262">				ID workResourceID = itWrk.next();</span>
<span class="nc" id="L263">				Collection&lt;CalendarEventTemplate&gt; al = map.get(workResourceID);</span>
<span class="nc bnc" id="L264" title="All 2 branches missed.">				if (al != null) {</span>
<span class="nc" id="L265">					al.add(te); // I hope, the same template will not be met for the same wrkId twice</span>
				}
<span class="nc" id="L267">			}</span>
<span class="nc" id="L268">		}</span>
<span class="fc" id="L269">	}</span>

	/**
	 * Takes a collection of EventTemplate IDs and a collection of associated
	 * CalendarEventAssignments and reorders it in a same order as
	 * cidEventTemplates goes
	 */
	static List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; reorderEventsByTemplateIds(Collection&lt;ID&gt; cidEventTemplates,
			Collection&lt;CalendarEventAssignment&gt; t) {
<span class="nc" id="L278">		Map&lt;ID, List&lt;CalendarEventAssignment&gt;&gt; map = new HashMap&lt;ID, List&lt;CalendarEventAssignment&gt;&gt;(); // wrkID -&gt; EventTemplate</span>
<span class="nc" id="L279">		List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; result = new ArrayList&lt;Collection&lt;CalendarEventAssignment&gt;&gt;(</span>
<span class="nc" id="L280">				cidEventTemplates.size());</span>
<span class="nc bnc" id="L281" title="All 2 branches missed.">		for (Iterator&lt;ID&gt; itEvTemplId = cidEventTemplates.iterator(); itEvTemplId.hasNext();) {</span>
<span class="nc" id="L282">			ID evTemplId = itEvTemplId.next();</span>
<span class="nc" id="L283">			List&lt;CalendarEventAssignment&gt; al = new ArrayList&lt;CalendarEventAssignment&gt;(); // maybe, will stay empty</span>
<span class="nc" id="L284">			result.add(al);</span>
<span class="nc" id="L285">			map.put(evTemplId, al);</span>
<span class="nc" id="L286">		}</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; itCEA = t.iterator(); itCEA.hasNext();) {// each CalendarEventAssignment from the collection</span>
			// This defensive code is because calling code is casting
			// dao.getObjects(strSQL.toString())
			// to Collection&lt;CalendarEventAssignment&gt; so in theory it could be
			// exercised.
<span class="nc" id="L292">			Object ob = itCEA.next();</span>
<span class="nc" id="L293">			CalendarEventAssignment cea = (CalendarEventAssignment) ob;</span>
<span class="nc" id="L294">			ID etID = cea.getEventTemplateID();</span>
<span class="nc" id="L295">			List&lt;CalendarEventAssignment&gt; al = map.get(etID);</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">			if (al != null) {</span>
<span class="nc" id="L297">				al.add(cea); // the same calendar event assignment will not be met twice</span>
			}
<span class="nc" id="L299">		}</span>
<span class="nc" id="L300">		return result;</span>
	}

	/**
	 * This method only check if all the conflicts have resolutions. Client side
	 * should make sure the resolution can work well with the specific conflict
	 * type.
	 * 
	 * @author ayu
	 *
	 *         To change the template for this generated type comment go to
	 *         Window - Preferences - Java - Code Generation - Code and Comments
	 */
	static boolean areConflictsResolvable(Collection&lt;BbmScheduleConflict&gt; conflicts,
			BbmScheduleConflictResolutions resolutions) {
<span class="nc" id="L315">		BbmScheduleConflict conflict = null;</span>
<span class="nc" id="L316">		int[] validResolutions = null;</span>
<span class="nc" id="L317">		int resolution = -1;</span>
<span class="nc bnc" id="L318" title="All 2 branches missed.">		for (Iterator&lt;BbmScheduleConflict&gt; i = conflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L319">			conflict = i.next();</span>
<span class="nc" id="L320">			validResolutions = conflict.getResolutions();</span>
<span class="nc" id="L321">			resolution = resolutions.getResolution(conflict.getConflictType());</span>
<span class="nc bnc" id="L322" title="All 2 branches missed.">			if (isInList(validResolutions, resolution)) {</span>
<span class="nc" id="L323">				continue;</span>
			} else {
<span class="nc" id="L325">				return false;</span>
			}
		}
<span class="nc" id="L328">		return true;</span>
	}

	private static boolean isInList(int[] list, int item) {
<span class="nc bnc" id="L332" title="All 4 branches missed.">		if (list == null || list.length == 0) {</span>
<span class="nc" id="L333">			return false;</span>
		}
<span class="nc bnc" id="L335" title="All 2 branches missed.">		for (int ix = 0; ix &lt; list.length; ix++) {</span>
<span class="nc bnc" id="L336" title="All 2 branches missed.">			if (list[ix] == item) {</span>
<span class="nc" id="L337">				return true;</span>
			}
		}
<span class="nc" id="L340">		return false;</span>
	}

	/**
	 * Currently only recurring overlap calender event or shift assignment can
	 * be resolved
	 * 
	 * the whole purpose of valueObj parameter is for passing template id for
	 * removing one instance of newly created template. Since the event object
	 * in BbmScheduleConflict does not have id set.
	 * 
	 * @param conflicts
	 * @param resolutions
	 */
	static void resolveConflicts(Collection&lt;BbmScheduleConflict&gt; conflicts, BbmScheduleConflictResolutions resolutions)
			throws BbmScheduleConflictException, BbmRemoveException, BbmCreateException, BbmFinderException {
<span class="nc" id="L356">		BbmScheduleConflict conflict = null;</span>
<span class="nc" id="L357">		int conflictType = 0;</span>
<span class="nc bnc" id="L358" title="All 2 branches missed.">		for (Iterator&lt;BbmScheduleConflict&gt; i = conflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L359">			conflict = i.next();</span>
<span class="nc" id="L360">			conflictType = conflict.getConflictType();</span>
<span class="nc" id="L361">			int resolution = resolutions.getResolution(conflictType);</span>
<span class="nc bnc" id="L362" title="All 9 branches missed.">			switch (conflictType) {</span>
			case BbmScheduleConflict.CONFLICT_OVERLAP_SHIFT:
<span class="nc" id="L364">				throw new BbmScheduleConflictException(conflicts);</span>
			case BbmScheduleConflict.CONFLICT_MULTIPLE_SHIFTS_ON_SINGLE_DAY:
<span class="nc" id="L366">				throw new BbmScheduleConflictException(conflicts);</span>
			case BbmScheduleConflict.CONFLICT_OVERLAP_SHIFT_EVENT:
<span class="nc" id="L368">				throw new BbmScheduleConflictException(conflicts);</span>
			case BbmScheduleConflict.CONFLICT_OVERLAP_RECURRING:
<span class="nc" id="L370">				throw new BbmScheduleConflictException(conflicts);</span>
			case BbmScheduleConflict.CONFLICT_OVERLAP_EVENT:
<span class="nc bnc" id="L372" title="All 2 branches missed.">				if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT) {</span>
<span class="nc" id="L373">					removeCalendarEvent(conflict, conflicts);</span>
				} else {
					// wrong resolution.
<span class="nc" id="L376">					throw new BbmScheduleConflictException(conflicts);</span>
				}
				break;
			case BbmScheduleConflict.CONFLICT_SHIFT_OVERLAP_EVENT:
				// for this conflict specificly,
				// shift is always top and event is alway bottom in conflict
				// object
<span class="nc bnc" id="L383" title="All 2 branches missed.">				if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_SHIFT) {</span>
<span class="nc" id="L384">					removeShiftAssignment(conflict, conflicts);</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">				} else if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT) {</span>
<span class="nc" id="L386">					removeCalendarEvent(conflict, conflicts);</span>
				} else {
					// wrong resolution.
<span class="nc" id="L389">					throw new BbmScheduleConflictException(conflicts);</span>
				}
				break;
			case BbmScheduleConflict.CONFLICT_RECURRING_OVERLAP_EVENT:
<span class="nc bnc" id="L393" title="All 2 branches missed.">				if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_RECURRINGINSTANCE) {</span>
<span class="nc" id="L394">					RecurringEventTemplateBase template = conflict.getRecurringTemplate();</span>
<span class="nc" id="L395">					CalendarEventAssignment cea = conflict.getCalendarEvent();</span>
<span class="nc bnc" id="L396" title="All 4 branches missed.">					if (template == null || cea == null) {</span>
						// wrong resolution.
<span class="nc" id="L398">						throw new BbmScheduleConflictException(conflicts);</span>
					}
<span class="nc" id="L400">					removeRecurringInstance(template, cea);</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">				} else if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_CALENDAREVENT) {</span>
<span class="nc" id="L402">					removeCalendarEvent(conflict, conflicts);</span>
				} else {
					// wrong resolution.
<span class="nc" id="L405">					throw new BbmScheduleConflictException(conflicts);</span>
				}
				break;
			case BbmScheduleConflict.CONFLICT_RECURRING_OVERLAP_SHIFT:
<span class="nc bnc" id="L409" title="All 2 branches missed.">				if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_RECURRINGINSTANCE) {</span>
<span class="nc" id="L410">					RecurringEventTemplateBase template = conflict.getRecurringTemplate();</span>
<span class="nc" id="L411">					ShiftAssignment shift = conflict.getShiftAssignment();</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">					if (template == null || shift == null) {</span>
						// wrong resolution.
<span class="nc" id="L414">						throw new BbmScheduleConflictException(conflicts);</span>
					}
<span class="nc" id="L416">					removeRecurringInstance(template, shift);</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">				} else if (resolution == BbmScheduleConflictResolutions.RESOLUTION_REMOVE_SHIFT) {</span>
<span class="nc" id="L418">					removeShiftAssignment(conflict, conflicts);</span>
				} else {
					// wrong resolution.
<span class="nc" id="L421">					throw new BbmScheduleConflictException(conflicts);</span>
				}
				break;
			}
<span class="nc" id="L425">		}</span>
<span class="nc" id="L426">	}</span>

	private static void removeCalendarEvent(BbmScheduleConflict conflict, Collection&lt;BbmScheduleConflict&gt; conflicts)
			throws BbmScheduleConflictException, BbmRemoveException {
<span class="nc" id="L430">		CalendarEventAssignment event = conflict.getCalendarEvent();</span>
<span class="nc bnc" id="L431" title="All 2 branches missed.">		if (event == null) {</span>
			// event is not on bottom. wrong resolution.
<span class="nc" id="L433">			throw new BbmScheduleConflictException(conflicts);</span>
		}
		// just in case, the DE client wants server to remove the
		// newly created or updated event
<span class="nc" id="L437">		ID eventID = event.getID();</span>
<span class="nc bnc" id="L438" title="All 4 branches missed.">		if (eventID == null || eventID.toInt() &lt;= 0) {</span>
<span class="nc" id="L439">			return;</span>
		}
<span class="nc" id="L441">		CalendarEventAssignmentDAO daoCEA = new CalendarEventAssignmentDAO();</span>
<span class="nc" id="L442">		daoCEA.deleteObject(event.getID());</span>
<span class="nc" id="L443">		return;</span>
	}

	private static void removeShiftAssignment(BbmScheduleConflict conflict, Collection&lt;BbmScheduleConflict&gt; conflicts)
			throws BbmScheduleConflictException, BbmRemoveException {
<span class="nc" id="L448">		ShiftAssignment shift = conflict.getShiftAssignment();</span>
<span class="nc bnc" id="L449" title="All 2 branches missed.">		if (shift == null) {</span>
			// shift is not on bottom. wrong resolution.
<span class="nc" id="L451">			throw new BbmScheduleConflictException(conflicts);</span>
		}
		// just in case, the DE client wants server to remove
		// the newly created or updated event.
<span class="nc" id="L455">		ID shiftID = shift.getID();</span>
<span class="nc bnc" id="L456" title="All 4 branches missed.">		if (shiftID == null || shiftID.toInt() &lt;= 0) {</span>
<span class="nc" id="L457">			return;</span>
		}
<span class="nc" id="L459">		ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO();</span>
<span class="nc" id="L460">		daoShift.deleteObject(shift.getID());</span>
<span class="nc" id="L461">		return;</span>
	}

	private static void removeRecurringInstance(RecurringEventTemplateBase template, Event event)
			throws BbmCreateException, BbmRemoveException {
<span class="nc" id="L466">		Collection&lt;CalendarEventAssignment&gt; overlappingInstances = template.whichInstancesOverlapWithEvent(event);</span>
		// whichInstancesOverlapWithEvent will return the instance with all the
		// attendees
		// but we should only create a hole for the attendees who has event
		// overlapped
<span class="nc" id="L471">		keepAttendeesHavingOverlap(overlappingInstances, event);</span>
<span class="nc" id="L472">		RecurringEventTemplateDAO daoRecur = new RecurringEventTemplateDAO();</span>
<span class="nc" id="L473">		daoRecur.deleteOverlappingInstances(template, overlappingInstances);</span>
<span class="nc" id="L474">		return;</span>
	}

	private static void keepAttendeesHavingOverlap(Collection&lt;CalendarEventAssignment&gt; instances, Event event) {
<span class="nc" id="L478">		CalendarEventAssignment calEvent = null;</span>
<span class="nc" id="L479">		Collection&lt;CalendarEventAttendee&gt; attendees = null;</span>
<span class="nc" id="L480">		Collection&lt;ID&gt; keptAttendees = event.getWorkResourceIDs();</span>
<span class="nc bnc" id="L481" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; i = instances.iterator(); i.hasNext();) {</span>
<span class="nc" id="L482">			calEvent = i.next();</span>
<span class="nc" id="L483">			attendees = calEvent.getCreatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L484" title="All 2 branches missed.">			for (Iterator&lt;CalendarEventAttendee&gt; ix = attendees.iterator(); ix.hasNext();) {</span>
<span class="nc" id="L485">				CalendarEventAttendee att = ix.next();</span>
<span class="nc bnc" id="L486" title="All 2 branches missed.">				if (keptAttendees.contains(att.getWorkResourceID())) {</span>
<span class="nc" id="L487">					continue;</span>
				} else {
<span class="nc" id="L489">					ix.remove();</span>
				}
<span class="nc" id="L491">			}</span>
		}
<span class="nc" id="L493">	}</span>

	// For QA 35812
	/*
	 * This method combines events for all work resources into single flat
	 * collection
	 */
	static &lt;T&gt; Set&lt;T&gt; getUniqueEvents(Collection&lt;Collection&lt;T&gt;&gt; listEvents) {

<span class="fc" id="L502">		Set&lt;T&gt; eventSet = new HashSet&lt;T&gt;();</span>

		// Iterate over the list events (list events is collection of collection
		// objects
		// which correspond to work resources)
<span class="fc bfc" id="L507" title="All 2 branches covered.">		for (Iterator&lt;Collection&lt;T&gt;&gt; i = listEvents.iterator(); i.hasNext();) {</span>
<span class="fc" id="L508">			Collection&lt;T&gt; wrkEvents = i.next();</span>
<span class="pc bpc" id="L509" title="3 of 4 branches missed.">			if (wrkEvents != null &amp;&amp; !wrkEvents.isEmpty()) {</span>
<span class="nc bnc" id="L510" title="All 2 branches missed.">				for (Iterator&lt;T&gt; j = wrkEvents.iterator(); j.hasNext();) {</span>
<span class="nc" id="L511">					T event = j.next();</span>
<span class="nc bnc" id="L512" title="All 2 branches missed.">					if (event != null) {</span>
<span class="nc" id="L513">						eventSet.add(event);</span>
					}
<span class="nc" id="L515">				}</span>
			}
<span class="fc" id="L517">		}</span>
<span class="fc" id="L518">		return eventSet;</span>
	}

	// QA 38793: Silk 80826 To filter the shifts after termination date
	/**
	 * Filters the event list based on the employee end date
	 */
	protected static &lt;T extends Event&gt; Collection&lt;Collection&lt;T&gt;&gt; filterShiftsByEmpEndDate(
			Collection&lt;Collection&lt;T&gt;&gt; listEvents, Collection&lt;ID&gt; workResources, Map&lt;ID, Date&gt; terminatedWRKS) {
		// Iterate over the initial work resource list
<span class="nc" id="L528">		Iterator&lt;ID&gt; wrkIt = workResources.iterator();</span>
		// Iterate over the List Events corresponding to every work resource
<span class="nc bnc" id="L530" title="All 4 branches missed.">		for (Iterator&lt;Collection&lt;T&gt;&gt; it = listEvents.iterator(); it.hasNext() &amp;&amp; wrkIt.hasNext();) {</span>
<span class="nc" id="L531">			Collection&lt;T&gt; events = it.next();</span>
<span class="nc" id="L532">			ID wrkResourceID = wrkIt.next();</span>
			// if wrkresource id is same as the terminated wrks, remove all the
			// events after the end time
<span class="nc bnc" id="L535" title="All 6 branches missed.">			if (terminatedWRKS.get(wrkResourceID) != null &amp;&amp; events != null &amp;&amp; !events.isEmpty()) {</span>
<span class="nc" id="L536">				Date termTime = terminatedWRKS.get(wrkResourceID);</span>
<span class="nc bnc" id="L537" title="All 2 branches missed.">				for (Iterator&lt;T&gt; eventIt = events.iterator(); eventIt.hasNext();) {</span>
<span class="nc" id="L538">					T event = eventIt.next();</span>
<span class="nc bnc" id="L539" title="All 4 branches missed.">					if (event != null &amp;&amp; event.getStartTime().compareTo(termTime) &gt; 0) {</span>
<span class="nc" id="L540">						eventIt.remove();</span>
					}
<span class="nc" id="L542">				}</span>
			}
<span class="nc" id="L544">		}</span>

<span class="nc" id="L546">		return listEvents;</span>
	}

	public static &lt;T extends Event&gt; TimePeriod getTimePeriod(Collection&lt;T&gt; eventList) {
<span class="nc" id="L550">		Collections.sort(new ArrayList(eventList));		//FIXME: This line seems unnecessary</span>
<span class="nc" id="L551">		Iterator&lt;T&gt; i = eventList.iterator();</span>
<span class="nc" id="L552">		T firstEvent = i.next();</span>
<span class="nc" id="L553">		T lastEvent = firstEvent;</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">		for (; i.hasNext();) {</span>
<span class="nc" id="L555">			lastEvent = i.next();</span>
		}
<span class="nc" id="L557">		return new TimePeriodImpl(firstEvent.getStartTime(), lastEvent.getEndTime());</span>
	}

	/**
	 * Find the overlapping events with the start/end time
	 * @param events events list
	 * @param start start time for the overlap
	 * @param end end time for the overlap event
	 * @param &lt;T&gt;
	 * @return list of Events overlapping
	 */
	public static &lt;T extends Event&gt; Collection&lt;T&gt; findOverlap(Collection&lt;T&gt; events, Date start, Date end) {
<span class="nc" id="L569">		T event = null;</span>
<span class="nc" id="L570">		List&lt;T&gt; overlaps = new ArrayList&lt;T&gt;();</span>
<span class="nc bnc" id="L571" title="All 2 branches missed.">		for (Iterator&lt;T&gt; i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L572">			event = i.next();</span>
<span class="nc bnc" id="L573" title="All 4 branches missed.">			if (event.getStartTime().before(end) &amp;&amp; event.getEndTime().after(start)) {</span>
<span class="nc" id="L574">				overlaps.add(event);</span>
			}
		}
<span class="nc" id="L577">		return overlaps;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>