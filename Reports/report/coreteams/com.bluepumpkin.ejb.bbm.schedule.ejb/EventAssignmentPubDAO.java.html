<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>EventAssignmentPubDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">EventAssignmentPubDAO.java</span></div><h1>EventAssignmentPubDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  An abstact extension of EventAssignmentDAO class to be derived
 *               from by published event assignment DAO classes
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Greg Fichtenholtz
 * @version 1.0
 */
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.PlannedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectUtil;
import com.bluepumpkin.ejb.core.base.SupportMultiUserAccess;

abstract class EventAssignmentPubDAO&lt;T extends ValueObjectBase &amp; PlannedEvent&gt; extends EventAssignmentDAO&lt;T&gt; {
	public EventAssignmentPubDAO() {
<span class="nc" id="L31">		super();</span>
<span class="nc" id="L32">	}</span>

	public EventAssignmentPubDAO(Jdmo dmo) {
<span class="fc" id="L35">		super(dmo);</span>
<span class="fc" id="L36">	}</span>

	/**
	 * This method will be overriden by the derived class to provide an instance
	 * of the DAO class that model the unpublished event
	 */
	protected abstract EventAssignmentUnpubDAO&lt;T&gt; getUnpublishedDAO();

	/**
	 * This is an override of the base class function to add system column
	 * values to object serializable state
	 */
	public HashMap getSerializableState(T objValue, boolean bNew) {
<span class="fc" id="L49">		HashMap hmap = super.getSerializableState(objValue, bNew);</span>
<span class="pc bpc" id="L50" title="1 of 2 branches missed.">		if (hmap.isEmpty()) {</span>
<span class="nc" id="L51">			return hmap;</span>
		}
		// set the MODIFIEDBY field
<span class="fc" id="L54">		SupportMultiUserAccess item = (SupportMultiUserAccess) objValue;</span>
<span class="fc" id="L55">		String strModifiedBy = item.getUpdateUser();</span>
<span class="pc bpc" id="L56" title="1 of 2 branches missed.">		if (strModifiedBy == null) {</span>
<span class="nc" id="L57">			strModifiedBy = &quot;&quot;;</span>
		}
<span class="fc" id="L59">		hmap.put(&quot;MODIFIEDBY&quot;, strModifiedBy);</span>
<span class="fc" id="L60">		return hmap;</span>
	}

	/**
	 * Publishes the current schedule for the selected employees and the
	 * selected time period
	 *
	 * The current implementation works as follows: 1. check if the current
	 * schedule is out of synch with the published schedule for the selected
	 * time period 2. if so, unpublish the schedule for the entire time period
	 * 3. re-publish the current schedule for the entire time period
	 *
	 * The method returns the object that describes the set of old events and
	 * the set of new events so that the schedule differences can be computed
	 * and appropriate employees can be notified of the changes. If there are no
	 * changes, the function returns null
	 */
	ScheduleChangeDetails publishSchedule(Date dtStart, Date dtEnd, boolean bPublishedPeriodsOnly,
			Collection&lt;ID&gt; workResourceIDs, Collection&lt;ID&gt; outOfSyncWrkIds) throws BbmSchedulePublishingException {
<span class="fc" id="L79">		return publishSchedule(dtStart, dtEnd, bPublishedPeriodsOnly, workResourceIDs, outOfSyncWrkIds, null);</span>
	}

	ScheduleChangeDetails publishSchedule(Date dtStart, Date dtEnd, boolean bPublishedPeriodsOnly,
			Collection&lt;ID&gt; workResourceIDs, Collection&lt;ID&gt; outOfSyncWrkIds, Collection&lt;Collection&lt;T&gt;&gt; eventToBePublished)
			throws BbmSchedulePublishingException {
<span class="fc" id="L85">		ScheduleChangeDetails changeDetails = null;</span>
		try {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">			if (!outOfSyncWrkIds.isEmpty()) {</span>
				/*
				 * retrieve the events from un-published schedule that are to be
				 * published
				 */
<span class="fc" id="L92">				EventAssignmentUnpubDAO&lt;T&gt; daoUnpub = getUnpublishedDAO();</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">				if (eventToBePublished == null) {</span>
<span class="fc" id="L94">					eventToBePublished = daoUnpub.getEventsToBePublished(outOfSyncWrkIds, dtStart, dtEnd,</span>
							bPublishedPeriodsOnly);
				}

				/* delete the published schedules, if any */
<span class="fc" id="L99">				Collection&lt;Collection&lt;T&gt;&gt; listOldEvents = unPublishSchedule(outOfSyncWrkIds, dtStart, dtEnd, bPublishedPeriodsOnly);</span>

				// Unpublish the schedule if the event to be publish dates are different from passed in.  There is
				// a possibility that it may not remove the schedule as needed.
<span class="fc" id="L103">				unPublishSchedule(eventToBePublished, dtStart, dtEnd, outOfSyncWrkIds, listOldEvents, bPublishedPeriodsOnly);</span>
				
<span class="fc" id="L105">				Collection&lt;T&gt; listEventsToPublish = publishSchedule(eventToBePublished, outOfSyncWrkIds);</span>

				/* finally return the list of schedule changes */
<span class="fc" id="L108">				changeDetails = new ScheduleChangeDetails(outOfSyncWrkIds, dtStart, dtEnd, listOldEvents,</span>
<span class="fc" id="L109">						ScheduleDAOUtil.groupEventsByWorkResources(listEventsToPublish, outOfSyncWrkIds));</span>
			}
<span class="fc" id="L111">			return changeDetails;</span>
<span class="nc" id="L112">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L113">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	// QA 35812
	/**
	 * Return the list of events that are published as part of publishing
	 */
	protected Collection&lt;T&gt; publishSchedule(Collection&lt;Collection&lt;T&gt;&gt; listNewEvents, Collection&lt;ID&gt; outOfSyncWrkIds)
			throws BbmSchedulePublishingException {
<span class="fc" id="L123">		return publishSchedule(listNewEvents);</span>
	}

	// QA 35812
	/**
	 * Return the list of events that are published as part of publishing
	 */
	protected Collection&lt;T&gt; publishSchedule(Collection&lt;Collection&lt;T&gt;&gt; listNewEvents) throws BbmSchedulePublishingException {

<span class="fc" id="L132">		Collection&lt;T&gt; listEventsToPublish = null;</span>
		try {

			/**
			 * now that we've got this collection of events, go through and
			 * create copies of objects so that they can be persisted
			 */

<span class="fc" id="L140">			listEventsToPublish = ScheduleDAOUtil.cloneEventsForPublishing(listNewEvents);</span>

			/**
			 * Now persist the given collection of unpublished events to the
			 * published schedule
			 */

<span class="fc" id="L147">			createObjects(listEventsToPublish);</span>

<span class="fc" id="L149">			getEventHandler().createAuditTrailEntryForPublishing(listEventsToPublish, AuditTrailEntry.ACTION_PUBLISH);</span>

<span class="nc" id="L151">		} catch (Exception e) {</span>
<span class="nc" id="L152">			throw new BbmSchedulePublishingException(e);</span>
<span class="fc" id="L153">		}</span>
<span class="fc" id="L154">		return listEventsToPublish;</span>
	}

	/**
	 * Return the list of events from the published schedule that are to be
	 * reverted back to the current schedule
	 */
	protected Collection&lt;Collection&lt;T&gt;&gt; getEventsToBeReverted(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L163">		return getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
	}

	/**
	 * Un-publishes the published schedule for the selected employees and the
	 * selected time period.
	 * 
	 * @return collection of events in the schedule before the unpublish
	 *         operation was completed (i.e. old schedule)
	 */
	public Collection&lt;Collection&lt;T&gt;&gt; unPublishSchedule(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean bPublishedPeriodsOnly) throws BbmSchedulePublishingException {
		try {
			/*
			 * save the old schedule so that 1) we can create an audit trail 2)
			 * we are able to find differences between the old and the new
			 * schedules for notification purposes
			 */
<span class="pc bpc" id="L181" title="1 of 2 branches missed.">			Collection&lt;Collection&lt;T&gt;&gt; listOldEvents = bPublishedPeriodsOnly ? getEventsForWorkResourcesInPublishedPeriodsOnly(</span>
<span class="fc" id="L182">					workResourceIDs, dtStart, dtEnd) : getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * create a hash map indexed by event ID with the value being the
			 * event object
			 */
<span class="fc" id="L188">			Collection&lt;T&gt; uniqueEvents = ScheduleDAOUtil.getUniqueEvents(listOldEvents);</span>
<span class="fc" id="L189">			HashMap&lt;ID, T&gt; mapEvents = ValueObjectUtil.getIDObjectMap(uniqueEvents);</span>

			// QA 35812
			// Deletion of objects for CalendarEvents need to be handled
			// differently
<span class="fc" id="L194">			deleteObjects(mapEvents.keySet(), workResourceIDs);</span>

<span class="fc" id="L196">			getEventHandler().createAuditTrailEntryForPublishing(mapEvents.values(), workResourceIDs,</span>
					AuditTrailEntry.ACTION_UNPUBLISH);

<span class="fc" id="L199">			return listOldEvents;</span>
<span class="nc" id="L200">		} catch (Exception e) {</span>
<span class="nc" id="L201">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	/**
	 * Un-publishes the published schedule for the selected employees and the
	 * selected time period.
	 *
	 * @return collection of events in the schedule before the unpublish
	 *         operation was completed (i.e. old schedule)
	 */
	public Collection&lt;Collection&lt;T&gt;&gt; unPublishSchedule(Collection&lt;Collection&lt;T&gt;&gt; eventToBePublished, Date dtStart, Date dtEnd,  
													   Collection&lt;ID&gt; outOfSyncWrkIds, Collection&lt;Collection&lt;T&gt;&gt; listOldEvents,
													   boolean bPublishedPeriodsOnly) throws BbmSchedulePublishingException {
		
		try {

			// Unpublish the schedule if the event to be publish dates are different from passed in.  There is
			// a possibility that it may not remove the schedule as needed.
<span class="pc bpc" id="L220" title="2 of 4 branches missed.">			if (eventToBePublished != null &amp;&amp; !eventToBePublished.isEmpty()) {</span>
<span class="fc bfc" id="L221" title="All 2 branches covered.">				for (Iterator&lt;Collection&lt;T&gt;&gt; it = eventToBePublished.iterator(); it.hasNext();) {</span>
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">					if (it != null) {</span>
<span class="fc" id="L223">						Collection&lt;T&gt; events = it.next();</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">						if (events != null) {</span>
<span class="fc bfc" id="L225" title="All 2 branches covered.">							for (Iterator&lt;T&gt; sas = events.iterator(); sas.hasNext(); ) {</span>
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">								if (sas != null) {</span>
<span class="fc" id="L227">									T sa = sas.next();</span>
<span class="pc bpc" id="L228" title="4 of 6 branches missed.">									if (sa != null &amp;&amp; !(dtStart.equals(sa.getStartTime()) &amp;&amp; dtEnd.equals(sa.getEndTime()))) {</span>
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">										if (listOldEvents != null) {</span>
<span class="fc" id="L230">											listOldEvents.addAll(unPublishSchedule(outOfSyncWrkIds, sa.getStartTime(), sa.getEndTime(),</span>
												bPublishedPeriodsOnly));
										} else {
<span class="nc" id="L233">											listOldEvents = unPublishSchedule(outOfSyncWrkIds, sa.getStartTime(), sa.getEndTime(),</span>
												bPublishedPeriodsOnly);
										}
									}
<span class="fc" id="L237">								}</span>
							}
						}
<span class="fc" id="L240">					}</span>
				}
			}

<span class="fc" id="L244">			return listOldEvents;</span>
<span class="nc" id="L245">		} catch (Exception e) {</span>
<span class="nc" id="L246">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	public Collection&lt;T&gt; unPublishSchedule(Collection&lt;T&gt; eventList, Collection&lt;ID&gt; workResourceIDs)
			throws BbmSchedulePublishingException {
		try {
<span class="fc" id="L253">			HashMap&lt;ID, T&gt; idObjects = ValueObjectUtil.getIDObjectMap(eventList);</span>
<span class="fc" id="L254">			deleteObjects(idObjects.keySet(), workResourceIDs);</span>
<span class="fc" id="L255">			getEventHandler().createAuditTrailEntryForPublishing(eventList, workResourceIDs,</span>
					AuditTrailEntry.ACTION_UNPUBLISH);
<span class="fc" id="L257">			return eventList;</span>
<span class="nc" id="L258">		} catch (Exception e) {</span>
<span class="nc" id="L259">			throw new BbmSchedulePublishingException(e);</span>
		}
	}
	
	

	// 8/21/05, till now only CalendarEventAssignmentPubDAO overrides this
	// method to assign the different
	// behavior specifically for fixing bug 80822
	protected void deleteObjects(Collection&lt;ID&gt; colIDs, Collection&lt;ID&gt; workResourceIDs) throws BbmRemoveException {
		/** now delete these events from unpublished schedule */
<span class="fc" id="L270">		deleteObjects(colIDs);</span>
<span class="fc" id="L271">	}</span>

	ScheduleEventHandler getEventHandler() {
<span class="fc" id="L274">		return CachePerEJBMethod.getCache().getEventHandler();</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>