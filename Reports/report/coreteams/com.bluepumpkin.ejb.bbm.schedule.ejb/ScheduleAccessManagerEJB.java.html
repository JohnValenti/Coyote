<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleAccessManagerEJB.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">ScheduleAccessManagerEJB.java</span></div><h1>ScheduleAccessManagerEJB.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

/**
 * Title: Blue Pumpkin Software Basic Business Model Description: Schedule
 * Access Manager EJB implementation Copyright: Copyright (c) 2001-2002 Company:
 * Blue Pumpkin Software, inc
 *
 * @author Greg Fichtenholtz
 * @version 1.0
 */
import java.io.InvalidObjectException;
import java.rmi.RemoteException;
import java.time.ZonedDateTime;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TimeZone;

import javax.naming.Context;
import javax.naming.InitialContext;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoPCommand;
import com.bluepumpkin.common.jdmo.JdmoQuery;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.localization.LocaleContext;
import com.bluepumpkin.common.localization.LocalizationManager;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.logging.Priority;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.Log;
import com.bluepumpkin.ejb.bbm.activity.ejb.ActivityManager;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.audit.ejb.EventAuditTrailManager;
import com.bluepumpkin.ejb.bbm.audit.model.AuditTrailEntry;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmDuplicateExternalIdentException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.campaign.model.Campaign;
import com.bluepumpkin.ejb.bbm.campaign.model.CampaignWorkResource;
import com.bluepumpkin.ejb.bbm.campaign.model.SchedulingPeriod;
import com.bluepumpkin.ejb.bbm.config.ConfigCacheUtil;
import com.bluepumpkin.ejb.bbm.config.ConfigKey;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.dao.DAOUtil;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriodUtil;
import com.bluepumpkin.ejb.bbm.empworkrule.ejb.EmpWorkRuleManager;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRule;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceComplexWorkRuleFieldInfo;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceRotation;
import com.bluepumpkin.ejb.bbm.empworkrule.model.WorkResourceWorkPattern;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbBundleKey;
import com.bluepumpkin.ejb.bbm.localization.DefaultLocalizationManager;
import com.bluepumpkin.ejb.bbm.notifyrules.ejb.NotifyRuleManager;
import com.bluepumpkin.ejb.bbm.notifyrules.model.NotifyRuleTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictException;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflictResolutions;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAttendee;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplateFields;
import com.bluepumpkin.ejb.bbm.schedule.model.EventTemplateExceptionCreateData;
import com.bluepumpkin.ejb.bbm.schedule.model.FloatingEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.ImportedEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateBase;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateFields;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventUpdateInfo;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ValueObjectAggEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.util.ScheduleUtil;
import com.bluepumpkin.ejb.bbm.schedulelock.ejb.ScheduleLockManager;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.Skill;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.timerecord.ejb.TimeRecordManager;
import com.bluepumpkin.ejb.bbm.util.MonthlySPUtil;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectBase;
import com.bluepumpkin.ejb.bbm.vo.ValueObjectEffectivity;
import com.bluepumpkin.ejb.bbm.workload.model.Media;
import com.bluepumpkin.ejb.bbm.workresource.ejb.EmployeeTemplateDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.PhantomDAO;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Employee;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeMinMaxMinutes;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTemplate;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTemplateFieldInfo;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.Phantom;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.bbm.workrules.ejb.WorkRuleManager;
import com.bluepumpkin.ejb.bbm.workrules.model.Rotation;
import com.bluepumpkin.ejb.bbm.workrules.model.Shift;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftOTExtension;
import com.bluepumpkin.ejb.bbm.workrules.model.ShiftPattern;
import com.bluepumpkin.ejb.core.base.MultiUserException;
import com.bluepumpkin.ejb.core.base.SessionEJBBase;
import com.verint.ejb.wfm.WfmManagerFactory;

<span class="fc" id="L132">public class ScheduleAccessManagerEJB extends SessionEJBBase {</span>
	/**
	 *
	 */
	private static final long serialVersionUID = 1L;

	/*
	 * this variable has package scope so that it can be accessed by schedule
	 * DAO classes
	 */
<span class="fc" id="L142">	static final Category m_cat = Log.initCategory(ScheduleAccessManagerEJB.class.getName());</span>

	/**
	 * this is a helper class that deals with various pre- and post- conditions
	 * to various schedule changes
	 */
	ScheduleEventHandler m_eventHandler;

	/** schedule cache-related */
	private ScheduleAccessManagerEJBCache m_scheduleCache;

	/**
	 * references to other EJBs used by the Schedule Access Manager EJB
	 */
	NotifyRuleManager m_notifyManager;

	WorkResourceManager m_workResourceManager;

	ActivityManager m_activityManager;

	DBConfigManager m_dbConfigManager;

	ScheduleLockManager m_lockManager;

	EventAuditTrailManager m_auditManager;

	CampaignManager m_pCampaignManager;

	SkillManager m_skillManager;

	EmpWorkRuleManager m_empWorkRuleManager;

	WorkRuleManager m_workRuleManager;

<span class="fc" id="L176">	public static int CHUNKSIZE = 500;</span>

	/*
	 * a flag that indicates whether or not this instance is running in what if
	 * mode
	 */
<span class="fc" id="L182">	boolean m_isWhatIf = false;</span>

	{
<span class="fc" id="L185">		super.init(ScheduleAccessManagerEJB.class.getName());</span>
<span class="fc" id="L186">	}</span>

	/**
	 * Perform one-time initialization of this EJB instance
	 */
	@Override
	public void onEjbCreate() {
		try {
			// First query environment to get WIF setting from DD
<span class="fc" id="L195">			Context initialContext = new InitialContext();</span>
<span class="fc" id="L196">			Boolean WIF = (Boolean) initialContext.lookup(&quot;java:comp/env/WIF&quot;);</span>
<span class="pc bpc" id="L197" title="1 of 2 branches missed.">			if (WIF != null) {</span>
<span class="fc" id="L198">				m_isWhatIf = WIF;</span>
			}

<span class="fc" id="L201">			m_dbConfigManager = BbmManagerFactory.getDBConfigManager(m_isWhatIf);</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">			if (ConfigCacheUtil.isCacheEnabled(m_dbConfigManager, ConfigKey.SCHEDULE_CACHE_USAGE)) {</span>
				/*
				 * from the spec: schedule cache time window would be +x hours
				 * (last x hours) to +x hours (the next x hours), where x is the
				 * cache window used by time record manager.
				 */
				/* the default cache window size is 1 day */
<span class="fc" id="L209">				long cacheWindowSize = TimeZoneUtil.DAY_IN_MILLISECONDS;</span>
<span class="fc" id="L210">				String cacheWindowSizeStr = m_dbConfigManager.getValue(TimeRecordManager.TIMERECORDS_CACHE_INTERVAL);</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">				if (cacheWindowSizeStr != null) {</span>
<span class="nc" id="L212">					cacheWindowSize = Long.parseLong(cacheWindowSizeStr);</span>
				}

				// Add Cache support
<span class="fc" id="L216">				m_scheduleCache = new ScheduleAccessManagerEJBCache(cacheWindowSize);</span>
			}
<span class="fc" id="L218">			m_workResourceManager = BbmManagerFactory.getWorkResourceManager(m_isWhatIf);</span>
<span class="fc" id="L219">			m_activityManager = WfmManagerFactory.getActivityManager(m_isWhatIf);</span>
<span class="fc" id="L220">			m_lockManager = WfmManagerFactory.getScheduleLockManager(m_isWhatIf);</span>
<span class="fc" id="L221">			m_auditManager = BbmManagerFactory.getEventAuditTrailManager(m_isWhatIf);</span>
<span class="fc" id="L222">			m_pCampaignManager = WfmManagerFactory.getCampaignManager(m_isWhatIf);</span>
<span class="fc" id="L223">			m_skillManager = WfmManagerFactory.getSkillManager(m_isWhatIf);</span>
<span class="fc" id="L224">			m_empWorkRuleManager = WfmManagerFactory.getEmpWorkRuleManager(m_isWhatIf);</span>
<span class="fc" id="L225">			m_workRuleManager = WfmManagerFactory.getWorkRuleManager(m_isWhatIf);</span>
<span class="fc" id="L226">			ScheduleAccessManager scheduleAccessManager = WfmManagerFactory.getScheduleAccessManager(m_isWhatIf);</span>

			/** There's no need for notifications in What-If Mode */
<span class="pc bpc" id="L229" title="1 of 2 branches missed.">			if (!m_isWhatIf) {</span>
<span class="fc" id="L230">				m_notifyManager = BbmManagerFactory.getNotifyRuleManager();</span>
			}

<span class="fc" id="L233">			m_eventHandler = new ScheduleEventHandler(m_cat, m_lockManager, m_auditManager, scheduleAccessManager);</span>
<span class="nc" id="L234">		} catch (Exception e) {</span>
<span class="nc" id="L235">			handleException(&quot;onEjbCreate&quot;, e, false);</span>
<span class="fc" id="L236">		}</span>
<span class="fc" id="L237">	}</span>

	/** override the base class to provide the appropriate logging category */
	@Override
	protected Category getCategory() {
<span class="fc" id="L242">		return m_cat;</span>
	}

	/**
	 * returns the identity (username) of the current user this method has
	 * package scope
	 */
	String getCallerIdentify() {
<span class="nc" id="L250">		java.security.Principal principal = m_sessionContext.getCallerPrincipal();</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">		return (principal != null ? principal.getName() : null);</span>
	}

	public ImportedEvent getImportedEventByID(ID eventID) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L255">		methodStart(&quot;getImportedEventByID&quot;, eventID);</span>

<span class="nc" id="L257">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
<span class="nc" id="L259">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L260">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L262">			throw e;</span>
<span class="nc" id="L263">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L264">			handleException(e);</span>
<span class="nc" id="L265">			throw e;</span>
		} finally {
<span class="nc" id="L267">			dao.cleanUp();</span>
<span class="nc" id="L268">			methodFinish();</span>
		}
	}

	public Collection&lt;ImportedEvent&gt; getImportedEventsForWorkResource(ID workResourceID, Collection&lt;ID&gt; activityCol,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L274">		methodStart(&quot;getImportedEventsForWorkResource&quot;, workResourceID, activityCol, dtStart, dtEnd);</span>

<span class="nc" id="L276">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
<span class="nc" id="L278">			return dao.getEventsForWorkResource(workResourceID, activityCol, dtStart, dtEnd);</span>
<span class="nc" id="L279">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L280">			handleException(e);</span>
<span class="nc" id="L281">			throw e;</span>
		} finally {
<span class="nc" id="L283">			dao.cleanUp();</span>
<span class="nc" id="L284">			methodFinish();</span>
		}
	}

	public Collection getEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L289">		return (ArrayList) getEventsForWorkResources(Collections.singletonList(workResourceID), dtStart, dtEnd)</span>
<span class="nc" id="L290">				.get(0);</span>
	}

	public Collection getEventsForWorkResourceByType(int eventTypeMask, ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L295">		return (ArrayList) getEventsForWorkResourcesByType(eventTypeMask, Collections.singletonList(workResourceID),</span>
<span class="nc" id="L296">				dtStart, dtEnd).get(0);</span>
	}

	public Collection getPublishedEventsForWorkResource(ID workResourceID, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L301">		List&lt;ID&gt; wrIDs = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L302">		wrIDs.add(workResourceID);</span>
<span class="nc" id="L303">		return (ArrayList) getPublishedEventsForWorkResources(wrIDs, dtStart, dtEnd).get(0);</span>
	}

	public Collection getPublishedEventsForWorkResourceByType(int eventTypeMask, ID workResourceID, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="nc" id="L308">		return (ArrayList) getPublishedEventsForWorkResourcesByType(eventTypeMask,</span>
<span class="nc" id="L309">				Collections.singletonList(workResourceID), dtStart, dtEnd).get(0);</span>
	}

	public List getEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L314">		methodStart(&quot;getEventsForWorkResources&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
			/*
			 * set up an event type bitmask the covers all types of un-published
			 * events
			 */
<span class="fc" id="L321">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>

<span class="fc" id="L323">			return getEventsForWorkResourcesByType(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
		} finally {
<span class="pc" id="L325">			methodFinish();</span>
		}
	}

	public List getEventsForWorkResourcesByType(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="fc" id="L331">		methodStart(&quot;getEventsForWorkResourcesByType&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs,</span>
				dtStart, dtEnd);

<span class="fc" id="L334">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="fc" id="L336">			Collection events = new ArrayList();</span>

<span class="pc bpc" id="L338" title="1 of 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0) {</span>
<span class="fc" id="L339">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="fc" id="L340">				events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
			}

<span class="pc bpc" id="L343" title="1 of 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_ALL_CALENDAR_EVENTS) != 0) {</span>
<span class="fc" id="L344">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="fc" id="L345">				events.add(dao.getAllEventsForWorkResources(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>
			}
<span class="fc" id="L347">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, events);</span>
<span class="nc" id="L348">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L349">			handleException(e);</span>
<span class="nc" id="L350">			throw e;</span>
<span class="nc" id="L351">		} catch (Exception e) {</span>
<span class="nc" id="L352">			handleException(e);</span>
<span class="nc" id="L353">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L355">			dmo.cleanUp();</span>
<span class="pc" id="L356">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L362">		methodStart(&quot;getPublishedEventsForWorkResources&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
			/*
			 * set up a bit mask that represents all types of published events
			 */
<span class="nc" id="L368">			int eventTypeMask = Event.EVENT_TYPE_IMPORTED | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
					| Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;

<span class="nc" id="L371">			return getPublishedEventsForWorkResourcesByType(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
		} finally {
<span class="nc" id="L373">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResourcesByType(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L379">		methodStart(&quot;getPublishedEventsForWorkResourcesByType&quot;, NumberFactory.newInteger(eventTypeMask),</span>
				workResourceIDs, dtStart, dtEnd);

<span class="nc" id="L382">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L384">			List events = new ArrayList();</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_IMPORTED) != 0) {</span>
<span class="nc" id="L387">				ImportedEventDAO dao = new ImportedEventDAO(dmo);</span>
<span class="nc" id="L388">				events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
			}

<span class="nc" id="L391">			String tempTableName = null;</span>
			// 50 is a number derived based on a few automated tests done on LW
			// database, Sameet , Aug 2008
<span class="nc bnc" id="L394" title="All 4 branches missed.">			if ((workResourceIDs != null &amp;&amp; workResourceIDs.size() &gt; 50)) {</span>
<span class="nc" id="L395">				tempTableName = createTempTableToQueryEvents(dmo, workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0) {</span>
<span class="nc" id="L398">				ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">				if (tempTableName != null) {</span>
<span class="nc" id="L400">					events.add(dao.getEventsForWorkResources(workResourceIDs, tempTableName));</span>
				} else {
<span class="nc" id="L402">					events.add(dao.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
				}
			}

<span class="nc bnc" id="L406" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_ALL_CALENDAR_EVENTS) != 0) {</span>
<span class="nc" id="L407">				CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc bnc" id="L408" title="All 2 branches missed.">				if (tempTableName != null) {</span>
<span class="nc" id="L409">					events.add(dao.getAttendingEventsForWorkResources(eventTypeMask, workResourceIDs, tempTableName));</span>
				} else {
<span class="nc" id="L411">					events.add(dao.getAttendingEventsForWorkResources(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>
				}
			}

<span class="nc" id="L415">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, events);</span>
<span class="nc" id="L416">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L417">			handleException(e);</span>
<span class="nc" id="L418">			throw e;</span>
<span class="nc" id="L419">		} catch (Exception e) {</span>
<span class="nc" id="L420">			handleException(e);</span>
<span class="nc" id="L421">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L423">			dmo.cleanUp();</span>
<span class="nc" id="L424">			methodFinish();</span>
		}
	}

	public ID createImportedEvent(ImportedEvent event) throws BbmCreateException {
<span class="nc" id="L429">		methodStart(&quot;createImportedEvent&quot;, event);</span>

<span class="nc" id="L431">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
			/* perform what is necessary before a new event gets created */
<span class="nc" id="L434">			m_eventHandler.preCreateEvent(null, event);</span>

<span class="nc" id="L436">			ID eventID = dao.createObject(event);</span>

			/* perform what is necessary when a new event gets created */
<span class="nc" id="L439">			m_eventHandler.postCreateEvent(event);</span>

<span class="nc" id="L441">			return eventID;</span>
<span class="nc" id="L442">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L443">			handleException(e);</span>
<span class="nc" id="L444">			throw e;</span>
<span class="nc" id="L445">		} catch (Exception e) {</span>
<span class="nc" id="L446">			handleException(e);</span>
<span class="nc" id="L447">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L449">			dao.cleanUp();</span>
<span class="nc" id="L450">			methodFinish();</span>
		}
	}

	public void deleteImportedEvents(Collection&lt;ID&gt; eventIDs) throws BbmRemoveException {
<span class="nc" id="L455">		methodStart(&quot;deleteImportedEvents&quot;, eventIDs);</span>

<span class="nc" id="L457">		ImportedEventDAO dao = new ImportedEventDAO();</span>
		try {
			/** save the objects before blowing them away */
<span class="nc" id="L460">			Collection&lt;ImportedEvent&gt; listEvents = dao.getObjectsByIDs(eventIDs);</span>

			/** perform what is necessary before events get deleted */
<span class="nc" id="L463">			m_eventHandler.preDeleteEvents(null, listEvents);</span>

<span class="nc" id="L465">			dao.deleteObjects(eventIDs);</span>

			/** perform what is necessary when events get deleted */
<span class="nc" id="L468">			m_eventHandler.postDeleteEvents(listEvents);</span>

<span class="nc" id="L470">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L471">			handleException(e);</span>
<span class="nc" id="L472">			throw e;</span>
<span class="nc" id="L473">		} catch (Exception e) {</span>
<span class="nc" id="L474">			handleException(e);</span>
<span class="nc" id="L475">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L477">			dao.cleanUp();</span>
<span class="nc" id="L478">			methodFinish();</span>
<span class="nc" id="L479">		}</span>
<span class="nc" id="L480">	}</span>

	public ID createShiftAssignment(ShiftAssignment shiftAssignment)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L484">		return createSAWithLock(null, Collections.singletonList(shiftAssignment)).iterator().next();</span>
	}

	public Collection&lt;ID&gt; createShiftAssignments(Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L489">		return createShiftAssignments(null, shiftAssignments);</span>
	}

	public Collection&lt;ID&gt; createShiftAssignmentsWithLock(String lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L494">		return createSAWithLock(lockID, shiftAssignments);</span>
	}

	public Collection&lt;ID&gt; createShiftAssignments(ID lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L499">		return createSAWithLock(lockID, shiftAssignments);</span>
	}

	private Collection&lt;ID&gt; createSAWithLock(Object lockID, Collection&lt;ShiftAssignment&gt; shiftAssignments)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="fc" id="L504">		methodStart(&quot;createShiftAssignments&quot;, lockID, shiftAssignments);</span>

<span class="fc" id="L506">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
			/* perform what is necessary before the assignments are created */
<span class="fc" id="L509">			m_eventHandler.preCreateShiftAssignments(lockID, shiftAssignments);</span>

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="fc" id="L514">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForNewScheduleObjects(shiftAssignments);</span>
<span class="pc bpc" id="L515" title="1 of 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L516">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="fc" id="L519">			Collection&lt;ID&gt; listIDs = dao.createObjects(shiftAssignments);</span>

			/* perform what is necessary whenever shifts are created */
<span class="fc" id="L522">			m_eventHandler.postCreateShiftAssignments(shiftAssignments);</span>

<span class="fc" id="L524">			return listIDs;</span>
<span class="nc" id="L525">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L526">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L527">			throw e; // rethrow</span>
<span class="nc" id="L528">		} catch (BbmCreateException | MultiUserException e) {</span>
<span class="nc" id="L529">			handleException(e);</span>
<span class="nc" id="L530">			throw e;</span>
<span class="nc" id="L531">		} catch (Exception e) {</span>
<span class="nc" id="L532">			handleException(e);</span>
<span class="nc" id="L533">			throw new BbmCreateException(e);</span>
		} finally {
<span class="pc" id="L535">			dao.cleanUp();</span>
<span class="pc" id="L536">			methodFinish();</span>
		}
	}

	public ID createShiftEventAssignment(ShiftEventAssignment sea)
			throws MultiUserException, BbmFinderException, BbmScheduleConflictException, BbmUpdateException, BbmCreateException {
<span class="nc" id="L542">		methodStart(&quot;createShiftEventAssignment&quot;, sea);</span>

		try {
<span class="nc" id="L545">			ShiftAssignment sa = getShiftAssignmentByID(sea.getParentID());</span>
<span class="nc" id="L546">			Collection&lt;ShiftEventAssignment&gt; listChildren = sa.getChildren();</span>
<span class="nc" id="L547">			sa.addShiftEventAssignment(sea);</span>
<span class="nc" id="L548">			updateShiftAssignment(sa);</span>
<span class="nc" id="L549">			Collection&lt;ShiftEventAssignment&gt; listOfNewChildren = sa.getChildren();</span>
<span class="nc bnc" id="L550" title="All 2 branches missed.">			for (ShiftEventAssignment newSEA : listOfNewChildren) {</span>
<span class="nc bnc" id="L551" title="All 2 branches missed.">				if (!listChildren.contains(newSEA)) {</span>
<span class="nc" id="L552">					return newSEA.getID();</span>
				}
<span class="nc" id="L554">			}</span>
			//TODO localize
<span class="nc" id="L556">			throw new BbmCreateException(&quot;Unable to create Shift Event&quot;);</span>
<span class="nc" id="L557">		} catch (MultiUserException | BbmCreateException | BbmScheduleConflictException | BbmUpdateException | BbmFinderException e) {</span>
<span class="nc" id="L558">			handleException(e);</span>
<span class="nc" id="L559">			throw e;</span>
		} finally {
<span class="nc" id="L561">			methodFinish();</span>
		}
	}

	/**
	 * This method should be called when a stored procedure is to be called that
	 * first selects shift assignments that fall within the sp date range
	 * selection but having null spids. Such shift assignments are then updated
	 * @param sid scheduling period id to be linked to shift assignments that
	 *        fall in the sp date range and having null sp id
	 */
	public void linkShiftAssignmentsToSchedulingPeriod(ID sid) throws JdmoException {
<span class="fc" id="L573">		methodStart(&quot;linkShiftAssignmentsToSchedulingPeriod&quot;, sid);</span>
<span class="fc" id="L574">		Jdmo jdmo = new Jdmo();</span>
		try {
<span class="fc" id="L576">			JdmoQuery query = jdmo.createQuery(&quot;LINKSPTOSHIFTASSIGNMENTS&quot;, Jdmo.STORPROC_QUERY_NORS);</span>
<span class="fc" id="L577">			query.setParID(1, sid);</span>
<span class="fc" id="L578">			jdmo.execute(query);</span>
<span class="nc" id="L579">		} catch (JdmoException e) {</span>
<span class="nc" id="L580">			handleException(Priority.DEBUG, e);</span>
<span class="nc" id="L581">			throw e;</span>
		} finally {
<span class="pc" id="L583">			jdmo.cleanUp();</span>
<span class="pc" id="L584">			methodFinish();</span>
<span class="fc" id="L585">		}</span>
<span class="fc" id="L586">	}</span>

	public void updateShiftAssignment(ShiftAssignment shiftAssignment)
			throws BbmScheduleConflictException, BbmUpdateException, BbmObjectNotFoundException, MultiUserException {
<span class="nc" id="L590">		methodStart(&quot;updateShiftAssignment&quot;, shiftAssignment);</span>

<span class="nc" id="L592">		shiftAssignment.processBeforeUpdate();</span>

<span class="nc" id="L594">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
			/* save the object before the update */
<span class="nc" id="L597">			Event oldEvent = dao.getObjectByID(shiftAssignment.getID());</span>

			/* perform what is necessary before an event gets updated */
<span class="nc" id="L600">			m_eventHandler.preUpdateEvent(null, oldEvent, shiftAssignment);</span>
<span class="nc" id="L601">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForUpdatedScheduleObject(shiftAssignment);</span>
<span class="nc bnc" id="L602" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L603">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="nc" id="L606">			dao.updateObject(shiftAssignment);</span>

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="nc" id="L611">			shiftAssignment = dao.getObjectByID(shiftAssignment.getID());</span>
<span class="nc" id="L612">			shiftAssignment.checkIsValid();</span>

			/* perform what is necessary whenever an event gets updated */
<span class="nc" id="L615">			m_eventHandler.postUpdateEvent(oldEvent, shiftAssignment);</span>
<span class="nc" id="L616">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L617">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L618">			throw e; // just rethrow</span>
<span class="nc" id="L619">		} catch (BbmUpdateException | BbmObjectNotFoundException | MultiUserException e) {</span>
<span class="nc" id="L620">			handleException(e);</span>
<span class="nc" id="L621">			throw e;</span>
<span class="nc" id="L622">		} catch (Exception e) {</span>
<span class="nc" id="L623">			handleException(e);</span>
<span class="nc" id="L624">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L626" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L627">				dao.cleanUp();</span>
			}
<span class="nc" id="L629">			methodFinish();</span>
<span class="nc" id="L630">		}</span>
<span class="nc" id="L631">	}</span>

	public void updateShiftEventAssignment(ShiftEventAssignment sea)
			throws BbmUpdateException, MultiUserException, BbmFinderException, BbmScheduleConflictException {
<span class="nc" id="L635">		methodStart(&quot;updateShiftEventAssignment&quot;, sea);</span>
		try {
<span class="nc" id="L637">			ShiftAssignment sa = getShiftAssignmentByID(sea.getParentID());</span>
<span class="nc" id="L638">			sa.updateShiftEventAssignment(sea);</span>
<span class="nc" id="L639">			updateShiftAssignment(sa);</span>
<span class="nc" id="L640">		} catch (BbmUpdateException | BbmScheduleConflictException | MultiUserException e) {</span>
<span class="nc" id="L641">			handleException(e);</span>
<span class="nc" id="L642">			throw e;</span>
		} finally {
<span class="nc" id="L644">			methodFinish();</span>
<span class="nc" id="L645">		}</span>
<span class="nc" id="L646">	}</span>

	public void deleteShiftEventAssignments(Collection&lt;ID&gt; shiftEventAssignmentIDs) throws BbmRemoveException {
<span class="nc" id="L649">		methodStart(&quot;deleteShiftEventAssignments&quot;, shiftEventAssignmentIDs);</span>

<span class="nc" id="L651">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>

		try {
<span class="nc" id="L654">			dao.deleteObjects(shiftEventAssignmentIDs);</span>
<span class="nc" id="L655">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L656">			handleException(e);</span>
<span class="nc" id="L657">			throw e;</span>
		} finally {
<span class="nc" id="L659">			dao.cleanUp();</span>
<span class="nc" id="L660">			methodFinish();</span>
<span class="nc" id="L661">		}</span>
<span class="nc" id="L662">	}</span>

	public void deleteShiftAssignments(Collection&lt;ID&gt; shiftAssignmentIDs) throws MultiUserException, BbmRemoveException {
<span class="nc" id="L665">		deleteSAWithLock(null, shiftAssignmentIDs);</span>
<span class="nc" id="L666">	}</span>

	public void deleteShiftAssignmentsWithLock(String lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L670">		deleteSAWithLock(lockID, shiftAssignmentIDs);</span>
<span class="nc" id="L671">	}</span>

	public void deleteShiftAssignments(ID lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L675">		deleteSAWithLock(lockID, shiftAssignmentIDs);</span>
<span class="nc" id="L676">	}</span>

	private void deleteSAWithLock(Object lockID, Collection&lt;ID&gt; shiftAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L680">		methodStart(&quot;deleteShiftAssignments&quot;, lockID, shiftAssignmentIDs);</span>

<span class="nc" id="L682">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L684">			Collection&lt;ShiftAssignment&gt; listEvents = dao.getObjectsByIDs(shiftAssignmentIDs);</span>

			/* perform what is necessary before events are deleted */
<span class="nc" id="L687">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* delete the shift assignments */
<span class="nc" id="L690">			dao.deleteObjects(shiftAssignmentIDs);</span>

			/* perform what is necessary whenever events are deleted */
<span class="nc" id="L693">			m_eventHandler.postDeleteEvents(listEvents);</span>

<span class="nc" id="L695">		} catch (BbmRemoveException | MultiUserException e) {</span>
<span class="nc" id="L696">			handleException(e);</span>
<span class="nc" id="L697">			throw e;</span>
<span class="nc" id="L698">		} catch (Exception e) {</span>
<span class="nc" id="L699">			handleException(e);</span>
<span class="nc" id="L700">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc bnc" id="L702" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L703">				dao.cleanUp();</span>
			}
<span class="nc" id="L705">			methodFinish();</span>
<span class="nc" id="L706">		}</span>
<span class="nc" id="L707">	}</span>

	public void deleteShiftAssignmentsWithLockString(String lockID, Collection&lt;ID&gt; workResourceIDs, Date startTime,
			Date endTime, ID campaignID, boolean unlockedOnly) throws MultiUserException, BbmRemoveException {
		// delete by start time only
<span class="fc" id="L712">		deleteShiftAssignments(lockID, workResourceIDs, startTime, endTime, campaignID, unlockedOnly, true);</span>
<span class="fc" id="L713">	}</span>

	private void deleteShiftAssignments(String lockID, Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime,
			ID spID, boolean unlockedOnly, boolean byStartTime) throws MultiUserException, BbmRemoveException {
<span class="pc bpc" id="L717" title="1 of 2 branches missed.">		methodStart(&quot;deleteShiftAssignmentsWithLockString&quot;, new Object[] {</span>
				lockID,
				workResourceIDs,
				startTime,
				endTime,
				spID,
				unlockedOnly ? Boolean.TRUE : Boolean.FALSE });
<span class="fc" id="L724">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		Collection&lt;ShiftAssignment&gt; shifts;
		try {
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">			if (spID != null) {</span>
				// to schedule a SP, FS will call this API with 3 weeks range to
				// cover
				// the events crossing this SP, but we should not lock all the
				// events
				// in 3 weeks. here we will find the events in this SP and only
				// locks those
				// - silk 91697

				// get all the shift assignment in this SP
<span class="fc" id="L737">				shifts = dao.getShiftAssignmentInSP(spID, workResourceIDs, startTime, endTime);</span>
				// call preDelete to lock.
<span class="fc" id="L739">				m_eventHandler.preDeleteEvents(lockID, shifts);</span>

				// before delete, get the shifts will be deleted, will use them
				// to generate audit record
<span class="fc" id="L743">				shifts = dao.getShiftAssignmentInSP(spID, workResourceIDs, startTime, endTime, unlockedOnly);</span>
			} else {
				/* perform what is necessary before a schedule gets cleared */
<span class="nc" id="L746">				m_eventHandler.preClearSchedule(lockID, workResourceIDs, startTime, endTime);</span>
<span class="nc" id="L747">				Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; list = dao.getEventsForWorkResources(workResourceIDs, startTime,</span>
						endTime);
<span class="nc" id="L749">				shifts = ScheduleDAOUtil.getUniqueEvents(list);</span>
			}

<span class="fc" id="L752">			dao.deleteEventsForWorkResources(workResourceIDs, startTime, endTime, spID, unlockedOnly, byStartTime);</span>

			/* perform what is necessary whenever a schedule gets cleared */
<span class="fc" id="L755">			m_eventHandler.postClearSchedule(workResourceIDs, startTime, endTime, unlockedOnly, shifts);</span>
<span class="nc" id="L756">		} catch (BbmRemoveException | MultiUserException e) {</span>
<span class="nc" id="L757">			handleException(e);</span>
<span class="nc" id="L758">			throw e;</span>
<span class="nc" id="L759">		} catch (Exception e) {</span>
<span class="nc" id="L760">			handleException(e);</span>
<span class="nc" id="L761">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="pc" id="L763">			dao.cleanUp();</span>
<span class="pc" id="L764">			methodFinish();</span>
<span class="fc" id="L765">		}</span>
<span class="fc" id="L766">	}</span>

	public void deleteShiftAssignments(Collection&lt;ID&gt; workResourceIDs, Date startTime, Date endTime, ID campaignID,
			boolean unlockedOnly) throws MultiUserException, BbmRemoveException {
		// delete by start time only
<span class="nc" id="L771">		deleteShiftAssignments(null, workResourceIDs, startTime, endTime, campaignID, unlockedOnly, true);</span>
<span class="nc" id="L772">	}</span>

	public ShiftAssignment getShiftAssignmentByID(ID shiftAssignmentID) throws BbmFinderException {
<span class="nc" id="L775">		methodStart(&quot;getShiftAssignmentByID&quot;, shiftAssignmentID);</span>

<span class="nc" id="L777">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L779">			return dao.getObjectByID(shiftAssignmentID);</span>
<span class="nc" id="L780">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L782">			throw e;</span>
<span class="nc" id="L783">		} catch (Exception e) {</span>
<span class="nc" id="L784">			handleException(e);</span>
<span class="nc" id="L785">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L787">			dao.cleanUp();</span>
<span class="nc" id="L788">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftAssignment&gt; getShiftAssignmentsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc" id="L793">		methodStart(&quot;getShiftAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L795">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L797">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L798">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L799">			handleException(e);</span>
<span class="nc" id="L800">			throw e;</span>
		} finally {
<span class="nc" id="L802">			dao.cleanUp();</span>
<span class="nc" id="L803">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEventAssignment&gt; getShiftEventAssignmentsByIDs(Collection&lt;ID&gt; ids) throws BbmFinderException {
<span class="nc" id="L808">		methodStart(&quot;getShiftEventAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L810">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>
		try {
<span class="nc" id="L812">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L813">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L814">			handleException(e);</span>
<span class="nc" id="L815">			throw e;</span>
		} finally {
<span class="nc" id="L817">			dao.cleanUp();</span>
<span class="nc" id="L818">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftAssignment&gt; getAllShiftAssignmentsForEmployeesBetweenDates(
			Collection&lt;ID&gt; employeeIds, Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L824">		methodStart(&quot;getAllShiftAssignmentsForEmployeesBetweenDates&quot;, employeeIds, startDate, endDate);</span>

<span class="nc" id="L826">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L828">			return dao.getShiftAssignments(employeeIds, startDate, endDate);</span>
<span class="nc" id="L829">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L830">			handleException(e);</span>
<span class="nc" id="L831">			throw e;</span>
		} finally {
<span class="nc" id="L833">			dao.cleanUp();</span>
<span class="nc" id="L834">			methodFinish();</span>
		}
	}

	public Collection&lt;ShiftEventAssignment&gt; getAllShiftEventAssignmentsForEmployeesBetweenDates(Collection&lt;ID&gt; employeeIds,
			Date startDate, Date endDate) throws BbmFinderException {
<span class="nc" id="L840">		methodStart(&quot;getAllShiftEventAssignmentsForEmployeesBetweenDates&quot;, employeeIds, startDate, endDate);</span>

<span class="nc" id="L842">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO();</span>
		try {
<span class="nc" id="L844">			return dao.getShiftAssignmentsForWorkResources(employeeIds, startDate, endDate);</span>
<span class="nc" id="L845">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L846">			handleException(e);</span>
<span class="nc" id="L847">			throw e;</span>
		} finally {
<span class="nc" id="L849">			dao.cleanUp();</span>
<span class="nc" id="L850">			methodFinish();</span>
		}
	}

	public ShiftEventAssignment getShiftEventAssignmentById(ID seaId) throws BbmFinderException {
<span class="nc" id="L855">		methodStart(&quot;getShiftEventAssignmentById&quot;, seaId);</span>

<span class="nc" id="L857">		ShiftEventAssignmentDAO dao = new ShiftEventAssignmentDAO(new Jdmo());</span>
		try {
<span class="nc" id="L859">			return dao.getObjectByID(seaId);</span>
<span class="nc" id="L860">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L861">			handleException(e);</span>
<span class="nc" id="L862">			throw e;</span>
		} finally {
<span class="nc" id="L864">			dao.cleanUp();</span>
<span class="nc" id="L865">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, ShiftAssignment&gt; getLastShiftAssignments(Collection&lt;ID&gt; workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L871">		methodStart(&quot;getLastShiftAssignments&quot;, workResourceIDs);</span>

<span class="nc" id="L873">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L875">			return dao.getLastShiftAssignments(workResourceIDs);</span>
<span class="nc" id="L876">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L878">			throw e;</span>
<span class="nc" id="L879">		} catch (Exception e) {</span>
<span class="nc" id="L880">			handleException(e);</span>
<span class="nc" id="L881">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L883">			dao.cleanUp();</span>
<span class="nc" id="L884">			methodFinish();</span>
		}
	}

	public ShiftAssignment getPublishedShiftAssignmentByID(ID shiftAssignmentID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L890">		methodStart(&quot;getPublishedShiftAssignmentByID&quot;, shiftAssignmentID);</span>

<span class="nc" id="L892">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L894">			return dao.getObjectByID(shiftAssignmentID);</span>
<span class="nc" id="L895">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L897">			throw e;</span>
<span class="nc" id="L898">		} catch (Exception e) {</span>
<span class="nc" id="L899">			handleException(e);</span>
<span class="nc" id="L900">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L902">			dao.cleanUp();</span>
<span class="nc" id="L903">			methodFinish();</span>
		}
	}

	public List&lt;ShiftAssignment&gt; getPublishedShiftAssignmentByIDs(List&lt;ID&gt; shiftAssignmentIds)
			throws BbmFinderException {
<span class="nc" id="L909">		methodStart(&quot;getShiftAssignmentsInSP&quot;, shiftAssignmentIds);</span>
<span class="nc" id="L910">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L912">			return dao.getPublishedShiftAssignmentByIDs(shiftAssignmentIds);</span>
<span class="nc" id="L913">		} catch (Exception e) {</span>
<span class="nc" id="L914">			handleException(e);</span>
<span class="nc" id="L915">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L917">			dao.cleanUp();</span>
<span class="nc" id="L918">			methodFinish();</span>
		}
	}

	public List&lt;ShiftAssignment&gt; getUnpublishedShiftAssignmentByIDs(List&lt;ID&gt; shiftAssignmentIds)
			throws BbmFinderException {
<span class="nc" id="L924">		methodStart(&quot;getUnpublishedShiftAssignmentByIDs&quot;, shiftAssignmentIds);</span>
<span class="nc" id="L925">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L927">			return dao.getShiftAssignmentByIDs(shiftAssignmentIds);</span>
<span class="nc" id="L928">		} catch (Exception e) {</span>
<span class="nc" id="L929">			handleException(e);</span>
<span class="nc" id="L930">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L932">			dao.cleanUp();</span>
<span class="nc" id="L933">			methodFinish();</span>
		}
	}

	public HashMap&lt;ID, ShiftAssignment&gt; getLastPublishedShiftAssignments(Collection&lt;ID&gt; workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L939">		methodStart(&quot;getLastPublishedShiftAssignments&quot;, workResourceIDs);</span>

<span class="nc" id="L941">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L943">			return dao.getLastShiftAssignments(workResourceIDs);</span>
<span class="nc" id="L944">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L946">			throw e;</span>
<span class="nc" id="L947">		} catch (Exception e) {</span>
<span class="nc" id="L948">			handleException(e);</span>
<span class="nc" id="L949">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L951">			dao.cleanUp();</span>
<span class="nc" id="L952">			methodFinish();</span>
		}
	}

	public ID createCalendarEventAssignment(CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L958">		return createCalendarEventAssignment(null, event);</span>
	}

	public ID createCalendarEventAssignmentWithLock(String lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L963">		return createCEAWithLock(lockID, event);</span>
	}

	public ID createCalendarEventAssignment(ID lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L968">		return createCEAWithLock(lockID, event);</span>
	}

	public Collection&lt;ID&gt; createCalendarEventAssignments(String lockID, Collection events)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L973">		return createCEAsWithLock(lockID, events);</span>
	}

	public Collection&lt;ID&gt; createCalendarEventAssignmentsFromAdapter(String lockID, Collection events)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L978">		return createCEAsWithLock(lockID, events);</span>
	}

	private ID createCEAWithLock(Object lockID, CalendarEventAssignment event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L983">		return createCEAsWithLock(lockID, Collections.singletonList(event)).iterator().next();</span>
	}

	private Collection&lt;ID&gt; createCEAsWithLock(Object lockID, Collection&lt;CalendarEventAssignment&gt; events)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L988">		methodStart(&quot;createCalendarEventAssignmentWithLock&quot;, lockID, events);</span>

<span class="nc" id="L990">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
			/* perform what is necessary before a new event gets created */
<span class="nc" id="L993">			m_eventHandler.preCreateEvents(lockID, events);</span>

			/** see if there were any conflicts as a result of this operation */
			// === do not do conflict checking if creating in batch ===
<span class="nc bnc" id="L997" title="All 4 branches missed.">			if (events != null &amp;&amp; !events.isEmpty()) {</span>
<span class="nc bnc" id="L998" title="All 2 branches missed.">				if (events.size() == 1) {</span>
<span class="nc" id="L999">					Collection listConflicts = dao.getConflictsForNewScheduleObjects(events);</span>
<span class="nc bnc" id="L1000" title="All 2 branches missed.">					if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L1001">						throw new BbmScheduleConflictException(listConflicts);</span>
					}
<span class="nc" id="L1003">				} else {</span>
					// create a list of time off events from scheduler,
					// so far no other components to create a list of any type
					// of events in batch.
					// QA94194: schedule sometimes create dup time off events,
					// so far it is not reproducible in house
					// but it happened a lot in customer production mode. here
					// we provide an adhoc-solution, e.g. ignore creating
					// dup time off event for the time off events creating from
					// scheduler.
<span class="nc" id="L1013">					ArrayList sortedList = new ArrayList(events);</span>
<span class="nc" id="L1014">					Collections.sort(sortedList);</span>
<span class="nc" id="L1015">					Date timeRangeStart = ((Event) (sortedList.get(0))).getStartTime();</span>
<span class="nc" id="L1016">					Date timeRangeEnd = ((Event) (sortedList.get(sortedList.size() - 1))).getEndTime();</span>
<span class="nc" id="L1017">					HashSet uniqueIDs = new HashSet(events.size());</span>
<span class="nc bnc" id="L1018" title="All 2 branches missed.">					for (Iterator i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1019">						uniqueIDs.addAll(((Event) i.next()).getWorkResourceIDs());</span>
					}
<span class="nc" id="L1021">					ArrayList workResourceIDs = new ArrayList(uniqueIDs);</span>
<span class="nc" id="L1022">					Collection existingEventsList = getEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF,</span>
							workResourceIDs, timeRangeStart, timeRangeEnd);
<span class="nc" id="L1024">					Collection creatingEventsList = ScheduleDAOUtil.groupEventsByWorkResources(sortedList,</span>
							workResourceIDs);
<span class="nc" id="L1026">					Iterator iCreate = creatingEventsList.iterator();</span>
<span class="nc" id="L1027">					Iterator iExist = existingEventsList.iterator();</span>
					Collection createEvents;
					Collection existEvents;
					Event eventToCreate;
<span class="nc bnc" id="L1031" title="All 2 branches missed.">					for (; iExist.hasNext();) {</span>
<span class="nc" id="L1032">						createEvents = (Collection) iCreate.next();</span>
<span class="nc" id="L1033">						existEvents = (Collection) iExist.next();</span>
<span class="nc bnc" id="L1034" title="All 4 branches missed.">						if (existEvents != null &amp;&amp; !existEvents.isEmpty()) {</span>
<span class="nc bnc" id="L1035" title="All 2 branches missed.">							for (Iterator iEvent = createEvents.iterator(); iEvent.hasNext();) {</span>
<span class="nc" id="L1036">								eventToCreate = (Event) iEvent.next();</span>
<span class="nc bnc" id="L1037" title="All 2 branches missed.">								if (eventToCreate.getEventType() == Event.EVENT_TYPE_TIME_OFF</span>
<span class="nc bnc" id="L1038" title="All 2 branches missed.">										&amp;&amp; isEventInList(eventToCreate, existEvents)) {</span>
<span class="nc" id="L1039">									events.remove(eventToCreate);</span>
<span class="nc" id="L1040">									m_cat.info(&quot;***************** Found Dup Time Off Event: &quot; + eventToCreate);</span>
<span class="nc" id="L1041">									m_cat.info(&quot;***************** Existing events are: &quot; + existEvents);</span>
								}
							}
						}
					}
				}
			}

<span class="nc" id="L1049">			Collection&lt;ID&gt; ids = dao.createObjects(events);</span>

			/* perform what is necessary after a new event gets created */
<span class="nc" id="L1052">			m_eventHandler.postCreateEvents(events);</span>

<span class="nc" id="L1054">			return ids;</span>
<span class="nc" id="L1055">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1056">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1057">			throw e; // just rethrow</span>
<span class="nc" id="L1058">		} catch (BbmCreateException | MultiUserException e) {</span>
<span class="nc" id="L1059">			handleException(e);</span>
<span class="nc" id="L1060">			throw e;</span>
<span class="nc" id="L1061">		} catch (Exception e) {</span>
<span class="nc" id="L1062">			handleException(e);</span>
<span class="nc" id="L1063">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc bnc" id="L1065" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L1066">				dao.cleanUp();</span>
			}
<span class="nc" id="L1068">			methodFinish();</span>
		}
	}

	private boolean isEventInList(Event event, Collection eventList) {
<span class="nc" id="L1073">		boolean isInList = false;</span>
		Event eventInList;
<span class="nc bnc" id="L1075" title="All 2 branches missed.">		for (Iterator i = eventList.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1076">			eventInList = (Event) i.next();</span>
<span class="nc bnc" id="L1077" title="All 2 branches missed.">			if (event.getEventType() == eventInList.getEventType()</span>
<span class="nc bnc" id="L1078" title="All 2 branches missed.">					&amp;&amp; event.getActivityID().equals(eventInList.getActivityID())</span>
<span class="nc bnc" id="L1079" title="All 2 branches missed.">					&amp;&amp; event.getStartTime().equals(eventInList.getStartTime())) {</span>
<span class="nc" id="L1080">				return true;</span>
			}
		}

<span class="nc" id="L1084">		return isInList;</span>
	}

	public void updateCalendarEventAssignment(CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1089">		updateCEAWithLock(null, event);</span>
<span class="nc" id="L1090">	}</span>

	public void updateCalendarEventAssignmentWithLock(String lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1094">		updateCEAWithLock(lockID, event);</span>
<span class="nc" id="L1095">	}</span>

	public void updateCalendarEventAssignment(ID lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1099">		updateCEAWithLock(lockID, event);</span>
<span class="nc" id="L1100">	}</span>

	private void updateCEAWithLock(Object lockID, CalendarEventAssignment event)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1104">		methodStart(&quot;updateCalendarEventAssignmentWithLock&quot;, lockID, event);</span>

<span class="nc" id="L1106">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1107">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
		try {
<span class="nc" id="L1109">			updateCEAWithLockInternal(lockID, event, dmo);</span>
<span class="nc" id="L1110">		} catch (BbmScheduleConflictException | BbmUpdateException | BbmObjectNotFoundException | MultiUserException e) {</span>
<span class="nc" id="L1111">			handleException(e);</span>
<span class="nc" id="L1112">			throw e;</span>
<span class="nc" id="L1113">		} catch (BbmCreateException | BbmFinderException | InvalidObjectException | RemoteException e) {</span>
<span class="nc" id="L1114">			handleException(e);</span>
<span class="nc" id="L1115">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1117">			dmo.cleanUp();</span>
<span class="nc" id="L1118">			methodFinish();</span>
<span class="nc" id="L1119">		}</span>
<span class="nc" id="L1120">	}</span>

	private void updateCEAWithLockInternal(Object lockID, CalendarEventAssignment event, Jdmo dmo) throws BbmCreateException,
			BbmScheduleConflictException, BbmFinderException, BbmUpdateException, MultiUserException, InvalidObjectException,
			RemoteException {

<span class="nc" id="L1126">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
		// event is full update all the time.  to remove linked shift id, we have to make sure the value
		// is set to NullObject instead of null value. however, whenever the calendar event is passed from applet, the NullObject
		// value will be reset to null value. here we can fix it, we should find better way later - angela
<span class="nc bnc" id="L1130" title="All 2 branches missed.">		if (event.getEventType() == Event.EVENT_TYPE_TIME_OFF) {</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">			if (event.getLinkedShiftAssignmentID() == null) {</span>
<span class="nc" id="L1132">				event.setFieldNull(CalendarEventAssignmentFields.SHIFTASSIGNMENTID);</span>
			}
		}

		// save the object before the update
<span class="nc" id="L1137">		CalendarEventAssignment oldEvent = dao.getObjectByID(event.getID());</span>

		// perform what is necessary before an existing event gets updated
<span class="nc" id="L1140">		m_eventHandler.preUpdateEvent(lockID, oldEvent, event);</span>

		// the event object might only have updated attributes instead of the whole picture. Here reset the org attendees list for
		// checking schedule conflict
<span class="nc" id="L1144">		populateExistingAttendee(oldEvent, event);</span>
<span class="nc" id="L1145">		event.setOverlayPrecedence(oldEvent.getOverlayPrecedence());</span>

<span class="nc" id="L1147">		checkConflictForUpdateObject(dmo, event);</span>
<span class="nc" id="L1148">		dao.updateObject(event);</span>

		// QA 94787 - F&amp;S receives an error occurs inside publish schedule
<span class="nc" id="L1151">		ID tplID = event.getEventTemplateID();</span>
<span class="nc bnc" id="L1152" title="All 2 branches missed.">		if (tplID != null</span>
<span class="nc bnc" id="L1153" title="All 2 branches missed.">				&amp;&amp; getCalendarEventTemplateTypeByID(tplID, dmo) == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>

			// this is an exception of recurring template
<span class="nc" id="L1156">			Collection&lt;ID&gt; createdWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1157">			Collection&lt;CalendarEventAttendee&gt; createdAttenddees = event</span>
<span class="nc" id="L1158">					.getCreatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L1159" title="All 4 branches missed.">			if (createdAttenddees != null &amp;&amp; !createdAttenddees.isEmpty()) {</span>
<span class="nc bnc" id="L1160" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAttendee&gt; it = createdAttenddees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1161">					createdWorkResources.add(it.next().getWorkResourceID());</span>
				}
			}

<span class="nc bnc" id="L1165" title="All 2 branches missed.">			if (!createdWorkResources.isEmpty()) {</span>
				// Update template exceptions
<span class="nc" id="L1167">				RecurringEventTemplateDAO tplDao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1168">				tplDao.deleteRecurringEventInstance(tplID, createdWorkResources, event.getStartTime());</span>
			}

<span class="nc" id="L1171">			Collection&lt;ID&gt; deleteWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc" id="L1172">			Collection&lt;CalendarEventAttendee&gt; deletedAttendees = event</span>
<span class="nc" id="L1173">					.getDeletedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L1174" title="All 4 branches missed.">			if (deletedAttendees != null &amp;&amp; !deletedAttendees.isEmpty()) {</span>
<span class="nc bnc" id="L1175" title="All 2 branches missed.">				for (Iterator&lt;CalendarEventAttendee&gt; it = deletedAttendees.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1176">					deleteWorkResources.add(it.next().getWorkResourceID());</span>
				}
			}

<span class="nc bnc" id="L1180" title="All 2 branches missed.">			if (!deleteWorkResources.isEmpty()) {</span>
				// Update template exceptions
<span class="nc" id="L1182">				RecurringEventTemplateDAO tplDao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1183">				RecurringEventTemplateBase recTemplate = tplDao.getObjectByID(tplID);</span>
<span class="nc" id="L1184">				tplDao.deleteRecurringEventException(recTemplate, deleteWorkResources, event.getStartTime());</span>
			}
		}
		// End #94787

		// see if there were any conflicts as a result of this operation
<span class="nc" id="L1190">		event = dao.getObjectByID(event.getID());</span>
<span class="nc" id="L1191">		event.checkIsValid();</span>

		// perform what is necessary after an existing event gets updated
<span class="nc" id="L1194">		m_eventHandler.postUpdateEvent(oldEvent, event);</span>
<span class="nc" id="L1195">	}</span>

	public void deleteCalendarEventAssignmentsWithLock(String lockID, Collection&lt;ID&gt; eventAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="fc" id="L1199">		methodStart(&quot;deleteCalendarEventAssignmentsWithLock&quot;, lockID, eventAssignmentIDs);</span>

<span class="fc" id="L1201">		Jdmo jdmo = new Jdmo();</span>
<span class="fc" id="L1202">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(jdmo);</span>
		try {
			/*
			 * save the the events before deletion, we'll need them for
			 * notifications
			 */
<span class="fc" id="L1208">			Collection&lt;CalendarEventAssignment&gt; listEvents = dao.getObjectsByIDs(eventAssignmentIDs);</span>

			/* perform what is necessary before a bunch of events get deleted */
<span class="fc" id="L1211">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* perform the delete */
<span class="fc" id="L1214">			dao.deleteObjects(eventAssignmentIDs);</span>

			/* perform what is necessary after a bunch of events get deleted */
<span class="fc" id="L1217">			m_eventHandler.postDeleteEvents(listEvents);</span>
<span class="nc" id="L1218">		} catch (BbmRemoveException | MultiUserException e) {</span>
<span class="nc" id="L1219">			handleException(e);</span>
<span class="nc" id="L1220">			throw e;</span>
<span class="nc" id="L1221">		} catch (Exception e) {</span>
<span class="nc" id="L1222">			handleException(e);</span>
<span class="nc" id="L1223">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="pc" id="L1225">			dao.cleanUp();</span>
<span class="pc" id="L1226">			jdmo.cleanUp();</span>
<span class="pc" id="L1227">			methodFinish();</span>
<span class="fc" id="L1228">		}</span>
<span class="fc" id="L1229">	}</span>

	// Tample add for QA 85638:START
	// This method is used to delete CalendarEvenAttendee first.
	// CalendarEventAssignment is only deleted when no workresourceid linked to
	// it
	public void deletePartialCalendarEventAssignments(String lockID, Collection&lt;ID&gt; eventAssignmentIDs,
			Collection&lt;ID&gt; idsExistingInAttendee) throws MultiUserException, BbmRemoveException {
<span class="nc" id="L1237">		methodStart(&quot;deletePartialCalendarEventAssignments&quot;, lockID, eventAssignmentIDs);</span>

<span class="nc" id="L1239">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(new Jdmo());</span>
		try {
			/*
			 * save the the events before deletion, we'll need them for
			 * notifications
			 */
<span class="nc" id="L1245">			Collection&lt;CalendarEventAssignment&gt; listEvents = dao.getObjectsByIDs(eventAssignmentIDs);</span>

			/* perform what is necessary before a bunch of events get deleted */
<span class="nc" id="L1248">			m_eventHandler.preDeleteEvents(lockID, listEvents);</span>

			/* perform the delete */
<span class="nc" id="L1251">			dao.deleteObjects(eventAssignmentIDs, idsExistingInAttendee);</span>

			/* perform what is necessary after a bunch of events get deleted */
<span class="nc" id="L1254">			m_eventHandler.postDeleteEvents(listEvents);</span>
<span class="nc" id="L1255">		} catch (BbmRemoveException | MultiUserException e) {</span>
<span class="nc" id="L1256">			handleException(e);</span>
<span class="nc" id="L1257">			throw e;</span>
<span class="nc" id="L1258">		} catch (Exception e) {</span>
<span class="nc" id="L1259">			handleException(e);</span>
<span class="nc" id="L1260">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L1262">			dao.cleanUp();</span>
<span class="nc" id="L1263">			methodFinish();</span>
<span class="nc" id="L1264">		}</span>
<span class="nc" id="L1265">	}</span>

	public void deleteCalendarEventAssignments(Collection&lt;ID&gt; eventAssignmentIDs)
			throws MultiUserException, BbmRemoveException {
<span class="nc" id="L1269">		deleteCalendarEventAssignmentsWithLock(null, eventAssignmentIDs);</span>
<span class="nc" id="L1270">	}</span>

	public CalendarEventAssignment getCalendarEventAssignmentByID(ID eventID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1274">		methodStart(&quot;getCalendarEventAssignmentByID&quot;, eventID);</span>

<span class="nc" id="L1276">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L1278">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L1279">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L1281">			throw e;</span>
<span class="nc" id="L1282">		} catch (Exception e) {</span>
<span class="nc" id="L1283">			handleException(e);</span>
<span class="nc" id="L1284">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1286">			dao.cleanUp();</span>
<span class="nc" id="L1287">			methodFinish();</span>
		}
	}

	public Collection&lt;CalendarEventAssignment&gt; getCalendarEventAssignmentsByIDs(Collection&lt;ID&gt; ids)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1293">		methodStart(&quot;getCalendarEventAssignmentsByIDs&quot;, ids);</span>

<span class="nc" id="L1295">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L1297">			return dao.getObjectsByIDs(ids);</span>
<span class="nc" id="L1298">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1299">			handleException(e);</span>
<span class="nc" id="L1300">			throw e;</span>
		} finally {
<span class="nc" id="L1302">			dao.cleanUp();</span>
<span class="nc" id="L1303">			methodFinish();</span>
		}
	}

	public &lt;T extends CalendarEventAssignment&gt; Collection&lt;T&gt; getAllEventsByType(int eventType) throws BbmObjectNotFoundException,
			BbmFinderException {
<span class="nc" id="L1309">		methodStart(&quot;getAllUnavailabilityEvents&quot;);</span>

<span class="nc" id="L1311">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L1313">			Collection&lt;CalendarEventAssignment&gt; ceas = dao.getObjects(&quot;A.EVENTTYPE=&quot; + eventType);</span>
<span class="nc" id="L1314">			Collection&lt;T&gt; eventsByType = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L1315" title="All 2 branches missed.">			for (CalendarEventAssignment cea : ceas) {</span>
<span class="nc" id="L1316">				eventsByType.add((T) cea);</span>
<span class="nc" id="L1317">			}</span>
<span class="nc" id="L1318">			return eventsByType;</span>
<span class="nc" id="L1319">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1320">			handleException(e);</span>
<span class="nc" id="L1321">			throw e;</span>
		} finally {
<span class="nc" id="L1323">			dao.cleanUp();</span>
<span class="nc" id="L1324">			methodFinish();</span>
		}
	}

	public CalendarEventAssignment getPublishedCalendarEventAssignmentByID(ID eventID) throws BbmFinderException {
<span class="nc" id="L1329">		methodStart(&quot;getPublishedCalendarEventAssignmentByID&quot;, eventID);</span>

<span class="nc" id="L1331">		CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO();</span>
		try {
<span class="nc" id="L1333">			return dao.getObjectByID(eventID);</span>
<span class="nc" id="L1334">		} catch (BbmObjectNotFoundException e) {</span>
			// no need to rollback/log, this is not a critical error
<span class="nc" id="L1336">			throw e;</span>
<span class="nc" id="L1337">		} catch (Exception e) {</span>
<span class="nc" id="L1338">			handleException(e);</span>
<span class="nc" id="L1339">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1341">			dao.cleanUp();</span>
<span class="nc" id="L1342">			methodFinish();</span>
		}
	}

	public ID createEventTemplateWithInstances(CalendarEventTemplate eventTemplate,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmCreateException {
<span class="nc" id="L1349">		methodStart(&quot;createEventTemplateWithInstances&quot;, eventTemplate, conflictResolutions);</span>

<span class="nc" id="L1351">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1352">		AggEventTemplateDAO dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="nc bnc" id="L1355" title="All 2 branches missed.">			if (dao == null) {</span>
				/* should really never happen */
<span class="nc" id="L1357">				throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/*
			 * perform what is necessary before a new calendar event template
			 * gets created
			 */
<span class="nc" id="L1364">			m_eventHandler.preCreateEventTemplate(eventTemplate);</span>

<span class="nc" id="L1366">			ValueObjectBase valueObj = (ValueObjectBase) eventTemplate;</span>

			/*
			 * see if there were any conflicts created as a result of this
			 * operation
			 */
<span class="nc" id="L1372">			ScheduleConflictChecker checker = (ScheduleConflictChecker) dao;</span>
<span class="nc" id="L1373">			Collection&lt;BbmScheduleConflict&gt; listConflicts = checker.getConflictsForNewScheduleObject(valueObj);</span>

			// if has conflicts and no resolution, throws exceptions without
			// creating object
<span class="nc" id="L1377">			boolean isClass = false;</span>
<span class="nc bnc" id="L1378" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING) {</span>
<span class="nc" id="L1379">				isClass = ((FloatingEventTemplate) eventTemplate).isClass();</span>
			}

<span class="nc" id="L1382">			boolean needToResolve = true;</span>

<span class="nc bnc" id="L1384" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L1385" title="All 2 branches missed.">				if (conflictResolutions == null</span>
<span class="nc bnc" id="L1386" title="All 2 branches missed.">						|| !ScheduleDAOUtil.areConflictsResolvable(listConflicts, conflictResolutions)) {</span>
<span class="nc bnc" id="L1387" title="All 2 branches missed.">					if (isClass) {</span>
<span class="nc" id="L1388">						((FloatingEventTemplate) eventTemplate).setConflicts(listConflicts);</span>
<span class="nc" id="L1389">						needToResolve = false;</span>
					} else {
<span class="nc" id="L1391">						throw new BbmScheduleConflictException(listConflicts);</span>
					}
				}
			}

			// in case the resolution is to remove one recurring instance
			// need template id to create recurring exception
<span class="nc" id="L1398">			ID templateID = dao.createObject(valueObj);</span>
<span class="nc" id="L1399">			valueObj.setID(templateID);</span>
			// resolve the conflictions
<span class="nc bnc" id="L1401" title="All 4 branches missed.">			if (!listConflicts.isEmpty() &amp;&amp; needToResolve) {</span>
<span class="nc" id="L1402">				setNewlyCreatedTemplateID(templateID, listConflicts);</span>
<span class="nc" id="L1403">				ScheduleDAOUtil.resolveConflicts(listConflicts, conflictResolutions);</span>
			}

			/*
			 * perform what is necessary after a new calendar event template
			 * gets created
			 */
<span class="nc bnc" id="L1410" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING</span>
<span class="nc bnc" id="L1411" title="All 2 branches missed.">					|| eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L1412">				m_eventHandler.postCreateEventTemplate(eventTemplate);</span>
			} else {
				// for floating event template. we will create audit on real
				// created event.
<span class="nc" id="L1416">				List&lt;ID&gt; idTemp = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L1417">				idTemp.add(templateID);</span>
<span class="nc" id="L1418">				Collection&lt;CalendarEventAssignment&gt; events = getCalendarEventAssignmentsForCalendarEventTemplate(idTemp)</span>
<span class="nc" id="L1419">						.iterator().next();</span>
<span class="nc bnc" id="L1420" title="All 2 branches missed.">				if (events != null) {</span>
<span class="nc bnc" id="L1421" title="All 2 branches missed.">					for (Iterator&lt;CalendarEventAssignment&gt; i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1422">						m_eventHandler.postCreateEvent(i.next());</span>
					}
				}
			}

<span class="nc" id="L1427">			return templateID;</span>
<span class="nc" id="L1428">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1429">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1430">			throw e;</span>
<span class="nc" id="L1431">		} catch (BbmCreateException | MultiUserException e) {</span>
<span class="nc" id="L1432">			handleException(e);</span>
<span class="nc" id="L1433">			throw e;</span>
<span class="nc" id="L1434">		} catch (Exception e) {</span>
<span class="nc" id="L1435">			handleException(e);</span>
<span class="nc" id="L1436">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1438">			dmo.cleanUp();</span>
<span class="nc" id="L1439">			methodFinish();</span>
		}
	}

	/**
	 * This method is specifically defined for
	 * createEventTemplateWithInstances(). the template id is only neccessory
	 * for rec template /shift or event conflict only.
	 *
	 * @param templateID
	 * @param conflicts
	 */
	private void setNewlyCreatedTemplateID(ID templateID, Collection&lt;BbmScheduleConflict&gt; conflicts) {
		BbmScheduleConflict conflict;
		RecurringEventTemplateBase recTemplate;
<span class="nc bnc" id="L1454" title="All 2 branches missed.">		for (Iterator&lt;BbmScheduleConflict&gt; i = conflicts.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1455">			conflict = i.next();</span>
<span class="nc" id="L1456">			recTemplate = conflict.getRecurringTemplate();</span>
<span class="nc bnc" id="L1457" title="All 2 branches missed.">			if (recTemplate != null) {</span>
<span class="nc" id="L1458">				recTemplate.setID(templateID);</span>
			}
		}
<span class="nc" id="L1461">	}</span>

	public void deleteEventTemplateWithInstances(ID templateID) throws MultiUserException, BbmRemoveException {
<span class="nc" id="L1464">		methodStart(&quot;deleteCalendarEventTemplateWithInstances&quot;, templateID);</span>

<span class="nc" id="L1466">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1468">			AggEventTemplateDAO dao = getDAOByEventTemplateID(templateID, dmo);</span>
<span class="nc bnc" id="L1469" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1470">				throw new BbmRemoveException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/**
			 * save the template before blowing it away for notification
			 * purposes
			 */
<span class="nc" id="L1477">			CalendarEventTemplate savedTemplate = dao.getObjectByID(templateID);</span>

			// special handle floating exception for
			// recurringfloatingeventtemplate
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if (savedTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L1482">				FloatingEventTemplateDAO floatDAO = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L1483">				Collection&lt;FloatingEventTemplate&gt; floatExceptions = floatDAO</span>
<span class="nc" id="L1484">						.getObjects(floatDAO.getFieldInfo().getParentIDFieldName() + &quot;=&quot; + savedTemplate.getID());</span>
<span class="nc bnc" id="L1485" title="All 4 branches missed.">				if (floatExceptions != null &amp;&amp; !floatExceptions.isEmpty()) {</span>
<span class="nc" id="L1486">					List&lt;ID&gt; ids = new ArrayList&lt;&gt;(floatExceptions.size());</span>
<span class="nc bnc" id="L1487" title="All 2 branches missed.">					for (Iterator&lt;FloatingEventTemplate&gt; i = floatExceptions.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1488">						ids.add(i.next().getID());</span>
					}
<span class="nc" id="L1490">					floatDAO.deleteObjects(ids);</span>
				}
			}

			/*
			 * perform what is necessary after a calendar event template gets
			 * deleted
			 */
<span class="nc" id="L1498">			m_eventHandler.preDeleteEventTemplate(savedTemplate);</span>

<span class="nc" id="L1500">			dao.deleteObject(templateID);</span>

			/*
			 * perform what is necessary whenever a new calendar event template
			 * gets deleted
			 */
<span class="nc" id="L1506">			m_eventHandler.postDeleteEventTemplate(savedTemplate);</span>
<span class="nc" id="L1507">		} catch (BbmObjectNotFoundException e) {</span>
			/* they're trying to delete a non-existant object - just ignore */
<span class="nc" id="L1509">		} catch (MultiUserException e) {</span>
<span class="nc" id="L1510">			handleException(e);</span>
<span class="nc" id="L1511">			throw e;</span>
<span class="nc" id="L1512">		} catch (Exception e) {</span>
<span class="nc" id="L1513">			handleException(e);</span>
<span class="nc" id="L1514">			throw new BbmRemoveException(e);</span>
		} finally {
<span class="nc" id="L1516">			dmo.cleanUp();</span>
<span class="nc" id="L1517">			methodFinish();</span>
<span class="nc" id="L1518">		}</span>
<span class="nc" id="L1519">	}</span>

	/**
	 * @deprecated
	 * @param eventTemplate
	 * @return
	 * @throws BbmFinderException
	 */
	@Deprecated
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForCalendarEventTemplate(CalendarEventTemplate eventTemplate)
			throws BbmFinderException {
<span class="nc bnc" id="L1530" title="All 2 branches missed.">		if (eventTemplate.getID() == null) {</span>
<span class="nc" id="L1531">			return getConflictsForNewCalendarEventTemplate(eventTemplate);</span>
		} else {
<span class="nc" id="L1533">			return getConflictsForUpdatedCalendarEventTemplate(eventTemplate);</span>
		}
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewCalendarEventTemplate(CalendarEventTemplate eventTemplate)
			throws BbmFinderException {
<span class="nc" id="L1539">		return getConflictsForCalendarEventTemplate(eventTemplate, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedCalendarEventTemplate(
			CalendarEventTemplate eventTemplate) throws BbmFinderException {
<span class="nc" id="L1544">		return getConflictsForCalendarEventTemplate(eventTemplate, false);</span>
	}

	private Collection&lt;BbmScheduleConflict&gt; getConflictsForCalendarEventTemplate(CalendarEventTemplate eventTemplate,
			boolean isForNewObject) throws BbmFinderException {
<span class="nc" id="L1549">		methodStart(&quot;getConflictsForCalendarEventTemplate&quot;, eventTemplate);</span>

<span class="nc" id="L1551">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1552">		DAOBase dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="nc bnc" id="L1555" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1556">				throw new BbmFinderException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE, null);</span>
			}

<span class="nc" id="L1559">			ValueObjectAggEventTemplate newTemp = (ValueObjectAggEventTemplate) eventTemplate;</span>
<span class="nc bnc" id="L1560" title="All 2 branches missed.">			if (!isForNewObject) {</span>
<span class="nc" id="L1561">				CalendarEventTemplate oldTemplate = (CalendarEventTemplate) dao.getObjectByID(eventTemplate.getID());</span>
				// the template object might only have updated attributes
				// instead
				// of the whole picture. Here reset the org attendees list for
				// checking
				// schedule conflict
<span class="nc" id="L1567">				ValueObjectAggEventTemplate oldTemp = (ValueObjectAggEventTemplate) oldTemplate;</span>

<span class="nc" id="L1569">				populateExistingAttendee(oldTemp, newTemp);</span>
<span class="nc" id="L1570">				newTemp.setOverlayPrecedence(oldTemp.getOverlayPrecedence());</span>
			}

			Collection&lt;BbmScheduleConflict&gt; listConflicts;
<span class="nc bnc" id="L1574" title="All 2 branches missed.">			if (isForNewObject) {</span>
<span class="nc" id="L1575">				listConflicts = ((ScheduleConflictChecker) dao).getConflictsForNewScheduleObject(newTemp);</span>
			} else {
<span class="nc" id="L1577">				listConflicts = ((ScheduleConflictChecker) dao).getConflictsForUpdatedScheduleObject(newTemp);</span>
			}

<span class="nc" id="L1580">			return listConflicts;</span>
<span class="nc" id="L1581">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1582">			handleException(e);</span>
<span class="nc" id="L1583">			throw e;</span>
<span class="nc" id="L1584">		} catch (Exception e) {</span>
<span class="nc" id="L1585">			handleException(e);</span>
<span class="nc" id="L1586">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L1588">			dmo.cleanUp();</span>
<span class="nc" id="L1589">			methodFinish();</span>
		}
	}

	public CalendarEventTemplate getCalendarEventTemplateByID(ID templateID)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1595">		methodStart(&quot;getCalendarEventTemplateByID&quot;, templateID);</span>

<span class="nc" id="L1597">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1599">			DAOBase dao = getDAOByEventTemplateID(templateID, dmo);</span>
<span class="nc bnc" id="L1600" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1601">				throw new BbmFinderException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE, null);</span>
			}
<span class="nc" id="L1603">			return (CalendarEventTemplate) dao.getObjectByID(templateID);</span>
<span class="nc" id="L1604">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1605">			handleException(e);</span>
<span class="nc" id="L1606">			throw e;</span>
		} finally {
<span class="nc" id="L1608">			dmo.cleanUp();</span>
<span class="nc" id="L1609">			methodFinish();</span>
		}
	}

	public Collection&lt;ValueObjectAggEventTemplate&gt; getCalendarEventTemplatesByIDs(Collection&lt;ID&gt; ctemplateIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L1615">		methodStart(&quot;getCalendarEventTemplatesByIDs&quot;, ctemplateIDs);</span>

<span class="nc" id="L1617">		Jdmo dmo1 = new Jdmo();</span>
		try {
<span class="nc" id="L1619">			Collection&lt;ValueObjectAggEventTemplate&gt; templates = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L1621">			FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo1);</span>
<span class="nc" id="L1622">			templates.addAll(dao1.getObjectsByIDs(ctemplateIDs));</span>
<span class="nc" id="L1623">			RecurringEventTemplateDAO dao2 = new RecurringEventTemplateDAO(dmo1);</span>
<span class="nc" id="L1624">			templates.addAll(dao2.getObjectsByIDs(ctemplateIDs));</span>

<span class="nc" id="L1626">			return templates;</span>
<span class="nc" id="L1627">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L1628">			handleException(e);</span>
<span class="nc" id="L1629">			throw e;</span>
		} finally {
<span class="nc" id="L1631">			dmo1.cleanUp();</span>
<span class="nc" id="L1632">			methodFinish();</span>
		}
	}

	public void updateEventTemplateWithInstances(CalendarEventTemplate eventTemplate,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmObjectNotFoundException, BbmUpdateException {
<span class="nc" id="L1639">		methodStart(&quot;updateEventTemplateWithInstances&quot;, eventTemplate, conflictResolutions);</span>

<span class="nc" id="L1641">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1642">		DAOBase dao = getDAOByEventTemplateType(eventTemplate.getTemplateType(), dmo);</span>

		try {
<span class="nc bnc" id="L1645" title="All 2 branches missed.">			if (dao == null) {</span>
<span class="nc" id="L1646">				throw new BbmUpdateException(BbmEjbBundleKey.SCHEDULE_UNSUPPORTED_EVENT_TEMPLATE);</span>
			}

			/*
			 * save the old template before updating it, since we'll need it for
			 * notifications
			 */
<span class="nc" id="L1653">			CalendarEventTemplate oldTemplate = (CalendarEventTemplate) dao.getObjectByID(eventTemplate.getID());</span>

			/*
			 * perform what is necessary before an existing calendar event
			 * template gets updated
			 */
<span class="nc" id="L1659">			m_eventHandler.preUpdateEventTemplate(oldTemplate);</span>

			// the template object might only have updated attributes instead
			// of the whole picture. Here reset the org attendees list for
			// checking
			// schedule conflict
<span class="nc" id="L1665">			ValueObjectAggEventTemplate oldTemp = (ValueObjectAggEventTemplate) oldTemplate;</span>
<span class="nc" id="L1666">			ValueObjectAggEventTemplate newTemp = (ValueObjectAggEventTemplate) eventTemplate;</span>

			// Trung Nguyen QA 83594
			// copy child objects (Recurring Event Object) to new template in
			// order to exclude
			// the RECURRING EVENT when checking conflict
<span class="nc bnc" id="L1672" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>
<span class="nc" id="L1673">				Collection childObjectsOfOld = oldTemp.getChildObjects(RecurringEventTemplateFields.CHILD_EXCEPTION);</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">				if (childObjectsOfOld != null) {</span>
<span class="nc bnc" id="L1675" title="All 2 branches missed.">					for (Iterator i = childObjectsOfOld.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1676">						newTemp.fillChildObject(RecurringEventTemplateFields.CHILD_EXCEPTION,</span>
<span class="nc" id="L1677">								(ValueObjectBase) i.next());</span>
					}
				}
			}
<span class="nc" id="L1681">			populateExistingAttendee(oldTemp, newTemp);</span>
<span class="nc" id="L1682">			newTemp.setOverlayPrecedence(oldTemp.getOverlayPrecedence());</span>

<span class="nc" id="L1684">			ScheduleConflictChecker checker = (ScheduleConflictChecker) dao;</span>
<span class="nc" id="L1685">			Collection listConflicts = checker.getConflictsForUpdatedScheduleObject(newTemp);</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L1687" title="All 2 branches missed.">				if (conflictResolutions == null</span>
<span class="nc bnc" id="L1688" title="All 2 branches missed.">						|| !ScheduleDAOUtil.areConflictsResolvable(listConflicts, conflictResolutions)) {</span>
<span class="nc" id="L1689">					throw new BbmScheduleConflictException(listConflicts);</span>
				} else {
					// resolve the conflictions
<span class="nc" id="L1692">					ScheduleDAOUtil.resolveConflicts(listConflicts, conflictResolutions);</span>
				}
			}

			// QA 91070 - check if the class name is already exist
<span class="nc bnc" id="L1697" title="All 2 branches missed.">			if (eventTemplate.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING) {</span>
<span class="nc" id="L1698">				FloatingEventTemplateDAO floatingEventTemplateDAO = (FloatingEventTemplateDAO) dao;</span>
<span class="nc" id="L1699">				floatingEventTemplateDAO.checkDuplcateClassName((FloatingEventTemplate) newTemp);</span>
			}

			/* now update */
<span class="nc" id="L1703">			dao.updateObject(newTemp);</span>

			/*
			 * perform what is necessary whenever an existing calendar event
			 * template gets updated
			 */
<span class="nc" id="L1709">			m_eventHandler.postUpdateEventTemplate(oldTemplate, newTemp);</span>
<span class="nc" id="L1710">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1711">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1712">			throw e; // just rethrow</span>
<span class="nc" id="L1713">		} catch (BbmUpdateException | BbmObjectNotFoundException | MultiUserException e) {</span>
<span class="nc" id="L1714">			handleException(e);</span>
<span class="nc" id="L1715">			throw e;</span>
<span class="nc" id="L1716">		} catch (BbmException e) {</span>
<span class="nc" id="L1717">			throw new BbmUpdateException(e.getBundleName(), e.getMsgID(), e.getParamObject());</span>
<span class="nc" id="L1718">		} catch (Exception e) {</span>
<span class="nc" id="L1719">			handleException(e);</span>
<span class="nc" id="L1720">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L1722">			dmo.cleanUp();</span>
<span class="nc" id="L1723">			methodFinish();</span>
<span class="nc" id="L1724">		}</span>
<span class="nc" id="L1725">	}</span>

	/**
	 * Updates an instance of a recurring event template (standard, time off, or unavailability but not floating).
	 *
	 * This will create a new RecurringEventException in the database as well as a new CalendarEventAssignment representing
	 * the newly updated event.
	 *
	 * @param info
	 * @return
	 * @throws BbmScheduleConflictException
	 * @throws BbmObjectNotFoundException
	 * @throws MultiUserException
	 * @throws BbmCreateException
	 * @throws BbmUpdateException
	 */
	public CalendarEventAssignment updateRecurringEventInstance(RecurringEventUpdateInfo info)
			throws BbmScheduleConflictException, BbmObjectNotFoundException, MultiUserException, BbmCreateException,
			BbmUpdateException {
<span class="nc" id="L1744">		methodStart(&quot;updateRecurringEventInstance&quot;, info);</span>

		try {
<span class="nc" id="L1747">			CalendarEventAssignment newCalendarEventAssignment = createRecurringEventException(info.getTemplateID(),</span>
<span class="nc" id="L1748">					info.getOriginalWorkResourceIDs(), info.getOriginalStartDate());</span>

<span class="nc bnc" id="L1750" title="All 2 branches missed.">			for (ID newID : info.getNewWorkResourceIDs()) {</span>
<span class="nc bnc" id="L1751" title="All 2 branches missed.">				if (!info.getOriginalWorkResourceIDs().contains(newID)) {</span>
<span class="nc" id="L1752">					newCalendarEventAssignment.addWorkResourceID(newID);</span>
				}
<span class="nc" id="L1754">			}</span>
<span class="nc bnc" id="L1755" title="All 2 branches missed.">			for (ID oldID : info.getOriginalWorkResourceIDs()) {</span>
<span class="nc bnc" id="L1756" title="All 2 branches missed.">				if (!info.getNewWorkResourceIDs().contains(oldID)) {</span>
<span class="nc" id="L1757">					newCalendarEventAssignment.removeWorkResourceID(oldID);</span>
				}
<span class="nc" id="L1759">			}</span>

<span class="nc" id="L1761">			newCalendarEventAssignment.setStartTime(info.getNewStartDate());</span>
<span class="nc" id="L1762">			newCalendarEventAssignment.setDuration(info.getNewDuration());</span>
<span class="nc" id="L1763">			newCalendarEventAssignment.setLocked(info.isNewEventLocked());</span>
<span class="nc" id="L1764">			newCalendarEventAssignment.setDescription(info.getNewEventDescription());</span>
<span class="nc" id="L1765">			newCalendarEventAssignment.setActivityID(info.getEventActivityID());</span>

<span class="nc" id="L1767">			newCalendarEventAssignment.setUpdateUser(m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L1768">			updateCalendarEventAssignment(newCalendarEventAssignment);</span>
<span class="nc" id="L1769">			return newCalendarEventAssignment;</span>
<span class="nc" id="L1770">		} catch (BbmUpdateException | MultiUserException | BbmObjectNotFoundException | BbmScheduleConflictException</span>
				| BbmCreateException e) {
<span class="nc" id="L1772">			handleException(e);</span>
<span class="nc" id="L1773">			throw e;</span>
		} finally {
<span class="nc" id="L1775">			methodFinish();</span>
		}
	}

	public CalendarEventAssignment createRecurringEventException(ID templateID, Collection&lt;ID&gt; workResourceIDs,
			Date exceptionDate) throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1781">		return createRecurringEventException(null, templateID, workResourceIDs, exceptionDate);</span>
	}

	public CalendarEventAssignment createRecurringEventException(ID lockID, ID templateID, Collection workResourceIDs,
			Date exceptionDate) throws BbmCreateException, BbmScheduleConflictException, MultiUserException {
<span class="nc" id="L1786">		methodStart(&quot;createRecurringEventException&quot;, lockID, templateID, workResourceIDs, exceptionDate);</span>

<span class="nc" id="L1788">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1790">			return createRecurringEventExceptionInternal(lockID, templateID, workResourceIDs, exceptionDate, dmo);</span>
<span class="nc" id="L1791">		} catch (BbmCreateException | BbmScheduleConflictException | MultiUserException e) {</span>
<span class="nc" id="L1792">			handleException(e);</span>
<span class="nc" id="L1793">			throw e;</span>
<span class="nc" id="L1794">		} catch (BbmFinderException | RemoteException e) {</span>
<span class="nc" id="L1795">			handleException(e);</span>
<span class="nc" id="L1796">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1798">			dmo.cleanUp();</span>
<span class="nc" id="L1799">			methodFinish();</span>
		}
	}

	private CalendarEventAssignment createRecurringEventExceptionInternal(ID lockID, ID templateID, Collection workResourceIDs,
			Date exceptionDate, Jdmo dmo) throws BbmFinderException, BbmCreateException, BbmScheduleConflictException,
			MultiUserException, RemoteException {
<span class="nc" id="L1806">		RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L1807">		RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

<span class="nc" id="L1809">		CalendarEventAssignment eventException = (CalendarEventAssignment) dao</span>
<span class="nc" id="L1810">				.createRecurringEventException(recTemplate, workResourceIDs, exceptionDate, 0, null, null, null);</span>

		// check if the exception already created before, QC67759
<span class="nc" id="L1813">		Collection&lt;ID&gt; conflictWorkResources = new HashSet&lt;ID&gt;();</span>
<span class="nc bnc" id="L1814" title="All 2 branches missed.">		for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1815">			ID workResourceID = (ID) it.next();</span>
<span class="nc bnc" id="L1816" title="All 2 branches missed.">			if (recTemplate.existsExceptionOnDate(eventException.getStartTime(), workResourceID)) {</span>
<span class="nc" id="L1817">				conflictWorkResources.add(workResourceID);</span>
			}
<span class="nc" id="L1819">		}</span>

<span class="nc" id="L1821">		Collection&lt;BbmScheduleConflict&gt; listConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="nc bnc" id="L1822" title="All 2 branches missed.">		if (!conflictWorkResources.isEmpty()) {</span>
<span class="nc" id="L1823">			BbmScheduleConflict schConflict = new BbmScheduleConflict(eventException, conflictWorkResources);</span>
<span class="nc" id="L1824">			listConflicts.add(schConflict);</span>
<span class="nc" id="L1825">			ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>
		}
<span class="nc bnc" id="L1827" title="All 2 branches missed.">		if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L1828">			throw new BbmScheduleConflictException(listConflicts);</span>
		}
		// end QC67759

<span class="nc" id="L1832">		checkConflictForNewObject(dmo, eventException, templateID);</span>

		// perform what is necessary after an exception to the recurring event template rule gets created
<span class="nc" id="L1835">		m_eventHandler.postCreateRecurringException(eventException);</span>

<span class="nc" id="L1837">		return eventException;</span>
	}

	/**
	 * Calls createRecurringEventExceptionInternal() and updateCEAWithLockInternal() with the same dmo instance, so that
	 * any conflict exception will rollback the entire transaction.
	 * This logic was moved here from the web tier (CalendarAppletRequestHandler).
	 *
	 * @param data	- Exception creation data object
	 */
	public ID createRecurringEventExceptionAndUpdateCalendarEventAssignment(EventTemplateExceptionCreateData data, String userName)
			throws MultiUserException, BbmCreateException, BbmScheduleConflictException {

<span class="nc" id="L1850">		methodStart(&quot;createRecurringEventExceptionAndUpdateCalendarEventAssignment&quot;, data, userName);</span>

<span class="nc" id="L1852">		Collection&lt;ID&gt; workResourceIDs = data.getNewWorkResourceIDs();</span>
<span class="nc" id="L1853">		CalendarEventAssignment exceptionEvent = data.getExceptionEvent();</span>
<span class="nc" id="L1854">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L1856">			CalendarEventAssignment recurringEventException = createRecurringEventExceptionInternal(null, data.getTemplateID(),</span>
<span class="nc" id="L1857">					workResourceIDs, data.getOrigStartDate(), dmo);</span>

<span class="nc" id="L1859">			workResourceIDs.removeAll(exceptionEvent.getRemovedWorkResourceIDs());</span>
<span class="nc bnc" id="L1860" title="All 2 branches missed.">			for (ID nextID : data.getTemplate().getWorkResourceIDs()) {</span>
<span class="nc bnc" id="L1861" title="All 2 branches missed.">				if (!workResourceIDs.contains(nextID)) {</span>
<span class="nc" id="L1862">					recurringEventException.removeWorkResourceID(nextID);</span>
				}
<span class="nc" id="L1864">			}</span>

<span class="nc bnc" id="L1866" title="All 2 branches missed.">			for (ID nextID : workResourceIDs) {</span>
<span class="nc bnc" id="L1867" title="All 2 branches missed.">				if (!recurringEventException.getWorkResourceIDs().contains(nextID)) {</span>
<span class="nc" id="L1868">					recurringEventException.addWorkResourceID(nextID);</span>
				}
<span class="nc" id="L1870">			}</span>
<span class="nc" id="L1871">			recurringEventException.setStartTime(data.getNewStartDate());</span>
<span class="nc" id="L1872">			recurringEventException.setDuration(data.getNewDuration());</span>
<span class="nc" id="L1873">			recurringEventException.setLocked(data.isLocked());</span>
<span class="nc" id="L1874">			recurringEventException.setDescription(exceptionEvent.getDescription());</span>
<span class="nc" id="L1875">			recurringEventException.setActivityID(exceptionEvent.getActivityID());</span>
<span class="nc" id="L1876">			recurringEventException.setUpdateUser(userName);</span>
<span class="nc" id="L1877">			updateCEAWithLockInternal(null, recurringEventException, dmo);</span>
<span class="nc" id="L1878">			return recurringEventException.getID();</span>
<span class="nc" id="L1879">		} catch (BbmCreateException | BbmScheduleConflictException | MultiUserException e) {</span>
<span class="nc" id="L1880">			handleException(e);</span>
<span class="nc" id="L1881">			throw e;</span>
<span class="nc" id="L1882">		} catch (BbmFinderException | RemoteException | BbmUpdateException | InvalidObjectException e) {</span>
<span class="nc" id="L1883">			handleException(e);</span>
<span class="nc" id="L1884">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1886">			dmo.cleanUp();</span>
<span class="nc" id="L1887">			methodFinish();</span>
		}
	}

	public void deleteRecurringEventInstance(ID templateID, Collection&lt;ID&gt; workResourceIDs, Date exceptionDate)
			throws MultiUserException, BbmCreateException {
<span class="nc" id="L1893">		methodStart(&quot;deleteRecurringEventInstance&quot;, templateID, workResourceIDs, exceptionDate);</span>

<span class="nc" id="L1895">		RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(new Jdmo());</span>
		try {
<span class="nc" id="L1897">			RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

			/** save the old event information for notification purposes */
<span class="nc" id="L1900">			Collection listEvents = recTemplate.getRecurringEventsOnDay(workResourceIDs, exceptionDate);</span>

			/*
			 * perform what is necessary before a recurring event instances get
			 * deleted
			 */
<span class="nc" id="L1906">			m_eventHandler.preDeleteRecurringEventInstance(listEvents, workResourceIDs);</span>

<span class="nc" id="L1908">			dao.deleteRecurringEventInstance(recTemplate, workResourceIDs, exceptionDate);</span>

			/*
			 * perform what is necessary after a recurring event instances get
			 * deleted
			 */
<span class="nc" id="L1914">			m_eventHandler.postDeleteRecurringEventInstance(templateID, listEvents, workResourceIDs);</span>
<span class="nc" id="L1915">		} catch (BbmFinderException e) {</span>
			/**
			 * this is not an error - simply the recurring event template with
			 * the given ID does not exist
			 */
<span class="nc" id="L1920">		} catch (BbmCreateException | MultiUserException e) {</span>
<span class="nc" id="L1921">			handleException(e);</span>
<span class="nc" id="L1922">			throw e;</span>
<span class="nc" id="L1923">		} catch (Exception e) {</span>
<span class="nc" id="L1924">			handleException(e);</span>
<span class="nc" id="L1925">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1927">			dao.cleanUp();</span>
<span class="nc" id="L1928">			methodFinish();</span>
<span class="nc" id="L1929">		}</span>
<span class="nc" id="L1930">	}</span>

	public ID createClassSession(ID templateID, CalendarEvent event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1934">		return createClassSessionWithLock(null, templateID, event);</span>
	}

	public ID createClassSessionWithLock(String sLock, ID templateID, CalendarEvent event)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L1939">		methodStart(&quot;createClassSession&quot;, templateID, event);</span>

<span class="nc" id="L1941">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L1942">		FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L1943">		CalendarEventAssignmentDAO dao2 = new CalendarEventAssignmentDAO(dmo);</span>
		try {
			/* first check that templateID is the ID of a class */
<span class="nc" id="L1946">			ValueObjectBase templateObj = dao1.getObjectByID(templateID);</span>
<span class="nc bnc" id="L1947" title="All 4 branches missed.">			if (!(templateObj instanceof FloatingEventTemplate) || !((FloatingEventTemplate) templateObj).isClass()) {</span>
<span class="nc" id="L1948">				throw new BbmCreateException(BbmEjbBundleKey.SCHEDULE_NOT_A_CLASS_TEMPLATE,</span>
						new Object[] {
								templateID });
			}

			/* perform what is necessary before a new event gets created */
			/** see if there were any conflicts as a result of this operation */
<span class="nc" id="L1955">			Collection listConflicts = dao2.getConflictsForNewScheduleObject(event);</span>
<span class="nc bnc" id="L1956" title="All 2 branches missed.">			if (!listConflicts.isEmpty()) {</span>
<span class="nc" id="L1957">				throw new BbmScheduleConflictException(listConflicts);</span>
			}

<span class="nc" id="L1960">			event.setFieldValue(CalendarEventAssignmentFields.TEMPLATEID, templateID);</span>
<span class="nc" id="L1961">			ID eventID = dao2.createObject(event);</span>

			/* perform what is necessary after a new event gets created */
<span class="nc" id="L1964">			m_eventHandler.postCreateEvent(event);</span>

<span class="nc" id="L1966">			return eventID;</span>
<span class="nc" id="L1967">		} catch (BbmScheduleConflictException e) {</span>
<span class="nc" id="L1968">			handleException(org.apache.log4j.Priority.DEBUG, e);</span>
<span class="nc" id="L1969">			throw e;</span>
<span class="nc" id="L1970">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L1971">			handleException(e);</span>
<span class="nc" id="L1972">			throw e;</span>
<span class="nc" id="L1973">		} catch (Exception e) {</span>
<span class="nc" id="L1974">			handleException(e);</span>
<span class="nc" id="L1975">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L1977">			dmo.cleanUp();</span>
<span class="nc" id="L1978">			methodFinish();</span>
		}
	}

	public void lockEvents(int eventTypeMask, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmUpdateException {
<span class="nc" id="L1984">		methodStart(&quot;lockEvents&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L1985">		Jdmo dmo = new Jdmo();</span>
		try {
			/* perform what is necessary before the events are locked */
<span class="nc" id="L1988">			m_eventHandler.preLockEvents(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc bnc" id="L1990" title="All 4 branches missed.">			if (((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0)</span>
					|| ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) != 0)) {
<span class="nc" id="L1992">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="nc" id="L1993">				dao.lockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc bnc" id="L1995" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="nc" id="L1996">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L1997">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, true,</span>
<span class="nc" id="L1998">						getExtraCondition(eventTypeMask));</span>
			}

			/* perform what is necessary after the events are locked */
<span class="nc" id="L2002">			m_eventHandler.postLockEvents(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2003">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2004">			handleException(e);</span>
<span class="nc" id="L2005">			throw e;</span>
<span class="nc" id="L2006">		} catch (Exception e) {</span>
<span class="nc" id="L2007">			handleException(e);</span>
<span class="nc" id="L2008">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L2010">			dmo.cleanUp();</span>
<span class="nc" id="L2011">			methodFinish();</span>
<span class="nc" id="L2012">		}</span>
<span class="nc" id="L2013">	}</span>

	public void unlockEvents(int eventTypeMask, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmUpdateException {
<span class="nc" id="L2017">		methodStart(&quot;unLockEvents&quot;, NumberFactory.newInteger(eventTypeMask), workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2018">		Jdmo dmo = new Jdmo();</span>
		try {
			/* perform what is necessary before the events are locked */
<span class="nc" id="L2021">			m_eventHandler.preUnlockEvents(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc bnc" id="L2023" title="All 4 branches missed.">			if (((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_ASSIGNMENT) != 0)</span>
					|| ((eventTypeMask &amp; Event.EVENT_TYPE_SHIFT_EVENT_ASSIGNMENT) != 0)) {
<span class="nc" id="L2025">				ShiftAssignmentDAO dao = new ShiftAssignmentDAO(dmo);</span>
<span class="nc" id="L2026">				dao.unlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc bnc" id="L2028" title="All 2 branches missed.">			if ((eventTypeMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="nc" id="L2029">				CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L2030">				dao.lockOrUnlockEvents(eventTypeMask, workResourceIDs, dtStart, dtEnd, false,</span>
<span class="nc" id="L2031">						getExtraCondition(eventTypeMask));</span>
			}

			/* perform what is necessary after the events are locked */
<span class="nc" id="L2035">			m_eventHandler.postUnlockEvents(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2036">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L2037">			handleException(e);</span>
<span class="nc" id="L2038">			throw e;</span>
<span class="nc" id="L2039">		} catch (Exception e) {</span>
<span class="nc" id="L2040">			handleException(e);</span>
<span class="nc" id="L2041">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L2043">			dmo.cleanUp();</span>
<span class="nc" id="L2044">			methodFinish();</span>
<span class="nc" id="L2045">		}</span>
<span class="nc" id="L2046">	}</span>

	private String getExtraCondition(int eventTypeMask) {
<span class="nc" id="L2049">		StringBuilder sb = new StringBuilder();</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">		if ((eventTypeMask &amp; Event.EVENT_TYPE_FLOATINGEVENTSSESSIONS) != 0) {</span>
<span class="nc" id="L2051">			sb.append(&quot; and calendareventtemplateid in (select id from floatingeventtemplate) &quot;);</span>
		}
<span class="nc bnc" id="L2053" title="All 2 branches missed.">		if ((eventTypeMask &amp; Event.EVENT_TYPE_PROJECTS) != 0) {</span>
<span class="nc" id="L2054">			sb</span>
<span class="nc" id="L2055">					.append(&quot; and Exists ( select a.ID from ACTIVITY a inner join ACTIVITYMEDIA am on a.ID = am.ACTIVITYID&quot;)</span>
<span class="nc" id="L2056">					.append(&quot; inner join MEDIA m on am.MEDIAID = m.SID where m.SID = &quot;)</span>
<span class="nc" id="L2057">					.append(Media.MEDIA_ID_PROJECT)</span>
<span class="nc" id="L2058">					.append(&quot; and CALENDAREVENTASSIGNMENT.ACTIVITYID = a.ID)&quot;);</span>
		}
<span class="nc" id="L2060">		return sb.toString();</span>
	}

	/**
	 * This API is created for request manager to manage time off request. Since
	 * it will do the partial publish, we won't touch publishing period.
	 *
	 * @param workResourceIDs
	 * @param dtStart
	 * @param dtEnd
	 */
	public void publishTimeOffEvents(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2073">		methodStart(&quot;publishTimeOffEvents&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="nc bnc" id="L2074" title="All 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L2075">			return;</span>
		}
<span class="nc" id="L2077">		Jdmo dmo = new Jdmo();</span>
		try {

<span class="nc" id="L2080">			boolean bNeedToNotify = false;</span>
<span class="nc bnc" id="L2081" title="All 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="nc" id="L2083">				bNeedToNotify = m_notifyManager</span>
<span class="nc" id="L2084">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}
<span class="nc" id="L2086">			Collection eventToUnPubGroupByEmployeeID = getPublishedEventsForWorkResourcesByType(</span>
					Event.EVENT_TYPE_TIME_OFF, workResourceIDs, dtStart, dtEnd);
<span class="nc" id="L2088">			Collection eventToUnPub = ScheduleDAOUtil.getUniqueEvents(eventToUnPubGroupByEmployeeID);</span>
<span class="nc" id="L2089">			Collection eventToPubGroupByEmployeeID = getEventsForWorkResourcesByType(Event.EVENT_TYPE_TIME_OFF,</span>
					workResourceIDs, dtStart, dtEnd);
<span class="nc" id="L2091">			Collection eventToPub = ScheduleDAOUtil.getUniqueEvents(eventToPubGroupByEmployeeID);</span>

<span class="nc" id="L2093">			CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2094">			dao.unPublishSchedule(eventToUnPub, workResourceIDs);</span>
<span class="nc" id="L2095">			eventToPub = dao.publishSchedule(eventToPubGroupByEmployeeID, new ArrayList(eventToUnPub), workResourceIDs);</span>
<span class="nc" id="L2096">			ScheduleChangeDetails changeDetails = new ScheduleChangeDetails(new ArrayList(), dtStart, dtEnd,</span>
					new ArrayList(), new ArrayList());
<span class="nc" id="L2098">			changeDetails.addMoreDetails(</span>
					new ScheduleChangeDetails(workResourceIDs, dtStart, dtEnd, eventToUnPubGroupByEmployeeID,
<span class="nc" id="L2100">							ScheduleDAOUtil.groupEventsByWorkResources(eventToPub, workResourceIDs)));</span>
			Event event;
<span class="nc" id="L2102">			PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>

			Collection ids;
<span class="nc bnc" id="L2105" title="All 2 branches missed.">			for (Iterator i = eventToPub.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2106">				event = (Event) i.next();</span>
				/*
				 * update the PublishingPeriod table to insert a partial publish
				 * record
				 */
<span class="nc" id="L2111">				ids = event.getWorkResourceIDs();</span>
<span class="nc" id="L2112">				ids.retainAll(workResourceIDs);</span>
<span class="nc" id="L2113">				daoPeriod.publishPeriods(ids, event.getStartTime(), event.getEndTime(), true);</span>
			}
<span class="nc" id="L2115">			m_eventHandler.triggerTONotificationSynrchronized(changeDetails);</span>

<span class="nc bnc" id="L2117" title="All 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="nc" id="L2122">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="nc" id="L2129">			m_eventHandler.postPublishEvent(eventToPub, changeDetails);</span>

<span class="nc" id="L2131">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2132">			handleException(e);</span>
<span class="nc" id="L2133">			throw e;</span>
<span class="nc" id="L2134">		} catch (Exception e) {</span>
<span class="nc" id="L2135">			handleException(e);</span>
<span class="nc" id="L2136">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2138">			dmo.cleanUp();</span>
			// QC53354/QA97533 need to publish
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="nc bnc" id="L2143" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2144">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2146">			methodFinish();</span>
<span class="nc" id="L2147">		}</span>
<span class="nc" id="L2148">	}</span>

	public void unPublishTimeOffEvents(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2152">		methodStart(&quot;unPublishTimeOffEvents&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L2154">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2155">		CalendarEventAssignmentPubDAO dao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2156">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
<span class="nc" id="L2158">			Collection eventToUnPub = ScheduleDAOUtil.getUniqueEvents(getPublishedEventsForWorkResourcesByType(</span>
					Event.EVENT_TYPE_TIME_OFF, workResourceIDs, dtStart, dtEnd));
<span class="nc" id="L2160">			dao.unPublishSchedule(eventToUnPub, workResourceIDs);</span>
			Event event;
			Collection ids;
<span class="nc bnc" id="L2163" title="All 2 branches missed.">			for (Iterator i = eventToUnPub.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2164">				event = (Event) i.next();</span>
<span class="nc" id="L2165">				ids = event.getWorkResourceIDs();</span>
<span class="nc" id="L2166">				ids.retainAll(workResourceIDs);</span>
<span class="nc" id="L2167">				daoPeriod.unPublishPeriods(ids, event.getStartTime(), event.getEndTime(), true);// QA100166</span>
																								// Partially
																								// publishing
																								// PublishPeriod
			}
<span class="nc" id="L2172">			m_eventHandler.postUnPublishSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2173">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2174">			handleException(e);</span>
<span class="nc" id="L2175">			throw e;</span>
<span class="nc" id="L2176">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2177">			handleException(e);</span>
<span class="nc" id="L2178">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2180">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="nc bnc" id="L2184" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2185">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2187">			methodFinish();</span>
<span class="nc" id="L2188">		}</span>
<span class="nc" id="L2189">	}</span>

	public void publishSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2193">		publishScheduleInBatch(workResourceIDs, dtStart, dtEnd, false);// always</span>
																		// set
																		// isBatchPublish
																		// =false
<span class="nc" id="L2197">	}</span>

	public void publishScheduleInBatch(Collection workResourceIDs, Date dtStart, Date dtEnd, boolean isBatchPublish)
			throws BbmSchedulePublishingException {
<span class="fc" id="L2201">		methodStart(&quot;publishSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L2202">		Jdmo dmo = new Jdmo();</span>
<span class="fc" id="L2203">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2204">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="fc" id="L2205">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
			/*
			 * this is an optimization that is used to check whether there
			 * actually are any notification rules for 'schedule changed'
			 * notifications. If not, there's no need to keep track of schedule
			 * change details
			 */
<span class="fc" id="L2213">			boolean bNeedToNotify = false;</span>
<span class="pc bpc" id="L2214" title="1 of 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="fc" id="L2216">				bNeedToNotify = m_notifyManager</span>
<span class="fc" id="L2217">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}

<span class="fc" id="L2220">			Collection cOutOfSynchWorkResourceIDs = getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs,</span>
					dtStart, dtEnd);

<span class="fc" id="L2223">			ScheduleChangeDetails changeDetails = dao1.publishSchedule(dtStart, dtEnd, false, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);

<span class="fc" id="L2226">			ScheduleChangeDetails pCalendarEventChangeDetails = dao2.publishSchedule(dtStart, dtEnd, false,</span>
					workResourceIDs, cOutOfSynchWorkResourceIDs);

			/* update the PublishingPeriod table */
<span class="fc" id="L2230">			daoPeriod.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>
			/*
			 * Fix for bug #94140 ;as per suggestions from Angela moved code
			 * here from ScheduleEventHandler to handle scenarios where
			 * changeDetails is set to null on Certain conditions, Sameet Jan
			 * 2007
			 */
<span class="pc bpc" id="L2237" title="1 of 2 branches missed.">			if (changeDetails != null) {</span>
<span class="fc" id="L2238">				changeDetails.addMoreDetails(pCalendarEventChangeDetails);</span>
<span class="fc" id="L2239">				ScheduleEventHandler.triggerTONotification(changeDetails, isBatchPublish);</span>
			}

<span class="pc bpc" id="L2242" title="1 of 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="fc" id="L2247">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="fc" id="L2254">			m_eventHandler.postPublishSchedule(workResourceIDs, dtStart, dtEnd, changeDetails);</span>
<span class="nc" id="L2255">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2256">			handleException(e);</span>
<span class="nc" id="L2257">			throw e;</span>
<span class="nc" id="L2258">		} catch (Exception e) {</span>
<span class="nc" id="L2259">			handleException(e);</span>
<span class="nc" id="L2260">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="pc" id="L2262">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="pc bpc" id="L2266" title="3 of 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="pc" id="L2267">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="pc" id="L2269">			methodFinish();</span>
<span class="fc" id="L2270">		}</span>
<span class="fc" id="L2271">	}</span>

	public void unPublishSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2275">		methodStart(&quot;unPublishSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L2277">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2278">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2279">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2280">		PublishingPeriodDAO daoPeriod = new PublishingPeriodDAO(dmo);</span>
		try {
<span class="nc" id="L2282">			dao1.unPublishSchedule(workResourceIDs, dtStart, dtEnd, false);</span>
<span class="nc" id="L2283">			dao2.unPublishSchedule(workResourceIDs, dtStart, dtEnd, false);</span>

			/* update the PublishingPeriod table */
<span class="nc" id="L2286">			daoPeriod.unPublishPeriods(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets un-published
			 */
<span class="nc" id="L2292">			m_eventHandler.postUnPublishSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2293">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2294">			handleException(e);</span>
<span class="nc" id="L2295">			throw e;</span>
		} finally {
<span class="nc" id="L2297">			dmo.cleanUp();</span>
			/*
			 * now we need to flush the schedule cache because it is out-of-sync
			 */
<span class="nc bnc" id="L2301" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2302">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2304">			methodFinish();</span>
<span class="nc" id="L2305">		}</span>
<span class="nc" id="L2306">	}</span>

	public void revertToPublishedSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2310">		methodStart(&quot;revertToPublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2311">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2312">		ShiftAssignmentDAO dao1 = new ShiftAssignmentDAO(dmo);</span>
<span class="nc" id="L2313">		CalendarEventAssignmentDAO dao2 = new CalendarEventAssignmentDAO(dmo);</span>
		try {
			/*
			 * perform what is necessary before the schedule for the selected
			 * work resources gets reverted to published state
			 */
<span class="nc" id="L2319">			m_eventHandler.preRevertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc" id="L2321">			dao1.revertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2322">			dao2.revertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * perform what is necessary after the schedule for the selected
			 * work resources gets reverted to published state
			 */
<span class="nc" id="L2328">			m_eventHandler.postRevertToPublishedSchedule(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2329">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2330">			handleException(e);</span>
<span class="nc" id="L2331">			throw e;</span>
<span class="nc" id="L2332">		} catch (Exception e) {</span>
<span class="nc" id="L2333">			handleException(e);</span>
<span class="nc" id="L2334">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2336">			dmo.cleanUp();</span>
<span class="nc" id="L2337">			methodFinish();</span>
<span class="nc" id="L2338">		}</span>
<span class="nc" id="L2339">	}</span>

	public void updatePublishedSchedule(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
<span class="nc" id="L2343">		methodStart(&quot;updatePublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2344">		Jdmo dmo = new Jdmo();</span>
<span class="nc" id="L2345">		ShiftAssignmentPubDAO dao1 = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2346">		CalendarEventAssignmentPubDAO dao2 = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L2347">		PublishingPeriodDAO dao3 = new PublishingPeriodDAO(dmo);</span>
		try {
			/*
			 * this is an optimization that is used to check whether there
			 * actually are any notification rules for 'schedule changed'
			 * notifications. If not, there's no need to keep track of schedule
			 * change details
			 */
<span class="nc" id="L2355">			boolean bNeedToNotify = false;</span>
<span class="nc bnc" id="L2356" title="All 2 branches missed.">			if (!m_isWhatIf) {</span>
				/** There is no need for notifications in What-If mode */
<span class="nc" id="L2358">				bNeedToNotify = m_notifyManager</span>
<span class="nc" id="L2359">						.existNotifyRulesWithTemplateID(NotifyRuleTemplate.NOTIFY_TEMPLATE_SCHEDULE_CHANGED_ID);</span>
			}

<span class="nc" id="L2362">			Collection cOutOfSynchWorkResourceIDs = getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs,</span>
					dtStart, dtEnd);

<span class="nc" id="L2365">			ScheduleChangeDetails changeDetails = dao1.publishSchedule(dtStart, dtEnd, true, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);
<span class="nc" id="L2367">			ScheduleChangeDetails moreDetails = dao2.publishSchedule(dtStart, dtEnd, true, workResourceIDs,</span>
					cOutOfSynchWorkResourceIDs);

			// refresh the publish time in publishingperiods table
<span class="nc" id="L2371">			dao3.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>

<span class="nc bnc" id="L2373" title="All 2 branches missed.">			if (changeDetails != null) {</span>
<span class="nc" id="L2374">				changeDetails.addMoreDetails(moreDetails);</span>
<span class="nc" id="L2375">				ScheduleEventHandler.triggerTONotification(changeDetails, false);</span>
			}

<span class="nc bnc" id="L2378" title="All 2 branches missed.">			if (!bNeedToNotify) {</span>
				/*
				 * changeDetails are only needed for notification purposes, so
				 * since there's no need to notify, we can discard them
				 */
<span class="nc" id="L2383">				changeDetails = null;</span>
			}

			/*
			 * perform what is necessary whenever the schedule for the selected
			 * work resources gets published
			 */
<span class="nc" id="L2390">			m_eventHandler.postUpdatePublishedSchedule(workResourceIDs, dtStart, dtEnd, changeDetails);</span>
<span class="nc" id="L2391">		} catch (BbmSchedulePublishingException e) {</span>
<span class="nc" id="L2392">			handleException(e);</span>
<span class="nc" id="L2393">			throw e;</span>
<span class="nc" id="L2394">		} catch (Exception e) {</span>
<span class="nc" id="L2395">			handleException(e);</span>
<span class="nc" id="L2396">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="nc" id="L2398">			dmo.cleanUp();</span>
<span class="nc bnc" id="L2399" title="All 4 branches missed.">			if (m_scheduleCache != null) {</span>
<span class="nc" id="L2400">				m_scheduleCache.flush(workResourceIDs, dtStart, dtEnd);</span>
			}
<span class="nc" id="L2402">			methodFinish();</span>
<span class="nc" id="L2403">		}</span>
<span class="nc" id="L2404">	}</span>

	public Collection getWorkResourcesOutOfSyncWithPublishedSchedule(Collection workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmSchedulePublishingException {
<span class="fc" id="L2408">		methodStart(&quot;getWorkResourcesOutOfSyncWithPublishedSchedule&quot;, workResourceIDs, dtStart, dtEnd);</span>

		try {
<span class="fc" id="L2411">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>
<span class="fc" id="L2412">			return m_auditManager.getWorkResourcesOutOfSyncWithPublishedSchedule(workResourceIDs, eventTypeMask,</span>
					dtStart, dtEnd);
<span class="nc" id="L2414">		} catch (Exception e) {</span>
<span class="nc" id="L2415">			handleException(e);</span>
<span class="nc" id="L2416">			throw new BbmSchedulePublishingException(e);</span>
		} finally {
<span class="pc" id="L2418">			methodFinish();</span>
		}
	}

	public List&lt;Collection&lt;PublishingPeriod&gt;&gt; getPublishedPeriods(Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws BbmFinderException {
<span class="fc" id="L2424">		methodStart(&quot;getPublishedPeriods&quot;, workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L2426">		PublishingPeriodDAO dao = new PublishingPeriodDAO();</span>
		try {
<span class="fc" id="L2428">			return dao.getPublishedPeriods(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L2429">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2430">			handleException(e);</span>
<span class="nc" id="L2431">			throw e;</span>
		} finally {
<span class="pc" id="L2433">			dao.cleanUp();</span>
<span class="pc" id="L2434">			methodFinish();</span>
		}
	}

	public List getPublishedEventsForWorkResourcesFromCache(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L2440">		methodStart(&quot;getPublishedEventsForWorkResourcesFromCache&quot;, workResourceIDs, dtStart, dtEnd);</span>
		try {
			/* if not using cache, just fetch from DB */
<span class="nc bnc" id="L2443" title="All 2 branches missed.">			if (m_scheduleCache == null) {</span>
<span class="nc" id="L2444">				return getPublishedEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
			}

			/**
			 * this is where we shall store the events that we find in the cache
			 */
<span class="nc" id="L2450">			HashMap mapEvents = m_scheduleCache.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			/* find out cache misses */
<span class="nc" id="L2453">			HashSet setCacheMisses = new HashSet();</span>
<span class="nc bnc" id="L2454" title="All 2 branches missed.">			for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2455">				ID workResourceID = (ID) it.next();</span>
<span class="nc bnc" id="L2456" title="All 2 branches missed.">				if (!mapEvents.containsKey(workResourceID)) {</span>
<span class="nc" id="L2457">					setCacheMisses.add(workResourceID);</span>
				}
<span class="nc" id="L2459">			}</span>

<span class="nc bnc" id="L2461" title="All 2 branches missed.">			if (!setCacheMisses.isEmpty()) {</span>
				/*
				 * we've had some cache misses, so we need to fetch those events
				 */
				List listEvents;
<span class="nc" id="L2466">				Date currentCacheWindowStart = m_scheduleCache.getCacheWindowStart();</span>
<span class="nc" id="L2467">				Date currentCacheWindowEnd = m_scheduleCache.getCacheWindowEnd();</span>
<span class="nc bnc" id="L2468" title="All 4 branches missed.">				if (dtStart.after(currentCacheWindowStart) &amp;&amp; dtEnd.before(currentCacheWindowEnd)) {</span>
					// inside cache time window, preload the events to the cache
					// window end
<span class="nc" id="L2471">					listEvents = getPublishedEventsForWorkResources(setCacheMisses, dtStart, currentCacheWindowEnd);</span>
					/** update the cache also */
<span class="nc" id="L2473">					m_scheduleCache.put(setCacheMisses, listEvents, dtStart, currentCacheWindowEnd);</span>
<span class="nc" id="L2474">					HashMap missedEvent = m_scheduleCache.getEventsForWorkResources(setCacheMisses, dtStart, dtEnd);</span>
<span class="nc" id="L2475">					mapEvents.putAll(missedEvent);</span>
<span class="nc" id="L2476">				} else {</span>
					// not in the cache window, load from db
<span class="nc" id="L2478">					listEvents = getPublishedEventsForWorkResources(setCacheMisses, dtStart, dtEnd);</span>
<span class="nc" id="L2479">					Iterator itWorkResource = setCacheMisses.iterator();</span>
<span class="nc" id="L2480">					Iterator itEvents = listEvents.iterator();</span>
<span class="nc bnc" id="L2481" title="All 4 branches missed.">					while (itWorkResource.hasNext() &amp;&amp; itEvents.hasNext()) {</span>
<span class="nc" id="L2482">						ID workResourceID = (ID) itWorkResource.next();</span>
<span class="nc" id="L2483">						Collection listWrkEvents = (Collection) itEvents.next();</span>
<span class="nc" id="L2484">						mapEvents.put(workResourceID, listWrkEvents);</span>
<span class="nc" id="L2485">					}</span>
					/** update the cache also */
<span class="nc" id="L2487">					m_scheduleCache.put(setCacheMisses, listEvents, dtStart, dtEnd);</span>

				}
			}

<span class="nc" id="L2492">			ArrayList listEvents = new ArrayList(workResourceIDs.size());</span>
<span class="nc bnc" id="L2493" title="All 2 branches missed.">			for (Iterator it = workResourceIDs.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2494">				ID workResourceID = (ID) it.next();</span>
<span class="nc" id="L2495">				listEvents.add(mapEvents.get(workResourceID));</span>
<span class="nc" id="L2496">			}</span>
<span class="nc" id="L2497">			return listEvents;</span>
		} finally {
<span class="nc" id="L2499">			methodFinish();</span>
		}
	}

	public HashMap getPublishedChangedIntervalsForWorkResources(Collection workResourceIDs, Date dateStart,
			Date dateEnd, Date dateLastUpdated) throws BbmFinderException {
<span class="nc" id="L2505">		methodStart(&quot;getPublishedChangedIntervalsForWorkResources&quot;, workResourceIDs, dateStart, dateEnd,</span>
				dateLastUpdated);
		try {
			/* first, query event audit trail for changes */
<span class="nc" id="L2509">			HashMap auditMap = m_auditManager.getChangedIntervalsForWorkResource(workResourceIDs,</span>
					AuditTrailEntry.MODULE_PUBLISHING, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastUpdated,
					null);
<span class="nc" id="L2512">			return auditMap;</span>
<span class="nc" id="L2513">		} catch (Exception e) {</span>
<span class="nc" id="L2514">			handleException(e);</span>
<span class="nc" id="L2515">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2517">			methodFinish();</span>
		}
	}

	/**
	 * This method will return a HashMap keyed on workresource ID, containing a
	 * collection of TimeRange objects (for each changed unpublished interval),
	 * for each work resource.
	 *
	 * @param workResourceIDs
	 *            a collection of IDs of the employees for whom to return the
	 *            changed intervals
	 * @param dateStart
	 *            time range start to return data for
	 * @param dateEnd
	 *            time range end to return data for
	 * @param dateLastUpdated
	 *            indicates to return all changes since dateLastUpdated
	 * @return hashmap
	 * @throws BbmFinderException
	 *             if there was an error while performing database queries
	 */
	public HashMap getChangedIntervalsForWorkResources(Collection workResourceIDs, Date dateStart, Date dateEnd,
			Date dateLastUpdated) throws BbmFinderException {
<span class="nc" id="L2541">		methodStart(&quot;getChangedIntervalsForWorkResources&quot;, workResourceIDs, dateStart, dateEnd, dateLastUpdated);</span>
		try {
			/* first, query event audit trail for changes */
<span class="nc" id="L2544">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT | Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;</span>
<span class="nc" id="L2545">			HashMap auditMap = m_auditManager.getChangedIntervalsForWorkResource(workResourceIDs,</span>
					AuditTrailEntry.MODULE_SCHEDULING, AuditTrailEntry.ACTION_ALL, dateStart, dateEnd, dateLastUpdated,
					null);
<span class="nc" id="L2548">			return auditMap;</span>
<span class="nc" id="L2549">		} catch (Exception e) {</span>
<span class="nc" id="L2550">			handleException(e);</span>
<span class="nc" id="L2551">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L2553">			methodFinish();</span>
		}
	}

	/*
	 * @deprecated by com.bluepumpkin.common.localization.Localizer - see
	 * getConflictMessagesWithLocaleStrings instead public Collection
	 * getConflictMessages (Collection listConflicts, String localeID, String
	 * timeZoneID) { methodStart(&quot;getConflictMessages&quot;, listConflicts, localeID,
	 * timeZoneID); try { Locale locale;
	 *
	 * if (localeID != null) locale =
	 * LocalizationManager.getInstance().getLocale(localeID); else // it should
	 * use Default Language Locale, may not be JVM Locale locale =
	 * DefaultLocalizationManager
	 * .getDefaultInstance().getLocaleContext().getLanguageLocale();
	 *
	 * TimeZone tz; if (timeZoneID != null) tz =
	 * TimeZone.getTimeZone(timeZoneID); else tz = TimeZone.getDefault();
	 *
	 * ArrayList listMessages = new ArrayList(listConflicts.size()); for
	 * (Iterator it = listConflicts.iterator(); it.hasNext(); ) {
	 * BbmScheduleConflict conflict = (BbmScheduleConflict)it.next();
	 * listMessages.add(conflict.getLocalizedMessage(locale, tz)); } return
	 * listMessages; } finally { methodFinish(); } }
	 */
	/**
	 * This method is used by the C++ client to retrieve a list of localized
	 * schedule conflict messages
	 *
	 * @param listConflicts
	 *            collection of BbmScheduleConflict objects to retrieve messages
	 *            for
	 * @param langLocaleID
	 *            string language locale ID (e.g. &quot;en_US&quot;) in which to return
	 *            the conflict messages. If null, default server locale will be
	 *            used
	 * @param regionalLocaleID
	 *            string regional locale ID (e.g. &quot;en_US&quot;) in which to return
	 *            the conflict messages date and time. If null, default server
	 *            locale will be used
	 * @param timeZoneID
	 *            string time zone ID (e.g. &quot;PST&quot;) in which the times in the
	 *            conflict message will be returned
	 * @return collection of messages, one for each conflict given
	 */
	public Collection getConflictMessagesWithLocaleStrings(Collection listConflicts, String langLocaleID,
			String regionalLocaleID, String timeZoneID) {
<span class="nc" id="L2601">		methodStart(&quot;getConflictMessagesWithLocaleStrings&quot;, listConflicts, langLocaleID, regionalLocaleID, timeZoneID);</span>
		try {
			Localizer localizer;
<span class="nc bnc" id="L2604" title="All 2 branches missed.">			if (langLocaleID != null) {</span>
<span class="nc bnc" id="L2605" title="All 2 branches missed.">				if (regionalLocaleID == null) {</span>
<span class="nc" id="L2606">					regionalLocaleID = langLocaleID;</span>
				}
<span class="nc" id="L2608">				LocalizationManager locMngr = LocalizationManager.getInstance();</span>
<span class="nc" id="L2609">				LocaleContext locCtx = locMngr.getLocaleContext(locMngr.getLocale(langLocaleID),</span>
<span class="nc" id="L2610">						locMngr.getLocale(regionalLocaleID), locMngr.getLocale(langLocaleID));</span>
<span class="nc" id="L2611">				localizer = locMngr.getLocalizer(locCtx);</span>
<span class="nc" id="L2612">			} else {</span>
<span class="nc" id="L2613">				localizer = DefaultLocalizationManager.getDefaultInstance().getLocalizer();</span>
			}

			TimeZone tz;
<span class="nc bnc" id="L2617" title="All 2 branches missed.">			if (timeZoneID != null) {</span>
<span class="nc" id="L2618">				tz = TimeZone.getTimeZone(timeZoneID);</span>
			} else {
<span class="nc" id="L2620">				tz = TimeZone.getDefault();</span>
			}

<span class="nc" id="L2623">			ArrayList listMessages = new ArrayList(listConflicts.size());</span>
<span class="nc bnc" id="L2624" title="All 2 branches missed.">			for (Iterator it = listConflicts.iterator(); it.hasNext();) {</span>
<span class="nc" id="L2625">				BbmScheduleConflict conflict = (BbmScheduleConflict) it.next();</span>
<span class="nc" id="L2626">				listMessages.add(conflict.getLocalizedMessage(localizer, tz));</span>
<span class="nc" id="L2627">			}</span>
<span class="nc" id="L2628">			return listMessages;</span>
		} finally {
<span class="nc" id="L2630">			methodFinish();</span>
		}
	}

	/**Get all conflicts of all shift assignments including the shift blocks
	 *
	 * @param shiftAssignments
	 * @return
	 * @throws Exception
	 */
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObjects(
			Collection&lt;ShiftAssignment&gt; shiftAssignments) throws Exception {
<span class="nc" id="L2642">		methodStart(&quot;getConflictsForNewScheduleObjects&quot;, shiftAssignments);</span>

<span class="nc" id="L2644">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {

			/*
			 * check if there were any conflicts as a result of this operation
			 */
<span class="nc" id="L2650">			Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForNewScheduleObjects(shiftAssignments);</span>
<span class="nc" id="L2651">			return listConflicts;</span>
		} finally {
<span class="nc" id="L2653">			dao.cleanUp();</span>
<span class="nc" id="L2654">			methodFinish();</span>
		}
	}

	private boolean intersectsEvent(Event pShiftAssignment, Collection cEvents, Organization pOrg) {
<span class="nc bnc" id="L2659" title="All 2 branches missed.">		if (cEvents == null) {</span>
<span class="nc" id="L2660">			return false;</span>
		}
<span class="nc bnc" id="L2662" title="All 2 branches missed.">		for (Iterator i = cEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2663">			Event pEvent = (Event) i.next();</span>
<span class="nc bnc" id="L2664" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
<span class="nc bnc" id="L2665" title="All 2 branches missed.">					|| pEvent.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY) {</span>
<span class="nc bnc" id="L2666" title="All 2 branches missed.">				if (pShiftAssignment.getEndTime().after(pEvent.getStartTime())</span>
<span class="nc bnc" id="L2667" title="All 2 branches missed.">						&amp;&amp; pShiftAssignment.getStartTime().before(pEvent.getEndTime())) {</span>
<span class="nc" id="L2668">					return true;</span>
				}
			}
<span class="nc bnc" id="L2671" title="All 2 branches missed.">			if (pEvent.getEventType() == Event.EVENT_TYPE_SHIFT_ASSIGNMENT) {</span>
<span class="nc" id="L2672">				Calendar cStartDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L2673">				cStartDay.setTime(pShiftAssignment.getStartTime());</span>
<span class="nc" id="L2674">				cStartDay.set(Calendar.HOUR_OF_DAY, pOrg.getDayBoundaryOffset() / 60);</span>
<span class="nc" id="L2675">				cStartDay.set(Calendar.MINUTE, pOrg.getDayBoundaryOffset() % 60);</span>
<span class="nc bnc" id="L2676" title="All 2 branches missed.">				if (cStartDay.getTime().after(pShiftAssignment.getStartTime())) {</span>
<span class="nc" id="L2677">					cStartDay.add(Calendar.DATE, -1);</span>
				}
<span class="nc" id="L2679">				Calendar cEndDay = Calendar.getInstance(pOrg.getTimeZone());</span>
<span class="nc" id="L2680">				cEndDay.setTime(cStartDay.getTime());</span>
<span class="nc" id="L2681">				cEndDay.add(Calendar.DATE, 1);</span>
<span class="nc bnc" id="L2682" title="All 2 branches missed.">				if (!pEvent.getStartTime().before(cStartDay.getTime())</span>
<span class="nc bnc" id="L2683" title="All 2 branches missed.">						&amp;&amp; pEvent.getStartTime().before(cEndDay.getTime())) {</span>
<span class="nc" id="L2684">					return true;</span>
				}
			}
<span class="nc" id="L2687">		}</span>
<span class="nc" id="L2688">		return false;</span>
	}

	public void copyShiftAssignments(ID idSourceSP, Date sourceWeekStart, ID idDestinationSP, Date targetWeekStart,
			boolean bClearDestinationSP) throws BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L2693" title="All 2 branches missed.">		methodStart(&quot;copyShiftAssignments&quot;, idSourceSP, sourceWeekStart, idDestinationSP, targetWeekStart,</span>
				bClearDestinationSP ? Boolean.TRUE : Boolean.FALSE);
<span class="nc" id="L2695">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L2697">			ID idSourceSPParent = m_pCampaignManager.getParentSchedulingPeriodID(idSourceSP);</span>

			// Date sourceWeekEnd = TimeZoneUtil.addWeek(sourceWeekStart);
			// Date targetWeekEnd = TimeZoneUtil.addWeek(targetWeekStart);

<span class="nc" id="L2702">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="nc" id="L2703">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>

			// Changes start for QA96688
<span class="nc" id="L2706">			Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP.getCampaignID());</span>
<span class="nc" id="L2707">			Date sourceWeekEnd = getWeekEnd(sourceWeekStart, pSourceSP, pCampaign, false);</span>
<span class="nc" id="L2708">			Date targetWeekEnd = getWeekEnd(targetWeekStart, pDestinationSP, pCampaign, false);</span>

<span class="nc" id="L2710">			TimeZone tz = pCampaign.getTimeZone();</span>
<span class="nc bnc" id="L2711" title="All 2 branches missed.">			boolean isPartialWeek = pCampaign.isMonthly()</span>
<span class="nc bnc" id="L2712" title="All 2 branches missed.">					&amp;&amp; (MonthlySPUtil.isPartialWeek(tz, sourceWeekStart, sourceWeekEnd)</span>
<span class="nc bnc" id="L2713" title="All 2 branches missed.">							|| MonthlySPUtil.isPartialWeek(tz, targetWeekStart, targetWeekEnd));</span>
<span class="nc bnc" id="L2714" title="All 2 branches missed.">			if (isPartialWeek) {</span>
<span class="nc" id="L2715">				Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
						sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc bnc" id="L2717" title="All 2 branches missed.">				if (sourceWeekCopiableRange[0] == null) {</span>
					// there is no common range (based on days of week) to copy
					// over, exit
<span class="nc" id="L2720">					return;</span>
				}
			}
			// Changes end for QA96688

			// DST adjust for source target fix QC52704
<span class="nc" id="L2726">			sourceWeekEnd = TimeZoneUtil.getMidNightDate(sourceWeekEnd, tz);</span>

<span class="nc" id="L2728">			Collection cpAssignments = m_pCampaignManager</span>
<span class="nc" id="L2729">					.getCampaignWorkResourceAssignments(pDestinationSP.getCampaignID(), targetWeekStart, targetWeekEnd);</span>

<span class="nc" id="L2731">			HashSet cidWorkResources = new HashSet();</span>
<span class="nc bnc" id="L2732" title="All 2 branches missed.">			for (Iterator i = cpAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2733">				CampaignWorkResource pAssignment = (CampaignWorkResource) i.next();</span>
<span class="nc" id="L2734">				cidWorkResources.add(pAssignment.getWorkResourceID());</span>
<span class="nc" id="L2735">			}</span>

			// map key:workresourceid, value=array of WorkResourceAssignment
<span class="nc" id="L2738">			Map orgAssignmentWithTZ = m_workResourceManager.getWRAssignmentsWithTimeZone(cidWorkResources);</span>

			// Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP
			// .getCampaignID());

<span class="nc" id="L2743">			ArrayList aEmployeeDatePairs = new ArrayList();</span>
<span class="nc bnc" id="L2744" title="All 2 branches missed.">			for (Iterator i = cidWorkResources.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2745">				ID idEmployee = (ID) i.next();</span>
<span class="nc" id="L2746">				aEmployeeDatePairs.add(new Pair(idEmployee, sourceWeekEnd));</span>
<span class="nc" id="L2747">			}</span>
<span class="nc" id="L2748">			Collection cEmployeeOrgIDs = m_workResourceManager.getEmployeeOrganizations(aEmployeeDatePairs);</span>

<span class="nc" id="L2750">			HashSet cidOrgs = new HashSet();</span>
<span class="nc bnc" id="L2751" title="All 2 branches missed.">			for (Iterator i = cEmployeeOrgIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2752">				ID idOrg = (ID) i.next();</span>
<span class="nc bnc" id="L2753" title="All 2 branches missed.">				if (idOrg != null) {</span>
<span class="nc" id="L2754">					cidOrgs.add(idOrg);</span>
				}
<span class="nc" id="L2756">			}</span>

<span class="nc" id="L2758">			Collection aOrgs = m_workResourceManager.getOrganizationsByIDs(cidOrgs);</span>
<span class="nc" id="L2759">			HashMap hOrgs = new HashMap();</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">			for (Iterator i = aOrgs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2761">				Organization pOrganization = (Organization) i.next();</span>
<span class="nc" id="L2762">				hOrgs.put(pOrganization.getID(), pOrganization);</span>
<span class="nc" id="L2763">			}</span>

<span class="nc bnc" id="L2765" title="All 2 branches missed.">			if (bClearDestinationSP) {</span>
				// delete by intersection
<span class="nc" id="L2767">				deleteShiftAssignments(null, cidWorkResources, targetWeekStart, targetWeekEnd, null, false, false);</span>
			}

<span class="nc" id="L2770">			int lTimeDeltaDays = getTimeDeltaDays(tz, isPartialWeek, sourceWeekStart, targetWeekStart, sourceWeekEnd,</span>
					targetWeekEnd);

			// I beleive, we are going to use GregorianCalendar only for now -
			// and
			// source uses the same timezone as destination
			// Gregorian
<span class="nc" id="L2777">			Calendar gc = Calendar.getInstance(pCampaign.getTimeZone()),</span>
<span class="nc" id="L2778">					gc2 = Calendar.getInstance(pCampaign.getTimeZone());</span>

<span class="nc" id="L2780">			String query = &quot;SELECT NAME,VALUE FROM BPCONFIG WHERE NAME = \'COPYSHIFTCHUNKSIZE\'&quot;;</span>
<span class="nc" id="L2781">			JdmoRowset r = dmo.createRowset(query);</span>
			// CHUNKSIZE is configurable. Insert 'COPYSHIFTCHUNKSIZE','size' in
			// BPCONFIG table where size is a no. like 100.
<span class="nc bnc" id="L2784" title="All 2 branches missed.">			while (r.next()) {</span>
<span class="nc" id="L2785">				String sKey = r.getString(&quot;NAME&quot;);</span>
<span class="nc" id="L2786">				String sValue = r.getString(&quot;VALUE&quot;);</span>
<span class="nc bnc" id="L2787" title="All 2 branches missed.">				if (sValue.length() != 0) {</span>
<span class="nc" id="L2788">					CHUNKSIZE = Integer.parseInt(sValue);</span>
				}
<span class="nc" id="L2790">			}</span>
<span class="nc" id="L2791">			Iterator iterWSCol = cidWorkResources.iterator();</span>

			// Start of chunking loop
<span class="nc bnc" id="L2794" title="All 2 branches missed.">			for (int nChunk = 0; nChunk * CHUNKSIZE &lt; cidWorkResources.size(); nChunk++) {</span>
<span class="nc" id="L2795">				int nStart = nChunk * CHUNKSIZE;</span>
<span class="nc" id="L2796">				int nEnd = nStart + CHUNKSIZE;</span>

<span class="nc" id="L2798">				HashSet cidSubSetWorkResources = new HashSet();</span>
<span class="nc bnc" id="L2799" title="All 4 branches missed.">				while (iterWSCol.hasNext() &amp;&amp; nStart &lt; nEnd) {</span>
<span class="nc" id="L2800">					ID idEmployee = (ID) iterWSCol.next();</span>
<span class="nc" id="L2801">					cidSubSetWorkResources.add(idEmployee);</span>
<span class="nc" id="L2802">					nStart++;</span>
<span class="nc" id="L2803">				}</span>

<span class="nc" id="L2805">				Collection cNewShiftAssignments = new LinkedList();</span>
<span class="nc" id="L2806">				Collection cSourceShiftAssignments = getSourceShiftAssignments(isPartialWeek, cidSubSetWorkResources,</span>
						tz, sourceWeekStart, targetWeekStart, sourceWeekEnd, targetWeekEnd);

				// get events in future week
<span class="nc" id="L2810">				Collection cUnavailabilities = getUnavailabilities(isPartialWeek, cidSubSetWorkResources, tz,</span>
						sourceWeekStart, targetWeekStart, sourceWeekEnd, targetWeekEnd);

				// copy shift assignments which are locked, have the source SP
				// id,
				// and which don't overlap unavailability or Shift Assignments
				// increment start time on shift assignments and shift event
				// assignments
<span class="nc" id="L2818">				Iterator u = cUnavailabilities.iterator();</span>
<span class="nc" id="L2819">				Iterator o = cEmployeeOrgIDs.iterator();</span>
<span class="nc" id="L2820">				HashMap empId2termDate = null; // termination date, or &quot;undef&quot;</span>
												// if
												// unknown
<span class="nc bnc" id="L2823" title="All 2 branches missed.">				for (Iterator i = cSourceShiftAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2824">					Collection cWorkResourceShiftAssignments = (Collection) i.next();</span>
<span class="nc" id="L2825">					Collection cWorkResourceUnavailabilities = (Collection) u.next();</span>
<span class="nc" id="L2826">					ID idOrganization = (ID) o.next();</span>
<span class="nc bnc" id="L2827" title="All 4 branches missed.">					if (cWorkResourceShiftAssignments == null || idOrganization == null) {</span>
<span class="nc" id="L2828">						continue;</span>
					}
<span class="nc bnc" id="L2830" title="All 2 branches missed.">					for (Iterator j = cWorkResourceShiftAssignments.iterator(); j.hasNext();) {</span>
<span class="nc" id="L2831">						ShiftAssignment shToCopy = (ShiftAssignment) j.next();</span>
						// couple of quick tests before cloning
<span class="nc bnc" id="L2833" title="All 2 branches missed.">						if (!shToCopy.isLocked()) {</span>
<span class="nc" id="L2834">							continue;</span>
						}
<span class="nc bnc" id="L2836" title="All 6 branches missed.">						if (shToCopy.getCampaignID() != null &amp;&amp; !(shToCopy.getCampaignID().equals(idSourceSP))</span>
<span class="nc bnc" id="L2837" title="All 2 branches missed.">								&amp;&amp; (idSourceSPParent == null || !(shToCopy.getCampaignID().equals(idSourceSPParent)))) {</span>
<span class="nc" id="L2838">							continue;</span>
						}
						// Shift Assignments should not be copied
						// if they begin after the Employee's termination date
						// Assuming there is just one workResourceID per
						// shiftAssignment
<span class="nc" id="L2844">						ID agentID = shToCopy.getWorkResourceIDs().iterator().next();</span>
<span class="nc" id="L2845">						TimeZone agentTZ = findStartTimeZoneOfAssignmentAtTime((Collection) (orgAssignmentWithTZ.get(agentID)),</span>
<span class="nc" id="L2846">								sourceWeekStart, pCampaign.getTimeZone());</span>
<span class="nc" id="L2847">						gc.setTimeZone(agentTZ);</span>
<span class="nc" id="L2848">						gc.setTime(shToCopy.getStartTime());</span>
<span class="nc" id="L2849">						gc.add(Calendar.DATE, lTimeDeltaDays);</span>
						// long newStartTime= shToCopy.getStartTime().getTime()
						// +
						// lTimeDelta;
<span class="nc" id="L2853">						Date newStartTime = gc.getTime();</span>
						// fix QC57855
<span class="nc" id="L2855">						int dstDelta = newStartTime.getTimezoneOffset() - shToCopy.getStartTime().getTimezoneOffset();</span>
<span class="nc bnc" id="L2856" title="All 2 branches missed.">						if (dstDelta != 0) {</span>
<span class="nc" id="L2857">							gc.add(Calendar.MINUTE, dstDelta);</span>
<span class="nc" id="L2858">							newStartTime = gc.getTime();</span>
						}

<span class="nc bnc" id="L2861" title="All 2 branches missed.">						if (empId2termDate == null) {</span>
<span class="nc" id="L2862">							empId2termDate = new HashMap();</span>
						}
<span class="nc" id="L2864">						Object termDateOb = empId2termDate.get(agentID);</span>
<span class="nc bnc" id="L2865" title="All 2 branches missed.">						if (termDateOb == null) { // not in map yet</span>
<span class="nc" id="L2866">							Employee agent = m_workResourceManager.getEmployeeByID(agentID, null, 0);</span>
<span class="nc" id="L2867">							termDateOb = agent.getEndTime(); // termination</span>
																// date,
																// can be null
<span class="nc bnc" id="L2870" title="All 2 branches missed.">							empId2termDate.put(agentID, termDateOb == null ? &quot;undef&quot; : termDateOb);</span>
						}
<span class="nc bnc" id="L2872" title="All 4 branches missed.">						if (termDateOb != null &amp;&amp; termDateOb instanceof Date</span>
<span class="nc bnc" id="L2873" title="All 2 branches missed.">								&amp;&amp; ((Date) termDateOb).before(newStartTime)) {</span>
							// out due to the end of employment
<span class="nc" id="L2875">							continue;</span>
						}

<span class="nc" id="L2878">						ShiftAssignment pShiftAssignment = (ShiftAssignment) shToCopy.cloneForPublishing();</span>
<span class="nc" id="L2879">						pShiftAssignment.setStartTime(newStartTime);</span>
<span class="nc" id="L2880">						gc2.setTimeZone(agentTZ);</span>
<span class="nc" id="L2881">						gc2.setTime(shToCopy.getEndTime());</span>
<span class="nc" id="L2882">						gc2.add(Calendar.DATE, lTimeDeltaDays);</span>
<span class="nc" id="L2883">						int duration = (int) ((gc2.getTime().getTime() - newStartTime.getTime())</span>
<span class="nc" id="L2884">								/ (ShiftAssignment.MILLIS_IN_ONE_MIN)), oldDuration = shToCopy.getDuration();</span>
<span class="nc bnc" id="L2885" title="All 2 branches missed.">						if (duration &lt;= 0) {</span>
							// transition
<span class="nc" id="L2887">							duration = oldDuration;</span>
						}
<span class="nc bnc" id="L2889" title="All 2 branches missed.">						if (duration != oldDuration) {</span>
<span class="nc" id="L2890">							m_cat.info(&quot;DST changed the duration from &quot; + oldDuration + &quot; to &quot; + duration + &quot; for:&quot;</span>
<span class="nc" id="L2891">									+ pShiftAssignment.toString());</span>
						}
<span class="nc" id="L2893">						pShiftAssignment.setDuration(duration);</span>
<span class="nc" id="L2894">						moveShiftEventAssignmentsToTargetWeek(lTimeDeltaDays, gc, pShiftAssignment, duration,</span>
								oldDuration);
<span class="nc" id="L2896">						setSpOfShiftEventAssignments(pShiftAssignment, idDestinationSP);</span>

<span class="nc bnc" id="L2898" title="All 2 branches missed.">						if (!intersectsEvent(pShiftAssignment, cWorkResourceUnavailabilities,</span>
<span class="nc" id="L2899">								(Organization) hOrgs.get(idOrganization))) {</span>
<span class="nc" id="L2900">							pShiftAssignment.setCampaignID(idDestinationSP);</span>

<span class="nc" id="L2902">							cNewShiftAssignments.add(pShiftAssignment);</span>
						}
<span class="nc" id="L2904">					}</span>
<span class="nc" id="L2905">				}</span>
<span class="nc" id="L2906">				createShiftAssignments(cNewShiftAssignments);</span>
			} // end of chunking loop
<span class="nc" id="L2908">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L2909">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L2910">			throw e;</span>
<span class="nc" id="L2911">		} catch (Exception e) {</span>
<span class="nc" id="L2912">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L2913">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L2915" title="All 6 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L2916">				dmo.cleanUp();</span>
			}
<span class="nc" id="L2918">			methodFinish();</span>
<span class="nc" id="L2919">		}</span>
<span class="nc" id="L2920">	}</span>

	/**
	 * Returns the week end date for given week start date. The week end date
	 * will be the next week start date or SP end date (whichever comes first).
	 * It must be different to the given date (unless the given date is SP end
	 * date).
	 *
	 * @param weekStart
	 *            week start date
	 * @param sp
	 *            SP which this week belongs to
	 * @param campaign
	 *            campaign of this SP
	 * @param useGMTForNonMonthlySPCalculation
	 *            flag to indicate if calculation for non-monthly SP should use
	 *            GMT timezone (otherwise use campaign time zone)
	 * @return Returns the week end date for given week start date
	 */
	private Date getWeekEnd(Date weekStart, SchedulingPeriod sp, Campaign campaign,
			boolean useGMTForNonMonthlySPCalculation) {
		Date sourceWeekEnd;
<span class="nc bnc" id="L2942" title="All 2 branches missed.">		if (campaign.isMonthly()) {</span>
<span class="nc" id="L2943">			sourceWeekEnd = MonthlySPUtil.getWeekEndDate(campaign.getTimeZone(), weekStart,</span>
<span class="nc" id="L2944">					MonthlySPUtil.getWeekStartDay(campaign.getWeekStart()), sp.getEndTime());</span>
		} else {
<span class="nc bnc" id="L2946" title="All 2 branches missed.">			if (useGMTForNonMonthlySPCalculation) {</span>
				// TODO: Not sure why we want to use GMT time zone (maybe a
				// bug?). This logic is refactored from copyEffectiveDates()
				// method
<span class="nc" id="L2950">				sourceWeekEnd = TimeZoneUtil.addWeek(weekStart);</span>
			} else {
<span class="nc" id="L2952">				sourceWeekEnd = TimeZoneUtil.addWeek(weekStart, campaign.getTimeZone());</span>
			}
		}
<span class="nc" id="L2955">		return sourceWeekEnd;</span>
	}

	private Collection getUnavailabilities(boolean isPartialWeek, Set workResources, TimeZone tz, Date sourceWeekStart,
			Date targetWeekStart, Date sourceWeekEnd, Date targetWeekEnd) throws BbmFinderException {
		Date start;
		Date end;
<span class="nc bnc" id="L2962" title="All 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L2963">			Date[] targetWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, targetWeekStart,</span>
					targetWeekEnd, sourceWeekStart, sourceWeekEnd);
<span class="nc" id="L2965">			start = targetWeekCopiableRange[0];</span>
<span class="nc" id="L2966">			end = targetWeekCopiableRange[1];</span>
<span class="nc" id="L2967">		} else {</span>
<span class="nc" id="L2968">			start = targetWeekStart;</span>
<span class="nc" id="L2969">			end = targetWeekEnd;</span>
		}
		// widen the select range up and down one day.
<span class="nc" id="L2972">		Calendar gc = Calendar.getInstance(tz);</span>
<span class="nc" id="L2973">		gc.setTime(start);</span>
<span class="nc" id="L2974">		gc.add(Calendar.DATE, -1);</span>
<span class="nc" id="L2975">		start = gc.getTime();</span>
<span class="nc" id="L2976">		gc.setTime(end);</span>
<span class="nc" id="L2977">		gc.add(Calendar.DATE, 1);</span>
<span class="nc" id="L2978">		end = gc.getTime();</span>
<span class="nc" id="L2979">		Collection cUnavailabilities = getEventsForWorkResourcesByType(</span>
				Event.EVENT_TYPE_UNAVAILABILITY | Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources, start, end);
<span class="nc" id="L2981">		return cUnavailabilities;</span>
	}

	private Collection getSourceShiftAssignments(boolean isPartialWeek, Set workResources, TimeZone tz,
			Date sourceWeekStart, Date targetWeekStart, Date sourceWeekEnd, Date targetWeekEnd)
			throws BbmFinderException {
		// get source shift assignments
		Collection cSourceShiftAssignments;
<span class="nc bnc" id="L2989" title="All 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L2990">			Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
					sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc" id="L2992">			cSourceShiftAssignments = getEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources,</span>
					sourceWeekCopiableRange[0], sourceWeekCopiableRange[1]);
<span class="nc" id="L2994">		} else {</span>
<span class="nc" id="L2995">			cSourceShiftAssignments = getEventsForWorkResourcesByType(Event.EVENT_TYPE_SHIFT_ASSIGNMENT, workResources,</span>
					sourceWeekStart, sourceWeekEnd);
		}
<span class="nc" id="L2998">		return cSourceShiftAssignments;</span>
	}

	private int getTimeDeltaDays(TimeZone tz, boolean isPartialWeek, Date sourceWeekStart, Date targetWeekStart,
			Date sourceWeekEnd, Date targetWeekEnd) {
		int lTimeDeltaDays;
<span class="nc bnc" id="L3004" title="All 2 branches missed.">		if (isPartialWeek) {</span>
<span class="nc" id="L3005">			Date[] sourceWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, sourceWeekStart,</span>
					sourceWeekEnd, targetWeekStart, targetWeekEnd);
<span class="nc" id="L3007">			Date[] targetWeekCopiableRange = MonthlySPUtil.findSubRangeHasSameDaysOfWeek(tz, targetWeekStart,</span>
					targetWeekEnd, sourceWeekStart, sourceWeekEnd);
<span class="nc" id="L3009">			lTimeDeltaDays = MonthlySPUtil.getDaysBetween(tz, sourceWeekCopiableRange[0], targetWeekCopiableRange[0]);</span>
<span class="nc" id="L3010">		} else {</span>
<span class="nc" id="L3011">			long lTimeDelta = targetWeekStart.getTime() - sourceWeekStart.getTime();</span>
			// we should not just use time delta b/c of DST transition.
			// If a Shift Assignment crosses the DST boundary and is cloned
			// to a future Week, the start time and end time should be
			// the same on both the week with the DST boundary and
			// the week it was cloned into. This means the duration may need to
			// change.
			// For example, a Shift Assignment starts at 1 AM and ends at 9 AM
			// on the day where there is an extra hour due to DST.
			// The Shift Assignment is 9 hours long. When cloned into another
			// week,
			// the Shift Assignment should still start at 1 AM and end at 9 AM,
			// but now is only 8 hours long.
<span class="nc" id="L3024">			lTimeDeltaDays = Math.round((float) lTimeDelta / (60 * 60 * 1000 * 24));</span>
		}
<span class="nc" id="L3026">		return lTimeDeltaDays;</span>
	}

	static void setSpOfShiftEventAssignments(ShiftAssignment shiftAssignment, ID destinationSpId) {
<span class="nc" id="L3030">		Collection&lt;ShiftEventAssignment&gt; eventAssignments = shiftAssignment</span>
<span class="nc" id="L3031">				.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT);</span>
<span class="nc bnc" id="L3032" title="All 4 branches missed.">		if (eventAssignments != null &amp;&amp; !eventAssignments.isEmpty()) {</span>
<span class="nc bnc" id="L3033" title="All 2 branches missed.">			for (ShiftEventAssignment eventAssignment : eventAssignments) {</span>
<span class="nc" id="L3034">				eventAssignment.setSPID(destinationSpId);</span>
<span class="nc" id="L3035">			}</span>
		}
<span class="nc" id="L3037">	}</span>

	private static void moveShiftEventAssignmentsToTargetWeek(int lTimeDeltaDays, Calendar gc,
			ShiftAssignment pShiftAssignment, int duration, int oldDuration) {
<span class="nc bnc" id="L3041" title="All 2 branches missed.">		if (pShiftAssignment.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT) != null) {</span>
<span class="nc" id="L3042">			for (Iterator&lt;ShiftEventAssignment&gt; iter = pShiftAssignment</span>
<span class="nc bnc" id="L3043" title="All 2 branches missed.">					.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT).iterator(); iter.hasNext();) {</span>
<span class="nc" id="L3044">				ShiftEventAssignment pShiftEventAssignment = iter.next();</span>
<span class="nc" id="L3045">				gc.setTime(pShiftEventAssignment.getStartTime());</span>
<span class="nc" id="L3046">				gc.add(Calendar.DATE, lTimeDeltaDays);</span>
<span class="nc" id="L3047">				pShiftEventAssignment.setStartTime(gc.getTime());</span>
<span class="nc bnc" id="L3048" title="All 2 branches missed.">				if (duration != oldDuration</span>
<span class="nc bnc" id="L3049" title="All 2 branches missed.">						&amp;&amp; (!isShiftEventContainedInShiftAssignment(pShiftEventAssignment, pShiftAssignment)</span>
<span class="nc bnc" id="L3050" title="All 2 branches missed.">								|| doesEventOverlapOtherEventsInShiftAssignment(pShiftEventAssignment,</span>
										pShiftAssignment))) {
<span class="nc" id="L3052">					iter.remove();</span>
				}
<span class="nc" id="L3054">			}</span>
		}
<span class="nc" id="L3056">	}</span>

	static boolean isShiftEventContainedInShiftAssignment(ShiftEventAssignment eventToCheck,
			ShiftAssignment shiftToCheck) {
<span class="nc" id="L3060">		return TimePeriodUtil.inside(eventToCheck.getStartTime(), eventToCheck.getEndTime(),</span>
<span class="nc" id="L3061">				shiftToCheck.getStartTime(), shiftToCheck.getEndTime());</span>
	}

	static boolean doesEventOverlapOtherEventsInShiftAssignment(ShiftEventAssignment eventToCheck,
			ShiftAssignment shiftToCheck) {

<span class="nc bnc" id="L3067" title="All 2 branches missed.">		for (ShiftEventAssignment eventAssignment : (Collection&lt;ShiftEventAssignment&gt;) shiftToCheck</span>
<span class="nc" id="L3068">				.getCreatedChildObjects(ShiftAssignmentFields.CHILD_SHIFT_EVENT)) {</span>
<span class="nc bnc" id="L3069" title="All 2 branches missed.">			if (eventToCheck.getID().equals(eventAssignment.getID())) {</span>
<span class="nc" id="L3070">				continue;</span>
			}

<span class="nc bnc" id="L3073" title="All 2 branches missed.">			if (checkEventsForOverlap(eventToCheck, eventAssignment)) {</span>
<span class="nc" id="L3074">				return true;</span>
			}
<span class="nc" id="L3076">		}</span>

<span class="nc" id="L3078">		return false;</span>
	}

	/**
	 * Events are determined to overlap if their time ranges (determined by
	 * their start and end times) overlap AND they have the same overlay
	 * precedence.
	 *
	 * @param event1
	 * @param event2
	 * @return
	 */
	static boolean checkEventsForOverlap(ShiftEventAssignment event1, ShiftEventAssignment event2) {
<span class="nc bnc" id="L3091" title="All 2 branches missed.">		if (event1.getOverlayPrecedence() == event2.getOverlayPrecedence() &amp;&amp; TimePeriodUtil</span>
<span class="nc bnc" id="L3092" title="All 2 branches missed.">				.overlap(event1.getStartTime(), event1.getEndTime(), event2.getStartTime(), event2.getEndTime())) {</span>
<span class="nc" id="L3093">			return true;</span>
		}
<span class="nc" id="L3095">		return false;</span>
	}

	private TimeZone findStartTimeZoneOfAssignmentAtTime(Collection&lt;WorkResourceAssignment&gt; orgAssignments, Date timeSpot,
			TimeZone defaultTZ) {
<span class="nc bnc" id="L3100" title="All 4 branches missed.">		if (orgAssignments == null || orgAssignments.isEmpty()) {</span>
<span class="nc" id="L3101">			return defaultTZ;</span>
		}

<span class="nc" id="L3104">		WorkResourceAssignment wra = WorkResourceAssignment.getRelatedWRAssignment(orgAssignments, timeSpot);</span>
<span class="nc bnc" id="L3105" title="All 4 branches missed.">		if (wra == null || wra.getStartTimeZone() == null) {</span>
<span class="nc" id="L3106">			return defaultTZ;</span>
		}

<span class="nc" id="L3109">		return wra.getStartTimeZone();</span>
	}

	/**
	 * Returns the timezone of the work resource's organization at the given date.  If the work resource does not have an organization
	 * assignment at that time, returns defaultTZ.
	 */
	private TimeZone findTimeZoneOfAssignmentAtTime(Collection&lt;WorkResourceAssignment&gt; orgAssignments, Date timeSpot, TimeZone defaultTZ) {
<span class="nc bnc" id="L3117" title="All 4 branches missed.">		if (orgAssignments == null || orgAssignments.isEmpty()) {</span>
<span class="nc" id="L3118">			return defaultTZ;</span>
		}

<span class="nc" id="L3121">		WorkResourceAssignment wra = WorkResourceAssignment.getRelatedWRAssignment(orgAssignments, timeSpot);</span>
<span class="nc bnc" id="L3122" title="All 4 branches missed.">		if (wra == null || wra.getTimeZone() == null) {</span>
<span class="nc" id="L3123">			return defaultTZ;</span>
		}

<span class="nc" id="L3126">		return TimeZone.getTimeZone(wra.getTimeZone());</span>
	}

	public void copyShiftAssignments(ID idSourceSP, ID idDestinationSP, boolean bClearDestinationSP)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L3131" title="All 2 branches missed.">		methodStart(&quot;copyShiftAssignments&quot;, idSourceSP, idDestinationSP,</span>
				bClearDestinationSP ? Boolean.TRUE : Boolean.FALSE);
		try {
<span class="nc" id="L3134">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="nc" id="L3135">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>
<span class="nc" id="L3136">			copyShiftAssignments(idSourceSP, pSourceSP.getStartTime(), idDestinationSP, pDestinationSP.getStartTime(),</span>
					bClearDestinationSP);
<span class="nc" id="L3138">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3139">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L3140">			throw e;</span>
<span class="nc" id="L3141">		} catch (Exception e) {</span>
<span class="nc" id="L3142">			handleException(&quot;copyShiftAssignments&quot;, e);</span>
<span class="nc" id="L3143">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3145">			methodFinish();</span>
<span class="nc" id="L3146">		}</span>

<span class="nc" id="L3148">	}</span>

	public void unlockShiftAssignmentsByIDs(Collection cShiftAssignmentIDs, Collection cWorkResourceIDs, Date dtStart,
			Date dtEnd, boolean bUnlockShiftEventsOnly) throws BbmUpdateException {
		// Jason: this is a last minute addition to address a customer issue, it
		// should be refactored later
		// 1) the lock method should be given a similar interface
		// 2) the is in synch with published state flags/audit trail should be
		// update
		// 3) cWorkResourceIDs,dtStart, and dtEnd are only used for logging and
		// lock checking

<span class="nc bnc" id="L3160" title="All 2 branches missed.">		methodStart(&quot;unlockShiftAssignmentsByIDs&quot;, cShiftAssignmentIDs,</span>
				bUnlockShiftEventsOnly ? Boolean.TRUE : Boolean.FALSE);

<span class="nc" id="L3163">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3165">			m_eventHandler.preUnlockEvents(cWorkResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L3166">			dao.unlockShiftAssignmentsByIDs(cShiftAssignmentIDs, bUnlockShiftEventsOnly);</span>
<span class="nc" id="L3167">			m_eventHandler.postUnlockEvents(cWorkResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L3168">		} catch (BbmUpdateException e) {</span>
<span class="nc" id="L3169">			handleException(e);</span>
<span class="nc" id="L3170">			throw e;</span>
<span class="nc" id="L3171">		} catch (Exception e) {</span>
<span class="nc" id="L3172">			handleException(e);</span>
<span class="nc" id="L3173">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L3175" title="All 4 branches missed.">			if (dao != null) {</span>
<span class="nc" id="L3176">				dao.cleanUp();</span>
			}
<span class="nc" id="L3178">			methodFinish();</span>
<span class="nc" id="L3179">		}</span>
<span class="nc" id="L3180">	}</span>

	/**
	 * This is an internal helper method that returns the DAO class that
	 * persists event template objects of a given type
	 */
	private AggEventTemplateDAO getDAOByEventTemplateType(short templateType, Jdmo dmo) {
<span class="nc" id="L3187">		AggEventTemplateDAO dao = null;</span>
<span class="nc bnc" id="L3188" title="All 3 branches missed.">		switch (templateType) {</span>
		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING:
		case CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING:
<span class="nc" id="L3191">			dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L3192">			break;</span>

		case CalendarEventTemplate.EVENT_TEMPLATE_FLOATING:
<span class="nc" id="L3195">			dao = new FloatingEventTemplateDAO(dmo);</span>
			break;
		}
<span class="nc" id="L3198">		return dao;</span>
	}

	/**
	 * This is an internal helper method that returns the Calendar Event
	 * Template Type persists event template objects of a given ID
	 */
	private short getCalendarEventTemplateTypeByID(ID templateID, Jdmo dmo) throws BbmFinderException {
<span class="nc" id="L3206">		CalendarEventTemplateDAO dao = new CalendarEventTemplateDAO(dmo);</span>
<span class="nc" id="L3207">		return dao.getTemplateTypeByID(templateID);</span>
	}

	/**
	 * This is an internal helper method that returns the DAO class that
	 * persists event template objects of a given ID
	 */
	private AggEventTemplateDAO getDAOByEventTemplateID(ID templateID, Jdmo dmo) throws BbmFinderException {
<span class="nc" id="L3215">		return getDAOByEventTemplateType(getCalendarEventTemplateTypeByID(templateID, dmo), dmo);</span>
	}

	/**
	 * This is an override of the base class method to initialize the per-EJB
	 * method cache
	 */
	@Override
	protected void methodStartHelper(String methodName, Object[] params) {
		/** @todo: maybe add the value of m_isWhatIf to each log message ? */
		/* call the base class */
<span class="fc" id="L3226">		super.methodStartHelper(methodName, params);</span>
		/*
		 * initialize the per-method cache only if we are the first method on
		 * the stack trace
		 */
<span class="fc bfc" id="L3231" title="All 2 branches covered.">		if (m_stackTrace.size() == 1) {</span>
<span class="fc" id="L3232">			CachePerEJBMethod cache = CachePerEJBMethod.newCache(this);</span>
		}
<span class="fc" id="L3234">	}</span>

	/**
	 * This is an override of the base class method to clean up the per-EJB
	 * method cache
	 */
	@Override
	protected void methodFinish() {
		/* call the base class */
<span class="fc" id="L3243">		super.methodFinish();</span>
		/*
		 * destroy the cash, we no longer need it since we are exiting the
		 * method
		 */
<span class="fc bfc" id="L3248" title="All 2 branches covered.">		if (m_stackTrace.isEmpty()) {</span>
<span class="fc" id="L3249">			CachePerEJBMethod.deleteCache();</span>
		}
<span class="fc" id="L3251">	}</span>

	/**
	 * These methods has package scope
	 */
	WorkResourceManager getWorkResourceManager() {
<span class="fc" id="L3257">		return m_workResourceManager;</span>
	}

	ActivityManager getActivityManager() {
<span class="fc" id="L3261">		return m_activityManager;</span>
	}

	EventAuditTrailManager getEventAuditTrailManager() {
<span class="nc" id="L3265">		return m_auditManager;</span>
	}

	ScheduleEventHandler getEventHandler() {
<span class="fc" id="L3269">		return m_eventHandler;</span>
	}

	/**
	 * Returns a list (an ordered collection) of collections of event templates
	 * for multiple workresources from their current (non-published) schedules.
	 * For each work resource ID in the method argument, there will be a
	 * corresponding collection of events in the return collection - maybe,
	 * empty, if there is no event template associated with that ID. The
	 * returned collections of events will be in the same order as the
	 * workresource IDs in the 1st method argument.
	 *
	 * @param workResourceIDs
	 *            IDs of the workresources
	 * @param dtStart
	 *            start of the desired time interval
	 * @param dtEnd
	 *            end of the desired time interval
	 * @return collection of ArrayLists of event templates
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List getEventTemplatesForWorkResourceIDs(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="fc" id="L3293">		methodStart(&quot;getEventTemplatesForWorkResourceIDs&quot;, workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3294">		Jdmo dmo1 = new Jdmo(), dmo2 = new Jdmo(); // not sure if we can use the</span>
		// same dmo for two selects
		try {
<span class="fc" id="L3297">			FloatingEventTemplateDAO dao1 = new FloatingEventTemplateDAO(dmo1);</span>
<span class="fc" id="L3298">			Collection flEvTemplates = dao1.getAllEventTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3299">			RecurringEventTemplateDAO dao2 = new RecurringEventTemplateDAO(dmo2);</span>
<span class="fc" id="L3300">			Collection recEvTemplates = dao2.getAllEventTemplatesForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="fc" id="L3301">			return ScheduleDAOUtil.combineTemplateCollections(workResourceIDs, flEvTemplates, recEvTemplates);</span>
<span class="nc" id="L3302">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3303">			handleException(e);</span>
<span class="nc" id="L3304">			throw e;</span>
		} finally {
<span class="pc" id="L3306">			dmo1.cleanUp();</span>
<span class="pc" id="L3307">			dmo2.cleanUp();</span>
<span class="pc" id="L3308">			methodFinish();</span>
		}
	} /* end of getEventTemplatesForWorkResourceIDs */

	/**
	 * Returns a list (an ordered collection) of collections of calendar event
	 * assignments for multiple event templates. For each calendar event
	 * template ID in the method argument, there will be a corresponding
	 * collection of calendar event assignments in the return collection -
	 * maybe, empty, if there is no assignment associated with that ID. The
	 * returned collections of events will be in the same order as the calendar
	 * event template IDs in the method argument.
	 *
	 * @param cidEventTemplates
	 *            IDs of the calendar event templates
	 * @return collection of ArrayLists of calendar event assignments
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getCalendarEventAssignmentsForCalendarEventTemplate(
			Collection&lt;ID&gt; cidEventTemplates) throws BbmFinderException {
<span class="nc" id="L3329">		methodStart(&quot;getCalendarEventAssignmentsForCalendarEventTemplate&quot;, cidEventTemplates);</span>
<span class="nc" id="L3330">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L3332">			CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L3333">			StringBuffer strSQL = new StringBuffer(100);</span>
<span class="nc" id="L3334">			strSQL.append(&quot; A.CALENDAREVENTTEMPLATEID IN &quot;);</span>
			try {
<span class="nc" id="L3336">				strSQL.append(dao.getDMO().createInClause(cidEventTemplates));</span>
<span class="nc" id="L3337">				Collection&lt;CalendarEventAssignment&gt; events = dao.getObjects(strSQL.toString());</span>
<span class="nc" id="L3338">				return ScheduleDAOUtil.reorderEventsByTemplateIds(cidEventTemplates, events);</span>
<span class="nc" id="L3339">			} catch (JdmoException e) {</span>
<span class="nc" id="L3340">				throw new BbmFinderException(e);</span>
			}
<span class="nc" id="L3342">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3343">			handleException(e);</span>
<span class="nc" id="L3344">			throw e;</span>
		} finally {
<span class="nc" id="L3346">			dmo.cleanUp();</span>
<span class="nc" id="L3347">			methodFinish();</span>
		}
	} /* end of getCalendarEventAssignmentsForCalendarEventTemplate */

	/**
	 * Returns a list of all RecurringEventTemplates for multiple workresources
	 * from their current (non-published) schedules.
	 *
	 * @param workResourceIDs
	 *            IDs of the workresources
	 * @param dtStart
	 *            start of the desired time interval
	 * @param dtEnd
	 *            end of the desired time interval
	 * @return collection of RecurringEventTemplates
	 * @throws BbmFinderException
	 *             if there is an error while executing DB query
	 */
	public List getAllRecurringEventTemplatesForPostMigration(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L3367">		RecurringEventTemplateDAO daoTemplate = new RecurringEventTemplateDAO();</span>
		try {
<span class="nc" id="L3369">			Collection res = daoTemplate.getAllEventTemplatesForWorkResourcesForPostMigration(workResourceIDs, dtStart,</span>
					dtEnd);
			// should be a list already, so it is just casting, not a copying
<span class="nc bnc" id="L3372" title="All 2 branches missed.">			return res instanceof List ? (List) res : new ArrayList(res);</span>
		} finally {
<span class="nc" id="L3374">			daoTemplate.cleanUp();</span>
		}
	}

	public void unlinkShiftAssignmentFromCampaign(Collection workResourceIDs, ID spID)
			throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3380">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, workResourceIDs, spID);</span>
<span class="nc" id="L3381">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3383">			dao.unlinkShiftAssignmentFromCampaign(workResourceIDs, spID);</span>
<span class="nc" id="L3384">		} catch (BbmUpdateException | MultiUserException e) {</span>
<span class="nc" id="L3385">			handleException(e);</span>
<span class="nc" id="L3386">			throw e;</span>
<span class="nc" id="L3387">		} catch (Exception e) {</span>
<span class="nc" id="L3388">			handleException(e);</span>
<span class="nc" id="L3389">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3391">			dao.cleanUp();</span>
<span class="nc" id="L3392">			methodFinish();</span>
<span class="nc" id="L3393">		}</span>
<span class="nc" id="L3394">	}</span>

	public void unlinkShiftAssignmentFromCampaign(Collection shiftAssignmentIDs)
			throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3398">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, shiftAssignmentIDs);</span>
<span class="nc" id="L3399">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3401">			dao.unlinkShiftAssignmentFromCampaign(shiftAssignmentIDs);</span>
<span class="nc" id="L3402">		} catch (BbmUpdateException | MultiUserException e) {</span>
<span class="nc" id="L3403">			handleException(e);</span>
<span class="nc" id="L3404">			throw e;</span>
<span class="nc" id="L3405">		} catch (Exception e) {</span>
<span class="nc" id="L3406">			handleException(e);</span>
<span class="nc" id="L3407">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3409">			dao.cleanUp();</span>
<span class="nc" id="L3410">			methodFinish();</span>
<span class="nc" id="L3411">		}</span>
<span class="nc" id="L3412">	}</span>

	public void unlinkShiftAssignmentFromCampaign(ID orgID, ID spID) throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3415">		methodStart(&quot;unlinkShiftAssignmentFromCampaign&quot;, orgID, spID);</span>
<span class="nc" id="L3416">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3418">			dao.unlinkShiftAssignmentFromCampaign(orgID, spID);</span>
<span class="nc" id="L3419">		} catch (BbmUpdateException | MultiUserException e) {</span>
<span class="nc" id="L3420">			handleException(e);</span>
<span class="nc" id="L3421">			throw e;</span>
<span class="nc" id="L3422">		} catch (Exception e) {</span>
<span class="nc" id="L3423">			handleException(e);</span>
<span class="nc" id="L3424">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L3426">			dao.cleanUp();</span>
<span class="nc" id="L3427">			methodFinish();</span>
<span class="nc" id="L3428">		}</span>
<span class="nc" id="L3429">	}</span>

	public void unlinkShiftAssignmentFromCampaign(ID spID) throws BbmUpdateException, MultiUserException {
<span class="nc" id="L3432">		unlinkShiftAssignmentFromCampaign((ID) null, spID);</span>
<span class="nc" id="L3433">	}</span>

	/*
	 * importedEvents is a two elements array list, first element is a hashmap
	 * of employeeid and skill assignments list pair; second elements are the
	 * list of sorted events - sorted by starttime;
	 */
	public boolean importStaffingProfiles(ID orgID, ID campaignID, ArrayList importedEvents, Date start, Date end)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3442">		methodStart(&quot;importStaffingProfiles&quot;, orgID, campaignID, importedEvents);</span>
		// reset static counters
		// Template_Name_ID = 1;
<span class="nc" id="L3445">		Phantom_Name = 1;</span>
		try {
			// get existing employee templates for the specific org including
			// skill assignments
<span class="nc" id="L3449">			Collection templates = getEmployeeTemplatesInOrg(orgID);</span>

			// refactor importedEvents map, replace skill assignment list to
			// template id.
<span class="nc" id="L3453">			HashMap skillMap = (HashMap) importedEvents.get(0);</span>
<span class="nc" id="L3454">			replaceSkillSetWithTemplateID(skillMap, orgID, templates);</span>

			// get campaign weeks linked to the specified org during the start
			// and end
<span class="nc" id="L3458">			Collection weeks = m_pCampaignManager.getSchedulingPeriods(campaignID, orgID, start, end);</span>
<span class="nc" id="L3459">			Collections.sort((ArrayList) weeks);</span>

<span class="nc" id="L3461">			ArrayList events = (ArrayList) importedEvents.get(1);</span>
<span class="nc" id="L3462">			Collections.sort(events);</span>

<span class="nc" id="L3464">			int ix = 0;</span>
<span class="nc" id="L3465">			int sizeOfEvents = events.size();</span>
			Event event;
<span class="nc" id="L3467">			HashMap workResourcePhantomIDMap = new HashMap();</span>
<span class="nc" id="L3468">			Collection attendees = null;</span>
<span class="nc" id="L3469">			Collection phantomIDs = null;</span>
<span class="nc" id="L3470">			ID id = null;</span>
			ShiftAssignment shift;
			SchedulingPeriod sp;
			// Note: both sp list and events list are sorted by start time asc
<span class="nc bnc" id="L3474" title="All 2 branches missed.">			for (Iterator i = weeks.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3475">				sp = (SchedulingPeriod) i.next();</span>
				// clear all profiles in the campaign week that have an Org ID
				// that was present in the export file
<span class="nc" id="L3478">				deletePhantomsWithoutDeleteChildlessTemplate(orgID, sp.getID());</span>

				// get events in this campain week
<span class="nc bnc" id="L3481" title="All 2 branches missed.">				while (ix &lt; sizeOfEvents) {</span>
<span class="nc" id="L3482">					event = (Event) events.get(ix++);</span>
<span class="nc" id="L3483">					tagEventUsingPhantomIDs(event, skillMap, workResourcePhantomIDMap);</span>
<span class="nc bnc" id="L3484" title="All 2 branches missed.">					if (event instanceof ShiftAssignment) {</span>
						// special handle shiftEventAssignment
<span class="nc" id="L3486">						shift = (ShiftAssignment) event;</span>
<span class="nc" id="L3487">						shift.setLocked(true);</span>
<span class="nc" id="L3488">						Collection shiftEvents = shift.getChildren();</span>
<span class="nc bnc" id="L3489" title="All 4 branches missed.">						if (shiftEvents != null &amp;&amp; !shiftEvents.isEmpty()) {</span>
<span class="nc bnc" id="L3490" title="All 2 branches missed.">							for (Iterator ise = shiftEvents.iterator(); ise.hasNext();) {</span>
<span class="nc" id="L3491">								ShiftEventAssignment shiftEvent = (ShiftEventAssignment) ise.next();</span>
<span class="nc" id="L3492">								shiftEvent.setLocked(true);</span>
<span class="nc" id="L3493">								tagEventUsingPhantomIDs(shiftEvent, skillMap, workResourcePhantomIDMap);</span>
<span class="nc" id="L3494">							}</span>
						}
<span class="nc" id="L3496">						createShiftAssignment(shift);</span>
<span class="nc bnc" id="L3497" title="All 2 branches missed.">					} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3498">						((CalendarEventAssignment) event).setLocked(true);</span>
<span class="nc" id="L3499">						createCalendarEventAssignment((CalendarEventAssignment) event);</span>
<span class="nc bnc" id="L3500" title="All 2 branches missed.">					} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3501">						((ImportedEvent) event).setLocked(true);</span>
<span class="nc" id="L3502">						createImportedEvent((ImportedEvent) event);</span>
					}

<span class="nc bnc" id="L3505" title="All 2 branches missed.">					if (ix &lt; sizeOfEvents) {</span>
<span class="nc" id="L3506">						Event nextEvent = (Event) events.get(ix);</span>
<span class="nc bnc" id="L3507" title="All 2 branches missed.">						if (nextEvent.getStartTime().after(sp.getEndTime())) {</span>
<span class="nc" id="L3508">							break;</span>
						}
<span class="nc" id="L3510">					}</span>
				}
				// link phantoms to the current sp
<span class="nc" id="L3513">				m_pCampaignManager.linkWorkResourcesToSchedulingPeriod(sp.getDEID(), workResourcePhantomIDMap.values());</span>
				// belong to next sp.
				// clean up phantom map since phantom only belong to single sp
<span class="nc" id="L3516">				workResourcePhantomIDMap = new HashMap();</span>
			}

			// delete hidden employee template that has no phantoms under it.
			// since this API will leave a lot of
			// garbage employee templates if we don't delete them. By the way,
			// only this code generate hidden
			// employee template for now, so delete them here is safe - 1/10/10
<span class="nc" id="L3524">			deleteChildlessHiddenEmployeeTemplate();</span>

<span class="nc" id="L3526">		} catch (Exception e) {</span>
<span class="nc" id="L3527">			handleException(e);</span>
<span class="nc" id="L3528">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L3530">			methodFinish();</span>
<span class="nc" id="L3531">		}</span>

<span class="nc" id="L3533">		return true;</span>
	}

	private void tagEventUsingPhantomIDs(Event event, HashMap skillMap, HashMap workResourcePhantomIDMap)
			throws Exception {
<span class="nc" id="L3538">		Collection attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L3539">		ArrayList phantomIDs = new ArrayList(attendees.size());</span>
		ID wkrsID;
<span class="nc bnc" id="L3541" title="All 2 branches missed.">		for (Iterator i = attendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3542">			wkrsID = (ID) i.next();</span>
			// i.remove();
<span class="nc" id="L3544">			phantomIDs.add(getOrCreatePhantom(wkrsID, skillMap, workResourcePhantomIDMap));</span>
		}

<span class="nc" id="L3547">		cleanOldAttendees(event);</span>

		ID phantomID;
<span class="nc bnc" id="L3550" title="All 2 branches missed.">		for (Iterator i = phantomIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3551">			phantomID = (ID) i.next();</span>
<span class="nc bnc" id="L3552" title="All 2 branches missed.">			if (event instanceof ShiftAssignment) {</span>
<span class="nc" id="L3553">				((ShiftAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3554" title="All 2 branches missed.">			} else if (event instanceof ShiftEventAssignment) {</span>
<span class="nc" id="L3555">				((ShiftEventAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3556" title="All 2 branches missed.">			} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3557">				((CalendarEventAssignment) event).addWorkResourceID(phantomID);</span>
<span class="nc bnc" id="L3558" title="All 2 branches missed.">			} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3559">				((ImportedEvent) event).addWorkResourceID(phantomID);</span>
			}
		}
<span class="nc" id="L3562">	}</span>

	// should add removeWorkResourceID into event interface, but it might have
	// too much
	// affect to other areas if we change it now, maybe later.
	private void cleanOldAttendees(Event event) {
<span class="nc" id="L3568">		Collection attendees = event.getWorkResourceIDs();</span>
		ID wkrsID;
<span class="nc bnc" id="L3570" title="All 2 branches missed.">		for (Iterator i = attendees.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3571">			wkrsID = (ID) i.next();</span>
<span class="nc bnc" id="L3572" title="All 2 branches missed.">			if (event instanceof ShiftAssignment) {</span>
<span class="nc" id="L3573">				((ShiftAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3574" title="All 2 branches missed.">			} else if (event instanceof ShiftEventAssignment) {</span>
<span class="nc" id="L3575">				((ShiftEventAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3576" title="All 2 branches missed.">			} else if (event instanceof CalendarEventAssignment) {</span>
<span class="nc" id="L3577">				((CalendarEventAssignment) event).removeWorkResourceID(wkrsID);</span>
<span class="nc bnc" id="L3578" title="All 2 branches missed.">			} else if (event instanceof ImportedEvent) {</span>
<span class="nc" id="L3579">				((ImportedEvent) event).removeWorkResourceID(wkrsID);</span>
			}
		}
<span class="nc" id="L3582">	}</span>

	/**
	 * Phantom naming rule: the first name is the name set in Phantom object the
	 * last name is the template name of phantom.
	 */
<span class="fc" id="L3588">	private static int Phantom_Name = 1;</span>

	private ID getOrCreatePhantom(ID wkrsID, Map skillMap, Map workResourcePhantomIDMap) throws Exception {
<span class="nc" id="L3591">		Object obj = workResourcePhantomIDMap.get(wkrsID);</span>
<span class="nc bnc" id="L3592" title="All 2 branches missed.">		if (obj != null) {</span>
			// phantom has been created in this sp
<span class="nc" id="L3594">			return (ID) obj;</span>
		}

<span class="nc" id="L3597">		ID empTemplateID = (ID) skillMap.get(wkrsID);</span>
<span class="nc" id="L3598">		Phantom phantom = new Phantom();</span>
<span class="nc" id="L3599">		phantom.setEmployeeTemplateID(empTemplateID);</span>
<span class="nc" id="L3600">		phantom.setName(&quot;&quot; + Phantom_Name++);</span>
<span class="nc" id="L3601">		ID phantomID = createPhantom(phantom);</span>
<span class="nc" id="L3602">		workResourcePhantomIDMap.put(wkrsID, phantomID);</span>
<span class="nc" id="L3603">		return phantomID;</span>
	}

	private void replaceSkillSetWithTemplateID(HashMap skillSet, ID orgID, Collection existingTemplates)
			throws Exception {
		Map.Entry entry;
		Collection skillAssignments;
		ID empTemplateID;
<span class="nc bnc" id="L3611" title="All 2 branches missed.">		for (Iterator i = skillSet.entrySet().iterator(); i.hasNext();) {</span>
<span class="nc" id="L3612">			entry = (Map.Entry) i.next();</span>
			// skill assignments
<span class="nc" id="L3614">			skillAssignments = (Collection) entry.getValue();</span>
<span class="nc" id="L3615">			empTemplateID = findOrCreateEmpTemplate(orgID, skillAssignments, existingTemplates);</span>
<span class="nc" id="L3616">			entry.setValue(empTemplateID);</span>
		}
<span class="nc" id="L3618">	}</span>

	/*
	 * Jason said: a. Check if a Hidden Employee Template exists for the
	 * Employee's skills and Orgs by calling a WorkResourceManager function b.
	 * If no Hidden Employee Template exists, create one by calling a
	 * WorkResourceManager method
	 *
	 * Note: there is no isHidden in emptemplate object any more, add it back? -
	 * Angela
	 */
	private ID findOrCreateEmpTemplate(ID orgID, Collection skillAssignments, Collection existingTemplates)
			throws Exception {
		EmployeeTemplate empTemplate;
		List templateSkills;
<span class="nc bnc" id="L3633" title="All 2 branches missed.">		for (Iterator i = existingTemplates.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3634">			empTemplate = (EmployeeTemplate) i.next();</span>
<span class="nc bnc" id="L3635" title="All 2 branches missed.">			if (!empTemplate.getFieldValueBoolean(EmployeeTemplateFieldInfo.EMPTEMPLATE_ISHIDDEN)) {</span>
<span class="nc" id="L3636">				continue;</span>
			}
<span class="nc" id="L3638">			templateSkills = empTemplate.getSkillAssignments();</span>
<span class="nc" id="L3639">			int skillSize = skillAssignments.size();</span>
<span class="nc bnc" id="L3640" title="All 2 branches missed.">			if (templateSkills.size() == skillAssignments.size()) {</span>
				SkillAssignment skillAssignment;
<span class="nc bnc" id="L3642" title="All 2 branches missed.">				for (Iterator ii = skillAssignments.iterator(); ii.hasNext();) {</span>
<span class="nc" id="L3643">					skillAssignment = (SkillAssignment) ii.next();</span>
<span class="nc bnc" id="L3644" title="All 2 branches missed.">					if (isInTemplateSkill(templateSkills, skillAssignment)) {</span>
<span class="nc" id="L3645">						skillSize -= 1;</span>
					}
				}
			}
<span class="nc bnc" id="L3649" title="All 2 branches missed.">			if (skillSize == 0) {</span>
<span class="nc" id="L3650">				return empTemplate.getID();</span>
			}
<span class="nc" id="L3652">		}</span>

		// can not find one in existing template, create one here
<span class="nc" id="L3655">		return createEmpTemplateWithSkills(orgID, skillAssignments);</span>
	}

	private boolean isInTemplateSkill(List templateSkills, SkillAssignment skillAssignment) {
		SkillAssignment templateSkill;
<span class="nc bnc" id="L3660" title="All 2 branches missed.">		for (Iterator i = templateSkills.iterator(); i.hasNext();) {</span>
<span class="nc" id="L3661">			templateSkill = (SkillAssignment) i.next();</span>
<span class="nc bnc" id="L3662" title="All 2 branches missed.">			if (templateSkill.getSkillID().equals(skillAssignment.getSkillID())</span>
<span class="nc bnc" id="L3663" title="All 2 branches missed.">					&amp;&amp; templateSkill.getPriority() == skillAssignment.getPriority()</span>
<span class="nc bnc" id="L3664" title="All 2 branches missed.">					&amp;&amp; templateSkill.getProficiency() == skillAssignment.getProficiency()</span>
<span class="nc bnc" id="L3665" title="All 2 branches missed.">					&amp;&amp; templateSkill.isReserve() == skillAssignment.isReserve()) {</span>
<span class="nc" id="L3666">				return true;</span>
			}
		}
<span class="nc" id="L3669">		return false;</span>
	}

	/*
	 * To create an employee template, here is the non-nullable field: orgID,
	 * name
	 */
	private ID createEmpTemplateWithSkills(ID orgID, Collection skillAssignments) throws Exception {
<span class="nc" id="L3677">		EmployeeTemplate empTemplate = new EmployeeTemplate();</span>
		// template name should be &lt;orgname&gt;-&lt;id&gt;
<span class="nc" id="L3679">		String templateName = m_workResourceManager.getOrganizationName(orgID);</span>
<span class="nc" id="L3680">		empTemplate.setOrganizationID(orgID);</span>
<span class="nc" id="L3681">		empTemplate.setName(templateName);</span>
<span class="nc" id="L3682">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_WAGE, 0.0);</span>
<span class="nc" id="L3683">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_PROFICIENCY, 1.0);</span>
<span class="nc" id="L3684">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_ISHIDDEN, true);</span>
<span class="nc" id="L3685">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CREATED, new Date());</span>
<span class="nc" id="L3686">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CREATEDBY, &quot;imported&quot;);</span>
<span class="nc" id="L3687">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_CONNECTIONID, 0);</span>
<span class="nc" id="L3688">		empTemplate.setFieldValue(EmployeeTemplateFieldInfo.EMPTEMPLATE_BPTIMESTAMP, 0);</span>
<span class="nc" id="L3689">		empTemplate.setChatSessions(1);</span>
<span class="nc" id="L3690">		empTemplate.setSkillAssignments(skillAssignments);</span>
<span class="nc" id="L3691">		return createEmployeeTemplate(empTemplate);</span>
	}

	public Collection exportStaffingProfiles(Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmFinderException {
<span class="nc" id="L3696">		methodStart(&quot;exportStaffingProfiles&quot;, workResourceIDs, dtStart, dtEnd);</span>

		/* set up a bit mask that represents all types of published events */
<span class="nc" id="L3699">		int eventTypeMask = Event.EVENT_TYPE_IMPORTED | Event.EVENT_TYPE_SHIFT_ASSIGNMENT</span>
				| Event.EVENT_TYPE_ALL_CALENDAR_EVENTS;

<span class="nc" id="L3702">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L3704">			ArrayList events = new ArrayList();</span>

<span class="nc" id="L3706">			ImportedEventDAO importedDao = new ImportedEventDAO(dmo);</span>
<span class="nc" id="L3707">			events.addAll(importedDao.exportStaffingProfiles(workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3709">			ShiftAssignmentPubDAO shiftDao = new ShiftAssignmentPubDAO(dmo);</span>
<span class="nc" id="L3710">			events.addAll(shiftDao.exportStaffingProfiles(workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3712">			CalendarEventAssignmentPubDAO ceaDao = new CalendarEventAssignmentPubDAO(dmo);</span>
<span class="nc" id="L3713">			events.addAll(ceaDao.exportStaffingProfiles(eventTypeMask, workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L3715">			Collections.sort(events);</span>
<span class="nc" id="L3716">			return events;</span>
		} finally {
<span class="nc" id="L3718">			dmo.cleanUp();</span>
<span class="nc" id="L3719">			methodFinish();</span>
		}
	}

	public HashMap getLastPublishedShiftAssignmentStartTime(Collection workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L3725">		methodStart(&quot;getLastPublishedShiftAssignmentStartTime&quot;, workResourceIDs);</span>

<span class="nc" id="L3727">		ShiftAssignmentPubDAO dao = new ShiftAssignmentPubDAO();</span>
		try {
<span class="nc" id="L3729">			return dao.getLastPublishedShiftAssignmentStartTime(workResourceIDs);</span>
<span class="nc" id="L3730">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3731">			throw ex;</span>
<span class="nc" id="L3732">		} catch (Exception e) {</span>
<span class="nc" id="L3733">			handleException(e);</span>
<span class="nc" id="L3734">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3736">			dao.cleanUp();</span>
<span class="nc" id="L3737">			methodFinish();</span>
		}
	}

	public HashMap getLastShiftAssignmentStartTime(Collection workResourceIDs)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L3743">		methodStart(&quot;getLastShiftAssignmentStartTime&quot;, workResourceIDs);</span>

<span class="nc" id="L3745">		ShiftAssignmentDAO dao = new ShiftAssignmentDAO();</span>
		try {
<span class="nc" id="L3747">			return dao.getLastShiftAssignmentStartTime(workResourceIDs);</span>
<span class="nc" id="L3748">		} catch (BbmFinderException ex) {</span>
<span class="nc" id="L3749">			throw ex;</span>
<span class="nc" id="L3750">		} catch (Exception e) {</span>
<span class="nc" id="L3751">			handleException(e);</span>
<span class="nc" id="L3752">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3754">			dao.cleanUp();</span>
<span class="nc" id="L3755">			methodFinish();</span>
		}
	}

	public FloatingEventTemplate createRecurringFloatingEventException(ID templateID, Collection workResourceIDs,
			Date instanceStart, int duration, Date floatingStart, Date floatingEnd, boolean isLocked)
			throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3762">		return createRecurringFloatingEventExceptionWithLock(null, templateID, workResourceIDs, instanceStart, duration,</span>
				floatingStart, floatingEnd, isLocked);
	}

	public FloatingEventTemplate createRecurringFloatingEventExceptionWithLock(String lockID, ID templateID,
			Collection workResourceIDs, Date instanceStart, int duration, Date floatingStart, Date floatingEnd,
			boolean isLocked) throws BbmCreateException, MultiUserException, BbmScheduleConflictException {
<span class="nc" id="L3769">		methodStart(&quot;createRecurringFloatingEventExceptionWithLock&quot;, lockID, templateID, workResourceIDs,</span>
				instanceStart);

<span class="nc" id="L3772">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L3774">			RecurringEventTemplateDAO dao = new RecurringEventTemplateDAO(dmo);</span>
<span class="nc" id="L3775">			RecurringEventTemplateBase recTemplate = dao.getObjectByID(templateID);</span>

<span class="nc" id="L3777">			Date exceptionOnDate = instanceStart;</span>

<span class="nc" id="L3779">			FloatingEventTemplate eventException = (FloatingEventTemplate) dao.createRecurringEventException(</span>
					recTemplate, workResourceIDs, exceptionOnDate, duration, instanceStart, floatingStart, floatingEnd);

			// find the exception instance
<span class="nc" id="L3783">			CalendarEventAssignmentDAO ceaDAO = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L3784">			CalendarEventAssignment cea = (ceaDAO.getObjectsByParentID(eventException.getID()).iterator().next());</span>
<span class="nc bnc" id="L3785" title="All 2 branches missed.">			if (isLocked) {</span>
<span class="nc" id="L3786">				cea.setLocked(isLocked);</span>
<span class="nc" id="L3787">				ceaDAO.updateObject(cea);</span>
			}
<span class="nc" id="L3789">			checkConflictForNewObject(dmo, cea, templateID);</span>

			// check if it can not be created because the schedule has been
			// locked
<span class="nc bnc" id="L3793" title="All 2 branches missed.">			if (lockID != null) {</span>
<span class="nc" id="L3794">				m_eventHandler.preCreateEvent(lockID, cea);</span>
			}

<span class="nc" id="L3797">			return eventException;</span>
<span class="nc" id="L3798">		} catch (BbmCreateException | BbmScheduleConflictException e) {</span>
<span class="nc" id="L3799">			handleException(e);</span>
<span class="nc" id="L3800">			throw e;</span>
<span class="nc" id="L3801">		} catch (Exception e) {</span>
<span class="nc" id="L3802">			handleException(e);</span>
<span class="nc" id="L3803">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L3805">			dmo.cleanUp();</span>
<span class="nc" id="L3806">			methodFinish();</span>
		}
	}

	// for recurring floating event template only
	public ID createFloatingEventTemplateWithInstances(CalendarEventTemplate eventTemplate, Date instanceStartTime,
			BbmScheduleConflictResolutions conflictResolutions)
			throws BbmScheduleConflictException, MultiUserException, BbmCreateException {
<span class="nc" id="L3814">		FloatingEventTemplate floatTemp = (FloatingEventTemplate) eventTemplate;</span>
<span class="nc" id="L3815">		floatTemp.setInstanceStart(instanceStartTime);</span>
<span class="nc" id="L3816">		return createEventTemplateWithInstances(floatTemp, conflictResolutions);</span>
	}

	/**
	 * Copies Employee Min/Max Hour Assignments, Skill Assignments, and Work Pattern Assignments from one SP week to another.
	 * @param idSourceSP
	 * @param sourceWeekStart
	 * @param idDestinationSP
	 * @param targetWeekStart
	 * @throws BbmFinderException
	 */
	public void copyEffectiveDates(ID idSourceSP, Date sourceWeekStart, ID idDestinationSP, Date targetWeekStart)
			throws BbmFinderException {
<span class="nc" id="L3829">		methodStart(&quot;copyEffectiveDates&quot;, idSourceSP, sourceWeekStart, idDestinationSP, targetWeekStart);</span>
		try {
<span class="nc" id="L3831">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(idSourceSP);</span>
<span class="nc" id="L3832">			SchedulingPeriod pDestinationSP = m_pCampaignManager.getSchedulingPeriodByID(idDestinationSP);</span>
<span class="nc" id="L3833">			Campaign pCampaign = m_pCampaignManager.getCampaignByID(pSourceSP.getCampaignID());</span>

<span class="nc" id="L3835">			Date sourceWeekEnd = getWeekEnd(sourceWeekStart, pSourceSP, pCampaign, true);</span>
<span class="nc" id="L3836">			Date targetWeekEnd = getWeekEnd(targetWeekStart, pDestinationSP, pCampaign, true);</span>

			// get workresources in the destination sp
<span class="nc" id="L3839">			Collection&lt;CampaignWorkResource&gt; cpAssignments = m_pCampaignManager</span>
<span class="nc" id="L3840">					.getCampaignWorkResourceAssignments(</span>
<span class="nc" id="L3841">							pDestinationSP.getCampaignID(), targetWeekStart, targetWeekEnd);</span>

<span class="nc" id="L3843">			Set&lt;ID&gt; workResourceIds = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L3844" title="All 2 branches missed.">			for (CampaignWorkResource pAssignment : cpAssignments) {</span>
<span class="nc" id="L3845">				workResourceIds.add(pAssignment.getWorkResourceID());</span>
<span class="nc" id="L3846">			}</span>

			// effecivity period: find effectivity value at source week start and extending 24 hours before and after to
			// absorb time zone difference
<span class="nc" id="L3850">			Date effStart = TimeZoneUtil.previousDay(sourceWeekStart);</span>
<span class="nc" id="L3851">			Date effEnd = TimeZoneUtil.nextDay(sourceWeekStart);</span>

			// load effective assignments that were active at the start of the source sp: minmax assignments, skill assignments and
			// work pattern assignments
<span class="nc" id="L3855">			Map&lt;ID, Collection&lt;EmployeeMinMaxMinutes&gt;&gt; sourceMinMaxAssignments = m_workResourceManager</span>
<span class="nc" id="L3856">					.getMinMaxMinutesAssignmentsInPeriodAndOnSpotOnly(workResourceIds, effStart, effEnd, null);</span>
<span class="nc" id="L3857">			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; sourceWorkPatternAssignments = m_empWorkRuleManager</span>
<span class="nc" id="L3858">					.getWorkPatternAssignmentsInPeriodAndOnSpotOnly(workResourceIds, effStart, effEnd, null);</span>
<span class="nc" id="L3859">			Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; sourceSkillAssignments = m_skillManager.getSkillAssignmentInPeriodAndOnSpotOnly(</span>
					workResourceIds, effStart, effEnd, null);

			//load effective assignments that were active at the start of the destination sp (in case they already existed before the
			// clone operation)
<span class="nc" id="L3864">			Date targetEffStart = TimeZoneUtil.previousDay(targetWeekStart);</span>
<span class="nc" id="L3865">			Date targetEffEnd = TimeZoneUtil.nextDay(targetWeekStart);</span>
<span class="nc" id="L3866">			Map&lt;ID, Collection&lt;EmployeeMinMaxMinutes&gt;&gt; targetMinMaxAssignments = m_workResourceManager</span>
<span class="nc" id="L3867">					.getMinMaxMinutesAssignmentsInPeriodAndOnSpotOnly(workResourceIds, targetEffStart, targetEffEnd,</span>
							null);
<span class="nc" id="L3869">			Map&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; targetWorkPatternAssignments = m_empWorkRuleManager</span>
<span class="nc" id="L3870">					.getWorkPatternAssignmentsInPeriodAndOnSpotOnly(workResourceIds, targetEffStart, targetEffEnd,</span>
							null);
<span class="nc" id="L3872">			Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; targetSkillAssignments = m_skillManager</span>
<span class="nc" id="L3873">					.getSkillAssignmentInPeriodAndOnSpotOnly(workResourceIds, targetEffStart, targetEffEnd, null);</span>

			// widen the select range up and down one day
<span class="nc" id="L3876">			Calendar gc = Calendar.getInstance(pCampaign.getTimeZone());</span>
<span class="nc" id="L3877">			gc.setTime(pSourceSP.getStartTime());</span>
<span class="nc" id="L3878">			gc.add(Calendar.DATE, -1);</span>
<span class="nc" id="L3879">			Date start = gc.getTime();</span>
<span class="nc" id="L3880">			gc.setTime(pSourceSP.getEndTime());</span>
<span class="nc" id="L3881">			gc.add(Calendar.DATE, 1);</span>
<span class="nc" id="L3882">			Date end = gc.getTime();</span>
<span class="nc" id="L3883">			Map&lt;ID, Collection&lt;WorkResourceAssignment&gt;&gt; workResourceAssignments = m_workResourceManager.getValidWorkResourceAssignments(</span>
<span class="nc" id="L3884">					workResourceIds, new LocalDate(start, pCampaign.getTimeZone()),</span>
<span class="nc" id="L3885">					new LocalDate(end, pCampaign.getTimeZone()));</span>

<span class="nc" id="L3887">			List&lt;EmployeeMinMaxMinutes&gt; newMinMaxAssignments = new ArrayList&lt;&gt;(sourceMinMaxAssignments.size());</span>
<span class="nc" id="L3888">			List&lt;WorkResourceWorkPattern&gt; newWorkPatternAssignments = new ArrayList&lt;&gt;(sourceWorkPatternAssignments.size());</span>
<span class="nc" id="L3889">			List&lt;SkillAssignment&gt; newSkillAssignments = new ArrayList&lt;&gt;(sourceSkillAssignments.size());</span>
			Collection&lt;WorkResourceAssignment&gt; orgAssignments;
<span class="nc bnc" id="L3891" title="All 2 branches missed.">			for (ID wrsID : workResourceIds) {</span>
<span class="nc" id="L3892">				orgAssignments = workResourceAssignments.get(wrsID);</span>
<span class="nc" id="L3893">				newMinMaxAssignments.addAll(moveEffectivitiesToDestinationSP(pCampaign, orgAssignments,</span>
<span class="nc" id="L3894">						sourceMinMaxAssignments.get(wrsID), targetMinMaxAssignments.get(wrsID), new Pair&lt;&gt;(sourceWeekStart, sourceWeekEnd),</span>
						new Pair&lt;&gt;(targetWeekStart, targetWeekEnd)));
<span class="nc" id="L3896">				newWorkPatternAssignments.addAll(moveEffectivitiesToDestinationSP(pCampaign, orgAssignments,</span>
<span class="nc" id="L3897">						sourceWorkPatternAssignments.get(wrsID), targetWorkPatternAssignments.get(wrsID),</span>
						new Pair&lt;&gt;(sourceWeekStart, sourceWeekEnd), new Pair&lt;&gt;(targetWeekStart, targetWeekEnd)));
<span class="nc" id="L3899">				newSkillAssignments.addAll(moveEffectivitiesToDestinationSP(pCampaign, orgAssignments,</span>
<span class="nc" id="L3900">						sourceSkillAssignments.get(wrsID), targetSkillAssignments.get(wrsID), new Pair&lt;&gt;(sourceWeekStart, sourceWeekEnd),</span>
						new Pair&lt;&gt;(targetWeekStart, targetWeekEnd)));
<span class="nc" id="L3902">			}</span>

<span class="nc bnc" id="L3904" title="All 2 branches missed.">			if (!newMinMaxAssignments.isEmpty()) {</span>
<span class="nc bnc" id="L3905" title="All 2 branches missed.">				for (EmployeeMinMaxMinutes empMinMax : newMinMaxAssignments) {</span>
<span class="nc" id="L3906">					m_workResourceManager.createMinMaxMinutesAssignment(empMinMax);</span>
<span class="nc" id="L3907">				}</span>
			}
<span class="nc bnc" id="L3909" title="All 2 branches missed.">			if (!newWorkPatternAssignments.isEmpty()) {</span>
<span class="nc" id="L3910">				m_empWorkRuleManager.createWorkPatternAssignments(newWorkPatternAssignments);</span>
			}
<span class="nc bnc" id="L3912" title="All 2 branches missed.">			if (!newSkillAssignments.isEmpty()) {</span>
<span class="nc" id="L3913">				m_skillManager.createSkillAssignments(newSkillAssignments);</span>
			}

<span class="nc" id="L3916">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L3917">			handleException(&quot;copyEffectiveDates&quot;, e);</span>
<span class="nc" id="L3918">			throw e;</span>
<span class="nc" id="L3919">		} catch (Exception e) {</span>
<span class="nc" id="L3920">			handleException(&quot;copyEffectiveDates&quot;, e);</span>
<span class="nc" id="L3921">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L3923">			methodFinish();</span>
<span class="nc" id="L3924">		}</span>
<span class="nc" id="L3925">	}</span>

	/**
	 * Moves a single work resource's effective assignments from one scheduling period to another, where an effective assignment is
	 * defined as one of the following: skill assignment, work pattern assignment, or min/max hour assignment.
	 * @param campaign - The campaign containing the source/destination SPs in the SP clone operation.
	 * @param orgAssignments - The organization effective assignments of the work resource.  Used to determine the time zone of the
	 *                       assignment.
	 * @param sourceAssignments - The effective assignments from the source week that will be moved/copied to the target week.
	 * @param curTargetAssignments - The assignments that are already currently effective for the work resource in the target week.
	 * @param sourceWeek
	 * @param targetWeek
	 * @param &lt;T&gt; - The type of ValueObjectEffectivity (currently only used for EmployeeMinMaxMinutes, WorkResourceWorkPattern, and
	 *           SkillAssignment)
	 * @return
	 * @throws Exception
	 */
	private &lt;T extends ValueObjectEffectivity&gt; Collection&lt;T&gt; moveEffectivitiesToDestinationSP(Campaign campaign,
			Collection&lt;WorkResourceAssignment&gt; orgAssignments, Collection&lt;T&gt; sourceAssignments, Collection&lt;T&gt; curTargetAssignments,
			Pair&lt;Date, Date&gt; sourceWeek, Pair&lt;Date, Date&gt; targetWeek) throws Exception {

<span class="nc bnc" id="L3946" title="All 4 branches missed.">		if (sourceAssignments == null || sourceAssignments.isEmpty()) {</span>
<span class="nc" id="L3947">			return Collections.emptyList();</span>
		}

<span class="nc" id="L3950">		List&lt;T&gt; sortedAssignments = new ArrayList&lt;&gt;(sourceAssignments);</span>
<span class="nc" id="L3951">		Collections.sort(sortedAssignments);</span>

<span class="nc" id="L3953">		List&lt;T&gt; movedAssignments = new ArrayList&lt;&gt;(sortedAssignments.size());</span>
<span class="nc bnc" id="L3954" title="All 2 branches missed.">		for (T assignmentToMove : sortedAssignments) {</span>

<span class="nc" id="L3956">			TimeZone userOrgTimeZone = findTimeZoneOfAssignmentAtTime(orgAssignments, assignmentToMove.getStartTime(),</span>
<span class="nc" id="L3957">					campaign.getTimeZone());</span>
<span class="nc" id="L3958">			Date adjustedSourceWeekStart = adjustDateToUserOrgTimeZone(sourceWeek.getFirst(), campaign.getTimeZone(), userOrgTimeZone);</span>
<span class="nc" id="L3959">			Date adjustedSourceWeekEnd = adjustDateToUserOrgTimeZone(sourceWeek.getSecond(), campaign.getTimeZone(), userOrgTimeZone);</span>
<span class="nc" id="L3960">			Date adjustedTargetWeekStart = adjustDateToUserOrgTimeZone(targetWeek.getFirst(), campaign.getTimeZone(), userOrgTimeZone);</span>
<span class="nc" id="L3961">			Date adjustedTargetWeekEnd = adjustDateToUserOrgTimeZone(targetWeek.getSecond(), campaign.getTimeZone(), userOrgTimeZone);</span>
<span class="nc bnc" id="L3962" title="All 2 branches missed.">			if (isAssignmentToBeMoved(assignmentToMove, adjustedSourceWeekStart, adjustedSourceWeekEnd)) {</span>
<span class="nc bnc" id="L3963" title="All 2 branches missed.">				if (isSourceOrTargetAPartialSpWeek(campaign, adjustedSourceWeekStart, adjustedSourceWeekEnd,</span>
						adjustedTargetWeekStart, adjustedTargetWeekEnd)) {
<span class="nc" id="L3965">					Pair&lt;Date, Date&gt; newAssignmentRange = MonthlySPUtil.relocateRangeFromOldWeekToNewWeek(campaign.getTimeZone(),</span>
<span class="nc" id="L3966">							assignmentToMove.getStartTime(), assignmentToMove.getEndTime(), adjustedSourceWeekStart, adjustedSourceWeekEnd,</span>
							adjustedTargetWeekStart, adjustedTargetWeekEnd);
<span class="nc bnc" id="L3968" title="All 2 branches missed.">					if (newAssignmentRange.getFirst() != null) {</span>
<span class="nc" id="L3969">						assignmentToMove.setStartTime(newAssignmentRange.getFirst());</span>
<span class="nc" id="L3970">						assignmentToMove.setEndTime(newAssignmentRange.getSecond());</span>
					} else {
						// nothing to copy, so skip it
						continue;
					}
<span class="nc" id="L3975">				} else {</span>
<span class="nc" id="L3976">					int deltaInMinutes = (int) ((adjustedTargetWeekStart.getTime() - adjustedSourceWeekStart.getTime()) /</span>
							TimeZoneUtil.MINUTE_IN_MILLISECONDS);

					// Trim the start/end dates of the new assignment to fit within the sp week (adjusted for the user's org's timezone)
<span class="nc bnc" id="L3980" title="All 2 branches missed.">					if (assignmentToMove.getStartTime().before(adjustedSourceWeekStart)) {</span>
<span class="nc" id="L3981">						assignmentToMove.setStartTime(adjustedSourceWeekStart);</span>
					}
<span class="nc bnc" id="L3983" title="All 4 branches missed.">					if (assignmentToMove.getEndTime() == null || assignmentToMove.getEndTime().after(adjustedSourceWeekEnd)) {</span>
<span class="nc" id="L3984">						assignmentToMove.setEndTime(adjustedSourceWeekEnd);</span>
					}

					// add delta
<span class="nc" id="L3988">					Calendar calendar = Calendar.getInstance();</span>
<span class="nc" id="L3989">					calendar.setTime(assignmentToMove.getStartTime());</span>
<span class="nc" id="L3990">					calendar.add(Calendar.MINUTE, deltaInMinutes);</span>
<span class="nc" id="L3991">					assignmentToMove.setStartTime(calendar.getTime());</span>

<span class="nc" id="L3993">					calendar.setTime(assignmentToMove.getEndTime());</span>
<span class="nc" id="L3994">					calendar.add(Calendar.MINUTE, deltaInMinutes);</span>
<span class="nc" id="L3995">					assignmentToMove.setEndTime(calendar.getTime());</span>
				}

				// check if the new assignment is in current target already
<span class="nc bnc" id="L3999" title="All 2 branches missed.">				if (isNewAssignment(curTargetAssignments, assignmentToMove)) {</span>
<span class="nc" id="L4000">					movedAssignments.add(assignmentToMove);</span>
				}
			}
<span class="nc" id="L4003">		}</span>
<span class="nc" id="L4004">		return movedAssignments;</span>
	}

	/**
	 * Adjusts the given date (should be midnight at the campaign's time zone) so that it becomes midnight at the user's org's time zone.
	 * If the user's org's timezone's offset from UTC is less than the campaign's timezone's offset, then this method will also subtract
	 * a day from the campaignDate to ensure that the adjusted date will cover the start of the SP relative to the campaign's time zone.
	 */
	private Date adjustDateToUserOrgTimeZone(Date campaignDate, TimeZone campaignTimeZone, TimeZone orgTimeZone) {
<span class="nc" id="L4013">		ZonedDateTime adjustedDate = campaignDate.toInstant().atZone(campaignTimeZone.toZoneId());</span>
<span class="nc bnc" id="L4014" title="All 2 branches missed.">		if (orgTimeZone.getOffset(campaignDate.getTime()) &lt; campaignTimeZone.getOffset(campaignDate.getTime())) {</span>
<span class="nc" id="L4015">			adjustedDate = adjustedDate.minusDays(1);</span>
		}
<span class="nc" id="L4017">		return Date.from(adjustedDate.withZoneSameLocal(orgTimeZone.toZoneId()).toInstant());</span>
	}

	private &lt;T extends ValueObjectEffectivity&gt; boolean isAssignmentToBeMoved(T assignmentToMove, Date sourceWeekStart, Date sourceWeekEnd) {
<span class="nc bnc" id="L4021" title="All 4 branches missed.">		return assignmentToMove.getStartTime().before(sourceWeekEnd) &amp;&amp; (assignmentToMove.getEndTime() == null ||</span>
<span class="nc bnc" id="L4022" title="All 2 branches missed.">				assignmentToMove.getEndTime().after(sourceWeekStart));</span>
	}

	private boolean isSourceOrTargetAPartialSpWeek(Campaign campaign, Date sourceWeekStart, Date sourceWeekEnd, Date targetWeekStart,
			Date targetWeekEnd) {
<span class="nc bnc" id="L4027" title="All 4 branches missed.">		return campaign.isMonthly() &amp;&amp; (MonthlySPUtil.isPartialWeek(campaign.getTimeZone(), sourceWeekStart, sourceWeekEnd)</span>
<span class="nc bnc" id="L4028" title="All 2 branches missed.">				|| MonthlySPUtil.isPartialWeek(campaign.getTimeZone(), targetWeekStart, targetWeekEnd));</span>
	}

	/**
	 * Checks the set of current assignments already assigned to the work resource to see if the potential new assignment is in
	 * that set.  If it is, returns false.  Otherwise, returns true.
	 */
	private &lt;T extends ValueObjectEffectivity&gt; boolean isNewAssignment(Collection&lt;T&gt; curTargetAssignments,
			ValueObjectEffectivity potentialNewAssignment) {
<span class="nc bnc" id="L4037" title="All 4 branches missed.">		if (curTargetAssignments == null || curTargetAssignments.isEmpty()) {</span>
<span class="nc" id="L4038">			return true;</span>
		}

<span class="nc bnc" id="L4041" title="All 2 branches missed.">		for (T curTargetObj : curTargetAssignments) {</span>
<span class="nc bnc" id="L4042" title="All 2 branches missed.">			if (curTargetObj.effectivityValueEqual(potentialNewAssignment)</span>
<span class="nc bnc" id="L4043" title="All 2 branches missed.">					&amp;&amp; !curTargetObj.getStartTime().after(potentialNewAssignment.getStartTime())</span>
<span class="nc bnc" id="L4044" title="All 4 branches missed.">					&amp;&amp; (curTargetObj.getEndTime() == null || !curTargetObj.getEndTime().before(potentialNewAssignment.getEndTime()))) {</span>
<span class="nc" id="L4045">				return false;</span>
			}
<span class="nc" id="L4047">		}</span>
<span class="nc" id="L4048">		return true;</span>
	}

	private Collection&lt;SkillAssignment&gt; fixProficiency(Collection&lt;SkillAssignment&gt; skillAssignments) {
<span class="nc bnc" id="L4052" title="All 4 branches missed.">		if (skillAssignments != null &amp;&amp; !skillAssignments.isEmpty()) {</span>
			// handle proficiency, should multiply 10 here - should fix with
			// laurie later
<span class="nc bnc" id="L4055" title="All 2 branches missed.">			for (SkillAssignment sa : skillAssignments) {</span>
<span class="nc" id="L4056">				sa.setProficiency(sa.getProficiency() * 10);</span>
<span class="nc" id="L4057">			}</span>
		} else {
<span class="nc" id="L4059">			return Collections.emptyList();</span>
		}
<span class="nc" id="L4061">		return skillAssignments;</span>
	}

	public void updateCalendarEventAssignments(String lockID, Collection events)
			throws BbmScheduleConflictException, MultiUserException, BbmUpdateException {
<span class="nc" id="L4066">		methodStart(&quot;updateCalendarEventAssignments&quot;, lockID, events);</span>

<span class="nc" id="L4068">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
			/* save the object before the update */
<span class="nc bnc" id="L4071" title="All 4 branches missed.">			if (events == null || events.isEmpty()) {</span>
<span class="nc" id="L4072">				return;</span>
			}

			Iterator i;
<span class="nc" id="L4076">			ArrayList ids = new ArrayList();</span>
<span class="nc bnc" id="L4077" title="All 2 branches missed.">			for (i = events.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4078">				ids.add(((Event) i.next()).getID());</span>
			}
<span class="nc" id="L4080">			Collection oldEvents = dao.getObjectsByIDs(ids);</span>
			// build id-event map
<span class="nc" id="L4082">			HashMap idEvent = new HashMap();</span>
			CalendarEventAssignment event;
<span class="nc bnc" id="L4084" title="All 2 branches missed.">			for (i = oldEvents.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4085">				event = (CalendarEventAssignment) i.next();</span>
<span class="nc" id="L4086">				idEvent.put(event.getID(), event);</span>
			}

			/*
			 * perform what is necessary before an existing event gets updated
			 */
<span class="nc" id="L4092">			m_eventHandler.preUpdateEvents(lockID, oldEvents, events);</span>

			CalendarEventAssignment oldEvent;
<span class="nc bnc" id="L4095" title="All 2 branches missed.">			for (i = events.iterator(); i.hasNext();) {</span>
				// the event object might only have updated attributes instead
				// of the whole picture. Here reset the org attendees list for
				// checking
				// schedule conflict
<span class="nc" id="L4100">				event = (CalendarEventAssignment) i.next();</span>
<span class="nc" id="L4101">				oldEvent = (CalendarEventAssignment) idEvent.get(event.getID());</span>

<span class="nc" id="L4103">				populateExistingAttendee(oldEvent, event);</span>

<span class="nc" id="L4105">				event.setOverlayPrecedence(oldEvent.getOverlayPrecedence());</span>
			}

<span class="nc" id="L4108">			dao.updateObjects(events);</span>

			/* perform what is necessary after an existing event gets updated */
<span class="nc" id="L4111">			m_eventHandler.postUpdateEvents(events, idEvent);</span>
<span class="nc" id="L4112">		} catch (BbmUpdateException | MultiUserException e) {</span>
<span class="nc" id="L4113">			handleException(e);</span>
<span class="nc" id="L4114">			throw e;</span>
<span class="nc" id="L4115">		} catch (Exception e) {</span>
<span class="nc" id="L4116">			handleException(e);</span>
<span class="nc" id="L4117">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc" id="L4119">			dao.cleanUp();</span>
<span class="nc" id="L4120">			methodFinish();</span>
<span class="nc" id="L4121">		}</span>
<span class="nc" id="L4122">	}</span>

	public Collection&lt;ID&gt; getCalendarEventAssignmentsForSelectedActivities(Collection colWorkResourceIDs, Date start, Date end,
			Collection activityIDs) throws BbmFinderException {
<span class="nc" id="L4126">		methodStart(&quot;getCalendarEventAssignmentsForSelectedActivities&quot;, colWorkResourceIDs, start, end, activityIDs);</span>

<span class="nc" id="L4128">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO();</span>
		try {
<span class="nc" id="L4130">			return dao.getCalendarEventAssignmentsForSelectedActivities(colWorkResourceIDs, start, end, activityIDs);</span>
<span class="nc" id="L4131">		} catch (Exception e) {</span>
<span class="nc" id="L4132">			handleException(e);</span>
<span class="nc" id="L4133">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4135">			dao.cleanUp();</span>
<span class="nc" id="L4136">			methodFinish();</span>
		}
	}

	private void populateExistingAttendee(CalendarEventAssignment oldEvent, CalendarEventAssignment newEvent) {
<span class="nc bnc" id="L4141" title="All 2 branches missed.">		if (oldEvent == null) {</span>
<span class="nc" id="L4142">			return;</span>
		}

<span class="nc" id="L4145">		HashMap&lt;Integer, Map&lt;Integer, CalendarEventAttendee&gt;&gt; childrenMap = oldEvent.getChildObjectMap();</span>
<span class="nc bnc" id="L4146" title="All 2 branches missed.">		if (childrenMap == null) {</span>
<span class="nc" id="L4147">			return;</span>
		}

		// if the new event already has its updated child attendees populated,
		// do not copy child attendees from the
		// old event to the new event, as that would override the already
		// updated child attendees on the new event.
<span class="nc" id="L4154">		Collection&lt;CalendarEventAttendee&gt; newEventUpdatedChildObjects = newEvent</span>
<span class="nc" id="L4155">				.getUpdatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>

<span class="nc bnc" id="L4157" title="All 4 branches missed.">		if (newEventUpdatedChildObjects != null &amp;&amp; !newEventUpdatedChildObjects.isEmpty()) {</span>
<span class="nc" id="L4158">			return;</span>
		}

<span class="nc" id="L4161">		Map&lt;Integer, CalendarEventAttendee&gt; orgAttendees = childrenMap</span>
<span class="nc" id="L4162">				.get(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>

<span class="nc bnc" id="L4164" title="All 4 branches missed.">		if (orgAttendees != null &amp;&amp; !orgAttendees.isEmpty()) {</span>
<span class="nc bnc" id="L4165" title="All 2 branches missed.">			for (CalendarEventAttendee orgAttendee : orgAttendees.values()) {</span>
<span class="nc" id="L4166">				newEvent.fillChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, orgAttendee);</span>
<span class="nc" id="L4167">			}</span>
		}
<span class="nc" id="L4169">	}</span>

	private void populateExistingAttendee(ValueObjectAggEventTemplate oldTemplate,
			ValueObjectAggEventTemplate newTemplate) {
<span class="nc bnc" id="L4173" title="All 2 branches missed.">		if (oldTemplate == null) {</span>
<span class="nc" id="L4174">			return;</span>
		}
<span class="nc" id="L4176">		HashMap childrenMap = oldTemplate.getAggregatedTemplate().getChildObjectMap();</span>
<span class="nc bnc" id="L4177" title="All 2 branches missed.">		if (childrenMap != null) {</span>
<span class="nc" id="L4178">			Object orgAttendees = childrenMap.get(NumberFactory.newInteger(CalendarEventTemplateFields.CHILD_ATTENDEE));</span>
<span class="nc bnc" id="L4179" title="All 4 branches missed.">			if (orgAttendees != null &amp;&amp; !((HashMap) orgAttendees).isEmpty()) {</span>
<span class="nc" id="L4180">				Collection objs = ((HashMap) orgAttendees).values();</span>
<span class="nc bnc" id="L4181" title="All 2 branches missed.">				for (Iterator i = objs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4182">					newTemplate.getAggregatedTemplate().fillChildObject(CalendarEventTemplateFields.CHILD_ATTENDEE,</span>
<span class="nc" id="L4183">							(ValueObjectBase) i.next());</span>
				}
			}
		}
<span class="nc" id="L4187">	}</span>

	private void checkConflictForNewObject(Jdmo dmo, CalendarEventAssignment event, ID templateEventID)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc" id="L4191">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L4192">		Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForScheduleObject(event, true, templateEventID);</span>
<span class="nc" id="L4193">		throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(dmo, listConflicts);</span>
<span class="nc" id="L4194">	}</span>

	private void checkConflictForUpdateObject(Jdmo dmo, CalendarEventAssignment event)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc" id="L4198">		CalendarEventAssignmentDAO dao = new CalendarEventAssignmentDAO(dmo);</span>
<span class="nc" id="L4199">		Collection&lt;BbmScheduleConflict&gt; listConflicts = dao.getConflictsForUpdatedScheduleObject(event);</span>
<span class="nc" id="L4200">		throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(dmo, listConflicts);</span>
<span class="nc" id="L4201">	}</span>

	private void throwConflictExceptionUnlessOneOfTheEventsIsARecurringFloatingEvent(Jdmo dmo,
			Collection&lt;BbmScheduleConflict&gt; listConflicts)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L4206" title="All 2 branches missed.">		if (!listConflicts.isEmpty()) {</span>
<span class="nc bnc" id="L4207" title="All 2 branches missed.">			for (BbmScheduleConflict conflict : listConflicts) {</span>
<span class="nc" id="L4208">				CalendarEventAssignment cea2 = conflict.getCalendarEvent2();</span>
<span class="nc" id="L4209">				CalendarEventAssignment cea1 = conflict.getCalendarEvent1();</span>
<span class="nc bnc" id="L4210" title="All 2 branches missed.">				ID eventTemplateID = cea2.getEventTemplateID() != null ? cea2.getEventTemplateID() : cea1.getEventTemplateID();</span>
<span class="nc" id="L4211">				throwConflictExceptionUnlessTemplateIsARecurringFloatingEvent(dmo, listConflicts, eventTemplateID);</span>
<span class="nc" id="L4212">			}</span>
		}
<span class="nc" id="L4214">	}</span>

	private void throwConflictExceptionUnlessTemplateIsARecurringFloatingEvent(Jdmo dmo,
			Collection&lt;BbmScheduleConflict&gt; listConflicts, ID eventTemplateID)
			throws BbmFinderException, BbmScheduleConflictException {
<span class="nc bnc" id="L4219" title="All 2 branches missed.">		if (eventTemplateID != null) {</span>
			//calendar event belongs to floating or recurring floating
<span class="nc" id="L4221">			RecurringEventTemplateDAO recEventTemplateDAO = new RecurringEventTemplateDAO(dmo);</span>
			try {
<span class="nc" id="L4223">				RecurringEventTemplateBase ret = recEventTemplateDAO.getObjectByID(eventTemplateID);</span>
<span class="nc bnc" id="L4224" title="All 2 branches missed.">				if (ret.getTemplateType() == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {</span>
<span class="nc" id="L4225">					return;</span>
				} else {
					//recurring event so throw conflict
<span class="nc" id="L4228">					throw new BbmScheduleConflictException(listConflicts);</span>
				}
<span class="nc" id="L4230">			} catch (BbmFinderException bfe) {</span>
<span class="nc" id="L4231">				FloatingEventTemplateDAO floatingEventTemplateDAO = new FloatingEventTemplateDAO(dmo);</span>
<span class="nc" id="L4232">				FloatingEventTemplate fet = floatingEventTemplateDAO.getObjectByID(eventTemplateID);</span>
<span class="nc bnc" id="L4233" title="All 2 branches missed.">				if (fet.getParentID() != null) {</span>
<span class="nc" id="L4234">					return;</span>
				} else {
<span class="nc" id="L4236">					throw new BbmScheduleConflictException(listConflicts);</span>
				}
			}
		} else {
<span class="nc" id="L4240">			throw new BbmScheduleConflictException(listConflicts);</span>
		}
	}

	/**
	 * @param wrkResIds
	 *            Collections of the work resource ids
	 * @param isPublish
	 *            indcates if the event is publish(true) or un-published (false)
	 * @throws BbmUpdateException
	 */
	public void notifyPublishComplete(Collection wrkResIds, Date startDate, Date endDate, boolean isPublish)
			throws BbmUpdateException {
<span class="fc" id="L4253">		methodStart(&quot;notifyPublishComplete&quot;, wrkResIds, startDate, endDate);</span>
		try {
<span class="fc" id="L4255">			m_eventHandler.triggerTONotification(wrkResIds, startDate, endDate, isPublish);</span>
<span class="nc" id="L4256">		} catch (Exception ex) {</span>
<span class="nc" id="L4257">			handleException(ex, true);</span>
<span class="nc" id="L4258">			throw new BbmUpdateException(ex.getMessage());</span>
		} finally {
<span class="pc" id="L4260">			methodFinish();</span>
<span class="fc" id="L4261">		}</span>
<span class="fc" id="L4262">	}</span>

	private String createTempTableToQueryEvents(Jdmo dmo, Collection workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException, Exception {
		// create temp table to hold workresource, start and end, later it will
		// join with event tables to get the events
<span class="nc" id="L4268">		StringBuffer strSQL = new StringBuffer();</span>
<span class="nc" id="L4269">		String strTableName = &quot;WORKRESOURCETIMERANGE&quot;;</span>
<span class="nc" id="L4270">		String strNativeTempName = dmo.getNativeTemptableName(strTableName);</span>

		// drop temp table just in case
		try {
<span class="nc" id="L4274">			dmo.dropTempTable(strTableName);</span>
<span class="nc" id="L4275">		} catch (Exception e) {</span>
			// do nothing
<span class="nc" id="L4277">		}</span>
<span class="nc" id="L4278">		strSQL.append(strNativeTempName);</span>
<span class="nc" id="L4279">		strSQL.append(&quot; (workresourceid int, starttime datetime, endtime datetime )&quot;);</span>
<span class="nc" id="L4280">		dmo.createTempTable(strSQL.toString());</span>

<span class="nc" id="L4282">		JdmoPCommand pc = dmo.createPCommand(&quot;insert into &quot; + strNativeTempName + &quot; values (?,?,?)&quot;);</span>
<span class="nc" id="L4283">		HashMap param = new HashMap();</span>

		// get employee terminated date if he/she has
<span class="nc" id="L4286">		HashMap terminateDate = new HashMap(workResourceIDs.size());</span>
<span class="nc" id="L4287">		JdmoRowset rs = dmo</span>
<span class="nc" id="L4288">				.createRowset(&quot;select id, endtime from employeeam where id in &quot; + dmo.createInClause(workResourceIDs));</span>
<span class="nc bnc" id="L4289" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L4290">			terminateDate.put(rs.getID(1), rs.getTimestamp(2));</span>
		}

		Date dTerminate;
		Date adjustedEnd;
<span class="nc bnc" id="L4295" title="All 2 branches missed.">		for (Iterator iter = workResourceIDs.iterator(); iter.hasNext();) {</span>
<span class="nc" id="L4296">			ID id = (ID) iter.next();</span>
<span class="nc" id="L4297">			dTerminate = (Date) terminateDate.get(id);</span>
<span class="nc" id="L4298">			adjustedEnd = dtEnd;</span>
<span class="nc bnc" id="L4299" title="All 2 branches missed.">			if (dTerminate != null) {</span>
<span class="nc bnc" id="L4300" title="All 2 branches missed.">				if (dTerminate.before(dtStart)) {</span>
<span class="nc" id="L4301">					continue; // has been terminated, no events</span>
				}
<span class="nc bnc" id="L4303" title="All 2 branches missed.">				if (dTerminate.before(dtEnd)) {</span>
<span class="nc" id="L4304">					adjustedEnd = dTerminate;</span>
				}
			}
<span class="nc" id="L4307">			param.clear();</span>
<span class="nc" id="L4308">			param.put(1, id.toInt());</span>
<span class="nc" id="L4309">			param.put(2, dtStart);</span>
<span class="nc" id="L4310">			param.put(3, adjustedEnd);</span>
<span class="nc" id="L4311">			pc.setParams(param);</span>
<span class="nc" id="L4312">			pc.addBatch();</span>
<span class="nc" id="L4313">		}</span>

<span class="nc" id="L4315">		dmo.executeBatchPCommand(pc);</span>
<span class="nc" id="L4316">		return strNativeTempName;</span>
	}

	public HashMap getEmployeeWorkHours(Collection employeeIds, Date startTime, Date endTime, boolean bPublished)
			throws BbmFinderException {
<span class="nc" id="L4321">		methodStart(&quot;getEmployeeWorkHours&quot;, employeeIds, startTime, endTime, bPublished);</span>
<span class="nc" id="L4322">		HashMap mapEmpWorkHours = new HashMap(employeeIds.size());</span>
<span class="nc" id="L4323">		Date periodStart = startTime;</span>
<span class="nc" id="L4324">		m_cat.info(&quot;== START getEmployeeWorkHours= &quot;);</span>
<span class="nc" id="L4325">		m_cat.info(&quot;== startTime= &quot; + startTime);</span>
<span class="nc" id="L4326">		m_cat.info(&quot;== endTime= &quot; + endTime);</span>
<span class="nc bnc" id="L4327" title="All 2 branches missed.">		Date periodEnd = endTime != null ? TimeZoneUtil.addDay(endTime) : null; // retrieve</span>
																				// one
																				// day
																				// extra
																				// suggested
																				// by
																				// Laurie

<span class="nc" id="L4335">		Jdmo dmo = new Jdmo();</span>
		try {
			// retrieve employee org assignment timezone history and org day
			// boundary
<span class="nc" id="L4339">			Map orgAssignmentHistory = m_workResourceManager.getWRAssignmentsWithTimeZone(employeeIds);</span>
<span class="nc" id="L4340">			HashMap mapIDOrg = new HashMap(); // cache orgs to save some calls</span>
												// to workresource manager

<span class="nc" id="L4343">			StringBuilder sb = new StringBuilder(1000);</span>
<span class="nc" id="L4344">			String nullFunc = dmo.getNullFunctionName();</span>
<span class="nc bnc" id="L4345" title="All 2 branches missed.">			if (!bPublished) {</span>
<span class="nc" id="L4346">				sb.append(</span>
						&quot; select sa.workresourceid, sa.starttime, sa.duration-isnull(sa.EXTENSIONBEFORE,0)-isnull(sa.EXTENSIONAFTER,0)-&quot;)
<span class="nc" id="L4348">						.append(dmo.getNullFunctionName()).append(&quot;(notpaid.totalnotpaid,0) as realduration &quot;);</span>
<span class="nc" id="L4349">				sb.append(&quot; from &quot;);</span>
<span class="nc" id="L4350">				sb.append(</span>
						&quot; (select shiftassignment.id as id, shiftassignment.workresourceid, shiftassignment.starttime, shiftassignment.duration, &quot;)
<span class="nc" id="L4352">						.append(nullFunc).append(&quot;(shiftassignment.extensionbefore,0) as extensionbefore, &quot;)</span>
<span class="nc" id="L4353">						.append(nullFunc)</span>
<span class="nc" id="L4354">						.append(&quot;(shiftassignment.extensionafter,0) as extensionafter from shiftassignment where &quot;);</span>
<span class="nc" id="L4355">				sb.append(&quot; shiftassignment.workresourceid in &quot;).append(dmo.createInClause(employeeIds));</span>
<span class="nc" id="L4356">				sb.append(&quot; and shiftassignment.endtime &gt; '&quot;).append(JdmoUtil.formatDBString(periodStart)).append(&quot;' &quot;);</span>
<span class="nc bnc" id="L4357" title="All 2 branches missed.">				if (endTime != null) {</span>
<span class="nc" id="L4358">					sb.append(&quot; and shiftassignment.starttime &lt; '&quot;).append(JdmoUtil.formatDBString(periodEnd))</span>
<span class="nc" id="L4359">							.append(&quot;' &quot;);</span>
				}
<span class="nc" id="L4361">				sb.append(&quot; ) sa &quot;);</span>
<span class="nc" id="L4362">				sb.append(&quot; left join &quot;);</span>
<span class="nc" id="L4363">				sb.append(</span>
						&quot; (select shift.id as shiftassignmentid, sum(event.DURATION) as totalnotpaid from SHIFTEVENTASSIGNMENT event, SHIFTASSIGNMENT shift where shift.ID = event.SHIFTASSIGNMENTID and event.ISPAID = 0 and event.overtimegaptype=0 and ((&quot;)
<span class="nc" id="L4365">						.append(nullFunc).append(&quot;(shift.extensionbefore,0)=0 and &quot;).append(nullFunc)</span>
<span class="nc" id="L4366">						.append(&quot;(shift.extensionafter,0)=0) or (event.starttime &gt;= dateadd(minute, &quot;).append(nullFunc)</span>
<span class="nc" id="L4367">						.append(&quot;(shift.extensionbefore,0), shift.starttime) and dateadd(minute, event.duration , event.starttime) &lt;= dateadd(minute, -&quot;)</span>
<span class="nc" id="L4368">						.append(nullFunc).append(&quot;(extensionafter,0), shift.endtime))) group by shift.ID) notpaid &quot;);</span>
<span class="nc" id="L4369">				sb.append(&quot; on sa.id = notpaid.shiftassignmentid&quot;);</span>
<span class="nc" id="L4370">				sb.append(&quot; order by sa.workresourceid, sa.starttime&quot;);</span>
			} else {
<span class="nc" id="L4372">				sb.append(</span>
						&quot; select sa.workresourceid, sa.starttime, sa.duration-isnull(sa.EXTENSIONBEFORE,0)-isnull(sa.EXTENSIONAFTER,0)-&quot;)
<span class="nc" id="L4374">						.append(dmo.getNullFunctionName()).append(&quot;(notpaid.totalnotpaid,0) as realduration &quot;);</span>
<span class="nc" id="L4375">				sb.append(&quot; from &quot;);</span>
<span class="nc" id="L4376">				sb.append(</span>
						&quot; (select shiftassignmentpub.id as id, shiftassignmentpub.workresourceid, shiftassignmentpub.starttime, shiftassignmentpub.duration, &quot;)
<span class="nc" id="L4378">						.append(nullFunc).append(&quot;(shiftassignmentpub.extensionbefore,0) as extensionbefore, &quot;)</span>
<span class="nc" id="L4379">						.append(nullFunc)</span>
<span class="nc" id="L4380">						.append(&quot;(shiftassignmentpub.extensionafter,0) as extensionafter from shiftassignmentpub where &quot;);</span>
<span class="nc" id="L4381">				sb.append(&quot; shiftassignmentpub.workresourceid in &quot;).append(dmo.createInClause(employeeIds));</span>
<span class="nc" id="L4382">				sb.append(&quot; and shiftassignmentpub.endtime &gt; '&quot;).append(JdmoUtil.formatDBString(periodStart))</span>
<span class="nc" id="L4383">						.append(&quot;' &quot;);</span>
<span class="nc bnc" id="L4384" title="All 2 branches missed.">				if (endTime != null) {</span>
<span class="nc" id="L4385">					sb.append(&quot; and shiftassignmentpub.starttime &lt; '&quot;).append(JdmoUtil.formatDBString(periodEnd))</span>
<span class="nc" id="L4386">							.append(&quot;' &quot;);</span>
				}
<span class="nc" id="L4388">				sb.append(&quot; ) sa &quot;);</span>
<span class="nc" id="L4389">				sb.append(&quot; left join &quot;);</span>
<span class="nc" id="L4390">				sb.append(</span>
						&quot; (select shift.id as shiftassignmentid, sum(event.DURATION) as totalnotpaid from SHIFTEVENTASSIGNMENTPUB event, SHIFTASSIGNMENTPUB shift where shift.ID = event.SHIFTASSIGNMENTID and event.ISPAID = 0 and event.overtimegaptype=0 and ((&quot;)
<span class="nc" id="L4392">						.append(nullFunc).append(&quot;(shift.extensionbefore,0)=0 and &quot;).append(nullFunc)</span>
<span class="nc" id="L4393">						.append(&quot;(shift.extensionafter,0)=0) or (event.starttime &gt;= dateadd(minute, &quot;).append(nullFunc)</span>
<span class="nc" id="L4394">						.append(&quot;(extensionbefore,0), shift.starttime) and dateadd(minute, event.duration , event.starttime) &lt;= dateadd(minute, -&quot;)</span>
<span class="nc" id="L4395">						.append(nullFunc).append(&quot;(extensionafter,0), shift.endtime))) group by shift.ID) notpaid &quot;);</span>
<span class="nc" id="L4396">				sb.append(&quot; on sa.id = notpaid.shiftassignmentid&quot;);</span>
<span class="nc" id="L4397">				sb.append(&quot; order by sa.workresourceid, sa.starttime&quot;);</span>
			}

<span class="nc" id="L4400">			JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc" id="L4401">			ID previousWKRSID = null;</span>
<span class="nc" id="L4402">			ID wkrsID = null;</span>
<span class="nc" id="L4403">			Date startOrgDayStartInGMT = null;</span>
			Date currentShiftDayStart;
			Date shiftStart;
			int workHourPerDay;
<span class="nc" id="L4407">			ArrayList workHourPerDayList = null;</span>
<span class="nc" id="L4408">			Date endOrgDayStartInGMT = null;</span>
<span class="nc bnc" id="L4409" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4410">				wkrsID = rs.getID(1);</span>
<span class="nc" id="L4411">				shiftStart = rs.getTimestamp(2);</span>
<span class="nc" id="L4412">				workHourPerDay = rs.getInt(3);</span>
				// prepare new employee data reading
<span class="nc bnc" id="L4414" title="All 4 branches missed.">				if (previousWKRSID == null || !previousWKRSID.equals(wkrsID)) { // start</span>
																				// new
																				// employee
																				// reading
<span class="nc" id="L4418">					endOrgDayStartInGMT = getDateForOrgDayStart(endTime, (Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg);</span>
<span class="nc bnc" id="L4419" title="All 2 branches missed.">					if (previousWKRSID != null) {</span>
						// the beginning of next employee data reading, also the
						// end of previous employee reading
<span class="nc bnc" id="L4422" title="All 2 branches missed.">						while (!startOrgDayStartInGMT.after(endOrgDayStartInGMT)) {</span>
<span class="nc" id="L4423">							m_cat.info(&quot;==startOrgDayStartInGMT at the beginning=&quot; +startOrgDayStartInGMT);</span>
<span class="nc" id="L4424">							workHourPerDayList.add(0);</span>
<span class="nc" id="L4425">							startOrgDayStartInGMT = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg, startOrgDayStartInGMT);</span>
						}
					}

<span class="nc" id="L4429">					startOrgDayStartInGMT = getDateForOrgDayStart(startTime, (Collection)orgAssignmentHistory.get(wkrsID), mapIDOrg);</span>
<span class="nc" id="L4430">					m_cat.info(&quot;==startOrgDayStartInGMT when starting loop&quot; +startOrgDayStartInGMT);</span>
<span class="nc" id="L4431">					workHourPerDayList = (ArrayList) (mapEmpWorkHours.get(wkrsID));</span>
<span class="nc bnc" id="L4432" title="All 2 branches missed.">					if (workHourPerDayList == null) {</span>
<span class="nc" id="L4433">						workHourPerDayList = new ArrayList();</span>
<span class="nc" id="L4434">						mapEmpWorkHours.put(wkrsID, workHourPerDayList);</span>
					}
				}

<span class="nc" id="L4438">				currentShiftDayStart = getDateForOrgDayStart(shiftStart, (Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg);</span>
				// handle the days before the current shift
<span class="nc bnc" id="L4440" title="All 2 branches missed.">				while (startOrgDayStartInGMT.before(currentShiftDayStart)</span>
<span class="nc bnc" id="L4441" title="All 2 branches missed.">						&amp;&amp; TimeZoneUtil.numberOfMinutes(startOrgDayStartInGMT, currentShiftDayStart) &gt; 60) { // for</span>
																									// DST
																									// date,
																									// one
																									// hour
																									// diff
																									// should
																									// not
																									// be
																									// considered
																									// diff
																									// day.
																									// fix
																									// QC52470
<span class="nc" id="L4455">					m_cat.info(&quot;==startOrgDayStartInGMT in the loop to handle the days before current shift (add 0)=&quot; +startOrgDayStartInGMT);</span>
<span class="nc" id="L4456">					workHourPerDayList.add(0);</span>
<span class="nc" id="L4457">					startOrgDayStartInGMT = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg, startOrgDayStartInGMT);</span>

				}
<span class="nc" id="L4460">				startOrgDayStartInGMT = currentShiftDayStart; // just in case DST or time</span>
													// zone changed.
<span class="nc" id="L4462">				workHourPerDayList.add(workHourPerDay); // handle</span>
																		// the
																		// current
																		// shift
				// //move to next day
<span class="nc" id="L4467">				m_cat.info(&quot;==startOrgDayStartInGMT for workHoursPerDay=&quot; +startOrgDayStartInGMT);</span>
<span class="nc" id="L4468">				startOrgDayStartInGMT = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg, startOrgDayStartInGMT);</span>
<span class="nc" id="L4469">				previousWKRSID = wkrsID;</span>
			}
			// for last employee, may need to append 0s
<span class="nc bnc" id="L4472" title="All 2 branches missed.">			if (previousWKRSID != null) {</span>
				// the beginning of next employee data reading, also the end of previous employee reading
<span class="nc bnc" id="L4474" title="All 2 branches missed.">				while (!startOrgDayStartInGMT.after(endOrgDayStartInGMT)) {</span>
<span class="nc" id="L4475">					m_cat.info(&quot;==for last employee, startOrgDayStartInGMT after addOneOrgDay in the loop=&quot; +startOrgDayStartInGMT);</span>
<span class="nc" id="L4476">					workHourPerDayList.add(0);</span>
<span class="nc" id="L4477">					startOrgDayStartInGMT = addOneOrgDay((Collection) orgAssignmentHistory.get(wkrsID), mapIDOrg, startOrgDayStartInGMT);</span>
				}
			}
<span class="nc" id="L4480">			return mapEmpWorkHours;</span>
<span class="nc" id="L4481">		} catch (Exception e) {</span>
<span class="nc" id="L4482">			handleException(e);</span>
<span class="nc" id="L4483">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc bnc" id="L4485" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L4486">				dmo.cleanUp();</span>
			}
<span class="nc" id="L4488">			methodFinish();</span>
		}
	}

	private Date addOneOrgDay(Collection orgAssignmentHistory, Map mapIDOrg, Date timeSpot) {
<span class="nc" id="L4493">		WorkResourceAssignment assignment = WorkResourceAssignment.getRelatedWRAssignment(orgAssignmentHistory,</span>
<span class="nc" id="L4494">				TimeZoneUtil.addDay(timeSpot)); // add one day to the spot to</span>
																																						// get org to avoid day boundary
																																						// problem
<span class="nc bnc" id="L4497" title="All 2 branches missed.">		if (assignment == null) {</span>
			// employee has not started or been terminated at the timespot,
			// return the first one
<span class="nc" id="L4500">			assignment = (WorkResourceAssignment) orgAssignmentHistory.iterator().next();</span>
		}
<span class="nc" id="L4502">		ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4503">		Organization org = (Organization) mapIDOrg.get(orgID);</span>

		try {
<span class="nc bnc" id="L4506" title="All 2 branches missed.">			if (org == null) {</span>
<span class="nc" id="L4507">				org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L4508">				mapIDOrg.put(orgID, org);</span>
			}
<span class="nc" id="L4510">		} catch (Exception e) {</span>
<span class="nc" id="L4511">		}</span>

<span class="nc" id="L4513">		TimeZone orgTimeZone = org.getTimeZone();</span>
<span class="nc" id="L4514">		Calendar calendar = Calendar.getInstance(orgTimeZone);</span>
<span class="nc" id="L4515">		calendar.setTime(timeSpot);</span>
<span class="nc" id="L4516">		calendar.add(Calendar.DATE, 1);</span>

<span class="nc" id="L4518">		return calendar.getTime();</span>
	}

	private Date getDateForOrgDayStart(Date timeSpotInGMT, Collection orgAssignmentHistory, HashMap mapIDOrg)
			throws Exception {
<span class="nc" id="L4523">		WorkResourceAssignment assignment = WorkResourceAssignment.getRelatedWRAssignment(orgAssignmentHistory,</span>
<span class="nc" id="L4524">				TimeZoneUtil.addDay(timeSpotInGMT)); // add one day to the spot</span>
																																								// to get org to avoid
																																								// day boundary problem
<span class="nc bnc" id="L4527" title="All 2 branches missed.">		if (assignment == null) {</span>
			// employee has not started or been terminated at the timespot,
			// return the first one
<span class="nc" id="L4530">			assignment = (WorkResourceAssignment) orgAssignmentHistory.iterator().next();</span>
		}
<span class="nc" id="L4532">		ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4533">		Organization org = (Organization) mapIDOrg.get(orgID);</span>
<span class="nc bnc" id="L4534" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L4535">			org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L4536">			mapIDOrg.put(orgID, org);</span>
		}
<span class="nc" id="L4538">		return TOCalcUtil.getDateForOrgDayStart(org, timeSpotInGMT);</span>
	}
	private Date getOrgDayStartInGMT(Date timeSpotInGMT, Collection orgAssignmentHistory, HashMap mapIDOrg)
			throws Exception {
<span class="nc" id="L4542">		WorkResourceAssignment assignment = WorkResourceAssignment.getRelatedWRAssignment(orgAssignmentHistory,</span>
<span class="nc" id="L4543">				TimeZoneUtil.addDay(timeSpotInGMT)); // add one day to the spot</span>
																																								// to get org to avoid
																																								// day boundary problem
<span class="nc bnc" id="L4546" title="All 2 branches missed.">		if (assignment == null) {</span>
			// employee has not started or been terminated at the timespot,
			// return the first one
<span class="nc" id="L4549">			assignment = (WorkResourceAssignment) orgAssignmentHistory.iterator().next();</span>
		}
<span class="nc" id="L4551">		ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4552">		Organization org = (Organization) mapIDOrg.get(orgID);</span>
<span class="nc bnc" id="L4553" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L4554">			org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L4555">			mapIDOrg.put(orgID, org);</span>
		}
<span class="nc" id="L4557">		int dayBoundaryInMinute = org.getDayBoundaryOffset();</span>
<span class="nc" id="L4558">		Calendar gmt = Calendar.getInstance(org.getTimeZone());</span>
<span class="nc" id="L4559">		gmt.setTime(timeSpotInGMT);</span>

<span class="nc" id="L4561">		Calendar orgCalendar = Calendar.getInstance(assignment.getStartTimeZone());</span>
<span class="nc" id="L4562">		orgCalendar.set(Calendar.YEAR, gmt.get(Calendar.YEAR));</span>
<span class="nc" id="L4563">		orgCalendar.set(Calendar.MONTH, gmt.get(Calendar.MONTH));</span>
<span class="nc" id="L4564">		orgCalendar.set(Calendar.DAY_OF_MONTH, gmt.get(Calendar.DAY_OF_MONTH));</span>
<span class="nc" id="L4565">		orgCalendar.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="nc" id="L4566">		orgCalendar.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L4567">		orgCalendar.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L4568">		orgCalendar.add(Calendar.MINUTE, dayBoundaryInMinute);</span>
<span class="nc" id="L4569">		return orgCalendar.getTime();</span>
	}

	public void setSPIDLockCustomizedShifts(ID spID, Collection idShiftsToSetSPID, Collection idShiftsToLock)
			throws BbmUpdateException {
<span class="nc" id="L4574">		methodStart(&quot;setCampaignIDLockCustomizedShifts&quot;, spID, idShiftsToSetSPID, idShiftsToLock);</span>

<span class="nc" id="L4576">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc bnc" id="L4578" title="All 4 branches missed.">			if (idShiftsToSetSPID != null &amp;&amp; !idShiftsToSetSPID.isEmpty()) {</span>
<span class="nc" id="L4579">				StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L4580">				sb.append(&quot;update shiftassignment set spid = &quot;).append(spID).append(&quot; where id in &quot;)</span>
<span class="nc" id="L4581">						.append(dmo.createInClause(idShiftsToSetSPID));</span>
<span class="nc" id="L4582">				dmo.execute(sb.toString());</span>
			}
<span class="nc bnc" id="L4584" title="All 4 branches missed.">			if (idShiftsToLock != null &amp;&amp; !idShiftsToLock.isEmpty()) {</span>
<span class="nc" id="L4585">				StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L4586">				sb.append(&quot;update shiftassignment set islocked = 1 where id in &quot;)</span>
<span class="nc" id="L4587">						.append(dmo.createInClause(idShiftsToLock));</span>
				// sb.append(&quot;;&quot;);
				// sb.append(&quot;update shifteventassignment set islocked = 1 where
				// shiftassignmentid
				// in&quot;).append(dmo.createInClause(idShiftsToLock));
<span class="nc" id="L4592">				dmo.execute(sb.toString());</span>
			}
<span class="nc" id="L4594">		} catch (Exception e) {</span>
<span class="nc" id="L4595">			handleException(e);</span>
<span class="nc" id="L4596">			throw new BbmUpdateException(e);</span>
		} finally {
<span class="nc bnc" id="L4598" title="All 4 branches missed.">			if (dmo != null) {</span>
<span class="nc" id="L4599">				dmo.cleanUp();</span>
			}
<span class="nc" id="L4601">			methodFinish();</span>
<span class="nc" id="L4602">		}</span>
<span class="nc" id="L4603">	}</span>

	/**
	 * Create a complete overtime shift, which is implemented as a shift
	 * assignment with a main shift of zero length, and only an OT Extension
	 * after the shift.
	 *
	 * @param workResourceID
	 * @param startTime
	 * @param oteID
	 * @throws BbmCreateException
	 */
	public void createOTShiftAssignment(ID workResourceID, Date startTime, ID oteID) throws BbmCreateException {
<span class="nc" id="L4616">		methodStart(&quot;createOTShiftAssignment&quot;, startTime, oteID);</span>
		try {
<span class="nc" id="L4618">			ArrayList&lt;ID&gt; list = new ArrayList&lt;&gt;(1);</span>
<span class="nc" id="L4619">			list.add(oteID);</span>
<span class="nc" id="L4620">			ShiftOTExtension ote = m_workRuleManager.getShiftOTExtensionsByIDs(list).iterator().next();</span>
<span class="nc" id="L4621">			ShiftAssignment sa = new ShiftAssignment();</span>
<span class="nc" id="L4622">			sa.addWorkResourceID(workResourceID);</span>
<span class="nc" id="L4623">			sa.setStartTime(startTime);</span>
<span class="nc" id="L4624">			sa.setDuration(0);</span>
<span class="nc" id="L4625">			sa.setActivityID(ote.getActivityID());</span>

<span class="nc" id="L4627">			ScheduleUtil.addOTE(sa, ote, false, true, true);</span>
<span class="nc" id="L4628">			createShiftAssignment(sa);</span>
<span class="nc" id="L4629">		} catch (Exception e) {</span>
<span class="nc" id="L4630">			handleException(e);</span>
<span class="nc" id="L4631">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L4633">			methodFinish();</span>
<span class="nc" id="L4634">		}</span>
<span class="nc" id="L4635">	}</span>

	// ====== new APIs for creating phantom on web calendar ============
	public HashMap getPhantomsOrganizations(Collection phantomIDs) throws BbmFinderException {
<span class="nc" id="L4639">		methodStart(&quot;getPhantomsOrganizations&quot;, phantomIDs);</span>
<span class="nc" id="L4640">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="nc" id="L4642">			return dao.getPhantomsOrganizations(new HashSet(phantomIDs));</span>
<span class="nc" id="L4643">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4644">			handleException(e);</span>
<span class="nc" id="L4645">			throw e;</span>
<span class="nc" id="L4646">		} catch (Exception e) {</span>
<span class="nc" id="L4647">			handleException(e);</span>
<span class="nc" id="L4648">			throw new BbmFinderException(e);</span>
		} finally {
<span class="nc" id="L4650">			dao.cleanUp();</span>
<span class="nc" id="L4651">			methodFinish();</span>
		}
	}

	/**
	 * get phantom names given their IDs
	 *
	 * @return hashmap of (idPhantom, phantomName)
	 */
	public HashMap getPhantomEmployeeNamesByIDs(Collection colIDs) throws BbmFinderException {
<span class="nc" id="L4661">		methodStart(&quot;getPhantomEmployeeNamesByIDs&quot;, colIDs);</span>
<span class="nc" id="L4662">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="nc" id="L4664">			return dao.getPhantomEmployeeNamesByIDs(colIDs);</span>
<span class="nc" id="L4665">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4666">			handleException(e, false);</span>
<span class="nc" id="L4667">			throw e;</span>
		} finally {
<span class="nc" id="L4669">			dao.cleanUp();</span>
<span class="nc" id="L4670">			methodFinish();</span>
		}
	}

	public ID createPhantom(ID empID, ID spID, Date start, Date end) throws BbmCreateException {
<span class="nc" id="L4675">		return (ID) createPhantoms(Collections.singletonList(empID), spID, start, end).iterator().next();</span>
	}

	// start and end are in GMT
	public Collection createPhantoms(Collection empIDs, ID spID, Date start, Date end) throws BbmCreateException {
<span class="nc" id="L4680">		methodStart(&quot;createPhantoms&quot;, empIDs, start, end);</span>
<span class="nc" id="L4681">		ArrayList ids = new ArrayList(empIDs.size());</span>
<span class="nc" id="L4682">		PhantomDAO dao = new PhantomDAO();</span>
<span class="nc" id="L4683">		ArrayList phantoms = new ArrayList(empIDs.size());</span>
<span class="nc" id="L4684">		HashMap empPhantomIDMap = new HashMap(empIDs.size());</span>
<span class="nc" id="L4685">		HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; empIDShiftAssignmentMap = new HashMap&lt;&gt;(</span>
<span class="nc" id="L4686">				empIDs.size());</span>
<span class="nc" id="L4687">		HashMap nextPhantomNameMap = new HashMap(empIDs.size());</span>
<span class="nc" id="L4688">		HashMap&lt;ID, Employee&gt; employeeNameByID = new HashMap&lt;&gt;(empIDs.size());</span>
		try {
<span class="nc" id="L4690">			int eventTypeMask = Event.EVENT_TYPE_SHIFT_ASSIGNMENT;</span>
<span class="nc" id="L4691">			Collection empShiftAssignments = getEventsForWorkResourcesByType(eventTypeMask, empIDs, start, end);</span>
<span class="nc" id="L4692">			Collection employees = m_workResourceManager.getEmployeesByIDs(empIDs, start,</span>
					Employee.DETAIL_LEVEL_EMPLOYEE_TIMEBASEDPROPERTY);

			ID workResourceID;
			Collection empShifts;

<span class="nc" id="L4698">			Iterator iEmpID = empIDs.iterator();</span>
<span class="nc" id="L4699">			Iterator iEmpShift = empShiftAssignments.iterator();</span>
<span class="nc bnc" id="L4700" title="All 2 branches missed.">			for (; iEmpID.hasNext();) {</span>
<span class="nc" id="L4701">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4702">				empShifts = (Collection) iEmpShift.next();</span>
<span class="nc" id="L4703">				empIDShiftAssignmentMap.put(workResourceID, empShifts);</span>
<span class="nc bnc" id="L4704" title="All 4 branches missed.">				if (empShifts == null || empShifts.isEmpty()) {</span>
					// if employee doesn't have a schedule, skip it.
<span class="nc" id="L4706">					iEmpID.remove();</span>
<span class="nc" id="L4707">					continue;</span>
				}
			}

<span class="nc" id="L4711">			Iterator iEmployees = employees.iterator();</span>
<span class="nc bnc" id="L4712" title="All 2 branches missed.">			for (; iEmployees.hasNext();) {</span>
<span class="nc" id="L4713">				Employee emp = (Employee) iEmployees.next();</span>
<span class="nc" id="L4714">				employeeNameByID.put(emp.getID(), emp);</span>

<span class="nc" id="L4716">			}</span>

<span class="nc" id="L4718">			HashMap complexWorkRules = m_empWorkRuleManager.getComplexWorkRuleAssignments(empIDs);</span>
<span class="nc" id="L4719">			HashMap rotationWorkRules = m_empWorkRuleManager.getRotationAssignments(empIDs);</span>

			// QC120615: taking out database calls from for-loop to improve
			// performance

<span class="nc" id="L4724">			TimeZone gmtTZ = TimeZone.getTimeZone(&quot;GMT&quot;);</span>
<span class="nc" id="L4725">			HashMap&lt;ID, Collection&lt;WorkResourceAssignment&gt;&gt; orgAssignmentsForEmployees = getWorkResourceManager()</span>
<span class="nc" id="L4726">					.getValidWorkResourceAssignments(empIDs, new LocalDate(start, TimeZone.getTimeZone(&quot;GMT&quot;)),</span>
<span class="nc" id="L4727">							new LocalDate(end, TimeZone.getTimeZone(&quot;GMT&quot;)));</span>

<span class="nc" id="L4729">			Map&lt;ID, Collection&lt;SkillAssignment&gt;&gt; employeesSkillAssignments = m_skillManager</span>
<span class="nc" id="L4730">					.getSkillAssignmentInPeriodAndOnSpotOnly(empIDs, start, end, start);</span>
<span class="nc" id="L4731">			HashMap&lt;ID, Collection&lt;WorkResourceWorkPattern&gt;&gt; employeesWorkPatterns = m_empWorkRuleManager</span>
<span class="nc" id="L4732">					.getWorkPatternAssignments(empIDs, start, end);</span>
<span class="nc" id="L4733">			HashMap&lt;ID, Collection&lt;ShiftPattern&gt;&gt; shiftPatternByWorkUnitID = new HashMap&lt;&gt;();</span>

<span class="nc" id="L4735">			HashMap&lt;ID, Collection&lt;Skill&gt;&gt; employeesSkills = m_skillManager.getSkillsForWorkResources(empIDs, start,</span>
					end);

<span class="nc" id="L4738">			HashMap&lt;ID, String&gt; derivedNameByID = derivePhantomNamesForEmployees(empIDShiftAssignmentMap, spID, start,</span>
					end, employeesSkills, employeeNameByID);

<span class="nc" id="L4741">			iEmpID = empIDs.iterator();</span>

<span class="nc bnc" id="L4743" title="All 2 branches missed.">			for (; iEmpID.hasNext();) {</span>
<span class="nc" id="L4744">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4745">				Employee emp = employeeNameByID.get(workResourceID);</span>

<span class="nc" id="L4747">				Collection&lt;WorkResourceAssignment&gt; orgAssignments = orgAssignmentsForEmployees.get(workResourceID);</span>
<span class="nc" id="L4748">				WorkResourceAssignment assignment = orgAssignments.iterator().next();</span>

<span class="nc" id="L4750">				ID orgID = assignment.getOrganizationID();</span>
<span class="nc" id="L4751">				int proficiency = emp.getProficiency();</span>

<span class="nc" id="L4753">				Collection skills = employeesSkills.get(workResourceID);</span>
<span class="nc" id="L4754">				Collection skillDEIDs = new ArrayList();</span>
<span class="nc bnc" id="L4755" title="All 2 branches missed.">				if (skills != null) {</span>
<span class="nc bnc" id="L4756" title="All 2 branches missed.">					for (Iterator iSkill = skills.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L4757">						skillDEIDs.add(new ID(((Skill) iSkill.next()).getIDStr()));</span>
					}
				}

				// get the Employees Work Patterns to be used for finding
				// employeeTemplate
<span class="nc" id="L4763">				ArrayList shiftPatternIDs = new ArrayList();</span>
<span class="nc" id="L4764">				Collection empRotationWorkRules = (Collection) rotationWorkRules.get(workResourceID);</span>
				WorkResourceRotation empRotationWorkRule;
<span class="nc" id="L4766">				ID complexWorkRuleID = null;</span>
				Rotation rotationWorkRule;

<span class="nc bnc" id="L4769" title="All 4 branches missed.">				if (empRotationWorkRules != null &amp;&amp; !empRotationWorkRules.isEmpty()) {</span>
					/*
					 * 3/1/10 angela: san diego team has to make
					 * WorkResourceComplexWorkRule object return SID of complext
					 * work rule then we can work on this code.
					 */
					ID curShiftPatternID;
<span class="nc bnc" id="L4776" title="All 2 branches missed.">					for (Iterator iComplextWorkRules = empRotationWorkRules.iterator(); iComplextWorkRules.hasNext();) {</span>
<span class="nc" id="L4777">						empRotationWorkRule = (WorkResourceRotation) iComplextWorkRules.next();</span>
<span class="nc" id="L4778">						rotationWorkRule = empRotationWorkRule.getRotation();</span>

<span class="nc" id="L4780">						Collection shiftPatterns = rotationWorkRule.getShiftPatterns();</span>
<span class="nc bnc" id="L4781" title="All 4 branches missed.">						if (shiftPatterns != null &amp;&amp; !shiftPatterns.isEmpty()) {</span>
<span class="nc" id="L4782">							curShiftPatternID = getRotationCurrentShiftPatternID(workResourceID, orgID,</span>
									empRotationWorkRule, rotationWorkRule, shiftPatterns, start);
<span class="nc bnc" id="L4784" title="All 2 branches missed.">							if (curShiftPatternID != null) {</span>
<span class="nc" id="L4785">								shiftPatternIDs.add(curShiftPatternID);</span>
							}
						}
<span class="nc" id="L4788">					}</span>
				} else {
					// no rotation rule, use employee shift pattern
<span class="nc" id="L4791">					Collection&lt;WorkResourceWorkPattern&gt; shiftPatternAssignments = employeesWorkPatterns</span>
<span class="nc" id="L4792">							.get(workResourceID);</span>
<span class="nc bnc" id="L4793" title="All 4 branches missed.">					if (shiftPatternAssignments != null &amp;&amp; !shiftPatternAssignments.isEmpty()) {</span>
<span class="nc" id="L4794">						for (Iterator&lt;WorkResourceWorkPattern&gt; iShiftPatterns = shiftPatternAssignments</span>
<span class="nc bnc" id="L4795" title="All 2 branches missed.">								.iterator(); iShiftPatterns.hasNext();) {</span>
<span class="nc" id="L4796">							shiftPatternIDs.add((iShiftPatterns.next()).getWorkPatternSID());</span>
						}
					}
				}

<span class="nc" id="L4801">				Collection empSkillAssignments = employeesSkillAssignments.get(workResourceID);</span>
<span class="nc" id="L4802">				String phantomLastName = derivedNameByID.get(workResourceID);</span>
				// looking for existing matching emp template based on skill and
				// shift pattern
<span class="nc" id="L4805">				EmployeeTemplate empTemplate = FindHiddenEmpTemplateWithAttributes(dao.getDMO(), orgID, phantomLastName,</span>
<span class="nc" id="L4806">						emp.getWage(), skillDEIDs, shiftPatternIDs, proficiency);</span>
<span class="nc bnc" id="L4807" title="All 2 branches missed.">				if (empTemplate == null) {</span>
					// create a new template
<span class="nc" id="L4809">					empTemplate = new EmployeeTemplate();</span>
<span class="nc" id="L4810">					empTemplate.setOrganizationID(orgID);</span>
<span class="nc" id="L4811">					empTemplate.setName(phantomLastName);</span>
<span class="nc" id="L4812">					empTemplate.setWage(emp.getWage());</span>
<span class="nc" id="L4813">					empTemplate.setChatSessions(1); // todo, should get chat</span>
													// sessions from
													// workresourcemedia table
													// later.
<span class="nc" id="L4817">					empTemplate.setIsHidden(true);</span>
<span class="nc" id="L4818">					empTemplate.setProficiency(proficiency / 10.0);</span>
<span class="nc bnc" id="L4819" title="All 4 branches missed.">					if (empSkillAssignments != null &amp;&amp; !empSkillAssignments.isEmpty()) {</span>
<span class="nc" id="L4820">						empTemplate.setSkillAssignments(empSkillAssignments);</span>
					}
<span class="nc bnc" id="L4822" title="All 4 branches missed.">					if (shiftPatternIDs != null &amp;&amp; !shiftPatternIDs.isEmpty()) {</span>
<span class="nc" id="L4823">						empTemplate.setShiftPatterns(shiftPatternIDs);</span>
					}
<span class="nc" id="L4825">					ID empTemplateSID = this.createEmployeeTemplate(empTemplate);</span>
<span class="nc" id="L4826">					empTemplate.setID(empTemplateSID);</span>
				}
				// have template now and create phantom
<span class="nc" id="L4829">				Phantom phantom = new Phantom();</span>
<span class="nc" id="L4830">				phantom.setEmployeeTemplateID(empTemplate.getID());</span>
<span class="nc" id="L4831">				phantom.setName(getPhantomFirstName(dao.getDMO(), empTemplate.getID(), nextPhantomNameMap));</span>
<span class="nc" id="L4832">				phantoms.add(phantom);</span>
<span class="nc" id="L4833">			} // end of for loop</span>

<span class="nc" id="L4835">			Collection phantomIDs = dao.createPhantoms(phantoms);</span>
<span class="nc" id="L4836">			iEmpID = empIDs.iterator();</span>
<span class="nc" id="L4837">			Iterator iPhantomID = phantomIDs.iterator();</span>
<span class="nc" id="L4838">			ArrayList phantomShifts = new ArrayList();</span>
<span class="nc" id="L4839">			ArrayList phantomComplexWorkRules = new ArrayList();</span>
			ID phantomID;
<span class="nc bnc" id="L4841" title="All 2 branches missed.">			while (iEmpID.hasNext()) {</span>
<span class="nc" id="L4842">				workResourceID = (ID) iEmpID.next();</span>
<span class="nc" id="L4843">				phantomID = (ID) iPhantomID.next();</span>
<span class="nc" id="L4844">				empShifts = empIDShiftAssignmentMap.get(workResourceID);</span>
<span class="nc" id="L4845">				phantomShifts.addAll(reassignShiftAssignmentToPhantom(spID, workResourceID, phantomID, empShifts));</span>
<span class="nc" id="L4846">				phantomComplexWorkRules.addAll(reassignComplexWorkRuleToPhantom(workResourceID, phantomID,</span>
<span class="nc" id="L4847">						(Collection) complexWorkRules.get(workResourceID), dao.getDMO()));</span>
			}
<span class="nc" id="L4849">			createShiftAssignments(phantomShifts);</span>
<span class="nc" id="L4850">			deleteShiftAssignments(empIDs, start, end, spID, false);</span>

<span class="nc bnc" id="L4852" title="All 2 branches missed.">			if (!phantomComplexWorkRules.isEmpty()) {</span>
<span class="nc" id="L4853">				m_empWorkRuleManager.createComplexWorkRuleAssignments(phantomComplexWorkRules);</span>
			}

			// link just created phantoms to the sp
<span class="nc" id="L4857">			Jdmo dmo = dao.getDMO();</span>
<span class="nc" id="L4858">			JdmoRowset rs = dmo.createRowset(&quot;select id from sp where sid = &quot; + spID);</span>
<span class="nc" id="L4859">			String deSPID = null;</span>
<span class="nc bnc" id="L4860" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L4861">				deSPID = rs.getString(1);</span>
			}
<span class="nc bnc" id="L4863" title="All 6 branches missed.">			if (deSPID != null &amp;&amp; phantomIDs != null &amp;&amp; !phantomIDs.isEmpty()) {</span>
<span class="nc" id="L4864">				HashMap nameValues = new HashMap(2);</span>
<span class="nc bnc" id="L4865" title="All 2 branches missed.">				for (Iterator i = phantomIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L4866">					nameValues.put(&quot;SPID&quot;, deSPID);</span>
<span class="nc" id="L4867">					nameValues.put(&quot;WORKRESOURCEID&quot;, i.next());</span>
<span class="nc" id="L4868">					dmo.addBatchInsert(&quot;SPWORKRESOURCE&quot;, nameValues);</span>
				}
<span class="nc" id="L4870">				dmo.executeBatch();</span>
			}

<span class="nc" id="L4873">			return phantomIDs;</span>
<span class="nc" id="L4874">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L4875">			handleException(e);</span>
<span class="nc" id="L4876">			throw e;</span>
<span class="nc" id="L4877">		} catch (Exception e) {</span>
<span class="nc" id="L4878">			handleException(e);</span>
<span class="nc" id="L4879">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L4881">			dao.cleanUp();</span>
<span class="nc" id="L4882">			methodFinish();</span>
		}
	}

	public ID createPhantom(Phantom objValue) throws BbmCreateException {
<span class="nc" id="L4887">		return createPhantoms(new ArrayList(Collections.singletonList(objValue))).iterator().next();</span>
	}

	public Collection&lt;ID&gt; createPhantoms(Collection objValues) throws BbmCreateException {
<span class="nc" id="L4891">		methodStart(&quot;createPhantoms&quot;, objValues);</span>
<span class="nc" id="L4892">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="nc" id="L4894">			return dao.createPhantoms(objValues);</span>
<span class="nc" id="L4895">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L4896">			handleException(e);</span>
<span class="nc" id="L4897">			throw e;</span>
		} finally {
<span class="nc" id="L4899">			dao.cleanUp();</span>
<span class="nc" id="L4900">			methodFinish();</span>
		}
	}

	public void deletePhantoms(Collection colPhantomIDs) throws BbmRemoveException {
<span class="nc" id="L4905">		methodStart(&quot;deletePhantoms&quot;, colPhantomIDs);</span>
<span class="nc" id="L4906">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4908">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4909">			dao.deletePhantoms(colPhantomIDs);</span>
<span class="nc" id="L4910">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4911">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4912">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4913">			handleException(e);</span>
<span class="nc" id="L4914">			throw e;</span>
		} finally {
<span class="nc" id="L4916">			dmo.cleanUp();</span>
<span class="nc" id="L4917">			methodFinish();</span>
<span class="nc" id="L4918">		}</span>
<span class="nc" id="L4919">	}</span>

	public void deletePhantomsByEmployeeTemplateID(ID empTemplateID) throws BbmRemoveException {
<span class="nc" id="L4922">		methodStart(&quot;deletePhantomsByEmployeeTemplateID&quot;, empTemplateID);</span>
<span class="nc" id="L4923">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4925">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4926">			dao.deletePhantomsByEmployeeTemplate(empTemplateID);</span>
<span class="nc" id="L4927">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4928">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4929">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4930">			handleException(e);</span>
<span class="nc" id="L4931">			throw e;</span>
		} finally {
<span class="nc" id="L4933">			dmo.cleanUp();</span>
<span class="nc" id="L4934">			methodFinish();</span>
<span class="nc" id="L4935">		}</span>
<span class="nc" id="L4936">	}</span>

	public Phantom getPhantomByID(ID idPhantom) throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L4939">		return (Phantom) getPhantomsByIDs(Collections.singletonList(idPhantom)).iterator().next();</span>
	}

	public Collection getPhantomsByIDs(Collection colIDs) throws BbmFinderException {
<span class="fc" id="L4943">		methodStart(&quot;getPhantomsByIDs&quot;, colIDs);</span>
<span class="fc" id="L4944">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4946">			return dao.getPhantoms(colIDs, null);</span>
<span class="nc" id="L4947">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L4948">			handleException(e);</span>
<span class="nc" id="L4949">			throw e;</span>
		} finally {
<span class="pc" id="L4951">			dao.cleanUp();</span>
<span class="pc" id="L4952">			methodFinish();</span>
		}
	}

	/**
	 * get phantom employees for a given scheduling period
	 */
	public Collection getPhantoms(ID idSchedulingPeriod) throws BbmFinderException {
<span class="fc" id="L4960">		methodStart(&quot;getPhantoms&quot;, idSchedulingPeriod);</span>
<span class="fc" id="L4961">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L4963">			return dao.getPhantoms(null, idSchedulingPeriod);</span>
<span class="nc" id="L4964">		} catch (Exception e) {</span>
<span class="nc" id="L4965">			handleException(e);</span>
<span class="nc" id="L4966">			throw new BbmFinderException(e);</span>
		} finally {
<span class="pc" id="L4968">			dao.cleanUp();</span>
<span class="pc" id="L4969">			methodFinish();</span>
		}
	}

	/**
	 * delete phantoms given scheduling period id
	 */
	public void deletePhantomsBySchedulingPeriod(ID idSchedulingPeriod) throws BbmRemoveException {
<span class="nc" id="L4977">		methodStart(&quot;deletePhantomsBySchedulingPeriod&quot;, idSchedulingPeriod);</span>
<span class="nc" id="L4978">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4980">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4981">			dao.deletePhantomsBySchedulingPeriod(idSchedulingPeriod);</span>
<span class="nc" id="L4982">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L4983">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L4984">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L4985">			handleException(e);</span>
<span class="nc" id="L4986">			throw e;</span>
		} finally {
<span class="nc" id="L4988">			dmo.cleanUp();</span>
<span class="nc" id="L4989">			methodFinish();</span>
<span class="nc" id="L4990">		}</span>
<span class="nc" id="L4991">	}</span>

	public void deletePhantoms(ID idOrg, ID idSchedulingPeriod) throws BbmRemoveException {
<span class="nc" id="L4994">		methodStart(&quot;deletePhantoms&quot;, idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4995">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L4997">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L4998">			dao.deletePhantoms(idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L4999">			EmployeeTemplateDAO templateDAO = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L5000">			templateDAO.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L5001">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5002">			handleException(e);</span>
<span class="nc" id="L5003">			throw e;</span>
		} finally {
<span class="nc" id="L5005">			dmo.cleanUp();</span>
<span class="nc" id="L5006">			methodFinish();</span>
<span class="nc" id="L5007">		}</span>
<span class="nc" id="L5008">	}</span>

	public void deletePhantomsWithoutDeleteChildlessTemplate(ID idOrg, ID idSchedulingPeriod)
			throws BbmRemoveException {
<span class="nc" id="L5012">		methodStart(&quot;deletePhantoms&quot;, idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L5013">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L5015">			PhantomDAO dao = new PhantomDAO(dmo);</span>
<span class="nc" id="L5016">			dao.deletePhantoms(idOrg, idSchedulingPeriod);</span>
<span class="nc" id="L5017">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5018">			handleException(e);</span>
<span class="nc" id="L5019">			throw e;</span>
		} finally {
<span class="nc" id="L5021">			dmo.cleanUp();</span>
<span class="nc" id="L5022">			methodFinish();</span>
<span class="nc" id="L5023">		}</span>
<span class="nc" id="L5024">	}</span>

	public void updatePhantom(Phantom objValue) throws MultiUserException, BbmUpdateException {
<span class="nc" id="L5027">		updatePhantoms(Collections.singletonList(objValue));</span>
<span class="nc" id="L5028">	}</span>

	public void updatePhantoms(Collection objValues) throws MultiUserException, BbmUpdateException {
<span class="nc" id="L5031">		methodStart(&quot;updatePhantoms&quot;, objValues);</span>
<span class="nc" id="L5032">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="nc" id="L5034">			dao.updateObjects(objValues);</span>
		} finally {
<span class="nc" id="L5036">			dao.cleanUp();</span>
<span class="nc" id="L5037">			methodFinish();</span>
<span class="nc" id="L5038">		}</span>
<span class="nc" id="L5039">	}</span>

	/**
	 * Filters the phantom IDs out of the collection of work resource IDs,
	 * returning only the non-phantom IDs.
	 */
	public Collection&lt;ID&gt; filterPhantomIDsFromWorkResourceIDList(Collection&lt;ID&gt; workResourceIDs)
			throws BbmFinderException {
<span class="fc" id="L5047">		methodStart(&quot;filterPhantomIDsFromWorkResourceIDList&quot;, workResourceIDs);</span>
<span class="pc bpc" id="L5048" title="2 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.size() == 0) {</span>
<span class="nc" id="L5049">			return new ArrayList&lt;&gt;();</span>
		}
<span class="fc" id="L5051">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="fc" id="L5053">			Collection&lt;ID&gt; phantomIDs = dao.retrievePhantomIDsFromWorkResourceIDList(workResourceIDs);</span>
<span class="fc" id="L5054">			workResourceIDs.removeAll(phantomIDs);</span>
		} finally {
<span class="pc" id="L5056">			dao.cleanUp();</span>
<span class="pc" id="L5057">			methodFinish();</span>
<span class="fc" id="L5058">		}</span>
<span class="fc" id="L5059">		return workResourceIDs;</span>
	}

	private HashMap&lt;ID, String&gt; derivePhantomNamesForEmployees(
			HashMap&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; empIDShiftAssignmentMap, ID spID, Date start, Date end,
			HashMap&lt;ID, Collection&lt;Skill&gt;&gt; empIDSkillMap, HashMap&lt;ID, Employee&gt; employeeNameByID) throws Exception {
<span class="nc" id="L5065">		Iterator entries = empIDShiftAssignmentMap.entrySet().iterator();</span>
<span class="nc" id="L5066">		HashMap&lt;ID, ID&gt; empIDWorkPatternIdMap = new HashMap&lt;&gt;(empIDShiftAssignmentMap.size());</span>
<span class="nc" id="L5067">		HashMap&lt;ID, ID&gt; empIDShiftIdMap = new HashMap&lt;&gt;(empIDShiftAssignmentMap.size());</span>

<span class="nc bnc" id="L5069" title="All 2 branches missed.">		while (entries.hasNext()) {</span>
<span class="nc" id="L5070">			Entry&lt;ID, Collection&lt;ShiftAssignment&gt;&gt; thisEntry = (Entry) entries.next();</span>
<span class="nc" id="L5071">			ID workResourceID = thisEntry.getKey();</span>
<span class="nc" id="L5072">			Collection&lt;ShiftAssignment&gt; sas = thisEntry.getValue();</span>

			ShiftAssignment sa;
<span class="nc bnc" id="L5075" title="All 2 branches missed.">			for (Iterator i = sas.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5076">				sa = (ShiftAssignment) i.next();</span>
<span class="nc bnc" id="L5077" title="All 4 branches missed.">				if (sa.getCampaignID() != null &amp;&amp; sa.getCampaignID().equals(spID)) {</span>
<span class="nc bnc" id="L5078" title="All 2 branches missed.">					if (sa.getWorkPatternID() != null) {</span>
						// add the workpatternId
<span class="nc" id="L5080">						empIDWorkPatternIdMap.put(workResourceID, sa.getWorkPatternID());</span>
<span class="nc" id="L5081">						break;</span>
<span class="nc bnc" id="L5082" title="All 2 branches missed.">					} else if (sa.getShiftID() != null) {</span>
						// if no shift pattern, try to use shift name
<span class="nc" id="L5084">						empIDShiftIdMap.put(workResourceID, sa.getShiftID());</span>
<span class="nc" id="L5085">						break;</span>
					}
				}
			}
<span class="nc" id="L5089">		}</span>
<span class="nc" id="L5090">		HashMap&lt;ID, String&gt; workResourceIDNameMap = new HashMap&lt;&gt;(empIDShiftAssignmentMap.size());</span>

<span class="nc bnc" id="L5092" title="All 2 branches missed.">		if (!empIDWorkPatternIdMap.isEmpty()) {</span>
<span class="nc" id="L5093">			Collection&lt;ShiftPattern&gt; shiftPatterns = m_workRuleManager</span>
<span class="nc" id="L5094">					.getShiftPatternsByIDs(empIDWorkPatternIdMap.values());</span>
<span class="nc" id="L5095">			Iterator&lt;ShiftPattern&gt; it = shiftPatterns.iterator();</span>
<span class="nc" id="L5096">			HashMap&lt;ID, ShiftPattern&gt; shiftIDMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5097" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L5098">				ShiftPattern sp = it.next();</span>
<span class="nc" id="L5099">				shiftIDMap.put(sp.getID(), sp);</span>
<span class="nc" id="L5100">			}</span>

<span class="nc" id="L5102">			Iterator&lt;ID&gt; empIDIt = empIDWorkPatternIdMap.keySet().iterator();</span>
<span class="nc bnc" id="L5103" title="All 2 branches missed.">			while (empIDIt.hasNext()) {</span>
<span class="nc" id="L5104">				ID id = empIDIt.next();</span>
<span class="nc" id="L5105">				workResourceIDNameMap.put(id, shiftIDMap.get(empIDWorkPatternIdMap.get(id)).getName());</span>
<span class="nc" id="L5106">			}</span>
		}

<span class="nc bnc" id="L5109" title="All 2 branches missed.">		if (!empIDShiftIdMap.isEmpty()) {</span>
<span class="nc" id="L5110">			Collection&lt;Shift&gt; shifts = m_workRuleManager.getShiftsByIDs(empIDShiftIdMap.values());</span>
<span class="nc" id="L5111">			Iterator&lt;Shift&gt; it = shifts.iterator();</span>
<span class="nc" id="L5112">			HashMap&lt;ID, Shift&gt; shiftIDMap = new HashMap&lt;&gt;();</span>
<span class="nc bnc" id="L5113" title="All 2 branches missed.">			while (it.hasNext()) {</span>
<span class="nc" id="L5114">				Shift sp = it.next();</span>
<span class="nc" id="L5115">				shiftIDMap.put(sp.getID(), sp);</span>
<span class="nc" id="L5116">			}</span>

<span class="nc" id="L5118">			Iterator&lt;ID&gt; empIDIt = empIDShiftIdMap.keySet().iterator();</span>
<span class="nc bnc" id="L5119" title="All 2 branches missed.">			while (empIDIt.hasNext()) {</span>
<span class="nc" id="L5120">				ID id = empIDIt.next();</span>
<span class="nc" id="L5121">				workResourceIDNameMap.put(id, shiftIDMap.get(empIDShiftIdMap.get(id)).getName());</span>
<span class="nc" id="L5122">			}</span>
		}

		// append skill name if there is any skill linked to emp
<span class="nc" id="L5126">		Iterator&lt;ID&gt; idIt = empIDShiftAssignmentMap.keySet().iterator();</span>
<span class="nc bnc" id="L5127" title="All 2 branches missed.">		while (idIt.hasNext()) {</span>
<span class="nc" id="L5128">			ID workResourceID = idIt.next();</span>
<span class="nc" id="L5129">			Collection&lt;Skill&gt; empSkills = empIDSkillMap.get(workResourceID);</span>
<span class="nc bnc" id="L5130" title="All 2 branches missed.">			String name = workResourceIDNameMap.get(workResourceID) == null ? &quot;&quot;</span>
<span class="nc" id="L5131">					: workResourceIDNameMap.get(workResourceID);</span>
<span class="nc bnc" id="L5132" title="All 2 branches missed.">			if (empSkills != null) {</span>
<span class="nc bnc" id="L5133" title="All 2 branches missed.">				for (Iterator iSkill = empSkills.iterator(); iSkill.hasNext();) {</span>
<span class="nc" id="L5134">					name += (&quot; - &quot; + ((Skill) iSkill.next()).getName());</span>
				}
			}

			// if still name string is empty, use employee last name
<span class="nc bnc" id="L5139" title="All 2 branches missed.">			if (name.length() == 0) {</span>
<span class="nc" id="L5140">				name = employeeNameByID.get(workResourceID).getLastName();</span>
			}
<span class="nc bnc" id="L5142" title="All 2 branches missed.">			name = name.length() &gt; 30 ? name.substring(0, 30) : name; // 30</span>
																		// characters
																		// long
<span class="nc" id="L5145">			workResourceIDNameMap.put(workResourceID, name);</span>
<span class="nc" id="L5146">		}</span>
<span class="nc" id="L5147">		return workResourceIDNameMap;</span>
	}

	private Collection reassignComplexWorkRuleToPhantom(ID workResourceID, ID phantomID, Collection empComplexWorkRule,
			Jdmo dmo) throws Exception {
<span class="nc" id="L5152">		ArrayList list = new ArrayList();</span>
<span class="nc bnc" id="L5153" title="All 4 branches missed.">		if (empComplexWorkRule == null || empComplexWorkRule.isEmpty()) {</span>
<span class="nc" id="L5154">			return list;</span>
		}

		WorkResourceComplexWorkRule workRuleAssignment;
<span class="nc bnc" id="L5158" title="All 2 branches missed.">		for (Iterator i = empComplexWorkRule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5159">			workRuleAssignment = (WorkResourceComplexWorkRule) i.next();</span>
<span class="nc" id="L5160">			workRuleAssignment.setID(null);</span>
<span class="nc" id="L5161">			workRuleAssignment.setFieldValue(WorkResourceComplexWorkRuleFieldInfo.COMPLEXWORKRULEWORKRESOURCE_ID,</span>
<span class="nc" id="L5162">					new ID(DAOUtil.getDEID(dmo)));</span>
<span class="nc" id="L5163">			workRuleAssignment.setWorkResourceID(phantomID);</span>
<span class="nc" id="L5164">			list.add(workRuleAssignment);</span>
		}

<span class="nc" id="L5167">		return list;</span>
	}

	private Collection reassignShiftAssignmentToPhantom(ID spID, ID empID, ID phantomID, Collection shiftAssignments)
			throws Exception {
<span class="nc bnc" id="L5172" title="All 4 branches missed.">		if (shiftAssignments == null || shiftAssignments.isEmpty()) {</span>
<span class="nc" id="L5173">			return new ArrayList();</span>
		}
		ShiftAssignment shiftAssignment;
		ShiftEventAssignment event;
<span class="nc bnc" id="L5177" title="All 2 branches missed.">		for (Iterator i = shiftAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5178">			shiftAssignment = (ShiftAssignment) i.next();</span>
<span class="nc bnc" id="L5179" title="All 2 branches missed.">			if (!shiftAssignment.getCampaignID().equals(spID)) {</span>
<span class="nc" id="L5180">				i.remove(); // only reassign the shifts in this campaign to</span>
							// phantom
<span class="nc" id="L5182">				continue;</span>
			}
<span class="nc" id="L5184">			shiftAssignment.setID(null);</span>
<span class="nc" id="L5185">			shiftAssignment.removeWorkResourceID(empID);</span>
<span class="nc" id="L5186">			shiftAssignment.addWorkResourceID(phantomID);</span>
<span class="nc" id="L5187">			Collection children = shiftAssignment.getChildren();</span>
<span class="nc bnc" id="L5188" title="All 4 branches missed.">			if (children != null &amp;&amp; !children.isEmpty()) {</span>
<span class="nc bnc" id="L5189" title="All 2 branches missed.">				for (Iterator iChildren = children.iterator(); iChildren.hasNext();) {</span>
<span class="nc" id="L5190">					event = (ShiftEventAssignment) iChildren.next();</span>
<span class="nc" id="L5191">					event.setID(null);</span>
<span class="nc" id="L5192">					event.addWorkResourceID(phantomID);</span>
<span class="nc" id="L5193">					shiftAssignment.createChildObject(ShiftAssignmentFields.CHILD_SHIFT_EVENT, event);</span>
				}
<span class="nc" id="L5195">				shiftAssignment.clearChildObjectMap(); // move the event list</span>
														// from persisted list
														// to create list
			}
<span class="nc" id="L5199">		}</span>
<span class="nc" id="L5200">		return shiftAssignments;</span>
	}

	private String getPhantomFirstName(Jdmo dmo, ID empTemplateSID, HashMap nextPhantomNameMap) throws Exception {
<span class="nc" id="L5204">		String nextPhantomName = (String) nextPhantomNameMap.get(empTemplateSID);</span>
		int next;
<span class="nc bnc" id="L5206" title="All 2 branches missed.">		if (nextPhantomName != null) {</span>
<span class="nc" id="L5207">			next = Integer.parseInt(nextPhantomName) + 1;</span>
<span class="nc" id="L5208">			nextPhantomNameMap.put(empTemplateSID, String.valueOf(next));</span>
<span class="nc" id="L5209">			return nextPhantomName;</span>
		}
<span class="nc" id="L5211">		StringBuffer sb = new StringBuffer(200);</span>
<span class="nc" id="L5212">		sb.append(&quot;select max(cast(name as int)) from phantom where EMPTEMPLATEID = &quot;).append(empTemplateSID);</span>
<span class="nc" id="L5213">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L5214" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L5215">			int curMax = rs.getInt(1);</span>
<span class="nc" id="L5216">			nextPhantomName = String.valueOf(curMax + 1);</span>
<span class="nc" id="L5217">			next = curMax + 2;</span>
<span class="nc" id="L5218">			nextPhantomNameMap.put(empTemplateSID, String.valueOf(next));</span>
<span class="nc" id="L5219">			return nextPhantomName;</span>
		}
<span class="nc" id="L5221">		return String.valueOf(1);</span>
	}

	/**************************************************************************
	 * functions for employee templates
	 **************************************************************************/
	public ID createEmployeeTemplate(EmployeeTemplate objValue) throws BbmCreateException {
<span class="nc" id="L5228">		methodStart(&quot;createEmployeeTemplate&quot;, objValue);</span>
<span class="nc" id="L5229">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5231">			return dao.createEmployeeTemplate(objValue);</span>
<span class="nc" id="L5232">		} catch (BbmCreateException e) {</span>
<span class="nc" id="L5233">			handleException(e);</span>
<span class="nc" id="L5234">			throw e;</span>
		} finally {
<span class="nc" id="L5236">			dao.cleanUp();</span>
<span class="nc" id="L5237">			methodFinish();</span>
		}
	}

	public void updateEmployeeTemplate(EmployeeTemplate objValue)
			throws BbmException, BbmUpdateException, MultiUserException {
<span class="nc" id="L5243">		updateEmployeeTemplates(Collections.singletonList(objValue));</span>
<span class="nc" id="L5244">	}</span>

	public void updateEmployeeTemplates(Collection&lt;EmployeeTemplate&gt; ETCol)
			throws BbmException, BbmUpdateException, MultiUserException {
<span class="nc" id="L5248">		methodStart(&quot;updateEmployeeTemplates&quot;, ETCol);</span>
<span class="nc" id="L5249">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5251">			dao.updateEmployeeTemplates(ETCol);</span>
<span class="nc" id="L5252">		} catch (MultiUserException | BbmException e) {</span>
<span class="nc" id="L5253">			handleException(e);</span>
<span class="nc" id="L5254">			throw e;</span>
		} finally {
<span class="nc" id="L5256">			dao.cleanUp();</span>
<span class="nc" id="L5257">			methodFinish();</span>
<span class="nc" id="L5258">		}</span>
<span class="nc" id="L5259">	}</span>

	public void deleteEmployeeTemplates(Collection colEmpTemplateIDs) throws BbmRemoveException {
<span class="nc" id="L5262">		methodStart(&quot;deleteEmployeeTemplates&quot;, colEmpTemplateIDs);</span>
<span class="nc" id="L5263">		Jdmo dmo = new Jdmo();</span>
		try {
<span class="nc" id="L5265">			EmployeeTemplateDAO dao = new EmployeeTemplateDAO(dmo);</span>
<span class="nc" id="L5266">			dao.deleteEmployeeTemplates(colEmpTemplateIDs);</span>
<span class="nc" id="L5267">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5268">			handleException(e);</span>
<span class="nc" id="L5269">			throw e;</span>
		} finally {
<span class="nc" id="L5271">			dmo.cleanUp();</span>
<span class="nc" id="L5272">			methodFinish();</span>
<span class="nc" id="L5273">		}</span>
<span class="nc" id="L5274">	}</span>

	public void copyEmployeeTemplates(Collection&lt;ID&gt; empTemplateIDs, boolean isOrgMode, ID ownerID,
			LocaleContext localeContext)
			throws BbmCreateException, BbmDuplicateExternalIdentException, BbmFinderException, RemoteException {
<span class="nc" id="L5279">		methodStart(&quot;copyEmployeeTemplates&quot;, empTemplateIDs, isOrgMode, ownerID, localeContext);</span>
<span class="nc" id="L5280">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>

		try {
<span class="nc" id="L5283">			dao.copyEmployeeTemplates(empTemplateIDs, isOrgMode, ownerID, localeContext,</span>
<span class="nc" id="L5284">					m_sessionContext.getCallerPrincipal().getName());</span>
<span class="nc" id="L5285">		} catch (BbmCreateException | BbmFinderException ex) {</span>
<span class="nc" id="L5286">			handleException(ex);</span>
<span class="nc" id="L5287">			throw ex;</span>
		} finally {
<span class="nc" id="L5289">			dao.cleanUp();</span>
<span class="nc" id="L5290">			methodFinish();</span>
<span class="nc" id="L5291">		}</span>
<span class="nc" id="L5292">	}</span>

	/**
	 * get employee templates in a given organization
	 */
	public EmployeeTemplate getEmployeeTemplateByID(ID idEmpTemplate)
			throws BbmObjectNotFoundException, BbmFinderException {
<span class="nc" id="L5299">		return (EmployeeTemplate) (getEmployeeTemplatesByIDs(Collections.singletonList(idEmpTemplate)).iterator().next());</span>
	}

	/**
	 * get employee templates in a given organization
	 */
	public Collection getEmployeeTemplatesByIDs(Collection colIDs) throws BbmFinderException {
<span class="nc" id="L5306">		methodStart(&quot;getEmployeeTemplatesByIDs&quot;, colIDs);</span>
<span class="nc" id="L5307">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5309">			return dao.getEmployeeTemplatesByIDs(colIDs);</span>
<span class="nc" id="L5310">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5311">			handleException(e);</span>
<span class="nc" id="L5312">			throw e;</span>
		} finally {
<span class="nc" id="L5314">			dao.cleanUp();</span>
<span class="nc" id="L5315">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a given organization
	 */
	public Collection getEmployeeTemplatesInOrg(ID idOrg) throws BbmFinderException {
<span class="nc" id="L5323">		return getEmployeeTemplatesInOrgs(Collections.singletonList(idOrg));</span>
	}

	/*
	 * Returns employee templates using the give shift pattern id
	 */
	public Collection getEmployeeTemplatesUsingShiftPattern(Collection&lt;ID&gt; shiftPatternIds) {
<span class="nc" id="L5330">		methodStart(&quot;getEmployeeTemplatesUsingShiftPattern&quot;, shiftPatternIds);</span>
<span class="nc" id="L5331">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5333">			return dao.getEmployeeTemplatesUsingShiftPattern(shiftPatternIds);</span>
<span class="nc" id="L5334">		} catch (Exception e) {</span>
<span class="nc" id="L5335">			handleException(e);</span>
<span class="nc" id="L5336">			return Collections.emptyList();</span>
		} finally {
<span class="nc" id="L5338">			dao.cleanUp();</span>
<span class="nc" id="L5339">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a given SP
	 */
	public Collection getEmployeeTemplatesInSP(ID spID) throws BbmFinderException {
<span class="nc" id="L5347">		methodStart(&quot;getEmployeeTemplatesInSP&quot;, spID);</span>
<span class="nc" id="L5348">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5350">			return dao.getEmployeeTemplatesInSP(spID);</span>
<span class="nc" id="L5351">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5352">			handleException(e);</span>
<span class="nc" id="L5353">			throw e;</span>
		} finally {
<span class="nc" id="L5355">			dao.cleanUp();</span>
<span class="nc" id="L5356">			methodFinish();</span>
		}
	}

	/**
	 * get employee templates in a set of given organizations
	 */
	public Collection getEmployeeTemplatesInOrgs(Collection colOrgIDs) throws BbmFinderException {
<span class="nc" id="L5364">		methodStart(&quot;getEmployeeTemplatesInOrgs&quot;, colOrgIDs);</span>
<span class="nc" id="L5365">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5367">			return dao.getEmployeeTemplatesInOrgs(colOrgIDs);</span>
<span class="nc" id="L5368">		} catch (BbmFinderException e) {</span>
<span class="nc" id="L5369">			handleException(e);</span>
<span class="nc" id="L5370">			throw e;</span>
		} finally {
<span class="nc" id="L5372">			dao.cleanUp();</span>
<span class="nc" id="L5373">			methodFinish();</span>
		}
	}

	private void deleteChildlessHiddenEmployeeTemplate() throws BbmRemoveException {
<span class="nc" id="L5378">		methodStart(&quot;deleteChildlessHiddenEmployeeTemplate&quot;);</span>
<span class="nc" id="L5379">		EmployeeTemplateDAO dao = new EmployeeTemplateDAO();</span>
		try {
<span class="nc" id="L5381">			dao.deleteChildlessHiddenEmployeeTemplate();</span>
<span class="nc" id="L5382">		} catch (BbmRemoveException e) {</span>
<span class="nc" id="L5383">			handleException(e);</span>
<span class="nc" id="L5384">			throw e;</span>
		} finally {
<span class="nc" id="L5386">			dao.cleanUp();</span>
<span class="nc" id="L5387">			methodFinish();</span>
<span class="nc" id="L5388">		}</span>
<span class="nc" id="L5389">	}</span>

	private EmployeeTemplate FindHiddenEmpTemplateWithAttributes(Jdmo dmo, ID orgID, String phantomLastName,
			double wage, Collection skillIDs, Collection shiftPatternIDs, int proficiency) throws Exception {
<span class="nc" id="L5393">		StringBuffer sb = new StringBuffer(300);</span>
<span class="nc" id="L5394">		sb.append(&quot; SELECT A.SID FROM EMPTEMPLATE A&quot;);</span>
<span class="nc" id="L5395">		sb.append(&quot; WHERE A.ISHIDDEN = 1 AND ORGANIZATIONID =  &quot;).append(orgID);</span>
<span class="nc" id="L5396">		sb.append(&quot; AND WAGE = &quot;).append(wage).append(&quot; AND PROFICIENCY = &quot;).append((float) proficiency / 10);</span>
<span class="nc" id="L5397">		sb.append(&quot; AND NAME LIKE &quot;).append(JdmoUtil.asSqlLiteral(phantomLastName));</span>
<span class="nc bnc" id="L5398" title="All 2 branches missed.">		if (!skillIDs.isEmpty()) {</span>
<span class="nc" id="L5399">			sb.append(&quot; AND (SELECT COUNT(ID) FROM EMPTEMPLATESKILL WHERE EMPTEMPLATEID = A.ID AND SKILLID IN (&quot;)</span>
<span class="nc" id="L5400">					.append(getStringIDList(skillIDs)).append(&quot;)) = &quot;).append(skillIDs.size());</span>
		}
<span class="nc bnc" id="L5402" title="All 2 branches missed.">		if (!shiftPatternIDs.isEmpty()) {</span>
			// shift pattern not SID, here we have
			// SID.
<span class="nc" id="L5405">			sb.append(</span>
					&quot; AND (SELECT COUNT(ID) FROM SHIFTPATTERNEMPTEMPLATE WHERE EMPTEMPLATEID = A.ID AND SHIFTPATTERNID IN (Select ID from SHIFTPATTERN where SID in (&quot;)
<span class="nc" id="L5407">					.append(getStringIDList(shiftPatternIDs)).append(&quot;))) = &quot;).append(shiftPatternIDs.size());</span>
		}
<span class="nc" id="L5409">		JdmoRowset rs = dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L5410" title="All 2 branches missed.">		while (rs.next()) {</span>
<span class="nc" id="L5411">			return getEmployeeTemplateByID(rs.getID(1));</span>
		}

<span class="nc" id="L5414">		return null;</span>
	}

	private ID getRotationCurrentShiftPatternID(ID workResourceID, ID orgID, WorkResourceRotation empRotationWorkRule,
			Rotation rotationWorkRule, Collection shiftPatterns, Date viewStartInGMT) throws Exception {
<span class="nc" id="L5419">		int currentWeekIndex = GetCurrentWeekOfRotation(workResourceID, orgID, empRotationWorkRule, rotationWorkRule,</span>
				viewStartInGMT);

<span class="nc" id="L5422">		ShiftPattern[] aShiftPattern = new ShiftPattern[shiftPatterns.size()];</span>
<span class="nc" id="L5423">		aShiftPattern = (ShiftPattern[]) shiftPatterns.toArray(aShiftPattern);</span>
<span class="nc" id="L5424">		return aShiftPattern[currentWeekIndex].getID();</span>
	}

	private int GetCurrentWeekOfRotation(ID workResourceID, ID orgID, WorkResourceRotation empRotationWorkRule,
			Rotation rotationWorkRule, Date startInGMT) throws Exception {
<span class="nc" id="L5429">		Organization org = m_workResourceManager.getOrganizationByID(orgID);</span>
<span class="nc" id="L5430">		TimeZone orgTZ = org.getTimeZone();</span>

		// find the week start
<span class="nc" id="L5433">		Calendar calendar = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L5434">		calendar.setTime(startInGMT);</span>
<span class="nc" id="L5435">		int viewWeekOffset = (calendar.get(Calendar.DAY_OF_WEEK) - 1) * 24 * 60</span>
<span class="nc" id="L5436">				+ calendar.get(Calendar.HOUR_OF_DAY) * 60 + calendar.get(Calendar.MINUTE);</span>
<span class="nc" id="L5437">		int weekBoundary = org.getWeekStartDate() * 24 * 60 + org.getDayBoundaryOffset();</span>
		// move back to sunday
<span class="nc" id="L5439">		calendar.add(Calendar.MINUTE, -viewWeekOffset);</span>
		// add week boundary defined in org
<span class="nc" id="L5441">		calendar.add(Calendar.MINUTE, weekBoundary);</span>
<span class="nc" id="L5442">		Date weekStartOrgT = calendar.getTime();</span>

<span class="nc" id="L5444">		int offsetInDays = TimeZoneUtil.numberOfDays(</span>
<span class="nc" id="L5445">				rotationWorkRule.getAlignmentDate().getTime(TimeZoneUtil.GMT_TIMEZONE),</span>
<span class="nc" id="L5446">				TimeZoneUtil.toGMT(weekStartOrgT));</span>
<span class="nc" id="L5447">		return (offsetInDays / 7) % empRotationWorkRule.getNumWeeksInRotation();</span>
	}

	private String getStringIDList(Collection sIDs) {
<span class="nc" id="L5451">		StringBuffer sb = new StringBuffer(100);</span>
<span class="nc bnc" id="L5452" title="All 2 branches missed.">		for (Iterator i = sIDs.iterator(); i.hasNext();) {</span>
<span class="nc" id="L5453">			sb.append(JdmoUtil.asSqlLiteral(i.next()));</span>
<span class="nc bnc" id="L5454" title="All 2 branches missed.">			if (i.hasNext()) {</span>
<span class="nc" id="L5455">				sb.append(&quot;,&quot;);</span>
			}
		}
<span class="nc" id="L5458">		return sb.toString();</span>
	}

	public boolean isTemplatesUsedInExistingSchedule(Collection empTemplateIds) throws BbmFinderException {
<span class="nc" id="L5462">		methodStart(&quot;isTemplatesUsedInExistingSchedule&quot;, empTemplateIds);</span>
<span class="nc" id="L5463">		boolean isTemplatesUsedInExistingSchedule = false;</span>
<span class="nc" id="L5464">		PhantomDAO dao = new PhantomDAO();</span>
		try {
<span class="nc" id="L5466">			isTemplatesUsedInExistingSchedule = dao.isTemplatesUsedInExistingSchedule(empTemplateIds);</span>
		} finally {
<span class="nc" id="L5468">			dao.cleanUp();</span>
<span class="nc" id="L5469">			methodFinish();</span>
<span class="nc" id="L5470">		}</span>
<span class="nc" id="L5471">		return isTemplatesUsedInExistingSchedule;</span>
	}

	public void updateStatusForScheduleRun(ID sid, int status, String user) throws BbmException {
<span class="fc" id="L5475">		methodStart(&quot;updateStatusForScheduleRun&quot;);</span>
<span class="fc" id="L5476">		ScheduleRunStatusDAO dao = new ScheduleRunStatusDAO();</span>
		try {

<span class="fc" id="L5479">			dao.updateStatusForScheduleRun(sid, status, user);</span>
		} finally {
<span class="pc" id="L5481">			dao.cleanUp();</span>
<span class="pc" id="L5482">			methodFinish();</span>
<span class="fc" id="L5483">		}</span>
<span class="fc" id="L5484">	}</span>

	public void linkWorkResourcesToSchedulingPeriod(ID spId, Collection employeeIds) throws BbmCreateException {
<span class="nc" id="L5487">		methodStart(&quot;linkWorkResourcesToSchedulingPeriod&quot;, spId, employeeIds);</span>
		try {
<span class="nc" id="L5489">			SchedulingPeriod pSourceSP = m_pCampaignManager.getSchedulingPeriodByID(spId);</span>
<span class="nc" id="L5490">			m_pCampaignManager.linkWorkResourcesToSchedulingPeriod(pSourceSP.getDEID(), employeeIds);</span>
<span class="nc" id="L5491">		} catch (Exception e) {</span>
<span class="nc" id="L5492">			handleException(e);</span>
<span class="nc" id="L5493">			throw new BbmCreateException(e);</span>
		} finally {
<span class="nc" id="L5495">			methodFinish();</span>
<span class="nc" id="L5496">		}</span>
<span class="nc" id="L5497">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>