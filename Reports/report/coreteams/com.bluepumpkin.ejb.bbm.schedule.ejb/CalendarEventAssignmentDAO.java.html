<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>CalendarEventAssignmentDAO.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.schedule.ejb</a> &gt; <span class="el_source">CalendarEventAssignmentDAO.java</span></div><h1>CalendarEventAssignmentDAO.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.bbm.schedule.ejb;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.jdmo.Jdmo;
import com.bluepumpkin.common.jdmo.JdmoException;
import com.bluepumpkin.common.jdmo.JdmoRowset;
import com.bluepumpkin.common.jdmo.JdmoUtil;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.dao.DAOBase;
import com.bluepumpkin.ejb.bbm.l10n.BbmEjbLogBundleKey;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmScheduleConflict;
import com.bluepumpkin.ejb.bbm.schedule.model.BbmSchedulePublishingException;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAssignmentFields;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventAttendee;
import com.bluepumpkin.ejb.bbm.schedule.model.CalendarEventTemplate;
import com.bluepumpkin.ejb.bbm.schedule.model.RecurringEventTemplateBase;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.TimeOffEvent;
import com.bluepumpkin.ejb.bbm.schedule.model.UnavailabilityEvent;
import com.bluepumpkin.ejb.bbm.vo.FieldInfo;
import com.bluepumpkin.ejb.core.base.MultiUserException;


class CalendarEventAssignmentDAO extends EventAssignmentUnpubDAO&lt;CalendarEventAssignment&gt;
		implements ScheduleConflictChecker&lt;CalendarEventAssignment&gt; {
	// meta data info.
<span class="fc" id="L45">	private static FieldInfo m_fieldInfo = new CalendarEventAssignmentFields();</span>

	public CalendarEventAssignmentDAO() {
<span class="nc" id="L48">		super();</span>
<span class="nc" id="L49">	}</span>

	public CalendarEventAssignmentDAO(Jdmo dmo) {
<span class="fc" id="L52">		super(dmo);</span>
<span class="fc" id="L53">	}</span>

	@Override
	protected FieldInfo getFieldInfo() {
<span class="fc" id="L57">		return m_fieldInfo;</span>
	}

	/**
	 * This is an override of the base class function to create an appropriate
	 * type of the value object based on the event type that is stored in
	 * CALENDAREVENTASSIGNMENT record
	 */
	@Override
	protected CalendarEventAssignment createValueObject(JdmoRowset rs) throws Exception {
<span class="nc" id="L67">		int eventType = rs.getInt(&quot;EVENTTYPE&quot;);</span>
<span class="nc bnc" id="L68" title="All 4 branches missed.">		switch (eventType) {</span>
		case Event.EVENT_TYPE_TIME_OFF:
<span class="nc" id="L70">			return new TimeOffEvent();</span>

		case Event.EVENT_TYPE_UNAVAILABILITY:
<span class="nc" id="L73">			return new UnavailabilityEvent();</span>

		case Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT:
<span class="nc" id="L76">			return new CalendarEvent();</span>

		default:
			/* this should never happen, could log an error here */
<span class="nc" id="L80">			ScheduleAccessManagerEJB.m_cat.l7dError(BbmEjbLogBundleKey.SCHEDULE_UNKNOWN_EVENT_TYPE,</span>
<span class="nc" id="L81">					new Object[] { NumberFactory.newInteger(eventType) });</span>
<span class="nc" id="L82">			return null;</span>
		}
	}

	@Override
	protected CalendarEventAssignment createValueObject() {
<span class="nc" id="L88">		return null;</span>
	}

	@Override
	protected DAOBase createChildDAO(int iType) {
<span class="nc bnc" id="L93" title="All 2 branches missed.">		if (iType == CalendarEventAssignmentFields.CHILD_ATTENDEE) {</span>
<span class="nc" id="L94">			return new CalendarEventAttendeeDAO(m_dmo);</span>
		} else {
<span class="nc" id="L96">			return new CalendarEventProjectDAO(m_dmo);</span>
		}
	}

	@Override
	protected CalendarEventAssignmentPubDAO getPublishedDAO() {
<span class="nc" id="L102">		return new CalendarEventAssignmentPubDAO(m_dmo);</span>
	}

	@Override
	protected void calcAndSetEventPrecedence(CalendarEventAssignment eventAssignment) throws Exception {
<span class="nc" id="L107">		int precedence = EventPrecedenceRule.getEventOverlayPrecedence(eventAssignment);</span>
<span class="nc" id="L108">		eventAssignment.setOverlayPrecedence(precedence);</span>
<span class="nc" id="L109">	}</span>

	@Override
	public ID createObject(CalendarEventAssignment eventAssignment, boolean bBatched) throws BbmCreateException {
		/*
		 * I don't really want to expose a method on CalendarEventAssignment
		 * like setEventType(), but we need to store the event type in the
		 * database table so we can know what type of event this was, so I will
		 * do this instead
		 */
<span class="nc" id="L119">		eventAssignment.setFieldValue(CalendarEventAssignmentFields.EVENTTYPE, eventAssignment.getEventType());</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (eventAssignment.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME) &amp;&amp; eventAssignment.isFieldValueSet</span>
<span class="nc bnc" id="L122" title="All 2 branches missed.">			(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="nc" id="L123">			eventAssignment.setFieldValue(CalendarEventAssignmentFields.ENDTIME, new Date(eventAssignment.getStartTime().getTime() + </span>
<span class="nc" id="L124">				eventAssignment.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}
<span class="nc" id="L126">		return super.createObject(eventAssignment, bBatched);</span>
	}

	/**
	 * This function is called right after an newly created calendar event
	 * assignment has been persisted to the database. It checks whether this new
	 * calendar event assignment created any conflicts in the employee's
	 * schedule. The following are possible conflicts: 1) Some shift assignment
	 * overlaps this Unavailability calendar event assignment 2) this calendar
	 * event assignment overlaps with some other calendar event assignment
	 *
	 */
	@Override
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObject(CalendarEventAssignment eventAssignment) throws 
			BbmFinderException {
<span class="nc" id="L141">		return getConflictsForScheduleObject(eventAssignment, true);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForNewScheduleObjects(Collection&lt;CalendarEventAssignment&gt; eventAssignments)
			throws BbmFinderException {
<span class="nc" id="L146">		List&lt;BbmScheduleConflict&gt; conflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">		if (eventAssignments == null) {</span>
<span class="nc" id="L148">			return conflicts;</span>
		}
<span class="nc bnc" id="L150" title="All 2 branches missed.">		for (Iterator&lt;CalendarEventAssignment&gt; i = eventAssignments.iterator(); i.hasNext();) {</span>
<span class="nc" id="L151">			conflicts.addAll(getConflictsForScheduleObject(i.next(), true, null));</span>
		}
<span class="nc" id="L153">		return conflicts;</span>
	}

	@Override
	public Collection&lt;BbmScheduleConflict&gt; getConflictsForUpdatedScheduleObject(CalendarEventAssignment eventAssignment) throws 
			BbmFinderException {
<span class="nc" id="L159">		return getConflictsForScheduleObject(eventAssignment, false, null);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(CalendarEventAssignment eventAssignment, boolean isNewObject)
            throws BbmFinderException {
<span class="nc" id="L164">		return getConflictsForScheduleObject(eventAssignment, isNewObject, null);</span>
	}

	public Collection&lt;BbmScheduleConflict&gt; getConflictsForScheduleObject(CalendarEventAssignment eventAssignment, boolean isNewObject, 
			ID recurringTemplateID) throws BbmFinderException {
		try {
			// will be use later to check conflict.
<span class="nc" id="L171">			calcAndSetEventPrecedence(eventAssignment);</span>
<span class="nc" id="L172">		} catch (Exception e) {</span>
<span class="nc" id="L173">			throw new BbmFinderException(e);</span>
<span class="nc" id="L174">		}</span>
<span class="nc" id="L175">		Collection&lt;ID&gt; workResourceIDs = eventAssignment.getWorkResourceIDs();</span>

<span class="nc" id="L177">		List&lt;BbmScheduleConflict&gt; listConflicts = new ArrayList&lt;BbmScheduleConflict&gt;();</span>
<span class="nc" id="L178">		List&lt;CalendarEventAssignment&gt; conflictEvents = new ArrayList&lt;CalendarEventAssignment&gt;();</span>


<span class="nc" id="L181">		getAlreadyAttendingConflictsForScheduleObject(isNewObject, eventAssignment, listConflicts);</span>

<span class="nc" id="L183">		getOverlapConflictsForScheduleObject(isNewObject, recurringTemplateID, eventAssignment, workResourceIDs, listConflicts, </span>
			conflictEvents);

<span class="nc" id="L186">		getSamePrecedenceShiftAssignmentConflictsForScheduleObject(eventAssignment, workResourceIDs, listConflicts);</span>
		
		/*
		 * the last step is to find the find all of the employee names for all
		 * of the conflicts returned from this method call
		 */
<span class="nc" id="L192">		ScheduleDAOUtil.findEmployeeNames(listConflicts);</span>

<span class="nc" id="L194">		return listConflicts;</span>
	}

	/**
	 * Get conflicts where this calendar event is a template exception and has
	 * attendee which has already attended the other exceptions
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getAlreadyAttendingConflictsForScheduleObject(boolean isNewObject, CalendarEventAssignment event,
			List&lt;BbmScheduleConflict&gt; listConflicts) throws BbmFinderException {
<span class="nc" id="L204">		ID tplID = event.getEventTemplateID();</span>
<span class="nc bnc" id="L205" title="All 4 branches missed.">		if (!isNewObject &amp;&amp; tplID != null) {</span>
<span class="nc" id="L206">			CalendarEventTemplateDAO tplDao = new CalendarEventTemplateDAO(this.m_dmo);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">			if (tplDao.getTemplateTypeByID(tplID) == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING) {</span>

<span class="nc" id="L209">				Collection&lt;CalendarEventAttendee&gt; createdAttendees = event</span>
<span class="nc" id="L210">					.getCreatedChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L211" title="All 4 branches missed.">				if (createdAttendees != null &amp;&amp; !createdAttendees.isEmpty()) {</span>

<span class="nc" id="L213">					RecurringEventTemplateDAO recTplDao = new RecurringEventTemplateDAO(this.m_dmo);</span>
<span class="nc" id="L214">					RecurringEventTemplateBase recTemplate = recTplDao</span>
<span class="nc" id="L215">						.getObjectByID(tplID);</span>

<span class="nc" id="L217">					Collection&lt;ID&gt; templateWorkResources = recTemplate.getWorkResourceIDs();</span>
<span class="nc" id="L218">					HashSet&lt;ID&gt; existingTemplateWorkResources = new HashSet&lt;&gt;();</span>
<span class="nc" id="L219">					existingTemplateWorkResources.addAll(templateWorkResources);</span>

<span class="nc" id="L221">					Collection&lt;ID&gt; conflictWorkResources = new HashSet&lt;&gt;();</span>
<span class="nc bnc" id="L222" title="All 2 branches missed.">					for (CalendarEventAttendee createdAttendee : createdAttendees) {</span>
<span class="nc" id="L223">						ID workResourceID = (createdAttendee).getWorkResourceID();</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">						if (!existingTemplateWorkResources.contains(workResourceID) </span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">							&amp;&amp; recTemplate.existsExceptionOnDate(event.getStartTime(), workResourceID)) {</span>
<span class="nc" id="L226">							conflictWorkResources.add(workResourceID);</span>
						}
<span class="nc" id="L228">					}</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">					if (!conflictWorkResources.isEmpty()) {</span>
<span class="nc" id="L231">						BbmScheduleConflict schConflict = new BbmScheduleConflict(event, conflictWorkResources);</span>
<span class="nc" id="L232">						listConflicts.add(schConflict);</span>
					}
				}
			}
		}
<span class="nc" id="L237">	}</span>

	/**
	 * Get conflicts where this calendar event assignment overlaps with another
	 * calendar event assignment with the same precedence
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getOverlapConflictsForScheduleObject(boolean isNewObject, ID recurringTemplateID,
			CalendarEventAssignment event, Collection&lt;ID&gt; workResourceIDs, List&lt;BbmScheduleConflict&gt; listConflicts,
			List&lt;CalendarEventAssignment&gt; conflictEvents) throws BbmFinderException {
<span class="nc" id="L247">		Collection&lt;CalendarEventAttendee&gt; attendees = event.getChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc" id="L248">		Map&lt;ID, Boolean&gt; workResourceAttendeesMap = new HashMap&lt;&gt;();</span>

<span class="nc bnc" id="L250" title="All 2 branches missed.">		for (CalendarEventAttendee attendee : attendees) {</span>
<span class="nc" id="L251">			workResourceAttendeesMap.put(attendee.getWorkResourceID(), attendee.isAttending());</span>
<span class="nc" id="L252">		}</span>
		
<span class="nc" id="L254">		Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listEvents = getAllAttendingEventsForWorkResources(workResourceIDs,</span>
<span class="nc" id="L255">			event.getStartTime(), event.getEndTime());</span>
<span class="nc bnc" id="L256" title="All 2 branches missed.">		for (Collection&lt;CalendarEventAssignment&gt; wrkEvents : listEvents) {</span>
<span class="nc bnc" id="L257" title="All 4 branches missed.">			if (wrkEvents == null || wrkEvents.isEmpty()) {</span>
<span class="nc" id="L258">				continue;</span>
			}

<span class="nc bnc" id="L261" title="All 2 branches missed.">			for (CalendarEventAssignment event2 : wrkEvents) {</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">				if (isInstanceForSameFloatingTemplate(event, event2)) {</span>
					// update the same floating event template
<span class="nc" id="L264">					continue;</span>
				}

<span class="nc bnc" id="L267" title="All 4 branches missed.">				if (recurringTemplateID != null &amp;&amp; recurringTemplateID.equals(event2.getEventTemplateID())) {</span>
					// skip for similar recurring floating event
<span class="nc" id="L269">					continue;</span>
				}

<span class="nc bnc" id="L272" title="All 4 branches missed.">				if ((isNewObject || !event.getID().equals(event2.getID())) &amp;&amp; event.getOverlayPrecedence() ==</span>
<span class="nc bnc" id="L273" title="All 2 branches missed.">					event2.getOverlayPrecedence()) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">					for (ID workResourceID : workResourceIDs) {</span>
<span class="nc bnc" id="L275" title="All 4 branches missed.">						if (event2.getWorkResourceIDs().contains(workResourceID) &amp;&amp; workResourceAttendeesMap.get(workResourceID) &amp;&amp;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">							!conflictEvents.contains(event2)) {</span>
<span class="nc" id="L277">							conflictEvents.add(event2);</span>
<span class="nc" id="L278">							listConflicts.add(new BbmScheduleConflict(event, event2));</span>
						}
<span class="nc" id="L280">					}</span>
				}
<span class="nc" id="L282">			}</span>
<span class="nc" id="L283">		}</span>
<span class="nc" id="L284">	}</span>

	/**
	 * Get conflicts where Some shift assignment with the same precedence overlaps this calendar
	 * event assignment
	 * @param listConflicts - Any conflicts will be added to this list.
	 */
	private void getSamePrecedenceShiftAssignmentConflictsForScheduleObject(CalendarEventAssignment event, 
			Collection&lt;ID&gt; workResourceIDs, List&lt;BbmScheduleConflict&gt; listConflicts) throws BbmFinderException {
		
<span class="nc" id="L294">		ShiftAssignmentDAO daoShift = new ShiftAssignmentDAO(m_dmo);</span>
<span class="nc" id="L295">		Collection&lt;Collection&lt;ShiftAssignment&gt;&gt; shifts = daoShift.getEventsForWorkResources(workResourceIDs, event.getStartTime(),</span>
<span class="nc" id="L296">					event.getEndTime());</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">		for (Collection&lt;ShiftAssignment&gt; wrkShifts : shifts) {</span>
<span class="nc bnc" id="L298" title="All 4 branches missed.">			if (wrkShifts == null || wrkShifts.isEmpty()) {</span>
<span class="nc" id="L299">				continue;</span>
			}

<span class="nc bnc" id="L302" title="All 2 branches missed.">			for (ShiftAssignment shift : wrkShifts) {</span>
				/*
				 * we can cast to ShiftAssignment here because this collection
				 * is a result of calling
				 * ShiftAssignmentDAO.getEventsForWorkResources which will only
				 * retrieve shift assignments
				 */
<span class="nc bnc" id="L309" title="All 2 branches missed.">				if (shift.getOverlayPrecedence() == event.getOverlayPrecedence()) {</span>
<span class="nc" id="L310">					listConflicts.add(new BbmScheduleConflict(shift, event));</span>
				}
<span class="nc" id="L312">			}</span>
<span class="nc" id="L313">		}</span>
<span class="nc" id="L314">	}</span>

	protected boolean 	isInstanceForSameFloatingTemplate(CalendarEventAssignment event1, CalendarEventAssignment event2) 
		throws BbmFinderException {
<span class="nc" id="L318">		ID parentID1 = event1.getParentID();</span>
<span class="nc" id="L319">		ID parentID2 = event2.getParentID();</span>
<span class="nc bnc" id="L320" title="All 8 branches missed.">		return parentID1 != null &amp;&amp; parentID2 != null &amp;&amp; parentID1.equals(parentID2) &amp;&amp; isAtLeaseOneFloatingEvent(event1, event2);</span>
	}

	protected boolean isAtLeaseOneFloatingEvent(CalendarEventAssignment event1, CalendarEventAssignment event2) throws BbmFinderException {
<span class="nc" id="L324">		CalendarEventTemplateDAO tplDao = new CalendarEventTemplateDAO(this.m_dmo);</span>
<span class="nc bnc" id="L325" title="All 4 branches missed.">		return isFloatingEvent(event1, tplDao) || isFloatingEvent(event2, tplDao);</span>
	}

	protected boolean isFloatingEvent(CalendarEventAssignment event, CalendarEventTemplateDAO tplDao) throws BbmFinderException {
<span class="nc" id="L329">		ID templateID = event.getEventTemplateID();</span>
<span class="nc bnc" id="L330" title="All 2 branches missed.">		if (templateID != null) {</span>
<span class="nc" id="L331">			short templateType = tplDao.getTemplateTypeByID(templateID);</span>
<span class="nc bnc" id="L332" title="All 4 branches missed.">			if (templateType == CalendarEventTemplate.EVENT_TEMPLATE_FLOATING</span>
				|| templateType == CalendarEventTemplate.EVENT_TEMPLATE_RECURRING_FLOATING) {
<span class="nc" id="L334">				return true;</span>
			}
		}
<span class="nc" id="L337">		return false;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 *
	 * Note: This is an override of the base class function to provide proper
	 * SQL clause for multi-attendee events and appropriate filter on the
	 * EVENTTYPE attribute
	 */
	protected StringBuffer getWhereClauseForGetEventsQuery(int eventTypeBitMask, Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws JdmoException {
<span class="fc" id="L350">		StringBuffer strSQL = getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd);</span>

<span class="pc bpc" id="L352" title="1 of 2 branches missed.">		if (strSQL.length() &gt; 0) {</span>
<span class="fc" id="L353">			strSQL.append(&quot; AND &quot;);</span>
		}
<span class="fc" id="L355">		strSQL.append(&quot;(&quot;);</span>
<span class="fc" id="L356">		strSQL.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask));</span>
<span class="fc" id="L357">		strSQL.append(&quot; )&quot;);</span>
<span class="fc" id="L358">		return strSQL;</span>
	}

	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events for a given set of work resources in a given time period
	 */
	@Override
	protected StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="fc" id="L368">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, false);</span>
	}

	protected StringBuffer getWhereClauseForGetAttendingEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws JdmoException {
<span class="fc" id="L373">		return getWhereClauseForGetEventsQuery(workResourceIDs, dtStart, dtEnd, true);</span>
	}

	private StringBuffer getWhereClauseForGetEventsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd,
			boolean isAttendingOnly) throws JdmoException {

<span class="fc" id="L379">		StringBuffer strSQL = new StringBuffer(200);</span>

<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		if (dtStart != null) {</span>
<span class="fc" id="L382">			strSQL.append(&quot; A.ENDTIME &gt; '&quot; + JdmoUtil.formatDBString(dtStart));</span>
<span class="fc" id="L383">			strSQL.append(&quot;'&quot;);</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">			if (dtEnd != null) {</span>
<span class="fc" id="L385">				strSQL.append(&quot; AND &quot;);</span>
<span class="fc" id="L386">				strSQL.append(&quot; A.STARTTIME &lt; '&quot; + JdmoUtil.formatDBString(dtEnd));</span>
<span class="fc" id="L387">				strSQL.append(&quot;'&quot;);</span>
			}
		}

<span class="fc" id="L391">		addWorkResourceToWhereClause(workResourceIDs, isAttendingOnly, strSQL);</span>

<span class="fc" id="L393">		return strSQL;</span>
	}

	private void addWorkResourceToWhereClause(Collection&lt;ID&gt; workResourceIDs, boolean isAttendingOnly, StringBuffer strSQL)
			throws JdmoException {

<span class="pc bpc" id="L399" title="2 of 4 branches missed.">		if (workResourceIDs == null || workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L400">			return;</span>
		}

		// to enhance the performance. waseem suggests to use temp table to hold
		// all the ids, and join the temp table with calendaeventattendee.
		// the predefined temp table should be used here, if no, oracle ddl will
		// commit the whole transaction
		// after creating or dropping new temp table. so far, IDS is only used
		// here. - fix93583

<span class="pc bpc" id="L410" title="1 of 2 branches missed.">		if (strSQL.length() &gt; 0) {</span>
<span class="fc" id="L411">			strSQL.append(&quot; AND &quot;);</span>
		}

<span class="fc bfc" id="L414" title="All 2 branches covered.">		if (workResourceIDs.size() == 1) {</span>

			//If there is only a single work resource id don't create a temp table
<span class="fc" id="L417">			String whereWorkResource = String.format(&quot; A.ID in  (SELECT CALENDAREVENTASSIGNMENTID FROM CALENDAREVENTATTENDEE &quot; +</span>
<span class="fc" id="L418">					&quot;where CALENDAREVENTATTENDEE.workresourceid = %d &quot;, workResourceIDs.iterator().next().toInt());</span>
<span class="fc" id="L419">			strSQL.append(whereWorkResource);</span>

<span class="fc" id="L421">		} else {</span>

<span class="fc" id="L423">			String strTableName = &quot;IDS&quot;;</span>
<span class="fc" id="L424">			strSQL.append(&quot; A.ID in  (SELECT CALENDAREVENTASSIGNMENTID FROM CALENDAREVENTATTENDEE&quot;);</span>
			// insert ids into temp table
<span class="fc" id="L426">			String tempTableName = m_dmo.insertIDs(strTableName, workResourceIDs);</span>
<span class="fc" id="L427">			strSQL.append(&quot;, &quot;).append(tempTableName).append(&quot; WHERE &quot;).append(tempTableName)</span>
<span class="fc" id="L428">					.append(&quot;.bpid = CALENDAREVENTATTENDEE.workresourceid &quot;);</span>
		}

<span class="fc bfc" id="L431" title="All 2 branches covered.">		if (isAttendingOnly) {</span>
<span class="fc" id="L432">			strSQL.append(&quot;  AND CALENDAREVENTATTENDEE.ISATTENDING = 1 &quot;);</span>
		}
<span class="fc" id="L434">		strSQL.append(&quot;)&quot;);</span>

<span class="fc" id="L436">	}</span>


	/**
	 * Returns the contents of the SQL WHERE clause that is used to fetch the
	 * events that fall within the already published periods for a given set of
	 * work resources in a given time period
	 */
	@Override
	protected StringBuffer getWhereClauseForGetEventsInPublishedPeriodsQuery(Collection&lt;ID&gt; workResourceIDs, Date dtStart,
			Date dtEnd) throws JdmoException {
<span class="nc" id="L447">		StringBuffer strSQL = new StringBuffer();</span>
<span class="nc" id="L448">		strSQL.append(&quot; A.ENDTIME &gt; '&quot;).append(JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L449">		strSQL.append(&quot;' AND &quot;);</span>
<span class="nc bnc" id="L450" title="All 2 branches missed.">		if (dtEnd != null) {</span>
<span class="nc" id="L451">			strSQL.append(&quot; A.STARTTIME &lt; '&quot;).append(JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L452">			strSQL.append(&quot;' AND &quot;);</span>
		}
<span class="nc" id="L454">		strSQL.append(&quot; EXISTS (SELECT 1 &quot;);</span>
<span class="nc" id="L455">		strSQL.append(&quot; FROM PUBLISHINGPERIOD B, CALENDAREVENTATTENDEE C &quot;);</span>
<span class="nc" id="L456">		strSQL.append(&quot; WHERE C.WORKRESOURCEID = B.WORKRESOURCEID AND &quot;);</span>
<span class="nc" id="L457">		strSQL.append(&quot; A.STARTTIME &lt; B.ENDTIME AND &quot;);</span>
<span class="nc" id="L458">		strSQL.append(&quot; A.ENDTIME &gt; B.STARTTIME AND &quot;);</span>
<span class="nc" id="L459">		strSQL.append(&quot; C.WORKRESOURCEID IN &quot;).append(m_dmo.createInClause(workResourceIDs)).append(&quot; AND &quot;);</span>
<span class="nc" id="L460">		strSQL.append(&quot; C.CALENDAREVENTASSIGNMENTID = A.ID) &quot;);</span>
<span class="nc" id="L461">		return strSQL;</span>
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L470">			StringBuffer strSQL = getWhereClauseForGetEventsQuery(eventTypeBitMask, workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L472">			return ScheduleDAOUtil.groupEventsByWorkResources(getObjects(strSQL.toString()), workResourceIDs);</span>
<span class="nc" id="L473">		} catch (JdmoException e) {</span>
<span class="nc" id="L474">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of calendar event assignments fo multiple work
	 * resources The returned collection is a combination of calendar event
	 * assignments created by user manually by placing them on the calendar,
	 * calendar event assignments instantiated from appropriate recurring event
	 * templates as well as floating calendar events
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd) throws BbmFinderException {
		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="fc" id="L491">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L493">		allEvents.add(this.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>

		/*
		 * Note: no need to do floating events separately since they will be
		 * already persisted as records in CALENDAREVENTASSIGNMENT table and
		 * this covered by CalendarEventAssignment DAO
		 */

<span class="fc" id="L501">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="fc" id="L502">		allEvents.add(daoRecurring.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>
<span class="fc" id="L503">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllAttendingEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="fc" id="L508">		return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, true);</span>
	}

	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAttendingEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
		try {
<span class="fc" id="L514">			StringBuffer strSQL = getWhereClauseForGetAttendingEventsQuery(workResourceIDs, dtStart, dtEnd);</span>

<span class="fc" id="L516">			return ScheduleDAOUtil.groupEventsByWorkResources(getObjects(strSQL.toString()), workResourceIDs);</span>
<span class="nc" id="L517">		} catch (JdmoException e) {</span>
<span class="nc" id="L518">			throw new BbmFinderException(e);</span>
		}
	}

	/**
	 * Returns a collection of calendar event assignments fo multiple work
	 * resources The returned collection is a combination of calendar event
	 * assignments created by user manually by placing them on the calendar,
	 * calendar event assignments instantiated from appropriate recurring event
	 * templates as well as floating calendar events
	 */
	public Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd) throws BbmFinderException {
<span class="nc" id="L531">		return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, false);</span>
	}

	private Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd, boolean isAttendingOnly) throws BbmFinderException {
		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="fc" id="L540">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L541" title="All 2 branches covered.">		if (!isAttendingOnly) {</span>
<span class="fc" id="L542">			allEvents.add(this.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
		} else {
<span class="fc" id="L544">			allEvents.add(this.getAttendingEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
		}

		/*
		 * Note: no need to do floating events separately since they will be
		 * already persisted as records in CALENDAREVENTASSIGNMENT table and
		 * this covered by CalendarEventAssignment DAO
		 */

<span class="fc" id="L553">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="fc" id="L554">		allEvents.add(daoRecurring.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd));</span>
<span class="fc" id="L555">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	/**
	 * Locks or unlocks events of a given type for a given set of work resources
	 * and time period
	 */
	public void lockOrUnlockEvents(int eventTypeMask, Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd, boolean bLock, String 
		extraCondition) throws BbmUpdateException {
		try {
<span class="nc" id="L565">			StringBuilder buf = new StringBuilder();</span>
<span class="nc" id="L566">			buf.append(&quot;UPDATE CALENDAREVENTASSIGNMENT &quot;);</span>
<span class="nc bnc" id="L567" title="All 2 branches missed.">			buf.append(&quot;SET ISLOCKED = &quot;).append(bLock ? &quot;1 &quot; : &quot;0 &quot;);</span>
<span class="nc" id="L568">			buf.append(&quot;WHERE (&quot;);</span>
<span class="nc" id="L569">			buf.append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeMask)).append(&quot;)&quot;);</span>
<span class="nc" id="L570">			buf.append(&quot; AND ENDTIME &gt; '&quot;).append(JdmoUtil.formatDBString(dtStart));</span>
<span class="nc" id="L571">			buf.append(&quot;' AND STARTTIME &lt;= '&quot;).append(JdmoUtil.formatDBString(dtEnd));</span>
<span class="nc" id="L572">			buf.append(&quot;' AND ID IN &quot;);</span>
<span class="nc" id="L573">			buf.append(&quot; (SELECT CALENDAREVENTASSIGNMENTID &quot;);</span>
<span class="nc" id="L574">			buf.append(&quot;  FROM CALENDAREVENTATTENDEE &quot;);</span>
<span class="nc" id="L575">			buf.append(&quot;  WHERE WORKRESOURCEID IN &quot;);</span>
<span class="nc" id="L576">			buf.append(m_dmo.createInClause(workResourceIDs)).append(&quot;)&quot;);</span>
<span class="nc bnc" id="L577" title="All 2 branches missed.">			if (extraCondition.trim().length() &gt; 0) {</span>
<span class="nc" id="L578">				buf.append(extraCondition);</span>
			}

<span class="nc" id="L581">			m_dmo.executeCommand(buf.toString());</span>
<span class="nc" id="L582">		} catch (JdmoException e) {</span>
<span class="nc" id="L583">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L584">		}</span>
<span class="nc" id="L585">	}</span>

	/**
	 * This is an override of the base class function Takes the currently
	 * published schedule for the selected employees and time period and
	 * overwrites the current schedule with it.
	 */
	@Override
	public Collection&lt;ID&gt; revertToPublishedSchedule(Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd)
			throws BbmSchedulePublishingException {
		try {
			/* first' we shall delete the current schedule */
<span class="nc" id="L597">			deleteEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>

			// V10SP6 HRF9 Activities are overlapping - ESR#4169926
<span class="nc" id="L600">			RecurringEventTemplateDAO daoRecTemplate = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L601">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; recInstances =</span>
<span class="nc" id="L602">					daoRecTemplate.getEventsForWorkResources(workResourceIDs, dtStart, dtEnd);</span>
<span class="nc" id="L603">			Collection&lt;CalendarEventAssignment&gt; recPerEmp = null;</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">			for (Collection&lt;CalendarEventAssignment&gt; recInstance : recInstances) {</span>
<span class="nc" id="L605">				recPerEmp = recInstance;</span>
<span class="nc bnc" id="L606" title="All 4 branches missed.">				if (recPerEmp != null &amp;&amp; !recPerEmp.isEmpty()) {</span>
<span class="nc bnc" id="L607" title="All 2 branches missed.">					for (CalendarEventAssignment event : recPerEmp) {</span>
<span class="nc" id="L608">						Collection&lt;ID&gt; attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L609">						attendees.retainAll(workResourceIDs);</span>
<span class="nc" id="L610">						daoRecTemplate.deleteRecurringEventInstance(event.getParentID(), attendees, event.getStartTime());</span>
<span class="nc" id="L611">					}</span>
				}
<span class="nc" id="L613">			}</span>

			/* now get all the event assignments from the published schedule */
<span class="nc" id="L616">			CalendarEventAssignmentPubDAO daoPub = getPublishedDAO();</span>
<span class="nc" id="L617">			Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; listPublishedEvents =</span>
<span class="nc" id="L618">					daoPub.getEventsToBeReverted(workResourceIDs, dtStart, dtEnd);</span>

			/*
			 * now that we've got this collection of events, go through and
			 * create copies of objects so that they can be persisted
			 */
<span class="nc" id="L624">			Collection&lt;CalendarEventAssignment&gt; listEventsToCreate = ScheduleDAOUtil.cloneEventsForPublishing(listPublishedEvents);</span>

			/*
			 * remove recurring event instance or exception from published area
			 * to avoid duplication.
			 */
<span class="nc" id="L630">			Collection&lt;ID&gt; recTemplateIDs = new HashSet&lt;&gt;();</span>
<span class="nc" id="L631">			JdmoRowset rs = m_dmo.createRowset(&quot;SELECT ID FROM RECURRINGEVENTTEMPLATE&quot;);</span>
<span class="nc bnc" id="L632" title="All 2 branches missed.">			while (rs.next()) {</span>
<span class="nc" id="L633">				recTemplateIDs.add(rs.getID(1));</span>
			}

<span class="nc" id="L636">			Set&lt;CalendarEventAssignment&gt; recInstanceToMakeHole = new HashSet&lt;CalendarEventAssignment&gt;(recTemplateIDs.size());</span>
			// remove attendee that is not in the revert list
<span class="nc" id="L638">			CalendarEventAssignment cea = null;</span>
<span class="nc bnc" id="L639" title="All 2 branches missed.">			for (CalendarEventAssignment aListEventsToCreate : listEventsToCreate) {</span>
<span class="nc" id="L640">				cea = aListEventsToCreate;</span>
<span class="nc bnc" id="L641" title="All 4 branches missed.">				if (cea.getParentID() != null &amp;&amp; recTemplateIDs.contains(cea.getParentID())) {</span>
<span class="nc" id="L642">					recInstanceToMakeHole.add(cea);</span>
				}
<span class="nc" id="L644">				Collection&lt;CalendarEventAttendee&gt; attendees = cea.getChildObjects(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc bnc" id="L645" title="All 2 branches missed.">				for (CalendarEventAttendee attendee : attendees) {</span>
<span class="nc" id="L646">					ID wrkrId = attendee.getWorkResourceID();</span>
<span class="nc bnc" id="L647" title="All 2 branches missed.">					if (workResourceIDs.contains(wrkrId)) {</span>
<span class="nc" id="L648">						cea.deleteChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, attendee.getID());</span>
					}
<span class="nc" id="L650">				}</span>
<span class="nc" id="L651">			}</span>

			/*
			 * Now persist the given collection of published events to the
			 * current schedule
			 */
<span class="nc" id="L657">			Collection&lt;ID&gt; eventIds = createObjects(listEventsToCreate);</span>

			/*
			 * update the publishingperiod's publishtime, make it now. that
			 * means the schedule is sync with publish
			 */
<span class="nc" id="L663">			PublishingPeriodDAO daoPubPeriod = new PublishingPeriodDAO(m_dmo);</span>
<span class="nc" id="L664">			daoPubPeriod.publishPeriods(workResourceIDs, dtStart, dtEnd);</span>

			// if recurring instance was reverted back, have to make a hole
<span class="nc bnc" id="L667" title="All 2 branches missed.">			for (CalendarEventAssignment event : recInstanceToMakeHole) {</span>
<span class="nc" id="L668">				Collection&lt;ID&gt; attendees = event.getWorkResourceIDs();</span>
<span class="nc" id="L669">				attendees.retainAll(workResourceIDs);</span>
<span class="nc" id="L670">				daoRecTemplate.deleteRecurringEventInstance(event.getParentID(), attendees, event.getStartTime());</span>
<span class="nc" id="L671">			}</span>

<span class="nc" id="L673">			return eventIds;</span>
<span class="nc" id="L674">		} catch (JdmoException | BbmException e) {</span>
<span class="nc" id="L675">			throw new BbmSchedulePublishingException(e);</span>
		}
	}

	/**
	 * This is a helper function only used internally by the schedule access
	 * manager EJB
	 */
	public Collection&lt;CalendarEventAssignment&gt; getEventsByTemplateID(ID templateID) throws BbmFinderException {
<span class="nc" id="L684">		return getObjects(&quot;CALENDAREVENTTEMPLATEID = &quot; + templateID);</span>
	}

	/** This is an override of the base class function */
	@Override
	protected Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getEventsToBePublished(Collection&lt;ID&gt; workResourceIDs,
			Date dtStart, Date dtEnd, boolean bPublishedPeriodsOnly) throws BbmFinderException {
<span class="pc bpc" id="L691" title="1 of 2 branches missed.">		if (!bPublishedPeriodsOnly) {</span>
<span class="fc" id="L692">			return getAllEventsForWorkResources(workResourceIDs, dtStart, dtEnd, false);</span>
		} else {
			/*
			 * iterate through the possible DAO types that get all possible
			 * types of event assignments
			 */
<span class="nc" id="L698">			Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L699">			allEvents.add(this.getEventsForWorkResourcesInPublishedPeriodsOnly(workResourceIDs, dtStart, dtEnd));</span>

			/*
			 * Note: no need to do floating events separately since they will be
			 * already persisted as records in CALENDAREVENTASSIGNMENT table and
			 * this covered by CalendarEventAssignment DAO
			 */
<span class="nc" id="L706">			RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L707">			allEvents.add(daoRecurring.getEventsToBePublishedInPublishedPeriodsOnly(workResourceIDs, dtStart, dtEnd));</span>
<span class="nc" id="L708">			return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
		}
	}

	// override the method defined in DAONode
	@Override
	public void updateObject(CalendarEventAssignment eventAssignment) throws MultiUserException, BbmUpdateException {
<span class="nc bnc" id="L715" title="All 2 branches missed.">		if (eventAssignment.isFieldValueSet(CalendarEventAssignmentFields.STARTTIME) &amp;&amp; eventAssignment.isFieldValueSet</span>
<span class="nc bnc" id="L716" title="All 2 branches missed.">			(CalendarEventAssignmentFields.DURATION)) {</span>
<span class="nc" id="L717">			eventAssignment.setFieldValue(CalendarEventAssignmentFields.ENDTIME, new Date(eventAssignment.getStartTime().getTime() + </span>
<span class="nc" id="L718">				eventAssignment.getDuration() * ShiftAssignment.MILLIS_IN_ONE_MIN));</span>
		}

<span class="nc" id="L721">		super.updateObject(eventAssignment);</span>
<span class="nc" id="L722">	}</span>

	public static String getEventTypeWhereClause(int eventTypeBitMask) {
<span class="fc" id="L725">		StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L726">		List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L727" title="1 of 2 branches missed.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT) != 0) {</span>
<span class="fc" id="L728">			list.add(Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT);</span>
		}
<span class="pc bpc" id="L730" title="1 of 2 branches missed.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_TIME_OFF) != 0) {</span>
<span class="fc" id="L731">			list.add(Event.EVENT_TYPE_TIME_OFF);</span>
		}
<span class="pc bpc" id="L733" title="1 of 2 branches missed.">		if ((eventTypeBitMask &amp; Event.EVENT_TYPE_UNAVAILABILITY) != 0) {</span>
<span class="fc" id="L734">			list.add(Event.EVENT_TYPE_UNAVAILABILITY);</span>
		}

<span class="fc bfc" id="L737" title="All 2 branches covered.">		for (Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();) {</span>
<span class="fc" id="L738">			Integer type = i.next();</span>
<span class="fc" id="L739">			sb.append(&quot;EVENTTYPE = &quot;).append(type.intValue());</span>
<span class="fc bfc" id="L740" title="All 2 branches covered.">			if (i.hasNext()) {</span>
<span class="fc" id="L741">				sb.append(&quot; OR &quot;);</span>
			}
<span class="fc" id="L743">		}</span>
<span class="fc" id="L744">		return sb.toString();</span>
	}

	@Deprecated
	// Tample:Add for QA 85638:START
	/**
	 * Deletes the entries in CalendarEventAttendee for the Ids passed and
	 * CalendarEventAssignment is deleted only if there are no entries in
	 * CalendarEventAssignment
	 */
	public void deleteObjects(Collection&lt;ID&gt; colIDs, Collection&lt;ID&gt; idsExistingInAttendee) throws BbmRemoveException {

		try {
<span class="nc" id="L757">			StringBuilder stmt = new StringBuilder();</span>

<span class="nc bnc" id="L759" title="All 6 branches missed.">			if (!(idsExistingInAttendee == null || idsExistingInAttendee.isEmpty() || colIDs == null || colIDs</span>
<span class="nc bnc" id="L760" title="All 2 branches missed.">					.isEmpty())) {</span>
				// delete child records in CalendarEventAttendee first
<span class="nc" id="L762">				stmt.append(&quot;DELETE CALENDAREVENTATTENDEE WHERE WORKRESOURCEID IN &quot;).append(m_dmo.createInClause(idsExistingInAttendee))</span>
<span class="nc" id="L763">					.append(&quot; AND CALENDAREVENTASSIGNMENTID IN&quot;).append(m_dmo.createInClause(colIDs));</span>
<span class="nc" id="L764">				m_dmo.execute(stmt.toString());</span>
			}
			// delete records in CalendarEventAssignmentPub only if no record
			// exists for the event in attendee
<span class="nc bnc" id="L768" title="All 4 branches missed.">			if (colIDs == null || colIDs.isEmpty()) {</span>
<span class="nc" id="L769">				return;</span>
			}

<span class="nc" id="L772">			stmt = new StringBuilder();</span>
<span class="nc" id="L773">			stmt.append(&quot;DELETE CALENDAREVENTASSIGNMENT WHERE ID &quot; + &quot; IN &quot;).append(m_dmo.createInClause(colIDs)).append(&quot; AND NOT EXISTS &quot; +</span>
				&quot;&quot; + &quot;(SELECT 1 FROM CALENDAREVENTATTENDEE WHERE CALENDAREVENTATTENDEE.CALENDAREVENTASSIGNMENTID = CALENDAREVENTASSIGNMENT&quot; +
				&quot;.ID)&quot;);

<span class="nc" id="L777">			m_dmo.execute(stmt.toString());</span>

<span class="nc" id="L779">		} catch (Exception ex) {</span>
<span class="nc" id="L780">			new BbmRemoveException(ex);</span>
<span class="nc" id="L781">		}</span>
<span class="nc" id="L782">	}</span>

	@Deprecated
	// the following two methods has the same logic in
	// getconflictsforscheduleobject api.
	public BbmScheduleConflict getConflict(CalendarEventAssignment event1, Collection&lt;CalendarEventAssignment&gt; overlapEvents, boolean 
		isNewObject) throws BbmFinderException {
<span class="nc bnc" id="L789" title="All 2 branches missed.">		for (CalendarEventAssignment event2 : overlapEvents) {</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">			if (isInstanceForSameFloatingTemplate(event1, event2)) {</span>
<span class="nc" id="L791">				return null;</span>
			}
<span class="nc bnc" id="L793" title="All 6 branches missed.">			if ((isNewObject || event1.getID() == null || !event1.getID().equals(event2.getID())) &amp;&amp; event1.getOverlayPrecedence() == </span>
<span class="nc bnc" id="L794" title="All 2 branches missed.">				event2.getOverlayPrecedence()) {</span>
<span class="nc" id="L795">				Collection&lt;ID&gt; workResourceIDs = event1.getWorkResourceIDs();</span>
<span class="nc" id="L796">				workResourceIDs.retainAll(event2.getWorkResourceIDs());</span>
<span class="nc bnc" id="L797" title="All 2 branches missed.">				if (!workResourceIDs.isEmpty()) {</span>
<span class="nc" id="L798">					return new BbmScheduleConflict(event1, event2);</span>
				}
			}
<span class="nc" id="L801">		}</span>
<span class="nc" id="L802">		return null;</span>
	}

	public BbmScheduleConflict getConflict(CalendarEventAssignment event, Collection&lt;ShiftAssignment&gt; overlapShifts) {
<span class="nc bnc" id="L806" title="All 2 branches missed.">		for (ShiftAssignment shift : overlapShifts) {</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">			if (shift.getOverlayPrecedence() == event.getOverlayPrecedence()) {</span>
<span class="nc" id="L808">				return new BbmScheduleConflict(shift, event);</span>
			}
<span class="nc" id="L810">		}</span>
<span class="nc" id="L811">		return null;</span>
	}

	/**
	 * Returns a collection of schedule events for multiple work resources
	 */
	public List&lt;Collection&lt;CalendarEventAssignment&gt;&gt; getAllEventsForWorkResources(int eventTypeBitMask,
			Collection&lt;ID&gt; workResourceIDs, Date dtStart, Date dtEnd, String strNativeTempName) throws BbmFinderException {

		/*
		 * iterate through the possible DAO types that get all possible types of
		 * event assignments
		 */
<span class="nc" id="L824">		Collection&lt;Collection&lt;Collection&lt;CalendarEventAssignment&gt;&gt;&gt; allEvents = new ArrayList&lt;&gt;();</span>

<span class="nc" id="L826">		StringBuilder strSQL = new StringBuilder();</span>
<span class="nc" id="L827">		strSQL.append(&quot; calendareventassignmentid in (select c.id from calendareventassignment c , calendareventattendee a, &quot;).append</span>
<span class="nc" id="L828">			(strNativeTempName).append(&quot; t where c.id = a.calendareventassignmentid and a.workresourceid = t.workresourceid and c&quot; + &quot;&quot; +</span>
<span class="nc" id="L829">			&quot;.starttime &lt; t.endtime and c.endtime &gt; t.starttime and (&quot;).append(CalendarEventAssignmentDAO.getEventTypeWhereClause</span>
<span class="nc" id="L830">			(eventTypeBitMask)).append(&quot;))&quot;);</span>
<span class="nc" id="L831">		CalendarEventAttendeeDAO dao = (CalendarEventAttendeeDAO) createChildDAO(CalendarEventAssignmentFields.CHILD_ATTENDEE);</span>
<span class="nc" id="L832">		Collection&lt;CalendarEventAttendee&gt; caAttendees = dao.getObjects(strSQL.toString());</span>

<span class="nc" id="L834">		Map&lt;ID, List&lt;CalendarEventAttendee&gt;&gt; attendeeMap = new HashMap&lt;&gt;();</span>
		List&lt;CalendarEventAttendee&gt; attendeeList;
<span class="nc bnc" id="L836" title="All 2 branches missed.">		for (CalendarEventAttendee caAttendee : caAttendees) {</span>
<span class="nc" id="L837">			ID eventID = caAttendee.getParentID();</span>
<span class="nc" id="L838">			attendeeList = attendeeMap.computeIfAbsent(eventID, k -&gt; new ArrayList&lt;&gt;());</span>
<span class="nc" id="L839">			attendeeList.add(caAttendee);</span>
<span class="nc" id="L840">		}</span>

<span class="nc" id="L842">		strSQL = new StringBuilder();</span>
<span class="nc" id="L843">		strSQL.append(&quot; id in (select c.id from calendareventassignment c , calendareventattendee a, &quot;).append(strNativeTempName).append</span>
<span class="nc" id="L844">			(&quot;&quot; + &quot; t where c.id = a.calendareventassignmentid and a.workresourceid = t.workresourceid and c.starttime &lt; t.endtime and c&quot; +</span>
<span class="nc" id="L845">				&quot;.endtime&quot; + &quot; &gt; t.starttime and (&quot;).append(CalendarEventAssignmentDAO.getEventTypeWhereClause(eventTypeBitMask)).append</span>
<span class="nc" id="L846">			(&quot;))&quot;);</span>
<span class="nc" id="L847">		Collection&lt;CalendarEventAssignment&gt; caEvents = getObjectsWithoutChild(strSQL.toString());</span>
<span class="nc bnc" id="L848" title="All 2 branches missed.">		for (CalendarEventAssignment caEvent : caEvents) {</span>
<span class="nc" id="L849">			attendeeList = attendeeMap.get(caEvent.getID());</span>
<span class="nc bnc" id="L850" title="All 2 branches missed.">			if (attendeeList != null) {</span>
<span class="nc bnc" id="L851" title="All 2 branches missed.">				for (CalendarEventAttendee anAttendeeList : attendeeList) {</span>
<span class="nc" id="L852">					caEvent.fillChildObject(CalendarEventAssignmentFields.CHILD_ATTENDEE, anAttendeeList);</span>
<span class="nc" id="L853">				}</span>
			}
<span class="nc" id="L855">		}</span>

<span class="nc" id="L857">		allEvents.add(ScheduleDAOUtil.groupEventsByWorkResources(caEvents, workResourceIDs));</span>

<span class="nc" id="L859">		RecurringEventTemplateDAO daoRecurring = new RecurringEventTemplateDAO(m_dmo);</span>
<span class="nc" id="L860">		allEvents.add(daoRecurring.getEventsForWorkResources(eventTypeBitMask, workResourceIDs, dtStart, dtEnd));</span>

<span class="nc" id="L862">		return ScheduleDAOUtil.combineEventCollections(workResourceIDs, allEvents);</span>
	}

	protected Collection&lt;ID&gt; getCalendarEventAssignmentsForSelectedActivities(Collection&lt;ID&gt; colWorkResourceIDs,
		Date start, Date end, Collection&lt;ID&gt; activityIDs) throws JdmoException {

<span class="nc" id="L868">		Collection&lt;ID&gt; ids = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L869">		StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L870">		sb.append(&quot;SELECT A.ID FROM CALENDAREVENTASSIGNMENT A WHERE &quot;);</span>
<span class="nc bnc" id="L871" title="All 4 branches missed.">		if (activityIDs != null &amp;&amp; !activityIDs.isEmpty()) {</span>
<span class="nc" id="L872">			sb.append(&quot; A.ACTIVITYID IN &quot;).append(m_dmo.createInClause(activityIDs)).append(&quot; AND &quot;);</span>
		}
<span class="nc" id="L874">		sb.append(getWhereClauseForGetEventsQuery(colWorkResourceIDs, start, end).toString() );</span>

<span class="nc" id="L876">		JdmoRowset rs = m_dmo.createRowset(sb.toString());</span>
<span class="nc bnc" id="L877" title="All 2 branches missed.">		while(rs.next()) {</span>
<span class="nc" id="L878">			ids.add(rs.getID(1));</span>
		}

<span class="nc" id="L881">		return ids;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>