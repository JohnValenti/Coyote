<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ErlangA.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">ErlangA.java</span></div><h1>ErlangA.java</h1><pre class="source lang-java linenums">/*
 * ï¿½ 2012 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import org.apfloat.Apfloat;
import org.apfloat.ApfloatMath;

/**
 * An abandoned port of C++ code that was supposed to take abandons into account in 
 * FTE calculations.  Its only remaining use is to look for places where the C++
 * calculations would get the wrong result.
 */
public class ErlangA {
	// This means that multiprecision calculations are being done to 16 significant figures.
	// This is more than adequate for staffing requirements for large workloads but it is
	// important to remember that our calculations are not exact.
	private static final int MULTIPRECISION_PRECISION = 200;
	// We use an erlangC instance to help with some abandonment calculations.
	private final double[] m_factorialLogs;
	private static final int NUM_TRUNKS = 6000;
	private static final int MAX_NUM_ERLANGS = 5000;
<span class="nc" id="L23">public double min_exponent = -1000;</span>
<span class="nc" id="L24">public double max_exponent = 1000;</span>
<span class="nc" id="L25">public double min_sMuOneMinusG = 100000;</span>
<span class="nc" id="L26">public double max_sMuOneMinusG = -100000;</span>

<span class="nc" id="L28">	private static final ErlangA INSTANCE = new ErlangA();</span>

	/**
	 * Returns an instance of ErlangA with an absolute maximum of 5000 agents.
	 * 
	 * There is no reason for this limit other than it's the same limit the C++
	 * client used for the largest organizations.  It would be smart to see if
	 * any performance problems arise at higher limits, and consider increasing
	 * this number still further.
	 * 
	 * @return
	 */
	public static ErlangA getInstance()
	{
<span class="nc" id="L42">		return INSTANCE;</span>
	}

	private ErlangA()
<span class="nc" id="L46">	{</span>
<span class="nc" id="L47">		m_factorialLogs = FactorialUtil.createLowPrecisionFactorialLogTable(NUM_TRUNKS);</span>
<span class="nc" id="L48">	}</span>

	/**
	 * Calculates the natural log of the gamma function.  The gamma function G(x) is
	 * similar to the factorial function in that G(x) = (x-1)! for integer x &gt; 0.
	 * &lt;p/&gt;
	 * Corresponds to the method gammln in erlanga.cpp.
	 * &lt;p/&gt;
	 * Based on the function gammln in &lt;i&gt;Numerical Recipes in C: The Art of Scientific
	 * Computing, Second Edition&lt;/i&gt;, ISBN 978-0521431088, Section 6.1.
	 * 
	 * @param x
	 * @return
	 */
	public double getLnGamma(double x) { 
<span class="nc" id="L63">		double[] cof = {</span>
				76.18009172947146,
				-86.50532032941677,
				24.01409824083091,
				-1.231739572450155,
				0.1208650973866179e-2,
				-0.5395239384953e-5};
<span class="nc" id="L70">		double y = x;</span>
<span class="nc" id="L71">		double tmp = x + 5.5;</span>
<span class="nc" id="L72">		tmp -= (x + 0.5)*Math.log(tmp);</span>
<span class="nc" id="L73">		double summation = 1.000000000190015;</span>
<span class="nc bnc" id="L74" title="All 2 branches missed.">		for (int j = 0; j &lt; cof.length; j++) {</span>
<span class="nc" id="L75">			summation += cof[j]/++y;</span>
		}
<span class="nc" id="L77">		return -tmp + Math.log(2.5066282746310005*summation/x);</span>
	}

	/**
	 * Returns what Numerical Recipes calls the incomplete gamma function P(a,x) which
	 * is equal to gamma(a,x)/GAMMA(a) where gamma(a,x) is what 
	 * Corresponds to the method gser in erlanga.cpp.
	 * &lt;p/&gt;
	 * Based on the function gser in &lt;i&gt;Numerical Recipes in C: The Art of Scientific
	 * Computing, Second Edition&lt;/i&gt;, ISBN 978-0521431088, Section 6.2.
	 * 
	 * @param a
	 * @param x
	 * @return
	 */
	private double approximateIncompleteGammaWithSeries(double a, double x) {   
<span class="nc" id="L93">		int maxIterations = Math.max(100, (int)Math.min(x, a)) ;</span>
<span class="nc" id="L94">		double epsilon = 3.0e-7;</span>

<span class="nc bnc" id="L96" title="All 2 branches missed.">		if (x &lt;= 0.0) {</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">			if (x &lt; 0.0) {</span>
<span class="nc" id="L98">				throw new IllegalArgumentException(&quot;Cannot calculate gamma(a,x) with x &lt; 0&quot;);</span>
			} else {
<span class="nc" id="L100">				return 0.0;</span>
			}
		} else {
<span class="nc" id="L103">			double gln = getLnGamma(a);</span>
<span class="nc" id="L104">			double ap = a;</span>
<span class="nc" id="L105">			double sum = 1.0/a;</span>
<span class="nc" id="L106">			double delta = sum;</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">			for (int n = 1; n &lt;= maxIterations; n++) {</span>
<span class="nc" id="L108">				ap += 1.0;</span>
<span class="nc" id="L109">				delta *= x/ap;</span>
<span class="nc" id="L110">				sum += delta;</span>
<span class="nc bnc" id="L111" title="All 2 branches missed.">				if (Math.abs(delta) &lt; Math.abs(sum)*epsilon) {</span>
<span class="nc" id="L112">					return sum * Math.exp(-x + a*Math.log(x) - gln);</span>
				}
			}
<span class="nc" id="L115">			throw new IllegalArgumentException(&quot;Unable to calculate gamma(a,x) to within &quot; + epsilon + &quot; within &quot; +  maxIterations + &quot; iterations&quot;);</span>
		}
	}

	/**
	 * Corresponds to the method gcf in erlanga.cpp.
	 * &lt;p/&gt;
	 * Based on the function gcf in &lt;i&gt;Numerical Recipes in C: The Art of Scientific
	 * Computing, Second Edition&lt;/i&gt;, ISBN 978-0521431088, Section 6.2.
	 * 
	 * @param a
	 * @param x
	 * @return
	 */
	private double approximateIncompleteGammaWithContinuedFraction(double a,double x) { 

<span class="nc" id="L131">		final int maxIterations = 100;</span>
<span class="nc" id="L132">		final double epsilon = 3.0e-7;</span>
<span class="nc" id="L133">		double gOld = 0.0, g, fac = 1.0, b1 = 1.0;</span>
<span class="nc" id="L134">		double b0 = 0.0, a0 = 1.0;</span>
		
<span class="nc" id="L136">		double gln = getLnGamma(a);</span>
<span class="nc" id="L137">		double a1 = x;</span>
<span class="nc bnc" id="L138" title="All 2 branches missed.">		for (int n = 1; n &lt;= maxIterations; n++) {</span>
<span class="nc" id="L139">			double ana = n - a;</span>
<span class="nc" id="L140">			a0 = (a1 + a0*ana)*fac;</span>
<span class="nc" id="L141">			b0 = (b1 + b0*ana)*fac;</span>
<span class="nc" id="L142">			double anf = n*fac;</span>
<span class="nc" id="L143">			a1 = x*a0 + anf*a1;</span>
<span class="nc" id="L144">			b1 = x*b0 + anf*b1;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">			if (a1 != 0) {</span>
<span class="nc" id="L146">				fac = 1.0/a1;</span>
<span class="nc" id="L147">				g = b1*fac;</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">				if (Math.abs((g - gOld)/g) &lt; epsilon) {</span>
<span class="nc" id="L149">					return Math.exp(-x+a*Math.log(x)-(gln))*g;</span>
				}
<span class="nc" id="L151">				gOld = g;</span>
			}
		}
<span class="nc" id="L154">		throw new IllegalArgumentException(&quot;Unable to calculate gamma(a,x) to within &quot; + epsilon + &quot; within &quot; +  maxIterations + &quot; iterations&quot;);</span>
	}

	/**
	 * Returns the incomplete gamma function P(a,x) = g(a,x) / G(a),
	 * where g(a,x) is what is referred to in some literature as the
	 * incomplete Gamma function Integral(0,x) of (e^(-t))(t^(a-1))dt and
	 * G(a) is the Gamma function Integral(0,infinity) of (e^(-t))(t^(a-1))dt.
	 * &lt;p/&gt; 
	 * Corresponds to the method gammp in erlanga.cpp.
	 * &lt;p/&gt;
	 * Originally ported from the function gammp in &lt;i&gt;Numerical Recipes in FORTRAN 77:
	 * The Art of Scientific Computing&lt;/i&gt;, ISBN 9780521430647, Section 6.2.
	 * 
	 * @param a
	 * @param x
	 * @return
	 */
	private double getIncompleteGamma(double a, double x) {
<span class="nc bnc" id="L173" title="All 4 branches missed.">		if (x &lt; 0.0 || a &lt;= 0.0) {</span>
<span class="nc" id="L174">			throw new IllegalArgumentException(&quot;getIncompleteGamma(a=&quot; + a + &quot;, x=&quot; + x + &quot;): x must be nonnegative and a must be positive.&quot;);</span>
		}
<span class="nc bnc" id="L176" title="All 2 branches missed.">		if (x &lt; (a + 1.0)) {</span>
<span class="nc" id="L177">			return approximateIncompleteGammaWithSeries(a, x);</span>
		} else {
<span class="nc" id="L179">			return 1.0 - approximateIncompleteGammaWithContinuedFraction(a, x);</span>
		}
	}

	/**
	 * Corresponds to the method genfx in erlanga.cpp.
	 * 
	 * @param x
	 * @param p
	 * @param s
	 * @param trunks
	 * @param lambda
	 * @param mu
	 * @param theta
	 * @param out
	 */
	private void genFx(
			double x,
			double p,
			int s,
			int trunks,
			double lambda,
			double mu,
			double theta,
			double[] out) {
		//DHM: Verify this before believing it.  No one knows who &quot;YN&quot; is.
		//YN: this function performs one step of numerical integration.
		//YN: note that on every step 3 integrals are calculated simultaneously
		//YN: the introduction of g allows using this function for both finite and
		//YN: infinite buffers, although the density function is different

		double g;

<span class="nc bnc" id="L212" title="All 2 branches missed.">		if (trunks == 0) {</span>
<span class="nc" id="L213">			g = 0.0;</span>
		} else {
<span class="nc" id="L215">			g = getIncompleteGamma(trunks - s, (lambda / theta) * (1 - Math.exp(-theta*p)));</span>
		}

		double out1;
		double out2;
		double out3;

<span class="nc" id="L222">		double exponent = (lambda/theta) * (1 - Math.exp(-theta*p)) - s*mu*p;</span>
<span class="nc bnc" id="L223" title="All 2 branches missed.">if (exponent &lt; min_exponent) {</span>
<span class="nc" id="L224">	min_exponent = exponent;</span>
<span class="nc" id="L225">	System.out.println(&quot;New min exponent &quot; + exponent);</span>
}
<span class="nc bnc" id="L227" title="All 2 branches missed.">if (exponent &gt; max_exponent) {</span>
<span class="nc" id="L228">	max_exponent = exponent;</span>
<span class="nc" id="L229">	System.out.println(&quot;New max exponent &quot; + exponent);</span>
}

		// In practice I was getting Double.Infinity when exponent was about 702.
<span class="nc bnc" id="L233" title="All 2 branches missed.">		if (exponent &lt; 650) {</span>
<span class="nc" id="L234">			out1 = s * mu * (1 - g) * Math.exp(exponent);</span>
<span class="nc" id="L235">			out2 = Math.exp(-theta*p) * out1;</span>
<span class="nc" id="L236">			out3 = p * out2;</span>
		} else {
<span class="nc bnc" id="L238" title="All 2 branches missed.">if (s * mu * (1 - g) &lt;  min_sMuOneMinusG) {</span>
<span class="nc" id="L239">	min_sMuOneMinusG = s * mu * (1 - g);</span>
<span class="nc" id="L240">	System.out.println(&quot;New min s * mu * (1 - g) : &quot; + min_sMuOneMinusG);</span>
}
<span class="nc bnc" id="L242" title="All 2 branches missed.">if (s * mu * (1 - g) &gt;  max_sMuOneMinusG) {</span>
<span class="nc" id="L243">	max_sMuOneMinusG = s * mu * (1 - g);</span>
<span class="nc" id="L244">	System.out.println(&quot;New max s * mu * (1 - g) : &quot; + max_sMuOneMinusG);</span>
}
<span class="nc" id="L246">			Apfloat mpfOut1 = new Apfloat(s * mu * (1 - g)).multiply(ApfloatMath.exp(new Apfloat(exponent)));</span>
<span class="nc" id="L247">			Apfloat mpfOut2 = mpfOut1.multiply(new Apfloat(Math.exp(-theta*p), MULTIPRECISION_PRECISION));</span>
<span class="nc" id="L248">			Apfloat mpfOut3 = mpfOut2.multiply(new Apfloat(p));</span>

			// This is just silly.  We used Apfloat to avoid numeric overflow because of
			// a huge exponent, so now we're putting the results right back into double
			// variables.  That is pretty much guaranteed to fail.
<span class="nc" id="L253">			out1 = mpfOut1.doubleValue();</span>
<span class="nc" id="L254">			out2 = mpfOut2.doubleValue();</span>
<span class="nc" id="L255">			out3 = mpfOut3.doubleValue();</span>
		}
<span class="nc" id="L257">		out[0] = x*out1;</span>
<span class="nc" id="L258">		out[1] = x*out2;</span>
<span class="nc" id="L259">		out[2] = x*out3;</span>
<span class="nc" id="L260">boolean errorFlag = false;</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">if (Double.isInfinite(out1)) {</span>
<span class="nc" id="L262">	System.out.println(&quot;out1 is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L263">	errorFlag = true;</span>
}
<span class="nc bnc" id="L265" title="All 2 branches missed.">if (Double.isInfinite(out2)) {</span>
<span class="nc" id="L266">	System.out.println(&quot;out2 is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L267">	errorFlag = true;</span>
}
<span class="nc bnc" id="L269" title="All 2 branches missed.">if (Double.isInfinite(out3)) {</span>
<span class="nc" id="L270">	System.out.println(&quot;out3 is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L271">	errorFlag = true;</span>
}
<span class="nc bnc" id="L273" title="All 2 branches missed.">if (Double.isInfinite(out[0])) {</span>
<span class="nc" id="L274">	System.out.println(&quot;out[0] is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L275">	errorFlag = true;</span>
}
<span class="nc bnc" id="L277" title="All 2 branches missed.">if (Double.isInfinite(out[1])) {</span>
<span class="nc" id="L278">	System.out.println(&quot;out[1] is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L279">	errorFlag = true;</span>
}
<span class="nc bnc" id="L281" title="All 2 branches missed.">if (Double.isInfinite(out[2])) {</span>
<span class="nc" id="L282">	System.out.println(&quot;out[2] is infinite!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;);</span>
<span class="nc" id="L283">	errorFlag = true;</span>
}
<span class="nc bnc" id="L285" title="All 2 branches missed.">if (errorFlag) {</span>
<span class="nc" id="L286">	System.out.println(&quot;&gt;&gt;&gt;&gt; x=&quot; + x + &quot;, p=&quot; + p + &quot;, s=&quot; + s + &quot;, trunks=&quot; + trunks + &quot;, lambda=&quot; + lambda + &quot;, mu=&quot; + mu + &quot;, theta=&quot; + theta);</span>
}
<span class="nc" id="L288">	}</span>

	/**
	 * Corresponds to the function compute_asa in erlanga.cpp.
	 * 
	 * @param s number of agents
	 * @param trunks total number of lines; (trunks - s) of those lines are queue 
	 * @param lambda arrival rate
	 * @param tau average handling time
	 * @param abandonsPerSecond abandons per second (1 / patience)
	 * @param stages 1/the number of intervals we are from the beginning, I think
	 * @return
	 */
	private double computeAsa(
			final int s,
			final int trunks,
			final double lambda,
			final double tau,
			final double abandonsPerSecond) {
//System.out.println(&quot;computeAsa(&quot; + trunks + &quot;, &quot; + lambda + &quot;, &quot; + tau + &quot;, &quot; + abandonsPerSecond + &quot;)&quot;);
<span class="nc" id="L308">		double stages = 1/35.0; // model steady state</span>
<span class="nc" id="L309">		double workload = lambda * tau;</span>
<span class="nc bnc" id="L310" title="All 4 branches missed.">		if (workload &gt; 0 &amp;&amp; s == 0) {</span>
<span class="nc" id="L311">			throw new IllegalArgumentException(&quot;computeAsa: No agents and non-zero workload&quot;);</span>
		}
<span class="nc bnc" id="L313" title="All 2 branches missed.">		if (trunks == s) {</span>
<span class="nc" id="L314">			return 0.0;</span>
		}
<span class="nc bnc" id="L316" title="All 4 branches missed.">		if ((trunks &gt; 0) &amp;&amp; (trunks &lt; s)) {</span>
<span class="nc" id="L317">			throw new IllegalArgumentException(&quot;computeAsa: Fewer trunks than agents: &quot; + trunks + &quot; &lt; &quot; + s);</span>
		}
<span class="nc bnc" id="L319" title="All 4 branches missed.">		if ((workload &lt; 1000.0) &amp;&amp; (s &lt; workload * 0.5)) {</span>
			// return an ASA that is obviously unacceptable (3 * patience)
<span class="nc" id="L321">			return 3/abandonsPerSecond;</span>
		}
<span class="nc bnc" id="L323" title="All 6 branches missed.">		if ((1000.0 &lt;= workload) &amp;&amp; (workload &lt; 1500.0) &amp;&amp; (s &lt; workload * 0.75)) {</span>
			// return an ASA that is obviously unacceptable (3 * patience)
<span class="nc" id="L325">			return 3/abandonsPerSecond;</span>
		}
<span class="nc bnc" id="L327" title="All 4 branches missed.">		if ((1500 &lt;= workload) &amp;&amp; (s &lt; workload * 0.9)) {</span>
			// return an ASA that is obviously unacceptable (3 * patience)
<span class="nc" id="L329">			return 3/abandonsPerSecond;</span>
		}
<span class="nc bnc" id="L331" title="All 4 branches missed.">		if ((s &lt;= 0) || (s &gt; MAX_NUM_ERLANGS)) {</span>
<span class="nc" id="L332">			throw new IllegalArgumentException(&quot;Invalid number of agents &quot; + s);</span>
		}

<span class="nc" id="L335">		double theta = stages*abandonsPerSecond;</span>
		// All calls are answered immediately when there's no workload.
<span class="nc bnc" id="L337" title="All 2 branches missed.">		if (workload == 0) {</span>
<span class="nc" id="L338">			return 0.0;</span>
		}

		// Intermediate calculations are done using logarithms to avoid overflow
<span class="nc" id="L342">		double ln_workload = Math.log(workload);</span>

		//YN: Find the cutoff - that's what we take as 
		//YN: infinity in our integrations. note that for infinite buffer
		//YN: (trnks==0), cutoff is always cutoff 1, as there is only one 
		//YN: integrand in fv(t). elsewhere, there are two integrands, so 
		//YN: the cutoff has to make sure that both integrands are small enough
		//YN: hence the minimum.
<span class="nc" id="L350">		double cutoff1 = (lambda*stages/theta + 10.0)*tau/s;</span>
<span class="nc" id="L351">		double cutoff2 = ((trunks - s)*2 + 10.0)/lambda;</span>
<span class="nc" id="L352">		double cutoff = Math.min(cutoff1, cutoff2);</span>

<span class="nc bnc" id="L354" title="All 2 branches missed.">		if (trunks == 0) {</span>
<span class="nc" id="L355">			cutoff = cutoff1;</span>
		}

		//YN: the quality of the algorithm may increase slightly if res rises
		//YN: making x (the increment) smaller
<span class="nc" id="L360">		int res = 100;</span>
<span class="nc" id="L361">		double x = cutoff/res;</span>
<span class="nc" id="L362">		double p = 0.0;</span>
<span class="nc" id="L363">		double k0[] = new double[3];</span>
<span class="nc" id="L364">		double k12[] = new double[3];</span>
<span class="nc" id="L365">		double k3[] = new double[3];</span>
<span class="nc" id="L366">		double intg[] = new double[3];</span>

		//YN: here we calculate the integrals numerically using the RK4 algorithm.
		//YN: the meaning of these integrals:
		//YN: intg[0] - the prob to be in states s+1 to trnks, divided by the prob.
		//YN:           to be in state s. i.e. p(wait&gt;0)/pi_s
		//YN: intg[1] - prob. of being in states between s+1 and trnks (i.e. have to
		//YN:			wait), and customer patience being smaller than waiting time
		//YN:           divided by the prob. to be in state s
		//YN: intg[2] - the average time of wait for non blocked calls that are 
		//YN:           answered prior to abandonment, divided by the 
		//YN:           prob. to be in state s
<span class="nc" id="L378">		k0[0] = x*s/tau;</span>
<span class="nc" id="L379">		k0[1] = x*s/tau;</span>
<span class="nc" id="L380">		k0[2] = 0.0;</span>
<span class="nc" id="L381">		genFx(x, x/2.0, s, trunks, lambda, 1.0/tau, theta, k12);</span>
<span class="nc" id="L382">		genFx(x, x, s, trunks, lambda, 1.0/tau, theta, k3);</span>
<span class="nc bnc" id="L383" title="All 2 branches missed.">		for (int j = 0; j &lt;= 2; j++) { </span>
<span class="nc" id="L384">			intg[j] = (k0[j] + 4.0*k12[j] + k3[j]) / 6.0;</span>
		}

<span class="nc bnc" id="L387" title="All 2 branches missed.">		for (int i = 2; i &lt;= res; i++) {</span>
<span class="nc" id="L388">			p += x;</span>
<span class="nc" id="L389">			genFx(x, p, s, trunks, lambda, 1.0/tau, theta, k0);</span>
<span class="nc" id="L390">			genFx(x, p + x/2.0, s, trunks, lambda, 1.0/tau, theta, k12);</span>
<span class="nc" id="L391">			genFx(x, p + x, s, trunks, lambda, 1.0/tau, theta, k3);</span>
<span class="nc bnc" id="L392" title="All 2 branches missed.">			for (int j = 0; j &lt;= 2; j++) {  </span>
<span class="nc" id="L393">				intg[j] += (k0[j] + 4.0*k12[j] + k3[j])/6.0;</span>
			}
		}

		//YN: summ is sum over the states with free agents, of pi_k/pi_s, 
		//YN: where s is the state with no queue and no free agents.
		//YN: in plain english, this is the prob. that the next call will be
		//YN: answered immediately, given that the queue is empty
<span class="nc" id="L401">		double summ = 0;</span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">		for (int k = 0; k &lt;= s - 1; k++) {</span>
			// summ += workload^(k-s) / k! only with less overflow
<span class="nc" id="L404">			summ += Math.exp((k - s)*ln_workload - m_factorialLogs[k]);</span>
		}

		//YN: pi_s_gnbl = prob(state s and no blocks) / prob(no blocks). note: given no 
		//YN: blocks, pi_s + pi_LessThanS (summ*pi_s) + pi_MoreThanS (intg[0]*pi-s)
		//YN: hence the expr. for pi_s.

		//DHM: pnab_gnbl = 1 - (intg[0] + intg[1]) / (intg[0] + summ)
		//YN: prob. of no abandon is [1 minus the prob of being in states between 
		//YN: s+1 and trnks (being the prob. for instant answer)] plus [prob. of being 
		//YN: in those states with customer patience smaller than waiting time

		//DHM:                  intg[2] / (intg[0] + summ)
		//     result = ------------------------------------------
		//              1 - (intg[0] + intg[1]) / (intg[0] + summ)
		//
		//       intg[2]
		// = --------------
		//   summ - intg[1]
		//YN: pca= average time of wait for non blocked calls that are answered
		//YN: prior to abandonment (that's intg[2]*pi_s_gnbl), normalized by
		//YN: prob. of no abandon
<span class="nc" id="L426">		return intg[2] / (summ - intg[1]);</span>
	}

	/**
	 * Corresponds to the function compute_asa_noabs in erlanga.cpp.
	 * 
	 * @param s number of agents
	 * @param trunks size of buffer; total number of telephone lines
	 * @param lambda rate of call arrivals
	 * @param tau rate of call departures [mean time of call]
	 * @return
	 */
	private double computeAsaNoAbandons(
			int s,
			int trunks,
			double lambda,
			double tau) {
<span class="nc bnc" id="L443" title="All 4 branches missed.">		if (s &lt;= 0 || s &gt; MAX_NUM_ERLANGS) {</span>
<span class="nc" id="L444">			throw new IllegalArgumentException(&quot;Invalid number of agents &quot; + s);</span>
		}
<span class="nc bnc" id="L446" title="All 2 branches missed.">		if (trunks == s) {</span>
<span class="nc" id="L447">			return 0.0;							//YN:  some obvious cases</span>
		}
<span class="nc bnc" id="L449" title="All 4 branches missed.">		if ((trunks &gt; 0) &amp;&amp; (trunks &lt; s)) {</span>
<span class="nc" id="L450">			throw new IllegalArgumentException(&quot;computeAsa: Fewer trunks than agents: &quot; + trunks + &quot; &lt; &quot; + s);</span>
		}

<span class="nc" id="L453">		double a = lambda * tau;</span>
<span class="nc bnc" id="L454" title="All 2 branches missed.">		if (a == 0.0) {</span>
<span class="nc" id="L455">			return 0.0;			// om - no work - perfect ASA 7/4/97</span>
		}
<span class="nc" id="L457">		double ln_a = Math.log(a);  // om - fix apowerk overflow.  3/13/97</span>

<span class="nc" id="L459">		double sum = 1.0;	    </span>
<span class="nc" id="L460">		double lnAPowerK = 0;         // om - fix apowerk overflow.  3/13/97</span>


<span class="nc bnc" id="L463" title="All 2 branches missed.">		for (int k = 1; k &lt; s; k++) {</span>
<span class="nc" id="L464">			lnAPowerK = k * ln_a; // om - fix apowerk overflow.  3/13/97</span>
<span class="nc" id="L465">			sum += Math.exp(lnAPowerK - m_factorialLogs[k]);   // om - fix apowerk overflow.  3/13/97</span>
		}

<span class="nc bnc" id="L468" title="All 2 branches missed.">		if (trunks == 0) {				//YN: infinite buffer</span>
<span class="nc" id="L469">			double tmp1 = 1 - a/s;</span>
<span class="nc bnc" id="L470" title="All 2 branches missed.">			if (tmp1 &lt;= 0) {</span>
<span class="nc" id="L471">				throw new IllegalArgumentException(&quot;computeAsaNoAbandons: workload greater than number of agents&quot;);</span>
			}

<span class="nc" id="L474">			double sum2 =	Math.exp(s*ln_a - m_factorialLogs[s] - Math.log(tmp1)); // om - fix apowerk overflow.  3/13/97</span>
<span class="nc" id="L475">			double p0inv = sum + sum2 ;    </span>

<span class="nc" id="L477">			double lq = Math.exp( s*ln_a + Math.log(a/s) - m_factorialLogs[s] - 2*Math.log(tmp1) - Math.log(p0inv) );  // om - fix apowerk overflow.  3/13/97</span>

<span class="nc" id="L479">			double result = lq/lambda;  // om - 11/3</span>

<span class="nc" id="L481">			return result;</span>
		} else {							//YN: finite buffer
<span class="nc" id="L483">			double sum2 = 0.0;		//YN: sum2 is sum of pi's where queue is </span>
			//YN: not empty (s&lt;total # of people&lt;trnks)
<span class="nc bnc" id="L485" title="All 2 branches missed.">			for (int j = s; j &lt;= trunks; j++) {</span>
<span class="nc" id="L486">				sum2 += Math.exp(j*ln_a - m_factorialLogs[s] - (j - s)*Math.log(s));</span>
			}

<span class="nc" id="L489">			double p0inv = sum + sum2;       //YN: pi_0=1/(sum+sum2) &lt;= BGR #2</span>

			//YN: computation of P(blocked) = pi_B
<span class="nc" id="L492">			double blocked = Math.exp(trunks*ln_a - m_factorialLogs[s] - (trunks - s)*Math.log(s)</span>
<span class="nc" id="L493">					- Math.log(p0inv));</span>
<span class="nc" id="L494">			double queue = trunks - s;</span>
			//YN: lq is AverageNumOfPeopleInQueue. this is the sum, over all states 
			//YN: with positive queue, of the # of people in queue times pi_ for that
			//YN: state which is the prob. of being in that state. 
<span class="nc" id="L498">			double lq = Math.exp(Math.log(a/s) + s*ln_a - m_factorialLogs[s] - </span>
<span class="nc" id="L499">					Math.log(p0inv) - 2*Math.log(a/s - 1)) </span>
<span class="nc" id="L500">					* (Math.pow(a/s,queue)*(queue*(a/s - 1) - 1) + 1);</span>

			/* YN: a better way of doing that: (more self explaining)
		long double lq = 0, tmp6 = 0;
		for (int m=1; m &lt; queue ; m++) {
			tmp6 += (m+s)*log(a) - m*log(s) - ln_fact(s) - log(pOinv); 
					//that's log(pi_(m+s)) i.e. prob. of m people (in queue only)
			lq += exp(tmp6 + log(m));
					//that's multipling #of people in queue by the prob. of the state
		}

			 */
			//YN: remember little's formula: asa=AverageNumOfPeopleInQueue
			//YN: divided by EffectiveRateOfArrival
			//YN: multiplying lambda by (1-blocked) gives you EffectiveRateOfArrival
<span class="nc" id="L515">			double result = lq / (lambda*(1 - blocked));</span>

<span class="nc" id="L517">			return result;</span>
		}
	}

	/**
	 * Corresponds to the function agents_asa_noabs in erlanga.cpp.
	 * 
	 * @param trunks
	 * @param lambda
	 * @param tau
	 * @param asa
	 * @return
	 */
	private int getAgentsAsaNoAbandons(
			int trunks,
			double lambda,
			double tau,
			double asa) {
	        //YN: this subroutine computes agents required, using compute_asa iteratively

<span class="nc bnc" id="L537" title="All 2 branches missed.">	    if (lambda == 0) return 0;    // no work - no agents</span>

		int min;
<span class="nc bnc" id="L540" title="All 2 branches missed.">		if (trunks == 0) {</span>
<span class="nc" id="L541">			min = (int)(tau*lambda*(1 + Math.sqrt(1 + 4/(lambda*asa)))); </span>
		} else {
<span class="nc" id="L543">			min = 1;</span>
		}
		int max;
<span class="nc bnc" id="L546" title="All 2 branches missed.">		if (trunks == 0) {</span>
<span class="nc" id="L547">			max = MAX_NUM_ERLANGS + 1; </span>
		} else {
<span class="nc" id="L549">			max = trunks;</span>
		}
<span class="nc bnc" id="L551" title="All 2 branches missed.">		while (max - min &gt; 1) {</span>
<span class="nc" id="L552">			int i = (max + min)/2;</span>
<span class="nc" id="L553">			double tmpAsa = computeAsaNoAbandons(i, trunks, lambda, tau);</span>
<span class="nc bnc" id="L554" title="All 2 branches missed.">			if (tmpAsa &gt; asa) min = i;</span>
<span class="nc" id="L555">			else max = i;</span>
<span class="nc" id="L556">		}       </span>
<span class="nc bnc" id="L557" title="All 2 branches missed.">		if (max &lt;= MAX_NUM_ERLANGS) {</span>
<span class="nc" id="L558">			return max;</span>
		} else {
<span class="nc" id="L560">			throw new IllegalArgumentException(&quot;Unable to meet ASA with &quot; + MAX_NUM_ERLANGS + &quot; agents&quot;);</span>
		}
	}

	/**
	 * Corresponds to the function agents_asa in erlanga.cpp.
	 * 
	 * @param trunks
	 * @param lambda
	 * @param tau
	 * @param abandonsPerSecond
	 * @param stages
	 * @param asa
	 * @return
	 */
	private int getAgentsAsa(
			int trunks,
			double lambda,
			double tau,
			double abandonsPerSecond,
			double stages,
			double asa) {

//System.out.println(&quot;getAgentsAsa(&quot; + trunks + &quot;, &quot; + lambda + &quot;, &quot; + tau + &quot;, &quot; + abandonsPerSecond + &quot;, &quot; + stages + &quot;, &quot; + asa + &quot;)&quot;);
<span class="nc" id="L584">		double theta = stages * abandonsPerSecond;</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">		if (lambda == 0) {</span>
<span class="nc" id="L586">			return 0;    // no work - no agents</span>
		}
<span class="nc bnc" id="L588" title="All 2 branches missed.">		if (asa == 0) {</span>
<span class="nc" id="L589">			throw new IllegalArgumentException(&quot;ASA must be positive&quot;);      </span>
		}

		//og int min= int(tau*lambda); 
<span class="nc" id="L593">		int min = 1; </span>
		int max;
<span class="nc bnc" id="L595" title="All 2 branches missed.">		if (trunks == 0) {</span>
<span class="nc" id="L596">			max = getAgentsAsaNoAbandons(trunks, lambda, tau, asa); </span>
		} else {
<span class="nc bnc" id="L598" title="All 2 branches missed.">			max = ((trunks &lt; MAX_NUM_ERLANGS) ? trunks : MAX_NUM_ERLANGS);	</span>
		}
		//YN 8/26/98 change to solve -1 in finite model
<span class="nc bnc" id="L601" title="All 2 branches missed.">		while (max - min &gt; 1) {</span>
<span class="nc" id="L602">			int i = (max + min)/2;</span>
<span class="nc" id="L603">			double tmp_asa = computeAsa(i, trunks, lambda, tau, theta);</span>
<span class="nc bnc" id="L604" title="All 2 branches missed.">			if (tmp_asa &gt; asa) {</span>
<span class="nc" id="L605">				min = i;</span>
			} else {
<span class="nc" id="L607">				max = i;</span>
			}
<span class="nc" id="L609">		}       </span>
		// if min is enough, no need to put another agent
<span class="nc bnc" id="L611" title="All 2 branches missed.">		return (computeAsa(min, trunks, lambda, tau, theta) &lt;= asa) ? min : max;</span>
	}

	/**
	 * Corresponds to the function int_agents_asa in erlangc.cpp.
	 * 
	 * @param lambda
	 * @param tau
	 * @param asa
	 * @param pct_aband
	 * @param patience
	 * @return
	 */
	public int getAgentsAsaWithPatience(
			double lambda,
			double tau,
			double asa,
			double patience) {
		//TODO: What happens when workload is between 5000 and 8000?
<span class="nc bnc" id="L630" title="All 4 branches missed.">		if (lambda &gt; (7000.0/900.0) || (lambda * tau) &gt; 8000.0) {</span>
<span class="nc" id="L631">			return 9999; // large WL; large volume</span>
		}
<span class="nc bnc" id="L633" title="All 2 branches missed.">		if (patience &gt; 400.0) {</span>
<span class="nc" id="L634">			patience = 400.0;</span>
		}
<span class="nc" id="L636">		return getAgentsAsa(NUM_TRUNKS, lambda, tau, (1/patience), 1.0, asa);</span>
	}

	/**
	 * Corresponds to the function double_compute_asa in erlangc.cpp.
	 * &lt;p/&gt;
	 * TODO: unused
	 * 
	 * @param s
	 * @param lambda
	 * @param tau
	 * @param patience
	 * @return
	 */
	public double getAsaWithPatience(
			int s,
			double lambda,
			double tau,
			double patience) {
<span class="nc bnc" id="L655" title="All 4 branches missed.">		if (lambda &gt; (7000.0/900.0) || (lambda * tau) &gt; 8000.0) { // Workload limit; large volume</span>
<span class="nc" id="L656">			return 3 * patience;</span>
		}
<span class="nc bnc" id="L658" title="All 2 branches missed.">		if (patience &gt; 900.0) {</span>
<span class="nc" id="L659">			patience = 900.0;</span>
		}
<span class="nc" id="L661">		return computeAsa(s, 0, lambda, tau, (1/patience));</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>