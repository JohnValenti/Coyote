<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceDistributionBuilder.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">TraceDistributionBuilder.java</span></div><h1>TraceDistributionBuilder.java</h1><pre class="source lang-java linenums">/*
 * (c) 2010 Verint Systems, Inc.
 */
package com.bluepumpkin.ejb.bbm.timeseries.util;

import java.util.ArrayList;
import java.util.List;

import com.bluepumpkin.ejb.bbm.timeseries.model.DataValueConstraints;
import com.bluepumpkin.ejb.bbm.timeseries.model.DataValueConstraints.BoundType;
import com.bluepumpkin.ejb.bbm.timeseries.util.TraceOperator.AggregationType;

//TODO: This class would likely be part of aggregation strategy implementations if
// aggregations were refactored into strategies.  Relatively little code is actually
// shared by all the aggregation types.

/**
 * An instance of this class may be used to build a TraceDistribution by adding successive
 * values to the distribution.
 * &lt;pre&gt;
private static TraceDistribution getArrayDistribution(int[] sourceValues, int dependentValueArrays[][], AggregationType aggregationType, DataValueConstraints constraints) {
	// Create an empty distribution builder
	TraceDistributionBuilder builder = new TraceDistributionBuilder(aggregationType, constraints);
	int sourceValueCount = sourceValues.length;
	// Add each source point to the builder
	for (int i = 0; i &lt; sourceValueCount; i++) {
		int traceValue = sourceValues[i];
		builder.addValue(traceValue, dependentValueArrays, i);
	}
	// Get a distribution from the builder
	return builder.getTraceDistribution();
}
&lt;/pre&gt;
 */
public class TraceDistributionBuilder {
	// The raw values that are added to the distribution.  Some may be negative, signaling
	// missing or invalid data.
	private final List&lt;Double&gt; m_sourceValues;
	private final List&lt;Boolean&gt; m_hasNonZeroWeight;
	private final AggregationType m_aggregationType;
	private final DataValueConstraints m_constraints;

	// The number of nonnegative source values.
<span class="nc" id="L44">	private double m_dataCount = 0;</span>

	// This is the sum of nonnegative source values.
<span class="nc" id="L47">	private double m_sum = 0;</span>

	// Weighted sum is only relevant when the aggregation is a weighted average.
	// This is the sum of value * dependent value for valid values.
<span class="nc" id="L51">	private double m_weightedSum = 0;</span>

	// Total weight is only relevant when the aggregation is a weighted average.
	// It is the sum of valid dependent values, where this is a simple sum for trace
	// types other than ASA, the sum of CV - ABN for trace type ASA and predict or forecast
	// data, and the sum of CV * (100 - ABN) for trace type ASA and required data.
<span class="nc" id="L57">	private double m_totalWeight = 0;</span>

	/**
	 * Creates a new TraceDistributionBuilder for a particular aggregation type and
	 * data constraints.
	 *
	 * @param aggregationType
	 */
<span class="nc" id="L65">	public TraceDistributionBuilder(AggregationType aggregationType, DataValueConstraints constraints) {</span>
<span class="nc" id="L66">		m_constraints = constraints;</span>
<span class="nc" id="L67">		m_sourceValues = new ArrayList&lt;Double&gt;();</span>
<span class="nc" id="L68">		m_hasNonZeroWeight = new ArrayList&lt;Boolean&gt;();</span>
<span class="nc" id="L69">		m_aggregationType = aggregationType;</span>
<span class="nc" id="L70">	}</span>

	/**
	 * Adds an integer value to this distribution builder.
	 *
	 * @param traceValue
	 * @param dependentValueArrays
	 * @param index
	 */
	public void addValue(double traceValue, double[][] dependentValueArrays, int index)
	{
<span class="nc" id="L81">		boolean hasDependentValues = false;</span>
<span class="nc" id="L82">		double depValSum = 0;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">		if (m_aggregationType.isWeightedAverage())</span>
		{
<span class="nc bnc" id="L85" title="All 2 branches missed.">			for (int j = 0; j &lt; dependentValueArrays.length; j++) {</span>
<span class="nc bnc" id="L86" title="All 4 branches missed.">				if (dependentValueArrays[j] == null || dependentValueArrays[j].length &lt; index) {</span>
<span class="nc" id="L87">					continue;</span>
				}
<span class="nc" id="L89">				double dependentVal = dependentValueArrays[j][index];</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">				if (dependentVal &lt; 0) {</span>
<span class="nc" id="L91">					continue;</span>
				}
				// Special condition for ASA ( has CV at j==0 and ABN at j==1)
<span class="nc bnc" id="L94" title="All 8 branches missed.">				if (m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT ||</span>
					m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS ||
					m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||
					m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
					// Special condition for ASA: SUM((CV-ABN)*ASA)/SUM(CV-ABN)
<span class="nc" id="L99">					double cv = dependentValueArrays[0][index];</span>
<span class="nc" id="L100">					double abn = 0;</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">					if (dependentValueArrays[1] != null) {</span>
<span class="nc" id="L102">						abn = dependentValueArrays[1][index];</span>
					}
<span class="nc bnc" id="L104" title="All 4 branches missed.">					if (cv &gt;= 0 &amp;&amp; abn &gt;= 0) {</span>
<span class="nc" id="L105">						hasDependentValues = true;</span>
<span class="nc bnc" id="L106" title="All 4 branches missed.">						if (m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT ||</span>
							m_aggregationType == AggregationType.WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS) {
							// Abandonment is a percentage of volume for required data
<span class="nc" id="L109">							depValSum = cv * (100 - abn);</span>
						} else {
							// Abandonment is a transaction count for forecast or predicted data
<span class="nc" id="L112">							depValSum = cv - abn;</span>
						}
					}
					break;
				} else {
<span class="nc" id="L117">					depValSum += dependentVal;</span>
<span class="nc" id="L118">					hasDependentValues = true;</span>
				}
			}
		}
<span class="nc" id="L122">		addValue(traceValue, hasDependentValues, depValSum);</span>
<span class="nc" id="L123">	}</span>

	/**
	 * Adds a floating point value to this builder and its associated dependent value, if needed.
	 * For instance, AHT would typically require the corresponding call volume to be supplied
	 * as a weight.
	 *
	 * @param traceValue
	 * @param hasDependentValue
	 * @param dependentValue
	 */
	public void addValue(double traceValue, boolean hasDependentValue, double dependentValue) {
<span class="nc" id="L135">		m_sourceValues.add(traceValue);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">		if (m_aggregationType.isWeightedAverage()) {</span>
<span class="nc bnc" id="L137" title="All 4 branches missed.">			m_hasNonZeroWeight.add(hasDependentValue &amp;&amp; dependentValue &gt; 0);</span>
		}
<span class="nc bnc" id="L139" title="All 2 branches missed.">		if (traceValue &lt; 0) {</span>
			// Only include valid points
<span class="nc" id="L141">			return;</span>
		}
<span class="nc" id="L143">		++m_dataCount;</span>
<span class="nc" id="L144">		m_sum += traceValue;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">		if (m_aggregationType.isWeightedAverage()) {</span>
<span class="nc bnc" id="L146" title="All 2 branches missed.">			if (hasDependentValue) {</span>
<span class="nc" id="L147">				m_weightedSum += dependentValue * traceValue;</span>
<span class="nc" id="L148">				m_totalWeight += dependentValue;</span>
			}
		}
<span class="nc" id="L151">	}</span>

	/**
	 * Returns a TraceDistribution representing all the values that have been
	 * added to this builder so far.
	 *
	 * @return
	 */
	public TraceDistribution getTraceDistribution()
	{
<span class="nc" id="L161">		double aggregateValue = 0;</span>
<span class="nc bnc" id="L162" title="All 5 branches missed.">		switch (m_aggregationType) {</span>
		case SUM:
<span class="nc" id="L164">			aggregateValue = m_sum;</span>
<span class="nc" id="L165">			break;</span>
		case SIMPLE_AVERAGE:
<span class="nc bnc" id="L167" title="All 2 branches missed.">			if (m_dataCount &gt; 0) {</span>
<span class="nc" id="L168">				aggregateValue = m_sum / m_dataCount;</span>
			} else {
<span class="nc" id="L170">				aggregateValue = 0;</span>
			}
<span class="nc" id="L172">			break;</span>
		case WEIGHTED_AVERAGE:
		case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT:
		case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT:
<span class="nc bnc" id="L176" title="All 2 branches missed.">			if (m_totalWeight &gt; 0) {</span>
<span class="nc" id="L177">				aggregateValue = m_weightedSum / m_totalWeight;</span>
			} else {
				// Ordinarily we cannot scale weighted averages if there are no weights.
<span class="nc" id="L180">				return TraceDistribution.INVALID_DISTRIBUTION;</span>
			}
			break;
		case WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
		case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
		case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
<span class="nc bnc" id="L186" title="All 2 branches missed.">			if (m_totalWeight &gt; 0) {</span>
<span class="nc" id="L187">				aggregateValue = m_weightedSum / m_totalWeight;</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">			} else if (m_dataCount &gt; 0) {</span>
				// If all weights are zero but there were at least some valid points,
				// we take the simple average of the valid points.
<span class="nc" id="L191">				aggregateValue = m_sum / m_dataCount;</span>
			} else {
<span class="nc" id="L193">				aggregateValue = 0;</span>
			}
			break;
		}

		// We separately calculate lower bound weights and upper bound weights.  Weights are
		// only meaningful for a SCALE_ORIGIN bound type; if a bound is a TRUNCATION_POINT then
		// the opposite bound must be a SCALE_ORIGIN and will always be used for scaling.

		// Weights are used to apply a target value to a range of values to produce new values
		// whose aggregate is the target value.  The weights take into account both the current
		// aggregate value and the individual source values.  When the aggregation type is an
		// average, the weights average to 1.  When the aggregation type is a sum, the weights
		// sum to 1.

		// There are special cases for when source values are all zero and/or dependent values
		// for a weighted average are all zero or missing.

		// When a trace uses weighted averaging to aggregate and there are no dependent values
		// or they are all zero, an invalid distribution will be returned for most aggregation
		// types.

		// If the aggregation type is one of WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS,
		// WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT, or WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT,
		// the weights are calculated as if for a simple average.

		// When all source values are zero, they are treated as if they were all one instead for
		// the purposes of weighting a new value.  This allows the user to adjust a range of
		// zero values upward without having to zoom in to view individual values.

<span class="nc" id="L223">		int sourceValueCount = m_sourceValues.size();</span>
<span class="nc" id="L224">		double[] lowerBoundWeights = null;</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">		if (m_constraints.getLowerBound() != null &amp;&amp;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">			m_constraints.getLowerBound().getType() == BoundType.SCALE_ORIGIN) {</span>
<span class="nc" id="L227">			lowerBoundWeights = new double[sourceValueCount];</span>
<span class="nc" id="L228">			double lowerBound = m_constraints.getLowerBound().getValue();</span>
<span class="nc" id="L229">			double lowerBoundReference = 1;</span>

<span class="nc bnc" id="L231" title="All 3 branches missed.">			switch (m_aggregationType) {</span>
			case SUM:
<span class="nc bnc" id="L233" title="All 2 branches missed.">				if (aggregateValue &gt; lowerBound) {</span>
<span class="nc" id="L234">					lowerBoundReference = aggregateValue - m_dataCount * lowerBound;</span>
				} else {
<span class="nc" id="L236">					lowerBoundReference = m_dataCount;</span>
				}
<span class="nc" id="L238">				break;</span>
			case SIMPLE_AVERAGE:
			case WEIGHTED_AVERAGE:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT:
			case WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
<span class="nc bnc" id="L246" title="All 2 branches missed.">				if (aggregateValue &gt; lowerBound) {</span>
<span class="nc" id="L247">					lowerBoundReference = aggregateValue - lowerBound;</span>
				} else {
<span class="nc" id="L249">					lowerBoundReference = 1;</span>
				}
				break;
			}
<span class="nc bnc" id="L253" title="All 2 branches missed.">			for (int i = 0; i &lt; sourceValueCount; i++) {</span>
<span class="nc" id="L254">				double traceValue = m_sourceValues.get(i);</span>
<span class="nc bnc" id="L255" title="All 2 branches missed.">				if (traceValue &lt; 0) {</span>
					// Only include valid points
<span class="nc" id="L257">					lowerBoundWeights[i] = traceValue;</span>
<span class="nc bnc" id="L258" title="All 2 branches missed.">				} else if (aggregateValue &gt; lowerBound) {</span>
<span class="nc" id="L259">					lowerBoundWeights[i] = (traceValue - lowerBound) / lowerBoundReference;</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">				} else if ( ! m_aggregationType.isWeightedAverage() ||</span>
<span class="nc bnc" id="L261" title="All 4 branches missed.">							(m_aggregationType.isSimpleAverageIfNoWeights() &amp;&amp; m_totalWeight == 0) ) {</span>
					// For all aggregation types other than weighted average,
					// if all values were lower bound, pretend all values were
					// (lower bound + 1) instead.
<span class="nc" id="L265">					lowerBoundWeights[i] = 1.0 / lowerBoundReference;</span>
				} else {
					// For weighted averages, if all values were lower bound,
					// pretend all values with nonzero weights were
					// (lower bound + 1) instead.
<span class="nc bnc" id="L270" title="All 2 branches missed.">					lowerBoundWeights[i] = m_hasNonZeroWeight.get(i) ? 1.0 / lowerBoundReference : 0;</span>
				}
			}
		}

<span class="nc" id="L275">		double[] upperBoundWeights = null;</span>
<span class="nc bnc" id="L276" title="All 2 branches missed.">		if (m_constraints.getUpperBound() != null &amp;&amp;</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">			m_constraints.getUpperBound().getType() == BoundType.SCALE_ORIGIN) {</span>
<span class="nc" id="L278">			upperBoundWeights = new double[sourceValueCount];</span>
<span class="nc" id="L279">			double upperBound = m_constraints.getUpperBound().getValue();</span>
<span class="nc" id="L280">			double upperBoundReference = 1;</span>

<span class="nc bnc" id="L282" title="All 3 branches missed.">			switch (m_aggregationType) {</span>
			case SUM:
<span class="nc bnc" id="L284" title="All 2 branches missed.">				if (aggregateValue &lt; upperBound) {</span>
<span class="nc" id="L285">					upperBoundReference = m_dataCount * upperBound - aggregateValue;</span>
				} else {
<span class="nc" id="L287">					upperBoundReference = m_dataCount;</span>
				}
<span class="nc" id="L289">				break;</span>
			case SIMPLE_AVERAGE:
			case WEIGHTED_AVERAGE:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT:
			case WEIGHTED_AVERAGE_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_COUNT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
			case WEIGHTED_AVERAGE_WITH_ABANDONMENT_PERCENT_USE_SIMPLE_AVERAGE_IF_NO_WEIGHTS:
<span class="nc bnc" id="L297" title="All 2 branches missed.">				if (aggregateValue &lt; upperBound) {</span>
<span class="nc" id="L298">					upperBoundReference = upperBound - aggregateValue;</span>
				} else {
<span class="nc" id="L300">					upperBoundReference = 1;</span>
				}
				break;
			}
<span class="nc bnc" id="L304" title="All 2 branches missed.">			for (int i = 0; i &lt; sourceValueCount; i++) {</span>
<span class="nc" id="L305">				double traceValue = m_sourceValues.get(i);</span>
<span class="nc bnc" id="L306" title="All 2 branches missed.">				if (traceValue &lt; 0) {</span>
					// Only include valid points
<span class="nc" id="L308">					upperBoundWeights[i] = traceValue;</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">				} else if (aggregateValue &lt; upperBound) {</span>
<span class="nc" id="L310">					upperBoundWeights[i] = (upperBound - traceValue) / upperBoundReference;</span>
				} else {
					// If all values were upper bound, pretend all values were (upper bound - 1) instead.
<span class="nc" id="L313">					upperBoundWeights[i] = 1.0 / upperBoundReference;</span>
				}
			}
		}
<span class="nc" id="L317">		return new TraceDistribution(aggregateValue, lowerBoundWeights, upperBoundWeights, m_constraints);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>