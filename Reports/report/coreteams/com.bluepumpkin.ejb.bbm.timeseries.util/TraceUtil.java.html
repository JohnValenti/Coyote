<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TraceUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.bbm.timeseries.util</a> &gt; <span class="el_source">TraceUtil.java</span></div><h1>TraceUtil.java</h1><pre class="source lang-java linenums">/*
 * (c) 2007-2011 Verint Systems, Inc.
 */
//TODO: Insert correct original year of publication
package com.bluepumpkin.ejb.bbm.timeseries.util;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.util.MathUtil;
import com.bluepumpkin.common.util.TimeZoneUtil;
import com.bluepumpkin.ejb.bbm.base.BbmTimeSeriesException;
import com.bluepumpkin.ejb.bbm.timeseries.model.*;
import com.bluepumpkin.ejb.bbm.workload.model.TimeUnit;

import java.io.Serializable;
import java.util.*;
/**
 * Title:        Blue Pumpkin Software Basic Business Model
 * Description:  TraceUtil object, Utility class for all Trace operations
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Sheng Song
 * @version 2.0
 */

<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class TraceUtil implements Serializable {</span>

	private static final long serialVersionUID = 1L;
<span class="fc" id="L28">	public static final ActualTraceCube META_ACTUAL = new ActualTraceCube();</span>
<span class="fc" id="L29">	public static final ActualTraceCube META_REPORT_ACTUAL =</span>
			new ActualTraceCube(new short[] {Trace.CV, Trace.AHT,Trace.PCA,
					Trace.ASA,Trace.ABANDONMENT,
					Trace.BACKLOG,Trace.STAFFING,
					Trace.OCCUPANCY,Trace.FTE,
					Trace.DIALS,Trace.CONNECTS,
					Trace.CRATE,Trace.RPC,
					Trace.RPCRATE,Trace.RPCAHT, Trace.VH, Trace.VAR});
<span class="fc" id="L37">	public static final ActualTraceCube META_ACTUAL_STAFFING = new ActualTraceCube(new short[] {Trace.STAFFING});</span>
<span class="fc" id="L38">	public static final ForecastTraceCube META_FORECAST =</span>
			new ForecastTraceCube(new short[]{ Trace.CV, Trace.AHT, Trace.CRATE, Trace.RPCAHT, Trace.RPCRATE});
<span class="fc" id="L40">	public static final PredictTraceCube META_REPORT_PREDICT =</span>
			new PredictTraceCube(new short[] {Trace.PCA,Trace.ASA,
					Trace.ABANDONMENT,Trace.BACKLOG,
					Trace.STAFFING,Trace.OCCUPANCY,
					Trace.FTE,Trace.DIALS,Trace.CONNECTS,Trace.RPC });
<span class="fc" id="L45">	public static final PredictTraceCube META_PREDICT = new PredictTraceCube();</span>
<span class="fc" id="L46">	public static final RequireTraceCube META_REQUIRE = new RequireTraceCube();</span>
<span class="fc" id="L47">	public static final ServiceGoalTraceCube META_REPORT_SERVICEGOAL =</span>
			new ServiceGoalTraceCube(new short[] {Trace.PCA, Trace.ASA, Trace.ABANDONMENT});
<span class="fc" id="L49">	public static final ServiceGoalTraceCube META_SERVICEGOAL =	new ServiceGoalTraceCube();</span>

<span class="fc" id="L51">	public static final ActualTraceCube META_ACTUAL_COMBINE = new ActualTraceCube(</span>
			new short[]{Trace.ABANDONMENT, Trace.AHT, Trace.ASA, Trace.BACKLOG, Trace.CV, Trace.PCA});
<span class="fc" id="L53">	public static final ForecastTraceCube META_FORECAST_COMBINE = new ForecastTraceCube(ForecastTraceCube.TYPES);</span>

<span class="fc" id="L55">	public static final AggrForecastedTraceCube META_AGGR_FORECAST = new AggrForecastedTraceCube();</span>
<span class="fc" id="L56">	public static final AggrRequiredTraceCube META_AGGR_REQUIRE = new AggrRequiredTraceCube();</span>

<span class="fc" id="L58">	public static final TraceChunk NULL_TraceChunk = new TraceChunk(null, null);</span>

	public static final short TIMEINTERVAL_STAT = 0;
	public static final short NUMBER_STAT = 1;
	public static final short PERCENTAGE_STAT = 2;

	public static final short MAXAREA = 5;

<span class="nc" id="L66">	private TraceUtil() {</span>
<span class="nc" id="L67">		throw new IllegalAccessError(&quot;Utility class&quot;);</span>
	}
	/**
	 * Gets area type of a given Trace Cube instance
	 * @param cube Types of trace cubes (ForecastTraceCube, PredictTraceCube, ServiceGoalTraceCube, RequireTraceCube)
	 * @return
	 */
	public static short getAreaType(TraceCube cube) {
<span class="nc bnc" id="L75" title="All 2 branches missed.">		if (cube instanceof ForecastTraceCube) {</span>
<span class="nc" id="L76">			return 1;</span>
		}
<span class="nc bnc" id="L78" title="All 2 branches missed.">		if (cube instanceof PredictTraceCube) {</span>
<span class="nc" id="L79">			return 2;</span>
		}
<span class="nc bnc" id="L81" title="All 2 branches missed.">		if (cube instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L82">			return 3;</span>
		}
<span class="nc bnc" id="L84" title="All 2 branches missed.">		if (cube instanceof RequireTraceCube) {</span>
<span class="nc" id="L85">			return 4;</span>
		}
<span class="nc" id="L87">		return 0;</span>
	}
	/**
	 * Routine to convert a Date to &quot;StartDate&quot; and &quot;OffSet&quot;
	 * The OffSet is always based on GMT
	 * @param date any date
	 * @return InsertionPoint, which represents a date and an offset 
	 */
	public static InsertionPoint getInsertionPoint(Date date) {
<span class="fc" id="L96">		Calendar cal = createGMTCalendarWithDateAndTime(date);</span>
<span class="fc" id="L97">		short offSet = calculateOffsetGivenDateAndCalendar(cal);</span>
<span class="fc" id="L98">		setTimeOnCalendarToZero(cal);</span>
		// If the Date is just midnight, it will be counted as 1st point
<span class="fc" id="L100">		++offSet;</span>
<span class="fc" id="L101">		return new InsertionPoint(cal.getTime(), offSet);</span>
	}
	
	/**
	 * Method to calculate the offset given a date based on a 15 minute interval
	 * within each hour given a calendar. Hours based on military time.
	 * @param cal, Calendar that the offset will be based off of. (GMT, PST, etc.)
	 * @return short, the offset that was calculated
	 */
	static short calculateOffsetGivenDateAndCalendar(Calendar cal) {
<span class="fc" id="L111">		short hour = (short)cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="fc" id="L112">		short min = (short)cal.get(Calendar.MINUTE);</span>
<span class="fc" id="L113">		return (short) (hour * 4 + min / 15);</span>
	}
	
	/**
	 * Sets the HOUR_OF_DAY, MINUTE, SECOND, MILLISECOND values of Calendar to 0 which
	 * represents 12:00am, or the start of the day.
	 * @param cal, Calendar with time of day to be set
	 */
	static void setTimeOnCalendarToZero(Calendar cal) {
<span class="fc" id="L122">		cal.set(Calendar.HOUR_OF_DAY, 0);</span>
<span class="fc" id="L123">		cal.set(Calendar.MINUTE, 0);</span>
<span class="fc" id="L124">		cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L125">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L126">	}</span>
	
	/**
	 * Creates a calendar in the GMT Timezone and sets the time to the given date
	 * @param date, Date to which the calendar will be set to
	 * @return cal, Calendar that is created based off the date and timezone.
	 */
	static Calendar createGMTCalendarWithDateAndTime(Date date) {
<span class="fc" id="L134">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L135">		cal.setTime(date);</span>
<span class="fc" id="L136">		return cal;</span>
	}

	/**
	 * This class represents an insertion point, represented as a Date and a
	 * short index into the 15-minute intervals comprising that date.
	 * &lt;p&gt;
	 * This class is not immutable since the Date object is not immutable.
	 * To improve performance its fields are public and are not defensively
	 * copied on read/write.  Modifying the date field after instantiation
	 * may produce undesirable results.
	 */
	public static class InsertionPoint {
		/** The base date for the insertion point. */
		public final Date startDate;
		/** The index into the date in 15-minute intervals.  Midnight is represented as 1. */
		public final short offset;

		/**
		 * Constructor for the InsertionPoint object
		 * @param date start date for insertion point
		 * @param offset amount to offset by.
		 */
<span class="fc" id="L159">		public InsertionPoint(Date date, short offset) {</span>
<span class="fc" id="L160">			this.startDate = date;</span>
<span class="fc" id="L161">			this.offset = offset;</span>
<span class="fc" id="L162">		}</span>
	}

	/**
	 * A shallow copy of the TraceCube to another type of TraceCube
	 * @param tc, any existing TraceCube
	 * @param metaTC, a MetaCube defined in TraceUtil
	 * @return TraceCube, an instanceof MetaCube
	 */
	public static TraceCube convertTraceCube(TraceCube tc, TraceCube metaTC)
		throws BbmTimeSeriesException {
<span class="pc bpc" id="L173" title="2 of 4 branches missed.">		if (tc == null || metaTC == null) {</span>
<span class="nc" id="L174">			return null;</span>
		}
<span class="fc" id="L176">		long milli = tc.getRawEndDate().getTime();</span>
<span class="fc" id="L177">		int points = tc.getMaximumLength(tc.getTraceTypes());</span>
<span class="fc" id="L178">		short[] types = new short[tc.getTraceTypes().length];</span>
<span class="fc" id="L179">		System.arraycopy(tc.getTraceTypes(), 0, types, 0, types.length);</span>
<span class="fc" id="L180">		int origPoints = gapOffSet(tc.getStartDate(), tc.getStartOffSet(), tc.getRawEndDate());</span>
<span class="fc" id="L181">		origPoints++;</span>
<span class="fc" id="L182">		milli += (points - origPoints) * Trace.INTERVAL * TimeZoneUtil.MINUTE_IN_MILLISECONDS_LONG;</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">		ID queueID = tc.getQueueID() == null ? null : new ID(tc.getQueueID());</span>
<span class="fc" id="L184">		return metaTC.newInstance(queueID, (Date)tc.getRawStartDate().clone(), new Date(milli),	types);</span>
	}

	/**
	 * Date need be snapped into closest 15 minutes interval time
	 * @param date original
	 * @return
	 */
	public static Date snapDate(Date date) {
<span class="fc bfc" id="L193" title="All 2 branches covered.">		if (date == null) {</span>
<span class="fc" id="L194">			return null;</span>
		}
<span class="fc" id="L196">		Calendar cal = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="fc" id="L197">		cal.setTime(date);</span>
<span class="fc" id="L198">		cal.set(Calendar.SECOND, 0);</span>
<span class="fc" id="L199">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="fc" id="L200">		int minute = cal.get(Calendar.MINUTE);</span>
<span class="fc" id="L201">		minute = minute / Trace.INTERVAL;</span>
<span class="fc" id="L202">		cal.set(Calendar.MINUTE, Trace.INTERVAL * minute);</span>
<span class="fc" id="L203">		return cal.getTime();</span>
	}
	/**
	 * validate multiple tracecubes, must have same length, same trace types
	 * as invalid parameters won't be continued in operation, just throw exception
	 * @param cubes array of TraceCubes
	 * @return TraceCube, a holder traceCube which has the same start/end definition of first TraceCube
	 */
	public static TraceCube validateTraceCubes(TraceCube[] cubes) throws BbmTimeSeriesException {
<span class="fc" id="L212">		TraceCube firstCube = getFirstNonNullTraceCube(cubes);</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">		if (firstCube == null) {</span>
<span class="nc" id="L214">			return null;</span>
		}
<span class="fc" id="L216">		short[] types = firstCube.getTraceTypes();</span>
<span class="fc" id="L217">		int length = firstCube.getMaximumLength(types);</span>
<span class="pc bpc" id="L218" title="1 of 2 branches missed.">		for (int i=1; i&lt;cubes.length; i++) {</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">			if (cubes[i] == null) {</span>
<span class="nc" id="L220">				continue;</span>
			}
<span class="nc bnc" id="L222" title="All 2 branches missed.">			if (!cubes[i].matchingTypes(types)) {</span>
<span class="nc" id="L223">				throw new BbmTimeSeriesException(BbmTimeSeriesException.CUBES_DIFF_TYPE);</span>
			}
<span class="nc bnc" id="L225" title="All 2 branches missed.">			if (cubes[i].getMaximumLength(types) != length) {</span>
<span class="nc" id="L226">				throw new BbmTimeSeriesException(BbmTimeSeriesException.CUBES_DIFF_LENGTH);</span>
			}
		}
<span class="fc" id="L229">		return firstCube.cloneTraceCube();</span>
	}

	private static TraceCube getFirstNonNullTraceCube(TraceCube[] cubes) {
<span class="fc" id="L233">		TraceCube firstCube = null;</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">		for (int i=0; i&lt;cubes.length; i++) {</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">			if (cubes[i] != null) {</span>
<span class="fc" id="L236">				firstCube = cubes[i];</span>
<span class="fc" id="L237">				break;</span>
			}
		}
<span class="fc" id="L240">		return firstCube;</span>
	}

	/**
	 * For aggregated view, we have to include more trace types
	 * For example, AHT aggregation requires CV
	 * @param actualCube
	 * @param forecastCube
	 * @param excPoints
	 * @param type
	 * @return short[]
	 */
	public static short[] getAggTraceType(TraceCube actualCube, TraceCube forecastCube, int excPoints, short type) {
		// Occupancy is Sum(Staffing*Occupancy)/Sum(Staffing)
		// ASA is Sum((CV - ABN)*ASA)/Sum(CV - ABN)
		// AHT/PCA is Sum(CV*AHT)/Sum(CV)
<span class="nc bnc" id="L256" title="All 12 branches missed.">		switch(type) {</span>
			case Trace.AHT:
<span class="nc" id="L258">				return getShortsForTraceAHT(actualCube, forecastCube, excPoints);</span>
			case Trace.FORECASTING_AHT:
<span class="nc" id="L260">				return new short[] {Trace.CV_VH, Trace.CRATE};</span>
			case Trace.PCA:
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
<span class="nc" id="L264">				return new short[] {Trace.VAR};</span>
			case Trace.OCCUPANCY:
<span class="nc" id="L266">				return new short[] {Trace.STAFFING};</span>
			case Trace.ASA:
			case Trace.SERVICE_GOALS_ASA:
<span class="nc" id="L269">				return new short[] {Trace.CV, Trace.ABANDONMENT};</span>
			case Trace.CONNECTS:
<span class="nc" id="L271">				 return new short[] {Trace.DIALS, Trace.CRATE};</span>
			case Trace.CRATE:
<span class="nc" id="L273">				 return new short[] {Trace.CONNECTS, Trace.DIALS};</span>
			case Trace.RPC:
<span class="nc" id="L275">				return new short[] {Trace.DIALS, Trace.RPCRATE};</span>
			case Trace.RPCRATE:
<span class="nc" id="L277">				return new short[] {Trace.RPC, Trace.DIALS};</span>
			case Trace.RPCAHT :
<span class="nc" id="L279">				return new short[] {Trace.RPC};</span>
			case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L281">				return new short[] {Trace.RPCRATE};</span>
			default:
<span class="nc" id="L283">				return new short[0];</span>
		}
	}

	private static short[] getShortsForTraceAHT(TraceCube actualCube, TraceCube forecastCube, int excPoints) {
<span class="nc" id="L288">		boolean addCV = false;</span>
<span class="nc" id="L289">		boolean addConnects = false;</span>
<span class="nc bnc" id="L290" title="All 2 branches missed.">		for (int i = 0; i &lt; excPoints; i++) {</span>
<span class="nc bnc" id="L291" title="All 4 branches missed.">			if (actualCube.getTraceValueD(Trace.CV_VH, i) &gt; 0 || forecastCube.getTraceValueD(Trace.CV_VH, i) &gt; 0) {</span>
<span class="nc" id="L292">				addCV = true;</span>
			}
<span class="nc bnc" id="L294" title="All 2 branches missed.">			if (actualCube.getTraceValueD(Trace.CONNECTS, i) &gt; 0 ||</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">					forecastCube.getTraceValueD(Trace.CONNECTS, i) &gt; 0) {</span>
<span class="nc" id="L296">				addConnects = true;</span>
			}
<span class="nc bnc" id="L298" title="All 4 branches missed.">			if (addCV &amp;&amp; addConnects) {</span>
<span class="nc" id="L299">				return new short[]{Trace.CV_VH, Trace.CONNECTS};</span>
			}
		}
<span class="nc bnc" id="L302" title="All 2 branches missed.">		return new short[]{addConnects ? Trace.CONNECTS : Trace.CV_VH};</span>
	}

	/**
	 * For aggregated view, we have to include more trace types
	 * For example, AHT aggregation requires CV
	 * @param types
	 * @return short[]
	 */
	public static short[] getAggTraceType(short[] types) {
		// Occupancy is Sum(Staffing*Occupancy)/Sum(Staffing)
		// ASA is Sum((CV - ABN)*ASA)/Sum(CV - ABN)
		// AHT/PCA is Sum(CV*AHT)/Sum(CV)
<span class="fc" id="L315">		boolean needCV = false;</span>
<span class="fc" id="L316">		boolean hasCV = false;</span>
<span class="fc" id="L317">		boolean needABN = false;</span>
<span class="fc" id="L318">		boolean hasABN = false;</span>
<span class="fc" id="L319">		boolean needSTF = false;</span>
<span class="fc" id="L320">		boolean hasSTF = false;</span>
<span class="fc" id="L321">	    boolean needDials =false;</span>
<span class="fc" id="L322">	    boolean hasDials =false;</span>
<span class="fc" id="L323">		boolean needConnects=false;</span>
<span class="fc" id="L324">		boolean hasConnects=false;</span>
<span class="fc" id="L325">		boolean needCRate =false;</span>
<span class="fc" id="L326">		boolean hasCRate=false;</span>
<span class="fc" id="L327">		boolean needRPC =false;</span>
<span class="fc" id="L328">		boolean hasRPC =false;</span>
<span class="fc" id="L329">		boolean needRPCRate =false;</span>
<span class="fc" id="L330">		boolean hasRPCRate =false;</span>
<span class="fc" id="L331">		boolean needVH = false;</span>
<span class="fc" id="L332">		boolean hasVH = false;</span>
<span class="fc" id="L333">		boolean needVAR = false;</span>
<span class="fc" id="L334">		boolean hasVAR = false;</span>
<span class="fc" id="L335">		boolean needCV_VH  = false;</span>
<span class="fc" id="L336">		boolean hasCV_VH  = false;</span>
<span class="fc" id="L337">		boolean needFTE =false;</span>
<span class="fc" id="L338">		boolean hasFTE =false;</span>
<span class="fc" id="L339">		boolean needASTF = false;</span>
<span class="fc" id="L340">		boolean hasASTF = false;</span>
<span class="fc" id="L341">		boolean needAFTE =false;</span>
<span class="fc" id="L342">		boolean hasAFTE =false;</span>
<span class="fc" id="L343">		boolean needASAWEIGHT = false;</span>
<span class="fc" id="L344">		boolean hasASAWEIGHT = false;</span>

<span class="fc bfc" id="L346" title="All 2 branches covered.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="pc bpc" id="L347" title="3 of 24 branches missed.">			switch(types[i]) {</span>
				case Trace.CV:
<span class="fc" id="L349">					hasCV = true;</span>
<span class="fc" id="L350">					break;</span>
				case Trace.AHT:
<span class="fc" id="L352">					needCV = true;</span>
<span class="fc" id="L353">					needConnects=true;</span>
<span class="fc" id="L354">					needCRate=true;</span>
<span class="fc" id="L355">					needDials=true;</span>
<span class="fc" id="L356">					needCV_VH=true;</span>
<span class="fc" id="L357">					needVH=true;</span>
<span class="fc" id="L358">					break;</span>
				case Trace.PCA:
				case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
				case Trace.SERVICE_GOALS_PCA_DEFERRED:
<span class="fc" id="L362">					needCV = true;</span>
<span class="fc" id="L363">					needVAR=true;</span>
<span class="fc" id="L364">					needVH=true;</span>
<span class="fc" id="L365">					needABN = true;</span>
<span class="fc" id="L366">					break;</span>
				case Trace.ABANDONMENT:
<span class="fc" id="L368">					hasABN = true;</span>
<span class="fc" id="L369">					break;</span>
				case Trace.OCCUPANCY:
<span class="fc" id="L371">					needSTF = true;</span>
<span class="fc" id="L372">					break;</span>
				case Trace.STAFFING:
<span class="fc" id="L374">					hasSTF = true;</span>
<span class="fc" id="L375">					needFTE=true;</span>
<span class="fc" id="L376">					break;</span>
				case Trace.FTE:
<span class="fc" id="L378">					hasFTE = true;</span>
<span class="fc" id="L379">					break;</span>
				case Trace.ASTAFFING:
<span class="fc" id="L381">					hasASTF = true;</span>
<span class="fc" id="L382">					needAFTE=true;</span>
<span class="fc" id="L383">					break;</span>
				case Trace.AFTE:
<span class="fc" id="L385">					hasAFTE = true;</span>
<span class="fc" id="L386">					break;</span>
				case Trace.NETSTAFFING:
<span class="fc" id="L388">					needASTF=true;</span>
<span class="fc" id="L389">					needAFTE=true;</span>
<span class="fc" id="L390">					needFTE=true;</span>
<span class="fc" id="L391">					needSTF=true;</span>
<span class="fc" id="L392">					break;</span>
				case Trace.ASA:
<span class="fc" id="L394">					needABN = true;</span>
<span class="fc" id="L395">					needCV = true;</span>
<span class="fc" id="L396">					needVH= true;</span>
<span class="fc" id="L397">					needASAWEIGHT = true;</span>
<span class="fc" id="L398">					break;</span>
				case Trace.SERVICE_GOALS_ASA:
<span class="nc" id="L400">					needABN = true;</span>
<span class="nc" id="L401">					needCV = true;</span>
<span class="nc" id="L402">					needVH = true;</span>
<span class="nc" id="L403">					break;</span>
				case Trace.DIALS:
<span class="fc" id="L405">					hasDials =true;</span>
<span class="fc" id="L406">					break;</span>
				case Trace.CONNECTS:
<span class="fc" id="L408">					hasConnects =true;</span>
<span class="fc" id="L409">					needCRate =true;</span>
<span class="fc" id="L410">					needDials=true;</span>
<span class="fc" id="L411">					break;</span>
				case Trace.CRATE:
<span class="fc" id="L413">					hasCRate = true;</span>
<span class="fc" id="L414">					needConnects = true;</span>
<span class="fc" id="L415">					needDials = true;</span>
<span class="fc" id="L416">					break;</span>
				case Trace.RPC:
<span class="fc" id="L418">					hasRPC = true;</span>
<span class="fc" id="L419">					needRPCRate = true;</span>
<span class="fc" id="L420">					needDials = true;</span>
<span class="fc" id="L421">					break;</span>
				case Trace.RPCRATE:
<span class="fc" id="L423">					hasRPCRate = true;</span>
<span class="fc" id="L424">					needRPC = true;</span>
<span class="fc" id="L425">					needDials = true;</span>
<span class="fc" id="L426">					break;</span>
				case Trace.RPCAHT:
<span class="fc" id="L428">					needRPC = true;</span>
<span class="fc" id="L429">					needRPCRate = true;</span>
<span class="fc" id="L430">					needDials = true;</span>
<span class="fc" id="L431">					break;</span>
				case Trace.VH:
<span class="fc" id="L433">					hasVH = true;</span>
<span class="fc" id="L434">					break;</span>
				case Trace.VAR:
<span class="fc" id="L436">					hasVAR = true;</span>
<span class="fc" id="L437">					break;</span>
				case Trace.CV_VH:
<span class="fc" id="L439">					hasCV_VH = true;</span>
<span class="fc" id="L440">					break;</span>
				case Trace.FORECASTING_AHT:
<span class="nc" id="L442">					needCV = true;</span>
<span class="nc" id="L443">					needCRate=true;</span>
<span class="nc" id="L444">					needCV_VH=true;</span>
<span class="nc" id="L445">					needVH=true;</span>
<span class="nc" id="L446">					break;</span>
				case Trace.FORECASTING_RPCAHT:
<span class="nc" id="L448">					needRPCRate = true;</span>
<span class="nc" id="L449">					break;</span>
				default:
			}
		}
		// At most add 8 more types
<span class="fc" id="L454">		short[] result = new short[types.length + 11];</span>
<span class="fc" id="L455">		int length = types.length;</span>
<span class="fc" id="L456">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="pc bpc" id="L457" title="1 of 4 branches missed.">		if (needCV &amp;&amp; !hasCV) {</span>
<span class="fc" id="L458">			result[length] = Trace.CV;</span>
<span class="fc" id="L459">			length++;</span>
		}
<span class="pc bpc" id="L461" title="1 of 4 branches missed.">		if (needABN &amp;&amp; !hasABN) {</span>
<span class="fc" id="L462">			result[length] = Trace.ABANDONMENT;</span>
<span class="fc" id="L463">			length++;</span>
		}
<span class="pc bpc" id="L465" title="1 of 4 branches missed.">		if (needSTF &amp;&amp; !hasSTF) {</span>
<span class="nc" id="L466">			result[length] = Trace.STAFFING;</span>
<span class="nc" id="L467">			length++;</span>
		}
<span class="pc bpc" id="L469" title="1 of 4 branches missed.">		if (needFTE &amp;&amp; !hasFTE) {</span>
<span class="nc" id="L470">			result[length] = Trace.FTE;</span>
<span class="nc" id="L471">			length++;</span>
		}
<span class="pc bpc" id="L473" title="1 of 4 branches missed.">		if (needASTF &amp;&amp; !hasASTF) {</span>
<span class="nc" id="L474">			result[length] = Trace.ASTAFFING;</span>
<span class="nc" id="L475">			length++;</span>
		}
<span class="pc bpc" id="L477" title="1 of 4 branches missed.">		if (needAFTE &amp;&amp; !hasAFTE) {</span>
<span class="nc" id="L478">			result[length] = Trace.AFTE;</span>
<span class="nc" id="L479">			length++;</span>
		}
<span class="fc bfc" id="L481" title="All 4 branches covered.">		if (needDials &amp;&amp; !hasDials) {</span>
<span class="fc" id="L482">			result[length] = Trace.DIALS;</span>
<span class="fc" id="L483">			length++;</span>
		}
<span class="fc bfc" id="L485" title="All 4 branches covered.">		if (needConnects &amp;&amp; !hasConnects) {</span>
<span class="fc" id="L486">			result[length] = Trace.CONNECTS;</span>
<span class="fc" id="L487">			length++;</span>
		}
<span class="fc bfc" id="L489" title="All 4 branches covered.">		if (needCRate &amp;&amp; !hasCRate) {</span>
<span class="fc" id="L490">			result[length] = Trace.CRATE;</span>
<span class="fc" id="L491">			length++;</span>
		}
<span class="pc bpc" id="L493" title="1 of 4 branches missed.">		if (needRPC &amp;&amp; !hasRPC) {</span>
<span class="nc" id="L494">			result[length] = Trace.RPC;</span>
<span class="nc" id="L495">			length++;</span>
		}
<span class="pc bpc" id="L497" title="1 of 4 branches missed.">		if (needRPCRate &amp;&amp; !hasRPCRate) {</span>
<span class="nc" id="L498">			result[length] = Trace.RPCRATE;</span>
<span class="nc" id="L499">			length++;</span>
		}
<span class="pc bpc" id="L501" title="1 of 4 branches missed.">		if (needVH &amp;&amp; !hasVH) {</span>
<span class="fc" id="L502">			result[length] = Trace.VH;</span>
<span class="fc" id="L503">			length++;</span>
		}
<span class="pc bpc" id="L505" title="1 of 4 branches missed.">		if (needVAR &amp;&amp; !hasVAR) {</span>
<span class="fc" id="L506">			result[length] = Trace.VAR;</span>
<span class="fc" id="L507">			length++;</span>
		}
<span class="fc bfc" id="L509" title="All 4 branches covered.">		if (needCV_VH &amp;&amp; !hasCV_VH) {</span>
<span class="fc" id="L510">			result[length] = Trace.CV_VH;</span>
<span class="fc" id="L511">			length++;</span>
		}
<span class="pc bpc" id="L513" title="2 of 4 branches missed.">		if (needASAWEIGHT &amp;&amp; !hasASAWEIGHT) {</span>
<span class="fc" id="L514">			result[length] = Trace.ASA_WEIGHT;</span>
<span class="fc" id="L515">			length++;</span>
		}

<span class="fc" id="L518">		short[] retResult = new short[length];</span>
<span class="fc" id="L519">		System.arraycopy(types, 0, retResult, 0, types.length);</span>
<span class="pc bpc" id="L520" title="1 of 2 branches missed.">		if (length &gt; types.length) {</span>
<span class="fc" id="L521">			System.arraycopy(result, types.length, retResult, types.length, length - types.length);</span>
		}
<span class="fc" id="L523">		return retResult;</span>
	}

	/**
	 * Aggregatable check
	 * @param cube
	 * @param type
	 * @return boolean
	 */
	public static boolean aggregatable(TraceCube cube, short type) {
<span class="nc bnc" id="L533" title="All 2 branches missed.">		if (cube.getTraceValueD(type) == null) {</span>
<span class="nc" id="L534">			return false;</span>
		}
<span class="nc" id="L536">		short[] oType = new short[1];</span>
<span class="nc" id="L537">		oType[0] = type;</span>
<span class="nc" id="L538">		short[] aType = getAggTraceType(oType);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">		for (int i=0; i&lt;aType.length; i++) {</span>
<span class="nc bnc" id="L540" title="All 2 branches missed.">			if (cube.getTraceValueD(aType[i]) == null) {</span>
<span class="nc" id="L541">				return false;</span>
			}
		}
<span class="nc" id="L544">		return true;</span>
	}
	/**
	 * Different trace statistics has different value type
	 * @param type
	 * @return short, metric type
	 */
	public static short getMetricType(short type) {
<span class="nc bnc" id="L552" title="All 4 branches missed.">		switch(type) {</span>
			case Trace.CV:
			case Trace.OCCUPANCY:
			case Trace.BACKLOG:
			case Trace.ABANDONMENT:
			case Trace.DIALS:
			case Trace.CONNECTS:
			case Trace.RPC:
			case Trace.VH:
			case Trace.VAR:
			case Trace.MAX_DIALS:
<span class="nc" id="L563">				return NUMBER_STAT;</span>
			case Trace.PCA:
			case Trace.SERVICE_GOALS_PCA_IMMEDIATE:
			case Trace.SERVICE_GOALS_PCA_DEFERRED:
			case Trace.CRATE:
			case Trace.FORECASTING_CRATE:
			case Trace.RPCRATE:
			case Trace.FORECASTING_RPCRATE:
<span class="nc" id="L571">				return PERCENTAGE_STAT;</span>
			case Trace.FTE:
			case Trace.STAFFING:
			case Trace.AHT:
			case Trace.FORECASTING_AHT:
			case Trace.ASA:
			case Trace.SERVICE_GOALS_ASA:
			case Trace.RPCAHT:
			case Trace.FORECASTING_RPCAHT:
			case Trace.DEADLINE_TIME:
			case Trace.SERVICE_GOALS_DEADLINE_TIME:
			case Trace.AFTE:
			case Trace.ASTAFFING:
			case Trace.NETSTAFFING:
<span class="nc" id="L585">				return TIMEINTERVAL_STAT;</span>
			default:
<span class="nc" id="L587">				return (short)-1;</span>
		}
	}
	/**
	 * For combined view, we have to include more trace types
	 * For example, ASA is Sum(ABN*ASA)/Sum(ABN)
	 * @param types
	 * @return short[]
	 */
	public static short[] getCmbTraceType(short[] types) {
<span class="fc" id="L597">           return getAggTraceType( types);</span>
	}
	/**
	 * Filter out Trace Types, based on supported Trace Types of the TraceCube
	 * @param cube
	 * @param types array of shorts of types
	 * @return short[]
	 */
	public static short[] getSupportedTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L606">		int j = 0;</span>
<span class="nc" id="L607">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L608" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L609" title="All 2 branches missed.">			if (!cube.supportType(types[i])) {</span>
<span class="nc" id="L610">				removed[j] = types[i];</span>
<span class="nc" id="L611">				j++;</span>
			}
		}
<span class="nc bnc" id="L614" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">			if (j == types.length) {</span>
<span class="nc" id="L616">				return null;</span>
			}
<span class="nc" id="L618">			short[] result = new short[types.length-j];</span>
<span class="nc" id="L619">			int k = 0;</span>
<span class="nc" id="L620">			int i = 0;</span>
<span class="nc bnc" id="L621" title="All 2 branches missed.">			for (int l = 0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L622" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L623">					result[i] = types[l];</span>
<span class="nc" id="L624">					i++;</span>
<span class="nc" id="L625">					continue;</span>
				}
<span class="nc bnc" id="L627" title="All 2 branches missed.">				if (types[l] != removed[k]) {</span>
<span class="nc" id="L628">					result[i] = types[l];</span>
<span class="nc" id="L629">					i++;</span>
				} else {
<span class="nc" id="L631">					k++;</span>
				}
			}
<span class="nc" id="L634">			return result;</span>
		}
<span class="nc" id="L636">		short[] result = new short[types.length];</span>
<span class="nc" id="L637">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L638">		return result;</span>
	}

	/**
	 * Helper function to tell if a type is defined in the given cube or not
	 * @param cube
	 * @param type
	 * @return
	 */
	public static boolean containTraceType(TraceCube cube, short type) {
<span class="nc bnc" id="L648" title="All 2 branches missed.">		if (cube.getTraceTypes() != null) {</span>
<span class="nc bnc" id="L649" title="All 2 branches missed.">			for (int i=0; i&lt;cube.getTraceTypes().length; i++) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">				if (type == cube.getTraceTypes()[i]) {</span>
<span class="nc" id="L651">					return true;</span>
				}
			}
		}
<span class="nc" id="L655">		return false;</span>
	}
	/**
	 * Get Trace Types, that is support to particular TraceCube
	 * @param cube
	 * @param types array of shorts of types
	 * @return short[], Valid Trace Types
	 */
	public static short[] containTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L664">		int j = 0;</span>
<span class="nc" id="L665">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L666" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L667" title="All 2 branches missed.">			if (cube.getTraceValueD(types[i]) == null) {</span>
<span class="nc" id="L668">				removed[j] = types[i];</span>
<span class="nc" id="L669">				j++;</span>
			}
		}
<span class="nc bnc" id="L672" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L673" title="All 2 branches missed.">			if (j == types.length) {</span>
<span class="nc" id="L674">				return null;</span>
			}
<span class="nc" id="L676">			short[] result = new short[types.length-j];</span>
<span class="nc" id="L677">			int i = 0;</span>
<span class="nc" id="L678">			int k = 0;</span>
<span class="nc bnc" id="L679" title="All 2 branches missed.">			for (int l = 0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L680" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L681">					result[i] = types[l];</span>
<span class="nc" id="L682">					i++;</span>
<span class="nc" id="L683">					continue;</span>
				}
<span class="nc bnc" id="L685" title="All 2 branches missed.">				if (types[l] != removed[k]) {</span>
<span class="nc" id="L686">					result[i] = types[l];</span>
<span class="nc" id="L687">					i++;</span>
				} else {
<span class="nc" id="L689">					k++;</span>
				}
			}
<span class="nc" id="L692">			return result;</span>
		}
<span class="nc" id="L694">		short[] result = new short[types.length];</span>
<span class="nc" id="L695">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L696">		return result;</span>
	}
	/**
	 * Based a cube, given an array of trace types
	 * Only return types not support by the given cube
	 * @param cube
	 * @param types
	 * @return short[][], [0] unsupported types, [1] supported types
	 */
	public static short[][] filterOutTraceType(TraceCube cube, short[] types) {
<span class="nc bnc" id="L706" title="All 2 branches missed.">		if (cube == null) {</span>
			// This means it doesn't support combined mode, everything goes to individual queues
<span class="nc" id="L708">			short[][] result = new short[2][0];</span>
<span class="nc" id="L709">			result[0] = null;</span>
<span class="nc" id="L710">			result[1] = new short[types.length];</span>
<span class="nc" id="L711">			System.arraycopy(types, 0, result[1], 0, types.length);</span>
<span class="nc" id="L712">			return result;</span>
		}
<span class="nc" id="L714">		short[] removed = new short[types.length];</span>
<span class="nc" id="L715">		short[] retained = new short[types.length];</span>
<span class="nc" id="L716">		short[] supported = cube.getTraceTypes();</span>
<span class="nc" id="L717">		int k=0;</span>
<span class="nc" id="L718">		int l=0;</span>
<span class="nc bnc" id="L719" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L720">			boolean found = false;</span>
<span class="nc bnc" id="L721" title="All 2 branches missed.">			for (int j=0; j&lt;supported.length; j++) {</span>
<span class="nc bnc" id="L722" title="All 2 branches missed.">				if (types[i] == supported[j]) {</span>
<span class="nc" id="L723">					found = true;</span>
<span class="nc" id="L724">					retained[l] = types[i];</span>
<span class="nc" id="L725">					l++;</span>
<span class="nc" id="L726">					break;</span>
				}
			}
<span class="nc bnc" id="L729" title="All 2 branches missed.">			if (!found) {</span>
<span class="nc" id="L730">				removed[k] = types[i];</span>
<span class="nc" id="L731">				k++;</span>
			}
		}
<span class="nc bnc" id="L734" title="All 4 branches missed.">		if (k != 0 || l!=0) {</span>
<span class="nc" id="L735">			short[][] result = new short[2][0];</span>
<span class="nc bnc" id="L736" title="All 2 branches missed.">			if (k != 0) {</span>
<span class="nc" id="L737">				short[] resultRemoved = new short[k];</span>
<span class="nc" id="L738">				System.arraycopy(removed, 0, resultRemoved, 0, k);</span>
<span class="nc" id="L739">				result[0] = resultRemoved;</span>
<span class="nc" id="L740">			} else {</span>
<span class="nc" id="L741">				result[0] = null;</span>
			}
<span class="nc bnc" id="L743" title="All 2 branches missed.">			if (l!=0) {</span>
<span class="nc" id="L744">				short[] resultRetained = new short[l];</span>
<span class="nc" id="L745">				System.arraycopy(retained, 0, resultRetained, 0, l);</span>
<span class="nc" id="L746">				result[1] = resultRetained;</span>
<span class="nc" id="L747">			} else {</span>
<span class="nc" id="L748">				result[1] = null;</span>
			}
<span class="nc" id="L750">			return result;</span>
		}
<span class="nc" id="L752">		return null;</span>
	}
	/**
	 * Filter out Trace Types, that is not valid to particular TraceCube, or not dirty
	 * @param cube
	 * @param types, Trace Types
	 * @return short[], Valid Trace Types
	 */
	public static short[] filterTraceType(TraceCube cube, short[] types) {
<span class="nc" id="L761">		int j = 0;</span>
<span class="nc" id="L762">		int[] removed = new int[types.length];</span>
<span class="nc bnc" id="L763" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc bnc" id="L764" title="All 2 branches missed.">			if (cube.getTraceValueD(types[i]) == null ||</span>
<span class="nc bnc" id="L765" title="All 2 branches missed.">				!cube.isDirty(types[i])) {</span>
<span class="nc" id="L766">				removed[j] = types[i];</span>
<span class="nc" id="L767">				j++;</span>
			}
		}
<span class="nc bnc" id="L770" title="All 2 branches missed.">		if (j != 0) {</span>
<span class="nc bnc" id="L771" title="All 2 branches missed.">			if (j == types.length) {</span>
<span class="nc" id="L772">				return null;</span>
			}
<span class="nc" id="L774">			short[] result = new short[types.length-j];</span>
<span class="nc" id="L775">			int k = 0;</span>
<span class="nc" id="L776">			int i = 0;</span>
<span class="nc bnc" id="L777" title="All 2 branches missed.">			for (int l = 0; l &lt; types.length; l++) {</span>
<span class="nc bnc" id="L778" title="All 2 branches missed.">				if (k &gt;= removed.length) {</span>
<span class="nc" id="L779">					result[i] = types[l];</span>
<span class="nc" id="L780">					i++;</span>
<span class="nc" id="L781">					continue;</span>
				}
<span class="nc bnc" id="L783" title="All 2 branches missed.">				if (types[l] != removed[k]) {</span>
<span class="nc" id="L784">					result[i] = types[l];</span>
<span class="nc" id="L785">					i++;</span>
				} else {
<span class="nc" id="L787">					k++;</span>
				}
			}
<span class="nc" id="L790">			return result;</span>
		}
<span class="nc" id="L792">		short[] result = new short[types.length];</span>
<span class="nc" id="L793">		System.arraycopy(types, 0, result, 0, types.length);</span>
<span class="nc" id="L794">		return result;</span>
	}
	/**
	 * Calculate points in between start and end dates in a given TimeZone
	 * Additional flag indicating if DST should be considered or not
	 * @param start
	 * @param end
	 * @param tz
	 * @param considerDST
	 * @return int, points
	 */
	public static int gapOffSet(Date start, Date end, TimeZone tz, boolean considerDST) {
<span class="nc" id="L806">		int initPoints = dissectPeriod(start, end)[1];</span>
<span class="nc bnc" id="L807" title="All 6 branches missed.">		if (tz== null || !tz.useDaylightTime() || !considerDST ||</span>
<span class="nc bnc" id="L808" title="All 2 branches missed.">			tz.inDaylightTime(start) == tz.inDaylightTime(end)) {</span>
<span class="nc" id="L809">			return initPoints;</span>
		}
		// divide DST adjustment by 15 minutes
<span class="nc" id="L812">		int points = tz.getDSTSavings()/900000;</span>
		// From STD to DST, we lost points
<span class="nc bnc" id="L814" title="All 2 branches missed.">		if (!tz.inDaylightTime(start)) {</span>
<span class="nc" id="L815">			return initPoints + points;</span>
		}
<span class="nc" id="L817">		return initPoints - points;</span>
	}
	/**
	 * To calculate the gapOffSet between any given date and a base
	 * @param start, start time treated as midnight
	 * @param offSet
	 * @param end
	 * @return int
	 */
	public static int gapOffSet(Date start, short offSet, Date end) {
<span class="fc" id="L827">		InsertionPoint resultObject = getInsertionPoint(end);</span>
<span class="fc" id="L828">		int result = resultObject.offset;</span>
<span class="fc" id="L829">		Date endDate = resultObject.startDate;</span>
		// Next line can be tuned later
<span class="fc" id="L831">		int days = TimeZoneUtil.numberOfDaysRound(start, endDate);</span>
<span class="fc" id="L832">		result = Trace.DAYPOINTS*days+result-offSet;</span>
<span class="fc" id="L833">		return result;</span>
	}
	/**
	 * Dissect a Period into Starting Day OffSet and OffSet between Period
	 * @param start
	 * @param end
	 * @return int[], 0 is Start Day OffSet, 1 is Gap OffSet
	 */
	public static int[] dissectPeriod(Date start, Date end) {
<span class="nc" id="L842">		int[] result = new int[2];</span>
<span class="nc" id="L843">		InsertionPoint startPoint = getInsertionPoint(start);</span>
<span class="nc" id="L844">		InsertionPoint endPoint = getInsertionPoint(end);</span>
<span class="nc" id="L845">		result[0] = startPoint.offset;</span>
<span class="nc" id="L846">		result[1] = endPoint.offset;</span>
<span class="nc" id="L847">		int days = TimeZoneUtil.numberOfDaysRound(startPoint.startDate, endPoint.startDate);</span>
<span class="nc" id="L848">		result[1] = Trace.DAYPOINTS*days-result[0]+result[1];</span>
<span class="nc" id="L849">		return result;</span>
	}
	/**
	 * Simpler routine, just to calculate the OffSet to mid-night
	 * Mid-night starts from 1
	 */
	public static short getOffSet(Date date) {
<span class="nc" id="L856">		return getOffSet(date, TimeZoneUtil.GMT_TIMEZONE);</span>
	}
	public static short getOffSet(Date date, TimeZone tz) {
<span class="nc" id="L859">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L860">		cal.setTime(date);</span>
<span class="nc" id="L861">		short offSet = calculateOffsetGivenDateAndCalendar(cal);</span>
<span class="nc" id="L862">		return ++offSet;</span>
	}
	/**
	 * Routine to check if the Type is predefined or not
	 */
	public static boolean isPredefinedType(short type) {
<span class="nc bnc" id="L868" title="All 2 branches missed.">		for (int i = 0; i &lt; Trace.TYPES.length; i++) {</span>
<span class="nc bnc" id="L869" title="All 2 branches missed.">			if (type == Trace.TYPES[i]) {</span>
<span class="nc" id="L870">				return true;</span>
			}
		}
<span class="nc" id="L873">		return false;</span>
	}

	/**
	 * Giving a day find the absolute offset in the TraceCube
	 * @param cube
	 * @param tz
	 * @param day, which day
	 * @param considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getDailyRange(TraceCube cube, TimeZone tz, int day, boolean considerDST) {
<span class="nc bnc" id="L885" title="All 2 branches missed.">		if (cube == null) {</span>
<span class="nc" id="L886">			return new int[0];</span>
		}
<span class="nc" id="L888">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L889" title="All 4 branches missed.">		if (start == null || tz == null) {</span>
<span class="nc" id="L890">			return new int[0];</span>
		}
<span class="nc" id="L892">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L893">		cal.setTime(start);</span>
<span class="nc" id="L894">		setTimeOnCalendarToZero(cal);</span>
<span class="nc" id="L895">		cal.add(Calendar.DATE, 1);</span>
		// First day's absolute ending position
<span class="nc" id="L897">		int pos = Trace.DAYPOINTS - cube.getStartOffSet();</span>
<span class="nc bnc" id="L898" title="All 2 branches missed.">		if (!tz.equals(TimeZoneUtil.GMT_TIMEZONE)) {</span>
<span class="nc" id="L899">			pos = TraceUtil.dissectPeriod(start, cal.getTime())[1]-1;</span>
		}
<span class="nc" id="L901">		int[] result = new int[2];</span>
<span class="nc" id="L902">		result[1] = pos;</span>
		// If trying to get first day
<span class="nc bnc" id="L904" title="All 2 branches missed.">		if (day == 0) {</span>
<span class="nc" id="L905">			return result;</span>
		}
		// Need figure out how to adjust days based on TimeZone
		int begin;
<span class="nc" id="L909">		int end = pos;</span>
<span class="nc bnc" id="L910" title="All 4 branches missed.">		if (!considerDST || !tz.useDaylightTime()) {</span>
<span class="nc" id="L911">			result[0] = end+1+Trace.DAYPOINTS*(day-1);</span>
<span class="nc" id="L912">			result[1] = result[0]+Trace.DAYPOINTS-1;</span>
		} else {
<span class="nc" id="L914">			begin = end + 1;</span>
<span class="nc" id="L915">			int dayValue = day;</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">			while (dayValue &gt; 0) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L918">				start = cal.getTime();</span>
<span class="nc" id="L919">				cal.add(Calendar.DATE, 1);</span>
<span class="nc" id="L920">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L921">				dayValue--;</span>
<span class="nc bnc" id="L922" title="All 2 branches missed.">				if (dayValue &gt; 0) {</span>
<span class="nc" id="L923">					begin = end + 1;</span>
				}
			}
<span class="nc" id="L926">			result[0] = begin;</span>
<span class="nc" id="L927">			result[1] = end;</span>
		}
<span class="nc" id="L929">		return result;</span>
	}

	/**
	 * Giving an hour find the absolute offset in the TraceCube
	 * @param cube
	 * @param tz
	 * @param hour, which hour
	 * @param considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getHourlyRange(TraceCube cube, TimeZone tz, int hour, boolean considerDST) {
<span class="nc bnc" id="L941" title="All 2 branches missed.">		if (cube == null) {</span>
<span class="nc" id="L942">			return new int[0];</span>
		}
<span class="nc" id="L944">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L945" title="All 4 branches missed.">		if (start == null || tz == null) {</span>
<span class="nc" id="L946">			return new int[0];</span>
		}
<span class="nc" id="L948">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L949">		cal.setTime(start);</span>
<span class="nc" id="L950">		int startMin = cal.get(Calendar.MINUTE);</span>
<span class="nc" id="L951">		cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L952">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L953">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L954">		cal.add(Calendar.HOUR_OF_DAY, 1);</span>
		// Get the absolute position
<span class="nc" id="L956">		int pos = startMin/15;</span>
		// Need figure out how many hours
<span class="nc" id="L958">		int begin = 0;</span>
		// if end point is already 3, then firt hour only one point
<span class="nc bnc" id="L960" title="All 2 branches missed.">		int end = (3-pos)==0?3:(3-pos);</span>
		// if there is no DST, or DST's offset is multiple of hours
<span class="nc bnc" id="L962" title="All 4 branches missed.">		boolean normHandling = !tz.useDaylightTime() || tz.getDSTSavings()%3600000 == 0;</span>
<span class="nc" id="L963">		int[] result = new int[2];</span>
<span class="nc" id="L964">		result[0] = begin;</span>
<span class="nc" id="L965">		result[1] = end;</span>
<span class="nc bnc" id="L966" title="All 4 branches missed.">		if (!considerDST || normHandling) {</span>
<span class="nc bnc" id="L967" title="All 2 branches missed.">			if (hour &gt;0) {</span>
<span class="nc" id="L968">				result[0] = result[1]+1+4*(hour-1);</span>
<span class="nc" id="L969">				result[1] = result[0]+3;</span>
			}
		} else {
<span class="nc" id="L972">			begin = end + 1;</span>
<span class="nc" id="L973">			int hours = 0;</span>
<span class="nc bnc" id="L974" title="All 2 branches missed.">			while (hours &lt; hour) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L976">				start = cal.getTime();</span>
<span class="nc" id="L977">				cal.add(Calendar.HOUR, 1);</span>
<span class="nc" id="L978">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L979">				result[0] = begin;</span>
<span class="nc" id="L980">				result[1] = end;</span>
<span class="nc" id="L981">				begin = end + 1;</span>
<span class="nc" id="L982">				hours++;</span>
			}
		}
<span class="nc" id="L985">		return result;</span>
	}

	/**
	 * Giving a week find the absolute offset in the TraceCube
	 * @param cube
	 * @param tz
	 * @param week, which week
	 * @param firstDayOfWeek day of a week
	 * @param considerDST, should consider DST effect
	 * @return int[], 0 start, 1 end
	 */
	public static int[] getWeeklyRange(TraceCube cube, TimeZone tz, int week, int firstDayOfWeek, boolean considerDST) {
<span class="nc bnc" id="L998" title="All 2 branches missed.">		if (cube == null) {</span>
<span class="nc" id="L999">			return new int[0];</span>
		}
<span class="nc" id="L1001">		Date start = cube.getRawStartDate();</span>
<span class="nc bnc" id="L1002" title="All 4 branches missed.">		if (start == null || tz == null) {</span>
<span class="nc" id="L1003">			return new int[0];</span>
		}
<span class="nc" id="L1005">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1006">		cal.setTime(start);</span>
<span class="nc" id="L1007">		setTimeOnCalendarToZero(cal);</span>
<span class="nc" id="L1008">		int currentDayOfWeek = cal.get(Calendar.DAY_OF_WEEK);</span>
		// If start day is the first day of the week
<span class="nc bnc" id="L1010" title="All 2 branches missed.">		if (currentDayOfWeek == firstDayOfWeek) {</span>
<span class="nc" id="L1011">			cal.add(Calendar.WEEK_OF_YEAR, 1);</span>
		} else {
			do {
<span class="nc" id="L1014">				cal.add(Calendar.DATE, 1);</span>
<span class="nc bnc" id="L1015" title="All 2 branches missed.">			} while(cal.get(Calendar.DAY_OF_WEEK) != firstDayOfWeek);</span>
		}
		// First day's absolute ending position
<span class="nc" id="L1018">		int pos = TraceUtil.dissectPeriod(start, cal.getTime())[1]-1;</span>
		// Need figure out how many days
<span class="nc" id="L1020">		int begin = 0;</span>
<span class="nc" id="L1021">		int end = pos;</span>
<span class="nc" id="L1022">		int[] result = new int[2];</span>
<span class="nc" id="L1023">		result[0] = begin;</span>
<span class="nc" id="L1024">		result[1] = end;</span>
<span class="nc bnc" id="L1025" title="All 4 branches missed.">		if (!considerDST || !tz.useDaylightTime()) {</span>
<span class="nc bnc" id="L1026" title="All 2 branches missed.">			if (week &gt; 0) {</span>
<span class="nc" id="L1027">				result[0] = result[1]+1+Trace.WEEKPOINTS*(week-1);</span>
<span class="nc" id="L1028">				result[1] = result[0]+Trace.WEEKPOINTS-1;</span>
			}
		} else {
<span class="nc" id="L1031">			begin = end + 1;</span>
<span class="nc" id="L1032">			int weeks = 0;</span>
<span class="nc bnc" id="L1033" title="All 2 branches missed.">			while (weeks &lt; week) {</span>
				// change it based on TimeZone to handle DST issue
<span class="nc" id="L1035">				start = cal.getTime();</span>
<span class="nc" id="L1036">				cal.add(Calendar.WEEK_OF_YEAR, 1);</span>
<span class="nc" id="L1037">				end += TraceUtil.dissectPeriod(start, cal.getTime())[1];</span>
<span class="nc" id="L1038">				result[0] = begin;</span>
<span class="nc" id="L1039">				result[1] = end;</span>
<span class="nc" id="L1040">				begin = end + 1;</span>
<span class="nc" id="L1041">				weeks ++;</span>
			}
		}
<span class="nc" id="L1044">		return result;</span>
	}

	/**
	 * Returns a new trace cube, most of whose data are identical to the source trace cube,
	 * but whose start date is the specified new start date.  Only the date portion of the
	 * new start date is used; the hours and minutes are copied from the start date of the
	 * source trace cube.
	 *
	 * The potential differences involve daylight savings.  In particular, the local
	 * time of day for each point in the new trace cube must match the local time of day
	 * for the corresponding point in the source trace cube.  This means that some or
	 * all points in the resulting trace cube might be offset from the corresponding
	 * points in the source trace cube.
	 *
	 * Only the trace types returned by &lt;code&gt;sourceCube.getTraceTypes()&lt;/code&gt; are
	 * processed; any data in other types will be missing from the resulting trace
	 * cube.
	 *
	 * @param sourceCube
	 * @param newRawStartDate
	 * @param timeZone
	 * @return
	 * @throws BbmTimeSeriesException
	 */
	public static TraceCube getTimeShiftedTraceCube(TraceCube sourceCube, Date newRawStartDate, TimeZone timeZone)
			throws BbmTimeSeriesException {

<span class="nc" id="L1072">		Date oldRawStartDate = sourceCube.getRawStartDate();</span>
<span class="nc" id="L1073">		Date oldRawEndDate = sourceCube.getRawEndDate();</span>
<span class="nc" id="L1074">		Calendar oldRawStartCal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L1075">		oldRawStartCal.setTime(oldRawStartDate);</span>
<span class="nc" id="L1076">		Calendar newRawStartCal = Calendar.getInstance(timeZone);</span>
<span class="nc" id="L1077">		newRawStartCal.setTime(newRawStartDate);</span>
<span class="nc" id="L1078">		newRawStartCal.set(Calendar.HOUR_OF_DAY, oldRawStartCal.get(Calendar.HOUR_OF_DAY));</span>
<span class="nc" id="L1079">		newRawStartCal.set(Calendar.MINUTE, oldRawStartCal.get(Calendar.MINUTE));</span>
<span class="nc" id="L1080">		newRawStartCal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L1081">		newRawStartCal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L1082">		Date newRawStartDateFromCal = newRawStartCal.getTime();</span>

		// Calculate new end date based on current raw start date, new raw start date,
		// and time zone.
<span class="nc" id="L1086">		Date newRawEndDate = TimeZoneUtil.getShiftedDate(oldRawStartDate, newRawStartDateFromCal,</span>
				oldRawEndDate, timeZone);

<span class="nc bnc" id="L1089" title="All 2 branches missed.">		assert TimeZoneUtil.numberOfDaysRound(oldRawStartDate, oldRawEndDate) ==</span>
<span class="nc bnc" id="L1090" title="All 2 branches missed.">			   TimeZoneUtil.numberOfDaysRound(newRawStartDateFromCal, newRawEndDate);</span>

<span class="nc" id="L1092">		TraceCube result = sourceCube.newInstance(sourceCube.getQueueID(), newRawStartDateFromCal, newRawEndDate,</span>
<span class="nc" id="L1093">				sourceCube.getTraceTypes());</span>

<span class="nc" id="L1095">		int totalNewMinutes = TimeZoneUtil.numberOfMinutes(newRawStartDateFromCal, newRawEndDate);</span>
<span class="nc" id="L1096">		int newPointsCount = totalNewMinutes / TraceCube.INTERVAL;</span>
		// Create an array indexed by index into the target trace array, whose values
		// are the indices of the corresponding elements in the source trace array.
<span class="nc" id="L1099">		int[] sourceIndices = new int[newPointsCount];</span>
<span class="nc" id="L1100">		int deltaIndex = 0;</span>
		// For each 15-minute interval in the new trace, we calculate the index in the source trace
		// that corresponds to the same local time on the corresponding day of the target trace.
<span class="nc bnc" id="L1103" title="All 2 branches missed.">		for (Date currentTargetDate = newRawStartDateFromCal; currentTargetDate.before(newRawEndDate);</span>
<span class="nc" id="L1104">			 currentTargetDate = new Date(currentTargetDate.getTime() + TraceCube.INTERVAL_IN_MILLIS)) {</span>
<span class="nc" id="L1105">			Date currentSourceDate = TimeZoneUtil.getShiftedDate(newRawStartDateFromCal, oldRawStartDate,</span>
					currentTargetDate, timeZone);
<span class="nc bnc" id="L1107" title="All 2 branches missed.">			if (currentSourceDate == null) {</span>
<span class="nc" id="L1108">				sourceIndices[deltaIndex] = -1;</span>
			} else {
<span class="nc" id="L1110">				sourceIndices[deltaIndex] =</span>
<span class="nc" id="L1111">					(int)( (currentSourceDate.getTime() - oldRawStartDate.getTime()) / TraceCube.INTERVAL_IN_MILLIS );</span>
			}
<span class="nc" id="L1113">			deltaIndex++;</span>
		}

		// We rely on sourceCube to have accurate information about its populated trace types.
<span class="nc bnc" id="L1117" title="All 2 branches missed.">		for (short traceType : sourceCube.getTraceTypes()) {</span>
<span class="nc bnc" id="L1118" title="All 2 branches missed.">			if (sourceCube.getTraceValueD(traceType) != null) {</span>
<span class="nc" id="L1119">				result.setTraceValue(traceType,</span>
<span class="nc" id="L1120">						getTimeShiftedTrace(sourceCube.getTraceValueD(traceType), sourceIndices));</span>
			}
		}

<span class="nc" id="L1124">		return result;</span>
	}

	/**
	 * Returns a new trace, using the supplied source indices to map source
	 * array values into the new array.  If an index is -1, that element is
	 * considered unavailable and TRACENA is inserted in the new array at
	 * that point.
	 *
	 * @param sourceTrace
	 * @param sourceIndices
	 * @return double[]
	 */
	static double[] getTimeShiftedTrace(double[] sourceTrace, int[] sourceIndices) {
<span class="nc" id="L1138">		double[] resultTrace = new double[sourceIndices.length];</span>

<span class="nc bnc" id="L1140" title="All 2 branches missed.">		for (int resultIndex = 0; resultIndex &lt; resultTrace.length; ++resultIndex) {</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">			if (sourceIndices[resultIndex] == -1) {</span>
<span class="nc" id="L1142">				resultTrace[resultIndex] = Trace.TRACENA;</span>
			} else {
<span class="nc" id="L1144">				resultTrace[resultIndex] = sourceTrace[sourceIndices[resultIndex]];</span>
			}
		}

<span class="nc" id="L1148">		return resultTrace;</span>
	}

	//TODO: This should be named &quot;round&quot; as it can be called with a float argument.
	/**
	 * This function standardizes rounding used in the Trace domain.
	 *
	 * Rounds a value to the nearest integer.  Values ending in .5 are rounded towards
	 * positive infinity.
	 */
	public static int roundDouble(double value) {
<span class="fc" id="L1159">		return MathUtil.roundHalfCeiling(value);</span>
	}

	/**
	 * validate multiple tracecubes, must have same length, same trace types
	 * as invalid parameters won't be continued in operation, just throw exception
	 * @return TraceCube, a holder traceCube which has the same start/end definition of first TraceCube
	 */
	public static TraceCube validateTraceCubes(TraceCube[] cubes, int[] weight) throws BbmTimeSeriesException {
<span class="nc bnc" id="L1168" title="All 2 branches missed.">		if (weight.length != cubes.length) {</span>
<span class="nc" id="L1169">			throw new BbmTimeSeriesException(BbmTimeSeriesException.WEIGHT_INVALID);</span>
		}
<span class="nc bnc" id="L1171" title="All 2 branches missed.">		for (int i=0; i&lt;weight.length; i++) {</span>
<span class="nc bnc" id="L1172" title="All 2 branches missed.">			if (weight[i] &lt;= 0) {</span>
<span class="nc" id="L1173">				throw new BbmTimeSeriesException(BbmTimeSeriesException.WEIGHT_INVALID);</span>
			}
		}
<span class="nc" id="L1176">		return validateTraceCubes(cubes);</span>
	}

	/**
	 * Get a slice from a TraceCube, for UI display
	 * @param tc, source tracecube
	 * @param startDate
	 * @param endDate
	 * @return TraceCube
	 */
	public static TraceCube sliceTraceCube(TraceCube tc, Date startDate, Date endDate) throws BbmTimeSeriesException {
<span class="nc bnc" id="L1187" title="All 2 branches missed.">		if (tc == null) {</span>
<span class="nc" id="L1188">			return null;</span>
		}
<span class="nc" id="L1190">		TraceCube slice = tc.newInstance(tc.getQueueID(), startDate, endDate, tc.getTraceTypes());</span>
<span class="nc" id="L1191">		short[] types = tc.getTraceTypes();</span>
<span class="nc bnc" id="L1192" title="All 2 branches missed.">		for (int i = 0; i &lt; types.length; i++) {</span>
<span class="nc" id="L1193">			boolean isDirty = tc.isDirty(types[i]);</span>
<span class="nc" id="L1194">			slice.setTraceValue(types[i], tc.getTraceValueD(types[i], startDate, endDate));</span>
			//This is done here because setting the trace values on the slices
			//  has the unfortunate side effect of setting the dirty flag.  So,
			//  we will clear out the dirty flag caused by this change unless
			//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1199" title="All 2 branches missed.">			if (!isDirty) {</span>
<span class="nc" id="L1200">				tc.setTypeDirty(types[i], false);</span>
			}
		}
<span class="nc" id="L1203">		return slice;</span>
	}
	public static TraceCube combinedCube(TraceCube metaTC) {
<span class="nc bnc" id="L1206" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1207">			return META_ACTUAL_COMBINE;</span>
		}
<span class="nc bnc" id="L1209" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L1210">			return META_FORECAST_COMBINE;</span>
		}
<span class="nc" id="L1212">		return null;</span>
	}
	public static TraceCube newMetaInstance(TraceCube metaTC, short[] types) throws BbmTimeSeriesException{
<span class="nc bnc" id="L1215" title="All 2 branches missed.">		if (types == null) {</span>
<span class="nc" id="L1216">			return null;</span>
		}
<span class="nc" id="L1218">		TraceCube tc = null;</span>
<span class="nc bnc" id="L1219" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L1220">			tc = new ForecastTraceCube();</span>
		}
<span class="nc bnc" id="L1222" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1223">			tc = new PredictTraceCube();</span>
		}
<span class="nc bnc" id="L1225" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1226">			tc = new RequireTraceCube();</span>
		}
<span class="nc bnc" id="L1228" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1229">			tc = new ActualTraceCube();</span>
		}
<span class="nc bnc" id="L1231" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1232">			tc = new ServiceGoalTraceCube();</span>
		}
<span class="nc bnc" id="L1234" title="All 2 branches missed.">		if (tc != null) {</span>
<span class="nc" id="L1235">			tc.setTraceType(types);</span>
		}
<span class="nc" id="L1237">		return tc;</span>
	}
	public static TraceCube newInstance(TraceCube metaTC, ID queueID, Date start, Date end)
			throws BbmTimeSeriesException{
<span class="nc" id="L1241">		TraceCube tc = null;</span>
<span class="nc bnc" id="L1242" title="All 2 branches missed.">		if (metaTC instanceof ForecastTraceCube) {</span>
<span class="nc" id="L1243">			tc = new ForecastTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc bnc" id="L1245" title="All 2 branches missed.">		if (metaTC instanceof PredictTraceCube) {</span>
<span class="nc" id="L1246">			tc = new PredictTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc bnc" id="L1248" title="All 2 branches missed.">		if (metaTC instanceof RequireTraceCube) {</span>
<span class="nc" id="L1249">			tc = new RequireTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc bnc" id="L1251" title="All 2 branches missed.">		if (metaTC instanceof ActualTraceCube) {</span>
<span class="nc" id="L1252">			tc = new ActualTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc bnc" id="L1254" title="All 2 branches missed.">		if (metaTC instanceof ServiceGoalTraceCube) {</span>
<span class="nc" id="L1255">			tc = new ServiceGoalTraceCube(queueID, start, end, metaTC.getTraceTypes());</span>
		}
<span class="nc" id="L1257">		return tc;</span>
	}

	/**
	 * Gets a List of TraceChunk objects representing values in this TraceCube.  If startDate or endDate falls
	 * outside of the bounds of the TraceCube, then TraceChunk objects will be returned for those dates but they
	 * will have zero values for their trace types.
	 * @param traceCube TraceCube object to retrieve trace chunks from
	 * @param startDate Start date representing start of where to get Trace Chunks
	 * @param endDate End date representing end of where to get trace chunks
	 * @return
	 */
	public static List&lt;TraceChunk&gt; getTraceChunks(TraceCube traceCube, Date startDate, Date endDate) {
<span class="nc" id="L1270">		short[] types = traceCube.getTraceTypes();</span>
<span class="nc" id="L1271">		int[][] values = traceCube.getTraceValues();</span>
<span class="nc" id="L1272">		Calendar timeCursor = Calendar.getInstance(TimeZoneUtil.GMT_TIMEZONE);</span>
<span class="nc" id="L1273">		timeCursor.setTime(startDate);</span>
<span class="nc" id="L1274">		List&lt;TraceChunk&gt; retVal = new ArrayList&lt;&gt;(values[types[0]].length);</span>
<span class="nc bnc" id="L1275" title="All 2 branches missed.">		while (timeCursor.getTime().before(endDate)) {</span>
<span class="nc" id="L1276">			TraceChunk chunk = new TraceChunk(traceCube.getQueueID(), timeCursor.getTime());</span>
<span class="nc" id="L1277">			double[] valuesAtInterval = new double[types.length];</span>
<span class="nc bnc" id="L1278" title="All 2 branches missed.">			for (int typeIndex = 0; typeIndex &lt; types.length; typeIndex++) {</span>
<span class="nc bnc" id="L1279" title="All 2 branches missed.">				if (traceCube.fallsIn(timeCursor.getTime())) {</span>
<span class="nc" id="L1280">					valuesAtInterval[typeIndex] = traceCube.getTraceValueD(types[typeIndex], timeCursor.getTime());</span>
				}
			}
<span class="nc" id="L1283">			chunk.setTraceValues(types, valuesAtInterval);</span>
<span class="nc" id="L1284">			retVal.add(chunk);</span>
<span class="nc" id="L1285">			timeCursor.add(Calendar.MINUTE, Trace.INTERVAL);</span>
<span class="nc" id="L1286">		}</span>
<span class="nc" id="L1287">		return retVal;</span>
	}

	/**
	 * Returns true if any type in the given trace cube has its dirty flag set.
	 */
	public static boolean isTraceCubeDirty(TraceCube tc) {
<span class="nc bnc" id="L1294" title="All 2 branches missed.">		for (short type : tc.getTraceTypes()) {</span>
<span class="nc bnc" id="L1295" title="All 2 branches missed.">			if (tc.isDirty(type)) {</span>
<span class="nc" id="L1296">				return true;</span>
			}
		}
<span class="nc" id="L1299">		return false;</span>
	}

	/**
	 * Clears the dirty flag for all types in the trace cube.
	 */
	public static void clearDirtyTraceCube(TraceCube tc) {
<span class="nc bnc" id="L1306" title="All 2 branches missed.">		for (short type : tc.getTraceTypes()) {</span>
<span class="nc" id="L1307">			tc.setTypeDirty(type, false);</span>
		}
<span class="nc" id="L1309">	}</span>

	/**
	 * Convert values in a trace cube to seconds for the given trace types. The values in the original
	 * trace cube are assumed to be in the given time unit.
	 *
	 * @param cube the cube
	 * @param types the types trace types to do the conversion for
	 * @param timeUnit the time unit to convert values from
	 */
	public static void convertValuesToSeconds(TraceCube cube, short[] types, TimeUnit timeUnit) {
<span class="nc bnc" id="L1320" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L1321">			boolean isDirty = cube.isDirty(type);</span>
<span class="nc" id="L1322">			double[] values = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L1323" title="All 2 branches missed.">			if (values != null) {</span>
<span class="nc bnc" id="L1324" title="All 2 branches missed.">				for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="nc bnc" id="L1325" title="All 2 branches missed.">					if (values[i] &gt;= 0) {</span>
<span class="nc" id="L1326">						values[i] = timeUnit.convertValueToSeconds(values[i]);</span>
					}
				}
<span class="nc" id="L1329">				cube.setTraceValue(type, values);</span>
				//This is done here because setting the undefined values to zero
				//  has the unfortunate side effect of setting the dirty flag.  So,
				//  we will clear out the dirty flag caused by this change unless
				//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1334" title="All 2 branches missed.">				if (!isDirty) {</span>
<span class="nc" id="L1335">					cube.setTypeDirty(type, false);</span>
				}
			}
		}
<span class="nc" id="L1339">	}</span>

	/**
	 * Convert values in a trace cube from seconds to values in given time unit.
	 *
	 * @param cube the cube
	 * @param types the types trace types to do the conversion for
	 * @param timeUnit the time unit to convert seconds values to
	 */
	public static void convertSeconds(TraceCube cube, short[] types, TimeUnit timeUnit) {
<span class="nc bnc" id="L1349" title="All 2 branches missed.">		for (short type : types) {</span>
<span class="nc" id="L1350">			boolean isDirty = cube.isDirty(type);</span>
<span class="nc" id="L1351">			double[] values = cube.getTraceValueD(type);</span>
<span class="nc bnc" id="L1352" title="All 2 branches missed.">			if (values != null) {</span>
<span class="nc bnc" id="L1353" title="All 2 branches missed.">				for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="nc bnc" id="L1354" title="All 2 branches missed.">					if (values[i] &gt;= 0) {</span>
<span class="nc" id="L1355">						values[i] = timeUnit.convertSeconds(values[i]);</span>
					}
				}
<span class="nc" id="L1358">				cube.setTraceValue(type, values);</span>
				//This is done here because setting the undefined values to zero
				//  has the unfortunate side effect of setting the dirty flag.  So,
				//  we will clear out the dirty flag caused by this change unless
				//  the cube was already dirty beforehand.
<span class="nc bnc" id="L1363" title="All 2 branches missed.">				if (!isDirty) {</span>
<span class="nc" id="L1364">					cube.setTypeDirty(type, false);</span>
				}
			}
		}
<span class="nc" id="L1368">	}</span>

	/**
	 * Sets all undefined trace values in the trace cube
	 * (values that are less than 0) to 0.
	 */
	public static void setUndefinedValuesToZero(TraceCube cube) {
<span class="fc bfc" id="L1375" title="All 2 branches covered.">		for (short type : cube.getTraceTypes()) {</span>
<span class="fc" id="L1376">			boolean isDirty = cube.isDirty(type);</span>
<span class="fc" id="L1377">			double[] values = cube.getTraceValueD(type);</span>
<span class="fc bfc" id="L1378" title="All 2 branches covered.">			for (int i = 0; i &lt;= values.length - 1; i++) {</span>
<span class="fc bfc" id="L1379" title="All 2 branches covered.">				if (values[i] &lt; 0) {</span>
<span class="fc" id="L1380">					values[i] = 0;</span>
				}
			}
<span class="fc" id="L1383">			cube.setTraceValue(type, values);</span>
			//This is done here because setting the undefined values to zero
			//  has the unfortunate side effect of setting the dirty flag.  So,
			//  we will clear out the dirty flag caused by this change unless
			//  the cube was already dirty beforehand.
<span class="fc bfc" id="L1388" title="All 2 branches covered.">			if (!isDirty) {</span>
<span class="fc" id="L1389">				cube.setTypeDirty(type, false);</span>
			}
		}
<span class="fc" id="L1392">	}</span>

	/**
	 * Sets all trace values for the given trace types in the given trace cube to zero.
	 */
	public static &lt;T extends TraceCube&gt; void zeroOutTraceCubeValues(T cube, short[] traceTypes) {
<span class="nc bnc" id="L1398" title="All 2 branches missed.">		for (short type : traceTypes) {</span>
<span class="nc" id="L1399">			cube.initTraceValue(type, 0);</span>
		}
<span class="nc" id="L1401">	}</span>

	/**
	 * In some trace cubes, certain trace types are dependent on other trace types to have a non-negative value if their
	 * own trace values are to have meaning.  This method will set the value of the base trace types to zero if the
	 * base trace type value is less than zero AND the corresponding value of the dependent trace type is non-negative.
	 */
	public static void adjustDependentTraceValues(TraceCube traceCube, short dependentTraceType, short baseTraceType) {
<span class="fc" id="L1409">		double[] baseTraceValues = traceCube.getTraceValueD(baseTraceType);</span>
<span class="fc" id="L1410">		double[] dependentTraceValues = traceCube.getTraceValueD(dependentTraceType);</span>
<span class="fc bfc" id="L1411" title="All 2 branches covered.">		for (int i = 0; i &lt;= dependentTraceValues.length - 1; i++) {</span>
<span class="pc bpc" id="L1412" title="1 of 4 branches missed.">			if (dependentTraceValues[i] &gt;= 0 &amp;&amp; baseTraceValues[i] &lt; 0) {</span>
<span class="nc" id="L1413">				baseTraceValues[i] = 0;</span>
			}
		}
<span class="fc" id="L1416">		traceCube.setTraceValue(baseTraceType, baseTraceValues);</span>
<span class="fc" id="L1417">	}</span>

	/**
	 * Accommodate the introduction of new trace type NETSTAFFING that allows negative values.
	 * These are the old values; return new TRACENA for trace types other than NETSTAFFING
	 * TRACENA = -1;
	 * TRACEOFF = -2;
	 * TRACEUNB = -3;
	 * TRACEINCOMP = -4;
	 * @param traceType Type of trace
	 * @param traceVal Current value of Trace
	 * @return Adjusted trace value
	 */
	public static double adjustTraceValue(short traceType, double traceVal) {
<span class="fc" id="L1431">		double adjustedTraceValue = traceVal;</span>
<span class="fc" id="L1432">		double oldTracenaValue = -1;</span>
<span class="fc" id="L1433">		double oldTraceOffValue = -2;</span>
<span class="fc" id="L1434">		double oldTraceInCompValue = -4;</span>
<span class="pc bpc" id="L1435" title="1 of 6 branches missed.">		if (Trace.isValidValue(traceVal) &amp;&amp; traceType != Trace.NETSTAFFING &amp;&amp; traceVal &lt; 0) {</span>
<span class="nc bnc" id="L1436" title="All 2 branches missed.">			if (traceVal == oldTracenaValue) {</span>
<span class="nc" id="L1437">				adjustedTraceValue = Trace.TRACENA;</span>
<span class="nc bnc" id="L1438" title="All 2 branches missed.">			} else if (traceVal == oldTraceOffValue) {</span>
<span class="nc" id="L1439">				adjustedTraceValue = Trace.TRACEOFF;</span>
<span class="nc bnc" id="L1440" title="All 2 branches missed.">			} else if (traceVal == oldTraceInCompValue) {</span>
<span class="nc" id="L1441">				adjustedTraceValue = Trace.TRACEINCOMP;</span>
			}
		}
<span class="fc" id="L1444">		return adjustedTraceValue;</span>
	}

	//bad hack as usual to accomdate introduction of new trace type NETSTAFFING that allows negative values.
	public static double[] adjustTraceValue(short traceType, double[] traceVal) {
<span class="fc bfc" id="L1449" title="All 4 branches covered.">		for (int i = 0; traceVal != null &amp;&amp; i &lt; traceVal.length; i++) {</span>
<span class="fc" id="L1450">			traceVal[i] = adjustTraceValue(traceType,traceVal[i]);</span>
		}
<span class="fc" id="L1452">		return traceVal;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>