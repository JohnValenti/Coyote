<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>TimeOffIntervalAllocationUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation</a> &gt; <span class="el_source">TimeOffIntervalAllocationUtil.java</span></div><h1>TimeOffIntervalAllocationUtil.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.TimeZone;

import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.IDPair;
import com.bluepumpkin.common.datatypes.LocalDate;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmRemoveException;
import com.bluepumpkin.ejb.bbm.base.BbmUpdateException;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.PublishingPeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ScheduleChangeDetails;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.EmployeeDate;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.IdDateRange;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.PublishingPeriodStatus;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.PublishingPeriodStatus.Status;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffIntervalAllocationManager;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.ejb.TimeOffRequestChoiceSegment;
import com.bluepumpkin.ejb.rm.requests.timeoff.intervalallocation.model.TimeOffIntervalPaidSegment;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TOChoice;
import com.bluepumpkin.ejb.rm.requests.timeoff.model.TORequest;
import com.bluepumpkin.ejb.rm.util.DateUtil;
import com.bluepumpkin.ejb.rm.util.TOCalendarUtil;
import com.verint.ejb.wfm.WfmManagerFactory;


public class  TimeOffIntervalAllocationUtil {
<span class="fc" id="L50">	private static final Category LOG = Log.initCategory(TimeOffIntervalAllocationUtil.class.getName());</span>

<span class="fc" id="L52">	protected static RmManagerFactory rmMgrFactory = null;</span>
	
<span class="nc" id="L54">	private TimeOffIntervalAllocationUtil(){</span>
		
<span class="nc" id="L56">	}</span>
	
	public static TimeOffIntervalPaidSegment getTimeOffIntervalPaidSegment(ID id) throws BbmFinderException {
		
		try {
<span class="nc" id="L61">			return  TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L62">					.getTimeOffIntervalPaidSegment(id);</span>
							
<span class="nc" id="L64">		} catch (Exception e) {</span>
<span class="nc" id="L65">			throw new BbmFinderException(e);</span>
		}
	}
	
	
	
	

	public static void updateTimeOffIntervalPaidSegment(
			TimeOffIntervalPaidSegment segment) throws BbmUpdateException {
		try {
<span class="nc" id="L76">			TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L77">					.updateTimeOffIntervalPaidSegment(segment);</span>
<span class="nc" id="L78">		} catch (Exception e) {</span>
<span class="nc" id="L79">			throw new BbmUpdateException(e);</span>
<span class="nc" id="L80">		}</span>

<span class="nc" id="L82">	}</span>
	
	public static List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsForTimeOffChoice(TOChoice toChoice) throws BbmFinderException {
		
		
		try {
<span class="nc" id="L88">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L89">					.findTimeOffIntervalPaidSegmentsForTimeOffChoice(toChoice);</span>

<span class="nc" id="L91">		} catch (Exception e) {</span>
<span class="nc" id="L92">			throw new BbmFinderException(e);</span>
		}

	}
	
	public static List&lt;TimeOffIntervalPaidSegment&gt; findTimeOffIntervalPaidSegmentsIntersectTimeRange(
			TimeRange timeRange) throws BbmFinderException {

		
		try {
<span class="nc" id="L102">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L103">					.findTimeOffIntervalPaidSegmentsIntersectTimeRange(timeRange);</span>

<span class="nc" id="L105">		} catch (Exception e) {</span>
<span class="nc" id="L106">			throw new BbmFinderException(e);</span>
		}

	
	}
	
	public static void deleteTimeOffIntervalPaidSegmentsForTimeOffChoice(
			TOChoice toChoice) throws BbmRemoveException {

		try {
<span class="nc" id="L116">			TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L117">					.deleteTimeOffIntervalPaidSegmentsForTimeOffChoice(toChoice);</span>

<span class="nc" id="L119">		} catch (Exception e) {</span>
<span class="nc" id="L120">			throw new BbmRemoveException(e);</span>
<span class="nc" id="L121">		}</span>
		
<span class="nc" id="L123">	}</span>
	
	
	public static List&lt;ID&gt; updateTimeOffIntervalPaidSegmentsForTimeoffChoices(
			 List&lt;ID&gt; timeOffChoiceIDs) throws BbmUpdateException {
		
		
		try {
			
<span class="nc" id="L132">			Collection&lt;TORequest&gt; listOfRequests = TimeOffIntervalAllocationUtil.getMgr().getTORequestsFromChoiceIDs(timeOffChoiceIDs);</span>
<span class="nc bnc" id="L133" title="All 4 branches missed.">			if(listOfRequests==null || listOfRequests.isEmpty()){</span>
<span class="nc" id="L134">				return Collections.emptyList();</span>
			}
			
<span class="nc" id="L137">			return TimeOffIntervalAllocationUtil.getMgr()</span>
<span class="nc" id="L138">					.updateTimeOffIntervalsForTimeOffChoices(listOfRequests, timeOffChoiceIDs);</span>

<span class="nc" id="L140">		} catch (Exception e) {</span>
<span class="nc" id="L141">			throw new BbmUpdateException(e);</span>
		}
		
	}
		
	@SuppressWarnings(&quot;rawtypes&quot;)
	static Organization getEmpOrgForDate(Map&lt;Object, Object&gt; empOrgAssignments, ID empID, Date date) throws Exception{ // NOSONAR
				
<span class="nc" id="L149">		return TOCalendarUtil.getOrgforDate(date,</span>
<span class="nc" id="L150">				(Collection) empOrgAssignments.get(empID));</span>
				
		}
			
		
	



	public static boolean isDayPublished(
			List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsByEmp, Date current) {

<span class="nc bnc" id="L162" title="All 2 branches missed.">		for (Collection&lt;PublishingPeriod&gt; pubPeriods : pubPeriodsByEmp) {</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">			if (pubPeriods == null || pubPeriods.isEmpty()) {</span>
<span class="nc" id="L164">				continue;</span>
			}
<span class="nc bnc" id="L166" title="All 2 branches missed.">			for (PublishingPeriod period : pubPeriods) {</span>
				//A partially published period is one with no published shifts, but only approved Timeoff Requests.
				//As far as we are concerned, it is unpublished
<span class="nc bnc" id="L169" title="All 4 branches missed.">				if (period == null || period.isPartialPublish()) {</span>
<span class="nc" id="L170">					continue;</span>
				}
<span class="nc" id="L172">				TimeRange pubRange = new TimeRange(period.getStartTime(),</span>
<span class="nc" id="L173">						period.getEndTime());</span>

<span class="nc bnc" id="L175" title="All 2 branches missed.">				if (pubRange.includes(current)) {</span>
<span class="nc" id="L176">					return true;</span>
				}
<span class="nc" id="L178">			}</span>
<span class="nc" id="L179">		}</span>

<span class="nc" id="L181">		return false;</span>
	}


	@SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
	public static Map&lt;Object, Object&gt; getEmpOrgAssignments(Collection&lt;ID&gt; empIDs, Date startDate, Date endDate) throws Exception {

<span class="nc" id="L188">		Map&lt;Object, Object&gt; empOrgAssignments = new HashMap&lt;Object, Object&gt;(1);</span>

<span class="nc" id="L190">		empOrgAssignments = (Map&lt;Object, Object&gt;) BbmManagerFactory.getWorkResourceManager().getValidWorkResourceAssignments(empIDs,</span>
<span class="nc" id="L191">				new LocalDate(startDate, TimeZone.getTimeZone(&quot;GMT&quot;)), new LocalDate(endDate, TimeZone.getTimeZone(&quot;GMT&quot;)), false);</span>

<span class="nc" id="L193">		return empOrgAssignments;</span>

	}


	public static TimeOffIntervalPaidSegment createTimeOffIntervalPaidSegmentFromSimpleEvent(
			TOChoice toChoice, SimpleEvent simpleEvent) {
<span class="nc" id="L200">		return new TimeOffIntervalPaidSegment(toChoice.getID(), simpleEvent.getStartTime(), simpleEvent.getEndTime());</span>
		
	}
	
	
	
	/*
	 *  checkAllocation
	 *  Return list of choices that fail allocation check. 
	 */
	public static Map&lt;Integer, TimeOffRequestChoiceSegment&gt; checkAllocation(TORequest toRequest) throws BbmFinderException  { 
	
<span class="nc" id="L212">		Map&lt;Integer, TimeOffRequestChoiceSegment&gt; map = null;</span>
		try {
<span class="nc" id="L214">			map = TimeOffIntervalAllocationUtil.getMgr().checkAllocation(</span>
<span class="nc" id="L215">					Collections.singletonList(toRequest.getID()));</span>
<span class="nc" id="L216">		} catch (Exception e) {</span>
<span class="nc" id="L217">			throw new BbmFinderException(e);</span>
<span class="nc" id="L218">		}</span>

<span class="nc" id="L220">		return map;</span>
		
	}
	
	
	
	
	public static List&lt;ShiftAssignment&gt; getReferenceSchedules(Organization organization,
			ID employeeID, Date start, Date end) throws BbmFinderException {
		
<span class="nc" id="L230">		List&lt;ShiftAssignment&gt; referencedShiftEvents = null; </span>
		try {
<span class="nc" id="L232">			referencedShiftEvents = TimeOffIntervalAllocationUtil.getMgr().getReferenceSchedules(</span>
					organization, employeeID, start,end);
<span class="nc" id="L234">		} catch (Exception e) {</span>
<span class="nc" id="L235">			throw new BbmFinderException(e);</span>
<span class="nc" id="L236">		}</span>
<span class="nc" id="L237">		return referencedShiftEvents;</span>
	}
	
	
	
	
	/*
	 *  validateReferenceScheduleGood
	 *  Hard validation check
	 *  Called by com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule.validate(Validatable)
	 *  For the request, for activities solely designated as &quot;interval allocation&quot; types, validate that a reference schedule exists for the 
	 *  employee.
	 *  If none exists, return false as a hard-validation error.
	 *  
	 */
	public static boolean validateReferenceScheduleGood(TORequest toRequest) throws Exception{ // NOSONAR
		
<span class="nc" id="L254">		List&lt;EmployeeDate&gt; employeeDates = new ArrayList&lt;EmployeeDate&gt;();</span>
<span class="nc" id="L255">		ID empId = toRequest.getEmployeeID();</span>
		
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L258">		List&lt;TOChoice&gt; choiceList = toRequest.getRequestChoiceList();</span>

<span class="nc bnc" id="L260" title="All 2 branches missed.">		for (TOChoice toChoice : choiceList) {</span>
<span class="nc bnc" id="L261" title="All 2 branches missed.">			if(toChoice==null){</span>
<span class="nc" id="L262">				continue;</span>
			}
<span class="nc" id="L264">			EmployeeDate employeeDate = new EmployeeDate(empId,toChoice.getStartDate());</span>
<span class="nc" id="L265">			employeeDates.add(employeeDate);</span>
<span class="nc" id="L266">		}</span>
		
<span class="nc" id="L268">		Map&lt;EmployeeDate, ID&gt; map = getMgr().getReferenceScheduleSPDEID(employeeDates);</span>
<span class="nc bnc" id="L269" title="All 4 branches missed.">		if( map == null || map.isEmpty()){</span>
<span class="nc" id="L270">			return false;</span>
		}
		
		// see if each choice is in the map (i.e., has a reference schedule)
<span class="nc bnc" id="L274" title="All 2 branches missed.">		for( EmployeeDate empDate : employeeDates ){</span>
<span class="nc bnc" id="L275" title="All 2 branches missed.">			if( !map.containsKey(empDate) )</span>
<span class="nc" id="L276">				return false;</span>
<span class="nc" id="L277">		}</span>
		
		
<span class="nc" id="L280">		return true;</span>
	}
	
	/*
	 *  validatePublishedStatusGood
	 *  Hard validation check
	 *  Called by com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationPublishedStatusRule.validate(Validatable) // NOSONAR
	 *  For each time off choice, validate that the range is fully published or fully unpublished
	 *  If not fully published or fully unpublished, then return false as a hard-validation error.
	 *  
	 */
	public static boolean validatePublishedStatusGood(PublishingPeriodStatus publishingPeriodStatus, ID empID,
			TOChoice toChoice){
<span class="nc" id="L293">		IdDateRange idDateRange = new IdDateRange(empID,</span>
<span class="nc" id="L294">				toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc bnc" id="L295" title="All 2 branches missed.">		return publishingPeriodStatus.getPeriodStatus(idDateRange) != Status.HAS_GAPS_IN_PUBLISHING;</span>
	}
	
	/*
	 * getPublishedPeriodStatusForTimeoffChoice Returns the status of a choice's
	 * date range published period: either wholly, un-wholly, or partly
	 * published. 
	 * Partly published periods are a hard-validation error.
	 * Unwholly published will require us to use Reference schedules
	 */

	static Status getPublishedPeriodStatusForTimeoffChoice(ID empId,
			TOChoice toChoice) throws BbmFinderException {
	
<span class="nc" id="L309">		PublishingPeriodStatus publishingPeriodStatus = new PublishingPeriodStatus();</span>
<span class="nc" id="L310">		IdDateRange idDateRange = new IdDateRange(empId,</span>
<span class="nc" id="L311">				toChoice.getStartDate(), toChoice.getEndDate());</span>

<span class="nc" id="L313">		publishingPeriodStatus.initialize(Collections.singleton(idDateRange),</span>
<span class="nc" id="L314">				getMgr());</span>

<span class="nc" id="L316">		return publishingPeriodStatus.getPeriodStatus(idDateRange);</span>
		
		} 
	
	static Status getPublishedPeriodStatusForTimeoffChoice(PublishingPeriodStatus publishingPeriodStatus, ID empID,
			TOChoice toChoice){
<span class="nc" id="L322">		IdDateRange idDateRange = new IdDateRange(empID,</span>
<span class="nc" id="L323">				toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc" id="L324">		return publishingPeriodStatus.getPeriodStatus(idDateRange);</span>
		
	}

	static Status getPublishedPeriodStatus(PublishingPeriodStatus publishingPeriodStatus, ID empID, Date start, Date end) {
<span class="nc" id="L329">		IdDateRange idDateRange = new IdDateRange(empID, start, end);</span>
<span class="nc" id="L330">		return publishingPeriodStatus.getPeriodStatus(idDateRange);</span>
	}
	

	/*
	 * Initialize a PublishingPeriodStatus object, which will check the published period status
	 * for each Timeoff Choice in the request.
	 * Calling publishingPeriodStatus.getPeriodStatus(idDateRange) for the choice range will return if 
	 * a publishing period is wholly, not-wholly, or partly published.
	 * Partly published periods are a hard-validation error
	 * Unwholly published will require us to use Reference schedules
	 */
	public static PublishingPeriodStatus initPublishedPeriodStatusForTimeoffRequest(TORequest toRequest) throws BbmFinderException {
		
<span class="nc" id="L344">		PublishingPeriodStatus publishingPeriodStatus = new PublishingPeriodStatus();</span>
<span class="nc" id="L345">		ID empID = toRequest.getEmployeeID();</span>
		
<span class="nc" id="L347">		List&lt;IdDateRange&gt; listOfIdDateRanges = new ArrayList&lt;IdDateRange&gt;();</span>
		
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L350">		List&lt;TOChoice&gt; choiceList = toRequest.getRequestChoiceList();</span>

<span class="nc bnc" id="L352" title="All 2 branches missed.">		for (TOChoice toChoice : choiceList) {</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			if(toChoice==null){</span>
<span class="nc" id="L354">				continue;</span>
			}
			
<span class="nc" id="L357">			IdDateRange idDateRange = new IdDateRange(empID, toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc" id="L358">			listOfIdDateRanges.add(idDateRange);</span>
<span class="nc" id="L359">		}</span>
		
		
<span class="nc" id="L362">		publishingPeriodStatus.initialize(listOfIdDateRanges, getMgr());</span>
<span class="nc" id="L363">		return publishingPeriodStatus;</span>
	}
	
	public static PublishingPeriodStatus initPublishedPeriodStatus(ID empID, Date start, Date end) throws BbmFinderException {
<span class="nc" id="L367">		PublishingPeriodStatus publishingPeriodStatus = new PublishingPeriodStatus();</span>
<span class="nc" id="L368">		IdDateRange idDateRange = new IdDateRange(empID, start, end);</span>
<span class="nc" id="L369">		publishingPeriodStatus.initialize(Collections.singletonList(idDateRange), getMgr());</span>
<span class="nc" id="L370">		return publishingPeriodStatus;</span>
	}


	
	
	
	public static TimeOffIntervalAllocationManager getMgr() throws BbmFinderException{
<span class="nc" id="L378">		return TimeOffIntervalAllocationUtil.getTimeOffIntervalAllocationManager(null, null);</span>
	}
			
	public static TimeOffIntervalAllocationManager getTimeOffIntervalAllocationManager(
			String userName, String password) throws BbmFinderException {

<span class="nc" id="L384">		TimeOffIntervalAllocationManager manager = null;</span>
		try {
<span class="nc bnc" id="L386" title="All 4 branches missed.">			if (userName == null &amp;&amp; password == null) {</span>
<span class="nc" id="L387">				manager = getRmManagerFactory()</span>
<span class="nc" id="L388">						.getTimeOffIntervalAllocationManager();</span>
			} else {
<span class="nc" id="L390">				manager = getRmManagerFactory()</span>
<span class="nc" id="L391">						.getTimeOffIntervalAllocationManager(userName, password);</span>
			}
<span class="nc" id="L393">		} catch (Exception e) {</span>
<span class="nc" id="L394">			throw new BbmFinderException(e);</span>
<span class="nc" id="L395">		}</span>
<span class="nc" id="L396">		return manager;</span>

	}

	

	private static synchronized RmManagerFactory getRmManagerFactory() {
<span class="nc bnc" id="L403" title="All 2 branches missed.">		if (rmMgrFactory == null) {</span>
<span class="nc" id="L404">			rmMgrFactory = RmManagerFactory.getInstance(true);</span>
		}
<span class="nc" id="L406">		return rmMgrFactory;</span>
	}
	
	
	public static ScheduleAccessManager getScheduleAccessManager() throws BbmEJBCreateException {
		
<span class="nc" id="L412">		return  WfmManagerFactory.getScheduleAccessManager();</span>

	}
	
	
	public static List&lt;Collection&lt;PublishingPeriod&gt;&gt; getPublishedPeriods(
			ID empId, TimeRange range) throws BbmFinderException {
<span class="nc" id="L419">		List&lt;Collection&lt;PublishingPeriod&gt;&gt; pubPeriodsByEmp = null;</span>
		try {
<span class="nc" id="L421">			pubPeriodsByEmp = getScheduleAccessManager().getPublishedPeriods(</span>
<span class="nc" id="L422">					Collections.singletonList(empId), range.getStartDate(),</span>
<span class="nc" id="L423">					range.getEndDate());</span>
<span class="nc" id="L424">		} catch (Exception e) {</span>
<span class="nc" id="L425">			throw new BbmFinderException(e);</span>
<span class="nc" id="L426">		}</span>
<span class="nc" id="L427">		return pubPeriodsByEmp;</span>
	}

	public static TimeRange getFullDayTimeRangeInclusive(Date date) {
<span class="nc" id="L431">		Date start = RequestUtil.getDateForDayStart(date,</span>
<span class="nc" id="L432">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L433">		Date end = RequestUtil.getDateForDayEnd(start,</span>
<span class="nc" id="L434">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L435">		return new TimeRange(start, end);</span>
		
	}
	public static TimeRange getFullDayTimeRangeExclusive(Date date) {
<span class="nc" id="L439">		Date start = RequestUtil.getDateForDayStart(date,</span>
<span class="nc" id="L440">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
<span class="nc" id="L441">		Date end = DateUtil.addDays(start, 1);</span>
<span class="nc" id="L442">		return new TimeRange(start, end);</span>
	}
	
	public static Date getDayForwardOneDay(Date currentDate) {

<span class="nc" id="L447">		return TOCalcUtil.getDateForwardOneDay(currentDate,</span>
<span class="nc" id="L448">				TimeZone.getTimeZone(&quot;GMT&quot;));</span>
	}

	
	/*
	 *  isPublishedStatusFullyPublished
	 *  Hard validation check
	 *  Called by com.bluepumpkin.ejb.rm.requests.timeoff.validation.TimeoffIntervalAllocationReferenceScheduleRule.validate(Validatable) // NOSONAR
	 *  For each time off choice, validate that the range is fully published
	 *  
	 */
	public static boolean isPublishedStatusFullyPublished(PublishingPeriodStatus publishingPeriodStatus, ID empID,
			TOChoice toChoice){
<span class="nc" id="L461">		IdDateRange idDateRange = new IdDateRange(empID,</span>
<span class="nc" id="L462">				toChoice.getStartDate(), toChoice.getEndDate());</span>
<span class="nc bnc" id="L463" title="All 2 branches missed.">		return publishingPeriodStatus.getPeriodStatus(idDateRange) == Status.FULLY_PUBLISHED;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static void updateTimeOffIntervalPaidSegmentsCalendarEventsForTimeoffChoices(ScheduleChangeDetails changeDetails) //NOSONAR
			throws Exception {//NOSONAR
		@SuppressWarnings(&quot;unchecked&quot;)
		
<span class="fc" id="L471">		HashSet&lt;IDPair&gt; setEventsNewOrUpdate = new HashSet&lt;IDPair&gt;();</span>
		
<span class="fc" id="L473">		Iterator&lt;Collection&lt;ID&gt;&gt; itWrk = changeDetails.getWorkResourceIDs().iterator();</span>
<span class="fc" id="L474">		Iterator&lt;Collection&lt;Event&gt;&gt; itOldEvents = changeDetails.getOldEvents().iterator();</span>
<span class="fc" id="L475">		Iterator&lt;Collection&lt;Event&gt;&gt; itNewEvents = changeDetails.getNewEvents().iterator();</span>
		
<span class="fc" id="L477">		ArrayList&lt;ID&gt; listEventsToDelete = new ArrayList&lt;ID&gt;();</span>
<span class="fc" id="L478">		ArrayList&lt;Event&gt; listEventsToUpdate = new ArrayList&lt;Event&gt;();</span>
		
		//loop through the employee and his collection of new and old events to figure
		//out what to delete and insert and update
<span class="pc bpc" id="L482" title="2 of 6 branches missed.">		while (itWrk.hasNext() &amp;&amp; itOldEvents.hasNext() &amp;&amp; itNewEvents.hasNext()) {</span>
<span class="fc" id="L483">			ID employeeID = (ID) itWrk.next();</span>
<span class="fc" id="L484">			Collection&lt;Event&gt; listBeforeEvents = itOldEvents.next();</span>
<span class="fc" id="L485">			Collection&lt;Event&gt; listAfterEvents = itNewEvents.next();</span>

			// all after events are current and need to be updated
<span class="fc bfc" id="L488" title="All 2 branches covered.">			if (listAfterEvents != null) {</span>
<span class="fc bfc" id="L489" title="All 2 branches covered.">				for (Event after : listAfterEvents) {</span>
<span class="pc bpc" id="L490" title="1 of 2 branches missed.">					if (after.getEventType() == Event.EVENT_TYPE_TIME_OFF) {//NOSONAR</span>
<span class="nc" id="L491">						setEventsNewOrUpdate.add(new IDPair(after.getID(), employeeID));</span>
<span class="nc" id="L492">						listEventsToUpdate.add(after);</span>
					}
<span class="fc" id="L494">				}</span>
			}

			// Only delete event if it is in old and not new
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">			if (listBeforeEvents != null) {</span>
<span class="nc bnc" id="L499" title="All 2 branches missed.">				for (Event before : listBeforeEvents) {</span>
<span class="nc bnc" id="L500" title="All 2 branches missed.">					if (before.getEventType() == Event.EVENT_TYPE_TIME_OFF) {//NOSONAR</span>
<span class="nc" id="L501">						IDPair pair = new IDPair(before.getID(), employeeID);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">						if (!setEventsNewOrUpdate.contains(pair)) {</span>
<span class="nc" id="L503">							listEventsToDelete.add(before.getID());</span>
						}
					}
<span class="nc" id="L506">				}</span>
			}

<span class="fc" id="L509">		}</span>
		
<span class="pc bpc" id="L511" title="2 of 4 branches missed.">		if(listEventsToDelete.isEmpty() &amp;&amp; listEventsToUpdate.isEmpty()){</span>
<span class="fc" id="L512">			return;</span>
		}
		
<span class="nc" id="L515">		TimeOffIntervalAllocationManager mgr = RmManagerFactory.getInstance(true).getTimeOffIntervalAllocationManager(null, null);</span>
<span class="nc" id="L516">		mgr.deleteTimeOffIntervalPaidSegmentCalendarEventsID(listEventsToDelete);</span>
<span class="nc" id="L517">		mgr.updateTimeOffIntervalPaidSegmentCalendarEvents(listEventsToUpdate);</span>
		
		
<span class="nc" id="L520">	}</span>

	

	


}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>