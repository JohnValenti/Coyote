<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ScheduleViewPM.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.web.fs.schedule</a> &gt; <span class="el_source">ScheduleViewPM.java</span></div><h1>ScheduleViewPM.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.web.fs.schedule;

import com.bluepumpkin.common.datatypes.*;
import com.bluepumpkin.common.l10n.RegionalFormatBundleKey;
import com.bluepumpkin.common.localization.Localizer;
import com.bluepumpkin.common.util.DateTimeUtil;
import com.bluepumpkin.common.util.StringUtil;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.activity.model.Activity;
import com.bluepumpkin.ejb.bbm.activity.model.Event;
import com.bluepumpkin.ejb.bbm.activity.model.SimpleEvent;
import com.bluepumpkin.ejb.bbm.base.BbmCreateException;
import com.bluepumpkin.ejb.bbm.base.BbmException;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.effectivity.TimePeriod;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.timeseries.ejb.TimeSeriesManager;
import com.bluepumpkin.ejb.bbm.timeseries.model.NetStaffingCube;
import com.bluepumpkin.ejb.bbm.timeseries.model.Trace;
import com.bluepumpkin.ejb.bbm.timeseries.model.TraceCube;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.OrganizationHOOPeriod;
import com.bluepumpkin.ejb.bbm.workresource.model.WorkResourceAssignment;
import com.bluepumpkin.ejb.rm.RmManagerFactory;
import com.bluepumpkin.ejb.rm.requests.swap.posting.model.ShiftSwapPosting;
import com.bluepumpkin.ejb.rm.requests.swap.shiftitem.model.ShiftSwapItem;
import com.bluepumpkin.ejb.rm.setup.settings.ejb.OrganizationConfigManager;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.bluepumpkin.web.bbm.activity.ActivityModelHandler;
import com.bluepumpkin.web.bbm.l10n.BbmWebBundleKey;
import com.bluepumpkin.web.bbm.workresource.WorkResourceModelHandler;
import com.bluepumpkin.web.fs.keys.FsImageFileID;
import com.bluepumpkin.web.fs.keys.FsJavaScriptFileID;
import com.bluepumpkin.web.fs.keys.FsKeys;
import com.bluepumpkin.web.fs.keys.FsPageAction;
import com.bluepumpkin.web.fs.l10n.FsWebBundleKey;
import com.bluepumpkin.web.fs.schedule.summary.DailyScheduleSummary;
import com.bluepumpkin.web.fs.schedule.summary.ScheduleSummaryMH;
import com.bluepumpkin.web.fs.shift.ShiftUtil;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.witness.web.uif.base.Message;
import com.witness.web.uif.jsp.HtmlImage;
import com.witness.web.uif.keys.*;
import com.witness.web.uif.l10n.UIFWebBundleKey;
import com.witness.web.uif.pagecomponent.DefaultMultiColumnNodeData;
import com.witness.web.uif.pagecomponent.contenttitle.ContentTitlePC;
import com.witness.web.uif.pagecomponent.dialog.DialogLegendPC;
import com.witness.web.uif.pagecomponent.dialog.DialogToolbarMenuPC;
import com.witness.web.uif.pagecomponent.list.DualListPC;
import com.witness.web.uif.pagecomponent.list.MultiColListPC;
import com.witness.web.uif.pagecomponent.picker.date.DatePickerPC;
import com.witness.web.uif.pagecomponent.picker.date.DateRangePickerPC;
import com.witness.web.uif.pagecomponent.selection.SelectableItems;
import com.witness.web.uif.pagecomponent.table.TableHeaderPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarPC;
import com.witness.web.uif.pagecomponent.toolbar.ToolbarTextButton;
import com.witness.web.uif.pagemodel.PageModel;
import com.witness.web.uif.pagemodel.WorkpaneListPM;
import com.witness.web.uif.system.RequestContext;
import com.witness.web.uif.util.HtmlUtil;
import com.witness.web.uif.util.html.CSSUtil;
import com.witness.web.uif.util.html.HtmlLinkUtil;
import com.witness.web.uif.util.js.JSUtil;

import javax.servlet.http.HttpServletRequest;
import java.rmi.RemoteException;
import java.util.*;

/**
 * Title:        ScheduleViewPM
 * Description:  Base class for Schedule viewing pages.
 *               Parent class for GroupSchedulePM and PersonalSchedulePM
 * Copyright:    Copyright (c) 2002
 * Company:      Blue Pumpkin Software, inc
 * @author       Pavel Bosin
 * Created on October 3, 2002, 5:40 PM
 * @version      1.0
 */
@SuppressWarnings(&quot;serial&quot;)
public abstract class ScheduleViewPM  extends WorkpaneListPM {
<span class="fc" id="L83">	protected static String POSTING_IMG = null;</span>
	protected static final String VIEW_TYPE_FN = &quot;viewType&quot;;
	protected static final String DATE_RANGE_FN = &quot;dateRange&quot;;
	protected static final String VIEW_DATE_FN = &quot;viewDate&quot;;

	public static final String VIEW_TYPE_MY_TEXT = &quot;VIEW_TYPE_MY_TEXT&quot;;
	public static final String VIEW_TYPE_MY_GRAPH = &quot;VIEW_TYPE_MY_GRAPH&quot;;
	public static final String VIEW_TYPE_MY_PRINT = &quot;VIEW_TYPE_MY_PRINT&quot;;
	public static final String VIEW_TYPE_GROUP_TEXT = &quot;VIEW_TYPE_GROUP_TEXT&quot;;   //keep &quot;GROUP&quot; as part
	public static final String VIEW_TYPE_GROUP_GRAPH = &quot;VIEW_TYPE_GROUP_GRAPH&quot;; // of all group view
	public static final String VIEW_TYPE_GROUP_PRINT = &quot;VIEW_TYPE_GROUP_PRINT&quot;; // key values !!
	public static final String VIEW_TYPE_GROUP_MULTI = &quot;VIEW_TYPE_GROUP_MULTI&quot;;

	public static final int PREV_DAY_INDEX = -1;
	public static final int NEXT_DAY_INDEX = 1441;

	protected ResourceBundle m_bundle;
	protected ResourceBundle m_bbm_bundle;
	protected String m_formAction;
	protected String m_viewType;
	protected String m_noShiftLabel;
	protected ID m_myEmpID;
<span class="nc" id="L105">	protected Organization m_myOrganization = null;</span>
	protected DialogToolbarMenuPC m_newSwapMenuPC;
	protected DialogToolbarMenuPC m_netStaffingDisambiguationMenuPC;

	protected boolean m_bGroupView;     //this is a group view
	protected boolean m_bGroupSelector; //show group selector
	protected boolean m_bPagination;   //show pagination
	protected boolean m_bDateSelector;  //show dates dropdown instead of the range
	protected boolean m_bLegendButton;  //show buttons...
	protected boolean m_bPrintButton;
<span class="nc" id="L115">	protected boolean m_isPageEnabled=true;</span>
<span class="nc" id="L116">	protected boolean m_isFullPageMode = true; //true=agent view, false=manager view</span>

<span class="nc" id="L118">	protected StringBuffer m_sbJS = new StringBuffer();   // for accumulation of js data</span>

<span class="nc" id="L120">	protected DualListPC m_dualList = null;</span>
	protected DateRangePickerPC m_dateRangePicker;
	protected DatePickerPC m_datePicker;
<span class="nc" id="L123">	protected DialogLegendPC m_legendPC = null;</span>
<span class="nc" id="L124">	protected TimeRange m_timeRange = null;    //period selected for viewing</span>
<span class="nc" id="L125">	protected TimeRange m_dayRange= null;    //current date in the period for group text/graph/print view</span>

	//Request Management Settings per organization
<span class="fc" id="L128">	protected static RmManagerFactory m_rmManagerFactory = RmManagerFactory.getInstance();</span>
	protected OrganizationSetting m_orgSetting;
<span class="nc" id="L130">	protected boolean m_allowNewShifts = false;</span>
<span class="nc" id="L131">	protected boolean m_allowShiftChanges = false;</span>
<span class="nc" id="L132">	protected boolean m_csReqEnabled = false;</span>
<span class="nc" id="L133">	protected boolean m_vtoReqEnabled = false;</span>

	//User Preferences for Net Staffing ribbons
<span class="nc" id="L136">	protected boolean m_isNetStaffingRibbonEnabled = false;</span>
<span class="nc" id="L137">	protected boolean m_isNetStaffingHalfHeight = true;</span>
	protected String m_netStaffingShortageColor;
	protected String m_netStaffingSurplusColor;
	protected String m_netStaffingNeutralColor;
	protected String m_netStaffingCellSelectionColor;

	//these three members tell us which of the Net Staffing colors should be shown in the legend, if any.
<span class="nc" id="L144">	protected boolean m_hasNetStaffingShortageData = false;</span>
<span class="nc" id="L145">	protected boolean m_hasNetStaffingNeutralData = false;</span>
<span class="nc" id="L146">	protected boolean m_hasNetStaffingSurplusData = false;</span>

	//Privileges to create requests
<span class="nc" id="L149">	boolean m_isCSEnabled = false;</span>
<span class="nc" id="L150">	boolean m_isTOEnabled = false;</span>

<span class="nc" id="L152">	public static enum dstTransitionMode { NEUTRAL, FALLBACK, SPRINGFORWARD };</span>

	//public static int NET_OVERSTAFFED = 1;
	//public static int NET_UNDERSTAFFED = -1;
	//public static int NET_NEUTRAL = 0;

    /**
     * The horizontal position to scroll to by default when the page loads.
     */
<span class="nc" id="L161">    protected int m_scrollX = 0;</span>

	/**
	 * The work resource assignments for the employee whose Net Staffing Ribbon will be displayed.
	 */
<span class="nc" id="L166">	protected Collection&lt;WorkResourceAssignment&gt; m_wrAssignmentsForNetStaffingEmp = null;</span>

	/**
	 * The open HOO periods for the employee whose Net Staffing Ribbon will be displayed.
	 */
<span class="nc" id="L171">	protected Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; m_orgOpenPeriodsForNetStaffingEmp = null;</span>


	/**
	 * Constructs a schedule view base class.
	 */
	public ScheduleViewPM(RequestContext context, String formAction, String viewType) {
<span class="nc" id="L178">		this(context, formAction, viewType, false);</span>
<span class="nc" id="L179">	}//constructor</span>

	/**
	 * Constructs a schedule view base class.
	 */
	public ScheduleViewPM(RequestContext context, String formAction, String viewType, boolean isDualListUsed){
<span class="nc" id="L185">		super(context, PageModel.BASIC_MODEL);</span>

<span class="nc" id="L187">		m_myEmpID = context.getUser().getEmployeeID();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">		m_isPageEnabled = (m_myEmpID!=null);</span>
<span class="nc" id="L189">		m_viewType = viewType;</span>
<span class="nc" id="L190">		m_formAction = formAction;</span>
<span class="nc" id="L191">		ScheduleViewUtil.cacheFormAction(context, formAction);</span>
<span class="nc" id="L192">		initFlags(viewType);</span>

<span class="nc" id="L194">		m_timeRange = new TimeRange(new Date(),new Date());</span>
<span class="nc" id="L195">		m_bundle = m_localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>
<span class="nc" id="L196">		m_bbm_bundle = m_localizer.getBundle(BbmWebBundleKey.BUNDLE_NAME);</span>
<span class="nc" id="L197">		m_noShiftLabel = i18n(m_bundle,FsWebBundleKey.SV_NO_SHIFT);</span>

		//=== Component specific required JavaScript Files
<span class="nc" id="L200">		addRequiredJavaScriptFile(JavaScriptFileID.MEDIATOR_WORKPANE_GENERIC);</span>
<span class="nc" id="L201">		setJSMediator(FsJavaScriptFileID.MEDIATOR_SCHEDULE_VIEW);</span>

		// Initialize date range picker
<span class="nc" id="L204">		m_dateRangePicker = new DateRangePickerPC(context,DATE_RANGE_FN);</span>
<span class="nc" id="L205">		m_dateRangePicker.setIsAllDateButtonsEnabled(true);</span>

		//Set the first day of week in the picker to the user's org start day
<span class="nc" id="L208">		m_myOrganization = ScheduleViewMH.getOrganizationForEmp(m_context, m_myEmpID);</span>
<span class="nc" id="L209">		int firstDayOfWeek = ScheduleViewMH.getWeekStartDayForEmp(m_context, m_myEmpID, m_myOrganization);</span>
<span class="nc" id="L210">		m_dateRangePicker.setFirstDayOfWeek(firstDayOfWeek); //ex: Calendar.FRIDAY</span>

<span class="nc" id="L212">		addChildComponent(m_dateRangePicker);</span>

		// Add legend
<span class="nc bnc" id="L215" title="All 2 branches missed.">		if (m_bLegendButton) {</span>
<span class="nc" id="L216">			m_legendPC= new DialogLegendPC(context, m_toolbar);</span>
<span class="nc" id="L217">			addChildComponent(m_legendPC);</span>
		}

		// Initialize Dual List
<span class="nc bnc" id="L221" title="All 2 branches missed.">		if (isDualListUsed)</span>
        {
<span class="nc" id="L223">			m_dualList = new DualListPC(context);; //isGraphView() ? new GraphDualListPC(context) : new DualListPC(context);</span>
<span class="nc" id="L224">			addChildComponent(m_dualList);</span>

<span class="nc" id="L226">            m_dualList.getRightListPC().setHasRowHeaders(false); //508: The row headers are actually in the left list!</span>
		}

<span class="nc" id="L229">		m_list.setIsZebra(true); //This will set zebra striping for the non-dualList schedule pages</span>
<span class="nc" id="L230">	}//constructor</span>

	public boolean isGraphView()
	{
<span class="nc bnc" id="L234" title="All 4 branches missed.">		return m_viewType.equals(VIEW_TYPE_GROUP_GRAPH) ||m_viewType.equals(VIEW_TYPE_MY_GRAPH);</span>
	}

	protected static OrganizationConfigManager getOrgConfigManager() throws BbmCreateException {
<span class="nc" id="L238">		return m_rmManagerFactory.getOrganizationConfigManager();</span>
	}

	/**
	 * Return OrganizationSetting for specified Organization ID
	 */
	public static OrganizationSetting getOrgSetting(ID orgID)
			throws RemoteException, BbmFinderException, BbmCreateException {
<span class="nc" id="L246">		return getOrgConfigManager().getConfiguration(orgID);</span>
	}

	/**
	 * Read the user's net staffing user preference, and his organization's net staffing / cust shift request settings.
	 * m_myEmpID , m_myOrganization
	 */
	protected void readNetStaffingSettingsForUserAndOrg() throws Exception
	{
<span class="nc bnc" id="L255" title="All 2 branches missed.">		if (m_myOrganization != null)</span>
		{
			//read the request amanagerment organization settings
<span class="nc" id="L258">			m_orgSetting = getOrgSetting(m_myOrganization.getID());</span>
			//allow new shift requests for employee's org
<span class="nc" id="L260">			m_allowNewShifts = m_orgSetting.getEnableCustomShiftRequests();</span>
			//allow shift change requests for employee's org
<span class="nc" id="L262">			m_allowShiftChanges = m_orgSetting.getAllowShiftChangeRequests();</span>

<span class="nc bnc" id="L264" title="All 4 branches missed.">			m_csReqEnabled = (m_allowNewShifts || m_allowShiftChanges);</span>
<span class="nc bnc" id="L265" title="All 2 branches missed.">			m_vtoReqEnabled = (m_isFullPageMode ? m_orgSetting.getAgentTimeOffWorkflowActive() : m_orgSetting.getManagerTimeOffWorkflowActive());</span>

			//read the user preferences
<span class="nc bnc" id="L268" title="All 6 branches missed.">			m_isNetStaffingRibbonEnabled = (m_csReqEnabled || m_vtoReqEnabled) &amp;&amp; ScheduleViewMH.getShowNetStaffing(m_context);</span>
<span class="nc" id="L269">			m_isNetStaffingHalfHeight = ScheduleViewMH.getNetStaffingHalfHeight(m_context);</span>
<span class="nc" id="L270">			m_netStaffingShortageColor = removeHash(ScheduleViewMH.getNetStaffingShortageColor(m_context));</span>
<span class="nc" id="L271">			m_netStaffingSurplusColor =  removeHash(ScheduleViewMH.getNetStaffingSurplusColor(m_context));</span>
<span class="nc" id="L272">			m_netStaffingNeutralColor =  removeHash(ScheduleViewMH.getNetStaffingNeutralColor(m_context));</span>
<span class="nc" id="L273">			m_netStaffingCellSelectionColor = ScheduleViewMH.getNetStaffingCellSelectionColor(m_context);</span>

<span class="nc" id="L275">			addJSVariableAsString(&quot;CELL_SELECT_COLOR&quot;, m_netStaffingCellSelectionColor);</span>
<span class="nc" id="L276">			addJSVariableAsString(&quot;INVALID_SELECTION&quot;, i18n(m_bundle, FsWebBundleKey.NET_STAFFING_INVALID_SELECTION));</span>

<span class="nc bnc" id="L278" title="All 2 branches missed.">			m_isCSEnabled = ScheduleViewMH.getCanCreateCustomShiftRequest(m_context, !m_isFullPageMode);</span>
<span class="nc bnc" id="L279" title="All 2 branches missed.">			m_isTOEnabled = ScheduleViewMH.getCanCreateTimeOffRequest(m_context, !m_isFullPageMode);</span>
<span class="nc" id="L280">			addJSVariable(&quot;isCSEnabled&quot;, &quot;&quot;+m_isCSEnabled);</span>
<span class="nc" id="L281">			addJSVariable(&quot;isTOEnabled&quot;, &quot;&quot;+m_isTOEnabled);</span>
		}
<span class="nc" id="L283">	}</span>


	/**
	 * Checks whether the &quot;Voluntary Time Off&quot; activity's isRequestable attribute is true or false.
	 */
	protected boolean isVTOActivityRequestable() throws Exception
	{
<span class="nc" id="L291">		Activity vtoAct = ActivityModelHandler.getActivityByID(m_context, Activity.ACTIVITY_VOLUNTARY_TIMEOFF);</span>
<span class="nc" id="L292">		return vtoAct.isRequestable();</span>
	}

	/**
	 * Given a color string such as &quot;#00FF33&quot;, return the color without the &quot;#&quot; at the beginning.
	 */
	private String removeHash(String color)
	{
<span class="nc bnc" id="L300" title="All 4 branches missed.">		if (color != null &amp;&amp; color.startsWith(&quot;#&quot;))</span>
		{
<span class="nc" id="L302">			color = color.substring(1);</span>
		}
<span class="nc" id="L304">		return color;</span>
	}

	/**
	 * Initialize Component For Display
	 */
	public void initForDisplay() {
<span class="nc bnc" id="L311" title="All 2 branches missed.">		if (m_isInitializedForDisplay) return;</span>
		else {
<span class="nc" id="L313">			super.initForDisplay();</span>

<span class="nc" id="L315">			initNewSwapMenu();</span>
<span class="nc" id="L316">			initShiftSwapPopupWindowArgs();</span>
		}
<span class="nc" id="L318">	}</span>

	/**
	 * Initialize Popup Window Arguments for Shift Swap
	 */
	protected void initShiftSwapPopupWindowArgs() {
<span class="nc" id="L324">		addPopupArgs(FsPageAction.POPUP_SWAPBOARD_POSTING_FORM_ACTION, FsKeys.RH_SWAPBOARD_FORM,</span>
				null, &quot;postingID,shiftType,shiftDate&quot;, &quot;550,400,ctr,ctr&quot;, true, 1);

<span class="nc" id="L327">		addPopupArgs(FsPageAction.POPUP_SHIFTSWAP_REQUEST_FORM_ACTION, FsKeys.RH_SHIFTSWAP_FORM,</span>
				null, &quot;postingID,shiftType,requestDate1,requestDate2&quot;, &quot;560,510,ctr,ctr&quot;, true, 1);
<span class="nc" id="L329">	}</span>

	/**
	 * Initialize New Shift Swap Menu
	 */
	protected void initNewSwapMenu() {
<span class="nc" id="L335">		m_newSwapMenuPC = createShiftSwapMenu(m_context, m_toolbar, &quot;NEW_SWAP_MENU&quot;);</span>
<span class="nc" id="L336">		addChildComponent(m_newSwapMenuPC);</span>
<span class="nc" id="L337">	}</span>

	/**
	 * Create Shift Swap Menu PC
	 */
	private DialogToolbarMenuPC createShiftSwapMenu(RequestContext context, ToolbarPC toolbar, String name) {
<span class="nc" id="L343">		DialogToolbarMenuPC newSwapMenuPC = new DialogToolbarMenuPC(context, toolbar);</span>
<span class="nc" id="L344">		newSwapMenuPC.setName(name);</span>

<span class="nc" id="L346">		Localizer localizer = context.getLocalizer();</span>
<span class="nc" id="L347">		ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>

		// Initialize Title
<span class="nc" id="L350">		String title = localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_SHIFT_SWAP);</span>
<span class="nc" id="L351">		newSwapMenuPC.setHeader(title);</span>

		// Initialize Menu Buttons
<span class="nc" id="L354">		newSwapMenuPC.addPopupWindowButton(FsPageAction.POPUP_SWAPBOARD_POSTING_FORM_ACTION,</span>
<span class="nc" id="L355">				localizer.i18n(bundle, FsWebBundleKey.CREATE_NEW_POSTING), true);</span>

<span class="nc" id="L357">		newSwapMenuPC.addPopupWindowButton(FsPageAction.POPUP_SHIFTSWAP_REQUEST_FORM_ACTION,</span>
<span class="nc" id="L358">				localizer.i18n(bundle, FsWebBundleKey.CREATE_NEW_REQUEST), true);</span>

<span class="nc" id="L360">		return newSwapMenuPC;</span>
	}

	/**
	 * Create the Net Staffing Request Type Disambiguation Menu PC.
	 */
	private DialogToolbarMenuPC createNetStaffingDisambiguationMenu(RequestContext context, ToolbarPC toolbar, String name) {
<span class="nc" id="L367">		DialogToolbarMenuPC menuPC = new DialogToolbarMenuPC(context, toolbar);</span>
<span class="nc" id="L368">		menuPC.setName(name);</span>

<span class="nc" id="L370">		Localizer localizer = context.getLocalizer();</span>
<span class="nc" id="L371">		ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>

		// Initialize Title
<span class="nc" id="L374">		String title = localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_LABEL);</span>
<span class="nc" id="L375">		menuPC.setHeader(title);</span>

		// Initialize Menu Buttons
<span class="nc" id="L378">		menuPC.addPopupWindowButton(FsPageAction.POPUP_CUSTSHIFT_REQUEST_FORM_ACTION,</span>
<span class="nc" id="L379">				localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_CUSTOM_SHIFT), true);</span>

<span class="nc" id="L381">		menuPC.addPopupWindowButton(FsPageAction.POPUP_TIMEOFF_REQUEST_FORM_ACTION,</span>
<span class="nc" id="L382">				localizer.i18n(bundle, FsWebBundleKey.REQUEST_TYPE_VTO), true);</span>

<span class="nc" id="L384">		return menuPC;</span>
	}

	/**
	 * Initialize Popup Window Arguments for VTO Request and Custom Shift Request (from Net Staffing ribbon).
	 */
	protected void initNetStaffingPopupWindowArgs() {
<span class="nc" id="L391">		addPopupArgs(FsPageAction.POPUP_TIMEOFF_REQUEST_FORM_ACTION, FsKeys.RH_TIMEOFF_FORM,</span>
				null, &quot;requestedFor,pageMode,ribbonStartDate,ribbonEndDate,isFromNetStaffingRibbon&quot;, &quot;800,655,ctr,ctr&quot;, true, 1);

<span class="nc" id="L394">		addPopupArgs(FsPageAction.POPUP_CUSTSHIFT_REQUEST_FORM_ACTION, FsKeys.RH_CUSTSHIFT_FORM,</span>
				null, &quot;requestedFor,pageMode,ribbonStartDate,ribbonEndDate,reloadAction&quot;, &quot;750,655,ctr,ctr&quot;, true, 1);
<span class="nc" id="L396">	}</span>

	/**
	 * Initialize Net Staffing Disambiguation Menu
	 */
	protected void initNetStaffingDisambiguationMenu() {
<span class="nc" id="L402">		m_netStaffingDisambiguationMenuPC = createNetStaffingDisambiguationMenu(m_context, m_toolbar, &quot;NET_STAFFING_DISAMBIGUATION&quot;);</span>
<span class="nc" id="L403">		addChildComponent(m_netStaffingDisambiguationMenuPC);</span>
<span class="nc" id="L404">	}</span>

	/**
	 * initialize boolean flags for the view
	 */
	private void initFlags(String viewType){
<span class="nc bnc" id="L410" title="All 2 branches missed.">		m_bGroupView = viewType.equals(VIEW_TYPE_GROUP_GRAPH)</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_MULTI)</span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_PRINT)</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_GROUP_TEXT);</span>
<span class="nc" id="L414">		m_bGroupSelector = m_bGroupView;</span>
<span class="nc" id="L415">		m_bPagination = m_bGroupView;</span>
<span class="nc bnc" id="L416" title="All 4 branches missed.">		m_bDateSelector = m_bGroupView &amp;&amp; !viewType.equals(VIEW_TYPE_GROUP_MULTI) ;</span>
<span class="nc bnc" id="L417" title="All 2 branches missed.">		m_bLegendButton = viewType.equals(VIEW_TYPE_GROUP_GRAPH)</span>
<span class="nc bnc" id="L418" title="All 2 branches missed.">				|| viewType.equals(VIEW_TYPE_MY_GRAPH);</span>
<span class="nc" id="L419">		m_bPrintButton = false; //TODO 5.x: enable when add print pages; print legend</span>
<span class="nc" id="L420">	}//initFlags</span>

	/**
	 * Initialize Model with Data
	 */
	protected void initializeModel()
	{
<span class="nc bnc" id="L427" title="All 2 branches missed.">		if (m_isInitialized)</span>
<span class="nc" id="L428">			return;</span>

		//adjustModelTypeFromScreenDef();
<span class="nc bnc" id="L431" title="All 2 branches missed.">		m_isFullPageMode = (BASIC_MODEL == getPageModelType());</span>

<span class="nc" id="L433">		super.initializeModel();</span>
<span class="nc" id="L434">	}</span>

	/**
	 * Initialize Selectable Items
	 */
	protected void loadData() throws Exception {
<span class="nc bnc" id="L440" title="All 2 branches missed.">		if (m_myEmpID!=null) {</span>
<span class="nc" id="L441">			initDateRange();</span>
<span class="nc" id="L442">			loadAndInitData();</span>
		} else {
<span class="nc" id="L444">			addPageMessage(Message.INFO_TYPE,</span>
					UIFWebBundleKey.SCREEN_DISABLED_FOR_NON_EMP,
					UIFWebBundleKey.BUNDLE_NAME);
		}
<span class="nc" id="L448">	}</span>

	protected void refreshTimeRangeFromSession() {
		//get time interval from the session
<span class="nc" id="L452">		m_timeRange = (TimeRange)m_context.getAttribute(RequestContext.SESSION_SCOPE,</span>
				UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD);

        //QC#44831
<span class="nc bnc" id="L456" title="All 2 branches missed.">        if (m_timeRange != null)</span>
        {
            //We must convert the date range to the user timezone, because the user may have just changed it.
<span class="nc" id="L459">            Date startDate = m_timeRange.getStartDate();</span>
<span class="nc" id="L460">            Date endDate = m_timeRange.getEndDate();</span>
<span class="nc" id="L461">            TimeZone tz = m_context.getViewingTimeZone();</span>

<span class="nc" id="L463">            TimeRange startRange = DateTimeUtil.makeDayRange(startDate, tz);</span>
<span class="nc" id="L464">            TimeRange endRange = DateTimeUtil.makeDayRange(endDate, tz);</span>
<span class="nc" id="L465">            m_timeRange.setStartDate(startRange.getStartDate());</span>
<span class="nc" id="L466">            m_timeRange.setEndDate(endRange.getEndDate());</span>

<span class="nc" id="L468">            m_context.setAttribute(RequestContext.SESSION_SCOPE, UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, m_timeRange);</span>
        }
<span class="nc" id="L470">	}</span>

	/**
	 * Initialize start and end dates
	 */
	protected void initDateRange() throws RemoteException, BbmException
	{
		//--- get dates from extracted parameters
<span class="nc" id="L478">		Date fromDate  = m_dateRangePicker.getStartDatePickerPC().getDate();</span>
<span class="nc" id="L479">		Date toDate    = m_dateRangePicker.getEndDatePickerPC().getDate();</span>

<span class="nc bnc" id="L481" title="All 4 branches missed.">		if (fromDate != null &amp;&amp; toDate != null) {</span>
			try {
<span class="nc bnc" id="L483" title="All 2 branches missed.">				String configKey = (BASIC_MODEL == getPageModelType())</span>
					? &quot;bluepumpkin/Schedule/MyGroup/dateRangeLimit&quot;
					: &quot;bluepumpkin/Schedule/People/dateRangeLimit&quot;;

<span class="nc" id="L487">				String limit = BbmManagerFactory.getDBConfigManager().getValue(configKey);</span>
<span class="nc bnc" id="L488" title="All 2 branches missed.">				if(limit!=null){</span>
<span class="nc" id="L489">					int dateRangeLimit = Integer.parseInt(limit);</span>
<span class="nc" id="L490">					Calendar cal = Calendar.getInstance();</span>
<span class="nc" id="L491">					cal.setTime(fromDate);</span>
<span class="nc" id="L492">					cal.add(Calendar.DAY_OF_MONTH, dateRangeLimit);</span>
<span class="nc bnc" id="L493" title="All 2 branches missed.">					if(cal.getTime().before(toDate)){</span>
						// set as End Time subtract 1 second
<span class="nc" id="L495">						cal.add(Calendar.SECOND, -1);</span>
<span class="nc" id="L496">						toDate = cal.getTime();</span>
					}
				}
			}
<span class="nc" id="L500">			catch (Exception e)</span>
			{
<span class="nc" id="L502">				e.printStackTrace();</span>
<span class="nc" id="L503">			}</span>
		}

<span class="nc bnc" id="L506" title="All 6 branches missed.">		if (fromDate!=null &amp;&amp; toDate!=null &amp;&amp; fromDate.after(toDate)){</span>
<span class="nc" id="L507">			this.addPageMessage(Message.WARNING_TYPE, FsWebBundleKey.SV_WARN_START_AFTER_END,</span>
					FsWebBundleKey.BUNDLE_NAME);
<span class="nc" id="L509">			fromDate = toDate;</span>
		}

		//--- if null, then use from the session
<span class="nc bnc" id="L513" title="All 4 branches missed.">		if (fromDate == null || toDate == null)</span>
		{
<span class="nc" id="L515">			refreshTimeRangeFromSession();</span>

<span class="nc bnc" id="L517" title="All 2 branches missed.">        	if (m_timeRange == null)</span>
    		{
<span class="nc" id="L519">    			m_timeRange = getThisWeekTimeRange();</span>
    		}
		}
		else
		{
<span class="nc" id="L524">			m_timeRange = new TimeRange(fromDate,toDate);</span>
		}

		//--- save date range in the session
<span class="nc" id="L528">		m_context.setAttribute(RequestContext.SESSION_SCOPE,</span>
				UserPreferenceKeys.USER_SCHEDULE_VIEW_PERIOD, m_timeRange);
<span class="nc" id="L530">	}//initDateRange</span>

    /**
	 * get time range as this week for the user org.
	 */
	public TimeRange getThisWeekTimeRange()
			throws RemoteException, BbmException
	{
<span class="nc" id="L538">		HashMap theData = new HashMap();</span>
<span class="nc" id="L539">		theData.put(&quot;VIEW_TYPE_KEY&quot;, m_viewType);</span>
<span class="nc" id="L540">		ScheduleViewMH.putUserOrgID(m_context, theData);</span>

<span class="nc" id="L542">		Calendar startCal = ScheduleViewMH.getThisWeekStart(m_context,theData);</span>
<span class="nc" id="L543">		Calendar endCal = ScheduleViewMH.getThisWeekEnd(m_context, startCal);</span>
<span class="nc" id="L544">		TimeRange timeRange = new TimeRange(startCal.getTime(), endCal.getTime());</span>

<span class="nc" id="L546">		return timeRange;</span>
	}

	/**
	 * Initialize Toolbar
	 */
	protected void initToolbar() {
		//Print button
<span class="nc bnc" id="L554" title="All 2 branches missed.">		if (m_bPrintButton) {</span>
<span class="nc" id="L555">			m_toolbar.addToolbarElement(new ToolbarTextButton(m_toolbar, &quot;SCHEDULE_PRINT&quot;,</span>
<span class="nc" id="L556">					i18n(m_bundle, FsWebBundleKey.PRINT), ToolbarTextButton.GREEN_BUTTON));</span>
		}

		//Legend button
<span class="nc bnc" id="L560" title="All 2 branches missed.">		if (m_bLegendButton) m_toolbar.addToolbarElement( m_legendPC.getLegendButton() );</span>

		//Refresh button
<span class="nc" id="L563">		m_toolbar.addSubmitTextButton(PageAction.REFRESH, i18n(m_bundle, FsWebBundleKey.REFRESH), true);</span>
<span class="nc" id="L564">	}//initToolbar</span>


	/**
	 * Return Collection of View Selector Options
	 */
	protected abstract Collection getViewSelectorOptions();

	/**
	 * Return Selected View Type
	 */
	public static String getViewType(RequestContext context) {
<span class="nc" id="L576">		return context.getRequest().getParameter(VIEW_TYPE_FN);</span>
	}

	/**
	 * make the view selector html string, which is used in the content title
	 */
	protected String makeViewSelector() {
<span class="nc" id="L583">		Collection options = getViewSelectorOptions();</span>
<span class="nc" id="L584">		String onChange = &quot;this.form.action = this.value;&quot; + getDropDownRefreshJS();</span>
<span class="nc" id="L585">		String label = i18n(m_common_bundle, UIFWebBundleKey.VIEW);</span>

<span class="nc" id="L587">		return makeSelector(VIEW_TYPE_FN, label, m_formAction, onChange, options);</span>
	}//makeViewSelector

	/**
	 * return JavaScript for Drop Down Refresh
	 */
	protected String getDropDownRefreshJS() {
<span class="nc" id="L594">		return JSUtil.REFRESH_IGNORE_CHANGES;</span>
	}


	/** make selector */
	protected String makeSelector(String fn, String label, String selected,
			String onChange, Collection options){
<span class="nc" id="L601">		StringBuffer sb = new StringBuffer(200);</span>

<span class="nc" id="L603">		String[] selectedValue = {selected};</span>
<span class="nc" id="L604">		String width = null;</span>
<span class="nc" id="L605">		boolean useDefaultOnChange = false;</span>
<span class="nc" id="L606">		boolean isMultiple = false;</span>
<span class="nc" id="L607">		String sDD = HtmlUtil.makeSelectInput(fn, &quot;0&quot;, selectedValue, onChange, options,</span>
				width, useDefaultOnChange, isMultiple);

<span class="nc" id="L610">        label = HtmlUtil.createLabel(label, fn); //508</span>
<span class="nc" id="L611">		sb.append(ContentTitlePC.formatLabel(label)).append(sDD);</span>
<span class="nc" id="L612">		return sb.toString();</span>
	}//makeSelector

	/**
	 * Initialize Legend
	 */
	protected void initLegend(Map&lt;String, Object&gt; theData) {
<span class="nc bnc" id="L619" title="All 2 branches missed.">		if (m_bLegendButton) {</span>
<span class="nc" id="L620">			m_legendPC.setHeader(i18n(m_bundle, FsWebBundleKey.GRAPH_SCHEDULE_LEGEND_PAGETITLE));</span>
<span class="nc" id="L621">			addOvertimeLegendItem(theData); //if have overtime, add to legend</span>
<span class="nc" id="L622">			addNetStaffingLegendItems(theData); //if has Net Staffing, add to legend</span>
<span class="nc" id="L623">			ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>
<span class="nc" id="L624">			m_legendPC.setItems(legendData);</span>
		}
<span class="nc" id="L626">	}//initLegend</span>

	/**
	 * if any of the schedule items in the collection has overtime, add entry to legend
	 */
	private void addOvertimeLegendItem(Map&lt;String, Object&gt; theData){
<span class="nc" id="L632">		Collection theScheduleItems = ScheduleViewMH.getAllScheduleItemsFromMap(theData);</span>
		//iterate through the schedule items and if find overtime add to the legend
<span class="nc bnc" id="L634" title="All 4 branches missed.">		if (theScheduleItems != null &amp;&amp; theScheduleItems.size() &gt; 0) {</span>
<span class="nc" id="L635">			ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">			for (Iterator it = theScheduleItems.iterator(); it.hasNext();) {</span>
<span class="nc" id="L637">				SimpleEvent anEvent = (SimpleEvent)it.next();</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">				if(anEvent.isOvertime()){</span>
<span class="nc" id="L639">					legendData.add(new StringsPair(FsImageFileID.OT_PATTERN,</span>
<span class="nc" id="L640">						i18n(m_bundle,FsWebBundleKey.SP_OVERTIME)));</span>
<span class="nc" id="L641">					return;</span>
				}
<span class="nc" id="L643">			}</span>
		}
<span class="nc" id="L645">	}//addOvertimeLegendItem</span>

	/**
	 * if viewing Net Staffing ribbons, add the Net Staffing colors to the legend.
	 */
	protected void addNetStaffingLegendItems(Map&lt;String, Object&gt; theData)
	{
<span class="nc" id="L652">		ArrayList legendData = (ArrayList)theData.get(ScheduleViewMH.LEGEND_ITEMS_KEY);</span>

<span class="nc bnc" id="L654" title="All 2 branches missed.">		if(m_hasNetStaffingShortageData)</span>
<span class="nc" id="L655">			legendData.add(new StringsPair(m_netStaffingShortageColor, i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE)));</span>

<span class="nc bnc" id="L657" title="All 2 branches missed.">		if(m_hasNetStaffingSurplusData)</span>
<span class="nc" id="L658">			legendData.add(new StringsPair(m_netStaffingSurplusColor, i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS)));</span>

<span class="nc bnc" id="L660" title="All 2 branches missed.">		if(m_hasNetStaffingNeutralData)</span>
<span class="nc" id="L661">			legendData.add(new StringsPair(m_netStaffingNeutralColor, i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL)));</span>

<span class="nc" id="L663">	}</span>

	/**
	 * Perform Extract parameters: current day in the group views
	 */
	public boolean extractParameters(HttpServletRequest request) {
<span class="nc" id="L669">		boolean isSuccess = super.extractParameters(request);</span>

<span class="nc" id="L671">		String strViewDate = request.getParameter(VIEW_DATE_FN);</span>
<span class="nc bnc" id="L672" title="All 2 branches missed.">		if (!StringUtil.isEmpty(strViewDate)){</span>
			try {
<span class="nc" id="L674">				long timeValue = Long.parseLong(strViewDate);</span>
<span class="nc" id="L675">				this.m_dayRange = DateTimeUtil.makeDayRange(new Date(timeValue),</span>
<span class="nc" id="L676">						m_context.getViewingTimeZone());</span>
<span class="nc" id="L677">				m_context.setAttribute(RequestContext.SESSION_SCOPE,</span>
						UserPreferenceKeys.USER_SCHEDULE_VIEW_DAY, this.m_dayRange);
<span class="nc" id="L679">			} catch (Exception ex) {</span>
<span class="nc" id="L680">				log.l7dError(UIFWebBundleKey.UNABLE_TO_LOAD_DATA, ex);</span>
<span class="nc" id="L681">				addPageMessage(Message.ERROR_TYPE, UIFWebBundleKey.EXTRACT_PARAM_FAILED,</span>
						UIFWebBundleKey.BUNDLE_NAME);
<span class="nc" id="L683">			}</span>
		}
<span class="nc" id="L685">		return isSuccess;</span>
	}//extractParameters

	/**
	 * Return the Selectable Items
	 */
	public SelectableItems getSelectableItems() {
<span class="nc" id="L692">		SelectableItems aList = null;</span>

<span class="nc bnc" id="L694" title="All 2 branches missed.">		if (m_dualList != null) {</span>
<span class="nc" id="L695">			initDualListForDisplay();</span>
<span class="nc" id="L696">			aList = m_dualList;</span>
<span class="nc bnc" id="L697" title="All 2 branches missed.">		}	else if (m_list != null) {</span>
<span class="nc" id="L698">			aList = m_list;</span>
		}

<span class="nc" id="L701">		return aList;</span>
	}// getSelectableItems

	//================= getters/setters ==================
	/** get date for the beginning of shown period */
	protected Date getFromDate(){
<span class="nc" id="L707">		return m_timeRange.getStartDate();</span>
	}
	/** get date for the end of shown period */
	protected Date getToDate(){
<span class="nc" id="L711">		return m_timeRange.getEndDate();</span>
	}
	/** set date for the beginning of shown period */
	protected void setFromDate(Date fromDate){
<span class="nc" id="L715">		m_timeRange.setStartDate(fromDate);</span>
<span class="nc" id="L716">	}</span>
	/** set date for the end of shown period */
	protected void setToDate(Date toDate){
<span class="nc" id="L719">		m_timeRange.setEndDate(toDate);</span>
<span class="nc" id="L720">	}</span>
	/** get view type */
	public String getViewType(){
<span class="nc" id="L723">		return m_viewType;</span>
	}
	/** set view type not needed: set only in the constructor */

	/**
	 * Return URL for HTML Form Action
	 */
	public String getFormAction() {
<span class="nc" id="L731">		return m_formAction;</span>
	}//getFormAction


	//============= helpers =======================
	/**
	 * get the show unavailabilities flag
	 */
	protected boolean showUnavailable(Map&lt;String, Object&gt; theData){
<span class="nc" id="L740">		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_UNAVAILABLE_KEY);</span>
	}//showUnavailable

	/**
	 * get the show timeoff flag
	 */
	protected boolean showTimeoff(Map&lt;String, Object&gt; theData){
<span class="nc" id="L747">		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_TIMEOFF_KEY);</span>
	}//showUnavailable

	/**
	 * get the shift swap enabled flag
	 */
	protected boolean isSwapEnabled(Map&lt;String, Object&gt; theData) throws Exception {

<span class="nc" id="L755">		boolean hasRightsReadOrWriteSwapBoard = getBooleanFromMap(theData, ScheduleViewMH.SWAP_FLAG_KEY) ;</span>
<span class="nc" id="L756">		boolean isEnableSwapFromOrgSetting = false;</span>
<span class="nc bnc" id="L757" title="All 2 branches missed.">		if(m_myOrganization!=null){</span>
<span class="nc" id="L758">			isEnableSwapFromOrgSetting = getOrgSetting(m_myOrganization.getID()).getEnableShiftSwap();</span>
		}

<span class="nc bnc" id="L761" title="All 4 branches missed.">		return hasRightsReadOrWriteSwapBoard&amp;&amp;isEnableSwapFromOrgSetting;</span>
	}//isSwapEnabled

	/**
	 * get the show my schedule notes flag
	 * @param orgID - the ID of the organization whose schedule you are viewing
	 *
	protected boolean showMyScheduleNote(HashMap theData)
	{
		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_MY_SCHEDULE_NOTE_KEY);
	}

	/**
	 * get the show group schedule notes flag
	 * @param orgID - the ID of the organization whose schedule you are viewing
	 *
	protected boolean showOrgScheduleNote(HashMap theData)
	{
		return getBooleanFromMap(theData, ScheduleViewMH.SHOW_ORG_SCHEDULE_NOTE_KEY);
	}
	*/

	/**
	 * get the boolean flag from the HashMap using the key value
	 * @return boolean or false if can't get the value
	 */
	public static boolean getBooleanFromMap(Map theData, String key){
<span class="nc" id="L788">		Object obj = theData.get(key);</span>
<span class="nc" id="L789">		boolean bVal = false; //default</span>
<span class="nc bnc" id="L790" title="All 2 branches missed.">		if (obj != null)</span>
<span class="nc" id="L791">			bVal = ((Boolean)obj).booleanValue();</span>
<span class="nc" id="L792">		return bVal;</span>
	}//getBooleanForTheUser

	//======= most of the methods below are used in both personal and group views =======
	/**
	 * calculate shown hours as the max range of day hours covering all events limited to HOOs.
	 * Hours are in {0,23} range
	 * m_isNetStaffingRibbonEnabled - if true, we show the entire hoo day. If false, we also consider the scheduled events.
	 */
	protected int[] calculateShownHours(Collection schedule, HOOAssignment hoos,
					boolean bShowUnavailable, TimeRange scheduleRange)
	{
<span class="nc" id="L804">		int hooHoursRange[] = getMinMaxHooHours(hoos);</span>

<span class="nc bnc" id="L806" title="All 2 branches missed.">		if (m_isNetStaffingRibbonEnabled)</span>
<span class="nc" id="L807">			return hooHoursRange;</span>

<span class="nc bnc" id="L809" title="All 2 branches missed.">		Collection scheduleEvents = (m_bGroupView)?</span>
<span class="nc" id="L810">				makeSingleEventsCollectionForGroup(schedule):</span>
				schedule;
<span class="nc" id="L812">		int eventHoursRange[] = getMinMaxEventHours(scheduleEvents, bShowUnavailable, scheduleRange);</span>
<span class="nc" id="L813">		int shownHours[] = combineMinMaxHours(eventHoursRange, hooHoursRange);</span>
<span class="nc" id="L814">		return shownHours;</span>
	}//calculateShownHours

	/**
	 * make single collection of events from collection of collections for multiple people
	 */
	protected Collection makeSingleEventsCollectionForGroup(Collection schedule){
<span class="nc bnc" id="L821" title="All 2 branches missed.">		if (schedule== null) return schedule;</span>
<span class="nc" id="L822">		ArrayList scheduleEvents = new ArrayList();</span>
<span class="nc bnc" id="L823" title="All 2 branches missed.">		for (Iterator i = schedule.iterator(); i.hasNext();){</span>
<span class="nc" id="L824">			Collection personSchedule = (Collection) i.next();</span>
<span class="nc bnc" id="L825" title="All 2 branches missed.">			if (personSchedule != null){</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">				for (Iterator j = personSchedule.iterator(); j.hasNext();){</span>
<span class="nc" id="L827">					scheduleEvents.add(j.next());</span>
				}
			}
<span class="nc" id="L830">		}</span>
<span class="nc" id="L831">		return scheduleEvents;</span>
	}//makeSingleEventsCollectionForGroup

    /**
     * calculate min and max day hours, which cover all the shown events
     * @param schedule - Collection or schedule Events
     * @param bShowUnavailable
     * @return int array of two values {minHour,mahHour}
     *
     * NOTE: assuming that viewing period is always in full days
     */
    protected int[] getMinMaxEventHours(Collection schedule, boolean bShowUnavailable, TimeRange scheduleRange){
<span class="nc" id="L843">        return getMinMaxEventHours(schedule, bShowUnavailable, scheduleRange, false);</span>
    }

	/**
	 * calculate min and max day hours, which cover all the shown events
	 * @param schedule - Collection or schedule Events
     * @param bShowUnavailable
     * @param bSkipTimeOffEvents If true, then we will not consider timeoff events.
	 * @return int array of two values {minHour,mahHour}
	 *
	 * NOTE: assuming that viewing period is always in full days
	 */
	protected int[] getMinMaxEventHours(Collection schedule, boolean bShowUnavailable, TimeRange scheduleRange,
            boolean bSkipTimeOffEvents){
		// initialize min and max
<span class="nc" id="L858">		int minHour = 23;</span>
<span class="nc" id="L859">		int maxHour = 0;</span>
<span class="nc" id="L860">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc bnc" id="L861" title="All 4 branches missed.">		if (schedule!=null &amp;&amp; schedule.size()&gt;0){</span>
			//--- for each event in the schedule
<span class="nc bnc" id="L863" title="All 2 branches missed.">			for (Iterator i = schedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L864">				Event event = (Event) i.next();</span>
<span class="nc bnc" id="L865" title="All 2 branches missed.">				if (event == null) continue;</span>
<span class="nc bnc" id="L866" title="All 4 branches missed.">                if (!bShowUnavailable &amp;&amp; event.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY ) continue;</span>
<span class="nc bnc" id="L867" title="All 4 branches missed.">                if (bSkipTimeOffEvents &amp;&amp; event.getEventType() == Event.EVENT_TYPE_TIME_OFF ) continue;</span>

<span class="nc" id="L869">				Calendar eventStartCal = Calendar.getInstance(tz, m_locale);</span>
<span class="nc" id="L870">				eventStartCal.setTime(event.getStartTime());</span>
<span class="nc" id="L871">				Calendar eventEndCal = Calendar.getInstance(tz, m_locale);</span>
<span class="nc" id="L872">				eventEndCal.setTime(event.getEndTime());</span>
<span class="nc" id="L873">				int eventStartHour = eventStartCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L874">				int eventEndHour = eventEndCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L875">				TimeRange eventRange = new TimeRange(event.getStartTime(),event.getEndTime());</span>
<span class="nc" id="L876">				int overlapCode = eventRange.getRelativeLocationTo(scheduleRange);</span>

				//   if event crosses day boundary,
<span class="nc bnc" id="L879" title="All 2 branches missed.">				if (eventStartCal.get(Calendar.DATE) != eventEndCal.get(Calendar.DATE)) {</span>
					//if event is inside the viewing schedule period or covers it
<span class="nc bnc" id="L881" title="All 6 branches missed.">					if (overlapCode == TimeRange.INTERVAL_IN</span>
						|| overlapCode == TimeRange.INTERVAL_EQUALS
						|| overlapCode == TimeRange.INTERVAL_COVERS){
						//set min and max to full day and break from the loop since we can't expand more
<span class="nc" id="L885">						minHour = 0;</span>
<span class="nc" id="L886">						maxHour = 23;</span>
<span class="nc" id="L887">						break;</span>
					} //else - event sticks out of the viewing schedule period
<span class="nc bnc" id="L889" title="All 2 branches missed.">					  else if (overlapCode == TimeRange.INTERVAL_BEFORE_AND_IN){</span>
						//if start is before then minHour = 0
<span class="nc" id="L891">						minHour = 0;</span>
<span class="nc bnc" id="L892" title="All 2 branches missed.">						if (eventEndHour &gt; maxHour)</span>
<span class="nc" id="L893">							maxHour = eventEndHour;</span>
<span class="nc bnc" id="L894" title="All 2 branches missed.">					} else if (overlapCode == TimeRange.INTERVAL_AFTER_AND_IN){</span>
						//if end is after then max hour = 23
<span class="nc" id="L896">						maxHour = 23;</span>
<span class="nc bnc" id="L897" title="All 2 branches missed.">						if (eventStartHour &lt; minHour)</span>
<span class="nc" id="L898">							minHour = eventStartHour;</span>
					}
				} else { //event is within a day - reset min and max to cover the event
<span class="nc bnc" id="L901" title="All 4 branches missed.">					if (overlapCode != TimeRange.INTERVAL_BEFORE &amp;&amp; overlapCode != TimeRange.INTERVAL_AFTER){</span>
<span class="nc bnc" id="L902" title="All 2 branches missed.">						if (eventStartHour &lt; minHour)</span>
<span class="nc" id="L903">							minHour = eventStartHour;</span>
<span class="nc bnc" id="L904" title="All 2 branches missed.">						if (eventEndHour &gt; maxHour)</span>
<span class="nc" id="L905">							maxHour = eventEndHour;</span>
					}
				}
<span class="nc" id="L908">			}//for</span>
		} else { //no schedule - no hours
<span class="nc" id="L910">			minHour = 1; //setting min &gt; max will show all hours of the day</span>
		}
<span class="nc" id="L912">		maxHour = adjustMaxHoursForDSTTransition(minHour, maxHour, tz);</span>
		//--- put results in the int array and return
<span class="nc" id="L914">		return getHoursArray(minHour,maxHour);</span>
	}//getMinMaxEventHours


	/**
	 * get hours range as two int using min and max values, which are ignored if invalid
	 */
	protected int[] getHoursArray(int minHour, int maxHour){
<span class="nc" id="L922">		int hours[] = {0,23};</span>
<span class="nc bnc" id="L923" title="All 2 branches missed.">		if (minHour &lt;= maxHour) {</span>
<span class="nc" id="L924">			hours[0] = minHour;</span>
<span class="nc" id="L925">			hours[1] = maxHour;</span>
		}
<span class="nc" id="L927">		return hours;</span>
	}//getHoursArray


	/**
	 * calculate min and max day hours for HOOs in the m_timeRange days
	 * If HOO close 7days/week. return [0,0]
	 * Else return [0,23]
	 */
	private int[] getMinMaxHooHours(HOOAssignment hoo){
		// initialize min and max for hoo
<span class="nc" id="L938">		int minHoo = 23;</span>
<span class="nc" id="L939">		int maxHoo = 0;</span>
		//--- for each day in the m_timeRange
<span class="nc" id="L941">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L942">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc" id="L943">		boolean dstAdjustment = false;</span>
<span class="nc bnc" id="L944" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange)) {</span>
			//   reset min and max hoo hours
<span class="nc" id="L946">			int[] minMaxHoo = getDayMinMaxHoo(aDay, hoo);</span>
<span class="nc bnc" id="L947" title="All 2 branches missed.">			if (minMaxHoo[0] &lt; minHoo)</span>
<span class="nc" id="L948">				minHoo = minMaxHoo[0];</span>
<span class="nc bnc" id="L949" title="All 2 branches missed.">			if (minMaxHoo[1] &gt; maxHoo)</span>
<span class="nc" id="L950">				maxHoo = minMaxHoo[1];</span>
			//QC46598 java bug for Brazil DST transition 10/18/09
<span class="nc" id="L952">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
//			aDay.nextDay();
<span class="nc" id="L954">		}//endwhile</span>

<span class="nc" id="L956">		maxHoo = adjustMaxHoursForDSTTransition(minHoo, maxHoo, tz);</span>
		//--- put results in the int array and return
<span class="nc" id="L958">		return getHoursArray(minHoo,maxHoo);</span>
	}//getMinMaxHooHours

	// On DST transition days, the timeline either includes an extra hour or is missing one hour
	private int adjustMaxHoursForDSTTransition(int min, int max, TimeZone tz) {
//		Calendar startCal = m_timeRange.getStartCalendar(tz, m_locale);
<span class="nc bnc" id="L964" title="All 2 branches missed.">		Calendar startCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartCalendar(tz, m_locale):findDSTTransitionDay(tz);</span>
<span class="nc" id="L965">		startCal.set(Calendar.HOUR_OF_DAY, min);</span>
<span class="nc" id="L966">		boolean startInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc" id="L967">		startCal.set(Calendar.HOUR_OF_DAY, max);</span>
<span class="nc" id="L968">		boolean endInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc bnc" id="L969" title="All 4 branches missed.">		if (startInDST &amp;&amp; !endInDST)  // one hour extra</span>
<span class="nc" id="L970">			return ++max;</span>
		else
<span class="nc" id="L972">			return max;</span>
	}

	/**
	 * get min an max hour for HOO on a given day
	 */
	private int[] getDayMinMaxHoo(CalendarRange aDay, HOOAssignment hoo){
<span class="nc" id="L979">		int minHoo = 23;</span>
<span class="nc" id="L980">		int maxHoo = 0;</span>
<span class="nc bnc" id="L981" title="All 2 branches missed.">		if (hoo != null) {</span>
			//London: ignore effectivity periods
			/*
			Date hooStart = hoo.getStartTime();
			Date hooEnd = (hoo.getEndTime()!=null)?hoo.getEndTime(): new Date(Long.MAX_VALUE); //open-ended
			TimeRange hooEffectivityRange = new TimeRange(hooStart,hooEnd);
			if (hooEffectivityRange.getOverlapDuration(aDay) &gt; 0) {
			*/
<span class="nc" id="L989">			int startDayOfWeek = aDay.getStartCalendar().get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L990">			minHoo = adjustMinHoo(minHoo, hoo, startDayOfWeek);</span>
<span class="nc" id="L991">			minHoo = adjustMaxHoo(maxHoo, hoo, startDayOfWeek);</span>
<span class="nc" id="L992">			int endDayOfWeek = aDay.getEndCalendar().get(Calendar.DAY_OF_WEEK);</span>
<span class="nc" id="L993">			minHoo = adjustMinHoo(minHoo, hoo, endDayOfWeek);</span>
<span class="nc" id="L994">			minHoo = adjustMaxHoo(maxHoo, hoo, endDayOfWeek);</span>
			//}
		}
		//--- put results in the int array and return
<span class="nc" id="L998">		return getHoursArray(minHoo,maxHoo);</span>
	}//getDayMinMaxHoo

	/**
	 * adjust minHoo if hoo starts earler
	 */
	private int adjustMinHoo(int minHoo, HOOAssignment hoo, int weekDay){
<span class="nc" id="L1005">		Integer iTmp = new Integer(weekDay);</span>
<span class="nc" id="L1006">		short tmp = iTmp.shortValue();</span>
<span class="nc" id="L1007">		short hooOpenMinute = hoo.getDayOpen(tmp);</span>
<span class="nc" id="L1008">		int hooOpenHour = hooOpenMinute/60;</span>
<span class="nc bnc" id="L1009" title="All 2 branches missed.">		return (hooOpenHour &lt; minHoo)? hooOpenHour : minHoo;</span>
	}//adjustMinHoo

	/**
	 * adjust maxHoo if hoo ends later
	 */
	private int adjustMaxHoo(int maxHoo, HOOAssignment hoo, int weekDay){
<span class="nc" id="L1016">		Integer iTmp = new Integer(weekDay);</span>
<span class="nc" id="L1017">		short tmp = iTmp.shortValue();</span>
<span class="nc" id="L1018">		short hooCloseMinute = hoo.getDayClose(tmp);</span>
<span class="nc" id="L1019">		int hooCloseHour = hooCloseMinute/60;</span>
<span class="nc bnc" id="L1020" title="All 2 branches missed.">		return (hooCloseHour &gt; maxHoo)? hooCloseHour : maxHoo;</span>
	}//adjustMaxHoo

	/**
	 * combine min/max hours for all events with HOO to determine shown hours
	 */
	private int[] combineMinMaxHours(int[] eventHoursRange, int[] hooHoursRange){

<span class="nc" id="L1028">		int minHour = 0;</span>
<span class="nc" id="L1029">		int maxHour = 0;</span>

<span class="nc bnc" id="L1031" title="All 6 branches missed.">		if (hooHoursRange[0] == 0 &amp;&amp; hooHoursRange[1] == 0</span>
				&amp;&amp; eventHoursRange[0] == 0){
<span class="nc" id="L1033">			minHour = eventHoursRange[0];</span>
<span class="nc" id="L1034">			maxHour = eventHoursRange[1];</span>
		}
		else {
<span class="nc" id="L1037">			minHour = Math.max(eventHoursRange[0], hooHoursRange[0]);</span>
<span class="nc" id="L1038">			maxHour = Math.min(eventHoursRange[1], hooHoursRange[1]);</span>
		}
<span class="nc" id="L1040">		return getHoursArray(minHour, maxHour);</span>
	}//combineMinMaxHours

	/**
	 * make page message if no published schedule available
	 */
	protected boolean messageIfNotPublished(Map theData){
<span class="nc" id="L1047">		boolean havePublished = isPublished(theData);</span>
<span class="nc bnc" id="L1048" title="All 2 branches missed.">		if (!havePublished) {</span>
<span class="nc" id="L1049">			addPageMessage(Message.INFO_TYPE, FsWebBundleKey.MSG_SV_NONE_PUBLISHED,</span>
					FsWebBundleKey.BUNDLE_NAME);
		} else {
<span class="nc" id="L1052">			addPageMessage(Message.INFO_TYPE, FsWebBundleKey.MSG_SV_PUBLISHED,</span>
				FsWebBundleKey.BUNDLE_NAME);
		}
<span class="nc" id="L1055">		return havePublished;</span>
	}

	/**
	 * Gets whether the schedule has been published.
	 */
	public static boolean isPublished(Map theData) {
<span class="nc" id="L1062">		boolean havePublished = false;</span>
<span class="nc" id="L1063">		Collection publishedPeriods = (Collection)theData.get(ScheduleViewMH.PUB_PERIODS_KEY);</span>
		//we got either a collection of TimeRanges or
		//  collection of collections of TimeRanges for each employee in the group
		//search for a TimeRange
<span class="nc bnc" id="L1067" title="All 4 branches missed.">		if (publishedPeriods != null &amp;&amp; !publishedPeriods.isEmpty()) {</span>
<span class="nc bnc" id="L1068" title="All 2 branches missed.">			for (Iterator i = publishedPeriods.iterator();i.hasNext();){</span>
<span class="nc" id="L1069">				Object obj = i.next();</span>
<span class="nc bnc" id="L1070" title="All 2 branches missed.">				if (obj != null) {</span>
<span class="nc bnc" id="L1071" title="All 2 branches missed.">					if (obj instanceof Collection){</span>
<span class="nc bnc" id="L1072" title="All 2 branches missed.">						if ( !((Collection)obj).isEmpty()){</span>
<span class="nc" id="L1073">							havePublished = true;  //assuming that contents are not all null</span>
<span class="nc" id="L1074">							break;</span>
						}
					} else {
<span class="nc" id="L1077">						havePublished = true;</span>
<span class="nc" id="L1078">						break;</span>
					}
				}
<span class="nc" id="L1081">			}</span>
		}
<span class="nc" id="L1083">		return havePublished;</span>
	}

	/**
	 * make page message if there are/not published schedules available
	 */
	protected boolean messageIfNotPublished(Map theData, Date date, TimeZone tz){
<span class="nc" id="L1090">		boolean havePublished = isPublishedByDate(theData, date, tz);</span>
<span class="nc bnc" id="L1091" title="All 2 branches missed.">		if (!havePublished) {</span>
<span class="nc" id="L1092">			addPageMessage(Message.INFO_TYPE, FsWebBundleKey.MSG_SV_NONE_PUBLISHED,</span>
				FsWebBundleKey.BUNDLE_NAME);
		} else {
<span class="nc" id="L1095">			addPageMessage(Message.INFO_TYPE, FsWebBundleKey.MSG_SV_PUBLISHED,</span>
				FsWebBundleKey.BUNDLE_NAME);
		}
<span class="nc" id="L1098">		return havePublished;</span>
	}

	public static boolean isPublishedByDate(Map theData, Date date, TimeZone tz) {
<span class="nc" id="L1102">		boolean havePublished = false;</span>
<span class="nc" id="L1103">		Collection publishedPeriods = (Collection)theData.get(ScheduleViewMH.PUB_PERIODS_KEY);</span>
<span class="nc" id="L1104">		Date referenceDate = addASecondOfTimeToDate(date, tz);		</span>
		
		//we got either a collection of TimeRanges or
		//  collection of collections of TimeRanges for each employee in the group
		//search for a TimeRange
<span class="nc bnc" id="L1109" title="All 4 branches missed.">		if (publishedPeriods != null &amp;&amp; !publishedPeriods.isEmpty()) {</span>
<span class="nc bnc" id="L1110" title="All 2 branches missed.">			for (Iterator i = publishedPeriods.iterator();i.hasNext();) {</span>
<span class="nc" id="L1111">				Object obj = i.next();</span>
<span class="nc bnc" id="L1112" title="All 2 branches missed.">				if (obj != null) {</span>
<span class="nc bnc" id="L1113" title="All 2 branches missed.">					if (obj instanceof Collection) {</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">						if ( !((Collection)obj).isEmpty()){</span>
							//assuming that contents are not all null
<span class="nc" id="L1116">							havePublished = checkPublishedPeriodByDate((Collection)obj, referenceDate);</span>
<span class="nc bnc" id="L1117" title="All 2 branches missed.">							if (havePublished) {</span>
<span class="nc" id="L1118">								break;</span>
							}
						}
<span class="nc bnc" id="L1121" title="All 2 branches missed.">					} else if (obj instanceof TimeRange){</span>
<span class="nc" id="L1122">						TimeRange tr = (TimeRange)obj;</span>
<span class="nc bnc" id="L1123" title="All 2 branches missed.">						if (tr.includes(date)) {</span>
<span class="nc" id="L1124">							havePublished = true;</span>
<span class="nc" id="L1125">							break;</span>
						}
					}
				}
<span class="nc" id="L1129">			}</span>
		}
<span class="nc" id="L1131">		return havePublished;</span>
	}
	
	private static boolean checkPublishedPeriodByDate(Collection publishedPeriods, Date date) {

<span class="nc bnc" id="L1136" title="All 4 branches missed.">		if (publishedPeriods != null &amp;&amp; !publishedPeriods.isEmpty()) {</span>
<span class="nc bnc" id="L1137" title="All 2 branches missed.">			for (Iterator i = publishedPeriods.iterator(); i.hasNext(); ) {</span>
<span class="nc" id="L1138">				TimeRange tr = (TimeRange)i.next();</span>
<span class="nc bnc" id="L1139" title="All 2 branches missed.">				if (tr.includes(date)) {</span>
<span class="nc" id="L1140">					return true;</span>
				}
<span class="nc" id="L1142">			}</span>
		}
<span class="nc" id="L1144">		return false;</span>
	}
	
	private static Date addASecondOfTimeToDate(Date date, TimeZone tz) {
<span class="nc" id="L1148">		Calendar cal = Calendar.getInstance(tz);</span>
<span class="nc" id="L1149">		cal.setTime(date);</span>
<span class="nc" id="L1150">		cal.add(Calendar.SECOND, 1);</span>
<span class="nc" id="L1151">		return cal.getTime();</span>
	}

	/**
	 * Add a tooltip to an HTML element
	 */
	public String addTooltip(String html, String tooltip) {
<span class="nc bnc" id="L1158" title="All 2 branches missed.">		if(tooltip!=null) {</span>
<span class="nc" id="L1159">			return &quot;&lt;span title=\&quot;&quot; + tooltip + &quot;\&quot;&gt;&quot; + html + &quot;&lt;/span&gt;&quot;;</span>
		}else{
<span class="nc" id="L1161">			return &quot;&lt;span&gt;&quot;+html+&quot;&lt;/span&gt;&quot;;</span>
		}
	}
	
	/**
	 * make the swap link around the event label
	 */
	protected String makeSwappableLink(boolean bSwapEnabled, boolean isMyRow,
			boolean isTimeOff, CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings,
			ScheduleViewShiftDisplayInfo shiftDisplayInfo, ID employeeId){

<span class="nc bnc" id="L1172" title="All 2 branches missed.">        if (shiftDisplayInfo ==  null)</span>
<span class="nc" id="L1173">            return &quot;&quot;;</span>

<span class="nc" id="L1175">		StringBuffer sb = new StringBuffer(512);</span>

        //--- append the previous day icon if any
<span class="nc" id="L1178">        sb.append(shiftDisplayInfo.getPreviousDayIcon());</span>

		//--- swappable only starting tomorrow
<span class="nc bnc" id="L1181" title="All 4 branches missed.">		boolean isSwappable = bSwapEnabled &amp;&amp; aDay.getRelativeLocation(new Date())==TimeRange.TIME_BEFORE;</span>
<span class="nc bnc" id="L1182" title="All 4 branches missed.">		if (isSwappable &amp;&amp; isMyRow)</span>
		{
<span class="nc bnc" id="L1184" title="All 2 branches missed.">			String shiftType = isTimeOff ? ShiftSwapItem.SWAPITEMTYPE_TIMEOFF : ShiftSwapItem.SWAPITEMTYPE_SHIFT;</span>
<span class="nc" id="L1185">			String dateStr = getDatePickerDateDsp( aDay.getStartDate() );</span>
<span class="nc" id="L1186">			String onClickJS = &quot;pageMediator.handleSwap('&quot; + shiftType  + &quot;', '&quot; + dateStr + &quot;');&quot;;</span>
<span class="nc" id="L1187">            String swapLabel = i18n(m_bundle,FsWebBundleKey.SV_SWAP_MY_SHIFT_LABEL) +  &quot; &quot; + shiftDisplayInfo.getShiftString(); //508</span>
<span class="nc" id="L1188">            sb.append(HtmlLinkUtil.createActiveLink(&quot;#&quot;, shiftDisplayInfo.getShiftString(), swapLabel, swapLabel, null, onClickJS)); //508</span>
<span class="nc" id="L1189">		}</span>
        else
        {
			//--- put shift or day off label with optional times
<span class="nc" id="L1193">			sb.append(shiftDisplayInfo.getShiftString());</span>
		}

        //--- append the next day icon if any
<span class="nc bnc" id="L1197" title="All 2 branches missed.">		if (!StringUtil.isEmpty(shiftDisplayInfo.getNextDayIcon())) {</span>
<span class="nc" id="L1198">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1199">			sb.append(shiftDisplayInfo.getNextDayIcon());</span>
		}

        //append pooling icon if applicable
<span class="nc bnc" id="L1203" title="All 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getPoolingActivityIcon())) {</span>
<span class="nc" id="L1204">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1205">        	sb.append(shiftDisplayInfo.getPoolingActivityIcon());</span>
        }

        //append calendar event icon if applicable
<span class="nc bnc" id="L1209" title="All 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getCalendarEventIcon())) {</span>
<span class="nc" id="L1210">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1211">        	sb.append(shiftDisplayInfo.getCalendarEventIcon());</span>
        }

        //append overtime icon if applicable
<span class="nc bnc" id="L1215" title="All 2 branches missed.">        if (!StringUtil.isEmpty(shiftDisplayInfo.getOvertimeIcon())) {</span>
<span class="nc" id="L1216">			sb.append(HtmlUtil.NBSP);</span>
<span class="nc" id="L1217">        	sb.append(shiftDisplayInfo.getOvertimeIcon());</span>
        }
<span class="nc bnc" id="L1219" title="All 2 branches missed.">        if(bSwapEnabled)</span>
		//--- find if there is a posting for this user for this day
<span class="nc" id="L1221">        	appendPostingImg(aDay,postings,employeeId, sb, shiftDisplayInfo.getShiftString());</span>

<span class="nc" id="L1223">		return sb.toString();</span>
	}//makeSwappableLink

	/**
	 * make the swap link around the event label
	 * @param tooltip - The tooltip for the shift (not for the swap link).
  	 */
	protected String makeSwappableLink(boolean bSwapEnabled, boolean isMyRow,
			boolean isTimeOff, CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings,
			String eventLabel, String tooltip, ID employeeId)
	{
<span class="nc" id="L1234">		StringBuffer sb = new StringBuffer(512);</span>

		//--- swappable only starting tomorrow
<span class="nc bnc" id="L1237" title="All 4 branches missed.">		boolean isSwappable = bSwapEnabled &amp;&amp; aDay.getRelativeLocation(new Date())==TimeRange.TIME_BEFORE;</span>
<span class="nc bnc" id="L1238" title="All 4 branches missed.">		if (isSwappable &amp;&amp; isMyRow)</span>
		{
<span class="nc bnc" id="L1240" title="All 2 branches missed.">			String shiftType = isTimeOff ? ShiftSwapItem.SWAPITEMTYPE_TIMEOFF : ShiftSwapItem.SWAPITEMTYPE_SHIFT;</span>
<span class="nc" id="L1241">			String dateStr = getDatePickerDateDsp( aDay.getStartDate() );</span>
<span class="nc" id="L1242">			String onClickJS = &quot;pageMediator.handleSwap('&quot; + shiftType  + &quot;', '&quot; + dateStr + &quot;');&quot;;</span>
<span class="nc" id="L1243">			sb.append(HtmlLinkUtil.createActiveLink(eventLabel, tooltip, null, onClickJS));</span>
<span class="nc" id="L1244">		}</span>
		else
		{
			//--- put shift or day off label with optional times
<span class="nc" id="L1248">			sb.append(addTooltip(eventLabel, tooltip));</span>
		}

		//--- find if there is a posting for this user for this day
<span class="nc bnc" id="L1252" title="All 2 branches missed.">		if(bSwapEnabled)</span>
<span class="nc" id="L1253">			appendPostingImg(aDay,postings,employeeId, sb);</span>

<span class="nc" id="L1255">		return sb.toString();</span>
	}//makeSwappableLink

	/**
	 * Initialize Posting Image
	 */
	private synchronized static void initPostingIMG() {
<span class="nc bnc" id="L1262" title="All 2 branches missed.">		if (POSTING_IMG==null) {</span>
<span class="nc" id="L1263">			POSTING_IMG = &quot;&lt;img border=\&quot;0\&quot; src=\&quot;&quot; + FsImageFileID.RED_FLAG + &quot;\&quot; hspace=\&quot;3\&quot;&gt;&quot;;</span>
		}
<span class="nc" id="L1265">	}</span>


	/**
	 * Append Posting Images
	 *
	 * @param aDay
	 * @param postings
	 * @param eID
	 * @param sb StringBuffer to append content to
     * @param eventLabel - this event label will be used to construct a label for the posting link.
	 */
	protected void appendPostingImg(CalendarRange aDay, Collection postings, ID eID, StringBuffer sb,
            String eventLabel) {
<span class="nc bnc" id="L1279" title="All 6 branches missed.">		if (aDay != null &amp;&amp; postings != null &amp;&amp; postings.size() &gt; 0) {</span>
<span class="nc" id="L1280">			boolean isMine = eID.equals(m_myEmpID);</span>
<span class="nc bnc" id="L1281" title="All 2 branches missed.">			if (POSTING_IMG==null) initPostingIMG();</span>

<span class="nc bnc" id="L1283" title="All 2 branches missed.">			for (Iterator it = postings.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1284">				ShiftSwapPosting posting = (ShiftSwapPosting)it.next();</span>
<span class="nc bnc" id="L1285" title="All 4 branches missed.">				if (posting != null &amp;&amp; posting.getShiftSwapItem() != null</span>
<span class="nc bnc" id="L1286" title="All 2 branches missed.">						&amp;&amp; aDay.includes(posting.getStartDate())</span>
<span class="nc bnc" id="L1287" title="All 2 branches missed.">						&amp;&amp; posting.getExpirationDate().after(new Date())</span>
<span class="nc bnc" id="L1288" title="All 2 branches missed.">						&amp;&amp; posting.getEmployeeID().equals(eID)){</span>
<span class="nc" id="L1289">					String postingID = posting.getID().toString();</span>
<span class="nc" id="L1290">					String onClickJS=&quot;pageMediator.handlePosting('&quot; + postingID + &quot;', &quot; + isMine + &quot;);&quot;;</span>

                    //For 508 Accessibility, we're creating a label for the posting link
<span class="nc" id="L1293">                    String label = &quot;&quot;;</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">                    if (isMine)</span>
<span class="nc" id="L1295">                        label = i18n(m_bundle,FsWebBundleKey.SV_EDIT_POSTING_LABEL) + &quot; &quot; + eventLabel;</span>
                    else
<span class="nc" id="L1297">                        label = i18n(m_bundle,FsWebBundleKey.SV_SWAP_WITH_SHIFT_LABEL) +  &quot; &quot; + eventLabel;                    </span>

<span class="nc" id="L1299">					String hrefVal = &quot;#&quot;;</span>
<span class="nc bnc" id="L1300" title="All 2 branches missed.">					String activeLink = isAccessibilityComplianceMode()</span>
<span class="nc" id="L1301">							? HtmlLinkUtil.createActiveLink(hrefVal, POSTING_IMG, label, label, null, onClickJS, true,</span>
									label)
<span class="nc" id="L1303">							: HtmlLinkUtil.createActiveLink(hrefVal, POSTING_IMG, label, label, null, onClickJS);</span>
<span class="nc" id="L1304">					sb.append(activeLink);</span>
				}
<span class="nc" id="L1306">			}</span>
		}
<span class="nc" id="L1308">	}//appendPostingIcons</span>

	protected void appendPostingImg(CalendarRange aDay, Collection&lt;ShiftSwapPosting&gt; postings, ID eID, StringBuffer sb) {
<span class="nc bnc" id="L1311" title="All 6 branches missed.">		if (aDay != null &amp;&amp; postings != null &amp;&amp; postings.size() &gt; 0) {</span>
<span class="nc" id="L1312">			boolean isMine = eID.equals(m_myEmpID);</span>
<span class="nc bnc" id="L1313" title="All 2 branches missed.">			if (POSTING_IMG==null) initPostingIMG();</span>

<span class="nc bnc" id="L1315" title="All 2 branches missed.">			for (Iterator&lt;ShiftSwapPosting&gt; it = postings.iterator(); it.hasNext();) {</span>
<span class="nc" id="L1316">				ShiftSwapPosting posting = it.next();</span>
<span class="nc bnc" id="L1317" title="All 4 branches missed.">				if (posting != null &amp;&amp; posting.getShiftSwapItem() != null</span>
<span class="nc bnc" id="L1318" title="All 2 branches missed.">						&amp;&amp; aDay.includes(posting.getStartDate())</span>
<span class="nc bnc" id="L1319" title="All 2 branches missed.">						&amp;&amp; posting.getExpirationDate().after(new Date())</span>
<span class="nc bnc" id="L1320" title="All 2 branches missed.">						&amp;&amp; posting.getEmployeeID().equals(eID)){</span>
<span class="nc" id="L1321">					String postingID = posting.getID().toString();</span>
<span class="nc" id="L1322">					String onClickJS=&quot;pageMediator.handlePosting('&quot; + postingID + &quot;', &quot; + isMine + &quot;);&quot;;</span>
<span class="nc" id="L1323">					sb.append(HtmlLinkUtil.createActiveLink(POSTING_IMG, null, null, onClickJS));</span>
				}
<span class="nc" id="L1325">			}</span>
		}
<span class="nc" id="L1327">	}//appendPostingIcons</span>

	/**
	 * Return Date as a String which id Date Picker Compatitle
	 */
	private String getDatePickerDateDsp(Date date) {
<span class="nc bnc" id="L1333" title="All 2 branches missed.">		if (m_datePicker==null) m_datePicker = new DatePickerPC(m_context, &quot;&quot;);</span>
<span class="nc" id="L1334">		m_datePicker.setDate(date);</span>
<span class="nc" id="L1335">		return m_datePicker.getDateDisplay();</span>
	}
	
	protected StringsPair makeShiftString(CalendarRange aDay, Collection&lt;ShiftAssignment&gt; shifts, HashMap&lt;ID, Activity&gt; activities,
									 Collection&lt;ShiftSwapPosting&gt; postings, Collection&lt;DailyScheduleSummary&gt; daySummaries,
									 boolean bSwapEnabled, boolean isMy, ID empID, boolean bShowTimeoff,
									 Map&lt;ID, String&gt; campaignNamesBySpID) {
<span class="nc" id="L1342">		return makeShiftStringWithAccessibility(aDay, shifts, activities, postings, daySummaries, bSwapEnabled, isMy, empID, bShowTimeoff, campaignNamesBySpID, false);</span>
	}//makeShiftString

	/**
	 * make html string with the shift information and the swap link
	 * @param campaignNamesBySpID - Map of campaignID-&gt;campaignName.
	 * @param isAccessibility makes all images tabbable  
	 * @return StringsPair - first is the shiftString, second is the campaignName.
	 */
	protected StringsPair makeShiftStringWithAccessibility(CalendarRange aDay, Collection&lt;ShiftAssignment&gt; shifts, HashMap&lt;ID, Activity&gt; activities,
										  Collection&lt;ShiftSwapPosting&gt; postings, Collection&lt;DailyScheduleSummary&gt; daySummaries,
										  boolean bSwapEnabled, boolean isMy, ID empID, boolean bShowTimeoff,
										  Map&lt;ID, String&gt; campaignNamesBySpID, boolean isAccessibility) {
<span class="nc" id="L1355">		StringBuilder sb = new StringBuilder();</span>
<span class="nc" id="L1356">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L1357">		DailyScheduleSummary daySchedule = null;</span>
<span class="nc" id="L1358">		ScheduleViewShiftDisplayInfo shiftLabel = null;</span>

<span class="nc" id="L1360">		String tooltip = &quot;&quot;;</span>
<span class="nc" id="L1361">		String campaignName = &quot;&quot;;</span>

<span class="nc bnc" id="L1363" title="All 2 branches missed.">		if (shifts != null) {</span>
<span class="nc bnc" id="L1364" title="All 2 branches missed.">			for(Iterator&lt;DailyScheduleSummary&gt; it = daySummaries.iterator(); it.hasNext();) {</span>
				//entries &quot;unpublished&quot; or &quot;no shift&quot; or &quot;hh:mm am - hh:mm pm&quot;
<span class="nc" id="L1366">				DailyScheduleSummary oneDaySchedule = it.next();</span>
<span class="nc" id="L1367">				CalendarRange daySummaryDay = oneDaySchedule.getDayRange();</span>

				// NOTE: we really should be comparing the calendar range objects
				// however, the end dates (by 1 second) and the locales are actually different
<span class="nc" id="L1371">				Calendar startOfDay = DateTimeUtil.getDayStart(aDay.getStartCalendar());</span>
<span class="nc bnc" id="L1372" title="All 2 branches missed.">				if (!startOfDay.getTime().equals(daySummaryDay.getStartDate())) {</span>
<span class="nc" id="L1373">					continue;</span>
				}

<span class="nc" id="L1376">				campaignName = ScheduleViewUtil.getCampaignName(campaignNamesBySpID, oneDaySchedule);</span>
<span class="nc bnc" id="L1377" title="All 2 branches missed.">				campaignName = campaignName==null?&quot;&quot;:campaignName;</span>

				// Only supply the tool tip if it is associated to a campaign.
<span class="nc bnc" id="L1380" title="All 2 branches missed.">				if (campaignName.length() &gt; 0) {</span>
<span class="nc" id="L1381">					tooltip = verticalize(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN)  + campaignName;</span>
				}
				//tooltip = i18n(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN) + campaignName;

<span class="nc" id="L1385">				daySchedule = oneDaySchedule;  // save this for making overtime strings.</span>

<span class="nc bnc" id="L1387" title="All 2 branches missed.">				if (!oneDaySchedule.isPublished()) {</span>
<span class="nc" id="L1388">					return new StringsPair(i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_UNPUBLISHED), &quot;&quot;);</span>
				}
<span class="nc bnc" id="L1390" title="All 2 branches missed.">				else if (oneDaySchedule.isClosed()) {</span>
<span class="nc" id="L1391">					return new StringsPair(i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_CLOSED), campaignName);</span>
				}
<span class="nc bnc" id="L1393" title="All 6 branches missed.">				else if ((bShowTimeoff || isMy) &amp;&amp; oneDaySchedule.isDayOff()) {</span>
<span class="nc" id="L1394">					String defaultAbsentString= i18n(m_bundle,FsWebBundleKey.SCHED_SUMMARY_DAY_OFF);</span>
<span class="nc" id="L1395">					String absentStringOverride = ScheduleSummaryMH.getAbsentStringOverride();</span>
<span class="nc bnc" id="L1396" title="All 4 branches missed.">					if(absentStringOverride!=null&amp;&amp; absentStringOverride.equals(FsWebBundleKey.FS_CUSTOM_TIME_OFF)) //The value is specific for France Telecom, Story 34046</span>
<span class="nc" id="L1397">						absentStringOverride = i18n(m_bundle,FsWebBundleKey.FS_CUSTOM_TIME_OFF);</span>
<span class="nc bnc" id="L1398" title="All 2 branches missed.">					String shiftLabel1 = absentStringOverride==null ? defaultAbsentString: absentStringOverride;</span>
<span class="nc" id="L1399">					sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel1,tooltip,empID));</span>
<span class="nc" id="L1400">					return new StringsPair(sb.toString(),campaignName);</span>
				}
				else {
<span class="nc bnc" id="L1403" title="All 4 branches missed.">					if (oneDaySchedule.hasShift() &amp;&amp; !oneDaySchedule.isDayOff()) {</span>
<span class="nc" id="L1404">						shiftLabel =  getShiftDisplayInfoWithAccessibility(oneDaySchedule, m_localizer, tz, isAccessibility);</span>
					}
					else {
<span class="nc" id="L1407">						shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1408">						sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID)); //&quot;Off&quot;</span>
<span class="nc" id="L1409">						return new StringsPair(sb.toString(),campaignName);</span>
					}
				}
<span class="nc" id="L1412">			}//for</span>

<span class="nc" id="L1414">			boolean foundShift = false;</span>
<span class="nc bnc" id="L1415" title="All 2 branches missed.">			for (ShiftAssignment event : shifts) {</span>
<span class="nc bnc" id="L1416" title="All 2 branches missed.">				if (event!=null) {</span>
<span class="nc" id="L1417">					TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1418">					int overlapType = aDay.getRelativeLocationTo(eventRange);</span>
<span class="nc bnc" id="L1419" title="All 6 branches missed.">					if (overlapType == TimeRange.INTERVAL_COVERS</span>
						|| overlapType == TimeRange.INTERVAL_EQUALS
						|| overlapType == TimeRange.INTERVAL_BEFORE_AND_IN)
					{
<span class="nc" id="L1423">						foundShift = true;</span>
<span class="nc" id="L1424">						Activity activity = activities.get(event.getActivityID());</span>
<span class="nc bnc" id="L1425" title="All 4 branches missed.">						sb.append(addTooltip(isAccessibility ? ShiftUtil.makeFocusableActivityBox(activity, m_localizer) : ShiftUtil.makeActivityBox(activity),</span>
							isAccessibility ? null :tooltip))
<span class="nc" id="L1427">							.append(&quot; &quot;)</span>
<span class="nc" id="L1428">							.append(makeSwappableLink(bSwapEnabled,isMy,false,aDay,postings,shiftLabel,empID));</span>

<span class="nc" id="L1430">						sb.append(makeShiftOvertimeString(aDay, daySchedule, event, tz, m_localizer, true, false));</span>
<span class="nc" id="L1431">						break;</span>
					}
				}
<span class="nc" id="L1434">			}//for</span>
<span class="nc bnc" id="L1435" title="All 2 branches missed.">			if (!foundShift) {</span>
<span class="nc" id="L1436">				shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1437">				sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID));</span>
			}
<span class="nc" id="L1439">		}</span>
		else {
<span class="nc" id="L1441">			shiftLabel = new ScheduleViewShiftDisplayInfo(&quot;&quot;, m_noShiftLabel, &quot;&quot;);</span>
<span class="nc" id="L1442">			sb.append(makeSwappableLink(bSwapEnabled,isMy,true,aDay,postings,shiftLabel,empID));</span>
		}
<span class="nc" id="L1444">		return new StringsPair(sb.toString(), campaignName);</span>
	}//makeShiftString

    /**
     * See if the specified employee ID is the ID of the currently logged-in user.
     * @param empID The employee ID to check.
     * @return true if the specified employee ID is the ID of the currently logged-in user.
     */
    protected boolean isMyID(ID empID)
    {
<span class="nc" id="L1454">        return m_myEmpID.equals(empID);</span>
    }

	/**
	 * make html string with shift overtime periods or empty string
	 * @return - html formatted string starting with &lt;br&gt; (if includeHtmlMarkup is true)
	 */
	public static String makeShiftOvertimeString(CalendarRange aDayRange,
			DailyScheduleSummary daySchedule,
			ShiftAssignment shiftAssignment,
			TimeZone timeZone,
			Localizer localizer,
			boolean includeHtmlMarkup,
			boolean includeActivityNames) {
<span class="nc" id="L1468">		StringBuffer sb = new StringBuffer();</span>

<span class="nc" id="L1470">		boolean overtimeDisplayed = false;</span>
<span class="nc" id="L1471">		TimeRange beforeExTimeRange = ScheduleViewUtil.getExtensionBeforeTimeRange(shiftAssignment);</span>
<span class="nc" id="L1472">		TimeRange afterExTimeRange = ScheduleViewUtil.getExtensionAfterTimeRange(shiftAssignment);</span>
<span class="nc bnc" id="L1473" title="All 2 branches missed.">		if(beforeExTimeRange != null) {</span>
<span class="nc bnc" id="L1474" title="All 2 branches missed.">			if (includeHtmlMarkup) {</span>
<span class="nc" id="L1475">				sb.append(&quot;&lt;br&gt;&quot;);</span>
			}
<span class="nc" id="L1477">			sb.append(localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.OVERTIME_PROMPT)).append(&quot; &quot;);</span>
<span class="nc" id="L1478">			String timeRangeStr = ShiftUtil.makeShiftDatesString(aDayRange,</span>
<span class="nc" id="L1479">					beforeExTimeRange.getStartDate(), beforeExTimeRange.getEndDate(),</span>
					localizer, timeZone);
<span class="nc bnc" id="L1481" title="All 2 branches missed.">			if (includeActivityNames) {</span>
<span class="nc" id="L1482">				Activity activity = daySchedule.getOvertimeActivityForTimeRange(beforeExTimeRange);</span>
<span class="nc bnc" id="L1483" title="All 2 branches missed.">				if (activity != null) {</span>
<span class="nc" id="L1484">					sb.append(localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.SV_ACTIVITY_NAME_AND_TIME_RANGE,</span>
<span class="nc" id="L1485">							new Object[]{timeRangeStr, activity.getName()}));</span>
				} else {
<span class="nc" id="L1487">					sb.append(timeRangeStr);</span>
				}
<span class="nc" id="L1489">			} else {</span>
<span class="nc" id="L1490">				sb.append(timeRangeStr);</span>
			}
<span class="nc" id="L1492">			overtimeDisplayed = true;</span>
		}
<span class="nc bnc" id="L1494" title="All 2 branches missed.">		if(afterExTimeRange != null) {</span>
<span class="nc bnc" id="L1495" title="All 2 branches missed.">			if (overtimeDisplayed) {</span>
<span class="nc" id="L1496">				sb.append(&quot;, &quot;);</span>
			} else {
<span class="nc bnc" id="L1498" title="All 2 branches missed.">				if (includeHtmlMarkup) {</span>
<span class="nc" id="L1499">					sb.append(&quot;&lt;br&gt;&quot;);</span>
				}
<span class="nc" id="L1501">				sb.append(localizer.i18n(BbmWebBundleKey.BUNDLE_NAME, BbmWebBundleKey.OVERTIME_PROMPT)).append(&quot; &quot;);</span>
			}
<span class="nc" id="L1503">			String timeRangeStr = ShiftUtil.makeShiftDatesString(aDayRange,</span>
<span class="nc" id="L1504">					afterExTimeRange.getStartDate(), afterExTimeRange.getEndDate(),</span>
					localizer, timeZone);
<span class="nc bnc" id="L1506" title="All 2 branches missed.">			if (includeActivityNames) {</span>
<span class="nc" id="L1507">				Activity activity = daySchedule.getOvertimeActivityForTimeRange(afterExTimeRange);</span>
<span class="nc bnc" id="L1508" title="All 2 branches missed.">				if (activity != null) {</span>
<span class="nc" id="L1509">					sb.append(localizer.i18n(FsWebBundleKey.BUNDLE_NAME, FsWebBundleKey.SV_ACTIVITY_NAME_AND_TIME_RANGE,</span>
<span class="nc" id="L1510">							new Object[]{timeRangeStr, activity.getName()}));</span>
				} else {
<span class="nc" id="L1512">					sb.append(timeRangeStr);</span>
				}
<span class="nc" id="L1514">			} else {</span>
<span class="nc" id="L1515">				sb.append(timeRangeStr);</span>
			}
		}
<span class="nc" id="L1518">		return sb.toString();</span>
	}//makeShiftOvertimeString
	/**
	 * make html string with the shift and/or calendar events information for the text view
	 */
	protected String makeEventsString(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule, HashMap&lt;ID, Activity&gt; activities,
			boolean bShowUnavailable, boolean bShowTimeoff, boolean bShowNote, boolean isMy){

<span class="nc" id="L1526">		return makeEventsString(aDay,schedule,activities,bShowUnavailable,bShowTimeoff,bShowNote,isMy,true);</span>
	}//makeEventsString
	/**
	 * make html string with the shift and/or calendar events information for the text view
	 * @param isShowAbsentReason to indicate if the Absent Reason is displayed or not
	 */
	protected String makeEventsString(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule, HashMap&lt;ID, Activity&gt; activities,
			boolean bShowUnavailable, boolean bShowTimeoff, boolean bShowNote, boolean isMy, boolean isShowAbsentReason){
<span class="nc" id="L1534">		return makeEventsString(aDay, schedule, activities, bShowUnavailable, bShowTimeoff, bShowNote, isMy, isShowAbsentReason, null);</span>
	}//makeEventsString
	
	protected String makeEventsString(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule, HashMap&lt;ID, Activity&gt; activities,
			boolean bShowUnavailable, boolean bShowTimeoff, boolean bShowNote, boolean isMy, boolean isShowAbsentReason, String additionalLabel) {
<span class="nc" id="L1539">		String result = &quot;&quot;;</span>

		//--- make collection of events for this day (need it since the styles for different rows may differ)
<span class="nc" id="L1542">		ArrayList&lt;Event&gt; dayEventList = selectDayEvents(aDay,schedule);</span>
<span class="nc bnc" id="L1543" title="All 4 branches missed.">		if (dayEventList != null &amp;&amp; !dayEventList.isEmpty()) {</span>
<span class="nc bnc" id="L1544" title="All 4 branches missed.">			result = ShiftUtil.makeActivitiesString(aDay, dayEventList,</span>
<span class="nc" id="L1545">					 bShowUnavailable, bShowTimeoff||isMy, bShowNote, activities, m_localizer, m_context.getViewingTimeZone(),isShowAbsentReason, additionalLabel);</span>
		}

<span class="nc" id="L1548">		return result;</span>
	}//makeEventsString

	/**
	 * Creates and returns a string representing an HTML snippet used
	 * to render the campaign name associated to an activity of a shift.
	 */
	protected String makeCampaignActivityString(CalendarRange aDay, Collection&lt;DailyScheduleSummary&gt; daySummaries,
			Collection&lt;ShiftAssignment&gt; shifts, Collection&lt;SimpleEvent&gt; schedule, Map&lt;ID, Activity&gt; activities,
			Map&lt;ID, String&gt; campaignNamesBySpID, boolean bShowUnavailable, boolean bShowTimeoff) {

<span class="nc" id="L1559">		ArrayList&lt;Event&gt; dayEvents = selectDayEvents(aDay, schedule);</span>
<span class="nc" id="L1560">		DailyScheduleSummary daySummary = selectDayScheduleSummary(aDay, daySummaries);</span>

<span class="nc" id="L1562">		return ShiftUtil.makeCampaignActivityString(aDay, daySummary, shifts, dayEvents,</span>
				activities, campaignNamesBySpID, bShowUnavailable,
                bShowTimeoff);
	}

	/**
	 * select schedule events only for the given day
	 * @param aDay
	 * @param schedule - schedule events
	 * @return ArrayList of schedule events other than shifts overlapping aDay
	 */
	public static ArrayList&lt;Event&gt; selectDayEvents(CalendarRange aDay, Collection&lt;? extends Event&gt; schedule) {
<span class="nc bnc" id="L1574" title="All 4 branches missed.">		if (schedule == null || schedule.size() &lt; 1) {</span>
<span class="nc" id="L1575">			return null;</span>
		}
<span class="nc" id="L1577">		ArrayList&lt;Event&gt; daySchedule = new ArrayList&lt;Event&gt;();</span>
<span class="nc bnc" id="L1578" title="All 2 branches missed.">		for (Iterator&lt;? extends Event&gt; i = schedule.iterator(); i.hasNext();) {</span>
<span class="nc" id="L1579">			Event event = i.next();</span>
<span class="nc bnc" id="L1580" title="All 2 branches missed.">			if (event != null){</span>
<span class="nc" id="L1581">				TimeRange eventRange = new TimeRange(event.getStartTime(), event.getEndTime());</span>
<span class="nc" id="L1582">				int overlapType = aDay.getRelativeLocationTo(eventRange);</span>
<span class="nc bnc" id="L1583" title="All 4 branches missed.">				if (overlapType != TimeRange.INTERVAL_AFTER &amp;&amp; overlapType != TimeRange.INTERVAL_BEFORE) {</span>
<span class="nc" id="L1584">					daySchedule.add(event);</span>
				}
			}
<span class="nc" id="L1587">		}//for</span>
<span class="nc" id="L1588">		return daySchedule;</span>
	}//selectDayEvents

	/**
	 *
	 */
	public static DailyScheduleSummary selectDayScheduleSummary(CalendarRange aDay, Collection&lt;DailyScheduleSummary&gt; daySummaries) {
<span class="nc bnc" id="L1595" title="All 2 branches missed.">		for(DailyScheduleSummary oneDaySchedule : daySummaries)</span>
		{
			//entries &quot;unpublished&quot; or &quot;no shift&quot; or &quot;hh:mm am - hh:mm pm&quot;
<span class="nc" id="L1598">			CalendarRange daySummaryDay = oneDaySchedule.getDayRange();</span>

			// NOTE: we really should be comparing the calendar range objects
			// however, the end dates (by 1 second) and the locales are actually different
<span class="nc bnc" id="L1602" title="All 2 branches missed.">			if (aDay.getStartDate().equals(daySummaryDay.getStartDate())) {</span>
<span class="nc" id="L1603">				return oneDaySchedule;</span>
			}
<span class="nc" id="L1605">		}</span>

<span class="nc" id="L1607">		return null;</span>
	}

	/**
	 * make a row for the list display of the date
	 */
	protected DefaultMultiColumnNodeData makeLeftRowForGraph(CalendarRange aDay) {
<span class="nc" id="L1614">		String strDate = m_localizer.formatDate(aDay.getStartCalendar().getTime(),</span>
<span class="nc" id="L1615">				m_context.getViewingTimeZone(),</span>
				RegionalFormatBundleKey.DATE_DAYINWEEK_FORMAT);
<span class="nc" id="L1617">		return makeLeftRowStringForGraph(strDate);</span>
	}

	/**
	 * make a row in the date column, but instead of a date, you can show any string.
	 */
	protected DefaultMultiColumnNodeData makeLeftRowStringForGraph(String str) {
<span class="nc" id="L1624">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L1625">		rowData.add(str, CSSUtil.STYLE_NOWRAP);</span>
<span class="nc" id="L1626">		rowData.setSelectable(false);</span>
<span class="nc" id="L1627">		return rowData;</span>
	}
	protected DefaultMultiColumnNodeData makeRightRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, int[] shownHours,
			Collection&lt;SimpleEvent&gt; schedule, HashMap&lt;ID, Activity&gt; activities, boolean bShowUnavailable,
			boolean bShowTimeoff, int rowIndex, boolean isMy, Collection&lt;DailyScheduleSummary&gt; empDaySummaries,
			Map&lt;ID, String&gt; campaignNamesBySpID, dstTransitionMode mode, int dstTransitionHour) {
<span class="nc" id="L1634">		return makeRightRowForGraph(context,sbJS,aDay,shownHours,schedule,activities,bShowUnavailable,</span>
				bShowTimeoff,rowIndex,isMy,empDaySummaries,campaignNamesBySpID,mode,dstTransitionHour,true);
	}

	/**
	 * make a row for the multicolumn list display of the schedule events in Graph view.
	 * @param empDaySummaries - the collection of DailyScheduleSummary's for the employee
	 */
	protected DefaultMultiColumnNodeData makeRightRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, int[] shownHours,
			Collection&lt;SimpleEvent&gt; schedule, HashMap&lt;ID, Activity&gt; activities, boolean bShowUnavailable,
			boolean bShowTimeoff, int rowIndex, boolean isMy, Collection&lt;DailyScheduleSummary&gt; empDaySummaries,
			Map&lt;ID, String&gt; campaignNamesBySpID, ScheduleViewPM.dstTransitionMode mode, int dstTransitionHour,boolean isShowAbsentReason)
	{
<span class="nc" id="L1648">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L1649">		TimeZone tz = context.getViewingTimeZone();</span>

		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L1652">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L1653">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L1654">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>

		//--- make the row with one empty cell ---
<span class="nc" id="L1657">		rowData.add(&quot;&amp;nbsp;&quot;);</span>
<span class="nc" id="L1658">		rowData.setNodeAttribute(&quot;style&quot;, &quot;line-height:0px&quot;);</span>

		//--- generate JS object with the data for the row ---
<span class="nc" id="L1661">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L1662">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,false));&quot;);</span>

		//for each event in the flattened schedule for this day
<span class="nc" id="L1665">		int eventStartIndex = -1;</span>
<span class="nc" id="L1666">		int eventEndIndex = -1;</span>
<span class="nc" id="L1667">		int newEventStartIndex = -1;</span>
<span class="nc" id="L1668">		int newEventEndIndex = -1;</span>
<span class="nc" id="L1669">		String eventColor = &quot;&quot;;</span>
<span class="nc" id="L1670">		String eventPattern = &quot;&quot;;</span>

<span class="nc" id="L1672">		boolean isDayStartDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L1673">		boolean isDayEndDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L1674" title="All 2 branches missed.">		boolean dayIsDSTDay = isDayStartDST != isDayEndDST;</span>

<span class="nc bnc" id="L1676" title="All 2 branches missed.">		boolean isPeriodIncDST = tz.inDaylightTime(m_timeRange.getStartDate()) != tz.inDaylightTime(m_timeRange.getEndDate());</span>

<span class="nc bnc" id="L1678" title="All 2 branches missed.">		for (Iterator&lt;SimpleEvent&gt; i = schedule.iterator(); i.hasNext();)</span>
		{
<span class="nc" id="L1680">			SimpleEvent scheduleEvent = i.next();</span>
<span class="nc bnc" id="L1681" title="All 4 branches missed.">			if (scheduleEvent.getStartTime().after(aDay.getEndDate()) || scheduleEvent.getEndTime().before(aDay.getStartDate()))</span>
<span class="nc" id="L1682">				continue; //not overlap with the day, no painting.</span>

<span class="nc bnc" id="L1684" title="All 4 branches missed.">			if (scheduleEvent != null</span>
<span class="nc bnc" id="L1685" title="All 6 branches missed.">					&amp;&amp; (bShowUnavailable || scheduleEvent.getEventType() != Event.EVENT_TYPE_UNAVAILABILITY)</span>
<span class="nc bnc" id="L1686" title="All 2 branches missed.">					&amp;&amp; (bShowTimeoff || isMy || scheduleEvent.getEventType() != Event.EVENT_TYPE_TIME_OFF))</span>
			{
<span class="nc" id="L1688">				TimeRange eventRange = ScheduleViewUtil.eventRange(scheduleEvent);</span>
<span class="nc" id="L1689">				Calendar eventStartCal = eventRange.getStartCalendar(tz,null);</span>
<span class="nc" id="L1690">				Calendar eventEndCal = eventRange.getEndCalendar(tz,null);</span>
<span class="nc" id="L1691">				eventStartIndex =  makeMinuteIndex(aDay, eventStartCal, firstShownIndex, lastShownIndex, mode, isDayStartDST, dstTransitionHour);</span>
<span class="nc" id="L1692">				eventEndIndex =  makeMinuteIndex(aDay, eventEndCal, firstShownIndex, lastShownIndex, mode, isDayStartDST, dstTransitionHour);</span>

<span class="nc bnc" id="L1694" title="All 2 branches missed.">				if (eventStartIndex == PREV_DAY_INDEX) {</span>
					//event start at previous day, paining cross day event.
<span class="nc" id="L1696">					eventStartIndex =0;</span>
				}

<span class="nc bnc" id="L1699" title="All 2 branches missed.">				if (eventEndIndex &gt; gridWidth)</span>
<span class="nc" id="L1700">				    eventEndIndex = gridWidth;</span>

<span class="nc bnc" id="L1702" title="All 4 branches missed.">				if (eventStartIndex &lt; gridWidth+1 &amp;&amp; eventEndIndex != PREV_DAY_INDEX)</span>
				{
<span class="nc" id="L1704">					boolean eventStartIsDST = tz.inDaylightTime(eventStartCal.getTime());</span>
<span class="nc" id="L1705">					boolean eventEndIsDST = tz.inDaylightTime(eventEndCal.getTime());</span>
<span class="nc" id="L1706">					int dstSavings = tz.getDSTSavings()/(60*1000);</span>

<span class="nc bnc" id="L1708" title="All 4 branches missed.">					switch(mode) {</span>
					case FALLBACK:
<span class="nc bnc" id="L1710" title="All 6 branches missed.">						if (!dayIsDSTDay &amp;&amp; isPeriodIncDST &amp;&amp; getViewType().equals(VIEW_TYPE_MY_GRAPH)) {</span>
							//The Personal Graph view can show multiple days at once, but if one of those days is the
							//Fall DST transition, then all of the days will show two 1AM's. Only the transition day
							//will actually have data in the 2nd 1AM. For the other days, we need to break up any
							//events that start before the 2nd 1AM and end after the 2nd 1AM, so that nothing is
							//graphed during the 2nd 1AM hour.
<span class="nc bnc" id="L1716" title="All 4 branches missed.">							if ((eventStartIndex &lt; dstTransitionHour*60) &amp;&amp; (eventEndIndex &gt;= dstTransitionHour*60)) {</span>
<span class="nc" id="L1717">								newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L1718">								eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L1719">								newEventStartIndex = eventEndIndex + dstSavings;</span>
							}
						}

						break;
					case SPRINGFORWARD:
<span class="nc bnc" id="L1725" title="All 6 branches missed.">						if (dayIsDSTDay &amp;&amp; eventEndIsDST &amp;&amp; !eventStartIsDST) {</span>
							//The Personal and Group Graph views will always include 2AM, even if the only day in the view
							//is the Spring DST transition, which is supposed to skip 2AM. The DST transition day
							//will have no data in the 2AM hour, so we need to break up any events that start before
							//2AM and end after the on or after 3AM, so that nothing is graphed during the 2AM hour.
<span class="nc" id="L1730">							newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L1731">							eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L1732">							newEventStartIndex = eventEndIndex + dstSavings;</span>
						}
					case NEUTRAL:
<span class="nc" id="L1735">						break;</span>
					default:
						break;
					}

					//event overlaps with the shown hrs
<span class="nc" id="L1741">					Activity eventActivity = getEventActivity(scheduleEvent,activities);</span>
<span class="nc" id="L1742">					eventColor = eventActivity.getColor();</span>

<span class="nc bnc" id="L1744" title="All 4 branches missed.">                    if (scheduleEvent.isOvertime() &amp;&amp; (scheduleEvent.getEventType()!=Event.EVENT_TYPE_TIME_OFF))</span>
<span class="nc" id="L1745">                        eventPattern = FsImageFileID.OT_PATTERN;</span>
                    else
<span class="nc" id="L1747">                        eventPattern = &quot;null&quot;;</span>

<span class="nc" id="L1749">                    String eventTooltip = getEventTooltip(aDay, scheduleEvent, eventActivity, eventPattern, eventRange, empDaySummaries, campaignNamesBySpID, tz);</span>
<span class="nc" id="L1750">                    String nsValue = &quot;SE&quot;; //tells us the cell type: &quot;SE&quot;=Schedule Event, &lt;0=NS Shortage, 0=NS Neutral, &gt;0=NS Surplus</span>
<span class="nc" id="L1751">                    String nsID = &quot;&quot;; //The cell ID which countains row and column numbers (used for Net Staffing cells only).</span>

                    // do not display the event if it has an unavailability type activity, reset to show just the shift assignment
<span class="nc bnc" id="L1754" title="All 2 branches missed.">    				if (ShiftUtil.isEventUnavailabilityType(eventActivity, scheduleEvent, bShowUnavailable)</span>
    						//Story34045- PSR 6104 - Reason for Absence viewable only by Supervisor
<span class="nc bnc" id="L1756" title="All 4 branches missed.">    						|| (eventActivity.isTimeoff() &amp;&amp;!isShowAbsentReason)) {</span>

<span class="nc" id="L1758">    					eventPattern = &quot;&quot;;</span>
<span class="nc" id="L1759">    					eventColor = &quot;0000FF&quot;;</span>
<span class="nc" id="L1760">    					eventTooltip = &quot;&quot;;</span>
    				}

					// create JS ScheduleEvent object and add it to calendarGrid.rows[rowIndex]
<span class="nc" id="L1764">					sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L1765">							.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L1766">							.append(eventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L1767">							.append(eventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1768">							.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1769">							.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1770">							.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1771">							.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1772">							.append(eventRange.getStartDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1773">							.append(eventRange.getEndDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1774">							.append(nsValue).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1775">					        .append(nsID).append(&quot;\&quot;)&quot;);</span>

<span class="nc bnc" id="L1777" title="All 2 branches missed.">					if (newEventStartIndex != -1) {</span>
<span class="nc" id="L1778">						sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L1779">						.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L1780">						.append(newEventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L1781">						.append(newEventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1782">						.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1783">						.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1784">						.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1785">						.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1786">						.append(eventRange.getStartDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1787">						.append(eventRange.getEndDate().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1788">						.append(nsValue).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L1789">				        .append(nsID).append(&quot;\&quot;)&quot;);</span>
					}
				}

<span class="nc" id="L1793">				newEventStartIndex = -1;</span>
<span class="nc" id="L1794">				newEventEndIndex = -1;</span>
			}
<span class="nc" id="L1796">		}</span>
<span class="nc" id="L1797">		rowData.setSelectable(false);</span>
<span class="nc" id="L1798">		return rowData;</span>
	}

	/**
	 *  A wrapper for what-if mode
	 */
	public static TimeSeriesManager getTimeSeriesManager(RequestContext context) throws Exception {
<span class="nc" id="L1805">		return WfmManagerFactory.getTimeSeriesManager(context.isInWhatIfMode());</span>
	}

    /**
	 * Return the date for an absolute offset from the TraceCube.
	 */
	protected Date getDateFromTraceCubeOffset(TraceCube tc, int offset)
	{
<span class="nc" id="L1813">		Calendar cal = Calendar.getInstance(m_context.getViewingTimeZone());</span>
<span class="nc" id="L1814">		cal.setTime(tc.getRawStartDate());</span>
<span class="nc" id="L1815">		cal.add(Calendar.MINUTE, offset*15);</span>
<span class="nc" id="L1816">		return cal.getTime();</span>
	}

    /**
	 * Return the Calendar date for an absolute offset from the TraceCube.
	 */
	protected Calendar getCalendarFromTraceCubeOffset(TraceCube tc, int offset)
	{
<span class="nc" id="L1824">		Calendar cal = Calendar.getInstance(m_context.getViewingTimeZone());</span>
<span class="nc" id="L1825">		cal.setTime(tc.getRawStartDate());</span>
<span class="nc" id="L1826">		cal.add(Calendar.MINUTE, offset*15);</span>
<span class="nc" id="L1827">		return cal;</span>
	}

	/**
	 * Get the personalized Net Staffing values at the given TraceCube offset, taking into account any scheduled Time Off/work
	 * time/Unavailability event at that interval, and whether or not Custom Shift Requests or VTO Requests are enabled.
	 * For example, if the Net Staffing at the requested interval is NS_UNDERSTAFFED, and the user is already scheduled to
	 * work at that time, then it doesn't make sense to return NS_UNDERSTAFFED because the user is already working and cannot
	 * do anything to satisfy that deficiency. So we return NS_NEUTRAL in this case.
	 * Conversely, if the user is not working at a time when the net staffing is NS_OVERSTAFFED, then we'll return 0 instead.
	 *
	 * For queues with LTI &gt; 15 minutes, it is possible that an LTI period will partially or completely fall outside of the
	 * employee's organization HOO. If that's the case, we wouldn't want to show a net staffing deficiency for the entire
	 * period. So, we consider the HOO's and only show a deficiency for time intervals that fall within the HOO.
	 *
	 * @param schedule - The flattened scheduled events for the employee.
	 * @param csReqEnabled - Are Custom Shift Requests enabled?
	 * @param vtoReqEnabled - Are Time Off Requests enabled?
	 * @param isPublished - Is the schedule published?
	 *
	 * @return the personalized Net Staffing value for the user at the given TraceCube offset. This is a pair of int's (valid values for each are -1,0,+1):
	 *
	 *   [index 0] = The personalized net staffing value. This is used to determine which color to paint the cell.
	 *               Possible values:
	 *               NET_UNDERSTAFFED: This cell will be painted with the Net Staffing Shortage color.
	 *
	 *               NET_OVERSTAFFED: This cell will be painted with the Net Staffing Surplus color.
	 *
	 *               NET_NEUTRAL: This cell will be painted with the Net Staffing Neutral color.
	 *
	 *   [index 1] = The &quot;simplified&quot; personalized net staffing value. This value is used by the graphing code to determine which
	 *               type of request should be associated with &quot;neutral&quot; colored cells (those cells with a 0 value for [index 0]).
	 *               Possible values:
	 *               NET_UNDERSTAFFED: Any cell NOT under a Shift, TO, or Unavailability, as long as CS requests are enabled. Indicates that
	 *                   only CS requests are available for this cell.
	 *
	 *               NET_OVERSTAFFED: Any cell under a shift (but NOT under TO or Unavailability), as long as VTO Requests are enabled.
	 *               	Indicates that only VTO requests are available for this cell.
	 *
	 *               NET_NEUTRAL: Any cell in the past, or one that is under a Time Off/Unavailability event, or one for which the appropriate
	 *                   request type is disabled. Indicates that no requests are available for this cell, or any selection that includes this cell.
	 */
	public static int[] getPersonalizedNetStaffingValue(NetStaffingCube nsCube, Calendar eventStartCal, Calendar eventEndCal,
			Collection schedule, boolean csReqEnabled, boolean vtoReqEnabled, boolean isPublished, HashMap activities,
			Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias, Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues,
			Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp,
			Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp)
	{
<span class="nc" id="L1875">		int[] value = new int[2];</span>
<span class="nc" id="L1876">		value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //initialize to neutral</span>
<span class="nc" id="L1877">		value[1] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //initialize to neutral</span>

<span class="nc" id="L1879">		Date startIntervalDate = eventStartCal.getTime();</span>
<span class="nc" id="L1880">		Date endIntervalDate = eventEndCal.getTime();</span>

<span class="nc" id="L1882">		TimeRange intervalRange = new TimeRange(startIntervalDate, endIntervalDate);</span>
<span class="nc" id="L1883">		Date now = new Date();</span>
<span class="nc" id="L1884">		boolean cellIsNotRequestable = false;</span>
<span class="nc" id="L1885">		long totalWorkDurationMS = 0;</span>
<span class="nc" id="L1886">		long totalTimeoffDurationMS = 0;</span>

<span class="nc" id="L1888">		HashMap&lt;Integer, Long&gt; overUnderToDurationMap = new HashMap&lt;Integer, Long&gt;();</span>

<span class="nc bnc" id="L1890" title="All 2 branches missed.">		if (startIntervalDate.after(now))</span>
		{
			//see if there is any scheduled event at that time
<span class="nc bnc" id="L1893" title="All 2 branches missed.">			for (Iterator it = schedule.iterator(); it.hasNext();)</span>
			{
<span class="nc" id="L1895">				SimpleEvent curEvent = (SimpleEvent) it.next();</span>
<span class="nc bnc" id="L1896" title="All 4 branches missed.">				if (curEvent != null &amp;&amp; (curEvent.getEventType() != Event.EVENT_TYPE_UNAVAILABILITY))</span>
				{
<span class="nc" id="L1898">					TimeRange eventRange = ScheduleViewUtil.eventRange(curEvent);</span>
<span class="nc" id="L1899">					long overlapDurationMS = eventRange.getOverlapDuration(intervalRange);</span>

<span class="nc bnc" id="L1901" title="All 2 branches missed.">					if (overlapDurationMS &gt; 0) //if this scheduled event is in the current interval</span>
					{
<span class="nc" id="L1903">						int overUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>

<span class="nc bnc" id="L1905" title="All 2 branches missed.">						if (curEvent.getEventType() == Event.EVENT_TYPE_TIME_OFF) // || curEvent.getEventType() == Event.EVENT_TYPE_UNAVAILABILITY</span>
						{
<span class="nc" id="L1907">							totalTimeoffDurationMS += overlapDurationMS;</span>
<span class="nc" id="L1908">							overUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
						}
						else
						{
<span class="nc" id="L1912">							totalWorkDurationMS += overlapDurationMS;</span>
<span class="nc" id="L1913">							Activity eventActivity = getEventActivity(curEvent, activities);</span>
<span class="nc bnc" id="L1914" title="All 2 branches missed.">							if (eventActivity != null)</span>
							{
<span class="nc" id="L1916">								Collection&lt;ID&gt; mediaIDs = activityMedias.get(eventActivity.getID());</span>
<span class="nc" id="L1917">								Collection&lt;ID&gt; qIDs = activityQueues.get(eventActivity.getID());</span>
<span class="nc" id="L1918">								overUnderType = nsCube.getOverUnder(startIntervalDate, eventActivity, mediaIDs, qIDs);</span>
							}
						}

<span class="nc" id="L1922">						incrementDuration(overUnderToDurationMap, overUnderType, overlapDurationMS);</span>
					}

<span class="nc bnc" id="L1925" title="All 2 branches missed.">					if (endIntervalDate.before(eventRange.getStartDate()))</span>
<span class="nc" id="L1926">						break; //we've already passed the cell</span>
				}
<span class="nc" id="L1928">			}</span>

<span class="nc" id="L1930">			boolean isWorkingForMostOfInterval = false;</span>
<span class="nc bnc" id="L1931" title="All 2 branches missed.">			if (totalTimeoffDurationMS &gt; 450000) //if cube interval overlaps timeoff event by more than 7.5 minutes (450000 ms)</span>
			{
				//cellIsNotRequestable = true; //we don't care about this anymore. We will let the user make a request and let the validation rules handle it.
<span class="nc" id="L1934">				value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //cell will be requestable for custom shifts, but not advertised as such.</span>
			}
			else
			{
<span class="nc bnc" id="L1938" title="All 2 branches missed.">				isWorkingForMostOfInterval = totalWorkDurationMS &gt; 450000; //if scheduled time overlaps interval by more than 7.5 minutes (450000 ms)</span>

<span class="nc" id="L1940">				long totalOffDurationMS = Trace.INTERVAL_IN_MILLIS - totalTimeoffDurationMS - totalWorkDurationMS;</span>
<span class="nc bnc" id="L1941" title="All 2 branches missed.">				if (totalOffDurationMS &gt; 0)</span>
				{
<span class="nc" id="L1943">					int overUnderType = nsCube.getOverUnder(startIntervalDate, null, null, null); //get the overUnder value for the interval as if the agent is not scheduled at all</span>
<span class="nc" id="L1944">					incrementDuration(overUnderToDurationMap, overUnderType, totalOffDurationMS);</span>
				}

<span class="nc" id="L1947">				int maxOverUnderType = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
<span class="nc" id="L1948">				long maxDuration = 0;</span>
<span class="nc bnc" id="L1949" title="All 2 branches missed.">				for (int curOverUnderType : overUnderToDurationMap.keySet())</span>
				{
<span class="nc" id="L1951">					long curDuration = overUnderToDurationMap.get(curOverUnderType);</span>
<span class="nc bnc" id="L1952" title="All 2 branches missed.">					if (curDuration &gt; maxDuration)</span>
					{
<span class="nc" id="L1954">						maxDuration = curDuration;</span>
<span class="nc" id="L1955">						maxOverUnderType = curOverUnderType;</span>
					}
<span class="nc" id="L1957">				}</span>
<span class="nc" id="L1958">				value[0] = maxOverUnderType;</span>

<span class="nc bnc" id="L1960" title="All 4 branches missed.">				if ((value[0] == Trace.NETSTAFF_UNDER) &amp;&amp; isWorkingForMostOfInterval)</span>
<span class="nc" id="L1961">					value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
			}

			//System.out.print(value[0] + &quot;, &quot;);
<span class="nc bnc" id="L1965" title="All 2 branches missed.">			if (value[0] == Trace.NETSTAFF_NA)</span>
<span class="nc" id="L1966">				return value; //null means invalid point</span>


<span class="nc bnc" id="L1969" title="All 2 branches missed.">			if (!cellIsNotRequestable)</span>
			{
<span class="nc bnc" id="L1971" title="All 4 branches missed.">				if ((value[0] == Trace.NETSTAFF_OVER) &amp;&amp; !isWorkingForMostOfInterval)</span>
				{
<span class="nc" id="L1973">					value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //User is not scheduled during this interval. Requesting a time off event for this interval would not improve net staffing.</span>
				}

				//Determine the request type for the cell
<span class="nc bnc" id="L1977" title="All 2 branches missed.">				if (isWorkingForMostOfInterval)</span>
				{
<span class="nc bnc" id="L1979" title="All 2 branches missed.">					if (vtoReqEnabled)</span>
<span class="nc" id="L1980">						value[1] = Trace.NETSTAFF_OVER;</span>
					else
<span class="nc" id="L1982">						cellIsNotRequestable = true;</span>
				}
				else
				{
<span class="nc bnc" id="L1986" title="All 2 branches missed.">					if (csReqEnabled)</span>
<span class="nc" id="L1987">						value[1] = Trace.NETSTAFF_UNDER;</span>
					else
<span class="nc" id="L1989">						cellIsNotRequestable = true;</span>
				}
			}
<span class="nc" id="L1992">		}</span>
		else
		{
<span class="nc" id="L1995">			cellIsNotRequestable = true;</span>
		}

<span class="nc bnc" id="L1998" title="All 2 branches missed.">		if (cellIsNotRequestable)</span>
		{
<span class="nc" id="L2000">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //any invalid intervals should be neutral in color</span>
<span class="nc" id="L2001">			value[1] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //any invalid intervals should not be requestable</span>
		}

<span class="nc bnc" id="L2004" title="All 2 branches missed.">		if (!isPublished)</span>
		{
<span class="nc" id="L2006">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER; //Unpublished schedules should show grey for net staffing (QC91459)</span>
		}

		//We only show a deficiency for time intervals that fall within the HOO.
<span class="nc bnc" id="L2010" title="All 4 branches missed.">		if (value[0] == Trace.NETSTAFF_UNDER &amp;&amp; !isOpenPeriodForNetStaffingEmp(startIntervalDate, wrAssignmentsForNetStaffingEmp,</span>
				orgOpenPeriodsForNetStaffingEmp)) {
<span class="nc" id="L2012">			value[0] = Trace.NETSTAFF_NOT_OVER_OR_UNDER;</span>
		}

<span class="nc" id="L2015">		return value;</span>
	}

	private static void incrementDuration(HashMap&lt;Integer, Long&gt; overUnderToDurationMap, int overUnderType, long incrementAmountMS)
	{
<span class="nc" id="L2020">		Long prevDurationMS = (Long)overUnderToDurationMap.get(overUnderType);</span>
<span class="nc bnc" id="L2021" title="All 2 branches missed.">		if (prevDurationMS == null)</span>
<span class="nc" id="L2022">			overUnderToDurationMap.put(overUnderType, incrementAmountMS);</span>
		else
<span class="nc" id="L2024">			overUnderToDurationMap.put(overUnderType, prevDurationMS+incrementAmountMS);</span>
<span class="nc" id="L2025">	}</span>

	/**
	 * Append the JavaScript to the stringBuffer for adding a single net staffing event to a row.
	 * @param realVal - The real Net Staffing value for the event.
	 * @param simpleVal - The simple Net Staffing value for the event. Basically, any cell not under a shift
	 *        will have -1. Any cell under a shift will have +1. It will only be 0 if in the past or the required request type is diabled (invalid request)
	 * @param eventStartCubeIndex - The start index of the event in the net staffing TraceCube
	 * @param sbJS - The StringBuffer to append the event javaScript to.
	 */
	protected void graphNetStaffingEvent(int realVal, int simpleVal, Calendar eventStartCal, Calendar eventEndCal, int eventStartCubeIndex,
			StringBuffer sbJS, TimeRange aDay, int firstShownIndex, int lastShownIndex, int gridWidth, int rowIndex, boolean isStartCalDST,
			ScheduleViewPM.dstTransitionMode mode, int dstTransitionHour)
	{
<span class="nc" id="L2039">		int eventStartIndex = -1;</span>
<span class="nc" id="L2040">		int eventEndIndex = -1;</span>
<span class="nc" id="L2041">		int newEventStartIndex = -1;</span>
<span class="nc" id="L2042">		int newEventEndIndex = -1;</span>
<span class="nc" id="L2043">		String eventColor = &quot;&quot;;</span>
<span class="nc" id="L2044">		String eventPattern = &quot;null&quot;;</span>

<span class="nc" id="L2046">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc" id="L2047">		boolean isDayStartDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L2048">		boolean isDayEndDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L2049" title="All 2 branches missed.">		boolean dayIsDSTDay = isDayStartDST != isDayEndDST;</span>
<span class="nc bnc" id="L2050" title="All 2 branches missed.">		boolean isPeriodIncDST = tz.inDaylightTime(m_timeRange.getStartDate()) != tz.inDaylightTime(m_timeRange.getEndDate());</span>
<span class="nc" id="L2051">		int dstTransitionIndex = dstTransitionHour*60;</span>

<span class="nc" id="L2053">		eventStartIndex = makeMinuteIndex(aDay, eventStartCal, firstShownIndex, lastShownIndex,mode, isDayStartDST, dstTransitionHour); //isStartCalDST</span>
<span class="nc" id="L2054">		eventEndIndex = makeMinuteIndex(aDay, eventEndCal, firstShownIndex, lastShownIndex,mode, isDayStartDST, dstTransitionHour); //isStartCalDST</span>

<span class="nc bnc" id="L2056" title="All 2 branches missed.">		if (eventEndIndex &gt; gridWidth)</span>
<span class="nc" id="L2057">			eventEndIndex = gridWidth;</span>

<span class="nc bnc" id="L2059" title="All 4 branches missed.">		if (eventStartIndex &lt; gridWidth+1 &amp;&amp; eventEndIndex != PREV_DAY_INDEX) {</span>
<span class="nc" id="L2060">			boolean eventStartIsDST = tz.inDaylightTime(eventStartCal.getTime());</span>
<span class="nc" id="L2061">			boolean eventEndIsDST = tz.inDaylightTime(eventEndCal.getTime());</span>
<span class="nc" id="L2062">			int dstSavings = tz.getDSTSavings()/(60*1000);</span>

<span class="nc bnc" id="L2064" title="All 4 branches missed.">			switch(mode) {</span>
			case FALLBACK:
				//The Personal Graph view can show multiple days at once, but if one of those days is the
				//Fall DST transition, then all of the days will show two 1AM's. Only the transition day
				//will actually have data in the 2nd 1AM. For the other days, we need to break up any
				//events that start before the 2nd 1AM and end after the 2nd 1AM, so that nothing is
				//graphed during the 2nd 1AM hour.
<span class="nc bnc" id="L2071" title="All 10 branches missed.">				if (!dayIsDSTDay &amp;&amp; isPeriodIncDST &amp;&amp; getViewType().equals(VIEW_TYPE_MY_GRAPH) &amp;&amp;</span>
					(eventStartIndex &lt; dstTransitionHour*60) &amp;&amp; (eventEndIndex &gt;= dstTransitionHour*60)) {
<span class="nc" id="L2073">						newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L2074">						eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L2075">						newEventStartIndex = eventEndIndex + dstSavings;</span>
				}

				break;
			case SPRINGFORWARD:
<span class="nc bnc" id="L2080" title="All 6 branches missed.">				if (dayIsDSTDay &amp;&amp; eventEndIsDST &amp;&amp; !eventStartIsDST) {</span>
					//The Personal and Group Graph views will always include 2AM, even if the only day in the view
					//is the Spring DST transition, which is supposed to skip 2AM. The DST transition day
					//will have no data in the 2AM hour, so we need to break up any events that start before
					//2AM and end after the on or after 3AM, so that nothing is graphed during the 2AM hour.
<span class="nc" id="L2085">					newEventEndIndex = eventEndIndex;</span>
<span class="nc" id="L2086">					eventEndIndex = dstTransitionHour*60;</span>
<span class="nc" id="L2087">					newEventStartIndex = eventEndIndex + dstSavings;</span>
				}
			case NEUTRAL:
<span class="nc" id="L2090">				break;</span>
			default:
				break;
			}

			//event overlaps with the shown hrs
<span class="nc" id="L2096">			eventColor = getNetStaffingEventColor(realVal);</span>
<span class="nc" id="L2097">            String eventTooltip = getNetStaffingEventTooltip(realVal, simpleVal);</span>

            //The cell ID which countains row and column numbers (used for Net Staffing cells only). Ex: &quot;NS_3_7&quot; = row 3 col 7
<span class="nc" id="L2100">            String nsID = &quot;NS_&quot; + rowIndex + &quot;_&quot; + eventStartCubeIndex; //(simpleVal==0) ? &quot;&quot; :</span>

			// create JS ScheduleEvent object and add it to calendarGrid.rows[rowIndex]
<span class="nc" id="L2103">			sbJS.append(&quot;\n calendarGrid.rows[&quot;)</span>
<span class="nc" id="L2104">					.append(rowIndex).append(&quot;].addEvent(&quot;)</span>
<span class="nc" id="L2105">					.append(eventStartIndex).append(&quot;,&quot;)</span>
<span class="nc" id="L2106">					.append(eventEndIndex).append(&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2107">					.append(eventColor).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2108">					.append(eventPattern).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2109">					.append(eventTooltip).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2110">					.append(rowIndex).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2111">					.append(eventStartCal.getTime().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2112">					.append(eventEndCal.getTime().getTime()).append(&quot;\&quot;,\&quot;&quot;)</span>
<span class="nc" id="L2113">					.append(simpleVal).append(&quot;\&quot;,\&quot;&quot;) //tells us the cell type: &quot;SE&quot;=Schedule Event, &lt;0=NS Shortage, 0=NS Neutral, &gt;0=NS Surplus</span>
<span class="nc" id="L2114">			        .append(nsID).append(&quot;\&quot;)&quot;);</span>
		}

<span class="nc" id="L2117">	}</span>

	protected String getNetStaffingEventColor(int curVal)
	{
<span class="nc bnc" id="L2121" title="All 2 branches missed.">		if (curVal == Trace.NETSTAFF_UNDER)</span>
		{
<span class="nc" id="L2123">			m_hasNetStaffingShortageData = true;</span>
<span class="nc" id="L2124">			return m_netStaffingShortageColor;</span>
		}
<span class="nc bnc" id="L2126" title="All 2 branches missed.">		else if (curVal == Trace.NETSTAFF_OVER)</span>
		{
<span class="nc" id="L2128">			m_hasNetStaffingSurplusData = true;</span>
<span class="nc" id="L2129">			return m_netStaffingSurplusColor;</span>
		}
		else //if (curVal == Trace.NETSTAFF_NOT_OVER_OR_UNDER)
		{
<span class="nc" id="L2133">			m_hasNetStaffingNeutralData = true;</span>
<span class="nc" id="L2134">			return m_netStaffingNeutralColor;</span>
		}
	}

	/**
	 * @param realVal - The real Net Staffing value for the event.
	 * @param simpleVal - The simple Net Staffing value for the event. Basically, any cell not under a shift
	 *        will have -1. Any cell under a shift will have +1. It will only be 0 if in the past (invalid request)
	 */
	protected String getNetStaffingEventTooltip(int realVal, int simpleVal)
	{
<span class="nc bnc" id="L2145" title="All 2 branches missed.">		if (realVal &lt; 0)</span>
		{
<span class="nc bnc" id="L2147" title="All 2 branches missed.">			if (m_isCSEnabled)</span>
<span class="nc" id="L2148">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE_TOOLTIP);</span>
<span class="nc bnc" id="L2149" title="All 2 branches missed.">			else if (m_isTOEnabled)</span>
<span class="nc" id="L2150">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE_CS_DISABLED_TOOLTIP);</span>
			else
<span class="nc" id="L2152">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SHORTAGE);</span>
		}
<span class="nc bnc" id="L2154" title="All 2 branches missed.">		else if (realVal &gt; 0)</span>
		{
<span class="nc bnc" id="L2156" title="All 2 branches missed.">			if (m_isTOEnabled)</span>
<span class="nc" id="L2157">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS_TOOLTIP);</span>
<span class="nc bnc" id="L2158" title="All 2 branches missed.">			else if (m_isCSEnabled)</span>
<span class="nc" id="L2159">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS_TO_DISABLED_TOOLTIP);</span>
			else
<span class="nc" id="L2161">				return i18n(m_bundle, FsWebBundleKey.STAFFING_SURPLUS);</span>
		}
		else
		{
<span class="nc bnc" id="L2165" title="All 2 branches missed.">			if (simpleVal &lt; 0)</span>
			{
<span class="nc bnc" id="L2167" title="All 2 branches missed.">				if (m_isCSEnabled)</span>
<span class="nc" id="L2168">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_CSR_TOOLTIP);</span>
<span class="nc bnc" id="L2169" title="All 2 branches missed.">				else if (m_isTOEnabled)</span>
<span class="nc" id="L2170">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_TOR_TOOLTIP);</span>
				else
<span class="nc" id="L2172">					return &quot;&quot;;</span>
			}
<span class="nc bnc" id="L2174" title="All 2 branches missed.">			else if (simpleVal &gt; 0)</span>
			{
<span class="nc bnc" id="L2176" title="All 2 branches missed.">				if (m_isTOEnabled)</span>
<span class="nc" id="L2177">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_TOR_TOOLTIP);</span>
<span class="nc bnc" id="L2178" title="All 2 branches missed.">				else if (m_isCSEnabled)</span>
<span class="nc" id="L2179">					return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_CSR_TOOLTIP);</span>
				else
<span class="nc" id="L2181">					return &quot;&quot;;</span>
			}
			else
			{
<span class="nc" id="L2185">				return i18n(m_bundle, FsWebBundleKey.STAFFING_NEUTRAL_FOR_PAST_TOOLTIP);</span>
			}
		}
	}

	/**
	 * Snap the current time to the next 15 minute interval if it is not exactly on one.
	 * @return
	 */
	public Date getNowSnappedTo15MinuteInterval() {
<span class="nc" id="L2195">		return getNowSnappedTo15MinuteInterval(m_context.getViewingTimeZone());</span>
	}

	/**
	 * Snap the current time to the next 15 minute interval if it is not exactly on one.
	 * @return
	 */
	public static Date getNowSnappedTo15MinuteInterval(TimeZone viewingTimeZone) {
<span class="nc" id="L2203">		Calendar cal = Calendar.getInstance(viewingTimeZone);</span>
<span class="nc" id="L2204">		cal.set(Calendar.SECOND, 0);</span>
<span class="nc" id="L2205">		cal.set(Calendar.MILLISECOND, 0);</span>
<span class="nc" id="L2206">		int mins = cal.get(Calendar.MINUTE);</span>

<span class="nc bnc" id="L2208" title="All 4 branches missed.">		if (mins &gt; 0 &amp;&amp; mins &lt;= 15)</span>
<span class="nc" id="L2209">			cal.set(Calendar.MINUTE, 15);</span>
<span class="nc bnc" id="L2210" title="All 4 branches missed.">		else if (mins &gt; 15 &amp;&amp; mins &lt;= 30)</span>
<span class="nc" id="L2211">			cal.set(Calendar.MINUTE, 30);</span>
<span class="nc bnc" id="L2212" title="All 4 branches missed.">		else if (mins &gt; 30 &amp;&amp; mins &lt;= 45)</span>
<span class="nc" id="L2213">			cal.set(Calendar.MINUTE, 45);</span>
<span class="nc bnc" id="L2214" title="All 2 branches missed.">		else if (mins &gt; 45)</span>
		{
<span class="nc" id="L2216">			cal.set(Calendar.MINUTE, 0);</span>
<span class="nc" id="L2217">			cal.add(Calendar.HOUR, 1);</span>
		}

<span class="nc" id="L2220">		return cal.getTime();</span>
	}

	/**
	 * This method initializes the org HOO data necessary for graphing the Net Staffing Ribbon for a single employee.
	 * @param context - The request context
	 * @param empID - the employee ID for the employee whose Net Staffing Ribbon will be shown.
	 * @param start - the start of the day for the Net Staffing Ribbon.
	 * @param end - the end of the day for the Net Staffing Ribbon.
	 * @throws RemoteException
	 * @throws BbmException
	 */
	protected void loadOrgsAndOpenPeriodsForNetStaffingEmp(RequestContext context, ID empID, Date start, Date end)
			throws RemoteException, BbmException {

<span class="nc" id="L2235">		Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt; pair =</span>
<span class="nc" id="L2236">				getOrgsAndOpenPeriodsForNetStaffingEmp(context, empID, start, end);</span>
<span class="nc" id="L2237">		m_wrAssignmentsForNetStaffingEmp = pair.getFirst();</span>
<span class="nc" id="L2238">		m_orgOpenPeriodsForNetStaffingEmp = pair.getSecond();</span>
<span class="nc" id="L2239">	}</span>

	/**
	 * This method initializes the org HOO data necessary for graphing the Net Staffing Ribbon for a single employee.
	 * @param context - The request context
	 * @param empID - the employee ID for the employee whose Net Staffing Ribbon will be shown.
	 * @param start - the start of the day for the Net Staffing Ribbon.
	 * @param end - the end of the day for the Net Staffing Ribbon.
	 * @throws RemoteException
	 * @throws BbmException
	 */
	public static Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt; getOrgsAndOpenPeriodsForNetStaffingEmp(
			RequestContext context, ID empID, Date start, Date end) throws RemoteException, BbmException {
<span class="nc" id="L2252">		WorkResourceManager workResourceManager = WorkResourceModelHandler.getWorkResourceManager(context);</span>
<span class="nc" id="L2253">		Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp = null;</span>
		//first, load the org assignments for the employee
<span class="nc" id="L2255">		Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp = workResourceManager.getWorkResourceAssignments(empID, start,</span>
				end, false);

		//now load the open periods for each org
<span class="nc bnc" id="L2259" title="All 4 branches missed.">		if (wrAssignmentsForNetStaffingEmp != null &amp;&amp; !wrAssignmentsForNetStaffingEmp.isEmpty()) {</span>
<span class="nc" id="L2260">			List&lt;ID&gt; orgIDs = new ArrayList&lt;&gt;(wrAssignmentsForNetStaffingEmp.size());</span>
<span class="nc bnc" id="L2261" title="All 2 branches missed.">			for (WorkResourceAssignment wra : wrAssignmentsForNetStaffingEmp) {</span>
<span class="nc" id="L2262">				ID orgID = wra.getOrganizationID();</span>
<span class="nc" id="L2263">				orgIDs.add(orgID);</span>
<span class="nc" id="L2264">			}</span>

<span class="nc" id="L2266">			HashMap&lt;ID, OrganizationHOOPeriod&gt; orgIdToHoopMap = workResourceManager.getHOOPeriod(orgIDs, start, end);</span>

<span class="nc bnc" id="L2268" title="All 4 branches missed.">			if (orgIdToHoopMap != null &amp;&amp; !orgIdToHoopMap.isEmpty()) {</span>
<span class="nc" id="L2269">				orgOpenPeriodsForNetStaffingEmp = new HashMap&lt;ID, Collection&lt;TimePeriod&gt;&gt;(orgIdToHoopMap.size());</span>
<span class="nc bnc" id="L2270" title="All 2 branches missed.">				for (ID orgID : orgIdToHoopMap.keySet()) {</span>
<span class="nc" id="L2271">					OrganizationHOOPeriod ohoop = orgIdToHoopMap.get(orgID);</span>
<span class="nc" id="L2272">					Collection&lt;TimePeriod&gt; openPeriods = ohoop.getOpenPeriods(start, end);</span>
<span class="nc" id="L2273">					orgOpenPeriodsForNetStaffingEmp.put(orgID, openPeriods);</span>
<span class="nc" id="L2274">				}</span>
			}
		}
<span class="nc" id="L2277">		return new Pair&lt;Collection&lt;WorkResourceAssignment&gt;, Map&lt;ID, Collection&lt;TimePeriod&gt;&gt;&gt;(wrAssignmentsForNetStaffingEmp,</span>
				orgOpenPeriodsForNetStaffingEmp);
	}

	/**
	 * Assuming loadOrgsAndOpenPeriodsForNetStaffingEmp() has been run, this method will tell
	 * you whether or not a particular datetime falls inside of the employee's Hours Of Operation.
	 * This method is intended to be used by Net Staffing Ribbon code in order to determine whether
	 * a net staffing deficiency should show up as such in the ribbon (when the datetime falls in
	 * the HOO), or should be shown as a neutral cell instead (when it's a non-HOO time). Since the
	 * Net Staffing ribbon is only shown for one agent, no need to provide the empID to this method;
	 * the m_wrAssignmentsForNetStaffingEmp and m_orgOpenPeriodsForNetStaffingEmp member variables will
	 * have already been populated with the data for that employee.
	 * employee.
	 * @return - true if the date parameter is within the HOO for the net staffing employee's org at that time.
	 */
	protected static boolean isOpenPeriodForNetStaffingEmp(Date date, Collection&lt;WorkResourceAssignment&gt; wrAssignmentsForNetStaffingEmp,
			Map&lt;ID, Collection&lt;TimePeriod&gt;&gt; orgOpenPeriodsForNetStaffingEmp) {
<span class="nc bnc" id="L2295" title="All 4 branches missed.">		if (wrAssignmentsForNetStaffingEmp != null &amp;&amp; orgOpenPeriodsForNetStaffingEmp != null) {</span>

			//first, find the user's orgID at that time
<span class="nc" id="L2298">			ID orgID = null;</span>
<span class="nc bnc" id="L2299" title="All 2 branches missed.">			for (WorkResourceAssignment wra : wrAssignmentsForNetStaffingEmp) {</span>
<span class="nc bnc" id="L2300" title="All 6 branches missed.">				if (!date.before(wra.getStartTime()) &amp;&amp; (wra.getEndTime()==null) || date.before(wra.getEndTime())) {</span>
<span class="nc" id="L2301">					orgID = wra.getOrganizationID();</span>
<span class="nc" id="L2302">					break;</span>
				}
<span class="nc" id="L2304">			}</span>

			//now see if that org is open during that time
<span class="nc bnc" id="L2307" title="All 2 branches missed.">			if (orgID != null) {</span>
<span class="nc" id="L2308">				Collection&lt;TimePeriod&gt; openPeriods = orgOpenPeriodsForNetStaffingEmp.get(orgID);</span>
<span class="nc bnc" id="L2309" title="All 2 branches missed.">				if (openPeriods != null) {</span>
<span class="nc bnc" id="L2310" title="All 2 branches missed.">					for (TimePeriod tp : openPeriods) {</span>
<span class="nc bnc" id="L2311" title="All 4 branches missed.">						if (!date.before(tp.getStartTime()) &amp;&amp; date.before(tp.getEndTime())) {</span>
<span class="nc" id="L2312">							return true;</span>
						}
<span class="nc" id="L2314">					}</span>
				}
			}
		}
<span class="nc" id="L2318">		return false;</span>
	}

	/**
	 * make a row for the multicolumn list display of the net staffing events in Graph view.
	 * @param empDaySummaries - the collection of DailyScheduleSummary's for the employee
	 * @param aDay - The full day being graphed (midnight to midnight)
	 * @param graphStart - The beginning of the graph on aDay
	 * @param graphEnd - The end of the graph on aDay
	 */
	public DefaultMultiColumnNodeData makeRightNetStaffingRowForGraph(RequestContext context, StringBuffer sbJS,
			TimeRange aDay, Date graphStart, Date graphEnd, int[] shownHours, Collection schedule, NetStaffingCube nsCube, int rowIndex, boolean isMy,
			Collection empDaySummaries, boolean isPublished, dstTransitionMode mode, int dstTransitionHour, HashMap activities,
			Map&lt;ID, Collection&lt;ID&gt;&gt; activityMedias, Map&lt;ID, Collection&lt;ID&gt;&gt; activityQueues)
	{
<span class="nc" id="L2333">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>
<span class="nc" id="L2334">		TimeZone tz = context.getViewingTimeZone();</span>

		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L2337">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L2338">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L2339">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>

		//--- make the row with one empty cell ---
<span class="nc" id="L2342">		rowData.add(&quot;&amp;nbsp;&quot;);</span>
<span class="nc" id="L2343">		rowData.setNodeAttribute(&quot;style&quot;, &quot;font-size:0px&quot;);</span>

		//--- generate JS object with the data for the row ---
<span class="nc" id="L2346">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L2347">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,&quot;).append(m_isNetStaffingHalfHeight).append(&quot;));&quot;);</span>

<span class="nc bnc" id="L2349" title="All 2 branches missed.">		if (nsCube!=null)</span>
		{
<span class="nc" id="L2351">			Calendar eventStartCal = Calendar.getInstance(tz);</span>
<span class="nc" id="L2352">			eventStartCal.setTime(graphStart);</span>

<span class="nc" id="L2354">			boolean isStartCalDST = tz.inDaylightTime(graphStart);</span>

<span class="nc" id="L2356">			Calendar eventEndCal = Calendar.getInstance(tz);</span>
<span class="nc" id="L2357">			eventEndCal.setTime(eventStartCal.getTime());</span>
<span class="nc" id="L2358">			eventEndCal.add(Calendar.MINUTE, 15);</span>

<span class="nc" id="L2360">			int cubeIndex = 0;</span>
<span class="nc" id="L2361">			Date now = new Date();</span>
<span class="nc bnc" id="L2362" title="All 2 branches missed.">			while (eventStartCal.getTime().before(graphEnd))</span>
			{
<span class="nc bnc" id="L2364" title="All 2 branches missed.">				if (eventStartCal.getTime().after(now))</span>
				{
<span class="nc" id="L2366">					int[] curVal = getPersonalizedNetStaffingValue(nsCube, eventStartCal, eventEndCal, schedule, m_csReqEnabled,</span>
							m_vtoReqEnabled, isPublished, activities, activityMedias, activityQueues,
							m_wrAssignmentsForNetStaffingEmp, m_orgOpenPeriodsForNetStaffingEmp);

<span class="nc bnc" id="L2370" title="All 2 branches missed.">					if ((curVal[0] != Trace.NETSTAFF_NA))</span>
					{
<span class="nc" id="L2372">						graphNetStaffingEvent(curVal[0], curVal[1], eventStartCal, eventEndCal, cubeIndex++, sbJS, aDay,</span>
							firstShownIndex, lastShownIndex, gridWidth, rowIndex, isStartCalDST, mode, dstTransitionHour);
					}
				}
<span class="nc" id="L2376">				eventStartCal.add(Calendar.MINUTE, 15);</span>
<span class="nc" id="L2377">				eventEndCal.add(Calendar.MINUTE, 15);</span>
			}

<span class="nc bnc" id="L2380" title="All 4 branches missed.">			if (m_isCSEnabled || m_isTOEnabled)</span>
<span class="nc" id="L2381">				rowData.setNodeAttribute(&quot;style&quot;, &quot;cursor: pointer; cursor: hand; font-size:0px&quot;);</span>
		}

<span class="nc" id="L2384">		rowData.setSelectable(false);</span>
<span class="nc" id="L2385">		return rowData;</span>
	}

	/**
	 * make a spacer row for the multicolumn list display of the net staffing events in Graph view.
	 */
	public DefaultMultiColumnNodeData makeRightSpacerRowForGraph(StringBuffer sbJS, int[] shownHours,  int rowIndex)
	{
<span class="nc" id="L2393">		DefaultMultiColumnNodeData rowData = new DefaultMultiColumnNodeData();</span>

		//--- calculate offset indexes for shown hours (index is the number of minutes before)
<span class="nc" id="L2396">		int firstShownIndex = shownHours[0] * 60;</span>
<span class="nc" id="L2397">		int lastShownIndex = (shownHours[1] + 1) * 60 - 1;</span>
<span class="nc" id="L2398">		int gridWidth = lastShownIndex - firstShownIndex + 1;</span>

		//--- make the row with one empty cell ---
<span class="nc" id="L2401">		rowData.add(&quot;&amp;nbsp;&quot;);</span>

		//--- generate JS object with the data for the row ---
<span class="nc" id="L2404">		sbJS.append(&quot;\n calendarGrid.addRow(new GridRow(&quot;)</span>
<span class="nc" id="L2405">				.append(rowIndex).append(&quot;,&quot;).append(gridWidth).append(&quot;,false));&quot;);</span>


<span class="nc" id="L2408">		rowData.setSelectable(false);</span>
<span class="nc" id="L2409">		return rowData;</span>
	}//makeRightSpacerRowForGraph

	/**
	 * find if there is published schedule for the given day for the given person
	 */
	public static boolean dayIsPublished(CalendarRange aDay, Collection personalTimeRanges) {
<span class="nc" id="L2416">		boolean result = false;</span>
<span class="nc bnc" id="L2417" title="All 4 branches missed.">		if (aDay != null &amp;&amp; personalTimeRanges != null) {</span>
<span class="nc bnc" id="L2418" title="All 2 branches missed.">			for (Iterator i = personalTimeRanges.iterator(); i.hasNext();) {</span>
<span class="nc" id="L2419">				TimeRange tp = (TimeRange) i.next();</span>
<span class="nc bnc" id="L2420" title="All 4 branches missed.">				if (tp != null &amp;&amp; tp.getOverlapDuration(aDay) &gt; 0) {</span>
<span class="nc" id="L2421">					result = true;</span>
<span class="nc" id="L2422">					break;</span>
				}
<span class="nc" id="L2424">			}</span>
		}
<span class="nc" id="L2426">		return result;</span>
	}//dayIsPublished

	/**
	 * calculate the index in minutes of the Calendar value from the shown index in the given day
	 * @param theDay - the given day
	 * @param theCal - the time value
	 * @param firstShownIndex - limitation by the grid boundaries
	 * @param lastShownIndex - limitation by the grid boundaries
	 * @return int index - offset in minutes of theCal from the firstShownIndex
	 *         or -1 if theCal is before the shown hours and 1441 if after shown hours
	 */
	public static int makeMinuteIndex(TimeRange theDay, Calendar theCal, int firstShownIndex, int lastShownIndex,  ScheduleViewPM.dstTransitionMode mode, boolean dayStartIsDST, int dstTransitionHour){

<span class="nc" id="L2440">		int relLocOfTheCal = theDay.getRelativeLocation(theCal);</span>
<span class="nc bnc" id="L2441" title="All 2 branches missed.">		if (relLocOfTheCal == TimeRange.TIME_BEFORE) {</span>
<span class="nc" id="L2442">			return PREV_DAY_INDEX;</span>
<span class="nc bnc" id="L2443" title="All 2 branches missed.">		} else if (relLocOfTheCal == TimeRange.TIME_AFTER) {</span>
<span class="nc" id="L2444">			boolean curDateIsDST = theCal.getTimeZone().inDaylightTime(theCal.getTime());</span>
<span class="nc bnc" id="L2445" title="All 2 branches missed.">			if (mode.equals(ScheduleViewPM.dstTransitionMode.FALLBACK) ) { // add an hour</span>
<span class="nc" id="L2446">				return NEXT_DAY_INDEX + 60;</span>
			} else {
<span class="nc" id="L2448">				return NEXT_DAY_INDEX;</span>
			}
		} else {
<span class="nc" id="L2451">			int hourOfDay = theCal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L2452">			boolean curDateIsDST = theCal.getTimeZone().inDaylightTime(theCal.getTime());</span>
<span class="nc bnc" id="L2453" title="All 2 branches missed.">			if (mode.equals(ScheduleViewPM.dstTransitionMode.FALLBACK)) {</span>
					//Add an hour if cur date is &gt;= the 2nd 1AM. We check the fall transition day,
					//as well as the fall non-transition days, since they also show two 1AM's
<span class="nc bnc" id="L2456" title="All 8 branches missed.">					if ((dayStartIsDST &amp;&amp; !curDateIsDST) || (dstTransitionHour&gt;=0 &amp;&amp; hourOfDay&gt;=dstTransitionHour))</span>
<span class="nc" id="L2457">						hourOfDay++;</span>
			}

<span class="nc" id="L2460">			int minutesFromDayStart = hourOfDay*60 + theCal.get(Calendar.MINUTE); //DST bug: Can't use HOUR_OF_DAY because there could be two 1AM's.</span>
			//int minutesFromDayStart = (int) ((theCal.getTime().getTime() - theDay.getStartDate().getTime()) / 1000 / 60);

<span class="nc bnc" id="L2463" title="All 2 branches missed.">			if (minutesFromDayStart &lt; firstShownIndex) {</span>
<span class="nc" id="L2464">				return PREV_DAY_INDEX;</span>
<span class="nc bnc" id="L2465" title="All 2 branches missed.">			} else if (minutesFromDayStart &gt; lastShownIndex) {</span>
<span class="nc" id="L2466">				return NEXT_DAY_INDEX;</span>
			} else {
<span class="nc" id="L2468">				int mins = minutesFromDayStart - firstShownIndex;</span>
<span class="nc bnc" id="L2469" title="All 2 branches missed.">				if (mins &gt; lastShownIndex) // weird bug where last end index is 1 minute over</span>
<span class="nc" id="L2470">					mins = lastShownIndex;</span>
<span class="nc" id="L2471">				return mins;</span>
			}
		}
	}

	/**
	 * get Event Activity
	 * @param event - scheduleEvent
	 * @param activities
	 * @return the event's Activity
	 */
	public static Activity getEventActivity(Event event, HashMap activities) {
<span class="nc" id="L2483">		Activity activity = null;</span>
<span class="nc bnc" id="L2484" title="All 4 branches missed.">		if (event != null &amp;&amp; activities != null) {</span>
<span class="nc" id="L2485">			activity = (Activity)activities.get(event.getActivityID());</span>
			//if(activity!=null)
			//	color = activity.getColor();
		}
<span class="nc" id="L2489">		return  activity;</span>
	}//getEventActivityColor

    /**
	 * Get the tooltip for an event, such as &quot;Campaign: My Campaign&quot;
	 * @param eventRange - The time range for the event.
	 * @param empDaySummaries - The DailyScheduleSummary collection for the employee.
	 * @return the tooltip for the event, such as &quot;Campaign: My Campaign&quot;
	 */
	public String getEventTooltip(TimeRange dayRange, SimpleEvent event, Activity eventActivity, String eventPattern,
			TimeRange eventRange, Collection&lt;DailyScheduleSummary&gt; empDaySummaries, Map&lt;ID, String&gt; campaignNamesBySpID, TimeZone tz)
	{
<span class="nc" id="L2501">		String lineBreak = &quot; &amp;#13;&quot;; //NOTE: This may only work in Internet Explorer for Windows. Not sure.</span>

<span class="nc" id="L2503">	    StringBuilder tooltip = new StringBuilder();</span>
<span class="nc bnc" id="L2504" title="All 2 branches missed.">	    if (eventActivity != null) {</span>
<span class="nc" id="L2505">	    	tooltip.append(eventActivity.getName());</span>

<span class="nc" id="L2507">	    	CalendarRange calRange = DateTimeUtil.makeDayRange(dayRange.getStartDate(), tz);</span>
<span class="nc" id="L2508">	    	tooltip.append(lineBreak).append(ShiftUtil.makeEventPeriodString(calRange, event, false, m_localizer, tz));</span>

<span class="nc bnc" id="L2510" title="All 2 branches missed.">	    	if (!eventPattern.equals(&quot;null&quot;))</span>
		    {
<span class="nc" id="L2512">		    	tooltip.append(lineBreak).append(i18n(m_bundle, FsWebBundleKey.SP_OVERTIME));</span>
		    }
	    }

<span class="nc bnc" id="L2516" title="All 4 branches missed.">	    if (eventRange != null &amp;&amp; empDaySummaries != null)</span>
	    {
<span class="nc bnc" id="L2518" title="All 2 branches missed.">	        for (Iterator&lt;DailyScheduleSummary&gt; it=empDaySummaries.iterator(); it.hasNext();)</span>
	        {
<span class="nc" id="L2520">	            DailyScheduleSummary dailyScheduleSummary = it.next();</span>
	            //Determine the campaign name of the campaign associated to the event (if applicable).
	            //Calendar Events do not have campaigns associated to them.
<span class="nc bnc" id="L2523" title="All 2 branches missed.">	            if (!eventRange.getStartDate().before(dailyScheduleSummary.getShiftStartDate()) &amp;&amp;</span>
<span class="nc bnc" id="L2524" title="All 2 branches missed.">	                 eventRange.getStartDate().before(dailyScheduleSummary.getShiftEndDate()) &amp;&amp;</span>
<span class="nc bnc" id="L2525" title="All 2 branches missed.">	                 event.getEventType() != Event.EVENT_TYPE_CALENDAR_EVENT_ASSIGNMENT)</span>
	            {
<span class="nc" id="L2527">					String campaignName = ScheduleViewUtil.getCampaignName(campaignNamesBySpID, event);</span>

					//QC 137591: Only display a campaign name if it is available.
					// 			 Schedules with only TO and unavailability will pass the above test, but not have a match in campaignNamesBySpID.
<span class="nc bnc" id="L2531" title="All 2 branches missed.">					if (!StringUtil.isEmptyOrWhiteSpace(campaignName)) {</span>
<span class="nc bnc" id="L2532" title="All 2 branches missed.">						if (tooltip.length() &gt; 0)</span>
<span class="nc" id="L2533">							tooltip.append(lineBreak);</span>

						//GMT
<span class="nc" id="L2536">						tooltip.append(verticalize(m_bundle, FsWebBundleKey.FS_CAL_TITLEBAR_CAMPAIGN));</span>
<span class="nc" id="L2537">						tooltip.append(campaignName);</span>
<span class="nc" id="L2538">						break;</span>
					}
	            }
<span class="nc" id="L2541">	        }</span>
	    }

<span class="nc" id="L2544">	    return tooltip.toString();</span>
	}

	/**
     * make the work period string start - end,
     *  optional &quot;next day&quot; if it ends on the other date;
     *
     * @return ScheduleViewShiftDisplayInfo object which contains the necessary information to display
     * a shift in a schedule view screen (including icons such as overtime, calendar events, etc. if they
     * apply to the shift).
     */
    public static ScheduleViewShiftDisplayInfo getShiftDisplayInfo(DailyScheduleSummary daySchedule, Localizer localizer, TimeZone tz){
<span class="nc" id="L2556">		return getShiftDisplayInfoWithAccessibility(daySchedule,localizer,tz,false);</span>
	}

	public static ScheduleViewShiftDisplayInfo getShiftDisplayInfoWithAccessibility (DailyScheduleSummary daySchedule, Localizer localizer, TimeZone tz, boolean isAccessibility){
<span class="nc" id="L2560">		CalendarRange aDay = daySchedule.getDayRange();</span>
<span class="nc" id="L2561">		Date firstEventStartDate = daySchedule.getShiftStartDate();</span>
<span class="nc" id="L2562">		Date firstEventEndDate = daySchedule.getShiftEndDate();</span>

<span class="nc" id="L2564">		Date secondEventStartDate = firstEventStartDate;</span>
<span class="nc" id="L2565">		Date secondEventEndDate = firstEventEndDate;</span>
<span class="nc bnc" id="L2566" title="All 2 branches missed.">		if (daySchedule.getSecondShift() != null)</span>
		{
<span class="nc" id="L2568">			secondEventStartDate = daySchedule.getSecondShift().getShiftStartDate();</span>
<span class="nc" id="L2569">			secondEventEndDate = daySchedule.getSecondShift().getShiftEndDate();</span>
		}

<span class="nc" id="L2572">		StringBuffer sb = new StringBuffer();</span>

<span class="nc" id="L2574">		ResourceBundle bundle = localizer.getBundle(FsWebBundleKey.BUNDLE_NAME);</span>

		//previous day icon
<span class="nc" id="L2577">		String prevIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2578" title="All 2 branches missed.">		if (!aDay.includes(firstEventStartDate)) {</span>
<span class="nc" id="L2579">			prevIcon = makeAdjacentDayIcon(aDay, firstEventStartDate,</span>
<span class="nc" id="L2580">					localizer.i18n(bundle, FsWebBundleKey.SV_PREVIOUS_DAY),</span>
<span class="nc" id="L2581">					localizer.i18n(bundle, FsWebBundleKey.SV_NEXT_DAY), isAccessibility);</span>
		}

		//first shift string
<span class="nc" id="L2585">		sb.append(localizer.formatDate(firstEventStartDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>
<span class="nc" id="L2586">		sb.append(&quot; - &quot;);</span>
<span class="nc" id="L2587">		sb.append(localizer.formatDate(firstEventEndDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>

<span class="nc bnc" id="L2589" title="All 2 branches missed.">		if (daySchedule.getSecondShift() != null)</span>
		{
			//second shift string
<span class="nc" id="L2592">			sb.append(&quot;, &quot;);</span>
<span class="nc" id="L2593">			sb.append(localizer.formatDate(secondEventStartDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>
<span class="nc" id="L2594">			sb.append(&quot; - &quot;);</span>
<span class="nc" id="L2595">			sb.append(localizer.formatDate(secondEventEndDate,tz,RegionalFormatBundleKey.TIME_FORMAT));</span>
		}

		//next day icon
<span class="nc" id="L2599">		String nextIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2600" title="All 2 branches missed.">		if (!aDay.includes(secondEventEndDate)) {</span>
<span class="nc" id="L2601">			nextIcon = makeAdjacentDayIcon(aDay, secondEventEndDate,</span>
<span class="nc" id="L2602">					localizer.i18n(bundle, FsWebBundleKey.SV_PREVIOUS_DAY),</span>
<span class="nc" id="L2603">					localizer.i18n(bundle, FsWebBundleKey.SV_NEXT_DAY), isAccessibility);</span>
		}

		//pooling icon
<span class="nc" id="L2607">		String poolingIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2608" title="All 2 branches missed.">		if (daySchedule.containsPoolingActivities()) {</span>
<span class="nc" id="L2609">			poolingIcon = getShiftDisplayImage(ImageFileID.POOLER_ICON, &quot;16&quot;, &quot;15&quot;,</span>
<span class="nc" id="L2610">				localizer.i18n(bundle,FsWebBundleKey.SV_SHIFT_CONTAINS_POOLING_ACTIVITIES), isAccessibility);</span>
		}

		//overtime icon
<span class="nc" id="L2614">		String overTimeIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2615" title="All 2 branches missed.">		if (daySchedule.containsOvertime()) {</span>
<span class="nc" id="L2616">			overTimeIcon = getShiftDisplayImage(FsImageFileID.OVERTIME_ICON, FsImageFileID.OVERTIME_WIDTH,</span>
<span class="nc" id="L2617">				FsImageFileID.OVERTIME_HEIGHT, daySchedule.getOvertimeDescription(localizer), isAccessibility);</span>
		}

		//calendar event icon
<span class="nc" id="L2621">		String calendarEventIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2622" title="All 2 branches missed.">		if (daySchedule.containsCalendarEvents()) {</span>
<span class="nc" id="L2623">			calendarEventIcon = getShiftDisplayImage(FsImageFileID.CALENDAR_EVENT_ICON, FsImageFileID.CALENDAR_EVENT_WIDTH,</span>
<span class="nc" id="L2624">				FsImageFileID.CALENDAR_EVENT_HEIGHT, localizer.i18n(bundle,</span>
					FsWebBundleKey.SV_CALENDAR_EVENTS_TOOLTIP,
<span class="nc" id="L2626">					daySchedule.getCalendarEventsDescription(localizer)),isAccessibility);</span>
		}

<span class="nc" id="L2629">		return new ScheduleViewShiftDisplayInfo(prevIcon, sb.toString(), nextIcon, poolingIcon,</span>
			overTimeIcon, calendarEventIcon);
	}

	static String getShiftDisplayIcon(String src, String width, String height, String alt) {
<span class="nc" id="L2634">		HtmlImage img = new HtmlImage(src, width, height, alt);</span>
<span class="nc" id="L2635">		img.setStyle(&quot;vertical-align: middle&quot;);</span>
<span class="nc" id="L2636">		img.setTitle(alt);</span>
<span class="nc" id="L2637">		return img.toString();</span>
	}

	private static String getShiftDisplayIconWithAccessibility (String src, String width, String height, String alt) {
<span class="nc" id="L2641">		HtmlImage img = new HtmlImage(src, width, height, alt);</span>
<span class="nc" id="L2642">		img.setStyle(&quot;vertical-align: middle&quot;);</span>
<span class="nc" id="L2643">		img.setTitle(alt);</span>
<span class="nc" id="L2644">		img.setStyleClass(AccessibilityComplianceKeys.ATTR_VALUE_TABBABLE);</span>
<span class="nc" id="L2645">		img.appendAttribute(AccessibilityComplianceKeys.ATTR_ARIA_LABEL, alt);</span>
<span class="nc" id="L2646">		img.appendAttribute(AccessibilityComplianceKeys.ATTR_ARIA_LABEL_TOOLTIP, &quot;true&quot;);</span>
<span class="nc" id="L2647">		img.appendAttribute(AccessibilityComplianceKeys.ATTR_TABINDEX,&quot;0&quot;);</span>
<span class="nc" id="L2648">		return img.toString();</span>
	}

	private static String getShiftDisplayImage(String src, String width, String height, String alt, boolean isAccessibility) {
<span class="nc bnc" id="L2652" title="All 2 branches missed.">		if (isAccessibility) {</span>
<span class="nc" id="L2653">			return getShiftDisplayIconWithAccessibility(src, width, height, alt);</span>
		} else {
<span class="nc" id="L2655">			return getShiftDisplayIcon(src, width, height, alt);</span>
		}
	}

	/**
	 * add next or previous day icon
	 * @param prevLabel For 508 Accessibility, added label for the previous day icon
	 * @param nextLabel For 508 Accessibility, added label for the next day icon
	 */
	public static String makeAdjacentDayIcon(TimeRange aDay, Date date, String prevLabel, String nextLabel) {
<span class="nc" id="L2665">		return makeAdjacentDayIcon(aDay, date, prevLabel, nextLabel, false);</span>
	}
	
	/**
	 * 
	 * @param aDay 
	 * @param date - date value
	 * @param prevLabel - For 508 Accessibility, added label for the previous day icon
	 * @param nextLabel - For 508 Accessibility, added label for the next day icon
	 * @param isAccessibility - is Accessibility mode turned on
	 * @return dayIcon ready to be shown on the page
	 */
	public static String makeAdjacentDayIcon(TimeRange aDay, Date date, String prevLabel, String nextLabel,
			boolean isAccessibility) {
<span class="nc" id="L2679">		String dayIcon = &quot;&quot;;</span>
<span class="nc bnc" id="L2680" title="All 2 branches missed.">		if (aDay.getRelativeLocation(date) == TimeRange.TIME_AFTER) {</span>
<span class="nc" id="L2681">			dayIcon = getShiftDisplayImage(ImageFileID.NEXT_DAY, ImageFileID.NEXT_DAY_WIDTH,</span>
					ImageFileID.NEXT_DAY_HEIGHT, nextLabel, isAccessibility);
<span class="nc bnc" id="L2683" title="All 2 branches missed.">		} else if (aDay.getRelativeLocation(date) == TimeRange.TIME_BEFORE) {</span>
<span class="nc" id="L2684">			dayIcon = getShiftDisplayImage(ImageFileID.PREV_DAY, ImageFileID.PREV_DAY_WIDTH,</span>
					ImageFileID.PREV_DAY_HEIGHT, prevLabel, isAccessibility);
		}
<span class="nc" id="L2687">		return dayIcon;</span>
	}

	/**
	 * initialize generated JS data objects for the Graph views
	 */
	protected void startGenerateJSData(){
<span class="nc" id="L2694">		m_sbJS.append(&quot;\n\n// Graph View Data \n function afterMain(){\n var calendarGrid = new CalendarGrid();&quot;);</span>
<span class="nc" id="L2695">	}</span>

	/**
	 * initialize generated JS data objects for the Graph views
	 */
	protected void finishGenerateJSData(){
<span class="nc" id="L2701">		m_sbJS.append(&quot;\n calendarGrid.writeGrid();\n GraphViewSupport();\n }\n&quot;);</span>
<span class="nc" id="L2702">	}</span>


	/**
	 * limit the DateRange picker to +/- 30 years
	 */
	protected void limitDateRangePicker(){
<span class="nc" id="L2709">		CalendarRange selectableRange = DateTimeUtil.makeTimeRangeAroundNow(Calendar.YEAR,30,30); //+/-30 years</span>
<span class="nc" id="L2710">		m_dateRangePicker.getStartDatePickerPC().setLowerLimit(selectableRange.getStartDate());</span>
<span class="nc" id="L2711">		m_dateRangePicker.getEndDatePickerPC().setUpperLimit(selectableRange.getEndDate());</span>
<span class="nc" id="L2712">	}</span>

	protected ScheduleViewPM.dstTransitionMode getDstTransitionMode(TimeZone tz) {
<span class="nc" id="L2715">		ScheduleViewPM.dstTransitionMode mode = ScheduleViewPM.dstTransitionMode.NEUTRAL;</span>

<span class="nc bnc" id="L2717" title="All 2 branches missed.">		Date startDate = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartDate() : m_timeRange.getStartDate();</span>
<span class="nc bnc" id="L2718" title="All 2 branches missed.">		Date endDate = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getEndDate() : m_timeRange.getEndDate();</span>

<span class="nc" id="L2720">		boolean startOfRangeInDST = tz.inDaylightTime(startDate);</span>
<span class="nc" id="L2721">		boolean endOfRangeInDST = tz.inDaylightTime(endDate);</span>
<span class="nc bnc" id="L2722" title="All 4 branches missed.">		if (startOfRangeInDST &amp;&amp; !endOfRangeInDST) {</span>
<span class="nc" id="L2723">			mode = ScheduleViewPM.dstTransitionMode.FALLBACK;</span>
		}
<span class="nc bnc" id="L2725" title="All 4 branches missed.">		else if (!startOfRangeInDST &amp;&amp; endOfRangeInDST) {</span>
<span class="nc" id="L2726">			mode = ScheduleViewPM.dstTransitionMode.SPRINGFORWARD;</span>
		}

<span class="nc" id="L2729">		return mode;</span>
	}

	protected Calendar findDSTTransitionDay(TimeZone tz) {
<span class="nc" id="L2733">		boolean dstAdjustment = false;</span>
<span class="nc" id="L2734">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc bnc" id="L2735" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange))</span>
		{
<span class="nc" id="L2737">			boolean dayStartInDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L2738">			boolean dayEndInDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L2739" title="All 2 branches missed.">			if (dayStartInDST != dayEndInDST) {</span>
<span class="nc" id="L2740">				return aDay.getStartCalendar();</span>
			}

<span class="nc" id="L2743">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
<span class="nc" id="L2744">		}</span>

<span class="nc" id="L2746">		return m_timeRange.getStartCalendar(tz, m_locale);</span>
	}

	protected int findDSTTransition(int shownHours[], ScheduleViewPM.dstTransitionMode mode, TimeZone tz) {
<span class="nc bnc" id="L2750" title="All 2 branches missed.">		if (mode==ScheduleViewPM.dstTransitionMode.NEUTRAL)</span>
<span class="nc" id="L2751">			return -1;</span>

<span class="nc" id="L2753">		boolean dstAdjustment = false;</span>
<span class="nc" id="L2754">		CalendarRange aDay = DateTimeUtil.makeDayRange(m_timeRange.getStartDate(), tz);</span>
<span class="nc" id="L2755">		int prevHour = -1;</span>
<span class="nc bnc" id="L2756" title="All 2 branches missed.">		while (!aDay.isAfter(m_timeRange))</span>
		{
<span class="nc" id="L2758">			boolean dayStartInDST = tz.inDaylightTime(aDay.getStartDate());</span>
<span class="nc" id="L2759">			boolean dayEndInDST = tz.inDaylightTime(aDay.getEndDate());</span>
<span class="nc bnc" id="L2760" title="All 2 branches missed.">			if (dayStartInDST != dayEndInDST) {</span>
<span class="nc" id="L2761">				Calendar cal = aDay.getStartCalendar();</span>
<span class="nc" id="L2762">				cal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2763">				prevHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc" id="L2764">				cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L2765">				Date dateTime = cal.getTime();</span>
<span class="nc bnc" id="L2766" title="All 2 branches missed.">				while (dateTime.before(aDay.getEndDate())) {</span>
<span class="nc" id="L2767">					int curHour = cal.get(Calendar.HOUR_OF_DAY);</span>
<span class="nc bnc" id="L2768" title="All 2 branches missed.">					if (prevHour == curHour) {</span>
						//Fall DST transition occurs when 1AM follows 1AM. Transition occurs on the 2nd 1AM.
<span class="nc" id="L2770">						return prevHour+1;</span>
					}
<span class="nc bnc" id="L2772" title="All 2 branches missed.">					else if (curHour == prevHour + 2) {</span>
						//Spring DST transition occurs when 3AM follows 1AM. Transition occurs at 2AM.
<span class="nc" id="L2774">						return prevHour+1;</span>
					}

<span class="nc" id="L2777">					prevHour = curHour;</span>
<span class="nc" id="L2778">					cal.add(Calendar.HOUR_OF_DAY, 1);</span>
<span class="nc" id="L2779">					dateTime = cal.getTime();</span>
<span class="nc" id="L2780">				}</span>
			}

<span class="nc" id="L2783">			dstAdjustment = ScheduleViewUtil.nextDay(aDay, dstAdjustment);</span>
<span class="nc" id="L2784">		}</span>

<span class="nc" id="L2786">		return -1; // didn't find it</span>
	}

	//////////////////////////////////////////////////////////////////////////////
	// Dual List Helper Methods
	//////////////////////////////////////////////////////////////////////////////
	private void initDualListForDisplay() {
<span class="nc" id="L2793">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="nc" id="L2794">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2795">		leftListPC.setRowSelectable(false);</span>
<span class="nc" id="L2796">		rightListPC.setRowSelectable(false);</span>

<span class="nc" id="L2798">		initRightListProperties();</span>

<span class="nc bnc" id="L2800" title="All 2 branches missed.">		if (leftListPC.getListModel().isEmpty()) {</span>
<span class="nc" id="L2801">			m_dualList.setIsBorderEnabled(false);</span>
		}

<span class="nc bnc" id="L2804" title="All 2 branches missed.">		if (!isGraphView())</span>
		{
<span class="nc" id="L2806">			m_dualList.getLeftListPC().setIsZebra(true);</span>
<span class="nc" id="L2807">			m_dualList.getRightListPC().setIsZebra(true);</span>
		}
<span class="nc" id="L2809">	}</span>

	protected void initRightListProperties() {
		//set CSS class to remove margins in the right list
<span class="nc" id="L2813">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2814">		rightListPC.setCellClass(&quot;tblItemNoPaddn&quot;);</span>
<span class="nc" id="L2815">		rightListPC.setTableRowClass(&quot;tblRowNoPaddn&quot;);</span>
<span class="nc" id="L2816">		rightListPC.getHeader().setStyleClass(&quot;tableHeaderNoPaddn&quot;);</span>
<span class="nc" id="L2817">	}</span>

	protected void initRightListPropertiesForGraph()
	{
<span class="nc" id="L2821">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2822">		rightListPC.setTableAttribute(&quot;onselectstart&quot;, &quot;return false;&quot;);</span>
<span class="nc" id="L2823">		rightListPC.setTableAttribute(&quot;ondragstart&quot;, &quot;return false;&quot;);</span>

<span class="nc bnc" id="L2825" title="All 2 branches missed.">		rightListPC.setTableAttribute(&quot;requestedFor&quot;, (m_isFullPageMode ? m_myEmpID.toString() : getSelectedID())); //net staffing can only be shown for one agent at a time</span>
<span class="nc bnc" id="L2826" title="All 2 branches missed.">		rightListPC.setTableAttribute(&quot;pageMode&quot;, m_isFullPageMode ? FsKeys.RP_MODE_AGENT : FsKeys.RP_MODE_MGR);</span>

<span class="nc" id="L2828">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="nc" id="L2829">		leftListPC.setCellClass(&quot;tblRow tblItemNoPaddn&quot;); //tableItem   tblItem  tblItemNoPaddn</span>
<span class="nc" id="L2830">		leftListPC.setTableRowClass(&quot;tblRow&quot;); //tblRow tblRowNoPaddn</span>
<span class="nc" id="L2831">	}</span>

	/**
	 * generate left list header in dual list
	 */
	protected void makeLeftDualLIstHeader(String title){
		//--- left column header ----
<span class="nc" id="L2838">		MultiColListPC leftListPC = m_dualList.getLeftListPC();</span>
<span class="nc" id="L2839">		TableHeaderPC leftHeader = leftListPC.getHeader();</span>
<span class="nc" id="L2840">		leftHeader.addColumnHeaderData(null,title);</span>
<span class="nc" id="L2841">	}//makeLeftDualLIstHeader</span>

	/**
	 * generate right list headers with hours for the graph view
	 */
	protected void makeRightDualListHeader(int[] shownHours){
		//--- right headers = times within shown hours ----
<span class="nc" id="L2848">		MultiColListPC rightListPC = m_dualList.getRightListPC();</span>
<span class="nc" id="L2849">		TableHeaderPC rightHeader = rightListPC.getHeader();</span>


<span class="nc" id="L2852">		TimeZone tz = m_context.getViewingTimeZone();</span>
<span class="nc bnc" id="L2853" title="All 2 branches missed.">		Calendar startCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getStartCalendar(tz, m_locale):m_timeRange.getStartCalendar(tz, m_locale);</span>
<span class="nc" id="L2854">		startCal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2855">		boolean startInDST = tz.inDaylightTime(startCal.getTime());</span>
<span class="nc bnc" id="L2856" title="All 2 branches missed.">		Calendar endCal = getViewType().equals(VIEW_TYPE_GROUP_GRAPH)?m_dayRange.getEndCalendar(tz, m_locale):m_timeRange.getEndCalendar(tz, m_locale);</span>
<span class="nc" id="L2857">		endCal.set(Calendar.HOUR_OF_DAY, shownHours[1]);</span>
<span class="nc" id="L2858">		boolean endInDST = tz.inDaylightTime(endCal.getTime());</span>

<span class="nc" id="L2860">        Calendar headerCal = (Calendar)startCal.clone();</span>
		// if the startDate is in DST and the endDate is not, then we'll add an extra hour
		//   in this case, for multiple days, the days which don't include the extra hour will skip the extra hour
		// for the other DST transition case: in the spring,
		//   the day that has one less hour will skip the hour that's missing
<span class="nc bnc" id="L2865" title="All 4 branches missed.">		if (!(startInDST &amp;&amp; !endInDST)) {  // if !(add an hour for DST transition from DST to ST)</span>
<span class="nc" id="L2866">			headerCal.set(Calendar.MONTH,1); //to avoid DST-based formatting on DST-switch date</span>
<span class="nc" id="L2867">			headerCal.set(Calendar.DAY_OF_MONTH,1);</span>
<span class="nc" id="L2868">			headerCal.set(Calendar.MINUTE,0);</span>
<span class="nc" id="L2869">			headerCal.set(Calendar.SECOND,0);</span>
<span class="nc" id="L2870">			headerCal.set(Calendar.MILLISECOND,0);</span>
		} else {
<span class="nc" id="L2872">			headerCal = findDSTTransitionDay(tz);</span>
		}

		//put one string with fixed width spans for each hour
<span class="nc" id="L2876">		headerCal.set(Calendar.HOUR_OF_DAY, shownHours[0]);</span>
<span class="nc" id="L2877">		StringBuffer sb = new StringBuffer();</span>
<span class="nc bnc" id="L2878" title="All 2 branches missed.">		for (int i = shownHours[0]; i &lt;= shownHours[1]; i++) {</span>
<span class="nc" id="L2879">			boolean isDST = tz.inDaylightTime(headerCal.getTime());</span>
<span class="nc" id="L2880">			sb.append(&quot;&lt;span class=\&quot;hour\&quot;&gt;&quot;)</span>
<span class="nc" id="L2881">					.append(m_localizer.formatDate(headerCal.getTime(),tz,</span>
						RegionalFormatBundleKey.TIME_FORMAT))
<span class="nc" id="L2883">					.append(&quot;&lt;/span&gt;&quot;);</span>
<span class="nc" id="L2884">			headerCal.add(Calendar.HOUR_OF_DAY,1);</span>
		}
<span class="nc" id="L2886">		rightHeader.addColumnHeaderData(null,sb.toString());</span>
<span class="nc" id="L2887">	}//makeRightDualListHeader</span>

	/**
	 * Initialize Dual List with Models
	 */
	protected void setDualListModels(List lModel, List rModel) {
<span class="nc" id="L2893">		m_dualList.getLeftListPC().setListModel(lModel);</span>
<span class="nc" id="L2894">		m_dualList.getRightListPC().setListModel(rModel);</span>
<span class="nc" id="L2895">	}</span>

    /**
     * Generate Custom JavaScript Code.
     */
    public String getCustomJavaScript()
    {
<span class="nc" id="L2902">        StringBuilder js = new StringBuilder();</span>
<span class="nc bnc" id="L2903" title="All 2 branches missed.">        if (m_dualList!=null) {</span>
<span class="nc" id="L2904">            js.append(&quot;\nfunction customResize() {&quot; +</span>
<span class="nc" id="L2905">                    m_dualList.getName() + &quot;.onResize(); } \n&quot;);</span>
        }
<span class="nc" id="L2907">		String arialabel = m_localizer.i18n(UIFWebBundleKey.BUNDLE_NAME, UIFWebBundleKey.WORK_PANE_DESCRIPTION,</span>
<span class="nc" id="L2908">				m_contentTitlePC.getPageTitle(), &quot;&quot;);</span>
<span class="nc" id="L2909">        js.append(getJSChangeWorkspaceAriaLabel(arialabel));</span>
<span class="nc" id="L2910">        return js.toString();</span>
    }//getCustomJavaScript

	//================ abstract ======================
	/** inheriting classes overwrite content tittle with or without group features */
	protected abstract void initContentTitle();

	/** inheriting classes overwrite data loading with or without group data */
	protected abstract void loadAndInitData();

	//////////////////////////////////////////////////////////////////////////////
	// Empty Impl for WorkpaneListPM - to minimize subclass refactoring
	//////////////////////////////////////////////////////////////////////////////
	/**
	 * Initialize Header
	 */
<span class="nc" id="L2926">	protected void initHeader() {}</span>

	/**
	 * Initialize Selectable Items
	 */
<span class="nc" id="L2931">	protected void initSelectableItems() {}</span>

	/**
	 * For Story 34045 -PSR 6104 - Reason for Absence viewable only by Supervisor and Employee
     * See if the currently logged-in user is the Supervisor of the specified employee ID ..
     * @param empID The employee ID to check.
     * @return true if the currently logged-in user is the Supervisor of the specified employee ID .
     */
	protected boolean isSupervisor(ID empID) {
<span class="nc" id="L2940">    	return ScheduleViewMH.isSupervisor(m_context, empID, m_myEmpID);</span>
    }

    protected boolean isEnabledAbsentReasonToOnlySupervisor(){
<span class="nc" id="L2944">    	return ScheduleViewMH.enabledAbsentReasonToOnlySupervisor();</span>
    }
	/**
	 * This inner class is necessary in order to show the borders around the outter left and right graph tables.
	 *
	protected class GraphDualListPC extends DualListPC {

		private String BORDER_CLASS1 = &quot; class=\&quot;&quot; + CSSUtil.CLASS_BORDER_DEFAULT + &quot;\&quot; &quot;;
		private String DEFAULT_LWPR_STYLE1 = &quot;overflow:visible; overflow-x:visible !important; overflow-y:visible; border:1px solid #d2d2d2; height:100% !important;&quot;; //grey:d2d2d2 blue:0C99C9   height:400px; overflow-x:auto; overflow-y:hidden;     overflow:auto; works on modern browsers but not IE8
		private String DEFAULT_LWPR_ATTR1 = &quot; style=\&quot;&quot; + DEFAULT_LWPR_STYLE1 + &quot;\&quot; &quot;;

		private String DEFAULT_RWPR_STYLE1 = &quot;overflow:visible; overflow-x:visible !important; overflow-y:visible; border:1px solid #d2d2d2; height:100% !important;&quot;; //height:400px; overflow:auto;    overflow:auto; works on modern browsers but not IE8
		private String DEFAULT_RWPR_ATTR1 =  &quot; style=\&quot;&quot; + DEFAULT_RWPR_STYLE1 + &quot;\&quot; &quot;;

		public GraphDualListPC(RequestContext context) {
			super(context);
			//initLists();
			//setName(&quot;dualList&quot;);
			setJSMediator(JavaScriptFileID.MEDIATOR_DUAL_LIST_FOR_GRAPH);//&quot;/webroot/uif/js/modules/DualListMediatorForGraph.js&quot;); //JavaScriptFileID.MEDIATOR_DUAL_LIST_FOR_GRAPH);
			addRequiredJavaScriptFile(JavaScriptFileID.MEDIATOR_DUAL_CONTAINER_FOR_GRAPH);
		}

		/**
		 * Return Left Wrapper Attributes As String
		 *
		protected String getLWAttrAsString() {
			if (m_leftWprAttr==null || m_leftWprAttr.isEmpty()) {
				if (isBorderEnabled()) return BORDER_CLASS1 + DEFAULT_LWPR_ATTR1;
				else return DEFAULT_LWPR_ATTR1;
			}

			appendDefaultWprAttr(m_leftWprAttr, DEFAULT_LWPR_STYLE1);
			return getVPfromMap(m_leftWprAttr);
		}

		/**
		 * Return Right Wrapper Attributes As String
		 *
		protected String getRWAttrAsString() {
			if (m_rightWprAttr==null || m_rightWprAttr.isEmpty()) {
				if (isBorderEnabled()) return BORDER_CLASS1 + DEFAULT_RWPR_ATTR1;
				else return DEFAULT_RWPR_ATTR1;
			}

			appendDefaultWprAttr(m_rightWprAttr, DEFAULT_RWPR_STYLE1);
			return getVPfromMap(m_rightWprAttr);
		}
	}
	*/

}//class
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>