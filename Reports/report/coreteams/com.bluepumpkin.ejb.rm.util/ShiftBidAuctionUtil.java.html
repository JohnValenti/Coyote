<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ShiftBidAuctionUtil.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">ShiftBidAuctionUtil.java</span></div><h1>ShiftBidAuctionUtil.java</h1><pre class="source lang-java linenums">/*
 * Created on Aug 19, 2003
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
package com.bluepumpkin.ejb.rm.util;

import java.io.Serializable;
import java.rmi.RemoteException;
import java.util.*;

import com.bluepumpkin.common.config.ConfigManager;
import com.bluepumpkin.common.datatypes.ID;
import com.bluepumpkin.common.datatypes.Pair;
import com.bluepumpkin.common.datatypes.TimeRange;
import com.bluepumpkin.common.logging.Category;
import com.bluepumpkin.common.util.JMSNotifyUtil;
import com.bluepumpkin.common.util.NumberFactory;
import com.bluepumpkin.ejb.bbm.BbmEJBCreateException;
import com.bluepumpkin.ejb.bbm.BbmManagerFactory;
import com.bluepumpkin.ejb.bbm.base.BbmFinderException;
import com.bluepumpkin.ejb.bbm.base.BbmObjectNotFoundException;
import com.bluepumpkin.ejb.bbm.campaign.ejb.CampaignManager;
import com.bluepumpkin.ejb.bbm.config.ejb.DBConfigManager;
import com.bluepumpkin.ejb.bbm.schedule.ejb.ScheduleAccessManager;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftAssignment;
import com.bluepumpkin.ejb.bbm.schedule.model.ShiftEventAssignment;
import com.bluepumpkin.ejb.bbm.skill.ejb.SkillManager;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignment;
import com.bluepumpkin.ejb.bbm.skill.model.SkillAssignmentFieldInfo;
import com.bluepumpkin.ejb.bbm.timeoffcalculator.TOCalcUtil;
import com.bluepumpkin.ejb.bbm.vo.HOOAssignment;
import com.bluepumpkin.ejb.bbm.workresource.ejb.WorkResourceManager;
import com.bluepumpkin.ejb.bbm.workresource.model.EmployeeTemplate;
import com.bluepumpkin.ejb.bbm.workresource.model.Organization;
import com.bluepumpkin.ejb.bbm.workresource.model.Phantom;
import com.bluepumpkin.ejb.rm.Log;
import com.bluepumpkin.ejb.rm.base.RmRuntimeException;
import com.bluepumpkin.ejb.rm.l10n.RmEjbBundleKey;
import com.bluepumpkin.ejb.rm.l10n.RmEjbLogBundleKey;
import com.bluepumpkin.ejb.rm.notification.model.SerializedAuctionDetail;
import com.bluepumpkin.ejb.rm.requests.common.ejb.RequestUtil;
import com.bluepumpkin.ejb.rm.requests.common.model.RequestAuditTrail;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationResult;
import com.bluepumpkin.ejb.rm.requests.common.validation.ValidationUtil;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.SerializedAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.ejb.ShiftBidAuctionManager;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.SerializedAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidauction.model.ShiftBidAuction;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.ejb.ShiftBidderDAO;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequest;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidRequestBiddableSchedule;
import com.bluepumpkin.ejb.rm.requests.shiftbid.shiftbidrequest.model.ShiftBidder;
import com.bluepumpkin.ejb.rm.setup.settings.model.OrganizationSetting;
import com.verint.ejb.wfm.WfmManagerFactory;
import com.verint.ejb.wfm.cache.WfmCacheUtil;
import com.witness.ejb.core.security.PrivilegeKeys;

/**
 * @author rrajendran
 *
 * To change this generated comment go to
 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
 */
<span class="nc bnc" id="L67" title="All 2 branches missed.">public class ShiftBidAuctionUtil {</span>

<span class="nc" id="L69">	private static final Category LOG = Log.initCategory(ShiftBidAuctionUtil.class.getName());</span>
	public static final String CACHEKEY_PHANTOMS = &quot;ShiftBidAuctionUtil.Phantoms&quot;;
	public static final String CACHEKEY_SKILL_ASSIGNMENTS_FOR_TEMPLATE = &quot;ShiftBidAuctionUtil.SkillAssignmentsForTemplate&quot;;
	public static final String WFM_MIGRATION_15_1_0_135_MAX_AUCTION_ID = &quot;WFM_MIGRATION_15_1_0_135_MAX_AUCTION_ID&quot;;

	//MD5 checksums are 16 bytes long.  String representation as hex number is 32 chars.
	//    private static String m_MD5ForShiftNotFound = &quot;0102030405060708090a0b0c0d0e0f&quot;;

	public static final int COLLTYPE_EMPS = 1;
	public static final int COLLTYPE_EMPIDS = 2;

	static final String CACHEKEY_MAXRANK = &quot;CACHEKEY_MAXRANK&quot;;

<span class="nc" id="L82">	private static final String m_className = ShiftBidAuctionUtil.class.getName();</span>

	/**
	 * @author rrajendran
	 *
	 * To change this generated comment go to
	 * Window&gt;Preferences&gt;Java&gt;Code Generation&gt;Code and Comments
	 */
<span class="nc" id="L90">	public static class ShiftAssignmentComparator implements Comparator&lt;ShiftAssignment&gt; {</span>

		/* (non-Javadoc)
		 * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
		 */
		@Override
		public int compare(ShiftAssignment o1, ShiftAssignment o2) {
<span class="nc" id="L97">			return RmUtil.dateCompare(o1.getStartTime(), o2.getStartTime());</span>
		}

	}

<span class="nc" id="L102">	public static class ShiftEventAssignmentComparator implements Comparator&lt;ShiftEventAssignment&gt; {</span>
		@Override
		public int compare(ShiftEventAssignment event1, ShiftEventAssignment event2) {

			//compare Activity ID
<span class="nc" id="L107">			int diff = event1.getActivityID().compareTo(event2.getActivityID());</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">			if (diff != 0) {</span>
<span class="nc" id="L109">				return diff;</span>
			}
<span class="nc" id="L111">			diff = RmUtil.dateCompare(event1.getStartTime(), event2.getStartTime());</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">			if (diff != 0) {</span>
<span class="nc" id="L113">				return diff;</span>
			}

<span class="nc" id="L116">			return RmUtil.dateCompare(event1.getEndTime(), event2.getEndTime());</span>
		}
	}

<span class="nc" id="L120">	public static class ShiftBidRequestBiddableScheduleComparator implements Comparator&lt;ShiftBidRequestBiddableSchedule&gt; {</span>

		@Override
		public int compare(ShiftBidRequestBiddableSchedule o1, ShiftBidRequestBiddableSchedule o2) {
<span class="nc" id="L124">			return o1.getOrder() - o2.getOrder();</span>
		}
	}

<span class="nc" id="L128">	public static class ShiftBidderComparator implements Comparator&lt;ShiftBidder&gt; {</span>
<span class="nc" id="L129">		private int m_rankBy = -1;</span>

<span class="nc" id="L131">		public ShiftBidderComparator(int rankBy) {</span>
<span class="nc" id="L132">			m_rankBy = rankBy;</span>
<span class="nc" id="L133">		}</span>

		@Override
		public int compare(ShiftBidder bidder1, ShiftBidder bidder2) {

<span class="nc bnc" id="L138" title="All 6 branches missed.">			switch (m_rankBy) {</span>
			case ShiftBidder.RANKBY_ACCUMULATEDBONUS:
<span class="nc" id="L140">				return bidder1.getOptMethods().getAccumulatedBonus() - bidder2.getOptMethods().getAccumulatedBonus();</span>
			case ShiftBidder.RANKBY_EMPLOYEERANK:
				// For employee rank, a lower value means a higher rank (for example
				// a rank of 1 is higher than a rank of 2).  For this reason we compute
				// (bidder2.rank - bidder1.rank) instead of (bidder1.rank - bidder2.rank)
<span class="nc" id="L145">				return bidder2.getOptMethods().getEmployee().getRank() - bidder1.getOptMethods().getEmployee().getRank();</span>
			case ShiftBidder.RANKBY_SENIORITY:
<span class="nc" id="L147">				return bidder1.getOptMethods().getEmployee().getSeniority() - bidder2.getOptMethods().getEmployee().getSeniority();</span>
			case ShiftBidder.RANKBY_SCORE:
<span class="nc" id="L149">				return bidder1.getOptMethods().getScoreWithBonus() - bidder2.getOptMethods().getScoreWithBonus();</span>
			case ShiftBidder.RANKBY_SHIFTBIDDER_BONUS:
<span class="nc" id="L151">				return bidder1.getBonusThisAuction() - bidder2.getBonusThisAuction();</span>
			default:
<span class="nc" id="L153">				throw RequestUtil.createIllegalArgumentException(null, LOG);</span>
			}
		}
	}

	/**
	 * Gets the Orgs that associated with the Auction Scheduling Period.  If an org is selected
	 * for the auction, the orgs and suborgs of the auction are filter by the orgs selected for
	 * the scheduling period that the auction creator can view.
	 * 
	 * @param auction Auction to get the Scheduling Period
	 * @return Collection of org IDs that intersect with the org ID associated with the auction
	 */
	public static Collection&lt;ID&gt; getConcurrentAuctionOrgs(ShiftBidAuction auction) throws Exception {
<span class="nc" id="L167">		Collection&lt;ID&gt; spOrgs = null;</span>
<span class="nc" id="L168">		CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>

<span class="nc bnc" id="L170" title="All 2 branches missed.">		if (getIDFromValue(auction.getOrganizationId()) != null) {</span>
<span class="nc" id="L171">			WorkResourceManager workResourceManager = BbmManagerFactory.getWorkResourceManager(false);</span>
<span class="nc" id="L172">			Collection&lt;ID&gt; auctionScopeOrgs = new ArrayList&lt;ID&gt;();</span>
<span class="nc" id="L173">			Collection&lt;ID&gt; auctionOrg = Arrays.asList(getIDFromValue(auction.getOrganizationId()));</span>
<span class="nc" id="L174">			Collection&lt;ID&gt; orgs = workResourceManager.getOrganizationsChildrenByIDs(auctionOrg);</span>
<span class="nc" id="L175">			orgs.add(getIDFromValue(auction.getOrganizationId()));</span>

			// Gets the orgs the Auction creator can view
<span class="nc" id="L178">			Collection&lt;ID&gt; orgScope = RequestUtil.getOrgIDsWithPrivForEmpID(auction.getCreatorID(),</span>
					PrivilegeKeys.CORE_VIEWORGANIZATION_ID, null);

			// Gets Orgs the user has View Scope that are in the Scheduling Period
<span class="nc bnc" id="L182" title="All 2 branches missed.">			for (ID org : orgScope) {</span>
<span class="nc bnc" id="L183" title="All 2 branches missed.">				if (orgs.contains(org)) {</span>
<span class="nc" id="L184">					auctionScopeOrgs.add(org);</span>
				}
<span class="nc" id="L186">			}</span>

<span class="nc" id="L188">			spOrgs = campMgr.getSchedulingPeriodOrgs(auction.getSPID(), auctionScopeOrgs);</span>
<span class="nc" id="L189">		} else {</span>
<span class="nc" id="L190">			spOrgs = campMgr.getLinkedOrgsforSP(auction.getSPID());</span>
		}
<span class="nc" id="L192">		return spOrgs;</span>
	}

	/**
	 * Gets the parent and child Orgs of the auction or orgs.
	 * 
	 * @param auction Auction to get Orgs
	 * @return Collection of parent and child org IDs including the auction org ID.
	 */
	public static Collection&lt;ID&gt; getConcurrentAuctionParentChildOrgsOrSPOrgs(ShiftBidAuction auction) throws Exception {
<span class="nc" id="L202">		Collection&lt;ID&gt; orgs = new ArrayList&lt;ID&gt;();</span>

<span class="nc bnc" id="L204" title="All 2 branches missed.">		if (getIDFromValue(auction.getOrganizationId()) != null) {</span>
<span class="nc" id="L205">			WorkResourceManager workResourceManager = BbmManagerFactory.getWorkResourceManager(false);</span>

<span class="nc" id="L207">			Collection&lt;ID&gt; auctionOrg = Arrays.asList(getIDFromValue(auction.getOrganizationId()));</span>
<span class="nc" id="L208">			orgs.addAll(workResourceManager.getOrganizationsChildrenByIDs(auctionOrg));</span>
<span class="nc" id="L209">			orgs.addAll(workResourceManager.getOrganizationsParentsByIDs(auctionOrg));</span>
<span class="nc" id="L210">			orgs.add(getIDFromValue(auction.getOrganizationId()));</span>
<span class="nc" id="L211">		} else {</span>
<span class="nc" id="L212">			CampaignManager campMgr = WfmManagerFactory.getCampaignManager();</span>
<span class="nc" id="L213">			orgs = campMgr.getLinkedOrgsforSP(auction.getSPID());</span>
		}
<span class="nc" id="L215">		return orgs;</span>
	}

	/**
	 * Note: this method may return 'null' if no HOO assignments are found for the employee's org.
	 *
	 * Obtain the bid deadline for 'nextBidder' after which the next eligible bidder will be added
	 * to the serialized auction.
	 *
	 * Method declared public for access from unit test code.
	 *
	 * @param bidderTimeLimit
	 * @return
	 */
	public static Date getBidderDeadlineForSerAuction(ShiftBidder nextBidder, Date currDate, int bidderTimeLimit) throws Exception {
		// resolution for deadline computation in this method is a minute.  So trim the given date to
		// minutes, by resetting seconds and milliseconds to zero.
<span class="nc" id="L232">		currDate = RequestUtil.getDateWithSecondsReset(currDate);</span>

		// Bidders org can be 'null' if the employee's 'endDate' has expired.
<span class="nc" id="L235">		Organization org = ValidationUtil.getOrganizationForEmployeeDuringPeriod(nextBidder.getEmployeeID(), currDate, currDate);</span>
<span class="nc bnc" id="L236" title="All 2 branches missed.">		if (org == null) {</span>
<span class="nc" id="L237">			return null;</span>
		}

		// get the HOOs for shift bidder's org.
<span class="nc" id="L241">		Collection hoos = RequestUtil.getHooAssignmentsDuringPeriod(org, new TimeRange(currDate, currDate));</span>

		// HOOs collection can never be empty for an org (in London).  But in some test databases in QA,
		// HOO assignments for orgs do not exist.
<span class="nc bnc" id="L245" title="All 4 branches missed.">		if (hoos == null || hoos.isEmpty()) {</span>
<span class="nc" id="L246">			return null;</span>
		}

		// verify that only one hoo exists in collection.
<span class="nc bnc" id="L250" title="All 4 branches missed.">		assert hoos.size() == 1 : &quot;hoos.size() == 1: &quot; + hoos.size();</span>

		// get the hoo assignment.
<span class="nc" id="L253">		HOOAssignment hooAssn = (HOOAssignment) hoos.iterator().next();</span>

		//4 possible cases:
		//  currTime falls on a non open day.
		//  currTime before day start
		//  currTime after day end
		//  currTime between day start and end.

		//
		//  if (currTime falls on non open day)
		//     move currtime to next open day.
		//  end if
		//  if (currTime before day's HOO start)
		//    move currtime to day start of this day(if day open) or next open day's hoo start
		//  endif
		//  if currTime after day's HOO end
		//     move currtime to next open day's hoo start.
		//  end if
		//  while (timeLimit &gt; 0)
		//    if currTime + timeLimit within day's HOO
		//       computeDeadlineTime.
		//       timeLimit = 0
		//    else if currTime + timeLimit after day's HOO end.
		//       timeLimit -= remaining minutes for day
		//       move to next open day's hoo start.
		//    end if
		//  end while

		// ********* controlling varaibles: currDate, midnightForCurrDate, currDayOpen, currDayClose. *********
		// initial value for deadline.
<span class="nc" id="L283">		TimeZone orgTZ = org.getTimeZone();</span>
		//Date currDate = currDate;
		// get calendar for deadline.
<span class="nc" id="L286">		Calendar currDateCal = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L287">		currDateCal.setTime(currDate);</span>
		// get midnight for deadline day
<span class="nc" id="L289">		Date midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>

<span class="nc" id="L291">		Date currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L292">		Date currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L293">		Calendar currDayCloseCal = Calendar.getInstance(orgTZ);</span>
		//currDayCloseCal.setTime(currDayClose) not done as currDayClose could be null.

		//if currDate does not fall during hours of operation (currDate
		// falls on closed day, before dayStart or after dayEnd)
<span class="nc bnc" id="L298" title="All 6 branches missed.">		if (currDayOpen == null || currDate.before(currDayOpen) || currDate.after(currDayClose)) {</span>
			// set currDate to next day start
<span class="nc" id="L300">			currDate = getNextDayOpenForHOO(currDate, hooAssn, orgTZ);</span>

			// recompute associated data.
<span class="nc" id="L303">			currDateCal.setTime(currDate);</span>
<span class="nc" id="L304">			midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L305">			currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L306">			currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L307">			currDayCloseCal.setTime(currDayClose);</span>
		} else {
<span class="nc" id="L309">			currDayCloseCal.setTime(currDayClose);</span>
		}

<span class="nc bnc" id="L312" title="All 2 branches missed.">		while (bidderTimeLimit &gt; 0) {</span>
			// add the bidderTimeLimit to the deadLineDate.
<span class="nc" id="L314">			currDateCal.add(Calendar.MINUTE, bidderTimeLimit);</span>

			// if currDate + timeLimit &lt;= day end
<span class="nc bnc" id="L317" title="All 2 branches missed.">			if (currDayClose.after(currDateCal.getTime())) {</span>
<span class="nc" id="L318">				currDate = currDateCal.getTime();</span>
<span class="nc" id="L319">				bidderTimeLimit = 0; //terminate loop</span>
			} else { // if currDate + timeLimit &gt; day end; we need to get minutes from the next day open.
				// compute minutes left until end of day.
<span class="nc" id="L322">				int minutesLeft = (int) ((currDayClose.getTime() - currDate.getTime()) / 60000L);</span>

				// debit # of minutes from bidderTimeLimit
<span class="nc" id="L325">				bidderTimeLimit -= minutesLeft;</span>
<span class="nc bnc" id="L326" title="All 4 branches missed.">				assert bidderTimeLimit &gt;= 0 : &quot;bidderTimeLimit &gt;= 0: &quot; + bidderTimeLimit;</span>

				// move deadlineDate to next day's start time for which call center is open.
<span class="nc" id="L329">				currDate = getNextDayOpenForHOO(currDate, hooAssn, orgTZ);</span>
				// recompute associated data.
<span class="nc" id="L331">				currDateCal.setTime(currDate);</span>
<span class="nc" id="L332">				midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L333">				currDayOpen = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L334">				currDayClose = hooAssn.getDayClose(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L335">				currDayCloseCal.setTime(currDayClose);</span>
<span class="nc" id="L336">			}</span>
		}

<span class="nc" id="L339">		return currDate;</span>
	}

	private static Date getNextDayOpenForHOO(Date currDate, HOOAssignment hooAssn, TimeZone orgTZ) {
		// possible cases:
		//   currDate falls on day call center is closed
		//   currDate falls on day call center is open and before day open
		//   currDate falls on day call center is open and between day open and close.
		//   currDate falls on day call center is open and after day open

		// while call center closed or (call center open and currDate is after day start)
		//    find next open day
		//    currDate = day start.
		// end while
		//
		// //At this point we have an open day with currDate before or at dayStart.
		// get day start for currDay.
		// return day start.

		// ********* controlling variables: currDate, midnight for curr date, daystart and dayend. *********
<span class="nc" id="L359">		Date midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L360">		Calendar midnightForCurrDateCal = Calendar.getInstance(orgTZ);</span>
<span class="nc" id="L361">		midnightForCurrDateCal.setTime(midnightForCurrDate);</span>

<span class="nc" id="L363">		Date dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc" id="L364">		Date dayOpenForGivenDate = dayOpenForCurrDate;</span>

		// keep skipping until we find a open day.
		// QA 87592 - Auction Deadline Defaults to 24h
		// if currDate is also the dayOpenForCurrDate then this 'while' will be failed
		//while (dayOpenForCurrDate == null || currDate.after(dayOpenForCurrDate)) {
<span class="nc bnc" id="L370" title="All 4 branches missed.">		while (dayOpenForCurrDate == null || !dayOpenForCurrDate.after(dayOpenForGivenDate)) {</span>
			// move to next day's midnight
			//midnightForCurrDateCal.add(Calendar.DAY_OF_MONTH, 1);
<span class="nc" id="L373">			TOCalcUtil.addDaysToCalendar(midnightForCurrDateCal, 1);</span>
<span class="nc" id="L374">			midnightForCurrDate = midnightForCurrDateCal.getTime();</span>

			// get the opening time for next day.
<span class="nc" id="L377">			dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>
<span class="nc bnc" id="L378" title="All 2 branches missed.">			currDate = (dayOpenForCurrDate != null) ? dayOpenForCurrDate : midnightForCurrDate;</span>
		}

		// At this point, we have an open day with currDate either before or at dayStart.  Now adjust accordingly.
<span class="nc" id="L382">		midnightForCurrDate = RequestUtil.getDateForDayStart(currDate, orgTZ);</span>
<span class="nc" id="L383">		dayOpenForCurrDate = hooAssn.getDayOpen(midnightForCurrDate, orgTZ);</span>

<span class="nc" id="L385">		return dayOpenForCurrDate;</span>
	}

	/**
	 * Returns the sorted list of bidders (sorted by the given sort criteria) who are 'unadded' and
	 * marked as 'seraialized auction bidders'.  If no such bidders exist, return null.
	 *
	 * @param auctionID
	 * @return
	 */
	private static List&lt;ShiftBidder&gt; getSortedBiddersForSerAuction(ID auctionID, int rankBy, ShiftBidderDAO bidderDAO) throws Exception {

<span class="nc bnc" id="L397" title="All 2 branches missed.">		boolean bidderDAOAllocNeeded = (bidderDAO == null);</span>
		try {
<span class="nc bnc" id="L399" title="All 2 branches missed.">			bidderDAO = (bidderDAO == null) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>

			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L402">			Collection&lt;ShiftBidder&gt; notAddedSerAucBidders = bidderDAO.getSerializedAuctionBiddersForAuction(auctionID, ShiftBidder.DL_BASIC</span>
					| ShiftBidder.DL_EMPLOYEE);

			// return if no 'not added' bidders found.
<span class="nc bnc" id="L406" title="All 2 branches missed.">			if (notAddedSerAucBidders.isEmpty()) {</span>
<span class="nc" id="L407">				return null;</span>
			}

			// need to compute the score for the bidders if ranking is by 'score'
<span class="nc bnc" id="L411" title="All 4 branches missed.">			if (!notAddedSerAucBidders.isEmpty() &amp;&amp; rankBy == ShiftBidder.RANKBY_SCORE) {</span>
<span class="nc" id="L412">				Map&lt;ID, Pair&lt;Integer, Integer&gt;&gt; bidderToScore = bidderDAO.getShiftBidderScore(auctionID, null);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">				for (ShiftBidder notAddedBidder : notAddedSerAucBidders) {</span>
<span class="nc" id="L415">					notAddedBidder.setScores(bidderToScore.get(notAddedBidder.getID()));</span>
<span class="nc" id="L416">				}</span>
			}

<span class="nc" id="L419">			List&lt;ShiftBidder&gt; notAddedBiddersList = RequestUtil.getListFromCollection(notAddedSerAucBidders);</span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">			if (notAddedBiddersList.size() &gt; 1) {</span>
<span class="nc" id="L421">				Collections.sort(notAddedBiddersList, new ShiftBidAuctionUtil.ShiftBidderComparator(rankBy));</span>
			}

<span class="nc" id="L424">			return notAddedBiddersList;</span>
		} finally {

<span class="nc bnc" id="L427" title="All 12 branches missed.">			if (bidderDAOAllocNeeded &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L428">				bidderDAO.cleanUp();</span>
			}

		}
	}

	/**
	 * TODO: think about if bidder's state transistion and isSerializedBidder flag must be linked.  If
	 * so, this is the method where the link can be enforced.
	 *
	 * @param origBidderFromDB
	 * @param newStatus
	 */
	protected static ValidationResult validateShiftBidderStateTrans(ShiftBidder origBidderFromDB, int newStatus) {

<span class="nc" id="L443">		int origStatus = origBidderFromDB.getStatus();</span>
		//int newStatus = givenBidder.getStatus();

<span class="nc bnc" id="L446" title="All 2 branches missed.">		if (origStatus == newStatus) {</span>
<span class="nc" id="L447">			return null;</span>
		}

		// valid transistions:
		//
		//             Not Added  Added  Scheduled
		//  Not Added               x       x
		//    Added       x                 x
		//  Scheduled     x
		//
<span class="nc bnc" id="L457" title="All 4 branches missed.">		if (origStatus == ShiftBidder.STATUS_UNAVAILABLE &amp;&amp; newStatus == ShiftBidder.STATUS_ADDED) {</span>
<span class="nc" id="L458">			String oldState = ShiftBidder.STATUS_STRARR[origStatus];</span>
<span class="nc" id="L459">			String newState = ShiftBidder.STATUS_STRARR[newStatus];</span>

<span class="nc" id="L461">			return ValidationUtil.setAndLogHardValidationResult(origBidderFromDB, RmEjbBundleKey.REQ_CANNOT_TRANSITION_STATUS,</span>
					RmEjbLogBundleKey.REQ_CANNOT_TRANSITION_STATUS, new Serializable[] {
							oldState,
							newState,
							&quot;n/a&quot; },
					m_className);
		}

<span class="nc" id="L469">		return null;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static Set&lt;ID&gt; getTerminatedEmployeeIDs(Date date) throws Exception {
<span class="nc" id="L474">		WorkResourceManager wrm = BbmManagerFactory.getWorkResourceManager();</span>
<span class="nc" id="L475">		return new HashSet&lt;ID&gt;(wrm.getTerminatedEmployeeIDs(date));</span>
	}

	/**
	 * &lt;p&gt;Note: To detect if any updates were done, check for a hard or soft validation error.
	 * &lt;p&gt;
	 * If the shiftBidder VO has invalid fields, then either:
	 * &lt;li&gt; shiftBidder VO is updated with the invalid value replaced with a valid value, a soft
	 * validation result is added to the shiftBidder VO but a 'null' is still returned.
	 * &lt;li&gt; or a hard validation error is added to the shiftBidder VO and this non-null hard
	 * validation result is returned to the caller.
	 *
	 * &lt;p&gt; one or more of the following validations are done (depending on the 'actionType' parameter)
	 * &lt;li&gt; if bidder is being added to the auction, has the auction already expired?
	 * &lt;li&gt; bidder deadline is not later than auction deadline
	 * &lt;li&gt; Does bidder status have a valid value?
	 * &lt;li&gt; Is the status transition valid for the bidder?
	 * &lt;li&gt; Is employee in good standing?
	 * &lt;li&gt; Must employee's status be changed from 'scheduled' to another or to 'scheduled' from another.
	 *
	 * @param sbAuction if non null, then the bidder's deadline is validated against the auction deadline.  If
	 * null, then this check is not made.
	 *
	 * @param origBidderFromDB Used for update validation and represents the original bidder object fetched from DB
	 * before the update. Must be non-null if actionType = {@link RequestUtil#ACTION_UPDATE ACTION_UPDATE}.
	 * Can be null otherwise.
	 *
	 * @param givenBidder For ACTION_UPDATE, represents the updated object.  Contrast this with 'origBidderFromDB'
	 * parameter.  For other actions, represents the bidder object to be validated.
	 */
	public static ValidationResult validateShiftBidderAndUpdate(ShiftBidder givenBidder, ShiftBidder origBidderFromDB, int actionType,
			ShiftBidAuction sbAuction, Collection&lt;ID&gt; unavailableEmpIDs, Set&lt;ID&gt; terminatedEmployeeIDs) throws Exception {
		//
		// validate shiftBidder on get
		//    shiftBidder deadline &lt;= auctionDeadline.
		//    employee in good standing
		// validate shiftbidder on create
		//    shiftBidder deadline &lt;= auctionDeadline.
		//    valid state.
		//    employee in good standing
		// validate shiftBidder on update
		//    updateable fields: deadline, status, bonusThisAuction.
		//    shift bidder deadline &lt;= auctionDeadline.
		//    valid state and state transition
		//    employee in good standing
		// validate shiftBidder on delete:
		//    not necessary
		//
<span class="nc" id="L523">		ID bidderID = givenBidder.getID();</span>
<span class="nc" id="L524">		ValidationResult valResult = null;</span>
<span class="nc bnc" id="L525" title="All 2 branches missed.">		if (actionType == RequestUtil.ACTION_UPDATE) {</span>
			// copy 'unset' fields from origBidderFromDB to 'givenBidder'.
<span class="nc" id="L527">			givenBidder.getSetters().copyUnsetFields(origBidderFromDB);</span>

			// verify state transition validation.
<span class="nc" id="L530">			valResult = validateShiftBidderStateTrans(origBidderFromDB, givenBidder.getStatus());</span>
<span class="nc bnc" id="L531" title="All 2 branches missed.">			if (valResult != null) {</span>
<span class="nc" id="L532">				return valResult;</span>
			}

<span class="nc bnc" id="L535" title="All 4 branches missed.">			boolean bidderAddition = !origBidderFromDB.isStatusAdded() &amp;&amp; givenBidder.isStatusAdded();</span>
			// Note: A bidder can be added to a closed auction.  For instance, the mgr can add bidders to a
			// a closed auction and then open the auction.

			// verify bidder cannot be 'added' to an expired auction.
<span class="nc" id="L540">			Date currDate = new Date();</span>
<span class="nc bnc" id="L541" title="All 6 branches missed.">			if (bidderAddition &amp;&amp; sbAuction != null &amp;&amp; sbAuction.getAuctionDeadLine().before(currDate)) {</span>
<span class="nc" id="L542">				return ValidationUtil.setAndLogHardValidationResult(givenBidder, RmEjbBundleKey.AUC_CANT_ADD_BIDDER_AFTER_AUC_DEADLINE,</span>
						RmEjbLogBundleKey.AUC_CANT_ADD_BIDDER_AFTER_AUC_DEADLINE, new Serializable[] {
<span class="nc" id="L544">								origBidderFromDB.getID(),</span>
<span class="nc" id="L545">								sbAuction.getID() },</span>
						m_className);
			}
		}

		// bidder deadline is no later than auction deadline.
<span class="nc" id="L551">		Date bidderDeadlineDate = givenBidder.getDeadlineDate();</span>
<span class="nc bnc" id="L552" title="All 6 branches missed.">		if (sbAuction != null &amp;&amp; bidderDeadlineDate != null &amp;&amp; bidderDeadlineDate.after(sbAuction.getAuctionDeadLine())) {</span>
<span class="nc" id="L553">			Date aucDeadline = sbAuction.getAuctionDeadLine();</span>
<span class="nc" id="L554">			givenBidder.setDeadlineDate(aucDeadline);</span>

<span class="nc" id="L556">			LOG.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_DEADLINE_WITH_AUC_DEALINE, new Object[] {</span>
					bidderID,
					aucDeadline });
<span class="nc" id="L559">			ValidationUtil.setSoftValidationResult(givenBidder, RmEjbLogBundleKey.AUC_UPDATED_BIDDER_DEADLINE_WITH_AUC_DEALINE,</span>
					m_className);
		}

		// Does bidder status have a valid value?
<span class="nc bnc" id="L564" title="All 4 branches missed.">		if (givenBidder.getStatus() &lt; ShiftBidder.STATUS_FIRST || givenBidder.getStatus() &gt; ShiftBidder.STATUS_LAST) {</span>
<span class="nc" id="L565">			return ValidationUtil.setAndLogHardValidationResult(givenBidder, RmEjbBundleKey.AUC_INVALID_BIDDER_STATUS,</span>
					RmEjbLogBundleKey.AUC_INVALID_BIDDER_STATUS, new Serializable[] {
							bidderID,
<span class="nc" id="L568">							NumberFactory.newInteger(givenBidder.getStatus()) },</span>
					m_className);
		}

		// Is employee in good standing?  detail level == EMPLOYEE is checked to ensure that any call
		// to fetch a shift bidder with detail level != EMPLOYEE, say thru the EJB API, will not result in an exception here.
<span class="nc bnc" id="L574" title="All 4 branches missed.">		if ((givenBidder.getDetailLevel() &amp; ShiftBidder.DL_EMPLOYEE) != 0 &amp;&amp; terminatedEmployeeIDs.contains(givenBidder.getEmployeeID())) {</span>
<span class="nc" id="L575">			return ValidationUtil.setAndLogHardValidationResult(givenBidder, RmEjbBundleKey.EMP_ID_HAS_BEEN_TERMINATED,</span>
					RmEjbLogBundleKey.INVALID_SHIFTBIDDER_EMP_ID_HAS_BEEN_TERMINATED, new Serializable[] {
<span class="nc" id="L577">							givenBidder.getEmployeeID() },</span>
					m_className);
		}

<span class="nc" id="L581">		valResult = validateShiftBidderForScheduled(givenBidder, unavailableEmpIDs);</span>
<span class="nc bnc" id="L582" title="All 2 branches missed.">		if (valResult != null) {</span>
<span class="nc" id="L583">			return valResult;</span>
		}

<span class="nc" id="L586">		return null;</span>
	}

	/**
	 * @param givenBidder
	 * @param bidderEmpIDToNumOfShiftsMap
	 * @return a validationResult which reflects the validation modification made.
	 * &lt;li&gt; If validaiton modifications were made, returns a non-null value.  If
	 * {@link SimpleValidationResult#getValResult() SimpleValidationResult.getValResult()} returns
	 * {@link SimpleValidationResult#VALRESULT_ERROR VALRESULT_ERROR} then a hard validation error was
	 * encountered.  Otherwise a soft validation error (recoverable) occured.
	 * &lt;li&gt; If no validation modifications were done returns 'null.
	 */
	private static ValidationResult validateShiftBidderForScheduled(ShiftBidder givenBidder, Collection&lt;ID&gt; unavailableEmpIDs) {

<span class="nc" id="L601">		ID bidderEmpID = givenBidder.getEmployeeID();</span>
<span class="nc" id="L602">		ID bidderID = givenBidder.getID();</span>

		// if employee is scheduled for SP week
<span class="nc bnc" id="L605" title="All 4 branches missed.">		if (unavailableEmpIDs != null &amp;&amp; unavailableEmpIDs.contains(bidderEmpID)) {</span>
			// if status is not 'scheduled', make it scheduled.
<span class="nc bnc" id="L607" title="All 2 branches missed.">			if (givenBidder.getStatus() != ShiftBidder.STATUS_UNAVAILABLE) {</span>
				// since the employee has shifts during the SP week, switch status to scheduled.
				//verify if this status transistion is valid.
<span class="nc" id="L610">				ValidationResult stateTransValRes = validateShiftBidderStateTrans(givenBidder, ShiftBidder.STATUS_UNAVAILABLE);</span>
				// if transition is invalid, return.
<span class="nc bnc" id="L612" title="All 2 branches missed.">				if (stateTransValRes != null) {</span>
<span class="nc" id="L613">					return stateTransValRes;</span>
				}

<span class="nc" id="L616">				givenBidder.getSetters().setStatus(ShiftBidder.STATUS_UNAVAILABLE);</span>
				// reset deadline date.  deadline set only for status == 'added'.
<span class="nc" id="L618">				givenBidder.setDeadlineDate(null);</span>

				// 'bonus this auction' is not reset.  Keep the value as a reference for
				// the manager after the bidder's req is approved and scheduled.
				// Not resetting this to zero on 'scheduled' status does not affect anything else.
				//
				//givenBidder.setBonusThisAuction(0);

<span class="nc" id="L626">				LOG.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS, new Object[] {</span>
						bidderID,
<span class="nc" id="L628">						NumberFactory.newInteger(givenBidder.getStatus()),</span>
<span class="nc" id="L629">						NumberFactory.newInteger(ShiftBidder.STATUS_UNAVAILABLE) });</span>
<span class="nc" id="L630">				ValidationUtil.setSoftValidationResult(givenBidder, RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS, m_className);</span>
<span class="nc" id="L631">			}</span>
			// if employee is not scheduled for SP week
<span class="nc bnc" id="L633" title="All 4 branches missed.">		} else if (unavailableEmpIDs != null &amp;&amp; !unavailableEmpIDs.contains(bidderEmpID)) {</span>
			// if employee is marked scheduled.
<span class="nc bnc" id="L635" title="All 2 branches missed.">			if (givenBidder.getStatus() == ShiftBidder.STATUS_UNAVAILABLE) {</span>
				//verify if this status transistion is valid.
<span class="nc" id="L637">				ValidationResult stateTransValRes = validateShiftBidderStateTrans(givenBidder, ShiftBidder.STATUS_NOT_ADDED);</span>
				// if transistion is invalid, return.
<span class="nc bnc" id="L639" title="All 2 branches missed.">				if (stateTransValRes != null) {</span>
<span class="nc" id="L640">					return stateTransValRes;</span>
				}
<span class="nc" id="L642">				givenBidder.getSetters().setStatus(ShiftBidder.STATUS_NOT_ADDED);</span>
<span class="nc" id="L643">				givenBidder.setDeadlineDate(null); //reset deadline date.  deadline set only for status == 'added'.</span>

<span class="nc" id="L645">				LOG.l7dDebug(RmEjbLogBundleKey.AUC_UPDATED_BIDDER_STATUS, new Object[] {</span>
						bidderID,
<span class="nc" id="L647">						NumberFactory.newInteger(ShiftBidder.STATUS_UNAVAILABLE),</span>
<span class="nc" id="L648">						NumberFactory.newInteger(ShiftBidder.STATUS_NOT_ADDED), });</span>
<span class="nc" id="L649">				ValidationUtil.setSoftValidationResult(givenBidder, RmEjbBundleKey.AUC_UPDATED_BIDDER_STATUS, m_className);</span>
			}
		}

<span class="nc" id="L653">		return null;</span>
	}

	/**
	 * &lt;p&gt; Loads the bidder VOs from DB corresponding to the bidders in 'givenBidders'. Validates each bidder
	 *  in 'givenBidders'.  If validation fails for a bidder, bidder is removed from the 'givenBidders' collection.
	 *
	 * &lt;p&gt;Note: The list of givenBidders must be a mutable list. This method might remove elements from this
	 * list.
	 *
	 * &lt;p&gt; All shift bidder updates happen thru' this method except for updates to 'isSerializedAuctionBidder'
	 * flag for a bidder.  This is done using a DAO method (called by startAuctionSerialization() and
	 * stopAuctionSerialization() methods).
	 *
	 * @param auctionID
	 * @param givenBidders
	 * @param sbAuctionDAO
	 * @param bidderDAO
	 * @throws Exception
	 */
	public static void validateShiftBiddersForUpdateActionAndUpdate(ID auctionID, Collection&lt;ShiftBidder&gt; givenBidders,
			ShiftBidAuctionDAO sbAuctionDAO, ShiftBidderDAO bidderDAO) throws Exception {
<span class="nc bnc" id="L675" title="All 2 branches missed.">		boolean bidderDAONeedsCreate = bidderDAO == null;</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">		boolean sbAuctionDAONeedsCreate = sbAuctionDAO == null;</span>
		try {
<span class="nc" id="L678">			List&lt;ID&gt; shiftBidderIDs = RequestUtil.getListOfIDsFromVOBases(givenBidders);</span>

			// get auction VO.
<span class="nc bnc" id="L681" title="All 2 branches missed.">			sbAuctionDAO = (sbAuctionDAONeedsCreate) ? new ShiftBidAuctionDAO(ShiftBidAuction.DL_BASIC) : sbAuctionDAO;</span>
<span class="nc" id="L682">			ShiftBidAuction sbAuction = sbAuctionDAO.getAuctionByID(auctionID, ShiftBidAuction.DL_BASIC);</span>

			// load given bidders from DB.
<span class="nc bnc" id="L685" title="All 2 branches missed.">			bidderDAO = (bidderDAONeedsCreate) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : bidderDAO;</span>
<span class="nc" id="L686">			List&lt;ID&gt; givenBidderIDs = RequestUtil.getListOfIDsFromVOBases(givenBidders);</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L688">			Collection&lt;ShiftBidder&gt; biddersFromDB = bidderDAO.getShiftBiddersByIDs(givenBidderIDs, false,</span>
<span class="nc" id="L689">					ShiftBidder.getDetailLevelForValidation());</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L691">			Map&lt;ID, ShiftBidder&gt; bidderIDTobidderFromDBMap = RequestUtil.getMapOfIDsForVOBases(biddersFromDB);</span>
<span class="nc" id="L692">			Date current = new Date();</span>
<span class="nc" id="L693">			Set&lt;ID&gt; terminatedEmployeeIDs = ShiftBidAuctionUtil.getTerminatedEmployeeIDs(current);</span>

<span class="nc bnc" id="L695" title="All 2 branches missed.">			for (Iterator&lt;ShiftBidder&gt; givenBiddersIter = givenBidders.iterator(); givenBiddersIter.hasNext();) {</span>
<span class="nc" id="L696">				ShiftBidder givenBidder = givenBiddersIter.next();</span>

				// validate if the update operation
<span class="nc" id="L699">				ValidationResult hardValResult = validateShiftBidderAndUpdate(givenBidder,</span>
<span class="nc" id="L700">						bidderIDTobidderFromDBMap.get(givenBidder.getID()), RequestUtil.ACTION_UPDATE, sbAuction, null,</span>
						terminatedEmployeeIDs);

<span class="nc bnc" id="L703" title="All 2 branches missed.">				if (hardValResult != null) {</span>
<span class="nc" id="L704">					LOG.debug(hardValResult.getLocalizedMessage(RequestUtil.getLocalizerForAppDefLocale(), TimeZone.getDefault()));</span>
<span class="nc" id="L705">					givenBiddersIter.remove();</span>
				}
<span class="nc" id="L707">			}</span>

<span class="nc" id="L709">			LOG.debug(&quot;Updating shift bidders: size = &quot; + givenBidders.size());</span>
<span class="nc" id="L710">			bidderDAO.updateShiftBidders(givenBidders);</span>
		} finally {
<span class="nc bnc" id="L712" title="All 8 branches missed.">			if (bidderDAONeedsCreate &amp;&amp; bidderDAO != null) {</span>
<span class="nc" id="L713">				bidderDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L715" title="All 8 branches missed.">			if (sbAuctionDAONeedsCreate &amp;&amp; sbAuctionDAO != null) {</span>
<span class="nc" id="L716">				sbAuctionDAO.cleanUp();</span>
			}
		}
<span class="nc" id="L719">	}</span>

	/**
	 * &lt;li&gt; identify unadded shift bidders and rank them.  Get first bidder in list.
	 * &lt;li&gt; Add first as current bidder.
	 * &lt;li&gt; compute deadline for current bidder to respond by.
	 * &lt;li&gt; update AuctionSerialization table with currentBidder and bidderDeadline.
	 * &lt;li&gt; update current bidder's status to 'added'
	 * &lt;li&gt; Notify current bidder.
	 *
	 * @param serAucDAO optional.  If not specifid, then a DAO is created for internal use.  If not, passed
	 *   DAO reused.
	 * @param serAuc optional.  If specified, object reused internally.  If not, then object loaded from DB.
	 * @return 'null' if no bidders were added (ie all eligible bidders have been added alread).
	 * the added shift bidder if otherwise.
	 * @throws Exception
	 */
	public static ShiftBidder addNextBidderToSerAucUpdateAndNotify(SerializedAuction serAuc, SerializedAuctionDAO serAucDAO,
			ShiftBidderDAO shiftBidderDAO) throws Exception {
<span class="nc bnc" id="L738" title="All 2 branches missed.">		boolean serAucDaoCreateNeeded = (serAucDAO == null);</span>
<span class="nc bnc" id="L739" title="All 2 branches missed.">		boolean shiftBidderDAOCreateNeeded = (shiftBidderDAO == null);</span>

		try {
<span class="nc bnc" id="L742" title="All 2 branches missed.">			serAucDAO = (serAucDaoCreateNeeded) ? new SerializedAuctionDAO() : serAucDAO;</span>
<span class="nc bnc" id="L743" title="All 2 branches missed.">			shiftBidderDAO = (shiftBidderDAOCreateNeeded) ? new ShiftBidderDAO(ShiftBidder.DL_BASIC) : shiftBidderDAO;</span>

			//            // if serialized auction already exists, fetch from db, and set the serialized auction ID
			//            SerializedAuction serAucFromDB = serAucDAO.getSerializedAuctionForAuctionID(serAuc.getAuctionID());
			//            if (serAucFromDB != null) serAuc.setID(serAucFromDB.getID());

			// set &quot;isEnabled&quot; = true in AuctionSerailization table.
<span class="nc" id="L750">			serAuc.setIsEnabled(true);</span>

			// get sorted list of bidders for serialized auction (sorted by given criteria)
<span class="nc" id="L753">			ID serAucID = serAuc.getAuctionID();</span>
<span class="nc" id="L754">			List sortedBiddersList = getSortedBiddersForSerAuction(serAucID, serAuc.getRankingMethod(), shiftBidderDAO);</span>
<span class="nc bnc" id="L755" title="All 2 branches missed.">			if (sortedBiddersList == null) {</span>
<span class="nc" id="L756">				LOG.debug(&quot;No bidder found (All bidders already added) for adding to the serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L757">				return null;</span>
			}

			// choose the first **valid** top ranked bidder (start with the end of the list to find bidders with highest rank)
<span class="nc" id="L761">			Date currDate = new Date();</span>
<span class="nc" id="L762">			Date nextBidderAdditionDeadline = null;</span>
<span class="nc" id="L763">			ShiftBidder topBidder = null;</span>
<span class="nc" id="L764">			List topBidderSingletonList = new ArrayList(1);</span>
<span class="nc" id="L765">			int i = 0;</span>
<span class="nc bnc" id="L766" title="All 2 branches missed.">			for (i = (sortedBiddersList.size() - 1); i &gt;= 0; i--) {</span>
				// TODO: tie breaker must be used if multiple bidders are tied for the first spot.
				// Note: top ranked bidder is the last in the list and not the first.
<span class="nc" id="L769">				topBidder = (ShiftBidder) sortedBiddersList.get(i);</span>

				// get time after which the next eligible bidder will be added to the serialized auction.
<span class="nc" id="L772">				nextBidderAdditionDeadline = getBidderDeadlineForSerAuction(topBidder, currDate, serAuc.getBidderTimelimit());</span>

				// if the deadline can't computed (most likely reason: no org hoo assignment for employee's org).
<span class="nc bnc" id="L775" title="All 2 branches missed.">				if (nextBidderAdditionDeadline == null) {</span>
<span class="nc" id="L776">					continue;</span>
				}

				// update status to added.
<span class="nc" id="L780">				topBidder.getSetters().setStatus(ShiftBidder.STATUS_ADDED);</span>
<span class="nc" id="L781">				topBidder.setDeadlineDate(nextBidderAdditionDeadline);</span>

				// update shiftBidder in DB (status was changed to 'added')
<span class="nc" id="L784">				topBidderSingletonList.add(topBidder);</span>
<span class="nc" id="L785">				ShiftBidAuctionUtil.validateShiftBiddersForUpdateActionAndUpdate(serAucID, topBidderSingletonList, null, shiftBidderDAO);</span>

				// if bidder passed validation.
<span class="nc bnc" id="L788" title="All 2 branches missed.">				if (!topBidderSingletonList.isEmpty()) {</span>
<span class="nc" id="L789">					LOG.debug(&quot;Added bidder ID &quot; + topBidder.getID() + &quot; to auction ID &quot; + serAucID);</span>
<span class="nc" id="L790">					break;</span>
				}

				// validation failed for bidder.  bidder was not updated in the DB.
<span class="nc" id="L794">				LOG.debug(&quot;Bidder ID &quot; + topBidder.getID() + &quot; not added to auction ID &quot; + serAucID + &quot; due to bidder validation error&quot;);</span>
				// look for the next bidder.
			}
			// if no valid bidders were found
<span class="nc bnc" id="L798" title="All 2 branches missed.">			if (i &lt; 0) {</span>
<span class="nc" id="L799">				LOG.debug(&quot;No valid bidders (from eligible bidders) found for adding to the serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L800">				return null;</span>
			}

			// update serialized auction attributes.
<span class="nc" id="L804">			serAuc.setCurrentBidderDeadline(nextBidderAdditionDeadline);</span>
<span class="nc" id="L805">			serAuc.setCurrentBidderID(topBidder.getID());</span>

			// if first time auction is serialized, create AuctionSerialization record in db.
<span class="nc bnc" id="L808" title="All 2 branches missed.">			if (serAuc.getID() == null) {</span>
<span class="nc" id="L809">				LOG.debug(&quot;Creating serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L810">				serAucDAO.createSerializedAuction(serAuc);</span>
			} else { // if auction was serialized earlier, update the existing record in db.
<span class="nc" id="L812">				LOG.debug(&quot;updating serialized auction: &quot; + serAuc);</span>
<span class="nc" id="L813">				serAucDAO.updateSerializedAuction(serAuc);</span>
			}

			// send notification
<span class="nc" id="L817">			ShiftBidAuction sbAuction = _getAuctionByID(serAucID, ShiftBidAuction.DL_BASIC);</span>
<span class="nc" id="L818">			fireSerAuctionNotification(serAuc, topBidder, sbAuction);</span>

<span class="nc" id="L820">			return topBidder;</span>
		} finally {
<span class="nc bnc" id="L822" title="All 16 branches missed.">			if (serAucDaoCreateNeeded &amp;&amp; serAucDAO != null) {</span>
<span class="nc" id="L823">				serAucDAO.cleanUp();</span>
			}
<span class="nc bnc" id="L825" title="All 16 branches missed.">			if (shiftBidderDAOCreateNeeded &amp;&amp; shiftBidderDAO != null) {</span>
<span class="nc" id="L826">				shiftBidderDAO.cleanUp();</span>
			}
		}
	}

	public static ShiftBidAuction _getAuctionByID(ID auctionID, long detailLevel) throws Exception {

<span class="nc bnc" id="L833" title="All 2 branches missed.">		if (auctionID == null) {</span>
<span class="nc" id="L834">			return null;</span>
		}

<span class="nc bnc" id="L837" title="All 2 branches missed.">		if (!ThreadLocalCache.isEnabled()) {</span>
<span class="nc" id="L838">			return getAuctionByIDFromDb(auctionID, detailLevel);</span>
		}
<span class="nc" id="L840">		String key = String.format(&quot;%s-%d&quot;, auctionID, detailLevel);</span>
<span class="nc" id="L841">		Map&lt;String, ShiftBidAuction&gt; cache = ThreadLocalCache.getMap(&quot;ShiftBidAuctionUtil._getAuctionByID&quot;);</span>
<span class="nc bnc" id="L842" title="All 2 branches missed.">		if (cache.containsKey(key)) {</span>
<span class="nc" id="L843">			return cache.get(key);</span>
		}

<span class="nc" id="L846">		ShiftBidAuction result = getAuctionByIDFromDb(auctionID, detailLevel);</span>
<span class="nc" id="L847">		cache.put(key, result);</span>
<span class="nc" id="L848">		return result;</span>

	}

	private static ShiftBidAuction getAuctionByIDFromDb(ID auctionID, long detailLevel) throws Exception {
<span class="nc" id="L853">		ShiftBidAuctionDAO auctionDao = new ShiftBidAuctionDAO(detailLevel);</span>
		try {
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L856">			Collection&lt;ShiftBidAuction&gt; auctions = auctionDao.getAuctionsByIDs(Collections.singletonList(auctionID), detailLevel);</span>

<span class="nc bnc" id="L858" title="All 2 branches missed.">			if (auctions.isEmpty()) {</span>
<span class="nc" id="L859">				throw RequestUtil.createRmException(RmEjbLogBundleKey.AUC_NOT_FOUND,</span>
						auctionID, LOG);
			}

<span class="nc" id="L863">			return auctions.iterator().next();</span>
		} finally {
<span class="nc" id="L865">			auctionDao.cleanUp();</span>
		}
	}

	/**
	 * This method should not throw any exceptions to ensure that the current transaction
	 * is not aborted because notification failed.
	 *
	 * @param serAuc
	 */
	private static void fireSerAuctionNotification(SerializedAuction serAuc, ShiftBidder nextBidder, ShiftBidAuction sbAuction) {
<span class="nc" id="L876">		LOG.debug(&quot;fireSerAuctionNotification: Sending JMS message to Notification subsystem&quot;);</span>

<span class="nc" id="L878">		SerializedAuctionDetail serAucDetail = new SerializedAuctionDetail();</span>
<span class="nc" id="L879">		serAucDetail.setAuctionID(serAuc.getID());</span>
<span class="nc" id="L880">		serAucDetail.setAuctionName(sbAuction.getName());</span>
<span class="nc" id="L881">		serAucDetail.setNextEmployeeBidDeadline(serAuc.getCurrentBidderDeadline());</span>
<span class="nc" id="L882">		serAucDetail.setNextEmployeeID(nextBidder.getEmployeeID());</span>
<span class="nc" id="L883">		serAucDetail.setNextShiftBidderID(serAuc.getCurrentBidderID());</span>

<span class="nc" id="L885">		JMSNotifyUtil.notifyOnUserAction(serAucDetail);</span>
<span class="nc" id="L886">	}</span>

	public static Collection&lt;SkillAssignment&gt; getSkillAssnsForBidder(ShiftBidRequest sbReq) throws BbmEJBCreateException,
			BbmFinderException, RemoteException {

<span class="nc" id="L891">		ShiftBidAuction sbAuction = sbReq.getOptMethods().getShiftBidAuction();</span>
<span class="nc" id="L892">		SkillManager skillMgr = WfmManagerFactory.getSkillManager();</span>

		// obtain shift bidder's skills
<span class="nc" id="L895">		Collection&lt;SkillAssignment&gt; skillAssnsForBidder = skillMgr.getSkillAssignments(sbReq.getEmployeeID(), sbAuction.getStartTime(),</span>
<span class="nc" id="L896">				sbAuction.getEndTime());</span>

<span class="nc bnc" id="L898" title="All 2 branches missed.">		if (skillAssnsForBidder == null) {</span>
<span class="nc" id="L899">			Collections.emptyList();</span>
		}

<span class="nc" id="L902">		return skillAssnsForBidder;</span>
	}

	@SuppressWarnings(&quot;unchecked&quot;)
	public static Set&lt;ID&gt; getActiveSkillsForBidder(ShiftBidRequest request) throws Exception {
<span class="nc" id="L907">		Collection&lt;SkillAssignment&gt; skillAssnsForBidder = ShiftBidAuctionUtil.getSkillAssnsForBidder(request);</span>

		// get 'not-deleted' skillIDs for bidder.              
		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L911">		Collection&lt;ID&gt; skillIDsForBidder = RequestUtil.getListOfFieldValuesFromVOBases(skillAssnsForBidder,</span>
				SkillAssignmentFieldInfo.SKILLASSIGNMENT_SKILLID);

<span class="nc" id="L914">		return new HashSet&lt;ID&gt;(WfmCacheUtil.getSkillIDsNotDeleted(skillIDsForBidder));</span>

	}

	public static List getSkillAssignsForPhanID(ID phantomID, ScheduleAccessManager sam)
			throws BbmObjectNotFoundException, BbmFinderException, RemoteException {
<span class="nc" id="L920">		Phantom phantom = sam.getPhantomByID(phantomID);</span>
		// get employee template id associated with phantom.
<span class="nc" id="L922">		ID empTemplateID = phantom.getEmployeeTemplateID();</span>
		// get employee template for phantom.
<span class="nc" id="L924">		EmployeeTemplate empTemplate = sam.getEmployeeTemplateByID(empTemplateID);</span>
		// fetch the skills for the phantom assoc with the bidSchedInst.  These BidSchedInstances may have different
		// phantoms but each phantom has the same skill assignments.
<span class="nc" id="L927">		List skillAssnsForPhantom = empTemplate.getSkillAssignments();</span>
<span class="nc bnc" id="L928" title="All 2 branches missed.">		skillAssnsForPhantom = (skillAssnsForPhantom == null) ? Collections.emptyList() : skillAssnsForPhantom;</span>

<span class="nc" id="L930">		return skillAssnsForPhantom;</span>
	}

	public static int calculateShiftBidderMinimumNumberOfBidsForEmployee(ShiftBidAuction auction, ID employeeID) {
		try {
<span class="nc" id="L935">			ShiftBidAuctionManager sbAuctionMgr = RequestUtil.getShiftBidAuctionMgr(null, null);</span>
<span class="nc" id="L936">			ShiftBidder shiftBidder = sbAuctionMgr.getShiftBidderForEmpID(employeeID, auction.getID(), ShiftBidder.DL_BASIC);</span>
<span class="nc" id="L937">			return ShiftBidAuctionUtil.calculateShiftBidderMinimumNumberOfBidsForBidder(auction, shiftBidder.getID());</span>
<span class="nc" id="L938">		} catch (Exception e) {</span>
<span class="nc" id="L939">			RmUtil.logException(e);</span>
<span class="nc" id="L940">			throw RmRuntimeException.toRuntimeException(e);</span>
		}
	}

	// For AdvancedRM License, for multi-bid submissions, minimum number of bid
	// calculation is always equal to the employee's Bid Approval Order By Rank
	// plus the auction's number of bid submissions.
	private static int calculateShiftBidderMinimumNumberOfBidsForBidder(ShiftBidAuction auction, ID bidderID) {
		try {
<span class="nc" id="L949">			Pair&lt;Integer, Integer&gt; bidApprovalOrderPair = getShiftBidderApprovalOrder(auction.getID(), bidderID,</span>
					ShiftBidder.RANKBY_EMPLOYEERANK);
<span class="nc" id="L951">			Integer approvalOrder = bidApprovalOrderPair.getFirst();</span>
<span class="nc" id="L952">			return approvalOrder + auction.getNumOfBidSubmissions();</span>
<span class="nc" id="L953">		} catch (Exception e) {</span>
<span class="nc" id="L954">			RmUtil.logException(e);</span>
<span class="nc" id="L955">			throw RmRuntimeException.toRuntimeException(e);</span>
		}
	}

	/*
	 *  Returns the ranking of of the given shift bidder in the given auction as x/y
	 *  The sort order is specified by sortBy and is one of the ShiftBidder.RANKBY_ constants
	 */
	public static Pair&lt;Integer, Integer&gt; getShiftBidderApprovalOrder(final ID auctionID, final ID shiftBidderID, final int sortBy) {
<span class="nc" id="L964">		ShiftBidderDAO bidderDAO = new ShiftBidderDAO(ShiftBidder.DL_BASIC);</span>
		try {
<span class="nc" id="L966">			return bidderDAO.getShiftBidderApprovalOrder(auctionID, shiftBidderID, sortBy);</span>
<span class="nc" id="L967">		} catch (Exception e) {</span>
<span class="nc" id="L968">			throw RmRuntimeException.toRuntimeException(e);</span>
		} finally {
<span class="nc" id="L970">			bidderDAO.cleanUp();</span>
		}
	}

	/**
	 * Usually all the scheduled employees with SP are marked as scheduled/unavailable
	 * With the new setting to allow previously scheduled employees, we need to
	 * verify that setting is checked or not and filter employees based on this setting
	 */
	public static Collection&lt;ID&gt; getUnavailableEmpIdsForAuction(Collection empIDs, ShiftBidAuction auction, ShiftBidderDAO bidderDAO)
			throws Exception {
		Collection&lt;ID&gt; unavailableEmpIDs;
<span class="nc bnc" id="L982" title="All 2 branches missed.">		if (!auction.getIncPrevSchedEmp()) {</span>
			// unavailable employees are employees who have shifts for the SP this auction is for.
<span class="nc" id="L984">			unavailableEmpIDs = bidderDAO.getNumOfShiftsDuringAuctionForEmps(empIDs, auction.getStartTime(), auction.getEndTime()).keySet();</span>
		} else {
			// unavailable employees are employees who have at least one approved shift bidding request in this auction
<span class="nc" id="L987">			unavailableEmpIDs = bidderDAO.getEmployeeIDsByAuctionAndRequestStatus(Collections.singleton(auction.getID()), new String[] {</span>
					RequestAuditTrail.STATUS_APPROVED });
		}
<span class="nc" id="L990">		return unavailableEmpIDs;</span>
	}

	/**
	 * 15.1.0 bug fix for QC183653 changed MD5 calc. Migration will create key in BPCONFIG with highest auction id.
	 *
	 * @param auctionId
	 * @return is using new md5 calculation
	 * @throws Exception
	 */
	public static boolean isNewMd5(ID auctionId) throws Exception {
<span class="nc" id="L1001">		DBConfigManager m_dbConfigManager = BbmManagerFactory.getDBConfigManager();</span>
<span class="nc" id="L1002">		int oldAuctionID = m_dbConfigManager.getIntValue(WFM_MIGRATION_15_1_0_135_MAX_AUCTION_ID);</span>
<span class="nc bnc" id="L1003" title="All 4 branches missed.">		return (oldAuctionID == ConfigManager.NOVALUE || auctionId.toInt() &gt; oldAuctionID);</span>
	}

	/**
	 * Converts a int value into an ID Type
	 * 
	 * @param value Value to convert to an ID Type
	 * @return ID of the value passed; if the value passed is zero, null is return.
	 */
	public static ID getIDFromValue(int value) {
<span class="nc" id="L1013">		ID id = null;</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">		if (value != 0) {</span>
<span class="nc" id="L1015">			id = new ID(value);</span>
		}
<span class="nc" id="L1017">		return id;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>