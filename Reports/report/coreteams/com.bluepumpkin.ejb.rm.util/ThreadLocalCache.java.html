<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ThreadLocalCache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">QA Code Coverage</a> &gt; <a href="index.source.html" class="el_package">com.bluepumpkin.ejb.rm.util</a> &gt; <span class="el_source">ThreadLocalCache.java</span></div><h1>ThreadLocalCache.java</h1><pre class="source lang-java linenums">package com.bluepumpkin.ejb.rm.util;

import java.util.HashMap;
import java.util.Map;

import com.bluepumpkin.ejb.rm.base.RmRuntimeException;

/**
 * A thread specific cache similar to ThreadLocalForCacheManagerHelper/CacheManager 
 * To enable caching for a thread  call ThreadLocalCache.enable at a function near the root of the processing 
 * At the function which needs to cache its return, call ThreadLocalCache.getMap with a unique key to return a map. 
 * This map can be used to cache the function result by the function inputs.  
 * 
 * Note that the cache is enabled while group approving requests. This means that if you cache anything that approving a request would 
 * invalidate, it is up to the client to remove or update the stale item. 
 * 
 * &lt;pre&gt;
 * for example:
 * {@code
 * 
 * 	void root(){
 * 		boolean cacheEnabled = false;
 *		try{
 *			cacheEnabled = ThreadLocalCache.enable();
 *   		calcFunc(100);
 *   	}
 *   	finally{
 *   		ThreadLocalCache.clear(cacheEnabled);
 *   	}
 * 	}
 * 
 * 	int caclFunc(int input){
 * 		//No need to check for null. getMap will return a do nothing map if the cache is not enabled
 * 		Map&lt;Integer,Integer&gt; cache = ThreadLocalCache.getMap(&quot;MyClass.calcFunc&quot;);
 * 
 * 		if( cache.containsKey(input) ){
 * 			return cache.get(input);
 * 		}	
 * 		
 * 		int result = do_some_calculation(input);
 * 
 * 		cache.put(input,result);
 * 		
 * 		return result;
 *  }
 * 
 *} 
 * &lt;/pre&gt;
 * 
 *
 */
public class ThreadLocalCache {

<span class="nc" id="L54">	private static final ThreadLocal&lt;Map&lt;String, Object&gt;&gt; cache = new ThreadLocal&lt;Map&lt;String, Object&gt;&gt;();</span>

<span class="nc" id="L56">	private ThreadLocalCache() {</span>

<span class="nc" id="L58">	}</span>

	/**
	 * Enable the cache for the calling thread
	 * @return 
	 * 	 True  	If the cache was enabled by this call. This means that the caller is responsible for calling clear 
	 *   False 	If the cache was already enabled by a function down the call stack. 
	 *			This means that the caller is not responsible for calling clear
	 */
	public static boolean enable() {

<span class="nc" id="L69">		Map&lt;String, Object&gt; map = cache.get();</span>
<span class="nc bnc" id="L70" title="All 2 branches missed.">		if (map == null) {</span>
<span class="nc" id="L71">			cache.set(new HashMap&lt;String, Object&gt;());</span>
<span class="nc" id="L72">			return true;</span>
		}
<span class="nc" id="L74">		return false;</span>
	}

	public static boolean isEnabled() {
<span class="nc" id="L78">		Map&lt;String, Object&gt; map = cache.get();</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">		return map != null;</span>

	}

	/**
	 * @return 
	 * The thread local map for the specified key. 
	 * If the key does not exists and the cache is enabled then an empty map is created for the key and returned. 
	 * If cache is not enabled then a NoOperationMap (a map that does nothing) is returned.
	 * Clients should not count on any object remaining in the returned map.
	 * Even putting and getting immediately is not guaranteed to work (if the cache is disabled a NoOperationMap which ignore call to put) 
	 */
	public static &lt;K, V&gt; Map&lt;K, V&gt; getMap(String key) {

<span class="nc" id="L93">		checkKey(key);</span>

<span class="nc" id="L95">		Map&lt;String, Object&gt; map = cache.get();</span>
<span class="nc bnc" id="L96" title="All 2 branches missed.">		if (map == null) {</span>
<span class="nc" id="L97">			return NoOperationMap.getNoOperationMap();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L101">		Map&lt;K, V&gt; cachedMap = (Map&lt;K, V&gt;) map.get(key);</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">		if (cachedMap != null) {</span>
<span class="nc" id="L103">			return cachedMap;</span>
		}

<span class="nc" id="L106">		cachedMap = new HashMap&lt;K, V&gt;();</span>

<span class="nc" id="L108">		map.put(key, cachedMap);</span>
<span class="nc" id="L109">		return cachedMap;</span>
	}

	public static &lt;T&gt; T get(Class&lt;T&gt; clazz, Factory&lt;T&gt; factory) {
<span class="nc" id="L113">		return get(clazz.getName(), factory);</span>
	}

	public static &lt;T&gt; T get(String key, Factory&lt;T&gt; factory) {

<span class="nc" id="L118">		checkKey(key);</span>

<span class="nc" id="L120">		Map&lt;String, Object&gt; map = cache.get();</span>
<span class="nc bnc" id="L121" title="All 2 branches missed.">		if (map == null) {</span>
<span class="nc" id="L122">			return factory.create();</span>
		}

		@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L126">		T object = (T) map.get(key);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">		if (object != null) {</span>
<span class="nc" id="L128">			return object;</span>
		}

<span class="nc" id="L131">		object = factory.create();</span>
<span class="nc" id="L132">		map.put(key, object);</span>
<span class="nc" id="L133">		return object;</span>
	}

	public static &lt;T&gt; T get(Class&lt;T&gt; clazz) {
<span class="nc" id="L137">		return get(clazz.getName(), clazz);</span>
	}

	public static &lt;T&gt; T get(String key, Class&lt;T&gt; clazz) {

		try {

<span class="nc" id="L144">			checkKey(key);</span>

<span class="nc" id="L146">			Map&lt;String, Object&gt; map = cache.get();</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">			if (map == null) {</span>
<span class="nc" id="L148">				return clazz.newInstance();</span>
			}

			@SuppressWarnings(&quot;unchecked&quot;)
<span class="nc" id="L152">			T object = (T) map.get(key);</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">			if (object != null) {</span>
<span class="nc" id="L154">				return object;</span>
			}

<span class="nc" id="L157">			object = clazz.newInstance();</span>
<span class="nc" id="L158">			map.put(key, object);</span>
<span class="nc" id="L159">			return object;</span>
<span class="nc" id="L160">		} catch (Exception e) {</span>
<span class="nc" id="L161">			throw new RmRuntimeException(e);</span>
		}
	}

	private static void checkKey(String key) {
<span class="nc bnc" id="L166" title="All 4 branches missed.">		if (key == null || key.isEmpty()) {</span>
<span class="nc" id="L167">			throw new IllegalArgumentException(&quot;The key to ThreadLocal cannot be null or empty&quot;);</span>
		}
<span class="nc" id="L169">	}</span>

	/**
	 * clear the cache associated with this thread
	 */
	public static void clear(boolean clear) {
<span class="nc bnc" id="L175" title="All 2 branches missed.">		if (!clear) {</span>
<span class="nc" id="L176">			return;</span>
		}
<span class="nc" id="L178">		cache.set(null);</span>
<span class="nc" id="L179">	}</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.5.201505241946</span></div></body></html>